Swift::String_optional __swiftcall Unicode.Scalar.Properties._fastScalarName()()
{
  unsigned int *v0;
  unsigned int v1;
  Swift::String v2;
  unint64_t object;
  uint64_t v4;
  int32x4_t v5;
  uint64_t countAndFlagsBits;
  void *v7;
  Swift::String v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char v34;
  unint64_t v35;
  Swift::String v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  unint64_t v44;
  unint64_t v45;
  char v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  char v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  void *v61;
  char v62;
  unint64_t v63;
  void *v64;
  uint64_t v65;
  unint64_t v66;
  void *v67;
  char v68;
  uint64_t v69;
  void *v70;
  const char *v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  void *v82;
  char v83;
  unint64_t v84;
  void *v85;
  uint64_t v86;
  Swift::String_optional result;
  Swift::String v88;
  v1 = *v0;
  v2 = _uint64ToString(_:radix:uppercase:)(*v0, 16LL, 1);
  object = (unint64_t)v2._object;
  if (v1 - 55204 >= 0xFFFFD45C)
  {
    swift_bridgeObjectRelease((uint64_t)v2._object);
    v8 = Unicode.Scalar.Properties._hangulName()();
    countAndFlagsBits = v8._countAndFlagsBits;
    v7 = v8._object;
    goto LABEL_118;
  }

  if (v1 - 918000 >= 0xFFFFFF10)
  {
    swift_bridgeObjectRelease((uint64_t)v2._object);
    v9 = specialized static String._createEmpty(withInitialCapacity:)(21LL);
    v11 = v10;
    v88._countAndFlagsBits = v9;
    v88._object = (void *)v10;
    v12 = HIBYTE(v10) & 0xF;
    if ((v10 & 0x2000000000000000LL) == 0) {
      v12 = v9 & 0xFFFFFFFFFFFFLL;
    }
    if (v12 || (v9 & ~v10 & 0x2000000000000000LL) != 0)
    {
      if ((v10 & 0x2000000000000000LL) == 0
        || (0x80000001818BAF90LL & 0x2000000000000000LL) == 0
        || (v13 = specialized _SmallString.init(_:appending:)( v9,  v10,  0xD000000000000013LL,  0x80000001818BAF90LL | 0x8000000000000000LL),  (v15 & 1) != 0))
      {
        if ((0x80000001818BAF90LL & 0x2000000000000000LL) != 0) {
          v18 = (0x80000001818BAF90LL >> 56) & 0xF;
        }
        else {
          v18 = 19LL;
        }
        _StringGuts.append(_:)(0xD000000000000013LL, 0x80000001818BAF90LL | 0x8000000000000000LL, 0LL, v18);
        swift_bridgeObjectRelease(0x80000001818BAF90LL | 0x8000000000000000LL);
        v17 = (unint64_t)v88._object;
        v16 = v88._countAndFlagsBits;
LABEL_53:
        v36 = _uint64ToString(_:radix:uppercase:)(v1 - 917743, 10LL, 0);
        v4 = v36._countAndFlagsBits;
        object = (unint64_t)v36._object;
        v37 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000LL) == 0) {
          v37 = v16 & 0xFFFFFFFFFFFFLL;
        }
        if (v37 || (v16 & ~v17 & 0x2000000000000000LL) != 0)
        {
          if ((v17 & 0x2000000000000000LL) == 0) {
            goto LABEL_99;
          }
          v38 = v16;
          goto LABEL_105;
        }

        goto LABEL_103;
      }

      v16 = v13;
      v17 = v14;
      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(0x80000001818BAF90LL | 0x8000000000000000LL);
    }

    else
    {
      swift_bridgeObjectRelease(v10);
      v16 = 0xD000000000000013LL;
      v17 = 0x80000001818BAF90LL | 0x8000000000000000LL;
    }

    v88._countAndFlagsBits = v16;
    v88._object = (void *)v17;
    goto LABEL_53;
  }

  v4 = v2._countAndFlagsBits;
  v5 = vdupq_n_s32(v1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v5, (int32x4_t)xmmword_1817FFF00),  (uint32x4_t)xmmword_1817FFF20),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v5, (int32x4_t)xmmword_1817FFF10),  (uint32x4_t)xmmword_1817FFF30)))) & 1) != 0 || v1 - 205744 >= 0xFFFFEFA0)
  {
    v19 = specialized static String._createEmpty(withInitialCapacity:)(24LL);
    v21 = v20;
    v88._countAndFlagsBits = v19;
    v88._object = (void *)v20;
    v22 = HIBYTE(v20) & 0xF;
    if ((v20 & 0x2000000000000000LL) == 0) {
      v22 = v19 & 0xFFFFFFFFFFFFLL;
    }
    if (v22 || (v19 & ~v20 & 0x2000000000000000LL) != 0)
    {
      if ((v20 & 0x2000000000000000LL) == 0
        || (0x80000001818BAFB0LL & 0x2000000000000000LL) == 0
        || (v23 = specialized _SmallString.init(_:appending:)( v19,  v20,  0xD000000000000016LL,  0x80000001818BAFB0LL | 0x8000000000000000LL),  (v25 & 1) != 0))
      {
        if ((0x80000001818BAFB0LL & 0x2000000000000000LL) != 0) {
          v27 = (0x80000001818BAFB0LL >> 56) & 0xF;
        }
        else {
          v27 = 22LL;
        }
        _StringGuts.append(_:)(0xD000000000000016LL, 0x80000001818BAFB0LL | 0x8000000000000000LL, 0LL, v27);
        swift_bridgeObjectRelease(0x80000001818BAFB0LL | 0x8000000000000000LL);
        v17 = (unint64_t)v88._object;
        v26 = v88._countAndFlagsBits;
LABEL_73:
        v50 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000LL) == 0) {
          v50 = v26 & 0xFFFFFFFFFFFFLL;
        }
        if (v50 || (v26 & ~v17 & 0x2000000000000000LL) != 0) {
          goto LABEL_98;
        }
        goto LABEL_103;
      }

      v26 = v23;
      v17 = v24;
      swift_bridgeObjectRelease(v21);
      swift_bridgeObjectRelease(0x80000001818BAFB0LL | 0x8000000000000000LL);
    }

    else
    {
      swift_bridgeObjectRelease(v20);
      v26 = 0xD000000000000016LL;
      v17 = 0x80000001818BAFB0LL | 0x8000000000000000LL;
    }

    v88._countAndFlagsBits = v26;
    v88._object = (void *)v17;
    goto LABEL_73;
  }

  if (v1 - 64110 > 0xFFFFFE91 || v1 - 64218 > 0xFFFFFF95 || v1 - 195102 >= 0xFFFFFDE2)
  {
    v28 = specialized static String._createEmpty(withInitialCapacity:)(30LL);
    v30 = v29;
    v88._countAndFlagsBits = v28;
    v88._object = (void *)v29;
    v31 = HIBYTE(v29) & 0xF;
    if ((v29 & 0x2000000000000000LL) == 0) {
      v31 = v28 & 0xFFFFFFFFFFFFLL;
    }
    if (v31 || (v28 & ~v29 & 0x2000000000000000LL) != 0)
    {
      if ((v29 & 0x2000000000000000LL) == 0
        || (0x80000001818BAFD0LL & 0x2000000000000000LL) == 0
        || (v32 = specialized _SmallString.init(_:appending:)( v28,  v29,  0xD00000000000001CLL,  0x80000001818BAFD0LL | 0x8000000000000000LL),  (v34 & 1) != 0))
      {
        if ((0x80000001818BAFD0LL & 0x2000000000000000LL) != 0) {
          v35 = (0x80000001818BAFD0LL >> 56) & 0xF;
        }
        else {
          v35 = 28LL;
        }
        _StringGuts.append(_:)(0xD00000000000001CLL, 0x80000001818BAFD0LL | 0x8000000000000000LL, 0LL, v35);
        swift_bridgeObjectRelease(0x80000001818BAFD0LL | 0x8000000000000000LL);
        v17 = (unint64_t)v88._object;
        v26 = v88._countAndFlagsBits;
LABEL_94:
        v58 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000LL) == 0) {
          v58 = v26 & 0xFFFFFFFFFFFFLL;
        }
        if (v58 || (v26 & ~v17 & 0x2000000000000000LL) != 0)
        {
LABEL_98:
          if ((v17 & 0x2000000000000000LL) == 0)
          {
LABEL_99:
            if ((object & 0x2000000000000000LL) != 0)
            {
LABEL_107:
              v59 = HIBYTE(object) & 0xF;
              goto LABEL_108;
            }

uint64_t Unicode.Scalar.Properties.name.getter()
{
  unsigned int v1 = *v0;
  Swift::String_optional v3 = Unicode.Scalar.Properties._fastScalarName()();
  uint64_t result = v3.value._countAndFlagsBits;
  if (!v3.value._object)
  {
    uint64_t result = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(88LL, v1);
    uint64_t v5 = HIBYTE(v4) & 0xF;
    if ((v4 & 0x2000000000000000LL) == 0) {
      uint64_t v5 = result & 0xFFFFFFFFFFFFLL;
    }
    if (!v5)
    {
      swift_bridgeObjectRelease(v4);
      return 0LL;
    }
  }

  return result;
}

char *Unicode.Scalar.Properties.nameAlias.getter()
{
  uint64_t result = _swift_stdlib_getNameAlias(*v0);
  if (result)
  {
    v2 = (uint64_t *)result;
    size_t v3 = _swift_stdlib_strlen(result);
    if ((v3 & 0x8000000000000000LL) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    return (char *)_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n( v2,  v3);
  }

  return result;
}

Swift::Unicode::CanonicalCombiningClass __swiftcall Unicode.CanonicalCombiningClass.init(rawValue:)( Swift::Unicode::CanonicalCombiningClass rawValue)
{
  v1->rawValue = rawValue.rawValue;
  return rawValue;
}

void static Unicode.CanonicalCombiningClass.notReordered.getter(_BYTE *a1@<X8>)
{
  *a1 = 0;
}

void static Unicode.CanonicalCombiningClass.overlay.getter(_BYTE *a1@<X8>)
{
  *a1 = 1;
}

void static Unicode.CanonicalCombiningClass.nukta.getter(_BYTE *a1@<X8>)
{
  *a1 = 7;
}

void static Unicode.CanonicalCombiningClass.kanaVoicing.getter(_BYTE *a1@<X8>)
{
  *a1 = 8;
}

void static Unicode.CanonicalCombiningClass.virama.getter(_BYTE *a1@<X8>)
{
  *a1 = 9;
}

void static Unicode.CanonicalCombiningClass.attachedBelowLeft.getter(_BYTE *a1@<X8>)
{
  *a1 = -56;
}

void static Unicode.CanonicalCombiningClass.attachedBelow.getter(_BYTE *a1@<X8>)
{
  *a1 = -54;
}

void static Unicode.CanonicalCombiningClass.attachedAbove.getter(_BYTE *a1@<X8>)
{
  *a1 = -42;
}

void static Unicode.CanonicalCombiningClass.attachedAboveRight.getter(_BYTE *a1@<X8>)
{
  *a1 = -40;
}

void static Unicode.CanonicalCombiningClass.belowLeft.getter(_BYTE *a1@<X8>)
{
  *a1 = -38;
}

void static Unicode.CanonicalCombiningClass.below.getter(_BYTE *a1@<X8>)
{
  *a1 = -36;
}

void static Unicode.CanonicalCombiningClass.belowRight.getter(_BYTE *a1@<X8>)
{
  *a1 = -34;
}

void static Unicode.CanonicalCombiningClass.left.getter(_BYTE *a1@<X8>)
{
  *a1 = -32;
}

void static Unicode.CanonicalCombiningClass.right.getter(_BYTE *a1@<X8>)
{
  *a1 = -30;
}

void static Unicode.CanonicalCombiningClass.aboveLeft.getter(_BYTE *a1@<X8>)
{
  *a1 = -28;
}

void static Unicode.CanonicalCombiningClass.above.getter(_BYTE *a1@<X8>)
{
  *a1 = -26;
}

void static Unicode.CanonicalCombiningClass.aboveRight.getter(_BYTE *a1@<X8>)
{
  *a1 = -24;
}

void static Unicode.CanonicalCombiningClass.doubleBelow.getter(_BYTE *a1@<X8>)
{
  *a1 = -23;
}

void static Unicode.CanonicalCombiningClass.doubleAbove.getter(_BYTE *a1@<X8>)
{
  *a1 = -22;
}

void static Unicode.CanonicalCombiningClass.iotaSubscript.getter(_BYTE *a1@<X8>)
{
  *a1 = -16;
}

uint64_t Unicode.CanonicalCombiningClass.rawValue.getter()
{
  return *v0;
}

BOOL static Unicode.CanonicalCombiningClass.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

BOOL static Unicode.CanonicalCombiningClass.< infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

uint64_t Unicode.CanonicalCombiningClass.hashValue.getter()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, *v0, 1LL);
}

uint64_t UInt8.hashValue.getter(unsigned __int8 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, a1, 1LL);
}

void Unicode.CanonicalCombiningClass.hash(into:)()
{
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Unicode.CanonicalCombiningClass( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Unicode.CanonicalCombiningClass( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Unicode.CanonicalCombiningClass( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Unicode.CanonicalCombiningClass( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 < *a1;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Unicode.CanonicalCombiningClass()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, *v0, 1LL);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Unicode.CanonicalCombiningClass()
{
  return Hasher._finalize()();
}

unsigned __int8 *protocol witness for RawRepresentable.init(rawValue:) in conformance Unicode.CanonicalCombiningClass@<X0>( unsigned __int8 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance Unicode.CanonicalCombiningClass( _BYTE *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t Unicode.Scalar.Properties.canonicalCombiningClass.getter@<X0>(_BYTE *a1@<X8>)
{
  uint64_t result = *v1;
  if (result >= 0xC0)
  {
    uint64_t result = _swift_stdlib_getNormData(result);
    unsigned int v4 = result >> 3;
  }

  else
  {
    LOBYTE(v4) = 0;
  }

  *a1 = v4;
  return result;
}

Swift::Unicode::NumericType __swiftcall Unicode.NumericType.init(rawValue:)(Swift::Unicode::NumericType rawValue)
{
  if (rawValue >= Swift_Unicode_NumericType_unknownDefault)
  {
    Swift::Unicode::NumericType v2 = rawValue;
    unint64_t countAndFlagsBits = 0xD000000000000015LL;
    unint64_t v4 = specialized static String._createEmpty(withInitialCapacity:)(23LL);
    uint64_t v6 = v5;
    v29._unint64_t countAndFlagsBits = v4;
    v29._unint64_t object = (void *)v5;
    uint64_t v7 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000LL) == 0) {
      uint64_t v7 = v4 & 0xFFFFFFFFFFFFLL;
    }
    if (v7 || (v4 & ~v5 & 0x2000000000000000LL) != 0)
    {
      if ((v5 & 0x2000000000000000LL) == 0
        || (0x80000001818BAF40LL & 0x2000000000000000LL) == 0
        || (unint64_t v9 = specialized _SmallString.init(_:appending:)( v4,  v5,  0xD000000000000015LL,  0x80000001818BAF40LL | 0x8000000000000000LL),  (v11 & 1) != 0))
      {
        if ((0x80000001818BAF40LL & 0x2000000000000000LL) != 0) {
          unint64_t v12 = (0x80000001818BAF40LL >> 56) & 0xF;
        }
        else {
          unint64_t v12 = 21LL;
        }
        _StringGuts.append(_:)(0xD000000000000015LL, 0x80000001818BAF40LL | 0x8000000000000000LL, 0LL, v12);
        swift_bridgeObjectRelease(0x80000001818BAF40LL | 0x8000000000000000LL);
        unint64_t object = (unint64_t)v29._object;
        unint64_t countAndFlagsBits = v29._countAndFlagsBits;
LABEL_17:
        Swift::String v13 = _uint64ToString(_:radix:uppercase:)(v2, 10LL, 0);
        unint64_t v14 = v13._countAndFlagsBits;
        unint64_t v15 = (unint64_t)v13._object;
        uint64_t v16 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000LL) == 0) {
          uint64_t v16 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        if (!v16 && (countAndFlagsBits & ~object & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(object);
          Swift::String v29 = v13;
          goto LABEL_31;
        }

        if ((object & 0x2000000000000000LL) != 0)
        {
          if (((uint64_t)v13._object & 0x2000000000000000LL) != 0)
          {
            unint64_t v18 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  object,  v13._countAndFlagsBits,  (unint64_t)v13._object);
            if ((v20 & 1) == 0)
            {
              unint64_t v21 = v18;
              v22 = v19;
              swift_bridgeObjectRelease(object);
              swift_bridgeObjectRelease((uint64_t)v13._object);
              v29._unint64_t countAndFlagsBits = v21;
              v29._unint64_t object = v22;
              unint64_t v15 = (unint64_t)v22;
              unint64_t v14 = v21;
              goto LABEL_31;
            }

            goto LABEL_29;
          }
        }

        else if (((uint64_t)v13._object & 0x2000000000000000LL) != 0)
        {
LABEL_29:
          uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
          goto LABEL_30;
        }

        uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_30:
        _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0LL, v17);
        swift_bridgeObjectRelease((uint64_t)v13._object);
        unint64_t v15 = (unint64_t)v29._object;
        unint64_t v14 = v29._countAndFlagsBits;
LABEL_31:
        uint64_t v23 = HIBYTE(v15) & 0xF;
        if ((v15 & 0x2000000000000000LL) == 0) {
          uint64_t v23 = v14 & 0xFFFFFFFFFFFFLL;
        }
        if (v23 || (v14 & ~v15 & 0x2000000000000000LL) != 0)
        {
          if ((v15 & 0x2000000000000000LL) == 0
            || (unint64_t v26 = specialized _SmallString.init(_:appending:)(v14, v15, 0LL, 0xE000000000000000LL), (v28 & 1) != 0))
          {
            _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
            swift_bridgeObjectRelease(0xE000000000000000LL);
            unint64_t v25 = (unint64_t)v29._object;
            v24 = (char *)v29._countAndFlagsBits;
          }

          else
          {
            v24 = (char *)v26;
            unint64_t v25 = v27;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(0xE000000000000000LL);
          }
        }

        else
        {
          swift_bridgeObjectRelease(v15);
          v24 = 0LL;
          unint64_t v25 = 0xE000000000000000LL;
        }

        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v24,  v25,  "Swift/UnicodeScalarProperties.swift",  35LL,  2,  0x5D0uLL,  0);
      }

      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x80000001818BAF40LL | 0x8000000000000000LL);
    }

    else
    {
      swift_bridgeObjectRelease(v5);
      unint64_t object = 0x80000001818BAF40LL | 0x8000000000000000LL;
    }

    v29._unint64_t countAndFlagsBits = countAndFlagsBits;
    v29._unint64_t object = (void *)object;
    goto LABEL_17;
  }

  *unsigned int v1 = 2 - rawValue;
  return rawValue;
}

uint64_t Unicode.Scalar.Properties.numericType.getter@<X0>(char *a1@<X8>)
{
  uint64_t result = _swift_stdlib_getNumericType(*v1);
  if ((_DWORD)result == 255)
  {
    char v4 = 3;
  }

  else
  {
    uint64_t result = Unicode.NumericType.init(rawValue:)(result);
    char v4 = v5;
  }

  *a1 = v4;
  return result;
}

uint64_t Unicode.Scalar.Properties.numericValue.getter()
{
  unsigned int v1 = *v0;
  int NumericType = _swift_stdlib_getNumericType(v1);
  if (NumericType == 255) {
    return 0LL;
  }
  Unicode.NumericType.init(rawValue:)(NumericType);
  return _swift_stdlib_getNumericValue(v1);
}

unint64_t Character._firstScalar.getter(uint64_t a1, unint64_t a2)
{
  unint64_t result = specialized Collection.first.getter(a1, a2);
  if ((result & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  return result;
}

BOOL Character._isSingleScalar.getter(uint64_t a1, unint64_t a2)
{
  v4._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)15LL)._rawBits;
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v4)._rawBits;
  }

  else
  {
    Swift::UInt64 v5 = v4._rawBits >> 16;
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      v13[0] = a1;
      v13[1] = a2 & 0xFFFFFFFFFFFFFFLL;
      int v7 = *((unsigned __int8 *)v13 + v5);
    }

    else
    {
      if ((a1 & 0x1000000000000000LL) != 0) {
        uint64_t v6 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v6 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      }
      int v7 = v6[v5];
    }

    int v8 = (char)v7;
    unsigned int v9 = __clz(v7 ^ 0xFF) - 24;
    if (v8 >= 0) {
      LOBYTE(v9) = 1;
    }
    Swift::UInt64 rawBits = ((v5 + v9) << 16) | 5;
  }

  uint64_t v11 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v11 = a1 & 0xFFFFFFFFFFFFLL;
  }
  return rawBits >> 14 == 4 * v11;
}

BOOL Character.isASCII.getter(uint64_t a1, unint64_t a2)
{
  return (Character.asciiValue.getter(a1, a2) & 0x100) == 0;
}

uint64_t Character.asciiValue.getter(uint64_t a1, unint64_t a2)
{
  if (a1 == 2573 && a2 == 0xE200000000000000LL
    || (~a2 & 0x6000000000000000LL) != 0
    && (_stringCompareInternal(_:_:expecting:)(a1, a2, 2573LL, 0xE200000000000000LL, 0) & 1) != 0)
  {
    int v4 = 0;
    LOBYTE(v5) = 10;
    return v5 | (v4 << 8);
  }

  if (!Character._isSingleScalar.getter(a1, a2)) {
    goto LABEL_12;
  }
  unint64_t v6 = specialized Collection.first.getter(a1, a2);
  if ((v6 & 0x100000000LL) != 0) {
    goto LABEL_15;
  }
  if ((v6 & 0xFFFFFF80) != 0)
  {
LABEL_12:
    LOBYTE(v5) = 0;
    int v4 = 1;
    return v5 | (v4 << 8);
  }

  unint64_t v5 = specialized Collection.first.getter(a1, a2);
  if ((v5 & 0x100000000LL) != 0) {
LABEL_15:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  if ((v5 & 0xFFFFFF00) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  int v4 = 0;
  return v5 | (v4 << 8);
}

unint64_t Character.isWhitespace.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 45) & 1;
}

uint64_t Character.isNewline.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  BOOL v3 = (v2 - 8232) < 2 || v2 == 133;
  return (v2 - 14) >= 0xFFFFFFFC || v3;
}

BOOL Character.isNumber.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  int NumericType = _swift_stdlib_getNumericType(v2);
  int v4 = NumericType;
  if (NumericType != 255) {
    Unicode.NumericType.init(rawValue:)(NumericType);
  }
  return v4 != 255;
}

BOOL Character.isWholeNumber.getter(uint64_t a1, unint64_t a2)
{
  if (!Character._isSingleScalar.getter(a1, a2)) {
    return 0LL;
  }
  unint64_t v4 = specialized Collection.first.getter(a1, a2);
  if ((v4 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  int v5 = v4;
  int NumericType = _swift_stdlib_getNumericType(v4);
  if (NumericType == 255) {
    return 0LL;
  }
  Unicode.NumericType.init(rawValue:)(NumericType);
  double NumericValue = _swift_stdlib_getNumericValue(v5);
  BOOL v8 = NumericValue > -9.22337204e18;
  if (NumericValue >= 9.22337204e18) {
    BOOL v8 = 0;
  }
  return NumericValue == trunc(NumericValue) && v8;
}

uint64_t Character.wholeNumberValue.getter(uint64_t a1, unint64_t a2)
{
  if (!Character._isSingleScalar.getter(a1, a2)) {
    return 0LL;
  }
  unint64_t v4 = specialized Collection.first.getter(a1, a2);
  if ((v4 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  int v5 = v4;
  int NumericType = _swift_stdlib_getNumericType(v4);
  if (NumericType == 255) {
    return 0LL;
  }
  Unicode.NumericType.init(rawValue:)(NumericType);
  double NumericValue = _swift_stdlib_getNumericValue(v5);
  BOOL v8 = NumericValue > -9.22337204e18;
  if (NumericValue >= 9.22337204e18) {
    BOOL v8 = 0;
  }
  if ((v8 & (NumericValue == trunc(NumericValue))) != 0) {
    return (uint64_t)NumericValue;
  }
  else {
    return 0LL;
  }
}

Swift::Int_optional __swiftcall Int.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -9.22337204e18;
  if (exactly >= 9.22337204e18) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (trunc(exactly) == exactly);
  if (v2) {
    Swift::Int v3 = (uint64_t)exactly;
  }
  else {
    Swift::Int v3 = 0LL;
  }
  char v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

BOOL Character.isHexDigit.getter(uint64_t a1, unint64_t a2)
{
  return (v2 & 1) == 0;
}

uint64_t Character.hexDigitValue.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
    }
    if ((v4 - 58) >= 0xFFFFFFF6)
    {
      return (v4 - 48);
    }

    else if ((v4 - 71) >= 0xFFFFFFFA)
    {
      return (v4 - 55);
    }

    else if ((v4 - 103) >= 0xFFFFFFFA)
    {
      return (v4 - 87);
    }

    else
    {
      unsigned int v5 = v4 - 65335;
      else {
        unsigned int v6 = v5;
      }
      else {
        return v6;
      }
    }
  }

  else
  {
    return 0;
  }

unint64_t Character.isLetter.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 7) & 1;
}

uint64_t Character._isUppercased.getter(uint64_t a1, unint64_t a2)
{
  return Character._isUppercased.getter(a1, a2, (uint64_t (*)(void))String.uppercased());
}

uint64_t Character._isLowercased.getter(uint64_t a1, unint64_t a2)
{
  return Character._isUppercased.getter(a1, a2, (uint64_t (*)(void))String.lowercased());
}

uint64_t Character._isUppercased.getter(uint64_t a1, unint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v6 = a3();
  uint64_t v7 = v5;
  if (v6 == a1 && v5 == a2)
  {
    char v8 = 1;
    uint64_t v7 = a2;
  }

  else if ((~a2 & 0x6000000000000000LL) == 0 && (v5 & 0x2000000000000000LL) != 0 && (v5 & 0x4000000000000000LL) != 0)
  {
    char v8 = 0;
  }

  else
  {
    char v8 = _stringCompareInternal(_:_:expecting:)(a1, a2, v6, v5, 0);
  }

  swift_bridgeObjectRelease(v7);
  return v8 & 1;
}

uint64_t Character.isUppercase.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
    }
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x80000000000LL) != 0) {
      return 1LL;
    }
  }

  if ((Character._isUppercased.getter(a1, a2) & 1) != 0) {
    return Character.isCased.getter(a1, a2);
  }
  return 0LL;
}

uint64_t Character.isCased.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
    }
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x800) != 0) {
      goto LABEL_6;
    }
  }

  if ((Character._isUppercased.getter(a1, a2) & 1) == 0) {
LABEL_6:
  }
    char v5 = 1;
  else {
    char v5 = Character._isLowercased.getter(a1, a2) ^ 1;
  }
  return v5 & 1;
}

uint64_t Character.isLowercase.getter(uint64_t a1, unint64_t a2)
{
  if (Character._isSingleScalar.getter(a1, a2))
  {
    unint64_t v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
    }
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x100000000LL) != 0) {
      return 1LL;
    }
  }

  if ((Character._isLowercased.getter(a1, a2) & 1) != 0) {
    return Character.isCased.getter(a1, a2);
  }
  return 0LL;
}

BOOL Character.isSymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 - 18 < 4;
}

unint64_t Character.isMathSymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 33) & 1;
}

BOOL Character.isCurrencySymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 == 19;
}

BOOL Character.isPunctuation.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CharacterProperties.swift",  31LL,  2,  0x10uLL,  0);
  }
  Swift::UInt8 GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 - 11 < 7;
}

Swift::Unicode::Scalar_optional __swiftcall Unicode._NFD.Iterator.next()()
{
  unint64_t v0 = specialized Unicode._InternalNFD.Iterator.next()();
  uint64_t v1 = v0;
  if ((v0 & 0x1000000000000LL) != 0) {
    uint64_t v1 = 0LL;
  }
  return (Swift::Unicode::Scalar_optional)(v1 | ((HIWORD(v0) & 1) << 32));
}

unint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._NFD.Iterator@<X0>( uint64_t a1@<X8>)
{
  unint64_t result = specialized Unicode._InternalNFD.Iterator.next()();
  if ((result & 0x1000000000000LL) != 0) {
    int v3 = 0;
  }
  else {
    int v3 = result;
  }
  *(_DWORD *)a1 = v3;
  *(_BYTE *)(a1 + 4) = BYTE6(result) & 1;
  return result;
}

unint64_t Unicode._NFD.makeIterator()@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *((void *)v4 + 2);
  unint64_t v5 = *((void *)v4 + 3);
  *(void *)a4 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a4 + 8) = 0;
  __int128 v7 = *v4;
  *(void *)(a4 + 16) = *(void *)v4;
  *(_OWORD *)(a4 + 24) = v7;
  *(void *)(a4 + 40) = v6;
  *(void *)(a4 + 48) = v5;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

__n128 protocol witness for Sequence.makeIterator() in conformance Unicode._NFD@<Q0>(uint64_t a1@<X8>)
{
  unint64_t v2 = v1[1].n128_u64[0];
  unint64_t v3 = v1[1].n128_u64[1];
  *(void *)a1 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a1 + 8) = 0;
  __n128 result = *v1;
  *(void *)(a1 + 16) = v1->n128_u64[0];
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 40) = v2;
  *(void *)(a1 + 48) = v3;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFD( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring( a1,  a2,  (uint64_t (*)(void, void, void, uint64_t))specialized _copySequenceToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFD( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

Swift::Unicode::Scalar_optional __swiftcall Unicode._NFC.Iterator.next()()
{
  unint64_t v0 = specialized Unicode._InternalNFC.Iterator.next()();
  return (Swift::Unicode::Scalar_optional)(v0 | ((HIDWORD(v0) & 1) << 32));
}

unint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._NFC.Iterator@<X0>( uint64_t a1@<X8>)
{
  unint64_t result = specialized Unicode._InternalNFC.Iterator.next()();
  *(_DWORD *)a1 = result;
  *(_BYTE *)(a1 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t Unicode._NFC.makeIterator()@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *((void *)v4 + 2);
  unint64_t v5 = *((void *)v4 + 3);
  *(void *)a4 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 12) = 0;
  *(_BYTE *)(a4 + 16) = 1;
  *(void *)(a4 + 24) = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a4 + 32) = 0;
  __int128 v7 = *v4;
  *(void *)(a4 + 40) = *(void *)v4;
  *(_OWORD *)(a4 + 48) = v7;
  *(void *)(a4 + 64) = v6;
  *(void *)(a4 + 72) = v5;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

__n128 protocol witness for Sequence.makeIterator() in conformance Unicode._NFC@<Q0>(__n128 *a1@<X8>)
{
  unint64_t v2 = v1[1].n128_u64[0];
  unint64_t v3 = v1[1].n128_u64[1];
  a1->n128_u64[0] = (unint64_t)&_swiftEmptyArrayStorage;
  a1->n128_u8[8] = 0;
  a1->n128_u32[3] = 0;
  a1[1].n128_u8[0] = 1;
  a1[1].n128_u64[1] = (unint64_t)&_swiftEmptyArrayStorage;
  a1[2].n128_u8[0] = 0;
  __n128 result = *v1;
  a1[2].n128_u64[1] = v1->n128_u64[0];
  a1[3] = result;
  a1[4].n128_u64[0] = v2;
  a1[4].n128_u64[1] = v3;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFC( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring( a1,  a2,  (uint64_t (*)(void, void, void, uint64_t))specialized _copySequenceToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, void, void))specialized Sequence._copySequenceContents(initializing:));
}

unint64_t String._nfd.getter@<X0>( unint64_t a1@<X0>, unint64_t a2@<X1>, Swift::UInt64 *a3@<X8>)
{
  *a3 = specialized Collection.subscript.getter(a1, a2);
  a3[1] = v4;
  a3[2] = v5;
  a3[3] = (Swift::UInt64)v6;
  return swift_bridgeObjectRetain((unint64_t)v6, v4, v5, v6);
}

unint64_t Substring._nfd.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, void *a5@<X8>)
{
  *a5 = a1;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return swift_bridgeObjectRetain((unint64_t)a4, a2, a3, a4);
}

uint64_t Unicode.Scalar.Properties._script.getter()
{
  return _swift_stdlib_getScript(*v0);
}

void *Unicode.Scalar.Properties._scriptExtensions.getter()
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  unsigned int v1 = *v0;
  unsigned __int8 v13 = 0;
  ScriptExtensions = _swift_stdlib_getScriptExtensions(v1, &v13);
  if (ScriptExtensions)
  {
    unint64_t v3 = ScriptExtensions;
    uint64_t v4 = v13;
    uint64_t v5 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v13,  0,  (uint64_t)&_swiftEmptyArrayStorage);
    uint64_t v6 = v5;
    if (v4)
    {
      __int128 v7 = v5[2];
      do
      {
        char v9 = *v3++;
        char v8 = v9;
        unint64_t v10 = v6[3];
        if ((unint64_t)v7 >= v10 >> 1) {
          uint64_t v6 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v10 > 1),  (int64_t)&v7->isa + 1,  1,  (uint64_t)v6);
        }
        v6[2] = (char *)&v7->isa + 1;
        *((_BYTE *)&v7->info + (void)v6) = v8;
        __int128 v7 = (__objc2_class *)((char *)v7 + 1);
        --v4;
      }

      while (v4);
    }
  }

  else
  {
    uint64_t v11 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
    uint64_t v6 = swift_allocObject(v11, 0x21uLL, 7uLL);
    *((_OWORD *)v6 + 1) = xmmword_1817FFC60;
    *((_BYTE *)v6 + 32) = _swift_stdlib_getScript(v1);
  }

  return v6;
}

unint64_t Unicode.Scalar.Properties._caseFolded.getter()
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  int v1 = *v0;
  uint64_t v16 = -1LL;
  int v17 = -1;
  _swift_stdlib_getCaseMapping(v1, (int *)&v16);
  uint64_t v2 = 0LL;
  unint64_t v3 = 0LL;
  unint64_t v4 = 0xE000000000000000LL;
  do
  {
    unsigned int v5 = *(_DWORD *)((char *)&v16 + v2);
    if (v5 == -1) {
      break;
    }
    if (HIWORD(v5) > 0x10u || (v5 & 0xFFFFF800) == 55296) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnicodeSPI.swift",  22LL,  2,  0xCFuLL,  0);
    }
    unint64_t v18 = v3;
    unint64_t v19 = v4;
    uint64_t v8 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v5);
    unint64_t v9 = v7;
    if ((v4 & 0x2000000000000000LL) == 0)
    {
      if ((v7 & 0x2000000000000000LL) != 0) {
LABEL_14:
      }
        uint64_t v10 = HIBYTE(v9) & 0xF;
      else {
LABEL_11:
      }
        uint64_t v10 = v8 & 0xFFFFFFFFFFFFLL;
      _StringGuts.append(_:)(v8, v9, 0LL, v10);
      swift_bridgeObjectRelease(v9);
      unint64_t v3 = v18;
      unint64_t v4 = v19;
      goto LABEL_16;
    }

    if ((v7 & 0x2000000000000000LL) == 0) {
      goto LABEL_11;
    }
    unint64_t v11 = specialized _SmallString.init(_:appending:)(v3, v4, v8, v7);
    if ((v13 & 1) != 0) {
      goto LABEL_14;
    }
    unint64_t v3 = v11;
    unint64_t v14 = v12;
    swift_bridgeObjectRelease(v9);
    swift_bridgeObjectRelease(v4);
    unint64_t v4 = v14;
LABEL_16:
    v2 += 4LL;
    swift_bridgeObjectRelease(0xE000000000000000LL);
  }

  while (v2 != 12);
  return v3;
}

Swift::String::Index __swiftcall String._wordIndex(after:)(Swift::String::Index after)
{
  unint64_t v3 = _StringGuts.validateWordIndex(_:)( after._rawBits,  v1,  v2,  (uint64_t (*)(void))_StringGuts.validateSubscalarIndex(_:));
  return (Swift::String::Index)(_StringGuts.nextWordIndex(startingAt:)(v3 >> 16) << 16);
}

Swift::String::Index __swiftcall String._wordIndex(before:)(Swift::String::Index before)
{
  unint64_t v3 = _StringGuts.validateWordIndex(_:)( before._rawBits,  v1,  v2,  (uint64_t (*)(void))_StringGuts.validateInclusiveSubscalarIndex(_:));
  if (!(v3 >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/UnicodeSPI.swift",  22LL,  2,  0xEAuLL,  0);
  }
  return (Swift::String::Index)(_StringGuts.previousWordIndex(endingAt:)(v3 >> 16) << 16);
}

Swift::String::Index __swiftcall String._nearestWordIndex(atOrBelow:)(Swift::String::Index atOrBelow)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveSubscalarIndex(_:)(atOrBelow)._rawBits;
  Swift::UInt64 rawBits = v5._rawBits;
  if ((v5._rawBits & 1) != 0)
  {
    if (v5._rawBits < 0x10000) {
      return (Swift::String::Index)rawBits;
    }
  }

  else
  {
    Swift::UInt64 rawBits = v5._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v5)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if (rawBits < 0x10000) {
      return (Swift::String::Index)rawBits;
    }
  }

  Swift::UInt64 v7 = rawBits >> 16;
  uint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 != v8)
  {
    Swift::Int v9 = _StringGuts.previousWordIndex(endingAt:)(rawBits >> 16);
    if (v7 != _StringGuts.nextWordIndex(startingAt:)(v9)) {
      return (Swift::String::Index)(v9 << 16);
    }
  }

  return (Swift::String::Index)rawBits;
}

id key path getter for Unmanaged._value : <A>Unmanaged<A>@<X0>( void **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, void *a5@<X8>)
{
  Swift::String::Index v5 = *a1;
  *a5 = v5;
  return swift_unknownObjectRetain(v5, a2, a3, a4);
}

void Unmanaged._value.setter(void *a1)
{
  *uint64_t v1 = a1;
}

void (*Unmanaged._value.modify(void **a1, uint64_t a2, uint64_t a3, char *a4))(uint64_t a1)
{
  uint64_t v6 = *v4;
  *a1 = *v4;
  a1[1] = v4;
  swift_unknownObjectRetain(v6, a2, a3, a4);
  return Unmanaged._value.modify;
}

void Unmanaged._value.modify(uint64_t a1)
{
  id v1 = *(id *)a1;
  unint64_t v2 = *(void **)(a1 + 8);
  swift_unknownObjectRelease(*(id *)a1);
  void *v2 = v1;
}

void *Unmanaged.init(_private:)(void *a1)
{
  return a1;
}

id Unmanaged.autorelease()(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  id v4 = swift_unknownObjectRetain(a1, a2, a3, a4);
  swift_unknownObjectRelease(v4);
  return v4;
}

Swift::Int UnsafePointer.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter( a1,  a2,  (uint64_t (*)(void))type metadata accessor for UnsafePointer,  (uint64_t)&protocol conformance descriptor for UnsafePointer<A>);
}

Swift::Int _sSPyxGSHsRi_zrlSH9hashValueSivgTW(uint64_t a1)
{
  return UnsafePointer.hashValue.getter(*v1, *(void *)(a1 + 16));
}

void _sSPyxGSHsRi_zrlSH4hash4intoys6HasherVz_tFTW(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafePointer<A>, a2, a3);
  _Pointer.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int _sSPyxGSHsRi_zrlSH13_rawHashValue4seedS2i_tFTW(Swift::Int a1, uint64_t a2, uint64_t a3)
{
  return _Pointer._rawHashValue(seed:)(a1);
}

uint64_t _sSPyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafePointer<A>, a1, a3);
  return _Pointer.debugDescription.getter(a1, WitnessTable);
}

uint64_t _sSPyxGs17CustomReflectablesRi_zrlsABP12customMirrors0D0VvgTW@<X0>( swift *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return _Pointer.customMirror.getter(a1, a3);
}

uint64_t UnsafePointer.pointee.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a3, a1);
}

uint64_t UnsafePointer.subscript.unsafeAddressor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 + *(void *)(*(void *)(a3 - 8) + 72LL) * a1;
}

uint64_t UnsafePointer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + *(void *)(*(void *)(a3 - 8) + 72LL) * a1);
}

uint64_t UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5)
{
  return UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(a1, a2, a3, a4, a5);
}

{
  return a3(a5);
}

uint64_t static UnsafePointer._max.getter(uint64_t a1)
{
  return -*(void *)(*(void *)(a1 - 8) + 72LL);
}

Swift::Int UnsafeMutablePointer.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter( a1,  a2,  (uint64_t (*)(void))type metadata accessor for UnsafeMutablePointer,  (uint64_t)&protocol conformance descriptor for UnsafeMutablePointer<A>);
}

Swift::Int AutoreleasingUnsafeMutablePointer.hashValue.getter( uint64_t a1, uint64_t a2, uint64_t (*a3)(void), uint64_t a4)
{
  uint64_t v5 = a3(0LL);
  swift_getWitnessTable(a4, v5, v6);
  return _Pointer._rawHashValue(seed:)(0LL);
}

Swift::Int _sSpyxGSHsRi_zrlSH9hashValueSivgTW(uint64_t a1)
{
  return UnsafeMutablePointer.hashValue.getter(*v1, *(void *)(a1 + 16));
}

void _sSpyxGSHsRi_zrlSH4hash4intoys6HasherVz_tFTW(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutablePointer<A>, a2, a3);
  _Pointer.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int _sSpyxGSHsRi_zrlSH13_rawHashValue4seedS2i_tFTW(Swift::Int a1, uint64_t a2, uint64_t a3)
{
  return _Pointer._rawHashValue(seed:)(a1);
}

uint64_t _sSpyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutablePointer<A>, a1, a3);
  return _Pointer.debugDescription.getter(a1, WitnessTable);
}

uint64_t _sSpyxGs17CustomReflectablesRi_zrlsABP12customMirrors0D0VvgTW@<X0>( swift *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return _Pointer.customMirror.getter(a1, a3);
}

uint64_t key path getter for UnsafeMutablePointer.pointee : <A>UnsafeMutablePointer<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)(a3 + a2 - 8) - 8LL) + 16LL))(a4, *a1);
}

uint64_t key path setter for UnsafeMutablePointer.pointee : <A>UnsafeMutablePointer<A>( uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t))(*(void *)(*(void *)(a4 + a3 - 8) - 8LL) + 24LL))(*a2, a1);
}

uint64_t UnsafeMutablePointer.pointee.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 40LL))(a2, a1);
}

uint64_t (*UnsafeMutablePointer.pointee.modify())()
{
  return EnumeratedSequence._base.modify;
}

void *specialized UnsafeMutablePointer.initialize(repeating:count:)(void *__c, size_t __len, void *__b)
{
  if ((__len & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize(repeating:count:): negative count",  65LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x371uLL,  0);
  }
  if (__len) {
    return memset(__b, (int)__c, __len);
  }
  return __c;
}

uint64_t UnsafeMutablePointer.initialize(repeating:count:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize(repeating:count:): negative count",  65LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x371uLL,  0);
  }
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 16);
    do
    {
      __n128 result = v10(a3, v7, a4);
      a3 += v9;
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t UnsafeMutablePointer.initialize(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a2, a1);
}

char *UnsafeMutablePointer.moveAssign(from:count:)(char *__src, uint64_t a2, char *__dst, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveUpdate(from:) with negative count",  58LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x46AuLL,  0);
  }
  uint64_t v4 = *(void *)(*(void *)(a4 - 8) + 72LL) * a2;
  uint64_t v5 = &__dst[v4];
  uint64_t v6 = &__src[v4];
  if (v5 > __src && v6 > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "moveUpdate overlapping range",  28LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x46CuLL,  0);
  }
  return swift_arrayAssignWithTake(__dst, __src, a2, a4);
}

uint64_t UnsafeMutablePointer.withMemoryRebound<A, B>(to:capacity:_:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5)
{
  return UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(a1, a2, a3, a4, a5);
}

uint64_t key path getter for UnsafeMutablePointer.subscript(_:) : <A>UnsafeMutablePointer<A>A@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void *)(*(void *)((char *)a2 + a3 - 8) - 8LL);
  return (*(uint64_t (**)(uint64_t, void))(v4 + 16))(a4, *a1 + *(void *)(v4 + 72) * *a2);
}

uint64_t key path setter for UnsafeMutablePointer.subscript(_:) : <A>UnsafeMutablePointer<A>A( uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(*(void *)((char *)a3 + a4 - 8) - 8LL) + 24LL))( *a2 + *(void *)(*(void *)(*(void *)((char *)a3 + a4 - 8) - 8LL) + 72LL) * *a3,  a1,  *(void *)((char *)a3 + a4 - 8));
}

uint64_t UnsafeMutablePointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 40LL))( a3 + *(void *)(*(void *)(a4 - 8) + 72LL) * a2,  a1,  a4);
}

uint64_t (*UnsafeMutablePointer.subscript.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawPointer.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0LL, a1);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeRawPointer()
{
  return _rawPointerToString(_:)(*v0)._countAndFlagsBits;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UnsafeRawPointer@<X0>( uint64_t a1@<X8>)
{
  return specialized _Pointer.customMirror.getter(*v1, (swift *)&type metadata for UnsafeRawPointer, a1);
}

Swift::Void __swiftcall UnsafeRawPointer.deallocate()()
{
}

void *protocol witness for Strideable.distance(to:) in conformance UnsafeRawPointer@<X0>( void *result@<X0>, void *a2@<X8>)
{
  *a2 = *result - *v2;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance UnsafeRawPointer@<X0>( void *result@<X0>, void *a2@<X8>)
{
  *a2 = *v2 + *result;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UnsafeRawPointer( void *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  *a1 = *a4 + *a6;
  return 0LL;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeMutableRawPointer()
{
  return specialized _Pointer.debugDescription.getter(*v0);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UnsafeMutableRawPointer@<X0>( uint64_t a1@<X8>)
{
  return specialized _Pointer.customMirror.getter(*v1, (swift *)&type metadata for UnsafeMutableRawPointer, a1);
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.initializeMemory: negative count",  56LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x456uLL,  0);
  }
  uint64_t v6 = a3;
  if (a3)
  {
    uint64_t v9 = *(void *)(a5 - 8);
    uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 16);
    uint64_t v11 = a4;
    do
    {
      v10(v11, a2, a5);
      v11 += *(void *)(v9 + 72);
      --v6;
    }

    while (v6);
  }

  return a4;
}

char *UnsafeMutableRawPointer.moveInitializeMemory<A>(as:from:count:)( int a1, char *a2, uint64_t a3, char *__dst, uint64_t a5)
{
  if (a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.moveInitializeMemory with negative count",  64LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4C8uLL,  0);
  }
  if (__dst < a2 || &a2[*(void *)(*(void *)(a5 - 8) + 72LL) * a3] <= __dst) {
    swift_arrayInitWithTakeFrontToBack(__dst, a2, a3, a5);
  }
  else {
    swift_arrayInitWithTakeBackToFront(__dst, a2, a3, a5);
  }
  return __dst;
}

void *UnsafeMutableRawPointer.storeBytes<A>(of:toByteOffset:as:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(a1, a2, a5, a4, a5);
}

void *UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v13[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a5 - 8);
  size_t v7 = *(void *)(v6 + 64);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (void *)(v10 + v9);
  if ((*(_BYTE *)(v6 + 80) & (v10 + v9)) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "storeBytes to misaligned raw pointer",  36LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x5DEuLL,  0);
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))((char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL), v8, a5);
  (*(void (**)(char *, uint64_t))(v6 + 8))((char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL), a5);
  if ((v7 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  return memcpy(v11, (char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL), v7);
}

void _UTFParser<>.parseScalar<A>(from:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  uint64_t v276 = a6;
  uint64_t v267 = a5;
  uint64_t v264 = a1;
  uint64_t v265 = a3;
  v248 = a7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a2,  (uint64_t)&protocol requirements base descriptor for _UTFParser,  associated type descriptor for _UTFParser.Encoding);
  AssociatedConformanceWitness = (const char *)swift_getAssociatedConformanceWitness( a4,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UTFParser,  (uint64_t)&associated conformance descriptor for _UTFParser._UTFParser.Encoding: _UnicodeEncoding);
  unint64_t v247 = swift_getAssociatedTypeWitness( 0LL,  AssociatedConformanceWitness,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v242 = *(void *)(v247 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v247);
  v257 = (char *)&v237 - v13;
  uint64_t v240 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v12);
  v241 = (char *)&v237 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v15 = swift_getAssociatedTypeWitness( 255LL,  AssociatedConformanceWitness,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  v260 = AssociatedConformanceWitness;
  unint64_t v259 = AssociatedTypeWitness;
  unint64_t v271 = swift_getAssociatedConformanceWitness( (uint64_t)AssociatedConformanceWitness,  AssociatedTypeWitness,  v15,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger);
  uint64_t v16 = *(void *)(v271 + 8);
  v263 = *(const char **)(*(void *)(v16 + 24) + 16LL);
  unint64_t v262 = swift_getAssociatedTypeWitness( 0LL,  v263,  v15,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v262);
  v261 = (char *)&v237 - v17;
  v269 = (void (*)(void, void))type metadata accessor for CollectionOfOne(0LL, v15, v18, v19);
  MEMORY[0x1895F8858](v269);
  unint64_t v268 = (unint64_t)&v237 - v20;
  uint64_t v246 = type metadata accessor for Optional(0LL, v15, v21, v22);
  uint64_t v245 = *(void *)(v246 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v246);
  v255 = (char *)&v237 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  unint64_t v27 = (char *)&v237 - v26;
  uint64_t v28 = *(void *)(v15 - 8);
  uint64_t v29 = MEMORY[0x1895F8858](v25);
  v244 = (char *)&v237 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  v243 = (char *)&v237 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  v249 = (char *)&v237 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  v250 = (char *)&v237 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  v270 = (char *)&v237 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  v258 = (char *)&v237 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  v251 = (char *)&v237 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  v45 = (char *)&v237 - v44;
  uint64_t v46 = MEMORY[0x1895F8858](v43);
  v278 = (char *)&v237 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  v50 = (char *)&v237 - v49;
  uint64_t v51 = MEMORY[0x1895F8858](v48);
  v274 = (char *)&v237 - v52;
  MEMORY[0x1895F8858](v51);
  v54 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v237 - v53);
  v55 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 40);
  uint64_t v272 = v7;
  uint64_t v273 = a2;
  uint64_t v56 = a2;
  v57 = v55;
  uint64_t v256 = a4;
  uint64_t v58 = v55(v56, a4);
  uint64_t v275 = v28;
  if ((v58 & 0xFF00000000LL) != 0)
  {
    v266 = v50;
    v197 = swift_checkMetadataState(0LL, v259);
    uint64_t v78 = v256;
    uint64_t v198 = v57(v273, v256);
    int v281 = v198;
    v253 = (void (*)(uint64_t, uint64_t))v57;
    v199 = *(void (**)(int *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v16 + 96);
    unint64_t v202 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v198, v200, v201);
    v203 = v274;
    unint64_t v238 = v202;
    v239 = v199;
    ((void (*)(int *, ValueMetadata *))v199)(&v281, &type metadata for UInt32);
    uint64_t v204 = (uint64_t)v260;
    v205 = (uint64_t (*)(char *, unint64_t *, const char *))*((void *)v260 + 14);
    v254 = v197;
    char v206 = v205(v203, v197, v260);
    v277 = *(void (**)(char *, unint64_t))(v28 + 8);
    v277(v203, v15);
    if ((v206 & 1) != 0)
    {
      uint64_t v207 = v273;
      v208 = v253;
      int v281 = ((uint64_t (*)(uint64_t, uint64_t))v253)(v273, v78);
      v239(&v281, &type metadata for UInt32, v238, v15, v16);
      v208(v207, v78);
      LOBYTE(v279) = 0;
      v209 = (void (*)(int *, void))(*(uint64_t (**)(int *, uint64_t, uint64_t))(v78 + 56))( &v281,  v207,  v78);
      unint64_t v210 = swift_getAssociatedConformanceWitness( v204,  (uint64_t)v254,  v15,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
      uint64_t v211 = type metadata accessor for _UIntBuffer(0LL, v15, v271, v210);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, v211, v212);
      uint64_t v214 = (uint64_t)v266;
      RangeReplaceableCollection.remove(at:)((uint64_t)&v279, v211, WitnessTable, (uint64_t)v266);
      v277((char *)v214, v15);
      v209(&v281, 0LL);
      uint64_t v215 = v268;
      (*(void (**)(unint64_t, char *, unint64_t))(v28 + 32))(v268, v203, v15);
      uint64_t v216 = v276;
      v217 = *(void (**)(uint64_t, void (*)(void, void), uint64_t, unint64_t, uint64_t))(v276 + 56);
      v218 = v269;
      uint64_t v220 = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v269, v219);
      v221 = v248;
      v222 = v218;
      uint64_t v223 = v247;
      v217(v215, v222, v220, v247, v216);
      size_t v61 = type metadata accessor for Unicode.ParseResult(0LL, v223, v224, v225);
      v62 = v221;
LABEL_51:
      unsigned int v63 = 0;
      goto LABEL_52;
    }

    v254 = *(unint64_t **)(v267 + 16);
    uint64_t v83 = v271;
  }

  else
  {
    v254 = *(unint64_t **)(v267 + 16);
    ((void (*)(uint64_t))v254)(v265);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v28 + 48))(v27, 1LL, v15) == 1)
    {
      (*(void (**)(char *, uint64_t))(v245 + 8))(v27, v246);
LABEL_4:
      size_t v61 = type metadata accessor for Unicode.ParseResult(0LL, v247, v59, v60);
      v62 = v248;
      unsigned int v63 = 2;
      goto LABEL_52;
    }

    v253 = (void (*)(uint64_t, uint64_t))v57;
    v64 = *(void (**)(uint64_t (*)(uint64_t, uint64_t), char *, unint64_t))(v28 + 32);
    v64(v54, v27, v15);
    v65 = swift_checkMetadataState(0LL, v259);
    uint64_t v66 = (uint64_t)v260;
    if (((*((uint64_t (**)(uint64_t (*)(uint64_t, uint64_t), unint64_t *, const char *))v260
           + 14))( v54,  v65,  v260) & 1) != 0)
    {
      uint64_t v67 = v268;
      v64((uint64_t (*)(uint64_t, uint64_t))v268, (char *)v54, v15);
      uint64_t v68 = v276;
      v69 = *(void (**)(uint64_t, void (*)(void, void), uint64_t, unint64_t, uint64_t))(v276 + 56);
      v70 = v269;
      uint64_t v72 = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v269, v71);
      v73 = v248;
      v74 = v70;
      uint64_t v75 = v247;
      v69(v67, v74, v72, v247, v68);
      size_t v61 = type metadata accessor for Unicode.ParseResult(0LL, v75, v76, v77);
      v62 = v73;
      goto LABEL_51;
    }

    uint64_t v78 = v256;
    uint64_t v79 = (*(uint64_t (**)(int *, uint64_t, uint64_t))(v256 + 56))(&v281, v273, v256);
    uint64_t v80 = v66;
    v81 = (void (*)(int *, void))v79;
    unint64_t v82 = swift_getAssociatedConformanceWitness( v80,  (uint64_t)v65,  v15,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
    uint64_t v83 = v271;
    uint64_t v84 = type metadata accessor for _UIntBuffer(0LL, v15, v271, v82);
    _UIntBuffer.append(_:)(v54, v84);
    v277 = *(void (**)(char *, unint64_t))(v28 + 8);
    v277((char *)v54, v15);
    v81(&v281, 0LL);
  }

  uint64_t v85 = v15;
  v86 = v274;
  v87 = v255;
  v266 = v45;
  unint64_t v268 = v15;
  uint64_t v252 = v16;
  while (1)
  {
    ((void (*)(uint64_t, uint64_t))v254)(v265, v267);
    uint64_t v88 = v275;
    (*(void (**)(char *, char *, uint64_t))(v88 + 32))(v278, v87, v85);
    v269 = (void (*)(void, void))(*(uint64_t (**)(int *, uint64_t, uint64_t))(v78 + 56))( &v281,  v273,  v78);
    uint64_t v90 = v89;
    char v91 = *(_BYTE *)(v89 + 4);
    unsigned int v279 = *(_DWORD *)v89;
    char v280 = v91;
    unint64_t v92 = swift_getAssociatedConformanceWitness( (uint64_t)v260,  v259,  v85,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
    uint64_t v93 = type metadata accessor for _UIntBuffer(0LL, v85, v83, v92);
    uint64_t v95 = swift_getWitnessTable(L"D\r䫴\r豸\u0AD5", v93, v94);
    uint64_t v96 = Collection.count.getter(v93, v95);
    if (__OFADD__(v96, 1LL))
    {
      __break(1u);
LABEL_56:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    }

    if (specialized _UIntBuffer.capacity.getter(v85, v83) < v96 + 1) {
      goto LABEL_56;
    }
    (*(void (**)(uint64_t, uint64_t))(v83 + 64))(v85, v83);
    uint64_t v276 = *(void *)(v16 + 64);
    char v97 = ((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16);
    uint64_t v98 = v275;
    v99 = v258;
    if ((v97 & 1) != 0)
    {
      v100 = v45;
      v101 = v251;
      (*(void (**)(char *, char *, uint64_t))(v275 + 16))(v251, v100, v85);
      v102 = v263;
      unint64_t v103 = v262;
      unint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v263,  v85,  v262,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v105 = v261;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v104 + 8))( &unk_18180BE68,  256LL,  v103,  v104);
      (*((void (**)(char *, uint64_t, const char *))v102 + 3))(v105, v85, v102);
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v16 + 32) + 8LL) + 32LL))( v101,  v86,  v85);
      v106 = (void (*)(char *, uint64_t))v277;
      v277(v86, v85);
      if ((v103 & 1) == 0) {
        goto LABEL_57;
      }
      v106(v101, v85);
      v45 = v266;
    }

    v107 = *(uint64_t (**)(uint64_t, uint64_t))(v16 + 128);
    if (v107(v85, v16) >= 32)
    {
      v108 = *(void (**)(char *, char *, uint64_t))(v98 + 16);
      v108(v99, v45, v85);
      unsigned int v279 = -1;
      char v109 = ((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16);
      uint64_t v110 = v107(v85, v16);
      if ((v109 & 1) != 0)
      {
        if (v110 <= 32)
        {
          v113 = v263;
          uint64_t v85 = v268;
          unint64_t v114 = v262;
          unint64_t v115 = swift_getAssociatedConformanceWitness( (uint64_t)v263,  v268,  v262,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v116 = v261;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v115 + 8))( &unk_18180BE68,  256LL,  v114,  v115);
          v117 = v116;
          v86 = v274;
          (*((void (**)(char *, uint64_t, const char *))v113 + 3))(v117, v85, v113);
          LODWORD(v239) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v16 + 32) + 8LL)
                                                                             + 40LL))( v99,  v86,  v85);
          v118 = v99;
          v119 = (void (*)(char *, uint64_t))v277;
          v277(v86, v85);
          LODWORD(v238) = v279;
          v120 = v244;
          v108(v244, v118, v85);
          if ((v239 & 1) != 0)
          {
            unsigned int v121 = (*(uint64_t (**)(uint64_t, uint64_t))(v16 + 120))(v85, v16);
            v119(v120, v85);
            BOOL v155 = v238 >= v121;
            uint64_t v98 = v275;
            v122 = v258;
            if (!v155) {
              goto LABEL_58;
            }
          }

          else
          {
            v119(v120, v85);
            uint64_t v98 = v275;
            v122 = v258;
          }

uint64_t static UInt8.% infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2B4uLL,  0);
  }
  return a1 % a2;
}

uint64_t static UInt8./ infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
  }
  return a1 / a2;
}

uint64_t static Unicode.UTF8.encodedReplacementCharacter.getter()
{
  return 12501232LL;
}

uint64_t static _ValidUTF8Buffer.encodedReplacementCharacter.getter()
{
  return 12501232LL;
}

BOOL static Unicode.UTF8._isScalar(_:)(char a1)
{
  return (a1 & 0x80) == 0;
}

uint64_t static Unicode.UTF8.decode(_:)(unsigned int a1)
{
  uint64_t v1 = 4LL - (__clz(a1) >> 3);
  unsigned int v2 = a1 - 1;
  if (v1 != 1) {
    unsigned int v2 = ((a1 - 16843009) >> 10) & 0xFC0 | ((a1 - 16843009) >> 24) & 0x3F | ((((a1 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((a1 - 16843009) & 7) << 18);
  }
  if (v1 == 2) {
    unsigned int v2 = (((a1 - 257) & 0x1F) << 6) | ((a1 - 257) >> 8) & 0x3F;
  }
  if (v1 == 3) {
    return ((a1 - 65793) >> 2) & 0xFC0 | ((a1 - 65793) >> 16) & 0x3F | (((a1 - 65793) & 0xF) << 12);
  }
  else {
    return v2;
  }
}

uint64_t static UInt32.&>> infix(_:_:)(unsigned int a1, char a2)
{
  return a1 >> a2;
}

Swift::_ValidUTF8Buffer __swiftcall _ValidUTF8Buffer.init(_containing:)(Swift::UInt8 _containing)
{
  return (Swift::_ValidUTF8Buffer)(_containing + 1);
}

_DWORD *static UInt32.&>>= infix(_:_:)(_DWORD *result, char a2)
{
  *result >>= a2;
  return result;
}

uint64_t static Unicode.UTF8.transcode<A>(_:from:)( unsigned int *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  if (a3 != &type metadata for Unicode.UTF16)
  {
    if (a3 != &type metadata for Unicode.UTF8) {
      goto LABEL_15;
    }
    if ((ValueMetadata *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)&type metadata for Unicode.UTF8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar) == &type metadata for _ValidUTF8Buffer) {
      return *a1;
    }
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
  }

  uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
  if (swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)&type metadata for Unicode.UTF16,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar) != v7) {
    goto LABEL_9;
  }
  unsigned int v8 = *a1;
  unsigned int v9 = (unsigned __int16)*a1;
  if (v9 <= 0x7F) {
    return (v8 + 1);
  }
  int v12 = (*a1 & 0x3F) << 8;
  if (v9 <= 0x7FF)
  {
    int v13 = v12 | (v9 >> 6);
    return (v13 + 33217);
  }

  if ((*a1 & 0xF800) != 0xD800) {
    return (((v12 | (v9 >> 6) & 0x3F) << 8) | ((unsigned __int16)v8 >> 12)) + 8487393;
  }
LABEL_15:
  unsigned int v14 = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a4 + 88))(a1, a3, a4);
  if (v14 <= 0x7F) {
    return v14 + 1;
  }
  int v15 = (v14 & 0x3F) << 8;
  if (v14 <= 0x7FF)
  {
    int v13 = v15 | (v14 >> 6);
    return (v13 + 33217);
  }

  int v16 = (v15 | (v14 >> 6) & 0x3F) << 8;
  unsigned int v17 = (((v16 | (v14 >> 12) & 0x3F) << 8) | (v14 >> 18)) - 2122219023;
  unsigned int v10 = (v16 | (v14 >> 12)) + 8487393;
  if (HIWORD(v14)) {
    return v17;
  }
  return v10;
}

BOOL static UInt16.< infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a1 < a2;
}

_WORD *static UInt16.&>>= infix(_:_:)(_WORD *result, char a2)
{
  *__n128 result = (unsigned __int16)*result >> (a2 & 0xF);
  return result;
}

uint64_t static UInt16.&>> infix(_:_:)(unsigned __int16 a1, char a2)
{
  return a1 >> (a2 & 0xF);
}

uint64_t Unicode.UTF8.ForwardParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t Unicode.UTF8.ForwardParser._buffer.setter(uint64_t result)
{
  *(_DWORD *)uint64_t v1 = result;
  *(_BYTE *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t (*Unicode.UTF8.ForwardParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.UTF8.ForwardParser.init()()
{
  return 0LL;
}

uint64_t Unicode.UTF8.ReverseParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF8.ReverseParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF8( _DWORD *a1@<X8>)
{
  *a1 = 12501232;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF8( unsigned int *a1)
{
  uint64_t v1 = 4LL - (__clz(*a1) >> 3);
  unsigned int v2 = *a1 - 1;
  if (v1 != 1) {
    unsigned int v2 = ((*a1 - 16843009) >> 10) & 0xFC0 | ((*a1 - 16843009) >> 24) & 0x3F | ((((*a1 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((*a1 - 16843009) & 7) << 18);
  }
  if (v1 == 2) {
    unsigned int v2 = (((*a1 - 257) & 0x1F) << 6) | ((*a1 - 257) >> 8) & 0x3F;
  }
  if (v1 == 3) {
    return ((*a1 - 65793) >> 2) & 0xFC0 | ((*a1 - 65793) >> 16) & 0x3F | (((*a1 - 65793) & 0xF) << 12);
  }
  else {
    return v2;
  }
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF8@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  if (result > 0x7F)
  {
    int v3 = (result & 0x3F) << 8;
    if (result >= 0x800)
    {
      unsigned int v4 = (v3 | (result >> 6) & 0x3F) << 8;
      unsigned int v5 = (((v4 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
      unsigned int v2 = (v4 | (result >> 12)) + 8487393;
      if (WORD1(result)) {
        unsigned int v2 = v5;
      }
    }

    else
    {
      unsigned int v2 = (v3 | (result >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v2 = result + 1;
  }

  *(_DWORD *)a2 = v2;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

unint64_t protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF8@<X0>( int *a1@<X0>, ValueMetadata *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  if (a2 != &type metadata for Unicode.UTF16)
  {
    if (a2 != v4) {
      goto LABEL_15;
    }
    unint64_t result = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if ((ValueMetadata *)result == &type metadata for _ValidUTF8Buffer)
    {
      int v13 = *a1;
      goto LABEL_5;
    }

uint64_t protocol witness for static _UnicodeEncoding._isScalar(_:) in conformance Unicode.UTF8( unsigned __int8 *a1)
{
  return (*a1 >> 7) ^ 1u;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF8.ReverseParser._parseMultipleCodeUnits()()
{
  if ((v0 & 0xE0C0) == 0xC080)
  {
    if ((v0 & 0x1E00) != 0)
    {
LABEL_11:
      Swift::Bool v2 = 1;
      goto LABEL_12;
    }
  }

  else if ((v0 & 0xF0C0C0) == 0xE08080)
  {
    if ((v0 & 0xF2000) != 0 && (v0 & 0xF2000) != 0xD2000) {
      goto LABEL_11;
    }
  }

  else if ((v0 & 0xF8C0C0C0) == 0xF0808080 && ((v0 & 0x7300000u) - 67108865) >> 26 == 63)
  {
    goto LABEL_11;
  }

  Unicode.UTF8.ReverseParser._invalidLength()();
  Swift::Bool v2 = 0;
LABEL_12:
  result.bitCount = v1;
  result.isValid = v2;
  return result;
}

uint64_t static UInt8.* infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result = a1 * a2;
  if ((result & 0xFF00) != 0) {
    __break(1u);
  }
  return result;
}

Swift::UInt8 __swiftcall Unicode.UTF8.ReverseParser._invalidLength()()
{
  if ((v0 & 0xF0C0) != 0xE080)
  {
    if ((v0 & 0xF8C0) == 0xF080)
    {
      if ((v0 & 0x730u) - 1025 >= 0xFFFFFC00) {
        return 2;
      }
    }

    else if ((v0 & 0xF8C0C0) == 0xF08080 && (v0 & 0x73000u) - 262145 > 0xFFFBFFFF)
    {
      return 3;
    }

    return 1;
  }

  if ((v0 & 0xF20) == 0xD20 || (v0 & 0xF20) == 0) {
    return 1;
  }
  else {
    return 2;
  }
}

Swift::_ValidUTF8Buffer __swiftcall Unicode.UTF8.ReverseParser._bufferedScalar(bitCount:)(Swift::UInt8 bitCount)
{
  return (Swift::_ValidUTF8Buffer)((bswap32(v1) + 16843009) >> -bitCount);
}

uint64_t UInt32.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1);
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF8.ReverseParser@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v9)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  char v17;
  Swift::UInt8 v18;
  unsigned __int8 v19;
  unsigned int v20;
  uint64_t (*v21)();
  void v22[4];
  uint64_t v5 = v4;
  if (*(_BYTE *)(v4 + 4))
  {
    uint64_t v20 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0x80) != 0)
    {
      uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      uint64_t result = v9(v22, a2, a3);
      goto LABEL_9;
    }

    lazy protocol witness table accessor for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser( a1,  a2,  a3);
    uint64_t v21 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    uint64_t result = (void *)((uint64_t (*)(void *, void))v21)(v22, 0LL);
    unsigned int v12 = 0;
    int v11 = (v20 + 1);
  }

  else
  {
    uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    uint64_t result = v9(v22, a2, a3);
    if ((v22[0] & 0x100LL) != 0)
    {
LABEL_3:
      int v11 = 0LL;
      unsigned int v12 = 2;
      goto LABEL_27;
    }

    if ((v22[0] & 0x80) == 0)
    {
      unsigned int v12 = 0;
      int v11 = LOBYTE(v22[0]) + 1LL;
      goto LABEL_27;
    }

    int v13 = *(unsigned __int8 *)(v4 + 4);
    if (v13 >= 0x20) {
LABEL_29:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-255 << v13) - 1) | (LOBYTE(v22[0]) << v13);
    *(_BYTE *)(v4 + 4) = v13 + 8;
    while (1)
    {
      uint64_t result = v9(v22, a2, a3);
LABEL_9:
      if ((v22[0] & 0x100LL) != 0) {
        break;
      }
      int v14 = *(unsigned __int8 *)(v4 + 4);
      if (v14 > 0x1F) {
        goto LABEL_29;
      }
      unsigned int v15 = *(_DWORD *)v4 & ((-255 << v14) - 1) | (LOBYTE(v22[0]) << v14);
      *(_DWORD *)uint64_t v4 = v15;
      int v16 = v14 + 8;
      *(_BYTE *)(v4 + 4) = v14 + 8;
      if (v14 >= 0x18) {
        goto LABEL_15;
      }
    }

    int v16 = *(_BYTE *)(v4 + 4);
    if (!v16) {
      goto LABEL_3;
    }
    unsigned int v15 = *(_DWORD *)v4;
LABEL_15:
    if ((v15 & 0xE0C0) == 0xC080)
    {
      if ((v15 & 0x1E00) != 0)
      {
        unsigned int v17 = 16;
LABEL_18:
        unsigned int v12 = 0;
        *(_DWORD *)uint64_t v4 = (unint64_t)v15 >> v17;
        *(_BYTE *)(v4 + 4) = v16 - v17;
        int v11 = (bswap32(v15) + 16843009) >> (-v17 & 0x18);
        goto LABEL_27;
      }
    }

    else if ((v15 & 0xF0C0C0) == 0xE08080)
    {
      if ((v15 & 0xF2000) != 0 && (v15 & 0xF2000) != 0xD2000)
      {
        unsigned int v17 = 24;
        goto LABEL_18;
      }
    }

    else if ((v15 & 0xF8C0C0C0) == 0xF0808080 && ((v15 & 0x7300000) - 67108865) >> 26 == 63)
    {
      unsigned int v17 = 32;
      goto LABEL_18;
    }

    unsigned int v18 = Unicode.UTF8.ReverseParser._invalidLength()();
    uint64_t v19 = 8 * v18;
    *(_DWORD *)uint64_t v5 = v15 >> (8 * (v18 & 0x1F));
    *(_BYTE *)(v5 + 4) = v16 - 8 * v18;
    uint64_t result = (void *)specialized numericCast<A, B>(_:)(8uLL);
    if (!(_BYTE)result) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
    }
    unsigned int v12 = 1;
    int v11 = v19 / result;
  }

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF8.ReverseParser()
{
  int v1 = *v0;
  if ((*v0 & 0xE0C0) != 0xC080)
  {
    if ((v1 & 0xF0C0C0) == 0xE08080)
    {
      if ((v1 & 0xF2000) != 0 && (v1 & 0xF2000) != 0xD2000)
      {
        int v2 = 24;
        int v3 = 1;
        return v3 | (v2 << 8);
      }
    }

    else if ((v1 & 0xF8C0C0C0) == 0xF0808080 && ((v1 & 0x7300000u) - 67108865) >> 26 == 63)
    {
      int v2 = 32;
      int v3 = 1;
      return v3 | (v2 << 8);
    }

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF8.ReverseParser@<X0>( uint64_t result@<X0>, unsigned int *a2@<X8>)
{
  *a2 = (bswap32(*v2) + 16843009) >> -(char)result;
  return result;
}

uint64_t (*protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser())()
{
  return EnumeratedSequence._base.modify;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF8.ForwardParser._parseMultipleCodeUnits()()
{
  if ((v0 & 0xC0E0) != 0x80C0)
  {
    if ((v0 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v0 & 0x200F) != 0 && (v0 & 0x200F) != 0x200D) {
        goto LABEL_3;
      }
    }

    else if ((v0 & 0xC0C0C0F8) == 0x808080F0 && (v0 & 0x3007) != 0 && __rev16(v0 & 0x3007) < 0x401)
    {
      goto LABEL_3;
    }

Swift::UInt8 __swiftcall Unicode.UTF8.ForwardParser._invalidLength()()
{
  int v1 = v0;
  if ((v0 & 0xC0F0) == 0x80E0)
  {
    if ((v0 & 0x200F) == 0x200D || (v0 & 0x200F) == 0) {
      return 1;
    }
    else {
      return 2;
    }
  }

  else if ((v0 & 0xC0F8) == 0x80F0)
  {
    Swift::UInt8 result = 1;
    if ((v1 & 0x3007) != 0)
    {
      unsigned int v4 = __rev16(v1 & 0x3007);
      if ((v1 & 0xC00000) == 0x800000) {
        Swift::UInt8 v5 = 3;
      }
      else {
        Swift::UInt8 v5 = 2;
      }
      if (v4 <= 0x400) {
        return v5;
      }
      else {
        return 1;
      }
    }
  }

  else
  {
    return 1;
  }

  return result;
}

Swift::_ValidUTF8Buffer __swiftcall Unicode.UTF8.ForwardParser._bufferedScalar(bitCount:)(Swift::UInt8 bitCount)
{
  return (Swift::_ValidUTF8Buffer)(((1 << ((bitCount + 1) >> 1) << (bitCount >> 1)) - 1) & (v1 + 16843009));
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF8.ForwardParser@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v9)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  unsigned int v17;
  Swift::UInt8 v18;
  unsigned __int8 v19;
  unsigned int v20;
  uint64_t (*v21)();
  void v22[4];
  uint64_t v5 = v4;
  if (*(_BYTE *)(v4 + 4))
  {
    uint64_t v20 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0x80) != 0)
    {
      uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      Swift::UInt8 result = v9(v22, a2, a3);
      goto LABEL_9;
    }

    lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser( a1,  a2,  a3);
    uint64_t v21 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    Swift::UInt8 result = (void *)((uint64_t (*)(void *, void))v21)(v22, 0LL);
    unsigned int v12 = 0;
    int v11 = (v20 + 1);
  }

  else
  {
    uint64_t v9 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    Swift::UInt8 result = v9(v22, a2, a3);
    if ((v22[0] & 0x100LL) != 0)
    {
LABEL_3:
      int v11 = 0LL;
      unsigned int v12 = 2;
      goto LABEL_29;
    }

    if ((v22[0] & 0x80) == 0)
    {
      unsigned int v12 = 0;
      int v11 = LOBYTE(v22[0]) + 1LL;
      goto LABEL_29;
    }

    int v13 = *(unsigned __int8 *)(v4 + 4);
    if (v13 >= 0x20) {
LABEL_30:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-255 << v13) - 1) | (LOBYTE(v22[0]) << v13);
    *(_BYTE *)(v4 + 4) = v13 + 8;
    while (1)
    {
      Swift::UInt8 result = v9(v22, a2, a3);
LABEL_9:
      if ((v22[0] & 0x100LL) != 0) {
        break;
      }
      int v14 = *(unsigned __int8 *)(v4 + 4);
      if (v14 > 0x1F) {
        goto LABEL_30;
      }
      unsigned int v15 = *(_DWORD *)v4 & ((-255 << v14) - 1) | (LOBYTE(v22[0]) << v14);
      *(_DWORD *)uint64_t v4 = v15;
      int v16 = v14 + 8;
      *(_BYTE *)(v4 + 4) = v14 + 8;
      if (v14 >= 0x18) {
        goto LABEL_15;
      }
    }

    int v16 = *(_BYTE *)(v4 + 4);
    if (!v16) {
      goto LABEL_3;
    }
    unsigned int v15 = *(_DWORD *)v4;
LABEL_15:
    if ((v15 & 0xC0E0) == 0x80C0)
    {
      if ((v15 & 0x1E) != 0)
      {
        unsigned int v17 = 16;
LABEL_18:
        unsigned int v12 = 0;
        *(_DWORD *)uint64_t v4 = (unint64_t)v15 >> v17;
        *(_BYTE *)(v4 + 4) = v16 - v17;
        int v11 = ((1 << (v17 >> 1) << (v17 >> 1)) - 1) & (v15 + 16843009);
        goto LABEL_29;
      }
    }

    else if ((v15 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v15 & 0x200F) != 0 && (v15 & 0x200F) != 0x200D)
      {
        unsigned int v17 = 24;
        goto LABEL_18;
      }
    }

    else if ((v15 & 0xC0C0C0F8) == 0x808080F0 && (v15 & 0x3007) != 0 && __rev16(v15 & 0x3007) <= 0x400)
    {
      unsigned int v17 = 32;
      goto LABEL_18;
    }

    unsigned int v18 = Unicode.UTF8.ForwardParser._invalidLength()();
    uint64_t v19 = 8 * v18;
    *(_DWORD *)uint64_t v5 = v15 >> (8 * (v18 & 0x1F));
    *(_BYTE *)(v5 + 4) = v16 - 8 * v18;
    Swift::UInt8 result = (void *)specialized numericCast<A, B>(_:)(8uLL);
    if (!(_BYTE)result) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
    }
    unsigned int v12 = 1;
    int v11 = v19 / result;
  }

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF8.ForwardParser()
{
  int v1 = *v0;
  if ((*v0 & 0xC0E0) != 0x80C0)
  {
    if ((v1 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v1 & 0x200F) != 0 && (*v0 & 0x200F) != 0x200D)
      {
        int v2 = 24;
        int v3 = 1;
        return v3 | (v2 << 8);
      }
    }

    else if ((v1 & 0xC0C0C0F8) == 0x808080F0 && (v1 & 0x3007) != 0 && __rev16(*v0 & 0x3007) <= 0x400)
    {
      int v2 = 32;
      int v3 = 1;
      return v3 | (v2 << 8);
    }

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF8.ForwardParser@<X0>( uint64_t result@<X0>, int *a2@<X8>)
{
  *a2 = (*v2 + 16843009) & ((1 << ((result + 1) >> 1) << (result >> 1)) - 1);
  return result;
}

unint64_t protocol witness for _UTFParser._buffer.getter in conformance Unicode.UTF8.ForwardParser()
{
  return *v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32);
}

uint64_t protocol witness for _UTFParser._buffer.setter in conformance Unicode.UTF8.ForwardParser( uint64_t result)
{
  *(_DWORD *)uint64_t v1 = result;
  *(_BYTE *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t static UInt16.+ infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result = a1 + a2;
  if ((result & 0x10000) != 0) {
    __break(1u);
  }
  return result;
}

void *static Unicode.UTF16._copy<A, B>(source:destination:count:)( char *a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a5 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  int v11 = (char *)&v27 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = (void *)MEMORY[0x1895F8858](v9);
  uint64_t v19 = (char *)&v27 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v20 = *(void *)(v17 + 72);
  uint64_t v21 = *(void *)(v8 + 72);
  if (v20 == v21)
  {
    if ((a3 & 0x8000000000000000LL) != 0 || (v20 & 0x8000000000000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    if (is_mul_ok(a3, v20)) {
      return memcpy(a2, v7, a3 * v20);
    }
    __break(1u);
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if ((a3 & 0x8000000000000000LL) != 0) {
    goto LABEL_13;
  }
  uint64_t v31 = v16;
  uint64_t v32 = v17;
  if (a3)
  {
    uint64_t v22 = v13;
    uint64_t v23 = v15;
    uint64_t v24 = v14;
    uint64_t v28 = *(void (**)(char *, char *, uint64_t))(v32 + 16);
    uint64_t v29 = v21;
    unint64_t v30 = v20;
    do
    {
      v28(v19, v7, v22);
      uint64_t v25 = v8;
      uint64_t v26 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v23 + 8))(v19, v22, v23);
      (*(void (**)(char *, uint64_t))(v32 + 8))(v19, v22);
      (*(void (**)(uint64_t, uint64_t))(v31 + 16))(v26, v24);
      uint64_t v8 = v25;
      uint64_t result = (void *)(*(uint64_t (**)(char *, char *, uint64_t))(v25 + 40))(a2, v11, v24);
      a2 += v29;
      v7 += v30;
      --a3;
    }

    while (a3);
  }

  return result;
}

unint64_t static UInt.* infix(_:_:)(unint64_t result, unint64_t a2)
{
  if (is_mul_ok(result, a2)) {
    result *= a2;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Unicode.UTF16.transcodedLength<A, B>(of:decodedAs:repairingIllFormedSequences:)( ValueMetadata *a1, ValueMetadata *a2, int a3, uint64_t a4, uint64_t a5, ValueMetadata *a6, const char *a7)
{
  uint64_t v197 = a4;
  int v184 = a3;
  uint64_t v195 = a2;
  uint64_t v193 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a7,  a5,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  uint64_t v194 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v172 = (char *)&v156 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v159 = v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v174 = (char *)&v156 - v14;
  uint64_t v177 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v15, v16);
  uint64_t v188 = *(void *)(v177 - 8);
  MEMORY[0x1895F8858](v177);
  v187 = (char *)&v156 - v17;
  v189 = (ValueMetadata *)AssociatedTypeWitness;
  uint64_t v20 = type metadata accessor for Unicode.ParseResult(0LL, AssociatedTypeWitness, v18, v19);
  uint64_t v183 = *(void *)(v20 - 8);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  unsigned int v185 = (unsigned __int8 *)&v156 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v176 = (unsigned __int8 *)&v156 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  v190 = (unsigned __int8 *)&v156 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v191 = (char *)&v156 - v27;
  unint64_t v28 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for IteratorProtocol,  associated type descriptor for IteratorProtocol.Element);
  uint64_t v31 = type metadata accessor for Optional(0LL, v28, v29, v30);
  uint64_t v180 = *(void *)(v31 - 8);
  uint64_t v181 = (void (*)(void, void, void, void, void))v31;
  MEMORY[0x1895F8858](v31);
  unsigned int v179 = (char *)&v156 - v32;
  uint64_t v33 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)a7,  a5,  v28,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)
                  + 8);
  uint64_t v171 = *(const char **)(*(void *)(v33 + 24) + 16LL);
  unint64_t v170 = swift_getAssociatedTypeWitness( 0LL,  v171,  v28,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v34 = MEMORY[0x1895F8858](v170);
  unsigned __int8 v169 = (char *)&v156 - v35;
  uint64_t v182 = *(void *)(v28 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unsigned int v160 = (char *)&v156 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v161 = (char *)&v156 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v168 = (char *)&v156 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  uint64_t v175 = (char *)&v156 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  uint64_t v46 = (char *)&v156 - v45;
  MEMORY[0x1895F8858](v44);
  unint64_t v186 = (void (*)(char *, uint64_t, ValueMetadata *, ValueMetadata *, unint64_t))((char *)&v156 - v47);
  unint64_t v48 = swift_getAssociatedTypeWitness( 0LL,  a7,  a5,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.ForwardParser);
  uint64_t v166 = *(void *)(v48 - 8);
  uint64_t v49 = MEMORY[0x1895F8858](v48);
  uint64_t v51 = (char *)&v156 - v50;
  MEMORY[0x1895F8858](v49);
  uint64_t v53 = (char *)&v156 - ((v52 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v165 = v54;
  v55 = *(void (**)(void))(v54 + 16);
  unint64_t v196 = v53;
  v55();
  char v158 = a7;
  uint64_t v173 = (ValueMetadata *)a5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a7,  a5,  v48,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  v57 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  v192 = v51;
  uint64_t v193 = (ValueMetadata *)v48;
  v57(v48, AssociatedConformanceWitness);
  uint64_t v58 = 0LL;
  uint64_t v59 = v195;
  uint64_t v195 = a6;
  if (v59 != &type metadata for Unicode.UTF8)
  {
LABEL_2:
    int v60 = 0;
    unint64_t v186 = *(void (**)(char *, uint64_t, ValueMetadata *, ValueMetadata *, unint64_t))(AssociatedConformanceWitness + 32);
    uint64_t v61 = v177;
    uint64_t v62 = v183;
    unsigned int v63 = v190;
    v64 = v191;
    while (1)
    {
      while (1)
      {
        unint64_t v65 = AssociatedConformanceWitness;
        v186(v196, v197, v195, v193, AssociatedConformanceWitness);
        uint64_t v66 = *(void (**)(unsigned __int8 *, char *, uint64_t))(v62 + 16);
        v66(v63, v64, v20);
        if (swift_getEnumCaseMultiPayload(v63, v20))
        {
          uint64_t v67 = *(void (**)(unsigned __int8 *, uint64_t))(v62 + 8);
          v67(v63, v20);
          uint64_t v68 = v187;
          (*(void (**)(char *, uint64_t, uint64_t, ValueMetadata *))(v194 + 56))(v187, 1LL, 1LL, v189);
          (*(void (**)(char *, uint64_t))(v188 + 8))(v68, v61);
          goto LABEL_8;
        }

        uint64_t v69 = v194;
        v70 = *(void (**)(char *, unsigned __int8 *, ValueMetadata *))(v194 + 32);
        uint64_t v71 = v63;
        uint64_t v72 = v187;
        v73 = v189;
        v70(v187, v71, v189);
        v74 = *(void (**)(char *, void, uint64_t, ValueMetadata *))(v69 + 56);
        uint64_t v61 = v177;
        v74(v72, 0LL, 1LL, v73);
        (*(void (**)(char *, uint64_t))(v188 + 8))(v72, v61);
        uint64_t v75 = v176;
        v66(v176, v64, v20);
        uint64_t v62 = v183;
        uint64_t v67 = *(void (**)(unsigned __int8 *, uint64_t))(v183 + 8);
        v67(v75, v20);
LABEL_8:
        uint64_t v76 = v185;
        v64 = v191;
        (*(void (**)(unsigned __int8 *, char *, uint64_t))(v62 + 32))(v185, v191, v20);
        if (swift_getEnumCaseMultiPayload(v76, v20) != 1)
        {
          v67(v185, v20);
          (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, v193);
          (*(void (**)(char *, uint64_t))(v165 + 8))(v196, v197);
          return v58;
        }

        if ((v184 & 1) == 0)
        {
          (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, v193);
          (*(void (**)(char *, uint64_t))(v165 + 8))(v196, v197);
          return 0LL;
        }

        BOOL v77 = __OFADD__(v58++, 1LL);
        if (v77)
        {
          __break(1u);
LABEL_78:
          __break(1u);
LABEL_79:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
        }

        unint64_t AssociatedConformanceWitness = v65;
        v60 |= 0xFFFDu;
        unsigned int v63 = v190;
      }

      uint64_t v78 = v172;
      v70(v172, v75, v73);
      (*(void (**)(char *, uint64_t))(v183 + 8))(v64, v20);
      v70(v174, (unsigned __int8 *)v78, v73);
      if (v173 == &type metadata for Unicode.UTF8) {
        break;
      }
      unsigned int v63 = v190;
      if (v173 != &type metadata for Unicode.UTF16)
      {
        v87 = v174;
        unsigned int v81 = (*((uint64_t (**)(char *))v158 + 11))(v174);
        (*(void (**)(char *, ValueMetadata *))(v194 + 8))(v87, v189);
        if (v81 < 0x10000)
        {
          unsigned int v82 = 16;
        }

        else
        {
          unsigned int v81 = ((v81 + 983040) >> 10) & 0x3FF | ((v81 & 0x3FF) << 16) | 0xDC00D800;
          unsigned int v82 = 32;
        }

        goto LABEL_16;
      }

      uint64_t v62 = v183;
      if (v159 != 5) {
        goto LABEL_81;
      }
      unsigned int v81 = *(_DWORD *)v174;
      unsigned int v82 = v174[4];
      (*(void (**)(void))(v194 + 8))();
LABEL_17:
      uint64_t v83 = v82 >> 4;
      BOOL v77 = __OFADD__(v58, v83);
      v58 += v83;
      if (v77)
      {
        __break(1u);
LABEL_81:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

      if (v82)
      {
        do
        {
          int v84 = (unsigned __int16)v81;
          v81 >>= 16;
          v82 -= 16;
          v60 |= v84;
        }

        while ((_BYTE)v82);
      }

      v64 = v191;
      unint64_t AssociatedConformanceWitness = v65;
    }

    unsigned int v63 = v190;
    if (v73 != &type metadata for _ValidUTF8Buffer) {
      goto LABEL_79;
    }
    unsigned int v79 = *(_DWORD *)v174;
    (*(void (**)(void))(v194 + 8))();
    unsigned int v80 = __clz(v79) >> 3;
    if (v80 == 3)
    {
      unsigned int v81 = (v79 - 1) & 0x7F;
      unsigned int v82 = 16;
LABEL_16:
      uint64_t v62 = v183;
      goto LABEL_17;
    }

    unsigned int v85 = v79 - 16843009;
    int v86 = (v85 << 6) | (v85 >> 8) & 0x3F;
    uint64_t v62 = v183;
    if (v80 == 2)
    {
      unsigned int v81 = (v85 << 6) & 0x7FF | (v85 >> 8) & 0x3F;
      unsigned int v82 = 16;
      goto LABEL_17;
    }

    int v88 = HIWORD(v85) & 0x3F | (v86 << 6);
    if (v80 == 1)
    {
      unsigned int v81 = ((v79 - 16843009) >> 16) & 0x3F | (unsigned __int16)((_WORD)v86 << 6);
    }

    else
    {
      unsigned int v81 = (v88 << 6) & 0x1FFFC0 | HIBYTE(v85) & 0x3F;
      if (v81 >= 0x10000)
      {
        unsigned int v81 = (((v88 << 6) & 0x3C0 | HIBYTE(v85) & 0x3F) << 16) | (((v88 << 6) + 983040) >> 10) & 0x3FF | 0xDC00D800;
        unsigned int v82 = 32;
        goto LABEL_32;
      }
    }

    unsigned int v82 = 16;
LABEL_32:
    uint64_t v61 = v177;
    uint64_t v62 = v183;
    unsigned int v63 = v190;
    goto LABEL_17;
  }

  unint64_t v157 = AssociatedConformanceWitness;
  uint64_t v89 = v171;
  unint64_t v90 = v170;
  unint64_t v91 = swift_getAssociatedConformanceWitness( (uint64_t)v171,  v28,  v170,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v92 = *(void (**)(void *, uint64_t))(v91 + 8);
  uint64_t v93 = v169;
  unint64_t v164 = v91;
  char v163 = v92;
  ((void (*)(void *, uint64_t, unint64_t))v92)(&unk_18180BE68, 256LL, v90);
  int v162 = (void (*)(char *, unint64_t, const char *))*((void *)v89 + 3);
  v162(v93, v28, v89);
  uint64_t v58 = 0LL;
  Kind = (void (*)(uint64_t, ValueMetadata *))a6[1].Kind;
  uint64_t v95 = v180;
  uint64_t v94 = v181;
  while (1)
  {
    char v97 = a6;
    uint64_t v98 = v179;
    Kind(v197, v97);
    v99 = (void *)v182;
    v100 = (void (*)(char *, unint64_t))v99[1];
    v101 = (char *)v186;
    v100((char *)v186, v28);
    v102 = (void (*)(char *, char *, unint64_t))v99[4];
    v102(v101, v98, v28);
    unint64_t v103 = (void (*)(char *, char *, unint64_t))v99[2];
    v103(v46, v101, v28);
    unint64_t v104 = *(uint64_t (**)(unint64_t, uint64_t))(v33 + 64);
    if ((v104(v28, v33) & 1) != 0)
    {
      uint64_t v105 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
      if (v105 < 64) {
        goto LABEL_37;
      }
LABEL_45:
      uint64_t v198 = 128LL;
      char v109 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
      unint64_t v110 = lazy protocol witness table accessor for type Int and conformance Int(v105, v106, v107);
      uint64_t v111 = v175;
      v109(&v198, &type metadata for Int, v110, v28, v33);
      char v112 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v33 + 32) + 8LL)
                                                                         + 16LL))( v46,  v111,  v28);
      v100(v111, v28);
      v113 = v46;
LABEL_48:
      v100(v113, v28);
      a6 = v195;
      uint64_t v95 = v180;
      uint64_t v94 = v181;
      if ((v112 & 1) == 0) {
        goto LABEL_55;
      }
      goto LABEL_38;
    }

    char v108 = v104(v28, v33);
    uint64_t v105 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
    if ((v108 & 1) == 0)
    {
      if (v105 < 64)
      {
LABEL_37:
        uint64_t v96 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
        v100(v46, v28);
        a6 = v195;
        uint64_t v95 = v180;
        uint64_t v94 = v181;
        if (v96 >= 128) {
          goto LABEL_55;
        }
        goto LABEL_38;
      }

      uint64_t v198 = 128LL;
      unint64_t v114 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
      unint64_t v115 = lazy protocol witness table accessor for type Int and conformance Int(v105, v106, v107);
      v116 = v175;
      v114(&v198, &type metadata for Int, v115, v28, v33);
      char v112 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v33 + 32) + 8LL)
                                                                         + 16LL))( v46,  v116,  v28);
      v100(v46, v28);
      v113 = v116;
      goto LABEL_48;
    }

    if (v105 > 64) {
      goto LABEL_45;
    }
    uint64_t v167 = v103;
    v117 = v169;
    v163(&unk_18180BE68, 256LL);
    v118 = v175;
    v162(v117, v28, v171);
    char v119 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v33 + 32) + 8LL) + 16LL))( v46,  v118,  v28);
    v100(v118, v28);
    v120 = v168;
    v102(v168, v46, v28);
    a6 = v195;
    if ((v119 & 1) != 0)
    {
      v100(v120, v28);
      uint64_t v95 = v180;
      uint64_t v94 = v181;
    }

    else
    {
      uint64_t v121 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
      v100(v120, v28);
      uint64_t v95 = v180;
      uint64_t v94 = v181;
      unint64_t v103 = v167;
      if (v121 >= 128) {
        goto LABEL_55;
      }
    }

unint64_t static Unicode.UTF16.transcode<A>(_:from:)( unsigned int *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  if (a3 == &type metadata for Unicode.UTF8)
  {
    if ((ValueMetadata *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)&type metadata for Unicode.UTF8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar) != &type metadata for _ValidUTF8Buffer) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
    }
    unsigned int v5 = *a1;
    unsigned int v6 = __clz(*a1) >> 3;
    if (v6 == 3) {
      return ((_BYTE)v5 - 1) & 0x7F | 0x1000000000LL;
    }
    unsigned int v9 = v5 - 16843009;
    int v10 = (v9 << 6) | (v9 >> 8) & 0x3F;
    int v11 = HIWORD(v9) & 0x3F | (v10 << 6);
    if (((v11 << 6) & 0x1F0000) != 0) {
      uint64_t v12 = (((v11 << 6) + 983040) >> 10) & 0x3FF | (((v11 << 6) & 0x3C0 | HIBYTE(v9) & 0x3F) << 16) | 0x20DC00D800LL;
    }
    else {
      uint64_t v12 = (v11 << 6) & 0x1FFFC0 | HIBYTE(v9) & 0x3F | 0x1000000000LL;
    }
    uint64_t v13 = (unsigned __int16)v11 | 0x1000000000LL;
    if (v6 == 1) {
      uint64_t v12 = v13;
    }
    uint64_t v14 = v10 & 0x7FF | 0x1000000000LL;
    BOOL v15 = v6 == 2;
    goto LABEL_16;
  }

  if (a3 != &type metadata for Unicode.UTF16)
  {
    unsigned int v16 = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a4 + 88))(a1, a3, a4);
    uint64_t v12 = ((v16 & 0x3FF) << 16) | ((v16 + 983040) >> 10) & 0x3FF | 0x20DC00D800LL;
    uint64_t v14 = v16 | 0x1000000000LL;
    BOOL v15 = HIWORD(v16) == 0;
LABEL_16:
    if (v15) {
      return v14;
    }
    else {
      return v12;
    }
  }

  if (*(void *)(*(void *)(swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)&type metadata for Unicode.UTF16,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar)
                             - 8)
                 + 64LL) != 5LL)
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  return *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32);
}

uint64_t static Unicode.UTF16.encodedReplacementCharacter.getter()
{
  return 0x100000FFFDLL;
}

BOOL static Unicode.UTF16._isScalar(_:)(unsigned __int16 a1)
{
  return a1 >> 11 != 27;
}

uint64_t static Unicode.UTF16.decode(_:)(uint64_t result)
{
  if ((result & 0xFF00000000LL) == 0x1000000000LL) {
    return (unsigned __int16)result;
  }
  else {
    return (WORD1(result) & 0x3FF | ((result & 0x3FF) << 10)) + 0x10000;
  }
}

uint64_t static Unicode.UTF16.encode(_:)(unsigned int a1)
{
  uint64_t v1 = 0x1000000000LL;
  LODWORD(v2) = ((a1 & 0x3FF) << 16) | ((a1 + 983040) >> 10) & 0x3FF;
  if (a1 >= 0x10000) {
    uint64_t v2 = v2;
  }
  else {
    uint64_t v2 = a1;
  }
  if (a1 >= 0x10000) {
    uint64_t v1 = 0x20DC00D800LL;
  }
  return v1 | v2;
}

uint64_t Unicode.UTF16.ForwardParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF16.ForwardParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.UTF16.ReverseParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF16.ReverseParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF16( uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 65533;
  *(_BYTE *)(a1 + 4) = 16;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF16(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 4) == 16) {
    return (unsigned __int16)*(_DWORD *)a1;
  }
  else {
    return (HIWORD(*(_DWORD *)a1) & 0x3FF | ((*(_DWORD *)a1 & 0x3FFu) << 10)) + 0x10000;
  }
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF16@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = 0x1000000000LL;
  int v3 = ((result & 0x3FF) << 16) | ((result + 983040) >> 10) & 0x3FF;
  else {
    int v3 = result;
  }
  *(_BYTE *)(a2 + 4) = BYTE4(v2);
  *(_DWORD *)a2 = v2 | v3;
  *(_BYTE *)(a2 + 5) = 0;
  return result;
}

unint64_t protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF16@<X0>( unsigned int *a1@<X0>, ValueMetadata *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  if (a2 == &type metadata for Unicode.UTF8)
  {
    unint64_t result = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)&type metadata for Unicode.UTF8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if ((ValueMetadata *)result != &type metadata for _ValidUTF8Buffer) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
    }
    unsigned int v8 = *a1;
    unsigned int v9 = __clz(*a1) >> 3;
    if (v9 == 3)
    {
      unint64_t v10 = ((_BYTE)v8 - 1) & 0x7F | 0x1000000000LL;
    }

    else
    {
      unsigned int v11 = v8 - 16843009;
      uint64_t v12 = (v11 << 6) & 0x7FF | (v11 >> 8) & 0x3F | 0x1000000000LL;
      int v13 = HIWORD(v11) & 0x3F | (((v11 << 6) | (v11 >> 8) & 0x3F) << 6);
      if (((v13 << 6) & 0x1F0000) != 0) {
        uint64_t v14 = (((v13 << 6) + 983040) >> 10) & 0x3FF | (((v13 << 6) & 0x3C0 | HIBYTE(v11) & 0x3F) << 16) | 0x20DC00D800LL;
      }
      else {
        uint64_t v14 = (v13 << 6) & 0x1FFFC0 | HIBYTE(v11) & 0x3F | 0x1000000000LL;
      }
      if (v9 == 1) {
        uint64_t v14 = (unsigned __int16)v13 | 0x1000000000LL;
      }
      if (v9 == 2) {
        unint64_t v10 = v12;
      }
      else {
        unint64_t v10 = v14;
      }
    }
  }

  else if (a2 == v4)
  {
    unint64_t result = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)a2,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if (*(void *)(*(void *)(result - 8) + 64LL) != 5LL) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }
    unint64_t v10 = *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32);
  }

  else
  {
    unint64_t result = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a3 + 88))(a1, a2, a3);
    unint64_t v10 = result | 0x1000000000LL;
  }

  *(_DWORD *)a4 = v10;
  *(_WORD *)(a4 + 4) = BYTE4(v10);
  return result;
}

BOOL protocol witness for static _UnicodeEncoding._isScalar(_:) in conformance Unicode.UTF16(_WORD *a1)
{
  return (*a1 & 0xF800) != 55296;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF16.ReverseParser._parseMultipleCodeUnits()()
{
  Swift::Bool v1 = (v0 & 0xFC00FC00) == 3623934976LL;
  result.isValid = v1;
  return result;
}

unint64_t Unicode.UTF16.ReverseParser._bufferedScalar(bitCount:)(unint64_t result, int a2)
{
  int v2 = 32 - result;
  if ((v2 & 0xFFFFFF00) != 0)
  {
    __break(1u);
  }

  else
  {
    HIDWORD(v3) = a2;
    LODWORD(v3) = a2;
    return ((v3 >> 16) >> v2) | ((unint64_t)result << 32);
  }

  return result;
}

uint64_t static UInt8.- infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result = a1 - a2;
  if ((result & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  return result;
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF16.ReverseParser@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v8)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  BOOL v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t (*v22)();
  void v23[4];
  if (*(_BYTE *)(v4 + 4))
  {
    if ((*(_DWORD *)v4 & 0xF800) == 0xD800)
    {
      unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      uint64_t result = v8(v23, a2, a3);
      goto LABEL_8;
    }

    uint64_t v21 = (unsigned __int16)*(_DWORD *)v4;
    lazy protocol witness table accessor for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser( a1,  a2,  a3);
    uint64_t v22 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    uint64_t result = (void *)((uint64_t (*)(void *, void))v22)(v23, 0LL);
    unsigned int v11 = 0;
    unint64_t v10 = v21 | 0x1000000000LL;
  }

  else
  {
    unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    uint64_t result = v8(v23, a2, a3);
    if ((v23[0] & 0x10000LL) != 0)
    {
LABEL_3:
      unint64_t v10 = 0LL;
      unsigned int v11 = 2;
    }

    else if ((v23[0] & 0xF800) == 0xD800)
    {
      uint64_t v12 = *(unsigned __int8 *)(v4 + 4);
      if (v12 >= 0x20) {
LABEL_25:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
      *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-65535 << v12) - 1) | (LOWORD(v23[0]) << v12);
      *(_BYTE *)(v4 + 4) = v12 + 16;
      while (1)
      {
        uint64_t result = v8(v23, a2, a3);
LABEL_8:
        if ((v23[0] & 0x10000LL) != 0) {
          break;
        }
        int v13 = *(unsigned __int8 *)(v4 + 4);
        if (v13 > 0x1F) {
          goto LABEL_25;
        }
        uint64_t v14 = *(_DWORD *)v4 & ((-65535 << v13) - 1) | (LOWORD(v23[0]) << v13);
        *(_DWORD *)uint64_t v4 = v14;
        BOOL v15 = v13 + 16;
        *(_BYTE *)(v4 + 4) = v13 + 16;
        if (v13 >= 0x10) {
          goto LABEL_15;
        }
      }

      BOOL v15 = *(_BYTE *)(v4 + 4);
      if (!v15) {
        goto LABEL_3;
      }
      uint64_t v14 = *(_DWORD *)v4;
LABEL_15:
      unsigned int v16 = v14 & 0xFC00FC00;
      if ((v14 & 0xFC00FC00) == 0xD800DC00) {
        uint64_t v17 = 32;
      }
      else {
        uint64_t v17 = 16;
      }
      *(_BYTE *)(v4 + 4) = v15 - v17;
      uint64_t v18 = v16 == -671032320;
      if (v16 == -671032320) {
        uint64_t v19 = 32LL;
      }
      else {
        uint64_t v19 = 16LL;
      }
      *(_DWORD *)uint64_t v4 = (unint64_t)v14 >> v19;
      if (v18)
      {
        unsigned int v11 = 0;
        HIDWORD(v20) = v14;
        LODWORD(v20) = v14;
        unint64_t v10 = (v20 >> 16) | (unint64_t)(v19 << 32);
      }

      else
      {
        uint64_t result = (void *)specialized numericCast<A, B>(_:)(0x10uLL);
        if (!(_BYTE)result) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
        }
        unsigned int v11 = 1;
        unint64_t v10 = 0x10u / result;
      }
    }

    else
    {
      unsigned int v11 = 0;
      unint64_t v10 = LOWORD(v23[0]) | 0x1000000000LL;
    }
  }

  *(void *)a4 = v10;
  *(_BYTE *)(a4 + 8) = v11;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF16.ReverseParser()
{
  if ((*v0 & 0xFC00FC00) == 0xD800DC00) {
    int v1 = 0x2000;
  }
  else {
    int v1 = 4096;
  }
  return v1 | ((*v0 & 0xFC00FC00) == -671032320);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF16.ReverseParser@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  int v3 = 32 - result;
  if ((v3 & 0xFFFFFF00) != 0)
  {
    __break(1u);
  }

  else
  {
    HIDWORD(v4) = *v2;
    LODWORD(v4) = *v2;
    *(_DWORD *)a2 = (v4 >> 16) >> v3;
    *(_BYTE *)(a2 + 4) = result;
  }

  return result;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF16.ForwardParser._parseMultipleCodeUnits()()
{
  Swift::Bool v1 = (v0 & 0xFC00FC00) == 3691042816LL;
  result.isValid = v1;
  return result;
}

unint64_t Unicode.UTF16.ForwardParser._bufferedScalar(bitCount:)(unsigned __int8 a1, unsigned int a2)
{
  return a2 | ((unint64_t)a1 << 32);
}

void *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF16.ForwardParser@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *(*v8)(void *__return_ptr, uint64_t, uint64_t);
  void *result;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  char v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)();
  void v24[4];
  if (*(_BYTE *)(v4 + 4))
  {
    if ((*(_DWORD *)v4 & 0xF800) == 0xD800)
    {
      unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      Swift::tuple_isValid_Bool_bitCount_UInt8 result = v8(v24, a2, a3);
      goto LABEL_8;
    }

    uint64_t v22 = (unsigned __int16)*(_DWORD *)v4;
    lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser( a1,  a2,  a3);
    uint64_t v23 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    Swift::tuple_isValid_Bool_bitCount_UInt8 result = (void *)((uint64_t (*)(void *, void))v23)(v24, 0LL);
    unsigned int v11 = 0;
    unint64_t v10 = v22 | 0x1000000000LL;
  }

  else
  {
    unsigned int v8 = *(void *(**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    Swift::tuple_isValid_Bool_bitCount_UInt8 result = v8(v24, a2, a3);
    if ((v24[0] & 0x10000LL) != 0)
    {
LABEL_3:
      unint64_t v10 = 0LL;
      unsigned int v11 = 2;
    }

    else if ((v24[0] & 0xF800) == 0xD800)
    {
      uint64_t v12 = *(unsigned __int8 *)(v4 + 4);
      if (v12 >= 0x20) {
LABEL_25:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
      *(_DWORD *)uint64_t v4 = *(_DWORD *)v4 & ((-65535 << v12) - 1) | (LOWORD(v24[0]) << v12);
      *(_BYTE *)(v4 + 4) = v12 + 16;
      while (1)
      {
        Swift::tuple_isValid_Bool_bitCount_UInt8 result = v8(v24, a2, a3);
LABEL_8:
        if ((v24[0] & 0x10000LL) != 0) {
          break;
        }
        int v13 = *(unsigned __int8 *)(v4 + 4);
        if (v13 > 0x1F) {
          goto LABEL_25;
        }
        uint64_t v14 = *(_DWORD *)v4 & ((-65535 << v13) - 1) | (LOWORD(v24[0]) << v13);
        *(_DWORD *)uint64_t v4 = v14;
        BOOL v15 = v13 + 16;
        *(_BYTE *)(v4 + 4) = v13 + 16;
        if (v13 >= 0x10) {
          goto LABEL_15;
        }
      }

      BOOL v15 = *(_BYTE *)(v4 + 4);
      if (!v15) {
        goto LABEL_3;
      }
      uint64_t v14 = *(_DWORD *)v4;
LABEL_15:
      unsigned int v16 = v14 & 0xFC00FC00;
      if ((v14 & 0xFC00FC00) == 0xDC00D800) {
        uint64_t v17 = 32;
      }
      else {
        uint64_t v17 = 16;
      }
      uint64_t v18 = v15 - v17;
      uint64_t v19 = v14;
      *(_BYTE *)(v4 + 4) = v18;
      uint64_t v20 = v16 == -603924480;
      if (v16 == -603924480) {
        uint64_t v21 = 32LL;
      }
      else {
        uint64_t v21 = 16LL;
      }
      *(_DWORD *)uint64_t v4 = (unint64_t)v14 >> v21;
      if (v20)
      {
        unsigned int v11 = 0;
        unint64_t v10 = v19 | (v21 << 32);
      }

      else
      {
        Swift::tuple_isValid_Bool_bitCount_UInt8 result = (void *)specialized numericCast<A, B>(_:)(0x10uLL);
        if (!(_BYTE)result) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
        }
        unsigned int v11 = 1;
        unint64_t v10 = 0x10u / result;
      }
    }

    else
    {
      unsigned int v11 = 0;
      unint64_t v10 = LOWORD(v24[0]) | 0x1000000000LL;
    }
  }

  *(void *)a4 = v10;
  *(_BYTE *)(a4 + 8) = v11;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF16.ForwardParser()
{
  if ((*v0 & 0xFC00FC00) == 0xDC00D800) {
    int v1 = 0x2000;
  }
  else {
    int v1 = 4096;
  }
  return v1 | ((*v0 & 0xFC00FC00) == -603924480);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF16.ForwardParser@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *v2;
  *(_BYTE *)(a2 + 4) = result;
  return result;
}

Swift::Int _MergeError.hashValue.getter()
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance _MergeError()
{
  return Hasher._finalize()();
}

uint64_t static Unicode.UTF32.encodedReplacementCharacter.getter()
{
  return 65533LL;
}

uint64_t static Unicode.UTF32._isScalar(_:)()
{
  return 1LL;
}

uint64_t static Unicode.UTF32.encode(_:)(uint64_t result)
{
  return result;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF32( _DWORD *a1@<X8>)
{
  *a1 = 65533;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF32( unsigned int *a1)
{
  return *a1;
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF32@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = result;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

uint64_t protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF32@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result = specialized static _UnicodeEncoding.transcode<A>(_:from:)(a1, a2, a3, a4);
  *(_DWORD *)a5 = result;
  *(_BYTE *)(a5 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t Unicode.UTF32.Parser.parseScalar<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a3 + 16))(&v5, a2, a3);
  if ((v5 & 0x100000000LL) != 0) {
    return 0LL;
  }
  else {
    return v5;
  }
}

uint64_t protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF32.Parser@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = Unicode.UTF32.Parser.parseScalar<A>(from:)(a1, a2, a3);
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6;
  return result;
}

uint64_t static UnicodeDecodingResult.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (a2 & 0x100000000LL) == 0 && (_DWORD)a1 == (_DWORD)a2;
  unsigned int v4 = BYTE4(a2) & ((_DWORD)a2 != 0);
  if (!(_DWORD)a1) {
    unsigned int v4 = BYTE4(a2) & ((_DWORD)a2 == 0);
  }
  if ((a1 & 0x100000000LL) != 0) {
    return v4;
  }
  else {
    return v3;
  }
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance UnicodeDecodingResult( uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 4);
  unsigned int v3 = (*(_DWORD *)a1 == *(_DWORD *)a2) & ~v2;
  if (*(_DWORD *)a2) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = *(unsigned __int8 *)(a2 + 4);
  }
  if (!*(_DWORD *)a2) {
    unsigned int v2 = 0;
  }
  if (*(_DWORD *)a1) {
    unsigned int v5 = v2;
  }
  else {
    unsigned int v5 = v4;
  }
  if (*(_BYTE *)(a1 + 4) == 1) {
    return v5;
  }
  else {
    return v3;
  }
}

uint64_t static UnicodeCodec._nullCodeUnitOffset(in:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static UnicodeCodec._nullCodeUnitOffset(in:)(a1, a2, a3);
}

{
  const char *v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t (*v20)(void, void);
  void (*v21)(char *, uint64_t, unint64_t *);
  uint64_t v22;
  uint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  void (*v29)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v30;
  char v31;
  void (*v32)(char *, unint64_t *);
  char *v33;
  uint64_t v34;
  unint64_t v35;
  const char *v36;
  unint64_t AssociatedConformanceWitness;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, unint64_t *);
  void (*v43)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  const char *v48;
  uint64_t (*v49)(void, void);
  uint64_t v50;
  void (*v51)(char *, uint64_t, unint64_t *);
  uint64_t v52;
  unsigned int v5 = *(const char **)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  a2,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.CodeUnit);
  uint64_t v7 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)
                 + 8);
  unint64_t v48 = *(const char **)(*(void *)(v7 + 24) + 16LL);
  uint64_t v47 = swift_getAssociatedTypeWitness( 0LL,  v48,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v47);
  uint64_t v46 = (char *)&v45 - v8;
  unsigned int v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  unint64_t v10 = *(v9 - 1);
  unsigned int v11 = MEMORY[0x1895F8858](v9);
  int v13 = (char *)&v45 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  unsigned int v16 = (char *)&v45 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v45 - v17;
  uint64_t v19 = 0LL;
  uint64_t v20 = *(uint64_t (**)(void, void))(v7 + 64);
  uint64_t v21 = *(void (**)(char *, uint64_t, unint64_t *))(v10 + 16);
  uint64_t v50 = *(void *)(v10 + 72);
  uint64_t v51 = v21;
  uint64_t v49 = v20;
  uint64_t v45 = v13;
  v21((char *)&v45 - v17, a1, v9);
  while (1)
  {
    if ((v20(v9, v7) & 1) != 0)
    {
      uint64_t v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v9, v7);
      if (v25 < 64)
      {
        uint64_t v22 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v9, v7);
        uint64_t result = (*(uint64_t (**)(char *, unint64_t *))(v10 + 8))(v18, v9);
        if (!v22) {
          return v19;
        }
        goto LABEL_3;
      }

      goto LABEL_10;
    }

    unint64_t v28 = v20(v9, v7);
    uint64_t v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v9, v7);
    if ((v28 & 1) != 0)
    {
      if (v25 > 64)
      {
LABEL_10:
        uint64_t v52 = 0LL;
        uint64_t v29 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v7 + 96);
        uint64_t v30 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
        v29(&v52, &type metadata for Int, v30, v9, v7);
        uint64_t v31 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v7 + 16) + 8LL)
                                                                            + 8LL))( v18,  v16,  v9);
        uint64_t v32 = *(void (**)(char *, unint64_t *))(v10 + 8);
        v32(v16, v9);
        uint64_t v33 = v18;
        goto LABEL_18;
      }

      uint64_t v35 = v47;
      uint64_t v36 = v48;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v48,  (uint64_t)v9,  v47,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v38 = v10;
      uint64_t v39 = v46;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v35,  AssociatedConformanceWitness);
      uint64_t v40 = v39;
      unint64_t v10 = v38;
      uint64_t v41 = v45;
      (*((void (**)(char *, unint64_t *, const char *))v36 + 3))(v40, v9, v36);
      LOBYTE(v35) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v7 + 32)
                                                                                              + 8LL)
                                                                                  + 32LL))( v18,  v16,  v9);
      uint64_t v42 = *(void (**)(char *, unint64_t *))(v10 + 8);
      v42(v16, v9);
      (*(void (**)(char *, char *, unint64_t *))(v10 + 32))(v41, v18, v9);
      if ((v35 & 1) == 0)
      {
        uint64_t result = ((uint64_t (*)(char *, unint64_t *))v42)(v41, v9);
        uint64_t v20 = v49;
        goto LABEL_3;
      }

      uint64_t v34 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v9, v7);
      uint64_t result = ((uint64_t (*)(char *, unint64_t *))v42)(v41, v9);
LABEL_16:
      uint64_t v20 = v49;
      if (!v34) {
        return v19;
      }
      goto LABEL_3;
    }

    if (v25 < 64)
    {
      uint64_t v34 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v9, v7);
      uint64_t result = (*(uint64_t (**)(char *, unint64_t *))(v10 + 8))(v18, v9);
      goto LABEL_16;
    }

    uint64_t v52 = 0LL;
    uint64_t v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v7 + 96);
    uint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
    v43(&v52, &type metadata for Int, v44, v9, v7);
    uint64_t v31 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v7 + 16) + 8LL) + 8LL))( v18,  v16,  v9);
    uint64_t v32 = *(void (**)(char *, unint64_t *))(v10 + 8);
    v32(v18, v9);
    uint64_t v33 = v16;
LABEL_18:
    uint64_t result = ((uint64_t (*)(char *, unint64_t *))v32)(v33, v9);
    uint64_t v20 = v49;
    if ((v31 & 1) != 0) {
      return v19;
    }
LABEL_3:
    a1 += v50;
    if (__OFADD__(v19++, 1LL)) {
      break;
    }
    v51(v18, a1, v9);
  }

  __break(1u);
  return result;
}

uint64_t Unicode.UTF8.init()()
{
  return 0LL;
}

unint64_t Unicode.UTF8.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v8)(void *__return_ptr, uint64_t, uint64_t);
  char v9;
  unsigned int v10;
  unsigned __int8 v11;
  unsigned int v12;
  unsigned int v13;
  char v14;
  unsigned int v15;
  char v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t (*v23)();
  void v24[4];
  int v25;
  char v26;
  LODWORD(v6) = *v3;
  unsigned int v7 = *((unsigned __int8 *)v3 + 4);
  uint64_t v25 = *v3;
  uint64_t v26 = v7;
  if (v7)
  {
    if ((v6 & 0x80) == 0)
    {
      lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser( a1,  a2,  a3);
      uint64_t v23 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(void *, void))v23)(v24, 0LL);
      uint64_t v12 = (v6 + 1);
      goto LABEL_31;
    }

    unsigned int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v24, a2, a3);
LABEL_7:
    if ((v24[0] & 0x100LL) != 0)
    {
      int v13 = v6;
      uint64_t v14 = v7;
    }

    else
    {
      if (v7 >= 0x20) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
      }
      int v13 = v6 & ((-255 << v7) - 1) | (LOBYTE(v24[0]) << v7);
      uint64_t v14 = v7 + 8;
      if (v7 <= 0x17)
      {
        v8(v24, a2, a3);
        if ((v24[0] & 0x100LL) == 0)
        {
          int v13 = v13 & ((-65280 << v7) - 1) | (LOBYTE(v24[0]) << v14);
          uint64_t v14 = v7 + 16;
          if (v7 <= 0xF)
          {
            v8(v24, a2, a3);
            if ((v24[0] & 0x100LL) == 0)
            {
              int v13 = v13 & ((-16711680 << v7) - 1) | (LOBYTE(v24[0]) << v14);
              uint64_t v14 = v7 + 24;
              if (v7 <= 7)
              {
                v8(v24, a2, a3);
                if ((v24[0] & 0x100LL) == 0)
                {
                  int v13 = v13 & ((0x1000000 << v7) - 1) | (LOBYTE(v24[0]) << v14);
                  uint64_t v14 = v7 + 32;
                }
              }
            }
          }
        }
      }
    }

    if ((v13 & 0xC0E0) == 0x80C0)
    {
      if ((v13 & 0x1E) != 0)
      {
        BOOL v15 = 16;
        unsigned int v16 = 1;
LABEL_29:
        unint64_t v10 = 1;
        unint64_t v6 = (unint64_t)v13 >> (v15 & 0x38);
        uint64_t v25 = v6;
        unsigned int v9 = v14 - v15;
        uint64_t v26 = v14 - v15;
        if ((v16 & 1) == 0)
        {
          unsigned int v11 = 1;
          goto LABEL_38;
        }

        uint64_t v12 = ((1 << ((v15 >> 1) & 0x1C) << ((v15 >> 1) & 0x1C)) - 1) & (v13 + 16843009);
        goto LABEL_31;
      }
    }

    else if ((v13 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v13 & 0x200F) != 0 && (v13 & 0x200F) != 0x200D)
      {
        BOOL v15 = 24;
        unsigned int v16 = 1;
        goto LABEL_29;
      }
    }

    else if ((v13 & 0xC0C0C0F8) == 0x808080F0 && (v13 & 0x3007) != 0 && __rev16(v13 & 0x3007) <= 0x400)
    {
      BOOL v15 = 32;
      unsigned int v16 = 1;
      goto LABEL_29;
    }

    uint64_t v17 = Unicode.UTF8.ForwardParser._invalidLength()();
    unsigned int v16 = 0;
    BOOL v15 = 8 * v17;
    goto LABEL_29;
  }

  unsigned int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
  v8(v24, a2, a3);
  if ((v24[0] & 0x100LL) != 0)
  {
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    unsigned int v11 = 1;
    goto LABEL_38;
  }

  if ((v24[0] & 0x80) != 0)
  {
    LODWORD(v6) = v6 & 0xFFFFFF00 | LOBYTE(v24[0]);
    unsigned int v7 = 8;
    v8(v24, a2, a3);
    goto LABEL_7;
  }

  uint64_t v12 = LOBYTE(v24[0]) + 1;
LABEL_31:
  unsigned int v11 = 0;
  uint64_t v18 = 4LL - (__clz(v12) >> 3);
  uint64_t v19 = ((v12 - 65793) >> 2) & 0xFC0 | ((v12 - 65793) >> 16) & 0x3F | (((v12 - 65793) & 0xF) << 12);
  uint64_t v20 = (((v12 - 257) & 0x1F) << 6) | ((v12 - 257) >> 8) & 0x3F;
  uint64_t v21 = ((v12 - 16843009) >> 10) & 0xFC0 | ((v12 - 16843009) >> 24) & 0x3F | ((((v12 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v12 - 16843009) & 7) << 18);
  unint64_t v10 = v12 - 1;
  if (v18 != 1) {
    unint64_t v10 = v21;
  }
  if (v18 == 2) {
    unint64_t v10 = v20;
  }
  if (v18 == 3) {
    unint64_t v10 = v19;
  }
  LODWORD(v6) = v25;
  unsigned int v9 = v26;
LABEL_38:
  *unsigned int v3 = v6;
  *((_BYTE *)v3 + 4) = v9;
  LOBYTE(v24[0]) = v11;
  return v10 | ((unint64_t)v11 << 32);
}

unint64_t static Unicode.UTF8._decodeOne(_:)(int a1)
{
  if ((a1 & 0x80) == 0)
  {
    unsigned __int8 v2 = 0;
    unsigned int v3 = a1;
    LOBYTE(v4) = 1;
    return ((unint64_t)v4 << 40) | ((unint64_t)v2 << 32) | v3;
  }

  if ((a1 & 0xC0E0) == 0x80C0)
  {
    if ((a1 & 0x1E) != 0)
    {
      LODWORD(v4) = 16;
      char v5 = 1;
      goto LABEL_15;
    }
  }

  else if ((a1 & 0xC0C0F0) == 0x8080E0)
  {
    if ((a1 & 0x200F) != 0 && (a1 & 0x200F) != 0x200D)
    {
      LODWORD(v4) = 24;
      char v5 = 1;
      goto LABEL_15;
    }
  }

  else if ((a1 & 0xC0C0C0F8) == 0x808080F0 && (a1 & 0x3007) != 0 && __rev16(a1 & 0x3007) <= 0x400)
  {
    LODWORD(v4) = 32;
    char v5 = 1;
    goto LABEL_15;
  }

  int v6 = Unicode.UTF8.ForwardParser._invalidLength()();
  char v5 = 0;
  LODWORD(v4) = 8 * v6;
LABEL_15:
  if ((v5 & 1) != 0)
  {
    unsigned __int8 v2 = 0;
    unsigned int v7 = ((1 << ((v4 >> 1) & 0x1C) << ((v4 >> 1) & 0x1C)) - 1) & (a1 + 16843009);
    uint64_t v4 = 4LL - (__clz(v7) >> 3);
    unsigned int v8 = ((v7 - 65793) >> 2) & 0xFC0 | ((v7 - 65793) >> 16) & 0x3F | (((v7 - 65793) & 0xF) << 12);
    unsigned int v9 = (((v7 - 257) & 0x1F) << 6) | ((v7 - 257) >> 8) & 0x3F;
    unsigned int v10 = ((v7 - 16843009) >> 10) & 0xFC0 | ((v7 - 16843009) >> 24) & 0x3F | ((((v7 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v7 - 16843009) & 7) << 18);
    unsigned int v3 = v7 - 1;
    if (v4 != 1) {
      unsigned int v3 = v10;
    }
    if (v4 == 2) {
      unsigned int v3 = v9;
    }
    if (v4 == 3) {
      unsigned int v3 = v8;
    }
  }

  else
  {
    unsigned int v3 = 0;
    LOBYTE(v4) = v4 >> 3;
    unsigned __int8 v2 = 1;
  }

  return ((unint64_t)v4 << 40) | ((unint64_t)v2 << 32) | v3;
}

uint64_t static Unicode.UTF8.encode(_:into:)(unsigned int a1, uint64_t (*a2)(void))
{
  if (a1 < 0x80) {
    return a2();
  }
  int v4 = (a1 & 0x3F) << 8;
  int v5 = (v4 | (a1 >> 6) & 0x3F) << 8;
  int v6 = (((v5 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
  int v7 = (v5 | (a1 >> 12)) + 8487393;
  if (HIWORD(a1)) {
    int v7 = v6;
  }
  unsigned int v8 = a1 <= 0x7FF ? (v4 | (a1 >> 6)) + 33217 : v7;
  ((void (*)(void))a2)(v8 - 1);
  uint64_t result = ((uint64_t (*)(void))a2)((v8 >> 8) - 1);
  if (v8 >= 0x10000)
  {
    uint64_t result = ((uint64_t (*)(void))a2)(HIWORD(v8) - 1);
    if (HIBYTE(v8)) {
      return a2();
    }
  }

  return result;
}

unint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF8( uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v9)(void *__return_ptr, uint64_t, uint64_t);
  char v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t (*v24)();
  void v25[4];
  int v26;
  char v27;
  int v4 = v3;
  LODWORD(v7) = *v3;
  unsigned int v8 = *((unsigned __int8 *)v3 + 4);
  uint64_t v26 = *v3;
  uint64_t v27 = v8;
  if (v8)
  {
    if ((v7 & 0x80) == 0)
    {
      lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser( a1,  a2,  a3);
      uint64_t v24 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(void *, void))v24)(v25, 0LL);
      int v13 = (v7 + 1);
      goto LABEL_31;
    }

    unsigned int v9 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v9(v25, a2, a3);
  }

  else
  {
    unsigned int v9 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v9(v25, a2, a3);
    if ((v25[0] & 0x100LL) != 0)
    {
      unsigned int v10 = 0;
      unsigned int v11 = 0;
      uint64_t v12 = 1;
      goto LABEL_38;
    }

    if ((v25[0] & 0x80) == 0)
    {
      int v13 = LOBYTE(v25[0]) + 1;
LABEL_31:
      uint64_t v12 = 0;
      uint64_t v19 = 4LL - (__clz(v13) >> 3);
      uint64_t v20 = ((v13 - 65793) >> 2) & 0xFC0 | ((v13 - 65793) >> 16) & 0x3F | (((v13 - 65793) & 0xF) << 12);
      uint64_t v21 = (((v13 - 257) & 0x1F) << 6) | ((v13 - 257) >> 8) & 0x3F;
      uint64_t v22 = ((v13 - 16843009) >> 10) & 0xFC0 | ((v13 - 16843009) >> 24) & 0x3F | ((((v13 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v13 - 16843009) & 7) << 18);
      unsigned int v11 = v13 - 1;
      if (v19 != 1) {
        unsigned int v11 = v22;
      }
      if (v19 == 2) {
        unsigned int v11 = v21;
      }
      if (v19 == 3) {
        unsigned int v11 = v20;
      }
      LODWORD(v7) = v26;
      unsigned int v10 = v27;
      goto LABEL_38;
    }

    LODWORD(v7) = v7 & 0xFFFFFF00 | LOBYTE(v25[0]);
    unsigned int v8 = 8;
    v9(v25, a2, a3);
  }

  if ((v25[0] & 0x100LL) != 0)
  {
    uint64_t v14 = v7;
    BOOL v15 = v8;
  }

  else
  {
    if (v8 >= 0x20) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    }
    uint64_t v14 = v7 & ((-255 << v8) - 1) | (LOBYTE(v25[0]) << v8);
    BOOL v15 = v8 + 8;
    if (v8 <= 0x17)
    {
      v9(v25, a2, a3);
      if ((v25[0] & 0x100LL) == 0)
      {
        uint64_t v14 = v14 & ((-65280 << v8) - 1) | (LOBYTE(v25[0]) << v15);
        BOOL v15 = v8 + 16;
        if (v8 <= 0xF)
        {
          v9(v25, a2, a3);
          if ((v25[0] & 0x100LL) == 0)
          {
            uint64_t v14 = v14 & ((-16711680 << v8) - 1) | (LOBYTE(v25[0]) << v15);
            BOOL v15 = v8 + 24;
            if (v8 <= 7)
            {
              v9(v25, a2, a3);
              if ((v25[0] & 0x100LL) == 0)
              {
                uint64_t v14 = v14 & ((0x1000000 << v8) - 1) | (LOBYTE(v25[0]) << v15);
                BOOL v15 = v8 + 32;
              }
            }
          }
        }
      }
    }
  }

  if ((v14 & 0xC0E0) == 0x80C0)
  {
    if ((v14 & 0x1E) != 0)
    {
      unsigned int v16 = 16;
      uint64_t v17 = 1;
      goto LABEL_29;
    }
  }

  else if ((v14 & 0xC0C0F0) == 0x8080E0)
  {
    if ((v14 & 0x200F) != 0 && (v14 & 0x200F) != 0x200D)
    {
      unsigned int v16 = 24;
      uint64_t v17 = 1;
      goto LABEL_29;
    }
  }

  else if ((v14 & 0xC0C0C0F8) == 0x808080F0 && (v14 & 0x3007) != 0 && __rev16(v14 & 0x3007) <= 0x400)
  {
    unsigned int v16 = 32;
    uint64_t v17 = 1;
    goto LABEL_29;
  }

  uint64_t v18 = Unicode.UTF8.ForwardParser._invalidLength()();
  uint64_t v17 = 0;
  unsigned int v16 = 8 * v18;
LABEL_29:
  unint64_t v7 = (unint64_t)v14 >> (v16 & 0x38);
  uint64_t v26 = v7;
  unsigned int v10 = v15 - v16;
  uint64_t v27 = v15 - v16;
  if ((v17 & 1) != 0)
  {
    int v13 = ((1 << ((v16 >> 1) & 0x1C) << ((v16 >> 1) & 0x1C)) - 1) & (v14 + 16843009);
    goto LABEL_31;
  }

  if (!specialized numericCast<A, B>(_:)(8uLL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
  }
  unsigned int v11 = 1;
  uint64_t v12 = 1;
LABEL_38:
  *int v4 = v7;
  *((_BYTE *)v4 + 4) = v10;
  LOBYTE(v25[0]) = v12;
  return v11 | ((unint64_t)v12 << 32);
}

uint64_t protocol witness for static UnicodeCodec.encode(_:into:) in conformance Unicode.UTF8( unsigned int a1, uint64_t (*a2)(char *))
{
  if (a1 >= 0x80)
  {
    int v5 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v6 = (v5 | (a1 >> 6) & 0x3F) << 8;
      int v7 = (((v6 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      int v8 = (v6 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v3 = v7;
      }
      else {
        unsigned int v3 = v8;
      }
    }

    else
    {
      unsigned int v3 = (v5 | (a1 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v3 = a1 + 1;
  }

  char v12 = v3 - 1;
  uint64_t result = a2(&v12);
  if (v3 >= 0x100)
  {
    char v11 = BYTE1(v3) - 1;
    uint64_t result = a2(&v11);
    if (HIWORD(v3))
    {
      char v10 = BYTE2(v3) - 1;
      uint64_t result = a2(&v10);
      if (HIBYTE(v3))
      {
        char v9 = HIBYTE(v3) - 1;
        return a2(&v9);
      }
    }
  }

  return result;
}

uint64_t Unicode.UTF16.init()()
{
  return 0LL;
}

unint64_t Unicode.UTF16.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v8)(void *__return_ptr, uint64_t, uint64_t);
  char v9;
  unsigned int v10;
  unsigned __int8 v11;
  char v12;
  unsigned int v13;
  char v14;
  BOOL v15;
  char v16;
  unint64_t v17;
  uint64_t (*v19)();
  void v20[4];
  unsigned int v21;
  char v22;
  unsigned int v6 = *(_DWORD *)v3;
  unsigned int v7 = *(unsigned __int8 *)(v3 + 4);
  uint64_t v21 = *(_DWORD *)v3;
  uint64_t v22 = v7;
  if (v7)
  {
    if ((v6 & 0xF800) != 0xD800)
    {
      lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser( a1,  a2,  a3);
      uint64_t v19 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(void *, void))v19)(v20, 0LL);
      char v11 = 0;
      char v10 = (unsigned __int16)v6;
      unsigned int v6 = v21;
      char v9 = v22;
      goto LABEL_23;
    }

    int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v20, a2, a3);
  }

  else
  {
    int v8 = *(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v20, a2, a3);
    if ((v20[0] & 0x10000LL) != 0)
    {
      char v9 = 0;
      char v10 = 0;
      char v11 = 1;
      goto LABEL_23;
    }

    char v10 = LOWORD(v20[0]);
    if ((v20[0] & 0xF800) != 0xD800)
    {
      char v9 = 0;
      char v11 = 0;
      goto LABEL_23;
    }

    unsigned int v6 = v6 & 0xFFFF0000 | LOWORD(v20[0]);
    unsigned int v7 = 16;
    v8(v20, a2, a3);
  }

  if ((v20[0] & 0x10000LL) != 0)
  {
    char v12 = v7;
  }

  else
  {
    if (v7 >= 0x20) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    }
    unsigned int v6 = v6 & ((-65535 << v7) - 1) | (LOWORD(v20[0]) << v7);
    char v12 = v7 + 16;
    if (v7 <= 0xF)
    {
      v8(v20, a2, a3);
      if ((v20[0] & 0x10000LL) == 0)
      {
        unsigned int v6 = v6 & ((0x10000 << v7) - 1) | (LOWORD(v20[0]) << v12);
        char v12 = v7 + 32;
      }
    }
  }

  int v13 = v6 & 0xFC00FC00;
  if ((v6 & 0xFC00FC00) == 0xDC00D800) {
    uint64_t v14 = 32;
  }
  else {
    uint64_t v14 = 16;
  }
  char v9 = v12 - v14;
  BOOL v15 = v13 == -603924480;
  if (v13 == -603924480) {
    unsigned int v16 = 32;
  }
  else {
    unsigned int v16 = 16;
  }
  uint64_t v17 = (unint64_t)v6 >> v16;
  char v10 = (HIWORD(v6) & 0x3FF | ((v6 & 0x3FF) << 10)) + 0x10000;
  if (v15)
  {
    char v11 = 0;
  }

  else
  {
    char v10 = 1;
    char v11 = 1;
  }

  unsigned int v6 = v17;
LABEL_23:
  *(_DWORD *)uint64_t v3 = v6;
  *(_BYTE *)(v3 + 4) = v9;
  LOBYTE(v20[0]) = v11;
  return v10 | ((unint64_t)v11 << 32);
}

uint64_t Unicode.UTF16._decodeOne<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = Unicode.UTF16.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t static Unicode.UTF16.encode(_:into:)(unsigned int a1, uint64_t (*a2)(void))
{
  if (a1 >= 0x10000) {
    ((void (*)(void))a2)(((a1 + 983040) >> 10) & 0x3FF | ((a1 & 0x3FF) << 16) | 0xDC00D800);
  }
  return a2();
}

uint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF16( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = Unicode.UTF16.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

_WORD *protocol witness for static UnicodeCodec._nullCodeUnitOffset(in:) in conformance Unicode.UTF16( _WORD *result)
{
  if (!*result) {
    return 0LL;
  }
  for (uint64_t i = 0LL; ; ++i)
  {
    uint64_t v2 = i + 1;
    if (__OFADD__(i, 1LL)) {
      break;
    }
    if (!result[v2]) {
      return (_WORD *)v2;
    }
  }

  __break(1u);
  return result;
}

unint64_t Unicode.UTF32.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a3 + 16))(&v8, a2, a3);
  uint64_t v3 = v8;
  BOOL v4 = WORD1(v8) > 0x10u || v8 >> 11 == 27;
  char v5 = v4;
  if (v4) {
    uint64_t v3 = 1LL;
  }
  if ((v8 & 0x100000000LL) != 0)
  {
    uint64_t v3 = 0LL;
    unsigned __int8 v6 = 1;
  }

  else
  {
    unsigned __int8 v6 = v5;
  }

  return v3 | ((unint64_t)v6 << 32);
}

uint64_t static Unicode.UTF32.encode(_:into:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

uint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF32( uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = Unicode.UTF32.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t protocol witness for static UnicodeCodec.encode(_:into:) in conformance Unicode.UTF32( int a1, uint64_t (*a2)(int *))
{
  int v3 = a1;
  return a2(&v3);
}

_DWORD *protocol witness for static UnicodeCodec._nullCodeUnitOffset(in:) in conformance Unicode.UTF32( _DWORD *result)
{
  if (!*result) {
    return 0LL;
  }
  for (uint64_t i = 0LL; ; ++i)
  {
    uint64_t v2 = i + 1;
    if (__OFADD__(i, 1LL)) {
      break;
    }
    if (!result[v2]) {
      return (_DWORD *)v2;
    }
  }

  __break(1u);
  return result;
}

uint64_t protocol witness for static _StringElement._toUTF16CodeUnit(_:) in conformance UInt16( unsigned __int16 *a1)
{
  return *a1;
}

uint64_t protocol witness for static _StringElement._fromUTF16CodeUnit(_:) in conformance UInt16@<X0>( uint64_t result@<X0>, _WORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t static UInt8._toUTF16CodeUnit(_:)(uint64_t result)
{
  return result;
}

BOOL hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(unsigned int a1)
{
  int32x4_t v1 = vdupq_n_s32(a1);
  uint64_t v2 = 1LL;
  if ((vmaxv_u8((uint8x8_t)vmovn_s16( vuzp1q_s16( (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v1, (int32x4_t)xmmword_1817FFF40),  (uint32x4_t)xmmword_1817FFF60),  (int16x8_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v1, (int32x4_t)xmmword_1817FFF50),  (uint32x4_t)xmmword_1817FFF70)))) & 1) == 0) {
    return a1 < 0x300 || a1 - 65281 < 0x9D;
  }
  return v2;
}

Swift::String::Index __swiftcall _StringGuts._slowRoundDownToNearestCharacter(_:)(Swift::String::Index a1)
{
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  int64_t v6 = a1._rawBits >> 16;
  if (a1._rawBits < 0x20000)
  {
    Swift::Int v9 = 0LL;
    goto LABEL_15;
  }

  if ((v2 & 0x1000000000000000LL) != 0) {
    goto LABEL_43;
  }
  if ((v2 & 0x2000000000000000LL) != 0)
  {
    uint64_t v23 = v1;
    uint64_t v24 = v2 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = (char *)&v23 + v6;
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0)
    {
      unsigned int v7 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      unsigned int v7 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
      if (!v7) {
LABEL_48:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    }

    uint64_t v8 = &v7[v6];
  }

  int v10 = *((unsigned __int16 *)v8 - 1);
  if (v10 != 2573 && (v10 & 0x80808080) == 0)
  {
    Swift::Int v9 = v6 - 1;
    if (__OFSUB__(v6, 1LL)) {
      goto LABEL_45;
    }
    goto LABEL_15;
  }

  while (1)
  {
LABEL_43:
    Swift::Int v22 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v6);
    Swift::Int v9 = v6 - v22;
    if (__OFSUB__(v6, v22))
    {
LABEL_45:
      __break(1u);
      goto LABEL_46;
    }

uint64_t _StringGuts._slowRoundDownToNearestCharacter(_:in:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  char v7 = a2;
  unint64_t v8 = a1;
  Swift::Int v9 = a1 >> 16;
  uint64_t v10 = _StringGuts._opaqueCharacterStride(endingAt:in:)(a1 >> 16, a2 >> 16, a3, a4, a5);
  Swift::Int v11 = v9 - v10;
  if (__OFSUB__(v9, v10)) {
    goto LABEL_29;
  }
  if ((a5 & 0x1000000000000000LL) != 0) {
    goto LABEL_26;
  }
  if ((a5 & 0x2000000000000000LL) != 0)
  {
    v22[0] = a4;
    v22[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    if (v11 + 1 != (HIBYTE(a5) & 0xF))
    {
      int v14 = *(unsigned __int16 *)((char *)v22 + v11);
      goto LABEL_11;
    }

    goto LABEL_16;
  }

  if ((a4 & 0x1000000000000000LL) == 0) {
    goto LABEL_30;
  }
  char v12 = (char *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v13 = a4 & 0xFFFFFFFFFFFFLL;
  while (1)
  {
    if (v11 + 1 != v13)
    {
      if (!v12) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      }
      int v14 = *(unsigned __int16 *)&v12[v11];
LABEL_11:
      if (v14 == 2573 || (v14 & 0x8080) != 0) {
        break;
      }
    }

Swift::Int __swiftcall _StringGuts._opaqueComplexCharacterStride(startingAt:)(Swift::Int startingAt)
{
  if ((v2 & 0x1000000000000000LL) == 0)
  {
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      Swift::Int v10 = HIBYTE(v2) & 0xF;
      v15[0] = v1;
      v15[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (v10 > startingAt)
      {
        v11._value = _decodeScalar(_:startingAt:)((uint64_t)v15, v1, startingAt);
        for (Swift::Int i = v12 + startingAt; i < v10; v11._value = v13)
        {
          Swift::UInt32 v13 = *((unsigned __int8 *)v15 + i);
          if (*((char *)v15 + i) < 0) {
            __asm { BR              X9 }
          }

          if (_GraphemeBreakingState.shouldBreak(between:and:)( v11,  (Swift::Unicode::Scalar)*((unsigned __int8 *)v15 + i)))
          {
            break;
          }

          ++i;
        }

        return i - startingAt;
      }
    }

    else
    {
      if ((v1 & 0x1000000000000000LL) != 0)
      {
        uint64_t v4 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        Swift::Int v5 = v1 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v4 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v1, v2);
        Swift::Int v5 = v1;
      }

      LODWORD(v15[0]) = 0;
      if (v5 > startingAt)
      {
        v6._value = _decodeScalar(_:startingAt:)((uint64_t)v4, v1, startingAt);
        for (Swift::Int i = v7 + startingAt; i < v5; v6._value = v9)
        {
          Swift::UInt32 v9 = v4[i];
          if ((char)v4[i] < 0) {
            __asm { BR              X9 }
          }

          if (_GraphemeBreakingState.shouldBreak(between:and:)(v6, (Swift::Unicode::Scalar)v4[i])) {
            break;
          }
          ++i;
        }

        return i - startingAt;
      }
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGraphemeBreaking.swift",  34LL,  2,  0x280uLL,  0);
  }

  return _StringGuts._foreignOpaqueCharacterStride(startingAt:)(startingAt, v1, v2);
}

Swift::UInt64 _StringGuts._foreignOpaqueCharacterStride(startingAt:)( uint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((a3 & 0x2000000000000000LL) != 0) {
    uint64_t v3 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  }
  int v38 = 0;
  if (v3 <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGraphemeBreaking.swift",  34LL,  2,  0x280uLL,  0);
  }
  v7._Swift::UInt64 rawBits = a1 << 16;
  v8._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  uint64_t v35 = a1;
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    v12._value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v8._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
    v34._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits;
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v34)._rawBits;
  }

  else
  {
    Swift::UInt64 v10 = v8._rawBits >> 16;
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v36 = a2;
      uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
      v12._value = _decodeScalar(_:startingAt:)((uint64_t)&v36, v9._rawBits, v10);
      v13._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits >> 16;
      uint64_t v36 = a2;
      uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
      int v15 = *((unsigned __int8 *)&v36 + v13._rawBits);
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0) {
        id v11 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        id v11 = _StringObject.sharedUTF8.getter(a2, a3);
      }
      v12._value = _decodeScalar(_:startingAt:)((uint64_t)v11, v9._rawBits, v10);
      v13._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits >> 16;
      if ((a2 & 0x1000000000000000LL) != 0) {
        int v14 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        int v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      int v15 = v14[v13._rawBits];
    }

    int v16 = (char)v15;
    unsigned int v17 = __clz(v15 ^ 0xFF) - 24;
    if (v16 >= 0) {
      LOBYTE(v17) = 1;
    }
    Swift::UInt64 rawBits = ((v13._rawBits + v17) << 16) | 5;
  }

  do
  {
    Swift::UInt64 v22 = rawBits >> 16;
    if (rawBits >> 16 >= v3) {
      break;
    }
    v23._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL))._rawBits;
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      v19._value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v23._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
      v20._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL))._rawBits;
      Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v20)._rawBits;
    }

    else
    {
      Swift::UInt64 v25 = v23._rawBits >> 16;
      if ((a3 & 0x2000000000000000LL) != 0)
      {
        uint64_t v36 = a2;
        uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
        v19._value = _decodeScalar(_:startingAt:)((uint64_t)&v36, v24._rawBits, v25);
        Swift::UInt64 v29 = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL))._rawBits >> 16;
        uint64_t v36 = a2;
        uint64_t v37 = a3 & 0xFFFFFFFFFFFFFFLL;
        int v30 = *((unsigned __int8 *)&v36 + v29);
      }

      else
      {
        id v26 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a2 & 0x1000000000000000LL) == 0) {
          id v26 = _StringObject.sharedUTF8.getter(a2, a3);
        }
        v19._value = _decodeScalar(_:startingAt:)((uint64_t)v26, v24._rawBits, v25);
        v27._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL))._rawBits;
        unint64_t v28 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a2 & 0x1000000000000000LL) == 0) {
          unint64_t v28 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
        }
        Swift::UInt64 v29 = v27._rawBits >> 16;
        int v30 = v28[v27._rawBits >> 16];
      }

      int v31 = (char)v30;
      unsigned int v32 = __clz(v30 ^ 0xFF) - 24;
      if (v31 >= 0) {
        LOBYTE(v32) = 1;
      }
      Swift::UInt64 rawBits = ((v29 + v32) << 16) | 5;
    }

    Swift::Bool v21 = _GraphemeBreakingState.shouldBreak(between:and:)(v12, v19);
    v12._value = v19._value;
  }

  while (!v21);
  return v22 - v35;
}

Swift::Int __swiftcall _StringGuts._opaqueComplexCharacterStride(endingAt:)(Swift::Int endingAt)
{
  if ((v2 & 0x1000000000000000LL) == 0)
  {
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      v22[0] = v1;
      v22[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (endingAt > 0)
      {
        Swift::Int v6 = endingAt - 1;
        if ((*((_BYTE *)v22 + endingAt - 1) & 0xC0) == 0x80)
        {
          Swift::Int v13 = endingAt;
          do
            int v14 = v21[v13--] & 0xC0;
          while (v14 == 128);
          Swift::Int v6 = v13 - 1;
        }

        unsigned int v15 = _decodeScalar(_:startingAt:)((uint64_t)v22, v1, v6);
        if (v6 >= 1)
        {
          unsigned int v16 = v15;
          do
          {
            uint64_t v17 = v6 - 1;
            unsigned int v18 = *((unsigned __int8 *)v22 + v6 - 1);
            if ((v18 & 0xC0) == 0x80)
            {
              Swift::Int v19 = v6;
              do
                unsigned int v18 = v21[v19--];
              while ((v18 & 0xC0) == 0x80);
              uint64_t v17 = v19 - 1;
            }

            if ((v18 & 0x80) != 0) {
              __asm { BR              X9 }
            }

            Swift::Int v6 = v17;
            unsigned int v16 = v18;
          }

          while (v17 > 0);
        }

        return endingAt - v6;
      }
    }

    else if ((v1 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v5 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (endingAt >= 1)
      {
LABEL_5:
        Swift::Int v6 = endingAt;
        do
          int v7 = v5[--v6] & 0xC0;
        while (v7 == 128);
        unsigned int v8 = _decodeScalar(_:startingAt:)((uint64_t)v5, v1, v6);
        if (v6 >= 1)
        {
          unsigned int v9 = v8;
          do
          {
            uint64_t v10 = v6 - 1;
            unsigned int v11 = v5[v6 - 1];
            if ((v11 & 0xC0) == 0x80)
            {
              Swift::Int v12 = v6;
              do
                unsigned int v11 = v5[v12-- - 2];
              while ((v11 & 0xC0) == 0x80);
              uint64_t v10 = v12 - 1;
            }

            if ((v11 & 0x80) != 0) {
              __asm { BR              X9 }
            }

            Swift::Int v6 = v10;
            unsigned int v9 = v11;
          }

          while (v10 > 0);
        }

        return endingAt - v6;
      }
    }

    else
    {
      Swift::Int v5 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
      if (endingAt >= 1) {
        goto LABEL_5;
      }
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGraphemeBreaking.swift",  34LL,  2,  0x2A1uLL,  0);
  }

  return _StringGuts._foreignOpaqueCharacterStride(endingAt:)(endingAt, v1, v2, v3);
}

Swift::UInt64 _StringGuts._foreignOpaqueCharacterStride(endingAt:)( uint64_t a1, uint64_t a2, unint64_t a3, char *a4)
{
  if (a1 < 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGraphemeBreaking.swift",  34LL,  2,  0x2A1uLL,  0);
  }
  v8._Swift::UInt64 rawBits = a1 << 16;
  swift_bridgeObjectRetain(a3, a2, a3, a4);
  v9._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v8)._rawBits;
  if (!(v9._rawBits >> 14)) {
    goto LABEL_46;
  }
  Swift::UInt64 rawBits = v9._rawBits;
  if ((a3 & 0x1000000000000000LL) == 0)
  {
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v45 = a2;
      uint64_t v46 = a3 & 0xFFFFFFFFFFFFFFLL;
      unsigned int v15 = (char *)&v45 + (v9._rawBits >> 16);
      if ((*(v15 - 1) & 0xC0) == 0x80)
      {
        uint64_t v16 = 0LL;
        uint64_t v17 = v15 - 2;
        do
          int v18 = v17[v16--] & 0xC0;
        while (v18 == 128);
        uint64_t v14 = 1 - v16;
      }

      else
      {
        uint64_t v14 = 1LL;
      }
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0)
      {
        unsigned int v11 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        unsigned int v11 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
        if (!v11)
        {
LABEL_49:
          swift_bridgeObjectRelease(a3);
          __break(1u);
          goto LABEL_50;
        }
      }

      uint64_t v12 = 0LL;
      do
        int v13 = v11[(rawBits >> 16) - 1 + v12--] & 0xC0;
      while (v13 == 128);
      uint64_t v14 = -v12;
    }

    unint64_t v4 = (rawBits - (v14 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
    Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)v4)._rawBits >> 16;
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v45 = a2;
      uint64_t v46 = a3 & 0xFFFFFFFFFFFFFFLL;
      Swift::String::Index v20 = &v45;
      goto LABEL_19;
    }

    if ((a2 & 0x1000000000000000LL) != 0)
    {
      Swift::String::Index v20 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
LABEL_19:
      unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v20, v19._rawBits, rawBits);
      goto LABEL_20;
    }

uint64_t closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 1) {
    return 0LL;
  }
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v5)._rawBits;
    v20._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)rawBits)._rawBits;
    LODWORD(result) = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v20._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
  }

  else
  {
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v24 = a2;
      uint64_t v25 = a3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v12 = (char *)&v24 + (v5._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = v12 - 2;
        do
          int v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        uint64_t v10 = 1 - v13;
      }

      else
      {
        uint64_t v10 = 1LL;
      }
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0)
      {
        id v6 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        Swift::UInt64 v21 = v5._rawBits;
        id v6 = _StringObject.sharedUTF8.getter(a2, a3);
        v5._Swift::UInt64 rawBits = v21;
      }

      uint64_t v7 = 0LL;
      Swift::UInt64 v8 = (Swift::UInt64)v6 + (v5._rawBits >> 16) - 1;
      do
        int v9 = *(_BYTE *)(v8 + v7--) & 0xC0;
      while (v9 == 128);
      uint64_t v10 = -v7;
    }

    v17._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)((v5._rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000LL | 5))._rawBits >> 16;
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v24 = a2;
      uint64_t v25 = a3 & 0xFFFFFFFFFFFFFFLL;
      int v18 = &v24;
    }

    else if ((a2 & 0x1000000000000000LL) != 0)
    {
      int v18 = (void *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v22 = a3;
      Swift::UInt64 v23 = v17._rawBits;
      int v18 = _StringObject.sharedUTF8.getter(a2, v22);
      v17._Swift::UInt64 rawBits = v23;
    }

    LODWORD(result) = _decodeScalar(_:startingAt:)((uint64_t)v18, v16._rawBits, v17._rawBits);
  }

  return result;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _GraphemeBreakingState( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2 | a1[1] ^ a2[1] | a1[2] ^ a2[2] | a2[3] ^ a1[3]) & 1) == 0;
}

uint64_t _GraphemeBreakingState.description.getter(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  LODWORD(v4) = a1;
  uint64_t v5 = 91LL;
  unint64_t v6 = 0xE100000000000000LL;
  uint64_t v115 = 91LL;
  unint64_t v116 = 0xE100000000000000LL;
  if ((a1 & 1) == 0)
  {
    if ((a1 & 0x100) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v7 = HIBYTE(v6) & 3;
    if (v7)
    {
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      uint64_t v5 = (69LL << (8 * v7)) | ((-255 << (8 * v7)) - 1) & v5;
      unint64_t v6 = (v7 << 56) - 0x1F00000000000000LL;
      uint64_t v115 = v5;
      unint64_t v116 = v6;
      if ((v4 & 0x10000) == 0) {
        goto LABEL_14;
      }
    }

    else
    {
      uint64_t v5 = 69LL;
      uint64_t v115 = 69LL;
      unint64_t v116 = 0xE100000000000000LL;
      swift_bridgeObjectRelease(v6);
      unint64_t v6 = 0xE100000000000000LL;
      if ((v4 & 0x10000) == 0) {
        goto LABEL_14;
      }
    }

    goto LABEL_10;
  }

  swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
  uint64_t v5 = 22107LL;
  unint64_t v6 = 0xE200000000000000LL;
  uint64_t v115 = 22107LL;
  unint64_t v116 = 0xE200000000000000LL;
  if ((v4 & 0x100) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v4 & 0x10000) == 0) {
    goto LABEL_14;
  }
LABEL_10:
  unint64_t v8 = HIBYTE(v6) & 0xF;
  if (!v8 && (v6 & 0x2000000000000000LL) != 0)
  {
    uint64_t v115 = 73LL;
    unint64_t v116 = 0xE100000000000000LL;
    uint64_t v9 = v6;
    goto LABEL_13;
  }

  if ((v6 & 0x2000000000000000LL) == 0 || v8 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, a3, a4);
    if ((v6 & 0x1000000000000000LL) != 0) {
      goto LABEL_110;
    }
    if ((v6 & 0x2000000000000000LL) != 0) {
      uint64_t v54 = HIBYTE(v6) & 0xF;
    }
    else {
      uint64_t v54 = v5;
    }
    BOOL v27 = __OFADD__(v54, 1LL);
    int64_t v55 = v54 + 1;
    if (!v27) {
      goto LABEL_65;
    }
LABEL_112:
    __break(1u);
    goto LABEL_113;
  }

  uint64_t v20 = 8 * (HIBYTE(v6) & 7);
  uint64_t v21 = (-255LL << v20) - 1;
  uint64_t v22 = 73LL << v20;
  unint64_t v23 = v22 | v21 & v6;
  uint64_t v24 = v22 | v21 & v5;
  if (v8 >= 8) {
    unint64_t v25 = v23;
  }
  else {
    unint64_t v25 = v6;
  }
  if (v8 < 8) {
    uint64_t v5 = v24;
  }
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  unint64_t v26 = 0xA000000000000000LL;
  if (((v5 | v25) & 0x80808080808080LL) == 0) {
    unint64_t v26 = 0xE000000000000000LL;
  }
  uint64_t v115 = v5;
  unint64_t v116 = (v26 & 0xFF00000000000000LL | (v8 << 56) | v25 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL;
  unint64_t v10 = v116;
  if ((v4 & 0x1000000) != 0) {
    goto LABEL_15;
  }
  while (1)
  {
LABEL_68:
    unint64_t v58 = HIBYTE(v10) & 0xF;
    if ((v10 & 0x2000000000000000LL) != 0) {
      uint64_t v59 = HIBYTE(v10) & 0xF;
    }
    else {
      uint64_t v59 = v5 & 0xFFFFFFFFFFFFLL;
    }
    if (!v59 && (v5 & ~v10 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v10);
      return 93LL;
    }

    if ((v10 & 0x2000000000000000LL) != 0 && v58 != 15) {
      break;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, a3, a4);
    if ((v10 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v110 = String.UTF8View._foreignCount()();
      int64_t v61 = v110 + 1;
      if (!__OFADD__(v110, 1LL))
      {
LABEL_81:
        if ((v5 & ~v10 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v62 = _StringGuts.nativeUnusedCapacity.getter(v5, v10);
          if ((v63 & 1) != 0)
          {
LABEL_114:
            unint64_t v113 = 258LL;
            goto LABEL_115;
          }

          BOOL v65 = (v10 & 0x2000000000000000LL) == 0 && v62 > 0;
          if (v61 <= 15 && !v65)
          {
LABEL_92:
            swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
            swift_bridgeObjectRetain(v10, v66, v67, v68);
            unint64_t v69 = _StringGuts._convertedToSmall()(v5, v10);
            unint64_t v71 = v70;
            swift_bridgeObjectRelease(v10);
            v72._Swift::UInt64 rawBits = 1LL;
            v73._Swift::UInt64 rawBits = 65537LL;
            v74._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v72, v73, 0x5DuLL, 0xE100000000000000LL);
            if (v74._rawBits < 0x10000) {
              v74._rawBits |= 3;
            }
            unint64_t v76 = specialized String.init(_:)(v74, v75, 0x5DuLL, 0xE100000000000000LL);
            unint64_t v78 = v77;
            swift_bridgeObjectRelease(0xE100000000000000LL);
            unint64_t v79 = _StringGuts._convertedToSmall()(v76, v78);
            unint64_t v81 = v80;
            swift_bridgeObjectRelease(v78);
            unint64_t v82 = specialized _SmallString.init(_:appending:)(v69, v71, v79, v81);
            if ((v83 & 1) == 0)
            {
              uint64_t v60 = v82;
              swift_bridgeObjectRelease(0xE100000000000000LL);
              swift_bridgeObjectRelease(v116);
              return v60;
            }

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _GraphemeBreakingState( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (v4[3]) {
    int v5 = 0x1000000;
  }
  else {
    int v5 = 0;
  }
  if (v4[2]) {
    int v6 = 0x10000;
  }
  else {
    int v6 = 0;
  }
  if (v4[1]) {
    int v7 = 256;
  }
  else {
    int v7 = 0;
  }
  return _GraphemeBreakingState.description.getter(v7 | *v4 | v6 | v5, a2, a3, a4);
}

uint64_t static Unicode._CharacterRecognizer.quickBreak(between:and:)(unsigned int a1, unsigned int a2)
{
  if (a1 == 13 && a2 == 10) {
    return 0LL;
  }
  if (hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(a1)
    && hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(a2))
  {
    return 1LL;
  }

  return 2LL;
}

Swift::Unicode::_CharacterRecognizer __swiftcall Unicode._CharacterRecognizer.init()()
{
  void *v0 = 0LL;
  return result;
}

Swift::Bool __swiftcall Unicode._CharacterRecognizer.hasBreak(before:)(Swift::Unicode::Scalar before)
{
  unint64_t v2 = v1;
  v5._unsigned int value = v1->_value;
  int64_t v4 = v1 + 1;
  Swift::Bool v6 = _GraphemeBreakingState.shouldBreak(between:and:)(v5, before);
  if (v6) {
    v4->_unsigned int value = 0;
  }
  v2->_unsigned int value = before._value;
  return v6;
}

uint64_t Unicode._CharacterRecognizer._firstBreak(inUncheckedUnsafeUTF8Buffer:startingAt:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 >= a2) {
    return 0LL;
  }
  uint64_t v4 = a3;
  v7._unsigned int value = *v3;
  while (1)
  {
    Swift::UInt32 v8 = *(unsigned __int8 *)(a1 + v4);
    if (*(char *)(a1 + v4) < 0) {
      __asm { BR              X9 }
    }

    ++v4;
    v7._unsigned int value = v8;
    if (v4 >= a2)
    {
      uint64_t v4 = 0LL;
      *uint64_t v3 = v8;
      return v4;
    }
  }

  *uint64_t v3 = v8;
  v3[1] = 0;
  return v4;
}

uint64_t Unicode._CharacterRecognizer.description.getter()
{
  Swift::UInt64 _ = *(unsigned int *)v0;
  LODWORD(v1) = v0[4];
  LODWORD(v2) = v0[5];
  int v3 = v0[6];
  LODWORD(v4) = v0[7];
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(6LL);
  uint64_t v9 = v5;
  unint64_t v10 = v6;
  v288._uint64_t countAndFlagsBits = v5;
  v288._unint64_t object = (void *)v6;
  uint64_t v11 = HIBYTE(v6) & 0xF;
  uint64_t v12 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000LL) != 0) {
    uint64_t v13 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v13 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (v13 || (v5 & ~v6 & 0x2000000000000000LL) != 0)
  {
    if ((v6 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v42 = 0xA000000000000000LL;
      if (!(v10 & 0x80808080808080LL | v9 & 0x8080808080808080LL)) {
        unint64_t v42 = 0xE000000000000000LL;
      }
      v288._uint64_t countAndFlagsBits = v9;
      v288._unint64_t object = (void *)(v42 & 0xFF00000000000000LL | (v11 << 56) | v10 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_29;
    }

    swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v7, v8);
    Swift::Int v14 = v12;
    if ((v10 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v14 = String.UTF8View._foreignCount()();
      if ((v9 & ~v10 & 0x2000000000000000LL) == 0) {
        goto LABEL_26;
      }
    }

    else if ((v9 & ~v10 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_26;
    }

    if (swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v15 = _StringGuts.nativeUnusedCapacity.getter(v9, v10);
      if ((v16 & 1) == 0)
      {
        if (v14 <= 15 && (v15 & 0x8000000000000000LL) != 0)
        {
LABEL_13:
          swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
          if ((v10 & 0x1000000000000000LL) == 0)
          {
            if ((v9 & 0x1000000000000000LL) != 0)
            {
              uint64_t v20 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }

            else
            {
              uint64_t v20 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v10);
              uint64_t v12 = v17;
            }

            swift_bridgeObjectRetain(v10, v17, v18, v19);
            closure #1 in _StringGuts._convertedToSmall()(v20, v12, &v287);
            swift_bridgeObjectRelease(v10);
            unint64_t v22 = *((void *)&v287 + 1);
            unint64_t v21 = v287;
            goto LABEL_17;
          }

          goto LABEL_255;
        }

uint64_t _ValidUTF8Buffer._biasedBits.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _ValidUTF8Buffer.Iterator._biasedBits.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer.Iterator._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt8_optional __swiftcall _ValidUTF8Buffer.Iterator.next()()
{
  unsigned int v1 = *v0;
  if (*v0)
  {
    unsigned __int8 v2 = v1 - 1;
    unsigned int *v0 = v1 >> 8;
  }

  else
  {
    unsigned __int8 v2 = 0;
  }

  return (Swift::UInt8_optional)(v2 | ((v1 == 0) << 8));
}

void protocol witness for IteratorProtocol.next() in conformance _ValidUTF8Buffer.Iterator(_BYTE *a1@<X8>)
{
  unsigned int v2 = *v1;
  if (*v1)
  {
    char v3 = v2 - 1;
    *unsigned int v1 = v2 >> 8;
  }

  else
  {
    char v3 = 0;
  }

  *a1 = v3;
  a1[1] = v2 == 0;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _ValidUTF8Buffer.Iterator()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _ValidUTF8Buffer.Iterator( unsigned int *a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _ValidUTF8Buffer.Iterator@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5( a1,  a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _ValidUTF8Buffer()
{
  return 4LL - (__clz(*v0) >> 3);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance _ValidUTF8Buffer()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t _ValidUTF8Buffer.Index._biasedBits.setter(uint64_t result)
{
  *unsigned int v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer.Index._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

BOOL static _ValidUTF8Buffer.Index.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

BOOL static _ValidUTF8Buffer.Index.< infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a2 < a1;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _ValidUTF8Buffer.Index( _DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _ValidUTF8Buffer.Index( _DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _ValidUTF8Buffer.Index( _DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

uint64_t _ValidUTF8Buffer.endIndex.getter()
{
  return 0LL;
}

uint64_t static Int.&>> infix(_:_:)(uint64_t a1, char a2)
{
  return a1 >> a2;
}

BOOL _ValidUTF8Buffer.isEmpty.getter(int a1)
{
  return a1 == 0;
}

Swift::_ValidUTF8Buffer::Index __swiftcall _ValidUTF8Buffer.index(after:)(Swift::_ValidUTF8Buffer::Index after)
{
  if (!after._biasedBits) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x69uLL,  0);
  }
  return (Swift::_ValidUTF8Buffer::Index)(after._biasedBits >> 8);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _ValidUTF8Buffer( _BYTE *a1, _BYTE *a2))()
{
  *a1 = *a2 - 1;
  return EnumeratedSequence._base.modify;
}

_DWORD *protocol witness for Collection.subscript.getter in conformance _ValidUTF8Buffer@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int v3 = *v2;
  if (*v2 < *result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  int v4 = result[1];
  *a2 = *result;
  a2[1] = v4;
  a2[2] = v3;
  return result;
}

void protocol witness for Collection.indices.getter in conformance _ValidUTF8Buffer(uint64_t a1@<X8>)
{
  unsigned int v2 = *v1;
  *(_DWORD *)a1 = *v1;
  *(void *)(a1 + 4) = v2;
}

void protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance _ValidUTF8Buffer( uint64_t a1@<X8>)
{
  *(_WORD *)(a1 + 4) = 256;
  *(_DWORD *)a1 = 0;
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer( a1,  a2,  (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply,  a3);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer( a1,  a2,  a3,  a4,  (uint64_t)closure #1 in Sequence<>.contains(_:)specialized partial apply,  (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply);
}

Swift::Int __swiftcall _ValidUTF8Buffer.distance(from:to:)( Swift::_ValidUTF8Buffer::Index from, Swift::_ValidUTF8Buffer::Index to)
{
  if (from._biasedBits)
  {
    if (!v2) {
LABEL_6:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x82uLL,  0);
    unsigned int v3 = v2;
    while (v3 != from._biasedBits)
    {
      BOOL v4 = v3 >= 0x100;
      v3 >>= 8;
      if (!v4) {
        goto LABEL_6;
      }
    }
  }

  if (to._biasedBits)
  {
    if (!v2) {
LABEL_11:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x83uLL,  0);
    while (v2 != to._biasedBits)
    {
      BOOL v4 = v2 >= 0x100;
      v2 >>= 8;
      if (!v4) {
        goto LABEL_11;
      }
    }
  }

  return (uint64_t)(__clz(from._biasedBits) - (unint64_t)__clz(to._biasedBits)) >> 3;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance _ValidUTF8Buffer( unsigned int *a1, uint64_t *a2)
{
  return specialized Collection._failEarlyRangeCheck(_:bounds:)(*a1, *a2);
}

_DWORD *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance _ValidUTF8Buffer( _DWORD *result, _DWORD *a2)
{
  if (*a2 < *result || *result < a2[1]) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }
  return result;
}

{
  if (*a2 < *result || result[1] < a2[1]) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  return result;
}

_DWORD *protocol witness for Collection.index(after:) in conformance _ValidUTF8Buffer@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  if (!*result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x69uLL,  0);
  }
  *a2 = *result >> 8;
  return result;
}

_DWORD *protocol witness for Collection.formIndex(after:) in conformance _ValidUTF8Buffer(_DWORD *result)
{
  if (!*result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x69uLL,  0);
  }
  *result >>= 8;
  return result;
}

Swift::_ValidUTF8Buffer::Index __swiftcall _ValidUTF8Buffer.index(before:)(Swift::_ValidUTF8Buffer::Index before)
{
  char v2 = __clz(before._biasedBits);
  if ((v2 & 0x38) == 0x20) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x77uLL,  0);
  }
  return (Swift::_ValidUTF8Buffer::Index)(v1 >> (~v2 & 0x18));
}

Swift::_ValidUTF8Buffer::Index protocol witness for BidirectionalCollection.index(before:) in conformance _ValidUTF8Buffer@<W0>( Swift::_ValidUTF8Buffer::Index *a1@<X0>, Swift::_ValidUTF8Buffer::Index *a2@<X8>)
{
  result._biasedBits = _ValidUTF8Buffer.index(before:)((Swift::_ValidUTF8Buffer::Index)a1->_biasedBits)._biasedBits;
  a2->_biasedBits = result._biasedBits;
  return result;
}

unsigned int *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _ValidUTF8Buffer( unsigned int *result)
{
  char v2 = __clz(*result);
  if ((v2 & 0x38) == 0x20) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x77uLL,  0);
  }
  *Swift::_ValidUTF8Buffer::Index result = *v1 >> (~v2 & 0x18);
  return result;
}

Swift::Bool __swiftcall _ValidUTF8Buffer._isValid(_:)(Swift::_ValidUTF8Buffer::Index a1)
{
  if (a1._biasedBits)
  {
    if (v1)
    {
      do
      {
        Swift::Bool result = v1 == a1._biasedBits;
        if (v1 == a1._biasedBits) {
          break;
        }
        BOOL v4 = v1 > 0xFF;
        v1 >>= 8;
      }

      while (v4);
    }

    else
    {
      return 0;
    }
  }

  else
  {
    return 1;
  }

  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, unsigned int (*a3)(int *)@<X5>, unsigned int *a4@<X8>)
{
  unsigned int v8 = *(_DWORD *)result;
  uint64_t v9 = *v4;
  if ((_DWORD)v9)
  {
    unsigned int v18 = v9;
    MEMORY[0x1895F8858](result);
    uint64_t v17 = &v18;
    Swift::Bool result = specialized Sequence.contains(where:)(v10, (uint64_t)v16, v9 | (v9 << 32), 0);
    if ((result & 1) == 0)
    {
      LODWORD(v17) = 0;
      unint64_t v15 = 130LL;
      goto LABEL_14;
    }
  }

  if (v8)
  {
    unsigned int v18 = v8;
    MEMORY[0x1895F8858](result);
    uint64_t v17 = &v18;
    Swift::Bool result = specialized Sequence.contains(where:)(a3, (uint64_t)v16, v9 | (v9 << 32), 0);
    if ((result & 1) == 0)
    {
      LODWORD(v17) = 0;
      unint64_t v15 = 131LL;
LABEL_14:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  v15,  (int)v17);
    }
  }

  unint64_t v11 = __clz(v9);
  uint64_t v12 = __clz(v8);
  BOOL v13 = __OFADD__(a2, (uint64_t)(v11 - v12) >> 3);
  unint64_t v14 = a2 + ((uint64_t)(v11 - v12) >> 3);
  if (v13)
  {
    __break(1u);
    goto LABEL_10;
  }

  if ((v14 & 0x8000000000000000LL) != 0)
  {
LABEL_10:
    LODWORD(v17) = 0;
    unint64_t v15 = 142LL;
    goto LABEL_14;
  }

  if (4 - (v11 >> 3) < v14)
  {
    LODWORD(v17) = 0;
    unint64_t v15 = 143LL;
    goto LABEL_14;
  }

  *a4 = v9 >> (4 * (v14 & 7)) >> (4 * (v14 & 7));
  return result;
}

unint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance _ValidUTF8Buffer@<X0>( unsigned int *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3, *v4);
  *(_DWORD *)a4 = result;
  *(_BYTE *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int (*a6)(int *))
{
  unsigned int v8 = *(_DWORD *)a1;
  unsigned int v9 = *a2;
  unint64_t v10 = *v6 | ((unint64_t)*v6 << 32);
  if (*(_DWORD *)a1)
  {
    unsigned int v16 = *(_DWORD *)a1;
    MEMORY[0x1895F8858](a1);
    unint64_t v15 = &v16;
    a1 = specialized Sequence.contains(where:)(v11, (uint64_t)v14, v10, 0);
    if ((a1 & 1) == 0)
    {
      LODWORD(v15) = 0;
      unint64_t v13 = 130LL;
      goto LABEL_8;
    }
  }

  if (v9)
  {
    unsigned int v16 = v9;
    MEMORY[0x1895F8858](a1);
    unint64_t v15 = &v16;
    if ((specialized Sequence.contains(where:)(a6, (uint64_t)v14, v10, 0) & 1) == 0)
    {
      LODWORD(v15) = 0;
      unint64_t v13 = 131LL;
LABEL_8:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  v13,  (int)v15);
    }
  }

  return (uint64_t)(__clz(v8) - (unint64_t)__clz(v9)) >> 3;
}

Swift::_ValidUTF8Buffer __swiftcall _ValidUTF8Buffer.init()()
{
  return 0;
}

uint64_t _ValidUTF8Buffer.capacity.getter()
{
  return 4LL;
}

uint64_t static _ValidUTF8Buffer.capacity.getter()
{
  return 4LL;
}

uint64_t static UInt8.bitWidth.getter()
{
  return 8LL;
}

Swift::Void __swiftcall _ValidUTF8Buffer.append(_:)(Swift::UInt8 a1)
{
  if (HIBYTE(*v1)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
  }
  *v1 |= (a1 + 1) << (-(__clz(*v1) & 0x18) & 0x18);
}

Swift::UInt8 __swiftcall _ValidUTF8Buffer.removeFirst()()
{
  unsigned int v1 = *v0;
  if (!*v0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xB1uLL,  0);
  }
  Swift::UInt8 result = v1 - 1;
  unsigned int *v0 = v1 >> 8;
  return result;
}

uint64_t _ValidUTF8Buffer.replaceSubrange<A>(_:with:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v25)(uint64_t *__return_ptr, unint64_t, unint64_t);
  char v26;
  uint64_t result;
  unint64_t v28;
  BOOL v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v4 = v3;
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v10 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(v11 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  v13,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v31 - v16;
  if ((_DWORD)a1)
  {
    unsigned int v18 = *v4;
    if (!*v4) {
LABEL_5:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC1uLL,  0);
    while (v18 != (_DWORD)a1)
    {
      BOOL v19 = v18 >= 0x100;
      v18 >>= 8;
      if (!v19) {
        goto LABEL_5;
      }
    }
  }

  if (HIDWORD(a1))
  {
    unsigned int v20 = *v4;
    if (!*v4) {
LABEL_10:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC2uLL,  0);
    while (v20 != HIDWORD(a1))
    {
      BOOL v19 = v20 >= 0x100;
      v20 >>= 8;
      if (!v19) {
        goto LABEL_10;
      }
    }
  }

  unsigned int v21 = *v4;
  if (*v4 < a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v22 = a2;
  unint64_t v31 = v15;
  unsigned int v23 = 0;
  if (v21 != (_DWORD)a1)
  {
    unint64_t v30 = v21;
    while (v21 >= v30 && v30 > a1)
    {
      if (HIBYTE(v23)) {
        goto LABEL_31;
      }
      v23 |= v30 << (-(__clz(v23) & 0x18) & 0x18);
      v30 >>= 8;
      if (v30 == (_DWORD)a1) {
        goto LABEL_14;
      }
    }

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance _ValidUTF8Buffer( unsigned int *a1, uint64_t a2, uint64_t a3)
{
  void (*v24)(uint64_t *__return_ptr, unint64_t, unint64_t);
  char v25;
  uint64_t result;
  unsigned int *v27;
  unsigned int v28;
  BOOL v29;
  unint64_t v30;
  char v31[8];
  uint64_t *v32;
  uint64_t v33;
  unsigned int *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v36 = a2;
  uint64_t v38 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  char v35 = (char *)&v33 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void *)(v6 + 8);
  unint64_t v37 = v8;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v33 - v12;
  uint64_t v15 = *a1;
  uint64_t v14 = a1[1];
  unint64_t v16 = *v3 | ((unint64_t)*v3 << 32);
  if ((_DWORD)v15)
  {
    LODWORD(v39) = v15;
    MEMORY[0x1895F8858](v11);
    unint64_t v32 = &v39;
    uint64_t v11 = specialized Sequence.contains(where:)( (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply,  (uint64_t)v31,  v16,  0);
    if ((v11 & 1) == 0)
    {
      LODWORD(v32) = 0;
      unint64_t v30 = 193LL;
      goto LABEL_23;
    }
  }

  if ((_DWORD)v14)
  {
    LODWORD(v39) = v14;
    MEMORY[0x1895F8858](v11);
    unint64_t v32 = &v39;
    if ((specialized Sequence.contains(where:)( (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply,  (uint64_t)v31,  v16,  0) & 1) == 0)
    {
      LODWORD(v32) = 0;
      unint64_t v30 = 194LL;
      goto LABEL_23;
    }
  }

  uint64_t v17 = *v3;
  if (v17 < v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v33 = v10;
  Swift::String::Index v34 = v3;
  unsigned int v18 = 0;
  if ((_DWORD)v17 != (_DWORD)v15)
  {
    unsigned int v19 = v17;
    while (1)
    {
      char v20 = specialized Slice.subscript.getter(v19, v17 | (v15 << 32));
      if (!v19) {
        break;
      }
      if (HIBYTE(v18)) {
        goto LABEL_21;
      }
      v19 >>= 8;
      v18 |= (v20 + 1) << (-(__clz(v18) & 0x18) & 0x18);
      if (v19 == (_DWORD)v15) {
        goto LABEL_11;
      }
    }

    LODWORD(v32) = 0;
    unint64_t v30 = 105LL;
LABEL_23:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  v30,  (int)v32);
  }

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance _ValidUTF8Buffer@<X0>( char *a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance _ValidUTF8Buffer@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  return result;
}

_BYTE *protocol witness for RangeReplaceableCollection.append(_:) in conformance _ValidUTF8Buffer( _BYTE *result)
{
  if (HIBYTE(*v1)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
  }
  *v1 |= (*result + 1) << (-(__clz(*v1) & 0x18) & 0x18);
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance _ValidUTF8Buffer( unsigned __int8 *a1, unsigned int *a2)
{
  return specialized RangeReplaceableCollection.insert(_:at:)(*a1, *a2);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance _ValidUTF8Buffer( uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(a1, *a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance _ValidUTF8Buffer@<X0>( unsigned int *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result = specialized RangeReplaceableCollection.remove(at:)(*a1);
  *a2 = result;
  return result;
}

unint64_t protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance _ValidUTF8Buffer( unint64_t *a1)
{
  return specialized RangeReplaceableCollection.removeSubrange(_:)(*a1);
}

void protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance _ValidUTF8Buffer( _WORD *a1@<X8>)
{
  *a1 = 256;
}

void protocol witness for RangeReplaceableCollection.removeFirst() in conformance _ValidUTF8Buffer( _BYTE *a1@<X8>)
{
  unsigned int v2 = *v1;
  if (!*v1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xB1uLL,  0);
  }
  *unsigned int v1 = v2 >> 8;
  *a1 = v2 - 1;
}

uint64_t protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance _ValidUTF8Buffer( uint64_t a1)
{
  return specialized RangeReplaceableCollection.removeAll(where:)(a1);
}

Swift::Void __swiftcall _ValidUTF8Buffer.append(contentsOf:)(Swift::_ValidUTF8Buffer contentsOf)
{
  unint64_t v2 = 4LL - (__clz(*v1) >> 3);
  if (v2 > __clz(contentsOf._biasedBits) >> 3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xCFuLL,  0);
  }
  *v1 |= contentsOf._biasedBits << (8 * (v2 & 3));
}

uint64_t Range<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(_:)( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void))type metadata accessor for Range,  a4);
}

uint64_t ClosedRange<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(_:)( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void))type metadata accessor for ClosedRange,  a4);
}

uint64_t Range<>.init(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t (*a4)(void, uint64_t, void)@<X4>, uint64_t a5@<X8>)
{
  uint64_t v7 = a4(0LL, a2, *(void *)(a3 + 8));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(a5, a1, v7);
}

void String.characters.setter(uint64_t a1, uint64_t a2)
{
  void *v2 = a1;
  v2[1] = a2;
}

void (*String.characters.modify( void *a1, uint64_t a2, uint64_t a3, char *a4))(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  a1[2] = v4;
  unint64_t v6 = v4[1];
  *a1 = *v4;
  a1[1] = v6;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  return String.utf16.modify;
}

uint64_t String.withMutableCharacters<A>(_:)(uint64_t (*a1)(uint64_t))
{
  return a1(v1);
}

uint64_t Substring.characters.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a1;
}

unint64_t key path getter for Substring.utf8 : Substring@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v5 = *(void *)(a1 + 24);
  *(_OWORD *)a5 = *(_OWORD *)a1;
  *(void *)(a5 + 16) = v6;
  *(void *)(a5 + 24) = v5;
  return swift_bridgeObjectRetain(v5, a2, a3, a4);
}

__n128 key path setter for Substring.characters : Substring(__n128 *a1, uint64_t a2, uint64_t a3, char *a4)
{
  __n128 v9 = *a1;
  unint64_t v6 = a1[1].n128_u64[0];
  unint64_t v5 = a1[1].n128_u64[1];
  uint64_t v7 = *(void *)(a2 + 24);
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  __n128 result = v9;
  *(__n128 *)a2 = v9;
  *(void *)(a2 + 16) = v6;
  *(void *)(a2 + 24) = v5;
  return result;
}

void Substring.unicodeScalars.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *BOOL v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
}

void (*Substring.characters.modify(void *a1))(uint64_t **a1, uint64_t a2, uint64_t a3, char *a4)
{
  unsigned int v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  uint64_t v5 = *(void *)(v1 + 16);
  unint64_t v4 = *(void *)(v1 + 24);
  *(_OWORD *)unsigned int v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4, v6, v7, v8);
  return Substring.unicodeScalars.modify;
}

uint64_t Substring.withMutableCharacters<A>(_:)(uint64_t (*a1)(uint64_t))
{
  return a1(v1);
}

uint64_t Substring.customPlaygroundQuickLook.getter@<X0>( Swift::String::Index a1@<X0>, Swift::String::Index a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result = specialized String.init(_:)(a1, a2, a3, a4);
  *(void *)a5 = result;
  *(void *)(a5 + 8) = v7;
  *(_BYTE *)(a5 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Substring@<X0>( uint64_t a1@<X8>)
{
  v3._Swift::UInt64 rawBits = *v1;
  v4._Swift::UInt64 rawBits = v1[1];
  uint64_t result = specialized String.init(_:)(v3, v4, v1[2], v1[3]);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v6;
  *(_BYTE *)(a1 + 32) = 0;
  return result;
}

uint64_t Collection.index<A>(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v93 = a5;
  uint64_t v91 = a1;
  uint64_t v92 = a3;
  uint64_t v90 = a7;
  Swift::String::Index v85 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v85,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  Swift::String::Index v84 = (char *)&v82 - v12;
  uint64_t v13 = *(void *)(a4 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  unint64_t v16 = (char *)&v82 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  unint64_t v88 = (char *)&v82 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v82 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v89 = (char *)&v82 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v87 = (char *)&v82 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v28 = (char *)&v82 - v27;
  MEMORY[0x1895F8858](v26);
  unint64_t v30 = (char *)&v82 - v29;
  unint64_t v31 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v31((char *)&v82 - v29, a2, a4);
  char v94 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  LOBYTE(a2) = v94(a4, a6);
  v31(v28, (uint64_t)v30, a4);
  if ((a2 & 1) == 0)
  {
    unint64_t v33 = *(void (**)(char *, uint64_t))(v13 + 8);
    v33(v28, a4);
    uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    char v35 = v94;
    uint64_t v41 = v36(a4, a6);
    goto LABEL_25;
  }

  unint64_t v86 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
  uint64_t v32 = v86(a4, a6);
  unint64_t v33 = *(void (**)(char *, uint64_t))(v13 + 8);
  v33(v28, a4);
  if (v32 <= 64)
  {
    char v35 = v94;
    uint64_t v36 = v86;
    uint64_t v41 = v86(a4, a6);
    goto LABEL_25;
  }

  Swift::String::Index v83 = v16;
  Swift::String::Index v34 = v87;
  v31(v87, (uint64_t)v30, a4);
  uint64_t v96 = 0x8000000000000000LL;
  char v35 = v94;
  if ((v94(a4, a6) & 1) != 0)
  {
    uint64_t v36 = v86;
    uint64_t v37 = v86(a4, a6);
    if (v37 < 64)
    {
      uint64_t v40 = v89;
      v31(v89, (uint64_t)v34, a4);
      Swift::String::Index v85 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v33(v40, a4);
      goto LABEL_24;
    }

    Swift::String::Index v85 = *(const char **)(a6 + 96);
    unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
    uint64_t v51 = v89;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v85)( &v96,  &type metadata for Int,  v50,  a4,  a6);
    char v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v34,  v51,  a4);
    unint64_t v53 = v51;
    char v35 = v94;
    v33(v53, a4);
    if ((v52 & 1) != 0) {
LABEL_41:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  else
  {
    char v42 = v35(a4, a6);
    uint64_t v43 = v86(a4, a6);
    if ((v42 & 1) != 0)
    {
      if (v43 <= 64)
      {
        unint64_t v57 = v85;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v85,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v59 = v84;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
        unint64_t v60 = v57;
        uint64_t v61 = (void (*)(char *, uint64_t, const char *))*((void *)v57 + 3);
        uint64_t v62 = v89;
        v61(v59, a4, v60);
        char v63 = v87;
        LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v87,  v62,  a4);
        v33(v62, a4);
        Swift::Int v64 = v83;
        v31(v83, (uint64_t)v63, a4);
        if ((v59 & 1) != 0)
        {
          v33(v64, a4);
          goto LABEL_41;
        }

        uint64_t v65 = v96;
        uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
        v33(v64, a4);
        BOOL v56 = v66 < v65;
        char v35 = v94;
        uint64_t v36 = v86;
        Swift::String::Index v34 = v87;
        if (v56) {
          goto LABEL_41;
        }
      }

      else
      {
        int v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
        uint64_t v48 = v89;
        v46(&v96, &type metadata for Int, v47, a4, a6);
        Swift::String::Index v34 = v87;
        char v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v87,  v48,  a4);
        v33(v48, a4);
        char v35 = v94;
        uint64_t v36 = v86;
        if ((v49 & 1) != 0) {
          goto LABEL_41;
        }
      }
    }

    else if (v43 < 64)
    {
      uint64_t v54 = v89;
      Swift::String::Index v34 = v87;
      v31(v89, (uint64_t)v87, a4);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v33(v54, a4);
      BOOL v56 = v55 < v96;
      char v35 = v94;
      uint64_t v36 = v86;
      if (v56) {
        goto LABEL_41;
      }
    }

    else
    {
      char v35 = v94;
      uint64_t v36 = v86;
      Swift::String::Index v34 = v87;
    }
  }

uint64_t Collection.formIndex<A>(_:offsetBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6)
{
  uint64_t v100 = a1;
  uint64_t v91 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v91,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v92 = (char *)&v90 - v12;
  unint64_t v99 = a5;
  uint64_t v98 = a3;
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v96 = *(void *)(v13 - 8);
  unint64_t v97 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v95 = (char *)&v90 - v15;
  uint64_t v16 = *(void *)(a4 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v90 = (char *)&v90 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v101 = (char *)&v90 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v90 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  char v94 = (char *)&v90 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v28 = (char *)&v90 - v27;
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  unint64_t v31 = (char *)&v90 - v30;
  MEMORY[0x1895F8858](v29);
  unint64_t v33 = (char *)&v90 - v32;
  Swift::String::Index v34 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  v34((char *)&v90 - v32, a2, a4);
  unint64_t v102 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  LOBYTE(a2) = v102(a4, a6);
  v34(v31, (uint64_t)v33, a4);
  if ((a2 & 1) == 0)
  {
    uint64_t v37 = *(void (**)(char *, uint64_t))(v16 + 8);
    v37(v31, a4);
    char v35 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    goto LABEL_8;
  }

  uint64_t v93 = v28;
  char v35 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
  uint64_t v36 = v35(a4, a6);
  uint64_t v37 = *(void (**)(char *, uint64_t))(v16 + 8);
  v37(v31, a4);
  if (v36 <= 64)
  {
LABEL_8:
    uint64_t v45 = v101;
    goto LABEL_24;
  }

  v34(v93, (uint64_t)v33, a4);
  int64_t v104 = 0x8000000000000000LL;
  uint64_t v38 = v102;
  if ((v102(a4, a6) & 1) == 0)
  {
    char v46 = v38(a4, a6);
    uint64_t v47 = v35(a4, a6);
    if ((v46 & 1) != 0)
    {
      if (v47 > 64)
      {
        unint64_t v50 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v47, v48, v49);
        char v52 = v94;
        v50(&v104, &type metadata for Int, v51, a4, a6);
        unint64_t v53 = v93;
        char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v93,  v52,  a4);
        uint64_t v55 = v52;
        uint64_t v39 = v53;
        goto LABEL_13;
      }

      uint64_t v62 = v91;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v91,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      Swift::Int v64 = v62;
      uint64_t v65 = (void (*)(char *, uint64_t, const char *))*((void *)v62 + 3);
      uint64_t v66 = v94;
      v65(v92, a4, v64);
      uint64_t v67 = v93;
      LODWORD(v92) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v93,  v66,  a4);
      v37(v66, a4);
      int64_t v68 = v90;
      v34(v90, (uint64_t)v67, a4);
      if ((v92 & 1) != 0)
      {
        v37(v68, a4);
        goto LABEL_40;
      }

      int64_t v69 = v104;
      uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v37(v68, a4);
      BOOL v71 = v70 < v69;
      uint64_t v45 = v101;
      uint64_t v39 = v93;
      if (!v71) {
        goto LABEL_23;
      }
    }

    else
    {
      uint64_t v45 = v101;
      if (v47 >= 64)
      {
        uint64_t v39 = v93;
        goto LABEL_23;
      }

      uint64_t v59 = v94;
      v34(v94, (uint64_t)v93, a4);
      uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      uint64_t v61 = v59;
      uint64_t v39 = v93;
      v37(v61, a4);
      if (v60 >= v104) {
        goto LABEL_23;
      }
    }

uint64_t Collection.index<A>(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v94 = a6;
  uint64_t v92 = a3;
  uint64_t v93 = a4;
  uint64_t v90 = a8;
  uint64_t v91 = a1;
  uint64_t v85 = *(const char **)(*(void *)(a7 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v85,  a5,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v84 = (char *)&v83 - v13;
  uint64_t v14 = *(void *)(a5 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v83 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v88 = (char *)&v83 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v83 - v21;
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  unint64_t v89 = (char *)&v83 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  unint64_t v87 = (char *)&v83 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v29 = (char *)&v83 - v28;
  MEMORY[0x1895F8858](v27);
  unint64_t v31 = (char *)&v83 - v30;
  uint64_t v32 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  v32((char *)&v83 - v30, a2, a5);
  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 64);
  LOBYTE(a2) = v95(a5, a7);
  v32(v29, (uint64_t)v31, a5);
  if ((a2 & 1) == 0)
  {
    Swift::String::Index v34 = *(void (**)(char *, uint64_t))(v14 + 8);
    v34(v29, a5);
    uint64_t v37 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
    uint64_t v36 = v95;
    uint64_t v42 = v37(a5, a7);
    goto LABEL_25;
  }

  unint64_t v86 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
  uint64_t v33 = v86(a5, a7);
  Swift::String::Index v34 = *(void (**)(char *, uint64_t))(v14 + 8);
  v34(v29, a5);
  if (v33 <= 64)
  {
    uint64_t v36 = v95;
    uint64_t v37 = v86;
    uint64_t v42 = v86(a5, a7);
    goto LABEL_25;
  }

  char v83 = v17;
  char v35 = v87;
  v32(v87, (uint64_t)v31, a5);
  uint64_t v97 = 0x8000000000000000LL;
  uint64_t v36 = v95;
  if ((v95(a5, a7) & 1) != 0)
  {
    uint64_t v37 = v86;
    uint64_t v38 = v86(a5, a7);
    if (v38 < 64)
    {
      uint64_t v41 = v89;
      v32(v89, (uint64_t)v35, a5);
      uint64_t v85 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      v34(v41, a5);
      goto LABEL_24;
    }

    uint64_t v85 = *(const char **)(a7 + 96);
    unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v38, v39, v40);
    char v52 = v89;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v85)( &v97,  &type metadata for Int,  v51,  a5,  a7);
    char v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v35,  v52,  a5);
    char v54 = v52;
    uint64_t v36 = v95;
    v34(v54, a5);
    if ((v53 & 1) != 0) {
LABEL_41:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  else
  {
    char v43 = v36(a5, a7);
    uint64_t v44 = v86(a5, a7);
    if ((v43 & 1) != 0)
    {
      if (v44 <= 64)
      {
        uint64_t v58 = v85;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v85,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v60 = v84;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
        uint64_t v61 = v58;
        uint64_t v62 = (void (*)(char *, uint64_t, const char *))*((void *)v58 + 3);
        char v63 = v89;
        v62(v60, a5, v61);
        Swift::Int v64 = v87;
        LOBYTE(v60) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v87,  v63,  a5);
        v34(v63, a5);
        uint64_t v65 = v83;
        v32(v83, (uint64_t)v64, a5);
        if ((v60 & 1) != 0)
        {
          v34(v65, a5);
          goto LABEL_41;
        }

        uint64_t v66 = v97;
        uint64_t v67 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
        v34(v65, a5);
        BOOL v57 = v67 < v66;
        uint64_t v36 = v95;
        uint64_t v37 = v86;
        char v35 = v87;
        if (v57) {
          goto LABEL_41;
        }
      }

      else
      {
        uint64_t v47 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
        unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v44, v45, v46);
        uint64_t v49 = v89;
        v47(&v97, &type metadata for Int, v48, a5, a7);
        char v35 = v87;
        char v50 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v87,  v49,  a5);
        v34(v49, a5);
        uint64_t v36 = v95;
        uint64_t v37 = v86;
        if ((v50 & 1) != 0) {
          goto LABEL_41;
        }
      }
    }

    else if (v44 < 64)
    {
      uint64_t v55 = v89;
      char v35 = v87;
      v32(v89, (uint64_t)v87, a5);
      uint64_t v56 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      v34(v55, a5);
      BOOL v57 = v56 < v97;
      uint64_t v36 = v95;
      uint64_t v37 = v86;
      if (v57) {
        goto LABEL_41;
      }
    }

    else
    {
      uint64_t v36 = v95;
      uint64_t v37 = v86;
      char v35 = v87;
    }
  }

BOOL Collection.formIndex<A>(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t v106 = a3;
  uint64_t v107 = a1;
  uint64_t v96 = *(const char **)(*(void *)(a7 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v96,  a5,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v97 = (char *)&v95 - v13;
  uint64_t v105 = a6;
  uint64_t v103 = a4;
  unint64_t v104 = swift_getAssociatedTypeWitness( 255LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v16 = type metadata accessor for Optional(0LL, v104, v14, v15);
  uint64_t v99 = *(void *)(v16 - 8);
  uint64_t v100 = v16;
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  unint64_t v102 = (char *)&v95 - v18;
  uint64_t v19 = *(void *)(a5 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v95 = (char *)&v95 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v108 = (char *)&v95 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v95 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  unint64_t v101 = (char *)&v95 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v31 = (char *)&v95 - v30;
  uint64_t v32 = MEMORY[0x1895F8858](v29);
  Swift::String::Index v34 = (char *)&v95 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v95 - v35;
  uint64_t v37 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v37((char *)&v95 - v35, a2, a5);
  unint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 64);
  LOBYTE(a2) = v109(a5, a7);
  v37(v34, (uint64_t)v36, a5);
  if ((a2 & 1) == 0)
  {
    uint64_t v40 = *(void (**)(char *, uint64_t))(v19 + 8);
    v40(v34, a5);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
    goto LABEL_8;
  }

  uint64_t v98 = v31;
  uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
  uint64_t v39 = v38(a5, a7);
  uint64_t v40 = *(void (**)(char *, uint64_t))(v19 + 8);
  v40(v34, a5);
  if (v39 <= 64)
  {
LABEL_8:
    unint64_t v48 = v108;
    goto LABEL_24;
  }

  v37(v98, (uint64_t)v36, a5);
  int64_t v111 = 0x8000000000000000LL;
  uint64_t v41 = v109;
  if ((v109(a5, a7) & 1) == 0)
  {
    char v49 = v41(a5, a7);
    uint64_t v50 = v38(a5, a7);
    if ((v49 & 1) != 0)
    {
      if (v50 > 64)
      {
        char v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
        unint64_t v54 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
        uint64_t v55 = v101;
        v53(&v111, &type metadata for Int, v54, a5, a7);
        uint64_t v56 = v98;
        char v57 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v98,  v55,  a5);
        uint64_t v58 = v55;
        uint64_t v42 = v56;
        goto LABEL_13;
      }

      uint64_t v65 = v96;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v96,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v67 = v65;
      uint64_t v68 = (void (*)(char *, uint64_t, const char *))*((void *)v65 + 3);
      int64_t v69 = v101;
      v68(v97, a5, v67);
      char v70 = v98;
      LODWORD(v97) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v98,  v69,  a5);
      v40(v69, a5);
      uint64_t v71 = v95;
      v37(v95, (uint64_t)v70, a5);
      if ((v97 & 1) != 0)
      {
        v40(v71, a5);
        goto LABEL_43;
      }

      int64_t v72 = v111;
      uint64_t v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      v40(v71, a5);
      BOOL v74 = v73 < v72;
      unint64_t v48 = v108;
      uint64_t v42 = v98;
      if (!v74) {
        goto LABEL_23;
      }
    }

    else
    {
      unint64_t v48 = v108;
      if (v50 >= 64)
      {
        uint64_t v42 = v98;
        goto LABEL_23;
      }

      uint64_t v62 = v101;
      v37(v101, (uint64_t)v98, a5);
      uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      Swift::Int v64 = v62;
      uint64_t v42 = v98;
      v40(v64, a5);
      if (v63 >= v111) {
        goto LABEL_23;
      }
    }

uint64_t Collection.distance<A>(from:to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 152))(a1, a2, a3, a5);
  uint64_t v8 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 88);
  unint64_t v11 = lazy protocol witness table accessor for type Int and conformance Int(v13, v9, v10);
  return v8(&v13, &type metadata for Int, v11, a4, a6);
}

Swift::UnsafeMutableRawPointer __swiftcall UnsafeMutablePointer.deinitialize()()
{
  v2._rawValue = (Builtin::RawPointer)v0;
  swift_arrayDestroy(v0, 1LL, v1);
  return v2;
}

Swift::Void __swiftcall UnsafeMutablePointer.deallocate(capacity:)(Swift::Int capacity)
{
}

uint64_t UnsafeMutablePointer.initialize<A>(from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v27 = a2;
  uint64_t v9 = type metadata accessor for Optional(0LL, a3, a3, a4);
  uint64_t v28 = *(void *)(v9 - 8);
  uint64_t v29 = v9;
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v26 - v11;
  uint64_t v13 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v16,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v26 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v19 = (char *)&v26 - v18;
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 112))(a4, a5);
  if (v20 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v21 = v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a1, a4);
  uint64_t v22 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 64))(v19, v27, v21, a4, v16);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v16,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( AssociatedTypeWitness,  AssociatedConformanceWitness);
  int v24 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 48LL))(v12, 1LL, a3);
  (*(void (**)(char *, uint64_t))(v28 + 8))(v12, v29);
  if (v24 != 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "rhs underreported its count",  27LL,  2,  "Swift/MigrationSupport.swift",  28LL,  2,  0x17BuLL,  0);
  }
  if (v22 != v21) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "rhs overreported its count",  26LL,  2,  "Swift/MigrationSupport.swift",  28LL,  2,  0x17CuLL,  0);
  }
  return (*(uint64_t (**)(char *, unint64_t))(v26 + 8))(v19, AssociatedTypeWitness);
}

uint64_t UnsafeRawPointer.summary.getter(Swift::UInt64 a1)
{
  unint64_t v1 = 0xD000000000000013LL;
  if (!a1) {
    return 0xD000000000000015LL;
  }
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(22LL);
  uint64_t v5 = v4;
  uint64_t v27 = v3;
  unint64_t v28 = v4;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v6 && (v3 & ~v4 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v4);
    unint64_t v10 = 0x80000001818BAEB0LL;
    goto LABEL_16;
  }

  if ((v4 & 0x2000000000000000LL) != 0
    && ((unint64_t)"UnsafeMutableRawPointer(nil)" & 0x2000000000000000LL) != 0)
  {
    unint64_t v7 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD000000000000013LL, 0x80000001818BAEB0LL);
    if ((v9 & 1) == 0)
    {
      unint64_t v1 = v7;
      unint64_t v10 = v8;
      swift_bridgeObjectRelease(v5);
LABEL_16:
      uint64_t v27 = v1;
      unint64_t v28 = v10;
      goto LABEL_17;
    }
  }

  else {
    unint64_t v11 = 19LL;
  }
  _StringGuts.append(_:)(0xD000000000000013LL, 0x80000001818BAEB0LL, 0LL, v11);
  unint64_t v1 = v27;
  unint64_t v10 = v28;
LABEL_17:
  Swift::String v13 = _uint64ToString(_:radix:uppercase:)(a1, 16LL, 1);
  unint64_t countAndFlagsBits = v13._countAndFlagsBits;
  unint64_t object = (unint64_t)v13._object;
  uint64_t v16 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000LL) == 0) {
    uint64_t v16 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v16 && (v1 & ~v10 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v10);
    uint64_t v27 = v13._countAndFlagsBits;
    goto LABEL_30;
  }

  if ((v10 & 0x2000000000000000LL) == 0)
  {
LABEL_25:
    uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0LL, v17);
    swift_bridgeObjectRelease((uint64_t)v13._object);
    unint64_t countAndFlagsBits = v27;
    unint64_t object = v28;
    goto LABEL_30;
  }

  unint64_t v18 = specialized _SmallString.init(_:appending:)(v1, v10, v13._countAndFlagsBits, (unint64_t)v13._object);
  if ((v20 & 1) != 0)
  {
LABEL_28:
    uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
    goto LABEL_29;
  }

  unint64_t v21 = v18;
  unint64_t v22 = v19;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease((uint64_t)v13._object);
  uint64_t v27 = v21;
  unint64_t object = v22;
  unint64_t countAndFlagsBits = v21;
LABEL_30:
  uint64_t v23 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000LL) == 0) {
    uint64_t v23 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v23 || (countAndFlagsBits & ~object & 0x2000000000000000LL) != 0)
  {
    if ((object & 0x2000000000000000LL) == 0
      || (unint64_t v24 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x29uLL, 0xE100000000000000LL),
          (v25 & 1) != 0))
    {
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      return v27;
    }

    else
    {
      unint64_t v12 = v24;
      swift_bridgeObjectRelease(object);
    }
  }

  else
  {
    swift_bridgeObjectRelease(object);
    return 41LL;
  }

  return v12;
}

uint64_t UnsafeRawPointer.customPlaygroundQuickLook.getter@<X0>(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = UnsafeRawPointer.summary.getter(a1);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer@<X0>( uint64_t a1@<X8>)
{
  return protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer( UnsafeRawPointer.summary.getter,  a1);
}

uint64_t UnsafeMutableRawPointer.summary.getter(Swift::UInt64 a1)
{
  unint64_t v1 = 0xD00000000000001ALL;
  if (!a1) {
    return 0xD00000000000001CLL;
  }
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(29LL);
  uint64_t v5 = v4;
  uint64_t v27 = v3;
  unint64_t v28 = v4;
  uint64_t v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v6 && (v3 & ~v4 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v4);
    unint64_t v10 = 0x80000001818BAE70LL;
    goto LABEL_16;
  }

  if ((v4 & 0x2000000000000000LL) != 0 && ((unint64_t)"UnsafePointer(nil)" & 0x2000000000000000LL) != 0)
  {
    unint64_t v7 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD00000000000001ALL, 0x80000001818BAE70LL);
    if ((v9 & 1) == 0)
    {
      unint64_t v1 = v7;
      unint64_t v10 = v8;
      swift_bridgeObjectRelease(v5);
LABEL_16:
      uint64_t v27 = v1;
      unint64_t v28 = v10;
      goto LABEL_17;
    }
  }

  else {
    unint64_t v11 = 26LL;
  }
  _StringGuts.append(_:)(0xD00000000000001ALL, 0x80000001818BAE70LL, 0LL, v11);
  unint64_t v1 = v27;
  unint64_t v10 = v28;
LABEL_17:
  Swift::String v13 = _uint64ToString(_:radix:uppercase:)(a1, 16LL, 1);
  unint64_t countAndFlagsBits = v13._countAndFlagsBits;
  unint64_t object = (unint64_t)v13._object;
  uint64_t v16 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000LL) == 0) {
    uint64_t v16 = v1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v16 && (v1 & ~v10 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v10);
    uint64_t v27 = v13._countAndFlagsBits;
    goto LABEL_30;
  }

  if ((v10 & 0x2000000000000000LL) == 0)
  {
LABEL_25:
    uint64_t v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0LL, v17);
    swift_bridgeObjectRelease((uint64_t)v13._object);
    unint64_t countAndFlagsBits = v27;
    unint64_t object = v28;
    goto LABEL_30;
  }

  unint64_t v18 = specialized _SmallString.init(_:appending:)(v1, v10, v13._countAndFlagsBits, (unint64_t)v13._object);
  if ((v20 & 1) != 0)
  {
LABEL_28:
    uint64_t v17 = ((unint64_t)v13._object >> 56) & 0xF;
    goto LABEL_29;
  }

  unint64_t v21 = v18;
  unint64_t v22 = v19;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease((uint64_t)v13._object);
  uint64_t v27 = v21;
  unint64_t object = v22;
  unint64_t countAndFlagsBits = v21;
LABEL_30:
  uint64_t v23 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000LL) == 0) {
    uint64_t v23 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v23 || (countAndFlagsBits & ~object & 0x2000000000000000LL) != 0)
  {
    if ((object & 0x2000000000000000LL) == 0
      || (unint64_t v24 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x29uLL, 0xE100000000000000LL),
          (v25 & 1) != 0))
    {
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      return v27;
    }

    else
    {
      unint64_t v12 = v24;
      swift_bridgeObjectRelease(object);
    }
  }

  else
  {
    swift_bridgeObjectRelease(object);
    return 41LL;
  }

  return v12;
}

uint64_t UnsafeMutableRawPointer.customPlaygroundQuickLook.getter@<X0>( Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = UnsafeMutableRawPointer.summary.getter(a1);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeMutableRawPointer@<X0>( uint64_t a1@<X8>)
{
  return protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer( UnsafeMutableRawPointer.summary.getter,  a1);
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer@<X0>( uint64_t (*a1)(void)@<X2>, uint64_t a2@<X8>)
{
  uint64_t result = a1(*v2);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v5;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

void UnsafePointer.customPlaygroundQuickLook.getter(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t countAndFlagsBits = 0xD000000000000010LL;
  if (!a1)
  {
    unint64_t v14 = 0xD000000000000012LL;
    unint64_t v15 = 0x80000001818BAE50LL;
    goto LABEL_38;
  }

  unint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(19LL);
  uint64_t v7 = v6;
  v30._unint64_t countAndFlagsBits = v5;
  v30._unint64_t object = (void *)v6;
  uint64_t v8 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v8 && (v5 & ~v6 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v6);
    unint64_t object = 0x80000001818BAE30LL;
    goto LABEL_16;
  }

  if ((v6 & 0x2000000000000000LL) != 0 && ((unint64_t)"UnsafeMutablePointer(nil)" & 0x2000000000000000LL) != 0)
  {
    unint64_t v9 = specialized _SmallString.init(_:appending:)(v5, v6, 0xD000000000000010LL, 0x80000001818BAE30LL);
    if ((v11 & 1) == 0)
    {
      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v7);
LABEL_16:
      v30._unint64_t countAndFlagsBits = countAndFlagsBits;
      v30._unint64_t object = (void *)object;
      goto LABEL_17;
    }
  }

  else {
    unint64_t v13 = 16LL;
  }
  _StringGuts.append(_:)(0xD000000000000010LL, 0x80000001818BAE30LL, 0LL, v13);
  unint64_t object = (unint64_t)v30._object;
  unint64_t countAndFlagsBits = v30._countAndFlagsBits;
LABEL_17:
  Swift::String v16 = _uint64ToString(_:radix:uppercase:)(a1, 16LL, 1);
  unint64_t v17 = v16._countAndFlagsBits;
  unint64_t v18 = (unint64_t)v16._object;
  uint64_t v19 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000LL) == 0) {
    uint64_t v19 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v19 && (countAndFlagsBits & ~object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(object);
    Swift::String v30 = v16;
    goto LABEL_30;
  }

  if ((object & 0x2000000000000000LL) == 0)
  {
LABEL_25:
    uint64_t v20 = v16._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v16._countAndFlagsBits, (unint64_t)v16._object, 0LL, v20);
    swift_bridgeObjectRelease((uint64_t)v16._object);
    unint64_t v18 = (unint64_t)v30._object;
    unint64_t v17 = v30._countAndFlagsBits;
    goto LABEL_30;
  }

  unint64_t v21 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  object,  v16._countAndFlagsBits,  (unint64_t)v16._object);
  if ((v23 & 1) != 0)
  {
LABEL_28:
    uint64_t v20 = ((unint64_t)v16._object >> 56) & 0xF;
    goto LABEL_29;
  }

  unint64_t v24 = v21;
  char v25 = v22;
  swift_bridgeObjectRelease((uint64_t)v16._object);
  swift_bridgeObjectRelease(object);
  v30._unint64_t countAndFlagsBits = v24;
  v30._unint64_t object = v25;
  unint64_t v18 = (unint64_t)v25;
  unint64_t v17 = v24;
LABEL_30:
  uint64_t v26 = HIBYTE(v18) & 0xF;
  if ((v18 & 0x2000000000000000LL) == 0) {
    uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
  }
  if (v26 || (v17 & ~v18 & 0x2000000000000000LL) != 0)
  {
    if ((v18 & 0x2000000000000000LL) == 0
      || (unint64_t v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0x29uLL, 0xE100000000000000LL), (v29 & 1) != 0))
    {
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      unint64_t v15 = (unint64_t)v30._object;
      unint64_t v14 = v30._countAndFlagsBits;
    }

    else
    {
      unint64_t v14 = v27;
      unint64_t v15 = v28;
      swift_bridgeObjectRelease(v18);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v18);
    unint64_t v15 = 0xE100000000000000LL;
    unint64_t v14 = 41LL;
  }

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafePointer<A>( uint64_t a1@<X8>)
{
}

void UnsafeMutablePointer.customPlaygroundQuickLook.getter(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t countAndFlagsBits = 0xD000000000000017LL;
  if (!a1)
  {
    unint64_t v14 = 0xD000000000000019LL;
    unint64_t v15 = 0x80000001818BAE10LL;
    goto LABEL_38;
  }

  unint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(26LL);
  uint64_t v7 = v6;
  v30._unint64_t countAndFlagsBits = v5;
  v30._unint64_t object = (void *)v6;
  uint64_t v8 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v8 && (v5 & ~v6 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v6);
    unint64_t object = 0x80000001818BADF0LL;
    goto LABEL_16;
  }

  if ((v6 & 0x2000000000000000LL) != 0 && ((unint64_t)"Swift/Diffing.swift" & 0x2000000000000000LL) != 0)
  {
    unint64_t v9 = specialized _SmallString.init(_:appending:)(v5, v6, 0xD000000000000017LL, 0x80000001818BADF0LL);
    if ((v11 & 1) == 0)
    {
      unint64_t countAndFlagsBits = v9;
      unint64_t object = v10;
      swift_bridgeObjectRelease(v7);
LABEL_16:
      v30._unint64_t countAndFlagsBits = countAndFlagsBits;
      v30._unint64_t object = (void *)object;
      goto LABEL_17;
    }
  }

  else {
    unint64_t v13 = 23LL;
  }
  _StringGuts.append(_:)(0xD000000000000017LL, 0x80000001818BADF0LL, 0LL, v13);
  unint64_t object = (unint64_t)v30._object;
  unint64_t countAndFlagsBits = v30._countAndFlagsBits;
LABEL_17:
  Swift::String v16 = _uint64ToString(_:radix:uppercase:)(a1, 16LL, 1);
  unint64_t v17 = v16._countAndFlagsBits;
  unint64_t v18 = (unint64_t)v16._object;
  uint64_t v19 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000LL) == 0) {
    uint64_t v19 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v19 && (countAndFlagsBits & ~object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(object);
    Swift::String v30 = v16;
    goto LABEL_30;
  }

  if ((object & 0x2000000000000000LL) == 0)
  {
LABEL_25:
    uint64_t v20 = v16._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v16._countAndFlagsBits, (unint64_t)v16._object, 0LL, v20);
    swift_bridgeObjectRelease((uint64_t)v16._object);
    unint64_t v18 = (unint64_t)v30._object;
    unint64_t v17 = v30._countAndFlagsBits;
    goto LABEL_30;
  }

  unint64_t v21 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  object,  v16._countAndFlagsBits,  (unint64_t)v16._object);
  if ((v23 & 1) != 0)
  {
LABEL_28:
    uint64_t v20 = ((unint64_t)v16._object >> 56) & 0xF;
    goto LABEL_29;
  }

  unint64_t v24 = v21;
  char v25 = v22;
  swift_bridgeObjectRelease((uint64_t)v16._object);
  swift_bridgeObjectRelease(object);
  v30._unint64_t countAndFlagsBits = v24;
  v30._unint64_t object = v25;
  unint64_t v18 = (unint64_t)v25;
  unint64_t v17 = v24;
LABEL_30:
  uint64_t v26 = HIBYTE(v18) & 0xF;
  if ((v18 & 0x2000000000000000LL) == 0) {
    uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
  }
  if (v26 || (v17 & ~v18 & 0x2000000000000000LL) != 0)
  {
    if ((v18 & 0x2000000000000000LL) == 0
      || (unint64_t v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0x29uLL, 0xE100000000000000LL), (v29 & 1) != 0))
    {
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      unint64_t v15 = (unint64_t)v30._object;
      unint64_t v14 = v30._countAndFlagsBits;
    }

    else
    {
      unint64_t v14 = v27;
      unint64_t v15 = v28;
      swift_bridgeObjectRelease(v18);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v18);
    unint64_t v15 = 0xE100000000000000LL;
    unint64_t v14 = 41LL;
  }

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeMutablePointer<A>( uint64_t a1@<X8>)
{
}

void *static UnsafeMutableRawPointer.allocate(bytes:alignedTo:)(size_t a1, uint64_t a2)
{
  if (a2 <= 16) {
    unint64_t v2 = -1LL;
  }
  else {
    unint64_t v2 = a2 - 1;
  }
  return swift_slowAlloc(a1, v2);
}

Swift::Void __swiftcall UnsafeMutableRawPointer.deallocate(bytes:alignedTo:)(Swift::Int bytes, Swift::Int alignedTo)
{
}

Swift::Void __swiftcall UnsafeMutableRawPointer.copyBytes(from:count:)(Swift::UnsafeRawPointer from, Swift::Int count)
{
  if (count < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
  }
  memmove(v2, from._rawValue, count);
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:at:count:to:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(*(void *)(a6 - 8) + 72LL);
  __break(1u);
  return result;
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:from:)( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v31 = a3;
  uint64_t v33 = a2;
  uint64_t v6 = *(void *)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v10 = (char *)&v30 - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  Swift::String v16 = (char *)&v30 - v15;
  uint64_t v17 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v30 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v30 = *(void *)(v20 - 8);
  MEMORY[0x1895F8858](v20);
  unint64_t v22 = (char *)&v30 - v21;
  (*(void (**)(char *, char *, uint64_t))(v17 + 16))(v19, v33, a4);
  (*(void (**)(uint64_t, uint64_t))(v6 + 32))(a4, v6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a4,  v20,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v24 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v32 = v20;
  uint64_t v33 = v22;
  v24(v20, AssociatedConformanceWitness);
  char v25 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48);
  if (v25(v16, 1LL, AssociatedTypeWitness) != 1)
  {
    uint64_t v26 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
    uint64_t v27 = v31;
    do
    {
      v26(v10, v16, AssociatedTypeWitness);
      (*(void (**)(uint64_t, char *, unint64_t))(v8 + 16))(v27, v10, AssociatedTypeWitness);
      uint64_t v28 = *(void *)(v8 + 72);
      (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
      v27 += v28;
      v24(v32, AssociatedConformanceWitness);
    }

    while (v25(v16, 1LL, AssociatedTypeWitness) != 1);
  }

  (*(void (**)(char *, unint64_t))(v30 + 8))(v33, v32);
  return v31;
}

void *static UnsafeMutableRawBufferPointer.allocate(count:)(size_t a1)
{
  uint64_t result = swift_slowAlloc(a1, 0xFFFFFFFFFFFFFFFFLL);
  if ((a1 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }
  return result;
}

void *static UnsafeMutableRawBufferPointer.allocate(byteCount:alignment:)(size_t a1, uint64_t a2)
{
  if (a2 <= 16) {
    unint64_t v3 = -1LL;
  }
  else {
    unint64_t v3 = a2 - 1;
  }
  uint64_t result = swift_slowAlloc(a1, v3);
  if ((a1 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeMutableRawBufferPointer.copyMemory(from:)(Swift::UnsafeRawBufferPointer from)
{
  if (from._position.value._rawValue) {
    int64_t v3 = (char *)from._end.value._rawValue - (char *)from._position.value._rawValue;
  }
  else {
    int64_t v3 = 0LL;
  }
  if (!v1)
  {
    if (v3 < 1) {
      return;
    }
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.copyMemory source has too many elements",  69LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1E7uLL,  0);
  }

  if (from._position.value._rawValue) {
    memmove( v1,  from._position.value._rawValue,  (char *)from._end.value._rawValue - (char *)from._position.value._rawValue);
  }
}

void Sequence.flatMap<A>(_:)( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, const char *a5)
{
}

__objc2_class **Collection.flatMap(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v46 = a1;
  uint64_t v47 = a2;
  uint64_t v5 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v50 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v45 = (char *)&v41 - v7;
  uint64_t v10 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v41 - v12;
  uint64_t v14 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v11);
  Swift::String v16 = (char *)&v41 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v42 = *(void *)(v17 - 8);
  MEMORY[0x1895F8858](v17);
  uint64_t v19 = (char *)&v41 - v18;
  (*(void (**)(char *, unint64_t, uint64_t))(v14 + 16))(v16, v49, a3);
  (*(void (**)(uint64_t, uint64_t))(v5 + 32))(a3, v5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a3,  v17,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v21 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v48 = v19;
  unint64_t v49 = v17;
  v21(v17, AssociatedConformanceWitness);
  uint64_t v22 = v50;
  char v23 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v50 + 48);
  if (v23(v13, 1LL, AssociatedTypeWitness) == 1)
  {
    unint64_t v24 = &_swiftEmptyArrayStorage;
LABEL_3:
    (*(void (**)(char *, unint64_t))(v42 + 8))(v48, v49);
  }

  else
  {
    uint64_t v44 = *(void (**)(char *, char *, unint64_t))(v22 + 32);
    unint64_t v24 = &_swiftEmptyArrayStorage;
    uint64_t v43 = v23;
    while (1)
    {
      uint64_t v26 = v21;
      uint64_t v27 = (uint64_t)v24;
      unint64_t v28 = AssociatedConformanceWitness;
      char v29 = v45;
      v44(v45, v13, AssociatedTypeWitness);
      uint64_t v30 = v51;
      uint64_t v31 = v46(v29);
      if (v30) {
        break;
      }
      uint64_t v33 = v31;
      Swift::String::Index v34 = v32;
      (*(void (**)(char *, unint64_t))(v50 + 8))(v29, AssociatedTypeWitness);
      uint64_t v51 = 0LL;
      if (v34)
      {
        unint64_t v24 = (__objc2_class **)v27;
        if (!swift_isUniquelyReferenced_nonNull_native(v27)) {
          unint64_t v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v27 + 16) + 1LL,  1,  v27);
        }
        unint64_t v36 = (unint64_t)v24[2];
        unint64_t v35 = (unint64_t)v24[3];
        uint64_t v37 = (__objc2_class *)(v36 + 1);
        if (v36 >= v35 >> 1)
        {
          uint64_t v41 = (__objc2_class *)(v36 + 1);
          uint64_t v39 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v35 > 1),  v36 + 1,  1,  (uint64_t)v24);
          uint64_t v37 = v41;
          unint64_t v24 = v39;
        }

        v24[2] = v37;
        uint64_t v38 = &v24[2 * v36];
        v38[4] = (__objc2_class *)v33;
        v38[5] = v34;
      }

      else
      {
        unint64_t v24 = (__objc2_class **)v27;
      }

      unint64_t AssociatedConformanceWitness = v28;
      unint64_t v25 = v28;
      uint64_t v21 = v26;
      v26(v49, v25);
      if (v43(v13, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_3;
      }
    }

    (*(void (**)(char *, unint64_t))(v50 + 8))(v29, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v42 + 8))(v48, v49);
    unint64_t v24 = (__objc2_class **)v27;
    swift_bridgeObjectRelease(v27);
  }

  return v24;
}

uint64_t Collection.index(where:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return Collection.firstIndex(where:)(a1, a2, a3, a4, a5);
}

uint64_t _PlaygroundQuickLook.init(reflecting:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CustomPlaygroundQuickLookable);
  if ((swift_dynamicCast((char *)&v85, v88, (swift *)byte_189B8D218, v4, 6uLL) & 1) != 0
    || (uint64_t v87 = 0LL,
        __int128 v85 = 0u,
        __int128 v86 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v85,  &demangling cache variable for type metadata for _CustomPlaygroundQuickLookable?),  outlined init with copy of Any((uint64_t)a1, (uint64_t)v88),  uint64_t v5 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for __DefaultCustomPlaygroundQuickLookable),  (swift_dynamicCast((char *)&v85, v88, (swift *)byte_189B8D218, v5, 6uLL) & 1) != 0))
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    outlined init with take of MirrorPath(&v85, (uint64_t)&v89);
    uint64_t v6 = *((void *)&v90 + 1);
    uint64_t v7 = v91;
    __swift_project_boxed_opaque_existential_0Tm(&v89, *((uint64_t *)&v90 + 1));
    (*(void (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v89);
  }

  uint64_t v87 = 0LL;
  __int128 v85 = 0u;
  __int128 v86 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v85,  &demangling cache variable for type metadata for __DefaultCustomPlaygroundQuickLookable?);
  id v9 = swift_reflectionMirror_quickLookObject((swift::SwiftError **)a1, (void **)byte_189B8D218);
  if (!v9)
  {
    __int128 v89 = 0u;
    __int128 v90 = 0u;
    LOBYTE(v91) = -1;
    goto LABEL_29;
  }

  uint64_t v12 = v9;
  swift_unknownObjectRetain_n((uint64_t)v9, 2LL, v10, v11);
  unsigned __int8 v14 = specialized String.withCString<A>(_:)(0x7265626D754E534EuLL, 0xE800000000000000LL, v12, v13);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  swift_unknownObjectRelease(v12);
  swift_unknownObjectRetain(v12, v15, v16, v17);
  if ((v14 & 1) == 0)
  {
    unsigned __int8 v23 = specialized String.withCString<A>(_:)( 0xD000000000000012LL,  0x80000001818B7B30LL | 0x8000000000000000LL,  v12,  v18);
    swift_bridgeObjectRelease(0x80000001818B7B30LL | 0x8000000000000000LL);
    swift_unknownObjectRelease(v12);
    if ((v23 & 1) != 0)
    {
      *((void *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
      *(void *)&__int128 v89 = v12;
      char v27 = 9;
    }

    else
    {
      swift_unknownObjectRetain(v12, v24, v25, v26);
      unsigned __int8 v29 = specialized String.withCString<A>(_:)(0x6567616D49534EuLL, 0xE700000000000000LL, v12, v28);
      swift_bridgeObjectRelease(0xE700000000000000LL);
      swift_unknownObjectRelease(v12);
      if ((v29 & 1) != 0) {
        goto LABEL_20;
      }
      swift_unknownObjectRetain(v12, v30, v31, v32);
      unsigned __int8 v34 = specialized String.withCString<A>(_:)(0x6567616D494955uLL, 0xE700000000000000LL, v12, v33);
      swift_bridgeObjectRelease(0xE700000000000000LL);
      swift_unknownObjectRelease(v12);
      if ((v34 & 1) != 0) {
        goto LABEL_20;
      }
      Swift::String v35 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NSImageView", 0xBuLL, 1);
      swift_unknownObjectRetain(v12, (uint64_t)v35._object, v36, v37);
      unsigned __int8 v39 = specialized String.withCString<A>(_:)( v35._countAndFlagsBits,  (unint64_t)v35._object,  v12,  v38);
      swift_bridgeObjectRelease((uint64_t)v35._object);
      swift_unknownObjectRelease(v12);
      if ((v39 & 1) != 0) {
        goto LABEL_20;
      }
      Swift::String v40 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UIImageView", 0xBuLL, 1);
      swift_unknownObjectRetain(v12, (uint64_t)v40._object, v41, v42);
      unsigned __int8 v44 = specialized String.withCString<A>(_:)( v40._countAndFlagsBits,  (unint64_t)v40._object,  v12,  v43);
      swift_bridgeObjectRelease((uint64_t)v40._object);
      swift_unknownObjectRelease(v12);
      if ((v44 & 1) != 0) {
        goto LABEL_20;
      }
      swift_unknownObjectRetain(v12, v45, v46, v47);
      unsigned __int8 v49 = specialized String.withCString<A>(_:)(0x6567616D494943uLL, 0xE700000000000000LL, v12, v48);
      swift_bridgeObjectRelease(0xE700000000000000LL);
      swift_unknownObjectRelease(v12);
      if ((v49 & 1) != 0
        || (swift_unknownObjectRetain(v12, v50, v51, v52),
            unsigned __int8 v54 = specialized String.withCString<A>(_:)( 0xD000000000000010LL,  0x80000001818B7B60LL | 0x8000000000000000LL,  v12,  v53),  swift_bridgeObjectRelease(0x80000001818B7B60LL | 0x8000000000000000LL),  swift_unknownObjectRelease(v12),  (v54 & 1) != 0))
      {
LABEL_20:
        *((void *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
        *(void *)&__int128 v89 = v12;
        char v27 = 5;
      }

      else
      {
        swift_unknownObjectRetain(v12, v55, v56, v57);
        unsigned __int8 v64 = specialized String.withCString<A>(_:)( 0x726F6C6F43534EuLL,  0xE700000000000000LL,  v12,  v63);
        swift_bridgeObjectRelease(0xE700000000000000LL);
        swift_unknownObjectRelease(v12);
        if ((v64 & 1) != 0
          || (swift_unknownObjectRetain(v12, v65, v66, v67),
              unsigned __int8 v69 = specialized String.withCString<A>(_:)( 0x726F6C6F434955uLL,  0xE700000000000000LL,  v12,  v68),  swift_bridgeObjectRelease(0xE700000000000000LL),  swift_unknownObjectRelease(v12),  (v69 & 1) != 0))
        {
          *((void *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
          *(void *)&__int128 v89 = v12;
          char v27 = 7;
        }

        else
        {
          Swift::String v70 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NSBezierPath", 0xCuLL, 1);
          swift_unknownObjectRetain(v12, (uint64_t)v70._object, v71, v72);
          unsigned __int8 v74 = specialized String.withCString<A>(_:)( v70._countAndFlagsBits,  (unint64_t)v70._object,  v12,  v73);
          swift_bridgeObjectRelease((uint64_t)v70._object);
          swift_unknownObjectRelease(v12);
          if ((v74 & 1) == 0)
          {
            Swift::String v75 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UIBezierPath", 0xCuLL, 1);
            swift_unknownObjectRetain(v12, (uint64_t)v75._object, v76, v77);
            unsigned __int8 v79 = specialized String.withCString<A>(_:)( v75._countAndFlagsBits,  (unint64_t)v75._object,  v12,  v78);
            swift_bridgeObjectRelease((uint64_t)v75._object);
            swift_unknownObjectRelease(v12);
            if ((v79 & 1) == 0)
            {
              swift_unknownObjectRetain(v12, v80, v81, v82);
              unsigned __int8 v84 = specialized String.withCString<A>(_:)( 0x676E69727453534EuLL,  0xE800000000000000LL,  v12,  v83);
              swift_bridgeObjectRelease(0xE800000000000000LL);
              swift_unknownObjectRelease(v12);
              if ((v84 & 1) != 0)
              {
                __int128 v85 = 0uLL;
                _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)( (swift *)v12,  (uint64_t)&type metadata for String,  (uint64_t *)&v85);
                if (!*((void *)&v85 + 1)) {
                  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
                }
                __int128 v89 = v85;
                LOBYTE(v91) = 0;
              }

              else
              {
                __int128 v89 = 0u;
                __int128 v90 = 0u;
                LOBYTE(v91) = -1;
              }

              swift_unknownObjectRelease(v12);
              goto LABEL_22;
            }
          }

          *((void *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
          *(void *)&__int128 v89 = v12;
          char v27 = 8;
        }
      }
    }

    LOBYTE(v91) = v27;
LABEL_22:
    swift_unknownObjectRelease(v12);
    goto LABEL_27;
  }

  int v19 = *(unsigned __int8 *)objc_msgSend(v12, sel_objCType);
  if ((v19 & 0x80) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  switch(v19)
  {
    case 'Q':
      id v60 = objc_msgSend(v12, sel_unsignedLongLongValue);
      swift_unknownObjectRelease(v12);
      *(void *)&__int128 v89 = v60;
      char v22 = 2;
      break;
    case 'f':
      objc_msgSend(v12, sel_floatValue);
      int v59 = v58;
      swift_unknownObjectRelease(v12);
      LODWORD(v89) = v59;
      char v22 = 3;
      break;
    case 'd':
      objc_msgSend(v12, sel_doubleValue);
      uint64_t v21 = v20;
      swift_unknownObjectRelease(v12);
      *(void *)&__int128 v89 = v21;
      char v22 = 4;
      break;
    default:
      id v61 = objc_msgSend(v12, sel_longLongValue);
      swift_unknownObjectRelease(v12);
      *(void *)&__int128 v89 = v61;
      char v22 = 1;
      break;
  }

  LOBYTE(v91) = v22;
  swift_unknownObjectRelease_n((uint64_t)v12, 2LL);
LABEL_27:
  if (v91 != 255)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    return outlined init with take of _PlaygroundQuickLook(&v89, a2);
  }

uint64_t _availabilityNextMajorVersion.getter()
{
  return 14LL;
}

uint64_t static _SwiftStdlibVersion.current.getter()
{
  return 393216LL;
}

uint64_t _SwiftStdlibVersion.description.getter(unsigned int a1)
{
  uint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(8LL);
  unint64_t countAndFlagsBits = v3;
  unint64_t object = v4;
  v315._unint64_t countAndFlagsBits = v3;
  v315._unint64_t object = (void *)v4;
  uint64_t v9 = HIBYTE(v4) & 0xF;
  uint64_t v10 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000LL) != 0) {
    uint64_t v11 = HIBYTE(v4) & 0xF;
  }
  else {
    uint64_t v11 = v3 & 0xFFFFFFFFFFFFLL;
  }
  unsigned int v313 = a1;
  if (!v11 && (v3 & ~v4 & 0x2000000000000000LL) == 0)
  {
    v315._unint64_t countAndFlagsBits = 0LL;
    v315._unint64_t object = (void *)0xE000000000000000LL;
    uint64_t v44 = v4;
    goto LABEL_59;
  }

  if ((v4 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v4);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v45 = 0xA000000000000000LL;
    if (!(object & 0x80808080808080LL | countAndFlagsBits & 0x8080808080808080LL)) {
      unint64_t v45 = 0xE000000000000000LL;
    }
    v315._unint64_t countAndFlagsBits = countAndFlagsBits;
    v315._unint64_t object = (void *)(v45 & 0xFF00000000000000LL | (v9 << 56) | object & 0xFFFFFFFFFFFFFFLL);
    goto LABEL_60;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v5, v6);
  uint64_t v12 = v10;
  if ((object & 0x1000000000000000LL) != 0)
  {
    uint64_t v12 = String.UTF8View._foreignCount()();
    unint64_t v13 = countAndFlagsBits & ~object;
    if ((v13 & 0x2000000000000000LL) == 0)
    {
LABEL_39:
      if (v12 <= 15) {
        goto LABEL_13;
      }
      goto LABEL_40;
    }
  }

  else
  {
    unint64_t v13 = countAndFlagsBits & ~object;
    if ((v13 & 0x2000000000000000LL) == 0) {
      goto LABEL_39;
    }
  }

  if (!swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL)) {
    goto LABEL_39;
  }
  unint64_t v14 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
  if ((v15 & 1) != 0) {
    goto LABEL_284;
  }
  if (v12 <= 15 && (v14 & 0x8000000000000000LL) != 0)
  {
LABEL_13:
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
    if ((object & 0x1000000000000000LL) == 0)
    {
      if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
      {
        int v19 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        int v19 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
        uint64_t v10 = v16;
      }

      swift_bridgeObjectRetain(object, v16, v17, v18);
      closure #1 in _StringGuts._convertedToSmall()(v19, v10, &v314);
      swift_bridgeObjectRelease(object);
      unint64_t v21 = *((void *)&v314 + 1);
      unint64_t v20 = v314;
      goto LABEL_17;
    }

    goto LABEL_271;
  }

LABEL_157:
    if ((v163 & ~v164 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v164 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v176 = (unint64_t)v315._object;
      int64_t v177 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
      if ((v178 & 1) != 0) {
        goto LABEL_284;
      }
      if (v174 <= 15 && ((v176 & 0x2000000000000000LL) != 0 || v177 < v173))
      {
LABEL_167:
        swift_bridgeObjectRelease_n((uint64_t)v162._object, 5LL);
        unint64_t v182 = v315._countAndFlagsBits;
        Swift::String::Index v183 = v315._object;
        swift_bridgeObjectRetain((unint64_t)v315._object, v184, v185, v186);
        unint64_t v187 = _StringGuts._convertedToSmall()(v182, (unint64_t)v183);
        unint64_t v189 = v188;
        swift_bridgeObjectRelease((uint64_t)v183);
        v190._Swift::UInt64 rawBits = (v170 << 16) | 1;
        v191._Swift::UInt64 rawBits = 1LL;
        v192._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v191,  v190,  v162._countAndFlagsBits,  (unint64_t)v162._object);
        if (v192._rawBits < 0x10000) {
          v192._rawBits |= 3;
        }
        unint64_t v194 = specialized String.init(_:)(v192, v193, v162._countAndFlagsBits, (unint64_t)v162._object);
        unint64_t v196 = v195;
        swift_bridgeObjectRelease((uint64_t)v162._object);
        unint64_t v197 = _StringGuts._convertedToSmall()(v194, v196);
        unint64_t v199 = v198;
        swift_bridgeObjectRelease(v196);
        unint64_t v200 = specialized _SmallString.init(_:appending:)(v187, v189, v197, v199);
        if ((v202 & 1) != 0) {
          goto LABEL_283;
        }
        uint64_t v203 = v200;
        uint64_t v204 = v201;
        swift_bridgeObjectRelease((uint64_t)v162._object);
        Swift::String::Index v181 = v315._object;
        v315._unint64_t countAndFlagsBits = v203;
        v315._unint64_t object = v204;
        goto LABEL_171;
      }
    }

    else if (v174 <= 15)
    {
      goto LABEL_167;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v174, v173);
    swift_bridgeObjectRelease_n((uint64_t)v162._object, 4LL);
    if (((uint64_t)v162._object & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v162._object);
      _StringGuts._foreignAppendInPlace(_:)(v162._countAndFlagsBits, (unint64_t)v162._object, 0LL, v170);
      swift_bridgeObjectRelease_n((uint64_t)v162._object, 2LL);
      a1 = v313;
    }

    else
    {
      if (v167)
      {
        swift_bridgeObjectRelease_n((uint64_t)v162._object, 2LL);
        *(void *)&__int128 v314 = v162._countAndFlagsBits;
        *((void *)&v314 + 1) = (uint64_t)v162._object & 0xFFFFFFFFFFFFFFLL;
        unint64_t v179 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v162._object >> 56) & 0xF,  (uint64_t)&v314,  ((unint64_t)v162._object >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v179, v180, ((uint64_t)v162._object & 0x4000000000000000LL) != 0);
        Swift::String::Index v181 = v162._object;
LABEL_171:
        swift_bridgeObjectRelease((uint64_t)v181);
        a1 = v313;
        goto LABEL_189;
      }

      if ((v162._countAndFlagsBits & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease((uint64_t)v162._object);
        id v220 = (id)(((uint64_t)v162._object & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v221 = v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        id v220 = _StringObject.sharedUTF8.getter(v162._countAndFlagsBits, (uint64_t)v162._object);
        uint64_t v221 = v309;
        swift_bridgeObjectRelease((uint64_t)v162._object);
        if (v221 < (v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
LABEL_282:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }

      a1 = v313;
      unint64_t v222 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL,  (uint64_t)v220,  v221);
      _StringGuts.appendInPlace(_:isASCII:)(v222, v223, v162._countAndFlagsBits < 0);
      swift_bridgeObjectRelease_n((uint64_t)v162._object, 2LL);
    }

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _SwiftStdlibVersion()
{
  return _SwiftStdlibVersion.description.getter(*v0);
}

unint64_t CollectionDifference.insertions.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_bridgeObjectRetain(*v4, a2, a3, a4);
}

unint64_t CollectionDifference.removals.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_bridgeObjectRetain(*(void *)(v4 + 8), a2, a3, a4);
}

void CollectionDifference.init<A>(_:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  if ((static CollectionDifference._validateChanges<A>(_:)(a1, a2, a3, a4) & 1) != 0)
  {
    CollectionDifference.init<A>(_validatedChanges:)(a1, a2, a3, a4, (__objc2_class ***)&v11);
    __int128 v10 = v11;
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
    __int128 v10 = 0uLL;
  }

  *a5 = v10;
}

uint64_t static CollectionDifference._validateChanges<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v120 = a2;
  uint64_t v7 = type metadata accessor for CollectionDifference.Change(0LL, a2, a3, a4);
  uint64_t v130 = *(void *)(v7 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](v7);
  unint64_t v121 = (unsigned __int8 *)&v112 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v126 = (char *)&v112 - v11;
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  unint64_t v127 = (unsigned __int8 *)&v112 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  BOOL v129 = (uint64_t *)((char *)&v112 - v15);
  MEMORY[0x1895F8858](v14);
  unint64_t v131 = (char *)&v112 - v16;
  uint64_t v19 = type metadata accessor for Optional(0LL, v7, v17, v18);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  Swift::String::Index v22 = (char *)&v112 - v21;
  uint64_t v23 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v20);
  Swift::String::Index v25 = (char *)&v112 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v26,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v122 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v29 = (char *)&v112 - v28;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 104))(a3, a4) & 1) != 0)
  {
    char v30 = 1;
    return v30 & 1;
  }

  char v133 = &_swiftEmptySetSingleton;
  uint64_t v134 = &_swiftEmptySetSingleton;
  (*(void (**)(char *, uint64_t, uint64_t))(v23 + 16))(v25, a1, a3);
  (*(void (**)(uint64_t, uint64_t))(v26 + 32))(a3, v26);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v26,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  char v32 = v29;
  unint64_t v118 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v119 = AssociatedConformanceWitness;
  v118(AssociatedTypeWitness);
  uint64_t v33 = v130;
  unint64_t v34 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v130 + 48);
  uint64_t v114 = v7;
  uint64_t v117 = v34;
  if (v34(v22, 1LL, v7) == 1)
  {
    uint64_t v123 = &_swiftEmptyDictionarySingleton;
    char v128 = &_swiftEmptyDictionarySingleton;
LABEL_5:
    (*(void (**)(char *, unint64_t))(v122 + 8))(v32, AssociatedTypeWitness);
    swift_bridgeObjectRelease((uint64_t)v133);
    swift_bridgeObjectRelease((uint64_t)v134);
    unint64_t v35 = v123;
    unint64_t v36 = v128;
    char v30 = specialized static Dictionary<>.== infix(_:_:)((unint64_t)v123, (uint64_t)v128);
    swift_bridgeObjectRelease((uint64_t)v36);
    swift_bridgeObjectRelease((uint64_t)v35);
    return v30 & 1;
  }

  unint64_t v37 = v22;
  char v38 = *(void (**)(unsigned __int8 *, char *, uint64_t))(v33 + 32);
  uint64_t v123 = &_swiftEmptyDictionarySingleton;
  uint64_t v124 = v38;
  char v128 = &_swiftEmptyDictionarySingleton;
  uint64_t v39 = v131;
  uint64_t v40 = v120;
  uint64_t v41 = v114;
  id v116 = v32;
  unint64_t v113 = v37;
  unint64_t v115 = AssociatedTypeWitness;
  v38((unsigned __int8 *)v131, v37, v114);
  while (1)
  {
    unint64_t v43 = *(void (**)(uint64_t *, char *, uint64_t))(v33 + 16);
    uint64_t v44 = v129;
    v43(v129, v39, v41);
    uint64_t v45 = *v44;
    int64_t v46 = (char *)v44
        + *((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v40,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
          + 12);
    char v47 = v39;
    uint64_t v48 = v40;
    uint64_t v49 = *(void (**)(char *, uint64_t))(*(void *)(v40 - 8) + 8LL);
    v49(v46, v48);
    if (v45 < 0)
    {
      (*(void (**)(char *, uint64_t))(v33 + 8))(v47, v41);
LABEL_60:
      (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
      swift_bridgeObjectRelease((uint64_t)v133);
      swift_bridgeObjectRelease((uint64_t)v134);
      goto LABEL_55;
    }

    uint64_t v50 = (void (*)(unsigned __int8 *, uint64_t))v49;
    char v51 = v43;
    uint64_t v52 = v127;
    uint64_t v125 = (void (*)(char *, char *, uint64_t))v51;
    v51((uint64_t *)v127, v47, v41);
    int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v52, v41);
    uint64_t v40 = v48;
    unsigned __int8 v54 = &v52[*((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v48,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
               + 12)];
    if (EnumCaseMultiPayload == 1)
    {
      size_t v55 = v133;
      uint64_t v56 = v50;
      uint64_t v57 = v45;
      if (v133[2])
      {
        uint64_t v58 = specialized static Hasher._hash(seed:_:)((uint64_t)v133[5], v45);
        uint64_t v59 = -1LL << *((_BYTE *)v55 + 32);
        unint64_t v60 = v58 & ~v59;
        if (((*(unint64_t *)((char *)v55 + ((v60 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> v60) & 1) != 0)
        {
          uint64_t v61 = ~v59;
          while (*((void *)&v55[6]->isa + v60) != v45)
          {
            unint64_t v60 = (v60 + 1) & v61;
          }

          goto LABEL_54;
        }
      }
    }

    else
    {
      unint64_t v62 = v134;
      uint64_t v56 = v50;
      uint64_t v57 = v45;
      if (v134[2])
      {
        uint64_t v63 = specialized static Hasher._hash(seed:_:)((uint64_t)v134[5], v45);
        uint64_t v64 = -1LL << *((_BYTE *)v62 + 32);
        unint64_t v65 = v63 & ~v64;
        if (((*(unint64_t *)((char *)v62 + ((v65 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> v65) & 1) != 0)
        {
          uint64_t v66 = ~v64;
          while (*((void *)&v62[6]->isa + v65) != v45)
          {
            unint64_t v65 = (v65 + 1) & v66;
          }

void CollectionDifference.init<A>(_validatedChanges:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, __objc2_class ***a5@<X8>)
{
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, a2, a3, a4);
  uint64_t v11 = *(v10 - 1);
  uint64_t v78 = *(void *)(v11 + 64);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (unsigned __int8 *)&v76 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v83 = a2;
  uint64_t v84 = a3;
  uint64_t v85 = a4;
  uint64_t v79 = v16;
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))( (char *)&v76 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a1,  a3);
  uint64_t v86 = (*(uint64_t (**)(uint64_t))(*(void *)(a4 + 8) + 56LL))(a3);
  uint64_t v19 = type metadata accessor for ContiguousArray(0LL, (uint64_t)v10, v17, v18);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v19, v20);
  uint64_t v23 = (void *)swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v19, v22);
  MutableCollection<>.sort(by:)( partial apply for closure #1 in CollectionDifference.init<A>(_validatedChanges:),  (uint64_t)v82,  v19,  WitnessTable,  v23);
  uint64_t v24 = v86;
  uint64_t v80 = a1;
  uint64_t v81 = a3;
  if (Array._getCount()())
  {
    Swift::Int v25 = Array._getCount()();
    if (v25 < 0) {
LABEL_36:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
    Swift::Int v26 = v25;
    if (v25)
    {
      uint64_t v77 = a5;
      uint64_t v27 = 0LL;
      do
      {
        if (__OFADD__(v27, v26))
        {
          __break(1u);
          goto LABEL_38;
        }

        uint64_t v29 = (v27 + v26) / 2;
        char v30 = ((v24 & 0xC000000000000001LL) == 0) | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v29, v30 & 1);
        if ((v30 & 1) != 0)
        {
          (*(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v11 + 16))( v14,  v24 + ((*(unsigned __int8 *)(v11 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))
          + *(void *)(v11 + 72) * v29,
            v10);
        }

        else
        {
          id v31 = _ArrayBuffer._getElementSlowPath(_:)(v29, v24, v10);
          char v32 = v31;
          if (v78 != 8)
          {
            swift_unknownObjectRelease(v31);
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
          }

          uint64_t v86 = (uint64_t)v31;
          (*(void (**)(unsigned __int8 *, uint64_t *, uint64_t *))(v11 + 16))(v14, &v86, v10);
          swift_unknownObjectRelease(v32);
        }

        if (swift_getEnumCaseMultiPayload(v14, (uint64_t)v10) == 1)
        {
          if (v26 <= v29) {
            goto LABEL_36;
          }
          uint64_t v27 = v29 + 1;
        }

        else
        {
          Swift::Int v26 = (v27 + v26) / 2;
          if (v29 < v27) {
            goto LABEL_36;
          }
        }

        TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a2,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
        (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)(a2 - 8) + 8LL))( &v14[*((int *)TupleTypeMetadata3 + 12)],  a2);
      }

      while (v27 != v26);
      a5 = v77;
      if (v26 < 0) {
LABEL_38:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  else
  {
    Swift::Int v26 = 0LL;
  }

  Array._checkIndex(_:)(0LL);
  Array._checkIndex(_:)(v26);
  swift_retain((unint64_t *)v24, v33, v34, v35);
  char v38 = (void *)_ArrayBuffer.subscript.getter(0LL, v26, v24, v10);
  uint64_t v40 = v39;
  uint64_t v41 = v36;
  unint64_t v42 = v37;
  if ((v37 & 1) == 0) {
    goto LABEL_19;
  }
  uint64_t v47 = type metadata accessor for __ContiguousArrayStorageBase();
  uint64_t v50 = swift_unknownObjectRetain_n((uint64_t)v38, 2LL, v48, v49);
  char v51 = (__objc2_class **)swift_dynamicCastClass(v50, v47);
  if (!v51)
  {
    swift_unknownObjectRelease(v38);
    char v51 = &_swiftEmptyArrayStorage;
  }

  uint64_t v52 = v51[2];
  uint64_t v53 = (void *)swift_release((uint64_t)v51);
  if (__OFSUB__(v42 >> 1, v41))
  {
    __break(1u);
    goto LABEL_40;
  }

  uint64_t v53 = v38;
  if (v52 != (__objc2_class *)((v42 >> 1) - v41))
  {
LABEL_40:
    swift_unknownObjectRelease(v53);
LABEL_19:
    uint64_t v86 = (uint64_t)v38;
    uint64_t v87 = v40;
    uint64_t v88 = v41;
    unint64_t v89 = v42;
    uint64_t v43 = type metadata accessor for ArraySlice(0LL, (uint64_t)v10, v36, v37);
    uint64_t v45 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v43, v44);
    int64_t v46 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v86, v43, v45);
    swift_unknownObjectRelease(v38);
    goto LABEL_26;
  }

  int64_t v46 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v38, v47);
  swift_unknownObjectRelease(v38);
  if (!v46)
  {
    swift_unknownObjectRelease(v38);
    int64_t v46 = &_swiftEmptyArrayStorage;
  }

BOOL closure #1 in CollectionDifference.init<A>(_validatedChanges:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for CollectionDifference.Change(0LL, a3, a3, a4);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  unint64_t v42 = (char *)&v38 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  char v38 = (char *)&v38 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v38 - v14;
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v38 - v16;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, 0LL, 0LL);
  uint64_t v40 = *(TupleTypeMetadata2 - 1);
  uint64_t v19 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v21 = (unsigned __int8 *)&v38 - v20;
  uint64_t v41 = v19;
  uint64_t v22 = (unsigned __int8 *)&v38 + *(int *)(v19 + 48) - v20;
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  uint64_t v39 = a1;
  v23((char *)&v38 - v20, a1, v7);
  uint64_t v43 = a2;
  v23((char *)v22, a2, v7);
  if (swift_getEnumCaseMultiPayload(v21, v7) != 1)
  {
    v23(v15, (uint64_t)v21, v7);
    uint64_t v28 = *((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a3,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
          + 12);
    Swift::Int v25 = &v15[v28];
    if (swift_getEnumCaseMultiPayload(v22, v7) == 1)
    {
      uint64_t v29 = *(void (**)(unsigned __int8 *, uint64_t))(*(void *)(a3 - 8) + 8LL);
      v29(&v22[v28], a3);
      v29((unsigned __int8 *)&v15[v28], a3);
      BOOL v27 = 0LL;
      goto LABEL_7;
    }

void CollectionDifference.inverse()( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, __objc2_class ***a4@<X8>)
{
  uint64_t v53 = a1;
  uint64_t v54 = *(void *)(a1 + 16);
  uint64_t v6 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, v54, a2, a3);
  uint64_t v52 = *(v6 - 1);
  uint64_t v7 = MEMORY[0x1895F8858](v6);
  char v51 = (unsigned __int8 *)&v46 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v50 = (char *)&v46 - v10;
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v49 = (uint64_t)&v46 - v12;
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v46 - v13;
  uint64_t v15 = v4[1];
  v58[0] = *v4;
  v58[1] = v15;
  Swift::Int v16 = Array._getCount()();
  Swift::Int v17 = Array._getCount()();
  Swift::Int v20 = v16 + v17;
  if (__OFADD__(v16, v17))
  {
    __break(1u);
    goto LABEL_12;
  }

  int64_t v46 = a4;
  if (!v20)
  {
    _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
    unint64_t v42 = &_swiftEmptyArrayStorage;
    goto LABEL_10;
  }

  uint64_t v57 = &_swiftEmptyArrayStorage;
  uint64_t v48 = type metadata accessor for ContiguousArray(0LL, (uint64_t)v6, v18, v19);
  ContiguousArray.reserveCapacity(_:)(v20);
  if (v20 < 0) {
LABEL_12:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  Swift::Int v23 = 0LL;
  Swift::Int v47 = v20;
  uint64_t v24 = v50;
  uint64_t v25 = v54;
  while (v20 != v23)
  {
    Swift::Int v55 = v23 + 1;
    uint64_t v26 = v49;
    CollectionDifference.subscript.getter(v23, v53, v21, v22, v49);
    uint64_t v27 = v52;
    (*(void (**)(char *, uint64_t, uint64_t *))(v52 + 32))(v24, v26, v6);
    uint64_t v28 = v51;
    (*(void (**)(unsigned __int8 *, char *, uint64_t *))(v27 + 16))(v51, v24, v6);
    unsigned int v29 = swift_getEnumCaseMultiPayload(v28, (uint64_t)v6) != 1;
    uint64_t v30 = *(void *)v28;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v25,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    uint64_t v32 = *((int *)TupleTypeMetadata3 + 12);
    uint64_t v33 = &v28[v32];
    uint64_t v34 = &v28[*((int *)TupleTypeMetadata3 + 16)];
    uint64_t v35 = *(void *)v34;
    LOBYTE(v28) = v34[8];
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(*(void *)(v25 - 8) + 32LL))(&v14[v32], v33, v25);
    uint64_t v36 = &v14[*((int *)TupleTypeMetadata3 + 16)];
    *(void *)uint64_t v14 = v30;
    *(void *)uint64_t v36 = v35;
    v36[8] = (char)v28;
    swift_storeEnumTagMultiPayload(v14, (size_t)v6, v29);
    uint64_t v37 = *(void (**)(char *, uint64_t *))(v27 + 8);
    Swift::Int v20 = v47;
    v37(v24, v6);
    ContiguousArray.append(_:)((uint64_t)v14, v48);
    Swift::Int v23 = v55;
    if (v55 == 0x8000000000000000LL)
    {
      __break(1u);
      break;
    }
  }

  Swift::Int v56 = v20;
  uint64_t v38 = v53;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, v53, v21);
  _expectEnd<A>(of:is:)((uint64_t)v58, (uint64_t)&v56, v38, WitnessTable);
  unint64_t v42 = v57;
LABEL_10:
  v58[0] = v42;
  uint64_t v43 = type metadata accessor for Array(0LL, (uint64_t)v6, v40, v41);
  uint64_t v45 = swift_getWitnessTable(&protocol conformance descriptor for [A], v43, v44);
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)v58, v54, v43, v45, v46);
}

BOOL static CollectionDifference.CodingKeys.== infix(_:_:)(int a1, int a2)
{
  return ((a2 ^ a1) & 1) == 0;
}

void CollectionDifference.CodingKeys.hash(into:)(uint64_t a1, char a2)
{
}

uint64_t CollectionDifference.CodingKeys.init(stringValue:)(uint64_t a1, unint64_t a2)
{
  if (a1 == 0x6F69747265736E69LL && a2 == 0xEA0000000000736ELL) {
    goto LABEL_10;
  }
  if ((~a2 & 0x6000000000000000LL) == 0)
  {
    if (a1 != 0x736C61766F6D6572LL || a2 != 0xE800000000000000LL)
    {
      swift_bridgeObjectRelease(a2);
      swift_bridgeObjectRelease(0xE800000000000000LL);
      return 2LL;
    }

    goto LABEL_13;
  }

  if ((_stringCompareInternal(_:_:expecting:)(0x6F69747265736E69LL, 0xEA0000000000736ELL, a1, a2, 0) & 1) != 0)
  {
LABEL_10:
    swift_bridgeObjectRelease(a2);
    return 0LL;
  }

  if (a1 == 0x736C61766F6D6572LL && a2 == 0xE800000000000000LL)
  {
LABEL_13:
    swift_bridgeObjectRelease_n(0xE800000000000000LL, 2LL);
    return 1LL;
  }

  char v6 = _stringCompareInternal(_:_:expecting:)(0x736C61766F6D6572LL, 0xE800000000000000LL, a1, a2, 0);
  swift_bridgeObjectRelease(a2);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  if ((v6 & 1) != 0) {
    return 1LL;
  }
  else {
    return 2LL;
  }
}

Swift::Int CollectionDifference.CodingKeys.hashValue.getter(char a1)
{
  return Hasher._finalize()();
}

uint64_t CollectionDifference.CodingKeys.stringValue.getter(char a1)
{
  if ((a1 & 1) != 0) {
    return 0x736C61766F6D6572LL;
  }
  else {
    return 0x6F69747265736E69LL;
  }
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.CodingKeys( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return static CollectionDifference.CodingKeys.== infix(_:_:)(*a1, *a2);
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  return CollectionDifference.CodingKeys.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.CodingKeys(uint64_t a1)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance CollectionDifference<A>.CodingKeys( uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  CollectionDifference.CodingKeys.hash(into:)((uint64_t)v3, *v1);
  return Hasher._finalize()();
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  return CollectionDifference.CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance CollectionDifference<A>.CodingKeys@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result = CollectionDifference.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CodingKey.intValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  return 0LL;
}

void protocol witness for CodingKey.init(intValue:) in conformance CollectionDifference<A>.CodingKeys( _BYTE *a1@<X8>)
{
  *a1 = 2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance CollectionDifference<A>.CodingKeys( uint64_t *a1)
{
  return CodingKey.description.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.CodingKeys);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance CollectionDifference<A>.CodingKeys( uint64_t a1)
{
  return CodingKey.debugDescription.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.CodingKeys);
}

uint64_t CollectionDifference.startIndex.getter()
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
}

Swift::Int CollectionDifference.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  Swift::Int v4 = Array._getCount()();
  Swift::Int v5 = Array._getCount()();
  BOOL v6 = __OFADD__(v4, v5);
  Swift::Int result = v4 + v5;
  if (v6) {
    __break(1u);
  }
  return result;
}

uint64_t CollectionDifference.index(after:)(uint64_t a1)
{
  return specialized CollectionDifference.index(after:)(a1);
}

void CollectionDifference.subscript.getter( Swift::Int a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  Swift::Int v8 = *v5;
  Swift::Int v9 = v5[1];
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, *(void *)(a2 + 16), a3, a4);
  Swift::Int v11 = Array._getCount()();
  if (v11 > a1)
  {
    Swift::Int v8 = v11 - (a1 + 1);
    if (!__OFSUB__(v11, a1 + 1))
    {
      char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      char v13 = ((v9 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
      Array._checkSubscript(_:wasNativeTypeChecked:)( v8,  (v9 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
      if ((v13 & 1) != 0)
      {
        uint64_t v14 = *(v10 - 1);
        unint64_t v15 = v9
LABEL_8:
        (*(void (**)(uint64_t, unint64_t, uint64_t *))(v14 + 16))(a5, v15, v10);
        return;
      }

      goto LABEL_11;
    }

    __break(1u);
LABEL_10:
    __break(1u);
LABEL_11:
    unint64_t v18 = v8;
    uint64_t v19 = v9;
    goto LABEL_13;
  }

  Swift::Int v9 = a1 - v11;
  if (__OFSUB__(a1, v11)) {
    goto LABEL_10;
  }
  char v16 = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
  char v17 = ((v8 & 0xC000000000000001LL) == 0) | ~v16;
  Array._checkSubscript(_:wasNativeTypeChecked:)(v9, (v8 & 0xC000000000000001LL) == 0 || (v16 & 1) == 0);
  if ((v17 & 1) != 0)
  {
    uint64_t v14 = *(v10 - 1);
    unint64_t v15 = v8
    goto LABEL_8;
  }

  unint64_t v18 = v9;
  uint64_t v19 = v8;
LABEL_13:
  id v20 = _ArrayBuffer._getElementSlowPath(_:)(v18, v19, v10);
  uint64_t v21 = v20;
  uint64_t v22 = *(v10 - 1);
  if (*(void *)(v22 + 64) != 8LL)
  {
    swift_unknownObjectRelease(v20);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }

  id v23 = v20;
  (*(void (**)(uint64_t, id *, uint64_t *))(v22 + 16))(a5, &v23, v10);
  swift_unknownObjectRelease(v21);
}

uint64_t CollectionDifference.index(before:)(uint64_t a1)
{
  BOOL v1 = __OFSUB__(a1, 1LL);
  uint64_t result = a1 - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

void *CollectionDifference.formIndex(_:offsetBy:)(void *result, uint64_t a2)
{
  if (__OFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

uint64_t CollectionDifference.distance(from:to:)(uint64_t a1, uint64_t a2)
{
  return Array.distance(from:to:)(a1, a2);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance CollectionDifference<A>@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
  *a1 = result;
  return result;
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance CollectionDifference<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, Swift::Int *a5@<X8>)
{
  Swift::Int result = CollectionDifference.endIndex.getter(a1, a2, a3, a4);
  *a5 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance CollectionDifference<A>( uint64_t **a1, Swift::Int *a2, uint64_t a3))()
{
  BOOL v6 = (uint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (uint64_t)CollectionDifference.subscript.read(v6, *a2, a3, v7);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*CollectionDifference.subscript.read( uint64_t *a1, Swift::Int a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v7 = type metadata accessor for CollectionDifference.Change(0LL, *(void *)(a3 + 16), a3, a4);
  *a1 = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  a1[1] = v8;
  Swift::Int v9 = malloc(*(void *)(v8 + 64));
  a1[2] = (uint64_t)v9;
  CollectionDifference.subscript.getter(a2, a3, v10, v11, (uint64_t)v9);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance CollectionDifference<A>( uint64_t *a1, uint64_t *a2)
{
  return Array.distance(from:to:)(*a1, *a2);
}

uint64_t protocol witness for Collection.index(after:) in conformance CollectionDifference<A>@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized CollectionDifference.index(after:)(*a1);
  *a2 = result;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance CollectionDifference<A>( uint64_t *a1)
{
  uint64_t result = specialized CollectionDifference.index(after:)(*a1);
  *a1 = result;
  return result;
}

__n128 protocol witness for Sequence.makeIterator() in conformance CollectionDifference<A>@<Q0>( __n128 *a1@<X8>)
{
  uint64_t v3 = protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
  __n128 result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = v3;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance CollectionDifference<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance CollectionDifference<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

BOOL static CollectionDifference.Index.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.Index( uint64_t *a1, uint64_t *a2)
{
  return static CollectionDifference.Index.== infix(_:_:)(*a1, *a2);
}

BOOL static CollectionDifference.Index.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance CollectionDifference<A>.Index( uint64_t *a1, uint64_t *a2)
{
  return static CollectionDifference.Index.< infix(_:_:)(*a1, *a2);
}

void CollectionDifference.Index.hash(into:)(int a1, Swift::UInt a2)
{
}

Swift::Int CollectionDifference.Index.hashValue.getter(Swift::UInt a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance CollectionDifference<A>.Index()
{
  return CollectionDifference.Index.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.Index(int a1)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance CollectionDifference<A>.Index( uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  CollectionDifference.Index.hash(into:)((int)v3, *v1);
  return Hasher._finalize()();
}

uint64_t static CollectionDifference.Change<A>.== infix(_:_:)( unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v75 = a4;
  uint64_t v81 = a1;
  BOOL v82 = a2;
  uint64_t v80 = *(void *)(a3 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v76 = &v73[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  Swift::Int v9 = &v73[-v8];
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = &v73[-v11];
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = &v73[-v13];
  uint64_t v17 = type metadata accessor for CollectionDifference.Change(0LL, v15, v15, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (uint64_t *)&v73[-((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  MEMORY[0x1895F8858](v19);
  id v23 = (uint64_t *)&v73[-v22];
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v17, v17, 0LL, 0LL);
  uint64_t v78 = *(TupleTypeMetadata2 - 1);
  uint64_t v25 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v27 = &v73[-v26];
  uint64_t v79 = v25;
  uint64_t v28 = &v73[*(int *)(v25 + 48) - v26];
  uint64_t v77 = v18;
  unsigned int v29 = *(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v18 + 16);
  v29(&v73[-v26], v81, v17);
  v29(v28, v82, v17);
  if (swift_getEnumCaseMultiPayload(v27, v17) == 1)
  {
    BOOL v82 = v9;
    v29((unsigned __int8 *)v21, v27, v17);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a3,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    uint64_t v31 = *((int *)TupleTypeMetadata3 + 12);
    uint64_t v32 = (char *)v21 + v31;
    uint64_t v33 = *((int *)TupleTypeMetadata3 + 16);
    uint64_t v81 = *(unsigned __int8 **)((char *)v21 + v33);
    int v34 = *((unsigned __int8 *)v21 + v33 + 8);
    uint64_t v35 = a3;
    if (swift_getEnumCaseMultiPayload(v28, v17) == 1)
    {
      int v74 = v34;
      uint64_t v36 = *v21;
      uint64_t v37 = *(void *)v28;
      uint64_t v38 = &v28[v31];
      uint64_t v79 = *(void *)&v28[v33];
      LODWORD(v78) = v28[v33 + 8];
      uint64_t v39 = v80;
      uint64_t v40 = *(void (**)(unsigned __int8 *, char *, uint64_t))(v80 + 32);
      uint64_t v41 = v82;
      v40(v82, v32, v35);
      unint64_t v42 = v76;
      v40(v76, (char *)v38, v35);
      if (v36 == v37)
      {
        uint64_t v43 = (unsigned __int8 *)v79;
        char v44 = v78;
        char v45 = (*(uint64_t (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v75 + 8))(v41, v42, v35);
        int64_t v46 = v42;
        Swift::Int v47 = *(void (**)(unsigned __int8 *, uint64_t))(v39 + 8);
        v47(v46, v35);
        v47(v41, v35);
        if ((v45 & 1) != 0)
        {
          if ((v74 & 1) != 0)
          {
            uint64_t v48 = v77;
            if ((v44 & 1) != 0) {
              goto LABEL_30;
            }
          }

          else
          {
            if (v81 == v43) {
              char v70 = v44;
            }
            else {
              char v70 = 1;
            }
            uint64_t v48 = v77;
            if ((v70 & 1) == 0) {
              goto LABEL_30;
            }
          }

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> CollectionDifference<A>.Change( unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  return static CollectionDifference.Change<A>.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a4 - 8));
}

uint64_t static CollectionDifference<A>.== infix(_:_:)(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v61 = a3;
  uint64_t v62 = a4;
  uint64_t v6 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, a3, a3, a4);
  uint64_t v7 = *(v6 - 1);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = MEMORY[0x1895F8858](v6);
  uint64_t v55 = (unsigned __int8 *)&v54 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  char v60 = (unsigned __int8 *)&v54 - v11;
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (unsigned __int8 *)&v54 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (unsigned __int8 *)&v54 - v15;
  uint64_t v18 = *a1;
  uint64_t v17 = a1[1];
  uint64_t v20 = *a2;
  uint64_t v19 = a2[1];
  Swift::Int v21 = Array._getCount()();
  if (v21 != Array._getCount()()) {
    return 0LL;
  }
  uint64_t v56 = v17;
  uint64_t v57 = v19;
  uint64_t v54 = v8;
  if (v21)
  {
    uint64_t v22 = _ArrayBuffer.identity.getter(v18, v6);
    if (v22 != _ArrayBuffer.identity.getter(v20, v6))
    {
      if (v21 < 0) {
        goto LABEL_36;
      }
      unint64_t v23 = 0LL;
      unint64_t v58 = v20 & 0xC000000000000001LL;
      unint64_t v59 = v18 & 0xC000000000000001LL;
      while (v21 != v23)
      {
        BOOL v24 = v59 == 0;
        char v25 = v24 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v23, v25 & 1);
        if ((v25 & 1) != 0)
        {
          uint64_t v26 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
          v26( v16,  v18 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
          + *(void *)(v7 + 72) * v23,
            v6);
        }

        else
        {
          id v31 = _ArrayBuffer._getElementSlowPath(_:)(v23, v18, v6);
          uint64_t v32 = v31;
          if (v54 != 8) {
            goto LABEL_37;
          }
          id v63 = v31;
          uint64_t v26 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
          v26(v16, (unint64_t)&v63, v6);
          swift_unknownObjectRelease(v32);
        }

        BOOL v27 = v58 == 0;
        char v28 = v27 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v23, v28 & 1);
        if ((v28 & 1) != 0)
        {
          v26( v14,  v20 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
          + *(void *)(v7 + 72) * v23,
            v6);
        }

        else
        {
          id v33 = _ArrayBuffer._getElementSlowPath(_:)(v23, v20, v6);
          uint64_t v32 = v33;
          if (v54 != 8)
          {
LABEL_37:
            int v53 = v32;
            goto LABEL_39;
          }

          id v63 = v33;
          v26(v14, (unint64_t)&v63, v6);
          swift_unknownObjectRelease(v32);
        }

        char v29 = static CollectionDifference.Change<A>.== infix(_:_:)(v16, v14, v61, v62);
        uint64_t v30 = *(void (**)(unsigned __int8 *, uint64_t *))(v7 + 8);
        v30(v14, v6);
        v30(v16, v6);
        ++v23;
        if ((v29 & 1) == 0) {
          return 0LL;
        }
      }
    }
  }

  uint64_t v34 = v56;
  Swift::Int v35 = Array._getCount()();
  if (v35 != Array._getCount()()) {
    return 0LL;
  }
  if (v35)
  {
    uint64_t v36 = _ArrayBuffer.identity.getter(v34, v6);
    if (v36 != _ArrayBuffer.identity.getter(v57, v6))
    {
      if ((v35 & 0x8000000000000000LL) == 0)
      {
        unint64_t v37 = 0LL;
        unint64_t v59 = v34 & 0xC000000000000001LL;
        unint64_t v38 = v57 & 0xC000000000000001LL;
        uint64_t v39 = v55;
        while (1)
        {
          BOOL v40 = v35 == v37;
          if (v35 == v37) {
            return v40;
          }
          BOOL v41 = v59 == 0;
          char v42 = v41 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
          Array._checkSubscript(_:wasNativeTypeChecked:)(v37, v42 & 1);
          if ((v42 & 1) != 0)
          {
            uint64_t v43 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
            v43( v60,  v34 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
            + *(void *)(v7 + 72) * v37,
              v6);
          }

          else
          {
            id v49 = _ArrayBuffer._getElementSlowPath(_:)(v37, v34, v6);
            uint64_t v50 = v49;
            if (v54 != 8) {
              goto LABEL_38;
            }
            id v63 = v49;
            uint64_t v43 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
            v43(v60, (unint64_t)&v63, v6);
            swift_unknownObjectRelease(v50);
          }

          uint64_t v44 = v57;
          char v45 = (v38 == 0) | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
          Array._checkSubscript(_:wasNativeTypeChecked:)(v37, v45 & 1);
          if ((v45 & 1) != 0)
          {
            v43( v39,  v44 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
            + *(void *)(v7 + 72) * v37,
              v6);
          }

          else
          {
            id v51 = _ArrayBuffer._getElementSlowPath(_:)(v37, v44, v6);
            uint64_t v50 = v51;
            if (v54 != 8)
            {
LABEL_38:
              int v53 = v50;
LABEL_39:
              swift_unknownObjectRelease(v53);
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
            }

            id v63 = v51;
            v43(v39, (unint64_t)&v63, v6);
            swift_unknownObjectRelease(v50);
          }

          int64_t v46 = v60;
          char v47 = static CollectionDifference.Change<A>.== infix(_:_:)(v60, v39, v61, v62);
          uint64_t v48 = *(void (**)(unsigned __int8 *, uint64_t *))(v7 + 8);
          v48(v39, v6);
          v48(v46, v6);
          ++v37;
          uint64_t v34 = v56;
          if ((v47 & 1) == 0) {
            return v40;
          }
        }
      }

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> CollectionDifference<A>( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return static CollectionDifference<A>.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a4 - 8));
}

void CollectionDifference.Change<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v26 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (unsigned __int8 *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(v17 + 16))(v16, v3, a2);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v16, a2);
  Swift::UInt v19 = *(void *)v16;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v7,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
  Swift::Int v21 = &v16[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v22 = &v16[*((int *)TupleTypeMetadata3 + 16)];
  Swift::UInt v23 = *(void *)v22;
  int v24 = v22[8];
  char v25 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v8 + 32);
  if (EnumCaseMultiPayload == 1)
  {
    v25(v11, v21, v7);
    Hasher._combine(_:)(1uLL);
    Hasher._combine(_:)(v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v7, a3);
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
  }

  else
  {
    v25(v14, v21, v7);
    Hasher._combine(_:)(0LL);
    Hasher._combine(_:)(v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v7, a3);
    (*(void (**)(char *, uint64_t))(v8 + 8))(v14, v7);
  }

  if (v24)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v23);
  }

Swift::Int CollectionDifference.Change<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice<>.hashValue.getter( a1,  a2,  (void (*)(void *, uint64_t, uint64_t))CollectionDifference.Change<A>.hash(into:));
}

Swift::Int DiscontiguousSlice<>.hashValue.getter( uint64_t a1, uint64_t a2, void (*a3)(void *, uint64_t, uint64_t))
{
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  a3(v4, a1, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> CollectionDifference<A>.Change( uint64_t a1, uint64_t a2)
{
  return CollectionDifference.Change<A>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> CollectionDifference<A>.Change( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> CollectionDifference<A>.Change( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))CollectionDifference.Change<A>.hash(into:));
}

void CollectionDifference<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v90 = a3;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v84 = *(void *)(v5 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  int v73 = (char *)&v71 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v72 = (char *)&v71 - v9;
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v75 = (char *)&v71 - v11;
  MEMORY[0x1895F8858](v10);
  int v74 = (char *)&v71 - v12;
  uint64_t v15 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, v5, v13, v14);
  uint64_t v16 = *(v15 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v80 = (unsigned __int8 *)&v71 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v86 = (char *)&v71 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v79 = (char *)&v71 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v83 = (unsigned __int8 *)&v71 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  BOOL v27 = (char *)&v71 - v26;
  uint64_t v71 = v28;
  MEMORY[0x1895F8858](v25);
  BOOL v82 = (char *)&v71 - v29;
  uint64_t v31 = *v3;
  uint64_t v30 = v3[1];
  Swift::UInt v32 = Array._getCount()();
  Hasher._combine(_:)(v32);
  Swift::Int v33 = Array._getCount()();
  uint64_t v88 = v16;
  uint64_t v89 = v5;
  uint64_t v87 = v30;
  Swift::Int v81 = v33;
  if (v33)
  {
    unint64_t v34 = 0LL;
    uint64_t v77 = v27;
    unint64_t v78 = v31 & 0xC000000000000001LL;
    uint64_t v76 = v31;
    do
    {
      BOOL v35 = v78 == 0;
      char v36 = v35 | ~_swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v34, v36 & 1);
      if ((v36 & 1) != 0)
      {
        (*(void (**)(char *, unint64_t, uint64_t *))(v16 + 16))( v27,  v31 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80))
        + *(void *)(v16 + 72) * v34,
          v15);
        unint64_t v37 = v34 + 1;
        if (__OFADD__(v34, 1LL)) {
          goto LABEL_15;
        }
      }

      else
      {
        id v50 = _ArrayBuffer._getElementSlowPath(_:)(v34, v31, v15);
        id v51 = v50;
        if (v71 != 8)
        {
LABEL_32:
          swift_unknownObjectRelease(v51);
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }

        v91[0] = v50;
        (*(void (**)(char *, void *, uint64_t *))(v16 + 16))(v27, v91, v15);
        swift_unknownObjectRelease(v51);
        unint64_t v37 = v34 + 1;
        if (__OFADD__(v34, 1LL))
        {
LABEL_15:
          __break(1u);
          break;
        }
      }

      unint64_t v38 = *(void (**)(char *, char *, uint64_t *))(v16 + 32);
      uint64_t v39 = v82;
      v38(v82, v27, v15);
      BOOL v40 = v83;
      v38((char *)v83, v39, v15);
      LODWORD(v38) = swift_getEnumCaseMultiPayload(v40, (uint64_t)v15);
      Swift::UInt v41 = *(void *)v40;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v5,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
      uint64_t v43 = &v40[*((int *)TupleTypeMetadata3 + 12)];
      uint64_t v44 = &v40[*((int *)TupleTypeMetadata3 + 16)];
      Swift::UInt v85 = *(void *)v44;
      int v45 = v44[8];
      uint64_t v46 = v84;
      char v47 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v84 + 32);
      if ((_DWORD)v38 == 1)
      {
        uint64_t v48 = v75;
        v47(v75, v43, v5);
        Swift::UInt v49 = 1LL;
      }

      else
      {
        uint64_t v48 = v74;
        v47(v74, v43, v5);
        Swift::UInt v49 = 0LL;
      }

      Hasher._combine(_:)(v49);
      Hasher._combine(_:)(v41);
      (*(void (**)(uint64_t, uint64_t))(v90 + 24))(a1, v5);
      (*(void (**)(char *, uint64_t))(v46 + 8))(v48, v5);
      if (v45)
      {
        Hasher._combine(_:)(0);
      }

      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v85);
      }

      uint64_t v30 = v87;
      uint64_t v16 = v88;
      uint64_t v31 = v76;
      BOOL v27 = v77;
      ++v34;
      uint64_t v5 = v89;
    }

    while (v37 != v81);
  }

  Swift::UInt v52 = Array._getCount()();
  Hasher._combine(_:)(v52);
  Swift::Int v53 = Array._getCount()();
  uint64_t v54 = v84;
  uint64_t v83 = (unsigned __int8 *)v53;
  if (!v53) {
    return;
  }
  unint64_t v55 = 0LL;
  BOOL v82 = (char *)(v30 & 0xC000000000000001LL);
  while (1)
  {
    BOOL v56 = v82 == 0LL;
    char v57 = v56 | ~_swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v55, v57 & 1);
    if ((v57 & 1) == 0) {
      break;
    }
    (*(void (**)(char *, unint64_t, uint64_t *))(v16 + 16))( v86,  v30 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80))
    + *(void *)(v16 + 72) * v55,
      v15);
    unint64_t v58 = (char *)(v55 + 1);
    if (__OFADD__(v55, 1LL)) {
      goto LABEL_30;
    }
LABEL_22:
    unint64_t v59 = *(void (**)(char *, char *, uint64_t *))(v16 + 32);
    char v60 = v79;
    v59(v79, v86, v15);
    uint64_t v61 = v80;
    v59((char *)v80, v60, v15);
    LODWORD(v59) = swift_getEnumCaseMultiPayload(v61, (uint64_t)v15);
    Swift::UInt v62 = *(void *)v61;
    id v63 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v5,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    uint64_t v64 = &v61[*((int *)v63 + 12)];
    char v65 = &v61[*((int *)v63 + 16)];
    Swift::UInt v85 = *(void *)v65;
    int v66 = v65[8];
    uint64_t v67 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v54 + 32);
    if ((_DWORD)v59 == 1)
    {
      uint64_t v68 = v73;
      v67(v73, v64, v5);
      Swift::UInt v69 = 1LL;
    }

    else
    {
      uint64_t v68 = v72;
      v67(v72, v64, v5);
      Swift::UInt v69 = 0LL;
    }

    Hasher._combine(_:)(v69);
    Hasher._combine(_:)(v62);
    (*(void (**)(uint64_t, uint64_t))(v90 + 24))(a1, v5);
    (*(void (**)(char *, uint64_t))(v54 + 8))(v68, v5);
    if (v66)
    {
      Hasher._combine(_:)(0);
    }

    else
    {
      Hasher._combine(_:)(1u);
      Hasher._combine(_:)(v85);
    }

    uint64_t v30 = v87;
    uint64_t v16 = v88;
    ++v55;
    uint64_t v5 = v89;
  }

  id v70 = _ArrayBuffer._getElementSlowPath(_:)(v55, v30, v15);
  id v51 = v70;
  if (v71 != 8) {
    goto LABEL_32;
  }
  v91[0] = v70;
  (*(void (**)(char *, void *, uint64_t *))(v16 + 16))(v86, v91, v15);
  swift_unknownObjectRelease(v51);
  unint64_t v58 = (char *)(v55 + 1);
  if (!__OFADD__(v55, 1LL)) {
    goto LABEL_22;
  }
LABEL_30:
  __break(1u);
}

Swift::Int CollectionDifference<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  __int128 v7 = *v2;
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  CollectionDifference<A>.hash(into:)((uint64_t)v4, a1, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> CollectionDifference<A>( uint64_t a1, uint64_t a2)
{
  return CollectionDifference<A>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> CollectionDifference<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> CollectionDifference<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 - 8);
  v5[0] = 0LL;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v5[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v5[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  CollectionDifference<A>.hash(into:)((uint64_t)v5, a2, v3);
  return Hasher._finalize()();
}

void CollectionDifference<A>.inferringMoves()(uint64_t a1@<X0>, uint64_t a2@<X1>, __objc2_class ***a3@<X8>)
{
  uint64_t v8 = *v3;
  uint64_t v7 = v3[1];
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = closure #1 in CollectionDifference<A>.inferringMoves()(v8, v7, v9, a2);
  uint64_t v11 = closure #2 in CollectionDifference<A>.inferringMoves()(v8, v7, v9, a2);
  v24[0] = v8;
  v24[1] = v7;
  v23[2] = v9;
  v23[3] = a2;
  v23[4] = v10;
  v23[5] = v11;
  uint64_t v14 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, v9, v12, v13);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a1, v15);
  uint64_t v17 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOqd__Isgnrzr_xAbGSlRzAGRsd_0_r_0_lIetMgnozo_Tp5( (void (*)(char *))partial apply for closure #3 in CollectionDifference<A>.inferringMoves(),  (uint64_t)v23,  a1,  v14,  WitnessTable);
  swift_bridgeObjectRelease((uint64_t)v11);
  swift_bridgeObjectRelease((uint64_t)v10);
  v24[0] = v17;
  uint64_t v20 = type metadata accessor for Array(0LL, (uint64_t)v14, v18, v19);
  uint64_t v22 = swift_getWitnessTable(&protocol conformance descriptor for [A], v20, v21);
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)v24, v9, v20, v22, a3);
}

__objc2_class **closure #1 in CollectionDifference<A>.inferringMoves()( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v111 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v112 = (char *)&v96 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, v8, v8, v9);
  uint64_t v106 = *(v10 - 1);
  uint64_t v11 = *(void *)(v106 + 64);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  char v98 = (char *)&v96 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v104 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v110 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v96 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v96 - v20;
  Swift::Int v22 = Array._getCount()();
  Swift::Int v23 = Array._getCount()();
  if (v23 >= v22) {
    Swift::Int v23 = v22;
  }
  uint64_t v24 = (__objc2_class **)a4;
  if (v23) {
    uint64_t v25 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v23, v5, a4);
  }
  else {
    uint64_t v25 = &_swiftEmptyDictionarySingleton;
  }
  Swift::Int v26 = Array._getCount()();
  Swift::Int v103 = v26;
  if (v26)
  {
    uint64_t v96 = v11;
    uint64_t v97 = a2;
    unint64_t v27 = 0LL;
    uint64_t v101 = v10;
    unint64_t v102 = a2 & 0xC000000000000001LL;
    unint64_t v108 = v24;
    unint64_t v105 = v5;
    unint64_t v99 = v21;
    char v100 = v19;
    do
    {
      BOOL v30 = v102 == 0;
      char v31 = v30 | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v31 & 1);
      if ((v31 & 1) != 0)
      {
        uint64_t v32 = v106;
        Swift::Int v33 = *(void (**)(char *, unint64_t, uint64_t *))(v106 + 16);
        v33( v19,  a2 + ((*(unsigned __int8 *)(v32 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v32 + 80))
        + *(void *)(v106 + 72) * v27,
          v10);
      }

      else
      {
        id v77 = _ArrayBuffer._getElementSlowPath(_:)(v27, a2, v10);
        id v78 = v77;
        if (v96 != 8)
        {
          swift_unknownObjectRelease(v77);
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }

        unint64_t v113 = (__objc2_class **)v77;
        Swift::Int v33 = *(void (**)(char *, unint64_t, uint64_t *))(v106 + 16);
        v33(v19, (unint64_t)&v113, v10);
        uint64_t v79 = v78;
        uint64_t v32 = v106;
        swift_unknownObjectRelease(v79);
      }

      unint64_t v34 = *(void (**)(char *, char *, uint64_t *))(v32 + 32);
      v34(v21, v19, v10);
      if (__OFADD__(v27, 1LL))
      {
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v105);
      }

      unint64_t v109 = v27 + 1;
      BOOL v35 = v21;
      char v36 = v110;
      v34(v110, v35, v10);
      unint64_t v37 = v104;
      v33(v104, (unint64_t)v36, v10);
      unint64_t v38 = &v37[*((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v5,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
                 + 12)];
      uint64_t v107 = *(void (**)(uint64_t, char *, uint64_t))(v111 + 32);
      v107((uint64_t)v112, v38, v5);
      if (v25[2])
      {
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v5, (uint64_t)v24);
        if ((v39 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t *))(v106 + 8))(v110, v10);
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v25);
          unint64_t v113 = v25;
          unint64_t v41 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v5, (uint64_t)v24);
          uint64_t v43 = v25[2];
          BOOL v44 = (v42 & 1) == 0;
          uint64_t v45 = (uint64_t)v43 + v44;
          if (__OFADD__(v43, v44)) {
            goto LABEL_45;
          }
          char v46 = v42;
          if ((uint64_t)v25[3] >= v45)
          {
            unint64_t v53 = v41;
            if (isUniquelyReferenced_nonNull_native)
            {
              if ((v42 & 1) == 0) {
                goto LABEL_38;
              }
            }

            else
            {
              uint64_t v81 = type metadata accessor for _NativeDictionary(0LL, v5, (uint64_t)&unk_189B88E40, (uint64_t)v108);
              specialized _NativeDictionary.copy()(v81);
              if ((v46 & 1) == 0) {
                goto LABEL_38;
              }
            }
          }

          else
          {
            uint64_t v47 = v5;
            uint64_t v48 = v5;
            uint64_t v49 = (uint64_t)v108;
            uint64_t v50 = type metadata accessor for _NativeDictionary(0LL, v47, (uint64_t)&unk_189B88E40, (uint64_t)v108);
            specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)( v45,  isUniquelyReferenced_nonNull_native,  v50);
            unint64_t v51 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v48, v49);
            if ((v46 & 1) != (v52 & 1)) {
              goto LABEL_47;
            }
            unint64_t v53 = v51;
            uint64_t v5 = v105;
            if ((v46 & 1) == 0)
            {
LABEL_38:
              uint64_t v25 = v113;
              v113[(v53 >> 6) + 8] = (__objc2_class *)((unint64_t)v113[(v53 >> 6) + 8] | (1LL << v53));
              v107((uint64_t)v25[6] + *(void *)(v111 + 72) * v53, v112, v5);
              uint64_t v82 = (uint64_t)v25[7] + 16 * v53;
              *(void *)uint64_t v82 = 0LL;
              *(_BYTE *)(v82 + 8) = 1;
              uint64_t v83 = v25[2];
              BOOL v74 = __OFADD__(v83, 1LL);
              uint64_t v84 = (__objc2_class *)((char *)&v83->isa + 1);
              if (v74) {
                goto LABEL_46;
              }
              v25[2] = v84;
              goto LABEL_40;
            }
          }

          (*(void (**)(char *, uint64_t))(v111 + 8))(v112, v5);
          uint64_t v25 = v113;
          uint64_t v76 = (uint64_t)v113[7] + 16 * v53;
          *(void *)uint64_t v76 = 0LL;
          *(_BYTE *)(v76 + 8) = 1;
LABEL_40:
          swift_bridgeObjectRelease(0x8000000000000000LL);
          uint64_t v24 = v108;
          goto LABEL_10;
        }
      }

      uint64_t v54 = (uint64_t *)v98;
      v34(v98, v110, v10);
      uint64_t v55 = *v54;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v5,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
      uint64_t v57 = v5;
      unint64_t v58 = *(void (**)(char *, uint64_t))(v111 + 8);
      v58((char *)v54 + *((int *)TupleTypeMetadata3 + 12), v57);
      BOOL v59 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v25);
      unint64_t v113 = v25;
      unint64_t v60 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v57, (uint64_t)v24);
      Swift::UInt v62 = v25[2];
      BOOL v63 = (v61 & 1) == 0;
      uint64_t v64 = (uint64_t)v62 + v63;
      if (__OFADD__(v62, v63)) {
        goto LABEL_43;
      }
      char v65 = v61;
      if ((uint64_t)v25[3] >= v64)
      {
        unint64_t v71 = v60;
        if (v59)
        {
          if ((v61 & 1) == 0) {
            goto LABEL_28;
          }
        }

        else
        {
          uint64_t v80 = type metadata accessor for _NativeDictionary(0LL, v105, (uint64_t)&unk_189B88E40, (uint64_t)v108);
          specialized _NativeDictionary.copy()(v80);
          if ((v65 & 1) == 0) {
            goto LABEL_28;
          }
        }
      }

      else
      {
        uint64_t v66 = v105;
        uint64_t v67 = (uint64_t)v108;
        uint64_t v68 = type metadata accessor for _NativeDictionary(0LL, v105, (uint64_t)&unk_189B88E40, (uint64_t)v108);
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v64, v59, v68);
        unint64_t v69 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v66, v67);
        if ((v65 & 1) != (v70 & 1)) {
          goto LABEL_47;
        }
        unint64_t v71 = v69;
        if ((v65 & 1) == 0)
        {
LABEL_28:
          uint64_t v25 = v113;
          v113[(v71 >> 6) + 8] = (__objc2_class *)((unint64_t)v113[(v71 >> 6) + 8] | (1LL << v71));
          uint64_t v5 = v105;
          v107((uint64_t)v25[6] + *(void *)(v111 + 72) * v71, v112, v105);
          uint64_t v72 = (uint64_t)v25[7] + 16 * v71;
          *(void *)uint64_t v72 = v55;
          *(_BYTE *)(v72 + 8) = 0;
          int v73 = v25[2];
          BOOL v74 = __OFADD__(v73, 1LL);
          uint64_t v75 = (__objc2_class *)((char *)&v73->isa + 1);
          if (v74) {
            goto LABEL_44;
          }
          v25[2] = v75;
          goto LABEL_9;
        }
      }

      unint64_t v28 = v105;
      v58(v112, v105);
      uint64_t v5 = v28;
      uint64_t v25 = v113;
      uint64_t v29 = (uint64_t)v113[7] + 16 * v71;
      *(void *)uint64_t v29 = v55;
      *(_BYTE *)(v29 + 8) = 0;
LABEL_9:
      swift_bridgeObjectRelease(0x8000000000000000LL);
      uint64_t v24 = v108;
      a2 = v97;
LABEL_10:
      uint64_t v19 = v100;
      uint64_t v10 = v101;
      uint64_t v21 = v99;
      ++v27;
    }

    while (v109 != v103);
  }

  uint64_t v85 = MEMORY[0x1895F8858](v26);
  MEMORY[0x1895F8858](v85);
  uint64_t v92 = v5;
  char v93 = v24;
  unint64_t v94 = partial apply for closure #1 in closure #1 in CollectionDifference<A>.inferringMoves();
  uint64_t v95 = v86;
  swift_bridgeObjectRetain((unint64_t)v25, v87, v88, v89);
  uint64_t v90 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5( (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool),  (uint64_t)(&v96 - 6),  (uint64_t)v25,  v5,  v24);
  swift_bridgeObjectRelease((uint64_t)v25);
  swift_bridgeObjectRelease((uint64_t)v25);
  return v90;
}

__objc2_class **closure #2 in CollectionDifference<A>.inferringMoves()( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = a1;
  uint64_t v112 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v113 = (char *)&v97 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, v8, v8, v9);
  uint64_t v11 = *(v10 - 1);
  uint64_t v12 = *(void *)(v11 + 64);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  unint64_t v99 = (char *)&v97 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  unint64_t v105 = (char *)&v97 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v111 = (char *)&v97 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v97 - v19;
  MEMORY[0x1895F8858](v18);
  Swift::Int v22 = (char *)&v97 - v21;
  Swift::Int v23 = Array._getCount()();
  Swift::Int v24 = Array._getCount()();
  if (v24 >= v23) {
    Swift::Int v24 = v23;
  }
  uint64_t v25 = (__objc2_class **)a4;
  if (v24) {
    Swift::Int v26 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v24, v5, a4);
  }
  else {
    Swift::Int v26 = &_swiftEmptyDictionarySingleton;
  }
  Swift::Int v27 = Array._getCount()();
  Swift::Int v104 = v27;
  if (v27)
  {
    uint64_t v97 = v12;
    uint64_t v98 = v6;
    unint64_t v106 = v5;
    uint64_t v107 = v11;
    unint64_t v28 = 0LL;
    unint64_t v102 = v10;
    unint64_t v103 = v6 & 0xC000000000000001LL;
    unint64_t v109 = v25;
    char v100 = v22;
    uint64_t v101 = v20;
    do
    {
      BOOL v31 = v103 == 0;
      char v32 = v31 | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v28, v32 & 1);
      if ((v32 & 1) != 0)
      {
        uint64_t v33 = v107;
        unint64_t v34 = *(void (**)(char *, unint64_t, uint64_t *))(v107 + 16);
        v34( v20,  v6 + ((*(unsigned __int8 *)(v33 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v33 + 80))
        + *(void *)(v107 + 72) * v28,
          v10);
      }

      else
      {
        id v78 = _ArrayBuffer._getElementSlowPath(_:)(v28, v6, v10);
        id v79 = v78;
        if (v97 != 8)
        {
          swift_unknownObjectRelease(v78);
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }

        uint64_t v114 = (__objc2_class **)v78;
        unint64_t v34 = *(void (**)(char *, unint64_t, uint64_t *))(v107 + 16);
        v34(v20, (unint64_t)&v114, v10);
        uint64_t v80 = v79;
        uint64_t v33 = v107;
        swift_unknownObjectRelease(v80);
      }

      BOOL v35 = *(void (**)(char *, char *, uint64_t *))(v33 + 32);
      v35(v22, v20, v10);
      if (__OFADD__(v28, 1LL))
      {
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v106);
      }

      unint64_t v110 = v28 + 1;
      char v36 = v22;
      unint64_t v37 = v111;
      v35(v111, v36, v10);
      unint64_t v38 = v105;
      v34(v105, (unint64_t)v37, v10);
      char v39 = &v38[*((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v5,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
                 + 12)];
      unint64_t v108 = *(void (**)(uint64_t, char *, uint64_t))(v112 + 32);
      v108((uint64_t)v113, v39, v5);
      if (v26[2])
      {
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v5, (uint64_t)v25);
        if ((v40 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t *))(v107 + 8))(v111, v10);
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v26);
          uint64_t v114 = v26;
          unint64_t v42 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v5, (uint64_t)v25);
          BOOL v44 = v26[2];
          BOOL v45 = (v43 & 1) == 0;
          uint64_t v46 = (uint64_t)v44 + v45;
          if (__OFADD__(v44, v45)) {
            goto LABEL_45;
          }
          char v47 = v43;
          if ((uint64_t)v26[3] >= v46)
          {
            unint64_t v54 = v42;
            if (isUniquelyReferenced_nonNull_native)
            {
              if ((v43 & 1) == 0) {
                goto LABEL_38;
              }
            }

            else
            {
              uint64_t v82 = type metadata accessor for _NativeDictionary(0LL, v5, (uint64_t)&unk_189B88E40, (uint64_t)v109);
              specialized _NativeDictionary.copy()(v82);
              if ((v47 & 1) == 0) {
                goto LABEL_38;
              }
            }
          }

          else
          {
            uint64_t v48 = v5;
            uint64_t v49 = v5;
            uint64_t v50 = (uint64_t)v109;
            uint64_t v51 = type metadata accessor for _NativeDictionary(0LL, v48, (uint64_t)&unk_189B88E40, (uint64_t)v109);
            specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)( v46,  isUniquelyReferenced_nonNull_native,  v51);
            unint64_t v52 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v49, v50);
            if ((v47 & 1) != (v53 & 1)) {
              goto LABEL_47;
            }
            unint64_t v54 = v52;
            uint64_t v5 = v106;
            if ((v47 & 1) == 0)
            {
LABEL_38:
              Swift::Int v26 = v114;
              v114[(v54 >> 6) + 8] = (__objc2_class *)((unint64_t)v114[(v54 >> 6) + 8] | (1LL << v54));
              v108((uint64_t)v26[6] + *(void *)(v112 + 72) * v54, v113, v5);
              uint64_t v83 = (uint64_t)v26[7] + 16 * v54;
              *(void *)uint64_t v83 = 0LL;
              *(_BYTE *)(v83 + 8) = 1;
              uint64_t v84 = v26[2];
              BOOL v75 = __OFADD__(v84, 1LL);
              uint64_t v85 = (__objc2_class *)((char *)&v84->isa + 1);
              if (v75) {
                goto LABEL_46;
              }
              v26[2] = v85;
              goto LABEL_40;
            }
          }

          (*(void (**)(char *, uint64_t))(v112 + 8))(v113, v5);
          Swift::Int v26 = v114;
          uint64_t v77 = (uint64_t)v114[7] + 16 * v54;
          *(void *)uint64_t v77 = 0LL;
          *(_BYTE *)(v77 + 8) = 1;
LABEL_40:
          swift_bridgeObjectRelease(0x8000000000000000LL);
          uint64_t v25 = v109;
          goto LABEL_10;
        }
      }

      uint64_t v55 = (uint64_t *)v99;
      v35(v99, v111, v10);
      uint64_t v56 = *v55;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v5,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
      uint64_t v58 = v5;
      BOOL v59 = *(void (**)(char *, uint64_t))(v112 + 8);
      v59((char *)v55 + *((int *)TupleTypeMetadata3 + 12), v58);
      BOOL v60 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v26);
      uint64_t v114 = v26;
      unint64_t v61 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v58, (uint64_t)v25);
      BOOL v63 = v26[2];
      BOOL v64 = (v62 & 1) == 0;
      uint64_t v65 = (uint64_t)v63 + v64;
      if (__OFADD__(v63, v64)) {
        goto LABEL_43;
      }
      char v66 = v62;
      if ((uint64_t)v26[3] >= v65)
      {
        unint64_t v72 = v61;
        if (v60)
        {
          if ((v62 & 1) == 0) {
            goto LABEL_28;
          }
        }

        else
        {
          uint64_t v81 = type metadata accessor for _NativeDictionary(0LL, v106, (uint64_t)&unk_189B88E40, (uint64_t)v109);
          specialized _NativeDictionary.copy()(v81);
          if ((v66 & 1) == 0) {
            goto LABEL_28;
          }
        }
      }

      else
      {
        uint64_t v67 = v106;
        uint64_t v68 = (uint64_t)v109;
        uint64_t v69 = type metadata accessor for _NativeDictionary(0LL, v106, (uint64_t)&unk_189B88E40, (uint64_t)v109);
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v65, v60, v69);
        unint64_t v70 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v67, v68);
        if ((v66 & 1) != (v71 & 1)) {
          goto LABEL_47;
        }
        unint64_t v72 = v70;
        if ((v66 & 1) == 0)
        {
LABEL_28:
          Swift::Int v26 = v114;
          v114[(v72 >> 6) + 8] = (__objc2_class *)((unint64_t)v114[(v72 >> 6) + 8] | (1LL << v72));
          uint64_t v5 = v106;
          v108((uint64_t)v26[6] + *(void *)(v112 + 72) * v72, v113, v106);
          uint64_t v73 = (uint64_t)v26[7] + 16 * v72;
          *(void *)uint64_t v73 = v56;
          *(_BYTE *)(v73 + 8) = 0;
          BOOL v74 = v26[2];
          BOOL v75 = __OFADD__(v74, 1LL);
          uint64_t v76 = (__objc2_class *)((char *)&v74->isa + 1);
          if (v75) {
            goto LABEL_44;
          }
          v26[2] = v76;
          goto LABEL_9;
        }
      }

      unint64_t v29 = v106;
      v59(v113, v106);
      uint64_t v5 = v29;
      Swift::Int v26 = v114;
      uint64_t v30 = (uint64_t)v114[7] + 16 * v72;
      *(void *)uint64_t v30 = v56;
      *(_BYTE *)(v30 + 8) = 0;
LABEL_9:
      swift_bridgeObjectRelease(0x8000000000000000LL);
      uint64_t v25 = v109;
      uint64_t v6 = v98;
LABEL_10:
      uint64_t v20 = v101;
      uint64_t v10 = v102;
      Swift::Int v22 = v100;
      ++v28;
    }

    while (v110 != v104);
  }

  uint64_t v86 = MEMORY[0x1895F8858](v27);
  MEMORY[0x1895F8858](v86);
  uint64_t v93 = v5;
  unint64_t v94 = v25;
  uint64_t v95 = partial apply for closure #1 in closure #2 in CollectionDifference<A>.inferringMoves();
  uint64_t v96 = v87;
  swift_bridgeObjectRetain((unint64_t)v26, v88, v89, v90);
  char v91 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5( (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool),  (uint64_t)(&v97 - 6),  (uint64_t)v26,  v5,  v25);
  swift_bridgeObjectRelease((uint64_t)v26);
  swift_bridgeObjectRelease((uint64_t)v26);
  return v91;
}

void closure #3 in CollectionDifference<A>.inferringMoves()( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  uint64_t v54 = a5;
  uint64_t v57 = a6;
  uint64_t v10 = *(void *)(a4 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v52 - v14;
  uint64_t v18 = type metadata accessor for CollectionDifference.Change(0LL, v17, v16, v17);
  MEMORY[0x1895F8858](v18);
  uint64_t v20 = (unsigned __int8 *)&v52 - v19;
  uint64_t v55 = *(void (**)(char *, uint64_t, uint64_t))(v21 + 16);
  uint64_t v56 = a1;
  v55((char *)&v52 - v19, a1, v18);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v20, v18);
  uint64_t v53 = *(void *)v20;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a4,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
  Swift::Int v24 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v25 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v10 + 32);
  if (EnumCaseMultiPayload != 1)
  {
    char v39 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
    v25(v13, v24, a4);
    if (*(void *)(a3 + 16))
    {
      __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, a4, v54);
      if ((v40 & 1) != 0)
      {
        if (*(void *)(a2 + 16))
        {
          unint64_t v41 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, a4, v54);
          if ((v42 & 1) != 0)
          {
            uint64_t v43 = *(void *)(a2 + 56) + 16 * v41;
            uint64_t v44 = *(void *)v43;
            char v45 = *(_BYTE *)(v43 + 8);
            uint64_t v46 = v57;
            char v47 = (char *)v57 + *((int *)TupleTypeMetadata3 + 12);
            uint64_t v48 = (char *)v57 + *((int *)TupleTypeMetadata3 + 16);
            *uint64_t v57 = v53;
            v39(v47, v13, a4);
            *(void *)uint64_t v48 = v44;
            v48[8] = v45;
            char v36 = v46;
            size_t v37 = v18;
            unsigned int v38 = 0;
            goto LABEL_12;
          }
        }

        goto LABEL_17;
      }
    }

    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a4);
LABEL_15:
    v55((char *)v57, v56, v18);
    return;
  }

  Swift::Int v26 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
  v25(v15, v24, a4);
  if (!*(void *)(a2 + 16) || (__RawDictionaryStorage.find<A>(_:)((uint64_t)v15, a4, v54), (v27 & 1) == 0))
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, a4);
    goto LABEL_15;
  }

  if (*(void *)(a3 + 16))
  {
    unint64_t v28 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, a4, v54);
    if ((v29 & 1) != 0)
    {
      uint64_t v30 = *(void *)(a3 + 56) + 16 * v28;
      uint64_t v31 = *(void *)v30;
      char v32 = *(_BYTE *)(v30 + 8);
      uint64_t v33 = v57;
      unint64_t v34 = (char *)v57 + *((int *)TupleTypeMetadata3 + 12);
      BOOL v35 = (char *)v57 + *((int *)TupleTypeMetadata3 + 16);
      *uint64_t v57 = v53;
      v26(v34, v15, a4);
      *(void *)BOOL v35 = v31;
      v35[8] = v32;
      char v36 = v33;
      size_t v37 = v18;
      unsigned int v38 = 1;
LABEL_12:
      swift_storeEnumTagMultiPayload(v36, v37, v38);
      return;
    }
  }

  uint64_t v13 = v15;
LABEL_17:
  uint64_t v50 = v56;
  uint64_t v49 = (char *)v57;
  uint64_t v51 = v55;
  (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a4);
  v51(v49, v50, v18);
}

unint64_t CollectionDifference.Change<A>._CodingKeys.init(rawValue:)(Swift::String string)
{
  unint64_t object = string._object;
  v2._unint64_t countAndFlagsBits = string._countAndFlagsBits;
  v2._unint64_t object = object;
  unint64_t v3 = _findStringSwitchCase(cases:string:)( (Swift::OpaquePointer)&outlined read-only object #0 of CollectionDifference.Change<A>._CodingKeys.init(rawValue:),  v2);
  swift_bridgeObjectRelease((uint64_t)object);
  if (v3 >= 4) {
    return 4LL;
  }
  else {
    return v3;
  }
}

uint64_t CollectionDifference.Change<A>._CodingKeys.rawValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_181641D24 + 4 * byte_1818001C6[a1]))( 0xD000000000000010LL,  0x80000001818B44A0LL);
}

uint64_t sub_181641D24()
{
  return 0x74657366666FLL;
}

uint64_t sub_181641D38()
{
  return 0x746E656D656C65LL;
}

uint64_t sub_181641D50()
{
  return 0x65766F6D65527369LL;
}

uint64_t CollectionDifference.Change<A>._CodingKeys.stringValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_181641DA0 + 4 * byte_1818001CA[a1]))( 0xD000000000000010LL,  0x80000001818B44A0LL);
}

uint64_t sub_181641DA0()
{
  return 0x74657366666FLL;
}

uint64_t sub_181641DB4()
{
  return 0x746E656D656C65LL;
}

uint64_t sub_181641DCC()
{
  return 0x65766F6D65527369LL;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.Change<A>._CodingKeys( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return == infix<A>(_:_:)( a1,  a2,  a3,  (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys,  (uint64_t)&protocol witness table for String);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.Change<A>._CodingKeys( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return RawRepresentable<>.hash(into:)( a1,  a2,  a3,  (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys,  (uint64_t)&protocol witness table for String);
}

unint64_t protocol witness for RawRepresentable.init(rawValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>( Swift::String *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result = CollectionDifference.Change<A>._CodingKeys.init(rawValue:)(*a1);
  *a2 = result;
  return result;
}

uint64_t protocol witness for RawRepresentable.rawValue.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = CollectionDifference.Change<A>._CodingKeys.rawValue.getter(*v1);
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys()
{
  return CollectionDifference.Change<A>._CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>( _BYTE *a1@<X8>)
{
  uint64_t result = CollectionDifference.Change<A>._CodingKeys.init(stringValue:)();
  *a1 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys( _BYTE *a1@<X8>)
{
  *a1 = 4;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys( uint64_t *a1)
{
  return CodingKey.description.getter( a1,  (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys( uint64_t a1)
{
  return CodingKey.debugDescription.getter( a1,  (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
}

uint64_t CollectionDifference.Change<A>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  char v42 = a4;
  uint64_t v38 = a5;
  uint64_t v39 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v36 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = type metadata accessor for CollectionDifference.Change(0LL, v10, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (uint64_t *)((char *)&v36 - v15);
  uint64_t v17 = a1[3];
  uint64_t v18 = a1[4];
  unint64_t v41 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v17);
  uint64_t v40 = a3;
  uint64_t v19 = type metadata accessor for CollectionDifference.Change<A>._CodingKeys(0LL, a2, a3, (uint64_t)v42);
  uint64_t v20 = v43;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v18 + 24))( &v44,  v19,  v19,  &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys,  v17,  v18);
  if (!v20)
  {
    uint64_t v21 = v40;
    char v42 = v16;
    uint64_t v43 = v14;
    size_t v37 = v13;
    uint64_t v22 = v44;
    LOBYTE(v44) = 0;
    uint64_t v23 = v19;
    uint64_t v24 = (*(uint64_t (**)(uint64_t *, uint64_t, _UNKNOWN **))(*(void *)v22 + 152LL))( &v44,  v19,  &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    LOBYTE(v44) = 1;
    uint64_t v25 = *(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(void *)v22 + 248LL);
    uint64_t v26 = a2;
    v25(a2, &v44, a2, v23, v21, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    char v46 = 2;
    unint64_t v27 = lazy protocol witness table accessor for type Int? and conformance <A> A?();
    ((void (*)(uint64_t *__return_ptr, void *, char *, void *, uint64_t, unint64_t, _UNKNOWN **))v25)( &v44,  &unk_189B88E40,  &v46,  &unk_189B88E40,  v23,  v27,  &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    uint64_t v28 = v44;
    LOBYTE(v25) = v45;
    LOBYTE(v44) = 3;
    char v30 = (*(uint64_t (**)(uint64_t *, uint64_t, _UNKNOWN **))(*(void *)v22 + 120LL))( &v44,  v23,  &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    swift_release(v22);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v26,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    char v32 = v42;
    uint64_t v33 = (char *)v42 + *((int *)TupleTypeMetadata3 + 12);
    unint64_t v34 = (char *)v42 + *((int *)TupleTypeMetadata3 + 16);
    *char v42 = v24;
    (*(void (**)(char *, char *, uint64_t))(v39 + 32))(v33, v9, v26);
    *(void *)unint64_t v34 = v28;
    v34[8] = (char)v25;
    size_t v35 = v37;
    swift_storeEnumTagMultiPayload(v32, v37, v30 & 1);
    (*(void (**)(uint64_t, uint64_t *, size_t))(v43 + 32))(v38, v32, v35);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v41);
}

uint64_t CollectionDifference.Change<A>.encode(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v56 = a3;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v58 = *(void *)(v7 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v54 = (char *)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v8);
  uint64_t v52 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v53 = (char *)&v51 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v55 = (char *)&v51 - v17;
  uint64_t v18 = (void *)MEMORY[0x1895F8858](v16);
  uint64_t v20 = (unsigned __int8 *)&v51 - v19;
  uint64_t v22 = v18[3];
  uint64_t v21 = v18[4];
  __swift_project_boxed_opaque_existential_0Tm(v18, v22);
  uint64_t v23 = v56;
  uint64_t v56 = a4;
  uint64_t v24 = type metadata accessor for CollectionDifference.Change<A>._CodingKeys(0LL, v7, v23, a4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v21 + 24))( &v62,  v24,  v24,  &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys,  v22,  v21);
  uint64_t v25 = *(void (**)(unsigned __int8 *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v26 = v4;
  v25(v20, v4, a2);
  int EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v20, a2);
  uint64_t v28 = &v20[*((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v7,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
             + 12)];
  LOBYTE(v59) = 3;
  if (EnumCaseMultiPayload == 1)
  {
    uint64_t v29 = v62;
    char v30 = *(void (**)(uint64_t, uint64_t *, uint64_t, _UNKNOWN **))(*(void *)v62 + 104LL);
    uint64_t v31 = 1LL;
  }

  else
  {
    uint64_t v29 = v62;
    char v30 = *(void (**)(uint64_t, uint64_t *, uint64_t, _UNKNOWN **))(*(void *)v62 + 104LL);
    uint64_t v31 = 0LL;
  }

  uint64_t v32 = v57;
  v30(v31, &v59, v24, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
  if (v32)
  {
    swift_release(v29);
    return (*(uint64_t (**)(unsigned __int8 *, uint64_t))(v58 + 8))(v28, v7);
  }

  else
  {
    unint64_t v34 = (uint64_t *)v55;
    size_t v35 = *(void (**)(unsigned __int8 *, uint64_t))(v58 + 8);
    v35(v28, v7);
    v25((unsigned __int8 *)v34, v26, a2);
    uint64_t v36 = *v34;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v7,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    v35((unsigned __int8 *)v34 + *((int *)TupleTypeMetadata3 + 12), v7);
    LOBYTE(v59) = 0;
    uint64_t v38 = v62;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, _UNKNOWN **))(*(void *)v62 + 136LL))( v36,  &v59,  v24,  &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    uint64_t v39 = v53;
    v25((unsigned __int8 *)v53, v26, a2);
    uint64_t v40 = &v39[*((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v7,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
               + 12)];
    unint64_t v41 = v54;
    (*(void (**)(char *, char *, uint64_t))(v58 + 32))(v54, v40, v7);
    LOBYTE(v59) = 1;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(void *)v38 + 232LL))( v41,  &v59,  v7,  v24,  v56,  &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    v35((unsigned __int8 *)v41, v7);
    char v42 = v52;
    v25((unsigned __int8 *)v52, v26, a2);
    uint64_t v43 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v7,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    uint64_t v44 = &v42[*((int *)v43 + 12)];
    char v45 = &v42[*((int *)v43 + 16)];
    uint64_t v46 = *(void *)v45;
    char v47 = v45[8];
    v35((unsigned __int8 *)v44, v7);
    char v61 = 2;
    uint64_t v59 = v46;
    char v60 = v47;
    uint64_t v48 = v62;
    uint64_t v49 = *(void (**)(uint64_t *, char *, void *, uint64_t, unint64_t, _UNKNOWN **))(*(void *)v62 + 232LL);
    unint64_t v50 = lazy protocol witness table accessor for type Int? and conformance <A> A?();
    v49(&v59, &v61, &unk_189B88E40, v24, v50, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    return swift_release(v48);
  }

uint64_t protocol witness for Encodable.encode(to:) in conformance <A> CollectionDifference<A>.Change( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CollectionDifference.Change<A>.encode(to:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

uint64_t protocol witness for Decodable.init(from:) in conformance <A> CollectionDifference<A>.Change@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return CollectionDifference.Change<A>.init(from:)( a1,  *(void *)(a2 + 16),  *(void *)(a3 - 8),  *(uint64_t **)(a3 - 16),  a4);
}

void CollectionDifference<A>.encode(to:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v9 = *v4;
  unint64_t v33 = v4[1];
  uint64_t v11 = a1[3];
  uint64_t v10 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v11);
  uint64_t v12 = *(void *)(a2 + 16);
  uint64_t v15 = type metadata accessor for CollectionDifference.CodingKeys(0LL, v12, v13, v14);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v10 + 24))( &v38,  v15,  v15,  &protocol witness table for CollectionDifference<A>.CodingKeys,  v11,  v10);
  unint64_t v37 = v9;
  char v36 = 0;
  uint64_t v16 = v38;
  uint64_t v17 = v12;
  uint64_t v18 = *(void (**)(unint64_t *, char *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(void *)v38
                                                                                                  + 232LL);
  uint64_t v21 = type metadata accessor for CollectionDifference.Change(255LL, v17, v19, v20);
  uint64_t v24 = type metadata accessor for Array(0LL, v21, v22, v23);
  v35[0] = a3;
  v35[1] = a4;
  swift_bridgeObjectRetain(v9, v25, v26, v27);
  uint64_t WitnessTable = swift_getWitnessTable( &protocol conformance descriptor for <A> CollectionDifference<A>.Change,  v21,  v35);
  uint64_t v28 = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v24, &WitnessTable);
  v18(&v37, &v36, v24, v15, v28, &protocol witness table for CollectionDifference<A>.CodingKeys);
  if (v5)
  {
    swift_release(v16);
    uint64_t v29 = v9;
  }

  else
  {
    swift_bridgeObjectRelease(v9);
    unint64_t v37 = v33;
    char v36 = 1;
    swift_bridgeObjectRetain(v33, v30, v31, v32);
    v18(&v37, &v36, v24, v15, v28, &protocol witness table for CollectionDifference<A>.CodingKeys);
    swift_release(v16);
    uint64_t v29 = v33;
  }

  swift_bridgeObjectRelease(v29);
}

void CollectionDifference<A>.init(from:)( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  void (*v22)(unint64_t *__return_ptr, uint64_t, char *, uint64_t, uint64_t, uint64_t, _UNKNOWN **);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t *v32;
  uint64_t WitnessTable;
  void v35[2];
  char v36;
  unint64_t v37;
  uint64_t v11 = a1[3];
  uint64_t v10 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v11);
  uint64_t v14 = type metadata accessor for CollectionDifference.CodingKeys(0LL, a2, v12, v13);
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v10 + 24))( &v37,  v14,  v14,  &protocol witness table for CollectionDifference<A>.CodingKeys,  v11,  v10);
  if (v5)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }

  else
  {
    uint64_t v32 = a5;
    uint64_t v17 = v37;
    char v36 = 0;
    uint64_t v18 = type metadata accessor for CollectionDifference.Change(255LL, a2, v15, v16);
    uint64_t v21 = type metadata accessor for Array(0LL, v18, v19, v20);
    uint64_t v22 = *(void (**)(unint64_t *__return_ptr, uint64_t, char *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(void *)v17 + 248LL);
    v35[0] = a3;
    v35[1] = a4;
    uint64_t WitnessTable = swift_getWitnessTable( &protocol conformance descriptor for <A> CollectionDifference<A>.Change,  v18,  v35);
    uint64_t v23 = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v21, &WitnessTable);
    v22(&v37, v21, &v36, v21, v14, v23, &protocol witness table for CollectionDifference<A>.CodingKeys);
    uint64_t v24 = v37;
    char v36 = 1;
    swift_bridgeObjectRetain(v37, v25, v26, v27);
    v22(&v37, v21, &v36, v21, v14, v23, &protocol witness table for CollectionDifference<A>.CodingKeys);
    swift_release(v17);
    uint64_t v28 = v37;
    *uint64_t v32 = v24;
    v32[1] = v28;
    swift_bridgeObjectRetain(v28, v29, v30, v31);
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    swift_bridgeObjectRelease(v28);
    swift_bridgeObjectRelease(v24);
  }

void protocol witness for Encodable.encode(to:) in conformance <A> CollectionDifference<A>( void *a1, uint64_t a2, uint64_t a3)
{
}

void protocol witness for Decodable.init(from:) in conformance <A> CollectionDifference<A>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
}

uint64_t (*CollectionOfOne._element.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.Iterator._elements.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = type metadata accessor for Optional(0LL, *(void *)(a1 + 16), a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a4, v4, v6);
}

uint64_t CollectionOfOne.Iterator._elements.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for Optional(0LL, *(void *)(a2 + 16), a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 40LL))(v4, a1, v6);
}

uint64_t (*CollectionOfOne.Iterator._elements.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.Iterator.init(_elements:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, a2, v6, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 40LL))(a3, a1, v8);
}

uint64_t CollectionOfOne.Iterator.next()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = type metadata accessor for Optional(0LL, v6, a2, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(a4, v4, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56LL))(v4, 1LL, 1LL, v6);
}

uint64_t CollectionOfOne.startIndex.getter()
{
  return 0LL;
}

uint64_t CollectionOfOne.endIndex.getter()
{
  return 1LL;
}

Swift::Int __swiftcall CollectionOfOne.index(after:)(Swift::Int after)
{
  if (after) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x66uLL,  0);
  }
  return 1LL;
}

Swift::Int __swiftcall CollectionOfOne.index(before:)(Swift::Int before)
{
  if (before != 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x70uLL,  0);
  }
  return 0LL;
}

uint64_t CollectionOfOne.makeIterator()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = type metadata accessor for Optional(0LL, v6, a2, a3);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v14 - v9;
  uint64_t v11 = *(void *)(v6 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 32))((char *)&v14 - v9, v4, v6);
  uint64_t v12 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 56);
  v12(v10, 0LL, 1LL, v6);
  v12(a4, 1LL, 1LL, v6);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v8 + 40))(a4, v10, v7);
}

uint64_t CollectionOfOne.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x83uLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 16LL))(a3, v3);
}

uint64_t key path getter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A@<X0>( uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v5 = CollectionOfOne.subscript.read((uint64_t)v7, *a1);
  (*(void (**)(uint64_t))(*(void *)(v4 - 8) + 16LL))(a3);
  return ((uint64_t (*)(_BYTE *, void))v5)(v7, 0LL);
}

uint64_t (*CollectionOfOne.subscript.read(uint64_t a1, uint64_t a2))()
{
  if (a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x83uLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t key path setter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = *(uint64_t *)((char *)a3 + a4 - 8);
  uint64_t v6 = CollectionOfOne.subscript.modify((uint64_t)v9, *a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24LL))(v7, a1, v5);
  return ((uint64_t (*)(_BYTE *, void))v6)(v9, 0LL);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t WitnessTable;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v6 = type metadata accessor for CollectionOfOne( (const char *)0xFF,  *(uint64_t *)((char *)a3 + a4 - 8),  (uint64_t)a3,  a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v6, v7);
  uint64_t v10 = type metadata accessor for Slice(0LL, v6, WitnessTable, v9);
  MEMORY[0x1895F8858](v10);
  uint64_t v12 = (uint64_t *)((char *)&v17 - v11);
  uint64_t v14 = *a3;
  uint64_t v13 = a3[1];
  (*(void (**)(char *, uint64_t))(v15 + 16))((char *)&v17 - v11, a1);
  return CollectionOfOne.subscript.setter(v12, v14, v13, v6);
}

uint64_t (*CollectionOfOne.subscript.modify(uint64_t a1, uint64_t a2))()
{
  if (a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x87uLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x87uLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8LL) + 40LL))(v3, a1);
}

uint64_t CollectionOfOne.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  v14[0] = a1;
  v14[1] = a2;
  __int128 v13 = xmmword_1817FFC90;
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v14, (char *)&v13, a3, WitnessTable);
  uint64_t v11 = type metadata accessor for Slice(0LL, a3, (uint64_t)WitnessTable, v10);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( &a4[*(int *)(v11 + 40)],  v4,  a3);
  *(void *)a4 = a1;
  *((void *)a4 + 1) = a2;
  return result;
}

uint64_t key path getter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A@<X0>( uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  uint64_t v7 = type metadata accessor for CollectionOfOne(0LL, *(uint64_t *)((char *)a1 + a2 - 8), a2, a3);
  return CollectionOfOne.subscript.getter(v5, v6, v7, a4);
}

uint64_t CollectionOfOne.subscript.setter(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  v21[0] = a2;
  v21[1] = a3;
  __int128 v20 = xmmword_1817FFC90;
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, a3);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v21, (char *)&v20, a4, WitnessTable);
  uint64_t v11 = a1[1];
  v21[0] = *a1;
  *(void *)&__int128 v20 = v11;
  uint64_t v13 = type metadata accessor for Slice(0LL, a4, (uint64_t)WitnessTable, v12);
  uint64_t v14 = (char *)a1 + *(int *)(v13 + 40);
  uint64_t v16 = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, v15);
  uint64_t v17 = RandomAccessCollection<>.distance(from:to:)( (uint64_t)v21,  (uint64_t)&v20,  a4,  v16,  (uint64_t)&protocol witness table for Int);
  if (__OFSUB__(a3, a2))
  {
    __break(1u);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "CollectionOfOne can't be resized",  32LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x95uLL,  0);
  }

  if (a3 - a2 != v17) {
    goto LABEL_8;
  }
  if (v17 != 1) {
    return (*(uint64_t (**)(void *, uint64_t))(*(void *)(v13 - 8) + 8LL))(a1, v13);
  }
  uint64_t v18 = *(void *)(a4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v18 + 8))(v5, a4);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v18 + 32))(v5, v14, a4);
}

void (*CollectionOfOne.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v5 = v4;
  uint64_t v10 = malloc(0x60uLL);
  *a1 = v10;
  *((void *)v10 + 6) = a4;
  *((void *)v10 + 7) = v5;
  *((void *)v10 + 4) = a2;
  *((void *)v10 + 5) = a3;
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, v11);
  uint64_t v14 = type metadata accessor for Slice(0LL, a4, (uint64_t)WitnessTable, v13);
  *((void *)v10 + 8) = v14;
  uint64_t v15 = *(void *)(v14 - 8);
  *((void *)v10 + 9) = v15;
  size_t v16 = *(void *)(v15 + 64);
  *((void *)v10 + 10) = malloc(v16);
  uint64_t v17 = (char *)malloc(v16);
  *((void *)v10 + 11) = v17;
  *(void *)uint64_t v10 = a2;
  *((void *)v10 + 1) = a3;
  *((_OWORD *)v10 + 1) = xmmword_1817FFC90;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v10, (char *)v10 + 16, a4, WitnessTable);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a4 - 8) + 16LL))(&v17[*(int *)(v14 + 40)], v5, a4);
  *(void *)uint64_t v17 = a2;
  *((void *)v17 + 1) = a3;
  return CollectionOfOne.subscript.modify;
}

void CollectionOfOne.subscript.modify(uint64_t **a1, char a2)
{
  Swift::String v2 = *a1;
  uint64_t v3 = (void *)(*a1)[10];
  uint64_t v4 = (void *)(*a1)[11];
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = v2[8];
    uint64_t v6 = v2[9];
    uint64_t v7 = v2[6];
    uint64_t v9 = v2[4];
    uint64_t v8 = v2[5];
    (*(void (**)(uint64_t, void *, uint64_t))(v6 + 16))((*a1)[10], v4, v5);
    CollectionOfOne.subscript.setter(v3, v9, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v4, v5);
  }

  else
  {
    CollectionOfOne.subscript.setter((void *)(*a1)[11], v2[4], v2[5], v2[6]);
  }

  free(v4);
  free(v3);
  free(v2);
}

uint64_t CollectionOfOne.count.getter()
{
  return 1LL;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance CollectionOfOne<A>( uint64_t a1, void *a2, uint64_t a3)
{
  if (*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x87uLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8LL) + 40LL))(v3, a1);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>( void *a1, uint64_t *a2))()
{
  uint64_t v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = CollectionOfOne.subscript.modify((uint64_t)v4, *a2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance CollectionOfOne<A>( void *a1, uint64_t *a2, uint64_t a3)
{
  return CollectionOfOne.subscript.setter(a1, *a2, a2[1], a3);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>( void *a1, uint64_t *a2, uint64_t a3))(uint64_t **a1, char a2)
{
  uint64_t v7 = malloc(0x60uLL);
  *a1 = v7;
  *((void *)v7 + 4) = v3;
  *((void *)v7 + 5) = a3;
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, v8);
  uint64_t v11 = type metadata accessor for Slice(0LL, a3, (uint64_t)WitnessTable, v10);
  *((void *)v7 + 6) = v11;
  uint64_t v12 = *(void *)(v11 - 8);
  *((void *)v7 + 7) = v12;
  size_t v13 = *(void *)(v12 + 64);
  *((void *)v7 + 8) = malloc(v13);
  uint64_t v14 = (char *)malloc(v13);
  uint64_t v16 = *a2;
  uint64_t v15 = a2[1];
  *((void *)v7 + 9) = v14;
  *((void *)v7 + 10) = v16;
  *((void *)v7 + 11) = v15;
  *(void *)uint64_t v7 = v16;
  *((void *)v7 + 1) = v15;
  *((_OWORD *)v7 + 1) = xmmword_1817FFC90;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v7, (char *)v7 + 16, a3, WitnessTable);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(&v14[*(int *)(v11 + 40)], v3, a3);
  *(void *)uint64_t v14 = v16;
  *((void *)v14 + 1) = v15;
  return protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>( uint64_t **a1, char a2)
{
  Swift::String v2 = *a1;
  uint64_t v3 = (*a1)[10];
  uint64_t v4 = (*a1)[11];
  uint64_t v5 = (void *)(*a1)[8];
  uint64_t v6 = (void *)(*a1)[9];
  if ((a2 & 1) != 0)
  {
    uint64_t v7 = v2[6];
    uint64_t v8 = v2[7];
    uint64_t v9 = v2[5];
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[8], v6, v7);
    CollectionOfOne.subscript.setter(v5, v3, v4, v9);
    (*(void (**)(void *, uint64_t))(v8 + 8))(v6, v7);
  }

  else
  {
    CollectionOfOne.subscript.setter((void *)(*a1)[9], v3, v4, v2[5]);
  }

  free(v6);
  free(v5);
  free(v2);
}

void *protocol witness for MutableCollection.partition(by:) in conformance CollectionOfOne<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance CollectionOfOne<A>@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if (*result != 1LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x70uLL,  0);
  }
  *a2 = 0LL;
  return result;
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance CollectionOfOne<A>( void *result)
{
  if (*result != 1LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x70uLL,  0);
  }
  *uint64_t result = 0LL;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance CollectionOfOne<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance CollectionOfOne<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

void protocol witness for Collection.endIndex.getter in conformance CollectionOfOne<A>(void *a1@<X8>)
{
  *a1 = 1LL;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance CollectionOfOne<A>( void *a1, uint64_t *a2))()
{
  uint64_t v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = CollectionOfOne.subscript.read((uint64_t)v4, *a2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t protocol witness for Collection.subscript.getter in conformance CollectionOfOne<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  return CollectionOfOne.subscript.getter(*a1, a1[1], a2, a3);
}

uint64_t protocol witness for Collection.indices.getter in conformance CollectionOfOne<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for Collection.index(after:) in conformance CollectionOfOne<A>@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if (*result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x66uLL,  0);
  }
  *a2 = 1LL;
  return result;
}

void *protocol witness for Collection.formIndex(after:) in conformance CollectionOfOne<A>(void *result)
{
  if (*result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x66uLL,  0);
  }
  *uint64_t result = 1LL;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance CollectionOfOne<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t CollectionOfOne.debugDescription.getter(uint64_t a1)
{
  unint64_t v3 = v1;
  unint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (uint64_t)&v196 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = specialized static String._createEmpty(withInitialCapacity:)(19LL);
  uint64_t v12 = v8;
  uint64_t v13 = v9;
  unint64_t v199 = v8;
  unint64_t v200 = v9;
  uint64_t v14 = HIBYTE(v9) & 0xF;
  uint64_t v15 = v8 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0x2000000000000000LL) != 0) {
    uint64_t v16 = HIBYTE(v9) & 0xF;
  }
  else {
    uint64_t v16 = v8 & 0xFFFFFFFFFFFFLL;
  }
  if (!v16 && (v8 & ~v9 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v9);
    unint64_t v65 = 0x80000001818B7C00LL | 0x8000000000000000LL;
    unint64_t v199 = 0xD000000000000010LL;
LABEL_85:
    unint64_t v200 = v65;
    goto LABEL_86;
  }

  if ((v9 & 0x2000000000000000LL) != 0 && (0x80000001818B7C00LL & 0x2000000000000000LL) != 0)
  {
    unint64_t v2 = v14 + ((0x80000001818B7C00LL >> 56) & 0xF);
    if (v2 <= 0xF)
    {
      unint64_t v42 = (0x80000001818B7C00LL >> 56) & 0xF;
      if (v42)
      {
        char v66 = 0;
        uint64_t v67 = 0LL;
        unint64_t v43 = v9;
        do
        {
          uint64_t v68 = v14 + v67;
          uint64_t v69 = v67 + 1;
          unint64_t v70 = 0x80000001818B7C00LL | 0x8000000000000000LL;
          if (v67 < 8) {
            unint64_t v70 = 0xD000000000000010LL;
          }
          unint64_t v71 = v70 >> (v66 & 0x38);
          char v72 = (8 * v14 + v66) & 0x38;
          uint64_t v73 = (-255LL << v72) - 1;
          unint64_t v74 = (unint64_t)v71 << v72;
          unint64_t v75 = v74 | v73 & v43;
          unint64_t v76 = v74 | v73 & v12;
          if (v68 < 8) {
            uint64_t v12 = v76;
          }
          else {
            unint64_t v43 = v75;
          }
          v66 += 8;
          uint64_t v67 = v69;
        }

        while (v42 != v69);
      }

      else
      {
        unint64_t v43 = v9;
      }

      swift_bridgeObjectRelease(v9);
      swift_bridgeObjectRelease(0x80000001818B7C00LL | 0x8000000000000000LL);
      unint64_t v77 = 0xA000000000000000LL;
      if (!(v12 & 0x8080808080808080LL | v43 & 0x80808080808080LL)) {
        unint64_t v77 = 0xE000000000000000LL;
      }
      unint64_t v65 = v77 & 0xFF00000000000000LL | (v2 << 56) | v43 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v199 = v12;
      goto LABEL_85;
    }
  }

  unint64_t v197 = v3;
  uint64_t v17 = (const char *)(0x80000001818B7C00LL | 0x8000000000000000LL);
  if ((0x80000001818B7C00LL & 0x2000000000000000LL) != 0) {
    unint64_t v2 = (0x80000001818B7C00LL >> 56) & 0xF;
  }
  else {
    unint64_t v2 = 16LL;
  }
  swift_bridgeObjectRetain_n(0x80000001818B7C00LL | 0x8000000000000000LL, 2LL, v10, v11);
  if ((0x80000001818B7C00LL & 0x1000000000000000LL) != 0) {
    goto LABEL_208;
  }
  swift_bridgeObjectRetain_n(0x80000001818B7C00LL | 0x8000000000000000LL, 4LL, v18, v19);
  Swift::Int v20 = v2;
  if ((v13 & 0x1000000000000000LL) != 0) {
    goto LABEL_211;
  }
LABEL_14:
  BOOL v21 = __OFADD__(v16, v20);
  Swift::Int v22 = v16 + v20;
  if (v21)
  {
LABEL_213:
    __break(1u);
    goto LABEL_214;
  }

uint64_t CollectionOfOne.customMirror.getter@<X0>(swift *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *((void *)a1 - 1);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  BOOL v29 = (uint64_t *)((char *)&v30[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v30[-1] - v9;
  (*(void (**)(char *, uint64_t, swift *))(v6 + 16))((char *)&v30[-1] - v9, v3, a1);
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  uint64_t v12 = swift_allocObject(v11, 0x50uLL, 7uLL);
  *((_OWORD *)v12 + 1) = xmmword_1817FFC60;
  v12[4] = 0x746E656D656C65LL;
  v12[5] = 0xE700000000000000LL;
  uint64_t v13 = *((void *)a1 + 2);
  v12[9] = v13;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v12 + 6);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v13 - 8) + 16LL))( boxed_opaque_existential_0Tm,  v3,  v13);
  v30[0] = 0LL;
  v30[1] = 0LL;
  uint64_t v15 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v10, (uint64_t)v30, a1);
  uint64_t v17 = v16;
  uint64_t v18 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  uint64_t v19 = swift_allocObject(v18, 0x48uLL, 7uLL);
  v19[6] = v12;
  v19[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v19[8] = 0LL;
  uint64_t v20 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  BOOL v21 = swift_allocObject(v20, 0x18uLL, 7uLL);
  void v21[2] = 0LL;
  uint64_t v22 = v12[2];
  uint64_t v23 = swift_allocObject(v20, 0x18uLL, 7uLL);
  v23[2] = v22;
  v19[2] = v21;
  v19[3] = &protocol witness table for _IndexBox<A>;
  v19[4] = v23;
  v19[5] = &protocol witness table for _IndexBox<A>;
  int64_t v24 = *(void (**)(uint64_t *, char *, swift *))(v6 + 32);
  char v25 = v29;
  v24(v29, v10, a1);
  int64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v30, v25, a1, v26, 6uLL);
  char v28 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v30);
  }
  *(void *)a2 = a1;
  *(void *)(a2 + 8) = v19;
  *(_BYTE *)(a2 + 16) = 8;
  *(void *)(a2 + 24) = v15;
  *(void *)(a2 + 32) = v17;
  *(_BYTE *)(a2 + 40) = v28;
  return result;
}

Swift::Int CollectionDifference._fastEnumeratedApply(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0LL, v7, a3, a4);
  uint64_t v9 = *(v8 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)v70 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  char v72 = (char *)v70 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v71 = (char *)v70 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v73 = (char *)v70 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v74 = (char *)v70 - v20;
  v70[0] = v21;
  MEMORY[0x1895F8858](v19);
  uint64_t v82 = (char *)v70 - v22;
  uint64_t v23 = *v5;
  uint64_t v24 = v5[1];
  Swift::Int v84 = Array._getCount()();
  Swift::Int result = Array._getCount()();
  Swift::Int v83 = result;
  int64_t v26 = 0LL;
  int64_t v27 = 0LL;
  unint64_t v80 = v23 & 0xC000000000000001LL;
  uint64_t v81 = v23;
  uint64_t v28 = v7;
  uint64_t v77 = v7;
  unint64_t v78 = v24 & 0xC000000000000001LL;
  uint64_t v85 = v24;
  v70[1] = a1;
  unint64_t v75 = v12;
  while (1)
  {
    if (v27 >= v84)
    {
      if (v26 >= v83) {
        return result;
      }
      BOOL v55 = v80 == 0;
      char v56 = v55 | ~_swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
      uint64_t v57 = v81;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v56 & 1);
      if ((v56 & 1) == 0)
      {
        id v62 = _ArrayBuffer._getElementSlowPath(_:)(v26, v57, v8);
        id v63 = v62;
        if (v70[0] != 8LL) {
          goto LABEL_49;
        }
        Swift::String::Index v45 = v12;
        int64_t v87 = (char *)v62;
        uint64_t v54 = (uint64_t)v82;
        (*(void (**)(char *, char **, uint64_t *))(v9 + 16))(v82, &v87, v8);
        unint64_t v64 = v63;
        goto LABEL_39;
      }

      uint64_t v54 = (uint64_t)v82;
      (*(void (**)(char *, unint64_t, uint64_t *))(v9 + 16))( v82,  v57 + ((*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
      + *(void *)(v9 + 72) * v26,
        v8);
      uint64_t v28 = v77;
      Swift::String::Index v45 = v12;
    }

    else
    {
      BOOL v31 = v78 == 0;
      BOOL v32 = !_swift_isClassOrObjCExistentialType((uint64_t)v8, v8) || v31;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v32);
      if (v26 >= v83)
      {
        if (v32)
        {
          uint64_t v54 = (uint64_t)v82;
          (*(void (**)(char *, unint64_t, uint64_t *))(v9 + 16))( v82,  v85 + ((*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
          + *(void *)(v9 + 72) * v27,
            v8);
          Swift::String::Index v45 = v12;
        }

        else
        {
          uint64_t v67 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v85, v8);
          Swift::String::Index v45 = v67;
          if (v70[0] != 8LL) {
            goto LABEL_48;
          }
          int64_t v87 = v67;
          uint64_t v54 = (uint64_t)v82;
          (*(void (**)(char *, char **, uint64_t *))(v9 + 16))(v82, &v87, v8);
          swift_unknownObjectRelease(v45);
          Swift::String::Index v45 = v12;
        }
      }

      else
      {
        if (v32)
        {
          unint64_t v33 = v85
          unint64_t v34 = v74;
          id v79 = *(void (**)(char *, unint64_t, uint64_t *))(v9 + 16);
          v79(v74, v33, v8);
        }

        else
        {
          unint64_t v65 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v85, v8);
          Swift::String::Index v45 = v65;
          if (v70[0] != 8LL) {
            goto LABEL_48;
          }
          int64_t v87 = v65;
          unint64_t v34 = v74;
          id v79 = *(void (**)(char *, unint64_t, uint64_t *))(v9 + 16);
          v79(v74, (unint64_t)&v87, v8);
          swift_unknownObjectRelease(v45);
        }

        BOOL v35 = v80 == 0;
        size_t v36 = (uint64_t *)v73;
        uint64_t v37 = v34;
        uint64_t v38 = *(void (**)(char *, char *, uint64_t *))(v9 + 32);
        v38(v73, v37, v8);
        uint64_t v39 = *v36;
        uint64_t v40 = (char *)v36
            + *((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v28,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
              + 12);
        unint64_t v76 = *(void (**)(char *, uint64_t))(*(void *)(v28 - 8) + 8LL);
        v76(v40, v28);
        char v41 = v35 | ~_swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
        uint64_t v42 = v81;
        Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v41 & 1);
        if ((v41 & 1) != 0)
        {
          unint64_t v43 = v42
          Swift::String::Index v44 = v71;
          v79(v71, v43, v8);
        }

        else
        {
          char v66 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v26, v42, v8);
          Swift::String::Index v45 = v66;
          if (v70[0] != 8LL) {
            goto LABEL_48;
          }
          int64_t v87 = v66;
          Swift::String::Index v44 = v71;
          v79(v71, (unint64_t)&v87, v8);
          swift_unknownObjectRelease(v45);
        }

        Swift::String::Index v45 = v75;
        Swift::String::Index v46 = v38;
        Swift::String::Index v47 = (uint64_t *)v72;
        v46(v72, v44, v8);
        uint64_t v48 = *v47;
        TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v28,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
        v76((char *)v47 + *((int *)TupleTypeMetadata3 + 12), v28);
        if (__OFSUB__(v39, v27)) {
          goto LABEL_46;
        }
        BOOL v29 = __OFSUB__(v48, v26);
        uint64_t v50 = v48 - v26;
        if (v29) {
          goto LABEL_47;
        }
        BOOL v51 = !_swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
        if (v50 < v39 - v27)
        {
          uint64_t v52 = v81;
          BOOL v53 = v51 || v80 == 0;
          Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v51 || v80 == 0);
          if (v53)
          {
            uint64_t v54 = (uint64_t)v82;
            v79( v82,  v52 + ((*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
            + *(void *)(v9 + 72) * v26,
              v8);
LABEL_15:
            uint64_t v28 = v77;
            goto LABEL_24;
          }

          id v62 = _ArrayBuffer._getElementSlowPath(_:)(v26, v52, v8);
          id v68 = v62;
          if (v70[0] != 8LL) {
            goto LABEL_49;
          }
          int64_t v87 = (char *)v62;
          uint64_t v54 = (uint64_t)v82;
          v79(v82, (unint64_t)&v87, v8);
          unint64_t v64 = v68;
LABEL_39:
          swift_unknownObjectRelease(v64);
          goto LABEL_15;
        }

        unint64_t v58 = v79;
        BOOL v59 = v51 || v78 == 0;
        uint64_t v60 = v85;
        Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v51 || v78 == 0);
        if (v59)
        {
          uint64_t v54 = (uint64_t)v82;
          v58( v82,  v60 + ((*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
          + *(void *)(v9 + 72) * v27,
            v8);
        }

        else
        {
          uint64_t v69 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v60, v8);
          Swift::String::Index v45 = v69;
          if (v70[0] != 8LL) {
            goto LABEL_48;
          }
          int64_t v87 = v69;
          uint64_t v54 = (uint64_t)v82;
          v58(v82, (unint64_t)&v87, v8);
          swift_unknownObjectRelease(v45);
        }

        Swift::String::Index v45 = v75;
      }
    }

uint64_t protocol witness for Error._domain.getter in conformance _ApplicationError(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError( a1,  a2,  &demangling cache variable for type metadata for _ApplicationError.Type);
}

uint64_t RangeReplaceableCollection.applying(_:)@<X0>( _OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v113 = a1;
  uint64_t v111 = a4;
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  Swift::String::Index v100 = (char *)&v87 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v93 = (char *)&v87 - v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v99 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v98 = *(void *)(v99 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v99);
  BOOL v92 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v95 = (char *)&v87 - v15;
  unint64_t v96 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  MEMORY[0x1895F8858](v96);
  uint64_t v94 = (char *)&v87 - v16;
  unint64_t v109 = AssociatedConformanceWitness;
  uint64_t v107 = type metadata accessor for PartialRangeFrom(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v17);
  uint64_t v106 = *(void *)(v107 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v107);
  uint64_t v102 = (char *)&v87 - v19;
  uint64_t v112 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v104 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v103 = (char *)&v87 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  char v105 = (char *)&v87 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v108 = (char *)&v87 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v87 - v29;
  uint64_t v31 = MEMORY[0x1895F8858](v28);
  unint64_t v33 = (char *)&v87 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  size_t v36 = (char *)&v87 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  uint64_t v39 = (char *)&v87 - v38;
  uint64_t v110 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v37);
  char v41 = (char *)&v87 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
  uint64_t v126 = 0LL;
  uint64_t v127 = 0LL;
  uint64_t v125 = 0LL;
  uint64_t v42 = v114;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(a2, v6);
  __int128 v124 = *v113;
  uint64_t v116 = a2;
  uint64_t v117 = a3;
  uint64_t v101 = a3;
  unint64_t v118 = &v125;
  unint64_t v119 = v41;
  unint64_t v113 = v41;
  uint64_t v120 = v42;
  char v121 = v39;
  uint64_t v122 = &v127;
  uint64_t v123 = &v126;
  unint64_t v43 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v46 = type metadata accessor for CollectionDifference(0LL, v43, v44, v45);
  CollectionDifference._fastEnumeratedApply(_:)((uint64_t)v115, v46, v47, v48);
  char v90 = v33;
  unint64_t v49 = *(void (**)(uint64_t, uint64_t))(v6 + 72);
  uint64_t v91 = v6;
  v49(a2, v6);
  unint64_t v50 = v109;
  LOBYTE(v42) = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v109 + 16))( v39,  v36,  AssociatedTypeWitness,  v109);
  uint64_t v51 = v112;
  uint64_t v52 = *(void (**)(char *, unint64_t))(v112 + 8);
  v52(v36, AssociatedTypeWitness);
  if ((v42 & 1) != 0)
  {
    char v88 = v49;
    BOOL v53 = *(void (**)(char *, char *, unint64_t))(v51 + 16);
    uint64_t v54 = v90;
    int64_t v87 = v39;
    v53(v90, v39, AssociatedTypeWitness);
    int64_t v89 = v53;
    v53(v30, v54, AssociatedTypeWitness);
    if (((*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(v50 + 8) + 8LL))( v30,  v30,  AssociatedTypeWitness) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range cannot have an unordered lower bound.",  43LL,  2,  "Swift/Range.swift",  17LL,  2,  0x34FuLL,  0);
    }
    v52(v30, AssociatedTypeWitness);
    BOOL v55 = v102;
    uint64_t v112 = *(void *)(v51 + 32);
    ((void (*)(char *, char *, unint64_t))v112)(v102, v54, AssociatedTypeWitness);
    char v56 = v108;
    uint64_t v57 = v89;
    v89(v108, v55, AssociatedTypeWitness);
    unint64_t v58 = v105;
    v88(a2, v91);
    BOOL v59 = v103;
    v57(v103, v56, AssociatedTypeWitness);
    uint64_t v60 = v52;
    uint64_t v61 = v104;
    v57(v104, v58, AssociatedTypeWitness);
    char v62 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v50 + 24))( v59,  v61,  AssociatedTypeWitness,  v50);
    uint64_t v63 = v107;
    uint64_t v64 = v106;
    if ((v62 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    v60(v61, AssociatedTypeWitness);
    v60(v59, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v64 + 8))(v55, v63);
    unint64_t v65 = TupleTypeMetadata2;
    char v66 = v93;
    uint64_t v67 = &v93[*((int *)TupleTypeMetadata2 + 12)];
    id v68 = (void (*)(char *, char *, unint64_t))v112;
    ((void (*)(char *, char *, unint64_t))v112)(v93, v108, AssociatedTypeWitness);
    v68(v67, v58, AssociatedTypeWitness);
    uint64_t v69 = v100;
    unint64_t v70 = &v100[*((int *)v65 + 12)];
    unint64_t v71 = v89;
    v89(v100, v66, AssociatedTypeWitness);
    v71(v70, v67, AssociatedTypeWitness);
    char v72 = v92;
    v68(v92, v69, AssociatedTypeWitness);
    v60(v70, AssociatedTypeWitness);
    uint64_t v73 = &v69[*((int *)v65 + 12)];
    v68(v69, v66, AssociatedTypeWitness);
    v68(v73, v67, AssociatedTypeWitness);
    uint64_t v74 = v99;
    v68(&v72[*(int *)(v99 + 36)], v73, AssociatedTypeWitness);
    v60(v69, AssociatedTypeWitness);
    uint64_t v75 = v98;
    unint64_t v76 = v95;
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v95, v72, v74);
    uint64_t v77 = v91;
    unint64_t v78 = v94;
    (*(void (**)(char *, uint64_t, uint64_t))(v91 + 88))(v76, a2, v91);
    (*(void (**)(char *, uint64_t))(v75 + 8))(v76, v74);
    uint64_t v79 = v101;
    unint64_t v80 = *(void (**)(char *, unint64_t, void, uint64_t, uint64_t))(v101 + 72);
    unint64_t v81 = v96;
    unint64_t v82 = swift_getAssociatedConformanceWitness( v77,  a2,  v96,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    v80(v78, v81, *(void *)(v82 + 8), a2, v79);
    uint64_t v52 = v60;
    uint64_t v39 = v87;
  }

  v52(v39, AssociatedTypeWitness);
  uint64_t v83 = v110;
  uint64_t v84 = v111;
  uint64_t v85 = v113;
  (*(void (**)(uint64_t, _OWORD *, uint64_t))(v110 + 16))(v111, v113, a2);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v83 + 56))(v84, 0LL, 1LL, a2);
  return (*(uint64_t (**)(_OWORD *, uint64_t))(v83 + 8))(v85, a2);
}

uint64_t append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v78 = a6;
  uint64_t v86 = a4;
  uint64_t v77 = a1;
  uint64_t v9 = *(void *)(a6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v75 = (char *)&v66 - v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  a5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v11, v11, "lower upper ", 0LL);
  uint64_t v12 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v73 = (char *)&v66 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  id v68 = (char *)&v66 - v14;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a5,  v11,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v16 = type metadata accessor for Range(0LL, v11, AssociatedConformanceWitness, v15);
  uint64_t v71 = *(void *)(v16 - 8);
  uint64_t v72 = v16;
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v67 = (char *)&v66 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v69 = (char *)&v66 - v19;
  uint64_t v22 = type metadata accessor for Optional(0LL, v11, v20, v21);
  uint64_t v79 = *(void *)(v22 - 8);
  uint64_t v80 = v22;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v66 - v24;
  uint64_t v26 = *(void *)(v11 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v23);
  unint64_t v81 = (char *)&v66 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v85 = (char *)&v66 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v83 = (char *)&v66 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v35 = (char *)&v66 - v34;
  MEMORY[0x1895F8858](v33);
  uint64_t v37 = (char *)&v66 - v36;
  unint64_t v82 = *(void (**)(char *, uint64_t, unint64_t))(v26 + 16);
  v82((char *)&v66 - v36, a3, v11);
  (*(void (**)(uint64_t, uint64_t))(v9 + 72))(a5, v9);
  uint64_t v38 = *(void (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(v9 + 144);
  uint64_t v39 = v86;
  uint64_t v74 = a2;
  uint64_t v86 = a5;
  v38(a3, v39, v35, a5, v9);
  uint64_t v40 = *(void (**)(uint64_t, unint64_t))(v26 + 8);
  v40(a3, v11);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v26 + 48))(v25, 1LL, v11) == 1)
  {
    (*(void (**)(char *, uint64_t))(v79 + 8))(v25, v80);
    (*(void (**)(uint64_t, char *, unint64_t))(v26 + 32))(a3, v35, v11);
    v40((uint64_t)v37, v11);
    swift_allocError((uint64_t)&unk_189B897A8, (uint64_t)&protocol witness table for _ApplicationError, 0LL, 0);
    return swift_willThrow();
  }

  else
  {
    v40((uint64_t)v35, v11);
    uint64_t v42 = *(void (**)(uint64_t, char *, unint64_t))(v26 + 32);
    v42(a3, v25, v11);
    unint64_t v43 = v83;
    uint64_t v44 = a3;
    uint64_t v45 = (void (*)(char *, char *, unint64_t))v82;
    v82(v83, v44, v11);
    uint64_t v46 = v85;
    v45(v85, v37, v11);
    uint64_t v47 = v81;
    v45(v81, v43, v11);
    if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v46,  v47,  v11) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    v40((uint64_t)v47, v11);
    v40((uint64_t)v85, v11);
    unint64_t AssociatedConformanceWitness = (unint64_t)v40;
    uint64_t v85 = (char *)v9;
    uint64_t v48 = TupleTypeMetadata2;
    unint64_t v49 = v68;
    unint64_t v50 = &v68[*((int *)TupleTypeMetadata2 + 12)];
    v42((uint64_t)v68, v37, v11);
    v42((uint64_t)v50, v43, v11);
    uint64_t v51 = v73;
    uint64_t v52 = &v73[*((int *)v48 + 12)];
    v45(v73, v49, v11);
    v45(v52, v50, v11);
    BOOL v53 = v67;
    v42((uint64_t)v67, v51, v11);
    uint64_t v54 = (void (*)(char *, unint64_t))AssociatedConformanceWitness;
    ((void (*)(char *, unint64_t))AssociatedConformanceWitness)(v52, v11);
    BOOL v55 = &v51[*((int *)v48 + 12)];
    v42((uint64_t)v51, v49, v11);
    v42((uint64_t)v55, v50, v11);
    uint64_t v56 = v72;
    v42((uint64_t)&v53[*(int *)(v72 + 36)], v55, v11);
    v54(v51, v11);
    uint64_t v57 = v71;
    unint64_t v58 = v69;
    (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v69, v53, v56);
    uint64_t v59 = (uint64_t)v85;
    uint64_t v60 = v75;
    uint64_t v61 = v86;
    (*((void (**)(char *, uint64_t, char *))v85 + 11))(v58, v86, v85);
    (*(void (**)(char *, uint64_t))(v57 + 8))(v58, v56);
    uint64_t v62 = v78;
    uint64_t v63 = *(uint64_t (**)(char *, unint64_t, void, uint64_t, uint64_t))(v78 + 72);
    unint64_t v64 = AssociatedTypeWitness;
    unint64_t v65 = swift_getAssociatedConformanceWitness( v59,  v61,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    return v63(v60, v64, *(void *)(v65 + 8), v61, v62);
  }

unint64_t *closure #1 in RangeReplaceableCollection.applying(_:)( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v66 = a7;
  unint64_t v65 = a6;
  uint64_t v69 = a4;
  uint64_t v70 = a5;
  uint64_t v68 = a3;
  uint64_t v12 = *(void *)(a9 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v12 + 8),  a8,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v14 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v60 = (char *)&v59 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v59 - v17;
  uint64_t v63 = v12;
  uint64_t v71 = a8;
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  a8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t v64 = *(void *)(v19 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  uint64_t v62 = (char *)&v59 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  uint64_t v61 = (char *)&v59 - v22;
  uint64_t v25 = type metadata accessor for CollectionDifference.Change(0LL, AssociatedTypeWitness, v23, v24);
  MEMORY[0x1895F8858](v25);
  uint64_t v27 = (unsigned __int8 *)&v59 - v26;
  (*(void (**)(char *, uint64_t, uint64_t))(v28 + 16))((char *)&v59 - v26, a1, v25);
  LODWORD(v25) = swift_getEnumCaseMultiPayload(v27, v25);
  uint64_t v29 = *(void *)v27;
  Swift::Int result = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  AssociatedTypeWitness,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
  uint64_t v31 = &v27[*((int *)result + 12)];
  if ((_DWORD)v25 != 1)
  {
    unint64_t v43 = AssociatedTypeWitness;
    uint64_t v44 = (uint64_t (*)(char *, unsigned __int8 *))v14[4];
    unint64_t v64 = v43;
    Swift::Int result = (unint64_t *)v44(v18, v31);
    uint64_t v45 = v29 + *v65;
    if (!__OFADD__(v29, *v65))
    {
      BOOL v46 = __OFSUB__(v45, *v66);
      uint64_t v47 = v45 - *v66;
      if (!v46)
      {
        uint64_t v48 = v47 - *a2;
        if (!__OFSUB__(v47, *a2))
        {
          unint64_t v49 = a2;
          uint64_t v50 = v47 - *a2;
          uint64_t v51 = v71;
          uint64_t v52 = v67;
          append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)( v68,  v69,  v70,  v50,  v71,  a9);
          if (v52)
          {
            uint64_t v42 = v18;
            unint64_t AssociatedTypeWitness = v64;
            return (unint64_t *)((uint64_t (*)(char *, unint64_t))v14[1])( v42,  AssociatedTypeWitness);
          }

          BOOL v53 = v60;
          ((void (*)(char *, char *, unint64_t))v44)(v60, v18, v64);
          Swift::Int result = (unint64_t *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(a9 + 64))(v53, v51, a9);
          if (!__OFADD__(*v49, v48))
          {
            *v49 += v48;
            if (!__OFADD__(*v66, 1LL))
            {
              ++*v66;
              return result;
            }

            goto LABEL_26;
          }

uint64_t BidirectionalCollection.difference<A>(from:by:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  v17[2] = a5;
  v17[3] = a4;
  v17[4] = a7;
  v17[5] = a6;
  v17[7] = a2;
  v17[8] = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(*(void *)(a6 + 8) + 8LL),  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v15 = type metadata accessor for CollectionDifference(0LL, AssociatedTypeWitness, v13, v14);
  return _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)( a1,  (void (*)(uint64_t, void))partial apply for closure #1 in _myers<A, B>(from:to:using:),  (uint64_t)v17,  a5,  v15,  *(void *)(a7 + 8),  a8);
}

uint64_t BidirectionalCollection<>.difference<A>(from:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a4 + 8) + 8LL),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v25 = a2;
  uint64_t v26 = a3;
  uint64_t v27 = a4;
  uint64_t v28 = a5;
  uint64_t v29 = a6;
  unint64_t v30 = AssociatedTypeWitness;
  v20[2] = a3;
  v20[3] = a2;
  v20[4] = a5;
  v20[5] = a4;
  uint64_t v21 = v7;
  uint64_t v22 = partial apply for implicit closure #1 in BidirectionalCollection<>.difference<A>(from:);
  uint64_t v23 = &v24;
  uint64_t v18 = type metadata accessor for CollectionDifference(0LL, AssociatedTypeWitness, v16, v17);
  return _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)( a1,  (void (*)(uint64_t, void))partial apply for closure #1 in _myers<A, B>(from:to:using:),  (uint64_t)v20,  a3,  v18,  *(void *)(a5 + 8),  a7);
}

__objc2_class **_descent #1 <A, B>(from:to:) in _myers<A, B>(from:to:using:)( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(char *, char *), uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v74 = a3;
  uint64_t v75 = a5;
  uint64_t v77 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a8 + 8) + 8LL),  a7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v73 = (char *)&v56 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v56 - v14;
  int64_t v67 = a2;
  unint64_t v59 = a2 + a4;
  if (__OFADD__(a2, a4)) {
    goto LABEL_93;
  }
  uint64_t v16 = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(2LL);
  v16[2] = (__objc2_class *)2;
  a2 = (unint64_t)v16;
  v16[4] = 0LL;
  v16[5] = 0LL;
  if (!*(void *)(a2 + 16)) {
    goto LABEL_95;
  }
  while (1)
  {
    *(void *)(a2 + 32) = 0LL;
    if ((v59 & 0x8000000000000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
    }
    uint64_t v76 = v11;
    uint64_t v20 = 0LL;
    int64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    int64_t v72 = v67 - 1;
    uint64_t v61 = -a4;
    uint64_t v23 = &_swiftEmptyArrayStorage;
    uint64_t v60 = a4;
LABEL_6:
    unint64_t v66 = a2;
    swift_bridgeObjectRetain(a2, v17, v18, v19);
    else {
      char v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v23[2]->isa + 1,  1,  (uint64_t)v23);
    }
    unint64_t v26 = (unint64_t)v24[2];
    unint64_t v25 = (unint64_t)v24[3];
    uint64_t v11 = v26 + 1;
    if (v26 >= v25 >> 1) {
      char v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v25 > 1),  v26 + 1,  1,  (uint64_t)v24);
    }
    void v24[2] = (__objc2_class *)v11;
    uint64_t v27 = &v24[v26];
    a2 = v66;
    v27[4] = (__objc2_class *)v66;
    if (!__OFADD__(v22, 1LL)) {
      break;
    }
LABEL_92:
    __break(1u);
LABEL_93:
    __break(1u);
LABEL_94:
    a2 = (unint64_t)specialized _ArrayBuffer._consumeAndCreateNew()(a2);
    if (!*(void *)(a2 + 16)) {
      goto LABEL_95;
    }
  }

  unint64_t v58 = v24;
  uint64_t v57 = v22 + 1;
  Swift::Int result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)(v22 + 1));
  uint64_t v29 = (uint64_t)result;
  uint64_t v64 = 0LL;
  unint64_t v65 = 0LL;
  unint64_t v30 = -v22;
  unint64_t v68 = a2 + 32;
  uint64_t v62 = v22 - 1;
  unint64_t v63 = -v22;
  uint64_t v31 = -v22;
  while (v31 < v22)
  {
    if (__OFADD__(v31, 2LL))
    {
      HIDWORD(v64) = 0;
      unint64_t v65 = 0x8000000000000000LL;
      uint64_t v69 = 0x7FFFFFFFFFFFFFFFLL;
      if (v31 != v30)
      {
        uint64_t v33 = 0x7FFFFFFFFFFFFFFDLL;
LABEL_33:
        unint64_t v34 = v33 - 1;
        goto LABEL_35;
      }

      unint64_t v32 = 0x7FFFFFFFFFFFFFFELL;
      goto LABEL_28;
    }

    uint64_t v69 = v31 + 2;
    if (v31 == v30)
    {
      unint64_t v65 = 0LL;
      if (v30 >= 0x7FFFFFFFFFFFFFFFLL) {
        unint64_t v32 = ~v31;
      }
      else {
        unint64_t v32 = v30;
      }
      HIDWORD(v64) = 1;
      goto LABEL_28;
    }

    unint64_t v65 = 0LL;
    uint64_t v33 = v31 - 1;
    HIDWORD(v64) = 1;
    if (v31 - 1 >= 1) {
      goto LABEL_33;
    }
LABEL_34:
    BOOL v35 = __OFSUB__(0LL, v33);
    unint64_t v34 = -v33;
    if (v35)
    {
LABEL_91:
      __break(1u);
      goto LABEL_92;
    }

void _formChanges #1 <A, B>(from:to:using:) in _myers<A, B>(from:to:using:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v46 = a2;
  uint64_t v47 = a4;
  uint64_t v44 = a1;
  uint64_t v45 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(*(void *)(a7 + 8) + 8LL),  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = type metadata accessor for CollectionDifference.Change(0LL, AssociatedTypeWitness, v9, v10);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v43 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v43 - v15;
  uint64_t v50 = &_swiftEmptyArrayStorage;
  unint64_t v17 = *(void *)(a5 + 16);
  uint64_t v49 = type metadata accessor for Array(0LL, v11, v18, v19);
  Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(v17, 0);
  if (v17 >= 2)
  {
    uint64_t v48 = a5 + 24;
    unint64_t v20 = 1 - v17;
    uint64_t v21 = v46;
    uint64_t v22 = v47;
    while (1)
    {
      unint64_t v26 = v17 - 1;
      uint64_t v27 = *(void *)(v48 + 8 * v17);
      unint64_t v28 = v21 - v22;
      if (v20 == v21 - v22) {
        goto LABEL_6;
      }
      uint64_t v29 = v28 - 1;
      if (v26 != v28)
      {
        if (v29 < 1)
        {
          unint64_t v39 = 1 - v28;
          if (__OFSUB__(0LL, v29)) {
            goto LABEL_45;
          }
        }

        else
        {
          unint64_t v39 = v28 - 2;
        }

        if ((v39 & 0x8000000000000000LL) != 0) {
          goto LABEL_40;
        }
        unint64_t v40 = *(void *)(v27 + 16);
        if (v39 >= v40) {
          goto LABEL_40;
        }
        uint64_t v41 = *(void *)(v27 + 32 + 8 * v39);
        if (v28 > 0x7FFFFFFFFFFFFFFELL)
        {
          unint64_t v42 = -(uint64_t)(v28 + 1);
          if (__OFSUB__(0LL, v28 + 1)) {
            goto LABEL_44;
          }
        }

        else
        {
          unint64_t v42 = v21 - v22;
        }

        if ((v42 & 0x8000000000000000LL) != 0 || v42 >= v40) {
LABEL_40:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        if (v41 < *(void *)(v27 + 32 + 8 * v42)) {
LABEL_6:
        }
          uint64_t v29 = v28 + 1;
      }

      unint64_t v30 = v29 - 1;
      if (v29 < 1)
      {
        unint64_t v30 = -v29;
        if (__OFSUB__(0LL, v29)) {
          break;
        }
      }

      if ((v30 & 0x8000000000000000LL) != 0 || v30 >= *(void *)(v27 + 16)) {
        goto LABEL_40;
      }
      uint64_t v31 = *(void *)(v27 + 8 * v30 + 32);
      uint64_t v32 = v31 - v29;
      unint64_t v33 = ~v31 + v29 + v22;
      if (v33 >= v21 + ~v31) {
        unint64_t v33 = v21 + ~v31;
      }
      uint64_t v34 = v22 + ~v33;
      if (v31 < v21 && v32 < v22) {
        uint64_t v36 = v34;
      }
      else {
        uint64_t v36 = v22;
      }
      if (v36 == v32)
      {
        *(void *)uint64_t v14 = v31;
        if (v31 < 0) {
          goto LABEL_41;
        }
        if (v31 >= v46) {
          goto LABEL_42;
        }
        TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  AssociatedTypeWitness,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
        unint64_t v38 = &v14[*((int *)TupleTypeMetadata3 + 16)];
        (*(void (**)(char *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( &v14[*((int *)TupleTypeMetadata3 + 12)],  v44 + *(void *)(*(void *)(AssociatedTypeWitness - 8) + 72LL) * v31,  AssociatedTypeWitness);
        *(void *)unint64_t v38 = 0LL;
        v38[8] = 1;
        swift_storeEnumTagMultiPayload(v14, v11, 1u);
        uint64_t v25 = (uint64_t)v14;
      }

      else
      {
        *(void *)uint64_t v16 = v32;
        if (v32 < 0) {
LABEL_41:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
        if (v32 >= v47) {
LABEL_42:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
        uint64_t v23 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  AssociatedTypeWitness,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
        char v24 = &v16[*((int *)v23 + 16)];
        (*(void (**)(char *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( &v16[*((int *)v23 + 12)],  v45 + *(void *)(*(void *)(AssociatedTypeWitness - 8) + 72LL) * v32,  AssociatedTypeWitness);
        *(void *)char v24 = 0LL;
        v24[8] = 1;
        swift_storeEnumTagMultiPayload(v16, v11, 0);
        uint64_t v25 = (uint64_t)v16;
      }

      Array.append(_:)(v25, v49);
      ++v20;
      --v17;
      uint64_t v21 = v31;
      uint64_t v22 = v32;
      if (v26 + 1 <= 2) {
        return;
      }
    }

    __break(1u);
LABEL_44:
    __break(1u);
LABEL_45:
    __break(1u);
  }

uint64_t _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)@<X0>( uint64_t a1@<X0>, void (*a2)(uint64_t, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v38 = a7;
  uint64_t v40 = a1;
  uint64_t v33 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v37 = (char *)&v32 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = type metadata accessor for Optional(0LL, v15, v13, v14);
  uint64_t v17 = *(void *)(v16 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v20 = (char *)&v32 - v19;
  uint64_t v36 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v32 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = *(void *)(a6 + 8);
  char v24 = *(uint64_t (**)(void (*)(uint64_t, void), uint64_t, uint64_t, uint64_t, uint64_t))(v23 + 72);
  uint64_t v34 = a2;
  uint64_t v35 = a3;
  uint64_t v25 = v39;
  uint64_t result = v24(a2, a3, a5, a4, v23);
  if (!v25)
  {
    uint64_t v28 = v36;
    uint64_t v27 = v37;
    uint64_t v39 = 0LL;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v36 + 48))(v20, 1LL, a5) == 1)
    {
      (*(void (**)(char *, uint64_t))(v17 + 8))(v20, v16);
      (*(void (**)(char *, uint64_t, uint64_t))(v33 + 16))(v27, v40, a4);
      uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v23 + 56))(a4, v23);
      uint64_t v30 = *(unsigned __int8 *)(*(void *)(swift_getAssociatedTypeWitness( 0LL,  (const char *)v23,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element)
                                           - 8)
                               + 80LL);
      v34(v29 + ((v30 + 32) & ~v30), *(void *)(v29 + 16));
      return swift_release(v29);
    }

    else
    {
      uint64_t v31 = *(void (**)(char *, char *, uint64_t))(v28 + 32);
      v31(v22, v20, a5);
      return ((uint64_t (*)(uint64_t, char *, uint64_t))v31)(v38, v22, a5);
    }
  }

  return result;
}

void closure #1 in _myers<A, B>(from:to:using:)( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X6>, uint64_t a5@<X7>, _OWORD *a6@<X8>)
{
  void (*v22)(void *__return_ptr, double (*)@<D0>(uint64_t@<X0>, uint64_t@<X1>, _OWORD *@<X8>), _BYTE *, uint64_t, uint64_t, uint64_t);
  unint64_t AssociatedTypeWitness;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _OWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t (*v35)(char *, char *);
  uint64_t v36;
  void *v37;
  _BYTE v38[16];
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t (*v45)(char *, char *);
  uint64_t v46;
  void v47[2];
  _OWORD *v48;
  uint64_t v48 = a6;
  uint64_t v10 = *(void *)(a4 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v32 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v39 = v14;
  uint64_t v40 = v15;
  uint64_t v41 = v16;
  unint64_t v42 = v17;
  uint64_t v33 = v11;
  uint64_t v34 = v18;
  uint64_t v43 = v11;
  uint64_t v44 = v18;
  uint64_t v35 = v19;
  uint64_t v36 = v20;
  uint64_t v45 = v19;
  uint64_t v46 = v20;
  uint64_t v21 = *(void *)(*(void *)(v17 + 8) + 8LL);
  uint64_t v22 = *(void (**)(void *__return_ptr, double (*)@<D0>(uint64_t@<X0>, uint64_t@<X1>, _OWORD *@<X8>), _BYTE *, uint64_t, uint64_t, uint64_t))(v21 + 72);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(*(void *)(v16 + 8) + 8LL),  v14,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v26 = type metadata accessor for CollectionDifference(0LL, AssociatedTypeWitness, v24, v25);
  uint64_t v27 = v37;
  v22(v47, partial apply for closure #1 in closure #1 in _myers<A, B>(from:to:using:), v38, v26, a4, v21);
  if (v27)
  {
    swift_errorRelease(v27);
    __break(1u);
  }

  else if (v47[0])
  {
    uint64_t v28 = v47[1];
    uint64_t v29 = v48;
    *(void *)uint64_t v48 = v47[0];
    *((void *)v29 + 1) = v28;
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v13, a2, a4);
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v21 + 56))(a4, v21);
    uint64_t v31 = *(unsigned __int8 *)(*(void *)(AssociatedTypeWitness - 8) + 80LL);
    closure #1 in closure #1 in _myers<A, B>(from:to:using:)( v30 + ((v31 + 32) & ~v31),  *(void *)(v30 + 16),  v33,  v34,  v35,  v36,  a3,  a5,  v48);
    swift_release(v30);
  }

double closure #1 in closure #1 in _myers<A, B>(from:to:using:)@<D0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t (*a5)(char *, char *)@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _OWORD *a9@<X8>)
{
  uint64_t v16 = _descent #1 <A, B>(from:to:) in _myers<A, B>(from:to:using:)(a3, a4, a1, a2, a5, a6, a7, a8);
  _formChanges #1 <A, B>(from:to:using:) in _myers<A, B>(from:to:using:)(a3, a4, a1, a2, (uint64_t)v16, a7, a8);
  uint64_t v18 = v17;
  swift_bridgeObjectRelease((uint64_t)v16);
  uint64_t v30 = v18;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a8 + 8) + 8LL),  a7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v22 = type metadata accessor for CollectionDifference.Change(255LL, AssociatedTypeWitness, v20, v21);
  uint64_t v25 = type metadata accessor for Array(0LL, v22, v23, v24);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v25, v26);
  if ((static CollectionDifference._validateChanges<A>(_:)((uint64_t)&v30, AssociatedTypeWitness, v25, WitnessTable) & 1) == 0)
  {
    swift_bridgeObjectRelease(v18);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Diffing.swift",  19LL,  2,  0x16BuLL,  0);
  }

  CollectionDifference.init<A>(_validatedChanges:)( (uint64_t)&v30,  AssociatedTypeWitness,  v25,  WitnessTable,  (__objc2_class ***)&v29);
  double result = *(double *)&v29;
  *a9 = v29;
  return result;
}

uint64_t Duration._low.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Duration._low.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Duration._high.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t (*Duration._high.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Duration __swiftcall Duration.init(secondsComponent:attosecondsComponent:)( Swift::Int64 secondsComponent, Swift::Int64 attosecondsComponent)
{
  Swift::UInt64 v2 = specialized static Duration.+ infix(_:_:)( 1000000000000000000LL * secondsComponent,  ((secondsComponent >> 63) & 0xF21F494C589C0000LL)
       + (((unint64_t)secondsComponent * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64),
         attosecondsComponent,
         attosecondsComponent >> 63);
  result._high = v3;
  result._low = v2;
  return result;
}

uint64_t static Duration.seconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v92 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v92,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v90 = (char *)&v88 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v6);
  uint64_t v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v94 = (char *)&v88 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v96 = (char *)&v88 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v88 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v88 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v88 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v88 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  __int128 v29 = (char *)&v88 - v28;
  int64_t v101 = 64LL;
  uint64_t v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  uint64_t v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  Swift::String::Index v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v98 = v8;
  uint64_t v99 = v34;
  v34(v26, v29, a2);
  BOOL v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  uint64_t v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v43 = v99;
    goto LABEL_10;
  }

  int64_t v101 = 0x8000000000000000LL;
  if ((v97(a2, a3) & 1) != 0)
  {
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v39 = v38(a2, a3);
    if (v39 < 64)
    {
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      uint64_t v43 = v99;
      if (v42 < v101) {
        goto LABEL_46;
      }
      goto LABEL_10;
    }

    uint64_t v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    uint64_t v37 = v97;
    char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/Duration.swift",  20LL,  2,  0x71uLL,  0);
    }

    goto LABEL_10;
  }

  char v60 = v37(a2, a3);
  int64_t v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      unint64_t v81 = AssociatedTypeWitness;
      unint64_t v82 = (void (**)(char *, uint64_t, const char *))v92;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v81,  AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
      v36(v20, a2);
      uint64_t v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      uint64_t v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }

      int64_t v85 = v101;
      uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      BOOL v87 = v86 < v85;
      uint64_t v43 = v99;
      uint64_t v37 = v97;
      if (!v87) {
        goto LABEL_10;
      }
      goto LABEL_46;
    }

    uint64_t v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    uint64_t v37 = v97;
    char v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if ((v66 & 1) != 0) {
      goto LABEL_46;
    }
LABEL_10:
    uint64_t v44 = v38(a2, a3);
    goto LABEL_11;
  }

  if (v61 < 64)
  {
    uint64_t v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if (v80 < v101) {
      goto LABEL_46;
    }
    goto LABEL_10;
  }

  v36(v23, a2);
  uint64_t v43 = v99;
  uint64_t v38 = v89;
  uint64_t v44 = v89(a2, a3);
LABEL_11:
  uint64_t v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    uint64_t v46 = v17;
    uint64_t v47 = v38;
    v36(v46, a2);
    uint64_t v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }

  uint64_t v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    uint64_t v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    unint64_t v59 = v48;
    goto LABEL_27;
  }

  uint64_t v47 = v38;
  char v58 = v37(a2, a3);
  uint64_t v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0) {
    goto LABEL_26;
  }
LABEL_13:
  int64_t v101 = 0x7FFFFFFFFFFFFFFFLL;
  char v49 = v37(a2, a3);
  uint64_t v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      BOOL v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v20,  v48,  a2);
      v36(v20, a2);
      uint64_t v56 = v48;
      goto LABEL_29;
    }

    goto LABEL_20;
  }

  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    unint64_t v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }

  uint64_t v100 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  unint64_t v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  int64_t v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v72,  v20,  a2);
  v36(v72, a2);
  uint64_t v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0) {
    goto LABEL_46;
  }
LABEL_30:
  uint64_t v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  uint64_t v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000000000000LL) >> 64 != (1000000000000000000LL * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }

  if (__OFADD__(1000000000000000000LL * v74, ((unint64_t)v75 * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }

  return 1000000000000000000LL * v75;
}

uint64_t Duration.components.getter(unint64_t a1, unint64_t a2)
{
  v4.low = 0x73AFF322E62439FDLL;
  v4.high = 0x9392EE8E921D5D0LL;
  *(_OWORD *)(&v5 - 1) = (unsigned __int128)_Int128.multipliedFullWidth(by:)(v4);
  uint64_t v7 = (__int128)__PAIR128__(v5, v6) >> 55;
  uint64_t v8 = v7 + (a2 >> 63);
  if (__CFADD__(v7, a2 >> 63)) {
    Swift::Int64 v9 = (v5 >> 55) + 1;
  }
  else {
    Swift::Int64 v9 = v5 >> 55;
  }
  v10.low = v7 + (a2 >> 63);
  v10.high = v9;
  *(_OWORD *)&unint64_t v11 = (unsigned __int128)_Int128.multipliedReportingOverflow(by:)(v10);
  unint64_t v13 = v12;
  uint64_t v14 = a1 - v11;
  BOOL v15 = v8 >= 0;
  if (v9 != -1) {
    BOOL v15 = v9 < -1;
  }
  if (v15) {
    goto LABEL_17;
  }
  BOOL v16 = v8 < 0;
  if (v9) {
    BOOL v16 = v9 > 0;
  }
  if (v16) {
LABEL_18:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  uint64_t v17 = (__PAIR128__(a2, a1) - __PAIR128__(v13, v11)) >> 64;
  BOOL v18 = v14 >= 0;
  if (v17 != -1) {
    BOOL v18 = v17 < -1;
  }
  if (v18) {
LABEL_17:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  BOOL v19 = v17 == 0;
  BOOL v20 = v17 > 0;
  if (v19) {
    BOOL v20 = v14 < 0;
  }
  if (v20) {
    goto LABEL_18;
  }
  return v8;
}

double static Double.- infix(_:_:)(double a1, double a2)
{
  return a1 - a2;
}

double Double.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t (**a3)(void, void))
{
  if (a3[16](a2, a3) <= 64)
  {
    char v7 = a3[8](a2, a3);
    uint64_t v8 = a3[15](a2, a3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    if ((v7 & 1) != 0) {
      return (double)v8;
    }
    else {
      return (double)(unint64_t)v8;
    }
  }

  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v9, a1, a2, (uint64_t)a3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    return v9;
  }

uint64_t static Duration.seconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0xDE0B6B3A7640000uLL, a1);
}

uint64_t static Duration.milliseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v92 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v92,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v90 = (char *)&v88 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v6);
  uint64_t v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v94 = (char *)&v88 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v96 = (char *)&v88 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v88 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  BOOL v20 = (char *)&v88 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v88 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v88 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  __int128 v29 = (char *)&v88 - v28;
  int64_t v101 = 64LL;
  uint64_t v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  uint64_t v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  Swift::String::Index v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v98 = v8;
  uint64_t v99 = v34;
  v34(v26, v29, a2);
  BOOL v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  uint64_t v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v43 = v99;
    goto LABEL_10;
  }

  int64_t v101 = 0x8000000000000000LL;
  if ((v97(a2, a3) & 1) != 0)
  {
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v39 = v38(a2, a3);
    if (v39 < 64)
    {
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      uint64_t v43 = v99;
      if (v42 < v101) {
        goto LABEL_46;
      }
      goto LABEL_10;
    }

    uint64_t v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    uint64_t v37 = v97;
    char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/Duration.swift",  20LL,  2,  0x9FuLL,  0);
    }

    goto LABEL_10;
  }

  char v60 = v37(a2, a3);
  int64_t v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      unint64_t v81 = AssociatedTypeWitness;
      unint64_t v82 = (void (**)(char *, uint64_t, const char *))v92;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v81,  AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
      v36(v20, a2);
      uint64_t v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      uint64_t v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }

      int64_t v85 = v101;
      uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      BOOL v87 = v86 < v85;
      uint64_t v43 = v99;
      uint64_t v37 = v97;
      if (!v87) {
        goto LABEL_10;
      }
      goto LABEL_46;
    }

    uint64_t v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    uint64_t v37 = v97;
    char v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if ((v66 & 1) != 0) {
      goto LABEL_46;
    }
LABEL_10:
    uint64_t v44 = v38(a2, a3);
    goto LABEL_11;
  }

  if (v61 < 64)
  {
    uint64_t v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if (v80 < v101) {
      goto LABEL_46;
    }
    goto LABEL_10;
  }

  v36(v23, a2);
  uint64_t v43 = v99;
  uint64_t v38 = v89;
  uint64_t v44 = v89(a2, a3);
LABEL_11:
  uint64_t v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    uint64_t v46 = v17;
    uint64_t v47 = v38;
    v36(v46, a2);
    uint64_t v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }

  uint64_t v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    uint64_t v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    unint64_t v59 = v48;
    goto LABEL_27;
  }

  uint64_t v47 = v38;
  char v58 = v37(a2, a3);
  uint64_t v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0) {
    goto LABEL_26;
  }
LABEL_13:
  int64_t v101 = 0x7FFFFFFFFFFFFFFFLL;
  char v49 = v37(a2, a3);
  uint64_t v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      BOOL v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v20,  v48,  a2);
      v36(v20, a2);
      uint64_t v56 = v48;
      goto LABEL_29;
    }

    goto LABEL_20;
  }

  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    unint64_t v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }

  uint64_t v100 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  unint64_t v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  int64_t v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v72,  v20,  a2);
  v36(v72, a2);
  uint64_t v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0) {
    goto LABEL_46;
  }
LABEL_30:
  uint64_t v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  uint64_t v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000000000LL) >> 64 != (1000000000000000LL * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }

  if (__OFADD__(1000000000000000LL * v74, ((unint64_t)v75 * (unsigned __int128)0x38D7EA4C68000uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }

  return 1000000000000000LL * v75;
}

uint64_t static Duration.milliseconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0x38D7EA4C68000uLL, a1);
}

uint64_t static Duration.microseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v92 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v92,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v90 = (char *)&v88 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v6);
  uint64_t v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v94 = (char *)&v88 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v96 = (char *)&v88 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v88 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  BOOL v20 = (char *)&v88 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v88 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v88 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  __int128 v29 = (char *)&v88 - v28;
  int64_t v101 = 64LL;
  uint64_t v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  uint64_t v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  Swift::String::Index v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v98 = v8;
  uint64_t v99 = v34;
  v34(v26, v29, a2);
  BOOL v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  uint64_t v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v43 = v99;
    goto LABEL_10;
  }

  int64_t v101 = 0x8000000000000000LL;
  if ((v97(a2, a3) & 1) != 0)
  {
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v39 = v38(a2, a3);
    if (v39 < 64)
    {
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      uint64_t v43 = v99;
      if (v42 < v101) {
        goto LABEL_46;
      }
      goto LABEL_10;
    }

    uint64_t v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    uint64_t v37 = v97;
    char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/Duration.swift",  20LL,  2,  0xBCuLL,  0);
    }

    goto LABEL_10;
  }

  char v60 = v37(a2, a3);
  int64_t v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      unint64_t v81 = AssociatedTypeWitness;
      unint64_t v82 = (void (**)(char *, uint64_t, const char *))v92;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v81,  AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
      v36(v20, a2);
      uint64_t v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      uint64_t v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }

      int64_t v85 = v101;
      uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      BOOL v87 = v86 < v85;
      uint64_t v43 = v99;
      uint64_t v37 = v97;
      if (!v87) {
        goto LABEL_10;
      }
      goto LABEL_46;
    }

    uint64_t v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    uint64_t v37 = v97;
    char v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if ((v66 & 1) != 0) {
      goto LABEL_46;
    }
LABEL_10:
    uint64_t v44 = v38(a2, a3);
    goto LABEL_11;
  }

  if (v61 < 64)
  {
    uint64_t v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if (v80 < v101) {
      goto LABEL_46;
    }
    goto LABEL_10;
  }

  v36(v23, a2);
  uint64_t v43 = v99;
  uint64_t v38 = v89;
  uint64_t v44 = v89(a2, a3);
LABEL_11:
  uint64_t v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    uint64_t v46 = v17;
    uint64_t v47 = v38;
    v36(v46, a2);
    uint64_t v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }

  uint64_t v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    uint64_t v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    unint64_t v59 = v48;
    goto LABEL_27;
  }

  uint64_t v47 = v38;
  char v58 = v37(a2, a3);
  uint64_t v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0) {
    goto LABEL_26;
  }
LABEL_13:
  int64_t v101 = 0x7FFFFFFFFFFFFFFFLL;
  char v49 = v37(a2, a3);
  uint64_t v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      BOOL v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v20,  v48,  a2);
      v36(v20, a2);
      uint64_t v56 = v48;
      goto LABEL_29;
    }

    goto LABEL_20;
  }

  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    unint64_t v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }

  uint64_t v100 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  unint64_t v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  int64_t v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v72,  v20,  a2);
  v36(v72, a2);
  uint64_t v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0) {
    goto LABEL_46;
  }
LABEL_30:
  uint64_t v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  uint64_t v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000000LL) >> 64 != (1000000000000LL * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }

  if (__OFADD__(1000000000000LL * v74, ((unint64_t)v75 * (unsigned __int128)0xE8D4A51000uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }

  return 1000000000000LL * v75;
}

uint64_t static Duration.microseconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0xE8D4A51000uLL, a1);
}

uint64_t static Duration.nanoseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v92 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v92,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v90 = (char *)&v88 - v7;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v6);
  uint64_t v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v94 = (char *)&v88 - v12;
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v96 = (char *)&v88 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v88 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  BOOL v20 = (char *)&v88 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v88 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v88 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  __int128 v29 = (char *)&v88 - v28;
  int64_t v101 = 64LL;
  uint64_t v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  uint64_t v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  Swift::String::Index v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  uint64_t v98 = v8;
  uint64_t v99 = v34;
  v34(v26, v29, a2);
  BOOL v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  uint64_t v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v43 = v99;
    goto LABEL_10;
  }

  int64_t v101 = 0x8000000000000000LL;
  if ((v97(a2, a3) & 1) != 0)
  {
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v39 = v38(a2, a3);
    if (v39 < 64)
    {
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      uint64_t v43 = v99;
      if (v42 < v101) {
        goto LABEL_46;
      }
      goto LABEL_10;
    }

    uint64_t v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    uint64_t v37 = v97;
    char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/Duration.swift",  20LL,  2,  0xD9uLL,  0);
    }

    goto LABEL_10;
  }

  char v60 = v37(a2, a3);
  int64_t v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      unint64_t v81 = AssociatedTypeWitness;
      unint64_t v82 = (void (**)(char *, uint64_t, const char *))v92;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v81,  AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
      v36(v20, a2);
      uint64_t v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      uint64_t v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }

      int64_t v85 = v101;
      uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      BOOL v87 = v86 < v85;
      uint64_t v43 = v99;
      uint64_t v37 = v97;
      if (!v87) {
        goto LABEL_10;
      }
      goto LABEL_46;
    }

    uint64_t v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    uint64_t v37 = v97;
    char v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v20,  a2);
    v36(v20, a2);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if ((v66 & 1) != 0) {
      goto LABEL_46;
    }
LABEL_10:
    uint64_t v44 = v38(a2, a3);
    goto LABEL_11;
  }

  if (v61 < 64)
  {
    uint64_t v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    uint64_t v43 = v99;
    uint64_t v38 = v89;
    if (v80 < v101) {
      goto LABEL_46;
    }
    goto LABEL_10;
  }

  v36(v23, a2);
  uint64_t v43 = v99;
  uint64_t v38 = v89;
  uint64_t v44 = v89(a2, a3);
LABEL_11:
  uint64_t v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    uint64_t v46 = v17;
    uint64_t v47 = v38;
    v36(v46, a2);
    uint64_t v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }

  uint64_t v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    uint64_t v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    unint64_t v59 = v48;
    goto LABEL_27;
  }

  uint64_t v47 = v38;
  char v58 = v37(a2, a3);
  uint64_t v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0) {
    goto LABEL_26;
  }
LABEL_13:
  int64_t v101 = 0x7FFFFFFFFFFFFFFFLL;
  char v49 = v37(a2, a3);
  uint64_t v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      BOOL v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v20,  v48,  a2);
      v36(v20, a2);
      uint64_t v56 = v48;
      goto LABEL_29;
    }

    goto LABEL_20;
  }

  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    unint64_t v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }

  uint64_t v100 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  unint64_t v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  int64_t v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v72,  v20,  a2);
  v36(v72, a2);
  uint64_t v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0) {
    goto LABEL_46;
  }
LABEL_30:
  uint64_t v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  uint64_t v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  uint64_t v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000LL) >> 64 != (1000000000 * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }

  if (__OFADD__(1000000000 * v74, ((unint64_t)v75 * (unsigned __int128)0x3B9ACA00uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }

  return 1000000000 * v75;
}

uint64_t Duration.init(from:)(uint64_t *a1)
{
  return specialized Duration.init(from:)(a1);
}

uint64_t Duration.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 32))(v13, v6, v7);
  uint64_t v8 = v14;
  uint64_t v9 = v15;
  __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 96))(a3, v8, v9);
  if (!v3)
  {
    uint64_t v10 = v14;
    uint64_t v11 = v15;
    __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 144))(a2, v10, v11);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v13);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Duration(void *a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  uint64_t v5 = a1[3];
  uint64_t v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 32))(v12, v5, v6);
  uint64_t v7 = v13;
  uint64_t v8 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 96))(v4, v7, v8);
  if (!v2)
  {
    uint64_t v9 = v13;
    uint64_t v10 = v14;
    __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 144))(v3, v9, v10);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Duration@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized Duration.init(from:)(a1);
  if (!v2)
  {
    *a2 = result;
    a2[1] = v5;
  }

  return result;
}

void Duration.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
}

Swift::Int Duration.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Duration()
{
  Swift::UInt64 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Duration()
{
  Swift::UInt64 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Duration()
{
  Swift::UInt64 v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL static Duration.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4 && a1 == a3;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  return a1[1] == a2[1] && *a1 == *a2;
}

BOOL static Duration.< infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2 == a4) {
    return a1 < a3;
  }
  else {
    return a2 < a4;
  }
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 < v3;
  if (v4) {
    return *a1 < *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 >= v2;
  if (v4) {
    return *a2 >= *a1;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 >= v3;
  if (v4) {
    return *a1 >= *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Duration(void *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 < v2;
  if (v4) {
    return *a2 < *a1;
  }
  else {
    return v5;
  }
}

uint64_t static Duration.zero.getter()
{
  return 0LL;
}

uint64_t protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration( a1,  a2,  specialized static Duration.+ infix(_:_:),  a3);
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Duration( void *a1, uint64_t *a2)
{
  return specialized static Duration.+= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Duration@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration( a1,  a2,  (uint64_t (*)(void, void, void, void))specialized static Duration.- infix(_:_:),  a3);
}

uint64_t protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t (*a3)(void, void, void, void)@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result = a3(*a1, a1[1], *a2, a2[1]);
  *a4 = result;
  a4[1] = v6;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Duration( unint64_t *a1, uint64_t a2)
{
  return specialized static Duration.-= infix(_:_:)(a1, *(void *)a2, *(void *)(a2 + 8));
}

uint64_t static Duration./= infix(_:_:)(uint64_t a1, double a2)
{
  uint64_t result = specialized static Duration./ infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), a2);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v4;
  return result;
}

unint64_t specialized static Duration./ infix<A>(_:_:)( uint64_t a1, uint64_t a2, Swift::_Int128 dividingBy)
{
  if ((dividingBy.low & 0x8000000000000000LL) != 0)
  {
    if (dividingBy.low == -1LL && a2 == 0x8000000000000000LL && !a1) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in /=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x3CEuLL,  0);
  }

  else if (!dividingBy.low)
  {
    goto LABEL_8;
  }

  v3.high = (uint64_t)dividingBy.low >> 63;
  v3.low = dividingBy.low;
  return (unint64_t)_Int128.quotientAndRemainder(dividingBy:)(v3);
}

unint64_t static Duration./ infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a4 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v12 = (void (*)(char *, char *, uint64_t))((char *)&v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v28 - v13;
  uint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15((char *)&v28 - v13, v16, v17);
  v15((char *)v12, (uint64_t)v14, a4);
  uint64_t v18 = _Int128.init<A>(exactly:)(v12, a4, a5);
  if ((v20 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000028LL,  0x80000001818B7CB0LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x27CuLL,  0);
  }
  Swift::UInt64 v21 = v18;
  Swift::Int64 v22 = v19;
  (*(void (**)(char *, uint64_t))(v9 + 8))(v14, a4);
  if (v22 != -1)
  {
    if (v22) {
      BOOL v23 = 0;
    }
    else {
      BOOL v23 = v21 == 0;
    }
    if (!v23) {
      goto LABEL_7;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in /=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x3CEuLL,  0);
  }

  if (v21 == -1LL && a2 == 0x8000000000000000LL && a1 == 0) {
    goto LABEL_16;
  }
LABEL_7:
  v24.low = v21;
  v24.high = v22;
  return (unint64_t)_Int128.quotientAndRemainder(dividingBy:)(v24);
}

unint64_t static Duration./= infix<A>(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t result = static Duration./ infix<A>(_:_:)(*a1, a1[1], a2, a3, a4);
  *a1 = result;
  a1[1] = v6;
  return result;
}

double static Duration./ infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  double v6 = v8;
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v8, a3, a4);
  return v6 / v8;
}

uint64_t static Duration.* infix(_:_:)(unint64_t a1, uint64_t a2, double a3)
{
  if ((v61 & 1) != 0)
  {
    *(double *)&unint64_t v5 = COERCE_DOUBLE(specialized static String._createEmpty(withInitialCapacity:)(80LL));
    unint64_t v7 = v6;
    double v59 = *(double *)&v5;
    unint64_t v60 = v6;
    TypeName = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Double, 0);
    if (v9 < 0) {
      goto LABEL_66;
    }
    uint64_t v10 = (uint8x16_t *)TypeName;
    int64_t v11 = v9;
    int64_t v12 = validateUTF8(_:)(TypeName, v9);
    if ((v14 & 1) != 0) {
      unint64_t v15 = repairUTF8(_:firstKnownBrokenRange:)(v10->i8, v11, v12, v13);
    }
    else {
      unint64_t v15 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v10, v11, v12 & 1);
    }
    unint64_t v17 = v15;
    unint64_t v18 = v16;
    uint64_t v19 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000LL) == 0) {
      uint64_t v19 = v5 & 0xFFFFFFFFFFFFLL;
    }
    if (!v19 && (v5 & ~v7 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v7);
      double v59 = *(double *)&v17;
      unint64_t v60 = v18;
      goto LABEL_21;
    }

    if ((v7 & 0x2000000000000000LL) != 0)
    {
      if ((v16 & 0x2000000000000000LL) != 0)
      {
        unint64_t v21 = specialized _SmallString.init(_:appending:)(v5, v7, v15, v16);
        if ((v23 & 1) == 0)
        {
          double v24 = *(double *)&v21;
          unint64_t v25 = v22;
          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v18);
          double v59 = v24;
          unint64_t v60 = v25;
          unint64_t v18 = v25;
          *(double *)&unint64_t v17 = v24;
          goto LABEL_21;
        }

        goto LABEL_19;
      }
    }

    else if ((v16 & 0x2000000000000000LL) != 0)
    {
LABEL_19:
      uint64_t v20 = HIBYTE(v18) & 0xF;
      goto LABEL_20;
    }

    uint64_t v20 = v15 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v17, v18, 0LL, v20);
    swift_bridgeObjectRelease(v18);
    *(double *)&unint64_t v17 = v59;
    unint64_t v18 = v60;
LABEL_21:
    uint64_t v26 = HIBYTE(v18) & 0xF;
    if ((v18 & 0x2000000000000000LL) == 0) {
      uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
    }
    if (v26 || (v17 & ~v18 & 0x2000000000000000LL) != 0)
    {
      if ((v18 & 0x2000000000000000LL) != 0
        && (0x80000001818B69D0LL & 0x2000000000000000LL) != 0
        && (unint64_t v27 = specialized _SmallString.init(_:appending:)( v17,  v18,  0xD00000000000001ELL,  0x80000001818B69D0LL | 0x8000000000000000LL),  (v29 & 1) == 0))
      {
        double v30 = *(double *)&v27;
        unint64_t v31 = v28;
        swift_bridgeObjectRelease(v18);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
        double v59 = v30;
        unint64_t v60 = v31;
      }

      else
      {
        if ((0x80000001818B69D0LL & 0x2000000000000000LL) != 0) {
          unint64_t v32 = (0x80000001818B69D0LL >> 56) & 0xF;
        }
        else {
          unint64_t v32 = 30LL;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001818B69D0LL | 0x8000000000000000LL, 0LL, v32);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v18);
      double v59 = -2.31584178e77;
      unint64_t v60 = 0x80000001818B69D0LL | 0x8000000000000000LL;
    }

    unint64_t v33 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for _Int128, 0);
    if ((v34 & 0x8000000000000000LL) == 0)
    {
      BOOL v35 = (uint8x16_t *)v33;
      int64_t v36 = v34;
      int64_t v37 = validateUTF8(_:)(v33, v34);
      if ((v39 & 1) != 0) {
        unint64_t v40 = repairUTF8(_:firstKnownBrokenRange:)(v35->i8, v36, v37, v38);
      }
      else {
        unint64_t v40 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v35, v36, v37 & 1);
      }
      unint64_t v42 = v40;
      unint64_t v43 = v41;
      uint64_t v44 = v60;
      unint64_t v45 = HIBYTE(v60) & 0xF;
      if ((v60 & 0x2000000000000000LL) == 0) {
        unint64_t v45 = *(void *)&v59 & 0xFFFFFFFFFFFFLL;
      }
      if (!v45 && (*(void *)&v59 & ~v60 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v60);
        double v59 = *(double *)&v42;
        unint64_t v60 = v43;
        goto LABEL_52;
      }

      if ((v60 & 0x2000000000000000LL) != 0)
      {
        if ((v41 & 0x2000000000000000LL) != 0)
        {
          unint64_t v47 = specialized _SmallString.init(_:appending:)(*(unint64_t *)&v59, v60, v40, v41);
          if ((v49 & 1) == 0)
          {
            double v50 = *(double *)&v47;
            unint64_t v51 = v48;
            swift_bridgeObjectRelease(v44);
            swift_bridgeObjectRelease(v43);
            double v59 = v50;
            unint64_t v60 = v51;
            unint64_t v43 = v51;
            *(double *)&unint64_t v42 = v50;
            goto LABEL_52;
          }

          goto LABEL_50;
        }
      }

      else if ((v41 & 0x2000000000000000LL) != 0)
      {
LABEL_50:
        uint64_t v46 = HIBYTE(v43) & 0xF;
        goto LABEL_51;
      }

      uint64_t v46 = v40 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v42, v43, 0LL, v46);
      swift_bridgeObjectRelease(v43);
      *(double *)&unint64_t v42 = v59;
      unint64_t v43 = v60;
LABEL_52:
      uint64_t v52 = HIBYTE(v43) & 0xF;
      if ((v43 & 0x2000000000000000LL) == 0) {
        uint64_t v52 = v42 & 0xFFFFFFFFFFFFLL;
      }
      if (v52 || (v42 & ~v43 & 0x2000000000000000LL) != 0)
      {
        if ((v43 & 0x2000000000000000LL) != 0
          && (0x80000001818B69F0LL & 0x2000000000000000LL) != 0
          && (unint64_t v55 = specialized _SmallString.init(_:appending:)( v42,  v43,  0xD00000000000002ELL,  0x80000001818B69F0LL | 0x8000000000000000LL),  (v57 & 1) == 0))
        {
          unint64_t v54 = (char *)v55;
          unint64_t v53 = v56;
          swift_bridgeObjectRelease(v43);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
        }

        else
        {
          if ((0x80000001818B69F0LL & 0x2000000000000000LL) != 0) {
            unint64_t v58 = (0x80000001818B69F0LL >> 56) & 0xF;
          }
          else {
            unint64_t v58 = 46LL;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001818B69F0LL | 0x8000000000000000LL, 0LL, v58);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
          unint64_t v54 = *(char **)&v59;
          unint64_t v53 = v60;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v43);
        unint64_t v53 = 0x80000001818B69F0LL | 0x8000000000000000LL;
        unint64_t v54 = (char *)0xD00000000000002ELL;
      }

      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v54,  v53,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
    }

unint64_t static Duration.* infix<A>(_:_:)( unint64_t a1, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a4 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  int64_t v12 = (void (*)(char *, char *, uint64_t))((char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v10);
  char v14 = (char *)&v24 - v13;
  unint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15((char *)&v24 - v13, v16, v17);
  v15((char *)v12, (uint64_t)v14, a4);
  uint64_t v18 = _Int128.init<A>(exactly:)(v12, a4, a5);
  if ((v20 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000028LL,  0x80000001818B7CB0LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x27CuLL,  0);
  }
  unint64_t v21 = v18;
  unint64_t v22 = v19;
  (*(void (**)(char *, uint64_t))(v9 + 8))(v14, a4);
  return specialized static _Int128.* infix(_:_:)(a1, a2, v21, v22);
}

unint64_t static Duration.*= infix<A>(_:_:)(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (void (*)(char *, char *, uint64_t))((char *)&v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v11 = (unint64_t *)MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v24 - v12;
  unint64_t v14 = *v11;
  int64_t v15 = v11[1];
  uint64_t v16 = *(void (**)(char *))(v7 + 16);
  v16((char *)&v24 - v12);
  ((void (*)(void, char *, uint64_t))v16)(v10, v13, a3);
  uint64_t v17 = _Int128.init<A>(exactly:)(v10, a3, a4);
  if ((v19 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000028LL,  0x80000001818B7CB0LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x27CuLL,  0);
  }
  unint64_t v20 = v17;
  unint64_t v21 = v18;
  (*(void (**)(char *, uint64_t))(v7 + 8))(v13, a3);
  unint64_t result = specialized static _Int128.* infix(_:_:)(v14, v15, v20, v21);
  *a1 = result;
  a1[1] = v23;
  return result;
}

unint64_t Duration.description.getter(unint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)__src, a1, a2);
  if ((~COERCE__INT64(*(double *)__src / 1.0e18) & 0x7FF0000000000000LL) != 0
    || (COERCE_UNSIGNED_INT64(*(double *)__src / 1.0e18) & 0xFFFFFFFFFFFFFLL) == 0)
  {
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    int64_t v3 = swift_float64ToString(&v19, 32LL, 0LL);
    __src[0] = v19;
    __src[1] = v20;
    if (v3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    size_t v4 = v3;
    if (v3)
    {
      if ((unint64_t)v3 <= 0xF)
      {
        uint64_t v9 = v3 - 8;
        uint64_t v10 = 8LL;
        if (v3 < 8) {
          uint64_t v10 = v3;
        }
        unint64_t v8 = LOBYTE(__src[0]);
        if (v10 != 1)
        {
          unint64_t v8 = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
          if (v10 != 2)
          {
            v8 |= (unint64_t)BYTE2(__src[0]) << 16;
            if (v10 != 3)
            {
              v8 |= (unint64_t)BYTE3(__src[0]) << 24;
              if (v10 != 4)
              {
                v8 |= (unint64_t)BYTE4(__src[0]) << 32;
                if (v10 != 5)
                {
                  v8 |= (unint64_t)BYTE5(__src[0]) << 40;
                  if (v10 != 6)
                  {
                    v8 |= (unint64_t)BYTE6(__src[0]) << 48;
                    if (v10 != 7) {
                      v8 |= (unint64_t)BYTE7(__src[0]) << 56;
                    }
                  }
                }
              }
            }
          }
        }

        uint64_t v11 = 0LL;
        if (v4 >= 9)
        {
          uint64_t v12 = 0LL;
          uint64_t v13 = (unsigned __int8 *)__src + 8;
          unint64_t v14 = v9 & ~(v9 >> 63);
          do
          {
            if (v14 <= v4 - 9) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
            }
            unsigned int v15 = *v13++;
            v11 |= (unint64_t)v15 << v12;
            v12 += 8LL;
            --v9;
          }

          while (v9);
        }

        unint64_t v16 = 0xA000000000000000LL;
        if (((v11 | v8) & 0x8080808080808080LL) == 0) {
          unint64_t v16 = 0xE000000000000000LL;
        }
        int64_t v7 = v16 | (v4 << 56) | v11;
      }

      else
      {
        unint64_t v5 = v3 | 0xF000000000000000LL;
        int64_t v7 = _allocateStringStorage(codeUnitCapacity:)(v3);
        *(void *)(v7 + 16) = v6;
        *(void *)(v7 + 24) = v5;
        if (v6 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
          unint64_t v5 = *(void *)(v7 + 24);
        }

        *(_BYTE *)(v7 + 32 + (v5 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v4, (char *)(v7 + 32));
        unint64_t v8 = *(void *)(v7 + 24);
      }
    }

    else
    {
      unint64_t v8 = 0LL;
      int64_t v7 = 0xE000000000000000LL;
    }
  }

  else
  {
    int64_t v7 = 0xE300000000000000LL;
    unint64_t v8 = 7233902LL;
  }

  unint64_t v17 = specialized static String.+ infix(_:_:)(v8, v7, 0x73646E6F63657320LL, 0xE800000000000000LL);
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  return v17;
}

unint64_t Double.description.getter(double a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0 && (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0) {
    return 7233902LL;
  }
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  int64_t v2 = swift_float64ToString(&v14, 32LL, 0LL);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  size_t v3 = v2;
  if (!v2) {
    return 0LL;
  }
  if ((unint64_t)v2 <= 0xF)
  {
    uint64_t v7 = v2 - 8;
    uint64_t v8 = 8LL;
    if (v2 < 8) {
      uint64_t v8 = v2;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v9 = 0LL;
    if (v3 >= 9)
    {
      uint64_t v10 = 0LL;
      uint64_t v11 = (unsigned __int8 *)__src + 8;
      unint64_t v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        unsigned int v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8LL;
        --v7;
      }

      while (v7);
    }
  }

  else
  {
    unint64_t v4 = v2 | 0xF000000000000000LL;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      unint64_t v4 = *(void *)(v5 + 24);
    }

    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }

  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Duration()
{
  return Duration.description.getter(*(void *)v0, *(void *)(v0 + 8));
}

unint64_t protocol witness for static DurationProtocol./ infix(_:_:) in conformance Duration@<X0>( Swift::_Int128 dividingBy@<0:X1, 8:X2>, uint64_t *a2@<X0>, uint64_t a3@<X3>, unint64_t *a4@<X8>)
{
  Swift::UInt64 low = dividingBy.low;
  unint64_t result = specialized static Duration./ infix<A>(_:_:)(*a2, a2[1], *(Swift::_Int128 *)(&a3 - 1));
  *a4 = result;
  a4[1] = v7;
  return result;
}

uint64_t specialized static DurationProtocol./= infix(_:_:)(void *a1, Swift::_Int128 dividingBy)
{
  if ((dividingBy.low & 0x8000000000000000LL) != 0)
  {
    if (dividingBy.low == -1LL && a1[1] == 0x8000000000000000LL && *a1 == 0LL) {
LABEL_10:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in /=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x3CEuLL,  0);
  }

  else if (!dividingBy.low)
  {
    goto LABEL_10;
  }

  v4.Swift::UInt64 low = dividingBy.low;
  v4.high = (uint64_t)dividingBy.low >> 63;
  *(_OWORD *)&uint64_t result = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(v4);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t static DurationProtocol./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(v9 + 24))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

{
  return static DurationProtocol./= infix(_:_:)(a1, a2, a3);
}

unint64_t protocol witness for static DurationProtocol.* infix(_:_:) in conformance Duration@<X0>( uint64_t a1@<X0>, int64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized static _Int128.* infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), a2, a2 >> 63);
  *a3 = result;
  a3[1] = v5;
  return result;
}

unint64_t protocol witness for static DurationProtocol.*= infix(_:_:) in conformance Duration( uint64_t a1, int64_t a2)
{
  unint64_t result = specialized static _Int128.* infix(_:_:)(*(void *)a1, *(void *)(a1 + 8), a2, a2 >> 63);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v4;
  return result;
}

uint64_t static DurationProtocol.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(v9 + 40))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

{
  return static DurationProtocol.*= infix(_:_:)(a1, a2, a3);
}

double protocol witness for static DurationProtocol./ infix(_:_:) in conformance Duration( uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  specialized static BinaryFloatingPoint<>._convert<A>(from:)( (unint64_t *)&v6,  *(void *)a1,  *(void *)(a1 + 8));
  double v4 = v6;
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v6, v2, v3);
  return v4 / v6;
}

uint64_t specialized static BinaryFloatingPoint<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v126 = a2;
  uint64_t v110 = a6;
  uint64_t v10 = *(void **)(a4 + 16);
  uint64_t v11 = *(void *)(v10[2] + 8LL);
  uint64_t v123 = *(const char **)(v11 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v123,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v120 = (char *)&v94 - v12;
  uint64_t v131 = a5;
  uint64_t v128 = *(void *)(a5 + 8);
  uint64_t v104 = *(void *)(v128 + 24);
  unsigned int v13 = *(const char **)(v104 + 16);
  uint64_t v129 = a4;
  unint64_t v14 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v103 = v13;
  unint64_t v100 = swift_getAssociatedTypeWitness( 0LL,  v13,  v14,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v100);
  uint64_t v98 = (char *)&v94 - v15;
  unint64_t v16 = swift_checkMetadataState(0LL, v14);
  uint64_t v17 = *(v16 - 1);
  __int128 v124 = v16;
  uint64_t v125 = v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v99 = (char *)&v94 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v102 = (char *)&v94 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int64_t v101 = (char *)&v94 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v112 = (char *)&v94 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v111 = (uint64_t)&v94 - v27;
  uint64_t v127 = *(void *)(a3 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v122 = (char *)&v94 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v116 = (char *)&v94 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  unint64_t v115 = (char *)&v94 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v117 = (char *)&v94 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v119 = (char *)&v94 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  unint64_t v118 = (char *)&v94 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  unint64_t v42 = (char *)&v94 - v41;
  MEMORY[0x1895F8858](v40);
  uint64_t v44 = (char *)&v94 - v43;
  uint64_t v46 = type metadata accessor for Range(0LL, a3, *(void *)(v10[3] + 8LL), v45);
  uint64_t v47 = *(void *)(v46 - 8);
  MEMORY[0x1895F8858](v46);
  char v49 = (char *)&v94 - v48;
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))((char *)&v94 - v48, a1, v46);
  double v50 = &v49[*(int *)(v46 + 36)];
  unint64_t v130 = v10;
  uint64_t v51 = *(void *)(v10[1] + 8LL);
  unint64_t v113 = *(uint64_t (**)(char *, char *, uint64_t))(v51 + 8);
  uint64_t v114 = v51;
  if ((v113(v49, v50, a3) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't get random value with an empty range",  42LL,  2,  "Swift/FloatingPointRandom.swift",  31LL,  2,  0x34uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v47 + 8))(v49, v46);
  uint64_t v52 = a1 + *(int *)(v46 + 36);
  uint64_t v53 = *(void *)(v11 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v53 + 40))(v52, a1, a3, v53);
  uint64_t v54 = v127;
  (*(void (**)(char *, char *, uint64_t))(v127 + 16))(v42, v44, a3);
  if ((((uint64_t (*)(uint64_t))v130[47])(a3) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "There is no uniform distribution on an infinite range",  53LL,  2,  "Swift/FloatingPointRandom.swift",  31LL,  2,  0x3EuLL,  0);
  }
  uint64_t v105 = v53;
  uint64_t v106 = v52;
  uint64_t v107 = v44;
  uint64_t v108 = v11;
  uint64_t v109 = a1;
  unint64_t v55 = *(void (**)(char *, uint64_t))(v54 + 8);
  v55(v42, a3);
  uint64_t v56 = (uint64_t)v124;
  uint64_t v57 = (*(uint64_t (**)(unint64_t *))(v131 + 56))(v124);
  unint64_t v58 = *(uint64_t (**)(uint64_t))(v129 + 104);
  uint64_t result = v58(a3);
  if (__OFADD__(result, 1LL))
  {
    __break(1u);
    goto LABEL_15;
  }

  if (v57 == result + 1)
  {
    uint64_t v60 = v111;
    specialized static FixedWidthInteger._random<A>(using:)(v56, v131, v111);
    uint64_t v61 = v128;
    uint64_t v62 = v125;
    uint64_t v63 = v112;
    goto LABEL_8;
  }

  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v58)(a3, v129);
  uint64_t v64 = result + 1;
  if (__OFADD__(result, 1LL))
  {
LABEL_15:
    __break(1u);
    return result;
  }

  uint64_t v65 = (uint64_t)v103;
  unint64_t v66 = v100;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v103,  v56,  v100,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  Swift::String::Index v97 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  unint64_t v96 = AssociatedConformanceWitness;
  unint64_t v68 = v98;
  v97(&qword_18180BE70, 512LL, v66, AssociatedConformanceWitness);
  uint64_t v95 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v65 + 24);
  uint64_t v69 = (uint64_t)v101;
  uint64_t v70 = v95(v68, v56, v65);
  uint64_t v132 = v64;
  unint64_t v71 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v128 + 256);
  unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v72, v73);
  uint64_t v63 = v112;
  v71(v69, &v132, &type metadata for Int, v74, v56, v128);
  uint64_t v75 = *(void (**)(uint64_t, uint64_t))(v125 + 8);
  v75(v69, v56);
  specialized static FixedWidthInteger._random<A>(using:)(v56, v131, v69);
  v97(&qword_18180BE70, 512LL, v66, v96);
  uint64_t v76 = v99;
  v95(v68, v56, v65);
  uint64_t v77 = v102;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v104 + 8) + 40LL))(v63, v76, v56);
  unint64_t v78 = v76;
  uint64_t v61 = v128;
  v75((uint64_t)v78, v56);
  v75((uint64_t)v63, v56);
  uint64_t v60 = v111;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v61 + 192))(v69, v77, v56, v61);
  v75((uint64_t)v77, v56);
  v75(v69, v56);
  uint64_t v62 = v125;
LABEL_8:
  (*(void (**)(char *, uint64_t, uint64_t))(v62 + 32))(v63, v60, v56);
  char v79 = v130;
  uint64_t v80 = v119;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v130[9])(v63, v56, v61, a3, v130);
  unint64_t v81 = v115;
  ((void (*)(uint64_t, void *))v79[18])(a3, v79);
  unint64_t v82 = v123;
  unint64_t v83 = AssociatedTypeWitness;
  unint64_t v84 = swift_getAssociatedConformanceWitness( (uint64_t)v123,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v85 = v120;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v84 + 8))( &unk_18180BE80,  768LL,  v83,  v84);
  uint64_t v86 = v116;
  (*((void (**)(char *, uint64_t, const char *))v82 + 3))(v85, a3, v82);
  BOOL v87 = v117;
  ((void (*)(char *, char *, uint64_t, void *))v79[24])(v81, v86, a3, v79);
  v55(v86, a3);
  v55(v81, a3);
  uint64_t v88 = v108;
  int64_t v89 = *(void (**)(char *, char *, uint64_t, uint64_t))(v108 + 64);
  char v90 = v118;
  v89(v80, v87, a3, v108);
  v55(v87, a3);
  v55(v80, a3);
  uint64_t v91 = v107;
  v89(v107, v90, a3, v88);
  v55(v90, a3);
  v55(v91, a3);
  BOOL v92 = v122;
  uint64_t v93 = v109;
  (*(void (**)(char *, uint64_t, uint64_t))(v105 + 24))(v80, v109, a3);
  v55(v80, a3);
  v55(v92, a3);
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(v93, v126, a3, v129, v131);
}

{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(void);
  uint64_t (*v46)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v47)(uint64_t, void *);
  void (*v48)(char *, uint64_t);
  uint64_t v49;
  uint64_t v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t result;
  char *v53;
  char v54;
  char *v55;
  void *v56;
  char v57;
  void (*v58)(char *, unint64_t *);
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t AssociatedConformanceWitness;
  unint64_t v63;
  char *v64;
  uint64_t v65;
  void (*v66)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, void *);
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  char v72;
  void *v73;
  char *v74;
  char *v75;
  unint64_t v76;
  const char *v77;
  unint64_t v78;
  char *v79;
  void (*v80)(char *, uint64_t);
  char *v81;
  char *v82;
  uint64_t v83;
  void (*v84)(char *, char *, uint64_t, uint64_t);
  char *v85;
  char *v86;
  uint64_t (*v87)(char *, unint64_t *, uint64_t);
  void (*v88)(uint64_t *, uint64_t, unint64_t, unint64_t);
  uint64_t v89;
  uint64_t v90;
  char *v91;
  char *v92;
  unint64_t v93;
  const char *v94;
  uint64_t v95;
  uint64_t (*v96)(uint64_t, uint64_t, uint64_t);
  uint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  char *v101;
  void *v102;
  char *v103;
  char *v104;
  unint64_t AssociatedTypeWitness;
  const char *v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  void (*v110)(char *, uint64_t);
  char *v111;
  char *v112;
  uint64_t v113;
  char *v114;
  void *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t __buf;
  unint64_t v113 = a2;
  uint64_t v116 = a6;
  uint64_t v10 = *(void **)(a4 + 16);
  uint64_t v11 = *(void *)(v10[2] + 8LL);
  uint64_t v106 = *(const char **)(v11 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v106,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v104 = (char *)&v87 - v12;
  unint64_t v118 = a5;
  unint64_t v115 = *(void **)(a5 + 8);
  uint64_t v95 = v115[3];
  unsigned int v13 = *(const char **)(v95 + 16);
  unint64_t v14 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v94 = v13;
  uint64_t v93 = swift_getAssociatedTypeWitness( 0LL,  v13,  v14,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v93);
  uint64_t v91 = (char *)&v87 - v15;
  unint64_t v16 = swift_checkMetadataState(0LL, v14);
  uint64_t v117 = *(v16 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  BOOL v92 = (char *)&v87 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v111 = (char *)&v87 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v87 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v112 = (char *)&v87 - v25;
  uint64_t v26 = *(void *)(a3 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v99 = (char *)&v87 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v98 = (char *)&v87 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  unint64_t v100 = (char *)&v87 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v103 = (char *)&v87 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  int64_t v101 = (char *)&v87 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v39 = (char *)&v87 - v38;
  MEMORY[0x1895F8858](v37);
  uint64_t v41 = (char *)&v87 - v40;
  uint64_t v43 = a1 + *(int *)(type metadata accessor for ClosedRange(0LL, a3, *(void *)(v10[3] + 8LL), v42) + 36);
  uint64_t v107 = v11;
  uint64_t v44 = *(void *)(v11 + 8);
  uint64_t v45 = *(void (**)(void))(v44 + 40);
  Swift::String::Index v97 = v43;
  uint64_t v108 = a1;
  v45();
  uint64_t v46 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v26 + 16);
  uint64_t v114 = v41;
  unint64_t v96 = v46;
  v46((uint64_t)v39, (uint64_t)v41, a3);
  uint64_t v47 = (uint64_t (*)(uint64_t, void *))v10[47];
  uint64_t v102 = v10;
  if ((v47(a3, v10) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "There is no uniform distribution on an infinite range",  53LL,  2,  "Swift/FloatingPointRandom.swift",  31LL,  2,  0xA2uLL,  0);
  }
  uint64_t v48 = *(void (**)(char *, uint64_t))(v26 + 8);
  uint64_t v109 = v23;
  uint64_t v110 = v48;
  v48(v39, a3);
  char v49 = v118;
  double v50 = (*(uint64_t (**)(unint64_t *, uint64_t))(v118 + 56))(v16, v118);
  uint64_t v51 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 104);
  uint64_t result = v51(a3, a4);
  if (__OFADD__(result, 1LL))
  {
    __break(1u);
    goto LABEL_14;
  }

  char v90 = v44;
  if (v50 == result + 1)
  {
    uint64_t v53 = v112;
    specialized static FixedWidthInteger._random<A>(using:)((uint64_t)v16, v49, (uint64_t)v112);
    __buf = 0LL;
    swift_stdlib_random(&__buf, 8uLL);
    uint64_t v54 = __buf;
    unint64_t v55 = v109;
    (*(void (**)(unint64_t *, uint64_t))(v49 + 64))(v16, v49);
    uint64_t v56 = v115;
    uint64_t v57 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v115[2] + 8LL) + 8LL))( v53,  v55,  v16);
    unint64_t v58 = *(void (**)(char *, unint64_t *))(v117 + 8);
    v58(v55, v16);
    if ((v57 & 1) == 0 || (v54 & 1) == 0) {
      goto LABEL_10;
    }
LABEL_7:
    v58(v53, v16);
    v110(v114, a3);
    return v96(v116, v97, a3);
  }

  uint64_t result = v51(a3, a4);
  double v59 = result + 1;
  if (__OFADD__(result, 1LL))
  {
LABEL_14:
    __break(1u);
    return result;
  }

  uint64_t v60 = (uint64_t)v94;
  uint64_t v61 = v93;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v94,  (uint64_t)v16,  v93,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v89 = a4;
  uint64_t v63 = AssociatedConformanceWitness;
  uint64_t v88 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  uint64_t v64 = v91;
  v88(&qword_18180BE70, 512LL, v61, AssociatedConformanceWitness);
  BOOL v87 = *(uint64_t (**)(char *, unint64_t *, uint64_t))(v60 + 24);
  unint64_t v55 = v109;
  uint64_t v65 = v87(v64, v16, v60);
  __buf = v59;
  uint64_t v56 = v115;
  unint64_t v66 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, void *))v115[32];
  uint64_t v69 = lazy protocol witness table accessor for type Int and conformance Int(v65, v67, v68);
  v66(v55, &__buf, &type metadata for Int, v69, v16, v56);
  unint64_t v58 = *(void (**)(char *, unint64_t *))(v117 + 8);
  v58(v55, v16);
  v88(&qword_18180BE70, 512LL, v61, v63);
  uint64_t v70 = v92;
  v87(v64, v16, v60);
  unint64_t v71 = v111;
  (*(void (**)(char *, char *, unint64_t *))(*(void *)(v95 + 8) + 24LL))(v111, v70, v16);
  v58(v70, v16);
  swift_getAssociatedConformanceWitness( v89,  a3,  (uint64_t)v16,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
  uint64_t v53 = v112;
  specialized RandomNumberGenerator.next<A>(upperBound:)(v55, (uint64_t)v16, v118, v112);
  v58(v55, v16);
  uint64_t v72 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v56[2] + 8LL) + 8LL))(v53, v71, v16);
  v58(v71, v16);
  if ((v72 & 1) != 0) {
    goto LABEL_7;
  }
LABEL_10:
  (*(void (**)(char *, char *, unint64_t *))(v117 + 32))(v55, v53, v16);
  uint64_t v73 = v102;
  unint64_t v74 = v103;
  ((void (*)(char *, unint64_t *, void *, uint64_t, void *))v102[9])(v55, v16, v56, a3, v102);
  uint64_t v75 = v98;
  ((void (*)(uint64_t, void *))v73[18])(a3, v73);
  uint64_t v76 = AssociatedTypeWitness;
  uint64_t v77 = v106;
  unint64_t v78 = swift_getAssociatedConformanceWitness( (uint64_t)v106,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v79 = v104;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v78 + 8))( &unk_18180BE80,  768LL,  v76,  v78);
  uint64_t v80 = v110;
  unint64_t v81 = v99;
  (*((void (**)(char *, uint64_t, const char *))v77 + 3))(v79, a3, v77);
  unint64_t v82 = v100;
  ((void (*)(char *, char *, uint64_t, void *))v73[24])(v75, v81, a3, v73);
  v80(v81, a3);
  v80(v75, a3);
  unint64_t v83 = v107;
  unint64_t v84 = *(void (**)(char *, char *, uint64_t, uint64_t))(v107 + 64);
  int64_t v85 = v101;
  v84(v74, v82, a3, v107);
  v80(v82, a3);
  v80(v74, a3);
  uint64_t v86 = v114;
  v84(v114, v85, a3, v83);
  v80(v85, a3);
  v80(v86, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v90 + 24))(v74, v108, a3);
  return ((uint64_t (*)(char *, uint64_t))v80)(v74, a3);
}

uint64_t static BinaryFloatingPoint<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v126 = a4;
  uint64_t v127 = a6;
  uint64_t v125 = a2;
  uint64_t v110 = a8;
  uint64_t v12 = *(void **)(a5 + 16);
  uint64_t v132 = *(void **)(v12[2] + 8LL);
  uint64_t v123 = (const char *)v132[2];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v123,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v120 = (char *)&v96 - v13;
  uint64_t v133 = a7;
  uint64_t v130 = *(void *)(a7 + 8);
  uint64_t v105 = *(void *)(v130 + 24);
  unint64_t v14 = *(const char **)(v105 + 16);
  uint64_t v128 = a5;
  unint64_t v15 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v104 = v14;
  unint64_t v101 = swift_getAssociatedTypeWitness( 0LL,  v14,  v15,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v101);
  uint64_t v99 = (char *)&v96 - v16;
  uint64_t v17 = swift_checkMetadataState(0LL, v15);
  uint64_t v124 = *(v17 - 1);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  unint64_t v100 = (char *)&v96 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v103 = (char *)&v96 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v102 = (char *)&v96 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v112 = (char *)&v96 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v111 = (uint64_t)&v96 - v27;
  uint64_t v129 = *(void *)(a3 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v122 = (char *)&v96 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v116 = (char *)&v96 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  unint64_t v115 = (char *)&v96 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v117 = (char *)&v96 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v119 = (char *)&v96 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  unint64_t v118 = (char *)&v96 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  unint64_t v42 = (char *)&v96 - v41;
  MEMORY[0x1895F8858](v40);
  uint64_t v44 = (char *)&v96 - v43;
  uint64_t v46 = type metadata accessor for Range(0LL, a3, *(void *)(v12[3] + 8LL), v45);
  uint64_t v47 = *(void *)(v46 - 8);
  MEMORY[0x1895F8858](v46);
  char v49 = (char *)&v96 - v48;
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))((char *)&v96 - v48, a1, v46);
  double v50 = &v49[*(int *)(v46 + 36)];
  uint64_t v131 = v12;
  uint64_t v51 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v12[1] + 8LL) + 8LL);
  uint64_t v114 = *(void *)(v12[1] + 8LL);
  unint64_t v113 = v51;
  if ((((uint64_t (*)(char *, char *, uint64_t))v51)(v49, v50, a3) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't get random value with an empty range",  42LL,  2,  "Swift/FloatingPointRandom.swift",  31LL,  2,  0x34uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v47 + 8))(v49, v46);
  uint64_t v52 = a1 + *(int *)(v46 + 36);
  uint64_t v53 = v132[1];
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v53 + 40))(v52, a1, a3, v53);
  uint64_t v54 = v129;
  (*(void (**)(char *, char *, uint64_t))(v129 + 16))(v42, v44, a3);
  if ((((uint64_t (*)(uint64_t))v131[47])(a3) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "There is no uniform distribution on an infinite range",  53LL,  2,  "Swift/FloatingPointRandom.swift",  31LL,  2,  0x3EuLL,  0);
  }
  uint64_t v107 = v53;
  uint64_t v108 = v44;
  uint64_t v109 = a1;
  unint64_t v55 = *(void (**)(char *, uint64_t))(v54 + 8);
  v55(v42, a3);
  uint64_t v56 = (*(uint64_t (**)(unint64_t *))(v133 + 56))(v17);
  uint64_t v57 = v128;
  unint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t))(v128 + 104);
  uint64_t result = v58(a3, v128);
  if (__OFADD__(result, 1LL))
  {
    __break(1u);
    goto LABEL_16;
  }

  uint64_t v106 = v52;
  if (v56 == result + 1)
  {
    uint64_t v60 = v111;
    static FixedWidthInteger._random<A>(using:)(v125, (uint64_t)v17, v126, v133, v127, v111);
    uint64_t v61 = v130;
    uint64_t v62 = v124;
    uint64_t v63 = v112;
    goto LABEL_9;
  }

  uint64_t result = v58(a3, v57);
  uint64_t v64 = result + 1;
  if (__OFADD__(result, 1LL))
  {
LABEL_16:
    __break(1u);
    return result;
  }

  uint64_t v98 = v55;
  uint64_t v65 = (uint64_t)v104;
  unint64_t v66 = v101;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v104,  (uint64_t)v17,  v101,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  Swift::String::Index v97 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  unint64_t v68 = v99;
  v97(&qword_18180BE70, 512LL, v66, AssociatedConformanceWitness);
  unint64_t v96 = *(uint64_t (**)(char *, unint64_t *, uint64_t))(v65 + 24);
  uint64_t v69 = (uint64_t)v102;
  uint64_t v70 = v96(v68, v17, v65);
  uint64_t v134 = v64;
  unint64_t v71 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v130 + 256);
  unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v72, v73);
  uint64_t v63 = v112;
  v71(v69, &v134, &type metadata for Int, v74, v17, v130);
  uint64_t v75 = *(void (**)(uint64_t, unint64_t *))(v124 + 8);
  v75(v69, v17);
  static FixedWidthInteger._random<A>(using:)(v125, (uint64_t)v17, v126, v133, v127, v69);
  v97(&qword_18180BE70, 512LL, v66, AssociatedConformanceWitness);
  uint64_t v76 = v100;
  uint64_t v77 = v68;
  uint64_t v61 = v130;
  uint64_t v78 = v65;
  unint64_t v55 = v98;
  v96(v77, v17, v78);
  char v79 = v103;
  (*(void (**)(char *, char *, unint64_t *))(*(void *)(v105 + 8) + 40LL))(v63, v76, v17);
  v75((uint64_t)v76, v17);
  v75((uint64_t)v63, v17);
  uint64_t v60 = v111;
  (*(void (**)(uint64_t, char *, unint64_t *, uint64_t))(v61 + 192))(v69, v79, v17, v61);
  v75((uint64_t)v79, v17);
  v75(v69, v17);
  uint64_t v62 = v124;
LABEL_9:
  (*(void (**)(char *, uint64_t, unint64_t *))(v62 + 32))(v63, v60, v17);
  uint64_t v80 = v131;
  unint64_t v81 = v119;
  ((void (*)(char *, unint64_t *, uint64_t, uint64_t, void *))v131[9])(v63, v17, v61, a3, v131);
  unint64_t v82 = v115;
  ((void (*)(uint64_t, void *))v80[18])(a3, v80);
  unint64_t v83 = v123;
  unint64_t v84 = AssociatedTypeWitness;
  unint64_t v85 = swift_getAssociatedConformanceWitness( (uint64_t)v123,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v86 = v120;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v85 + 8))( &unk_18180BE80,  768LL,  v84,  v85);
  BOOL v87 = v116;
  (*((void (**)(char *, uint64_t, const char *))v83 + 3))(v86, a3, v83);
  uint64_t v88 = v117;
  ((void (*)(char *, char *, uint64_t, void *))v80[24])(v82, v87, a3, v80);
  v55(v87, a3);
  v55(v82, a3);
  int64_t v89 = v132;
  char v90 = (void (*)(char *, char *, uint64_t, void *))v132[8];
  uint64_t v91 = v118;
  v90(v81, v88, a3, v132);
  v55(v88, a3);
  v55(v81, a3);
  BOOL v92 = v55;
  uint64_t v93 = v108;
  v90(v108, v91, a3, v89);
  v92(v91, a3);
  v92(v93, a3);
  uint64_t v94 = v122;
  uint64_t v95 = v109;
  (*(void (**)(char *, uint64_t, uint64_t))(v107 + 24))(v81, v109, a3);
  v92(v81, a3);
  if ((v113(v94, v106, a3, v114) & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v129 + 32))(v110, v94, a3);
  }
  v92(v94, a3);
  return static BinaryFloatingPoint<>.random<A>(in:using:)(v95, v125, a3, v126, v128, v127, v133);
}

{
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(void);
  void (*v47)(char *, char *, uint64_t);
  uint64_t (*v48)(uint64_t, void *);
  void (*v49)(char *, uint64_t);
  uint64_t (*v50)(unint64_t *, uint64_t);
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  char *v59;
  void *v60;
  char v61;
  uint64_t v62;
  void (*v63)(char *, unint64_t *);
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t AssociatedConformanceWitness;
  char *v68;
  char *v69;
  uint64_t v70;
  void (*v71)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, void *);
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  void (*v76)(char *, unint64_t *);
  char *v77;
  char *v78;
  uint64_t (*v79)(uint64_t, uint64_t, uint64_t);
  char *v80;
  char *v81;
  char v82;
  char *v83;
  char *v84;
  void *v85;
  char *v86;
  char *v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  void (*v95)(char *, uint64_t);
  uint64_t v96;
  void (*v97)(char *, char *, uint64_t, uint64_t);
  char *v98;
  char *v99;
  uint64_t v100;
  uint64_t (*v101)(char *, unint64_t *, uint64_t);
  void (*v102)(uint64_t *, uint64_t, unint64_t, unint64_t);
  void (*v103)(char *, char *, uint64_t);
  char *v104;
  char *v105;
  unint64_t v106;
  char *v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  void *v111;
  char *v112;
  uint64_t v113;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  const char *v120;
  uint64_t v121;
  uint64_t v122;
  void (*v123)(char *, uint64_t);
  uint64_t v124;
  char *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  char *v129;
  uint64_t v130;
  uint64_t v131;
  char *v132;
  void *v133;
  uint64_t v134;
  uint64_t v127 = a2;
  uint64_t v128 = a6;
  uint64_t v126 = a4;
  uint64_t v130 = a8;
  uint64_t v12 = *(void **)(a5 + 16);
  uint64_t v13 = *(void *)(v12[2] + 8LL);
  uint64_t v120 = *(const char **)(v13 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v118 = (char *)&v100 - v14;
  uint64_t v133 = *(void **)(a7 + 8);
  uint64_t v109 = v133[3];
  unint64_t v15 = *(const char **)(v109 + 16);
  uint64_t v16 = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v108 = v15;
  uint64_t v106 = swift_getAssociatedTypeWitness( 0LL,  v15,  v16,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v106);
  uint64_t v104 = (char *)&v100 - v17;
  uint64_t v18 = swift_checkMetadataState(0LL, v16);
  uint64_t v131 = *(v18 - 1);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v105 = (char *)&v100 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v107 = (char *)&v100 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v132 = (char *)&v100 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v125 = (char *)&v100 - v26;
  uint64_t v27 = *(void *)(a3 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v114 = (char *)&v100 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v112 = (char *)&v100 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  unint64_t v115 = (char *)&v100 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v117 = (char *)&v100 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  uint64_t v116 = (char *)&v100 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  uint64_t v40 = (char *)&v100 - v39;
  MEMORY[0x1895F8858](v38);
  unint64_t v42 = (char *)&v100 - v41;
  uint64_t v44 = a1 + *(int *)(type metadata accessor for ClosedRange(0LL, a3, *(void *)(v12[3] + 8LL), v43) + 36);
  char v121 = v13;
  uint64_t v45 = *(void *)(v13 + 8);
  uint64_t v46 = *(void (**)(void))(v45 + 40);
  uint64_t v110 = v44;
  uint64_t v122 = a1;
  unint64_t v113 = v45;
  v46();
  uint64_t v47 = *(void (**)(char *, char *, uint64_t))(v27 + 16);
  uint64_t v129 = v42;
  v47(v40, v42, a3);
  uint64_t v48 = (uint64_t (*)(uint64_t, void *))v12[47];
  uint64_t v111 = v12;
  if ((v48(a3, v12) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "There is no uniform distribution on an infinite range",  53LL,  2,  "Swift/FloatingPointRandom.swift",  31LL,  2,  0xA2uLL,  0);
  }
  char v49 = *(void (**)(char *, uint64_t))(v27 + 8);
  v49(v40, a3);
  double v50 = *(uint64_t (**)(unint64_t *, uint64_t))(a7 + 56);
  uint64_t v124 = a7;
  uint64_t v51 = v50(v18, a7);
  uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 104);
  uint64_t result = v52(a3, a5);
  if (__OFADD__(result, 1LL))
  {
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v123 = v49;
  if (v51 != result + 1)
  {
    uint64_t result = v52(a3, a5);
    uint64_t v64 = result + 1;
    if (!__OFADD__(result, 1LL))
    {
      uint64_t v103 = v47;
      uint64_t v65 = (uint64_t)v108;
      unint64_t v66 = v106;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v108,  (uint64_t)v18,  v106,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v102 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8);
      unint64_t v68 = v104;
      v102(&qword_18180BE70, 512LL, v66, AssociatedConformanceWitness);
      unint64_t v101 = *(uint64_t (**)(char *, unint64_t *, uint64_t))(v65 + 24);
      uint64_t v69 = v132;
      uint64_t v70 = v101(v68, v18, v65);
      uint64_t v134 = v64;
      unint64_t v71 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, void *))v133[32];
      unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v72, v73);
      uint64_t v75 = v107;
      v71(v69, &v134, &type metadata for Int, v74, v18, v133);
      uint64_t v76 = *(void (**)(char *, unint64_t *))(v131 + 8);
      v76(v69, v18);
      v102(&qword_18180BE70, 512LL, v66, AssociatedConformanceWitness);
      uint64_t v77 = v105;
      uint64_t v78 = v68;
      uint64_t v60 = v133;
      char v79 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v103;
      v101(v78, v18, v65);
      (*(void (**)(char *, char *, unint64_t *))(*(void *)(v109 + 8) + 24LL))(v75, v77, v18);
      v76(v77, v18);
      uint64_t v80 = v125;
      RandomNumberGenerator.next<A>(upperBound:)(v69, v126, (uint64_t)v18, v128, v124, v125);
      unint64_t v81 = v69;
      unint64_t v55 = v80;
      v76(v81, v18);
      unint64_t v82 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v60[2] + 8LL) + 8LL))( v80,  v75,  v18);
      unint64_t v83 = v75;
      uint64_t v62 = v131;
      v76(v83, v18);
      if ((v82 & 1) != 0)
      {
        v76(v80, v18);
        v123(v129, a3);
        return v79(v130, v110, a3);
      }

      goto LABEL_10;
    }

uint64_t static BinaryFloatingPoint<>.random(in:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5);
}

{
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5);
}

uint64_t Int128._value.setter(uint64_t result, uint64_t a2)
{
  void *v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t (*Int128._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int128._high.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t static Int128.zero.getter()
{
  return 0LL;
}

uint64_t static Int128.min.getter()
{
  return 0LL;
}

uint64_t static Int128.max.getter()
{
  return -1LL;
}

uint64_t Int128.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 8 <= 0x80) {
    return *(void *)a1;
  }
  else {
    return 0LL;
  }
}

uint64_t Int128.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v98 = *(const char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v98,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  Swift::String::Index v97 = (char *)&v95 - v8;
  uint64_t v9 = *(void *)(a2 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v99 = (char *)&v95 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  unint64_t v14 = (char *)&v95 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v102 = (char *)&v95 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v103 = (char *)&v95 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v101 = (char *)&v95 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v95 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v95 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v29 = (char *)&v95 - v28;
  int64_t v108 = 64LL;
  uint64_t v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  uint64_t v104 = (char *)a1;
  v30(a1, &v108, &type metadata for Int, v33, a2, a3);
  uint64_t v105 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v105(a2, a3);
  uint64_t v106 = v9;
  uint64_t v34 = *(void (**)(char *, char *, uint64_t))(v9 + 16);
  v34(v26, v29, a2);
  unint64_t v100 = v14;
  BOOL v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v36 = *(void (**)(char *, uint64_t))(v106 + 8);
  v36(v26, a2);
  v34(v23, v29, a2);
  if (!v35)
  {
    v36(v23, a2);
    uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v43 = v104;
    goto LABEL_10;
  }

  int64_t v108 = 0x8000000000000000LL;
  uint64_t v37 = v105;
  if ((v105(a2, a3) & 1) != 0)
  {
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v39 = v38(a2, a3);
    if (v39 >= 64)
    {
      uint64_t v73 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v74 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
      uint64_t v75 = v101;
      v73(&v108, &type metadata for Int64, v74, a2, a3);
      char v76 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v75,  a2);
      v36(v75, a2);
      v36(v23, a2);
      uint64_t v43 = v104;
      uint64_t v44 = v38;
      if ((v76 & 1) != 0) {
        goto LABEL_41;
      }
    }

    else
    {
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      uint64_t v43 = v104;
      uint64_t v44 = v38;
      if (v42 < v108) {
        goto LABEL_41;
      }
    }

    goto LABEL_10;
  }

  char v61 = v37(a2, a3);
  unint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v62 = v96(a2, a3);
  if ((v61 & 1) != 0)
  {
    if (v62 > 64)
    {
      uint64_t v65 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v66 = lazy protocol witness table accessor for type Int64 and conformance Int64(v62, v63, v64);
      uint64_t v67 = v101;
      v65(&v108, &type metadata for Int64, v66, a2, a3);
      char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v67,  a2);
      v36(v67, a2);
      v36(v23, a2);
      uint64_t v43 = v104;
      uint64_t v44 = v96;
      if ((v68 & 1) != 0) {
        goto LABEL_41;
      }
      goto LABEL_10;
    }

    uint64_t v86 = v98;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v98,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v88 = v97;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    int64_t v89 = v101;
    (*((void (**)(char *, uint64_t, const char *))v86 + 3))(v88, a2, v86);
    char v90 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v23,  v89,  a2);
    v36(v89, a2);
    uint64_t v91 = v99;
    (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v99, v23, a2);
    uint64_t v43 = v104;
    if ((v90 & 1) != 0)
    {
      v36(v91, a2);
LABEL_41:
      v36(v29, a2);
      uint64_t v72 = 0LL;
      goto LABEL_42;
    }

    int64_t v92 = v108;
    uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v91, a2);
    BOOL v78 = v93 < v92;
    goto LABEL_39;
  }

  if (v62 < 64)
  {
    uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    BOOL v78 = v77 < v108;
    uint64_t v43 = v104;
LABEL_39:
    uint64_t v44 = v96;
    if (v78) {
      goto LABEL_41;
    }
LABEL_10:
    uint64_t v45 = v44(a2, a3);
    goto LABEL_11;
  }

  v36(v23, a2);
  uint64_t v43 = v104;
  uint64_t v44 = v96;
  uint64_t v45 = v96(a2, a3);
LABEL_11:
  uint64_t v46 = v45;
  uint64_t v47 = v103;
  v34(v103, v29, a2);
  if (v46 >= 65)
  {
    v36(v47, a2);
    uint64_t v48 = v102;
    v34(v102, v29, a2);
    char v49 = v105;
    goto LABEL_15;
  }

  uint64_t v50 = v44(a2, a3);
  v36(v47, a2);
  if (v50 != 64)
  {
    uint64_t v48 = v102;
    v34(v102, v29, a2);
    goto LABEL_25;
  }

  char v49 = v105;
  char v51 = v105(a2, a3);
  uint64_t v48 = v102;
  v34(v102, v29, a2);
  if ((v51 & 1) != 0)
  {
LABEL_25:
    uint64_t v70 = v48;
    goto LABEL_26;
  }

uint64_t Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized Int128.init<A>(_:));
}

{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized Int128.init<A>(_:));
}

uint64_t Int128.init<A>(clamping:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  uint64_t v9 = Int128.init<A>(exactly:)((uint64_t)v8, a2, a3);
  if ((v10 & 1) != 0)
  {
    (*(void (**)(uint64_t))(*(void *)(*(void *)(a3 + 24) + 8LL) + 16LL))(a2);
    char v12 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( a1,  v8,  a2);
    uint64_t v13 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
    v13(a1, a2);
    v13((uint64_t)v8, a2);
    if ((v12 & 1) != 0) {
      return 0LL;
    }
    else {
      return -1LL;
    }
  }

  else
  {
    uint64_t v11 = v9;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }

  return v11;
}

uint64_t UInt128.init<A>(truncatingIfNeeded:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = specialized UInt128.init<A>(truncatingIfNeeded:)(a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v5;
}

  ;
}

uint64_t *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int128@<X0>( uint64_t *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 8 <= 0x80)
  {
    uint64_t v3 = *result;
    if (a2 >> 8 > 0x40)
    {
      uint64_t v4 = result[1];
      *a3 = v3;
      a3[1] = v4;
    }

    else
    {
      *(_OWORD *)a3 = v3;
    }
  }

  else
  {
    *a3 = 0LL;
    a3[1] = 0LL;
  }

  return result;
}

uint64_t Int128.init<A>(exactly:)(char *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(*(void *)(v6 + 16) + 8LL);
  uint64_t v64 = *(const char **)(v7 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v64,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v61 = (char *)&v60 - v8;
  unint64_t v74 = a3;
  uint64_t v9 = *(void *)(a3 + 8);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v60 - v12;
  uint64_t v14 = *(void *)(a2 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v11);
  uint64_t v63 = (char *)&v60 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v72 = (char *)&v60 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v60 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v60 - v22;
  uint64_t v24 = *(void (**)(char *, char *, uint64_t))(v7 + 56);
  uint64_t v75 = a1;
  uint64_t v73 = v7;
  uint64_t v65 = v24;
  ((void (*)(uint64_t, uint64_t))v24)(a2, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a2,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
  uint64_t v70 = *(void (**)(unint64_t, double))(AssociatedConformanceWitness + 8);
  unint64_t v71 = AssociatedConformanceWitness;
  v70(v10, 1.84467441e19);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 24);
  unint64_t v66 = v13;
  uint64_t v67 = v9;
  uint64_t v27 = v13;
  uint64_t v28 = v14;
  uint64_t v69 = v26;
  v26(v27, a2, v9);
  uint64_t v68 = v6;
  uint64_t v29 = *(void *)(*(void *)(v6 + 24) + 8LL);
  uint64_t v30 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v29 + 16);
  LOBYTE(a1) = v30(v23, v21, a2, v29);
  uint64_t v31 = *(void (**)(char *, uint64_t))(v28 + 8);
  v31(v21, a2);
  v31(v23, a2);
  if ((a1 & 1) == 0)
  {
    uint64_t v37 = v66;
    ((void (*)(unint64_t, unint64_t, double))v70)(v10, v71, 5.42101086e-20);
    uint64_t v38 = v67;
    v69(v37, a2, v67);
    uint64_t v65 = *(void (**)(char *, char *, uint64_t))(v73 + 64);
    v65(v75, v21, a2);
    v31(v21, a2);
    LOBYTE(v76) = 3;
    uint64_t v39 = v72;
    (*(void (**)(uint64_t *, uint64_t))(v68 + 304))(&v76, a2);
    v31(v23, a2);
    uint64_t v40 = (*(uint64_t (**)(char *, char *, uint64_t))(v28 + 16))(v23, v39, a2);
    unint64_t v43 = lazy protocol witness table accessor for type Int64 and conformance Int64(v40, v41, v42);
    FixedWidthInteger.init<A>(exactly:)((uint64_t)v23, (uint64_t)&type metadata for Int64, a2, v43, v74, (uint64_t)&v76);
    if (v77 != 1)
    {
      ((void (*)(unint64_t, unint64_t, double))v70)(v10, v71, 1.84467441e19);
      uint64_t v50 = v63;
      v69(v37, a2, v38);
      char v52 = v72;
      uint64_t v51 = v73;
      ((void (*)(char *, char *, uint64_t, uint64_t))v65)(v50, v72, a2, v73);
      v31(v50, a2);
      v31(v52, a2);
      uint64_t v53 = *(void (**)(char *, char *, uint64_t))(*(void *)(v51 + 8) + 40LL);
      uint64_t v54 = v75;
      v53(v75, v21, a2);
      v31(v54, a2);
      uint64_t v55 = ((uint64_t (*)(char *, uint64_t))v31)(v21, a2);
      unint64_t v58 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v55, v56, v57);
      FixedWidthInteger.init<A>(exactly:)((uint64_t)v23, (uint64_t)&type metadata for UInt64, a2, v58, v74, (uint64_t)&v76);
      if (v77 != 1) {
        return v76;
      }
      return 0LL;
    }

    v31(v75, a2);
    uint64_t v36 = v72;
LABEL_6:
    v31(v36, a2);
    return 0LL;
  }

  uint64_t v32 = ((uint64_t (*)(uint64_t, uint64_t))v65)(a2, v73);
  unint64_t v35 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v32, v33, v34);
  FixedWidthInteger.init<A>(exactly:)((uint64_t)v23, (uint64_t)&type metadata for UInt64, a2, v35, v74, (uint64_t)&v76);
  if (v77 == 1)
  {
    uint64_t v36 = v75;
    goto LABEL_6;
  }

  uint64_t v44 = v76;
  uint64_t v45 = v64;
  unint64_t v46 = AssociatedTypeWitness;
  unint64_t v47 = swift_getAssociatedConformanceWitness( (uint64_t)v64,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v48 = v61;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8))( &unk_18180BE68,  256LL,  v46,  v47);
  (*((void (**)(char *, uint64_t, const char *))v45 + 3))(v48, a2, v45);
  char v49 = v75;
  LOBYTE(v46) = v30(v75, v23, a2, v29);
  v31(v49, a2);
  v31(v23, a2);
  if ((v46 & 1) != 0) {
    return -v44;
  }
  return v44;
}

uint64_t Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  uint64_t v6 = a4();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v6;
}

BOOL static Int128.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Int128(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL static Int128.< infix(_:_:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return (__int128)__PAIR128__(a2, a1) < (__int128)__PAIR128__(a4, a3);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a2 < *a1;
}

void Int128.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
}

Swift::Int Int128.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Int128()
{
  return Int128.hashValue.getter(*v0, v0[1]);
}

uint64_t Int128.addingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t Int128.subtractingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 - a1;
}

uint64_t Int128.multipliedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (a1 ^ (a2 >> 63)) - (a2 >> 63);
  if ((a4 ^ a2) >= 0) {
    return ((a3 ^ (a4 >> 63)) - (a4 >> 63)) * v4;
  }
  else {
    return -(((a3 ^ (a4 >> 63)) - (a4 >> 63)) * v4);
  }
}

uint64_t Int128.magnitude.getter(uint64_t a1, uint64_t a2)
{
  return (a1 ^ (a2 >> 63)) - (a2 >> 63);
}

uint64_t UInt128.multipliedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 * a1;
}

uint64_t UInt128.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 9 <= 0x40 && (a2 & 1) == 0) {
    return *(void *)a1;
  }
  else {
    return 0LL;
  }
}

uint64_t Int128.dividedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x126uLL,  0);
  }
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL && (a3 | a4 ^ 0x8000000000000000LL) == 0) {
    return 0LL;
  }
  else {
    return __divti3();
  }
}

uint64_t Int128.remainderReportingOverflow(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x130uLL,  0);
  }
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL && (a3 | a4 ^ 0x8000000000000000LL) == 0) {
    return 0LL;
  }
  else {
    return __modti3();
  }
}

unint64_t static Int128.+ infix(_:_:)( unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4 = __OFADD__(__CFADD__(a1, a3), a2);
  unsigned __int128 v6 = __PAIR128__(a2, a1) + a3;
  unint64_t result = a1 + a3;
  if (v4 | __OFADD__(a4, *((void *)&v6 + 1))) {
    char v7 = 1;
  }
  else {
    char v7 = 0;
  }
  if ((v7 & 1) != 0) {
    __break(1u);
  }
  return result;
}

unint64_t static Int128.- infix(_:_:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _BOOL1 v4 = a1 >= a3;
  unint64_t result = a1 - a3;
  if (__OFSUB__(a2, a4, v4)) {
    __break(1u);
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int128@<X0>( void *result@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  __int128 v3 = *(_OWORD *)result + *(_OWORD *)a2;
  if (__OFADD__(__CFADD__(*result, *a2), result[1]) | __OFADD__(a2[1], *((void *)&v3 + 1))) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if ((v4 & 1) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int128( void *result, unint64_t *a2)
{
  unint64_t v2 = a2[1];
  __int128 v3 = *(_OWORD *)result + *a2;
  char v4 = __OFADD__(__CFADD__(*result, *a2), result[1]) | __OFADD__(v2, *((void *)&v3 + 1));
  unint64_t v5 = v2 + *((void *)&v3 + 1);
  if (v4) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if ((v6 & 1) != 0)
  {
    __break(1u);
  }

  else
  {
    *unint64_t result = v3;
    result[1] = v5;
  }

  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int128( _OWORD *result, _OWORD *a2)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

uint64_t static Int128.* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((__PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
      - __PAIR128__(a2 >> 63, a2 >> 63)) >> 64)
    BOOL v6 = *((void *)&v5 + 1) == 0LL;
  else {
    BOOL v6 = 1;
  }
  char v9 = !v6
    || (((__PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
        - __PAIR128__(a2 >> 63, a2 >> 63)) >> 64)
      * ((a3 ^ (unint64_t)(a4 >> 63)) - (a4 >> 63))) >> 64 != 0
    || (((__PAIR128__(a4 ^ (unint64_t)(a4 >> 63), a3 ^ (unint64_t)(a4 >> 63))
        - __PAIR128__(a4 >> 63, a4 >> 63)) >> 64)
      * ((a1 ^ (unint64_t)(a2 >> 63)) - (a2 >> 63))) >> 64 != 0;
  if (__CFADD__( ((unint64_t)v4 * (unsigned __int128)(unint64_t)v5) >> 64,  *((void *)&v5 + 1) * v4 + *((void *)&v4 + 1) * v5))
  {
    char v10 = 1;
  }

  else
  {
    char v10 = v9;
  }

  uint64_t result = v4 * v5;
  if (((a4 ^ a2) & 0x8000000000000000LL) == 0)
  {
    if ((((v5 * v4) >> 64) & 0x8000000000000000LL) != 0LL) {
      char v12 = 1;
    }
    else {
      char v12 = v10;
    }
    if ((v12 & 1) == 0) {
      return result;
    }
LABEL_26:
    __break(1u);
    return result;
  }

  uint64_t result = -result;
  if (result) {
    char v13 = 1;
  }
  else {
    char v13 = v10;
  }
  if ((v13 & 1) != 0) {
    goto LABEL_26;
  }
  return result;
}

uint64_t static Int128.*= infix(_:_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned __int128 v3 = abs128(*(_OWORD *)result);
  if (*((void *)&v3 + 1)) {
    BOOL v5 = *((void *)&v4 + 1) == 0LL;
  }
  else {
    BOOL v5 = 1;
  }
  char v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)((a2 ^ (unint64_t)(a3 >> 63)) - (a3 >> 63))) >> 64 != 0
    || (((__PAIR128__(a3 ^ (unint64_t)(a3 >> 63), a2 ^ (unint64_t)(a3 >> 63))
        - __PAIR128__(a3 >> 63, a3 >> 63)) >> 64)
      * (unint64_t)v3) >> 64 != 0;
  uint64_t v9 = (v4 * v3) >> 64;
  if (__CFADD__( ((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64,  *((void *)&v4 + 1) * v3 + *((void *)&v3 + 1) * v4))
  {
    char v8 = 1;
  }

  uint64_t v10 = v3 * v4;
  if (((*(void *)(result + 8) ^ a3) & 0x8000000000000000LL) == 0)
  {
    if ((v8 & 1) != 0)
    {
      __break(1u);
      goto LABEL_24;
    }

    if ((v9 & 0x8000000000000000LL) == 0)
    {
LABEL_22:
      *(void *)uint64_t result = v10;
      *(void *)(result + 8) = v9;
      return result;
    }

    __break(1u);
  }

  if ((v8 & 1) != 0)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }

  BOOL v11 = v10 == 0;
  uint64_t v10 = -v10;
  uint64_t v9 = -(v9 + !v11);
  if (!v10) {
    goto LABEL_22;
  }
LABEL_25:
  __break(1u);
  return result;
}

uint64_t static Int128./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x126uLL,  0);
  }
  if (a1 | a2 ^ 0x8000000000000000LL || (a3 & a4) != 0xFFFFFFFFFFFFFFFFLL) {
    return __divti3();
  }
  else {
    return 0LL;
  }
}

uint64_t static Int128./= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x126uLL,  0);
  }
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || v6 | v7 ^ 0x8000000000000000LL)
  {
    uint64_t result = __divti3();
  }

  else
  {
    uint64_t result = 0LL;
    unint64_t v10 = 0x8000000000000000LL;
  }

  *a1 = result;
  a1[1] = v10;
  return result;
}

uint64_t static Int128.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x130uLL,  0);
  }
  if (a1 | a2 ^ 0x8000000000000000LL || (a3 & a4) != 0xFFFFFFFFFFFFFFFFLL) {
    return __modti3();
  }
  else {
    return 0LL;
  }
}

uint64_t static Int128.%= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x130uLL,  0);
  }
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || v6 | v7 ^ 0x8000000000000000LL)
  {
    uint64_t result = __modti3();
  }

  else
  {
    uint64_t result = 0LL;
    uint64_t v10 = 0LL;
  }

  *a1 = result;
  a1[1] = v10;
  return result;
}

uint64_t protocol witness for static SignedNumeric.- prefix(_:) in conformance Int128@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -*(_OWORD *)result >> 64;
  if (__OFSUB__(0LL, *(void *)(result + 8), *(void *)result == 0LL))
  {
    __break(1u);
  }

  else
  {
    *a2 = -*(void *)result;
    a2[1] = v2;
  }

  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int128()
{
  uint64_t v1 = -*(_OWORD *)v0 >> 64;
  if (__OFSUB__(0LL, *(void *)(v0 + 8), *(void *)v0 == 0LL))
  {
    __break(1u);
  }

  else
  {
    *(void *)uint64_t v0 = -*(void *)v0;
    *(void *)(v0 + 8) = v1;
  }

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128( (uint64_t (*)(void))Int128.init<A>(exactly:),  a1);
}

void protocol witness for Numeric.magnitude.getter in conformance Int128(_OWORD *a1@<X8>)
{
  *a1 = abs128(*v1);
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance Int128@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unsigned __int128 v3 = abs128(*(_OWORD *)result);
  unsigned __int128 v4 = abs128(*(_OWORD *)a2);
  if (*((void *)&v3 + 1)) {
    BOOL v5 = *((void *)&v4 + 1) == 0LL;
  }
  else {
    BOOL v5 = 1;
  }
  char v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v4) >> 64 != 0
    || (*((unint64_t *)&v4 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0;
  uint64_t v9 = (v4 * v3) >> 64;
  if (__CFADD__( ((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64,  *((void *)&v4 + 1) * v3 + *((void *)&v3 + 1) * v4))
  {
    char v10 = 1;
  }

  else
  {
    char v10 = v8;
  }

  uint64_t v11 = v3 * v4;
  if (((*(void *)(a2 + 8) ^ *(void *)(result + 8)) & 0x8000000000000000LL) != 0)
  {
    BOOL v12 = v11 == 0;
    uint64_t v11 = -v11;
    uint64_t v9 = -(v9 + !v12);
    if (v11) {
      char v10 = 1;
    }
    if ((v10 & 1) == 0) {
      goto LABEL_20;
    }
  }

  else
  {
    if (v9 < 0) {
      char v10 = 1;
    }
    if ((v10 & 1) == 0)
    {
LABEL_20:
      *a3 = v11;
      a3[1] = v9;
      return result;
    }
  }

  __break(1u);
  return result;
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance Int128(uint64_t result, uint64_t a2)
{
  unsigned __int128 v2 = abs128(*(_OWORD *)result);
  unsigned __int128 v3 = abs128(*(_OWORD *)a2);
  if (*((void *)&v2 + 1)) {
    BOOL v4 = *((void *)&v3 + 1) == 0LL;
  }
  else {
    BOOL v4 = 1;
  }
  char v7 = !v4
    || (*((unint64_t *)&v2 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v2) >> 64 != 0;
  uint64_t v8 = (v3 * v2) >> 64;
  if (__CFADD__( ((unint64_t)v2 * (unsigned __int128)(unint64_t)v3) >> 64,  *((void *)&v3 + 1) * v2 + *((void *)&v2 + 1) * v3))
  {
    char v9 = 1;
  }

  else
  {
    char v9 = v7;
  }

  uint64_t v10 = v2 * v3;
  if (((*(void *)(result + 8) ^ *(void *)(a2 + 8)) & 0x8000000000000000LL) == 0)
  {
    if ((v9 & 1) != 0)
    {
      __break(1u);
      goto LABEL_24;
    }

    if ((v8 & 0x8000000000000000LL) == 0)
    {
LABEL_22:
      *(void *)uint64_t result = v10;
      *(void *)(result + 8) = v8;
      return result;
    }

    __break(1u);
  }

  if ((v9 & 1) != 0)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }

  BOOL v11 = v10 == 0;
  uint64_t v10 = -v10;
  uint64_t v8 = -(v8 + !v11);
  if (!v10) {
    goto LABEL_22;
  }
LABEL_25:
  __break(1u);
  return result;
}

void *static Int128.&= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1] & a3;
  *result &= a2;
  result[1] = v3;
  return result;
}

void *static Int128.|= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1] | a3;
  *result |= a2;
  result[1] = v3;
  return result;
}

void *static Int128.^= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1] ^ a3;
  *result ^= a2;
  result[1] = v3;
  return result;
}

uint64_t *static Int128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = ((2 * v2) << ~a2) | ((unint64_t)*result >> a2);
  uint64_t v4 = v2 >> a2;
  if ((a2 & 0x40) != 0) {
    uint64_t v3 = v2 >> a2;
  }
  uint64_t v5 = v2 >> 63;
  if ((a2 & 0x40) == 0) {
    uint64_t v5 = v4;
  }
  *uint64_t result = v3;
  result[1] = v5;
  return result;
}

void *static Int128.&<<= infix(_:_:)(void *result, char a2)
{
  uint64_t v2 = (result[1] << a2) | (*result >> 1 >> ~a2);
  uint64_t v3 = *result << a2;
  if ((a2 & 0x40) != 0)
  {
    uint64_t v2 = *result << a2;
    uint64_t v3 = 0LL;
  }

  *uint64_t result = v3;
  result[1] = v2;
  return result;
}

unint64_t Int128.trailingZeroBitCount.getter(unint64_t a1, unint64_t a2)
{
  unint64_t v2 = __clz(__rbit64(a1));
  unint64_t v3 = __clz(__rbit64(a2)) + 64;
  if (a1) {
    return v2;
  }
  else {
    return v3;
  }
}

unint64_t Int64.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

unint64_t UInt64.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128( (uint64_t (*)(void))Int128.init<A>(exactly:),  a1);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128( a1,  a2,  (uint64_t (*)(void))specialized Int128.init<A>(_:),  a3);
}

{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128( a1,  a2,  (uint64_t (*)(void))specialized Int128.init<A>(_:),  a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(void)@<X5>, uint64_t *a4@<X8>)
{
  uint64_t v7 = a3();
  uint64_t v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = specialized UInt128.init<A>(truncatingIfNeeded:)(a1, a2, a3);
  uint64_t v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = Int128.init<A>(clamping:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  return result;
}

void protocol witness for BinaryInteger.words.getter in conformance Int128(void *a1@<X8>)
{
  uint64_t v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
}

uint64_t protocol witness for BinaryInteger.bitWidth.getter in conformance Int128()
{
  return 128LL;
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int128()
{
  unint64_t v1 = __clz(__rbit64(*v0));
  unint64_t v2 = __clz(__rbit64(v0[1])) + 64;
  if (*v0) {
    return v1;
  }
  else {
    return v2;
  }
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int128@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (*(_OWORD *)a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x126uLL,  0);
  }
  if (*a1 | a1[1] ^ 0x8000000000000000LL) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1LL;
  }
  if (v4)
  {
    uint64_t result = 0LL;
    unint64_t v6 = 0x8000000000000000LL;
  }

  else
  {
    uint64_t result = __divti3();
  }

  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int128( uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x126uLL,  0);
  }
  if ((*(void *)a2 & *(void *)(a2 + 8)) == -1LL && (*a1 | a1[1] ^ 0x8000000000000000LL) == 0)
  {
    uint64_t result = 0LL;
    unint64_t v5 = 0x8000000000000000LL;
  }

  else
  {
    uint64_t result = __divti3();
  }

  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int128@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (*(_OWORD *)a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x130uLL,  0);
  }
  if (*a1 | a1[1] ^ 0x8000000000000000LL) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1LL;
  }
  if (v4)
  {
    uint64_t result = 0LL;
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t result = __modti3();
  }

  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int128( uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x130uLL,  0);
  }
  if ((*(void *)a2 & *(void *)(a2 + 8)) == -1LL && (*a1 | a1[1] ^ 0x8000000000000000LL) == 0)
  {
    uint64_t result = 0LL;
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t result = __modti3();
  }

  *a1 = result;
  a1[1] = v5;
  return result;
}

void *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int128@<X0>( void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = ~result[1];
  *a2 = ~*result;
  a2[1] = v2;
  return result;
}

void *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int128@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2[1] & result[1];
  *a3 = *a2 & *result;
  a3[1] = v3;
  return result;
}

void *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int128( void *result, void *a2)
{
  uint64_t v2 = result[1] & a2[1];
  *result &= *a2;
  result[1] = v2;
  return result;
}

void *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int128@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2[1] | result[1];
  *a3 = *a2 | *result;
  a3[1] = v3;
  return result;
}

void *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int128( void *result, void *a2)
{
  uint64_t v2 = result[1] | a2[1];
  *result |= *a2;
  result[1] = v2;
  return result;
}

void *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int128@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = a2[1] ^ result[1];
  *a3 = *a2 ^ *result;
  a3[1] = v3;
  return result;
}

void *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int128( void *result, void *a2)
{
  uint64_t v2 = result[1] ^ a2[1];
  *result ^= *a2;
  result[1] = v2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int128@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v124 = a5;
  uint64_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v122 = (char *)&v114 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v121 = (char *)&v114 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v117 = (char *)&v114 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v114 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v125 = (char *)&v114 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v114 - v28;
  unint64_t v30 = *a1;
  uint64_t v31 = a1[1];
  uint64_t v127 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v127(a3, a4) & 1) == 0)
  {
    unint64_t v123 = v30;
    uint64_t v115 = v31;
    char v37 = v127(a3, a4);
    uint64_t v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v38 = v126(a3, a4);
    if ((v37 & 1) != 0)
    {
      if (v38 > 64)
      {
        int64_t v129 = -128LL;
        uint64_t v41 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v42 = lazy protocol witness table accessor for type Int and conformance Int(v38, v39, v40);
        v41(&v129, &type metadata for Int, v42, a3, a4);
        char v43 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        uint64_t v31 = v115;
        unint64_t v30 = v123;
        if ((v43 & 1) != 0) {
          goto LABEL_18;
        }
        goto LABEL_19;
      }

      unint64_t v48 = AssociatedTypeWitness;
      char v49 = v120;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v51 = v118;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_18;
      }

      uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
    }

    else
    {
      if (v38 >= 64)
      {
        uint64_t v31 = v115;
        unint64_t v30 = v123;
        goto LABEL_19;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    }

    uint64_t v31 = v115;
    unint64_t v30 = v123;
    if (v47 < -128) {
      goto LABEL_18;
    }
    goto LABEL_19;
  }

  uint64_t v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v32 = v126(a3, a4);
  if (v32 >= 64)
  {
    int64_t v129 = -128LL;
    uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
    v44(&v129, &type metadata for Int, v45, a3, a4);
    char v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if ((v46 & 1) != 0) {
      goto LABEL_18;
    }
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v35 < -128) {
      goto LABEL_18;
    }
  }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int128( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v118 = a1;
  uint64_t v115 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v115,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v113 = (char *)&v108 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v108 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  BOOL v111 = (char *)&v108 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v108 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v116 = (char *)&v108 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v112 = (char *)&v108 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v108 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v108 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v29 = (char *)&v108 - v28;
  unint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v119(a3, a4) & 1) == 0)
  {
    uint64_t v109 = v17;
    unint64_t v110 = v27;
    char v35 = v119(a3, a4);
    uint64_t v117 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v36 = v117(a3, a4);
    if ((v35 & 1) != 0)
    {
      if (v36 > 64)
      {
        int64_t v121 = -128LL;
        uint64_t v39 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
        v39(&v121, &type metadata for Int, v40, a3, a4);
        char v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
        uint64_t v17 = v109;
        uint64_t v27 = v110;
        if ((v41 & 1) != 0) {
          goto LABEL_18;
        }
        goto LABEL_19;
      }

      unint64_t v46 = AssociatedTypeWitness;
      uint64_t v47 = v115;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v49 = v113;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_18;
      }

      uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
    }

    else
    {
      if (v36 >= 64)
      {
        uint64_t v17 = v109;
        uint64_t v27 = v110;
        goto LABEL_19;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
      uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    }

    uint64_t v17 = v109;
    uint64_t v27 = v110;
    if (v45 < -128) {
      goto LABEL_18;
    }
    goto LABEL_19;
  }

  uint64_t v117 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v30 = v117(a3, a4);
  if (v30 >= 64)
  {
    int64_t v121 = -128LL;
    unint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v42(&v121, &type metadata for Int, v43, a3, a4);
    char v44 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    if ((v44 & 1) != 0) {
      goto LABEL_18;
    }
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    if (v33 < -128) {
      goto LABEL_18;
    }
  }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int128@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v123 = a5;
  uint64_t v117 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v117,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v115 = (char *)&v112 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v112 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unint64_t v113 = (char *)&v112 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v118 = (char *)&v112 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v120 = (char *)&v112 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v114 = (char *)&v112 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v112 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  int64_t v121 = (char *)&v112 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v112 - v28;
  uint64_t v122 = a1[1];
  unint64_t v119 = *a1;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v124 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    uint64_t v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v125(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v127 = -128LL;
        unint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v127, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        uint64_t v30 = v124;
        uint64_t v32 = v125;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      char v49 = v117;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v117,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v51 = v115;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -128;
    }

    else
    {
      if (v39 >= 64)
      {
        uint64_t v30 = v124;
        uint64_t v32 = v125;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -128;
    }

    uint64_t v30 = v124;
    uint64_t v32 = v125;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    int64_t v127 = -128LL;
    char v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v44(&v127, &type metadata for Int, v45, a3, a4);
    LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 < -128) {
      goto LABEL_19;
    }
  }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int128( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v120 = a1;
  uint64_t v116 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v116,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v114 = (char *)&v109 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v109 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v112 = (char *)&v109 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v109 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v117 = (char *)&v109 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v113 = (char *)&v109 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v109 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v109 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v29 = (char *)&v109 - v28;
  unint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v119(a3, a4) & 1) == 0)
  {
    int64_t v110 = v17;
    uint64_t v111 = v27;
    char v35 = v119(a3, a4);
    unint64_t v118 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v36 = v118(a3, a4);
    if ((v35 & 1) != 0)
    {
      if (v36 > 64)
      {
        int64_t v122 = -128LL;
        uint64_t v39 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
        v39(&v122, &type metadata for Int, v40, a3, a4);
        char v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
        uint64_t v17 = v110;
        uint64_t v27 = v111;
        if ((v41 & 1) != 0) {
          goto LABEL_18;
        }
        goto LABEL_20;
      }

      unint64_t v46 = AssociatedTypeWitness;
      BOOL v47 = v116;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v116,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v49 = v114;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_18;
      }

      uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
    }

    else
    {
      if (v36 >= 64)
      {
        uint64_t v17 = v110;
        uint64_t v27 = v111;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
      uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    }

    uint64_t v17 = v110;
    uint64_t v27 = v111;
    if (v45 >= -128) {
      goto LABEL_20;
    }
    goto LABEL_18;
  }

  unint64_t v118 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v30 = v118(a3, a4);
  if (v30 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    if (v33 >= -128) {
      goto LABEL_20;
    }
LABEL_18:
    uint64_t v51 = v120[1];
    goto LABEL_19;
  }

  int64_t v122 = -128LL;
  unint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
  v42(&v122, &type metadata for Int, v43, a3, a4);
  char v44 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
  if ((v44 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_20:
  char v54 = v119(a3, a4);
  uint64_t v55 = v118(a3, a4);
  if ((v54 & 1) != 0)
  {
    if (v55 > 64) {
      goto LABEL_22;
    }
LABEL_25:
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
    uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v61 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    uint64_t result = v61(v29, a3);
    if (v62 > 128) {
      goto LABEL_26;
    }
    goto LABEL_27;
  }

  if (v55 < 64) {
    goto LABEL_25;
  }
LABEL_22:
  int64_t v122 = 128LL;
  uint64_t v58 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v59 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
  v58(&v122, &type metadata for Int, v59, a3, a4);
  char v60 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
  char v61 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  uint64_t result = v61(v29, a3);
  if ((v60 & 1) != 0) {
    goto LABEL_26;
  }
LABEL_27:
  uint64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v63(v27, a2, a3);
  char v64 = v119(a3, a4);
  v63(v24, (uint64_t)v27, a3);
  if ((v64 & 1) != 0)
  {
    uint64_t v65 = v118(a3, a4);
    v61(v24, a3);
    if (v65 <= 64) {
      goto LABEL_48;
    }
    char v66 = v113;
    v63(v113, (uint64_t)v27, a3);
    int64_t v122 = 0x8000000000000000LL;
    uint64_t v67 = v119;
    if ((v119(a3, a4) & 1) != 0)
    {
      uint64_t v68 = v118(a3, a4);
      if (v68 < 64)
      {
        char v71 = v29;
        goto LABEL_42;
      }

      uint64_t v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
      v80(&v122, &type metadata for Int, v81, a3, a4);
      char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v66,  v29,  a3);
      goto LABEL_37;
    }

    char v73 = v67(a3, a4);
    uint64_t v74 = v118(a3, a4);
    if ((v73 & 1) != 0)
    {
      if (v74 <= 64)
      {
        unint64_t v85 = AssociatedTypeWitness;
        uint64_t v84 = (void (**)(char *, uint64_t, const char *))v116;
        unint64_t v86 = swift_getAssociatedConformanceWitness( (uint64_t)v116,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v87 = v114;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v86 + 8))( &unk_18180BE68,  256LL,  v85,  v86);
        v84[3](v87, a3, (const char *)v84);
        int64_t v88 = v113;
        LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v113,  v29,  a3);
        v61(v29, a3);
        uint64_t v89 = v112;
        v63(v112, (uint64_t)v88, a3);
        if ((v84 & 1) != 0)
        {
          v61(v89, a3);
          goto LABEL_68;
        }

        int64_t v90 = v122;
        uint64_t v91 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v61(v89, a3);
        BOOL v92 = v91 < v90;
        char v66 = v113;
        if (v92) {
          goto LABEL_68;
        }
LABEL_46:
        uint64_t v72 = v66;
        goto LABEL_47;
      }

      char v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v78 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      v77(&v122, &type metadata for Int, v78, a3, a4);
      char v66 = v113;
      char v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v113,  v29,  a3);
LABEL_37:
      char v82 = v79;
      v61(v29, a3);
      if ((v82 & 1) != 0) {
        goto LABEL_68;
      }
      goto LABEL_46;
    }

    if (v74 < 64)
    {
      char v71 = v29;
      char v66 = v113;
LABEL_42:
      v63(v71, (uint64_t)v66, a3);
      uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      if (v83 < v122) {
LABEL_68:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      goto LABEL_46;
    }

    uint64_t v72 = v113;
  }

  else
  {
    uint64_t v72 = v24;
  }

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int128( uint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for BinaryInteger.isMultiple(of:) in conformance Int128(uint64_t *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

void protocol witness for BinaryInteger.signum() in conformance Int128(uint64_t *a1@<X8>)
{
  uint64_t v2 = *(uint64_t *)(v1 + 8) >> 63;
  *a1 = v2 | (*(_OWORD *)v1 != 0LL);
  a1[1] = v2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int128()
{
  return specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, *v0, v0[1]);
}

unint64_t *protocol witness for Strideable.distance(to:) in conformance Int128@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  uint64_t v4 = result[1];
  unint64_t v6 = *v2;
  uint64_t v5 = v2[1];
  if ((v5 ^ v4) < 0)
  {
    unsigned __int128 v12 = __PAIR128__(v5 ^ (unint64_t)(v5 >> 63), v6 ^ (v5 >> 63)) - __PAIR128__(v5 >> 63, v5 >> 63);
    uint64_t v14 = (v3 ^ (v4 >> 63)) - (v4 >> 63);
    uint64_t v13 = (__PAIR128__(v4 ^ (unint64_t)(v4 >> 63), v3 ^ (v4 >> 63)) - __PAIR128__(v4 >> 63, v4 >> 63)) >> 64;
    uint64_t v15 = (__PAIR128__(v5 ^ (unint64_t)(v5 >> 63), v6 ^ (v5 >> 63))
         - __PAIR128__(v5 >> 63, v5 >> 63)
         + (unint64_t)v14) >> 64;
    unint64_t v8 = (v6 ^ (v5 >> 63)) - (v5 >> 63) + v14;
    char v16 = __CFADD__(__CFADD__((void)v12, v14), *((void *)&v12 + 1)) | __CFADD__(v13, v15);
    uint64_t v17 = v13 + v15;
    if (v16) {
      char v18 = 1;
    }
    else {
      char v18 = 0;
    }
    if ((v18 & 1) == 0)
    {
      if (v17 | (v8 >> 63)) {
        goto LABEL_18;
      }
      if (v5 >= 0) {
        unint64_t v8 = -(uint64_t)v8;
      }
      goto LABEL_15;
    }

uint64_t *protocol witness for Strideable.advanced(by:) in conformance Int128@<X0>( uint64_t *result@<X0>, _OWORD *a2@<X8>)
{
  __int128 v3 = *(_OWORD *)v2 + *result;
  if (__OFADD__(__CFADD__(*v2, *result), v2[1]) | __OFADD__(*result >> 63, *((void *)&v3 + 1))) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if ((v4 & 1) != 0) {
    __break(1u);
  }
  else {
    *a2 = v3;
  }
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int128( uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance Int128( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t static Int128.bitWidth.getter()
{
  return 128LL;
}

uint64_t Int128.nonzeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  uint64_t v3 = v2.u32[0];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v4.i16[0] = vaddlv_u8(v4);
  return v3 + v4.u32[0];
}

uint64_t Int64.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t UInt64.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t Int128.leadingZeroBitCount.getter(unint64_t a1, unint64_t a2)
{
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (a2) {
    return v2;
  }
  else {
    return v3;
  }
}

BOOL static Int64.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

unint64_t UInt64.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

unint64_t Int64.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

unint64_t Int128.byteSwapped.getter(uint64_t a1, unint64_t a2)
{
  return bswap64(a2);
}

unint64_t Int64.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

unint64_t UInt64.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

uint64_t static Int128.&* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 * a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int128(void *a1@<X8>)
{
  *a1 = -1LL;
  a1[1] = 0x7FFFFFFFFFFFFFFFLL;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int128(void *a1@<X8>)
{
  *a1 = 0LL;
  a1[1] = 0x8000000000000000LL;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int128( _OWORD *a1, void *a2)
{
  __int128 v3 = *(_OWORD *)v2 + *(_OWORD *)a2;
  if (__OFADD__(__CFADD__(*v2, *a2), v2[1]) | __OFADD__(a2[1], *((void *)&v3 + 1))) {
    uint64_t v4 = 1LL;
  }
  else {
    uint64_t v4 = 0LL;
  }
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int128( _OWORD *a1, _OWORD *a2)
{
  BOOL v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int128( void *a1, uint64_t a2)
{
  unsigned __int128 v3 = abs128(*(_OWORD *)v2);
  unsigned __int128 v4 = abs128(*(_OWORD *)a2);
  if (*((void *)&v3 + 1)) {
    BOOL v5 = *((void *)&v4 + 1) == 0LL;
  }
  else {
    BOOL v5 = 1;
  }
  uint64_t v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v4) >> 64 != 0
    || (*((unint64_t *)&v4 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0;
  if (__CFADD__( ((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64,  *((void *)&v4 + 1) * v3 + *((void *)&v3 + 1) * v4))
  {
    int v9 = 1;
  }

  else
  {
    int v9 = v8;
  }

  uint64_t v10 = *(void *)(v2 + 8) ^ *(void *)(a2 + 8);
  uint64_t v11 = -(v3 * v4);
  uint64_t v12 = (unsigned __int128)-(__int128)__PAIR128__(v8, (void)v3 * (void)v4) >> 64;
  BOOL v13 = v10 < 0;
  if (v10 >= 0) {
    uint64_t v14 = (v4 * v3) >> 64;
  }
  else {
    uint64_t v14 = v12;
  }
  if (v13)
  {
    BOOL v15 = (void)v3 * (void)v4 != 0LL;
  }

  else
  {
    uint64_t v11 = v3 * v4;
    BOOL v15 = (((v4 * v3) >> 64) & 0x8000000000000000LL) != 0LL;
  }

  *a1 = v11;
  a1[1] = v14;
  return v9 | v15;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int128( uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x126uLL,  0);
  }
  BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1LL && (*v2 | v2[1] ^ 0x8000000000000000LL) == 0;
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = 0LL;
    unint64_t v7 = 0x8000000000000000LL;
  }

  else
  {
    uint64_t v6 = __divti3();
  }

  *a1 = v6;
  a1[1] = v7;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int128( uint64_t *a1, uint64_t a2)
{
  if (*(_OWORD *)a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x130uLL,  0);
  }
  BOOL v4 = (*(void *)a2 & *(void *)(a2 + 8)) == -1LL && (*v2 | v2[1] ^ 0x8000000000000000LL) == 0;
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v6 = __modti3();
  }

  *a1 = v6;
  a1[1] = v7;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int128( uint64_t *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t result = specialized FixedWidthInteger.multipliedFullWidth(by:)( a2,  *(void *)a3,  *(void *)(a3 + 8),  *(void *)v3,  *(void *)(v3 + 8));
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int128( uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t result = specialized SignedInteger<>.dividingFullWidth(_:)( a2,  *(void *)a3,  *(void *)(a3 + 8),  *a4,  a4[1],  *v4,  v4[1]);
  *a1 = result;
  a1[1] = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.init(_truncatingBits:) in conformance Int128@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  a2[1] = 0LL;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int128()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8(v0[1]);
  v1.i16[0] = vaddlv_u8(v1);
  uint64_t v2 = v1.u32[0];
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(*v0);
  v3.i16[0] = vaddlv_u8(v3);
  return v2 + v3.u32[0];
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int128()
{
  unint64_t v1 = v0[1];
  unint64_t v2 = __clz(v1);
  unint64_t v3 = __clz(*v0) + 64;
  if (v1) {
    return v2;
  }
  else {
    return v3;
  }
}

unint64_t *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int128@<X0>( unint64_t *result@<X0>, void *a2@<X8>)
{
  unint64_t v2 = bswap64(*result);
  *a2 = bswap64(result[1]);
  a2[1] = v2;
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int128(void *a1@<X8>)
{
  unint64_t v2 = bswap64(*v1);
  *a1 = bswap64(v1[1]);
  a1[1] = v2;
}

void *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int128@<X0>( void *result@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = result[1];
  uint64_t v4 = ((2 * v3) << ~*a2) | (*result >> *a2);
  uint64_t v5 = v3 >> *a2;
  if ((*a2 & 0x40LL) != 0) {
    uint64_t v4 = v3 >> *a2;
  }
  uint64_t v6 = v3 >> 63;
  if ((*a2 & 0x40LL) == 0) {
    uint64_t v6 = v5;
  }
  *a3 = v4;
  a3[1] = v6;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int128( uint64_t *result, void *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = v2 >> *a2;
  if ((*a2 & 0x40LL) != 0) {
    uint64_t v4 = v2 >> *a2;
  }
  else {
    uint64_t v4 = ((2 * v2) << ~*a2) | ((unint64_t)*result >> *a2);
  }
  uint64_t v5 = v2 >> 63;
  if ((*a2 & 0x40LL) == 0) {
    uint64_t v5 = v3;
  }
  *uint64_t result = v4;
  result[1] = v5;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int128@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = (result[1] << *a2) | (*result >> 1 >> ~*a2);
  uint64_t v4 = *result << *a2;
  if ((*a2 & 0x40LL) != 0)
  {
    uint64_t v3 = *result << *a2;
    uint64_t v4 = 0LL;
  }

  *a3 = v4;
  a3[1] = v3;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int128( void *result, void *a2)
{
  uint64_t v2 = *result << *a2;
  if ((*a2 & 0x40LL) != 0) {
    uint64_t v3 = *result << *a2;
  }
  else {
    uint64_t v3 = (result[1] << *a2) | (*result >> 1 >> ~*a2);
  }
  if ((*a2 & 0x40LL) != 0) {
    uint64_t v2 = 0LL;
  }
  *uint64_t result = v2;
  result[1] = v3;
  return result;
}

_OWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = (*a2 * *result) >> 64;
  *a3 = *(void *)a2 * *(void *)result;
  a3[1] = v3;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int128( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t Mirror.subjectType.getter()
{
  return *(void *)v0;
}

unint64_t *Mirror.children.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain(*(unint64_t **)(v4 + 8), a2, a3, a4);
}

void Mirror.displayStyle.getter(_BYTE *a1@<X8>)
{
  *a1 = *(_BYTE *)(v1 + 16);
}

double (*static Mirror._superclassIterator<A>(_:_:)( uint64_t a1, uint64_t a2, swift *a3))@<D0>(uint64_t a1@<X8>)
{
  uint64_t v5 = *((void *)a3 - 1);
  uint64_t v6 = *(void *)(v5 + 64);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *v8;
  int v9 = (unint64_t *)v8[1];
  if (swift_isClassType(v11)) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0LL;
  }
  if (!v12) {
    return (double (*)@<D0>(uint64_t@<X8>))implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
  }
  unint64_t Superclass = _swift_class_getSuperclass(v12);
  if (!Superclass) {
    return (double (*)@<D0>(uint64_t@<X8>))implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
  }
  unint64_t v14 = Superclass;
  if (v10)
  {
    if (v10 == 1) {
      return (double (*)@<D0>(uint64_t@<X8>))implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
    }
    (*(void (**)(char *, uint64_t, swift *))(v5 + 16))( (char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a1,  a3);
    uint64_t v20 = *(unsigned __int8 *)(v5 + 80);
    uint64_t v21 = (v20 + 48) & ~v20;
    uint64_t v22 = (char *)swift_allocObject((uint64_t)&unk_189B89668, v21 + v6, v20 | 7);
    *((void *)v22 + 2) = a3;
    *((void *)v22 + 3) = v10;
    *((void *)v22 + 4) = v9;
    *((void *)v22 + 5) = v14;
    (*(void (**)(char *, char *, swift *))(v5 + 32))(&v22[v21], v7, a3);
    swift_retain(v9, v23, v24, v25);
    return (double (*)@<D0>(uint64_t@<X8>))partial apply for closure #2 in static Mirror._superclassIterator<A>(_:_:);
  }

  else
  {
    (*(void (**)(char *, uint64_t, swift *))(v5 + 16))( (char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a1,  a3);
    uint64_t v16 = *(unsigned __int8 *)(v5 + 80);
    uint64_t v17 = (v16 + 24) & ~v16;
    unint64_t v18 = (v6 + v17 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v19 = (char *)swift_allocObject((uint64_t)&unk_189B89690, v18 + 8, v16 | 7);
    *((void *)v19 + 2) = a3;
    (*(void (**)(char *, char *, swift *))(v5 + 32))(&v19[v17], v7, a3);
    *(void *)&v19[v18] = v14;
    return partial apply for closure #1 in static Mirror._superclassIterator<A>(_:_:);
  }

uint64_t closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = a4 + 2;
  *a4 = 0LL;
  a4[1] = 0LL;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  a4[5] = AssociatedTypeWitness;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v6);
  return (*(uint64_t (**)(void *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( boxed_opaque_existential_0Tm,  a1,  AssociatedTypeWitness);
}

uint64_t closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)@<X0>( uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = a2 + 2;
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  outlined init with copy of Any((uint64_t)(a1 + 2), (uint64_t)v12);
  *a2 = v6;
  a2[1] = v5;
  outlined init with copy of Any(v4, (uint64_t)v11);
  outlined init with take of Any(v11, v3);
  swift_bridgeObjectRetain(v5, v7, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

double implicit closure #1 in static Mirror._superclassIterator<A>(_:_:)@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *(_OWORD *)((char *)a1 + 25) = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

unint64_t *protocol witness for CustomReflectable.customMirror.getter in conformance Mirror._Dummy@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v5 = *(unint64_t **)(v4 + 8);
  char v6 = *(_BYTE *)(v4 + 16);
  uint64_t v7 = *(void *)(v4 + 24);
  uint64_t v8 = *(unint64_t **)(v4 + 32);
  char v9 = *(_BYTE *)(v4 + 40);
  *(void *)a4 = *(void *)v4;
  *(void *)(a4 + 8) = v5;
  *(_BYTE *)(a4 + 16) = v6;
  *(void *)(a4 + 24) = v7;
  *(void *)(a4 + 32) = v8;
  *(_BYTE *)(a4 + 40) = v9;
  swift_retain(v5, a1, a2, a3);
  return swift_retain(v8, v10, v11, v12);
}

uint64_t Mirror.descendant(_:_:)@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v7 = *v3;
  char v6 = (unint64_t *)v3[1];
  char v8 = *((_BYTE *)v3 + 16);
  uint64_t v10 = v3[3];
  char v9 = (unint64_t *)v3[4];
  char v11 = *((_BYTE *)v3 + 40);
  uint64_t v108 = &type metadata for Mirror._Dummy;
  uint64_t v12 = swift_allocObject((uint64_t)&unk_189B78410, 0x39uLL, 7uLL);
  *(void *)&__int128 v107 = v12;
  v12[2] = v7;
  uint64_t v12[3] = v6;
  *((_BYTE *)v12 + 32) = v8;
  v12[5] = v10;
  v12[6] = v9;
  *((_BYTE *)v12 + 56) = v11;
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<MirrorPath>);
  inited = swift_initStackObject(v13, v106);
  *((_OWORD *)inited + 1) = xmmword_1817FFC60;
  outlined init with copy of MirrorPath(a1, (uint64_t)(inited + 4));
  *(void *)&__int128 v99 = inited;
  swift_retain(v6, v15, v16, v17);
  swift_retain(v9, v18, v19, v20);
  swift_bridgeObjectRetain(a2, v21, v22, v23);
  specialized Array.append<A>(contentsOf:)( a2,  &demangling cache variable for type metadata for _ContiguousArrayStorage<MirrorPath>,  &demangling cache variable for type metadata for MirrorPath);
  uint64_t v24 = (uint64_t)inited;
  uint64_t v96 = inited[2];
  if (!v96)
  {
LABEL_32:
    swift_bridgeObjectRelease(v24);
    outlined init with copy of Any((uint64_t)&v107, (uint64_t)a3);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v107);
  }

  unint64_t v25 = 0LL;
  uint64_t v95 = v99 + 32;
  uint64_t v94 = v99;
  while (2)
  {
    if (v25 >= *(void *)(v24 + 16)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }
    outlined init with copy of MirrorPath(v95 + 40 * v25, (uint64_t)v105);
    outlined init with take of MirrorPath(v105, (uint64_t)v104);
    outlined init with copy of Any((uint64_t)&v107, (uint64_t)v103);
    outlined init with copy of Any((uint64_t)v103, (uint64_t)v102);
    uint64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
    if (swift_dynamicCast((char *)&v99, v102, (swift *)byte_189B8D218, v26, 6uLL))
    {
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v103);
      outlined init with take of MirrorPath(&v99, (uint64_t)v98);
      uint64_t v28 = *(void *)&v98[32];
      uint64_t v27 = *(void *)&v98[24];
      __swift_project_boxed_opaque_existential_0Tm(v98, *(uint64_t *)&v98[24]);
      (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v28 + 8))(&v99, v27, v28);
      uint64_t v29 = (unint64_t *)*((void *)&v99 + 1);
      uint64_t v30 = v101;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v98);
    }

    else
    {
      *(void *)&__int128 v101 = 0LL;
      __int128 v99 = 0u;
      __int128 v100 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v99,  &demangling cache variable for type metadata for CustomReflectable?);
      memset(v98, 0, 41);
      Mirror.init(internalReflecting:subjectType:customAncestor:)(v103, 0LL, (uint64_t)v98, (uint64_t)&v99);
      uint64_t v29 = (unint64_t *)*((void *)&v99 + 1);
      uint64_t v30 = v101;
    }

    swift_release(v30);
    outlined init with copy of MirrorPath((uint64_t)v104, (uint64_t)&v99);
    uint64_t v31 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for MirrorPath);
    unint64_t v97 = v25;
    if ((swift_dynamicCast(v98, (uint64_t *)&v99, v31, (const char *)&type metadata for String, 6uLL) & 1) == 0)
    {
      outlined init with copy of MirrorPath((uint64_t)v104, (uint64_t)&v99);
      if (!swift_dynamicCast(v98, (uint64_t *)&v99, v31, (const char *)&type metadata for Int, 6uLL))
      {
        swift_release((uint64_t)v29);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Someone added a conformance to MirrorPath; that privilege is reserved to the standard library",
          93LL,
          2,
          "Swift/Mirror.swift",
          18LL,
          2,
          0x1CBuLL,
          0);
      }

      __swift_destroy_boxed_opaque_existential_1Tm(v104);
      uint64_t v55 = *(void *)v98;
      uint64_t v57 = (void *)v29[2];
      unint64_t v56 = v29[3];
      uint64_t v58 = (void *)v29[4];
      unint64_t v59 = v29[5];
      char v60 = *(uint64_t (**)(void *, unint64_t, uint64_t, void *, unint64_t))(*v29 + 288);
      swift_retain(v29, v61, v62, v63);
      swift_unknownObjectRetain(v57, v64, v65, v66);
      swift_unknownObjectRetain(v58, v67, v68, v69);
      uint64_t v36 = (void *)v60(v57, v56, v55, v58, v59);
      unint64_t v37 = v70;
      swift_unknownObjectRelease(v57);
      swift_unknownObjectRelease(v58);
      swift_release((uint64_t)v29);
      if (!v36)
      {
        uint64_t v36 = (void *)v29[4];
        unint64_t v37 = v29[5];
        swift_unknownObjectRetain(v36, v71, v72, v73);
      }

      goto LABEL_29;
    }

    __int128 v35 = *(_OWORD *)v98;
    uint64_t v36 = (void *)v29[2];
    unint64_t v37 = v29[3];
    swift_unknownObjectRetain(v36, v32, v33, v34);
LABEL_9:
    uint64_t v38 = *(uint64_t (**)(unint64_t, unint64_t))(v37 + 8);
    while (1)
    {
      unint64_t v39 = v29[4];
      unint64_t v40 = v29[5];
      unint64_t ObjectType = swift_getObjectType((unint64_t)v36);
      uint64_t v42 = v38(ObjectType, v37);
      unint64_t v43 = swift_getObjectType(v39);
      if (v42 != (*(uint64_t (**)(unint64_t, unint64_t))(v40 + 8))(v43, v40))
      {
        swift_release((uint64_t)v29);
LABEL_36:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Base index types differ",  23LL,  2,  "Swift/ExistentialCollection.swift",  33LL,  2,  0x747uLL,  0);
      }

      unint64_t v44 = swift_getObjectType((unint64_t)v36);
      if (((*(uint64_t (**)(unint64_t, unint64_t, unint64_t, unint64_t))(v37 + 24))( v39,  v40,  v44,  v37) & 1) != 0)
      {
        swift_bridgeObjectRelease(*((uint64_t *)&v35 + 1));
        __swift_destroy_boxed_opaque_existential_1Tm(v104);
        swift_unknownObjectRelease(v36);
        uint64_t v36 = (void *)v29[4];
        unint64_t v37 = v29[5];
        swift_unknownObjectRetain(v36, v74, v75, v76);
        goto LABEL_28;
      }

      (*(void (**)(__int128 *__return_ptr, void *, unint64_t))(*v29 + 256))(&v99, v36, v37);
      *(_OWORD *)uint64_t v98 = v99;
      *(_OWORD *)&v98[16] = v100;
      *(_OWORD *)&v98[32] = v101;
      if (!*((void *)&v99 + 1))
      {
LABEL_18:
        outlined destroy of _HasContiguousBytes?( (uint64_t)v98,  &demangling cache variable for type metadata for (label: String?, value: Any));
        goto LABEL_20;
      }

      if ((~*((void *)&v99 + 1) & 0x6000000000000000LL) == 0
        && (*((void *)&v35 + 1) & 0x2000000000000000LL) != 0
        && (*((void *)&v35 + 1) & 0x4000000000000000LL) != 0)
      {
        goto LABEL_18;
      }

      char v45 = _stringCompareInternal(_:_:expecting:)( *(uint64_t *)v98,  *((unint64_t *)&v99 + 1),  v35,  *((unint64_t *)&v35 + 1),  0);
      outlined destroy of _HasContiguousBytes?( (uint64_t)v98,  &demangling cache variable for type metadata for (label: String?, value: Any));
      if ((v45 & 1) != 0) {
        goto LABEL_27;
      }
LABEL_20:
      int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull((unint64_t)v36);
      unint64_t v50 = *v29;
      if (!isUniquelyReferenced_nonNull)
      {
        uint64_t v53 = (*(uint64_t (**)(void *, unint64_t))(v50 + 264))(v36, v37);
        unint64_t v37 = v54;
        swift_unknownObjectRelease(v36);
        uint64_t v36 = (void *)v53;
        goto LABEL_9;
      }

      uint64_t v51 = *(void (**)(id, unint64_t))(v50 + 272);
      id v52 = swift_unknownObjectRetain(v36, v47, v48, v49);
      v51(v52, v37);
      swift_unknownObjectRelease(v36);
    }

    outlined destroy of _HasContiguousBytes?( (uint64_t)v98,  &demangling cache variable for type metadata for (label: String?, value: Any));
LABEL_27:
    swift_bridgeObjectRelease(*((uint64_t *)&v35 + 1));
    __swift_destroy_boxed_opaque_existential_1Tm(v104);
LABEL_28:
    uint64_t v24 = v94;
LABEL_29:
    char v77 = (void *)v29[4];
    unint64_t v78 = v29[5];
    unint64_t v79 = swift_getObjectType((unint64_t)v36);
    uint64_t v80 = *(uint64_t (**)(unint64_t, unint64_t))(v37 + 8);
    swift_unknownObjectRetain(v77, v81, v82, v83);
    uint64_t v84 = v80(v79, v37);
    unint64_t v85 = swift_getObjectType((unint64_t)v77);
    unint64_t v86 = swift_getObjectType((unint64_t)v36);
    unint64_t v87 = *(uint64_t (**)(void *, unint64_t, unint64_t, unint64_t))(v37 + 24);
    swift_unknownObjectRetain(v36, v88, v89, v90);
    char v91 = v87(v77, v78, v86, v37);
    swift_unknownObjectRelease(v77);
    swift_unknownObjectRelease(v36);
    if ((v91 & 1) == 0)
    {
      unint64_t v25 = v97 + 1;
      (*(void (**)(__int128 *__return_ptr, void *, unint64_t))(*v29 + 256))(&v99, v36, v37);
      swift_release((uint64_t)v29);
      swift_unknownObjectRelease(v36);
      swift_bridgeObjectRelease(*((uint64_t *)&v99 + 1));
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v107);
      outlined init with take of Any(&v100, &v107);
      if (v97 + 1 == v96) {
        goto LABEL_32;
      }
      continue;
    }

    break;
  }

  swift_bridgeObjectRelease(v24);
  swift_release((uint64_t)v29);
  swift_unknownObjectRelease(v36);
  *a3 = 0u;
  a3[1] = 0u;
  return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v107);
}

uint64_t String.init<A>(describing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v5;
}

{
  void v6[2];
  v6[0] = 0LL;
  v6[1] = 0xE000000000000000LL;
  (*(void (**)(void *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(a3 + 8))( v6,  &type metadata for String,  &protocol witness table for String,  a2,  a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v6[0];
}

{
  uint64_t v5;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  return v5;
}

uint64_t Mirror.description.getter()
{
  unint64_t v2 = *v1;
  unint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(13LL);
  unint64_t v5 = (unint64_t)v4;
  v334._uint64_t countAndFlagsBits = v3;
  v334._unint64_t object = v4;
  Swift::String v8 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Mirror for ", 0xBuLL, 1);
  uint64_t countAndFlagsBits = v8._countAndFlagsBits;
  unint64_t object = v8._object;
  uint64_t v11 = HIBYTE(v5) & 0xF;
  uint64_t v12 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000LL) != 0) {
    uint64_t v13 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v13 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v13 && (v3 & ~v5 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v5);
    Swift::String v334 = v8;
    goto LABEL_90;
  }

  uint64_t v331 = v2;
  uint64_t v14 = (uint64_t)v8._object & 0x2000000000000000LL;
  uint64_t v15 = ((unint64_t)v8._object >> 56) & 0xF;
  if ((v5 & 0x2000000000000000LL) != 0 && v14)
  {
    unint64_t v0 = v15 + v11;
    if ((unint64_t)(v15 + v11) <= 0xF)
    {
      if (v15)
      {
        char v65 = 0;
        unint64_t v66 = 0LL;
        unint64_t v67 = v5;
        do
        {
          unint64_t v68 = v11 + v66;
          unint64_t v69 = v66 + 1;
          if (v66 >= 8) {
            unint64_t v70 = (unint64_t)v8._object;
          }
          else {
            unint64_t v70 = v8._countAndFlagsBits;
          }
          unint64_t v71 = v70 >> (v65 & 0x38);
          char v72 = (8 * v11 + v65) & 0x38;
          uint64_t v73 = (-255LL << v72) - 1;
          unint64_t v74 = (unint64_t)v71 << v72;
          unint64_t v75 = v74 | v73 & v67;
          unint64_t v76 = v74 | v73 & v3;
          if (v68 < 8) {
            unint64_t v3 = v76;
          }
          else {
            unint64_t v67 = v75;
          }
          v65 += 8;
          unint64_t v66 = v69;
        }

        while (v15 != v69);
      }

      else
      {
        unint64_t v67 = v5;
      }

      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      unint64_t v82 = 0xA000000000000000LL;
      if (!(v3 & 0x8080808080808080LL | v67 & 0x80808080808080LL)) {
        unint64_t v82 = 0xE000000000000000LL;
      }
      uint64_t v64 = (void *)(v82 & 0xFF00000000000000LL | (v0 << 56) | v67 & 0xFFFFFFFFFFFFFFLL);
LABEL_88:
      v334._uint64_t countAndFlagsBits = v3;
      v334._unint64_t object = v64;
      goto LABEL_89;
    }

    uint64_t v14 = 1LL;
  }

  if (v14) {
    uint64_t v16 = ((unint64_t)v8._object >> 56) & 0xF;
  }
  else {
    uint64_t v16 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n((uint64_t)v8._object, 2LL, v6, v7);
  uint64_t v330 = v16;
  if (((uint64_t)v8._object & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n((uint64_t)v8._object, 4LL, v17, v18);
    if ((v5 & 0x1000000000000000LL) == 0) {
      goto LABEL_15;
    }
LABEL_274:
    Swift::Int v313 = String.UTF8View._foreignCount()();
    Swift::Int v22 = v313 + v16;
    if (!__OFADD__(v313, v16)) {
      goto LABEL_16;
    }
LABEL_276:
    __break(1u);
    goto LABEL_277;
  }

  swift_bridgeObjectRetain_n((uint64_t)v8._object, 5LL, v17, v18);
  v309._Swift::UInt64 rawBits = 1LL;
  v310._Swift::UInt64 rawBits = (v16 << 16) | 1;
  v311._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v309, v310, v8._countAndFlagsBits, (unint64_t)v8._object);
  if (v311._rawBits < 0x10000) {
    v311._rawBits |= 3;
  }
  uint64_t v16 = specialized Collection.count.getter(v311, v312, v8._countAndFlagsBits, (unint64_t)v8._object);
  swift_bridgeObjectRelease((uint64_t)v8._object);
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_274;
  }
LABEL_15:
  BOOL v21 = __OFADD__(v13, v16);
  Swift::Int v22 = v13 + v16;
  if (v21) {
    goto LABEL_276;
  }
LABEL_16:
  unint64_t v23 = v3 & ~v5;
  if ((v23 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v22 > 15) {
      goto LABEL_24;
    }
    if ((v5 & 0x2000000000000000LL) == 0)
    {
LABEL_46:
      swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
      if ((v5 & 0x1000000000000000LL) == 0)
      {
        if ((v3 & 0x1000000000000000LL) != 0)
        {
          unint64_t v39 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          unint64_t v39 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v5);
          uint64_t v12 = v36;
        }

        uint64_t v40 = v330;
        swift_bridgeObjectRetain(v5, v36, v37, v38);
        closure #1 in _StringGuts._convertedToSmall()(v39, v12, &v332);
        swift_bridgeObjectRelease(v5);
        unint64_t v3 = v332;
        unint64_t v41 = v333;
        goto LABEL_53;
      }

      unint64_t v3 = _StringGuts._foreignConvertedToSmall()(v3, v5);
      unint64_t v41 = v324;
LABEL_52:
      uint64_t v40 = v330;
LABEL_53:
      v42._Swift::UInt64 rawBits = (v40 << 16) | 1;
      v43._Swift::UInt64 rawBits = 1LL;
      v44._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v43, v42, v8._countAndFlagsBits, (unint64_t)v8._object);
      if (v44._rawBits < 0x10000) {
        v44._rawBits |= 3;
      }
      unint64_t v46 = specialized String.init(_:)(v44, v45, v8._countAndFlagsBits, (unint64_t)v8._object);
      unint64_t v48 = v47;
      swift_bridgeObjectRelease((uint64_t)v8._object);
      if ((v48 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(v48);
      }

      else if ((v48 & 0x1000000000000000LL) != 0)
      {
        unint64_t v46 = _StringGuts._foreignConvertedToSmall()(v46, v48);
        unint64_t v329 = v328;
        swift_bridgeObjectRelease(v48);
        unint64_t v48 = v329;
      }

      else
      {
        if ((v46 & 0x1000000000000000LL) != 0)
        {
          v322 = (unsigned __int8 *)((v48 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v323 = v46 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v322 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v46, v48);
        }

        closure #1 in _StringGuts._convertedToSmall()(v322, v323, &v332);
        swift_bridgeObjectRelease(v48);
        unint64_t v46 = v332;
        unint64_t v48 = v333;
      }

      uint64_t v49 = HIBYTE(v41) & 0xF;
      uint64_t v50 = HIBYTE(v48) & 0xF;
      uint64_t v51 = v50 + v49;
      if (v50)
      {
        char v52 = 0;
        unint64_t v53 = 0LL;
        do
        {
          unint64_t v54 = v49 + v53;
          unint64_t v55 = v53 + 1;
          if (v53 >= 8) {
            unint64_t v56 = v48;
          }
          else {
            unint64_t v56 = v46;
          }
          unint64_t v57 = v56 >> (v52 & 0x38);
          char v58 = (8 * v49 + v52) & 0x38;
          uint64_t v59 = (-255LL << v58) - 1;
          unint64_t v60 = (unint64_t)v57 << v58;
          unint64_t v61 = v60 | v59 & v41;
          unint64_t v62 = v60 | v59 & v3;
          if (v54 < 8) {
            unint64_t v3 = v62;
          }
          else {
            unint64_t v41 = v61;
          }
          v52 += 8;
          unint64_t v53 = v55;
        }

        while (v50 != v55);
      }

      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      unint64_t v63 = 0xA000000000000000LL;
      if (!(v3 & 0x8080808080808080LL | v41 & 0x80808080808080LL)) {
        unint64_t v63 = 0xE000000000000000LL;
      }
      uint64_t v64 = (void *)(v63 & 0xFF00000000000000LL | (v51 << 56) | v41 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_88;
    }

    goto LABEL_51;
  }

  int64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  if ((v25 & 1) != 0) {
    goto LABEL_302;
  }
  if (v22 > 15) {
    goto LABEL_24;
  }
  if ((v5 & 0x2000000000000000LL) != 0)
  {
LABEL_51:
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
    unint64_t v41 = v5;
    goto LABEL_52;
  }

  if (v24 < v16) {
    goto LABEL_46;
  }
LABEL_24:
  int64_t v26 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  BOOL v29 = (v27 & 1) == 0 && v26 >= v16;
  if ((v23 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v29)
    {
LABEL_41:
      _StringGuts.grow(_:)(v22);
      goto LABEL_42;
    }

LABEL_306:
    swift_errorRelease(object);
    __break(1u);
    do
    {
      swift_errorRelease(object);
      swift_bridgeObjectRelease(v0);
      __break(1u);
LABEL_308:
      uint64_t v284 = v331;
LABEL_244:
      char v285 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v284, (uint64_t)v270, v268);
      uint64_t v270 = &v334;
      _StringGuts.appendInPlace(_:isASCII:)(v285, v286, countAndFlagsBits < 0);
    }

    while (object);
LABEL_245:
    swift_bridgeObjectRelease_n(v0, 2LL);
  }

  if ((v5 & ~v0 & 0x2000000000000000LL) == 0) {
    goto LABEL_284;
  }
LABEL_258:
  if (!swift_isUniquelyReferenced_nonNull_native(v0 & 0xFFFFFFFFFFFFFFFLL)) {
    goto LABEL_284;
  }
  unint64_t v289 = _StringGuts.nativeUnusedCapacity.getter(v5, v0);
  if ((v290 & 1) != 0) {
    goto LABEL_302;
  }
  if (v268 > 15 || (v289 & 0x8000000000000000LL) == 0) {
    goto LABEL_285;
  }
LABEL_262:
  swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
  swift_bridgeObjectRetain(v0, v291, v292, v293);
  unint64_t v294 = _StringGuts._convertedToSmall()(v5, v0);
  unint64_t v296 = v295;
  swift_bridgeObjectRelease(v0);
  v297._Swift::UInt64 rawBits = 1LL;
  v298._Swift::UInt64 rawBits = 1LL;
  v299._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v297, v298, 0LL, 0xE000000000000000LL);
  if (v299._rawBits < 0x10000) {
    v299._rawBits |= 3;
  }
  unint64_t v301 = specialized String.init(_:)(v299, v300, 0LL, 0xE000000000000000LL);
  unint64_t v303 = v302;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  unint64_t v304 = _StringGuts._convertedToSmall()(v301, v303);
  unint64_t v306 = v305;
  swift_bridgeObjectRelease(v303);
  unint64_t v307 = specialized _SmallString.init(_:appending:)(v294, v296, v304, v306);
  if ((v308 & 1) != 0)
  {
LABEL_301:
    unint64_t v327 = 266LL;
    goto LABEL_303;
  }

  unint64_t v5 = v307;
  swift_bridgeObjectRelease(v0);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  return v5;
}

uint64_t Mirror.customMirror.getter@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 v6 = v4[1];
  __int128 v8 = *v4;
  v9[0] = v6;
  *(_OWORD *)((char *)v9 + 9) = *(__int128 *)((char *)v4 + 25);
  outlined retain of Mirror((uint64_t)&v8, a1, a2, a3);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)( &v8,  (uint64_t)&_swiftEmptyArrayStorage,  8,  0LL,  0LL,  a4);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Mirror@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 v6 = v4[1];
  __int128 v8 = *v4;
  v9[0] = v6;
  *(_OWORD *)((char *)v9 + 9) = *(__int128 *)((char *)v4 + 25);
  outlined retain of Mirror((uint64_t)&v8, a1, a2, a3);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)( &v8,  (uint64_t)&_swiftEmptyArrayStorage,  8,  0LL,  0LL,  a4);
}

uint64_t static CommandLine._argc.getter()
{
  return static CommandLine._argc;
}

uint64_t static CommandLine._argc.setter(uint64_t result)
{
  static CommandLine._argc = result;
  return result;
}

uint64_t (*static CommandLine._argc.modify())()
{
  return EnumeratedSequence._base.modify;
}

char **one-time initialization function for _unsafeArgv()
{
  double result = _swift_stdlib_getUnsafeArgvArgc(&static CommandLine._argc);
  static CommandLine._unsafeArgv = (uint64_t)result;
  return result;
}

void static CommandLine._unsafeArgv.setter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once( &one-time initialization token for _unsafeArgv,  (dispatch_function_t)one-time initialization function for _unsafeArgv,  a3);
  }
  static CommandLine._unsafeArgv = a1;
}

uint64_t (*static CommandLine._unsafeArgv.modify(uint64_t a1, uint64_t a2, void *a3))()
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once( &one-time initialization token for _unsafeArgv,  (dispatch_function_t)one-time initialization function for _unsafeArgv,  a3);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t static CommandLine.argc.getter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once( &one-time initialization token for _unsafeArgv,  (dispatch_function_t)one-time initialization function for _unsafeArgv,  a3);
  }
  uint64_t result = 0LL;
  while (*(void *)(static CommandLine._unsafeArgv + 8 * result))
  {
    if (++result == 0x80000000LL)
    {
      __break(1u);
      return result;
    }
  }

  return result;
}

_DWORD *static Int32.+= infix(_:_:)(_DWORD *result, int a2)
{
  if (__OFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

uint64_t static CommandLine._unsafeArgv.getter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once( &one-time initialization token for _unsafeArgv,  (dispatch_function_t)one-time initialization function for _unsafeArgv,  a3);
  }
  return static CommandLine._unsafeArgv;
}

__objc2_class **one-time initialization function for _arguments(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1) {
    swift_once( &one-time initialization token for _unsafeArgv,  (dispatch_function_t)one-time initialization function for _unsafeArgv,  a3);
  }
  uint64_t v3 = 0LL;
  while (*(void *)(static CommandLine._unsafeArgv + 8 * v3))
  {
    if (++v3 == 0x80000000LL)
    {
      __break(1u);
      break;
    }
  }

  uint64_t result = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg549_ss11CommandLineO10_argumentsSaySSGvpZfiSSSiXEfU_Tf1cn_n( 0LL,  v3);
  static CommandLine._arguments = (uint64_t)result;
  return result;
}

unint64_t static CommandLine.arguments.getter(uint64_t a1, uint64_t a2, void *a3, char *a4)
{
  if (one-time initialization token for _arguments != -1) {
    swift_once( &one-time initialization token for _arguments,  (dispatch_function_t)one-time initialization function for _arguments,  a3);
  }
  return swift_bridgeObjectRetain(static CommandLine._arguments, a2, (uint64_t)a3, a4);
}

void static CommandLine.arguments.setter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _arguments != -1) {
    swift_once( &one-time initialization token for _arguments,  (dispatch_function_t)one-time initialization function for _arguments,  a3);
  }
  uint64_t v4 = static CommandLine._arguments;
  static CommandLine._arguments = a1;
  swift_bridgeObjectRelease(v4);
}

void (*static CommandLine.arguments.modify( void *a1, uint64_t a2, void *a3, char *a4))(uint64_t *a1)
{
  if (one-time initialization token for _arguments != -1) {
    swift_once( &one-time initialization token for _arguments,  (dispatch_function_t)one-time initialization function for _arguments,  a3);
  }
  unint64_t v5 = static CommandLine._arguments;
  *a1 = static CommandLine._arguments;
  swift_bridgeObjectRetain(v5, a2, (uint64_t)a3, a4);
  return static CommandLine.arguments.modify;
}

void static CommandLine.arguments.modify(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = static CommandLine._arguments;
  static CommandLine._arguments = v1;
  swift_bridgeObjectRelease(v2);
}

void _SliceBuffer.owner.setter(void *a1)
{
  *uint64_t v1 = a1;
}

uint64_t (*_SliceBuffer.owner.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer.subscriptBaseAddress.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _SliceBuffer.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t _SliceBuffer.startIndex.setter(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t (*_SliceBuffer.startIndex.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer.endIndexAndFlags.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t _SliceBuffer.endIndexAndFlags.setter(uint64_t result)
{
  *(void *)(v1 + 24) = result;
  return result;
}

uint64_t (*_SliceBuffer.endIndexAndFlags.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer._hasNativeBuffer.getter(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  return a4 & 1;
}

__objc2_class **_SliceBuffer.nativeBuffer.getter(void *a1)
{
  uint64_t v2 = type metadata accessor for __ContiguousArrayStorageBase();
  id v6 = swift_unknownObjectRetain(a1, v3, v4, v5);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v6, v2);
  if (!result)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptyArrayStorage;
  }

  return result;
}

Swift::Bool __swiftcall _SliceBuffer.isUniquelyReferenced()()
{
  return swift_isUniquelyReferenced_nonNull(*v0);
}

uint64_t _SliceBuffer.endIndex.setter(uint64_t result)
{
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  *(void *)(v1 + 24) = *(void *)(v1 + 24) & 1LL | (2 * result);
  return result;
}

__objc2_class **_SliceBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:)(uint64_t a1, uint64_t a2)
{
  unint64_t v6 = v2[2];
  unint64_t v5 = v2[3];
  unint64_t v7 = (v5 >> 1) - v6;
  if (__OFSUB__(v5 >> 1, v6))
  {
    __break(1u);
    goto LABEL_23;
  }

  unint64_t v8 = v2[1];
  if ((v5 & 1) == 0) {
    goto LABEL_8;
  }
  char v9 = (void *)*v2;
  uint64_t v10 = type metadata accessor for __ContiguousArrayStorageBase();
  id v14 = swift_unknownObjectRetain(v9, v11, v12, v13);
  uint64_t v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v14, v10);
  if (!v15)
  {
    swift_unknownObjectRelease(v9);
    uint64_t v15 = &_swiftEmptyArrayStorage;
  }

  uint64_t v16 = *(void *)(*(void *)(a2 + 16) - 8LL);
  uint64_t v17 = v15[2];
  if ((__objc2_class **)(v8 + *(void *)(v16 + 72) * v6 + *(void *)(v16 + 72) * v7) != (__objc2_class **)((char *)v15 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80)) + *(void *)(v16 + 72) * (void)v17))
  {
    swift_release((uint64_t)v15);
LABEL_8:
    int64_t v18 = v7;
    goto LABEL_10;
  }

  unint64_t v19 = (unint64_t)v15[3];
  swift_release((uint64_t)v15);
  unint64_t v20 = (v19 >> 1) - (void)v17;
  BOOL v21 = __OFADD__(v7, v20);
  int64_t v18 = v7 + v20;
  if (v21)
  {
    __break(1u);
    goto LABEL_27;
  }

char *_SliceBuffer._copyContents(initializing:)@<X0>( char *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  if (a2 < 1) {
    goto LABEL_15;
  }
  if (__OFSUB__(a6 >> 1, a5))
  {
    __break(1u);
    goto LABEL_18;
  }

  else {
    uint64_t v13 = (a6 >> 1) - a5;
  }
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x112uLL,  0);
  }
  if (v13 < 0) {
LABEL_18:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  uint64_t v14 = *(void *)(*(void *)(a7 - 8) + 72LL);
  uint64_t v15 = (char *)(a4 + v14 * a5);
  uint64_t v16 = v14 * v13;
  uint64_t v17 = &result[v16];
  int64_t v18 = &v15[v16];
  if (v15 < v17 && v18 > result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  uint64_t result = swift_arrayInitWithCopy(result, v15, v13, a7);
  uint64_t v20 = a5 + v13;
  if (__OFADD__(a5, v13))
  {
    __break(1u);
LABEL_15:
    uint64_t v13 = 0LL;
    uint64_t v20 = a5;
  }

  *a8 = a3;
  a8[1] = a4;
  a8[2] = a5;
  a8[3] = a6;
  a8[4] = v20;
  a8[5] = v13;
  return result;
}

uint64_t key path getter for _SliceBuffer.count : <A>_SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = _SliceBuffer.count.getter(a1, a2, *(void *)(a1 + 16), *(void *)(a1 + 24));
  *a3 = result;
  return result;
}

__objc2_class **key path setter for _SliceBuffer.count : <A>_SliceBuffer<A>( __objc2_class ***a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  type metadata accessor for _SliceBuffer(0LL, *(void *)(a4 + a3 - 8), a3, a4);
  return _SliceBuffer.count.setter(v4);
}

__objc2_class **(*_SliceBuffer.count.modify( __objc2_class **(*result)(__objc2_class **result, char a2), uint64_t a2))(__objc2_class **result, char a2)
{
  *((void *)result + 1) = a2;
  *((void *)result + 2) = v2;
  uint64_t v3 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24) >> 1;
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5)
  {
    __break(1u);
  }

  else
  {
    *(void *)uint64_t result = v6;
    return _SliceBuffer.count.modify;
  }

  return result;
}

__objc2_class **_SliceBuffer.count.modify(__objc2_class **result, char a2)
{
  uint64_t v2 = result[2];
  if ((a2 & 1) != 0) {
    return _SliceBuffer.count.setter(&(*result)->isa);
  }
  cache = v2->cache;
  unint64_t v4 = (unint64_t)v2->vtable >> 1;
  BOOL v5 = __OFSUB__(v4, cache);
  unint64_t v6 = v4 - (void)cache;
  if (v5)
  {
    __break(1u);
    goto LABEL_13;
  }

  unint64_t v7 = (char *)*result - v6;
  if (__OFSUB__(*result, v6))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  if (!v7) {
    return result;
  }
  isa = v2->isa;
  uint64_t v9 = type metadata accessor for __ContiguousArrayStorageBase();
  id v13 = swift_unknownObjectRetain(isa, v10, v11, v12);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v13, v9);
  if (!result)
  {
    swift_unknownObjectRelease(isa);
    uint64_t result = &_swiftEmptyArrayStorage;
  }

  uint64_t v14 = result[2];
  BOOL v5 = __OFADD__(v14, v7);
  uint64_t v15 = (__objc2_class *)&v7[(void)v14];
  if (v5) {
    goto LABEL_14;
  }
  result[2] = v15;
  swift_release((uint64_t)result);
  uint64_t result = (__objc2_class **)&v7[v4];
  if (__OFADD__(v4, v7))
  {
LABEL_15:
    __break(1u);
    return result;
  }

  return (__objc2_class **)_SliceBuffer.endIndex.setter((uint64_t)result);
}

uint64_t _SliceBuffer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + *(void *)(*(void *)(a3 - 8) + 72LL) * a1,  a3);
}

uint64_t key path getter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return _SliceBuffer.subscript.getter(*a2, *(void *)(a1 + 8), *(uint64_t *)((char *)a2 + a3 - 8), a4);
}

uint64_t key path setter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v7 = (char *)&v15 - v6;
  uint64_t v9 = *v8;
  (*(void (**)(char *))(v10 + 16))((char *)&v15 - v6);
  return _SliceBuffer.subscript.setter((uint64_t)v7, v9, v11, *(void *)(a2 + 8), v12, v13, v5);
}

uint64_t _SliceBuffer.subscript.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a7 - 8) + 40LL))( a4 + *(void *)(*(void *)(a7 - 8) + 72LL) * a2,  a1,  a7);
}

void (*_SliceBuffer.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7))(uint64_t a1)
{
  uint64_t v11 = malloc(0x30uLL);
  *a1 = v11;
  *uint64_t v11 = a2;
  v11[1] = a4;
  uint64_t v12 = *(void *)(a7 - 8);
  _OWORD v11[2] = a7;
  v11[3] = v12;
  uint64_t v13 = malloc(*(void *)(v12 + 64));
  uint64_t v14 = *(void *)(v12 + 72);
  v11[4] = v13;
  v11[5] = v14;
  (*(void (**)(void))(v12 + 16))();
  return _SliceBuffer.subscript.modify;
}

void _SliceBuffer.subscript.modify(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 32LL);
  (*(void (**)(void, void *, void))(*(void *)(*(void *)a1 + 24LL) + 40LL))( *(void *)(*(void *)a1 + 8LL) + **(void **)a1 * *(void *)(*(void *)a1 + 40LL),  v2,  *(void *)(*(void *)a1 + 16LL));
  free(v2);
  free(v1);
}

id key path getter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v4 = (void *)specialized _SliceBuffer.subscript.getter(*a2, a2[1], *a1);
  *a3 = v4;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

void key path setter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A( void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *a1;
  type metadata accessor for _SliceBuffer(0LL, *(void *)(a4 + a3 - 8), a3, a4);
  swift_unknownObjectRetain(v4, v5, v6, v7);
  specialized _SliceBuffer.subscript.setter();
}

void _SliceBuffer.subscript.setter()
{
}

void (*_SliceBuffer.subscript.modify( void *a1, uint64_t a2, uint64_t a3, char *a4))(id *a1, char a2)
{
  uint64_t v8 = *(void *)(v4 + 8);
  id v9 = swift_unknownObjectRetain(*(id *)v4, a2, a3, a4);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v9, v8, a2, a3);
  *a1 = v10;
  a1[1] = v11;
  a1[2] = v12;
  a1[3] = v13;
  return _SliceBuffer.subscript.modify;
}

void _SliceBuffer.subscript.modify(id *a1, char a2)
{
}

void _ArrayBuffer.subscript.modify( id *a1, char a2, const char *a3, uint64_t a4, unint64_t a5)
{
  if ((a2 & 1) == 0) {
    swift_unknownObjectRelease(*a1);
  }
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  a3,  a4,  2,  a5,  0);
}

unint64_t key path getter for _SliceBuffer.endIndex : <A>_SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t result = _SliceBuffer.endIndex.getter(a1, a2, a3, *(void *)(a1 + 24));
  *a4 = result;
  return result;
}

uint64_t key path setter for _SliceBuffer.endIndex : <A>_SliceBuffer<A>(uint64_t *a1)
{
  return _SliceBuffer.endIndex.setter(*a1);
}

uint64_t (*_SliceBuffer.endIndex.modify(void *a1, uint64_t a2))(uint64_t *a1, char a2)
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 24) >> 1;
  return _SliceBuffer.endIndex.modify;
}

uint64_t _SliceBuffer.endIndex.modify(uint64_t *a1, char a2)
{
  uint64_t result = *a1;
  if ((a2 & 1) != 0) {
    return _SliceBuffer.endIndex.setter(result);
  }
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  *(void *)(a1[2] + 24) = *(void *)(a1[2] + 24) & 1LL | (2 * result);
  return result;
}

uint64_t _SliceBuffer.withUnsafeMutableBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3[2];
  uint64_t v5 = v3[3] >> 1;
  if (__OFSUB__(v5, v4))
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  if (v5 - v4 < 0) {
    goto LABEL_5;
  }
  return a1(v3[1] + *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 72LL) * v4);
}

double protocol witness for _ArrayBufferProtocol.init() in conformance _SliceBuffer<A>@<D0>(uint64_t a1@<X8>)
{
  *(void *)a1 = &_swiftEmptyArrayStorage;
  *(void *)(a1 + 8) = v2;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_1817FFC90;
  return result;
}

uint64_t protocol witness for _ArrayBufferProtocol.init(_buffer:shiftedToStartIndex:) in conformance _SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = _SliceBuffer.init(_buffer:shiftedToStartIndex:)(a1, a2);
  *a3 = result;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return result;
}

char *protocol witness for _ArrayBufferProtocol._copyContents(subRange:initializing:) in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return _SliceBuffer._copyContents(subRange:initializing:)( a1,  a2,  a3,  *(void **)v7,  *(void *)(v7 + 8),  a6,  a7,  *(void *)(a4 + 16));
}

__objc2_class **protocol witness for _ArrayBufferProtocol.requestNativeBuffer() in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2)
{
  return _SliceBuffer.requestNativeBuffer()(*(void **)v2, a2, *(void *)(v2 + 16), *(void *)(v2 + 24));
}

uint64_t protocol witness for _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:) in conformance _SliceBuffer<A>( uint64_t a1, char *a2, uint64_t a3, void *a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  return _SliceBuffer.replaceSubrange<A>(_:with:elementsOf:)(a1, a2, a3, a4, a7, a5, a6);
}

id protocol witness for _ArrayBufferProtocol.subscript.getter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)specialized _SliceBuffer.subscript.getter(a1, a2, *v2);
  return swift_unknownObjectRetain(v3, v4, v5, v6);
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:) in conformance _SliceBuffer<A>( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.withUnsafeBufferPointer<A>(_:)( a1,  a2,  a3,  *(void *)(v4 + 8),  *(void *)(v4 + 16),  *(void *)(v4 + 24),  *(void *)(a4 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:) in conformance _SliceBuffer<A>( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.withUnsafeMutableBufferPointer<A>(_:)(a1, a2, a4);
}

__objc2_class **(*protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>( __objc2_class **(*result)(__objc2_class **result, char a2), uint64_t a2))(__objc2_class **result, char a2)
{
  *((void *)result + 1) = v2;
  *((void *)result + 2) = a2;
  uint64_t v3 = *(void *)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24) >> 1;
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5)
  {
    __break(1u);
  }

  else
  {
    *(void *)uint64_t result = v6;
    return protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>;
  }

  return result;
}

__objc2_class **protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>( __objc2_class **result, char a2)
{
  if ((a2 & 1) != 0) {
    return _SliceBuffer.count.setter(&(*result)->isa);
  }
  uint64_t v2 = result[1];
  cache = v2->cache;
  unint64_t v4 = (unint64_t)v2->vtable >> 1;
  BOOL v5 = __OFSUB__(v4, cache);
  unint64_t v6 = v4 - (void)cache;
  if (v5)
  {
    __break(1u);
    goto LABEL_13;
  }

  uint64_t v7 = (char *)*result - v6;
  if (__OFSUB__(*result, v6))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  if (!v7) {
    return result;
  }
  isa = v2->isa;
  uint64_t v9 = type metadata accessor for __ContiguousArrayStorageBase();
  id v13 = swift_unknownObjectRetain(isa, v10, v11, v12);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v13, v9);
  if (!result)
  {
    swift_unknownObjectRelease(isa);
    uint64_t result = &_swiftEmptyArrayStorage;
  }

  uint64_t v14 = result[2];
  BOOL v5 = __OFADD__(v14, v7);
  uint64_t v15 = (__objc2_class *)&v7[(void)v14];
  if (v5) {
    goto LABEL_14;
  }
  result[2] = v15;
  swift_release((uint64_t)result);
  uint64_t result = (__objc2_class **)&v7[v4];
  if (__OFADD__(v4, v7))
  {
LABEL_15:
    __break(1u);
    return result;
  }

  return (__objc2_class **)_SliceBuffer.endIndex.setter((uint64_t)result);
}

uint64_t protocol witness for _ArrayBufferProtocol.capacity.getter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( a1,  a2,  _SliceBuffer.capacity.getter);
}

id protocol witness for _ArrayBufferProtocol.owner.getter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_unknownObjectRetain(*v4, a2, a3, a4);
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddress.getter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.firstElementAddress.getter( a1,  *(void *)(v4 + 8),  *(void *)(v4 + 16),  a4,  *(void *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddressIfContiguous.getter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.firstElementAddressIfContiguous.getter( a1,  *(void *)(v4 + 8),  *(void *)(v4 + 16),  a4,  *(void *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.subscriptBaseAddress.getter in conformance _SliceBuffer<A>()
{
  return *(void *)(v0 + 8);
}

uint64_t protocol witness for _ArrayBufferProtocol.identity.getter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ArraySlice._baseAddress.getter(a1, *(void *)(v4 + 8), *(void *)(v4 + 16), a4, *(void *)(a1 + 16));
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return _SliceBuffer.subscript.setter(a1, *a2, a3, *(void *)(v6 + 8), a5, a6, *(void *)(a3 + 16));
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>( void *a1, uint64_t *a2, uint64_t a3))(void **a1)
{
  uint64_t v7 = malloc(0x30uLL);
  *a1 = v7;
  uint64_t v8 = *(void *)(a3 + 16);
  *uint64_t v7 = v8;
  uint64_t v9 = *(void *)(v8 - 8);
  v7[1] = v9;
  uint64_t v10 = malloc(*(void *)(v9 + 64));
  uint64_t v11 = *a2;
  v7[2] = v10;
  v7[3] = v11;
  uint64_t v12 = *(void *)(v9 + 72);
  v7[4] = *(void *)(v3 + 8);
  v7[5] = v12;
  (*(void (**)(void))(v9 + 16))();
  return protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)(*a1)[2];
  (*(void (**)(void, void *, void))((*a1)[1] + 40LL))((*a1)[4] + (*a1)[3] * (*a1)[5], v2, **a1);
  free(v2);
  free(v1);
}

void protocol witness for MutableCollection.subscript.setter in conformance _SliceBuffer<A>()
{
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>( void *a1, uint64_t *a2, uint64_t a3, char *a4))(id *a1, char a2)
{
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = *(void *)(v4 + 8);
  id v9 = swift_unknownObjectRetain(*(id *)v4, (uint64_t)a2, a3, a4);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v9, v8, v6, v7);
  *a1 = v10;
  a1[1] = v11;
  a1[2] = v12;
  a1[3] = v13;
  return protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>( id *a1, char a2)
{
}

void protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>( id *a1, char a2, const char *a3, unint64_t a4)
{
  if ((a2 & 1) == 0) {
    swift_unknownObjectRelease(*a1);
  }
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0x6C706D6920746F6ELL,  0xEF6465746E656D65LL,  a3,  23LL,  2,  a4,  0);
}

void *protocol witness for MutableCollection.partition(by:) in conformance _SliceBuffer<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _SliceBuffer<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

unint64_t protocol witness for Collection.endIndex.getter in conformance _SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t result = _SliceBuffer.endIndex.getter(a1, a2, a3, *(void *)(v4 + 24));
  *a4 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _SliceBuffer<A>( void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = _SliceBuffer.subscript.read(v7, *a2, *v3, v3[1], v3[2], v3[3], *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*_SliceBuffer.subscript.read( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7))()
{
  uint64_t v7 = *(void *)(a7 - 8);
  *a1 = a7;
  a1[1] = v7;
  a1[2] = malloc(*(void *)(v7 + 64));
  (*(void (**)(void))(v7 + 16))();
  return _ArrayBuffer.subscript.read;
}

id protocol witness for Collection.subscript.getter in conformance _SliceBuffer<A>@<X0>( uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (void *)specialized _SliceBuffer.subscript.getter(*a1, a1[1], *v2);
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

uint64_t protocol witness for Collection.indices.getter in conformance _SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.count.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  return _SliceBuffer.count.getter(a1, a2, *(void *)(v2 + 16), *(void *)(v2 + 24));
}

uint64_t protocol witness for Collection.index(after:) in conformance _SliceBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance _SliceBuffer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>( void *a1, uint64_t a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  unint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _SliceBuffer<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( a1,  a2,  (uint64_t (*)(void, void, void, void, void))_SliceBuffer._copyToContiguousArray());
}

__objc2_class **_SliceBuffer._copyToContiguousArray()( void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  if ((a4 & 1) == 0)
  {
    uint64_t v10 = (a4 >> 1) - a3;
    if (!__OFSUB__(a4 >> 1, a3))
    {
      if (v10 > 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }

    __break(1u);
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }

  uint64_t v24 = type metadata accessor for __ContiguousArrayStorageBase();
  id v28 = swift_unknownObjectRetain(a1, v25, v26, v27);
  uint64_t v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v28, v24);
  if (!v15)
  {
    swift_unknownObjectRelease(a1);
    uint64_t v15 = &_swiftEmptyArrayStorage;
  }

  BOOL v29 = __OFSUB__(a4 >> 1, a3);
  uint64_t v10 = (a4 >> 1) - a3;
  if (v29) {
    goto LABEL_20;
  }
  if ((__objc2_class *)v10 != v15[2])
  {
    swift_release((uint64_t)v15);
    if (v10 > 0)
    {
LABEL_4:
      uint64_t v11 = getContiguousArrayStorageType<A>(for:)((uint64_t)a5, a5);
      uint64_t v12 = *(a5 - 1);
      uint64_t v13 = *(void *)(v12 + 72);
      uint64_t v14 = *(unsigned __int8 *)(v12 + 80);
      uint64_t v15 = (__objc2_class **)swift_allocObject( v11,  ((v14 + *(unsigned int *)(v11 + 48)) & ~v14) + v13 * v10,  v14 | *(unsigned __int16 *)(v11 + 52));
      size_t v16 = _swift_stdlib_malloc_size(v15);
      if (v13)
      {
        unint64_t v20 = (v14 + 32) & ~v14;
        if (v16 - v20 == 0x8000000000000000LL && v13 == -1) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
        }
        uint64_t v22 = (uint64_t)(v16 - v20) / v13;
        swift_retain((unint64_t *)v15, v17, v18, v19);
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
        void v15[2] = (__objc2_class *)v10;
        v15[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v22));
        swift_unknownObjectRelease(a1);
        swift_release((uint64_t)v15);
        goto LABEL_17;
      }

__n128 protocol witness for Sequence._copyContents(initializing:) in conformance _SliceBuffer<A>( uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = v9;
  __n128 result = (__n128)v8[1];
  *(_OWORD *)a1 = v8[0];
  *(__n128 *)(a1 + 16) = result;
  *(void *)(a1 + 32) = v6;
  return result;
}

Swift::Int __swiftcall StaticBigInt.signum()()
{
  if ((v0 & 1) != 0) {
    return -1LL;
  }
  else {
    return (v0 & 0xFFFFFFFFFFFFFF00LL) != 256;
  }
}

uint64_t StaticBigInt._isNegative.getter(uint64_t a1, char a2)
{
  return a2 & 1;
}

unint64_t StaticBigInt.bitWidth.getter(uint64_t a1, unint64_t a2)
{
  return a2 >> 8;
}

uint64_t StaticBigInt.subscript.getter(unint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((a1 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/StaticBigInt.swift",  24LL,  2,  0x7BuLL,  0);
  }
  else {
    return *(void *)(a2 + 8 * a1);
  }
}

uint64_t StaticBigInt.debugDescription.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if ((a2 & 1) != 0) {
    uint64_t v2 = 7876653LL;
  }
  else {
    uint64_t v2 = 7876651LL;
  }
  unint64_t v3 = ((a2 >> 8) + 2) >> 2;
  uint64_t v4 = v3 + 3;
  unint64_t v5 = a2 >> 9;
  if (a2 >> 9 >= 0x19)
  {
    unint64_t v13 = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( v3 + 3,  v3 + 3,  a2 & 1,  a1,  a2);
    unint64_t v17 = v6;
  }

  else
  {
    uint8x16_t v25 = (uint8x16_t)xmmword_1817FFDF0;
    closure #1 in StaticBigInt.debugDescription.getter((uint64_t)&v25, v4, v4, a2 & 1, a1, a2);
    char v9 = 8;
    if (v4 >= 8) {
      char v10 = 8;
    }
    else {
      char v10 = v4;
    }
    if (v4 > 8) {
      char v9 = v4;
    }
    unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v10) & 0x38);
    unint64_t v12 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v9) & 0x38);
    if (v5 <= 0xA) {
      unint64_t v12 = 0LL;
    }
    unint64_t v13 = v25.i64[0] & v11;
    uint64_t v14 = v25.i64[1] & v12;
    BOOL v15 = ((v14 | v25.i64[0] & v11) & 0x8080808080808080LL) == 0;
    unint64_t v16 = 0xA000000000000000LL;
    if (v15) {
      unint64_t v16 = 0xE000000000000000LL;
    }
    unint64_t v17 = v16 | (v4 << 56) | v14;
    if ((v17 & 0x4000000000000000LL) == 0)
    {
      v25.i64[0] = v13;
      v25.i64[1] = v14 & 0xFFFFFFFFFFFFFFLL;
      closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v25, HIBYTE(v17) & 0xF, v24);
      unint64_t v13 = v24[0];
      unint64_t v17 = v24[1];
    }
  }

  v25.i64[0] = v13;
  v25.i64[1] = v17;
  swift_bridgeObjectRetain(v17, v6, v7, v8);
  Swift::UInt64 v18 = specialized Collection.firstIndex(where:)(v13, v17);
  char v20 = v19;
  swift_bridgeObjectRelease(v17);
  if ((v20 & 1) != 0)
  {
    swift_bridgeObjectRelease(0xE300000000000000LL);
    swift_bridgeObjectRelease(v17);
    return 813183019LL;
  }

  else
  {
    v21._Swift::UInt64 rawBits = 15LL;
    v22._Swift::UInt64 rawBits = v18;
    specialized String.replaceSubrange<A>(_:with:)(v21, v22, v2, 0xE300000000000000LL);
    swift_bridgeObjectRelease(0xE300000000000000LL);
    return v25.i64[0];
  }

uint64_t closure #1 in StaticBigInt.debugDescription.getter( uint64_t a1, uint64_t a2, uint64_t a3, BOOL a4, uint64_t a5, unint64_t a6)
{
  uint64_t v8 = specialized Collection.prefix(_:)(a3, a1, a2);
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  specialized Slice.initialize<A>(repeating:)((void *)0x30, v8, v9, v11);
  unint64_t v13 = 0LL;
  unint64_t v14 = a6 >> 8;
  BOOL v15 = a4;
  while (v13 < v14)
  {
    unint64_t v17 = -(uint64_t)(a6 & 1);
    if ((v13 & 0x7FFFFFFFFFFFFFC0LL) < v14) {
      unint64_t v17 = *(void *)(a5 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL));
    }
    unint64_t v18 = v17 >> (v13 & 0x20);
    if (v15)
    {
      BOOL v19 = !a4;
      a4 = a4 && ~(_DWORD)v18 == -1;
      if (v19) {
        LODWORD(v18) = ~(_DWORD)v18;
      }
      else {
        LODWORD(v18) = -(int)v18;
      }
    }

    Swift::String v20 = _uint64ToString(_:radix:uppercase:)(v18, 16LL, 1);
    if (((uint64_t)v20._object & 0x1000000000000000LL) != 0)
    {
      unint64_t v21 = String.UTF8View._foreignCount()();
      if ((v21 & 0x8000000000000000LL) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a suffix of negative length from a collection",  56LL,  2,  "Swift/BidirectionalCollection.swift",  35LL,  2,  0x19BuLL,  0);
      }
    }

    else if (((uint64_t)v20._object & 0x2000000000000000LL) != 0)
    {
      unint64_t v21 = ((unint64_t)v20._object >> 56) & 0xF;
    }

    else
    {
      unint64_t v21 = v20._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }

    uint64_t v22 = v8 - v10;
    if (__OFSUB__(v8, v10))
    {
      unint64_t v28 = 271LL;
      goto LABEL_42;
    }

    uint64_t v23 = -(uint64_t)v21;
    if (v22 > 0 || (uint64_t v24 = v8, v22 <= v23))
    {
      uint64_t v24 = v10 - v21;
      if (__OFADD__(v10, v23))
      {
LABEL_39:
        unint64_t v28 = 279LL;
        goto LABEL_42;
      }
    }

    if (v10 < v24) {
      goto LABEL_36;
    }
    if (v24 < v8)
    {
      unint64_t v28 = 571LL;
      goto LABEL_42;
    }

    if (v12) {
      uint8x16_t v25 = (char *)(v12 + v24);
    }
    else {
      uint8x16_t v25 = 0LL;
    }
    if (v10 - v24 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
    if (v10 != v24 && !v25) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
    }
    specialized UnsafeMutableBufferPointer.update<A>(fromContentsOf:)( v20._countAndFlagsBits,  (unint64_t)v20._object,  v25,  v10 - v24);
    swift_bridgeObjectRelease((uint64_t)v20._object);
    uint64_t v26 = v8;
    if ((unint64_t)(v22 + 7) >= 8)
    {
      uint64_t v26 = v10 - 8;
      if (__OFSUB__(v10, 8LL)) {
        goto LABEL_39;
      }
      if (v26 < v8) {
LABEL_36:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    v13 += 32LL;
    BOOL v16 = v10 < v26;
    uint64_t v10 = v26;
    if (v16)
    {
      unint64_t v28 = 572LL;
LABEL_42:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v28,  0);
    }
  }

  return a3;
}

void *specialized Slice.initialize<A>(repeating:)(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    unint64_t v5 = (void *)(a4 + a2);
  }
  else {
    unint64_t v5 = 0LL;
  }
  int64_t v6 = a3 - a2;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  if (v6)
  {
    if (!v5) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
    }
    return specialized UnsafeMutablePointer.initialize(repeating:count:)(result, v6, v5);
  }

  if (v5) {
    return specialized UnsafeMutablePointer.initialize(repeating:count:)(result, v6, v5);
  }
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.addingReportingOverflow(_:)(Swift::UInt32 a1)
{
  Swift::UInt32 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance StaticBigInt()
{
  return StaticBigInt.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t StaticBigInt.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  8,  0LL,  0LL,  a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance StaticBigInt@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( *v1,  v1[1],  8,  0LL,  0LL,  a1);
}

uint64_t UInt128._value.setter(uint64_t result, uint64_t a2)
{
  void *v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t (*UInt128._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t static UInt128.zero.getter()
{
  return 0LL;
}

uint64_t static UInt128.min.getter()
{
  return 0LL;
}

uint64_t static UInt128.max.getter()
{
  return -1LL;
}

uint64_t UInt128.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v69 = (char *)&v63 - v9;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v66 = (char *)&v63 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  char v72 = (char *)&v63 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v17 = (char *)&v63 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  Swift::String v20 = (char *)&v63 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v63 - v22;
  unint64_t v74 = 64LL;
  uint64_t v24 = *(void (**)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  unint64_t v27 = lazy protocol witness table accessor for type Int and conformance Int(v21, v25, v26);
  unint64_t v71 = a1;
  v24(a1, &v74, &type metadata for Int, v27, a2, a3);
  unint64_t v68 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v68(a2, a3);
  unint64_t v28 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
  unint64_t v70 = v23;
  v28(v20, v23, a2);
  unint64_t v64 = AssociatedTypeWitness;
  uint64_t v65 = v6;
  uint64_t v67 = v10;
  if ((a1 & 1) != 0)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v30 = v69;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v30, a2, v6);
    char v31 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v20,  v17,  a2);
    uint64_t v32 = *(void (**)(char *, uint64_t))(v10 + 8);
    v32(v17, a2);
    uint64_t v73 = v32;
    v32(v20, a2);
    uint64_t v33 = v70;
    int64_t v34 = v71;
    if ((v31 & 1) != 0) {
      goto LABEL_17;
    }
  }

  else
  {
    uint64_t v73 = *(void (**)(char *, uint64_t))(v10 + 8);
    v73(v20, a2);
    uint64_t v33 = v70;
    int64_t v34 = v71;
    uint64_t v30 = v69;
  }

  unint64_t v71 = v17;
  size_t v35 = v34;
  uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v37 = v36(a2, a3);
  uint64_t v38 = v72;
  v28(v72, v33, a2);
  if (v37 <= 63)
  {
    uint64_t v39 = v73;
    v73(v38, a2);
    int64_t v34 = v35;
    goto LABEL_7;
  }

  unint64_t v74 = -1LL;
  char v42 = v68(a2, a3);
  uint64_t v43 = v36(a2, a3);
  int64_t v34 = v35;
  if ((v42 & 1) != 0)
  {
    if (v43 < 65)
    {
      uint64_t v46 = v64;
      uint64_t v47 = v65;
      unint64_t v48 = swift_getAssociatedConformanceWitness( v65,  a2,  v64,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v48 + 8))(&unk_18180BE68, 256LL, v46, v48);
      uint64_t v49 = v30;
      uint64_t v50 = v71;
      (*(void (**)(char *, uint64_t, uint64_t))(v47 + 24))(v49, a2, v47);
      uint64_t v51 = v72;
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 40LL))( v72,  v50,  a2);
      uint64_t v39 = v73;
      v73(v50, a2);
      unint64_t v52 = v74;
      unint64_t v53 = v66;
      (*(void (**)(char *, char *, uint64_t))(v67 + 32))(v66, v51, a2);
      if ((v46 & 1) != 0)
      {
        unint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v39(v53, a2);
        if (v52 < v54) {
          goto LABEL_17;
        }
      }

      else
      {
        v39(v53, a2);
      }

      goto LABEL_7;
    }

uint64_t UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized UInt128.init<A>(_:));
}

{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized UInt128.init<A>(_:));
}

uint64_t UInt128.init<A>(clamping:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  uint64_t v9 = UInt128.init<A>(exactly:)(v8, a2, a3);
  if ((v10 & 1) != 0)
  {
    (*(void (**)(uint64_t))(*(void *)(*(void *)(a3 + 24) + 8LL) + 16LL))(a2);
    char v12 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( a1,  v8,  a2);
    uint64_t v13 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
    v13(a1, a2);
    v13((uint64_t)v8, a2);
    return (v12 & 1) - 1LL;
  }

  else
  {
    uint64_t v11 = v9;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }

  return v11;
}

  ;
}

uint64_t *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt128@<X0>( uint64_t *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 9 > 0x40 || (a2 & 1) != 0)
  {
    uint64_t v4 = 0LL;
LABEL_7:
    *a3 = v4;
    a3[1] = 0LL;
    return result;
  }

  uint64_t v4 = *result;
  if (a2 >> 9 <= 0x20) {
    goto LABEL_7;
  }
  uint64_t v5 = result[1];
  *a3 = v4;
  a3[1] = v5;
  return result;
}

uint64_t UInt128.init<A>(exactly:)(char *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v50 = a3;
  uint64_t v5 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)v41 - v8;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v7);
  uint64_t v49 = (char *)v41 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)v41 - v14;
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)v41 - v17;
  MEMORY[0x1895F8858](v16);
  Swift::String v20 = (char *)v41 - v19;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
  uint64_t v44 = *(void (**)(unint64_t, double))(AssociatedConformanceWitness + 8);
  unint64_t v45 = AssociatedConformanceWitness;
  v44(AssociatedTypeWitness, 5.42101086e-20);
  uint64_t v22 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 24);
  uint64_t v47 = v9;
  uint64_t v48 = v5;
  uint64_t v43 = v22;
  v22(v9, a2, v5);
  unint64_t v23 = v50;
  uint64_t v24 = *(void *)(v50 + 16);
  uint64_t v25 = *(void *)(*(void *)(v24 + 16) + 8LL);
  uint64_t v26 = *(void (**)(char *, char *, uint64_t, uint64_t))(v25 + 64);
  uint64_t v51 = a1;
  uint64_t v46 = v25;
  char v42 = v26;
  ((void (*)(char *, char *, uint64_t))v26)(a1, v15, a2);
  unint64_t v27 = *(void (**)(char *, uint64_t))(v10 + 8);
  v27(v15, a2);
  LOBYTE(v52) = 4;
  unint64_t v28 = *(void (**)(uint64_t *, uint64_t, uint64_t))(v24 + 304);
  uint64_t v29 = v24;
  unint64_t v30 = v23;
  v28(&v52, a2, v29);
  v27(v18, a2);
  uint64_t v31 = (*(uint64_t (**)(char *, char *, uint64_t))(v10 + 16))(v18, v20, a2);
  unint64_t v34 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v31, v32, v33);
  FixedWidthInteger.init<A>(exactly:)((uint64_t)v18, (uint64_t)&type metadata for UInt64, a2, v34, v23, (uint64_t)&v52);
  if (v53 == 1)
  {
    v27(v51, a2);
    v27(v20, a2);
    return 0LL;
  }

  v41[1] = v52;
  if (v52)
  {
    size_t v35 = v47;
    v41[0] = v34;
    ((void (*)(unint64_t, unint64_t, double))v44)(AssociatedTypeWitness, v45, 1.84467441e19);
    v43(v35, a2, v48);
    uint64_t v36 = v46;
    v42(v15, v20, a2, v46);
    v27(v15, a2);
    v27(v20, a2);
    uint64_t v37 = *(void (**)(uint64_t, char *, uint64_t))(*(void *)(v36 + 8) + 40LL);
    uint64_t v38 = (uint64_t)v49;
    uint64_t v39 = v51;
    v37((uint64_t)v51, v18, a2);
    unint64_t v34 = v41[0];
    v27(v39, a2);
    v27(v18, a2);
  }

  else
  {
    v27(v20, a2);
    uint64_t v38 = (uint64_t)v49;
    (*(void (**)(char *, char *, uint64_t))(v10 + 32))(v49, v51, a2);
  }

  FixedWidthInteger.init<A>(exactly:)(v38, (uint64_t)&type metadata for UInt64, a2, v34, v30, (uint64_t)&v52);
  if (v53 == 1) {
    return 0LL;
  }
  return v52;
}

BOOL static UInt128.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

BOOL static UInt128.< infix(_:_:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return __PAIR128__(a2, a1) < __PAIR128__(a4, a3);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a2 < *a1;
}

void UInt128.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
}

Swift::Int UInt128.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance UInt128()
{
  return UInt128.hashValue.getter(*v0, v0[1]);
}

uint64_t UInt128.addingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t UInt128.subtractingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 - a1;
}

uint64_t UInt128.dividedReportingOverflow(by:)(uint64_t a1, uint64_t a2)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  return __udivti3();
}

uint64_t UInt128.remainderReportingOverflow(dividingBy:)(uint64_t a1, uint64_t a2)
{
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x11CuLL,  0);
  }
  return __umodti3();
}

uint64_t static UInt128.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = __CFADD__(a1, a3);
  uint64_t result = a1 + a3;
  if (__CFADD__(v4, a2) | __CFADD__(a4, v4 + a2)) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if ((v6 & 1) != 0) {
    __break(1u);
  }
  return result;
}

unint64_t static UInt128.- infix(_:_:)( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _BOOL1 v4 = a1 >= a3;
  unint64_t result = a1 - a3;
  if (!__CFSUB__(a2, a4, v4)) {
    __break(1u);
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt128@<X0>( void *result@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  __int128 v3 = *(_OWORD *)result + *(_OWORD *)a2;
  if (__CFADD__(__CFADD__(*result, *a2), result[1]) | __CFADD__(a2[1], *((void *)&v3 + 1))) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if ((v4 & 1) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt128( void *result, unint64_t *a2)
{
  unint64_t v2 = a2[1];
  __int128 v3 = *(_OWORD *)result + *a2;
  char v4 = __CFADD__(__CFADD__(*result, *a2), result[1]) | __CFADD__(v2, *((void *)&v3 + 1));
  unint64_t v5 = v2 + *((void *)&v3 + 1);
  if (v4) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if ((v6 & 1) != 0)
  {
    __break(1u);
  }

  else
  {
    *unint64_t result = v3;
    result[1] = v5;
  }

  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt128( _OWORD *result, _OWORD *a2)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

unint64_t static UInt128.* infix(_:_:)( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a2) {
    BOOL v4 = a4 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  char v7 = !v4 || (a2 * (unsigned __int128)a3) >> 64 != 0 || (a4 * (unsigned __int128)result) >> 64 != 0;
  if ((v7 & 1) != 0) {
    __break(1u);
  }
  else {
    result *= a3;
  }
  return result;
}

unint64_t *static UInt128.*= infix(_:_:)( unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  if (v4) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v8 = !v5 || (v4 * (unsigned __int128)a2) >> 64 != 0 || (a3 * (unsigned __int128)*result) >> 64 != 0;
  unint64_t v9 = a3 * v3 + v4 * a2;
  uint64_t v10 = (v3 * (unsigned __int128)a2) >> 64;
  BOOL v11 = __CFADD__(v10, v9);
  unint64_t v12 = v10 + v9;
  if (v11) {
    char v8 = 1;
  }
  if ((v8 & 1) != 0)
  {
    __break(1u);
  }

  else
  {
    *unint64_t result = v3 * a2;
    result[1] = v12;
  }

  return result;
}

uint64_t static UInt128./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  return __udivti3();
}

uint64_t static UInt128./= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  uint64_t result = __udivti3();
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t static UInt128.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x11CuLL,  0);
  }
  return __umodti3();
}

uint64_t static UInt128.%= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x11CuLL,  0);
  }
  uint64_t result = __umodti3();
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128( (uint64_t (*)(void))UInt128.init<A>(exactly:),  a1);
}

unint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance UInt128@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  unint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  if (v4) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  char v10 = !v7 || (v4 * (unsigned __int128)*a2) >> 64 != 0 || (v6 * (unsigned __int128)*result) >> 64 != 0;
  unint64_t v11 = v6 * v3 + v4 * v5;
  uint64_t v12 = (v3 * (unsigned __int128)v5) >> 64;
  BOOL v13 = __CFADD__(v12, v11);
  uint64_t v14 = v12 + v11;
  if (v13) {
    char v15 = 1;
  }
  else {
    char v15 = v10;
  }
  if ((v15 & 1) != 0)
  {
    __break(1u);
  }

  else
  {
    *a3 = v3 * v5;
    a3[1] = v14;
  }

  return result;
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt128( unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = a2[1];
  unint64_t v4 = *result;
  unint64_t v5 = result[1];
  if (v5) {
    BOOL v6 = v3 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  char v9 = !v6 || (v5 * (unsigned __int128)*a2) >> 64 != 0 || (v3 * (unsigned __int128)*result) >> 64 != 0;
  unint64_t v10 = v3 * v4 + v5 * v2;
  uint64_t v11 = (v4 * (unsigned __int128)v2) >> 64;
  BOOL v12 = __CFADD__(v11, v10);
  unint64_t v13 = v11 + v10;
  if (v12) {
    char v14 = 1;
  }
  else {
    char v14 = v9;
  }
  if ((v14 & 1) != 0)
  {
    __break(1u);
  }

  else
  {
    *uint64_t result = v4 * v2;
    result[1] = v13;
  }

  return result;
}

uint64_t *static UInt128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  unint64_t v2 = result[1];
  uint64_t v3 = ((2 * v2) << ~a2) | ((unint64_t)*result >> a2);
  uint64_t v4 = v2 >> a2;
  if ((a2 & 0x40) != 0)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0LL;
  }

  *uint64_t result = v3;
  result[1] = v4;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128( (uint64_t (*)(void))UInt128.init<A>(exactly:),  a1);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int128@<X0>( uint64_t (*a1)(void)@<X5>, uint64_t a2@<X8>)
{
  uint64_t result = a1();
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 16) = v5 & 1;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128( a1,  a2,  (uint64_t (*)(void))specialized UInt128.init<A>(_:),  a3);
}

{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128( a1,  a2,  (uint64_t (*)(void))specialized UInt128.init<A>(_:),  a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = UInt128.init<A>(clamping:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  return result;
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt128@<X0>( _OWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  if (*a1 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  uint64_t result = __udivti3();
  *a2 = result;
  a2[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt128( uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  uint64_t result = __udivti3();
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt128@<X0>( _OWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  if (*a1 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x11CuLL,  0);
  }
  uint64_t result = __umodti3();
  *a2 = result;
  a2[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt128( uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x11CuLL,  0);
  }
  uint64_t result = __umodti3();
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt128@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v114 = *(const char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v114,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v112 = (char *)&v109 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  char v15 = (char *)&v109 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v110 = (char *)&v109 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v118 = (char *)&v109 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v117 = (char *)&v109 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v111 = (char *)&v109 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v116 = (char *)&v109 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v120 = (char *)&v109 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v109 - v28;
  unint64_t v30 = a1[1];
  unint64_t v115 = *a1;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v122 = v31;
  if ((v32 & 1) != 0)
  {
    size_t v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v121(a3, a4);
    if (v33 >= 64)
    {
      int64_t v124 = -128LL;
      uint64_t v47 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v47(&v124, &type metadata for Int, v48, a3, a4);
      char v49 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      uint64_t v38 = a5;
      if ((v49 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      uint64_t v38 = a5;
      if (v36 < -128) {
        goto LABEL_24;
      }
    }
  }

  else
  {
    unint64_t v119 = v30;
    uint64_t v109 = a5;
    char v39 = v31(a3, a4);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v41 = v40(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v41 > 64)
      {
        size_t v121 = v40;
        int64_t v124 = -128LL;
        uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        v44(&v124, &type metadata for Int, v45, a3, a4);
        char v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
        uint64_t v38 = v109;
        unint64_t v30 = v119;
        if ((v46 & 1) != 0) {
          goto LABEL_24;
        }
        goto LABEL_18;
      }

      unint64_t v51 = AssociatedTypeWitness;
      uint64_t v52 = v114;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v54 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v51,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v52 + 3))(v54, a3, v52);
      LOBYTE(v51) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      unint64_t v55 = *(void (**)(char *, uint64_t))(v12 + 8);
      v55(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
      if ((v51 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
        uint64_t v56 = 0LL;
        uint64_t v57 = 0LL;
        uint64_t v38 = v109;
        goto LABEL_60;
      }

      size_t v121 = v40;
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
    }

    else
    {
      size_t v121 = v40;
      if (v41 >= 64)
      {
        uint64_t v38 = v109;
        unint64_t v30 = v119;
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    }

    uint64_t v38 = v109;
    unint64_t v30 = v119;
    if (v50 < -128) {
      goto LABEL_24;
    }
  }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt128( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v118 = a1;
  uint64_t v114 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v114,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v112 = (char *)&v109 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v109 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v110 = (char *)&v109 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v116 = (char *)&v109 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v115 = (char *)&v109 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v111 = (char *)&v109 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v109 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v117 = (char *)&v109 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v27 = (char *)&v109 - v26;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v29 = v28(a3, a4);
  unint64_t v119 = v28;
  if ((v29 & 1) != 0)
  {
    unint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v30(a3, a4);
    if (v31 >= 64)
    {
      int64_t v122 = -128LL;
      uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v42(&v122, &type metadata for Int, v43, a3, a4);
      LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v27,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      if (v34 < -128) {
        goto LABEL_28;
      }
    }
  }

  else
  {
    char v36 = v28(a3, a4);
    uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v37 = v120(a3, a4);
    if ((v36 & 1) != 0)
    {
      if (v37 > 64)
      {
        int64_t v122 = -128LL;
        uint64_t v40 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v41 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
        v40(&v122, &type metadata for Int, v41, a3, a4);
        LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v27,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
        uint64_t v28 = v119;
        unint64_t v30 = v120;
        goto LABEL_18;
      }

      unint64_t v46 = AssociatedTypeWitness;
      uint64_t v47 = v114;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v49 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v27,  a3);
      uint64_t v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v27, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_28;
      }

      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
      BOOL v45 = v51 < -128;
    }

    else
    {
      if (v37 >= 64)
      {
        uint64_t v28 = v119;
        unint64_t v30 = v120;
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      BOOL v45 = v44 < -128;
    }

    uint64_t v28 = v119;
    unint64_t v30 = v120;
    if (v45) {
      goto LABEL_28;
    }
  }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt128@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v114 = *(const char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v114,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v112 = (char *)&v109 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v109 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v110 = (char *)&v109 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v118 = (char *)&v109 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v117 = (char *)&v109 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v111 = (char *)&v109 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v116 = (char *)&v109 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v120 = (char *)&v109 - v27;
  MEMORY[0x1895F8858](v26);
  char v29 = (char *)&v109 - v28;
  unint64_t v30 = *a1;
  unint64_t v115 = a1[1];
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  int64_t v122 = v31;
  if ((v32 & 1) != 0)
  {
    uint64_t v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v121(a3, a4);
    if (v33 >= 64)
    {
      int64_t v124 = -128LL;
      uint64_t v47 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v47(&v124, &type metadata for Int, v48, a3, a4);
      char v49 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      uint64_t v38 = a5;
      if ((v49 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      uint64_t v38 = a5;
      if (v36 < -128) {
        goto LABEL_24;
      }
    }
  }

  else
  {
    unint64_t v119 = v30;
    uint64_t v109 = a5;
    char v39 = v31(a3, a4);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v41 = v40(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v41 > 64)
      {
        uint64_t v121 = v40;
        int64_t v124 = -128LL;
        uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        v44(&v124, &type metadata for Int, v45, a3, a4);
        char v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
        uint64_t v38 = v109;
        unint64_t v30 = v119;
        if ((v46 & 1) != 0) {
          goto LABEL_24;
        }
        goto LABEL_18;
      }

      unint64_t v51 = AssociatedTypeWitness;
      char v52 = v114;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v54 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v51,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v52 + 3))(v54, a3, v52);
      LOBYTE(v51) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t v55 = *(void (**)(char *, uint64_t))(v12 + 8);
      v55(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
      if ((v51 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
        uint64_t v56 = 0LL;
        uint64_t v57 = 0LL;
        uint64_t v38 = v109;
        goto LABEL_64;
      }

      uint64_t v121 = v40;
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
    }

    else
    {
      uint64_t v121 = v40;
      if (v41 >= 64)
      {
        uint64_t v38 = v109;
        unint64_t v30 = v119;
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    }

    uint64_t v38 = v109;
    unint64_t v30 = v119;
    if (v50 < -128) {
      goto LABEL_24;
    }
  }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt128( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v118 = a1;
  uint64_t v114 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v114,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v112 = (char *)&v109 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v109 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v110 = (char *)&v109 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v116 = (char *)&v109 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v115 = (char *)&v109 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v111 = (char *)&v109 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v109 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v117 = (char *)&v109 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v27 = (char *)&v109 - v26;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v29 = v28(a3, a4);
  unint64_t v119 = v28;
  if ((v29 & 1) != 0)
  {
    unint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v30(a3, a4);
    if (v31 >= 64)
    {
      int64_t v122 = -128LL;
      uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v42(&v122, &type metadata for Int, v43, a3, a4);
      LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v27,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      if (v34 < -128) {
        goto LABEL_28;
      }
    }
  }

  else
  {
    char v36 = v28(a3, a4);
    uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v37 = v120(a3, a4);
    if ((v36 & 1) != 0)
    {
      if (v37 > 64)
      {
        int64_t v122 = -128LL;
        uint64_t v40 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v41 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
        v40(&v122, &type metadata for Int, v41, a3, a4);
        LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v27,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
        uint64_t v28 = v119;
        unint64_t v30 = v120;
        goto LABEL_18;
      }

      unint64_t v46 = AssociatedTypeWitness;
      uint64_t v47 = v114;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v49 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v27,  a3);
      uint64_t v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v27, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_28;
      }

      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
      BOOL v45 = v51 < -128;
    }

    else
    {
      if (v37 >= 64)
      {
        uint64_t v28 = v119;
        unint64_t v30 = v120;
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      BOOL v45 = v44 < -128;
    }

    uint64_t v28 = v119;
    unint64_t v30 = v120;
    if (v45) {
      goto LABEL_28;
    }
  }

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt128( uint64_t *a1, _OWORD *a2, unint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt128(uint64_t *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

void protocol witness for BinaryInteger.signum() in conformance UInt128(void *a1@<X8>)
{
  *a1 = *v1 != 0LL;
  a1[1] = 0LL;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt128()
{
  return specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, *v0, v0[1]);
}

unint64_t *protocol witness for Strideable.distance(to:) in conformance UInt128@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  unint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  if (*(_OWORD *)result >= *(_OWORD *)v2)
  {
    BOOL v7 = v3 >= v6;
    unint64_t v9 = v3 - v6;
    if (!((v4 - (v5 + !v7)) | (v9 >> 63))) {
      goto LABEL_5;
    }
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Distance is not representable in Int",  36LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x64AuLL,  0);
  }

  BOOL v7 = v6 >= v3;
  unint64_t v8 = v6 - v3;
  if ((v5 - (v4 + !v7)) | (v8 >> 63)) {
    goto LABEL_6;
  }
  unint64_t v9 = -(uint64_t)v8;
LABEL_5:
  *a2 = v9;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt128@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v5 = *v2;
  unint64_t v4 = v2[1];
  if ((*result & 0x8000000000000000LL) == 0)
  {
    BOOL v6 = __CFADD__(v5, v3);
    v3 += v5;
    uint64_t v7 = v6;
    BOOL v6 = __CFADD__(v6, v4);
    v4 += v7;
    unint64_t v5 = v6;
    if ((v5 & 1) == 0) {
      goto LABEL_11;
    }
    __break(1u);
  }

  unint64_t v8 = -(uint64_t)v3;
  BOOL v6 = v5 >= v8;
  unint64_t v3 = v5 - v8;
  BOOL v9 = v6;
  BOOL v6 = v4 >= !v6;
  v4 -= !v9;
  char v10 = !v6;
  if ((v10 & 1) == 0)
  {
LABEL_11:
    *a2 = v3;
    a2[1] = v4;
    return result;
  }

  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt128( uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance Int128( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int128( uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, a4[1], *a5, a5[1], *a6);
}

uint64_t UInt128.Words.count.getter()
{
  return 2LL;
}

uint64_t UInt128.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t UInt128.Words.endIndex.getter()
{
  return 2LL;
}

uint64_t UInt128.Words.indices.getter()
{
  return 0LL;
}

Swift::Int __swiftcall UInt128.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1LL);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall UInt128.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1LL);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t UInt128.Words.subscript.getter(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x1F9uLL,  0);
  }
  v4[0] = a2;
  v4[1] = a3;
  return v4[a1];
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance UInt128.Words@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2);
  *a3 = result;
  return result;
}

unint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt128.Words@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3);
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance UInt128.Words( unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt128.Words( uint64_t *a1, unint64_t *a2))()
{
  *a1 = UInt128.Words.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt128.Words@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if ((*result & 0x8000000000000000LL) != 0 || (uint64_t v3 = result[1], v3 >= 3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  uint64_t v4 = *v2;
  uint64_t v5 = v2[1];
  *a2 = *result;
  a2[1] = v3;
  a2[2] = v4;
  a2[3] = v5;
  return result;
}

double protocol witness for Collection.indices.getter in conformance UInt128.Words@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = xmmword_1817FFFC0;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance UInt128.Words(void *a1@<X8>)
{
  uint64_t v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
  a1[2] = 0LL;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt128.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt128.Words( void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

uint64_t static UInt128.bitWidth.getter()
{
  return 128LL;
}

unint64_t UInt128.byteSwapped.getter(uint64_t a1, unint64_t a2)
{
  return bswap64(a2);
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt128(void *a1@<X8>)
{
  *a1 = -1LL;
  a1[1] = -1LL;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt128( _OWORD *a1, void *a2)
{
  __int128 v3 = *(_OWORD *)v2 + *(_OWORD *)a2;
  if (__CFADD__(__CFADD__(*v2, *a2), v2[1]) | __CFADD__(a2[1], *((void *)&v3 + 1))) {
    uint64_t v4 = 1LL;
  }
  else {
    uint64_t v4 = 0LL;
  }
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt128( _OWORD *a1, _OWORD *a2)
{
  BOOL v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt128( void *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  unint64_t v3 = a2[1];
  unint64_t v6 = *v2;
  unint64_t v5 = v2[1];
  if (v5) {
    BOOL v7 = v3 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  unsigned int v10 = !v7 || (v5 * (unsigned __int128)*a2) >> 64 != 0 || (v3 * (unsigned __int128)*v2) >> 64 != 0;
  unint64_t v11 = v3 * v6 + v5 * v4;
  uint64_t v12 = (v6 * (unsigned __int128)v4) >> 64;
  BOOL v13 = __CFADD__(v12, v11);
  uint64_t v14 = v12 + v11;
  if (v13) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = v10;
  }
  *a1 = v6 * v4;
  a1[1] = v14;
  return v15;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt128( uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  *a1 = __udivti3();
  a1[1] = v3;
  return 0LL;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt128( uint64_t *a1, _OWORD *a2)
{
  if (*a2 == 0LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x11CuLL,  0);
  }
  *a1 = __umodti3();
  a1[1] = v3;
  return 0LL;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt128( uint64_t *a1, _OWORD *a2, unint64_t *a3)
{
  uint64_t result = specialized FixedWidthInteger.multipliedFullWidth(by:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt128( uint64_t *a1, uint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t result = specialized UnsignedInteger<>.dividingFullWidth(_:)(a2, *a3, a3[1], *a4, a4[1], *v4, v4[1]);
  *a1 = result;
  a1[1] = v7;
  return result;
}

void *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt128@<X0>( void *result@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v3 = result[1];
  uint64_t v4 = ((2 * v3) << ~*a2) | (*result >> *a2);
  uint64_t v5 = v3 >> *a2;
  if ((*a2 & 0x40LL) != 0)
  {
    uint64_t v4 = v5;
    uint64_t v5 = 0LL;
  }

  *a3 = v4;
  a3[1] = v5;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt128( uint64_t *result, void *a2)
{
  unint64_t v2 = result[1];
  uint64_t v3 = (2 * v2) << ~*a2;
  uint64_t v4 = v2 >> *a2;
  if ((*a2 & 0x40LL) != 0) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v3 | ((unint64_t)*result >> *a2);
  }
  if ((*a2 & 0x40LL) != 0) {
    uint64_t v4 = 0LL;
  }
  *uint64_t result = v5;
  result[1] = v4;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt128( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int128( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v7)
  {
    swift_bridgeObjectRelease(a2);
    goto LABEL_10;
  }

  uint64_t v10 = a3();
  if ((v12 & 0x100) != 0)
  {
    uint64_t v13 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10LL, a4);
    uint64_t v14 = v16;
    char v18 = v17;
    swift_bridgeObjectRelease(a2);
    if ((v18 & 1) == 0) {
      goto LABEL_8;
    }
LABEL_10:
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    char v19 = 1;
    goto LABEL_11;
  }

  uint64_t v13 = v10;
  uint64_t v14 = v11;
  char v15 = v12;
  swift_bridgeObjectRelease(a2);
  if ((v15 & 1) != 0) {
    goto LABEL_10;
  }
LABEL_8:
  char v19 = 0;
LABEL_11:
  *(void *)a5 = v13;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = v19;
}

unint64_t *sequence<A>(first:next:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v29 = a2;
  unint64_t v30 = (unint64_t *)a3;
  uint64_t v8 = type metadata accessor for Optional((const char *)0xFF, a4, a3, a4);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v8, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  uint64_t v10 = *(TupleTypeMetadata2 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v13 = (char *)&v29 - v12;
  uint64_t v14 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  uint64_t v17 = *(void *)(a4 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))((char *)&v29 - v15, a1, a4);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v17 + 56))(v16, 0LL, 1LL, a4);
  uint64_t v18 = *((int *)TupleTypeMetadata2 + 12);
  (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v13, v16, v8);
  v13[v18] = 1;
  char v19 = (uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X8>))swift_allocObject( (uint64_t)&unk_189B78438,  0x28uLL,  7uLL);
  uint64_t v20 = v29;
  uint64_t v21 = v30;
  *((void *)v19 + 2) = a4;
  *((void *)v19 + 3) = v20;
  *((void *)v19 + 4) = v21;
  (*(void (**)(uint64_t, char *, unint64_t *))(v10 + 32))(a5, v13, TupleTypeMetadata2);
  uint64_t v23 = type metadata accessor for UnfoldSequence(0LL, a4, (uint64_t)TupleTypeMetadata2, v22);
  *(_BYTE *)(a5 + *(int *)(v23 + 40)) = 0;
  uint64_t v24 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(a5 + *(int *)(v23 + 36));
  char *v24 = partial apply for closure #1 in sequence<A>(first:next:);
  v24[1] = v19;
  return swift_retain(v21, v25, v26, v27);
}

uint64_t closure #1 in sequence<A>(first:next:)@<X0>( uint64_t a1@<X0>, void (*a2)(char *)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v29 = a3;
  unint64_t v30 = a2;
  uint64_t v32 = a5;
  uint64_t v31 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v28 = (char *)&v27 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = type metadata accessor for Optional((const char *)0xFF, v9, v8, v9);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v10, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  uint64_t v12 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v14 = (char *)&v27 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v27 - v16;
  uint64_t v18 = *(int *)(v15 + 48);
  uint64_t v19 = *(void *)(v10 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))((char *)&v27 - v16, a1, v10);
  int v20 = *(unsigned __int8 *)(a1 + v18);
  v17[v18] = v20;
  uint64_t v21 = *((int *)TupleTypeMetadata2 + 12);
  uint64_t v22 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  v22(v14, v17, v10);
  v14[v21] = v20;
  if (v20 == 1)
  {
    uint64_t result = ((uint64_t (*)(uint64_t, char *, uint64_t))v22)(v32, v14, v10);
    *(_BYTE *)(a1 + v18) = 0;
  }

  else
  {
    uint64_t v25 = v31;
    uint64_t v24 = v32;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v31 + 48))(v14, 1LL, a4) == 1)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 56))(v24, 1LL, 1LL, a4);
    }

    else
    {
      uint64_t v26 = v28;
      (*(void (**)(char *, char *, uint64_t))(v25 + 32))(v28, v14, a4);
      v30(v26);
      (*(void (**)(char *, uint64_t))(v25 + 8))(v26, a4);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v19 + 24))(a1, v24, v10);
    }
  }

  return result;
}

unint64_t *sequence<A, B>(state:next:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = type metadata accessor for UnfoldSequence(0LL, a4, a5, v11);
  *(_BYTE *)(a6 + *(int *)(v12 + 40)) = 0;
  uint64_t v13 = (void *)(a6 + *(int *)(v12 + 36));
  *uint64_t v13 = a2;
  v13[1] = a3;
  return swift_retain(a3, v14, v15, v16);
}

uint64_t UnfoldSequence.init(_state:_next:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v11 = type metadata accessor for UnfoldSequence(0LL, a4, a5, a4);
  *(_BYTE *)(a6 + *(int *)(v11 + 40)) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 32LL))(a6, a1, a5);
  uint64_t v13 = (void *)(a6 + *(int *)(v11 + 36));
  *uint64_t v13 = a2;
  v13[1] = a3;
  return result;
}

uint64_t UnfoldSequence._state.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8LL) + 16LL))(a2, v2);
}

uint64_t UnfoldSequence._state.setter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 24) - 8LL) + 40LL))(v2, a1);
}

uint64_t (*UnfoldSequence._state.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence._predicate.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (uint64_t *)(v4 + *(int *)(a1 + 36));
  uint64_t v6 = *v5;
  swift_retain((unint64_t *)v5[1], a2, a3, a4);
  return v6;
}

uint64_t UnfoldSequence._done.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 40));
}

uint64_t UnfoldSequence._done.setter(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(v2 + *(int *)(a2 + 40)) = result;
  return result;
}

uint64_t (*UnfoldSequence._done.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnfoldSequence.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = type metadata accessor for Optional(0LL, v8, a2, a3);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v15 = (char *)&v22 - v14;
  uint64_t v16 = *(int *)(a1 + 40);
  if ((*(_BYTE *)(v5 + v16) & 1) != 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56LL))( a4,  1LL,  1LL,  v8);
  }
  uint64_t v18 = v5 + *(int *)(a1 + 36);
  int v20 = *(void (**)(uint64_t))v18;
  uint64_t v19 = *(unint64_t **)(v18 + 8);
  swift_retain(v19, v11, v12, v13);
  v20(v5);
  swift_release((uint64_t)v19);
  uint64_t v21 = *(void *)(v8 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v21 + 48))(v15, 1LL, v8) == 1)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, v9);
    *(_BYTE *)(v5 + v16) = 1;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v21 + 56))(a4, 1LL, 1LL, v8);
  }

  else
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v21 + 32))(a4, v15, v8);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v21 + 56))(a4, 0LL, 1LL, v8);
  }

uint64_t UnsafeMutableRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    uint64_t result = a3 + a1;
  }
  else {
    uint64_t result = 0LL;
  }
  uint64_t v5 = a2 - a1;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }
  if (v5)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer has a nil start and nonzero count",  63LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x69uLL,  0);
    }
  }

  return result;
}

void *UnsafeMutableRawBufferPointer.copyBytes<A>(from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v29)(void *__return_ptr, unint64_t *, unint64_t);
  unint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  void v44[2];
  uint64_t v45;
  uint64_t v9 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 8);
  uint64_t v15 = type metadata accessor for EnumeratedSequence(0LL, v14, v13, v14);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v19 = type metadata accessor for EnumeratedSequence.Iterator(0LL, a4, v13, v18);
  uint64_t result = (void *)MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v39 - v22;
  if (a2)
  {
    uint64_t v42 = v21;
    unint64_t v43 = result;
    MEMORY[0x1895F8858](result);
    *(&v39 - 6) = a4;
    *(&v39 - 5) = a5;
    uint64_t v35 = a1;
    char v36 = a2;
    unint64_t v41 = v24;
    uint64_t v37 = v24;
    uint64_t v38 = a2;
    uint64_t result = (*(void *(**)(uint64_t *__return_ptr, void))(v13 + 72))( &v45,  partial apply for closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:));
    if ((v45 & 1) != 0)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v17, a1, a4);
      (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v11, v17, a4);
      (*(void (**)(uint64_t, uint64_t))(v13 + 32))(a4, v13);
      uint64_t v25 = v43;
      uint64_t v26 = *((int *)v43 + 9);
      *(void *)&v23[v26] = 0LL;
      unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v13,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      uint64_t v29 = *(void (**)(void *__return_ptr, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                              + 16);
      unint64_t v30 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
      v29(v44, v30, AssociatedConformanceWitness);
      uint64_t v31 = 0LL;
      if ((v44[0] & 0x100LL) == 0)
      {
        uint64_t v40 = v26;
        uint64_t v32 = 0LL;
        uint64_t v33 = v41 - a2;
        do
        {
          uint64_t v31 = v32 + 1;
          if (__OFADD__(v32, 1LL))
          {
            __break(1u);
LABEL_12:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.copyBytes source has too many elements",  68LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x20FuLL,  0);
          }

          if (v32 >= v33) {
            goto LABEL_12;
          }
          *(_BYTE *)(a2 + v32) = v44[0];
          uint64_t v34 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
          v29(v44, v34, AssociatedConformanceWitness);
          ++v32;
        }

        while (BYTE1(v44[0]) != 1);
        uint64_t v26 = v40;
      }

      *(void *)&v23[v26] = v31;
      return (void *)(*(uint64_t (**)(char *, void *))(v42 + 8))(v23, v25);
    }
  }

  return result;
}

uint64_t UnsafeMutableRawBufferPointer.initializeMemory<A>(as:repeating:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v6 = *(void *)(*(void *)(a5 - 8) + 72LL);
    if (!v6) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }
    uint64_t v7 = a4 - a3;
    if (a4 - a3 == 0x8000000000000000LL && v6 == -1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
    }
    uint64_t v8 = v7 / v6;
    UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)(a1, a2, v7 / v6, a3, a5);
    if (v8 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
  }

  return a3;
}

uint64_t UnsafeMutableRawBufferPointer.initializeMemory<A>(as:from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v56 = a5;
  uint64_t v64 = a4;
  uint64_t v54 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a7,  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v51 = *(void *)(v13 - 8);
  uint64_t v52 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  unint64_t v63 = (char *)&v51 - v15;
  unint64_t v55 = AssociatedTypeWitness;
  uint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v59 = (char *)&v51 - v18;
  uint64_t v19 = *(void *)(a6 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v58 = (uint64_t)&v51 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v51 - v23;
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v51 - v25;
  unint64_t v62 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a7,  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v53 = *(void *)(v62 - 8);
  MEMORY[0x1895F8858](v62);
  uint64_t v28 = (char *)&v51 - v27;
  uint64_t v57 = v19;
  uint64_t v29 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v29(v26, a3, a6);
  unint64_t v30 = *(void (**)(uint64_t, uint64_t))(a7 + 32);
  char v61 = v28;
  v30(a6, a7);
  uint64_t v31 = *(void *)(v16 + 72);
  v29(v24, a3, a6);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 40);
  uint64_t v60 = a7;
  uint64_t v33 = v32(a6, a7);
  if (!v64)
  {
    uint64_t v45 = v58;
    if (!v31) {
      goto LABEL_26;
    }
    if (v33 <= 0)
    {
      unint64_t v46 = *(void (**)(char *, uint64_t))(v57 + 8);
      v46(v24, a6);
      v29((char *)v45, a3, a6);
      if (!v32(a6, v60))
      {
        v46((char *)v45, a6);
        (*(void (**)(uint64_t, char *, unint64_t))(v53 + 32))(v54, v61, v62);
        return v64;
      }

uint64_t UnsafeMutableRawBufferPointer.bindMemory<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeRawBufferPointer.bindMemory<A>(to:)( a1,  a2,  a3,  a4,  "UnsafeMutableBufferPointer with negative count",  46LL,  0x47uLL);
}

uint64_t UnsafeRawBufferPointer.bindMemory<A>(to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, unint64_t a7)
{
  if (a2)
  {
    uint64_t v7 = *(void *)(*(void *)(a4 - 8) + 72LL);
    if (!v7) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }
    if (a3 - a2 == 0x8000000000000000LL && v7 == -1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
    }
    if ((a3 - a2) / v7 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a5,  a6,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a7,  0);
    }
  }

  return a2;
}

uint64_t UnsafeMutableRawBufferPointer.load<A>(fromByteOffset:as:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.load with negative offset",  55LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x156uLL,  0);
  }
  uint64_t v5 = *(void *)(a4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  BOOL v7 = __OFADD__(a1, v6);
  uint64_t v8 = a1 + v6;
  if (v7)
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
  }

  if (!a2)
  {
    if (v8 < 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x159uLL,  0);
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.load out of bounds",  48LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x157uLL,  0);
  }

  if (a3 - a2 < v8) {
    goto LABEL_12;
  }
  return (*(uint64_t (**)(uint64_t))(v5 + 16))(a5);
}

uint64_t UnsafeRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    goto LABEL_12;
  }
  if (a3)
  {
    if (a4 - a3 >= a2) {
      goto LABEL_4;
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid slice",  13LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x5E5uLL,  0);
  }

  if (a2 >= 1) {
    goto LABEL_12;
  }
LABEL_4:
  if (a3) {
    uint64_t result = a3 + a1;
  }
  else {
    uint64_t result = 0LL;
  }
  uint64_t v6 = a2 - a1;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  if (v6)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  return result;
}

uint64_t UnsafeMutableBufferPointer.initialize(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.initialize(repeating:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))UnsafeMutablePointer.initialize(repeating:count:));
}

Swift::Int __swiftcall Int.advanced(by:)(Swift::Int by)
{
  BOOL v2 = __OFADD__(v1, by);
  Swift::Int result = v1 + by;
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t UnsafeMutableBufferPointer.assign(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.initialize(repeating:)( a1,  a2,  a3,  a4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))UnsafeMutablePointer.assign(repeating:count:));
}

uint64_t UnsafeMutableBufferPointer.initialize(repeating:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (a2) {
    return a5(result, a3, a2);
  }
  return result;
}

uint64_t specialized UnsafeMutableBufferPointer.update<A>(fromContentsOf:)( uint64_t a1, unint64_t a2, char *__dst, uint64_t a4)
{
  if ((a2 & 0x1000000000000000LL) != 0)
  {
    if ((a2 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v10 = HIBYTE(a2) & 0xF;
    }
    else {
      Swift::UInt64 v10 = a1 & 0xFFFFFFFFFFFFLL;
    }
    if (a4)
    {
      int64_t v8 = 0LL;
      if (!v10) {
        return v8;
      }
      uint64_t v11 = 4LL << ((a1 & 0x800000000000000LL) != 0);
      Swift::UInt64 rawBits = 15LL;
      uint64_t v13 = a4 & ~(a4 >> 63);
      while (1)
      {
        if ((rawBits & 0xC) == v11)
        {
          v16._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if (v10 <= v16._rawBits >> 16)
          {
LABEL_33:
            unint64_t v17 = 228LL;
LABEL_34:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v17,  0);
          }

          Swift::UInt8 v14 = String.UTF8View._foreignSubscript(position:)(v16);
          Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if (rawBits >> 16 >= v10)
          {
            unint64_t v17 = 144LL;
            goto LABEL_34;
          }
        }

        else
        {
          if (rawBits >> 16 >= v10) {
            goto LABEL_33;
          }
          Swift::UInt8 v14 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        }

        v15._Swift::UInt64 rawBits = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
        if (v13 == v8) {
          break;
        }
        Swift::UInt64 rawBits = v15._rawBits;
        __dst[v8++] = v14;
        if (4 * v10 == v15._rawBits >> 14) {
          return v8;
        }
      }

      unint64_t v19 = 941LL;
    }

    else
    {
      if (!v10) {
        return 0LL;
      }
      unint64_t v19 = 930LL;
    }

uint64_t _sSrsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_Sryqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSryxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5( uint64_t (*a1)(uint64_t, uint64_t, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    return a1(0LL, 0LL, &v13);
  }
  uint64_t v6 = *(void *)(a6 - 8);
  if ((*(_BYTE *)(v6 + 80) & a3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "baseAddress must be a properly aligned pointer for types Element and T",  70LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x4D3uLL,  0);
  }
  uint64_t v7 = *(void *)(v6 + 72);
  uint64_t v8 = *(void *)(*(void *)(a5 - 8) + 72LL);
  if (v7 != v8)
  {
    uint64_t v9 = a4 * v8;
    if ((unsigned __int128)(a4 * (__int128)v8) >> 64 == (a4 * v8) >> 63)
    {
      if (v7)
      {
        if (v7 == -1 && v9 == 0x8000000000000000LL) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
        }
        if (v8 >= v7)
        {
          if (v7 != -1 || v8 != 0x8000000000000000LL)
          {
            uint64_t v11 = v8 % v7;
            goto LABEL_19;
          }
        }

        else
        {
          if (!v8) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x390EuLL,  0);
          }
          if (v7 != 0x8000000000000000LL || v8 != -1)
          {
            uint64_t v11 = v7 % v8;
LABEL_19:
            if (v11) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Buffer must contain a whole number of Element instances",  55LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x4DDuLL,  0);
            }
            a4 = v9 / v7;
            goto LABEL_21;
          }
        }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3913uLL,  0);
      }
    }

    else
    {
      __break(1u);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }

uint64_t UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v5;
  uint64_t result;
  Swift::Int result = a1(a2, a3);
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56LL))(a5, 0LL, 1LL, a4);
  }
  return result;
}

void withVaList<A>(_:_:)(uint64_t a1, void (*a2)(void *))
{
  uint64_t v4 = type metadata accessor for __VaListBuilder();
  inited = swift_initStackObject(v4, v17);
  inited[2] = 8LL;
  inited[3] = 0LL;
  inited[4] = 0LL;
  inited[5] = 0LL;
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = a1 + 32;
    do
    {
      outlined init with copy of MirrorPath(v7, (uint64_t)v16);
      outlined init with take of MirrorPath(v16, (uint64_t)v13);
      uint64_t v8 = v14;
      uint64_t v9 = v15;
      __swift_project_boxed_opaque_existential_0Tm(v13, v14);
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 8))(v8, v9);
      __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v10);
      swift_bridgeObjectRelease(v10);
      __swift_destroy_boxed_opaque_existential_1Tm(v13);
      v7 += 40LL;
      --v6;
    }

    while (v6);
    uint64_t v11 = (void *)inited[5];
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = &static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
  a2(v12);
  swift_setDeallocating((uint64_t)inited);
  if (v11)
  {
    else {
      __break(1u);
    }
  }

void *__VaListBuilder.__allocating_init()()
{
  Swift::Int result = swift_allocObject(v0, 0x30uLL, 7uLL);
  result[2] = 8LL;
  result[3] = 0LL;
  result[4] = 0LL;
  result[5] = 0LL;
  return result;
}

void __VaListBuilder.append(_:)(void *a1)
{
  uint64_t v1 = a1[3];
  uint64_t v2 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
  __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v3);
  swift_bridgeObjectRelease(v3);
}

uint64_t _withVaList<A>(_:_:)(uint64_t a1, uint64_t (*a2)(void *))
{
  if (*(void *)(a1 + 40)) {
    uint64_t v2 = *(void **)(a1 + 40);
  }
  else {
    uint64_t v2 = &static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
  return a2(v2);
}

Swift::CVaListPointer __swiftcall __VaListBuilder.va_list()()
{
  if (v0[5]._value._rawValue) {
    return (Swift::CVaListPointer)v0[5]._value._rawValue;
  }
  else {
    return (Swift::CVaListPointer)&static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
}

Swift::CVaListPointer __swiftcall getVaList(_:)(Swift::OpaquePointer a1)
{
  uint64_t v2 = type metadata accessor for __VaListBuilder();
  uint64_t v3 = (Swift::CVaListPointer *)swift_allocObject(v2, 0x30uLL, 7uLL);
  v3[2]._value._rawValue = (Builtin::RawPointer)8;
  v3[3]._value._rawValue = 0LL;
  v3[4]._value._rawValue = 0LL;
  v3[5]._value._rawValue = 0LL;
  uint64_t v4 = *((void *)a1._rawValue + 2);
  if (v4)
  {
    uint64_t v5 = (char *)a1._rawValue + 32;
    do
    {
      outlined init with copy of MirrorPath((uint64_t)v5, (uint64_t)v14);
      outlined init with take of MirrorPath(v14, (uint64_t)v11);
      uint64_t v6 = v12;
      uint64_t v7 = v13;
      __swift_project_boxed_opaque_existential_0Tm(v11, v12);
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
      __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v8);
      swift_bridgeObjectRelease(v8);
      __swift_destroy_boxed_opaque_existential_1Tm(v11);
      v5 += 40;
      --v4;
    }

    while (v4);
  }

  uint64_t v9 = v3;
  if (v3[5]._value._rawValue) {
    return (Swift::CVaListPointer)v3[5]._value._rawValue;
  }
  else {
    return (Swift::CVaListPointer)&static __VaListBuilder.alignedStorageForEmptyVaLists;
  }
}

__objc2_class **_encodeBitsAsWords<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 - 8);
  size_t v5 = *(void *)(v4 + 64);
  MEMORY[0x1895F8858](a1);
  if (__OFADD__(v5, 8LL))
  {
    __break(1u);
    goto LABEL_7;
  }

  uint64_t v6 = v5 + 14;
  uint64_t v7 = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)(v6 >> 3));
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL), a1, a2);
  (*(void (**)(char *, uint64_t))(v4 + 8))((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL), a2);
  if ((v5 & 0x8000000000000000LL) != 0) {
LABEL_7:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  memcpy(v7 + 4, (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL), v5);
  return v7;
}

__objc2_class **Bool._cVarArgEncoding.getter(char a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = 0LL;
  *((_DWORD *)result + 8) = a1 & 1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Bool()
{
  return Bool._cVarArgEncoding.getter(*v0);
}

uint64_t Int64._cVarArgAlignment.getter()
{
  return 8LL;
}

uint64_t protocol witness for _CVarArgAligned._cVarArgAlignment.getter in conformance Int64()
{
  return 8LL;
}

__objc2_class **Int16._cVarArgEncoding.getter(__int16 a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = 0LL;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int16()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **Int8._cVarArgEncoding.getter(char a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = 0LL;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int8()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **Int._cVarArgEncoding.getter(__objc2_class *a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = a1;
  return result;
}

uint64_t UInt64._cVarArgAlignment.getter()
{
  return 8LL;
}

__objc2_class **Int32._cVarArgEncoding.getter(int a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = 0LL;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int32()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **UInt16._cVarArgEncoding.getter(unsigned __int16 a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = 0LL;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance UInt16()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **UInt8._cVarArgEncoding.getter(unsigned __int8 a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = 0LL;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance UInt8()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **OpaquePointer._cVarArgEncoding.getter(__objc2_class *a1)
{
  Swift::Int result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  result[4] = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int()
{
  int v1 = *v0;
  Swift::Int result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  result[4] = v1;
  return result;
}

__objc2_class **UnsafePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter( a1,  a2,  (uint64_t (*)(void))type metadata accessor for UnsafePointer);
}

__objc2_class **_sSPyxGs7CVarArgsRi_zrlsABP05_cVarB8EncodingSaySiGvgTW(uint64_t a1)
{
  return UnsafePointer._cVarArgEncoding.getter(*v1, *(void *)(a1 + 16));
}

__objc2_class **UnsafeMutablePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter( a1,  a2,  (uint64_t (*)(void))type metadata accessor for UnsafeMutablePointer);
}

__objc2_class **_sSpyxGs7CVarArgsRi_zrlsABP05_cVarB8EncodingSaySiGvgTW(uint64_t a1)
{
  return UnsafeMutablePointer._cVarArgEncoding.getter(*v1, *(void *)(a1 + 16));
}

__objc2_class **AutoreleasingUnsafeMutablePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter( a1,  a2,  (uint64_t (*)(void))type metadata accessor for AutoreleasingUnsafeMutablePointer);
}

__objc2_class **UnsafePointer._cVarArgEncoding.getter( uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a1;
  uint64_t v3 = a3(0LL);
  return _encodeBitsAsWords<A>(_:)((uint64_t)&v5, v3);
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance AutoreleasingUnsafeMutablePointer<A>( uint64_t a1)
{
  return AutoreleasingUnsafeMutablePointer._cVarArgEncoding.getter(*v1, *(void *)(a1 + 16));
}

double Float._cVarArgEncoding.getter(float a1)
{
  uint64_t v2 = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  v2[2] = (__objc2_class *)1;
  double result = a1;
  *((double *)v2 + 4) = a1;
  return result;
}

Swift::Double __swiftcall Double.init(_:)(Swift::Float a1)
{
  return a1;
}

uint64_t Float._cVarArgAlignment.getter()
{
  return 8LL;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Float()
{
  double v1 = *v0;
  double result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  *((double *)result + 4) = v1;
  return result;
}

__objc2_class **Double._cVarArgEncoding.getter(double a1)
{
  double result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1LL);
  result[2] = (__objc2_class *)1;
  *((double *)result + 4) = a1;
  return result;
}

uint64_t Double._cVarArgAlignment.getter()
{
  return 8LL;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Double()
{
  double v1 = *v0;
  double result = specialized Array.init(repeating:count:)(0LL, (__objc2_class *)1);
  result[4] = v1;
  return result;
}

void *__VaListBuilder.init()()
{
  double result = v0;
  v0[2] = 8LL;
  v0[3] = 0LL;
  v0[4] = 0LL;
  v0[5] = 0LL;
  return result;
}

Swift::Void __swiftcall __VaListBuilder.appendWords(_:)(Swift::OpaquePointer a1)
{
  uint64_t v2 = v1[3];
  uint64_t v3 = *((void *)a1._rawValue + 2);
  uint64_t v4 = v2 + v3;
  if (__OFADD__(v2, v3))
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

  uint64_t v6 = v1[4];
  if (v6 < v4)
  {
    if (v6 + 0x4000000000000000LL < 0)
    {
LABEL_18:
      __break(1u);
LABEL_19:
      __break(1u);
      goto LABEL_20;
    }

    uint64_t v7 = (char *)v1[5];
    if (2 * v6 > v4) {
      uint64_t v4 = 2 * v6;
    }
    v1[4] = v4;
    uint64_t v8 = (char *)swift_slowAlloc(8 * v4, 7uLL);
    v1[5] = v8;
    if (v7)
    {
      specialized UnsafeMutablePointer.moveInitialize(from:count:)(v7, v2, v8);
      if ((unint64_t)(v6 - 0x1000000000000000LL) >> 61 != 7)
      {
LABEL_20:
        __break(1u);
LABEL_21:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/VarArgs.swift",  19LL,  2,  0x29EuLL,  0);
      }

      swift_slowDealloc(v7);
    }
  }

  uint64_t v9 = v1[5];
  if (!v9) {
    goto LABEL_21;
  }
  if (v3)
  {
    uint64_t v10 = (uint64_t *)((char *)a1._rawValue + 32);
    uint64_t v11 = v1[3];
    while (1)
    {
      uint64_t v12 = *v10++;
      *(void *)(v9 + 8 * v11) = v12;
      uint64_t v13 = v1[3];
      BOOL v14 = __OFADD__(v13, 1LL);
      uint64_t v11 = v13 + 1;
      if (v14) {
        break;
      }
      v1[3] = v11;
      if (!--v3) {
        return;
      }
    }

    __break(1u);
    goto LABEL_17;
  }

unint64_t __VaListBuilder.allocStorage(wordCount:)(unint64_t result)
{
  if ((result - 0x1000000000000000LL) >> 61 == 7) {
    return (unint64_t)swift_slowAlloc(8 * result, 7uLL);
  }
  __break(1u);
  return result;
}

void __VaListBuilder.deallocStorage(wordCount:storage:)(uint64_t a1, void *a2)
{
  else {
    __break(1u);
  }
}

Swift::tuple_Builtin_Word_Builtin_Word __swiftcall __VaListBuilder.rawSizeAndAlignment(_:)(Swift::Int a1)
{
  if ((unint64_t)(a1 - 0x1000000000000000LL) >> 61 == 7)
  {
    a1 *= 8LL;
    Builtin::Word v1 = 8LL;
  }

  else
  {
    __break(1u);
  }

  result._1 = v1;
  result._0 = a1;
  return result;
}

void *__VaListBuilder.deinit()
{
  Swift::tuple_Builtin_Word_Builtin_Word result = *(void **)(v0 + 40);
  if (!result) {
    return (void *)v0;
  }
  if ((unint64_t)(*(void *)(v0 + 32) - 0x1000000000000000LL) >> 61 == 7)
  {
    swift_slowDealloc(result);
    return (void *)v0;
  }

  __break(1u);
  return result;
}

void __VaListBuilder.__deallocating_deinit()
{
  Builtin::Word v1 = *(void **)(v0 + 40);
  if (!v1) {
    goto LABEL_4;
  }
  if ((unint64_t)(*(void *)(v0 + 32) - 0x1000000000000000LL) >> 61 == 7)
  {
    swift_slowDealloc(v1);
LABEL_4:
    swift_deallocClassInstance(v0);
    return;
  }

  __break(1u);
}

uint64_t __VaListBuilder.requiredAlignmentInBytes.getter()
{
  return 8LL;
}

uint64_t __VaListBuilder.count.getter()
{
  return *(void *)(v0 + 24);
}

uint64_t __VaListBuilder.count.setter(uint64_t result)
{
  *(void *)(v1 + 24) = result;
  return result;
}

uint64_t (*__VaListBuilder.count.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __VaListBuilder.allocated.getter()
{
  return *(void *)(v0 + 32);
}

uint64_t __VaListBuilder.allocated.setter(uint64_t result)
{
  *(void *)(v1 + 32) = result;
  return result;
}

uint64_t (*__VaListBuilder.allocated.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __VaListBuilder.storage.getter()
{
  return *(void *)(v0 + 40);
}

uint64_t __VaListBuilder.storage.setter(uint64_t result)
{
  *(void *)(v1 + 40) = result;
  return result;
}

uint64_t (*__VaListBuilder.storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.init(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  v15[0] = a3;
  v15[1] = a4;
  void v15[2] = a5;
  v15[3] = a6;
  uint64_t v13 = type metadata accessor for Zip2Sequence(0LL, (uint64_t)v15);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32LL))( a7 + *(int *)(v13 + 52),  a2,  a4);
}

uint64_t Zip2Sequence._sequence2.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8LL) + 16LL))( a2,  v2 + *(int *)(a1 + 52));
}

uint64_t LazyMapSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 32),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a2,  v2,  AssociatedTypeWitness);
}

uint64_t LazyMapSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 32),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( v2,  a1,  AssociatedTypeWitness);
}

uint64_t (*Zip2Sequence.Iterator._baseStream1.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator._baseStream2.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 52);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 40),  *(void *)(a1 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a2,  v4,  AssociatedTypeWitness);
}

uint64_t Zip2Sequence.Iterator._baseStream2.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 52);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 40),  *(void *)(a2 + 24),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( v4,  a1,  AssociatedTypeWitness);
}

uint64_t (*Zip2Sequence.Iterator._baseStream2.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator._reachedEnd.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 56));
}

uint64_t Zip2Sequence.Iterator._reachedEnd.setter(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(v2 + *(int *)(a2 + 56)) = result;
  return result;
}

uint64_t (*Zip2Sequence.Iterator._reachedEnd.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator.init(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, const char *a6@<X5>, uint64_t a7@<X8>)
{
  v19[0] = a3;
  v19[1] = a4;
  v19[2] = a5;
  v19[3] = a6;
  uint64_t v14 = type metadata accessor for Zip2Sequence.Iterator(0LL, (uint64_t)v19);
  *(_BYTE *)(a7 + *(int *)(v14 + 56)) = 0;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a7,  a1,  AssociatedTypeWitness);
  uint64_t v16 = a7 + *(int *)(v14 + 52);
  unint64_t v17 = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v17 - 8) + 32LL))(v16, a2, v17);
}

uint64_t Zip2Sequence.underestimatedCount.getter(void *a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(a1[4] + 40LL))(a1[2]);
  uint64_t result = (*(uint64_t (**)(void))(a1[5] + 40LL))(a1[3]);
  if (result >= v2) {
    return v2;
  }
  return result;
}

uint64_t SIMD.indices.getter(uint64_t a1, uint64_t a2)
{
  if ((*(uint64_t (**)(void))(*(void *)(a2 + 48) + 40LL))() < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  return 0LL;
}

uint64_t SIMD.init(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v15 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v14 - v7;
  (*(void (**)(uint64_t, uint64_t))(v5 + 48))(a2, v5);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a2, v5);
  if (v9 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v10 = v9;
  if (v9)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = *(void (**)(char *, uint64_t, unint64_t))(v15 + 16);
    do
    {
      v12(v8, a1, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v5 + 64))(v8, v11++, a2, v5);
    }

    while (v10 != v11);
  }

  return (*(uint64_t (**)(uint64_t, unint64_t))(v15 + 8))(a1, AssociatedTypeWitness);
}

uint64_t static SIMD.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v48 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v47 = (char *)&v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v45 = (char *)&v40 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v40 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  unint64_t v17 = (char *)&v40 - v16;
  int64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v49 = v7;
  uint64_t v19 = v18(a3, v7);
  if (v19 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v19;
  if (v19)
  {
    uint64_t v21 = 0LL;
    uint64_t v22 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
    char v23 = 1;
    uint64_t v43 = a2;
    uint64_t v44 = a1;
    unint64_t v41 = v17;
    uint64_t v42 = v19;
    v22(v17, a1, a3);
    while (1)
    {
      v22(v15, a2, a3);
      if ((v23 & 1) != 0)
      {
        uint64_t v25 = v49;
        uint64_t v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(v49 + 56);
        uint64_t v27 = v45;
        v26(v21, a3, v49);
        uint64_t v28 = v15;
        uint64_t v29 = *(void (**)(char *, uint64_t))(v12 + 8);
        v29(v17, a3);
        unint64_t v30 = v22;
        uint64_t v31 = v12;
        uint64_t v32 = v47;
        v26(v21, a3, v25);
        v29(v28, a3);
        uint64_t v15 = v28;
        uint64_t v33 = v25;
        unint64_t v34 = AssociatedTypeWitness;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v33,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
        char v23 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                          + 8LL))( v27,  v32,  v34);
        uint64_t v36 = *(void (**)(char *, unint64_t))(v48 + 8);
        unint64_t v37 = v32;
        uint64_t v12 = v31;
        uint64_t v22 = v30;
        unint64_t v17 = v41;
        v36(v37, v34);
        unint64_t v38 = v27;
        uint64_t v20 = v42;
        v36(v38, v34);
        a2 = v43;
        a1 = v44;
      }

      else
      {
        uint64_t v24 = *(void (**)(char *, uint64_t))(v12 + 8);
        v24(v15, a3);
        v24(v17, a3);
        char v23 = 0;
      }

      if (v20 == ++v21) {
        break;
      }
      v22(v17, a1, a3);
    }
  }

  else
  {
    char v23 = 1;
  }

  return v23 & 1;
}

uint64_t SIMD.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v15 - v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a2, v5);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v11 = result;
  uint64_t v16 = a1;
  if (result)
  {
    uint64_t result = 0LL;
    uint64_t v12 = *(void (**)(void))(v5 + 56);
    do
    {
      uint64_t v13 = result + 1;
      v12();
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      (*(void (**)(uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v16,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      (*(void (**)(char *, unint64_t))(v7 + 8))(v9, AssociatedTypeWitness);
      uint64_t result = v13;
    }

    while (v11 != v13);
  }

  return result;
}

uint64_t SIMD.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v31 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v29 - v11;
  uint64_t v13 = a1[3];
  uint64_t v14 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v13);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v36, v13, v14);
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v32 = a2;
  uint64_t v33 = v6;
  uint64_t v34 = v9;
  uint64_t v16 = v15(a2, v9);
  if (v16 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v17 = v16;
  if (v16)
  {
    uint64_t v18 = 0LL;
    unint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v34 + 56);
    uint64_t v19 = v32;
    while (1)
    {
      uint64_t v39 = v5;
      uint64_t v20 = v12;
      unint64_t v21 = AssociatedTypeWitness;
      uint64_t v22 = v34;
      v30(v18, v19, v34);
      uint64_t v23 = v37;
      uint64_t v24 = v38;
      __swift_mutable_project_boxed_opaque_existential_1(v36, v37);
      uint64_t v35 = *(void (**)(char *, unint64_t, unint64_t, uint64_t, uint64_t))(v24 + 160);
      uint64_t v25 = v22;
      unint64_t AssociatedTypeWitness = v21;
      uint64_t v12 = v20;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v25,  v19,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Encodable);
      uint64_t v27 = v39;
      v35(v20, AssociatedTypeWitness, AssociatedConformanceWitness, v23, v24);
      uint64_t v5 = v27;
      if (v27) {
        break;
      }
      ++v18;
      (*(void (**)(char *, unint64_t))(v31 + 8))(v12, AssociatedTypeWitness);
      if (v17 == v18) {
        return __swift_destroy_boxed_opaque_existential_1Tm(v36);
      }
    }

    (*(void (**)(char *, unint64_t))(v31 + 8))(v12, AssociatedTypeWitness);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(v36);
}

uint64_t SIMD.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v75 = a4;
  uint64_t v6 = *(char **)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v73 - v8;
  uint64_t v10 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v73 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*((void (**)(uint64_t, char *))v6 + 6))(a2, v6);
  uint64_t v13 = a1[3];
  uint64_t v14 = a1[4];
  uint64_t v76 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v13);
  uint64_t v15 = v85;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v82, v13, v14);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, a2);
    uint64_t v16 = v76;
    return __swift_destroy_boxed_opaque_existential_1Tm(v16);
  }

  uint64_t v17 = v83;
  uint64_t v18 = v84;
  __swift_project_boxed_opaque_existential_0Tm(v82, v83);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v18 + 16))(v17, v18);
  LOBYTE(v18) = v20;
  uint64_t v21 = a2;
  uint64_t v22 = (uint64_t (*)(void))*((void *)v6 + 5);
  uint64_t v77 = v12;
  uint64_t v74 = v21;
  uint64_t v23 = v22();
  uint64_t v24 = v6;
  uint64_t v73 = v10;
  if ((v18 & 1) != 0 || v19 != v23)
  {
    uint64_t v85 = swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v35 = v34;
    uint64_t v36 = v76[3];
    uint64_t v37 = v76[4];
    __swift_project_boxed_opaque_existential_0Tm(v76, v36);
    uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(v37 + 8))(v36, v37);
    unint64_t v39 = specialized static String._createEmpty(withInitialCapacity:)(41LL);
    uint64_t v41 = v40;
    unint64_t v80 = v39;
    unint64_t v81 = (void *)v40;
    uint64_t v42 = HIBYTE(v40) & 0xF;
    if ((v40 & 0x2000000000000000LL) == 0) {
      uint64_t v42 = v39 & 0xFFFFFFFFFFFFLL;
    }
    if (v42 || (v39 & ~v40 & 0x2000000000000000LL) != 0)
    {
      if ((v40 & 0x2000000000000000LL) == 0
        || (0x80000001818B8020LL & 0x2000000000000000LL) == 0
        || (unint64_t v43 = specialized _SmallString.init(_:appending:)( v39,  v40,  0xD00000000000001DLL,  0x80000001818B8020LL | 0x8000000000000000LL),  (v45 & 1) != 0))
      {
        if ((0x80000001818B8020LL & 0x2000000000000000LL) != 0) {
          unint64_t v48 = (0x80000001818B8020LL >> 56) & 0xF;
        }
        else {
          unint64_t v48 = 29LL;
        }
        _StringGuts.append(_:)(0xD00000000000001DLL, 0x80000001818B8020LL | 0x8000000000000000LL, 0LL, v48);
        swift_bridgeObjectRelease(0x80000001818B8020LL | 0x8000000000000000LL);
        unint64_t v46 = v80;
        unint64_t v47 = (unint64_t)v81;
LABEL_26:
        uint64_t v50 = v77;
        uint64_t v51 = v74;
        uint64_t v52 = ((uint64_t (*)(uint64_t, char *))v22)(v74, v24);
        (*(void (**)(char *, uint64_t))(v73 + 8))(v50, v51);
        unint64_t v54 = _int64ToString(_:radix:uppercase:)( v52,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        unint64_t v55 = v53;
        uint64_t v56 = HIBYTE(v47) & 0xF;
        if ((v47 & 0x2000000000000000LL) == 0) {
          uint64_t v56 = v46 & 0xFFFFFFFFFFFFLL;
        }
        if (!v56 && (v46 & ~v47 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v47);
          unint64_t v80 = v54;
          unint64_t v81 = (void *)v55;
LABEL_39:
          Swift::String v63 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements.", 0xAuLL, 1);
          uint64_t countAndFlagsBits = v63._countAndFlagsBits;
          unint64_t object = v63._object;
          uint64_t v66 = HIBYTE(v55) & 0xF;
          if ((v55 & 0x2000000000000000LL) == 0) {
            uint64_t v66 = v54 & 0xFFFFFFFFFFFFLL;
          }
          if (!v66 && (v54 & ~v55 & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRelease(v55);
            goto LABEL_52;
          }

          if ((v55 & 0x2000000000000000LL) != 0)
          {
            if (((uint64_t)v63._object & 0x2000000000000000LL) != 0)
            {
              unint64_t v68 = specialized _SmallString.init(_:appending:)( v54,  v55,  v63._countAndFlagsBits,  (unint64_t)v63._object);
              if ((v70 & 1) == 0)
              {
                unint64_t v71 = v68;
                uint64_t v72 = v69;
                swift_bridgeObjectRelease(v55);
                swift_bridgeObjectRelease((uint64_t)v63._object);
                unint64_t object = v72;
                uint64_t countAndFlagsBits = v71;
LABEL_52:
                uint64_t v16 = v76;
                *(void *)uint64_t v35 = v38;
                *(void *)(v35 + 8) = countAndFlagsBits;
                *(void *)(v35 + 16) = object;
                *(void *)(v35 + 24) = 0LL;
                *(_BYTE *)(v35 + 72) = 3;
                swift_willThrow();
                __swift_destroy_boxed_opaque_existential_1Tm(v82);
                return __swift_destroy_boxed_opaque_existential_1Tm(v16);
              }

              goto LABEL_50;
            }
          }

          else if (((uint64_t)v63._object & 0x2000000000000000LL) != 0)
          {
LABEL_50:
            uint64_t v67 = ((unint64_t)v63._object >> 56) & 0xF;
            goto LABEL_51;
          }

          uint64_t v67 = v63._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_51:
          _StringGuts.append(_:)(v63._countAndFlagsBits, (unint64_t)v63._object, 0LL, v67);
          swift_bridgeObjectRelease((uint64_t)v63._object);
          uint64_t countAndFlagsBits = v80;
          unint64_t object = v81;
          goto LABEL_52;
        }

        if ((v47 & 0x2000000000000000LL) != 0)
        {
          if ((v53 & 0x2000000000000000LL) != 0)
          {
            unint64_t v58 = specialized _SmallString.init(_:appending:)(v46, v47, v54, v53);
            if ((v60 & 1) == 0)
            {
              unint64_t v61 = v58;
              unint64_t v62 = v59;
              swift_bridgeObjectRelease(v47);
              swift_bridgeObjectRelease(v55);
              unint64_t v80 = v61;
              unint64_t v81 = (void *)v62;
              unint64_t v55 = v62;
              unint64_t v54 = v61;
              goto LABEL_39;
            }

            goto LABEL_37;
          }
        }

        else if ((v53 & 0x2000000000000000LL) != 0)
        {
LABEL_37:
          uint64_t v57 = HIBYTE(v55) & 0xF;
          goto LABEL_38;
        }

        uint64_t v57 = v54 & 0xFFFFFFFFFFFFLL;
LABEL_38:
        _StringGuts.append(_:)(v54, v55, 0LL, v57);
        swift_bridgeObjectRelease(v55);
        unint64_t v54 = v80;
        unint64_t v55 = (unint64_t)v81;
        goto LABEL_39;
      }

      unint64_t v46 = v43;
      unint64_t v47 = v44;
      swift_bridgeObjectRelease(v41);
      swift_bridgeObjectRelease(0x80000001818B8020LL | 0x8000000000000000LL);
    }

    else
    {
      unint64_t v46 = 0xD00000000000001DLL;
      swift_bridgeObjectRelease(v40);
      unint64_t v47 = 0x80000001818B8020LL | 0x8000000000000000LL;
    }

    unint64_t v80 = v46;
    unint64_t v81 = (void *)v47;
    goto LABEL_26;
  }

  uint64_t v25 = ((uint64_t (*)(uint64_t, char *))v22)(v74, v6);
  if (v25 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v25)
  {
    uint64_t v26 = 0LL;
    uint64_t v85 = v6;
    uint64_t v27 = v74;
    unint64_t v79 = v9;
    uint64_t v28 = AssociatedTypeWitness;
    do
    {
      uint64_t v29 = v25;
      uint64_t v31 = v83;
      uint64_t v30 = v84;
      __swift_mutable_project_boxed_opaque_existential_1(v82, v83);
      uint64_t v32 = *(void (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(v30 + 176);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v85,  v27,  v28,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Decodable);
      v32(v28, v28, AssociatedConformanceWitness, v31, v30);
      ((void (*)(char *, uint64_t, uint64_t))v85[8])(v79, v26++, v27);
      uint64_t v25 = v29;
    }

    while (v29 != v26);
  }

  else
  {
    uint64_t v27 = v74;
  }

  __swift_destroy_boxed_opaque_existential_1Tm(v82);
  (*(void (**)(uint64_t, char *, uint64_t))(v73 + 32))(v75, v77, v27);
  return __swift_destroy_boxed_opaque_existential_1Tm(v76);
}

unint64_t SIMD.description.getter(unint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2;
  uint64_t v7 = specialized static String._createEmpty(withInitialCapacity:)(3LL);
  Swift::Int v11 = v7;
  unint64_t v12 = v8;
  uint64_t v339 = v7;
  unint64_t v340 = v8;
  uint64_t v13 = HIBYTE(v8) & 0xF;
  uint64_t v14 = v7 & 0xFFFFFFFFFFFFLL;
  if ((v8 & 0x2000000000000000LL) != 0) {
    uint64_t v15 = HIBYTE(v8) & 0xF;
  }
  else {
    uint64_t v15 = v7 & 0xFFFFFFFFFFFFLL;
  }
  if (v15 || (v7 & ~v8 & 0x2000000000000000LL) != 0)
  {
    if ((v8 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v8);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v49 = 0xA000000000000000LL;
      if (!(v12 & 0x80808080808080LL | v11 & 0x8080808080808080LL)) {
        unint64_t v49 = 0xE000000000000000LL;
      }
      unint64_t v48 = v49 & 0xFF00000000000000LL | (v13 << 56) | v12 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v339 = v11;
      goto LABEL_38;
    }

    swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v9, v10);
    uint64_t v16 = v14;
    if ((v12 & 0x1000000000000000LL) != 0)
    {
      uint64_t v16 = String.UTF8View._foreignCount()();
      unint64_t v17 = v11 & ~v12;
      if ((v17 & 0x2000000000000000LL) == 0) {
        goto LABEL_40;
      }
    }

    else
    {
      unint64_t v17 = v11 & ~v12;
      if ((v17 & 0x2000000000000000LL) == 0) {
        goto LABEL_40;
      }
    }

    if (swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v18 = _StringGuts.nativeUnusedCapacity.getter(v11, v12);
      if ((v19 & 1) != 0) {
        goto LABEL_283;
      }
      if (v16 <= 15 && (v18 & 0x8000000000000000LL) != 0)
      {
LABEL_13:
        swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
        if ((v12 & 0x1000000000000000LL) == 0)
        {
          if ((v11 & 0x1000000000000000LL) != 0)
          {
            uint64_t v23 = (unsigned __int8 *)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            uint64_t v23 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v12);
            uint64_t v14 = v20;
          }

          swift_bridgeObjectRetain(v12, v20, v21, v22);
          closure #1 in _StringGuts._convertedToSmall()(v23, v14, &v338);
          swift_bridgeObjectRelease(v12);
          unint64_t v25 = *((void *)&v338 + 1);
          unint64_t v24 = v338;
          goto LABEL_17;
        }

        goto LABEL_273;
      }

LABEL_280:
    id v262 = _StringObject.sharedUTF8.getter(v4, v3);
    uint64_t v264 = v326;
    swift_bridgeObjectRelease(v3);
    if ((uint64_t)v264 >= v334)
    {
      while (1)
      {
        a2 = v336;
        a1 = v337;
        uint64_t v263 = v334;
LABEL_214:
        uint64_t v265 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v263, (uint64_t)v262, (uint64_t)v264);
        uint64_t v264 = &v339;
        _StringGuts.appendInPlace(_:isASCII:)(v265, v266, v4 < 0);
        if (!v53) {
          break;
        }
        swift_errorRelease((id)v53);
        swift_bridgeObjectRelease(v3);
        __break(1u);
      }

      swift_bridgeObjectRelease_n(v3, 2LL);
      goto LABEL_195;
    }

    LODWORD(v333) = 0;
    unint64_t v332 = 1861LL;
    LOBYTE(v331) = 2;
    Swift::String::Index v315 = "";
    uint64_t v316 = 0LL;
LABEL_262:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  v315,  v316,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  v331,  v332,  v333);
  }

  int64_t v222 = _StringGuts.nativeUnusedCapacity.getter(v214, v12);
  if ((v223 & 1) != 0) {
    goto LABEL_283;
  }
  uint64_t v224 = (v12 >> 61) & 1;
  if (v222 < v11) {
    LODWORD(v224) = 1;
  }
  if (v221 > 15 || !(_DWORD)v224) {
    goto LABEL_197;
  }
LABEL_191:
  swift_bridgeObjectRelease_n(v3, 5LL);
  swift_bridgeObjectRetain(v12, v225, v226, v227);
  unint64_t v228 = _StringGuts._convertedToSmall()(v214, v12);
  unint64_t v230 = v229;
  swift_bridgeObjectRelease(v12);
  v231._Swift::UInt64 rawBits = (v218 << 16) | 1;
  v232._Swift::UInt64 rawBits = 1LL;
  v233._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v232, v231, v4, v3);
  if (v233._rawBits < 0x10000) {
    v233._rawBits |= 3;
  }
  unint64_t v235 = specialized String.init(_:)(v233, v234, v4, v3);
  unint64_t v237 = v236;
  swift_bridgeObjectRelease(v3);
  unint64_t v238 = _StringGuts._convertedToSmall()(v235, v237);
  unint64_t v240 = v239;
  swift_bridgeObjectRelease(v237);
  unint64_t v241 = specialized _SmallString.init(_:appending:)(v228, v230, v238, v240);
  a2 = v336;
  a1 = v337;
  if ((v243 & 1) != 0) {
    goto LABEL_282;
  }
  unint64_t v244 = v241;
  unint64_t v245 = v242;
  swift_bridgeObjectRelease(v12);
  swift_bridgeObjectRelease(v3);
  uint64_t v339 = v244;
  unint64_t v340 = v245;
LABEL_195:
  uint64_t v4 = v335;
LABEL_221:
  Swift::Int v11 = v339;
  unint64_t v12 = v340;
  unint64_t v268 = HIBYTE(v340) & 0xF;
  if ((v340 & 0x2000000000000000LL) != 0) {
    unint64_t v269 = HIBYTE(v340) & 0xF;
  }
  else {
    unint64_t v269 = v339 & 0xFFFFFFFFFFFFLL;
  }
  if (!v269 && (v339 & ~v340 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v340);
    Swift::Int v11 = 40LL;
    uint64_t v339 = 40LL;
    unint64_t v277 = 0xE100000000000000LL;
    goto LABEL_256;
  }

  if ((v340 & 0x2000000000000000LL) != 0 && v268 != 15)
  {
    unint64_t v270 = 8 * (HIBYTE(v340) & 7);
    uint64_t v271 = (-255LL << v270) - 1;
    uint64_t v272 = 40LL << v270;
    uint64_t v273 = v272 | v271 & v340;
    Swift::Int v274 = v272 | v271 & v339;
    if (v268 >= 8) {
      unint64_t v275 = v273;
    }
    else {
      unint64_t v275 = v340;
    }
    if (v268 < 8) {
      Swift::Int v11 = v274;
    }
    swift_bridgeObjectRelease(v340);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    unint64_t v276 = 0xA000000000000000LL;
    if (!(v11 & 0x8080808080808080LL | v275 & 0x80808080808080LL)) {
      unint64_t v276 = 0xE000000000000000LL;
    }
    unint64_t v277 = (v276 & 0xFF00000000000000LL | (v268 << 56) | v275 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL;
    uint64_t v339 = v11;
    unint64_t v340 = v277;
    goto LABEL_256;
  }

  swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v246, v247);
  if ((v12 & 0x1000000000000000LL) != 0) {
    goto LABEL_269;
  }
  BOOL v90 = __OFADD__(v269, 1LL);
  int64_t v278 = v269 + 1;
  if (v90) {
    goto LABEL_271;
  }
LABEL_238:
  if ((v11 & ~v12 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v279 = _StringGuts.nativeUnusedCapacity.getter(v11, v12);
    if ((v280 & 1) == 0)
    {
      BOOL v282 = (v12 & 0x2000000000000000LL) == 0 && v279 > 0;
      if (v278 <= 15 && !v282) {
        goto LABEL_249;
      }
LABEL_254:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v278, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
      __int128 v338 = xmmword_1817FFFD0;
      unint64_t v302 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v338, 1LL);
      _StringGuts.appendInPlace(_:isASCII:)(v302, v303, 1);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      Swift::Int v11 = v339;
      unint64_t v277 = v340;
      goto LABEL_256;
    }

void closure #1 in SIMD.description.getter( uint64_t *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t *a4@<X8>)
{
  Swift::String::Index v28 = a4;
  uint64_t v6 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = (swift *)swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v27 - v9;
  uint64_t v11 = *a1;
  uint64_t v12 = specialized static String._createEmpty(withInitialCapacity:)(2LL);
  uint64_t v14 = v12;
  unint64_t v15 = v13;
  uint64_t v29 = v12;
  unint64_t v30 = v13;
  uint64_t v16 = HIBYTE(v13) & 0xF;
  uint64_t v17 = v12 & 0xFFFFFFFFFFFFLL;
  if ((v13 & 0x2000000000000000LL) != 0) {
    uint64_t v17 = HIBYTE(v13) & 0xF;
  }
  if (v17 || (v12 & ~v13 & 0x2000000000000000LL) != 0)
  {
    if ((v13 & 0x2000000000000000LL) == 0)
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      goto LABEL_12;
    }

    swift_bridgeObjectRelease(v13);
    unint64_t v18 = 0xA000000000000000LL;
    if (!(v15 & 0x80808080808080LL | v14 & 0x8080808080808080LL)) {
      unint64_t v18 = 0xE000000000000000LL;
    }
    unint64_t v19 = v18 & 0xFF00000000000000LL | (v16 << 56) | v15 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v29 = v14;
  }

  else
  {
    swift_bridgeObjectRelease(v13);
    unint64_t v19 = 0xE000000000000000LL;
    uint64_t v29 = 0LL;
  }

  unint64_t v30 = v19;
LABEL_12:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56))(v11, a2, v6);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v10,  (uint64_t)&v29,  AssociatedTypeWitness,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  (*(void (**)(char *, swift *))(v8 + 8))(v10, AssociatedTypeWitness);
  uint64_t v21 = v29;
  unint64_t v20 = v30;
  unint64_t v22 = HIBYTE(v30) & 0xF;
  unint64_t v23 = v29 & 0xFFFFFFFFFFFFLL;
  if ((v30 & 0x2000000000000000LL) != 0) {
    unint64_t v23 = HIBYTE(v30) & 0xF;
  }
  if (v23 || (v29 & ~v30 & 0x2000000000000000LL) != 0)
  {
    if ((v30 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v30);
      unint64_t v25 = 0xA000000000000000LL;
      if (!(v20 & 0x80808080808080LL | v21 & 0x8080808080808080LL)) {
        unint64_t v25 = 0xE000000000000000LL;
      }
      unint64_t v24 = v25 & 0xFF00000000000000LL | (v22 << 56) | v20 & 0xFFFFFFFFFFFFFFLL;
    }

    else
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      uint64_t v21 = v29;
      unint64_t v24 = v30;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v30);
    uint64_t v21 = 0LL;
    unint64_t v24 = 0xE000000000000000LL;
  }

  Swift::String::Index v26 = v28;
  *Swift::String::Index v28 = v21;
  v26[1] = v24;
}

uint64_t static SIMD..== infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = a3;
  uint64_t v55 = a1;
  uint64_t v56 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v9 = *(void *)(swift_getAssociatedConformanceWitness( a4,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                 + 48);
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  int64_t v50 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  v6,  v10,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v48 = swift_getAssociatedTypeWitness( 0LL,  v50,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v48);
  uint64_t v12 = (char *)&v41 - v11;
  unint64_t v13 = swift_checkMetadataState(0LL, v10);
  MEMORY[0x1895F8858](v13);
  unint64_t v47 = (char *)&v41 - v14;
  unint64_t v58 = *(const char **)(a4 + 48);
  unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  v58,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v54 = *(void *)(v15 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  BOOL v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  char v51 = (char *)&v41 - v18;
  unint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v9 + 48))(v19, v9);
  unint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v9 + 40);
  uint64_t v57 = a5;
  uint64_t v52 = v20;
  uint64_t result = v20(v19, v9);
  if (result < 0) {
    goto LABEL_12;
  }
  unint64_t v46 = v12;
  if (result)
  {
    unint64_t v22 = 0LL;
    unint64_t v23 = (void (*)(void, void, void))*((void *)v58 + 7);
    unint64_t v44 = v23;
    uint64_t v45 = result;
    uint64_t v49 = v9;
    unint64_t v24 = v53;
    while (1)
    {
      unint64_t v25 = v51;
      Swift::String::Index v26 = v58;
      v23(v22, v6, v58);
      v23(v22, v6, v26);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v26,  v6,  v15,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v28 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8LL))( v25,  v24,  v15);
      uint64_t v29 = *(void (**)(char *, unint64_t))(v54 + 8);
      v29(v24, v15);
      unint64_t v30 = v25;
      uint64_t v31 = v49;
      v29(v30, v15);
      unint64_t v32 = v52(v19, v31);
      if ((v32 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v22 >= v32) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v43 = v13;
      unint64_t v33 = v48;
      unint64_t v34 = swift_getAssociatedConformanceWitness( (uint64_t)v50,  (uint64_t)v13,  v48,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v35 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v34 + 8);
      uint64_t v42 = v6;
      char v36 = v46;
      if ((v28 & 1) != 0)
      {
        unint64_t v37 = &unk_18180BE78;
        uint64_t v38 = 257LL;
      }

      else
      {
        unint64_t v37 = &unk_18180BE68;
        uint64_t v38 = 256LL;
      }

      v35(v37, v38, v33, v34);
      unint64_t v39 = v47;
      unint64_t v40 = v36;
      unint64_t v13 = v43;
      (*((void (**)(char *, unint64_t *))v50 + 3))(v40, v43);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v31 + 64))(v39, v22++, v19, v31);
      unint64_t v23 = v44;
      uint64_t result = v45;
      uint64_t v6 = v42;
      if (v45 == v22) {
        return result;
      }
    }

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;
  size_t v64 = a2;
  char v69 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v68 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  uint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v68,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v61 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v9,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  size_t v59 = swift_getAssociatedTypeWitness( 0LL,  v61,  v9,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v59);
  uint64_t v11 = (char *)&v54 - v10;
  char v60 = swift_checkMetadataState(0LL, v9);
  MEMORY[0x1895F8858](v60);
  unint64_t v58 = (char *)&v54 - v12;
  unint64_t v13 = *(void *)(a4 + 48);
  uint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v15 = MEMORY[0x1895F8858](v14);
  Swift::String v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)&v54 - v18;
  unint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v22 = (char *)&v54 - v21;
  uint64_t v65 = *(void *)(a3 - 8);
  unint64_t v23 = MEMORY[0x1895F8858](v20);
  unint64_t v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  uint64_t v67 = (char *)&v54 - v26;
  uint64_t v62 = v27;
  char v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a1, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unint64_t v30 = v29;
  uint64_t v57 = v11;
  if (v29)
  {
    uint64_t v31 = 0LL;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }

    while (v30 != v31);
  }

  uint64_t v62 = *(void *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  unint64_t v32 = swift_checkMetadataState(0LL, v66);
  unint64_t v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  unint64_t v34 = (uint64_t (*)(uint64_t, const char *))*((void *)v33 + 5);
  uint64_t v66 = (uint64_t)v32;
  uint64_t v35 = v33;
  char v36 = v34;
  unint64_t v37 = v34((uint64_t)v32, v35);
  if (v37 < 0) {
    goto LABEL_16;
  }
  if (v37)
  {
    uint64_t v38 = 0LL;
    unint64_t v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    uint64_t v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      unint64_t v40 = v63;
      uint64_t v41 = v39;
      v39(v38, a3, v13);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  a3,  v14,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8LL))( v19,  v40,  v14);
      unint64_t v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      uint64_t v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v38 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v59;
      unint64_t v47 = swift_getAssociatedConformanceWitness( (uint64_t)v61,  (uint64_t)v60,  v59,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      uint64_t v55 = v36;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE78;
        char v51 = 257LL;
      }

      else
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE68;
        char v51 = 256LL;
      }

      v48(v50, v51, v46, v47);
      uint64_t v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      char v36 = v55;
      unint64_t v39 = v41;
      if (v56 == v38) {
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
      }
    }

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;
  size_t v64 = a1;
  char v69 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v68 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  uint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v68,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v61 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v9,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  size_t v59 = swift_getAssociatedTypeWitness( 0LL,  v61,  v9,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v59);
  uint64_t v11 = (char *)&v54 - v10;
  char v60 = swift_checkMetadataState(0LL, v9);
  MEMORY[0x1895F8858](v60);
  unint64_t v58 = (char *)&v54 - v12;
  unint64_t v13 = *(void *)(a4 + 48);
  uint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v15 = MEMORY[0x1895F8858](v14);
  Swift::String v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)&v54 - v18;
  unint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v22 = (char *)&v54 - v21;
  uint64_t v65 = *(void *)(a3 - 8);
  unint64_t v23 = MEMORY[0x1895F8858](v20);
  unint64_t v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  uint64_t v67 = (char *)&v54 - v26;
  uint64_t v62 = v27;
  char v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a2, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unint64_t v30 = v29;
  uint64_t v57 = v11;
  if (v29)
  {
    uint64_t v31 = 0LL;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }

    while (v30 != v31);
  }

  uint64_t v62 = *(void *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  unint64_t v32 = swift_checkMetadataState(0LL, v66);
  unint64_t v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  unint64_t v34 = (uint64_t (*)(uint64_t, const char *))*((void *)v33 + 5);
  uint64_t v66 = (uint64_t)v32;
  uint64_t v35 = v33;
  char v36 = v34;
  unint64_t v37 = v34((uint64_t)v32, v35);
  if (v37 < 0) {
    goto LABEL_16;
  }
  if (v37)
  {
    uint64_t v38 = 0LL;
    unint64_t v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    uint64_t v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      unint64_t v40 = v63;
      uint64_t v41 = v39;
      v39(v38, a3, v13);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  a3,  v14,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8LL))( v19,  v40,  v14);
      unint64_t v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      uint64_t v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v38 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v59;
      unint64_t v47 = swift_getAssociatedConformanceWitness( (uint64_t)v61,  (uint64_t)v60,  v59,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      uint64_t v55 = v36;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE78;
        char v51 = 257LL;
      }

      else
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE68;
        char v51 = 256LL;
      }

      v48(v50, v51, v46, v47);
      uint64_t v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      char v36 = v55;
      unint64_t v39 = v41;
      if (v56 == v38) {
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
      }
    }

uint64_t SIMDMask.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 48) + 48LL))();
}

uint64_t SIMDMask.subscript.setter(int a1, uint64_t a2, void *a3)
{
  uint64_t v4 = v3;
  uint64_t v25 = a2;
  int v23 = a1;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a3[4] + 8LL) + 24LL) + 16LL);
  uint64_t v6 = a3[2];
  uint64_t v7 = *(void *)(a3[3] + 48LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v9 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v9);
  uint64_t v11 = &v22[-v10];
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  MEMORY[0x1895F8858](v12);
  uint64_t v14 = &v22[-v13];
  unint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v24 = v4;
  uint64_t v16 = v15(v6, v7);
  if (v16 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v17 = v25;
  if (v25 < 0 || v16 <= v25) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
  }
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  (uint64_t)v12,  v9,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if ((v23 & 1) != 0)
  {
    unint64_t v19 = &unk_18180BE78;
    uint64_t v20 = 257LL;
  }

  else
  {
    unint64_t v19 = &unk_18180BE68;
    uint64_t v20 = 256LL;
  }

  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v19,  v20,  v9,  AssociatedConformanceWitness);
  (*(void (**)(_BYTE *, unint64_t *, uint64_t))(v5 + 24))(v11, v12, v5);
  return (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v14, v17, v6, v7);
}

uint64_t static SIMD..!= infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = a3;
  uint64_t v55 = a1;
  uint64_t v56 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v9 = *(void *)(swift_getAssociatedConformanceWitness( a4,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                 + 48);
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  int64_t v50 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  v6,  v10,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v48 = swift_getAssociatedTypeWitness( 0LL,  v50,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v48);
  uint64_t v12 = (char *)&v41 - v11;
  uint64_t v13 = swift_checkMetadataState(0LL, v10);
  MEMORY[0x1895F8858](v13);
  unint64_t v47 = (char *)&v41 - v14;
  unint64_t v58 = *(const char **)(a4 + 48);
  unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  v58,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v54 = *(void *)(v15 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  BOOL v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  char v51 = (char *)&v41 - v18;
  unint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v9 + 48))(v19, v9);
  uint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v9 + 40);
  uint64_t v57 = a5;
  uint64_t v52 = v20;
  uint64_t result = v20(v19, v9);
  if (result < 0) {
    goto LABEL_12;
  }
  unint64_t v46 = v12;
  if (result)
  {
    unint64_t v22 = 0LL;
    int v23 = (void (*)(void, void, void))*((void *)v58 + 7);
    unint64_t v44 = v23;
    uint64_t v45 = result;
    uint64_t v49 = v9;
    uint64_t v24 = v53;
    while (1)
    {
      uint64_t v25 = v51;
      Swift::String::Index v26 = v58;
      v23(v22, v6, v58);
      v23(v22, v6, v26);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v26,  v6,  v15,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v28 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8LL))( v25,  v24,  v15);
      uint64_t v29 = *(void (**)(char *, unint64_t))(v54 + 8);
      v29(v24, v15);
      unint64_t v30 = v25;
      uint64_t v31 = v49;
      v29(v30, v15);
      unint64_t v32 = v52(v19, v31);
      if ((v32 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v22 >= v32) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v43 = v13;
      unint64_t v33 = v48;
      unint64_t v34 = swift_getAssociatedConformanceWitness( (uint64_t)v50,  (uint64_t)v13,  v48,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v35 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v34 + 8);
      uint64_t v42 = v6;
      char v36 = v46;
      if ((v28 & 1) != 0)
      {
        unint64_t v37 = &unk_18180BE68;
        uint64_t v38 = 256LL;
      }

      else
      {
        unint64_t v37 = &unk_18180BE78;
        uint64_t v38 = 257LL;
      }

      v35(v37, v38, v33, v34);
      unint64_t v39 = v47;
      unint64_t v40 = v36;
      uint64_t v13 = v43;
      (*((void (**)(char *, unint64_t *))v50 + 3))(v40, v43);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v31 + 64))(v39, v22++, v19, v31);
      int v23 = v44;
      uint64_t result = v45;
      uint64_t v6 = v42;
      if (v45 == v22) {
        return result;
      }
    }

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;
  size_t v64 = a2;
  char v69 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v68 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  uint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v68,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v61 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v9,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  size_t v59 = swift_getAssociatedTypeWitness( 0LL,  v61,  v9,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v59);
  uint64_t v11 = (char *)&v54 - v10;
  char v60 = swift_checkMetadataState(0LL, v9);
  MEMORY[0x1895F8858](v60);
  unint64_t v58 = (char *)&v54 - v12;
  uint64_t v13 = *(void *)(a4 + 48);
  uint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v15 = MEMORY[0x1895F8858](v14);
  Swift::String v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)&v54 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v22 = (char *)&v54 - v21;
  uint64_t v65 = *(void *)(a3 - 8);
  int v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  uint64_t v67 = (char *)&v54 - v26;
  uint64_t v62 = v27;
  char v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a1, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unint64_t v30 = v29;
  uint64_t v57 = v11;
  if (v29)
  {
    uint64_t v31 = 0LL;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }

    while (v30 != v31);
  }

  uint64_t v62 = *(void *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  unint64_t v32 = swift_checkMetadataState(0LL, v66);
  unint64_t v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  unint64_t v34 = (uint64_t (*)(uint64_t, const char *))*((void *)v33 + 5);
  uint64_t v66 = (uint64_t)v32;
  uint64_t v35 = v33;
  char v36 = v34;
  unint64_t v37 = v34((uint64_t)v32, v35);
  if (v37 < 0) {
    goto LABEL_16;
  }
  if (v37)
  {
    uint64_t v38 = 0LL;
    unint64_t v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    uint64_t v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      unint64_t v40 = v63;
      uint64_t v41 = v39;
      v39(v38, a3, v13);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  a3,  v14,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8LL))( v19,  v40,  v14);
      unint64_t v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      uint64_t v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v38 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v59;
      unint64_t v47 = swift_getAssociatedConformanceWitness( (uint64_t)v61,  (uint64_t)v60,  v59,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      uint64_t v55 = v36;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE68;
        char v51 = 256LL;
      }

      else
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE78;
        char v51 = 257LL;
      }

      v48(v50, v51, v46, v47);
      uint64_t v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      char v36 = v55;
      unint64_t v39 = v41;
      if (v56 == v38) {
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
      }
    }

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;
  size_t v64 = a1;
  char v69 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v68 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  uint64_t v66 = AssociatedTypeWitness;
  uint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v68,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v61 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v9,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  size_t v59 = swift_getAssociatedTypeWitness( 0LL,  v61,  v9,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v59);
  uint64_t v11 = (char *)&v54 - v10;
  char v60 = swift_checkMetadataState(0LL, v9);
  MEMORY[0x1895F8858](v60);
  unint64_t v58 = (char *)&v54 - v12;
  uint64_t v13 = *(void *)(a4 + 48);
  uint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v15 = MEMORY[0x1895F8858](v14);
  Swift::String v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)&v54 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v22 = (char *)&v54 - v21;
  uint64_t v65 = *(void *)(a3 - 8);
  int v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  uint64_t v67 = (char *)&v54 - v26;
  uint64_t v62 = v27;
  char v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a2, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0) {
    goto LABEL_16;
  }
  unint64_t v30 = v29;
  uint64_t v57 = v11;
  if (v29)
  {
    uint64_t v31 = 0LL;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }

    while (v30 != v31);
  }

  uint64_t v62 = *(void *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  unint64_t v32 = swift_checkMetadataState(0LL, v66);
  unint64_t v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  unint64_t v34 = (uint64_t (*)(uint64_t, const char *))*((void *)v33 + 5);
  uint64_t v66 = (uint64_t)v32;
  uint64_t v35 = v33;
  char v36 = v34;
  unint64_t v37 = v34((uint64_t)v32, v35);
  if (v37 < 0) {
    goto LABEL_16;
  }
  if (v37)
  {
    uint64_t v38 = 0LL;
    unint64_t v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    uint64_t v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      unint64_t v40 = v63;
      uint64_t v41 = v39;
      v39(v38, a3, v13);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  a3,  v14,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8LL))( v19,  v40,  v14);
      unint64_t v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      uint64_t v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v38 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v59;
      unint64_t v47 = swift_getAssociatedConformanceWitness( (uint64_t)v61,  (uint64_t)v60,  v59,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      uint64_t v55 = v36;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE68;
        char v51 = 256LL;
      }

      else
      {
        uint64_t v49 = v57;
        int64_t v50 = &unk_18180BE78;
        char v51 = 257LL;
      }

      v48(v50, v51, v46, v47);
      uint64_t v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      char v36 = v55;
      unint64_t v39 = v41;
      if (v56 == v38) {
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
      }
    }

uint64_t SIMD.replace(with:where:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v78 = a2;
  uint64_t v72 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  uint64_t v80 = *(const char **)(AssociatedConformanceWitness + 48);
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v80,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v10 = swift_getAssociatedConformanceWitness( a4,  a3,  v9,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  uint64_t v76 = *(void *)(v10 + 8);
  uint64_t v67 = *(const char **)(*(void *)(v76 + 24) + 16LL);
  unint64_t v66 = swift_getAssociatedTypeWitness( 0LL,  v67,  v9,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v66);
  uint64_t v65 = (char *)&v63 - v11;
  uint64_t v12 = swift_checkMetadataState(0LL, v9);
  uint64_t v74 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  size_t v64 = (char *)&v63 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v71 = (char *)&v63 - v16;
  MEMORY[0x1895F8858](v15);
  unsigned int v77 = (char *)&v63 - v17;
  unint64_t v18 = swift_getAssociatedConformanceWitness( a4,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  unint64_t v81 = AssociatedTypeWitness;
  v82[0] = AssociatedTypeWitness;
  v82[1] = AssociatedConformanceWitness;
  v82[2] = v10;
  uint64_t v82[3] = v18;
  uint64_t v19 = type metadata accessor for SIMDMask(0LL, (uint64_t)v82);
  uint64_t v79 = *(void *)(v19 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (char *)&v63 - v20;
  uint64_t v22 = *(void *)(a4 + 48);
  unint64_t v23 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v22,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1895F8858](v23);
  int v75 = (char *)&v63 - v24;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v22 + 40))(a3, v22);
  if (result < 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v26 = result;
  uint64_t v73 = v4;
  if (result)
  {
    unint64_t v27 = 0LL;
    char v28 = *(void (**)(void, void, void))(v79 + 16);
    while (1)
    {
      uint64_t v29 = v28;
      v28(v21, v78, v19);
      unint64_t v30 = (*((uint64_t (**)(unint64_t))v80 + 5))(v81);
      if ((v30 & 0x8000000000000000LL) != 0) {
        goto LABEL_23;
      }
      if (v27 >= v30) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
      }
      uint64_t v31 = *(void (**)(char *, uint64_t))(v79 + 8);
      uint64_t v68 = v21;
      uint64_t v70 = v19;
      v31(v21, v19);
      unint64_t v32 = v77;
      (*((void (**)(unint64_t, unint64_t))v80 + 7))(v27, v81);
      uint64_t v33 = v76;
      unint64_t v34 = *(uint64_t (**)(unint64_t *, uint64_t))(v76 + 64);
      char v35 = v34(v12, v76);
      uint64_t v69 = v26;
      if ((v35 & 1) == 0) {
        break;
      }
      uint64_t v36 = (*(uint64_t (**)(unint64_t *, uint64_t))(v33 + 128))(v12, v33);
      if (v36 >= 64)
      {
        v82[0] = 0LL;
        unint64_t v47 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v33 + 96);
        unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
        uint64_t v49 = v33;
        unint64_t v46 = v71;
        v47(v82, &type metadata for Int, v48, v12, v49);
        (*(void (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v49 + 32) + 8LL) + 16LL))( v32,  v46,  v12);
LABEL_13:
        int64_t v50 = *(void (**)(char *, unint64_t *))(v74 + 8);
        v50(v46, v12);
        v50(v32, v12);
        uint64_t v21 = v68;
        goto LABEL_20;
      }

      (*(void (**)(unint64_t *, uint64_t))(v33 + 120))(v12, v33);
      (*(void (**)(char *, unint64_t *))(v74 + 8))(v32, v12);
      uint64_t v21 = v68;
LABEL_20:
      uint64_t v62 = v75;
      (*(void (**)(unint64_t, uint64_t, uint64_t))(v22 + 56))(v27, a3, v22);
      uint64_t result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v62, v27++, a3, v22);
      uint64_t v26 = v69;
      uint64_t v19 = v70;
      char v28 = v29;
      if (v69 == v27) {
        return result;
      }
    }

    char v39 = v34(v12, v33);
    uint64_t v40 = (*(uint64_t (**)(unint64_t *, uint64_t))(v33 + 128))(v12, v33);
    if ((v39 & 1) == 0)
    {
      uint64_t v21 = v68;
      if (v40 < 64)
      {
        char v51 = v77;
        (*(void (**)(unint64_t *, uint64_t))(v33 + 120))(v12, v33);
        (*(void (**)(char *, unint64_t *))(v74 + 8))(v51, v12);
      }

      else
      {
        (*(void (**)(char *, unint64_t *))(v74 + 8))(v77, v12);
      }

      goto LABEL_20;
    }

    if (v40 <= 64)
    {
      uint64_t v52 = v33;
      unint64_t v53 = v66;
      uint64_t v54 = v67;
      unint64_t v55 = swift_getAssociatedConformanceWitness( (uint64_t)v67,  (uint64_t)v12,  v66,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v56 = v65;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v55 + 8))( &unk_18180BE68,  256LL,  v53,  v55);
      uint64_t v57 = v71;
      (*((void (**)(char *, unint64_t *, const char *))v54 + 3))(v56, v12, v54);
      LOBYTE(v53) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v52 + 32)
                                                                                              + 8LL)
                                                                                  + 16LL))( v77,  v57,  v12);
      uint64_t v58 = v74;
      size_t v59 = *(void (**)(char *, unint64_t *))(v74 + 8);
      v59(v57, v12);
      char v60 = *(void (**)(char *, char *, unint64_t *))(v58 + 32);
      uint64_t v61 = v64;
      v60(v64, v77, v12);
      uint64_t v21 = v68;
      if ((v53 & 1) == 0) {
        (*(void (**)(unint64_t *))(v76 + 120))(v12);
      }
      v59(v61, v12);
      goto LABEL_20;
    }

    v82[0] = 0LL;
    uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v33 + 96);
    unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    uint64_t v45 = v33;
    unint64_t v46 = v71;
    v43(v82, &type metadata for Int, v44, v12, v45);
    unint64_t v32 = v77;
    (*(void (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v45 + 32) + 8LL) + 16LL))( v77,  v46,  v12);
    goto LABEL_13;
  }

  return result;
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(char *, uint64_t, unint64_t);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  const char *v45;
  unint64_t v46;
  void (**v47)(char *, unint64_t);
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char *v62;
  void (*v63)(char *, char *, uint64_t);
  char *v64;
  void (*v65)(char *, uint64_t);
  char *v66;
  char *v67;
  void (*v68)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t v73;
  const char *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  uint64_t v81;
  char *v82;
  void (*v83)(char *, uint64_t);
  void (*v84)(char *, char *, uint64_t);
  char *v85;
  char *v87;
  char *v88;
  unint64_t v89;
  const char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  void (**v98)(char *, unint64_t);
  uint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  char *v103;
  char *v104;
  uint64_t v105;
  unint64_t v106;
  void v107[5];
  uint64_t v102 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  char v96 = *(const char **)(AssociatedConformanceWitness + 48);
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v96,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v10 = swift_getAssociatedConformanceWitness( a4,  a3,  v9,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  uint64_t v94 = *(void *)(v10 + 8);
  BOOL v90 = *(const char **)(*(void *)(v94 + 24) + 16LL);
  uint64_t v89 = swift_getAssociatedTypeWitness( 0LL,  v90,  v9,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v89);
  uint64_t v88 = (char *)&v87 - v11;
  uint64_t v12 = swift_checkMetadataState(0LL, v9);
  uint64_t v93 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  size_t v91 = (char *)&v87 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v101 = (char *)&v87 - v18;
  uint64_t v95 = v19;
  uint64_t v20 = swift_getAssociatedConformanceWitness( a4,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  unint64_t v106 = AssociatedTypeWitness;
  v107[0] = AssociatedTypeWitness;
  v107[1] = AssociatedConformanceWitness;
  v107[2] = v10;
  v107[3] = v20;
  unint64_t v105 = type metadata accessor for SIMDMask(0LL, (uint64_t)v107);
  uint64_t v99 = *(void *)(v105 - 8);
  MEMORY[0x1895F8858](v105);
  uint64_t v104 = (char *)&v87 - v21;
  uint64_t v22 = *(void *)(a4 + 48);
  unint64_t v23 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v22,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v24 = MEMORY[0x1895F8858](v23);
  uint64_t v92 = (char *)&v87 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  char v28 = (char *)&v87 - v27;
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  uint64_t v31 = (char *)&v87 - v30;
  uint64_t v100 = *(void *)(a3 - 8);
  unint64_t v32 = MEMORY[0x1895F8858](v29);
  unint64_t v34 = (char *)&v87 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v32);
  uint64_t v103 = (char *)&v87 - v35;
  uint64_t v98 = (void (**)(char *, unint64_t))v36;
  uint64_t v37 = *(void (**)(char *, uint64_t, unint64_t))(v36 + 16);
  v37(v31, a1, v23);
  (*(void (**)(uint64_t, uint64_t))(v22 + 48))(a3, v22);
  size_t v97 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  uint64_t v38 = v97(a3, v22);
  if (v38 < 0) {
    goto LABEL_29;
  }
  char v39 = v38;
  uint64_t v87 = v15;
  if (v38)
  {
    uint64_t v40 = 0LL;
    do
    {
      v37(v28, (uint64_t)v31, v23);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v28, v40++, a3, v22);
    }

    while (v39 != v40);
  }

  v98[1](v31, v23);
  (*(void (**)(char *, char *, uint64_t))(v100 + 32))(v103, v34, a3);
  uint64_t v41 = v97(a3, v22);
  if (v41 < 0) {
LABEL_29:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v42 = v41;
  unint64_t v44 = v101;
  uint64_t v43 = v102;
  uint64_t v45 = v96;
  if (v41)
  {
    unint64_t v46 = 0LL;
    unint64_t v47 = *(void (***)(char *, unint64_t))(v99 + 16);
    while (1)
    {
      ((void (*)(char *, uint64_t, uint64_t))v47)(v104, v43, v105);
      unint64_t v48 = (*((uint64_t (**)(unint64_t, const char *))v45 + 5))(v106, v45);
      if ((v48 & 0x8000000000000000LL) != 0) {
        goto LABEL_29;
      }
      if (v46 >= v48) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
      }
      uint64_t v98 = v47;
      (*(void (**)(char *, uint64_t))(v99 + 8))(v104, v105);
      (*((void (**)(unint64_t, unint64_t, const char *))v45 + 7))(v46, v106, v45);
      uint64_t v49 = v94;
      int64_t v50 = v95;
      char v51 = *(uint64_t (**)(uint64_t, uint64_t))(v94 + 64);
      if ((v51(v95, v94) & 1) != 0) {
        break;
      }
      unint64_t v55 = v51(v50, v49);
      uint64_t v56 = (*(uint64_t (**)(uint64_t, uint64_t))(v49 + 128))(v50, v49);
      if ((v55 & 1) != 0)
      {
        if (v56 <= 64)
        {
          uint64_t v74 = v90;
          int v75 = v95;
          uint64_t v76 = v89;
          unsigned int v77 = swift_getAssociatedConformanceWitness( (uint64_t)v90,  v95,  v89,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v78 = v88;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v77 + 8))( &unk_18180BE68,  256LL,  v76,  v77);
          uint64_t v79 = v91;
          (*((void (**)(char *, uint64_t, const char *))v74 + 3))(v78, v75, v74);
          uint64_t v80 = v101;
          LOBYTE(v76) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v94 + 32) + 8LL)
                                                                           + 16LL))( v101,  v79,  v75);
          unint64_t v81 = v93;
          uint64_t v82 = v79;
          unint64_t v44 = v80;
          uint64_t v83 = *(void (**)(char *, uint64_t))(v93 + 8);
          v83(v82, v75);
          uint64_t v84 = *(void (**)(char *, char *, uint64_t))(v81 + 32);
          uint64_t v85 = v87;
          v84(v87, v44, v75);
          if ((v76 & 1) != 0)
          {
            v83(v85, v75);
            uint64_t v72 = v92;
            goto LABEL_24;
          }

          (*(void (**)(uint64_t))(v94 + 120))(v75);
          v83(v85, v75);
          goto LABEL_21;
        }

        v107[0] = 0LL;
        size_t v59 = v94;
        char v60 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v94 + 96);
        uint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
        uint64_t v62 = v91;
        int64_t v50 = v95;
        v60(v107, &type metadata for Int, v61, v95, v59);
        uint64_t v63 = *(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v59 + 32) + 8LL) + 16LL);
        size_t v64 = v101;
        v63(v101, v62, v50);
        uint64_t v65 = *(void (**)(char *, uint64_t))(v93 + 8);
        unint64_t v66 = v62;
        unint64_t v44 = v64;
        v65(v66, v50);
        uint64_t v67 = v64;
LABEL_17:
        v65(v67, v50);
        uint64_t v72 = v92;
        goto LABEL_24;
      }

      if (v56 < 64)
      {
        uint64_t v73 = v95;
        (*(void (**)(uint64_t))(v94 + 120))(v95);
        (*(void (**)(char *, uint64_t))(v93 + 8))(v44, v73);
        goto LABEL_21;
      }

      (*(void (**)(char *, uint64_t))(v93 + 8))(v44, v95);
      uint64_t v72 = v92;
LABEL_24:
      (*(void (**)(unint64_t, uint64_t, uint64_t))(v22 + 56))(v46, a3, v22);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v72, v46++, a3, v22);
      uint64_t v43 = v102;
      unint64_t v47 = v98;
      if (v42 == v46) {
        return (*(uint64_t (**)(char *, uint64_t))(v100 + 8))(v103, a3);
      }
    }

    uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(v49 + 128))(v50, v49);
    if (v52 < 64)
    {
      (*(void (**)(uint64_t, uint64_t))(v49 + 120))(v50, v49);
      (*(void (**)(char *, uint64_t))(v93 + 8))(v44, v50);
LABEL_21:
      uint64_t v72 = v92;
      goto LABEL_24;
    }

    v107[0] = 0LL;
    uint64_t v68 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v49 + 96);
    uint64_t v69 = lazy protocol witness table accessor for type Int and conformance Int(v52, v53, v54);
    uint64_t v70 = v91;
    v68(v107, &type metadata for Int, v69, v50, v49);
    (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v49 + 32) + 8LL) + 16LL))(v101, v70, v50);
    uint64_t v65 = *(void (**)(char *, uint64_t))(v93 + 8);
    unint64_t v71 = v70;
    unint64_t v44 = v101;
    v65(v71, v50);
    uint64_t v67 = v44;
    goto LABEL_17;
  }

  return (*(uint64_t (**)(char *, uint64_t))(v100 + 8))(v103, a3);
}

unint64_t SIMDMask.subscript.getter(uint64_t a1, void *a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2[4] + 8LL);
  uint64_t v7 = *(const char **)(*(void *)(v6 + 24) + 16LL);
  uint64_t v8 = a2[2];
  uint64_t v9 = *(void *)(a2[3] + 48LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = v7;
  unint64_t v47 = swift_getAssociatedTypeWitness( 0LL,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v47);
  unint64_t v46 = (char *)&v45 - v11;
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v51 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v48 = (char *)&v45 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  int64_t v50 = (char *)&v45 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v45 - v18;
  uint64_t v20 = *(a2 - 1);
  MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v45 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, void *))(v20 + 16))(v22, v3, a2);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v8, v9);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a1 < 0 || v23 <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
  }
  (*(void (**)(char *, void *))(v20 + 8))(v22, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56))(a1, v8, v9);
  uint64_t v24 = *(uint64_t (**)(unint64_t *, uint64_t))(v6 + 64);
  if ((v24(v12, v6) & 1) != 0)
  {
    uint64_t v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 128))(v12, v6);
    if (v25 < 64)
    {
LABEL_6:
      unint64_t v28 = (*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 120))(v12, v6);
      (*(void (**)(char *, unint64_t *))(v51 + 8))(v19, v12);
      unint64_t v29 = v28 >> 63;
      return v29 & 1;
    }

    goto LABEL_10;
  }

  char v30 = v24(v12, v6);
  uint64_t v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 128))(v12, v6);
  if ((v30 & 1) == 0)
  {
    if (v25 >= 64)
    {
      (*(void (**)(char *, unint64_t *))(v51 + 8))(v19, v12);
      LOBYTE(v29) = 0;
      return v29 & 1;
    }

    goto LABEL_6;
  }

  if (v25 > 64)
  {
LABEL_10:
    uint64_t v52 = 0LL;
    uint64_t v31 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v6 + 96);
    unint64_t v32 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
    uint64_t v33 = v50;
    v31(&v52, &type metadata for Int, v32, v12, v6);
    LOBYTE(v29) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                + 16LL))( v19,  v33,  v12);
    unint64_t v34 = *(void (**)(char *, unint64_t *))(v51 + 8);
    v34(v33, v12);
    v34(v19, v12);
    return v29 & 1;
  }

  uint64_t v35 = (uint64_t)v49;
  unint64_t v36 = v47;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v49,  (uint64_t)v12,  v47,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v38 = v46;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v36,  AssociatedConformanceWitness);
  char v39 = v50;
  (*(void (**)(char *, unint64_t *, uint64_t))(v35 + 24))(v38, v12, v35);
  LOBYTE(v36) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                              + 16LL))( v19,  v39,  v12);
  uint64_t v40 = v51;
  uint64_t v41 = *(void (**)(char *, unint64_t *))(v51 + 8);
  v41(v39, v12);
  uint64_t v42 = *(void (**)(char *, char *, unint64_t *))(v40 + 32);
  uint64_t v43 = v48;
  v42(v48, v19, v12);
  if ((v36 & 1) != 0) {
    LOBYTE(v29) = 1;
  }
  else {
    unint64_t v29 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 120))(v12, v6) >> 63;
  }
  v41(v43, v12);
  return v29 & 1;
}

uint64_t SIMD.init(arrayLiteral:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v14 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a3 + 48),  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = type metadata accessor for Array(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for [A], v10, v11);
  return SIMD.init<A>(_:)((uint64_t)&v14, a2, v10, a3, WitnessTable, a4);
}

uint64_t SIMD.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v47 = a2;
  uint64_t v42 = (uint64_t)a5;
  uint64_t v43 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v40 - v12;
  uint64_t v44 = v14;
  uint64_t v17 = type metadata accessor for Optional(0LL, v14, v15, v16);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v40 - v19;
  uint64_t v21 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v40 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v41 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v26 = (char *)&v40 - v25;
  uint64_t v27 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  uint64_t v45 = a6;
  v27(v47, v9);
  uint64_t v40 = v21;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v23, v43, a3);
  unint64_t v28 = *(void (**)(uint64_t))(v42 + 32);
  unint64_t v46 = v26;
  uint64_t v29 = v42;
  v28(a3);
  uint64_t v42 = a3;
  uint64_t v30 = a3;
  unint64_t v31 = v24;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v29,  v30,  v24,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v33 = 0LL;
  unint64_t v34 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  while (1)
  {
    v34(v31, AssociatedConformanceWitness);
    uint64_t v35 = v44;
    uint64_t v36 = v11;
    (*(void (**)(char *, char *, uint64_t))(v11 + 32))(v13, v20, v35);
    uint64_t v37 = v47;
    if (v33 == (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v47, v9)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Too many elements in sequence.",  30LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0xF9uLL,  0);
    }
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v13, v33, v37, v9);
    BOOL v38 = __OFADD__(v33++, 1LL);
    uint64_t v11 = v36;
    if (v38)
    {
      __break(1u);
      break;
    }
  }

  (*(void (**)(char *, unint64_t))(v41 + 8))(v46, v31);
  if (v33 < (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v47, v9)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough elements in sequence.",  32LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0xFFuLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 8))(v43, v42);
}

uint64_t SIMD2.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()( a1,  a2,  associated type descriptor for SIMDScalar.SIMD2Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
}

uint64_t SIMD2.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x28uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD2.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x2CuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD3.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t SIMD3.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x587uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD3.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x58BuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD4.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()( a1,  a2,  associated type descriptor for SIMDScalar.SIMD4Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t SIMD4.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC5uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD4.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0xC9uLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD8.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()( a1,  a2,  associated type descriptor for SIMDScalar.SIMD8Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
}

uint64_t SIMD8.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1B7uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD8.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x1BBuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD16.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()( a1,  a2,  associated type descriptor for SIMDScalar.SIMD16Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
}

uint64_t SIMD16.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x27FuLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD16.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x283uLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD16Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD32.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()( a1,  a2,  associated type descriptor for SIMDScalar.SIMD32Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
}

uint64_t SIMD32.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x357uLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD32.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x35BuLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD32Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD64.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()( a1,  a2,  associated type descriptor for SIMDScalar.SIMD64Storage,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
}

uint64_t SIMD2.init()(uint64_t a1, const char *a2, _DWORD *a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a2,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  a4);
  return (*(uint64_t (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))( AssociatedTypeWitness,  AssociatedConformanceWitness);
}

uint64_t SIMD64.subscript.getter(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x44FuLL,  0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  uint64_t v7 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD64.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVectorTypes.swift",  27LL,  2,  0x453uLL,  0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD64Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  uint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t static SIMD<>..<= infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v56 = a2;
  uint64_t v57 = a5;
  uint64_t v55 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                  + 48);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  int64_t v50 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v47 = swift_getAssociatedTypeWitness( 0LL,  v50,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v47);
  unint64_t v46 = (char *)&v41 - v12;
  uint64_t v49 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v49);
  uint64_t v45 = (char *)&v41 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = a3;
  unint64_t v51 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v54 = *(void *)(v51 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v51);
  unint64_t v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v52 = (char *)&v41 - v18;
  uint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v10 + 48))(v19, v10);
  uint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v10 + 40);
  uint64_t v58 = a6;
  uint64_t v21 = v20;
  uint64_t result = v20(v19, v10);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    unint64_t v23 = 0LL;
    unint64_t v24 = *(void (**)(unint64_t, uint64_t, uint64_t))(v14 + 56);
    uint64_t v43 = v15;
    uint64_t v44 = result;
    uint64_t v48 = v10;
    uint64_t v25 = v53;
    while (1)
    {
      uint64_t v26 = v52;
      v24(v23, v15, v14);
      uint64_t v27 = v24;
      v24(v23, v15, v14);
      unint64_t v28 = v51;
      char v29 = (*(uint64_t (**)(char *, char *, unint64_t))(v57 + 24))(v26, v25, v51);
      uint64_t v30 = *(void (**)(char *, unint64_t))(v54 + 8);
      v30(v25, v28);
      unint64_t v31 = v26;
      uint64_t v32 = v48;
      v30(v31, v28);
      unint64_t v33 = v21(v19, v32);
      if ((v33 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v23 >= v33) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v41 = v21;
      unint64_t v34 = v47;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v50,  (uint64_t)v49,  v47,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v36 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v42 = v14;
      uint64_t v37 = v46;
      if ((v29 & 1) != 0)
      {
        BOOL v38 = &unk_18180BE78;
        uint64_t v39 = 257LL;
      }

      else
      {
        BOOL v38 = &unk_18180BE68;
        uint64_t v39 = 256LL;
      }

      v36(v38, v39, v34, AssociatedConformanceWitness);
      unint64_t v24 = v27;
      uint64_t v40 = v45;
      (*((void (**)(char *))v50 + 3))(v37);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v32 + 64))(v40, v23++, v19, v32);
      uint64_t result = v44;
      uint64_t v21 = v41;
      uint64_t v14 = v42;
      uint64_t v15 = v43;
      if (v44 == v23) {
        return result;
      }
    }

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v62 = a2;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  unint64_t v66 = AssociatedTypeWitness;
  uint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  uint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  uint64_t v13 = (char *)&v53 - v12;
  uint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  uint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  uint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v24 = (char *)&v53 - v23;
  size_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v65 = (char *)&v53 - v28;
  char v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a1, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  unint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  uint64_t v54 = v13;
  if (v31)
  {
    unint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  char v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  unint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  uint64_t v35 = swift_checkMetadataState(0LL, v66);
  uint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  unint64_t v66 = (uint64_t)v35;
  size_t v59 = v37;
  BOOL v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    uint64_t v39 = 0LL;
    uint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    unint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      uint64_t v42 = v40;
      v40(v39, a3, v15);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 24))(v21, v41, v16);
      uint64_t v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      uint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        int64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        int64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      unint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      unint64_t v34 = v65;
      uint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v62 = a1;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  unint64_t v66 = AssociatedTypeWitness;
  uint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  uint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  uint64_t v13 = (char *)&v53 - v12;
  uint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  uint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  uint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v24 = (char *)&v53 - v23;
  size_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v65 = (char *)&v53 - v28;
  char v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a2, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  unint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  uint64_t v54 = v13;
  if (v31)
  {
    unint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  char v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  unint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  uint64_t v35 = swift_checkMetadataState(0LL, v66);
  uint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  unint64_t v66 = (uint64_t)v35;
  size_t v59 = v37;
  BOOL v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    uint64_t v39 = 0LL;
    uint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    unint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      uint64_t v42 = v40;
      v40(v39, a3, v15);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 24))(v21, v41, v16);
      uint64_t v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      uint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        int64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        int64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      unint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      unint64_t v34 = v65;
      uint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

uint64_t static SIMD<>..> infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v56 = a2;
  uint64_t v57 = a5;
  uint64_t v55 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                  + 48);
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  int64_t v50 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  unint64_t v47 = swift_getAssociatedTypeWitness( 0LL,  v50,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v47);
  unint64_t v46 = (char *)&v41 - v12;
  uint64_t v49 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v49);
  uint64_t v45 = (char *)&v41 - v13;
  uint64_t v14 = *(void *)(a4 + 48);
  uint64_t v15 = a3;
  unint64_t v51 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v54 = *(void *)(v51 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v51);
  unint64_t v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v52 = (char *)&v41 - v18;
  uint64_t v19 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v10 + 48))(v19, v10);
  uint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v10 + 40);
  uint64_t v58 = a6;
  uint64_t v21 = v20;
  uint64_t result = v20(v19, v10);
  if (result < 0) {
    goto LABEL_12;
  }
  if (result)
  {
    unint64_t v23 = 0LL;
    unint64_t v24 = *(void (**)(unint64_t, uint64_t, uint64_t))(v14 + 56);
    uint64_t v43 = v15;
    uint64_t v44 = result;
    uint64_t v48 = v10;
    uint64_t v25 = v53;
    while (1)
    {
      uint64_t v26 = v52;
      v24(v23, v15, v14);
      uint64_t v27 = v24;
      v24(v23, v15, v14);
      unint64_t v28 = v51;
      char v29 = (*(uint64_t (**)(char *, char *, unint64_t))(v57 + 16))(v26, v25, v51);
      uint64_t v30 = *(void (**)(char *, unint64_t))(v54 + 8);
      v30(v25, v28);
      unint64_t v31 = v26;
      uint64_t v32 = v48;
      v30(v31, v28);
      unint64_t v33 = v21(v19, v32);
      if ((v33 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v23 >= v33) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v41 = v21;
      unint64_t v34 = v47;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v50,  (uint64_t)v49,  v47,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v36 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      uint64_t v42 = v14;
      uint64_t v37 = v46;
      if ((v29 & 1) != 0)
      {
        BOOL v38 = &unk_18180BE78;
        uint64_t v39 = 257LL;
      }

      else
      {
        BOOL v38 = &unk_18180BE68;
        uint64_t v39 = 256LL;
      }

      v36(v38, v39, v34, AssociatedConformanceWitness);
      unint64_t v24 = v27;
      uint64_t v40 = v45;
      (*((void (**)(char *))v50 + 3))(v37);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v32 + 64))(v40, v23++, v19, v32);
      uint64_t result = v44;
      uint64_t v21 = v41;
      uint64_t v14 = v42;
      uint64_t v15 = v43;
      if (v44 == v23) {
        return result;
      }
    }

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v62 = a2;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  unint64_t v66 = AssociatedTypeWitness;
  uint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  uint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  uint64_t v13 = (char *)&v53 - v12;
  uint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  uint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  uint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v24 = (char *)&v53 - v23;
  size_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v65 = (char *)&v53 - v28;
  char v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a1, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  unint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  uint64_t v54 = v13;
  if (v31)
  {
    unint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  char v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  unint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  uint64_t v35 = swift_checkMetadataState(0LL, v66);
  uint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  unint64_t v66 = (uint64_t)v35;
  size_t v59 = v37;
  BOOL v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    uint64_t v39 = 0LL;
    uint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    unint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      uint64_t v42 = v40;
      v40(v39, a3, v15);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 16))(v21, v41, v16);
      uint64_t v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      uint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        int64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        int64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      unint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      unint64_t v34 = v65;
      uint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v62 = a1;
  uint64_t v63 = a5;
  uint64_t v68 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for SIMD,  associated type descriptor for SIMD.MaskStorage);
  uint64_t v10 = *(const char **)(swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)
                       + 48);
  unint64_t v66 = AssociatedTypeWitness;
  uint64_t v67 = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 255LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v58 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a4,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for SIMD,  (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)
                                               + 8)
                                   + 24LL)
                       + 16LL);
  uint64_t v56 = swift_getAssociatedTypeWitness( 0LL,  v58,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v56);
  uint64_t v13 = (char *)&v53 - v12;
  uint64_t v57 = swift_checkMetadataState(0LL, v11);
  MEMORY[0x1895F8858](v57);
  uint64_t v55 = (char *)&v53 - v14;
  uint64_t v15 = *(void *)(a4 + 48);
  uint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v53 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  unint64_t v24 = (char *)&v53 - v23;
  size_t v64 = *(void *)(a3 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v65 = (char *)&v53 - v28;
  char v60 = v29;
  uint64_t v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a2, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  unint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0) {
    goto LABEL_16;
  }
  uint64_t v32 = v31;
  uint64_t v54 = v13;
  if (v31)
  {
    unint64_t v33 = 0LL;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }

    while (v32 != v33);
  }

  char v60 = *(void *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  unint64_t v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  uint64_t v35 = swift_checkMetadataState(0LL, v66);
  uint64_t v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  uint64_t v37 = (uint64_t (*)(uint64_t, const char *))*((void *)v36 + 5);
  unint64_t v66 = (uint64_t)v35;
  size_t v59 = v37;
  BOOL v38 = v37((uint64_t)v35, v36);
  if (v38 < 0) {
    goto LABEL_16;
  }
  if (v38)
  {
    uint64_t v39 = 0LL;
    uint64_t v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    unint64_t v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      uint64_t v41 = v61;
      uint64_t v42 = v40;
      v40(v39, a3, v15);
      uint64_t v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 16))(v21, v41, v16);
      uint64_t v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      uint64_t v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v39 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v46 = v56;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v58,  (uint64_t)v57,  v56,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v54;
      if ((v43 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        int64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        int64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      unint64_t v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      unint64_t v34 = v65;
      uint64_t v40 = v42;
      if (v53 == v39) {
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
      }
    }

uint64_t static SIMD<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  return static SIMD<>.random<A>(in:using:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  (void (*)(void, void, void, void, void, void))static FixedWidthInteger.random<A>(in:using:),  a8);
}

{
  return static SIMD<>.random<A>(in:using:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  (void (*)(void, void, void, void, void, void))static FixedWidthInteger.random<A>(in:using:),  a8);
}

uint64_t static SIMD<>.random(in:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return specialized static SIMD<>.random<A>(in:using:)( a1,  a2,  a2,  a3,  a4,  (void (*)(uint64_t, uint64_t, unint64_t, uint64_t))specialized static FixedWidthInteger.random<A>(in:using:),  a5);
}

{
  return specialized static SIMD<>.random<A>(in:using:)( a1,  a2,  a2,  a3,  a4,  (void (*)(uint64_t, uint64_t, unint64_t, uint64_t))specialized static FixedWidthInteger.random<A>(in:using:),  a5);
}

uint64_t specialized static SIMD<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void (*a6)(uint64_t, uint64_t, unint64_t, uint64_t)@<X5>, uint64_t a7@<X8>)
{
  uint64_t v25 = a6;
  uint64_t v12 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v24 - v14;
  (*(void (**)(uint64_t, uint64_t))(v12 + 48))(a3, v12);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 40))(a3, v12);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v17 = result;
  uint64_t v26 = a7;
  uint64_t v27 = a3;
  uint64_t v18 = v25;
  if (result)
  {
    uint64_t v19 = a2;
    uint64_t v20 = a1;
    uint64_t v21 = 0LL;
    do
    {
      uint64_t v22 = v20;
      uint64_t v23 = v19;
      v18(v20, v19, AssociatedTypeWitness, a5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v15, v21, v27, v12);
      uint64_t v20 = v22;
      uint64_t v19 = v23;
      ++v21;
    }

    while (v17 != v21);
  }

  return result;
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, void (*a8)(void, void, void, void, void, void)@<X7>, uint64_t a9@<X8>)
{
  uint64_t v34 = a7;
  uint64_t v35 = a8;
  uint64_t v33 = a6;
  uint64_t v14 = *(void *)(a5 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v17 = (char *)&v32 - v16;
  (*(void (**)(uint64_t, uint64_t))(v14 + 48))(a3, v14);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(a3, v14);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v19 = v33;
  uint64_t v20 = v34;
  uint64_t v38 = v14;
  uint64_t v39 = a3;
  uint64_t v21 = v35;
  uint64_t v37 = a9;
  if (result)
  {
    uint64_t v22 = a4;
    uint64_t v23 = a2;
    uint64_t v24 = a1;
    unint64_t v25 = AssociatedTypeWitness;
    uint64_t v26 = 0LL;
    uint64_t v36 = result;
    do
    {
      uint64_t v27 = v22;
      uint64_t v28 = v20;
      uint64_t v29 = v19;
      uint64_t v30 = v21;
      uint64_t v31 = v24;
      v21(v24, v23, v25, v22, v20, v19);
      (*(void (**)(char *, uint64_t, uint64_t))(v38 + 64))(v17, v26, v39);
      uint64_t v24 = v31;
      uint64_t v21 = v30;
      uint64_t v20 = v28;
      uint64_t result = v36;
      uint64_t v22 = v27;
      uint64_t v19 = v29;
      ++v26;
    }

    while (v36 != v26);
  }

  return result;
}

uint64_t static SIMD<>.zero.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 48) + 48LL))();
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  return static SIMD<>.random<A>(in:using:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  (void (*)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))static BinaryFloatingPoint<>.random<A>(in:using:));
}

{
  return static SIMD<>.random<A>(in:using:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  (void (*)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))static BinaryFloatingPoint<>.random<A>(in:using:));
}

uint64_t static SIMD<>.random(in:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return specialized static SIMD<>.random<A>(in:using:)( a1,  a2,  a2,  a3,  a4,  a5,  (void (*)(void, void, void, void, void))specialized static BinaryFloatingPoint<>.random<A>(in:using:),  a6);
}

{
  return specialized static SIMD<>.random<A>(in:using:)( a1,  a2,  a2,  a3,  a4,  a5,  (void (*)(void, void, void, void, void))specialized static BinaryFloatingPoint<>.random<A>(in:using:),  a6);
}

uint64_t specialized static SIMD<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void (*a7)(void, void, void, void, void)@<X6>, uint64_t a8@<X8>)
{
  uint64_t v30 = a6;
  uint64_t v31 = a7;
  uint64_t v13 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v16 = (char *)&v29 - v15;
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v33 = a8;
  uint64_t v34 = a3;
  uint64_t v18 = a1;
  uint64_t v20 = v30;
  uint64_t v19 = v31;
  uint64_t v32 = v13;
  if (result)
  {
    uint64_t v21 = a5;
    uint64_t v22 = a2;
    unint64_t v23 = AssociatedTypeWitness;
    uint64_t v24 = 0LL;
    do
    {
      uint64_t v25 = result;
      uint64_t v26 = v22;
      uint64_t v27 = v21;
      uint64_t v28 = v19;
      v19(v18, v22, v23, v21, v20);
      (*(void (**)(char *, uint64_t, uint64_t))(v32 + 64))(v16, v24, v34);
      uint64_t v19 = v28;
      uint64_t result = v25;
      uint64_t v22 = v26;
      uint64_t v21 = v27;
      ++v24;
    }

    while (v25 != v24);
  }

  return result;
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, void (*a10)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v35 = a7;
  uint64_t v36 = a8;
  uint64_t v34 = a6;
  uint64_t v15 = *(void *)(a5 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v18 = (char *)&v34 - v17;
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v40 = a9;
  uint64_t v41 = a3;
  uint64_t v21 = v34;
  uint64_t v20 = v35;
  uint64_t v22 = v36;
  uint64_t v39 = v15;
  if (result)
  {
    uint64_t v23 = a4;
    uint64_t v24 = a2;
    unint64_t v25 = AssociatedTypeWitness;
    uint64_t v26 = v18;
    uint64_t v27 = 0LL;
    uint64_t v37 = a10;
    uint64_t v38 = result;
    do
    {
      uint64_t v28 = a1;
      unint64_t v29 = v25;
      uint64_t v30 = v23;
      uint64_t v31 = v20;
      uint64_t v32 = a1;
      uint64_t v33 = v22;
      v37(v28, v24, v25, v23, v20, v21, v22);
      (*(void (**)(char *, uint64_t, uint64_t))(v39 + 64))(v26, v27, v41);
      unint64_t v25 = v29;
      uint64_t v20 = v31;
      uint64_t v22 = v33;
      a1 = v32;
      uint64_t result = v38;
      uint64_t v23 = v30;
      ++v27;
    }

    while (v38 != v27);
  }

  return result;
}

uint64_t (*SIMDMask._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMDMask.scalarCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 48LL) + 40LL))(*(void *)(a1 + 16));
}

uint64_t SIMDMask.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a3, a1);
}

uint64_t key path getter for SIMDMask.subscript(_:) : <A>SIMDMask<A>A@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  uint64_t v52 = a4;
  uint64_t v6 = (char *)a2 + a3;
  uint64_t v8 = *(uint64_t *)((char *)a2 + a3 - 32);
  uint64_t v7 = *(uint64_t *)((char *)a2 + a3 - 24);
  uint64_t v9 = *(void *)(v7 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  __int128 v54 = *((_OWORD *)v6 - 1);
  uint64_t v11 = *(void *)(v54 + 8);
  uint64_t v49 = *(char **)(*(void *)(v11 + 24) + 16LL);
  unint64_t v48 = swift_getAssociatedTypeWitness( 0LL,  v49,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v48);
  unint64_t v47 = (char *)&v46 - v12;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v53 = *(v13 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  int64_t v50 = (char *)&v46 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v51 = (char *)&v46 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v46 - v18;
  v55[0] = v8;
  v55[1] = v7;
  __int128 v56 = v54;
  uint64_t v20 = type metadata accessor for SIMDMask(0LL, (uint64_t)v55);
  uint64_t v21 = *(void *)(v20 - 8);
  MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v46 - v22;
  uint64_t v24 = *a2;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))((char *)&v46 - v22, a1, v20);
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v8, v9);
  if (v25 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v24 < 0 || v24 >= v25) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v21 + 8))(v23, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56))(v24, v8, v9);
  uint64_t v26 = *(uint64_t (**)(unint64_t *, uint64_t))(v11 + 64);
  if ((v26(v13, v11) & 1) != 0)
  {
    uint64_t v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 128))(v13, v11);
    if (v27 < 64)
    {
LABEL_6:
      unint64_t v30 = (*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 120))(v13, v11);
      uint64_t result = (*(uint64_t (**)(char *, unint64_t *))(v53 + 8))(v19, v13);
      uint64_t v32 = (void (*)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v30 >> 63);
LABEL_16:
      uint64_t v45 = v52;
      goto LABEL_17;
    }

    goto LABEL_10;
  }

  char v33 = v26(v13, v11);
  uint64_t v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 128))(v13, v11);
  if ((v33 & 1) == 0)
  {
    if (v27 >= 64)
    {
      uint64_t result = (*(uint64_t (**)(char *, unint64_t *))(v53 + 8))(v19, v13);
      LOBYTE(v32) = 0;
      goto LABEL_16;
    }

    goto LABEL_6;
  }

  if (v27 > 64)
  {
LABEL_10:
    v55[0] = 0LL;
    uint64_t v32 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v11 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    uint64_t v35 = v51;
    v32(v55, &type metadata for Int, v34, v13, v11);
    LOBYTE(v32) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v11 + 32) + 8LL)
                                                                                + 16LL))( v19,  v35,  v13);
    uint64_t v36 = *(void (**)(char *, unint64_t *))(v53 + 8);
    v36(v35, v13);
    uint64_t result = ((uint64_t (*)(char *, unint64_t *))v36)(v19, v13);
    goto LABEL_16;
  }

  unint64_t v38 = v48;
  uint64_t v37 = (void (**)(char *, unint64_t *, const char *))v49;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v49,  (uint64_t)v13,  v48,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v40 = v47;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v38,  AssociatedConformanceWitness);
  uint64_t v41 = v51;
  v37[3](v40, v13, (const char *)v37);
  LOBYTE(v37) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v11 + 32) + 8LL)
                                                                              + 16LL))( v19,  v41,  v13);
  uint64_t v42 = v53;
  uint64_t v43 = *(void (**)(char *, unint64_t *))(v53 + 8);
  v43(v41, v13);
  uint64_t v44 = v50;
  (*(void (**)(char *, char *, unint64_t *))(v42 + 32))(v50, v19, v13);
  else {
    uint64_t v32 = (void (*)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))((unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 120))(v13, v11) >> 63);
  }
  uint64_t v45 = v52;
  uint64_t result = ((uint64_t (*)(char *, unint64_t *))v43)(v44, v13);
LABEL_17:
  _BYTE *v45 = v32 & 1;
  return result;
}

uint64_t key path setter for SIMDMask.subscript(_:) : <A>SIMDMask<A>A( unsigned __int8 *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = *(uint64_t *)((char *)a3 + a4 - 32);
  uint64_t v8 = *(const char **)(*(void *)(*(void *)(*(uint64_t *)((char *)a3 + a4 - 16) + 8) + 24LL) + 16LL);
  uint64_t v9 = *(void *)(*(uint64_t *)((char *)a3 + a4 - 24) + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  v7,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  v26[0] = (uint64_t)v8;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v11);
  uint64_t v13 = (char *)v26 - v12;
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = (char *)v26 - v15;
  uint64_t v17 = *a3;
  int v18 = *a1;
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v26[1] = a2;
  uint64_t v20 = v19(v7, v9);
  if (v20 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v17 < 0 || v17 >= v20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
  }
  uint64_t v21 = v26[0];
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v26[0],  (uint64_t)v14,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v18)
  {
    uint64_t v23 = &unk_18180BE78;
    uint64_t v24 = 257LL;
  }

  else
  {
    uint64_t v23 = &unk_18180BE68;
    uint64_t v24 = 256LL;
  }

  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v23,  v24,  v11,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t *, uint64_t))(v21 + 24))(v13, v14, v21);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v16, v17, v7, v9);
}

void (*SIMDMask.subscript.modify(void *a1, uint64_t a2, void *a3))(uint64_t a1, char a2)
{
  uint64_t v7 = malloc(0x90uLL);
  *a1 = v7;
  v7[2] = a2;
  v7[3] = v3;
  uint64_t v47 = *(void *)(a3[4] + 8LL);
  uint64_t v8 = *(const char **)(*(void *)(v47 + 24) + 16LL);
  v7[4] = v8;
  uint64_t v9 = a3[2];
  uint64_t v10 = *(void *)(a3[3] + 48LL);
  v7[5] = v10;
  v7[6] = v9;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v10,  v9,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = (uint64_t)v8;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7[7] = v12;
  uint64_t v42 = v12;
  uint64_t v41 = malloc(*(void *)(*(void *)(v12 - 8) + 64LL));
  v7[8] = v41;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[9] = v13;
  uint64_t v46 = *(v13 - 1);
  size_t v14 = *(void *)(v46 + 64);
  v7[10] = malloc(v14);
  v7[11] = malloc(v14);
  uint64_t v43 = malloc(v14);
  v7[12] = v43;
  uint64_t v45 = malloc(v14);
  v7[13] = v45;
  uint64_t v15 = malloc(v14);
  v7[14] = v15;
  uint64_t v16 = *(a3 - 1);
  uint64_t v17 = malloc(*(void *)(v16 + 64));
  v7[15] = v17;
  (*(void (**)(void))(v16 + 16))();
  int v18 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 40);
  v7[16] = v18;
  uint64_t v19 = v18(v9, v10);
  if (v19 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a2 < 0 || v19 <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
  }
  (*(void (**)(void *, void *))(v16 + 8))(v17, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(a2, v9, v10);
  uint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v47 + 64);
  if ((v20(v13, v47) & 1) != 0)
  {
    uint64_t v21 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
    if (v21 < 64)
    {
LABEL_6:
      unint64_t v24 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47);
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      unint64_t v25 = v24 >> 63;
LABEL_18:
      uint64_t v39 = v7 + 17;
      goto LABEL_19;
    }

    v7[1] = 0LL;
    unint64_t v34 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    unint64_t v35 = lazy protocol witness table accessor for type Int and conformance Int(v21, v22, v23);
    v34(v7 + 1, &type metadata for Int, v35, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(void *)(*(void *)(v47 + 32) + 8LL)
                                                                                + 16LL))( v15,  v45,  v13);
    uint64_t v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    char v33 = v15;
LABEL_12:
    v32(v33, v13);
    goto LABEL_18;
  }

  char v26 = v20(v13, v47);
  uint64_t v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
  if ((v26 & 1) == 0)
  {
    if (v27 >= 64)
    {
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      LOBYTE(v25) = 0;
      goto LABEL_18;
    }

    goto LABEL_6;
  }

  if (v27 > 64)
  {
    *uint64_t v7 = 0LL;
    unint64_t v30 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    unint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    v30(v7, &type metadata for Int, v31, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(void *)(*(void *)(v47 + 32) + 8LL)
                                                                                + 16LL))( v15,  v45,  v13);
    uint64_t v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    char v33 = v15;
    goto LABEL_12;
  }

  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v44,  (uint64_t)v13,  v42,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v42,  AssociatedConformanceWitness);
  (*(void (**)(void *, unint64_t *, uint64_t))(v44 + 24))(v41, v13, v44);
  char v37 = (*(uint64_t (**)(void *, void *, unint64_t *))(*(void *)(*(void *)(v47 + 32) + 8LL) + 16LL))( v15,  v45,  v13);
  unint64_t v38 = *(void (**)(void *, unint64_t *))(v46 + 8);
  v38(v45, v13);
  (*(void (**)(void *, void *, unint64_t *))(v46 + 32))(v43, v15, v13);
  if ((v37 & 1) != 0) {
    LOBYTE(v25) = 1;
  }
  else {
    unint64_t v25 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47) >> 63;
  }
  uint64_t v39 = v7 + 17;
  v38(v43, v13);
LABEL_19:
  *uint64_t v39 = v25 & 1;
  return SIMDMask.subscript.modify;
}

void SIMDMask.subscript.modify(uint64_t a1, char a2)
{
  uint64_t v3 = *(void **)a1;
  int v4 = *(unsigned __int8 *)(*(void *)a1 + 136LL);
  unint64_t v5 = (*(uint64_t (**)(void, void))(*(void *)a1 + 128LL))( *(void *)(*(void *)a1 + 48LL),  *(void *)(*(void *)a1 + 40LL));
  if ((a2 & 1) != 0)
  {
    if ((v5 & 0x8000000000000000LL) == 0)
    {
      unint64_t v6 = v3[2];
      if (v5 > v6)
      {
        uint64_t v28 = (void *)v3[14];
        uint64_t v29 = (void *)v3[15];
        uint64_t v7 = (void *)v3[11];
        char v26 = (void *)v3[12];
        uint64_t v27 = (void *)v3[13];
        uint64_t v8 = v3[9];
        uint64_t v9 = (void *)v3[10];
        uint64_t v10 = v3[7];
        unint64_t v11 = (void *)v3[8];
        uint64_t v12 = v3[5];
        uint64_t v13 = v3[4];
        uint64_t v25 = v3[6];
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  v8,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        if (v4) {
          uint64_t v15 = 257LL;
        }
        else {
          uint64_t v15 = 256LL;
        }
        if (v4) {
          uint64_t v16 = &unk_18180BE78;
        }
        else {
          uint64_t v16 = &unk_18180BE68;
        }
        (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v16,  v15,  v10,  AssociatedConformanceWitness);
        (*(void (**)(void *, uint64_t, uint64_t))(v13 + 24))(v11, v8, v13);
        uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
        int v18 = v9;
        goto LABEL_21;
      }

Swift::Int SIMDMask.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMDMask<A>, a3);
}

{
  uint64_t WitnessTable;
  void v6[5];
  __int128 v7;
  __int128 v8;
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  uint64_t v7 = 0u;
  uint64_t v8 = 0u;
  uint64_t WitnessTable = swift_getWitnessTable(a2, a1, a3);
  SIMD.hash(into:)((uint64_t)v6, a1, WitnessTable);
  return Hasher._finalize()();
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMDMask<A>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 48LL) + 40LL))(*(void *)(a1 + 16));
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMDMask<A>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 48LL) + 48LL))(*(void *)(a1 + 16));
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMDMask<A>@<X0>( uint64_t a1@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v5 = v3;
  int64_t v50 = a3;
  uint64_t v7 = *(void *)(a2[4] + 8LL);
  uint64_t v8 = *(const char **)(*(void *)(v7 + 24) + 16LL);
  uint64_t v9 = a2[2];
  uint64_t v10 = *(void *)(a2[3] + 48LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v10,  v9,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v48 = v8;
  unint64_t v46 = swift_getAssociatedTypeWitness( 0LL,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v46);
  uint64_t v45 = (char *)&v45 - v12;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v51 = *(v13 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v47 = (char *)&v45 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v49 = (char *)&v45 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v45 - v19;
  uint64_t v21 = *(a2 - 1);
  MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v45 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, void *))(v21 + 16))(v23, v5, a2);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 40))(v9, v10);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a1 < 0 || v24 <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
  }
  (*(void (**)(char *, void *))(v21 + 8))(v23, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(a1, v9, v10);
  uint64_t v25 = *(uint64_t (**)(unint64_t *, uint64_t))(v7 + 64);
  if ((v25(v13, v7) & 1) != 0)
  {
    uint64_t v26 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v13, v7);
    if (v26 < 64)
    {
LABEL_6:
      unint64_t v29 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v13, v7);
      uint64_t result = (*(uint64_t (**)(char *, unint64_t *))(v51 + 8))(v20, v13);
      unint64_t v31 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v29 >> 63);
LABEL_16:
      uint64_t v44 = v50;
      goto LABEL_17;
    }

    goto LABEL_10;
  }

  char v32 = v25(v13, v7);
  uint64_t v26 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v13, v7);
  if ((v32 & 1) == 0)
  {
    if (v26 >= 64)
    {
      uint64_t result = (*(uint64_t (**)(char *, unint64_t *))(v51 + 8))(v20, v13);
      LOBYTE(v31) = 0;
      goto LABEL_16;
    }

    goto LABEL_6;
  }

  if (v26 > 64)
  {
LABEL_10:
    uint64_t v52 = 0LL;
    unint64_t v31 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v7 + 96);
    unint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v26, v27, v28);
    unint64_t v34 = v49;
    v31(&v52, &type metadata for Int, v33, v13, v7);
    LOBYTE(v31) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v7 + 32) + 8LL)
                                                                                + 16LL))( v20,  v34,  v13);
    unint64_t v35 = *(void (**)(char *, unint64_t *))(v51 + 8);
    v35(v34, v13);
    uint64_t result = ((uint64_t (*)(char *, unint64_t *))v35)(v20, v13);
    goto LABEL_16;
  }

  uint64_t v36 = (uint64_t)v48;
  unint64_t v37 = v46;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v48,  (uint64_t)v13,  v46,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v39 = v45;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v37,  AssociatedConformanceWitness);
  uint64_t v40 = v49;
  (*(void (**)(char *, unint64_t *, uint64_t))(v36 + 24))(v39, v13, v36);
  LOBYTE(v36) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v7 + 32) + 8LL)
                                                                              + 16LL))( v20,  v40,  v13);
  uint64_t v41 = v51;
  uint64_t v42 = *(void (**)(char *, unint64_t *))(v51 + 8);
  v42(v40, v13);
  uint64_t v43 = v47;
  (*(void (**)(char *, char *, unint64_t *))(v41 + 32))(v47, v20, v13);
  if ((v36 & 1) != 0) {
    LOBYTE(v31) = 1;
  }
  else {
    unint64_t v31 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))((unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v13, v7) >> 63);
  }
  uint64_t v44 = v50;
  uint64_t result = ((uint64_t (*)(char *, unint64_t *))v42)(v43, v13);
LABEL_17:
  *uint64_t v44 = v31 & 1;
  return result;
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMDMask<A>( unsigned __int8 *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a3[4] + 8LL) + 24LL) + 16LL);
  uint64_t v7 = a3[2];
  uint64_t v8 = *(void *)(a3[3] + 48LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v8,  v7,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v10);
  uint64_t v12 = (char *)&v23 - v11;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  MEMORY[0x1895F8858](v13);
  uint64_t v15 = (char *)&v23 - v14;
  int v16 = *a1;
  uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v24 = v3;
  uint64_t v18 = v17(v7, v8);
  if (v18 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a2 < 0 || v18 <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
  }
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  (uint64_t)v13,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v16)
  {
    uint64_t v20 = &unk_18180BE78;
    uint64_t v21 = 257LL;
  }

  else
  {
    uint64_t v20 = &unk_18180BE68;
    uint64_t v21 = 256LL;
  }

  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v20,  v21,  v10,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t *, uint64_t))(v6 + 24))(v12, v13, v6);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v15, a2, v7, v8);
}

void (*protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>( void *a1, uint64_t a2, void *a3))(uint64_t a1, char a2)
{
  uint64_t v7 = malloc(0x90uLL);
  *a1 = v7;
  v7[2] = a2;
  v7[3] = v3;
  uint64_t v47 = *(void *)(a3[4] + 8LL);
  uint64_t v8 = *(const char **)(*(void *)(v47 + 24) + 16LL);
  v7[4] = v8;
  uint64_t v9 = a3[2];
  uint64_t v10 = *(void *)(a3[3] + 48LL);
  v7[5] = v10;
  v7[6] = v9;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v10,  v9,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = (uint64_t)v8;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7[7] = v12;
  uint64_t v42 = v12;
  uint64_t v41 = malloc(*(void *)(*(void *)(v12 - 8) + 64LL));
  v7[8] = v41;
  uint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v7[9] = v13;
  uint64_t v46 = *(v13 - 1);
  size_t v14 = *(void *)(v46 + 64);
  uint64_t v43 = malloc(v14);
  v7[10] = v43;
  v7[11] = malloc(v14);
  v7[12] = malloc(v14);
  uint64_t v45 = malloc(v14);
  v7[13] = v45;
  uint64_t v15 = malloc(v14);
  v7[14] = v15;
  uint64_t v16 = *(a3 - 1);
  uint64_t v17 = malloc(*(void *)(v16 + 64));
  v7[15] = v17;
  (*(void (**)(void))(v16 + 16))();
  uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 40);
  v7[16] = v18;
  uint64_t v19 = v18(v9, v10);
  if (v19 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a2 < 0 || v19 <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
  }
  (*(void (**)(void *, void *))(v16 + 8))(v17, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(a2, v9, v10);
  uint64_t v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v47 + 64);
  if ((v20(v13, v47) & 1) != 0)
  {
    uint64_t v21 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
    if (v21 < 64)
    {
LABEL_6:
      unint64_t v24 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47);
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      unint64_t v25 = v24 >> 63;
LABEL_18:
      uint64_t v39 = v7 + 17;
      goto LABEL_19;
    }

    v7[1] = 0LL;
    unint64_t v34 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    unint64_t v35 = lazy protocol witness table accessor for type Int and conformance Int(v21, v22, v23);
    v34(v7 + 1, &type metadata for Int, v35, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(void *)(*(void *)(v47 + 32) + 8LL)
                                                                                + 16LL))( v15,  v45,  v13);
    char v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    unint64_t v33 = v15;
LABEL_12:
    v32(v33, v13);
    goto LABEL_18;
  }

  char v26 = v20(v13, v47);
  uint64_t v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
  if ((v26 & 1) == 0)
  {
    if (v27 >= 64)
    {
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      LOBYTE(v25) = 0;
      goto LABEL_18;
    }

    goto LABEL_6;
  }

  if (v27 > 64)
  {
    *uint64_t v7 = 0LL;
    unint64_t v30 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    unint64_t v31 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    v30(v7, &type metadata for Int, v31, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(void *)(*(void *)(v47 + 32) + 8LL)
                                                                                + 16LL))( v15,  v45,  v13);
    char v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    unint64_t v33 = v15;
    goto LABEL_12;
  }

  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v44,  (uint64_t)v13,  v42,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v42,  AssociatedConformanceWitness);
  (*(void (**)(void *, unint64_t *, uint64_t))(v44 + 24))(v41, v13, v44);
  char v37 = (*(uint64_t (**)(void *, void *, unint64_t *))(*(void *)(*(void *)(v47 + 32) + 8LL) + 16LL))( v15,  v45,  v13);
  unint64_t v38 = *(void (**)(void *, unint64_t *))(v46 + 8);
  v38(v45, v13);
  (*(void (**)(void *, void *, unint64_t *))(v46 + 32))(v43, v15, v13);
  if ((v37 & 1) != 0) {
    LOBYTE(v25) = 1;
  }
  else {
    unint64_t v25 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47) >> 63;
  }
  uint64_t v39 = v7 + 17;
  v38(v43, v13);
LABEL_19:
  *uint64_t v39 = v25 & 1;
  return protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>;
}

void protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>(uint64_t a1, char a2)
{
  uint64_t v3 = *(void **)a1;
  int v4 = *(unsigned __int8 *)(*(void *)a1 + 136LL);
  unint64_t v5 = (*(uint64_t (**)(void, void))(*(void *)a1 + 128LL))( *(void *)(*(void *)a1 + 48LL),  *(void *)(*(void *)a1 + 40LL));
  if ((a2 & 1) != 0)
  {
    if ((v5 & 0x8000000000000000LL) == 0)
    {
      unint64_t v6 = v3[2];
      if (v5 > v6)
      {
        uint64_t v28 = (void *)v3[14];
        uint64_t v29 = (void *)v3[15];
        uint64_t v7 = (void *)v3[12];
        uint64_t v8 = (void *)v3[11];
        char v26 = (void *)v3[10];
        uint64_t v27 = (void *)v3[13];
        uint64_t v10 = (void *)v3[8];
        uint64_t v9 = v3[9];
        uint64_t v11 = v3[7];
        uint64_t v13 = v3[4];
        uint64_t v12 = v3[5];
        uint64_t v25 = v3[6];
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  v9,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        if (v4) {
          uint64_t v15 = 257LL;
        }
        else {
          uint64_t v15 = 256LL;
        }
        if (v4) {
          uint64_t v16 = &unk_18180BE78;
        }
        else {
          uint64_t v16 = &unk_18180BE68;
        }
        (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v16,  v15,  v11,  AssociatedConformanceWitness);
        (*(void (**)(void *, uint64_t, uint64_t))(v13 + 24))(v10, v9, v13);
        uint64_t v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
        uint64_t v18 = v8;
        goto LABEL_21;
      }

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMDMask<A>( void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMDMask<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMDMask<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for SIMDMask<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMDMask<A>( unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMDMask<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMDMask<A>( char *a1, char *a2, void *a3)
{
  uint64_t v6 = *(void *)(a3[4] + 8LL);
  uint64_t v7 = *(const char **)(*(void *)(v6 + 24) + 16LL);
  uint64_t v8 = a3[2];
  uint64_t v9 = *(void *)(a3[3] + 48LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  v8,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  unint64_t v127 = swift_getAssociatedTypeWitness( 0LL,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v127);
  uint64x2_t v126 = (char *)&v114 - v11;
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v130 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint8x8_t v123 = (char *)&v114 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64x2_t v128 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint32x4_t v125 = (char *)&v114 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint32x4_t v129 = (char *)&v114 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  int8x16_t v133 = (char *)&v114 - v22;
  uint64_t v138 = *(a3 - 1);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  int8x16_t v131 = (char *)&v114 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  int8x16_t v135 = (char *)&v114 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  int8x8_t v139 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  unint64_t v30 = (char *)&v114 - v29;
  unint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  int8x16_t v136 = a1;
  uint64_t v137 = v8;
  uint16x8_t v134 = v31;
  uint64_t v32 = v31(v8, v9);
  if (v32 < 0) {
LABEL_48:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  if (v32)
  {
    int8x16_t v121 = v7;
    uint64_t v122 = v6;
    unint64_t v33 = 0LL;
    char v34 = 1;
    unint64_t v35 = *(void (**)(char *, char *, void *))(v138 + 16);
    uint64_t v36 = v133;
    uint64_t v132 = v32;
    while (1)
    {
      v35(v30, v136, a3);
      char v37 = v139;
      v35(v139, a2, a3);
      if ((v34 & 1) != 0) {
        break;
      }
      unint64_t v48 = *(void (**)(char *, void *))(v138 + 8);
      v48(v37, a3);
      v48(v30, a3);
      char v34 = 0;
LABEL_11:
      if (v132 == ++v33) {
        return v34 & 1;
      }
    }

    v35(v135, v30, a3);
    unint64_t v38 = v134(v137, v9);
    if ((v38 & 0x8000000000000000LL) != 0) {
      goto LABEL_48;
    }
    if (v33 >= v38) {
      goto LABEL_45;
    }
    uint16x8_t v124 = v35;
    uint64_t v39 = *(void (**)(char *, void *))(v138 + 8);
    v39(v135, a3);
    uint64_t v40 = v36;
    uint64_t v117 = *(void (**)(unint64_t, uint64_t, uint64_t))(v9 + 56);
    v117(v33, v137, v9);
    unint64_t v119 = v39;
    v39(v30, a3);
    uint64_t v41 = v122;
    uint64_t v42 = *(uint64_t (**)(unint64_t *, uint64_t))(v122 + 64);
    char v43 = v42(v12, v122);
    int64x2_t v115 = a2;
    int8x16_t v118 = v42;
    if ((v43 & 1) != 0)
    {
      int64x2_t v116 = *(uint64_t (**)(unint64_t *, uint64_t))(v41 + 128);
      uint64_t v44 = v116(v12, v41);
      uint64_t v47 = v124;
      if (v44 < 64) {
        goto LABEL_20;
      }
      v140[0] = 0LL;
      size_t v59 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
      unint64_t v60 = lazy protocol witness table accessor for type Int and conformance Int(v44, v45, v46);
      uint64_t v61 = v129;
      v59(v140, &type metadata for Int, v60, v12, v41);
      uint64_t v114 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v41 + 32) + 8LL)
                                                                           + 16LL))( v133,  v61,  v12);
      uint64_t v57 = *(void (**)(char *, unint64_t *))(v130 + 8);
      uint64_t v62 = v61;
      uint64_t v63 = v133;
      v57(v62, v12);
      uint64_t v58 = v63;
    }

    else
    {
      char v49 = v42(v12, v41);
      int64x2_t v116 = *(uint64_t (**)(unint64_t *, uint64_t))(v41 + 128);
      uint64_t v50 = v116(v12, v41);
      if ((v49 & 1) == 0)
      {
        uint64_t v47 = v124;
        if (v50 < 64)
        {
LABEL_20:
          unint64_t v64 = (*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41);
          int64x2_t v120 = *(void (**)(char *, unint64_t *))(v130 + 8);
          v120(v40, v12);
          uint64_t v114 = v64 >> 63;
          goto LABEL_23;
        }

        int64x2_t v120 = *(void (**)(char *, unint64_t *))(v130 + 8);
        v120(v40, v12);
        uint64_t v114 = 0LL;
LABEL_23:
        int v75 = v139;
        v47(v131, v139, a3);
        goto LABEL_24;
      }

      uint64_t v47 = v124;
      if (v50 <= 64)
      {
        uint64_t v65 = (uint64_t)v121;
        unint64_t v66 = v127;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v121,  (uint64_t)v12,  v127,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v68 = v126;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v66,  AssociatedConformanceWitness);
        uint64_t v69 = v129;
        (*(void (**)(char *, unint64_t *, uint64_t))(v65 + 24))(v68, v12, v65);
        uint64_t v70 = v133;
        LOBYTE(v66) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v41 + 32)
                                                                                                + 8LL)
                                                                                    + 16LL))( v133,  v69,  v12);
        uint64_t v71 = v130;
        int64x2_t v120 = *(void (**)(char *, unint64_t *))(v130 + 8);
        v120(v69, v12);
        uint64_t v72 = *(void (**)(char *, char *, unint64_t *))(v71 + 32);
        uint64_t v73 = v125;
        v72(v125, v70, v12);
        if ((v66 & 1) != 0) {
          unint64_t v74 = 1LL;
        }
        else {
          unint64_t v74 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41) >> 63;
        }
        uint64_t v114 = v74;
        v120(v73, v12);
        int v75 = v139;
        v124(v131, v139, a3);
LABEL_24:
        unint64_t v76 = v134(v137, v9);
        if ((v76 & 0x8000000000000000LL) != 0) {
          goto LABEL_48;
        }
        if (v33 >= v76) {
LABEL_45:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2C8uLL,  0);
        unsigned int v77 = v119;
        v119(v131, a3);
        uint64_t v78 = v128;
        v117(v33, v137, v9);
        v77(v75, a3);
        uint64_t v79 = v118;
        if ((v118(v12, v41) & 1) != 0)
        {
          uint64_t v80 = v116(v12, v41);
          if (v80 >= 64)
          {
            v140[0] = 0LL;
            uint64_t v94 = v78;
            uint64_t v95 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
            unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
            size_t v97 = v129;
            v95(v140, &type metadata for Int, v96, v12, v41);
            LOBYTE(v84) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v41 + 32) + 8LL)
                                                                                        + 16LL))( v94,  v97,  v12);
            uint64_t v36 = v133;
            uint64_t v98 = v120;
            v120(v97, v12);
            v98(v94, v12);
            a2 = v115;
          }

          else
          {
            unint64_t v83 = (*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41);
            v120(v78, v12);
            unint64_t v84 = v83 >> 63;
            a2 = v115;
            uint64_t v36 = v133;
          }

          char v99 = v114;
          unint64_t v35 = v124;
        }

        else
        {
          char v85 = v79(v12, v41);
          uint64_t v86 = v116(v12, v41);
          if ((v85 & 1) != 0)
          {
            unint64_t v35 = v124;
            if (v86 <= 64)
            {
              uint64_t v102 = (uint64_t)v121;
              unint64_t v103 = v127;
              unint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v121,  (uint64_t)v12,  v127,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              unint64_t v105 = v126;
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v104 + 8))( &unk_18180BE68,  256LL,  v103,  v104);
              uint64_t v106 = v102;
              unint64_t v107 = *(void (**)(char *, unint64_t *, uint64_t))(v102 + 24);
              unint64_t v108 = v129;
              unint64_t v109 = v105;
              int64x2_t v110 = v128;
              v107(v109, v12, v106);
              LOBYTE(v103) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v41 + 32) + 8LL)
                                                                                           + 16LL))( v110,  v108,  v12);
              v120(v108, v12);
              int8x16_t v111 = v123;
              (*(void (**)(char *, char *, unint64_t *))(v130 + 32))(v123, v110, v12);
              if ((v103 & 1) != 0) {
                LOBYTE(v84) = 1;
              }
              else {
                unint64_t v84 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41) >> 63;
              }
              int8x16_t v112 = v111;
              a2 = v115;
              uint64_t v36 = v133;
              char v99 = v114;
              v120(v112, v12);
              goto LABEL_44;
            }

            v140[0] = 0LL;
            uint64_t v89 = *(void (**)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
            unint64_t v90 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
            size_t v91 = v129;
            v89(v140, &type metadata for Int, v90, v12, v41);
            uint64_t v92 = v128;
            LOBYTE(v84) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v41 + 32) + 8LL)
                                                                                        + 16LL))( v128,  v91,  v12);
            uint64_t v93 = v120;
            v120(v91, v12);
            v93(v92, v12);
          }

          else
          {
            unint64_t v35 = v124;
            if (v86 < 64)
            {
              uint64_t v100 = v128;
              unint64_t v101 = (*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41);
              v120(v100, v12);
              unint64_t v84 = v101 >> 63;
            }

            else
            {
              v120(v128, v12);
              LOBYTE(v84) = 0;
            }
          }

          a2 = v115;
          uint64_t v36 = v133;
          char v99 = v114;
        }

uint64_t specialized static SIMDMask.random<A>(using:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(const char **)(*(void *)(*(void *)(a4 + 8) + 24LL) + 16LL);
  uint64_t v6 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v28 = v5;
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v8);
  uint64_t v10 = (char *)&v24 - v9;
  uint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  MEMORY[0x1895F8858](v11);
  uint64_t v27 = (char *)&v24 - v12;
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(a2, v6);
  uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 40);
  uint64_t result = v13(a2, v6);
  if (result < 0) {
    goto LABEL_12;
  }
  uint64_t v15 = result;
  uint64_t v26 = v10;
  if (result)
  {
    unint64_t v16 = 0LL;
    while (1)
    {
      uint64_t __buf = 0LL;
      swift_stdlib_random(&__buf, 8uLL);
      int v17 = __buf;
      unint64_t v18 = v13(a2, v6);
      if ((v18 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v16 >= v18) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v19 = *(void (**)(void *, uint64_t))(swift_getAssociatedConformanceWitness( (uint64_t)v28,  (uint64_t)v11,  v8,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral)
                                                   + 8);
      uint64_t v24 = v13;
      unint64_t v25 = v8;
      uint64_t v20 = v26;
      if ((v17 & 0x20000) != 0)
      {
        uint64_t v21 = &unk_18180BE68;
        uint64_t v22 = 256LL;
      }

      else
      {
        uint64_t v21 = &unk_18180BE78;
        uint64_t v22 = 257LL;
      }

      v19(v21, v22);
      uint64_t v23 = v27;
      (*((void (**)(char *, unint64_t *))v28 + 3))(v20, v11);
      uint64_t result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v6 + 64))(v23, v16++, a2, v6);
      uint64_t v13 = v24;
      unint64_t v8 = v25;
      if (v15 == v16) {
        return result;
      }
    }

uint64_t static SIMDMask.random<A>(using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v12 = *(const char **)(*(void *)(*(void *)(a6 + 8) + 24LL) + 16LL);
  uint64_t v13 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v13,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  char v43 = v12;
  unint64_t v41 = swift_getAssociatedTypeWitness( 0LL,  v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v41);
  unint64_t v16 = (char *)&v36 - v15;
  uint64_t v42 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  MEMORY[0x1895F8858](v42);
  uint64_t v40 = (char *)&v36 - v17;
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a2, v13);
  unint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(v13 + 40);
  uint64_t v44 = a2;
  uint64_t v45 = a7;
  uint64_t result = v18(a2, v13);
  if (result < 0) {
    goto LABEL_12;
  }
  uint64_t v20 = result;
  uint64_t v39 = v16;
  if (result)
  {
    unint64_t v21 = 0LL;
    uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 8);
    while (1)
    {
      uint64_t v23 = a1;
      uint64_t v24 = a3;
      uint64_t v25 = a3;
      uint64_t v26 = a5;
      int v27 = v22(v25, a5);
      unint64_t v28 = v18(v44, v13);
      if ((v28 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v21 >= v28) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      char v37 = v22;
      unint64_t v29 = v41;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v43,  (uint64_t)v42,  v41,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v31 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      unint64_t v38 = v18;
      uint64_t v32 = v39;
      if ((v27 & 0x20000) != 0)
      {
        unint64_t v33 = &unk_18180BE68;
        uint64_t v34 = 256LL;
      }

      else
      {
        unint64_t v33 = &unk_18180BE78;
        uint64_t v34 = 257LL;
      }

      v31(v33, v34, v29, AssociatedConformanceWitness);
      unint64_t v35 = v40;
      (*((void (**)(char *))v43 + 3))(v32);
      uint64_t result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v13 + 64))(v35, v21++, v44, v13);
      a5 = v26;
      a3 = v24;
      a1 = v23;
      uint64_t v22 = v37;
      unint64_t v18 = v38;
      if (v20 == v21) {
        return result;
      }
    }

uint64_t static SIMDMask.random()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized static SIMDMask.random<A>(using:)(a1, a1, a2, a3);
}

uint64_t SIMD<>.leadingZeroBitCount.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = a1;
  uint64_t v7 = *(void *)(a2 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v37 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v32 - v12;
  uint64_t v14 = a4;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v36 = v13;
  if (result)
  {
    uint64_t v16 = 0LL;
    unint64_t v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v34 = v7;
    uint64_t v35 = result;
    do
    {
      uint64_t v38 = v16 + 1;
      v33(v16, v5, v7);
      uint64_t v17 = (*(uint64_t (**)(unint64_t, uint64_t))(a3 + 152))(AssociatedTypeWitness, a3);
      uint64_t v18 = (*(uint64_t (**)(char *, unint64_t))(v37 + 8))(v11, AssociatedTypeWitness);
      uint64_t v39 = v17;
      unint64_t v19 = AssociatedTypeWitness;
      uint64_t v20 = v11;
      uint64_t v21 = v14;
      uint64_t v22 = v5;
      uint64_t v23 = *(void *)(a3 + 8);
      uint64_t v24 = a3;
      uint64_t v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v23 + 88);
      unint64_t v28 = lazy protocol witness table accessor for type Int and conformance Int(v18, v26, v27);
      unint64_t v29 = v36;
      uint64_t v30 = v23;
      uint64_t v5 = v22;
      uint64_t v11 = v20;
      unint64_t AssociatedTypeWitness = v19;
      v25(&v39, &type metadata for Int, v28, v19, v30);
      a3 = v24;
      uint64_t v7 = v34;
      unint64_t v31 = v29;
      uint64_t v14 = v21;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v31, v16, v5, v34);
      uint64_t result = v35;
      uint64_t v16 = v38;
    }

    while (v35 != v38);
  }

  return result;
}

uint64_t SIMD<>.trailingZeroBitCount.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v37 = a3;
  uint64_t v4 = a1;
  uint64_t v6 = *(void *)(a2 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v32 - v12;
  uint64_t v14 = a4;
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(v4, v6);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 40))(v4, v6);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v36 = v13;
  if (result)
  {
    uint64_t v16 = 0LL;
    unint64_t v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56);
    uint64_t v34 = result;
    uint64_t v35 = v6;
    do
    {
      uint64_t v38 = v16 + 1;
      v33(v16, v4, v6);
      uint64_t v17 = v14;
      uint64_t v18 = v4;
      uint64_t v19 = *(void *)(v37 + 8);
      uint64_t v20 = (*(uint64_t (**)(unint64_t, uint64_t))(v19 + 144))(AssociatedTypeWitness, v19);
      uint64_t v21 = (*(uint64_t (**)(char *, unint64_t))(v8 + 8))(v11, AssociatedTypeWitness);
      uint64_t v39 = v20;
      unint64_t v22 = AssociatedTypeWitness;
      uint64_t v23 = v11;
      uint64_t v24 = v8;
      uint64_t v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v19 + 88);
      unint64_t v28 = lazy protocol witness table accessor for type Int and conformance Int(v21, v26, v27);
      unint64_t v29 = v36;
      uint64_t v30 = v19;
      uint64_t v4 = v18;
      uint64_t v6 = v35;
      v25(&v39, &type metadata for Int, v28, v22, v30);
      uint64_t v8 = v24;
      uint64_t v11 = v23;
      unint64_t AssociatedTypeWitness = v22;
      unint64_t v31 = v29;
      uint64_t v14 = v17;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v6 + 64))(v31, v16, v4, v6);
      uint64_t result = v34;
      uint64_t v16 = v38;
    }

    while (v34 != v38);
  }

  return result;
}

uint64_t SIMD<>.nonzeroBitCount.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = a1;
  uint64_t v7 = *(void *)(a2 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v37 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v32 - v12;
  uint64_t v14 = a4;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v36 = v13;
  if (result)
  {
    uint64_t v16 = 0LL;
    unint64_t v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v34 = v7;
    uint64_t v35 = result;
    do
    {
      uint64_t v38 = v16 + 1;
      v33(v16, v5, v7);
      uint64_t v17 = (*(uint64_t (**)(unint64_t, uint64_t))(a3 + 144))(AssociatedTypeWitness, a3);
      uint64_t v18 = (*(uint64_t (**)(char *, unint64_t))(v37 + 8))(v11, AssociatedTypeWitness);
      uint64_t v39 = v17;
      unint64_t v19 = AssociatedTypeWitness;
      uint64_t v20 = v11;
      uint64_t v21 = v14;
      uint64_t v22 = v5;
      uint64_t v23 = *(void *)(a3 + 8);
      uint64_t v24 = a3;
      uint64_t v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v23 + 88);
      unint64_t v28 = lazy protocol witness table accessor for type Int and conformance Int(v18, v26, v27);
      unint64_t v29 = v36;
      uint64_t v30 = v23;
      uint64_t v5 = v22;
      uint64_t v11 = v20;
      unint64_t AssociatedTypeWitness = v19;
      v25(&v39, &type metadata for Int, v28, v19, v30);
      a3 = v24;
      uint64_t v7 = v34;
      unint64_t v31 = v29;
      uint64_t v14 = v21;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v31, v16, v5, v34);
      uint64_t result = v35;
      uint64_t v16 = v38;
    }

    while (v35 != v38);
  }

  return result;
}

uint64_t static SIMD<>.~ prefix(_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v20 = a3;
  uint64_t v6 = *(void *)(a2 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v17 - v12;
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(a1, v6);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 40))(a1, v6);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v18 = v8;
  uint64_t v19 = a4;
  if (result)
  {
    uint64_t v15 = 0LL;
    uint64_t v17 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56);
    do
    {
      uint64_t v16 = result;
      v17(v15, a1, v6);
      (*(void (**)(char *, unint64_t))(*(void *)(v20 + 8) + 184LL))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v18 + 8))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v6 + 64))(v13, v15, a1, v6);
      uint64_t result = v16;
      ++v15;
    }

    while (v16 != v15);
  }

  return result;
}

uint64_t static SIMD<>.& infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v36 + 8) + 192LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 192LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v57 + 8) + 192LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.^ infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v36 + 8) + 224LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 224LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v57 + 8) + 224LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.| infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v36 + 8) + 208LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 208LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v57 + 8) + 208LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.&<< infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v34 = a2;
  uint64_t v27 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v27 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = a6;
  uint64_t v32 = a5;
  uint64_t v30 = v18;
  if (result)
  {
    unint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = 0LL;
    unint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v29 = result;
    do
    {
      uint64_t v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      uint64_t v23 = v9;
      uint64_t v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 216))(v16, v13, v20);
      uint64_t v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      uint64_t v26 = v24;
      uint64_t v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      uint64_t result = v29;
      ++v21;
    }

    while (v29 != v21);
  }

  return result;
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, unint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  __int128 v56 = a5;
  uint64_t v57 = a2;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v50 = (char *)&v48 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  size_t v59 = (char *)&v48 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  uint64_t v55 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  unint64_t v54 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v54)(a3, v9);
  uint64_t v27 = v21;
  unint64_t v28 = a3;
  uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v29 = v53(a3, v9);
  if (v29 < 0) {
    goto LABEL_10;
  }
  uint64_t v30 = v29;
  char v49 = v13;
  uint64_t v58 = a6;
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v32 = v59;
  if (v29)
  {
    uint64_t v33 = 0LL;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }

    while (v30 != v33);
  }

  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v55 + 1);
  v34(v26, v31);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v28);
  ((void (*)(uint64_t, uint64_t))v54)(v28, v9);
  uint64_t v36 = v53(v28, v9);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v35;
  uint64_t v39 = v49;
  uint64_t v38 = v50;
  uint64_t v55 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v40, v28, v9);
      v42(v40, v28, v9);
      char v43 = v9;
      uint64_t v44 = v59;
      (*(void (**)(char *, char *, unint64_t))(v56 + 216))(v38, v39, v31);
      uint64_t v45 = (void (*)(char *, unint64_t))v55;
      v55((uint64_t)v39, v31);
      v45(v38, v31);
      uint64_t v46 = v44;
      uint64_t v9 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v28, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v28);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t);
  uint64_t v42;
  char *v43;
  void (*v44)(char *, unint64_t);
  char *v45;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  char *v53;
  void (*v54)(uint64_t, unint64_t);
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v55 = a5;
  char v49 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v50 = (char *)&v47 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v57 = (char *)&v47 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v51 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v47 - v18);
  uint64_t v21 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v58 = (char *)&v47 - v23;
  unint64_t v54 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v53 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v53)(a3, v9);
  uint64_t v27 = v21;
  unint64_t v28 = a3;
  uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v29 = v52(a3, v9);
  if (v29 < 0) {
    goto LABEL_10;
  }
  uint64_t v30 = v29;
  unint64_t v48 = v13;
  __int128 v56 = a6;
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v32 = v57;
  if (v29)
  {
    uint64_t v33 = 0LL;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }

    while (v30 != v33);
  }

  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v54 + 1);
  v34(v26, v31);
  (*(void (**)(char *, char *, uint64_t))(v51 + 32))(v58, v27, v28);
  ((void (*)(uint64_t, uint64_t))v53)(v28, v9);
  uint64_t v35 = v52(v28, v9);
  if (v35 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v48;
  uint64_t v36 = v49;
  unint64_t v54 = v34;
  uint64_t v38 = v50;
  if (v35)
  {
    uint64_t v39 = 0LL;
    uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    uint64_t v53 = (char *)v35;
    do
    {
      uint64_t v40 = v36;
      unint64_t v41 = (void (*)(char *, uint64_t, uint64_t))v52;
      ((void (*)(char *, uint64_t, uint64_t))v52)(v39, v28, v9);
      v41(v39, v28, v9);
      uint64_t v42 = v9;
      char v43 = v57;
      (*(void (**)(char *, char *, unint64_t))(v55 + 216))(v38, v37, v31);
      uint64_t v44 = (void (*)(char *, unint64_t))v54;
      v54((uint64_t)v37, v31);
      v44(v38, v31);
      uint64_t v45 = v43;
      uint64_t v9 = v42;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v42 + 64))(v45, v39, v28, v42);
      uint64_t v36 = v40;
      ++v39;
    }

    while (v53 != v39);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v51 + 8))(v58, v28);
}

uint64_t static SIMD<>.&>> infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v34 = a2;
  uint64_t v27 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v27 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = a6;
  uint64_t v32 = a5;
  uint64_t v30 = v18;
  if (result)
  {
    unint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = 0LL;
    unint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v29 = result;
    do
    {
      uint64_t v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      uint64_t v23 = v9;
      uint64_t v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 200))(v16, v13, v20);
      uint64_t v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      uint64_t v26 = v24;
      uint64_t v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      uint64_t result = v29;
      ++v21;
    }

    while (v29 != v21);
  }

  return result;
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, unint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  __int128 v56 = a5;
  uint64_t v57 = a2;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v50 = (char *)&v48 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  size_t v59 = (char *)&v48 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  uint64_t v55 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  unint64_t v54 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v54)(a3, v9);
  uint64_t v27 = v21;
  unint64_t v28 = a3;
  uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v29 = v53(a3, v9);
  if (v29 < 0) {
    goto LABEL_10;
  }
  uint64_t v30 = v29;
  char v49 = v13;
  uint64_t v58 = a6;
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v32 = v59;
  if (v29)
  {
    uint64_t v33 = 0LL;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }

    while (v30 != v33);
  }

  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v55 + 1);
  v34(v26, v31);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v28);
  ((void (*)(uint64_t, uint64_t))v54)(v28, v9);
  uint64_t v36 = v53(v28, v9);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v35;
  uint64_t v39 = v49;
  uint64_t v38 = v50;
  uint64_t v55 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v40, v28, v9);
      v42(v40, v28, v9);
      char v43 = v9;
      uint64_t v44 = v59;
      (*(void (**)(char *, char *, unint64_t))(v56 + 200))(v38, v39, v31);
      uint64_t v45 = (void (*)(char *, unint64_t))v55;
      v55((uint64_t)v39, v31);
      v45(v38, v31);
      uint64_t v46 = v44;
      uint64_t v9 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v28, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v28);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t);
  uint64_t v42;
  char *v43;
  void (*v44)(char *, unint64_t);
  char *v45;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  char *v53;
  void (*v54)(uint64_t, unint64_t);
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v55 = a5;
  char v49 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v50 = (char *)&v47 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v57 = (char *)&v47 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v51 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v47 - v18);
  uint64_t v21 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v58 = (char *)&v47 - v23;
  unint64_t v54 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v53 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v53)(a3, v9);
  uint64_t v27 = v21;
  unint64_t v28 = a3;
  uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v29 = v52(a3, v9);
  if (v29 < 0) {
    goto LABEL_10;
  }
  uint64_t v30 = v29;
  unint64_t v48 = v13;
  __int128 v56 = a6;
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v32 = v57;
  if (v29)
  {
    uint64_t v33 = 0LL;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }

    while (v30 != v33);
  }

  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v54 + 1);
  v34(v26, v31);
  (*(void (**)(char *, char *, uint64_t))(v51 + 32))(v58, v27, v28);
  ((void (*)(uint64_t, uint64_t))v53)(v28, v9);
  uint64_t v35 = v52(v28, v9);
  if (v35 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v48;
  uint64_t v36 = v49;
  unint64_t v54 = v34;
  uint64_t v38 = v50;
  if (v35)
  {
    uint64_t v39 = 0LL;
    uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    uint64_t v53 = (char *)v35;
    do
    {
      uint64_t v40 = v36;
      unint64_t v41 = (void (*)(char *, uint64_t, uint64_t))v52;
      ((void (*)(char *, uint64_t, uint64_t))v52)(v39, v28, v9);
      v41(v39, v28, v9);
      uint64_t v42 = v9;
      char v43 = v57;
      (*(void (**)(char *, char *, unint64_t))(v55 + 200))(v38, v37, v31);
      uint64_t v44 = (void (*)(char *, unint64_t))v54;
      v54((uint64_t)v37, v31);
      v44(v38, v31);
      uint64_t v45 = v43;
      uint64_t v9 = v42;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v42 + 64))(v45, v39, v28, v42);
      uint64_t v36 = v40;
      ++v39;
    }

    while (v53 != v39);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v51 + 8))(v58, v28);
}

uint64_t static SIMD<>.&+ infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v34 = a2;
  uint64_t v27 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v27 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = a6;
  uint64_t v32 = a5;
  uint64_t v30 = v18;
  if (result)
  {
    unint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = 0LL;
    unint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v29 = result;
    do
    {
      uint64_t v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      uint64_t v23 = v9;
      uint64_t v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 80))(v30, v13, v20);
      uint64_t v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      uint64_t v26 = v24;
      uint64_t v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      uint64_t result = v29;
      ++v21;
    }

    while (v29 != v21);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, uint64_t);
  char *v46;
  char *v48;
  char *v49;
  char *v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  __int128 v56 = a2;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v50 = (char *)&v48 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  size_t v59 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v18 = MEMORY[0x1895F8858]((char *)&v48 - v17);
  unint64_t v20 = (char *)&v48 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v48 - v22;
  uint64_t v55 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t))*((void *)v24 + 2);
  uint64_t v26 = v21;
  unint64_t v28 = v27;
  v25(v21, a1);
  uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v53(a3, v8);
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  unint64_t v54 = v20;
  uint64_t v30 = a3;
  uint64_t v51 = v29;
  uint64_t v31 = v29(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  unint64_t v48 = v12;
  char v49 = v23;
  uint64_t v33 = v59;
  uint64_t v34 = v54;
  if (v31)
  {
    uint64_t v35 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }

    while (v32 != v35);
  }

  uint64_t v36 = (void (*)(uint64_t, uint64_t))*((void *)v55 + 1);
  v36(v26, v28);
  uint64_t v37 = v49;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v49, v34, v30);
  v53(v30, v8);
  uint64_t v38 = v51(v30, v8);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v55 = v36;
  uint64_t v39 = v48;
  uint64_t v40 = v50;
  if (v38)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v38;
    do
    {
      uint64_t v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v41, v30, v8);
      v42(v41, v30, v8);
      char v43 = v8;
      uint64_t v44 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 80))(v59, v39, v28);
      uint64_t v45 = (void (*)(char *, uint64_t))v55;
      v55((uint64_t)v39, v28);
      v45(v40, v28);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v30, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v30);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  void (*v43)(char *, uint64_t, uint64_t);
  uint64_t v44;
  char *v45;
  void (*v46)(char *, uint64_t);
  char *v47;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  uint64_t v53;
  void (*v54)(uint64_t, uint64_t);
  char *v55;
  void (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v49 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v51 = (char *)&v49 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  size_t v59 = (char *)&v49 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v53 = *(void *)(a3 - 8);
  uint64_t v18 = MEMORY[0x1895F8858]((char *)&v49 - v17);
  unint64_t v20 = (char *)&v49 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v49 - v22;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t))*((void *)v24 + 2);
  uint64_t v26 = v21;
  unint64_t v28 = v27;
  v25(v21, a2);
  unint64_t v54 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v54(a3, v8);
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v55 = v20;
  uint64_t v30 = a3;
  uint64_t v52 = v29;
  uint64_t v31 = v29(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  unint64_t v60 = v23;
  char v49 = v12;
  uint64_t v33 = v59;
  uint64_t v34 = v55;
  if (v31)
  {
    uint64_t v35 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }

    while (v32 != v35);
  }

  uint64_t v36 = (void (*)(uint64_t, uint64_t))*((void *)v56 + 1);
  v36(v26, v28);
  (*(void (**)(char *, char *, uint64_t))(v53 + 32))(v60, v34, v30);
  v54(v30, v8);
  uint64_t v37 = v52(v30, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  __int128 v56 = v36;
  uint64_t v39 = v49;
  uint64_t v38 = v50;
  uint64_t v40 = v51;
  if (v37)
  {
    unint64_t v41 = 0LL;
    unint64_t v54 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    uint64_t v55 = (char *)v37;
    do
    {
      uint64_t v42 = v38;
      char v43 = (void (*)(char *, uint64_t, uint64_t))v54;
      ((void (*)(char *, uint64_t, uint64_t))v54)(v41, v30, v8);
      v43(v41, v30, v8);
      uint64_t v44 = v8;
      uint64_t v45 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 80))(v59, v39, v28);
      uint64_t v46 = (void (*)(char *, uint64_t))v56;
      v56((uint64_t)v39, v28);
      v46(v40, v28);
      uint64_t v47 = v45;
      uint64_t v8 = v44;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v44 + 64))(v47, v41, v30, v44);
      uint64_t v38 = v42;
      ++v41;
    }

    while (v55 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v60, v30);
}

uint64_t static SIMD<>.&* infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v34 = a2;
  uint64_t v27 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v27 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = a6;
  uint64_t v32 = a5;
  uint64_t v30 = v18;
  if (result)
  {
    unint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = 0LL;
    unint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v29 = result;
    do
    {
      uint64_t v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      uint64_t v23 = v9;
      uint64_t v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 96))(v30, v16, v20);
      uint64_t v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      uint64_t v26 = v24;
      uint64_t v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      uint64_t result = v29;
      ++v21;
    }

    while (v29 != v21);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, uint64_t);
  char *v46;
  char *v48;
  char *v49;
  char *v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  __int128 v56 = a2;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v50 = (char *)&v48 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  size_t v59 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v18 = MEMORY[0x1895F8858]((char *)&v48 - v17);
  unint64_t v20 = (char *)&v48 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v48 - v22;
  uint64_t v55 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t))*((void *)v24 + 2);
  uint64_t v26 = v21;
  unint64_t v28 = v27;
  v25(v21, a1);
  uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v53(a3, v8);
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  unint64_t v54 = v20;
  uint64_t v30 = a3;
  uint64_t v51 = v29;
  uint64_t v31 = v29(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  unint64_t v48 = v12;
  char v49 = v23;
  uint64_t v33 = v59;
  uint64_t v34 = v54;
  if (v31)
  {
    uint64_t v35 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }

    while (v32 != v35);
  }

  uint64_t v36 = (void (*)(uint64_t, uint64_t))*((void *)v55 + 1);
  v36(v26, v28);
  uint64_t v37 = v49;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v49, v34, v30);
  v53(v30, v8);
  uint64_t v38 = v51(v30, v8);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v55 = v36;
  uint64_t v39 = v48;
  uint64_t v40 = v50;
  if (v38)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v38;
    do
    {
      uint64_t v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v41, v30, v8);
      v42(v41, v30, v8);
      char v43 = v8;
      uint64_t v44 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 96))(v59, v40, v28);
      uint64_t v45 = (void (*)(char *, uint64_t))v55;
      v55((uint64_t)v39, v28);
      v45(v40, v28);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v30, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v30);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  void (*v43)(char *, uint64_t, uint64_t);
  uint64_t v44;
  char *v45;
  void (*v46)(char *, uint64_t);
  char *v47;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  uint64_t v53;
  void (*v54)(uint64_t, uint64_t);
  char *v55;
  void (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v49 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v51 = (char *)&v49 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  size_t v59 = (char *)&v49 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v53 = *(void *)(a3 - 8);
  uint64_t v18 = MEMORY[0x1895F8858]((char *)&v49 - v17);
  unint64_t v20 = (char *)&v49 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v49 - v22;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t))*((void *)v24 + 2);
  uint64_t v26 = v21;
  unint64_t v28 = v27;
  v25(v21, a2);
  unint64_t v54 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v54(a3, v8);
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v55 = v20;
  uint64_t v30 = a3;
  uint64_t v52 = v29;
  uint64_t v31 = v29(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  unint64_t v60 = v23;
  char v49 = v12;
  uint64_t v33 = v59;
  uint64_t v34 = v55;
  if (v31)
  {
    uint64_t v35 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }

    while (v32 != v35);
  }

  uint64_t v36 = (void (*)(uint64_t, uint64_t))*((void *)v56 + 1);
  v36(v26, v28);
  (*(void (**)(char *, char *, uint64_t))(v53 + 32))(v60, v34, v30);
  v54(v30, v8);
  uint64_t v37 = v52(v30, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  __int128 v56 = v36;
  uint64_t v39 = v49;
  uint64_t v38 = v50;
  uint64_t v40 = v51;
  if (v37)
  {
    unint64_t v41 = 0LL;
    unint64_t v54 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    uint64_t v55 = (char *)v37;
    do
    {
      uint64_t v42 = v38;
      char v43 = (void (*)(char *, uint64_t, uint64_t))v54;
      ((void (*)(char *, uint64_t, uint64_t))v54)(v41, v30, v8);
      v43(v41, v30, v8);
      uint64_t v44 = v8;
      uint64_t v45 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 96))(v59, v40, v28);
      uint64_t v46 = (void (*)(char *, uint64_t))v56;
      v56((uint64_t)v39, v28);
      v46(v40, v28);
      uint64_t v47 = v45;
      uint64_t v8 = v44;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v44 + 64))(v47, v41, v30, v44);
      uint64_t v38 = v42;
      ++v41;
    }

    while (v55 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v60, v30);
}

uint64_t static SIMD<>./ infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v36 + 8) + 152LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  char *v24;
  void (*v25)(char *, unint64_t);
  char *v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v34 = a2;
  uint64_t v27 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v33 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v27 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = a6;
  uint64_t v32 = a5;
  uint64_t v30 = v18;
  if (result)
  {
    uint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = 0LL;
    unint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v29 = result;
    do
    {
      uint64_t v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      uint64_t v23 = v9;
      uint64_t v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 192))(v16, v13, v20);
      uint64_t v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      uint64_t v26 = v24;
      uint64_t v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      uint64_t result = v29;
      ++v21;
    }

    while (v29 != v21);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 152LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v57 + 8) + 152LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, unint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  __int128 v56 = a5;
  uint64_t v57 = a2;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v50 = (char *)&v48 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  size_t v59 = (char *)&v48 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  uint64_t v55 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  unint64_t v54 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v54)(a3, v9);
  uint64_t v27 = v21;
  unint64_t v28 = a3;
  uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v29 = v53(a3, v9);
  if (v29 < 0) {
    goto LABEL_10;
  }
  uint64_t v30 = v29;
  char v49 = v13;
  uint64_t v58 = a6;
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v32 = v59;
  if (v29)
  {
    uint64_t v33 = 0LL;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }

    while (v30 != v33);
  }

  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v55 + 1);
  v34(v26, v31);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v28);
  ((void (*)(uint64_t, uint64_t))v54)(v28, v9);
  uint64_t v36 = v53(v28, v9);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v35;
  uint64_t v39 = v49;
  uint64_t v38 = v50;
  uint64_t v55 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v40, v28, v9);
      v42(v40, v28, v9);
      char v43 = v9;
      uint64_t v44 = v59;
      (*(void (**)(char *, char *, unint64_t))(v56 + 192))(v38, v39, v31);
      uint64_t v45 = (void (*)(char *, unint64_t))v55;
      v55((uint64_t)v39, v31);
      v45(v38, v31);
      uint64_t v46 = v44;
      uint64_t v9 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v28, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v28);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t);
  uint64_t v42;
  char *v43;
  void (*v44)(char *, unint64_t);
  char *v45;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  char *v53;
  void (*v54)(uint64_t, unint64_t);
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v55 = a5;
  char v49 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v50 = (char *)&v47 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v57 = (char *)&v47 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v51 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v47 - v18);
  uint64_t v21 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v58 = (char *)&v47 - v23;
  unint64_t v54 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v53 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v53)(a3, v9);
  uint64_t v27 = v21;
  unint64_t v28 = a3;
  uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v29 = v52(a3, v9);
  if (v29 < 0) {
    goto LABEL_10;
  }
  uint64_t v30 = v29;
  unint64_t v48 = v13;
  __int128 v56 = a6;
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v32 = v57;
  if (v29)
  {
    uint64_t v33 = 0LL;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }

    while (v30 != v33);
  }

  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v54 + 1);
  v34(v26, v31);
  (*(void (**)(char *, char *, uint64_t))(v51 + 32))(v58, v27, v28);
  ((void (*)(uint64_t, uint64_t))v53)(v28, v9);
  uint64_t v35 = v52(v28, v9);
  if (v35 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v48;
  uint64_t v36 = v49;
  unint64_t v54 = v34;
  uint64_t v38 = v50;
  if (v35)
  {
    uint64_t v39 = 0LL;
    uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    uint64_t v53 = (char *)v35;
    do
    {
      uint64_t v40 = v36;
      unint64_t v41 = (void (*)(char *, uint64_t, uint64_t))v52;
      ((void (*)(char *, uint64_t, uint64_t))v52)(v39, v28, v9);
      v41(v39, v28, v9);
      uint64_t v42 = v9;
      char v43 = v57;
      (*(void (**)(char *, char *, unint64_t))(v55 + 192))(v38, v37, v31);
      uint64_t v44 = (void (*)(char *, unint64_t))v54;
      v54((uint64_t)v37, v31);
      v44(v38, v31);
      uint64_t v45 = v43;
      uint64_t v9 = v42;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v42 + 64))(v45, v39, v28, v42);
      uint64_t v36 = v40;
      ++v39;
    }

    while (v53 != v39);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v51 + 8))(v58, v28);
}

uint64_t static SIMD<>.% infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v36 + 8) + 168LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 168LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v57 + 8) + 168LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.+ infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v36 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 24LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v58 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 24LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v57 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 24LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.- infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v36 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 40LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v58 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 40LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v57 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 40LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.* infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v35 = a2;
  uint64_t v36 = a5;
  uint64_t v29 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v29 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v20 = v29;
  uint64_t v33 = v10;
  uint64_t v34 = a6;
  uint64_t v32 = v18;
  if (result)
  {
    uint64_t v21 = a3;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v23 = v20;
      uint64_t v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      uint64_t v25 = v8;
      uint64_t v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v36 + 16) + 8LL) + 64LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      unint64_t v28 = v26;
      uint64_t v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      uint64_t v20 = v23;
      uint64_t result = v31;
      ++v22;
    }

    while (v31 != v22);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v57 = a2;
  uint64_t v58 = a5;
  size_t v59 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v51 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  uint64_t v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v36 = v33;
  uint64_t v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v38 = v35;
  uint64_t v39 = v49;
  uint64_t v40 = v50;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v37)
  {
    unint64_t v41 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v37;
    do
    {
      uint64_t v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v58 + 16) + 8LL) + 64LL))( v39,  v40,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }

    while (v54 != v41);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v57 = a5;
  uint64_t v58 = a6;
  uint64_t v50 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v19 = MEMORY[0x1895F8858]((char *)&v48 - v18);
  uint64_t v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  size_t v59 = (char *)&v48 - v23;
  __int128 v56 = v24;
  uint64_t v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((void *)v24 + 2);
  uint64_t v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  uint64_t v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  uint64_t v27 = v21;
  unint64_t v54 = *(char **)(v8 + 40);
  unint64_t v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0) {
    goto LABEL_10;
  }
  uint64_t v29 = v28;
  char v49 = v14;
  if (v28)
  {
    uint64_t v30 = 0LL;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }

    while (v29 != v30);
  }

  uint64_t v31 = v26;
  uint64_t v32 = v17;
  uint64_t v33 = a3;
  uint64_t v34 = (void (*)(uint64_t, unint64_t))*((void *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  uint64_t v35 = v33;
  uint64_t v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v37 = v50;
  uint64_t v38 = v51;
  uint64_t v39 = v49;
  uint64_t v55 = v32;
  __int128 v56 = v34;
  if (v36)
  {
    uint64_t v40 = 0LL;
    uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    unint64_t v54 = (char *)v36;
    do
    {
      unint64_t v41 = v37;
      uint64_t v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      char v43 = v8;
      uint64_t v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v57 + 16) + 8LL) + 64LL))( v39,  v38,  AssociatedTypeWitness);
      uint64_t v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      uint64_t v46 = v44;
      uint64_t v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      uint64_t v37 = v41;
      ++v40;
    }

    while (v54 != v40);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t SIMD<>.addingProduct(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v34 = a2;
  uint64_t v35 = a5;
  uint64_t v38 = a1;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v37 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v30 - v14;
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v30 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v36 = (char *)&v30 - v19;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v32 = v12;
  uint64_t v33 = a6;
  if (result)
  {
    uint64_t v21 = v15;
    uint64_t v22 = 0LL;
    uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v31 = result;
    do
    {
      uint64_t v39 = v22 + 1;
      uint64_t v23 = v30;
      v30(v22, a3, v8);
      v23(v22, a3, v8);
      uint64_t v24 = v8;
      uint64_t v25 = v21;
      uint64_t v26 = v32;
      v23(v22, a3, v24);
      uint64_t v27 = v36;
      (*(void (**)(char *, char *, unint64_t))(v35 + 256))(v25, v26, AssociatedTypeWitness);
      unint64_t v28 = *(void (**)(char *, unint64_t))(v37 + 8);
      uint64_t v29 = v26;
      uint64_t v21 = v25;
      uint64_t v8 = v24;
      v28(v29, AssociatedTypeWitness);
      v28(v21, AssociatedTypeWitness);
      v28(v18, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v27, v22, a3, v24);
      uint64_t result = v31;
      uint64_t v22 = v39;
    }

    while (v31 != v39);
  }

  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(uint64_t, uint64_t, uint64_t);
  uint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  void (*v51)(uint64_t, uint64_t);
  void v53[2];
  char *v54;
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(uint64_t, uint64_t);
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  size_t v59 = a5;
  unint64_t v60 = a2;
  uint64_t v63 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v61 = (char *)v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)v53 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unint64_t v54 = (char *)v53 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v62 = (char *)v53 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v55 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858]((char *)v53 - v19);
  uint64_t v22 = (char *)v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  unint64_t v64 = (char *)v53 - v24;
  uint64_t v65 = v25;
  uint64_t v26 = *(void (**)(uint64_t, uint64_t))(v25 + 16);
  uint64_t v27 = v23;
  uint64_t v29 = v28;
  v26(v23, a1);
  uint64_t v58 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v58(a3, v8);
  uint64_t v30 = a3;
  uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v31 = v57(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  v53[0] = v14;
  uint64_t v33 = v62;
  if (v31)
  {
    uint64_t v34 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v26)(v33, v27, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v34++, v30, v8);
    }

    while (v32 != v34);
  }

  uint64_t v35 = v8;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t))(v65 + 8);
  v36(v27, v29);
  (*(void (**)(char *, char *, uint64_t))(v55 + 32))(v64, v22, v30);
  v58(v30, v35);
  uint64_t v37 = v35;
  uint64_t v38 = v57(v30, v35);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v39 = v29;
  unint64_t v41 = v53[0];
  uint64_t v40 = v53[1];
  uint64_t v58 = v36;
  uint64_t v42 = v30;
  char v43 = v54;
  if (v38)
  {
    uint64_t v44 = 0LL;
    __int128 v56 = *(void (**)(uint64_t, uint64_t, uint64_t))(v37 + 56);
    uint64_t v57 = (uint64_t (*)(uint64_t, uint64_t))v38;
    do
    {
      uint64_t v65 = v44 + 1;
      uint64_t v45 = v40;
      uint64_t v46 = v56;
      v56(v44, v42, v37);
      v46(v44, v42, v37);
      uint64_t v47 = v41;
      unint64_t v48 = v61;
      v46(v44, v42, v37);
      char v49 = v62;
      (*(void (**)(uint64_t, char *, uint64_t))(v59 + 256))(v47, v48, v39);
      uint64_t v50 = v48;
      unint64_t v41 = v47;
      uint64_t v51 = v58;
      v58((uint64_t)v50, v39);
      v51(v47, v39);
      v51((uint64_t)v43, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v37 + 64))(v49, v44, v42, v37);
      uint64_t v40 = v45;
      uint64_t v44 = v65;
    }

    while (v57 != (uint64_t (*)(uint64_t, uint64_t))v65);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v55 + 8))(v64, v42);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(uint64_t, uint64_t, uint64_t);
  uint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  void (*v51)(uint64_t, uint64_t);
  void v53[2];
  char *v54;
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(uint64_t, uint64_t);
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  size_t v59 = a5;
  unint64_t v60 = a1;
  uint64_t v63 = a6;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v61 = (char *)v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)v53 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unint64_t v54 = (char *)v53 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v62 = (char *)v53 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v55 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858]((char *)v53 - v19);
  uint64_t v22 = (char *)v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  unint64_t v64 = (char *)v53 - v24;
  uint64_t v65 = v25;
  uint64_t v26 = *(void (**)(uint64_t, uint64_t))(v25 + 16);
  uint64_t v27 = v23;
  uint64_t v29 = v28;
  v26(v23, a2);
  uint64_t v58 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v58(a3, v8);
  uint64_t v30 = a3;
  uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v31 = v57(a3, v8);
  if (v31 < 0) {
    goto LABEL_10;
  }
  uint64_t v32 = v31;
  v53[0] = v14;
  uint64_t v33 = v62;
  if (v31)
  {
    uint64_t v34 = 0LL;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v26)(v33, v27, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v34++, v30, v8);
    }

    while (v32 != v34);
  }

  uint64_t v35 = v8;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t))(v65 + 8);
  v36(v27, v29);
  (*(void (**)(char *, char *, uint64_t))(v55 + 32))(v64, v22, v30);
  v58(v30, v35);
  uint64_t v37 = v35;
  uint64_t v38 = v57(v30, v35);
  if (v38 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v39 = v29;
  unint64_t v41 = v53[0];
  uint64_t v40 = v53[1];
  uint64_t v58 = v36;
  uint64_t v42 = v30;
  char v43 = v54;
  if (v38)
  {
    uint64_t v44 = 0LL;
    __int128 v56 = *(void (**)(uint64_t, uint64_t, uint64_t))(v37 + 56);
    uint64_t v57 = (uint64_t (*)(uint64_t, uint64_t))v38;
    do
    {
      uint64_t v65 = v44 + 1;
      uint64_t v45 = v40;
      uint64_t v46 = v56;
      v56(v44, v42, v37);
      v46(v44, v42, v37);
      uint64_t v47 = v41;
      unint64_t v48 = v61;
      v46(v44, v42, v37);
      char v49 = v62;
      (*(void (**)(uint64_t, char *, uint64_t))(v59 + 256))(v47, v48, v39);
      uint64_t v50 = v48;
      unint64_t v41 = v47;
      uint64_t v51 = v58;
      v58((uint64_t)v50, v39);
      v51(v47, v39);
      v51((uint64_t)v43, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v37 + 64))(v49, v44, v42, v37);
      uint64_t v40 = v45;
      uint64_t v44 = v65;
    }

    while (v57 != (uint64_t (*)(uint64_t, uint64_t))v65);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v55 + 8))(v64, v42);
}

uint64_t SIMD<>.squareRoot()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v22 - v13;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a1, v7);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a1, v7);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v24 = a3;
  unint64_t v25 = AssociatedTypeWitness;
  uint64_t v26 = v9;
  uint64_t v27 = a4;
  if (result)
  {
    uint64_t v16 = a1;
    uint64_t v17 = v14;
    uint64_t v18 = 0LL;
    uint64_t v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    unint64_t v19 = v25;
    do
    {
      uint64_t v20 = result;
      uint64_t v21 = v16;
      v23(v18, v16, v7);
      (*(void (**)(unint64_t))(v24 + 240))(v19);
      (*(void (**)(char *, unint64_t))(v26 + 8))(v12, v19);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v18, v21, v7);
      uint64_t v16 = v21;
      uint64_t result = v20;
      ++v18;
    }

    while (v20 != v18);
  }

  return result;
}

uint64_t SIMD<>.rounded(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v24 - v15;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a2, v9);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a2, v9);
  if (result < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v26 = a4;
  unint64_t v27 = AssociatedTypeWitness;
  uint64_t v29 = a5;
  uint64_t v30 = a1;
  uint64_t v28 = v11;
  if (result)
  {
    uint64_t v18 = a2;
    unint64_t v19 = v16;
    uint64_t v20 = 0LL;
    unint64_t v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    unint64_t v21 = v27;
    do
    {
      uint64_t v22 = result;
      uint64_t v23 = v18;
      v25(v20, v18, v9);
      (*(void (**)(uint64_t, unint64_t))(v26 + 304))(v30, v21);
      (*(void (**)(char *, unint64_t))(v28 + 8))(v14, v21);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v19, v20, v23, v9);
      uint64_t v18 = v23;
      uint64_t result = v22;
      ++v20;
    }

    while (v22 != v20);
  }

  return result;
}

uint64_t static SIMDMask..! prefix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = a4;
  uint64_t v35 = a5;
  uint64_t v7 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v37 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v32 - v13;
  uint64_t v15 = *(void *)(a2 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v12);
  uint64_t v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = MEMORY[0x1895F8858]((char *)&v32 - v19);
  uint64_t v34 = (char *)&v32 - v21;
  uint64_t v22 = v20;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v15 + 16))(v20, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a2, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a2, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v33 = v15;
  uint64_t v39 = v18;
  uint64_t v24 = v22;
  uint64_t v25 = a2;
  if (v23)
  {
    uint64_t v26 = 0LL;
    uint64_t v36 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    do
    {
      uint64_t v27 = v23;
      v36(v26, a2, v7);
      (*(void (**)(char *, unint64_t))(*(void *)(v38 + 8) + 184LL))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v37 + 8))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v14, v26, a2, v7);
      uint64_t v23 = v27;
      ++v26;
    }

    while (v27 != v26);
  }

  uint64_t v28 = v33;
  (*(void (**)(uint64_t, uint64_t))(v33 + 8))(v24, v25);
  uint64_t v29 = *(void (**)(char *, char *, uint64_t))(v28 + 32);
  uint64_t v30 = v34;
  v29(v34, v39, v25);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v29)(v35, v30, v25);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v50 = a5;
  uint64_t v46 = a6;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v44 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v44 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v44 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  MEMORY[0x1895F8858](v23);
  uint64_t v25 = MEMORY[0x1895F8858]((char *)&v44 - v24);
  uint64_t v44 = (char *)&v44 - v26;
  uint64_t v45 = v27;
  uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v27 + 16);
  uint64_t v53 = v25;
  uint64_t v29 = a1;
  uint64_t v31 = v30;
  v28(v25, v29, a3);
  v28(v31, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v32 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v51 = v31;
  uint64_t v52 = v22;
  unint64_t v48 = v19;
  uint64_t v33 = a3;
  if (v32)
  {
    uint64_t v34 = 0LL;
    uint64_t v47 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    do
    {
      uint64_t v35 = v32;
      uint64_t v36 = v47;
      v47(v34, v33, v9);
      v36(v34, v33, v9);
      uint64_t v37 = v48;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v50 + 8) + 192LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v38 = *(void (**)(char *, unint64_t))(v49 + 8);
      v38(v13, AssociatedTypeWitness);
      v38(v16, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v37, v34, v33, v9);
      uint64_t v32 = v35;
      ++v34;
    }

    while (v35 != v34);
  }

  uint64_t v39 = v45;
  uint64_t v40 = *(void (**)(uint64_t, uint64_t))(v45 + 8);
  v40(v51, v33);
  v40(v53, v33);
  unint64_t v41 = *(void (**)(char *, char *, uint64_t))(v39 + 32);
  uint64_t v42 = v44;
  v41(v44, v52, v33);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v41)(v46, v42, v33);
}

uint64_t static SIMDMask..^ infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v50 = a5;
  uint64_t v46 = a6;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v44 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v44 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v44 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  MEMORY[0x1895F8858](v23);
  uint64_t v25 = MEMORY[0x1895F8858]((char *)&v44 - v24);
  uint64_t v44 = (char *)&v44 - v26;
  uint64_t v45 = v27;
  uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v27 + 16);
  uint64_t v53 = v25;
  uint64_t v29 = a1;
  uint64_t v31 = v30;
  v28(v25, v29, a3);
  v28(v31, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v32 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v51 = v31;
  uint64_t v52 = v22;
  unint64_t v48 = v19;
  uint64_t v33 = a3;
  if (v32)
  {
    uint64_t v34 = 0LL;
    uint64_t v47 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    do
    {
      uint64_t v35 = v32;
      uint64_t v36 = v47;
      v47(v34, v33, v9);
      v36(v34, v33, v9);
      uint64_t v37 = v48;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v50 + 8) + 224LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v38 = *(void (**)(char *, unint64_t))(v49 + 8);
      v38(v13, AssociatedTypeWitness);
      v38(v16, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v37, v34, v33, v9);
      uint64_t v32 = v35;
      ++v34;
    }

    while (v35 != v34);
  }

  uint64_t v39 = v45;
  uint64_t v40 = *(void (**)(uint64_t, uint64_t))(v45 + 8);
  v40(v51, v33);
  v40(v53, v33);
  unint64_t v41 = *(void (**)(char *, char *, uint64_t))(v39 + 32);
  uint64_t v42 = v44;
  v41(v44, v52, v33);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v41)(v46, v42, v33);
}

uint64_t static SIMDMask..| infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v50 = a5;
  uint64_t v46 = a6;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v49 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v44 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v44 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v44 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  MEMORY[0x1895F8858](v23);
  uint64_t v25 = MEMORY[0x1895F8858]((char *)&v44 - v24);
  uint64_t v44 = (char *)&v44 - v26;
  uint64_t v45 = v27;
  uint64_t v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v27 + 16);
  uint64_t v53 = v25;
  uint64_t v29 = a1;
  uint64_t v31 = v30;
  v28(v25, v29, a3);
  v28(v31, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v32 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v51 = v31;
  uint64_t v52 = v22;
  unint64_t v48 = v19;
  uint64_t v33 = a3;
  if (v32)
  {
    uint64_t v34 = 0LL;
    uint64_t v47 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    do
    {
      uint64_t v35 = v32;
      uint64_t v36 = v47;
      v47(v34, v33, v9);
      v36(v34, v33, v9);
      uint64_t v37 = v48;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v50 + 8) + 208LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v38 = *(void (**)(char *, unint64_t))(v49 + 8);
      v38(v13, AssociatedTypeWitness);
      v38(v16, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v37, v34, v33, v9);
      uint64_t v32 = v35;
      ++v34;
    }

    while (v35 != v34);
  }

  uint64_t v39 = v45;
  uint64_t v40 = *(void (**)(uint64_t, uint64_t))(v45 + 8);
  v40(v51, v33);
  v40(v53, v33);
  unint64_t v41 = *(void (**)(char *, char *, uint64_t))(v39 + 32);
  uint64_t v42 = v44;
  v41(v44, v52, v33);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v41)(v46, v42, v33);
}

uint64_t static SIMD<>.&= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  uint64_t v25 = v36;
  unint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v43 + 8) + 192LL))(v14, v11, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  __int128 v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  unint64_t v41 = v54;
  unint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v62 + 8) + 192LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.^= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  uint64_t v25 = v36;
  unint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v43 + 8) + 224LL))(v14, v11, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  __int128 v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  unint64_t v41 = v54;
  unint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v62 + 8) + 224LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.|= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  uint64_t v25 = v36;
  unint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v43 + 8) + 208LL))(v14, v11, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  __int128 v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  unint64_t v41 = v54;
  unint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v62 + 8) + 208LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.&<<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v43 = a2;
  uint64_t v44 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v35 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v37 = (char *)&v34 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v38 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v36 = *(void (**)(void))(v20 + 32);
  v36();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v34 = a1;
  unint64_t v41 = v16;
  uint64_t v42 = v9;
  uint64_t v24 = v35;
  uint64_t v25 = v37;
  uint64_t v45 = v19;
  if (v23)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v23;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(v44 + 216))(v25, v24, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v42 + 8);
      v31(v24, v26);
      v31(v25, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v45, a3);
}

uint64_t static SIMD<>.&>>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v43 = a2;
  uint64_t v44 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v35 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v37 = (char *)&v34 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v38 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v36 = *(void (**)(void))(v20 + 32);
  v36();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v34 = a1;
  unint64_t v41 = v16;
  uint64_t v42 = v9;
  uint64_t v24 = v35;
  uint64_t v25 = v37;
  uint64_t v45 = v19;
  if (v23)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v23;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(v44 + 200))(v25, v24, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v42 + 8);
      v31(v24, v26);
      v31(v25, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v45, a3);
}

uint64_t static SIMD<>.&+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v33 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v36 = (char *)&v33 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v33 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v37 = v20;
  uint64_t v22 = (char *)&v33 - v21;
  uint64_t v35 = *(void (**)(void))(v20 + 32);
  v35();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v33 = a1;
  uint64_t v40 = v16;
  uint64_t v41 = v8;
  unint64_t v24 = AssociatedTypeWitness;
  uint64_t v25 = v36;
  uint64_t v44 = v19;
  if (v23)
  {
    uint64_t v26 = 0LL;
    uint64_t v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v39 = v23;
    do
    {
      uint64_t v27 = v38;
      v38(v26, a3, v7);
      v27(v26, a3, v7);
      uint64_t v28 = v7;
      uint64_t v29 = v40;
      (*(void (**)(char *, char *, unint64_t))(v43 + 80))(v40, v11, v24);
      uint64_t v30 = *(void (**)(char *, unint64_t))(v41 + 8);
      v30(v11, v24);
      v30(v25, v24);
      uint64_t v31 = v29;
      uint64_t v7 = v28;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 64))(v31, v26++, a3, v28);
    }

    while (v39 != v26);
  }

  (*(void (**)(char *, uint64_t))(v37 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v35)(v33, v44, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  unint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  void (*v39)(void, void, void);
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t, uint64_t);
  void (*v58)(void);
  void (*v59)(void, void, void);
  void (*v60)(char *, unint64_t);
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v61 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v53 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v54 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v63 = (char *)&v52 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v52 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v52 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v65 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v52 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v62 = (char *)&v52 - v30;
  uint64_t v55 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v19;
  uint64_t v33 = AssociatedTypeWitness;
  v31(v19, a2, AssociatedTypeWitness);
  uint64_t v57 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v57(a3, v8);
  uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  size_t v59 = (void (*)(void, void, void))v25;
  uint64_t v35 = a3;
  __int128 v56 = v34;
  uint64_t v36 = v34(a3, v8);
  if (v36 < 0) {
    goto LABEL_10;
  }
  uint64_t v37 = v36;
  unint64_t v64 = v22;
  uint64_t v38 = v63;
  uint64_t v39 = v59;
  if (v36)
  {
    uint64_t v40 = 0LL;
    do
    {
      v31(v38, (uint64_t)v32, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v38, v40++, v35, v8);
    }

    while (v37 != v40);
  }

  uint64_t v41 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v41(v32, v33);
  ((void (*)(char *, void, uint64_t))v58)(v65, v39, v35);
  v57(v35, v8);
  uint64_t v42 = v56(v35, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v43 = v42;
  uint64_t v45 = v53;
  uint64_t v44 = v54;
  unint64_t v60 = v41;
  if (v42)
  {
    uint64_t v46 = 0LL;
    size_t v59 = *(void (**)(void, void, void))(v8 + 56);
    do
    {
      uint64_t v47 = v59;
      v59(v46, v35, v8);
      v47(v46, v35, v8);
      unint64_t v48 = v63;
      (*(void (**)(char *, char *, unint64_t))(v61 + 80))(v63, v45, v33);
      uint64_t v49 = v60;
      v60(v45, v33);
      v49(v44, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v48, v46++, v35, v8);
    }

    while (v43 != v46);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v52 + 8);
  v50(v65, v35);
  v50(v62, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v55, v64, v35);
}

uint64_t static SIMD<>.&-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v33 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v36 = (char *)&v33 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v33 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v37 = v20;
  uint64_t v22 = (char *)&v33 - v21;
  uint64_t v35 = *(void (**)(void))(v20 + 32);
  v35();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v33 = a1;
  uint64_t v40 = v16;
  uint64_t v41 = v8;
  unint64_t v24 = AssociatedTypeWitness;
  uint64_t v25 = v36;
  uint64_t v44 = v19;
  if (v23)
  {
    uint64_t v26 = 0LL;
    uint64_t v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v39 = v23;
    do
    {
      uint64_t v27 = v38;
      v38(v26, a3, v7);
      v27(v26, a3, v7);
      uint64_t v28 = v7;
      uint64_t v29 = v40;
      (*(void (**)(char *, char *, unint64_t))(v43 + 88))(v40, v11, v24);
      uint64_t v30 = *(void (**)(char *, unint64_t))(v41 + 8);
      v30(v11, v24);
      v30(v25, v24);
      uint64_t v31 = v29;
      uint64_t v7 = v28;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 64))(v31, v26++, a3, v28);
    }

    while (v39 != v26);
  }

  (*(void (**)(char *, uint64_t))(v37 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v35)(v33, v44, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  unint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  void (*v39)(void, void, void);
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t, uint64_t);
  void (*v58)(void);
  void (*v59)(void, void, void);
  void (*v60)(char *, unint64_t);
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v61 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v53 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v54 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v63 = (char *)&v52 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v52 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v52 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v65 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v52 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v62 = (char *)&v52 - v30;
  uint64_t v55 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v19;
  uint64_t v33 = AssociatedTypeWitness;
  v31(v19, a2, AssociatedTypeWitness);
  uint64_t v57 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v57(a3, v8);
  uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  size_t v59 = (void (*)(void, void, void))v25;
  uint64_t v35 = a3;
  __int128 v56 = v34;
  uint64_t v36 = v34(a3, v8);
  if (v36 < 0) {
    goto LABEL_10;
  }
  uint64_t v37 = v36;
  unint64_t v64 = v22;
  uint64_t v38 = v63;
  uint64_t v39 = v59;
  if (v36)
  {
    uint64_t v40 = 0LL;
    do
    {
      v31(v38, (uint64_t)v32, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v38, v40++, v35, v8);
    }

    while (v37 != v40);
  }

  uint64_t v41 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v41(v32, v33);
  ((void (*)(char *, void, uint64_t))v58)(v65, v39, v35);
  v57(v35, v8);
  uint64_t v42 = v56(v35, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v43 = v42;
  uint64_t v45 = v53;
  uint64_t v44 = v54;
  unint64_t v60 = v41;
  if (v42)
  {
    uint64_t v46 = 0LL;
    size_t v59 = *(void (**)(void, void, void))(v8 + 56);
    do
    {
      uint64_t v47 = v59;
      v59(v46, v35, v8);
      v47(v46, v35, v8);
      unint64_t v48 = v63;
      (*(void (**)(char *, char *, unint64_t))(v61 + 88))(v63, v45, v33);
      uint64_t v49 = v60;
      v60(v45, v33);
      v49(v44, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v48, v46++, v35, v8);
    }

    while (v43 != v46);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v52 + 8);
  v50(v65, v35);
  v50(v62, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v55, v64, v35);
}

uint64_t static SIMD<>.&*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v33 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v36 = (char *)&v33 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v33 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v37 = v20;
  uint64_t v22 = (char *)&v33 - v21;
  uint64_t v35 = *(void (**)(void))(v20 + 32);
  v35();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v33 = a1;
  uint64_t v40 = v16;
  uint64_t v41 = v8;
  unint64_t v24 = AssociatedTypeWitness;
  uint64_t v25 = v36;
  uint64_t v44 = v19;
  if (v23)
  {
    uint64_t v26 = 0LL;
    uint64_t v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v39 = v23;
    do
    {
      uint64_t v27 = v38;
      v38(v26, a3, v7);
      v27(v26, a3, v7);
      uint64_t v28 = v7;
      uint64_t v29 = v40;
      (*(void (**)(char *, char *, unint64_t))(v43 + 96))(v40, v25, v24);
      uint64_t v30 = *(void (**)(char *, unint64_t))(v41 + 8);
      v30(v11, v24);
      v30(v25, v24);
      uint64_t v31 = v29;
      uint64_t v7 = v28;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 64))(v31, v26++, a3, v28);
    }

    while (v39 != v26);
  }

  (*(void (**)(char *, uint64_t))(v37 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v35)(v33, v44, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  unint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  void (*v39)(void, void, void);
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t, uint64_t);
  void (*v58)(void);
  void (*v59)(void, void, void);
  void (*v60)(char *, unint64_t);
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v61 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v53 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v54 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v63 = (char *)&v52 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v52 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v52 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v65 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v52 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v62 = (char *)&v52 - v30;
  uint64_t v55 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v19;
  uint64_t v33 = AssociatedTypeWitness;
  v31(v19, a2, AssociatedTypeWitness);
  uint64_t v57 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v57(a3, v8);
  uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  size_t v59 = (void (*)(void, void, void))v25;
  uint64_t v35 = a3;
  __int128 v56 = v34;
  uint64_t v36 = v34(a3, v8);
  if (v36 < 0) {
    goto LABEL_10;
  }
  uint64_t v37 = v36;
  unint64_t v64 = v22;
  uint64_t v38 = v63;
  uint64_t v39 = v59;
  if (v36)
  {
    uint64_t v40 = 0LL;
    do
    {
      v31(v38, (uint64_t)v32, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v38, v40++, v35, v8);
    }

    while (v37 != v40);
  }

  uint64_t v41 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v41(v32, v33);
  ((void (*)(char *, void, uint64_t))v58)(v65, v39, v35);
  v57(v35, v8);
  uint64_t v42 = v56(v35, v8);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v43 = v42;
  uint64_t v45 = v53;
  uint64_t v44 = v54;
  unint64_t v60 = v41;
  if (v42)
  {
    uint64_t v46 = 0LL;
    size_t v59 = *(void (**)(void, void, void))(v8 + 56);
    do
    {
      uint64_t v47 = v59;
      v59(v46, v35, v8);
      v47(v46, v35, v8);
      unint64_t v48 = v63;
      (*(void (**)(char *, char *, unint64_t))(v61 + 96))(v63, v44, v33);
      uint64_t v49 = v60;
      v60(v45, v33);
      v49(v44, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v48, v46++, v35, v8);
    }

    while (v43 != v46);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v52 + 8);
  v50(v65, v35);
  v50(v62, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v55, v64, v35);
}

uint64_t static SIMD<>./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  uint64_t v25 = v36;
  uint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v43 + 8) + 152LL))(v14, v11, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  __int128 v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  uint64_t v41 = v54;
  unint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v62 + 8) + 152LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  char *v35;
  void (*v36)(void);
  char *v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v43 = a2;
  uint64_t v44 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v35 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v37 = (char *)&v34 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v34 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v38 = v20;
  uint64_t v22 = (char *)&v34 - v21;
  uint64_t v36 = *(void (**)(void))(v20 + 32);
  v36();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v34 = a1;
  uint64_t v41 = v16;
  uint64_t v42 = v9;
  uint64_t v24 = v35;
  uint64_t v25 = v37;
  uint64_t v45 = v19;
  if (v23)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v23;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(v44 + 192))(v25, v24, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v42 + 8);
      v31(v24, v26);
      v31(v25, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v45, a3);
}

uint64_t static SIMD<>.%= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  uint64_t v25 = v36;
  uint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v43 + 8) + 168LL))(v14, v11, v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  __int128 v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  unint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  uint64_t v41 = v54;
  unint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v62 + 8) + 168LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.&<<= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v59 = a2;
  uint64_t v60 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v53 = (char *)&v52 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v52 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v63 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v52 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v62 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v54 = v28;
  uint64_t v55 = a1;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v61 = (char *)&v52 - v30;
  __int128 v56 = v29;
  v29();
  uint64_t v58 = v9;
  uint64_t v31 = (void (*)(char *, char *, unint64_t))*((void *)v9 + 2);
  uint64_t v32 = v20;
  uint64_t v33 = v20;
  unint64_t v34 = AssociatedTypeWitness;
  v31(v33, v59, AssociatedTypeWitness);
  size_t v59 = *(char **)(v7 + 48);
  ((void (*)(uint64_t, uint64_t))v59)(a3, v7);
  uint64_t v35 = a3;
  uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v36 = v57(a3, v7);
  if (v36 < 0) {
    goto LABEL_10;
  }
  uint64_t v37 = v36;
  uint64_t v52 = v14;
  uint64_t v38 = v25;
  unint64_t v39 = AssociatedTypeWitness;
  if (v36)
  {
    uint64_t v40 = 0LL;
    do
    {
      v31(v17, v32, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v40++, v35, v7);
    }

    while (v37 != v40);
  }

  uint64_t v41 = (void (*)(char *, unint64_t))*((void *)v58 + 1);
  v41(v32, v39);
  ((void (*)(char *, char *, uint64_t))v56)(v62, v38, v35);
  ((void (*)(uint64_t, uint64_t))v59)(v35, v7);
  uint64_t v42 = v57(v35, v7);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v44 = v52;
  uint64_t v43 = v53;
  uint64_t v58 = v41;
  size_t v59 = v17;
  if (v42)
  {
    uint64_t v45 = 0LL;
    uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 56);
    do
    {
      uint64_t v46 = v42;
      uint64_t v47 = (void (*)(uint64_t, uint64_t, uint64_t))v57;
      ((void (*)(uint64_t, uint64_t, uint64_t))v57)(v45, v35, v7);
      v47(v45, v35, v7);
      unint64_t v48 = v59;
      (*(void (**)(char *, char *, unint64_t))(v60 + 216))(v44, v43, v39);
      uint64_t v49 = v58;
      v58(v43, v39);
      v49(v44, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v48, v45, v35, v7);
      uint64_t v42 = v46;
      ++v45;
    }

    while (v46 != v45);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v54 + 8);
  v50(v62, v35);
  v50(v61, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v56)(v55, v63, v35);
}

uint64_t static SIMD<>.&>>= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v59 = a2;
  uint64_t v60 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v53 = (char *)&v52 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v52 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v63 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v52 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v62 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v54 = v28;
  uint64_t v55 = a1;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v61 = (char *)&v52 - v30;
  __int128 v56 = v29;
  v29();
  uint64_t v58 = v9;
  uint64_t v31 = (void (*)(char *, char *, unint64_t))*((void *)v9 + 2);
  uint64_t v32 = v20;
  uint64_t v33 = v20;
  unint64_t v34 = AssociatedTypeWitness;
  v31(v33, v59, AssociatedTypeWitness);
  size_t v59 = *(char **)(v7 + 48);
  ((void (*)(uint64_t, uint64_t))v59)(a3, v7);
  uint64_t v35 = a3;
  uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v36 = v57(a3, v7);
  if (v36 < 0) {
    goto LABEL_10;
  }
  uint64_t v37 = v36;
  uint64_t v52 = v14;
  uint64_t v38 = v25;
  unint64_t v39 = AssociatedTypeWitness;
  if (v36)
  {
    uint64_t v40 = 0LL;
    do
    {
      v31(v17, v32, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v40++, v35, v7);
    }

    while (v37 != v40);
  }

  uint64_t v41 = (void (*)(char *, unint64_t))*((void *)v58 + 1);
  v41(v32, v39);
  ((void (*)(char *, char *, uint64_t))v56)(v62, v38, v35);
  ((void (*)(uint64_t, uint64_t))v59)(v35, v7);
  uint64_t v42 = v57(v35, v7);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v44 = v52;
  uint64_t v43 = v53;
  uint64_t v58 = v41;
  size_t v59 = v17;
  if (v42)
  {
    uint64_t v45 = 0LL;
    uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 56);
    do
    {
      uint64_t v46 = v42;
      uint64_t v47 = (void (*)(uint64_t, uint64_t, uint64_t))v57;
      ((void (*)(uint64_t, uint64_t, uint64_t))v57)(v45, v35, v7);
      v47(v45, v35, v7);
      unint64_t v48 = v59;
      (*(void (**)(char *, char *, unint64_t))(v60 + 200))(v44, v43, v39);
      uint64_t v49 = v58;
      v58(v43, v39);
      v49(v44, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v48, v45, v35, v7);
      uint64_t v42 = v46;
      ++v45;
    }

    while (v46 != v45);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v54 + 8);
  v50(v62, v35);
  v50(v61, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v56)(v55, v63, v35);
}

void static SIMD<>.+ infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4CBuLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4DAuLL,  0);
}

void static SIMD<>.- infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4D0uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4DFuLL,  0);
}

void static SIMD<>.* infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4D5uLL,  0);
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4E4uLL,  0);
}

void static SIMD<>.+= infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F8uLL,  0);
}

void static SIMD<>.-= infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4FDuLL,  0);
}

void static SIMD<>.*= infix(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x502uLL,  0);
}

uint64_t static SIMD<>.- prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v64 = a1;
  uint64_t v65 = a4;
  uint64_t v60 = *(void *)(a2 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v63 = (char *)&v54 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v67 = (char *)&v54 - v8;
  uint64_t v10 = *(void *)(v9 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v58 = (char *)&v54 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v57 = (char *)&v54 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v66 = (char *)&v54 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v54 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v54 - v22;
  uint64_t v56 = *(void *)(*(void *)(a3 + 16) + 8LL);
  uint64_t v24 = *(void *)(v56 + 16);
  unint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v24,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v25);
  uint64_t v27 = (char *)&v54 - v26;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v24,  AssociatedTypeWitness,  v25,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v25,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t, uint64_t))(v24 + 24))(v27, AssociatedTypeWitness, v24);
  uint64_t v62 = v12;
  uint64_t v29 = *(void (**)(char *, char *, unint64_t))(v12 + 16);
  uint64_t v55 = v23;
  v29(v21, v23, AssociatedTypeWitness);
  uint64_t v30 = v63;
  uint64_t v61 = *(void (**)(uint64_t, uint64_t))(v10 + 48);
  v61(a2, v10);
  uint64_t v31 = v30;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 40);
  uint64_t v32 = v59(a2, v10);
  if (v32 < 0) {
    goto LABEL_10;
  }
  uint64_t v33 = v32;
  unint64_t v34 = v66;
  if (v32)
  {
    uint64_t v35 = 0LL;
    do
    {
      v29(v34, v21, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 64))(v34, v35++, a2, v10);
    }

    while (v33 != v35);
  }

  uint64_t v36 = *(void (**)(char *, unint64_t))(v62 + 8);
  v36(v21, AssociatedTypeWitness);
  uint64_t v37 = v67;
  (*(void (**)(char *, char *, uint64_t))(v60 + 32))(v67, v31, a2);
  v61(a2, v10);
  uint64_t v38 = v10;
  uint64_t v39 = v59(a2, v10);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v39;
  uint64_t v41 = a2;
  v36(v55, AssociatedTypeWitness);
  uint64_t v42 = v37;
  uint64_t v43 = v57;
  uint64_t v44 = v58;
  uint64_t v63 = (char *)v36;
  uint64_t v45 = v56;
  if (v40)
  {
    uint64_t v46 = 0LL;
    uint64_t v61 = *(void (**)(uint64_t, uint64_t))(v38 + 56);
    uint64_t v62 = v40;
    do
    {
      uint64_t v47 = (void (*)(uint64_t, uint64_t, uint64_t))v61;
      ((void (*)(uint64_t, uint64_t, uint64_t))v61)(v46, v41, v38);
      v47(v46, v41, v38);
      unint64_t v48 = *(void (**)(char *, char *, unint64_t))(*(void *)(v45 + 8) + 40LL);
      uint64_t v49 = v45;
      uint64_t v50 = v66;
      v48(v43, v44, AssociatedTypeWitness);
      uint64_t v51 = (void (*)(char *, unint64_t))v63;
      ((void (*)(char *, unint64_t))v63)(v44, AssociatedTypeWitness);
      v51(v43, AssociatedTypeWitness);
      uint64_t v52 = v50;
      uint64_t v45 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v38 + 64))(v52, v46, v41, v38);
      uint64_t v42 = v67;
      ++v46;
    }

    while (v62 != v46);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v60 + 8))(v42, v41);
}

uint64_t static SIMD<>.+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  unint64_t v25 = v36;
  uint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v43 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 24LL))( v14,  v11,  v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  uint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  uint64_t v41 = v54;
  uint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v62 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 24LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  unint64_t v25 = v36;
  uint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v43 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 40LL))( v14,  v11,  v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  uint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  uint64_t v41 = v54;
  uint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(*(void *)(v62 + 16) + 8LL)
                                                                           + 8LL)
                                                               + 40LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = a2;
  uint64_t v43 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v34 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = *(void (**)(void))(v21 + 32);
  uint64_t v36 = (char *)&v34 - v23;
  uint64_t v37 = v22;
  uint64_t v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v35 = a1;
  uint64_t v45 = v20;
  unint64_t v25 = v36;
  uint64_t v41 = v17;
  if (v24)
  {
    unint64_t v26 = AssociatedTypeWitness;
    uint64_t v27 = 0LL;
    uint64_t v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    uint64_t v40 = v24;
    do
    {
      uint64_t v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      uint64_t v29 = v7;
      uint64_t v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v43 + 16) + 8LL) + 64LL))( v14,  v11,  v26);
      uint64_t v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      uint64_t v32 = v30;
      uint64_t v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }

    while (v40 != v27);
  }

  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v62 = a5;
  uint64_t v8 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v56 = (char *)&v52 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v25 = (char *)&v52 - v24;
  unint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v64 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v55 = v28;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v63 = (char *)&v52 - v30;
  uint64_t v57 = a1;
  uint64_t v58 = v29;
  v29();
  uint64_t v60 = v10;
  uint64_t v31 = (void (*)(char *, uint64_t, unint64_t))*((void *)v10 + 2);
  uint64_t v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  uint64_t v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  uint64_t v34 = a3;
  size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  uint64_t v35 = v59(a3, v8);
  if (v35 < 0) {
    goto LABEL_10;
  }
  uint64_t v36 = v35;
  uint64_t v53 = v33;
  if (v35)
  {
    uint64_t v37 = 0LL;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }

    while (v36 != v37);
  }

  uint64_t v61 = v17;
  uint64_t v38 = (void (*)(char *, unint64_t))*((void *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  uint64_t v39 = v59(v34, v8);
  if (v39 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v40 = v34;
  uint64_t v41 = v54;
  uint64_t v60 = v38;
  uint64_t v42 = v56;
  if (v39)
  {
    uint64_t v43 = 0LL;
    size_t v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      uint64_t v44 = v39;
      uint64_t v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      uint64_t v46 = v8;
      uint64_t v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(*(void *)(v62 + 16) + 8LL) + 64LL))( v42,  v41,  AssociatedTypeWitness);
      unint64_t v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      uint64_t v49 = v47;
      uint64_t v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      uint64_t v39 = v44;
      ++v43;
    }

    while (v44 != v43);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>./= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v59 = a2;
  uint64_t v60 = a5;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v9 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v53 = (char *)&v52 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v52 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v52 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v63 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v25 = (char *)&v52 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v62 = (char *)&v52 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v54 = v28;
  uint64_t v55 = a1;
  uint64_t v29 = *(void (**)(void))(v28 + 32);
  uint64_t v61 = (char *)&v52 - v30;
  uint64_t v56 = v29;
  v29();
  uint64_t v58 = v9;
  uint64_t v31 = (void (*)(char *, char *, unint64_t))*((void *)v9 + 2);
  uint64_t v32 = v20;
  uint64_t v33 = v20;
  unint64_t v34 = AssociatedTypeWitness;
  v31(v33, v59, AssociatedTypeWitness);
  size_t v59 = *(char **)(v7 + 48);
  ((void (*)(uint64_t, uint64_t))v59)(a3, v7);
  uint64_t v35 = a3;
  uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  uint64_t v36 = v57(a3, v7);
  if (v36 < 0) {
    goto LABEL_10;
  }
  uint64_t v37 = v36;
  uint64_t v52 = v14;
  uint64_t v38 = v25;
  unint64_t v39 = AssociatedTypeWitness;
  if (v36)
  {
    uint64_t v40 = 0LL;
    do
    {
      v31(v17, v32, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v40++, v35, v7);
    }

    while (v37 != v40);
  }

  uint64_t v41 = (void (*)(char *, unint64_t))*((void *)v58 + 1);
  v41(v32, v39);
  ((void (*)(char *, char *, uint64_t))v56)(v62, v38, v35);
  ((void (*)(uint64_t, uint64_t))v59)(v35, v7);
  uint64_t v42 = v57(v35, v7);
  if (v42 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v44 = v52;
  uint64_t v43 = v53;
  uint64_t v58 = v41;
  size_t v59 = v17;
  if (v42)
  {
    uint64_t v45 = 0LL;
    uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 56);
    do
    {
      uint64_t v46 = v42;
      uint64_t v47 = (void (*)(uint64_t, uint64_t, uint64_t))v57;
      ((void (*)(uint64_t, uint64_t, uint64_t))v57)(v45, v35, v7);
      v47(v45, v35, v7);
      unint64_t v48 = v59;
      (*(void (**)(char *, char *, unint64_t))(v60 + 192))(v44, v43, v39);
      uint64_t v49 = v58;
      v58(v43, v39);
      v49(v44, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v48, v45, v35, v7);
      uint64_t v42 = v46;
      ++v45;
    }

    while (v46 != v45);
  }

  uint64_t v50 = *(void (**)(char *, uint64_t))(v54 + 8);
  v50(v62, v35);
  v50(v61, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v56)(v55, v63, v35);
}

uint64_t SIMD<>.addProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v44 = a2;
  uint64_t v45 = a5;
  uint64_t v43 = a1;
  uint64_t v7 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v48 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v47 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v37 - v12;
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v37 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v46 = (char *)&v37 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v37 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v37 - v23;
  unint64_t v39 = *(void (**)(void))(v22 + 32);
  uint64_t v40 = v22;
  v39();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v25 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v38 = v5;
  uint64_t v49 = v21;
  uint64_t v26 = v7;
  uint64_t v27 = v24;
  if (v25)
  {
    uint64_t v28 = 0LL;
    uint64_t v41 = *(void (**)(uint64_t, uint64_t, uint64_t))(v26 + 56);
    uint64_t v42 = v25;
    do
    {
      uint64_t v50 = v28 + 1;
      uint64_t v29 = v41;
      v41(v28, a3, v26);
      v29(v28, a3, v26);
      uint64_t v30 = v16;
      uint64_t v31 = v13;
      uint64_t v32 = v47;
      v29(v28, a3, v26);
      uint64_t v33 = v46;
      (*(void (**)(char *, char *, unint64_t))(v45 + 256))(v31, v32, AssociatedTypeWitness);
      unint64_t v34 = *(void (**)(char *, unint64_t))(v48 + 8);
      uint64_t v35 = v32;
      uint64_t v13 = v31;
      uint64_t v16 = v30;
      v34(v35, AssociatedTypeWitness);
      v34(v13, AssociatedTypeWitness);
      v34(v30, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v26 + 64))(v33, v28, a3, v26);
      uint64_t v28 = v50;
    }

    while (v42 != v50);
  }

  (*(void (**)(char *, uint64_t))(v40 + 8))(v27, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v39)(v38, v49, a3);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(void);
  uint64_t v33;
  void (*v34)(char *, uint64_t, unint64_t);
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, unint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  void (*v53)(uint64_t, uint64_t, uint64_t);
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  void (*v58)(char *, unint64_t);
  void (*v59)(char *, uint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  void (*v65)(void);
  char *v66;
  void (*v67)(char *, unint64_t);
  uint64_t (*v68)(uint64_t, uint64_t);
  void (*v69)(uint64_t, uint64_t);
  uint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  char *v76;
  uint64_t v6 = v5;
  uint64_t v70 = a5;
  uint64_t v71 = a2;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v72 = (char *)&v61 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v61 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v63 = (char *)&v61 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v66 = (char *)&v61 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v61 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  unint64_t v74 = (char *)&v61 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v61 - v27;
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  uint64_t v73 = (char *)&v61 - v30;
  MEMORY[0x1895F8858](v29);
  uint64_t v62 = v31;
  uint64_t v32 = *(void (**)(void))(v31 + 32);
  unint64_t v76 = (char *)&v61 - v33;
  uint64_t v64 = v6;
  uint64_t v65 = v32;
  v32();
  int v75 = v11;
  unint64_t v34 = *(void (**)(char *, uint64_t, unint64_t))(v11 + 16);
  uint64_t v35 = AssociatedTypeWitness;
  v34(v23, a1, AssociatedTypeWitness);
  uint64_t v69 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  v69(a3, v9);
  uint64_t v36 = a3;
  uint64_t v68 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v37 = v68(a3, v9);
  if (v37 < 0) {
    goto LABEL_10;
  }
  uint64_t v38 = v37;
  uint64_t v61 = v16;
  unint64_t v39 = v66;
  uint64_t v40 = v28;
  if (v37)
  {
    uint64_t v41 = 0LL;
    do
    {
      v34(v39, (uint64_t)v23, v35);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v39, v41++, v36, v9);
    }

    while (v38 != v41);
  }

  uint64_t v42 = v9;
  uint64_t v43 = *(void (**)(char *, unint64_t))(v75 + 8);
  v43(v23, v35);
  ((void (*)(char *, char *, uint64_t))v65)(v73, v40, v36);
  v69(v36, v42);
  uint64_t v44 = v42;
  uint64_t v45 = v68(v36, v42);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v46 = v61;
  uint64_t v47 = v35;
  uint64_t v48 = v63;
  uint64_t v49 = v66;
  uint64_t v50 = v76;
  if (v45)
  {
    uint64_t v51 = 0LL;
    uint64_t v68 = *(uint64_t (**)(uint64_t, uint64_t))(v44 + 56);
    uint64_t v69 = (void (*)(uint64_t, uint64_t))v45;
    uint64_t v67 = v43;
    do
    {
      int v75 = v51 + 1;
      uint64_t v52 = v47;
      uint64_t v53 = (void (*)(uint64_t, uint64_t, uint64_t))v68;
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v51, v36, v44);
      v53(v51, v36, v44);
      uint64_t v54 = v49;
      uint64_t v55 = v46;
      uint64_t v56 = v72;
      v53(v51, v36, v44);
      uint64_t v47 = v52;
      (*(void (**)(char *, char *, unint64_t))(v70 + 256))(v55, v56, v52);
      uint64_t v57 = v56;
      uint64_t v46 = v55;
      uint64_t v49 = v54;
      uint64_t v58 = v67;
      v67(v57, v47);
      v58(v46, v47);
      v58(v48, v47);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 64))(v54, v51, v36, v44);
      uint64_t v50 = v76;
      uint64_t v51 = v75;
    }

    while (v69 != (void (*)(uint64_t, uint64_t))v75);
  }

  size_t v59 = *(void (**)(char *, uint64_t))(v62 + 8);
  v59(v73, v36);
  v59(v50, v36);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v65)(v64, v74, v36);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(void);
  uint64_t v33;
  void (*v34)(char *, uint64_t, unint64_t);
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, unint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  void (*v53)(uint64_t, uint64_t, uint64_t);
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  void (*v58)(char *, unint64_t);
  void (*v59)(char *, uint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  void (*v65)(void);
  char *v66;
  void (*v67)(char *, unint64_t);
  uint64_t (*v68)(uint64_t, uint64_t);
  void (*v69)(uint64_t, uint64_t);
  uint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  char *v76;
  uint64_t v6 = v5;
  uint64_t v70 = a5;
  uint64_t v71 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v72 = (char *)&v61 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v61 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v63 = (char *)&v61 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v66 = (char *)&v61 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v61 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  unint64_t v74 = (char *)&v61 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v61 - v27;
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  uint64_t v73 = (char *)&v61 - v30;
  MEMORY[0x1895F8858](v29);
  uint64_t v62 = v31;
  uint64_t v32 = *(void (**)(void))(v31 + 32);
  unint64_t v76 = (char *)&v61 - v33;
  uint64_t v64 = v6;
  uint64_t v65 = v32;
  v32();
  int v75 = v11;
  unint64_t v34 = *(void (**)(char *, uint64_t, unint64_t))(v11 + 16);
  uint64_t v35 = AssociatedTypeWitness;
  v34(v23, a2, AssociatedTypeWitness);
  uint64_t v69 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  v69(a3, v9);
  uint64_t v36 = a3;
  uint64_t v68 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  uint64_t v37 = v68(a3, v9);
  if (v37 < 0) {
    goto LABEL_10;
  }
  uint64_t v38 = v37;
  uint64_t v61 = v16;
  unint64_t v39 = v66;
  uint64_t v40 = v28;
  if (v37)
  {
    uint64_t v41 = 0LL;
    do
    {
      v34(v39, (uint64_t)v23, v35);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v39, v41++, v36, v9);
    }

    while (v38 != v41);
  }

  uint64_t v42 = v9;
  uint64_t v43 = *(void (**)(char *, unint64_t))(v75 + 8);
  v43(v23, v35);
  ((void (*)(char *, char *, uint64_t))v65)(v73, v40, v36);
  v69(v36, v42);
  uint64_t v44 = v42;
  uint64_t v45 = v68(v36, v42);
  if (v45 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v46 = v61;
  uint64_t v47 = v35;
  uint64_t v48 = v63;
  uint64_t v49 = v66;
  uint64_t v50 = v76;
  if (v45)
  {
    uint64_t v51 = 0LL;
    uint64_t v68 = *(uint64_t (**)(uint64_t, uint64_t))(v44 + 56);
    uint64_t v69 = (void (*)(uint64_t, uint64_t))v45;
    uint64_t v67 = v43;
    do
    {
      int v75 = v51 + 1;
      uint64_t v52 = v47;
      uint64_t v53 = (void (*)(uint64_t, uint64_t, uint64_t))v68;
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v51, v36, v44);
      v53(v51, v36, v44);
      uint64_t v54 = v49;
      uint64_t v55 = v46;
      uint64_t v56 = v72;
      v53(v51, v36, v44);
      uint64_t v47 = v52;
      (*(void (**)(char *, char *, unint64_t))(v70 + 256))(v55, v56, v52);
      uint64_t v57 = v56;
      uint64_t v46 = v55;
      uint64_t v49 = v54;
      uint64_t v58 = v67;
      v67(v57, v47);
      v58(v46, v47);
      v58(v48, v47);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 64))(v54, v51, v36, v44);
      uint64_t v50 = v76;
      uint64_t v51 = v75;
    }

    while (v69 != (void (*)(uint64_t, uint64_t))v75);
  }

  size_t v59 = *(void (**)(char *, uint64_t))(v62 + 8);
  v59(v73, v36);
  v59(v50, v36);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v65)(v64, v74, v36);
}

uint64_t SIMD<>.formSquareRoot()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = a3;
  uint64_t v5 = *(void *)(a2 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v34 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v29 - v11;
  uint64_t v13 = *(void *)(a1 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v17 = *(void (**)(void))(v13 + 32);
  uint64_t v31 = (char *)&v29 - v18;
  uint64_t v32 = v17;
  v17();
  (*(void (**)(uint64_t, uint64_t))(v5 + 48))(a1, v5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a1, v5);
  if (v19 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v29 = v13;
  uint64_t v30 = v3;
  uint64_t v36 = v16;
  uint64_t v20 = v31;
  uint64_t v21 = a1;
  if (v19)
  {
    unint64_t v22 = AssociatedTypeWitness;
    uint64_t v23 = v9;
    uint64_t v24 = v5;
    uint64_t v25 = 0LL;
    uint64_t v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 56);
    do
    {
      uint64_t v26 = v19;
      uint64_t v27 = v20;
      v33(v25, v21, v24);
      (*(void (**)(unint64_t))(v35 + 240))(v22);
      (*(void (**)(char *, unint64_t))(v34 + 8))(v23, v22);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v12, v25, v21, v24);
      uint64_t v20 = v27;
      uint64_t v19 = v26;
      ++v25;
    }

    while (v26 != v25);
  }

  (*(void (**)(char *, uint64_t))(v29 + 8))(v20, v21);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v32)(v30, v36, v21);
}

uint64_t SIMD<>.round(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = a1;
  uint64_t v36 = a4;
  uint64_t v6 = *(void *)(a3 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v34 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v30 - v12;
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v30 - v18;
  uint64_t v31 = *(void (**)(void))(v17 + 32);
  uint64_t v32 = v17;
  v31();
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(a2, v6);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 40))(a2, v6);
  if (v20 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v30 = v4;
  uint64_t v37 = v16;
  uint64_t v21 = v19;
  uint64_t v22 = a2;
  if (v20)
  {
    unint64_t v23 = AssociatedTypeWitness;
    uint64_t v24 = v10;
    uint64_t v25 = v6;
    uint64_t v26 = 0LL;
    uint64_t v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56);
    do
    {
      uint64_t v27 = v20;
      uint64_t v28 = v21;
      v33(v26, v22, v25);
      (*(void (**)(uint64_t, unint64_t))(v36 + 304))(v35, v23);
      (*(void (**)(char *, unint64_t))(v34 + 8))(v24, v23);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v13, v26, v22, v25);
      uint64_t v21 = v28;
      uint64_t v20 = v27;
      ++v26;
    }

    while (v27 != v26);
  }

  (*(void (**)(char *, uint64_t))(v32 + 8))(v21, v22);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v31)(v30, v37, v22);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>( uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v80 = a2;
  int v84 = a1;
  uint64_t v76 = a7;
  uint64_t v85 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v71 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v93 = (char *)&v71 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v71 - v19;
  uint64_t v91 = *(void *)(v21 + 8);
  uint64_t v22 = *(const char **)(*(void *)(v91 + 24) + 16LL);
  uint64_t v24 = *(void *)(v23 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v24,  v25,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v87 = v22;
  unint64_t v83 = swift_getAssociatedTypeWitness( 0LL,  v22,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v83);
  uint64_t v82 = (char *)&v71 - v27;
  uint64_t v86 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v90 = *(v86 - 1);
  uint64_t v28 = MEMORY[0x1895F8858](v86);
  int v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v74 = (char *)&v71 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v89 = (char *)&v71 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  uint64_t v79 = type metadata accessor for SIMDMask(0LL, (uint64_t)v94);
  uint64_t v35 = *(void *)(v79 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v79);
  uint64_t v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  uint64_t v78 = (char *)&v71 - v39;
  unsigned int v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  uint64_t v40 = a3;
  uint64_t v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  uint64_t v41 = v88(a3, v24);
  if (v41 < 0) {
    goto LABEL_16;
  }
  uint64_t v42 = v41;
  uint64_t v92 = v16;
  uint64_t v73 = v20;
  if (v41)
  {
    unint64_t v43 = 0LL;
    uint64_t v44 = v81;
    while (1)
    {
      unint64_t v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v43 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v72 = v35;
      unint64_t v46 = v83;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  (uint64_t)v86,  v83,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v82;
      if ((v84 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      uint64_t v35 = v72;
      if (v42 == v43) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..^ infix(_:_:)@<X0>( uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v80 = a2;
  int v84 = a1;
  uint64_t v76 = a7;
  uint64_t v85 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v71 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v93 = (char *)&v71 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v71 - v19;
  uint64_t v91 = *(void *)(v21 + 8);
  uint64_t v22 = *(const char **)(*(void *)(v91 + 24) + 16LL);
  uint64_t v24 = *(void *)(v23 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v24,  v25,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v87 = v22;
  unint64_t v83 = swift_getAssociatedTypeWitness( 0LL,  v22,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v83);
  uint64_t v82 = (char *)&v71 - v27;
  uint64_t v86 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v90 = *(v86 - 1);
  uint64_t v28 = MEMORY[0x1895F8858](v86);
  int v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v74 = (char *)&v71 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v89 = (char *)&v71 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  uint64_t v79 = type metadata accessor for SIMDMask(0LL, (uint64_t)v94);
  uint64_t v35 = *(void *)(v79 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v79);
  uint64_t v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  uint64_t v78 = (char *)&v71 - v39;
  unsigned int v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  uint64_t v40 = a3;
  uint64_t v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  uint64_t v41 = v88(a3, v24);
  if (v41 < 0) {
    goto LABEL_16;
  }
  uint64_t v42 = v41;
  uint64_t v92 = v16;
  uint64_t v73 = v20;
  if (v41)
  {
    unint64_t v43 = 0LL;
    uint64_t v44 = v81;
    while (1)
    {
      unint64_t v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v43 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v72 = v35;
      unint64_t v46 = v83;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  (uint64_t)v86,  v83,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v82;
      if ((v84 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      uint64_t v35 = v72;
      if (v42 == v43) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..| infix(_:_:)@<X0>( uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v80 = a2;
  int v84 = a1;
  uint64_t v76 = a7;
  uint64_t v85 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v71 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v93 = (char *)&v71 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v71 - v19;
  uint64_t v91 = *(void *)(v21 + 8);
  uint64_t v22 = *(const char **)(*(void *)(v91 + 24) + 16LL);
  uint64_t v24 = *(void *)(v23 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v24,  v25,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v87 = v22;
  unint64_t v83 = swift_getAssociatedTypeWitness( 0LL,  v22,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v83);
  uint64_t v82 = (char *)&v71 - v27;
  uint64_t v86 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v90 = *(v86 - 1);
  uint64_t v28 = MEMORY[0x1895F8858](v86);
  int v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v74 = (char *)&v71 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v89 = (char *)&v71 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  uint64_t v79 = type metadata accessor for SIMDMask(0LL, (uint64_t)v94);
  uint64_t v35 = *(void *)(v79 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v79);
  uint64_t v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  uint64_t v78 = (char *)&v71 - v39;
  unsigned int v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  uint64_t v40 = a3;
  uint64_t v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  uint64_t v41 = v88(a3, v24);
  if (v41 < 0) {
    goto LABEL_16;
  }
  uint64_t v42 = v41;
  uint64_t v92 = v16;
  uint64_t v73 = v20;
  if (v41)
  {
    unint64_t v43 = 0LL;
    uint64_t v44 = v81;
    while (1)
    {
      unint64_t v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v43 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v72 = v35;
      unint64_t v46 = v83;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  (uint64_t)v86,  v83,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v82;
      if ((v84 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      uint64_t v35 = v72;
      if (v42 == v43) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..& infix(_:_:)@<X0>( uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  int v84 = a2;
  uint64_t v80 = a1;
  uint64_t v76 = a7;
  uint64_t v85 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v71 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v93 = (char *)&v71 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v71 - v19;
  uint64_t v91 = *(void *)(v21 + 8);
  uint64_t v22 = *(const char **)(*(void *)(v91 + 24) + 16LL);
  uint64_t v24 = *(void *)(v23 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v24,  v25,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v87 = v22;
  unint64_t v83 = swift_getAssociatedTypeWitness( 0LL,  v22,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v83);
  uint64_t v82 = (char *)&v71 - v27;
  uint64_t v86 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v90 = *(v86 - 1);
  uint64_t v28 = MEMORY[0x1895F8858](v86);
  int v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v74 = (char *)&v71 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v89 = (char *)&v71 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  uint64_t v79 = type metadata accessor for SIMDMask(0LL, (uint64_t)v94);
  uint64_t v35 = *(void *)(v79 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v79);
  uint64_t v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  uint64_t v78 = (char *)&v71 - v39;
  unsigned int v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  uint64_t v40 = a3;
  uint64_t v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  uint64_t v41 = v88(a3, v24);
  if (v41 < 0) {
    goto LABEL_16;
  }
  uint64_t v42 = v41;
  uint64_t v92 = v16;
  uint64_t v73 = v20;
  if (v41)
  {
    unint64_t v43 = 0LL;
    uint64_t v44 = v81;
    while (1)
    {
      unint64_t v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v43 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v72 = v35;
      unint64_t v46 = v83;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  (uint64_t)v86,  v83,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v82;
      if ((v84 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      uint64_t v35 = v72;
      if (v42 == v43) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..^ infix(_:_:)@<X0>( uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  int v84 = a2;
  uint64_t v80 = a1;
  uint64_t v76 = a7;
  uint64_t v85 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v71 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v93 = (char *)&v71 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v71 - v19;
  uint64_t v91 = *(void *)(v21 + 8);
  uint64_t v22 = *(const char **)(*(void *)(v91 + 24) + 16LL);
  uint64_t v24 = *(void *)(v23 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v24,  v25,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v87 = v22;
  unint64_t v83 = swift_getAssociatedTypeWitness( 0LL,  v22,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v83);
  uint64_t v82 = (char *)&v71 - v27;
  uint64_t v86 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v90 = *(v86 - 1);
  uint64_t v28 = MEMORY[0x1895F8858](v86);
  int v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v74 = (char *)&v71 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v89 = (char *)&v71 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  uint64_t v79 = type metadata accessor for SIMDMask(0LL, (uint64_t)v94);
  uint64_t v35 = *(void *)(v79 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v79);
  uint64_t v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  uint64_t v78 = (char *)&v71 - v39;
  unsigned int v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  uint64_t v40 = a3;
  uint64_t v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  uint64_t v41 = v88(a3, v24);
  if (v41 < 0) {
    goto LABEL_16;
  }
  uint64_t v42 = v41;
  uint64_t v92 = v16;
  uint64_t v73 = v20;
  if (v41)
  {
    unint64_t v43 = 0LL;
    uint64_t v44 = v81;
    while (1)
    {
      unint64_t v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v43 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v72 = v35;
      unint64_t v46 = v83;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  (uint64_t)v86,  v83,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v82;
      if ((v84 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      uint64_t v35 = v72;
      if (v42 == v43) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..| infix(_:_:)@<X0>( uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  int v84 = a2;
  uint64_t v80 = a1;
  uint64_t v76 = a7;
  uint64_t v85 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v71 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v93 = (char *)&v71 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v71 - v19;
  uint64_t v91 = *(void *)(v21 + 8);
  uint64_t v22 = *(const char **)(*(void *)(v91 + 24) + 16LL);
  uint64_t v24 = *(void *)(v23 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v24,  v25,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v87 = v22;
  unint64_t v83 = swift_getAssociatedTypeWitness( 0LL,  v22,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v83);
  uint64_t v82 = (char *)&v71 - v27;
  uint64_t v86 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v90 = *(v86 - 1);
  uint64_t v28 = MEMORY[0x1895F8858](v86);
  int v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v74 = (char *)&v71 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v89 = (char *)&v71 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  uint64_t v79 = type metadata accessor for SIMDMask(0LL, (uint64_t)v94);
  uint64_t v35 = *(void *)(v79 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v79);
  uint64_t v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  uint64_t v78 = (char *)&v71 - v39;
  unsigned int v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  uint64_t v40 = a3;
  uint64_t v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  uint64_t v41 = v88(a3, v24);
  if (v41 < 0) {
    goto LABEL_16;
  }
  uint64_t v42 = v41;
  uint64_t v92 = v16;
  uint64_t v73 = v20;
  if (v41)
  {
    unint64_t v43 = 0LL;
    uint64_t v44 = v81;
    while (1)
    {
      unint64_t v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v43 >= v45) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      uint64_t v72 = v35;
      unint64_t v46 = v83;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  (uint64_t)v86,  v83,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v48 = v82;
      if ((v84 & 1) != 0)
      {
        uint64_t v49 = &unk_18180BE78;
        uint64_t v50 = 257LL;
      }

      else
      {
        uint64_t v49 = &unk_18180BE68;
        uint64_t v50 = 256LL;
      }

      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( v49,  v50,  v46,  AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      uint64_t v35 = v72;
      if (v42 == v43) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..&= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v60 = a6;
  uint64_t v61 = a2;
  uint64_t v54 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v57 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v47 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  size_t v59 = (char *)&v47 - v18;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v47 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v47 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v52 = (char *)&v47 - v27;
  v62[0] = a3;
  v62[1] = a4;
  uint64_t v58 = a5;
  v62[2] = a5;
  v62[3] = v60;
  uint64_t v29 = v28;
  uint64_t v30 = type metadata accessor for SIMDMask(0LL, (uint64_t)v62);
  uint64_t v49 = *(void *)(v30 - 8);
  uint64_t v50 = v30;
  MEMORY[0x1895F8858](v30);
  uint64_t v48 = (char *)&v47 - v31;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  uint64_t v51 = v26;
  uint64_t v47 = v32;
  v32(v26, v54, a3);
  uint64_t v53 = v19;
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v61, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v33 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v60 = v23;
  uint64_t v61 = v29;
  uint64_t v34 = v51;
  uint64_t v35 = a3;
  if (v33)
  {
    uint64_t v36 = 0LL;
    uint64_t v55 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v56 = v33;
    do
    {
      uint64_t v37 = v55;
      v55(v36, v35, v9);
      v37(v36, v35, v9);
      uint64_t v38 = v35;
      uint64_t v39 = v59;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 192LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v40 = *(void (**)(char *, unint64_t))(v57 + 8);
      v40(v13, AssociatedTypeWitness);
      v40(v16, AssociatedTypeWitness);
      uint64_t v41 = v39;
      uint64_t v35 = v38;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v41, v36++, v38, v9);
    }

    while (v56 != v36);
  }

  uint64_t v42 = *(void (**)(char *, uint64_t))(v53 + 8);
  v42(v60, v35);
  v42(v34, v35);
  unint64_t v43 = v52;
  uint64_t v44 = v47;
  v47(v52, v61, v35);
  unint64_t v45 = v48;
  v44(v48, v43, v35);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v49 + 32))(v54, v45, v50);
}

uint64_t static SIMDMask..^= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v60 = a6;
  uint64_t v61 = a2;
  uint64_t v54 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v57 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v47 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  size_t v59 = (char *)&v47 - v18;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v47 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v47 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v52 = (char *)&v47 - v27;
  v62[0] = a3;
  v62[1] = a4;
  uint64_t v58 = a5;
  v62[2] = a5;
  v62[3] = v60;
  uint64_t v29 = v28;
  uint64_t v30 = type metadata accessor for SIMDMask(0LL, (uint64_t)v62);
  uint64_t v49 = *(void *)(v30 - 8);
  uint64_t v50 = v30;
  MEMORY[0x1895F8858](v30);
  uint64_t v48 = (char *)&v47 - v31;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  uint64_t v51 = v26;
  uint64_t v47 = v32;
  v32(v26, v54, a3);
  uint64_t v53 = v19;
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v61, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v33 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v60 = v23;
  uint64_t v61 = v29;
  uint64_t v34 = v51;
  uint64_t v35 = a3;
  if (v33)
  {
    uint64_t v36 = 0LL;
    uint64_t v55 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v56 = v33;
    do
    {
      uint64_t v37 = v55;
      v55(v36, v35, v9);
      v37(v36, v35, v9);
      uint64_t v38 = v35;
      uint64_t v39 = v59;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 224LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v40 = *(void (**)(char *, unint64_t))(v57 + 8);
      v40(v13, AssociatedTypeWitness);
      v40(v16, AssociatedTypeWitness);
      uint64_t v41 = v39;
      uint64_t v35 = v38;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v41, v36++, v38, v9);
    }

    while (v56 != v36);
  }

  uint64_t v42 = *(void (**)(char *, uint64_t))(v53 + 8);
  v42(v60, v35);
  v42(v34, v35);
  unint64_t v43 = v52;
  uint64_t v44 = v47;
  v47(v52, v61, v35);
  unint64_t v45 = v48;
  v44(v48, v43, v35);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v49 + 32))(v54, v45, v50);
}

uint64_t static SIMDMask..|= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v60 = a6;
  uint64_t v61 = a2;
  uint64_t v54 = a1;
  uint64_t v9 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v57 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v47 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  size_t v59 = (char *)&v47 - v18;
  uint64_t v19 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v47 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v47 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v52 = (char *)&v47 - v27;
  v62[0] = a3;
  v62[1] = a4;
  uint64_t v58 = a5;
  v62[2] = a5;
  v62[3] = v60;
  uint64_t v29 = v28;
  uint64_t v30 = type metadata accessor for SIMDMask(0LL, (uint64_t)v62);
  uint64_t v49 = *(void *)(v30 - 8);
  uint64_t v50 = v30;
  MEMORY[0x1895F8858](v30);
  uint64_t v48 = (char *)&v47 - v31;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  uint64_t v51 = v26;
  uint64_t v47 = v32;
  v32(v26, v54, a3);
  uint64_t v53 = v19;
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v61, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v33 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v60 = v23;
  uint64_t v61 = v29;
  uint64_t v34 = v51;
  uint64_t v35 = a3;
  if (v33)
  {
    uint64_t v36 = 0LL;
    uint64_t v55 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    uint64_t v56 = v33;
    do
    {
      uint64_t v37 = v55;
      v55(v36, v35, v9);
      v37(v36, v35, v9);
      uint64_t v38 = v35;
      uint64_t v39 = v59;
      (*(void (**)(char *, char *, unint64_t))(*(void *)(v58 + 8) + 208LL))( v16,  v13,  AssociatedTypeWitness);
      uint64_t v40 = *(void (**)(char *, unint64_t))(v57 + 8);
      v40(v13, AssociatedTypeWitness);
      v40(v16, AssociatedTypeWitness);
      uint64_t v41 = v39;
      uint64_t v35 = v38;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v41, v36++, v38, v9);
    }

    while (v56 != v36);
  }

  uint64_t v42 = *(void (**)(char *, uint64_t))(v53 + 8);
  v42(v60, v35);
  v42(v34, v35);
  unint64_t v43 = v52;
  uint64_t v44 = v47;
  v47(v52, v61, v35);
  unint64_t v45 = v48;
  v44(v48, v43, v35);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v49 + 32))(v54, v45, v50);
}

uint64_t static SIMDMask..&= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  size_t v97 = a6;
  int v91 = a2;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(const char **)(*(void *)(v10 + 24) + 16LL);
  uint64_t v12 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v12,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v94 = v11;
  unint64_t v90 = swift_getAssociatedTypeWitness( 0LL,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v90);
  uint64_t v89 = (char *)&v76 - v14;
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v16 = *(v15 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v80 = (char *)&v76 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v76 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v76 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v88 = (char *)&v76 - v26;
  uint64_t v92 = *(void *)(a3 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v100 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  char v99 = (char *)&v76 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v98 = (char *)&v76 - v32;
  MEMORY[0x1895F8858](v31);
  uint64_t v81 = (char *)&v76 - v33;
  v101[0] = a3;
  v101[1] = a4;
  v101[2] = a5;
  v101[3] = v97;
  uint64_t v34 = type metadata accessor for SIMDMask(0LL, (uint64_t)v101);
  uint64_t v35 = MEMORY[0x1895F8858](v34);
  uint64_t v37 = (char *)&v76 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = MEMORY[0x1895F8858](v35);
  uint64_t v86 = (char *)&v76 - v39;
  MEMORY[0x1895F8858](v38);
  uint64_t v79 = v40;
  uint64_t v41 = *(void (**)(void))(v40 + 32);
  uint64_t v85 = (char *)&v76 - v42;
  uint64_t v82 = a1;
  uint64_t v87 = v43;
  unint64_t v83 = v41;
  v41();
  int v84 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v84(a3, v12);
  uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  uint64_t v45 = v44(a3, v12);
  if (v45 < 0) {
    goto LABEL_16;
  }
  uint64_t v93 = v15;
  size_t v97 = v24;
  uint64_t v78 = v21;
  uint64_t v95 = v10;
  uint64_t v96 = v16;
  uint64_t v46 = (uint64_t)v94;
  if (v45)
  {
    unint64_t v47 = 0LL;
    uint64_t v48 = v88;
    while (1)
    {
      uint64_t v49 = v45;
      unint64_t v50 = v44(a3, v12);
      if ((v50 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v47 >= v50) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v51 = v90;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v46,  (uint64_t)v93,  v90,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v53 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      unsigned int v77 = v44;
      uint64_t v54 = v89;
      if ((v91 & 1) != 0)
      {
        uint64_t v55 = &unk_18180BE78;
        uint64_t v56 = 257LL;
      }

      else
      {
        uint64_t v55 = &unk_18180BE68;
        uint64_t v56 = 256LL;
      }

      v53(v55, v56, v51, AssociatedConformanceWitness);
      (*(void (**)(char *))(v46 + 24))(v54);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v48, v47++, a3, v12);
      uint64_t v45 = v49;
      uint64_t v44 = v77;
      if (v49 == v47) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..^= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  size_t v97 = a6;
  int v91 = a2;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(const char **)(*(void *)(v10 + 24) + 16LL);
  uint64_t v12 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v12,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v94 = v11;
  unint64_t v90 = swift_getAssociatedTypeWitness( 0LL,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v90);
  uint64_t v89 = (char *)&v76 - v14;
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v16 = *(v15 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v80 = (char *)&v76 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v76 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v76 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v88 = (char *)&v76 - v26;
  uint64_t v92 = *(void *)(a3 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v100 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  char v99 = (char *)&v76 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v98 = (char *)&v76 - v32;
  MEMORY[0x1895F8858](v31);
  uint64_t v81 = (char *)&v76 - v33;
  v101[0] = a3;
  v101[1] = a4;
  v101[2] = a5;
  v101[3] = v97;
  uint64_t v34 = type metadata accessor for SIMDMask(0LL, (uint64_t)v101);
  uint64_t v35 = MEMORY[0x1895F8858](v34);
  uint64_t v37 = (char *)&v76 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = MEMORY[0x1895F8858](v35);
  uint64_t v86 = (char *)&v76 - v39;
  MEMORY[0x1895F8858](v38);
  uint64_t v79 = v40;
  uint64_t v41 = *(void (**)(void))(v40 + 32);
  uint64_t v85 = (char *)&v76 - v42;
  uint64_t v82 = a1;
  uint64_t v87 = v43;
  unint64_t v83 = v41;
  v41();
  int v84 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v84(a3, v12);
  uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  uint64_t v45 = v44(a3, v12);
  if (v45 < 0) {
    goto LABEL_16;
  }
  uint64_t v93 = v15;
  size_t v97 = v24;
  uint64_t v78 = v21;
  uint64_t v95 = v10;
  uint64_t v96 = v16;
  uint64_t v46 = (uint64_t)v94;
  if (v45)
  {
    unint64_t v47 = 0LL;
    uint64_t v48 = v88;
    while (1)
    {
      uint64_t v49 = v45;
      unint64_t v50 = v44(a3, v12);
      if ((v50 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v47 >= v50) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v51 = v90;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v46,  (uint64_t)v93,  v90,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v53 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      unsigned int v77 = v44;
      uint64_t v54 = v89;
      if ((v91 & 1) != 0)
      {
        uint64_t v55 = &unk_18180BE78;
        uint64_t v56 = 257LL;
      }

      else
      {
        uint64_t v55 = &unk_18180BE68;
        uint64_t v56 = 256LL;
      }

      v53(v55, v56, v51, AssociatedConformanceWitness);
      (*(void (**)(char *))(v46 + 24))(v54);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v48, v47++, a3, v12);
      uint64_t v45 = v49;
      uint64_t v44 = v77;
      if (v49 == v47) {
        goto LABEL_10;
      }
    }

uint64_t static SIMDMask..|= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  size_t v97 = a6;
  int v91 = a2;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(const char **)(*(void *)(v10 + 24) + 16LL);
  uint64_t v12 = *(void *)(a4 + 48);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v12,  a3,  (uint64_t)&protocol requirements base descriptor for SIMDStorage,  associated type descriptor for SIMDStorage.Scalar);
  uint64_t v94 = v11;
  unint64_t v90 = swift_getAssociatedTypeWitness( 0LL,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v90);
  uint64_t v89 = (char *)&v76 - v14;
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v16 = *(v15 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v80 = (char *)&v76 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v76 - v20;
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v76 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v88 = (char *)&v76 - v26;
  uint64_t v92 = *(void *)(a3 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v100 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  char v99 = (char *)&v76 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v98 = (char *)&v76 - v32;
  MEMORY[0x1895F8858](v31);
  uint64_t v81 = (char *)&v76 - v33;
  v101[0] = a3;
  v101[1] = a4;
  v101[2] = a5;
  v101[3] = v97;
  uint64_t v34 = type metadata accessor for SIMDMask(0LL, (uint64_t)v101);
  uint64_t v35 = MEMORY[0x1895F8858](v34);
  uint64_t v37 = (char *)&v76 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v38 = MEMORY[0x1895F8858](v35);
  uint64_t v86 = (char *)&v76 - v39;
  MEMORY[0x1895F8858](v38);
  uint64_t v79 = v40;
  uint64_t v41 = *(void (**)(void))(v40 + 32);
  uint64_t v85 = (char *)&v76 - v42;
  uint64_t v82 = a1;
  uint64_t v87 = v43;
  unint64_t v83 = v41;
  v41();
  int v84 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v84(a3, v12);
  uint64_t v44 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  uint64_t v45 = v44(a3, v12);
  if (v45 < 0) {
    goto LABEL_16;
  }
  uint64_t v93 = v15;
  size_t v97 = v24;
  uint64_t v78 = v21;
  uint64_t v95 = v10;
  uint64_t v96 = v16;
  uint64_t v46 = (uint64_t)v94;
  if (v45)
  {
    unint64_t v47 = 0LL;
    uint64_t v48 = v88;
    while (1)
    {
      uint64_t v49 = v45;
      unint64_t v50 = v44(a3, v12);
      if ((v50 & 0x8000000000000000LL) != 0) {
        break;
      }
      if (v47 >= v50) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
      }
      unint64_t v51 = v90;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v46,  (uint64_t)v93,  v90,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v53 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      unsigned int v77 = v44;
      uint64_t v54 = v89;
      if ((v91 & 1) != 0)
      {
        uint64_t v55 = &unk_18180BE78;
        uint64_t v56 = 257LL;
      }

      else
      {
        uint64_t v55 = &unk_18180BE68;
        uint64_t v56 = 256LL;
      }

      v53(v55, v56, v51, AssociatedConformanceWitness);
      (*(void (**)(char *))(v46 + 24))(v54);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v48, v47++, a3, v12);
      uint64_t v45 = v49;
      uint64_t v44 = v77;
      if (v49 == v47) {
        goto LABEL_10;
      }
    }

void *ObjectIdentifier._lldb_summary.unsafeMutableAddressor()
{
  return &static ObjectIdentifier._lldb_summary;
}

void *_stdlib_AtomicInt.__allocating_init(_:)(uint64_t a1)
{
  uint64_t result = swift_allocObject(v1, 0x18uLL, 7uLL);
  result[2] = a1;
  return result;
}

uint64_t _stdlib_AtomicInt.init(_:)(uint64_t a1)
{
  *(void *)(v1 + 16) = a1;
  return v1;
}

Swift::Void __swiftcall _stdlib_AtomicInt.store(_:)(Swift::Int a1)
{
}

unint64_t *_swift_stdlib_atomicStoreInt(object:desired:)( unint64_t *result, unint64_t a2)
{
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.load()()
{
  return atomic_load((unint64_t *)(v0 + 16));
}

unint64_t _swift_stdlib_atomicLoadInt(object:)(unint64_t *a1)
{
  return atomic_load(a1);
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndAdd(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
    Swift::Int v3 = __ldaxr(v2);
  while (__stlxr(v3 + a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchAddInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result + a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.addAndFetch(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
    unint64_t v3 = __ldaxr(v2);
  while (__stlxr(v3 + a1, v2));
  BOOL v4 = __OFADD__(v3, a1);
  Swift::Int result = v3 + a1;
  if (v4) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndAnd(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
    Swift::Int v3 = __ldaxr(v2);
  while (__stlxr(v3 & a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchAndInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result & a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.andAndFetch(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
  {
    unint64_t v3 = __ldaxr(v2);
    Swift::Int v4 = v3 & a1;
  }

  while (__stlxr(v4, v2));
  return v4;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndOr(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
    Swift::Int v3 = __ldaxr(v2);
  while (__stlxr(v3 | a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchOrInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result | a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.orAndFetch(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
  {
    unint64_t v3 = __ldaxr(v2);
    Swift::Int v4 = v3 | a1;
  }

  while (__stlxr(v4, v2));
  return v4;
}

uint64_t static Int.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndXor(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
    Swift::Int v3 = __ldaxr(v2);
  while (__stlxr(v3 ^ a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchXorInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result ^ a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.xorAndFetch(_:)(Swift::Int a1)
{
  uint64_t v2 = (unint64_t *)(v1 + 16);
  do
  {
    unint64_t v3 = __ldaxr(v2);
    Swift::Int v4 = v3 ^ a1;
  }

  while (__stlxr(v4, v2));
  return v4;
}

uint64_t static Int.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

Swift::Bool __swiftcall _stdlib_AtomicInt.compareExchange(expected:desired:)(Swift::Int *expected, Swift::Int desired)
{
  Swift::Int v3 = *expected;
  Swift::Int v4 = (unint64_t *)(v2 + 16);
  while (1)
  {
    Swift::Int v5 = __ldaxr(v4);
    if (v5 != v3) {
      break;
    }
    if (!__stlxr(desired, v4))
    {
      Swift::Bool v6 = 1;
      goto LABEL_6;
    }
  }

  Swift::Bool v6 = 0;
  __clrex();
LABEL_6:
  *expected = v5;
  return v6;
}

uint64_t _swift_stdlib_atomicCompareExchangeStrongInt(object:expected:desired:)( unint64_t *a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3 = *a2;
  while (1)
  {
    unint64_t v4 = __ldaxr(a1);
    if (v4 != v3) {
      break;
    }
    if (!__stlxr(a3, a1))
    {
      uint64_t result = 1LL;
      *a2 = v4;
      return result;
    }
  }

  uint64_t result = 0LL;
  __clrex();
  *a2 = v4;
  return result;
}

uint64_t _stdlib_AtomicInt.deinit()
{
  return v0;
}

unint64_t _swift_stdlib_atomicFetchAddInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result + a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchAddInt32(object:operand:)(unsigned int *a1, int a2)
{
  do
    uint64_t v2 = __ldaxr(a1);
  while (__stlxr(v2 + a2, a1));
  return v2;
}

unint64_t _swift_stdlib_atomicFetchAndInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result & a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchAndInt32(object:operand:)(unsigned int *a1, int a2)
{
  do
    uint64_t v2 = __ldaxr(a1);
  while (__stlxr(v2 & a2, a1));
  return v2;
}

unint64_t _swift_stdlib_atomicFetchOrInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result | a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchOrInt32(object:operand:)(unsigned int *a1, int a2)
{
  do
    uint64_t v2 = __ldaxr(a1);
  while (__stlxr(v2 | a2, a1));
  return v2;
}

unint64_t _swift_stdlib_atomicFetchXorInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  do
    unint64_t result = __ldaxr(a1);
  while (__stlxr(result ^ a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchXorInt32(object:operand:)(unsigned int *a1, int a2)
{
  do
    uint64_t v2 = __ldaxr(a1);
  while (__stlxr(v2 ^ a2, a1));
  return v2;
}

Swift::Bool __swiftcall _isspace_clocale(_:)(Swift::UInt16 a1)
{
  Swift::UInt16 v3 = a1;
  v2[2] = &v3;
  return specialized Sequence.contains(where:)( (uint64_t (*)(void *))partial apply for specialized closure #1 in Sequence<>.contains(_:),  (uint64_t)v2,  0x200D0C0B0A09LL,  0xE600000000000000LL) & 1;
}

uint64_t Float16.init<A>(_:)(uint64_t *a1, ValueMetadata *x1_0, uint64_t a3)
{
  v3._Swift::UInt64 rawBits = Substring.init<A>(_:)(a1, x1_0, *(void *)(*(void *)(*(void *)(a3 + 8) + 8LL) + 8LL));
  uint64_t v5 = v4;
  unsigned __int16 v13 = 0;
  unint64_t v7 = specialized String.init(_:)(v3, v14, v6, v4);
  unint64_t v9 = v8;
  swift_bridgeObjectRelease(v5);
  char v10 = specialized String.withCString<A>(_:)(v7, v9, (uint64_t)&v13, (char *)_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v9);
  if ((v10 & 1) != 0) {
    int v11 = v13;
  }
  else {
    int v11 = 0;
  }
  return v11 & 0xFFFEFFFF | (((v10 & 1) == 0) << 16);
}

uint64_t Float16.init(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unsigned __int16 v11 = 0;
  unint64_t v5 = specialized String.init(_:)(a1, a2, a3, a4);
  unint64_t v7 = v6;
  swift_bridgeObjectRelease(a4);
  char v8 = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v11, (char *)_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v7);
  if ((v8 & 1) != 0) {
    int v9 = v11;
  }
  else {
    int v9 = 0;
  }
  return v9 & 0xFFFEFFFF | (((v8 & 1) == 0) << 16);
}

__int16 Float16.init(_builtinFloatLiteral:)@<H0>(double _D0@<D0>)
{
  __asm { FCVT            H0, D0 }

  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Float16(uint64_t a1@<X8>)
{
  v2._Swift::UInt64 rawBits = specialized Substring.init<A>(_:)();
  uint64_t v4 = v3;
  __int16 v11 = 0;
  unint64_t v6 = specialized String.init(_:)(v2, v12, v5, v3);
  unint64_t v8 = v7;
  swift_bridgeObjectRelease(v4);
  char v9 = specialized String.withCString<A>(_:)(v6, v8, (uint64_t)&v11, (char *)_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v8);
  __int16 v10 = v11;
  if ((v9 & 1) == 0) {
    __int16 v10 = 0;
  }
  *(_WORD *)a1 = v10;
  *(_BYTE *)(a1 + 2) = (v9 & 1) == 0;
}

unint64_t specialized Float.init<A>(_:)(unint64_t a1, unint64_t a2)
{
  unsigned int v11 = 0;
  if ((a2 & 0x1000000000000000LL) != 0 || !(a2 & 0x2000000000000000LL | a1 & 0x1000000000000000LL))
  {
    char v4 = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)&v11, (char *)_swift_stdlib_strtof_clocale);
  }

  else if ((a2 & 0x2000000000000000LL) != 0)
  {
    *(void *)__s = a1;
    uint64_t v10 = a2 & 0xFFFFFFFFFFFFFFLL;
    char v4 = (a1 > 0x20u || ((0x100003E01uLL >> a1) & 1) == 0)
      && (unint64_t v5 = _swift_stdlib_strtof_clocale(__s, (float *)&v11)) != 0LL
      && *v5 == 0;
  }

  else
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v3 = (_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      unint64_t v3 = _StringObject.sharedUTF8.getter(a1, a2);
      if (v8 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
    }

    closure #1 in closure #1 in Double.init<A>(_:)partial apply( v3,  (uint64_t (*)(void))_swift_stdlib_strtof_clocale,  (BOOL *)__s);
    char v4 = __s[0];
  }

  swift_bridgeObjectRelease(a2);
  uint64_t v6 = v11;
  __s[0] = (v4 & 1) == 0;
  if ((v4 & 1) == 0) {
    uint64_t v6 = 0LL;
  }
  return v6 | ((unint64_t)((v4 & 1) == 0) << 32);
}

unint64_t Float.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)((char *)&v9 + 1) = 0;
  _OWORD v8[2] = (char *)&v9 + 1;
  (*(void (**)(uint64_t *__return_ptr, _BYTE *(*)@<X0>(_BYTE *@<X0>, BOOL *@<X8>), void *, ValueMetadata *, uint64_t, uint64_t))(a3 + 200))( &v9,  partial apply for closure #1 in closure #1 in Float.init<A>(_:),  v8,  &type metadata for Bool,  a2,  a3);
  int v5 = v9;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  uint64_t v6 = *(unsigned int *)((char *)&v9 + 1);
  BYTE1(v9) = v5 ^ 1;
  if (!v5) {
    uint64_t v6 = 0LL;
  }
  return v6 | ((unint64_t)(v5 ^ 1u) << 32);
}

float Float.init(_builtinFloatLiteral:)(double a1)
{
  return a1;
}

unint64_t Float.init(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unsigned int v11 = 0;
  unint64_t v5 = specialized String.init(_:)(a1, a2, a3, a4);
  unint64_t v7 = v6;
  swift_bridgeObjectRelease(a4);
  char v8 = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v11, (char *)_swift_stdlib_strtof_clocale);
  swift_bridgeObjectRelease(v7);
  uint64_t v9 = v11;
  if ((v8 & 1) == 0) {
    uint64_t v9 = 0LL;
  }
  return v9 | ((unint64_t)((v8 & 1) == 0) << 32);
}

unint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance Float@<X0>( unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result = specialized Float.init<A>(_:)(a1, a2);
  *(_DWORD *)a3 = result;
  *(_BYTE *)(a3 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t specialized Double.init<A>(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v10 = 0LL;
  if ((a2 & 0x1000000000000000LL) != 0 || !(a2 & 0x2000000000000000LL | a1 & 0x1000000000000000LL))
  {
    char v4 = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)&v10, (char *)_swift_stdlib_strtod_clocale);
  }

  else if ((a2 & 0x2000000000000000LL) != 0)
  {
    *(void *)__s = a1;
    uint64_t v9 = a2 & 0xFFFFFFFFFFFFFFLL;
    char v4 = (a1 > 0x20u || ((0x100003E01uLL >> a1) & 1) == 0)
      && (unint64_t v5 = _swift_stdlib_strtod_clocale(__s, (double *)&v10)) != 0LL
      && *v5 == 0;
  }

  else
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      unint64_t v3 = (_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      unint64_t v3 = _StringObject.sharedUTF8.getter(a1, a2);
      if (v7 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
    }

    closure #1 in closure #1 in Double.init<A>(_:)partial apply( v3,  (uint64_t (*)(void))_swift_stdlib_strtod_clocale,  (BOOL *)__s);
    char v4 = __s[0];
  }

  swift_bridgeObjectRelease(a2);
  if ((v4 & 1) != 0) {
    return v10;
  }
  else {
    return 0LL;
  }
}

uint64_t Double.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0LL;
  v7[2] = &v9;
  (*(void (**)(unsigned __int8 *__return_ptr, _BYTE *(*)@<X0>(_BYTE *@<X0>, BOOL *@<X8>), void *, ValueMetadata *, uint64_t, uint64_t))(a3 + 200))( &v8,  partial apply for closure #1 in closure #1 in Double.init<A>(_:),  v7,  &type metadata for Bool,  a2,  a3);
  int v5 = v8;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  if (v5) {
    return v9;
  }
  else {
    return 0LL;
  }
}

uint64_t Double.init(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = 0LL;
  unint64_t v5 = specialized String.init(_:)(a1, a2, a3, a4);
  unint64_t v7 = v6;
  swift_bridgeObjectRelease(v4);
  LOBYTE(v4) = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v9, (char *)_swift_stdlib_strtod_clocale);
  swift_bridgeObjectRelease(v7);
  if ((v4 & 1) != 0) {
    return v9;
  }
  else {
    return 0LL;
  }
}

uint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance Double@<X0>( unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = specialized Double.init<A>(_:)(a1, a2);
  *(void *)a3 = result;
  *(_BYTE *)(a3 + 8) = v5 & 1;
  return result;
}

void Float16._value.setter(__n128 a1)
{
  *uint64_t v1 = a1.n128_u16[0];
}

uint64_t (*Float16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

float Float16.init()()
{
  return 0.0;
}

unint64_t Float16.description.getter(__n128 a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((~a1.n128_u32[0] & 0x7C00) == 0 && (a1.n128_u16[0] & 0x3FF) != 0) {
    return 7233902LL;
  }
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  int64_t v2 = swift_float16ToString(&v14, 0x20uLL, a1);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  size_t v3 = v2;
  if (!v2) {
    return 0LL;
  }
  if ((unint64_t)v2 <= 0xF)
  {
    uint64_t v7 = v2 - 8;
    uint64_t v8 = 8LL;
    if (v2 < 8) {
      uint64_t v8 = v2;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v9 = 0LL;
    if (v3 >= 9)
    {
      uint64_t v10 = 0LL;
      unsigned int v11 = (unsigned __int8 *)__src + 8;
      unint64_t v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        unsigned int v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8LL;
        --v7;
      }

      while (v7);
    }
  }

  else
  {
    unint64_t v4 = v2 | 0xF000000000000000LL;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      unint64_t v4 = *(void *)(v5 + 24);
    }

    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }

  return result;
}

BOOL Float16.isNaN.getter(float a1)
{
  return (LOWORD(a1) & 0x3FF) != 0 && (~LODWORD(a1) & 0x7C00) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Float16( __n128 a1)
{
  a1.n128_u16[0] = *v1;
  return Float16.description.getter(a1);
}

unint64_t Float16.debugDescription.getter(__n128 a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  int64_t v1 = swift_float16ToString(&v14, 0x20uLL, a1);
  __src[0] = v14;
  __src[1] = v15;
  if (v1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  size_t v2 = v1;
  if (!v1) {
    return 0LL;
  }
  if ((unint64_t)v1 <= 0xF)
  {
    uint64_t v7 = v1 - 8;
    uint64_t v8 = 8LL;
    if (v1 < 8) {
      uint64_t v8 = v1;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v9 = 0LL;
    if (v2 >= 9)
    {
      uint64_t v10 = 0LL;
      unsigned int v11 = (unsigned __int8 *)__src + 8;
      unint64_t v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v2 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        unsigned int v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8LL;
        --v7;
      }

      while (v7);
    }
  }

  else
  {
    unint64_t v3 = v1 | 0xF000000000000000LL;
    int64_t v4 = _allocateStringStorage(codeUnitCapacity:)(v1);
    *(void *)(v4 + 16) = v5;
    *(void *)(v4 + 24) = v3;
    if (v5 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      unint64_t v3 = *(void *)(v4 + 24);
    }

    *(_BYTE *)(v4 + 32 + (v3 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v2, (char *)(v4 + 32));
    return *(void *)(v4 + 24);
  }

  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Float16( __n128 a1)
{
  a1.n128_u16[0] = *v1;
  return Float16.debugDescription.getter(a1);
}

uint64_t Float16.write<A>(to:)(__n128 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  memset(v8, 0, sizeof(v8));
  uint64_t v6 = swift_float16ToString(v8, 0x20uLL, a1);
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a4 + 32))(v8, v6, a3, a4);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Float16( uint64_t a1, uint64_t a2, uint64_t a3, __n128 a4)
{
  a4.n128_u16[0] = *v4;
  return Float16.write<A>(to:)(a4, a1, a2, a3);
}

uint64_t static Float16.exponentBitCount.getter()
{
  return 5LL;
}

uint64_t static Float16.significandBitCount.getter()
{
  return 10LL;
}

uint64_t static Float16._infinityExponent.getter()
{
  return 31LL;
}

uint64_t static Float16._exponentBias.getter()
{
  return 15LL;
}

uint64_t static Float16._significandMask.getter()
{
  return 1023LL;
}

uint64_t static UInt16.- infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result = a1 - a2;
  if ((result & 0xFFFF0000) != 0) {
    __break(1u);
  }
  return result;
}

uint64_t static Float16._quietNaNMask.getter()
{
  return 512LL;
}

  ;
}

float Float16.init(bitPattern:)(int a1)
{
  return *(float *)&a1;
}

uint64_t Float16.sign.getter(float a1)
{
  return (LODWORD(a1) >> 15) & 1;
}

uint64_t Float16.exponentBitPattern.getter(float a1)
{
  return (LODWORD(a1) >> 10) & 0x1F;
}

uint64_t Float16.significandBitPattern.getter(__n128 a1)
{
  return a1.n128_u16[0] & 0x3FF;
}

uint64_t static UInt16.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

uint64_t Float16.isCanonical.getter()
{
  return 1LL;
}

__int16 static Float16.leastNonzeroMagnitude.getter@<H0>()
{
  return 1;
}

__int16 static Float16.leastNormalMagnitude.getter@<H0>()
{
  return 1024;
}

__int16 static Float16.infinity.getter@<H0>()
{
  return 31744;
}

__int16 static Float16.nan.getter@<H0>()
{
  return 32256;
}

float Float16.init(nan:signaling:)(int a1, char a2)
{
  if ((unsigned __int16)a1 >= 0x100u) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "NaN payload is not encodable.",  29LL,  2,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x198uLL,  0);
  }
  LODWORD(result) = (0x200u >> (a2 & 1)) | a1 | 0x7C00;
  return result;
}

__int16 static Float16.signalingNaN.getter@<H0>()
{
  return 32000;
}

__int16 static Float16.greatestFiniteMagnitude.getter@<H0>()
{
  return 31743;
}

__int16 static Float16.pi.getter@<H0>()
{
  return 16968;
}

__int16 Float16.ulp.getter@<H0>(float a1@<S0>)
{
  int v1 = (LODWORD(a1) >> 10) & 0x1F;
  if (!v1) {
    return 1;
  }
  if (v1 == 31) {
    return 32256;
  }
  _H0 = LOWORD(a1) & 0x7C00;
  __asm { FCVT            S0, H0 }

  _S0 = _S0 * 0.00097656;
  __asm { FCVT            H0, S0 }

  return result;
}

BOOL Float16.isFinite.getter(float a1)
{
  return (~LODWORD(a1) & 0x7C00) != 0;
}

BOOL Float16.isNormal.getter(float a1)
{
  return ((LODWORD(a1) >> 10) & 0x1F) != 0x1F && ((LODWORD(a1) >> 10) & 0x1F) != 0;
}

__int16 static Float16.* infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 static Float16.ulpOfOne.getter@<H0>()
{
  return 5120;
}

uint64_t Float16.exponent.getter(float a1)
{
  uint64_t v1 = (LODWORD(a1) >> 10) & 0x1F;
  if ((_DWORD)v1 == 31) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unsigned int v3 = LOWORD(a1) & 0x3FF;
  if ((_DWORD)v1) {
    return v1 - 15;
  }
  if ((LOWORD(a1) & 0x3FF) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return v1 - (unsigned __int16)(__clz(v3) - 16) - 9;
}

BOOL Float16.isZero.getter(__n128 a1)
{
  return (a1.n128_u16[0] & 0x7FFF) == 0;
}

float Float16.significand.getter(float result)
{
  int v1 = (LODWORD(result) >> 10) & 0x1F;
  unsigned int v2 = LOWORD(result) & 0x3FF;
  if ((LOWORD(result) & 0x3FF) == 0 || v1 != 31)
  {
    if (v1)
    {
      if (v1 != 31)
      {
        LODWORD(result) = v2 | 0x3C00;
        return result;
      }
    }

    else if ((LOWORD(result) & 0x3FF) != 0)
    {
      LODWORD(result) = (LODWORD(result) << ((__clz(v2) - 5) & 0xF)) & 0x3FF | 0x3C00;
      return result;
    }

    LODWORD(result) = v1 << 10;
  }

  return result;
}

BOOL Float16.isSubnormal.getter(__n128 a1)
{
  return (a1.n128_u16[0] & 0x3FF) != 0 && (a1.n128_u16[0] & 0x7C00) == 0;
}

double Float16.init(sign:exponent:significand:)(char a1, uint64_t a2, float a3)
{
  *(void *)&double result = specialized Float16.init(sign:exponent:significand:)(a1 & 1, a2, a3);
  return result;
}

__int16 static Float16.- prefix(_:)@<H0>(__n128 _Q0@<Q0>)
{
  __asm { FCVT            S0, H0 }

  _S0 = -_S0;
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 static Float16.*= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

float Float16.nextUp.getter(__n128 _Q0)
{
  __asm { FCVT            S0, H0 }

  float result = _S0 + 0.0;
  __asm
  {
    FCVT            H0, S0
    FCVT            S1, H0
  }

  if (_S1 < INFINITY) {
    LODWORD(result) += (SLOWORD(result) >> 15) | 1;
  }
  return result;
}

__int16 Float16.init(_builtinIntegerLiteral:)@<H0>(uint64_t *a1@<X0>, unint64_t a2@<X1>)
{
  _S0 = swift_intToFloat32(a1, a2);
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 static Float16.+ infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }

  return result;
}

uint64_t static Int16.&>> infix(_:_:)(__int16 a1, char a2)
{
  return (a1 >> (a2 & 0xF));
}

uint64_t static Int16.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

unsigned __int16 Float16.init(signOf:magnitudeOf:)@<H0>(int8x16_t _Q0@<Q0>, int8x16_t _Q1@<Q1>)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  v6.i64[0] = 0x8000000080000000LL;
  v6.i64[1] = 0x8000000080000000LL;
  _Q0.i32[0] = vbslq_s8(v6, _Q1, _Q0).u32[0];
  __asm { FCVT            H0, S0 }

  return _Q0.i16[0];
}

Swift::Void __swiftcall Float16.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  switch(*(_BYTE *)a1)
  {
    case 0:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = roundf(_S0);
      goto LABEL_12;
    case 1:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = rintf(_S0);
      goto LABEL_12;
    case 2:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = ceilf(_S0);
      goto LABEL_12;
    case 3:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      goto LABEL_11;
    case 4:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = truncf(_S0);
      goto LABEL_12;
    case 5:
      _H0 = *v1;
      if (*v1 < 0)
      {
        __asm { FCVT            S0, H0 }

Swift::Void __swiftcall Float16._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  char v20 = *(_BYTE *)a1;
  switch(v20)
  {
    case 0:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = roundf(_S0);
      goto LABEL_12;
    case 1:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = rintf(_S0);
      goto LABEL_12;
    case 2:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = ceilf(_S0);
      goto LABEL_12;
    case 3:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      goto LABEL_11;
    case 4:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = truncf(_S0);
      goto LABEL_12;
    case 5:
      _H0 = *v1;
      if (*v1 < 0)
      {
        __asm { FCVT            S0, H0 }

Swift::Void __swiftcall Float16.negate()()
{
  _H0 = *v0;
  __asm { FCVT            S0, H0 }

  _S0 = -_S0;
  __asm { FCVT            H0, S0 }

  __int16 *v0 = LOWORD(_S0);
}

__int16 static Float16.+= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  _S0 = _S1 + _S0;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 static Float16.-= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  _S0 = _S1 - _S0;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 static Float16./= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  _S0 = _S1 / _S0;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 Float16.formRemainder(dividingBy:)@<H0>(__n128 _Q0@<Q0>)
{
  _H1 = *v1;
  __asm
  {
    FCVT            S2, H1
    FCVT            S1, H0; float
  }

  _S0 = remainderf(_S2, _S1);
  __asm { FCVT            H0, S0 }

  *int v1 = result;
  return result;
}

__int16 Float16.formTruncatingRemainder(dividingBy:)@<H0>(__n128 _Q0@<Q0>)
{
  _H2 = *v1;
  __asm
  {
    FCVT            S1, H0; float
    FCVT            S0, H2; float
  }

  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }

  *int v1 = result;
  return result;
}

Swift::Void __swiftcall Float16.formSquareRoot()()
{
  _H0 = *v0;
  __asm { FCVT            S0, H0 }

  _S0 = sqrtf(_S0);
  __asm { FCVT            H0, S0 }

  __int16 *v0 = LOWORD(_S0);
}

__int16 Float16.addProduct(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  _H2 = *v2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
    FCVT            S2, H2
  }

  _S0 = _S2 + (float)(_S0 * _S1);
  __asm { FCVT            H0, S0 }

  __int16 *v2 = result;
  return result;
}

BOOL Float16.isEqual(to:)(__n128 _Q0, __n128 _Q1)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 == _S0;
}

BOOL Float16.isLess(than:)(__n128 _Q0, __n128 _Q1)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 < _S0;
}

BOOL Float16.isLessThanOrEqualTo(_:)(__n128 _Q0, __n128 _Q1)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 <= _S0;
}

BOOL Float16.isSignalingNaN.getter(float a1)
{
  return (~LODWORD(a1) & 0x7C00) == 0 && (LOWORD(a1) & 0x3FF) != 0 && (LOWORD(a1) & 0x200) == 0;
}

__int16 Float16.binade.getter@<H0>(float _S0@<S0>)
{
  int v1 = (LODWORD(_S0) >> 10) & 0x1F;
  if (v1 == 31) {
    return 32256;
  }
  if ((LOWORD(_S0) & 0x3FF) == 0 || v1) {
    return LOWORD(_S0) & 0xFC00;
  }
  __asm { FCVT            S0, H0 }

  _S0 = _S0 * 1024.0;
  __asm { FCVT            H0, S0 }

  LOWORD(_S0) &= 0xFC00u;
  __asm { FCVT            S0, H0 }

  _S0 = _S0 * 0.00097656;
  __asm { FCVT            H0, S0 }

  return result;
}

uint64_t Float16.significandWidth.getter(float a1)
{
  unsigned int v1 = __clz(__rbit32(LOWORD(a1) & 0x3FF | 0x10000));
  int v2 = (LODWORD(a1) >> 10) & 0x1F;
  if (v2 && v2 != 31)
  {
    if ((LOWORD(a1) & 0x3FF) != 0) {
      return 10LL - v1;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    uint64_t result = -1LL;
    if ((LOWORD(a1) & 0x3FF) != 0)
    {
      uint64_t v4 = 16LL - (unsigned __int16)(__clz(LOWORD(a1) & 0x3FF) + v1 - 15);
      if (!v2) {
        return v4;
      }
    }
  }

  return result;
}

uint64_t static UInt16.bitWidth.getter()
{
  return 16LL;
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Float16( char a1@<W0>, void *a2@<X1>, __int16 *a3@<X2>, _WORD *a4@<X8>)
{
  float v5 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
  *a4 = LOWORD(v5);
}

__int16 protocol witness for BinaryFloatingPoint.init(_:) in conformance Float16@<H0>( _WORD *a1@<X8>, float _S0@<S0>)
{
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 protocol witness for BinaryFloatingPoint.init(_:) in conformance Float16@<H0>( _WORD *a1@<X8>, double _D0@<D0>)
{
  __asm { FCVT            H0, D0 }

  *a1 = result;
  return result;
}

__int16 Float16.init(_:)@<H0>(double _D0@<D0>)
{
  __asm { FCVT            H0, D0 }

  return result;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Float16( uint64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, _WORD *a4@<X8>)
{
  float v5 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
  *a4 = LOWORD(v5);
}

uint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Float16@<X0>( uint64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(_WORD *)a4 = result;
  *(_BYTE *)(a4 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.exponentBitCount.getter in conformance Float16()
{
  return 5LL;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Float16()
{
  return 10LL;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Float16( unint64_t *a1@<X8>)
{
  *a1 = ((unint64_t)*v1 >> 10) & 0x1F;
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Float16( _WORD *a1@<X8>)
{
  *a1 = *v1 & 0x3FF;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Float16( __int16 *a1@<X8>, float a2@<S0>)
{
  LOWORD(a2) = *v2;
  *a1 = Float16.binade.getter(a2);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Float16(float a1)
{
  LOWORD(a1) = *v1;
  return Float16.significandWidth.getter(a1);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Float16( char a1@<W0>, uint64_t *a2@<X1>, _WORD *a3@<X2>, __int16 *a4@<X8>, float a5@<S0>)
{
  LOWORD(a5) = *a3;
  *a4 = specialized Float16.init(sign:exponent:significand:)(a1 & 1, *a2, a5);
}

unsigned __int16 protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Float16@<H0>( unsigned __int16 *a1@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>, int8x16_t _Q0@<Q0>, int8x16_t _Q1@<Q1>)
{
  _Q0.i16[0] = *a1;
  _Q1.i16[0] = *a2;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  v9.i64[0] = 0x8000000080000000LL;
  v9.i64[1] = 0x8000000080000000LL;
  _Q0.i32[0] = vbslq_s8(v9, _Q1, _Q0).u32[0];
  __asm { FCVT            H0, S0 }

  *a3 = _Q0.i16[0];
  return _Q0.i16[0];
}

__int16 protocol witness for FloatingPoint.init(_:) in conformance Float16@<H0>( uint64_t a1@<X0>, _WORD *a2@<X8>)
{
  _S0 = (float)a1;
  __asm { FCVT            H0, S0 }

  *a2 = result;
  return result;
}

__int16 Float16.init(_:)@<H0>(uint64_t a1@<X0>)
{
  _S0 = (float)a1;
  __asm { FCVT            H0, S0 }

  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Float16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>, __int16 *a4@<X8>)
{
  if (a3[16](a2, a3) < 65)
  {
    char v10 = a3[8](a2, a3);
    uint64_t v11 = a3[15](a2, a3);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    if ((v10 & 1) != 0) {
      _S0 = (float)v11;
    }
    else {
      _S0 = (float)(unint64_t)v11;
    }
    __asm { FCVT            H0, S0 }
  }

  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v17, a1, a2, (uint64_t)a3);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    _H0 = v17;
  }

  *a4 = _H0;
  return result;
}

__int16 Float16.init<A>(_:)@<H0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>)
{
  if (a3[16](a2, a3) <= 64)
  {
    char v7 = a3[8](a2, a3);
    uint64_t v8 = a3[15](a2, a3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    if ((v7 & 1) != 0) {
      _S0 = (float)v8;
    }
    else {
      _S0 = (float)(unint64_t)v8;
    }
    __asm { FCVT            H0, S0 }
  }

  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v14, a1, a2, (uint64_t)a3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    return v14;
  }

  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Float16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = Float16.init<A>(exactly:)(a1, a2, a3);
  *(_WORD *)a4 = result;
  *(_BYTE *)(a4 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t Float16.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) <= 64)
  {
    char v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    __int128 v15 = *(void (**)(char *, uint64_t))(v6 + 8);
    v15(v8, a2);
    v15((char *)a1, a2);
    if ((v13 & 1) != 0)
    {
      _S0 = (float)v14;
      __asm
      {
        FCVT            H0, S0
        FCVT            S1, H0
      }

      LOWORD(v12) = LOWORD(_S0);
      int v21 = ~LODWORD(_S0) & 0x7C00;
      uint64_t v22 = (uint64_t)_S1;
    }

    else
    {
      _S0 = (float)(unint64_t)v14;
      __asm
      {
        FCVT            H0, S0
        FCVT            S1, H0
      }

      LOWORD(v12) = LOWORD(_S0);
      int v21 = ~LODWORD(_S0) & 0x7C00;
      uint64_t v22 = (unint64_t)_S1;
    }

    if (v21) {
      _ZF = v14 == v22;
    }
    else {
      _ZF = 0;
    }
    if (_ZF) {
      goto LABEL_12;
    }
  }

  else
  {
    char v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v29, a1, a2, a3);
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
    if ((v11 & 1) != 0)
    {
      LOWORD(v12) = v29;
LABEL_12:
      int v26 = 0;
      int v12 = (unsigned __int16)v12;
      return v12 | (v26 << 16);
    }
  }

  int v12 = 0;
  int v26 = 1;
  return v12 | (v26 << 16);
}

void protocol witness for static FloatingPoint.nan.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 512);
  *a1 = LOWORD(v2);
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 256);
  *a1 = LOWORD(v2);
}

__int16 protocol witness for static FloatingPoint.infinity.getter in conformance Float16@<H0>( _WORD *a1@<X8>)
{
  __int16 result = 31744;
  *a1 = 31744;
  return result;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Float16( _WORD *a1@<X8>)
{
  float v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 30, 1023);
  *a1 = LOWORD(v2);
}

__int16 protocol witness for static FloatingPoint.pi.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result = 16968;
  *a1 = 16968;
  return result;
}

void protocol witness for FloatingPoint.ulp.getter in conformance Float16(_WORD *a1@<X8>)
{
  unsigned int v3 = *v1;
  int v4 = (v3 >> 10) & 0x1F;
  if (v4)
  {
    if (v4 == 31)
    {
      _S0 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 512);
    }

    else
    {
      _H0 = v3 & 0x7C00;
      __asm { FCVT            S0, H0 }

      _S0 = _S0 * 0.00097656;
      __asm { FCVT            H0, S0 }
    }
  }

  else
  {
    LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = 1;
  }

  *a1 = LOWORD(_S0);
}

__int16 protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Float16@<H0>( _WORD *a1@<X8>)
{
  __int16 result = 5120;
  *a1 = 5120;
  return result;
}

__int16 protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Float16@<H0>( _WORD *a1@<X8>)
{
  __int16 result = 1024;
  *a1 = 1024;
  return result;
}

__int16 protocol witness for static FloatingPoint.leastNonzeroMagnitude.getter in conformance Float16@<H0>( _WORD *a1@<X8>)
{
  __int16 result = 1;
  *a1 = 1;
  return result;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Float16(float a1)
{
  LOWORD(a1) = *v1;
  return Float16.sign.getter(a1);
}

uint64_t protocol witness for FloatingPoint.exponent.getter in conformance Float16@<X0>( uint64_t *a1@<X8>, float a2@<S0>)
{
  LOWORD(a2) = *v2;
  uint64_t result = Float16.exponent.getter(a2);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Float16( _WORD *a1@<X8>, float a2@<S0>)
{
  LOWORD(a2) = *v2;
  float v4 = Float16.significand.getter(a2);
  *a1 = LOWORD(v4);
}

__int16 protocol witness for static FloatingPoint./ infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 / _S1;
  __asm { FCVT            H0, S0 }

  *a3 = result;
  return result;
}

__int16 static Float16./ infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 / _S1;
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 protocol witness for static FloatingPoint./= infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>)
{
  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  _S0 = _S1 / _S0;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Float16@<H0>( __int16 *a1@<X0>, _WORD *a2@<X8>)
{
  _H1 = *a1;
  _H0 = *v2;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }

  _S0 = _stdlib_remainderf(_S0, _S1);
  __asm { FCVT            H0, S0 }

  *a2 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Float16@<H0>( __int16 *a1@<X0>)
{
  _H1 = *a1;
  _H0 = *v1;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }

  _S0 = _stdlib_remainderf(_S0, _S1);
  __asm { FCVT            H0, S0 }

  *unsigned int v1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Float16@<H0>( __int16 *a1@<X0>, _WORD *a2@<X8>)
{
  _H1 = *a1;
  _H0 = *v2;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }

  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }

  *a2 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Float16@<H0>( __int16 *a1@<X0>)
{
  _H1 = *a1;
  _H0 = *v1;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }

  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }

  *unsigned int v1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.squareRoot() in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  _H0 = *v1;
  __asm { FCVT            S0, H0 }

  _S0 = _stdlib_squareRootf(_S0);
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formSquareRoot() in conformance Float16@<H0>()
{
  _H0 = *v0;
  __asm { FCVT            S0, H0 }

  _S0 = _stdlib_squareRootf(_S0);
  __asm { FCVT            H0, S0 }

  __int16 *v0 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  _H0 = *a1;
  _H1 = *a2;
  _H2 = *v3;
  __asm
  {
    FCVT            S2, H2
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S2 + (float)(_S0 * _S1);
  __asm { FCVT            H0, S0 }

  *a3 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.addProduct(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>)
{
  _H0 = *a1;
  _H1 = *a2;
  _H2 = *v2;
  __asm
  {
    FCVT            S2, H2
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S2 + (float)(_S0 * _S1);
  __asm { FCVT            H0, S0 }

  __int16 *v2 = result;
  return result;
}

_WORD *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Float16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *result;
  LOWORD(_S1) = *a2;
  __asm
  {
    FCVT            S2, H1
    FCVT            S3, H0
  }

  if (_S3 <= _S2) {
    goto LABEL_7;
  }
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }

  if ((LOWORD(_S1) & 0x3FF) == 0) {
    _S0 = _S1;
  }
  *a3 = LOWORD(_S0);
  return result;
}

_WORD *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Float16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *result;
  LOWORD(_S1) = *a2;
  __asm
  {
    FCVT            S2, H0
    FCVT            S3, H1
  }

  if (_S3 < _S2) {
    goto LABEL_7;
  }
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }

  if ((LOWORD(_S1) & 0x3FF) == 0) {
    _S0 = _S1;
  }
  *a3 = LOWORD(_S0);
  return result;
}

_WORD *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Float16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *result;
  LOWORD(_S1) = *a2;
  __asm { FCVT            S2, H0 }

  _S2 = fabsf(_S2);
  __asm
  {
    FCVT            H2, S2
    FCVT            S3, H1
  }

  _S3 = fabsf(_S3);
  __asm
  {
    FCVT            H3, S3
    FCVT            S3, H3
    FCVT            S2, H2
  }

  if (_S2 <= _S3) {
    goto LABEL_7;
  }
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }

  if ((LOWORD(_S1) & 0x3FF) == 0) {
    _S0 = _S1;
  }
  *a3 = LOWORD(_S0);
  return result;
}

_WORD *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Float16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *result;
  LOWORD(_S1) = *a2;
  __asm { FCVT            S2, H0 }

  _S2 = fabsf(_S2);
  __asm
  {
    FCVT            H2, S2
    FCVT            S3, H1
  }

  _S3 = fabsf(_S3);
  __asm
  {
    FCVT            H3, S3
    FCVT            S2, H2
    FCVT            S3, H3
  }

  if (_S3 < _S2) {
    goto LABEL_7;
  }
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/SIMDVector.swift",  22LL,  2,  0x4F3uLL, 0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }

  if ((LOWORD(_S1) & 0x3FF) == 0) {
    _S0 = _S1;
  }
  *a3 = LOWORD(_S0);
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Float16(_BYTE *a1@<X0>, _WORD *a2@<X8>)
{
  LOWORD(_S8) = *v2;
  __int16 v16 = *v2;
  switch(*a1)
  {
    case 0:
      __asm { FCVT            S0, H8; jumptable 0000000181683A74 case 0 }

      _S0 = roundf(_S0);
      goto LABEL_9;
    case 1:
      __asm { FCVT            S0, H8; jumptable 0000000181683A74 case 1 }

      _S0 = rintf(_S0);
      goto LABEL_9;
    case 2:
      goto LABEL_8;
    case 3:
      goto LABEL_7;
    case 4:
      __asm { FCVT            S0, H8; jumptable 0000000181683A74 case 4 }

      _S0 = truncf(_S0);
      goto LABEL_9;
    case 5:
      if (Float16.sign.getter(_S8))
      {
LABEL_7:
        __asm { FCVT            S0, H8; jumptable 0000000181683A74 case 3 }

        _S0 = floorf(_S0);
      }

      else
      {
LABEL_8:
        __asm { FCVT            S0, H8; jumptable 0000000181683A74 case 2 }

        _S0 = ceilf(_S0);
      }

__int16 protocol witness for FloatingPoint.round(_:) in conformance Float16@<H0>(_BYTE *a1@<X0>)
{
  switch(*a1)
  {
    case 0:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = roundf(_S0);
      goto LABEL_11;
    case 1:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = rintf(_S0);
      goto LABEL_11;
    case 2:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      goto LABEL_10;
    case 3:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      goto LABEL_9;
    case 4:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }

      _S0 = truncf(_S0);
      goto LABEL_11;
    case 5:
      LOWORD(_S8) = *v1;
      char v18 = Float16.sign.getter(_S8);
      __asm { FCVT            S0, H8 }

      if (v18) {
LABEL_9:
      }
        _S0 = floorf(_S0);
      else {
LABEL_10:
      }
        _S0 = ceilf(_S0);
LABEL_11:
      __asm { FCVT            H0, S0 }

      *unsigned int v1 = result;
      break;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }

  return result;
}

void protocol witness for FloatingPoint.nextUp.getter in conformance Float16(_WORD *a1@<X8>)
{
  _H0 = *v1;
  __asm { FCVT            S0, H0 }

  _S0 = _S0 + 0.0;
  __asm
  {
    FCVT            H0, S0
    FCVT            S1, H0
  }

  if (_S1 < INFINITY) {
    LODWORD(_S0) += (SLOWORD(_S0) >> 15) | 1;
  }
  *a1 = LOWORD(_S0);
}

__int16 protocol witness for FloatingPoint.nextDown.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  _H0 = *v1;
  __asm { FCVT            S0, H0 }

  _S0 = 0.0 - _S0;
  __asm
  {
    FCVT            H0, S0
    FCVT            S1, H0
  }

  if (_S1 < INFINITY) {
    _H0 += (_H0 >> 15) | 1;
  }
  __asm { FCVT            S0, H0 }

  _S0 = -_S0;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Float16(__int16 *a1)
{
  _H0 = *a1;
  _H1 = *v1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 == _S0;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Float16(__int16 *a1)
{
  _H0 = *a1;
  _H1 = *v1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 < _S0;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Float16(__int16 *a1)
{
  _H0 = *a1;
  _H1 = *v1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 <= _S0;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Float16( unsigned __int16 *a1, __n128 a2, __n128 a3)
{
  a2.n128_u16[0] = *a1;
  a3.n128_u16[0] = *v3;
  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(a2, a3);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Float16()
{
  int v1 = (*v0 >> 10) & 0x1F;
  return v1 != 31 && v1 != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Float16()
{
  return (~*v0 & 0x7C00) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Float16()
{
  return (*v0 & 0x7FFF) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Float16()
{
  return (*v0 & 0x3FF) != 0 && (*v0 & 0x7C00) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Float16()
{
  return (*v0 & 0x7FFF) == 31744;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Float16()
{
  int v1 = *v0;
  return (v1 & 0x3FF) != 0 && (~v1 & 0x7C00) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Float16()
{
  int v1 = *v0;
  int v2 = ~v1 & 0x7C00;
  int v3 = v1 & 0x3FF;
  BOOL v4 = (v1 & 0x200) == 0;
  if (v2) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v3 == 0;
  }
  return !v5 && v4;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Float16(float a1)
{
  LOWORD(a1) = *v1;
  return specialized FloatingPoint.floatingPointClass.getter(a1);
}

__int16 protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X8>)
{
  __int16 result = *a1;
  *a2 = *a1;
  return result;
}

__int16 protocol witness for static SignedNumeric.- prefix(_:) in conformance Float16@<H0>( __int16 *a1@<X0>, _WORD *a2@<X8>)
{
  _H0 = *a1;
  __asm { FCVT            S0, H0 }

  _S0 = -_S0;
  __asm { FCVT            H0, S0 }

  *a2 = result;
  return result;
}

__int16 protocol witness for SignedNumeric.negate() in conformance Float16@<H0>()
{
  _H0 = *v0;
  __asm { FCVT            S0, H0 }

  _S0 = -_S0;
  __asm { FCVT            H0, S0 }

  __int16 *v0 = result;
  return result;
}

__int16 protocol witness for Numeric.magnitude.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  _H0 = *v1;
  __asm { FCVT            S0, H0 }

  _S0 = fabsf(_S0);
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 Float16.magnitude.getter@<H0>(__n128 _Q0@<Q0>)
{
  __asm { FCVT            S0, H0 }

  _S0 = fabsf(_S0);
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 protocol witness for static Numeric.* infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }

  *a3 = result;
  return result;
}

__int16 protocol witness for static Numeric.*= infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>)
{
  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.zero.getter in conformance Float16@<S0>(_WORD *a1@<X8>)
{
  float result = 0.0;
  *a1 = 0;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }

  *a3 = result;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>)
{
  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }

  *a3 = result;
  return result;
}

__int16 static Float16.- infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Float16@<H0>( __int16 *a1@<X0>, __int16 *a2@<X1>)
{
  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  _S0 = _S1 - _S0;
  __asm { FCVT            H0, S0 }

  *a1 = result;
  return result;
}

__int16 Float16.init(integerLiteral:)@<H0>(uint64_t a1@<X0>)
{
  _S0 = (float)a1;
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Float16@<H0>( uint64_t *a1@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  _S0 = swift_intToFloat32(a1, a2);
  __asm { FCVT            H0, S0 }

  *a3 = result;
  return result;
}

__int16 protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Float16@<H0>( uint64_t *a1@<X0>, _WORD *a2@<X8>)
{
  _S0 = (float)*a1;
  __asm { FCVT            H0, S0 }

  *a2 = result;
  return result;
}

void Float16.hash(into:)(__n128 a1)
{
  if ((a1.n128_u16[0] & 0x7FFF) != 0) {
    Swift::UInt16 v1 = a1.n128_u16[0];
  }
  else {
    Swift::UInt16 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Float16._rawHashValue(seed:)(Swift::Int seed)
{
  unsigned __int16 v2 = v1;
  if ((v1 & 0x7FFF) == 0) {
    unsigned __int16 v2 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v2, 2LL);
}

uint64_t Float16.hashValue.getter(__n128 a1)
{
  unsigned __int16 v1 = a1.n128_u16[0];
  if ((a1.n128_u16[0] & 0x7FFF) == 0) {
    unsigned __int16 v1 = 0;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, v1, 2LL);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Float16()
{
  if ((*v0 & 0x7FFF) != 0) {
    uint64_t v1 = (unsigned __int16)*v0;
  }
  else {
    uint64_t v1 = 0LL;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, v1, 2LL);
}

void protocol witness for Hashable.hash(into:) in conformance Float16()
{
  if ((*v0 & 0x7FFF) != 0) {
    Swift::UInt16 v1 = *v0;
  }
  else {
    Swift::UInt16 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Float16(uint64_t a1)
{
  if ((*v1 & 0x7FFF) != 0) {
    uint64_t v2 = (unsigned __int16)*v1;
  }
  else {
    uint64_t v2 = 0LL;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(a1, v2, 2LL);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 == _S0;
}

uint64_t Int.init(_:)(float a1)
{
  return Int.init(_:)( "Float16 value cannot be converted to Int because it is either infinite or NaN",  77LL,  0x36A2uLL,  a1);
}

unint64_t UInt.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3093uLL,  0);
  }
  __asm { FCVT            S0, H0 }

  if (_S0 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt because the result would be less than UInt.min",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3096uLL,  0);
  }
  return (unint64_t)_S0;
}

uint64_t Float16.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S1, H0 }

  return _Q0.n128_u16[0];
}

uint64_t Float16.init(exactly:)(float _S0)
{
  __asm
  {
    FCVT            H1, S0
    FCVT            S2, H1
  }

  int v7 = _H1;
  if (_S2 != _S0) {
    int v7 = 0;
  }
  return v7 | ((_S2 != _S0) << 16);
}

uint64_t Float16.init(exactly:)(double _D0)
{
  __asm
  {
    FCVT            H1, D0
    FCVT            D2, H1
  }

  int v7 = _H1;
  if (_D2 != _D0) {
    int v7 = 0;
  }
  return v7 | ((_D2 != _D0) << 16);
}

double Double.init(_:)(__n128 _Q0)
{
  __asm { FCVT            D0, H0 }

  return result;
}

__int16 Float16.distance(to:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 Float16.advanced(by:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }

  return result;
}

__int16 protocol witness for Strideable.distance(to:) in conformance Float16@<H0>( __int16 *a1@<X0>, _WORD *a2@<X8>)
{
  _H0 = *a1;
  _H1 = *v2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }

  *a2 = result;
  return result;
}

__int16 protocol witness for Strideable.advanced(by:) in conformance Float16@<H0>( __int16 *a1@<X0>, _WORD *a2@<X8>)
{
  _H0 = *a1;
  _H1 = *v2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }

  *a2 = result;
  return result;
}

_WORD *protocol witness for static Strideable._step(after:from:by:) in conformance Float16( _WORD *result, uint64_t a2, char a3, __int16 *a4, __int16 *a5, __int16 *a6)
{
  _H0 = *a6;
  if ((a3 & 1) != 0)
  {
    _H1 = *a4;
    __asm
    {
      FCVT            S0, H0
      FCVT            S1, H1
    }

    _S0 = _S0 + _S1;
    goto LABEL_5;
  }

  if (!__OFADD__(a2++, 1LL))
  {
    _H1 = *a5;
    _S2 = (float)a2;
    __asm
    {
      FCVT            H2, S2
      FCVT            S1, H1
      FCVT            S0, H0
      FCVT            S2, H2
    }

    _S0 = _S1 + (float)(_S2 * _S0);
LABEL_5:
    __asm { FCVT            H0, S0 }

    *__int16 result = _H0;
    return (_WORD *)a2;
  }

  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  return _S0 < _S1;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }

  return _S0 <= _S1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 <= _S0;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }

  return _S1 < _S0;
}

void Float._value.setter(float a1)
{
  *Swift::UInt16 v1 = a1;
}

uint64_t (*Float._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Float __swiftcall Float.init()()
{
  return 0.0;
}

unint64_t Float.description.getter(float a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if ((~LODWORD(a1) & 0x7F800000) == 0 && (LODWORD(a1) & 0x7FFFFF) != 0) {
    return 7233902LL;
  }
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  int64_t v2 = swift_float32ToString(&v14, 32LL, 0LL);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  size_t v3 = v2;
  if (!v2) {
    return 0LL;
  }
  if ((unint64_t)v2 <= 0xF)
  {
    uint64_t v7 = v2 - 8;
    uint64_t v8 = 8LL;
    if (v2 < 8) {
      uint64_t v8 = v2;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v9 = 0LL;
    if (v3 >= 9)
    {
      uint64_t v10 = 0LL;
      char v11 = (unsigned __int8 *)__src + 8;
      unint64_t v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        unsigned int v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8LL;
        --v7;
      }

      while (v7);
    }
  }

  else
  {
    unint64_t v4 = v2 | 0xF000000000000000LL;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      unint64_t v4 = *(void *)(v5 + 24);
    }

    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }

  return result;
}

BOOL Float.isNaN.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFF) != 0 && (~LODWORD(a1) & 0x7F800000) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Float()
{
  return Float.description.getter(*v0);
}

unint64_t Float.debugDescription.getter()
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  int64_t v0 = swift_float32ToString(&v13, 32LL, 1LL);
  __src[0] = v13;
  __src[1] = v14;
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  size_t v1 = v0;
  if (!v0) {
    return 0LL;
  }
  if ((unint64_t)v0 <= 0xF)
  {
    uint64_t v6 = v0 - 8;
    uint64_t v7 = 8LL;
    if (v0 < 8) {
      uint64_t v7 = v0;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v7 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v7 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v7 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v7 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v7 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v7 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v7 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v8 = 0LL;
    if (v1 >= 9)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = (unsigned __int8 *)__src + 8;
      unint64_t v11 = v6 & ~(v6 >> 63);
      do
      {
        if (v11 <= v1 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        unsigned int v12 = *v10++;
        v8 |= (unint64_t)v12 << v9;
        v9 += 8LL;
        --v6;
      }

      while (v6);
    }
  }

  else
  {
    unint64_t v2 = v0 | 0xF000000000000000LL;
    int64_t v3 = _allocateStringStorage(codeUnitCapacity:)(v0);
    *(void *)(v3 + 16) = v4;
    *(void *)(v3 + 24) = v2;
    if (v4 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      unint64_t v2 = *(void *)(v3 + 24);
    }

    *(_BYTE *)(v3 + 32 + (v2 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v1, (char *)(v3 + 32));
    return *(void *)(v3 + 24);
  }

  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Float()
{
  return Float.debugDescription.getter();
}

void specialized Float.write<A>(to:)()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  memset(v1, 0, sizeof(v1));
  uint64_t v0 = swift_float32ToString(v1, 32LL, 1LL);
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  _StringGuts.append(_:)(v0 | 0xD000000000000000LL, (unint64_t)&v1[0x7FFFFFFFFFFFFFELL] | 0x8000000000000000LL);
}

uint64_t Float.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v5 = swift_float32ToString(v7, 32LL, 1LL);
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a3 + 32))(v7, v5, a2, a3);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Float( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Float.write<A>(to:)(a1, a2, a3);
}

uint64_t static Float.exponentBitCount.getter()
{
  return 8LL;
}

uint64_t static Float.significandBitCount.getter()
{
  return 23LL;
}

uint64_t static Float._infinityExponent.getter()
{
  return 255LL;
}

uint64_t static Float._exponentBias.getter()
{
  return 127LL;
}

uint64_t static Float._significandMask.getter()
{
  return 0x7FFFFFLL;
}

uint64_t static Float._quietNaNMask.getter()
{
  return 0x400000LL;
}

  ;
}

Swift::Float __swiftcall Float.init(bitPattern:)(Swift::UInt32 bitPattern)
{
  return *(float *)&bitPattern;
}

uint64_t Float.sign.getter(float a1)
{
  return LODWORD(a1) >> 31;
}

uint64_t Float.exponentBitPattern.getter(float a1)
{
  return (LODWORD(a1) >> 23);
}

uint64_t Float.significandBitPattern.getter(float a1)
{
  return LODWORD(a1) & 0x7FFFFF;
}

uint64_t Float.isCanonical.getter()
{
  return 1LL;
}

float static Float.leastNonzeroMagnitude.getter()
{
  LODWORD(result) = 1;
  return result;
}

float static Float.leastNormalMagnitude.getter()
{
  return 1.1755e-38;
}

float static Float.infinity.getter()
{
  return INFINITY;
}

float static Float.nan.getter()
{
  return NAN;
}

float static Float.signalingNaN.getter()
{
  return NAN;
}

Swift::Float __swiftcall Float.init(nan:signaling:)(Swift::UInt32 nan, Swift::Bool signaling)
{
  if (nan >= 0x200000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "NaN payload is not encodable.",  29LL,  2,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x61AuLL,  0);
  }
  LODWORD(result) = (0x400000u >> signaling) | nan | 0x7F800000;
  return result;
}

float static Float.greatestFiniteMagnitude.getter()
{
  return 3.4028e38;
}

float static Float.pi.getter()
{
  return 3.1416;
}

float Float.ulp.getter(float a1)
{
  int v2 = (LODWORD(a1) >> 23);
  if ((LODWORD(a1) >> 23))
  {
    float result = NAN;
    if (v2 != 255) {
      return COERCE_FLOAT(LODWORD(a1) & 0x7F800000) * 0.00000011921;
    }
  }

  else
  {
    LODWORD(result) = 1;
  }

  return result;
}

BOOL Float.isNormal.getter(float a1)
{
  return (LODWORD(a1) >> 23) != 255 && (LODWORD(a1) >> 23) != 0;
}

double static Float.ulpOfOne.getter()
{
  return 3.18618444e-58;
}

uint64_t Float.exponent.getter(float a1)
{
  uint64_t v1 = (LODWORD(a1) >> 23);
  if ((_DWORD)v1 == 255) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unsigned int v3 = LODWORD(a1) & 0x7FFFFF;
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return v1 - __clz(v3) - 118;
}

BOOL Float.isZero.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 0;
}

float Float.significand.getter(float result)
{
  int v1 = (LODWORD(result) >> 23);
  unsigned int v2 = LODWORD(result) & 0x7FFFFF;
  if ((LODWORD(result) & 0x7FFFFF) == 0 || v1 != 255)
  {
    if ((LODWORD(result) >> 23))
    {
      if (v1 != 255)
      {
        LODWORD(result) = v2 | 0x3F800000;
        return result;
      }
    }

    else if (v2)
    {
      LODWORD(result) = (LODWORD(result) << (__clz(v2) + 24)) & 0x7FFFFF | 0x3F800000;
      return result;
    }

    LODWORD(result) = v1 << 23;
  }

  return result;
}

BOOL Float.isSubnormal.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFF) != 0 && (LODWORD(a1) & 0x7F800000) == 0;
}

Swift::Float __swiftcall Float.init(sign:exponent:significand:)( Swift::FloatingPointSign sign, Swift::Int exponent, Swift::Float significand)
{
  return specialized Float.init(sign:exponent:significand:)(sign & 1, exponent, significand);
}

float static Float.- prefix(_:)(float a1)
{
  return -a1;
}

float static Float.*= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 * a2;
  *a1 = result;
  return result;
}

float Float.nextUp.getter(float a1)
{
  float result = a1 + 0.0;
  if (result < INFINITY) {
    LODWORD(result) += (SLODWORD(result) >> 31) | 1;
  }
  return result;
}

float static Float.+ infix(_:_:)(float a1, float a2)
{
  return a1 + a2;
}

uint64_t static Int32.&>> infix(_:_:)(int a1, char a2)
{
  return (a1 >> a2);
}

uint64_t static Int32.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

Swift::Float __swiftcall Float.init(signOf:magnitudeOf:)(Swift::Float signOf, Swift::Float magnitudeOf)
{
  v2.i64[0] = 0x8000000080000000LL;
  v2.i64[1] = 0x8000000080000000LL;
  LODWORD(result) = vbslq_s8(v2, *(int8x16_t *)&magnitudeOf, *(int8x16_t *)&signOf).u32[0];
  return result;
}

Swift::Void __swiftcall Float.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  switch(*(_BYTE *)a1)
  {
    case 0:
      *int v1 = roundf(*v1);
      return;
    case 1:
      *int v1 = rintf(*v1);
      return;
    case 2:
      float v2 = *v1;
      goto LABEL_9;
    case 3:
      float v2 = *v1;
      goto LABEL_10;
    case 4:
      *int v1 = truncf(*v1);
      return;
    case 5:
      float v2 = *v1;
      if ((*(_DWORD *)v1 & 0x80000000) != 0) {
LABEL_10:
      }
        *int v1 = floorf(v2);
      else {
LABEL_9:
      }
        *int v1 = ceilf(v2);
      break;
    default:
      Float._roundSlowPath(_:)(a1);
      break;
  }

Swift::Void __swiftcall Float._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  char v4 = *(_BYTE *)a1;
  switch(v4)
  {
    case 0:
      float v2 = roundf(*v1);
      goto LABEL_11;
    case 1:
      float v2 = rintf(*v1);
      goto LABEL_11;
    case 2:
      float v3 = *v1;
      goto LABEL_9;
    case 3:
      float v3 = *v1;
      goto LABEL_10;
    case 4:
      float v2 = truncf(*v1);
      goto LABEL_11;
    case 5:
      float v3 = *v1;
      if ((*(_DWORD *)v1 & 0x80000000) != 0) {
LABEL_10:
      }
        float v2 = floorf(v3);
      else {
LABEL_9:
      }
        float v2 = ceilf(v3);
LABEL_11:
      *int v1 = v2;
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v4);
      break;
  }

Swift::Void __swiftcall Float.negate()()
{
  float *v0 = -*v0;
}

float static Float.+= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 + a2;
  *a1 = result;
  return result;
}

float static Float.-= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 - a2;
  *a1 = result;
  return result;
}

float static Float./= infix(_:_:)(float *a1, float a2)
{
  float result = *a1 / a2;
  *a1 = result;
  return result;
}

Swift::Void __swiftcall Float.formRemainder(dividingBy:)(Swift::Float dividingBy)
{
  *int v1 = remainderf(*v1, dividingBy);
}

Swift::Void __swiftcall Float.formTruncatingRemainder(dividingBy:)(Swift::Float dividingBy)
{
  *int v1 = fmodf(*v1, dividingBy);
}

Swift::Void __swiftcall Float.formSquareRoot()()
{
  float *v0 = sqrtf(*v0);
}

Swift::Void __swiftcall Float.addProduct(_:_:)(Swift::Float a1, Swift::Float a2)
{
  float *v2 = *v2 + (float)(a1 * a2);
}

Swift::Bool __swiftcall Float.isEqual(to:)(Swift::Float to)
{
  return v1 == to;
}

Swift::Bool __swiftcall Float.isLess(than:)(Swift::Float than)
{
  return v1 < than;
}

Swift::Bool __swiftcall Float.isLessThanOrEqualTo(_:)(Swift::Float a1)
{
  return v1 <= a1;
}

BOOL Float.isInfinite.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 2139095040;
}

BOOL Float.isSignalingNaN.getter(float a1)
{
  return (~LODWORD(a1) & 0x7F800000) == 0 && (LODWORD(a1) & 0x7FFFFF) != 0 && (LODWORD(a1) & 0x400000) == 0;
}

float Float.binade.getter(float a1)
{
  LODWORD(result) = LODWORD(a1) & 0xFF800000;
  return result;
}

uint64_t Float.significandWidth.getter(float a1)
{
  unsigned int v1 = LODWORD(a1) & 0x7FFFFF;
  unsigned int v2 = __clz(__rbit32(LODWORD(a1) & 0x7FFFFF));
  if ((LODWORD(a1) >> 23) && (LODWORD(a1) >> 23) != 255)
  {
    uint64_t v5 = 23LL - v2;
    if (v1) {
      return v5;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    uint64_t result = -1LL;
    if ((LODWORD(a1) & 0x7F800000) == 0)
    {
      uint64_t v4 = 32LL - (__clz(v1) + v2 + 1);
      if (v1) {
        return v4;
      }
    }
  }

  return result;
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Float( char a1@<W0>, void *a2@<X1>, int *a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
}

void protocol witness for BinaryFloatingPoint.init(_:) in conformance Float(float *a1@<X8>, float a2@<S0>)
{
  *a1 = a2;
}

float protocol witness for BinaryFloatingPoint.init(_:) in conformance Float@<S0>( float *a1@<X8>, double a2@<D0>)
{
  float result = a2;
  *a1 = result;
  return result;
}

Swift::Float __swiftcall Float.init(_:)(Swift::Double a1)
{
  return a1;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Float( const char *a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
}

unint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Float@<X0>( const char *a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(_DWORD *)a4 = result;
  *(_BYTE *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Float()
{
  return 23LL;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Float( void *a1@<X8>)
{
  *a1 = ((unint64_t)*v1 >> 23);
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Float( int *a1@<X8>)
{
  *a1 = *v1 & 0x7FFFFF;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Float(float *a1@<X8>)
{
  *a1 = Float.binade.getter(*v1);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Float()
{
  return Float.significandWidth.getter(*v0);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Float( char a1@<W0>, uint64_t *a2@<X1>, float *a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized Float.init(sign:exponent:significand:)(a1 & 1, *a2, *a3);
}

double protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Float@<D0>( unsigned __int32 *a1@<X0>, unsigned __int32 *a2@<X1>, _DWORD *a3@<X8>, int8x16_t a4@<Q0>, int8x16_t a5@<Q1>)
{
  a4.i32[0] = *a1;
  a5.i32[0] = *a2;
  v5.i64[0] = 0x8000000080000000LL;
  v5.i64[1] = 0x8000000080000000LL;
  a4.i64[0] = vbslq_s8(v5, a5, a4).u64[0];
  *a3 = a4.i32[0];
  return *(double *)a4.i64;
}

float protocol witness for FloatingPoint.init(_:) in conformance Float@<S0>(uint64_t a1@<X0>, float *a2@<X8>)
{
  float result = (float)a1;
  *a2 = (float)a1;
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Float@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>, float *a4@<X8>)
{
  if (a3[16](a2, a3) < 65)
  {
    char v10 = a3[8](a2, a3);
    uint64_t v11 = a3[15](a2, a3);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    if ((v10 & 1) != 0) {
      float v9 = (float)v11;
    }
    else {
      float v9 = (float)(unint64_t)v11;
    }
  }

  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v12, a1, a2, (uint64_t)a3);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    float v9 = v12;
  }

  *a4 = v9;
  return result;
}

float Float.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t (**a3)(void, void))
{
  if (a3[16](a2, a3) <= 64)
  {
    char v7 = a3[8](a2, a3);
    uint64_t v8 = a3[15](a2, a3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    if ((v7 & 1) != 0) {
      return (float)v8;
    }
    else {
      return (float)(unint64_t)v8;
    }
  }

  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v9, a1, a2, (uint64_t)a3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    return v9;
  }

unint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Float@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = Float.init<A>(exactly:)(a1, a2, a3);
  *(_DWORD *)a4 = result;
  *(_BYTE *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t Float.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) <= 64)
  {
    char v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    __int128 v15 = *(void (**)(char *, uint64_t))(v6 + 8);
    v15(v8, a2);
    if ((v13 & 1) != 0)
    {
      float v16 = (float)v14;
      if ((float)v14 < 9.2234e18)
      {
        float v12 = (float)v14;
        if ((~LODWORD(v16) & 0x7F800000) == 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int because it is either infinite or NaN",  75LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x36EDuLL,  0);
        }
        if (v16 <= -9.2234e18) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int because the result would be less than Int.min",  84LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x36F0uLL,  0);
        }
        v15((char *)a1, a2);
LABEL_15:
        uint64_t v19 = 0LL;
        unsigned __int8 v18 = 1;
        goto LABEL_16;
      }
    }

    else
    {
      float v17 = (float)(unint64_t)v14;
      if ((float)(unint64_t)v14 < 1.8447e19)
      {
        float v12 = (float)(unint64_t)v14;
        if ((~LODWORD(v17) & 0x7F800000) == 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x30E1uLL,  0);
        }
        v15((char *)a1, a2);
        goto LABEL_15;
      }
    }

    v15((char *)a1, a2);
    goto LABEL_15;
  }

  char v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v22, a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  if ((v11 & 1) == 0) {
    goto LABEL_15;
  }
  float v12 = v22;
LABEL_13:
  unsigned __int8 v18 = 0;
  uint64_t v19 = LODWORD(v12);
LABEL_16:
  unsigned __int8 v23 = v18;
  return v19 | ((unint64_t)v18 << 32);
}

void protocol witness for static FloatingPoint.nan.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2143289344;
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Float(float *a1@<X8>)
{
  *a1 = specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(0, 0xFFu, 0x200000);
}

void protocol witness for static FloatingPoint.infinity.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2139095040;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Float( _DWORD *a1@<X8>)
{
  *a1 = 2139095039;
}

void protocol witness for static FloatingPoint.pi.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 1078530010;
}

float protocol witness for FloatingPoint.ulp.getter in conformance Float@<S0>(float *a1@<X8>)
{
  if ((*v1 >> 23))
  {
    if ((*v1 >> 23) != 255)
    {
      float result = COERCE_FLOAT(*v1 & 0x7F800000) * 0.00000011921;
      *a1 = result;
      return result;
    }

    float v3 = NAN;
  }

  else
  {
    LODWORD(v3) = 1;
  }

  float result = v3;
  *a1 = v3;
  return result;
}

void protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 872415232;
}

void protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Float( _DWORD *a1@<X8>)
{
  *a1 = 0x800000;
}

void protocol witness for static FloatingPoint.leastNonzeroMagnitude.getter in conformance Float( _DWORD *a1@<X8>)
{
  *a1 = 1;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Float()
{
  return Float.sign.getter(*v0);
}

uint64_t protocol witness for FloatingPoint.exponent.getter in conformance Float@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = Float.exponent.getter(*v1);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Float(float *a1@<X8>)
{
  *a1 = Float.significand.getter(*v1);
}

float protocol witness for static FloatingPoint./ infix(_:_:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 / *a2;
  *a3 = result;
  return result;
}

float static Float./ infix(_:_:)(float a1, float a2)
{
  return a1 / a2;
}

float protocol witness for static FloatingPoint./= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *a1 / *a2;
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Float( float *a1@<X0>, float *a2@<X8>)
{
  *a2 = _stdlib_remainderf(*v2, *a1);
}

void protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Float(float *a1)
{
  *unsigned int v1 = _stdlib_remainderf(*v1, *a1);
}

void protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Float( float *a1@<X0>, float *a2@<X8>)
{
  *a2 = fmodf(*v2, *a1);
}

void protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Float(float *a1)
{
  *unsigned int v1 = fmodf(*v1, *a1);
}

void protocol witness for FloatingPoint.squareRoot() in conformance Float(float *a1@<X8>)
{
  *a1 = _stdlib_squareRootf(*v1);
}

void protocol witness for FloatingPoint.formSquareRoot() in conformance Float()
{
  float *v0 = _stdlib_squareRootf(*v0);
}

float protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *v3 + (float)(*a1 * *a2);
  *a3 = result;
  return result;
}

float protocol witness for FloatingPoint.addProduct(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *v2 + (float)(*a1 * *a2);
  float *v2 = result;
  return result;
}

float *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Float@<X0>( float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (*result > *a2)
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Float@<X0>( float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (*a2 >= *result)
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Float@<X0>( float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (fabsf(*result) > fabsf(*a2))
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Float@<X0>( float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *result;
  if (fabsf(*a2) >= fabsf(*result))
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0) {
      float v3 = *a2;
    }
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0) {
      float v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Float(_BYTE *a1@<X0>, float *a2@<X8>)
{
  float v4 = *v2;
  float v8 = *v2;
  switch(*a1)
  {
    case 0:
      float v5 = roundf(v4);
      break;
    case 1:
      float v5 = rintf(v4);
      break;
    case 2:
      float v5 = ceilf(v4);
      break;
    case 3:
      float v5 = floorf(v4);
      break;
    case 4:
      float v5 = truncf(v4);
      break;
    case 5:
      char v6 = Float.sign.getter(v4);
      float v5 = ceilf(v4);
      float v7 = floorf(v4);
      if (v6) {
        float v5 = v7;
      }
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      float v5 = v8;
      break;
  }

  *a2 = v5;
}

void protocol witness for FloatingPoint.round(_:) in conformance Float(_BYTE *a1)
{
  switch(*a1)
  {
    case 0:
      float v2 = roundf(*v1);
      goto LABEL_11;
    case 1:
      float v2 = rintf(*v1);
      goto LABEL_11;
    case 2:
      float v2 = ceilf(*v1);
      goto LABEL_11;
    case 3:
      float v2 = floorf(*v1);
      goto LABEL_11;
    case 4:
      float v2 = truncf(*v1);
      goto LABEL_11;
    case 5:
      float v3 = *v1;
      else {
        float v2 = ceilf(v3);
      }
LABEL_11:
      *unsigned int v1 = v2;
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }

void protocol witness for FloatingPoint.nextUp.getter in conformance Float(float *a1@<X8>)
{
  float v2 = *v1 + 0.0;
  if (v2 < INFINITY) {
    LODWORD(v2) += (SLODWORD(v2) >> 31) | 1;
  }
  *a1 = v2;
}

float protocol witness for FloatingPoint.nextDown.getter in conformance Float@<S0>(float *a1@<X8>)
{
  float v2 = 0.0 - *v1;
  if (v2 < INFINITY) {
    LODWORD(v2) += (SLODWORD(v2) >> 31) | 1;
  }
  float result = -v2;
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Float(float *a1)
{
  return *v1 == *a1;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Float(float *a1)
{
  return *v1 < *a1;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Float(float *a1)
{
  return *v1 <= *a1;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Float(float *a1)
{
  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(*a1, *v1);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Float()
{
  return (*v0 >> 23) != 255 && (*v0 >> 23) != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Float()
{
  return (~*v0 & 0x7F800000) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Float()
{
  return (*v0 & 0x7FFFFFFF) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Float()
{
  return (*v0 & 0x7FFFFF) != 0 && (*v0 & 0x7F800000) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Float()
{
  return (*v0 & 0x7FFFFFFF) == 2139095040;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Float()
{
  return (*v0 & 0x7FFFFF) != 0 && (~*v0 & 0x7F800000) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Float()
{
  return (~*v0 & 0x7F800000) == 0 && (*v0 & 0x7FFFFF) != 0 && (*v0 & 0x400000) == 0;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Float()
{
  return specialized FloatingPoint.floatingPointClass.getter(*v0);
}

float protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Float@<S0>( float *a1@<X0>, _DWORD *a2@<X8>)
{
  float result = *a1;
  *a2 = *(_DWORD *)a1;
  return result;
}

float protocol witness for static SignedNumeric.- prefix(_:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X8>)
{
  float result = -*a1;
  *a2 = result;
  return result;
}

float protocol witness for SignedNumeric.negate() in conformance Float()
{
  float result = -*v0;
  float *v0 = result;
  return result;
}

float protocol witness for Numeric.magnitude.getter in conformance Float@<S0>(float *a1@<X8>)
{
  float result = fabsf(*v1);
  *a1 = result;
  return result;
}

float Float.magnitude.getter(float a1)
{
  return fabsf(a1);
}

float protocol witness for static Numeric.* infix(_:_:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 * *a2;
  *a3 = result;
  return result;
}

float protocol witness for static Numeric.*= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result = *a2 * *a1;
  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 + *a2;
  *a3 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Float( float *a1, float *a2)
{
  float result = *a2 + *a1;
  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result = *a1 - *a2;
  *a3 = result;
  return result;
}

float static Float.- infix(_:_:)(float a1, float a2)
{
  return a1 - a2;
}

float protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Float( float *a1, float *a2)
{
  float result = *a1 - *a2;
  *a1 = result;
  return result;
}

Swift::Float __swiftcall Float.init(integerLiteral:)(Swift::Int64 integerLiteral)
{
  return (float)integerLiteral;
}

void protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Float( uint64_t *a1@<X0>, unint64_t a2@<X1>, float *a3@<X8>)
{
  *a3 = swift_intToFloat32(a1, a2);
}

float protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Float@<S0>( uint64_t *a1@<X0>, float *a2@<X8>)
{
  float result = (float)*a1;
  *a2 = result;
  return result;
}

void Float.hash(into:)(float a1)
{
  if ((LODWORD(a1) & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = LODWORD(a1);
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Float._rawHashValue(seed:)(Swift::Int seed)
{
  if ((v1 & 0x7FFFFFFF) != 0) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0LL;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v2, 4LL);
}

uint64_t Float.hashValue.getter(float a1)
{
  if ((LODWORD(a1) & 0x7FFFFFFF) != 0) {
    uint64_t v1 = LODWORD(a1);
  }
  else {
    uint64_t v1 = 0LL;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, v1, 4LL);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Float()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    uint64_t v1 = *v0;
  }
  else {
    uint64_t v1 = 0LL;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, v1, 4LL);
}

void protocol witness for Hashable.hash(into:) in conformance Float()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = *v0;
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Float(uint64_t a1)
{
  if ((*v1 & 0x7FFFFFFF) != 0) {
    uint64_t v2 = *v1;
  }
  else {
    uint64_t v2 = 0LL;
  }
  return specialized static Hasher._hash(seed:bytes:count:)(a1, v2, 4LL);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 == *a2;
}

void Float._toCustomAnyHashable()(uint64_t a1@<X8>, float a2@<S0>)
{
  *(void *)(a1 + 24) = &type metadata for _FloatAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _FloatAnyHashableBox;
  *(float *)a1 = a2;
}

float protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Float@<S0>( uint64_t a1@<X8>)
{
  float result = *v1;
  *(void *)(a1 + 24) = &type metadata for _FloatAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _FloatAnyHashableBox;
  *(float *)a1 = result;
  return result;
}

Swift::UInt __swiftcall UInt.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x30E1uLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt because the result would be less than UInt.min",  86LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x30E4uLL,  0);
  }
  if (a1 >= 1.8447e19) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt because the result would be greater than UInt.max",  89LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x30E7uLL,  0);
  }
  return (unint64_t)a1;
}

uint64_t Float.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S0, H0 }

  return _S0;
}

  ;
}

  ;
}

Swift::Float __swiftcall Float.distance(to:)(Swift::Float to)
{
  return to - v1;
}

Swift::Float __swiftcall Float.advanced(by:)(Swift::Float by)
{
  return by + v1;
}

float protocol witness for Strideable.distance(to:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X8>)
{
  float result = *a1 - *v2;
  *a2 = result;
  return result;
}

float protocol witness for Strideable.advanced(by:) in conformance Float@<S0>( float *a1@<X0>, float *a2@<X8>)
{
  float result = *a1 + *v2;
  *a2 = result;
  return result;
}

float *protocol witness for static Strideable._step(after:from:by:) in conformance Float( float *result, uint64_t a2, char a3, float *a4, float *a5, float *a6)
{
  float v6 = *a6;
  if ((a3 & 1) != 0)
  {
    float v8 = v6 + *a4;
    goto LABEL_5;
  }

  if (!__OFADD__(a2++, 1LL))
  {
    float v8 = *a5 + (float)((float)a2 * v6);
LABEL_5:
    *float result = v8;
    return (float *)a2;
  }

  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 <= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a2 <= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a2 < *a1;
}

void _FloatAnyHashableBox._canonicalBox.getter(uint64_t a1@<X8>, float a2@<S0>)
{
  float v3 = truncf(a2);
  if (a2 >= 0.0)
  {
    if (a2 <= -1.0 || a2 >= 1.8447e19 || v3 != a2) {
      goto LABEL_18;
    }
    uint64_t v6 = (unint64_t)a2;
    float v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
  }

  else
  {
    if (a2 <= -9.2234e18 || a2 >= 9.2234e18 || v3 != a2)
    {
LABEL_18:
      *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
      *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
      *(double *)a1 = a2;
      return;
    }

    uint64_t v6 = (uint64_t)a2;
    float v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  }

  *(void *)(a1 + 24) = __swift_instantiateConcreteTypeFromMangledName(v7);
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(void *)a1 = v6;
}

Swift::Double_optional __swiftcall Double.init(exactly:)(Swift::Float exactly)
{
  double v1 = exactly;
  result.is_nil = LOBYTE(v1);
  *(Swift::Float *)&result.unsigned int value = exactly;
  return result;
}

uint64_t _FloatAnyHashableBox._unbox<A>()@<X0>(const char *a1@<X0>, char *a2@<X8>, float a3@<S0>)
{
  *(float *)&uint64_t v7 = a3;
  int v5 = swift_dynamicCast(a2, &v7, (swift *)&type metadata for Float, a1, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a1 - 1) + 56LL))( a2,  v5 ^ 1u,  1LL,  a1);
}

uint64_t _FloatAnyHashableBox._downCastConditional<A>(into:)( char *a1, const char *a2, uint64_t a3, uint64_t a4, float a5)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, (uint64_t)a2, a3, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  float v12 = &v20[-v11];
  uint64_t v13 = *((void *)a2 - 1);
  MEMORY[0x1895F8858](v10);
  __int128 v15 = &v20[-((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  *(float *)&uint64_t v21 = a5;
  uint64_t v16 = swift_dynamicCast(v12, &v21, (swift *)&type metadata for Float, a2, 6uLL);
  float v17 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v13 + 56);
  if ((_DWORD)v16)
  {
    v17(v12, 0LL, 1LL, a2);
    unsigned __int8 v18 = *(void (**)(char *, char *, const char *))(v13 + 32);
    v18(v15, v12, a2);
    v18(a1, v15, a2);
  }

  else
  {
    v17(v12, 1LL, 1LL, a2);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  }

  return v16;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _FloatAnyHashableBox( uint64_t a1@<X8>)
{
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _FloatAnyHashableBox( uint64_t a1, const char *a2)
{
  float v4 = *v2;
  outlined init with copy of MirrorPath(a1, (uint64_t)v8);
  int v5 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  else {
    return 2LL;
  }
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _FloatAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = *v0;
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _FloatAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFF) != 0) {
    Swift::UInt32 v1 = *v0;
  }
  else {
    Swift::UInt32 v1 = 0;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

float protocol witness for _AnyHashableBox._base.getter in conformance _FloatAnyHashableBox@<S0>( uint64_t a1@<X8>)
{
  float result = *v1;
  *(void *)(a1 + 24) = &type metadata for Float;
  *(float *)a1 = result;
  return result;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _FloatAnyHashableBox@<X0>( const char *a1@<X0>, char *a2@<X8>)
{
  return _FloatAnyHashableBox._unbox<A>()(a1, a2, *v2);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _FloatAnyHashableBox( char *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return _FloatAnyHashableBox._downCastConditional<A>(into:)(a1, a2, a3, a4, *v4);
}

void Double._value.setter(double a1)
{
  *Swift::UInt32 v1 = a1;
}

uint64_t (*Double._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Double __swiftcall Double.init()()
{
  return 0.0;
}

BOOL Double.isNaN.getter(double a1)
{
  return (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && (~*(void *)&a1 & 0x7FF0000000000000LL) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Double()
{
  return Double.description.getter(*v0);
}

unint64_t Double.debugDescription.getter()
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  int64_t v0 = swift_float64ToString(&v13, 32LL, 1LL);
  __src[0] = v13;
  __src[1] = v14;
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  size_t v1 = v0;
  if (!v0) {
    return 0LL;
  }
  if ((unint64_t)v0 <= 0xF)
  {
    uint64_t v6 = v0 - 8;
    uint64_t v7 = 8LL;
    if (v0 < 8) {
      uint64_t v7 = v0;
    }
    unint64_t result = LOBYTE(__src[0]);
    if (v7 != 1)
    {
      unint64_t result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v7 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v7 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v7 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v7 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v7 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v7 != 7) {
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v8 = 0LL;
    if (v1 >= 9)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = (unsigned __int8 *)__src + 8;
      unint64_t v11 = v6 & ~(v6 >> 63);
      do
      {
        if (v11 <= v1 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        unsigned int v12 = *v10++;
        v8 |= (unint64_t)v12 << v9;
        v9 += 8LL;
        --v6;
      }

      while (v6);
    }
  }

  else
  {
    unint64_t v2 = v0 | 0xF000000000000000LL;
    int64_t v3 = _allocateStringStorage(codeUnitCapacity:)(v0);
    *(void *)(v3 + 16) = v4;
    *(void *)(v3 + 24) = v2;
    if (v4 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
      unint64_t v2 = *(void *)(v3 + 24);
    }

    *(_BYTE *)(v3 + 32 + (v2 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v1, (char *)(v3 + 32));
    return *(void *)(v3 + 24);
  }

  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Double()
{
  return Double.debugDescription.getter();
}

void specialized Double.write<A>(to:)()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  memset(v1, 0, sizeof(v1));
  uint64_t v0 = swift_float64ToString(v1, 32LL, 1LL);
  if (v0 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  _StringGuts.append(_:)(v0 | 0xD000000000000000LL, (unint64_t)&v1[0x7FFFFFFFFFFFFFELL] | 0x8000000000000000LL);
}

uint64_t Double.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  uint64_t v5 = swift_float64ToString(v7, 32LL, 1LL);
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a3 + 32))(v7, v5, a2, a3);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Double( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Double.write<A>(to:)(a1, a2, a3);
}

uint64_t static Double.exponentBitCount.getter()
{
  return 11LL;
}

uint64_t static Double.significandBitCount.getter()
{
  return 52LL;
}

uint64_t static Double._infinityExponent.getter()
{
  return 2047LL;
}

uint64_t static Double._exponentBias.getter()
{
  return 1023LL;
}

uint64_t static Double._significandMask.getter()
{
  return 0xFFFFFFFFFFFFFLL;
}

uint64_t static Double._quietNaNMask.getter()
{
  return 0x8000000000000LL;
}

  ;
}

Swift::Double __swiftcall Double.init(bitPattern:)(Swift::UInt64 bitPattern)
{
  return *(double *)&bitPattern;
}

uint64_t Double.sign.getter(double a1)
{
  return *(void *)&a1 >> 63;
}

uint64_t Double.exponentBitPattern.getter(double a1)
{
  return (*(void *)&a1 >> 52) & 0x7FFLL;
}

uint64_t Double.significandBitPattern.getter(double a1)
{
  return *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
}

uint64_t Double.isCanonical.getter()
{
  return 1LL;
}

double static Double.leastNonzeroMagnitude.getter()
{
  *(void *)&double result = 1LL;
  return result;
}

double static Double.leastNormalMagnitude.getter()
{
  return 2.22507386e-308;
}

double static Double.infinity.getter()
{
  return INFINITY;
}

double static Double.nan.getter()
{
  return NAN;
}

double static Double.signalingNaN.getter()
{
  return NAN;
}

Swift::Double __swiftcall Double.init(nan:signaling:)(Swift::UInt64 nan, Swift::Bool signaling)
{
  if (nan >> 50) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "NaN payload is not encodable.",  29LL,  2,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0xAC2uLL,  0);
  }
  *(void *)&Swift::Double result = (0x8000000000000uLL >> signaling) | nan | 0x7FF0000000000000LL;
  return result;
}

double static Double.greatestFiniteMagnitude.getter()
{
  return 1.79769313e308;
}

double static Double.pi.getter()
{
  return 3.14159265;
}

double Double.ulp.getter(double a1)
{
  uint64_t v2 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v2)
  {
    double result = NAN;
    if (v2 != 2047) {
      return COERCE_DOUBLE(*(void *)&a1 & 0x7FF0000000000000LL) * 2.22044605e-16;
    }
  }

  else
  {
    *(void *)&double result = 1LL;
  }

  return result;
}

BOOL Double.isFinite.getter(double a1)
{
  return (~*(void *)&a1 & 0x7FF0000000000000LL) != 0;
}

BOOL Double.isNormal.getter(double a1)
{
  return ((*(void *)&a1 >> 52) & 0x7FFLL) != 0x7FF && ((*(void *)&a1 >> 52) & 0x7FFLL) != 0;
}

double static Double.ulpOfOne.getter()
{
  return 2.22044605e-16;
}

unint64_t Double.exponent.getter(double a1)
{
  uint64_t v1 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v3 = *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
  if (!(v1 | *(void *)&a1 & 0xFFFFFFFFFFFFFLL)) {
    return 0x8000000000000000LL;
  }
  if (v1) {
    return v1 - 1023;
  }
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return -1011LL - __clz(v3);
}

BOOL Double.isZero.getter(double a1)
{
  return (*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0;
}

double Double.significand.getter(double result)
{
  uint64_t v1 = (*(void *)&result >> 52) & 0x7FFLL;
  unint64_t v2 = *(void *)&result & 0xFFFFFFFFFFFFFLL;
  if ((*(void *)&result & 0xFFFFFFFFFFFFFLL) == 0 || v1 != 2047)
  {
    if (v1)
    {
      if (v1 != 2047)
      {
        *(void *)&double result = v2 | 0x3FF0000000000000LL;
        return result;
      }
    }

    else if (v2)
    {
      *(void *)&double result = (*(void *)&result << (__clz(v2) + 53)) & 0xFFFFFFFFFFFFFLL | 0x3FF0000000000000LL;
      return result;
    }

    *(void *)&double result = v1 << 52;
  }

  return result;
}

BOOL Double.isSubnormal.getter(double a1)
{
  return (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && (*(void *)&a1 & 0x7FF0000000000000LL) == 0;
}

Swift::Double __swiftcall Double.init(sign:exponent:significand:)( Swift::FloatingPointSign sign, Swift::Int exponent, Swift::Double significand)
{
  return specialized Double.init(sign:exponent:significand:)(sign & 1, exponent, significand);
}

double static Double.- prefix(_:)(double a1)
{
  return -a1;
}

double static Double.*= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 * a2;
  *a1 = result;
  return result;
}

double Double.nextUp.getter(double a1)
{
  double result = a1 + 0.0;
  if (result < INFINITY) {
    *(void *)&result += (*(uint64_t *)&result >> 63) | 1;
  }
  return result;
}

double static Double.+ infix(_:_:)(double a1, double a2)
{
  return a1 + a2;
}

uint64_t static Int64.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

Swift::Double __swiftcall Double.init(signOf:magnitudeOf:)(Swift::Double signOf, Swift::Double magnitudeOf)
{
  v2.f64[0] = NAN;
  v2.f64[1] = NAN;
  *(void *)&Swift::Double result = vbslq_s8((int8x16_t)vnegq_f64(v2), *(int8x16_t *)&magnitudeOf, *(int8x16_t *)&signOf).u64[0];
  return result;
}

Swift::Void __swiftcall Double.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  switch(*(_BYTE *)a1)
  {
    case 0:
      *uint64_t v1 = round(*v1);
      return;
    case 1:
      *uint64_t v1 = rint(*v1);
      return;
    case 2:
      double v2 = *v1;
      goto LABEL_9;
    case 3:
      double v2 = *v1;
      goto LABEL_10;
    case 4:
      *uint64_t v1 = trunc(*v1);
      return;
    case 5:
      double v2 = *v1;
      if ((*(void *)v1 & 0x8000000000000000LL) != 0) {
LABEL_10:
      }
        *uint64_t v1 = floor(v2);
      else {
LABEL_9:
      }
        *uint64_t v1 = ceil(v2);
      break;
    default:
      Double._roundSlowPath(_:)(a1);
      break;
  }

Swift::Void __swiftcall Double._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  char v4 = *(_BYTE *)a1;
  switch(v4)
  {
    case 0:
      double v2 = round(*v1);
      goto LABEL_11;
    case 1:
      double v2 = rint(*v1);
      goto LABEL_11;
    case 2:
      double v3 = *v1;
      goto LABEL_9;
    case 3:
      double v3 = *v1;
      goto LABEL_10;
    case 4:
      double v2 = trunc(*v1);
      goto LABEL_11;
    case 5:
      double v3 = *v1;
      if ((*(void *)v1 & 0x8000000000000000LL) != 0) {
LABEL_10:
      }
        double v2 = floor(v3);
      else {
LABEL_9:
      }
        double v2 = ceil(v3);
LABEL_11:
      *uint64_t v1 = v2;
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v4);
      break;
  }

Swift::Void __swiftcall Double.negate()()
{
  double *v0 = -*v0;
}

double static Double.+= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 + a2;
  *a1 = result;
  return result;
}

double static Double.-= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 - a2;
  *a1 = result;
  return result;
}

double static Double./= infix(_:_:)(double *a1, double a2)
{
  double result = *a1 / a2;
  *a1 = result;
  return result;
}

Swift::Void __swiftcall Double.formRemainder(dividingBy:)(Swift::Double dividingBy)
{
  *uint64_t v1 = remainder(*v1, dividingBy);
}

Swift::Void __swiftcall Double.formTruncatingRemainder(dividingBy:)(Swift::Double dividingBy)
{
  *uint64_t v1 = fmod(*v1, dividingBy);
}

Swift::Void __swiftcall Double.formSquareRoot()()
{
  double *v0 = sqrt(*v0);
}

Swift::Void __swiftcall Double.addProduct(_:_:)(Swift::Double a1, Swift::Double a2)
{
  double *v2 = *v2 + a1 * a2;
}

Swift::Bool __swiftcall Double.isEqual(to:)(Swift::Double to)
{
  return v1 == to;
}

Swift::Bool __swiftcall Double.isLess(than:)(Swift::Double than)
{
  return v1 < than;
}

Swift::Bool __swiftcall Double.isLessThanOrEqualTo(_:)(Swift::Double a1)
{
  return v1 <= a1;
}

BOOL Double.isInfinite.getter(double a1)
{
  return (*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FF0000000000000LL;
}

BOOL Double.isSignalingNaN.getter(double a1)
{
  return (~*(void *)&a1 & 0x7FF0000000000000LL) == 0
      && (*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0
      && (*(void *)&a1 & 0x8000000000000LL) == 0;
}

double Double.binade.getter(double a1)
{
  uint64_t v1 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047) {
    return NAN;
  }
  if ((*(void *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && !v1) {
    return COERCE_DOUBLE(COERCE_UNSIGNED_INT64(a1 * 4.50359963e15) & 0xFFF0000000000000LL) * 2.22044605e-16;
  }
  *(void *)&double result = *(void *)&a1 & 0xFFF0000000000000LL;
  return result;
}

uint64_t Double.significandWidth.getter(double a1)
{
  unint64_t v1 = *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
  unint64_t v2 = __clz(__rbit64(*(void *)&a1 & 0xFFFFFFFFFFFFFLL));
  uint64_t v3 = (*(void *)&a1 >> 52) & 0x7FFLL;
  if (v3 && v3 != 2047)
  {
    unint64_t v6 = 52 - v2;
    if (v1) {
      return v6;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    unint64_t v4 = 63 - (__clz(v1) + v2);
    if (v3) {
      unint64_t v4 = -1LL;
    }
    if (v1) {
      return v4;
    }
    else {
      return -1LL;
    }
  }

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Double( char a1@<W0>, void *a2@<X1>, uint64_t *a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized Double.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
}

double protocol witness for BinaryFloatingPoint.init(_:) in conformance Double@<D0>( double *a1@<X8>, float a2@<S0>)
{
  double result = a2;
  *a1 = result;
  return result;
}

void protocol witness for BinaryFloatingPoint.init(_:) in conformance Double( double *a1@<X8>, double a2@<D0>)
{
  *a1 = a2;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Double( uint64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
}

unint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Double@<X0>( uint64_t a1@<X0>, swift *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.exponentBitCount.getter in conformance Double()
{
  return 11LL;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Double()
{
  return 52LL;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Double( uint64_t *a1@<X8>)
{
  *a1 = (*v1 >> 52) & 0x7FFLL;
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Double( uint64_t *a1@<X8>)
{
  *a1 = *v1 & 0xFFFFFFFFFFFFFLL;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Double(double *a1@<X8>)
{
  *a1 = Double.binade.getter(*v1);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Double()
{
  return Double.significandWidth.getter(*v0);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Double( char a1@<W0>, uint64_t *a2@<X1>, double *a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized Double.init(sign:exponent:significand:)(a1 & 1, *a2, *a3);
}

double protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Double@<D0>( unint64_t *a1@<X0>, unint64_t *a2@<X1>, void *a3@<X8>, int8x16_t a4@<Q0>, int8x16_t a5@<Q1>)
{
  a4.i64[0] = *a1;
  a5.i64[0] = *a2;
  v5.f64[0] = NAN;
  v5.f64[1] = NAN;
  a4.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v5), a5, a4).u64[0];
  *a3 = a4.i64[0];
  return *(double *)a4.i64;
}

double protocol witness for FloatingPoint.init(_:) in conformance Double@<D0>( uint64_t a1@<X0>, double *a2@<X8>)
{
  double result = (double)a1;
  *a2 = (double)a1;
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Double@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(void, void)@<X2>, double *a4@<X8>)
{
  if (a3[16](a2, a3) < 65)
  {
    char v10 = a3[8](a2, a3);
    uint64_t v11 = a3[15](a2, a3);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    if ((v10 & 1) != 0) {
      double v9 = (double)v11;
    }
    else {
      double v9 = (double)(unint64_t)v11;
    }
  }

  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v12, a1, a2, (uint64_t)a3);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
    double v9 = v12;
  }

  *a4 = v9;
  return result;
}

unint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Double@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = Double.init<A>(exactly:)(a1, a2, a3);
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

unint64_t Double.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) > 64)
  {
    char v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v20, a1, a2, a3);
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
    if ((v11 & 1) != 0)
    {
      double v12 = v20;
      return *(void *)&v12;
    }

void protocol witness for static FloatingPoint.nan.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x7FF8000000000000LL;
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x7FF4000000000000LL;
}

void protocol witness for static FloatingPoint.infinity.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x7FF0000000000000LL;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Double( void *a1@<X8>)
{
  *a1 = 0x7FEFFFFFFFFFFFFFLL;
}

void protocol witness for static FloatingPoint.pi.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x400921FB54442D18LL;
}

double protocol witness for FloatingPoint.ulp.getter in conformance Double@<D0>(double *a1@<X8>)
{
  uint64_t v2 = (*v1 >> 52) & 0x7FFLL;
  if (v2)
  {
    if (v2 != 2047)
    {
      double result = COERCE_DOUBLE(*v1 & 0x7FF0000000000000LL) * 2.22044605e-16;
      *a1 = result;
      return result;
    }

    double v4 = NAN;
  }

  else
  {
    *(void *)&double v4 = 1LL;
  }

  double result = v4;
  *a1 = v4;
  return result;
}

void protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Double(void *a1@<X8>)
{
  *a1 = 0x3CB0000000000000LL;
}

void protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Double( void *a1@<X8>)
{
  *a1 = 0x10000000000000LL;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Double()
{
  return Double.sign.getter(*v0);
}

unint64_t protocol witness for FloatingPoint.exponent.getter in conformance Double@<X0>( unint64_t *a1@<X8>)
{
  unint64_t result = Double.exponent.getter(*v1);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Double(double *a1@<X8>)
{
  *a1 = Double.significand.getter(*v1);
}

double protocol witness for static FloatingPoint./ infix(_:_:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 / *a2;
  *a3 = result;
  return result;
}

double protocol witness for static FloatingPoint./= infix(_:_:) in conformance Double( double *a1, double *a2)
{
  double result = *a1 / *a2;
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Double( double *a1@<X0>, double *a2@<X8>)
{
  *a2 = _stdlib_remainder(*v2, *a1);
}

void protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Double(double *a1)
{
  *unint64_t v1 = _stdlib_remainder(*v1, *a1);
}

void protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Double( double *a1@<X0>, double *a2@<X8>)
{
  *a2 = fmod(*v2, *a1);
}

void protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Double( double *a1)
{
  *unint64_t v1 = fmod(*v1, *a1);
}

void protocol witness for FloatingPoint.squareRoot() in conformance Double(double *a1@<X8>)
{
  *a1 = _stdlib_squareRoot(*v1);
}

void protocol witness for FloatingPoint.formSquareRoot() in conformance Double()
{
  double *v0 = _stdlib_squareRoot(*v0);
}

double protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *v3 + *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for FloatingPoint.addProduct(_:_:) in conformance Double(double *a1, double *a2)
{
  double result = *v2 + *a1 * *a2;
  double *v2 = result;
  return result;
}

double *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Double@<X0>( double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (*result > *a2)
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000LL) != 0) {
      double v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Double@<X0>( double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (*a2 >= *result)
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000LL) != 0) {
      double v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Double@<X0>( double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (fabs(*result) > fabs(*a2))
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000LL) != 0) {
      double v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Double@<X0>( double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = *result;
  double v4 = *a2;
  if (fabs(*a2) >= fabs(*result))
  {
    if ((*(void *)&v4 & 0xFFFFFFFFFFFFFLL) == 0) {
      double v3 = *a2;
    }
    if ((~*(void *)&v4 & 0x7FF0000000000000LL) != 0) {
      double v3 = *a2;
    }
  }

  *a3 = v3;
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Double(_BYTE *a1@<X0>, double *a2@<X8>)
{
  double v4 = *v2;
  double v8 = *v2;
  switch(*a1)
  {
    case 0:
      double v5 = round(v4);
      break;
    case 1:
      double v5 = rint(v4);
      break;
    case 2:
      double v5 = ceil(v4);
      break;
    case 3:
      double v5 = floor(v4);
      break;
    case 4:
      double v5 = trunc(v4);
      break;
    case 5:
      char v6 = Double.sign.getter(v4);
      double v5 = ceil(v4);
      double v7 = floor(v4);
      if (v6) {
        double v5 = v7;
      }
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      double v5 = v8;
      break;
  }

  *a2 = v5;
}

void protocol witness for FloatingPoint.round(_:) in conformance Double(_BYTE *a1)
{
  switch(*a1)
  {
    case 0:
      double v2 = round(*v1);
      goto LABEL_11;
    case 1:
      double v2 = rint(*v1);
      goto LABEL_11;
    case 2:
      double v2 = ceil(*v1);
      goto LABEL_11;
    case 3:
      double v2 = floor(*v1);
      goto LABEL_11;
    case 4:
      double v2 = trunc(*v1);
      goto LABEL_11;
    case 5:
      double v3 = *v1;
      else {
        double v2 = ceil(v3);
      }
LABEL_11:
      *unint64_t v1 = v2;
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }

void protocol witness for FloatingPoint.nextUp.getter in conformance Double(double *a1@<X8>)
{
  double v2 = *v1 + 0.0;
  if (v2 < INFINITY) {
    *(void *)&v2 += (*(uint64_t *)&v2 >> 63) | 1;
  }
  *a1 = v2;
}

double protocol witness for FloatingPoint.nextDown.getter in conformance Double@<D0>(double *a1@<X8>)
{
  double v2 = 0.0 - *v1;
  if (v2 < INFINITY) {
    *(void *)&v2 += (*(uint64_t *)&v2 >> 63) | 1;
  }
  double result = -v2;
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Double(double *a1)
{
  return *v1 == *a1;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Double(double *a1)
{
  return *v1 < *a1;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Double(double *a1)
{
  return *v1 <= *a1;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Double( double *a1)
{
  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(*a1, *v1);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Double()
{
  return ((*v0 >> 52) & 0x7FFLL) != 0x7FF && ((*v0 >> 52) & 0x7FFLL) != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Double()
{
  return (~*v0 & 0x7FF0000000000000LL) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Double()
{
  return (*v0 & 0x7FFFFFFFFFFFFFFFLL) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Double()
{
  return (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (*v0 & 0x7FF0000000000000LL) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Double()
{
  return (*v0 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FF0000000000000LL;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Double()
{
  return (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (~*v0 & 0x7FF0000000000000LL) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Double()
{
  return (~*v0 & 0x7FF0000000000000LL) == 0 && (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (*v0 & 0x8000000000000LL) == 0;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Double()
{
  return specialized FloatingPoint.floatingPointClass.getter(*v0);
}

double protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Double@<D0>( double *a1@<X0>, void *a2@<X8>)
{
  double result = *a1;
  *a2 = *(void *)a1;
  return result;
}

double protocol witness for static SignedNumeric.- prefix(_:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X8>)
{
  double result = -*a1;
  *a2 = result;
  return result;
}

double protocol witness for SignedNumeric.negate() in conformance Double()
{
  double result = -*v0;
  double *v0 = result;
  return result;
}

double protocol witness for Numeric.magnitude.getter in conformance Double@<D0>(double *a1@<X8>)
{
  double result = fabs(*v1);
  *a1 = result;
  return result;
}

double Double.magnitude.getter(double a1)
{
  return fabs(a1);
}

double protocol witness for static Numeric.* infix(_:_:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for static Numeric.*= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result = *a2 * *a1;
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 + *a2;
  *a3 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Double( double *a1, double *a2)
{
  double result = *a2 + *a1;
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result = *a1 - *a2;
  *a3 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Double( double *a1, double *a2)
{
  double result = *a1 - *a2;
  *a1 = result;
  return result;
}

Swift::Double __swiftcall Double.init(integerLiteral:)(Swift::Int64 integerLiteral)
{
  return (double)integerLiteral;
}

void protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Double( uint64_t *a1@<X0>, unint64_t a2@<X1>, double *a3@<X8>)
{
  *a3 = swift_intToFloat64(a1, a2);
}

double protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Double@<D0>( uint64_t *a1@<X0>, double *a2@<X8>)
{
  double result = (double)*a1;
  *a2 = result;
  return result;
}

void Double.hash(into:)(double a1)
{
  if ((*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *(void *)&a1;
  }
  else {
    Swift::UInt64 v1 = 0LL;
  }
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Double._rawHashValue(seed:)(Swift::Int seed)
{
  if ((v1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0LL;
  }
  return specialized static Hasher._hash(seed:_:)(seed, v2);
}

uint64_t Double.hashValue.getter(double a1)
{
  if ((*(void *)&a1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v1 = *(void *)&a1;
  }
  else {
    uint64_t v1 = 0LL;
  }
  return specialized static Hasher._hash(seed:_:)(0LL, v1);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Double()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v1 = *v0;
  }
  else {
    uint64_t v1 = 0LL;
  }
  return specialized static Hasher._hash(seed:_:)(0LL, v1);
}

void protocol witness for Hashable.hash(into:) in conformance Double()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *v0;
  }
  else {
    Swift::UInt64 v1 = 0LL;
  }
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Double(uint64_t a1)
{
  if ((*v1 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v2 = *v1;
  }
  else {
    uint64_t v2 = 0LL;
  }
  return specialized static Hasher._hash(seed:_:)(a1, v2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 == *a2;
}

void Double._toCustomAnyHashable()(uint64_t a1@<X8>, double a2@<D0>)
{
  *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
  *(double *)a1 = a2;
}

double protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Double@<D0>( uint64_t a1@<X8>)
{
  double result = *v1;
  *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
  *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
  *(double *)a1 = result;
  return result;
}

Swift::UInt __swiftcall UInt.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt because it is either infinite or NaN",  77LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3129uLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt because the result would be less than UInt.min",  87LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x312CuLL,  0);
  }
  if (a1 >= 1.84467441e19) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt because the result would be greater than UInt.max",  90LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x312FuLL,  0);
  }
  return (unint64_t)a1;
}

uint64_t Double.init(exactly:)(__n128 _Q0)
{
  __asm
  {
    FCVT            D1, H0
    FCVT            S0, H0
  }

  return _D1;
}

Swift::Double_optional __swiftcall Double.init(exactly:)(Swift::Double exactly)
{
  char v1 = LOBYTE(exactly);
  result.unsigned int value = exactly;
  result.is_nil = v1;
  return result;
}

Swift::Double __swiftcall Double.distance(to:)(Swift::Double to)
{
  return to - v1;
}

Swift::Double __swiftcall Double.advanced(by:)(Swift::Double by)
{
  return by + v1;
}

double protocol witness for Strideable.distance(to:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X8>)
{
  double result = *a1 - *v2;
  *a2 = result;
  return result;
}

double protocol witness for Strideable.advanced(by:) in conformance Double@<D0>( double *a1@<X0>, double *a2@<X8>)
{
  double result = *a1 + *v2;
  *a2 = result;
  return result;
}

double *protocol witness for static Strideable._step(after:from:by:) in conformance Double( double *result, uint64_t a2, char a3, double *a4, double *a5, double *a6)
{
  double v6 = *a6;
  if ((a3 & 1) != 0)
  {
    double v8 = v6 + *a4;
    goto LABEL_5;
  }

  if (!__OFADD__(a2++, 1LL))
  {
    double v8 = *a5 + (double)a2 * v6;
LABEL_5:
    *double result = v8;
    return (double *)a2;
  }

  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 <= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a2 <= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a2 < *a1;
}

void _DoubleAnyHashableBox._canonicalBox.getter(uint64_t a1@<X8>, double a2@<D0>)
{
  double v3 = trunc(a2);
  if (a2 >= 0.0)
  {
    if (a2 <= -1.0 || a2 >= 1.84467441e19 || v3 != a2) {
      goto LABEL_18;
    }
    uint64_t v6 = (unint64_t)a2;
    double v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
  }

  else
  {
    if (a2 <= -9.22337204e18 || a2 >= 9.22337204e18 || v3 != a2)
    {
LABEL_18:
      *(void *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
      *(void *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
      *(double *)a1 = a2;
      return;
    }

    uint64_t v6 = (uint64_t)a2;
    double v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  }

  *(void *)(a1 + 24) = __swift_instantiateConcreteTypeFromMangledName(v7);
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(void *)a1 = v6;
}

uint64_t _DoubleAnyHashableBox._unbox<A>()@<X0>(const char *a1@<X0>, char *a2@<X8>, double a3@<D0>)
{
  double v7 = a3;
  int v5 = swift_dynamicCast(a2, (uint64_t *)&v7, (swift *)&type metadata for Double, a1, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a1 - 1) + 56LL))( a2,  v5 ^ 1u,  1LL,  a1);
}

uint64_t _DoubleAnyHashableBox._downCastConditional<A>(into:)( char *a1, const char *a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, (uint64_t)a2, a3, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  double v12 = (char *)&v20 - v11;
  uint64_t v13 = *((void *)a2 - 1);
  MEMORY[0x1895F8858](v10);
  __int128 v15 = (char *)&v20 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  double v21 = a5;
  uint64_t v16 = swift_dynamicCast(v12, (uint64_t *)&v21, (swift *)&type metadata for Double, a2, 6uLL);
  double v17 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v13 + 56);
  if ((_DWORD)v16)
  {
    v17(v12, 0LL, 1LL, a2);
    unsigned __int8 v18 = *(void (**)(char *, char *, const char *))(v13 + 32);
    v18(v15, v12, a2);
    v18(a1, v15, a2);
  }

  else
  {
    v17(v12, 1LL, 1LL, a2);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  }

  return v16;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _DoubleAnyHashableBox( uint64_t a1@<X8>)
{
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _DoubleAnyHashableBox( uint64_t a1, const char *a2)
{
  double v4 = *v2;
  outlined init with copy of MirrorPath(a1, (uint64_t)v8);
  int v5 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  else {
    return 2LL;
  }
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _DoubleAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *v0;
  }
  else {
    Swift::UInt64 v1 = 0LL;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _DoubleAnyHashableBox()
{
  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0) {
    Swift::UInt64 v1 = *v0;
  }
  else {
    Swift::UInt64 v1 = 0LL;
  }
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

double protocol witness for _AnyHashableBox._base.getter in conformance _DoubleAnyHashableBox@<D0>( uint64_t a1@<X8>)
{
  double result = *v1;
  *(void *)(a1 + 24) = &type metadata for Double;
  *(double *)a1 = result;
  return result;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _DoubleAnyHashableBox@<X0>( const char *a1@<X0>, char *a2@<X8>)
{
  return _DoubleAnyHashableBox._unbox<A>()(a1, a2, *v2);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _DoubleAnyHashableBox( char *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return _DoubleAnyHashableBox._downCastConditional<A>(into:)(a1, a2, a3, a4, *v4);
}

void __swiftcall Float80.init()()
{
}

void % infix<A>(_:_:)()
{
}

void %= infix<A>(_:_:)()
{
}

uint64_t UInt8._value.setter(uint64_t result)
{
  *Swift::UInt64 v1 = result;
  return result;
}

uint64_t (*UInt8._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt8 because it is either infinite or NaN",  79LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x58uLL,  0);
  }
  __asm { FCVT            S0, H0 }

  if (_S0 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt8 because the result would be less than UInt8.min",  90LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x5BuLL,  0);
  }
  if (_S0 >= 256.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt8 because the result would be greater than UInt8.max",  93LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x5EuLL,  0);
  }
  return (int)_S0;
}

uint64_t UInt8.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S0, H0 }

  BOOL v6 = _S0 > -1.0;
  if (_S0 >= 256.0) {
    BOOL v6 = 0;
  }
  _S1 = truncf(_S0);
  __asm
  {
    FCVT            H1, S1
    FCVT            S1, H1
  }

  int v9 = v6 && _S1 == _S0;
  _ZF = v9 == 0;
  char v10 = ~(_BYTE)v9;
  if (_ZF) {
    int v11 = 0;
  }
  else {
    int v11 = (int)_S0;
  }
  return v11 & 0xFFFFFEFF | ((v10 & 1) << 8);
}

Swift::UInt8 __swiftcall UInt8.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt8 because it is either infinite or NaN",  77LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xA4uLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt8 because the result would be less than UInt8.min",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xA7uLL,  0);
  }
  if (a1 >= 256.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt8 because the result would be greater than UInt8.max",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xAAuLL,  0);
  }
  return (int)a1;
}

Swift::UInt8_optional __swiftcall UInt8.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 256.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    LOWORD(v5) = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

Swift::UInt8 __swiftcall UInt8.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt8 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xECuLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt8 because the result would be less than UInt8.min",  89LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xEFuLL,  0);
  }
  if (a1 >= 256.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt8 because the result would be greater than UInt8.max",  92LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xF2uLL,  0);
  }
  return (int)a1;
}

Swift::UInt8_optional __swiftcall UInt8.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 256.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    LOWORD(v5) = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

_BYTE *static UInt8.+= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  unsigned int v2 = *result + a2;
  if (((v2 >> 8) & 1) != 0) {
    __break(1u);
  }
  else {
    *double result = v2;
  }
  return result;
}

_BYTE *static UInt8.-= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  int v2 = *result - a2;
  if ((v2 & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *double result = v2;
  }
  return result;
}

_BYTE *static UInt8.*= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  else {
    *result *= a2;
  }
  return result;
}

_BYTE *static UInt8./= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.addingReportingOverflow(_:)(Swift::UInt8 a1)
{
  Swift::UInt8 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.subtractingReportingOverflow(_:)(Swift::UInt8 a1)
{
  Swift::UInt8 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.multipliedReportingOverflow(by:)(Swift::UInt8 by)
{
  Swift::UInt8 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.dividedReportingOverflow(by:)(Swift::UInt8 by)
{
  if (by) {
    v1 /= by;
  }
  Swift::UInt8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.remainderReportingOverflow(dividingBy:)( Swift::UInt8 dividingBy)
{
  if (dividingBy) {
    v1 %= dividingBy;
  }
  Swift::UInt8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

_BYTE *static UInt8.%= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2B4uLL,  0);
  }
  *result %= a2;
  return result;
}

_BYTE *static UInt8.&>>= infix(_:_:)(_BYTE *result, char a2)
{
  *Swift::tuple_partialValue_UInt8_overflow_Bool result = *result >> (a2 & 7);
  return result;
}

uint64_t UInt8._lowWord.getter(uint64_t result)
{
  return result;
}

uint64_t UInt8.Words._value.setter(uint64_t result)
{
  *unsigned __int8 v1 = result;
  return result;
}

uint64_t (*UInt8.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.Words.count.getter()
{
  return 1LL;
}

uint64_t UInt8.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t UInt8.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t UInt8.Words.indices.getter()
{
  return 0LL;
}

uint64_t UInt8.Words.subscript.getter(uint64_t a1, unsigned __int8 a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3B1uLL,  0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3B2uLL,  0);
  }
  return a2;
}

unint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt8.Words@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3);
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt8.Words( uint64_t *a1, uint64_t *a2))()
{
  *a1 = UInt8.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

double protocol witness for Collection.indices.getter in conformance UInt8.Words@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = xmmword_1817FFC90;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt8.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt8.Words( uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt8_low_UInt8 __swiftcall UInt8.multipliedFullWidth(by:)(Swift::UInt8 by)
{
  Swift::UInt8 v2 = __rev16(v1 * by);
  result.Swift::UInt64 low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt8_remainder_UInt8 __swiftcall UInt8.dividingFullWidth(_:)( Swift::tuple_high_UInt8_low_UInt8 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x417uLL,  0);
  }
  if (a1.high >= v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x419uLL,  0);
  }
  unsigned __int16 v3 = a1.low | (unsigned __int16)(__PAIR16__(v2, a1.high) << 8);
  unsigned int v4 = (v3 / v1) | ((v3 % v1) << 8);
  result.quotient = v4;
  result.remainder = v3;
  return result;
}

Swift::UInt8 __swiftcall UInt8.signum()()
{
  return v0 != 0;
}

uint64_t static UInt8.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt8(_BYTE *a1@<X8>)
{
  *a1 = -1;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt8( _BYTE *a1, _BYTE *a2)
{
  uint64_t v3 = (*v2 + *a2) >> 8;
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt8( _BYTE *a1, unsigned __int8 *a2)
{
  int v3 = *v2 - *a2;
  *a1 = v3;
  return (v3 & 0xFFFFFF00) != 0;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt8( _BYTE *a1, unsigned __int8 *a2)
{
  __int16 v3 = *v2 * *a2;
  *a1 = v3;
  return (v3 & 0xFF00) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt8( _BYTE *a1, _BYTE *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt8( _BYTE *a1, _BYTE *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

_BYTE *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt8( _BYTE *result, _BYTE *a2, unsigned __int8 *a3)
{
  __int16 v4 = *v3 * *a3;
  *Swift::tuple_quotient_UInt8_remainder_UInt8 result = HIBYTE(v4);
  *a2 = v4;
  return result;
}

Swift::UInt8 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt8( Swift::UInt8 *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  Swift::UInt8 result = UInt8.dividingFullWidth(_:)((Swift::tuple_high_UInt8_low_UInt8)__PAIR16__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

unsigned __int8 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt8@<X0>( unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result >> (*a2 & 7);
  return result;
}

_BYTE *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt8( _BYTE *result, _BYTE *a2)
{
  *Swift::UInt8 result = *result >> (*a2 & 7);
  return result;
}

char *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt8@<X0>( char *result@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v3 = 0;
  if (a2 <= 0x9FF && (a2 & 1) == 0) {
    char v3 = *result;
  }
  *a3 = v3;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt8@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8 and conformance UInt8,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _BYTE *a6@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v49 = a6;
  uint64_t v9 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v48 = (char *)&v44 - v12;
  uint64_t v52 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v51 = (char *)&v44 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v44 - v18;
  MEMORY[0x1895F8858](v17);
  double v21 = (char *)&v44 - v20;
  float v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v23 = v22(a2, a3);
  uint64_t v50 = a1;
  if ((v23 & 1) != 0)
  {
    uint64_t v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    int v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    char v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 32LL))( v21,  v19,  a2);
    uint64_t v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    v28(v21, a2);
    a1 = v50;
  }

  __int16 v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v30 = a1;
  if (v29(a2, a3) >= 8)
  {
    uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    unsigned __int8 v53 = -1;
    char v31 = v22(a2, a3);
    uint64_t v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 9)
      {
        unint64_t v33 = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        uint64_t v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 40LL))( v51,  v19,  a2);
        uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        unsigned int v37 = v53;
        uint64_t v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        uint64_t v30 = v50;
        if ((v34 & 1) != 0)
        {
          unsigned __int8 v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39) {
            goto LABEL_14;
          }
        }

        else
        {
          v36(v38, a2);
        }

        goto LABEL_16;
      }
    }

    else if (v32 <= 8)
    {
      uint64_t v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      unsigned __int8 v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      uint64_t v30 = v50;
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }

    (*(void (**)(unsigned __int8 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    uint64_t v35 = v51;
    char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v19,  v51,  a2);
    uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    uint64_t v30 = v50;
    if ((v40 & 1) != 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_16;
  }

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt8@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt8 and conformance UInt8((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt8()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt8()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_BYTE *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
  }
  *a3 = *result / *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt8( _BYTE *result, _BYTE *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
  }
  *result /= *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2B4uLL,  0);
  }
  *a3 = *result % *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt8( _BYTE *result, _BYTE *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2B4uLL,  0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt8.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt8@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64x2_t v126 = a5;
  int64x2_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v114 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint8x8_t v123 = (char *)&v114 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v117 = (char *)&v114 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int v26 = (char *)&v114 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint16x8_t v124 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v114 - v29;
  unsigned int v122 = *a1;
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  int8x16_t v121 = v19;
  unint64_t v127 = v31;
  if ((v32 & 1) != 0)
  {
    unint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      int64_t v129 = -8LL;
      uint64_t v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -8) {
        goto LABEL_24;
      }
    }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt8( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -8LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if (v37 < -8) {
        goto LABEL_24;
      }
    }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt8@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v118 = a5;
  int64x2_t v113 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v113,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v111 = (char *)&v109 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v109 = (char *)&v109 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v109 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64x2_t v115 = (char *)&v109 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  int64_t v110 = (char *)&v109 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v109 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  char v117 = (char *)&v109 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v109 - v28;
  unsigned int v114 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v119 = v30;
  if ((v31 & 1) != 0)
  {
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v122 = -8LL;
      uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v44(&v122, &type metadata for Int, v45, a3, a4);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v36 < -8) {
        goto LABEL_29;
      }
    }
  }

  else
  {
    char v38 = v30(a3, a4);
    uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v120(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 <= 64)
      {
        unint64_t v47 = AssociatedTypeWitness;
        char v48 = v113;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v113,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v50 = v111;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v47,  AssociatedConformanceWitness);
        (*((void (**)(char *, uint64_t, const char *))v48 + 3))(v50, a3, v48);
        LOBYTE(v47) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        unint64_t v51 = *(void (**)(char *, uint64_t))(v11 + 8);
        v51(v29, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
        if ((v47 & 1) != 0)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
          goto LABEL_29;
        }

        uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
        char v30 = v119;
        char v32 = v120;
        if (v52 < -8) {
          goto LABEL_29;
        }
      }

      else
      {
        int64_t v122 = -8LL;
        uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v122, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        char v30 = v119;
        char v32 = v120;
      }
    }

    else if (v39 <= 64)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      char v30 = v119;
      char v32 = v120;
      if (v46 < -8) {
        goto LABEL_29;
      }
    }

    else
    {
      char v30 = v119;
      char v32 = v120;
    }
  }

  uint64_t v120 = v32;
  char v53 = v30(a3, a4);
  uint64_t v54 = v32(a3, a4);
  if ((v53 & 1) != 0)
  {
    if (v54 > 64) {
      goto LABEL_20;
    }
  }

  else if (v54 > 63)
  {
LABEL_20:
    int64_t v122 = 8LL;
    uint64_t v57 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v58 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v57(&v122, &type metadata for Int, v58, a3, a4);
    LOBYTE(v57) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    char v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v59(v29, a3);
    goto LABEL_29;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v59(v29, a3);
  if (v72 <= 8)
  {
LABEL_21:
    uint64_t v60 = *(void (**)(void))(v11 + 16);
    unsigned int v61 = v117;
    v60();
    char v62 = v119(a3, a4);
    ((void (*)(char *, char *, uint64_t))v60)(v25, v61, a3);
    if ((v62 & 1) == 0)
    {
      uint64_t v71 = v25;
      uint64_t v64 = v116;
      goto LABEL_31;
    }

    uint64_t v63 = v120(a3, a4);
    v59(v25, a3);
    uint64_t v64 = v116;
    if (v63 < 65) {
      goto LABEL_32;
    }
    uint64_t v65 = v110;
    ((void (*)(char *, char *, uint64_t))v60)(v110, v61, a3);
    int64_t v122 = 0x8000000000000000LL;
    uint64_t v66 = v119;
    if ((v119(a3, a4) & 1) != 0)
    {
      uint64_t v67 = v120(a3, a4);
      if (v67 < 64)
      {
        ((void (*)(char *, char *, uint64_t))v60)(v29, v65, a3);
        uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v59(v29, a3);
        uint64_t v71 = v65;
        if (v70 < v122) {
          goto LABEL_68;
        }
        goto LABEL_31;
      }

      unint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v95(&v122, &type metadata for Int, v96, a3, a4);
      char v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v65,  v29,  a3);
LABEL_53:
      char v97 = v94;
      v59(v29, a3);
      uint64_t v71 = v65;
      if ((v97 & 1) != 0) {
        goto LABEL_68;
      }
LABEL_31:
      v59(v71, a3);
LABEL_32:
      char v75 = v120;
      uint64_t v76 = v120(a3, a4);
      unsigned int v77 = v115;
      ((void (*)(char *, char *, uint64_t))v60)(v115, v61, a3);
      if (v76 < 65)
      {
        uint64_t v85 = v75(a3, a4);
        v59(v77, a3);
        if (v85 != 64 || (v119(a3, a4) & 1) != 0)
        {
LABEL_45:
          unint64_t v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = v59(v61, a3);
          if ((v87 & 0x8000000000000000LL) != 0)
          {
            uint64_t v74 = v118;
            if (v87 > 0xFFFFFFFFFFFFFFF8LL)
            {
              unsigned int v73 = v114 >> -(char)v87;
              goto LABEL_48;
            }
          }

          else
          {
            uint64_t v74 = v118;
            if (v87 <= 7)
            {
              unsigned int v73 = v114 << v87;
              goto LABEL_48;
            }
          }

          LOBYTE(v73) = 0;
          goto LABEL_48;
        }
      }

      else
      {
        v59(v77, a3);
      }

      ((void (*)(char *, char *, uint64_t))v60)(v64, v61, a3);
      int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
      char v78 = v119(a3, a4);
      uint64_t v79 = v120(a3, a4);
      if ((v78 & 1) != 0)
      {
        if (v79 > 64)
        {
          uint64_t v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
          uint64_t v84 = &v122;
          goto LABEL_43;
        }
      }

      else if (v79 > 63)
      {
        uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        uint64_t v84 = &v121;
LABEL_43:
        v82(v84, &type metadata for Int, v83, a3, a4);
        char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v64,  a3);
        v59(v29, a3);
        if ((v86 & 1) != 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
        }
        goto LABEL_44;
      }

      ((void (*)(char *, char *, uint64_t))v60)(v29, v64, a3);
      (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
LABEL_44:
      v59(v64, a3);
      goto LABEL_45;
    }

    char v88 = v66(a3, a4);
    uint64_t v89 = v120(a3, a4);
    if ((v88 & 1) != 0)
    {
      if (v89 > 64)
      {
        uint64_t v92 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v93 = lazy protocol witness table accessor for type Int and conformance Int(v89, v90, v91);
        v92(&v122, &type metadata for Int, v93, a3, a4);
        uint64_t v65 = v110;
        char v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v110,  v29,  a3);
        goto LABEL_53;
      }

      unint64_t v101 = AssociatedTypeWitness;
      uint64_t v100 = (void (**)(char *, uint64_t, const char *))v113;
      unint64_t v102 = swift_getAssociatedConformanceWitness( (uint64_t)v113,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v103 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v102 + 8))( &qword_18180BE68,  256LL,  v101,  v102);
      v100[3](v103, a3, (const char *)v100);
      uint64_t v104 = v110;
      LOBYTE(v10_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v110,  v29,  a3);
      v59(v29, a3);
      uint64_t v105 = v109;
      ((void (*)(char *, char *, uint64_t))v60)(v109, v104, a3);
      if ((v100 & 1) != 0)
      {
        v59(v105, a3);
        goto LABEL_68;
      }

      int64_t v106 = v122;
      uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v105, a3);
      BOOL v108 = v107 < v106;
      unsigned int v61 = v117;
      uint64_t v71 = v110;
      if (!v108) {
        goto LABEL_31;
      }
    }

    else
    {
      if (v89 > 64)
      {
        uint64_t v71 = v110;
        goto LABEL_31;
      }

      char v98 = v110;
      ((void (*)(char *, char *, uint64_t))v60)(v29, v110, a3);
      uint64_t v99 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
      uint64_t v71 = v98;
      if (v99 >= v122) {
        goto LABEL_31;
      }
    }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt8( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -8LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if (v37 < -8) {
        goto LABEL_24;
      }
    }

_BYTE *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt8( _BYTE *result, _BYTE *a2, _BYTE *a3)
{
  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E0uLL,  0);
  }
  char v4 = *v3 / *a3;
  *a2 = *v3 % *a3;
  *uint64_t result = v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt8(unsigned __int8 *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt8(BOOL *a1@<X8>)
{
  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8( uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt8@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v66 = a4;
  uint64_t v71 = a5;
  uint64_t v8 = *(void *)(a3[3] + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v62 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  uint64_t v65 = (char *)&v62 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v70 = (char *)&v62 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v62 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v62 - v21;
  uint64_t v68 = (uint64_t (*)(uint64_t, void *))a3[8];
  char v23 = v68(a2, a3);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  uint64_t v72 = a1;
  char v69 = v24;
  v24(v22, a1, a2);
  unint64_t v67 = v20;
  unint64_t v63 = AssociatedTypeWitness;
  uint64_t v64 = v8;
  char v62 = v12;
  if ((v23 & 1) != 0)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a2, v8);
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3[4] + 8LL) + 16LL))(v22, v20, a2);
    uint64_t v27 = *(void (**)(char *, uint64_t))(v13 + 8);
    v27(v20, a2);
    uint64_t v28 = v22;
    uint64_t v29 = v27;
    v27(v28, a2);
    char v31 = v71;
    uint64_t v30 = v72;
    uint64_t v32 = v13;
    uint64_t v33 = a3;
    if ((v26 & 1) != 0) {
      goto LABEL_17;
    }
  }

  else
  {
    uint64_t v34 = v22;
    uint64_t v29 = *(void (**)(char *, uint64_t))(v13 + 8);
    v29(v34, a2);
    uint64_t v30 = v72;
    uint64_t v32 = v13;
    uint64_t v33 = a3;
  }

  uint64_t v35 = (uint64_t (*)(uint64_t, void *))v33[16];
  uint64_t v36 = v35(a2, v33);
  uint64_t v37 = v70;
  v69(v70, v30, a2);
  if (v36 <= 7)
  {
    v29(v37, a2);
    char v31 = v71;
    goto LABEL_7;
  }

  char v41 = v29;
  unsigned __int8 v73 = -1;
  char v42 = v68(a2, v33);
  uint64_t v43 = v35(a2, v33);
  if ((v42 & 1) != 0)
  {
    if (v43 < 9)
    {
      uint64_t v47 = v63;
      uint64_t v46 = v64;
      unint64_t v48 = swift_getAssociatedConformanceWitness( v64,  a2,  v63,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v49 = v62;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v48 + 8))( &qword_18180BE68,  256LL,  v47,  v48);
      unint64_t v50 = v67;
      (*(void (**)(char *, uint64_t, uint64_t))(v46 + 24))(v49, a2, v46);
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33[4] + 8LL) + 40LL))( v37,  v50,  a2);
      unint64_t v51 = v50;
      uint64_t v29 = v41;
      v41(v51, a2);
      char v52 = v37;
      unsigned int v53 = v73;
      uint64_t v54 = v65;
      (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v65, v52, a2);
      if ((v46 & 1) == 0)
      {
        v41(v54, a2);
        char v31 = v71;
        uint64_t v30 = v72;
        goto LABEL_7;
      }

      unsigned __int8 v55 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
      v41(v54, a2);
      BOOL v56 = v53 >= v55;
      goto LABEL_16;
    }

_BYTE *protocol witness for static Numeric.* infix(_:_:) in conformance UInt8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  else {
    *a3 = *result * *a2;
  }
  return result;
}

_BYTE *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt8(_BYTE *result, _BYTE *a2)
{
  else {
    *result *= *a2;
  }
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt8()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10LL, 0)._countAndFlagsBits;
}

unsigned __int8 *protocol witness for Strideable.distance(to:) in conformance UInt8@<X0>( unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  unsigned int v3 = *result;
  unsigned int v4 = *v2;
  uint64_t v5 = v4 - v3;
  BOOL v6 = v3 >= v4;
  uint64_t v7 = v3 - v4;
  if (!v6) {
    uint64_t v7 = -v5;
  }
  *a2 = v7;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt8@<X0>( unint64_t *result@<X0>, _BYTE *a2@<X8>)
{
  unint64_t v3 = *result;
  int v4 = *v2;
  if ((*result & 0x8000000000000000LL) == 0)
  {
    if (v3 >= 0x100) {
      goto LABEL_8;
    }
    v4 += v3;
    unint64_t v3 = v4;
    if (v4 == v4)
    {
LABEL_7:
      *a2 = v4;
      return result;
    }

    __break(1u);
  }

  unint64_t v5 = -(uint64_t)v3;
  if (v5 >= 0x100) {
LABEL_8:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  v4 -= v5;
  if ((v4 & 0xFFFFFF00) == 0) {
    goto LABEL_7;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt8( uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt8( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

unsigned __int8 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt8@<X0>( unsigned __int8 *result@<X0>, unsigned __int8 *a2@<X1>, _BYTE *a3@<X8>)
{
  unsigned int v3 = *result + *a2;
  if (((v3 >> 8) & 1) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

uint64_t static UInt8.+ infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result = a1 + a2;
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt8( _BYTE *result, unsigned __int8 *a2)
{
  unsigned int v2 = *result + *a2;
  if (((v2 >> 8) & 1) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

unsigned __int8 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt8@<X0>( unsigned __int8 *result@<X0>, unsigned __int8 *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3 = *result - *a2;
  if ((v3 & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt8( _BYTE *result, unsigned __int8 *a2)
{
  int v2 = *result - *a2;
  if ((v2 & 0xFFFFFF00) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

uint64_t UInt8._toCustomAnyHashable()@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt8>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt8@<X0>( uint64_t a1@<X8>)
{
  char v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt8>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a1 = v3;
  return result;
}

uint64_t Int8._value.setter(uint64_t result)
{
  *unsigned __int8 v1 = result;
  return result;
}

uint64_t (*Int8._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to Int8 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x63BuLL,  0);
  }
  __asm { FCVT            S0, H0 }

  if (_S0 <= -129.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to Int8 because the result would be less than Int8.min",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x63EuLL,  0);
  }
  if (_S0 >= 128.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to Int8 because the result would be greater than Int8.max",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x641uLL,  0);
  }
  return (int)_S0;
}

uint64_t Int8.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S0, H0 }

  BOOL v6 = _S0 > -129.0;
  if (_S0 >= 128.0) {
    BOOL v6 = 0;
  }
  _S1 = truncf(_S0);
  __asm
  {
    FCVT            H1, S1
    FCVT            S1, H1
  }

  int v9 = v6 && _S1 == _S0;
  _ZF = v9 == 0;
  char v10 = ~(_BYTE)v9;
  if (_ZF) {
    int v11 = 0;
  }
  else {
    int v11 = (int)_S0;
  }
  return v11 & 0xFFFFFEFF | ((v10 & 1) << 8);
}

Swift::Int8 __swiftcall Int8.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int8 because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x687uLL,  0);
  }
  if (a1 <= -129.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int8 because the result would be less than Int8.min",  86LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x68AuLL,  0);
  }
  if (a1 >= 128.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int8 because the result would be greater than Int8.max",  89LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x68DuLL,  0);
  }
  return (int)a1;
}

Swift::Int8_optional __swiftcall Int8.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -129.0;
  if (exactly >= 128.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = (int)exactly;
  }
  return (Swift::Int8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

Swift::Int8 __swiftcall Int8.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int8 because it is either infinite or NaN",  77LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x6CFuLL,  0);
  }
  if (a1 <= -129.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int8 because the result would be less than Int8.min",  87LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x6D2uLL,  0);
  }
  if (a1 >= 128.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int8 because the result would be greater than Int8.max",  90LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x6D5uLL,  0);
  }
  return (int)a1;
}

Swift::Int8_optional __swiftcall Int8.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -129.0;
  if (exactly >= 128.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = (int)exactly;
  }
  return (Swift::Int8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

BOOL static Int8.< infix(_:_:)(char a1, char a2)
{
  return a1 < a2;
}

_BYTE *static Int8.-= infix(_:_:)(_BYTE *result, char a2)
{
  int v2 = (char)*result - a2;
  else {
    __break(1u);
  }
  return result;
}

_BYTE *static Int8.*= infix(_:_:)(_BYTE *result, char a2)
{
  int v2 = (char)*result * a2;
  else {
    __break(1u);
  }
  return result;
}

_BYTE *static Int8./= infix(_:_:)(_BYTE *result, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7C3uLL,  0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 128) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7CAuLL,  0);
  }
  *uint64_t result = (char)v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.addingReportingOverflow(_:)(Swift::Int8 a1)
{
  Swift::Int8 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.subtractingReportingOverflow(_:)(Swift::Int8 a1)
{
  Swift::Int8 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.multipliedReportingOverflow(by:)(Swift::Int8 by)
{
  Swift::Int8 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.dividedReportingOverflow(by:)(Swift::Int8 by)
{
  if (by)
  {
    else {
      v1 /= by;
    }
  }

  Swift::Int8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.remainderReportingOverflow(dividingBy:)( Swift::Int8 dividingBy)
{
  if (dividingBy)
  {
    else {
      v1 %= dividingBy;
    }
  }

  Swift::Int8 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

_BYTE *static Int8.%= infix(_:_:)(_BYTE *result, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8A8uLL,  0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 128) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8ADuLL,  0);
  }
  *Swift::tuple_partialValue_Int8_overflow_Bool result = (char)v2 % a2;
  return result;
}

_BYTE *static Int8.&= infix(_:_:)(_BYTE *result, char a2)
{
  *result &= a2;
  return result;
}

_BYTE *static Int8.|= infix(_:_:)(_BYTE *result, char a2)
{
  *result |= a2;
  return result;
}

_BYTE *static Int8.^= infix(_:_:)(_BYTE *result, char a2)
{
  *result ^= a2;
  return result;
}

_BYTE *static Int8.&>>= infix(_:_:)(_BYTE *result, char a2)
{
  *Swift::tuple_partialValue_Int8_overflow_Bool result = (char)*result >> (a2 & 7);
  return result;
}

uint64_t static Int8.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

_BYTE *static Int8.&<<= infix(_:_:)(_BYTE *result, char a2)
{
  *Swift::tuple_partialValue_Int8_overflow_Bool result = *result << (a2 & 7);
  return result;
}

uint64_t static Int8.bitWidth.getter()
{
  return 8LL;
}

uint64_t Int8.leadingZeroBitCount.getter(unsigned __int8 a1)
{
  return (__clz(a1) - 24);
}

uint64_t Int8._lowWord.getter(uint64_t result)
{
  return (char)result;
}

uint64_t Int8.trailingZeroBitCount.getter(int a1)
{
  return __clz(__rbit32(a1 | 0x100));
}

uint64_t Int8.nonzeroBitCount.getter(unsigned __int8 a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t Int8.Words._value.setter(uint64_t result)
{
  *uint8x8_t v1 = result;
  return result;
}

uint64_t (*Int8.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.Words.count.getter()
{
  return 1LL;
}

uint64_t Int8.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t Int8.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t Int8.Words.indices.getter()
{
  return 0LL;
}

Swift::Int __swiftcall Int8.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1LL);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int8.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1LL);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int8.Words.subscript.getter(uint64_t a1, char a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x9AAuLL,  0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x9ABuLL,  0);
  }
  return a2;
}

uint64_t static Int8.&>> infix(_:_:)(char a1, char a2)
{
  return (a1 >> (a2 & 7));
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Int8.Words@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2);
  *a3 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Int8.Words( unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int8.Words( uint64_t *a1, uint64_t *a2))()
{
  *a1 = Int8.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt8.Words@<X0>( void *result@<X0>, uint64_t a2@<X8>)
{
  if ((*result & 0x8000000000000000LL) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  char v4 = *v2;
  *(void *)a2 = *result;
  *(void *)(a2 + 8) = v3;
  *(_BYTE *)(a2 + 16) = v4;
  return result;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance Int8.Words( uint64_t *a1, uint64_t *a2)
{
  return specialized Collection._failEarlyRangeCheck(_:bounds:)(*a1, *a2, a2[1]);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UInt8.Words( void *result, void *a2)
{
  if (*result < *a2 || a2[1] < *result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }
  return result;
}

{
  if (*result < *a2 || a2[1] < result[1]) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Int8.Words(uint64_t a1@<X8>)
{
  *(_BYTE *)a1 = *v1;
  *(void *)(a1 + 8) = 0LL;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int8.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int8.Words( uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int8.Words@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5( a1,  a2);
}

uint64_t Int8.magnitude.getter(char a1)
{
  if (a1 >= 0) {
    return a1;
  }
  else {
    return -a1;
  }
}

Swift::tuple_high_Int8_low_UInt8 __swiftcall Int8.multipliedFullWidth(by:)(Swift::Int8 by)
{
  unsigned int v2 = bswap32(v1 * by) >> 16;
  result.high = v2;
  result.Swift::UInt64 low = v1;
  return result;
}

Swift::tuple_quotient_Int8_remainder_Int8 __swiftcall Int8.dividingFullWidth(_:)(Swift::tuple_high_Int8_low_UInt8 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xA29uLL,  0);
  }
  __int16 v3 = a1.low | (unsigned __int16)(__PAIR16__(v2, a1.high) << 8);
  if (v1 == -1 && (unsigned __int16)v3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13CBuLL,  0);
  }
  unsigned __int16 v4 = v3 / v1;
  if ((unsigned __int16)(char)v4 != v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xA33uLL,  0);
  }
  result.remainder = v3;
  result.quotient = v4;
  return result;
}

uint64_t static Int16.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << (a2 & 0xF));
}

Swift::Int8 __swiftcall Int8.signum()()
{
  return (v0 > 0) | (v0 >> 7);
}

BOOL static Int8.> infix(_:_:)(char a1, char a2)
{
  return a2 < a1;
}

uint64_t static Int8.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int8(_BYTE *a1@<X8>)
{
  *a1 = 127;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int8(_BYTE *a1@<X8>)
{
  *a1 = 0x80;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int8( _BYTE *a1, _BYTE *a2)
{
  int v3 = (char)*v2 + (char)*a2;
  BOOL v4 = v3 != (char)(*v2 + *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int8( _BYTE *a1, _BYTE *a2)
{
  int v3 = (char)*v2 - (char)*a2;
  BOOL v4 = v3 != (char)(*v2 - *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int8( _BYTE *a1, _BYTE *a2)
{
  int v3 = (char)*v2 * (char)*a2;
  BOOL v4 = v3 != (char)(*v2 * *a2);
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int8( _BYTE *a1, _BYTE *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if (!*a2 || v3 == 255 && v4 == 128)
  {
    uint64_t v5 = 1LL;
  }

  else
  {
    uint64_t v5 = 0LL;
    LOBYTE(v4) = (char)v4 / (char)v3;
  }

  *a1 = v4;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int8( _BYTE *a1, _BYTE *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if (!*a2) {
    goto LABEL_7;
  }
  if (v3 == 255 && v4 == 128)
  {
    LOBYTE(v4) = 0;
LABEL_7:
    uint64_t v5 = 1LL;
    goto LABEL_5;
  }

  uint64_t v5 = 0LL;
  LOBYTE(v4) = (char)v4 % (char)v3;
LABEL_5:
  *a1 = v4;
  return v5;
}

_BYTE *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int8( _BYTE *result, _BYTE *a2, char *a3)
{
  __int16 v4 = *v3 * *a3;
  *Swift::tuple_quotient_Int8_remainder_Int8 result = HIBYTE(v4);
  *a2 = v4;
  return result;
}

Swift::Int8 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int8( Swift::Int8 *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  Swift::Int8 result = Int8.dividingFullWidth(_:)((Swift::tuple_high_Int8_low_UInt8)__PAIR16__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int8()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int8()
{
  return (__clz(*v0) - 24);
}

char *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int8@<X0>( char *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result >> (*a2 & 7);
  return result;
}

_BYTE *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  *Swift::Int8 result = (char)*result >> (*a2 & 7);
  return result;
}

unsigned __int8 *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int8@<X0>( unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result << (*a2 & 7);
  return result;
}

uint64_t static Int8.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << (a2 & 7));
}

_BYTE *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  *Swift::Int8 result = *result << (*a2 & 7);
  return result;
}

_BYTE *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_BYTE *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_BYTE *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_BYTE *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int8@<X0>( _BYTE *result@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  if (a2 <= 0x8FF) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int8@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int8 and conformance Int8(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int8@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int8 and conformance Int8,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _BYTE *a6@<X8>)
{
  unint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, a2, v13, a3);
  if ((BYTE1(v38) & 1) != 0)
  {
    char v38 = (char *)static String._createEmpty(withInitialCapacity:)(80LL);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000LL) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._unint64_t object = (void *)0x80000001818B69D0LL;
      v26._uint64_t countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000LL) == 0)
      {
        uint64_t v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._uint64_t countAndFlagsBits = 0xD00000000000002ELL;
        v37._unint64_t object = (void *)0x80000001818B69F0LL;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v38,  v39,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a6 = (_BYTE)v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int8@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _BYTE *a6@<X8>)
{
  uint64_t v71 = a4;
  uint64_t v72 = a5;
  char v75 = a6;
  uint64_t v68 = *(const char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v68,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v68 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  char v69 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unsigned __int8 v73 = (char *)&v68 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  int64_t v20 = (char *)&v68 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v74 = (char *)&v68 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v68 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v68 - v26;
  unsigned int v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v28 = v77(a2, a3);
  uint64_t v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  char v78 = a1;
  uint64_t v76 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v30 = v70(a2, a3);
    int64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 8)
    {
      int64_t v32 = v76;
      v76(v25, v78, a2);
      char v79 = 0x80;
      char v33 = v25;
      uint64_t v34 = v77;
      if ((v77(a2, a3) & 1) != 0)
      {
        uint64_t v35 = v70;
        if (v70(a2, a3) < 8)
        {
          uint64_t v36 = v74;
          v32(v74, v33, a2);
          char v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          BOOL v38 = v79 <= v37;
LABEL_18:
          char v42 = v33;
LABEL_19:
          uint64_t v46 = v78;
          if (!v38) {
LABEL_40:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
          goto LABEL_21;
        }

        uint64_t v45 = v74;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v33,  v45,  a2);
        v31(v45, a2);
        char v42 = v33;
        goto LABEL_11;
      }

      char v40 = v34(a2, a3);
      uint64_t v41 = v70(a2, a3);
      char v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 8)
        {
          uint64_t v49 = v68;
          unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v68,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
          unint64_t v51 = v74;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          char v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v51,  a2);
          v31(v51, a2);
          unsigned int v53 = v69;
          char v33 = v42;
          int64_t v32 = v76;
          v76(v69, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_40;
          }

          int v54 = v79;
          char v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          BOOL v38 = v54 <= v55;
          uint64_t v35 = v70;
          goto LABEL_18;
        }

        uint64_t v43 = v74;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v43,  a2);
        v31(v43, a2);
        int64_t v32 = v76;
        uint64_t v35 = v70;
LABEL_11:
        uint64_t v46 = v78;
        if ((v44 & 1) != 0) {
          goto LABEL_40;
        }
LABEL_21:
        v31(v42, a2);
        unint64_t v39 = v77;
        goto LABEL_24;
      }

      if (v41 < 8)
      {
        uint64_t v47 = v74;
        int64_t v32 = v76;
        v76(v74, v42, a2);
        char v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        BOOL v38 = v79 <= v48;
        uint64_t v35 = v70;
        goto LABEL_19;
      }

      v31(v33, a2);
    }

    int64_t v32 = v76;
    unint64_t v39 = v77;
    uint64_t v35 = v70;
  }

  else
  {
    int64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    uint64_t v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    int64_t v32 = v76;
    unint64_t v39 = v77;
  }

  uint64_t v46 = v78;
LABEL_24:
  uint64_t v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 9)
  {
    v31(v20, a2);
    goto LABEL_26;
  }

  uint64_t v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 8 && (v39(a2, a3) & 1) == 0)
  {
LABEL_26:
    uint64_t v57 = v73;
    v32(v73, v46, a2);
    char v81 = 127;
    char v58 = v39(a2, a3);
    uint64_t v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 8)
      {
        uint64_t v60 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        unsigned __int8 v61 = &v81;
        goto LABEL_35;
      }
    }

    else if (v59 > 7)
    {
      char v80 = 127;
      uint64_t v60 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      unsigned __int8 v61 = &v80;
LABEL_35:
      uint64_t v64 = v74;
      v60(v61, v71, v72, a2, a3);
      char v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v64,  v57,  a2);
      v31(v64, a2);
      if ((v65 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_36;
    }

    unint64_t v63 = v74;
    v32(v74, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_36:
    v31(v57, a2);
  }

  char v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *char v75 = v66;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt8@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  char v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int8@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int8 and conformance Int8((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int8()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int8()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int8()
{
  return __clz(__rbit32(*v0 | 0x100));
}

unsigned __int8 *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int8@<X0>( unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7C3uLL,  0);
  }
  int v4 = *result;
  if (v4 == 128 && v3 == 255) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7CAuLL,  0);
  }
  *a3 = (char)v4 / (char)v3;
  return result;
}

uint64_t static Int8./ infix(_:_:)(unsigned __int8 a1, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7C3uLL,  0);
  }
  if (a1 == 128 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7CAuLL,  0);
  }
  return ((char)a1 / a2);
}

_BYTE *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7C3uLL,  0);
  }
  int v3 = *result;
  if (v2 == 255 && v3 == 128) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7CAuLL,  0);
  }
  *uint64_t result = (char)v3 / (char)v2;
  return result;
}

unsigned __int8 *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int8@<X0>( unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8A8uLL,  0);
  }
  int v4 = *result;
  if (v4 == 128 && v3 == 255) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8ADuLL,  0);
  }
  *a3 = (char)v4 % (char)v3;
  return result;
}

uint64_t static Int8.% infix(_:_:)(unsigned __int8 a1, char a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8A8uLL,  0);
  }
  if (a1 == 128 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8ADuLL,  0);
  }
  return ((char)a1 % a2);
}

_BYTE *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8A8uLL,  0);
  }
  int v3 = *result;
  if (v2 == 255 && v3 == 128) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x8ADuLL,  0);
  }
  *uint64_t result = (char)v3 % (char)v2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  *result &= *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  *result |= *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int8.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_BYTE *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int8@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v120 = a5;
  int64x2_t v115 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v115,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64x2_t v113 = (char *)&v111 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v111 = (char *)&v111 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v111 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v117 = (char *)&v111 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  BOOL v112 = (char *)&v111 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v111 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v119 = (char *)&v111 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v111 - v28;
  int v118 = *a1;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v121 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    unint64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v124 = -8LL;
        char v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        uint64_t v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v115;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -8;
    }

    else
    {
      if (v39 > 64)
      {
        uint64_t v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -8;
    }

    uint64_t v30 = v121;
    int64_t v32 = v122;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 >= -8) {
      goto LABEL_20;
    }
LABEL_19:
    LOBYTE(v54) = 0;
    char v55 = v120;
    goto LABEL_50;
  }

  int64_t v124 = -8LL;
  char v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
LABEL_20:
  unint64_t v122 = v32;
  char v56 = v30(a3, a4);
  uint64_t v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64) {
      goto LABEL_22;
    }
  }

  else if (v57 > 63)
  {
LABEL_22:
    int64_t v124 = 8LL;
    uint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v6_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    uint64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v62(v29, a3);
LABEL_31:
    int v54 = (char)v118 >> 7;
    char v55 = v120;
    goto LABEL_50;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v62(v29, a3);
  if (v77 > 8) {
    goto LABEL_31;
  }
LABEL_23:
  unint64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v64 = v119;
  v63(v119, a2, a3);
  char v65 = v121(a3, a4);
  char v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    uint64_t v76 = v25;
    uint64_t v68 = v119;
    char v69 = v117;
    goto LABEL_33;
  }

  uint64_t v67 = v122(a3, a4);
  v62(v25, a3);
  uint64_t v68 = v119;
  char v69 = v117;
  if (v67 < 65) {
    goto LABEL_34;
  }
  uint64_t v70 = v112;
  v66(v112, v119, a3);
  int64_t v124 = 0x8000000000000000LL;
  uint64_t v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    char v91 = v71(a3, a4);
    uint64_t v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        unint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        uint64_t v70 = v112;
        char v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
        goto LABEL_55;
      }

      unint64_t v104 = AssociatedTypeWitness;
      uint64_t v103 = (void (**)(char *, uint64_t, const char *))v115;
      unint64_t v105 = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      int64_t v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))( &qword_18180BE68,  256LL,  v104,  v105);
      v103[3](v106, a3, (const char *)v103);
      uint64_t v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
      v62(v29, a3);
      BOOL v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }

      int64_t v109 = v124;
      uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      BOOL v47 = v110 < v109;
      uint64_t v68 = v119;
      uint64_t v76 = v112;
      if (!v47) {
        goto LABEL_33;
      }
    }

    else
    {
      if (v92 > 64)
      {
        uint64_t v76 = v112;
        goto LABEL_33;
      }

      uint64_t v101 = v112;
      v66(v29, v112, a3);
      uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      uint64_t v76 = v101;
      if (v102 >= v124) {
        goto LABEL_33;
      }
    }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int8( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -8LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) == 0) {
        goto LABEL_19;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if (v37 >= -8) {
        goto LABEL_19;
      }
    }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int8@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v119 = a5;
  uint64_t v114 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v114,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  BOOL v112 = (char *)&v110 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v110 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64_t v110 = (char *)&v110 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v115 = (char *)&v110 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64x2_t v116 = (char *)&v110 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v111 = (char *)&v110 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v110 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  char v117 = (char *)&v110 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v110 - v28;
  int v118 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v120 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    uint64_t v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v121(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v123 = -8LL;
        uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v123, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        char v30 = v120;
        int64_t v32 = v121;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v114;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -8;
    }

    else
    {
      if (v39 > 64)
      {
        char v30 = v120;
        int64_t v32 = v121;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -8;
    }

    char v30 = v120;
    int64_t v32 = v121;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    int64_t v123 = -8LL;
    uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v44(&v123, &type metadata for Int, v45, a3, a4);
    LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 <= -9) {
      goto LABEL_19;
    }
  }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int8( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    int8x16_t v131 = v19;
    uint64_t v132 = a1;
    char v41 = v29(a3, a4);
    int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        int64_t v144 = -8LL;
        unint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        BOOL v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        if ((v48 & 1) != 0) {
          goto LABEL_18;
        }
        goto LABEL_19;
      }

      char v55 = v137;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      char v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
      unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        uint64_t v39 = v132;
        goto LABEL_18;
      }

      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }

    else
    {
      if (v42 >= 64)
      {
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        goto LABEL_19;
      }

      uint64_t v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }

    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -8) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  char v31 = v19;
  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 < 64)
  {
    uint64_t v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    uint64_t v39 = a1;
    uint64_t v40 = v31;
    if (v37 > -9) {
      goto LABEL_19;
    }
LABEL_18:
    int v61 = *(char *)v39 >> 7;
    goto LABEL_60;
  }

  int64_t v144 = -8LL;
  uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  unint64_t v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  uint64_t v39 = a1;
  uint64_t v40 = v31;
  if ((v52 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  char v62 = v141(a3, a4);
  uint64_t v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
  }

  else if (v63 >= 64)
  {
LABEL_21:
    int64_t v144 = 8LL;
    char v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    uint64_t v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    char v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v68, a3);
    if ((v69 & 1) != 0) {
      goto LABEL_25;
    }
    goto LABEL_26;
  }

  uint64_t v71 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v70(v71, a3);
  if (v72 > 8)
  {
LABEL_25:
    LOBYTE(v61) = 0;
    goto LABEL_60;
  }

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int8( _BYTE *a1, _BYTE *a2, char *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int8(char *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int8(_BYTE *a1@<X8>)
{
  *a1 = (*v1 > 0) | (*v1 >> 7);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int8( uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, _BYTE *a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    unsigned int v10 = a3();
    if ((v10 & 0x10000) != 0) {
      unsigned int v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10LL, a4);
    }
    unsigned int v11 = v10;
    swift_bridgeObjectRelease(a2);
    int v12 = (v11 >> 8) & 1;
    if (v12) {
      char v13 = 0;
    }
    else {
      char v13 = v11;
    }
  }

  else
  {
    swift_bridgeObjectRelease(a2);
    char v13 = 0;
    LOBYTE(v12) = 1;
  }

  *a5 = v13;
  a5[1] = v12;
}

_BYTE *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  int v2 = (char)*result;
  else {
    *a2 = -(char)v2;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int8()
{
  int v1 = (char)*v0;
  else {
    _BYTE *v0 = -(char)v1;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int8@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v90 = a4;
  uint64_t v94 = a5;
  unint64_t v87 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v87,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unsigned int v11 = (char *)&v86 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v9);
  char v88 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v86 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v93 = (char *)&v86 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v92 = (char *)&v86 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v91 = (char *)&v86 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v86 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v86 - v27;
  unint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v29 = v95(a2, a3);
  uint64_t v96 = v12;
  char v30 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v30(v28, a1, a2);
  unint64_t v89 = v17;
  BOOL v31 = (v29 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 8;
  int64_t v32 = *(void (**)(char *, uint64_t))(v96 + 8);
  v32(v28, a2);
  v30(v26, a1, a2);
  if (!v31)
  {
    v32(v26, a2);
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    char v38 = v93;
    uint64_t v40 = v94;
    goto LABEL_10;
  }

  char v97 = 0x80;
  uint64_t v33 = v95;
  if ((v95(a2, a3) & 1) != 0)
  {
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v35 = v34(a2, a3);
    char v38 = v93;
    if (v35 >= 8)
    {
      unint64_t v67 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v68 = lazy protocol witness table accessor for type Int8 and conformance Int8(v35, v36, v37);
      unint64_t v86 = v34;
      char v69 = v91;
      v67(&v97, v90, v68, a2, a3);
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v69,  a2);
      uint64_t v70 = v69;
      uint64_t v34 = v86;
      v32(v70, a2);
      v32(v26, a2);
      uint64_t v40 = v94;
    }

    else
    {
      char v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v32(v26, a2);
      uint64_t v40 = v94;
      if (v97 > v39) {
        goto LABEL_40;
      }
    }

    goto LABEL_10;
  }

  char v55 = v33(a2, a3);
  unint64_t v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v56 = v86(a2, a3);
  if ((v55 & 1) != 0)
  {
    if (v56 > 8)
    {
      char v59 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v60 = lazy protocol witness table accessor for type Int8 and conformance Int8(v56, v57, v58);
      int v61 = v91;
      v59(&v97, v90, v60, a2, a3);
      LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v61,  a2);
      v32(v61, a2);
      v32(v26, a2);
      char v38 = v93;
      uint64_t v40 = v94;
      uint64_t v34 = v86;
      goto LABEL_10;
    }

    char v80 = (void (**)(char *, uint64_t, const char *))v87;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v82 = v91;
    v80[3](v11, a2, (const char *)v80);
    LOBYTE(v8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v82,  a2);
    v32(v82, a2);
    uint64_t v83 = v88;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v88, v26, a2);
    uint64_t v40 = v94;
    if ((v80 & 1) != 0)
    {
      v32(v83, a2);
LABEL_40:
      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
      char v64 = 0;
      char v66 = 1;
      goto LABEL_41;
    }

    int v84 = v97;
    char v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v83, a2);
    BOOL v72 = v84 <= v85;
    char v38 = v93;
    goto LABEL_39;
  }

  char v38 = v93;
  if (v56 < 8)
  {
    char v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v26, a2);
    BOOL v72 = v97 <= v71;
    uint64_t v40 = v94;
LABEL_39:
    uint64_t v34 = v86;
    if (!v72) {
      goto LABEL_40;
    }
LABEL_10:
    uint64_t v41 = v34(a2, a3);
    goto LABEL_11;
  }

  v32(v26, a2);
  uint64_t v40 = v94;
  uint64_t v34 = v86;
  uint64_t v41 = v86(a2, a3);
LABEL_11:
  uint64_t v42 = v41;
  uint64_t v43 = v92;
  v30(v92, a1, a2);
  if (v42 >= 9)
  {
    v32(v43, a2);
    v30(v38, a1, a2);
    goto LABEL_15;
  }

  uint64_t v44 = v34(a2, a3);
  v32(v43, a2);
  if (v44 != 8)
  {
    v30(v38, a1, a2);
    goto LABEL_25;
  }

  char v45 = v95(a2, a3);
  v30(v38, a1, a2);
  if ((v45 & 1) != 0)
  {
LABEL_25:
    uint64_t v63 = v38;
    goto LABEL_26;
  }

void protocol witness for Numeric.magnitude.getter in conformance Int8(_BYTE *a1@<X8>)
{
  int v2 = *v1;
  if (v2 < 0) {
    int v2 = -v2;
  }
  *a1 = v2;
}

_BYTE *protocol witness for static Numeric.* infix(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3 = (char)*result * (char)*a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int8.* infix(_:_:)(char a1, char a2)
{
  uint64_t result = (a1 * a2);
  return result;
}

_BYTE *protocol witness for static Numeric.*= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  int v2 = (char)*result * (char)*a2;
  else {
    __break(1u);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int8()
{
  return _int64ToString(_:radix:uppercase:)( *v0,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

unsigned __int8 *protocol witness for Strideable.distance(to:) in conformance Int8@<X0>( unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  int v3 = *result;
  int v4 = (char)*v2;
  if (((v4 ^ v3) & 0x80) == 0)
  {
    int v5 = (char)v3 - v4;
    if ((char)v5 == v5)
    {
      *a2 = (char)v5;
      return result;
    }

    __break(1u);
    goto LABEL_15;
  }

  if (v4 >= 0) {
    LOBYTE(v6) = *v2;
  }
  else {
    int v6 = -v4;
  }
  if ((v3 & 0x80u) != 0) {
    int v3 = -(char)v3;
  }
  unsigned int v7 = v6 + v3;
  if (((v7 >> 8) & 1) != 0)
  {
LABEL_15:
    __break(1u);
    return result;
  }

  if (v4 < 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = -(uint64_t)v7;
  }
  *a2 = v8;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int8@<X0>( void *result@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  if (v4 <= -129) {
    goto LABEL_6;
  }
  if (v4 >= 128) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int8( uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt8( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt8( uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

_BYTE *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3 = (char)*result + (char)*a2;
  else {
    __break(1u);
  }
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  int v2 = (char)*result + (char)*a2;
  else {
    __break(1u);
  }
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int8@<X0>( _BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3 = (char)*result - (char)*a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int8.- infix(_:_:)(char a1, char a2)
{
  uint64_t result = (a1 - a2);
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int8( _BYTE *result, _BYTE *a2)
{
  int v2 = (char)*result - (char)*a2;
  else {
    __break(1u);
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a2 >= *a1;
}

BOOL static Int8.<= infix(_:_:)(char a1, char a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a2 < *a1;
}

void Int8.hash(into:)(int a1, Swift::UInt8 a2)
{
}

Swift::Int __swiftcall Int8._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 1LL);
}

uint64_t Int8.hashValue.getter(unsigned __int8 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, a1, 1LL);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int8(uint64_t a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 1LL);
}

uint64_t Int8._toCustomAnyHashable()@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int8>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int8@<X0>( uint64_t a1@<X8>)
{
  char v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int8>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a1 = v3;
  return result;
}

uint64_t UInt16._value.setter(uint64_t result)
{
  *unsigned __int8 v1 = result;
  return result;
}

uint64_t (*UInt16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt16 because it is either infinite or NaN",  80LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xC57uLL,  0);
  }
  __asm { FCVT            S0, H0 }

  if (_S0 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt16 because the result would be less than UInt16.min",  92LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xC5AuLL,  0);
  }
  return (int)_S0;
}

uint64_t UInt16.init(exactly:)(float _S0)
{
  __asm { FCVT            S1, H0 }

  if (_S1 <= -1.0)
  {
    int v10 = 0;
    int v9 = 1;
  }

  else
  {
    float v6 = _S0;
    _S0 = truncf(_S1);
    __asm
    {
      FCVT            H0, S0
      FCVT            S0, H0
    }

    int v9 = (~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1;
    int v10 = (int)_S1;
    if (v9) {
      int v10 = 0;
    }
  }

  return v10 | (v9 << 16);
}

Swift::UInt16 __swiftcall UInt16.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt16 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xCA5uLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt16 because the result would be less than UInt16.min",  90LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xCA8uLL,  0);
  }
  if (a1 >= 65536.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt16 because the result would be greater than UInt16.max",  93LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xCABuLL,  0);
  }
  return (int)a1;
}

Swift::UInt16_optional __swiftcall UInt16.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 65536.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

Swift::UInt16 __swiftcall UInt16.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt16 because it is either infinite or NaN",  79LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xCEDuLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt16 because the result would be less than UInt16.min",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xCF0uLL,  0);
  }
  if (a1 >= 65536.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt16 because the result would be greater than UInt16.max",  94LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xCF3uLL,  0);
  }
  return (int)a1;
}

Swift::UInt16_optional __swiftcall UInt16.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 65536.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (int)exactly;
  }
  return (Swift::UInt16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

_WORD *static UInt16.+= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  int v2 = (unsigned __int16)*result + a2;
  if ((v2 & 0x10000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

_WORD *static UInt16.-= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  int v2 = (unsigned __int16)*result - a2;
  if ((v2 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

_WORD *static UInt16.*= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  else {
    *result *= a2;
  }
  return result;
}

_WORD *static UInt16./= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xDE1uLL,  0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.addingReportingOverflow(_:)(Swift::UInt16 a1)
{
  Swift::UInt16 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.subtractingReportingOverflow(_:)(Swift::UInt16 a1)
{
  Swift::UInt16 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.multipliedReportingOverflow(by:)(Swift::UInt16 by)
{
  Swift::UInt16 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.dividedReportingOverflow(by:)(Swift::UInt16 by)
{
  if (by) {
    v1 /= by;
  }
  Swift::UInt16 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.remainderReportingOverflow(dividingBy:)( Swift::UInt16 dividingBy)
{
  if (dividingBy) {
    v1 %= dividingBy;
  }
  Swift::UInt16 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

_WORD *static UInt16.%= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xEB5uLL,  0);
  }
  *result %= a2;
  return result;
}

uint64_t UInt16._lowWord.getter(uint64_t result)
{
  return (unsigned __int16)result;
}

uint64_t UInt16.Words._value.setter(uint64_t result)
{
  *unsigned __int16 v1 = result;
  return result;
}

uint64_t (*UInt16.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.Words.count.getter()
{
  return 1LL;
}

uint64_t UInt16.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t UInt16.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t UInt16.Words.indices.getter()
{
  return 0LL;
}

uint64_t UInt16.Words.subscript.getter(uint64_t a1, unsigned __int16 a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xFB2uLL,  0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xFB3uLL,  0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt16.Words( uint64_t *a1, uint64_t *a2))()
{
  *a1 = UInt16.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt16.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt16.Words( uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt16_low_UInt16 __swiftcall UInt16.multipliedFullWidth(by:)(Swift::UInt16 by)
{
  Swift::UInt16 v2 = (v1 * by) >> 16;
  result.Swift::UInt64 low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt16_remainder_UInt16 __swiftcall UInt16.dividingFullWidth(_:)( Swift::tuple_high_UInt16_low_UInt16 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1018uLL,  0);
  }
  if (a1.high >= v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x101AuLL,  0);
  }
  unsigned int v2 = a1.low | (a1.high << 16);
  Swift::UInt16 v3 = v2 / v1;
  result.remainder = v2;
  result.quotient = v3;
  return result;
}

BOOL static UInt16.> infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a2 < a1;
}

Swift::UInt16 __swiftcall UInt16.signum()()
{
  return v0 != 0;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt16()
{
  return 16LL;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = -1;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt16( _WORD *a1, _WORD *a2)
{
  uint64_t v3 = ((unsigned __int16)*v2 + (unsigned __int16)*a2) >> 16;
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt16( _WORD *a1, unsigned __int16 *a2)
{
  int v3 = *v2 - *a2;
  *a1 = v3;
  return (v3 & 0xFFFF0000) != 0;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt16( _WORD *a1, unsigned __int16 *a2)
{
  int v3 = *v2 * *a2;
  *a1 = v3;
  return (v3 & 0xFFFF0000) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt16( _WORD *a1, _WORD *a2)
{
  unsigned int v3 = (unsigned __int16)*a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt16( _WORD *a1, _WORD *a2)
{
  unsigned int v3 = (unsigned __int16)*a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

_WORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt16( _WORD *result, _WORD *a2, unsigned __int16 *a3)
{
  int v4 = *v3 * *a3;
  *Swift::tuple_quotient_UInt16_remainder_UInt16 result = HIWORD(v4);
  *a2 = v4;
  return result;
}

Swift::UInt16 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt16( Swift::UInt16 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  Swift::UInt16 result = UInt16.dividingFullWidth(_:)((Swift::tuple_high_UInt16_low_UInt16)__PAIR32__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

unsigned __int16 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt16@<X0>( unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result >> (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt16( _WORD *result, _WORD *a2)
{
  *Swift::UInt16 result = (unsigned __int16)*result >> (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt16@<X0>( _WORD *result@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  if (a2 >> 9 <= 8 && (a2 & 1) == 0) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16 and conformance UInt16,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _WORD *a6@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v49 = a6;
  uint64_t v9 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v48 = (char *)&v44 - v12;
  uint64_t v52 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  char v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v51 = (char *)&v44 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v44 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v44 - v20;
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v23 = v22(a2, a3);
  uint64_t v50 = a1;
  if ((v23 & 1) != 0)
  {
    uint64_t v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    char v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 32LL))( v21,  v19,  a2);
    uint64_t v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    v28(v21, a2);
    a1 = v50;
  }

  char v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v30 = a1;
  if (v29(a2, a3) >= 16)
  {
    uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    unsigned __int16 v53 = -1;
    char v31 = v22(a2, a3);
    uint64_t v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 17)
      {
        unint64_t v33 = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        uint64_t v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 40LL))( v51,  v19,  a2);
        uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        unsigned int v37 = v53;
        char v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        uint64_t v30 = v50;
        if ((v34 & 1) != 0)
        {
          unsigned __int16 v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39) {
            goto LABEL_14;
          }
        }

        else
        {
          v36(v38, a2);
        }

        goto LABEL_16;
      }
    }

    else if (v32 <= 16)
    {
      uint64_t v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      unsigned __int16 v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      uint64_t v30 = v50;
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }

    (*(void (**)(unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    uint64_t v35 = v51;
    char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v19,  v51,  a2);
    uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    uint64_t v30 = v50;
    if ((v40 & 1) != 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_16;
  }

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt16@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt16 and conformance UInt16((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt16()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt16()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_WORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xDE1uLL,  0);
  }
  *a3 = *result / *a2;
  return result;
}

uint64_t static UInt16./ infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xDE1uLL,  0);
  }
  return a1 / a2;
}

_WORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt16( _WORD *result, _WORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xDE1uLL,  0);
  }
  *result /= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xEB5uLL,  0);
  }
  *a3 = *result % *a2;
  return result;
}

uint64_t static UInt16.% infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xEB5uLL,  0);
  }
  return a1 % a2;
}

_WORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt16( _WORD *result, _WORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xEB5uLL,  0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt16.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt16@<X0>( unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64x2_t v126 = a5;
  uint64_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v114 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  int64_t v123 = (char *)&v114 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v117 = (char *)&v114 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v114 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v124 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v114 - v29;
  unsigned int v122 = *a1;
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v121 = v19;
  unint64_t v127 = v31;
  if ((v32 & 1) != 0)
  {
    unint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      int64_t v129 = -16LL;
      uint64_t v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -16) {
        goto LABEL_24;
      }
    }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt16( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -16LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if (v37 < -16) {
        goto LABEL_24;
      }
    }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt16@<X0>( unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v118 = a5;
  int64x2_t v113 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v113,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v111 = (char *)&v109 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v109 = (char *)&v109 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v109 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64x2_t v115 = (char *)&v109 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  int64_t v110 = (char *)&v109 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v109 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  char v117 = (char *)&v109 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v109 - v28;
  unsigned int v114 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v119 = v30;
  if ((v31 & 1) != 0)
  {
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v122 = -16LL;
      uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v44(&v122, &type metadata for Int, v45, a3, a4);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v36 < -16) {
        goto LABEL_29;
      }
    }
  }

  else
  {
    char v38 = v30(a3, a4);
    uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v120(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 <= 64)
      {
        unint64_t v47 = AssociatedTypeWitness;
        char v48 = v113;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v113,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v50 = v111;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v47,  AssociatedConformanceWitness);
        (*((void (**)(char *, uint64_t, const char *))v48 + 3))(v50, a3, v48);
        LOBYTE(v47) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        unint64_t v51 = *(void (**)(char *, uint64_t))(v11 + 8);
        v51(v29, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
        if ((v47 & 1) != 0)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
          goto LABEL_29;
        }

        uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
        char v30 = v119;
        char v32 = v120;
        if (v52 < -16) {
          goto LABEL_29;
        }
      }

      else
      {
        int64_t v122 = -16LL;
        uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v122, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        char v30 = v119;
        char v32 = v120;
      }
    }

    else if (v39 <= 64)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      char v30 = v119;
      char v32 = v120;
      if (v46 < -16) {
        goto LABEL_29;
      }
    }

    else
    {
      char v30 = v119;
      char v32 = v120;
    }
  }

  uint64_t v120 = v32;
  char v53 = v30(a3, a4);
  uint64_t v54 = v32(a3, a4);
  if ((v53 & 1) != 0)
  {
    if (v54 > 64) {
      goto LABEL_20;
    }
  }

  else if (v54 > 63)
  {
LABEL_20:
    int64_t v122 = 16LL;
    uint64_t v57 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v58 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v57(&v122, &type metadata for Int, v58, a3, a4);
    LOBYTE(v57) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    char v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v59(v29, a3);
    goto LABEL_29;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v59(v29, a3);
  if (v72 <= 16)
  {
LABEL_21:
    unint64_t v60 = *(void (**)(void))(v11 + 16);
    unsigned int v61 = v117;
    v60();
    char v62 = v119(a3, a4);
    ((void (*)(char *, char *, uint64_t))v60)(v25, v61, a3);
    if ((v62 & 1) == 0)
    {
      char v71 = v25;
      uint64_t v64 = v116;
      goto LABEL_31;
    }

    uint64_t v63 = v120(a3, a4);
    v59(v25, a3);
    uint64_t v64 = v116;
    if (v63 < 65) {
      goto LABEL_32;
    }
    uint64_t v65 = v110;
    ((void (*)(char *, char *, uint64_t))v60)(v110, v61, a3);
    int64_t v122 = 0x8000000000000000LL;
    char v66 = v119;
    if ((v119(a3, a4) & 1) != 0)
    {
      uint64_t v67 = v120(a3, a4);
      if (v67 < 64)
      {
        ((void (*)(char *, char *, uint64_t))v60)(v29, v65, a3);
        uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v59(v29, a3);
        char v71 = v65;
        if (v70 < v122) {
          goto LABEL_68;
        }
        goto LABEL_31;
      }

      unint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v95(&v122, &type metadata for Int, v96, a3, a4);
      char v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v65,  v29,  a3);
LABEL_53:
      char v97 = v94;
      v59(v29, a3);
      char v71 = v65;
      if ((v97 & 1) != 0) {
        goto LABEL_68;
      }
LABEL_31:
      v59(v71, a3);
LABEL_32:
      char v75 = v120;
      uint64_t v76 = v120(a3, a4);
      uint64_t v77 = v115;
      ((void (*)(char *, char *, uint64_t))v60)(v115, v61, a3);
      if (v76 < 65)
      {
        uint64_t v85 = v75(a3, a4);
        v59(v77, a3);
        if (v85 != 64 || (v119(a3, a4) & 1) != 0)
        {
LABEL_45:
          unint64_t v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = v59(v61, a3);
          if ((v87 & 0x8000000000000000LL) != 0)
          {
            uint64_t v74 = v118;
            if (v87 > 0xFFFFFFFFFFFFFFF0LL)
            {
              unsigned int v73 = v114 >> -(char)v87;
              goto LABEL_48;
            }
          }

          else
          {
            uint64_t v74 = v118;
            if (v87 <= 0xF)
            {
              unsigned int v73 = v114 << v87;
              goto LABEL_48;
            }
          }

          LOWORD(v73) = 0;
          goto LABEL_48;
        }
      }

      else
      {
        v59(v77, a3);
      }

      ((void (*)(char *, char *, uint64_t))v60)(v64, v61, a3);
      int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
      char v78 = v119(a3, a4);
      uint64_t v79 = v120(a3, a4);
      if ((v78 & 1) != 0)
      {
        if (v79 > 64)
        {
          uint64_t v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
          uint64_t v84 = &v122;
          goto LABEL_43;
        }
      }

      else if (v79 > 63)
      {
        uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        uint64_t v84 = &v121;
LABEL_43:
        v82(v84, &type metadata for Int, v83, a3, a4);
        char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v64,  a3);
        v59(v29, a3);
        if ((v86 & 1) != 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
        }
        goto LABEL_44;
      }

      ((void (*)(char *, char *, uint64_t))v60)(v29, v64, a3);
      (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
LABEL_44:
      v59(v64, a3);
      goto LABEL_45;
    }

    char v88 = v66(a3, a4);
    uint64_t v89 = v120(a3, a4);
    if ((v88 & 1) != 0)
    {
      if (v89 > 64)
      {
        uint64_t v92 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v93 = lazy protocol witness table accessor for type Int and conformance Int(v89, v90, v91);
        v92(&v122, &type metadata for Int, v93, a3, a4);
        uint64_t v65 = v110;
        char v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v110,  v29,  a3);
        goto LABEL_53;
      }

      unint64_t v101 = AssociatedTypeWitness;
      char v100 = (void (**)(char *, uint64_t, const char *))v113;
      unint64_t v102 = swift_getAssociatedConformanceWitness( (uint64_t)v113,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v103 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v102 + 8))( &qword_18180BE68,  256LL,  v101,  v102);
      v100[3](v103, a3, (const char *)v100);
      uint64_t v104 = v110;
      LOBYTE(v10_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v110,  v29,  a3);
      v59(v29, a3);
      uint64_t v105 = v109;
      ((void (*)(char *, char *, uint64_t))v60)(v109, v104, a3);
      if ((v100 & 1) != 0)
      {
        v59(v105, a3);
        goto LABEL_68;
      }

      int64_t v106 = v122;
      uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v105, a3);
      BOOL v108 = v107 < v106;
      unsigned int v61 = v117;
      char v71 = v110;
      if (!v108) {
        goto LABEL_31;
      }
    }

    else
    {
      if (v89 > 64)
      {
        char v71 = v110;
        goto LABEL_31;
      }

      char v98 = v110;
      ((void (*)(char *, char *, uint64_t))v60)(v29, v110, a3);
      uint64_t v99 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
      char v71 = v98;
      if (v99 >= v122) {
        goto LABEL_31;
      }
    }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt16( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -16LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if (v37 < -16) {
        goto LABEL_24;
      }
    }

_WORD *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt16( _WORD *result, _WORD *a2, _WORD *a3)
{
  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0xDE1uLL,  0);
  }
  __int16 v4 = *v3 / *a3;
  *a2 = *v3 % *a3;
  *uint64_t result = v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt16(unsigned __int16 *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v66 = a4;
  uint64_t v71 = a5;
  uint64_t v8 = *(void *)(a3[3] + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v62 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  uint64_t v65 = (char *)&v62 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v70 = (char *)&v62 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v62 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v62 - v21;
  uint64_t v68 = (uint64_t (*)(uint64_t, void *))a3[8];
  char v23 = v68(a2, a3);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  uint64_t v72 = a1;
  char v69 = v24;
  v24(v22, a1, a2);
  unint64_t v67 = v20;
  unint64_t v63 = AssociatedTypeWitness;
  uint64_t v64 = v8;
  char v62 = v12;
  if ((v23 & 1) != 0)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a2, v8);
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3[4] + 8LL) + 16LL))(v22, v20, a2);
    uint64_t v27 = *(void (**)(char *, uint64_t))(v13 + 8);
    v27(v20, a2);
    uint64_t v28 = v22;
    uint64_t v29 = v27;
    v27(v28, a2);
    uint64_t v31 = v71;
    uint64_t v30 = v72;
    uint64_t v32 = v13;
    uint64_t v33 = a3;
    if ((v26 & 1) != 0) {
      goto LABEL_17;
    }
  }

  else
  {
    uint64_t v34 = v22;
    uint64_t v29 = *(void (**)(char *, uint64_t))(v13 + 8);
    v29(v34, a2);
    uint64_t v30 = v72;
    uint64_t v32 = v13;
    uint64_t v33 = a3;
  }

  uint64_t v35 = (uint64_t (*)(uint64_t, void *))v33[16];
  uint64_t v36 = v35(a2, v33);
  uint64_t v37 = v70;
  v69(v70, v30, a2);
  if (v36 <= 15)
  {
    v29(v37, a2);
    uint64_t v31 = v71;
    goto LABEL_7;
  }

  char v41 = v29;
  unsigned __int16 v73 = -1;
  char v42 = v68(a2, v33);
  uint64_t v43 = v35(a2, v33);
  if ((v42 & 1) != 0)
  {
    if (v43 < 17)
    {
      uint64_t v47 = v63;
      uint64_t v46 = v64;
      unint64_t v48 = swift_getAssociatedConformanceWitness( v64,  a2,  v63,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v49 = v62;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v48 + 8))( &qword_18180BE68,  256LL,  v47,  v48);
      unint64_t v50 = v67;
      (*(void (**)(char *, uint64_t, uint64_t))(v46 + 24))(v49, a2, v46);
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33[4] + 8LL) + 40LL))( v37,  v50,  a2);
      unint64_t v51 = v50;
      uint64_t v29 = v41;
      v41(v51, a2);
      char v52 = v37;
      unsigned int v53 = v73;
      uint64_t v54 = v65;
      (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v65, v52, a2);
      if ((v46 & 1) == 0)
      {
        v41(v54, a2);
        uint64_t v31 = v71;
        uint64_t v30 = v72;
        goto LABEL_7;
      }

      unsigned __int16 v55 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
      v41(v54, a2);
      BOOL v56 = v53 >= v55;
      goto LABEL_16;
    }

unsigned __int16 *protocol witness for static Numeric.* infix(_:_:) in conformance UInt16@<X0>( unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result * *a2;
  if ((v3 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

uint64_t static UInt16.* infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result = a1 * a2;
  if ((result & 0xFFFF0000) != 0) {
    __break(1u);
  }
  return result;
}

_WORD *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt16( _WORD *result, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*result * *a2;
  if ((v2 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt16()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10LL, 0)._countAndFlagsBits;
}

unsigned __int16 *protocol witness for Strideable.distance(to:) in conformance UInt16@<X0>( unsigned __int16 *result@<X0>, uint64_t *a2@<X8>)
{
  unsigned int v3 = *result;
  unsigned int v4 = *v2;
  uint64_t v5 = v4 - v3;
  BOOL v6 = v3 >= v4;
  uint64_t v7 = v3 - v4;
  if (!v6) {
    uint64_t v7 = -v5;
  }
  *a2 = v7;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt16@<X0>( unint64_t *result@<X0>, _WORD *a2@<X8>)
{
  unint64_t v3 = *result;
  int v4 = *v2;
  if ((*result & 0x8000000000000000LL) == 0)
  {
    if (v3 >= 0x10000) {
      goto LABEL_8;
    }
    v4 += (unsigned __int16)v3;
    unint64_t v3 = (unsigned __int16)v4;
    if ((unsigned __int16)v4 == v4)
    {
LABEL_7:
      *a2 = v4;
      return result;
    }

    __break(1u);
  }

  unint64_t v5 = -(uint64_t)v3;
  if (v5 >= 0x10000) {
LABEL_8:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  v4 -= (unsigned __int16)v5;
  if ((v4 & 0xFFFF0000) == 0) {
    goto LABEL_7;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt16( uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt16( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

unsigned __int16 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt16@<X0>( unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result + *a2;
  if ((v3 & 0x10000) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

_WORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt16( _WORD *result, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*result + *a2;
  if ((v2 & 0x10000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

unsigned __int16 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt16@<X0>( unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result - *a2;
  if ((v3 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

_WORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt16( _WORD *result, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*result - *a2;
  if ((v2 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance UInt16( unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance UInt16( unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance UInt16( unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 >= *a2;
}

BOOL static UInt16.>= infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance UInt16( unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a2 < *a1;
}

uint64_t UInt16.hashValue.getter(unsigned __int16 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, a1, 2LL);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance UInt16()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, *v0, 2LL);
}

uint64_t UInt16._toCustomAnyHashable()@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt16>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt16@<X0>( uint64_t a1@<X8>)
{
  __int16 v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt16>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a1 = v3;
  return result;
}

uint64_t Int16._value.setter(uint64_t result)
{
  *unsigned __int16 v1 = result;
  return result;
}

uint64_t (*Int16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to Int16 because it is either infinite or NaN",  79LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x123CuLL,  0);
  }
  __asm { FCVT            S0, H0 }

  if (_S0 <= -32800.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to Int16 because the result would be less than Int16.min",  90LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x123FuLL,  0);
  }
  if (_S0 >= 32768.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to Int16 because the result would be greater than Int16.max",  93LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1242uLL,  0);
  }
  return (int)_S0;
}

uint64_t Int16.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S0, H0 }

  BOOL v6 = _S0 > -32800.0;
  if (_S0 >= 32768.0) {
    BOOL v6 = 0;
  }
  _S1 = truncf(_S0);
  __asm
  {
    FCVT            H1, S1
    FCVT            S1, H1
  }

  int v9 = v6 && _S1 == _S0;
  _ZF = v9 == 0;
  char v10 = ~(_BYTE)v9;
  if (_ZF) {
    int v11 = 0;
  }
  else {
    int v11 = (unsigned __int16)(int)_S0;
  }
  return v11 & 0xFFFEFFFF | ((v10 & 1) << 16);
}

Swift::Int16 __swiftcall Int16.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int16 because it is either infinite or NaN",  77LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1288uLL,  0);
  }
  if (a1 <= -32769.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int16 because the result would be less than Int16.min",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x128BuLL,  0);
  }
  if (a1 >= 32768.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int16 because the result would be greater than Int16.max",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x128EuLL,  0);
  }
  return (int)a1;
}

Swift::Int16_optional __swiftcall Int16.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -32769.0;
  if (exactly >= 32768.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (unsigned __int16)(int)exactly;
  }
  return (Swift::Int16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

Swift::Int16 __swiftcall Int16.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int16 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x12D0uLL,  0);
  }
  if (a1 <= -32769.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int16 because the result would be less than Int16.min",  89LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x12D3uLL,  0);
  }
  if (a1 >= 32768.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int16 because the result would be greater than Int16.max",  92LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x12D6uLL,  0);
  }
  return (int)a1;
}

Swift::Int16_optional __swiftcall Int16.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -32769.0;
  if (exactly >= 32768.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (unsigned __int16)(int)exactly;
  }
  return (Swift::Int16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

BOOL static Int16.== infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 == a2;
}

BOOL static Int16.< infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 < a2;
}

__int16 *static Int16.+= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2 = *result + a2;
  else {
    __break(1u);
  }
  return result;
}

__int16 *static Int16.-= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2 = *result - a2;
  else {
    __break(1u);
  }
  return result;
}

__int16 *static Int16.*= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2 = *result * a2;
  else {
    __break(1u);
  }
  return result;
}

_WORD *static Int16./= infix(_:_:)(_WORD *result, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13C4uLL,  0);
  }
  int v2 = (unsigned __int16)*result;
  if (a2 == -1 && v2 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13CBuLL,  0);
  }
  *uint64_t result = (__int16)v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.addingReportingOverflow(_:)(Swift::Int16 a1)
{
  Swift::Int16 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.subtractingReportingOverflow(_:)(Swift::Int16 a1)
{
  Swift::Int16 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.multipliedReportingOverflow(by:)(Swift::Int16 by)
{
  Swift::Int16 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.dividedReportingOverflow(by:)(Swift::Int16 by)
{
  if (by)
  {
    else {
      v1 /= by;
    }
  }

  Swift::Int16 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.remainderReportingOverflow(dividingBy:)( Swift::Int16 dividingBy)
{
  if (dividingBy)
  {
    else {
      v1 %= dividingBy;
    }
  }

  Swift::Int16 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

_WORD *static Int16.%= infix(_:_:)(_WORD *result, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14A9uLL,  0);
  }
  int v2 = (unsigned __int16)*result;
  if (a2 == -1 && v2 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14AEuLL,  0);
  }
  *Swift::tuple_partialValue_Int16_overflow_Bool result = (__int16)v2 % a2;
  return result;
}

_WORD *static Int16.&= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result &= a2;
  return result;
}

_WORD *static Int16.|= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result |= a2;
  return result;
}

_WORD *static Int16.^= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result ^= a2;
  return result;
}

__int16 *static Int16.&>>= infix(_:_:)(__int16 *result, char a2)
{
  *result >>= a2 & 0xF;
  return result;
}

uint64_t static Int16.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

_WORD *static Int16.&<<= infix(_:_:)(_WORD *result, char a2)
{
  *Swift::tuple_partialValue_Int16_overflow_Bool result = (unsigned __int16)*result << (a2 & 0xF);
  return result;
}

uint64_t static Int16.bitWidth.getter()
{
  return 16LL;
}

uint64_t Int16.leadingZeroBitCount.getter(unsigned __int16 a1)
{
  return (unsigned __int16)(__clz(a1) - 16);
}

uint64_t Int16._lowWord.getter(uint64_t result)
{
  return (__int16)result;
}

uint64_t Int16.trailingZeroBitCount.getter(int a1)
{
  return __clz(__rbit32(a1 | 0x10000));
}

uint64_t Int16.nonzeroBitCount.getter(unsigned __int16 a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t Int16.Words._value.setter(uint64_t result)
{
  *uint8x8_t v1 = result;
  return result;
}

uint64_t (*Int16.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.Words.count.getter()
{
  return 1LL;
}

uint64_t Int16.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t Int16.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t Int16.Words.indices.getter()
{
  return 0LL;
}

Swift::Int __swiftcall Int16.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1LL);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int16.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1LL);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int16.Words.subscript.getter(uint64_t a1, __int16 a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x15ABuLL,  0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x15ACuLL,  0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int16.Words( uint64_t *a1, uint64_t *a2))()
{
  *a1 = Int16.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt16.Words@<X0>( void *result@<X0>, uint64_t a2@<X8>)
{
  if ((*result & 0x8000000000000000LL) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  __int16 v4 = *v2;
  *(void *)a2 = *result;
  *(void *)(a2 + 8) = v3;
  *(_WORD *)(a2 + 16) = v4;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Int16.Words(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = *v1;
  *(void *)(a1 + 8) = 0LL;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int16.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int16.Words( uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int16.Words@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5( a1,  a2);
}

uint64_t Int16.magnitude.getter(__int16 a1)
{
  if (a1 >= 0) {
    return a1;
  }
  else {
    return -a1;
  }
}

Swift::tuple_high_Int16_low_UInt16 __swiftcall Int16.multipliedFullWidth(by:)(Swift::Int16 by)
{
  Swift::Int16 v2 = (v1 * by) >> 16;
  result.Swift::UInt64 low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_Int16_remainder_Int16 __swiftcall Int16.dividingFullWidth(_:)( Swift::tuple_high_Int16_low_UInt16 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x162AuLL,  0);
  }
  int v2 = a1.low | ((unsigned __int16)a1.high << 16);
  if (v1 == -1 && v2 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FD1uLL,  0);
  }
  int v3 = v2 / v1;
  if (v3 != (__int16)v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1634uLL,  0);
  }
  result.remainder = v2;
  result.quotient = v3;
  return result;
}

uint64_t static Int32.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << a2);
}

uint64_t Int16.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1) >> 16;
}

Swift::Int16 __swiftcall Int16.signum()()
{
  return (v0 > 0) | (v0 >> 15);
}

BOOL static Int16.> infix(_:_:)(__int16 a1, __int16 a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = 0x7FFF;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = 0x8000;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int16( _WORD *a1, __int16 *a2)
{
  int v3 = *v2 + *a2;
  BOOL v4 = v3 != (__int16)(*v2 + *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int16( _WORD *a1, __int16 *a2)
{
  int v3 = *v2 - *a2;
  BOOL v4 = v3 != (__int16)(*v2 - *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int16( _WORD *a1, __int16 *a2)
{
  int v3 = *v2 * *a2;
  BOOL v4 = v3 != (__int16)(*v2 * *a2);
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int16( _WORD *a1, _WORD *a2)
{
  int v3 = (unsigned __int16)*a2;
  int v4 = *v2;
  if (!*a2 || v3 == 0xFFFF && v4 == 0x8000)
  {
    uint64_t v5 = 1LL;
  }

  else
  {
    uint64_t v5 = 0LL;
    LOWORD(v4) = (__int16)v4 / (__int16)v3;
  }

  *a1 = v4;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int16( _WORD *a1, _WORD *a2)
{
  int v3 = (unsigned __int16)*a2;
  int v4 = *v2;
  if (!*a2) {
    goto LABEL_7;
  }
  if (v3 == 0xFFFF && v4 == 0x8000)
  {
    LOWORD(v4) = 0;
LABEL_7:
    uint64_t v5 = 1LL;
    goto LABEL_5;
  }

  uint64_t v5 = 0LL;
  LOWORD(v4) = (__int16)v4 % (__int16)v3;
LABEL_5:
  *a1 = v4;
  return v5;
}

_WORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int16( _WORD *result, _WORD *a2, __int16 *a3)
{
  int v4 = *v3 * *a3;
  *Swift::tuple_quotient_Int16_remainder_Int16 result = HIWORD(v4);
  *a2 = v4;
  return result;
}

Swift::Int16 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int16( Swift::Int16 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  Swift::Int16 result = Int16.dividingFullWidth(_:)((Swift::tuple_high_Int16_low_UInt16)__PAIR32__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int16()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int16()
{
  return (unsigned __int16)(__clz(*v0) - 16);
}

unsigned __int16 *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int16@<X0>( unsigned __int16 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = bswap32(*result) >> 16;
  return result;
}

_WORD *protocol witness for FixedWidthInteger.init(littleEndian:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = bswap32(*v1) >> 16;
}

void protocol witness for FixedWidthInteger.littleEndian.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = *v1;
}

__int16 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int16@<X0>( __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result >> (*a2 & 0xF);
  return result;
}

__int16 *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int16( __int16 *result, _WORD *a2)
{
  *result >>= *a2 & 0xF;
  return result;
}

unsigned __int16 *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int16@<X0>( unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result << (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int16( _WORD *result, _WORD *a2)
{
  *Swift::Int16 result = (unsigned __int16)*result << (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_WORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_WORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_WORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int16@<X0>( _WORD *result@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  if (a2 >> 8 <= 0x10) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int16 and conformance Int16(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int16@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int16 and conformance Int16,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _WORD *a6@<X8>)
{
  unint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, a2, v13, a3);
  if ((BYTE2(v38) & 1) != 0)
  {
    __int16 v38 = (char *)static String._createEmpty(withInitialCapacity:)(80LL);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000LL) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._unint64_t object = (void *)0x80000001818B69D0LL;
      v26._uint64_t countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000LL) == 0)
      {
        uint64_t v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._uint64_t countAndFlagsBits = 0xD00000000000002ELL;
        v37._unint64_t object = (void *)0x80000001818B69F0LL;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v38,  v39,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a6 = (_WORD)v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int16@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _WORD *a6@<X8>)
{
  uint64_t v71 = a4;
  uint64_t v72 = a5;
  char v75 = a6;
  uint64_t v68 = *(const char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v68,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v68 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  char v69 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unsigned __int16 v73 = (char *)&v68 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  int64_t v20 = (char *)&v68 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v74 = (char *)&v68 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v68 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v68 - v26;
  uint64_t v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v28 = v77(a2, a3);
  uint64_t v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  char v78 = a1;
  uint64_t v76 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v30 = v70(a2, a3);
    int64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 16)
    {
      int64_t v32 = v76;
      v76(v25, v78, a2);
      __int16 v79 = 0x8000;
      char v33 = v25;
      uint64_t v34 = v77;
      if ((v77(a2, a3) & 1) != 0)
      {
        uint64_t v35 = v70;
        if (v70(a2, a3) < 16)
        {
          uint64_t v36 = v74;
          v32(v74, v33, a2);
          __int16 v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          BOOL v38 = v79 <= v37;
LABEL_18:
          char v42 = v33;
LABEL_19:
          uint64_t v46 = v78;
          if (!v38) {
LABEL_40:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
          goto LABEL_21;
        }

        uint64_t v45 = v74;
        (*(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v33,  v45,  a2);
        v31(v45, a2);
        char v42 = v33;
        goto LABEL_11;
      }

      char v40 = v34(a2, a3);
      uint64_t v41 = v70(a2, a3);
      char v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 16)
        {
          uint64_t v49 = v68;
          unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v68,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
          unint64_t v51 = v74;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          char v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v51,  a2);
          v31(v51, a2);
          unsigned int v53 = v69;
          char v33 = v42;
          int64_t v32 = v76;
          v76(v69, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_40;
          }

          int v54 = v79;
          __int16 v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          BOOL v38 = v54 <= v55;
          uint64_t v35 = v70;
          goto LABEL_18;
        }

        uint64_t v43 = v74;
        (*(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v43,  a2);
        v31(v43, a2);
        int64_t v32 = v76;
        uint64_t v35 = v70;
LABEL_11:
        uint64_t v46 = v78;
        if ((v44 & 1) != 0) {
          goto LABEL_40;
        }
LABEL_21:
        v31(v42, a2);
        unint64_t v39 = v77;
        goto LABEL_24;
      }

      if (v41 < 16)
      {
        uint64_t v47 = v74;
        int64_t v32 = v76;
        v76(v74, v42, a2);
        __int16 v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        BOOL v38 = v79 <= v48;
        uint64_t v35 = v70;
        goto LABEL_19;
      }

      v31(v33, a2);
    }

    int64_t v32 = v76;
    unint64_t v39 = v77;
    uint64_t v35 = v70;
  }

  else
  {
    int64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    uint64_t v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    int64_t v32 = v76;
    unint64_t v39 = v77;
  }

  uint64_t v46 = v78;
LABEL_24:
  uint64_t v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 17)
  {
    v31(v20, a2);
    goto LABEL_26;
  }

  uint64_t v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 16 && (v39(a2, a3) & 1) == 0)
  {
LABEL_26:
    uint64_t v57 = v73;
    v32(v73, v46, a2);
    __int16 v81 = 0x7FFF;
    char v58 = v39(a2, a3);
    uint64_t v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 16)
      {
        unint64_t v60 = *(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        unsigned __int16 v61 = &v81;
        goto LABEL_35;
      }
    }

    else if (v59 > 15)
    {
      __int16 v80 = 0x7FFF;
      unint64_t v60 = *(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      unsigned __int16 v61 = &v80;
LABEL_35:
      uint64_t v64 = v74;
      v60(v61, v71, v72, a2, a3);
      char v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v64,  v57,  a2);
      v31(v64, a2);
      if ((v65 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_36;
    }

    unint64_t v63 = v74;
    v32(v74, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_36:
    v31(v57, a2);
  }

  __int16 v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *char v75 = v66;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _WORD *a4@<X8>)
{
  __int16 v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int16@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int16 and conformance Int16((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int16()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int16()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int16()
{
  return __clz(__rbit32(*v0 | 0x10000));
}

unsigned __int16 *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int16@<X0>( unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13C4uLL,  0);
  }
  int v4 = *result;
  if (v4 == 0x8000 && v3 == 0xFFFF) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13CBuLL,  0);
  }
  *a3 = (__int16)v4 / (__int16)v3;
  return result;
}

uint64_t static Int16./ infix(_:_:)(unsigned __int16 a1, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13C4uLL,  0);
  }
  if (a1 == 0x8000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13CBuLL,  0);
  }
  return ((__int16)a1 / a2);
}

_WORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int16( _WORD *result, _WORD *a2)
{
  int v2 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13C4uLL,  0);
  }
  int v3 = (unsigned __int16)*result;
  if (v2 == 0xFFFF && v3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13CBuLL,  0);
  }
  *uint64_t result = (__int16)v3 / (__int16)v2;
  return result;
}

unsigned __int16 *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int16@<X0>( unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14A9uLL,  0);
  }
  int v4 = *result;
  if (v4 == 0x8000 && v3 == 0xFFFF) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14AEuLL,  0);
  }
  *a3 = (__int16)v4 % (__int16)v3;
  return result;
}

uint64_t static Int16.% infix(_:_:)(unsigned __int16 a1, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14A9uLL,  0);
  }
  if (a1 == 0x8000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14AEuLL,  0);
  }
  return ((__int16)a1 % a2);
}

_WORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int16( _WORD *result, _WORD *a2)
{
  int v2 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14A9uLL,  0);
  }
  int v3 = (unsigned __int16)*result;
  if (v2 == 0xFFFF && v3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x14AEuLL,  0);
  }
  *uint64_t result = (__int16)v3 % (__int16)v2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int16( _WORD *result, _WORD *a2)
{
  *result &= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int16( _WORD *result, _WORD *a2)
{
  *result |= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int16@<X0>( _WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int16.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_WORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int16( _WORD *result, _WORD *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int16@<X0>( unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v120 = a5;
  int64x2_t v115 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v115,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64x2_t v113 = (char *)&v111 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v111 = (char *)&v111 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v111 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v117 = (char *)&v111 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  BOOL v112 = (char *)&v111 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v111 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v119 = (char *)&v111 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v111 - v28;
  int v118 = *a1;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v121 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    unint64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v124 = -16LL;
        char v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        uint64_t v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v115;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -16;
    }

    else
    {
      if (v39 > 64)
      {
        uint64_t v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -16;
    }

    uint64_t v30 = v121;
    int64_t v32 = v122;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 >= -16) {
      goto LABEL_20;
    }
LABEL_19:
    LOWORD(v54) = 0;
    __int16 v55 = v120;
    goto LABEL_50;
  }

  int64_t v124 = -16LL;
  char v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
LABEL_20:
  unint64_t v122 = v32;
  char v56 = v30(a3, a4);
  uint64_t v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64) {
      goto LABEL_22;
    }
  }

  else if (v57 > 63)
  {
LABEL_22:
    int64_t v124 = 16LL;
    unint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v6_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    uint64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v62(v29, a3);
LABEL_31:
    int v54 = (__int16)v118 >> 15;
    __int16 v55 = v120;
    goto LABEL_50;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v62(v29, a3);
  if (v77 > 16) {
    goto LABEL_31;
  }
LABEL_23:
  unint64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v64 = v119;
  v63(v119, a2, a3);
  char v65 = v121(a3, a4);
  __int16 v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    uint64_t v76 = v25;
    uint64_t v68 = v119;
    char v69 = v117;
    goto LABEL_33;
  }

  uint64_t v67 = v122(a3, a4);
  v62(v25, a3);
  uint64_t v68 = v119;
  char v69 = v117;
  if (v67 < 65) {
    goto LABEL_34;
  }
  uint64_t v70 = v112;
  v66(v112, v119, a3);
  int64_t v124 = 0x8000000000000000LL;
  uint64_t v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    char v91 = v71(a3, a4);
    uint64_t v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        unint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        uint64_t v70 = v112;
        char v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
        goto LABEL_55;
      }

      unint64_t v104 = AssociatedTypeWitness;
      uint64_t v103 = (void (**)(char *, uint64_t, const char *))v115;
      unint64_t v105 = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      int64_t v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))( &qword_18180BE68,  256LL,  v104,  v105);
      v103[3](v106, a3, (const char *)v103);
      uint64_t v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
      v62(v29, a3);
      BOOL v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }

      int64_t v109 = v124;
      uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      BOOL v47 = v110 < v109;
      uint64_t v68 = v119;
      uint64_t v76 = v112;
      if (!v47) {
        goto LABEL_33;
      }
    }

    else
    {
      if (v92 > 64)
      {
        uint64_t v76 = v112;
        goto LABEL_33;
      }

      uint64_t v101 = v112;
      v66(v29, v112, a3);
      uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      uint64_t v76 = v101;
      if (v102 >= v124) {
        goto LABEL_33;
      }
    }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int16( unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -16LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) == 0) {
        goto LABEL_19;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if (v37 >= -16) {
        goto LABEL_19;
      }
    }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int16@<X0>( unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v119 = a5;
  uint64_t v114 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v114,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  BOOL v112 = (char *)&v110 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v110 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64_t v110 = (char *)&v110 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v115 = (char *)&v110 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64x2_t v116 = (char *)&v110 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v111 = (char *)&v110 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v110 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  char v117 = (char *)&v110 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v110 - v28;
  int v118 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v120 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    uint64_t v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v121(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v123 = -16LL;
        uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v123, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        char v30 = v120;
        int64_t v32 = v121;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v114;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -16;
    }

    else
    {
      if (v39 > 64)
      {
        char v30 = v120;
        int64_t v32 = v121;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -16;
    }

    char v30 = v120;
    int64_t v32 = v121;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    int64_t v123 = -16LL;
    uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v44(&v123, &type metadata for Int, v45, a3, a4);
    LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 <= -17) {
      goto LABEL_19;
    }
  }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int16( unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    int8x16_t v131 = v19;
    uint64_t v132 = a1;
    char v41 = v29(a3, a4);
    int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        int64_t v144 = -16LL;
        unint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        BOOL v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        if ((v48 & 1) != 0) {
          goto LABEL_18;
        }
        goto LABEL_19;
      }

      char v55 = v137;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      char v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
      unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        uint64_t v39 = v132;
        goto LABEL_18;
      }

      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }

    else
    {
      if (v42 >= 64)
      {
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        goto LABEL_19;
      }

      uint64_t v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }

    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -16) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  char v31 = v19;
  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 < 64)
  {
    uint64_t v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    uint64_t v39 = a1;
    uint64_t v40 = v31;
    if (v37 > -17) {
      goto LABEL_19;
    }
LABEL_18:
    int v61 = (__int16)*v39 >> 15;
    goto LABEL_60;
  }

  int64_t v144 = -16LL;
  uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  unint64_t v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  uint64_t v39 = a1;
  uint64_t v40 = v31;
  if ((v52 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  char v62 = v141(a3, a4);
  uint64_t v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
  }

  else if (v63 >= 64)
  {
LABEL_21:
    int64_t v144 = 16LL;
    __int16 v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    uint64_t v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    char v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v68, a3);
    if ((v69 & 1) != 0) {
      goto LABEL_25;
    }
    goto LABEL_26;
  }

  uint64_t v71 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v70(v71, a3);
  if (v72 > 16)
  {
LABEL_25:
    LOWORD(v61) = 0;
    goto LABEL_60;
  }

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int16( _WORD *a1, _WORD *a2, __int16 *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int16(__int16 *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = (*v1 > 0) | (unsigned __int16)(*v1 >> 15);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int16( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    int v10 = a3();
    if ((v10 & 0x1000000) != 0) {
      int v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10LL, a4);
    }
    swift_bridgeObjectRelease(a2);
    unsigned int v11 = (v10 & 0x10000u) >> 16;
    if ((v10 & 0x10000) != 0) {
      __int16 v12 = 0;
    }
    else {
      __int16 v12 = v10;
    }
  }

  else
  {
    swift_bridgeObjectRelease(a2);
    __int16 v12 = 0;
    LOBYTE(v11) = 1;
  }

  *(_WORD *)a5 = v12;
  *(_BYTE *)(a5 + 2) = v11 & 1;
}

__int16 *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int16@<X0>( __int16 *result@<X0>, _WORD *a2@<X8>)
{
  int v2 = *result;
  else {
    *a2 = -(__int16)v2;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int16()
{
  int v1 = *v0;
  else {
    __int16 *v0 = -(__int16)v1;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int16@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v90 = a4;
  uint64_t v94 = a5;
  unint64_t v87 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v87,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unsigned int v11 = (char *)&v86 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v9);
  char v88 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v86 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v93 = (char *)&v86 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v92 = (char *)&v86 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v91 = (char *)&v86 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v86 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v86 - v27;
  unint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v29 = v95(a2, a3);
  uint64_t v96 = v12;
  char v30 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v30(v28, a1, a2);
  unint64_t v89 = v17;
  BOOL v31 = (v29 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 16;
  int64_t v32 = *(void (**)(char *, uint64_t))(v96 + 8);
  v32(v28, a2);
  v30(v26, a1, a2);
  if (!v31)
  {
    v32(v26, a2);
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    char v38 = v93;
    uint64_t v40 = v94;
    goto LABEL_10;
  }

  __int16 v97 = 0x8000;
  uint64_t v33 = v95;
  if ((v95(a2, a3) & 1) != 0)
  {
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v35 = v34(a2, a3);
    char v38 = v93;
    if (v35 >= 16)
    {
      unint64_t v67 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v68 = lazy protocol witness table accessor for type Int16 and conformance Int16(v35, v36, v37);
      unint64_t v86 = v34;
      char v69 = v91;
      v67(&v97, v90, v68, a2, a3);
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v69,  a2);
      uint64_t v70 = v69;
      uint64_t v34 = v86;
      v32(v70, a2);
      v32(v26, a2);
      uint64_t v40 = v94;
    }

    else
    {
      __int16 v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v32(v26, a2);
      uint64_t v40 = v94;
      if (v97 > v39) {
        goto LABEL_40;
      }
    }

    goto LABEL_10;
  }

  char v55 = v33(a2, a3);
  unint64_t v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v56 = v86(a2, a3);
  if ((v55 & 1) != 0)
  {
    if (v56 > 16)
    {
      char v59 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v60 = lazy protocol witness table accessor for type Int16 and conformance Int16(v56, v57, v58);
      int v61 = v91;
      v59(&v97, v90, v60, a2, a3);
      LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v61,  a2);
      v32(v61, a2);
      v32(v26, a2);
      char v38 = v93;
      uint64_t v40 = v94;
      uint64_t v34 = v86;
      goto LABEL_10;
    }

    char v80 = (void (**)(char *, uint64_t, const char *))v87;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v87,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v82 = v91;
    v80[3](v11, a2, (const char *)v80);
    LOBYTE(v8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v82,  a2);
    v32(v82, a2);
    uint64_t v83 = v88;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v88, v26, a2);
    uint64_t v40 = v94;
    if ((v80 & 1) != 0)
    {
      v32(v83, a2);
LABEL_40:
      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
      __int16 v64 = 0;
      char v66 = 1;
      goto LABEL_41;
    }

    int v84 = v97;
    __int16 v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v83, a2);
    BOOL v72 = v84 <= v85;
    char v38 = v93;
    goto LABEL_39;
  }

  char v38 = v93;
  if (v56 < 16)
  {
    __int16 v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v26, a2);
    BOOL v72 = v97 <= v71;
    uint64_t v40 = v94;
LABEL_39:
    uint64_t v34 = v86;
    if (!v72) {
      goto LABEL_40;
    }
LABEL_10:
    uint64_t v41 = v34(a2, a3);
    goto LABEL_11;
  }

  v32(v26, a2);
  uint64_t v40 = v94;
  uint64_t v34 = v86;
  uint64_t v41 = v86(a2, a3);
LABEL_11:
  uint64_t v42 = v41;
  uint64_t v43 = v92;
  v30(v92, a1, a2);
  if (v42 >= 17)
  {
    v32(v43, a2);
    v30(v38, a1, a2);
    goto LABEL_15;
  }

  uint64_t v44 = v34(a2, a3);
  v32(v43, a2);
  if (v44 != 16)
  {
    v30(v38, a1, a2);
    goto LABEL_25;
  }

  char v45 = v95(a2, a3);
  v30(v38, a1, a2);
  if ((v45 & 1) != 0)
  {
LABEL_25:
    uint64_t v63 = v38;
    goto LABEL_26;
  }

void protocol witness for Numeric.magnitude.getter in conformance Int16(_WORD *a1@<X8>)
{
  int v2 = *v1;
  if (v2 < 0) {
    int v2 = -v2;
  }
  *a1 = v2;
}

__int16 *protocol witness for static Numeric.* infix(_:_:) in conformance Int16@<X0>( __int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result * *a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int16.* infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result = (a1 * a2);
  return result;
}

__int16 *protocol witness for static Numeric.*= infix(_:_:) in conformance Int16( __int16 *result, __int16 *a2)
{
  int v2 = *result * *a2;
  else {
    __break(1u);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int16()
{
  return _int64ToString(_:radix:uppercase:)( *v0,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

unsigned __int16 *protocol witness for Strideable.distance(to:) in conformance Int16@<X0>( unsigned __int16 *result@<X0>, uint64_t *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  if (((v4 ^ v3) & 0x8000) == 0)
  {
    int v5 = (__int16)v3 - v4;
    if ((__int16)v5 == v5)
    {
      *a2 = (__int16)v5;
      return result;
    }

    __break(1u);
    goto LABEL_15;
  }

  if (v4 >= 0) {
    LOWORD(v6) = *v2;
  }
  else {
    int v6 = -v4;
  }
  if ((v3 & 0x8000u) != 0) {
    int v3 = -(__int16)v3;
  }
  int v7 = (unsigned __int16)v6 + (unsigned __int16)v3;
  if ((v7 & 0x10000) != 0)
  {
LABEL_15:
    __break(1u);
    return result;
  }

  if (v4 < 0) {
    uint64_t v8 = (unsigned __int16)v7;
  }
  else {
    uint64_t v8 = -(uint64_t)(unsigned __int16)v7;
  }
  *a2 = v8;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int16@<X0>( void *result@<X0>, _WORD *a2@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  if (v4 <= -32769) {
    goto LABEL_6;
  }
  if (v4 >= 0x8000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int16( uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt16( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt16( uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

__int16 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int16@<X0>( __int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result + *a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int16.+ infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result = (a1 + a2);
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int16( __int16 *result, __int16 *a2)
{
  int v2 = *result + *a2;
  else {
    __break(1u);
  }
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int16@<X0>( __int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result - *a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int16.- infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result = (a1 - a2);
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int16( __int16 *result, __int16 *a2)
{
  int v2 = *result - *a2;
  else {
    __break(1u);
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a2 >= *a1;
}

BOOL static Int16.<= infix(_:_:)(__int16 a1, __int16 a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a1 >= *a2;
}

BOOL static Int16.>= infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a2 < *a1;
}

void Int16.hash(into:)(int a1, Swift::UInt16 a2)
{
}

Swift::Int __swiftcall Int16._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 2LL);
}

uint64_t Int16.hashValue.getter(unsigned __int16 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, a1, 2LL);
}

void protocol witness for Hashable.hash(into:) in conformance Int16()
{
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int16(uint64_t a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 2LL);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Int16( unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 == *a2;
}

uint64_t Int16._toCustomAnyHashable()@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int16>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int16@<X0>( uint64_t a1@<X8>)
{
  __int16 v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int16>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a1 = v3;
  return result;
}

uint64_t UInt32._value.setter(uint64_t result)
{
  *unsigned __int16 v1 = result;
  return result;
}

uint64_t (*UInt32._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt32 because it is either infinite or NaN",  80LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1858uLL,  0);
  }
  __asm { FCVT            S0, H0 }

  if (_S0 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt32 because the result would be less than UInt32.min",  92LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x185BuLL,  0);
  }
  return _S0;
}

unint64_t UInt32.init(exactly:)(float _S0)
{
  __asm { FCVT            S1, H0 }

  if (_S1 <= -1.0)
  {
    uint64_t v10 = 0LL;
    LOBYTE(v9) = 1;
  }

  else
  {
    float v6 = _S0;
    _S0 = truncf(_S1);
    __asm
    {
      FCVT            H0, S0
      FCVT            S0, H0
    }

    BOOL v9 = (~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1;
    uint64_t v10 = _S1;
    if (v9) {
      uint64_t v10 = 0LL;
    }
  }

  return v10 | ((unint64_t)v9 << 32);
}

Swift::UInt32 __swiftcall UInt32.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt32 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x18A6uLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt32 because the result would be less than UInt32.min",  90LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x18A9uLL,  0);
  }
  if (a1 >= 4295000000.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt32 because the result would be greater than UInt32.max",  93LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x18ACuLL,  0);
  }
  return a1;
}

Swift::UInt32_optional __swiftcall UInt32.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 4295000000.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = exactly;
  }
  return (Swift::UInt32_optional)(v5 | (v4 << 32));
}

Swift::UInt32 __swiftcall UInt32.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt32 because it is either infinite or NaN",  79LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x18EEuLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt32 because the result would be less than UInt32.min",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x18F1uLL,  0);
  }
  if (a1 >= 4294967300.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt32 because the result would be greater than UInt32.max",  94LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x18F4uLL,  0);
  }
  return a1;
}

Swift::UInt32_optional __swiftcall UInt32.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 4294967300.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = exactly;
  }
  return (Swift::UInt32_optional)(v5 | (v4 << 32));
}

unsigned int *static UInt32.-= infix(_:_:)(unsigned int *result, unsigned int a2)
{
  if (*result < a2) {
    __break(1u);
  }
  else {
    *result -= a2;
  }
  return result;
}

_DWORD *static UInt32.*= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  unint64_t v2 = *result * (unint64_t)a2;
  if ((v2 & 0xFFFFFFFF00000000LL) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

_DWORD *static UInt32./= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x19E2uLL,  0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.subtractingReportingOverflow(_:)(Swift::UInt32 a1)
{
  Swift::UInt32 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.multipliedReportingOverflow(by:)(Swift::UInt32 by)
{
  Swift::UInt32 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.dividedReportingOverflow(by:)(Swift::UInt32 by)
{
  if (by) {
    v1 /= by;
  }
  Swift::UInt32 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.remainderReportingOverflow(dividingBy:)( Swift::UInt32 dividingBy)
{
  if (dividingBy) {
    v1 %= dividingBy;
  }
  Swift::UInt32 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

_DWORD *static UInt32.%= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1AB6uLL,  0);
  }
  *result %= a2;
  return result;
}

uint64_t UInt32._lowWord.getter(uint64_t result)
{
  return result;
}

uint64_t UInt32.Words._value.setter(uint64_t result)
{
  *Swift::UInt32 v1 = result;
  return result;
}

uint64_t (*UInt32.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.Words.count.getter()
{
  return 1LL;
}

uint64_t UInt32.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t UInt32.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t UInt32.Words.indices.getter()
{
  return 0LL;
}

uint64_t UInt32.Words.subscript.getter(uint64_t a1, unsigned int a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1BB3uLL,  0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1BB4uLL,  0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt32.Words( uint64_t *a1, uint64_t *a2))()
{
  *a1 = UInt32.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt32.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt32.Words( uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt32_low_UInt32 __swiftcall UInt32.multipliedFullWidth(by:)(Swift::UInt32 by)
{
  Swift::UInt32 v2 = __ROR8__(v1 * (unint64_t)by, 32);
  result.Swift::UInt64 low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt32_remainder_UInt32 __swiftcall UInt32.dividingFullWidth(_:)( Swift::tuple_quotient_UInt32_remainder_UInt32 result)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1C19uLL,  0);
  }
  if (result.quotient >= v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1C1BuLL,  0);
  }
  Swift::UInt32 v3 = (result.remainder | (__PAIR64__(v2, result.quotient) << 32)) / v1;
  result.quotient = v3;
  return result;
}

Swift::UInt32 __swiftcall UInt32.signum()()
{
  return v0 != 0;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt32()
{
  return 32LL;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt32(_DWORD *a1@<X8>)
{
  *a1 = -1;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt32( _DWORD *a1, _DWORD *a2)
{
  BOOL v3 = __CFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt32( _DWORD *a1, _DWORD *a2)
{
  BOOL v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt32( _DWORD *a1, unsigned int *a2)
{
  unint64_t v3 = *v2 * (unint64_t)*a2;
  *a1 = v3;
  return (v3 & 0xFFFFFFFF00000000LL) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt32( _DWORD *a1, unsigned int *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt32( _DWORD *a1, unsigned int *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

_DWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt32( _DWORD *result, _DWORD *a2, unsigned int *a3)
{
  unint64_t v4 = *v3 * (unint64_t)*a3;
  *Swift::tuple_high_UInt32_low_UInt32 result = HIDWORD(v4);
  *a2 = v4;
  return result;
}

Swift::UInt32 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt32( Swift::UInt32 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  Swift::UInt32 result = UInt32.dividingFullWidth(_:)((Swift::tuple_high_UInt32_low_UInt32)__PAIR64__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt32( _DWORD *result, _DWORD *a2)
{
  *result >>= *a2;
  return result;
}

_DWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt32@<X0>( _DWORD *result@<X0>, unint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  if (a2 >> 9 <= 0x10 && (a2 & 1) == 0) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt32@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _DWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32 and conformance UInt32,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v49 = a6;
  uint64_t v9 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v48 = (char *)&v44 - v12;
  uint64_t v52 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  char v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v51 = (char *)&v44 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v44 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v44 - v20;
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v23 = v22(a2, a3);
  uint64_t v50 = a1;
  if ((v23 & 1) != 0)
  {
    uint64_t v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    char v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 32LL))( v21,  v19,  a2);
    uint64_t v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    v28(v21, a2);
    a1 = v50;
  }

  char v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v30 = a1;
  if (v29(a2, a3) >= 32)
  {
    uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    unsigned int v53 = -1;
    char v31 = v22(a2, a3);
    uint64_t v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 33)
      {
        unint64_t v33 = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        uint64_t v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 40LL))( v51,  v19,  a2);
        uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        unsigned int v37 = v53;
        char v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        uint64_t v30 = v50;
        if ((v34 & 1) != 0)
        {
          unsigned int v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39) {
            goto LABEL_14;
          }
        }

        else
        {
          v36(v38, a2);
        }

        goto LABEL_16;
      }
    }

    else if (v32 <= 32)
    {
      uint64_t v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      unsigned int v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      uint64_t v30 = v50;
      if (v53 < v41) {
        goto LABEL_14;
      }
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }

    (*(void (**)(unsigned int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    uint64_t v35 = v51;
    char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v19,  v51,  a2);
    uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    uint64_t v30 = v50;
    if ((v40 & 1) != 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_16;
  }

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt32@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt32 and conformance UInt32((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt32()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt32()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_DWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x19E2uLL,  0);
  }
  *a3 = *result / *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt32( _DWORD *result, _DWORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x19E2uLL,  0);
  }
  *result /= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1AB6uLL,  0);
  }
  *a3 = *result % *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt32( _DWORD *result, _DWORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1AB6uLL,  0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt32.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt32@<X0>( unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int *a5@<X8>)
{
  uint64x2_t v126 = a5;
  uint64_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v114 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  int64_t v123 = (char *)&v114 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v117 = (char *)&v114 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v114 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v124 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v114 - v29;
  unsigned int v122 = *a1;
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v121 = v19;
  unint64_t v127 = v31;
  if ((v32 & 1) != 0)
  {
    unint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      int64_t v129 = -32LL;
      uint64_t v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -32) {
        goto LABEL_24;
      }
    }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt32( unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    char v32 = *(unsigned int **)(a4 + 128);
    uint64_t v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -32LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if (v37 < -32) {
        goto LABEL_24;
      }
    }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt32@<X0>( unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int *a5@<X8>)
{
  uint64x2_t v126 = a5;
  uint64_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v114 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  int64_t v123 = (char *)&v114 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v117 = (char *)&v114 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v114 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v124 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  char v30 = (char *)&v114 - v29;
  unsigned int v122 = *a1;
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v121 = v19;
  unint64_t v127 = v31;
  if ((v32 & 1) != 0)
  {
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      int64_t v129 = -32LL;
      unint64_t v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -32) {
        goto LABEL_24;
      }
    }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt32( unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    char v32 = *(unsigned int **)(a4 + 128);
    uint64_t v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -32LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if (v37 < -32) {
        goto LABEL_24;
      }
    }

int *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt32( int *result, int *a2, unsigned int *a3)
{
  unsigned int v4 = *a3;
  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x19E2uLL,  0);
  }
  unsigned int v5 = *v3;
  *a2 = *v3 % v4;
  *uint64_t result = v5 / v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt32(unsigned int *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt32(_DWORD *a1@<X8>)
{
  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt32@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v66 = a4;
  uint64_t v71 = a5;
  uint64_t v8 = *(void *)(a3[3] + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v62 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  uint64_t v65 = (char *)&v62 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v70 = (char *)&v62 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v62 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v62 - v21;
  unint64_t v68 = (uint64_t (*)(uint64_t, void *))a3[8];
  char v23 = v68(a2, a3);
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  uint64_t v72 = a1;
  char v69 = v24;
  v24(v22, a1, a2);
  unint64_t v67 = v20;
  unint64_t v63 = AssociatedTypeWitness;
  uint64_t v64 = v8;
  char v62 = v12;
  if ((v23 & 1) != 0)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a2, v8);
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3[4] + 8LL) + 16LL))(v22, v20, a2);
    uint64_t v27 = *(void (**)(char *, uint64_t))(v13 + 8);
    v27(v20, a2);
    uint64_t v28 = v22;
    uint64_t v29 = v27;
    v27(v28, a2);
    uint64_t v31 = v71;
    uint64_t v30 = v72;
    uint64_t v32 = v13;
    uint64_t v33 = a3;
    if ((v26 & 1) != 0) {
      goto LABEL_17;
    }
  }

  else
  {
    uint64_t v34 = v22;
    uint64_t v29 = *(void (**)(char *, uint64_t))(v13 + 8);
    v29(v34, a2);
    uint64_t v30 = v72;
    uint64_t v32 = v13;
    uint64_t v33 = a3;
  }

  uint64_t v35 = (uint64_t (*)(uint64_t, void *))v33[16];
  uint64_t v36 = v35(a2, v33);
  uint64_t v37 = v70;
  v69(v70, v30, a2);
  if (v36 <= 31)
  {
    v29(v37, a2);
    uint64_t v31 = v71;
    goto LABEL_7;
  }

  char v41 = v29;
  unsigned int v73 = -1;
  char v42 = v68(a2, v33);
  uint64_t v43 = v35(a2, v33);
  if ((v42 & 1) != 0)
  {
    if (v43 < 33)
    {
      uint64_t v47 = v63;
      uint64_t v46 = v64;
      unint64_t v48 = swift_getAssociatedConformanceWitness( v64,  a2,  v63,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v49 = v62;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v48 + 8))( &qword_18180BE68,  256LL,  v47,  v48);
      unint64_t v50 = v67;
      (*(void (**)(char *, uint64_t, uint64_t))(v46 + 24))(v49, a2, v46);
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33[4] + 8LL) + 40LL))( v37,  v50,  a2);
      unint64_t v51 = v50;
      uint64_t v29 = v41;
      v41(v51, a2);
      char v52 = v37;
      unsigned int v53 = v73;
      uint64_t v54 = v65;
      (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v65, v52, a2);
      if ((v46 & 1) == 0)
      {
        v41(v54, a2);
        uint64_t v31 = v71;
        uint64_t v30 = v72;
        goto LABEL_7;
      }

      unsigned int v55 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
      v41(v54, a2);
      BOOL v56 = v53 >= v55;
      goto LABEL_16;
    }

unsigned int *protocol witness for static Numeric.* infix(_:_:) in conformance UInt32@<X0>( unsigned int *result@<X0>, unsigned int *a2@<X1>, _DWORD *a3@<X8>)
{
  unint64_t v3 = *result * (unint64_t)*a2;
  if ((v3 & 0xFFFFFFFF00000000LL) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

unint64_t static UInt32.* infix(_:_:)(unsigned int a1, unsigned int a2)
{
  unint64_t result = a1 * (unint64_t)a2;
  if ((result & 0xFFFFFFFF00000000LL) != 0) {
    __break(1u);
  }
  return result;
}

_DWORD *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt32( _DWORD *result, unsigned int *a2)
{
  unint64_t v2 = *result * (unint64_t)*a2;
  if ((v2 & 0xFFFFFFFF00000000LL) != 0) {
    __break(1u);
  }
  else {
    *unint64_t result = v2;
  }
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt32()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10LL, 0)._countAndFlagsBits;
}

_DWORD *protocol witness for Strideable.distance(to:) in conformance UInt32@<X0>( _DWORD *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = (*result - *v2);
  if (*result < *v2) {
    uint64_t v3 = -(uint64_t)(*v2 - *result);
  }
  *a2 = v3;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt32@<X0>( unint64_t *result@<X0>, unsigned int *a2@<X8>)
{
  unint64_t v3 = *result;
  unsigned int v4 = *v2;
  if ((*result & 0x8000000000000000LL) == 0)
  {
    if (HIDWORD(v3)) {
      goto LABEL_10;
    }
    BOOL v5 = __CFADD__(v4, (_DWORD)v3);
    v4 += v3;
    if (!v5) {
      goto LABEL_9;
    }
    __break(1u);
  }

  unint64_t v6 = -(uint64_t)v3;
  if (HIDWORD(v6)) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  BOOL v5 = v4 >= v6;
  v4 -= v6;
  if (!v5)
  {
    __break(1u);
    return result;
  }

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt32( uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt32( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

_DWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt32( _DWORD *result, _DWORD *a2)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt32( _DWORD *result, _DWORD *a2)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

uint64_t UInt32.hashValue.getter(unsigned int a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, a1, 4LL);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance UInt32()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, *v0, 4LL);
}

uint64_t UInt32._toCustomAnyHashable()@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt32>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt32@<X0>( uint64_t a1@<X8>)
{
  int v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt32>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a1 = v3;
  return result;
}

uint64_t Int32._value.setter(uint64_t result)
{
  *Swift::UInt32 v1 = result;
  return result;
}

uint64_t (*Int32._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to Int32 because it is either infinite or NaN",  79LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E43uLL,  0);
  }
  __asm { FCVT            S0, H0 }

  return (int)_S0;
}

uint64_t Int32.init(exactly:)(float _S0)
{
  __asm { FCVT            S1, H0 }

  float v6 = _S0;
  _S0 = truncf(_S1);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }

  BOOL v9 = (~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1;
  uint64_t v10 = v9;
  if (v9) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = (int)_S1;
  }
  return v11 | (v10 << 32);
}

Swift::Int32 __swiftcall Int32.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int32 because it is either infinite or NaN",  77LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E8EuLL,  0);
  }
  if (a1 <= -2147500000.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int32 because the result would be less than Int32.min",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E91uLL,  0);
  }
  if (a1 >= 2147500000.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int32 because the result would be greater than Int32.max",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1E94uLL,  0);
  }
  return (int)a1;
}

Swift::Int32_optional __swiftcall Int32.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -2147500000.0;
  if (exactly >= 2147500000.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = (int)exactly;
  }
  return (Swift::Int32_optional)(v5 | (v4 << 32));
}

Swift::Int32 __swiftcall Int32.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int32 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1ED6uLL,  0);
  }
  if (a1 <= -2147483650.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int32 because the result would be less than Int32.min",  89LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1ED9uLL,  0);
  }
  if (a1 >= 2147483650.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int32 because the result would be greater than Int32.max",  92LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1EDCuLL,  0);
  }
  return (int)a1;
}

Swift::Int32_optional __swiftcall Int32.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -2147483650.0;
  if (exactly >= 2147483650.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = (int)exactly;
  }
  return (Swift::Int32_optional)(v5 | (v4 << 32));
}

_DWORD *static Int32.-= infix(_:_:)(_DWORD *result, int a2)
{
  if (__OFSUB__(*result, a2)) {
    __break(1u);
  }
  else {
    *result -= a2;
  }
  return result;
}

int *static Int32.*= infix(_:_:)(int *result, int a2)
{
  uint64_t v2 = *result * (uint64_t)a2;
  else {
    __break(1u);
  }
  return result;
}

int *static Int32./= infix(_:_:)(int *result, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FCAuLL,  0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FD1uLL,  0);
  }
  *uint64_t result = v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.addingReportingOverflow(_:)(Swift::Int32 a1)
{
  Swift::Int32 v2 = v1 + a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.subtractingReportingOverflow(_:)(Swift::Int32 a1)
{
  Swift::Int32 v2 = v1 - a1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.multipliedReportingOverflow(by:)(Swift::Int32 by)
{
  Swift::Int32 v2 = v1 * by;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.dividedReportingOverflow(by:)(Swift::Int32 by)
{
  if (by)
  {
    if (by == -1 && v1 == 0x80000000) {
      signed int v1 = 0x80000000;
    }
    else {
      v1 /= by;
    }
  }

  Swift::Int32 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.remainderReportingOverflow(dividingBy:)( Swift::Int32 dividingBy)
{
  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 0x80000000) {
      Swift::Int32 v1 = 0;
    }
    else {
      v1 %= dividingBy;
    }
  }

  Swift::Int32 v2 = v1;
  result.overfSwift::UInt64 low = v1;
  result.partialValue = v2;
  return result;
}

int *static Int32.%= infix(_:_:)(int *result, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20AFuLL,  0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20B4uLL,  0);
  }
  *Swift::tuple_partialValue_Int32_overflow_Bool result = v2 % a2;
  return result;
}

_DWORD *static Int32.&= infix(_:_:)(_DWORD *result, int a2)
{
  *result &= a2;
  return result;
}

_DWORD *static Int32.|= infix(_:_:)(_DWORD *result, int a2)
{
  *result |= a2;
  return result;
}

_DWORD *static Int32.^= infix(_:_:)(_DWORD *result, int a2)
{
  *result ^= a2;
  return result;
}

int *static Int32.&>>= infix(_:_:)(int *result, char a2)
{
  *result >>= a2;
  return result;
}

_DWORD *static Int32.&<<= infix(_:_:)(_DWORD *result, char a2)
{
  *result <<= a2;
  return result;
}

uint64_t static Int32.bitWidth.getter()
{
  return 32LL;
}

uint64_t Int32.leadingZeroBitCount.getter(unsigned int a1)
{
  return __clz(a1);
}

uint64_t Int32._lowWord.getter(uint64_t result)
{
  return (int)result;
}

uint64_t Int32.trailingZeroBitCount.getter(unsigned int a1)
{
  return __clz(__rbit32(a1));
}

uint64_t Int32.nonzeroBitCount.getter(__int32 a1, int8x8_t a2)
{
  a2.i32[0] = a1;
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(a2);
  v2.i16[0] = vaddlv_u8(v2);
  return v2.u32[0];
}

uint64_t Int32.Words._value.setter(uint64_t result)
{
  *Swift::Int32 v1 = result;
  return result;
}

uint64_t (*Int32.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.Words.count.getter()
{
  return 1LL;
}

uint64_t Int32.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t Int32.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t Int32.Words.indices.getter()
{
  return 0LL;
}

Swift::Int __swiftcall Int32.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1LL);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int32.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1LL);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int32.Words.subscript.getter(uint64_t a1, int a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x21B1uLL,  0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x21B2uLL,  0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int32.Words( uint64_t *a1, uint64_t *a2))()
{
  *a1 = Int32.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt32.Words@<X0>( void *result@<X0>, uint64_t a2@<X8>)
{
  if ((*result & 0x8000000000000000LL) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  int v4 = *v2;
  *(void *)a2 = *result;
  *(void *)(a2 + 8) = v3;
  *(_DWORD *)(a2 + 16) = v4;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int32.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int32.Words( uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t Int32.magnitude.getter(uint64_t result)
{
  else {
    return -(int)result;
  }
}

Swift::tuple_high_Int32_low_UInt32 __swiftcall Int32.multipliedFullWidth(by:)(Swift::Int32 by)
{
  Swift::Int32 v2 = __ROR8__(v1 * (uint64_t)by, 32);
  result.Swift::UInt64 low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_Int32_remainder_Int32 __swiftcall Int32.dividingFullWidth(_:)( Swift::tuple_quotient_Int32_remainder_Int32 result)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2230uLL,  0);
  }
  if (v1 == -1 && (result.remainder | (__PAIR64__(v2, result.quotient) << 32)) == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2BEEuLL,  0);
  }
  uint64_t v3 = (uint64_t)(result.remainder | (__PAIR64__(v2, result.quotient) << 32)) / v1;
  if (v3 != (int)v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x223AuLL,  0);
  }
  result.quotient = v3;
  return result;
}

uint64_t Int32.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1);
}

Swift::Int32 __swiftcall Int32.signum()()
{
  return (v0 > 0) | (v0 >> 31);
}

BOOL static Int32.> infix(_:_:)(int a1, int a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = 0x7FFFFFFF;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = 0x80000000;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int32( _DWORD *a1, _DWORD *a2)
{
  BOOL v3 = __OFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int32( _DWORD *a1, _DWORD *a2)
{
  BOOL v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int32( _DWORD *a1, int *a2)
{
  uint64_t v3 = *v2 * (uint64_t)*a2;
  *a1 = v3;
  return v3 != (int)v3;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int32( signed int *a1, int *a2)
{
  int v3 = *a2;
  signed int v4 = *v2;
  if (*a2)
  {
    if (v3 == -1 && v4 == 0x80000000)
    {
      uint64_t v6 = 1LL;
      signed int v4 = 0x80000000;
    }

    else
    {
      uint64_t v6 = 0LL;
      v4 /= v3;
    }
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  *a1 = v4;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int32( _DWORD *a1, int *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if (!*a2) {
    goto LABEL_9;
  }
  if (v3 == -1 && v4 == 0x80000000)
  {
    int v4 = 0;
LABEL_9:
    uint64_t v6 = 1LL;
    goto LABEL_7;
  }

  uint64_t v6 = 0LL;
  v4 %= v3;
LABEL_7:
  *a1 = v4;
  return v6;
}

_DWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int32( _DWORD *result, _DWORD *a2, int *a3)
{
  uint64_t v4 = *v3 * (uint64_t)*a3;
  *Swift::tuple_high_Int32_low_UInt32 result = HIDWORD(v4);
  *a2 = v4;
  return result;
}

Swift::Int32 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int32( Swift::Int32 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  Swift::Int32 result = Int32.dividingFullWidth(_:)((Swift::tuple_high_Int32_low_UInt32)__PAIR64__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int32()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int32()
{
  return __clz(*v0);
}

unsigned int *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int32@<X0>( unsigned int *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = bswap32(*result);
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = bswap32(*v1);
}

int *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int32@<X0>( int *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

int *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int32( int *result, _DWORD *a2)
{
  *result >>= *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result << *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int32( _DWORD *result, _DWORD *a2)
{
  *result <<= *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_DWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_DWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_DWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int32@<X0>( _DWORD *result@<X0>, unint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  if (a2 >> 8 <= 0x20) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int32@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int32 and conformance Int32(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int32@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _DWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int32 and conformance Int32,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _DWORD *a6@<X8>)
{
  unint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, a2, v13, a3);
  if ((BYTE4(v38) & 1) != 0)
  {
    int v38 = (char *)static String._createEmpty(withInitialCapacity:)(80LL);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000LL) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._unint64_t object = (void *)0x80000001818B69D0LL;
      v26._uint64_t countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000LL) == 0)
      {
        uint64_t v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._uint64_t countAndFlagsBits = 0xD00000000000002ELL;
        v37._unint64_t object = (void *)0x80000001818B69F0LL;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v38,  v39,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a6 = (_DWORD)v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int32@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  uint64_t v72 = a4;
  uint64_t v73 = a5;
  uint64_t v76 = a6;
  char v69 = *(const char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v69,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v68 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  uint64_t v70 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v74 = (char *)&v68 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  int64_t v20 = (char *)&v68 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  char v75 = (char *)&v68 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v68 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v68 - v26;
  uint64_t v78 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v28 = v78(a2, a3);
  uint64_t v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  uint64_t v79 = a1;
  uint64_t v77 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    uint64_t v71 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v30 = v71(a2, a3);
    int64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 32)
    {
      int64_t v32 = v77;
      v77(v25, v79, a2);
      signed int v80 = 0x80000000;
      char v33 = v25;
      uint64_t v34 = v78;
      if ((v78(a2, a3) & 1) != 0)
      {
        uint64_t v35 = v71;
        if (v71(a2, a3) < 32)
        {
          uint64_t v36 = v75;
          v32(v75, v33, a2);
          signed int v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          BOOL v38 = v80 <= v37;
LABEL_18:
          char v42 = v33;
LABEL_19:
          uint64_t v46 = v79;
          if (!v38) {
LABEL_40:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
          goto LABEL_21;
        }

        uint64_t v45 = v75;
        (*(void (**)(signed int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v80, v72, v73, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v33,  v45,  a2);
        v31(v45, a2);
        char v42 = v33;
        goto LABEL_11;
      }

      char v40 = v34(a2, a3);
      uint64_t v41 = v71(a2, a3);
      char v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 32)
        {
          uint64_t v49 = v69;
          unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v69,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
          unint64_t v51 = v75;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          char v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v51,  a2);
          v31(v51, a2);
          unsigned int v53 = v70;
          char v33 = v42;
          int64_t v32 = v77;
          v77(v70, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_40;
          }

          signed int v54 = v80;
          signed int v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          BOOL v38 = v54 <= v55;
          uint64_t v35 = v71;
          goto LABEL_18;
        }

        uint64_t v43 = v75;
        (*(void (**)(signed int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v80, v72, v73, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v43,  a2);
        v31(v43, a2);
        int64_t v32 = v77;
        uint64_t v35 = v71;
LABEL_11:
        uint64_t v46 = v79;
        if ((v44 & 1) != 0) {
          goto LABEL_40;
        }
LABEL_21:
        v31(v42, a2);
        unint64_t v39 = v78;
        goto LABEL_24;
      }

      if (v41 < 32)
      {
        uint64_t v47 = v75;
        int64_t v32 = v77;
        v77(v75, v42, a2);
        signed int v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        BOOL v38 = v80 <= v48;
        uint64_t v35 = v71;
        goto LABEL_19;
      }

      v31(v33, a2);
    }

    int64_t v32 = v77;
    unint64_t v39 = v78;
    uint64_t v35 = v71;
  }

  else
  {
    int64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    uint64_t v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    int64_t v32 = v77;
    unint64_t v39 = v78;
  }

  uint64_t v46 = v79;
LABEL_24:
  uint64_t v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 33)
  {
    v31(v20, a2);
    goto LABEL_26;
  }

  uint64_t v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 32 && (v39(a2, a3) & 1) == 0)
  {
LABEL_26:
    uint64_t v57 = v74;
    v32(v74, v46, a2);
    int v82 = 0x7FFFFFFF;
    char v58 = v39(a2, a3);
    uint64_t v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 32)
      {
        unint64_t v60 = *(void (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        unsigned int v61 = &v82;
        goto LABEL_35;
      }
    }

    else if (v59 > 31)
    {
      int v81 = 0x7FFFFFFF;
      unint64_t v60 = *(void (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      unsigned int v61 = &v81;
LABEL_35:
      uint64_t v64 = v75;
      v60(v61, v72, v73, a2, a3);
      char v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v64,  v57,  a2);
      v31(v64, a2);
      if ((v65 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_36;
    }

    unint64_t v63 = v75;
    v32(v75, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_36:
    v31(v57, a2);
  }

  int v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *uint64_t v76 = v66;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt32@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  int v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int32@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int32 and conformance Int32((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int32()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int32()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int32()
{
  return __clz(__rbit32(*v0));
}

_DWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, int *a2@<X1>, int *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FCAuLL,  0);
  }
  if (*result == 0x80000000 && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FD1uLL,  0);
  }
  *a3 = *result / v3;
  return result;
}

uint64_t static Int32./ infix(_:_:)(int a1, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FCAuLL,  0);
  }
  if (a1 == 0x80000000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FD1uLL,  0);
  }
  return (a1 / a2);
}

int *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FCAuLL,  0);
  }
  int v3 = *result;
  if (v2 == -1 && v3 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FD1uLL,  0);
  }
  *uint64_t result = v3 / v2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, int *a2@<X1>, int *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20AFuLL,  0);
  }
  if (*result == 0x80000000 && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20B4uLL,  0);
  }
  *a3 = *result % v3;
  return result;
}

uint64_t static Int32.% infix(_:_:)(int a1, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20AFuLL,  0);
  }
  if (a1 == 0x80000000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20B4uLL,  0);
  }
  return (a1 % a2);
}

int *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20AFuLL,  0);
  }
  int v3 = *result;
  if (v2 == -1 && v3 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20B4uLL,  0);
  }
  *uint64_t result = v3 % v2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int32@<X0>( _DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int32( _DWORD *result, _DWORD *a2)
{
  *result &= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int32( _DWORD *result, _DWORD *a2)
{
  *result |= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int32.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_DWORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int32( _DWORD *result, _DWORD *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int32@<X0>( int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int *a5@<X8>)
{
  uint64_t v120 = a5;
  int64x2_t v115 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v115,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64x2_t v113 = (char *)&v111 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v111 = (char *)&v111 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v111 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v117 = (char *)&v111 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  BOOL v112 = (char *)&v111 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v111 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v119 = (char *)&v111 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v111 - v28;
  int v118 = *a1;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v121 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    unint64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v124 = -32LL;
        char v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        uint64_t v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v115;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -32;
    }

    else
    {
      if (v39 > 64)
      {
        uint64_t v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -32;
    }

    uint64_t v30 = v121;
    int64_t v32 = v122;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 >= -32) {
      goto LABEL_20;
    }
LABEL_19:
    int v54 = 0;
    signed int v55 = v120;
    goto LABEL_50;
  }

  int64_t v124 = -32LL;
  char v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
LABEL_20:
  unint64_t v122 = v32;
  char v56 = v30(a3, a4);
  uint64_t v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64) {
      goto LABEL_22;
    }
  }

  else if (v57 > 63)
  {
LABEL_22:
    int64_t v124 = 32LL;
    unint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v6_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    uint64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v62(v29, a3);
LABEL_31:
    int v54 = v118 >> 31;
    signed int v55 = v120;
    goto LABEL_50;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v62(v29, a3);
  if (v77 > 32) {
    goto LABEL_31;
  }
LABEL_23:
  unint64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v64 = v119;
  v63(v119, a2, a3);
  char v65 = v121(a3, a4);
  int v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    uint64_t v76 = v25;
    uint64_t v68 = v119;
    char v69 = v117;
    goto LABEL_33;
  }

  uint64_t v67 = v122(a3, a4);
  v62(v25, a3);
  uint64_t v68 = v119;
  char v69 = v117;
  if (v67 < 65) {
    goto LABEL_34;
  }
  uint64_t v70 = v112;
  v66(v112, v119, a3);
  int64_t v124 = 0x8000000000000000LL;
  uint64_t v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    char v91 = v71(a3, a4);
    uint64_t v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        unint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        uint64_t v70 = v112;
        char v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
        goto LABEL_55;
      }

      unint64_t v104 = AssociatedTypeWitness;
      uint64_t v103 = (void (**)(char *, uint64_t, const char *))v115;
      unint64_t v105 = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      int64_t v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))( &qword_18180BE68,  256LL,  v104,  v105);
      v103[3](v106, a3, (const char *)v103);
      unint64_t v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
      v62(v29, a3);
      int64_t v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }

      int64_t v109 = v124;
      uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      BOOL v47 = v110 < v109;
      uint64_t v68 = v119;
      uint64_t v76 = v112;
      if (!v47) {
        goto LABEL_33;
      }
    }

    else
    {
      if (v92 > 64)
      {
        uint64_t v76 = v112;
        goto LABEL_33;
      }

      uint64_t v101 = v112;
      v66(v29, v112, a3);
      uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      uint64_t v76 = v101;
      if (v102 >= v124) {
        goto LABEL_33;
      }
    }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int32( int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    char v31 = v19;
    int64_t v32 = *(int **)(a4 + 128);
    uint64_t v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -32LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) == 0) {
        goto LABEL_19;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      uint64_t v39 = a1;
      uint64_t v40 = v31;
      if (v37 >= -32) {
        goto LABEL_19;
      }
    }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int32@<X0>( int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int *a5@<X8>)
{
  uint64_t v120 = a5;
  int64x2_t v115 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v115,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64x2_t v113 = (char *)&v111 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v111 = (char *)&v111 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v111 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v117 = (char *)&v111 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  BOOL v112 = (char *)&v111 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v111 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v118 = (char *)&v111 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v111 - v28;
  int v119 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v121 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    unint64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v124 = -32LL;
        uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        char v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v115;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -32;
    }

    else
    {
      if (v39 > 64)
      {
        char v30 = v121;
        int64_t v32 = v122;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -32;
    }

    char v30 = v121;
    int64_t v32 = v122;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 > -33) {
      goto LABEL_20;
    }
LABEL_19:
    int v54 = v119 >> 31;
    signed int v55 = v120;
    goto LABEL_50;
  }

  int64_t v124 = -32LL;
  uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
LABEL_20:
  unint64_t v122 = v32;
  char v56 = v30(a3, a4);
  uint64_t v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64) {
      goto LABEL_22;
    }
  }

  else if (v57 > 63)
  {
LABEL_22:
    int64_t v124 = 32LL;
    unint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v6_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    char v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v62(v29, a3);
LABEL_31:
    int v54 = 0;
    signed int v55 = v120;
    goto LABEL_50;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v62(v29, a3);
  if (v77 > 32) {
    goto LABEL_31;
  }
LABEL_23:
  uint64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v64 = v118;
  v63(v118, a2, a3);
  char v65 = v121(a3, a4);
  int v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    uint64_t v76 = v25;
    uint64_t v68 = v117;
    char v69 = v118;
    goto LABEL_33;
  }

  uint64_t v67 = v122(a3, a4);
  v62(v25, a3);
  uint64_t v68 = v117;
  char v69 = v118;
  if (v67 < 65) {
    goto LABEL_34;
  }
  uint64_t v70 = v112;
  v66(v112, v118, a3);
  int64_t v124 = 0x8000000000000000LL;
  uint64_t v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    char v91 = v71(a3, a4);
    uint64_t v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        unint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        uint64_t v70 = v112;
        char v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
        goto LABEL_55;
      }

      unint64_t v104 = AssociatedTypeWitness;
      uint64_t v103 = (void (**)(char *, uint64_t, const char *))v115;
      unint64_t v105 = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      int64_t v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))( &qword_18180BE68,  256LL,  v104,  v105);
      v103[3](v106, a3, (const char *)v103);
      unint64_t v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
      v62(v29, a3);
      int64_t v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }

      int64_t v109 = v124;
      uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      BOOL v47 = v110 < v109;
      char v69 = v118;
      uint64_t v76 = v112;
      if (!v47) {
        goto LABEL_33;
      }
    }

    else
    {
      if (v92 > 64)
      {
        uint64_t v76 = v112;
        goto LABEL_33;
      }

      uint64_t v101 = v112;
      v66(v29, v112, a3);
      uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      uint64_t v76 = v101;
      if (v102 >= v124) {
        goto LABEL_33;
      }
    }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int32( int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    int8x16_t v131 = v19;
    uint64_t v132 = a1;
    char v41 = v29(a3, a4);
    int64_t v32 = *(int **)(a4 + 128);
    uint64_t v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        int64_t v144 = -32LL;
        unint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        BOOL v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        if ((v48 & 1) != 0) {
          goto LABEL_18;
        }
        goto LABEL_19;
      }

      signed int v55 = v137;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      char v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
      unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        uint64_t v39 = v132;
        goto LABEL_18;
      }

      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }

    else
    {
      if (v42 >= 64)
      {
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        goto LABEL_19;
      }

      uint64_t v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }

    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -32) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  char v31 = v19;
  int64_t v32 = *(int **)(a4 + 128);
  uint64_t v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if (v33 < 64)
  {
    uint64_t v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    uint64_t v39 = a1;
    uint64_t v40 = v31;
    if (v37 > -33) {
      goto LABEL_19;
    }
LABEL_18:
    int v61 = *v39 >> 31;
    goto LABEL_60;
  }

  int64_t v144 = -32LL;
  uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  unint64_t v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  uint64_t v39 = a1;
  uint64_t v40 = v31;
  if ((v52 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  char v62 = v141(a3, a4);
  uint64_t v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
  }

  else if (v63 >= 64)
  {
LABEL_21:
    int64_t v144 = 32LL;
    int v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    uint64_t v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    char v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v68, a3);
    if ((v69 & 1) != 0) {
      goto LABEL_25;
    }
    goto LABEL_26;
  }

  uint64_t v71 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v70(v71, a3);
  if (v72 > 32)
  {
LABEL_25:
    int v61 = 0;
    goto LABEL_60;
  }

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int32( _DWORD *a1, int *a2, int *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int32(int *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int32(int *a1@<X8>)
{
  *a1 = (*v1 > 0) | (*v1 >> 31);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int32( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    uint64_t v10 = a3();
    if ((v10 & 0x10000000000LL) != 0) {
      uint64_t v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10LL, a4);
    }
    swift_bridgeObjectRelease(a2);
    unint64_t v11 = (v10 & 0x100000000uLL) >> 32;
    if ((v10 & 0x100000000LL) != 0) {
      int v12 = 0;
    }
    else {
      int v12 = v10;
    }
  }

  else
  {
    swift_bridgeObjectRelease(a2);
    int v12 = 0;
    LOBYTE(v11) = 1;
  }

  *(_DWORD *)a5 = v12;
  *(_BYTE *)(a5 + 4) = v11 & 1;
}

_DWORD *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  if (__OFSUB__(0, *result)) {
    __break(1u);
  }
  else {
    *a2 = -*result;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int32()
{
  if (__OFSUB__(0, *v0)) {
    __break(1u);
  }
  else {
    _DWORD *v0 = -*v0;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int32@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v91 = a4;
  uint64_t v95 = a5;
  uint64_t v88 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v88,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v11 = (char *)&v86 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v9);
  char v89 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v86 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v94 = (char *)&v86 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v93 = (char *)&v86 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v92 = (char *)&v86 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v86 - v25;
  MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v86 - v27;
  unint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v29 = v96(a2, a3);
  uint64_t v97 = v12;
  char v30 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v30(v28, a1, a2);
  char v90 = v17;
  BOOL v31 = (v29 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 32;
  int64_t v32 = *(void (**)(char *, uint64_t))(v97 + 8);
  v32(v28, a2);
  v30(v26, a1, a2);
  if (!v31)
  {
    v32(v26, a2);
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    char v38 = v94;
    uint64_t v40 = v95;
    goto LABEL_10;
  }

  signed int v98 = 0x80000000;
  uint64_t v33 = v96;
  if ((v96(a2, a3) & 1) != 0)
  {
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v35 = v34(a2, a3);
    char v38 = v94;
    if (v35 >= 32)
    {
      unint64_t v67 = *(void (**)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v68 = lazy protocol witness table accessor for type Int32 and conformance Int32(v35, v36, v37);
      unint64_t v87 = v34;
      char v69 = v92;
      v67(&v98, v91, v68, a2, a3);
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v69,  a2);
      uint64_t v70 = v69;
      uint64_t v34 = v87;
      v32(v70, a2);
      v32(v26, a2);
      uint64_t v40 = v95;
    }

    else
    {
      signed int v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v32(v26, a2);
      uint64_t v40 = v95;
      if (v98 > v39) {
        goto LABEL_40;
      }
    }

    goto LABEL_10;
  }

  char v55 = v33(a2, a3);
  unint64_t v87 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v56 = v87(a2, a3);
  if ((v55 & 1) != 0)
  {
    if (v56 > 32)
    {
      char v59 = *(void (**)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v60 = lazy protocol witness table accessor for type Int32 and conformance Int32(v56, v57, v58);
      int v61 = v92;
      v59(&v98, v91, v60, a2, a3);
      LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v61,  a2);
      v32(v61, a2);
      v32(v26, a2);
      char v38 = v94;
      uint64_t v40 = v95;
      uint64_t v34 = v87;
      goto LABEL_10;
    }

    signed int v80 = (void (**)(char *, uint64_t, const char *))v88;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v88,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v82 = v92;
    v80[3](v11, a2, (const char *)v80);
    LOBYTE(v8_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v26,  v82,  a2);
    v32(v82, a2);
    uint64_t v83 = v89;
    (*(void (**)(char *, char *, uint64_t))(v97 + 32))(v89, v26, a2);
    uint64_t v40 = v95;
    if ((v80 & 1) != 0)
    {
      v32(v83, a2);
LABEL_40:
      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
      int v64 = 0;
      char v66 = 1;
      goto LABEL_41;
    }

    signed int v84 = v98;
    signed int v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v83, a2);
    BOOL v72 = v84 <= v85;
    char v38 = v94;
    goto LABEL_39;
  }

  char v38 = v94;
  if (v56 < 32)
  {
    signed int v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v26, a2);
    BOOL v72 = v98 <= v71;
    uint64_t v40 = v95;
LABEL_39:
    uint64_t v34 = v87;
    if (!v72) {
      goto LABEL_40;
    }
LABEL_10:
    uint64_t v41 = v34(a2, a3);
    goto LABEL_11;
  }

  v32(v26, a2);
  uint64_t v40 = v95;
  uint64_t v34 = v87;
  uint64_t v41 = v87(a2, a3);
LABEL_11:
  uint64_t v42 = v41;
  uint64_t v43 = v93;
  v30(v93, a1, a2);
  if (v42 >= 33)
  {
    v32(v43, a2);
    v30(v38, a1, a2);
    goto LABEL_15;
  }

  uint64_t v44 = v34(a2, a3);
  v32(v43, a2);
  if (v44 != 32)
  {
    v30(v38, a1, a2);
    goto LABEL_25;
  }

  char v45 = v96(a2, a3);
  v30(v38, a1, a2);
  if ((v45 & 1) != 0)
  {
LABEL_25:
    uint64_t v63 = v38;
    goto LABEL_26;
  }

void protocol witness for Numeric.magnitude.getter in conformance Int32(int *a1@<X8>)
{
  int v2 = *v1;
  if (*v1 < 0) {
    int v2 = -v2;
  }
  *a1 = v2;
}

int *protocol witness for static Numeric.* infix(_:_:) in conformance Int32@<X0>( int *result@<X0>, int *a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t v3 = *result * (uint64_t)*a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int32.* infix(_:_:)(int a1, int a2)
{
  uint64_t result = a1 * (uint64_t)a2;
  return result;
}

int *protocol witness for static Numeric.*= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  uint64_t v2 = *result * (uint64_t)*a2;
  else {
    __break(1u);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int32()
{
  return _int64ToString(_:radix:uppercase:)( *v0,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

int *protocol witness for Strideable.distance(to:) in conformance Int32@<X0>( int *result@<X0>, uint64_t *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  if (((*v2 ^ *result) & 0x80000000) == 0)
  {
    BOOL v5 = __OFSUB__(v3, v4);
    int v6 = v3 - v4;
    if (!v5)
    {
      *a2 = v6;
      return result;
    }

    __break(1u);
    goto LABEL_15;
  }

  if (v4 >= 0) {
    int v7 = *v2;
  }
  else {
    int v7 = -v4;
  }
  if (v3 < 0) {
    int v3 = -v3;
  }
  BOOL v8 = __CFADD__(v7, v3);
  uint64_t v9 = (v7 + v3);
  if (v8)
  {
LABEL_15:
    __break(1u);
    return result;
  }

  if (v4 < 0) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = -v9;
  }
  *a2 = v10;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int32@<X0>( void *result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  if (v4 >= 0x80000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  }
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int32( uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt32( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt32( uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

_DWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

uint64_t static Int32.+ infix(_:_:)(int a1, int a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  uint64_t result = (a1 + a2);
  if (v2) {
    __break(1u);
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int32( _DWORD *result, _DWORD *a2)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int32@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int32( _DWORD *result, _DWORD *a2)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL static Int32.<= infix(_:_:)(int a1, int a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL static Int32.>= infix(_:_:)(int a1, int a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a2 < *a1;
}

void Int32.hash(into:)(int a1, Swift::UInt32 a2)
{
}

Swift::Int __swiftcall Int32._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 4LL);
}

uint64_t Int32.hashValue.getter(unsigned int a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0LL, a1, 4LL);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int32(uint64_t a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 4LL);
}

uint64_t Int32._toCustomAnyHashable()@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int32>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int32@<X0>( uint64_t a1@<X8>)
{
  int v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int32>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a1 = v3;
  return result;
}

uint64_t UInt64._value.setter(uint64_t result)
{
  *unsigned int v1 = result;
  return result;
}

uint64_t (*UInt64._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t UInt64.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt64 because it is either infinite or NaN",  80LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x245EuLL,  0);
  }
  __asm { FCVT            S0, H0 }

  if (_S0 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float16 value cannot be converted to UInt64 because the result would be less than UInt64.min",  92LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2461uLL,  0);
  }
  return (unint64_t)_S0;
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt64 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x24ACuLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt64 because the result would be less than UInt64.min",  90LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x24AFuLL,  0);
  }
  if (a1 >= 1.8447e19) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to UInt64 because the result would be greater than UInt64.max",  93LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x24B2uLL,  0);
  }
  return (unint64_t)a1;
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt64 because it is either infinite or NaN",  79LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x24F4uLL,  0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt64 because the result would be less than UInt64.min",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x24F7uLL,  0);
  }
  if (a1 >= 1.84467441e19) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt64 because the result would be greater than UInt64.max",  94LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x24FAuLL,  0);
  }
  return (unint64_t)a1;
}

void *static UInt64./= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x25E8uLL,  0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.addingReportingOverflow(_:)(Swift::UInt64 a1)
{
  BOOL v2 = __CFADD__(v1, a1);
  Swift::UInt64 v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.subtractingReportingOverflow(_:)(Swift::UInt64 a1)
{
  BOOL v2 = v1 >= a1;
  Swift::UInt64 v3 = v1 - a1;
  Swift::Bool v4 = !v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.multipliedReportingOverflow(by:)(Swift::UInt64 by)
{
  Swift::UInt64 v2 = v1 * by;
  Swift::Bool v3 = !is_mul_ok(v1, by);
  Swift::UInt64 v4 = v2;
  result.partialValue = v4;
  result.overfSwift::UInt64 low = v3;
  return result;
}

void *static UInt64.%= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x26BCuLL,  0);
  }
  *result %= a2;
  return result;
}

uint64_t UInt64.Words._value.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*UInt64.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.Words.count.getter()
{
  return 1LL;
}

uint64_t UInt64.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t UInt64.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t UInt64.Words.indices.getter()
{
  return 0LL;
}

uint64_t UInt64.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x27B9uLL, 0x27BAuLL);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt64.Words@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance [A]( a1,  a2,  a3,  (uint64_t (*)(void, uint64_t, void))specialized RandomAccessCollection.index(_:offsetBy:limitedBy:),  a4);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt64.Words( uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  UInt64.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

Swift::tuple_quotient_UInt64_remainder_UInt64 __swiftcall UInt64.dividingFullWidth(_:)( Swift::tuple_high_UInt64_low_UInt64 a1)
{
  Swift::UInt64 v2 = UInt64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x282DuLL, 0x282FuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt64()
{
  return 64LL;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt64(void *a1@<X8>)
{
  *a1 = -1LL;
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt64( Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 *a3)
{
  Swift::tuple_quotient_UInt64_remainder_UInt64 v6 = UInt64.dividingFullWidth(_:)(*a3);
  Swift::UInt64 result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64 and conformance UInt64,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt64@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt64 and conformance UInt64((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt64@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x25E8uLL,  0);
  }
  *a3 = *result / *a2;
  return result;
}

unint64_t static UInt64./ infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x25E8uLL,  0);
  }
  return a1 / a2;
}

void *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt64( void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x25E8uLL,  0);
  }
  *result /= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt64@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x26BCuLL,  0);
  }
  *a3 = *result % *a2;
  return result;
}

unint64_t static UInt64.% infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x26BCuLL,  0);
  }
  return a1 % a2;
}

void *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt64( void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x26BCuLL,  0);
  }
  *result %= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt64@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64x2_t v126 = a5;
  uint64_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v114 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v123 = (char *)&v114 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v117 = (char *)&v114 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v114 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v124 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  char v30 = (char *)&v114 - v29;
  unint64_t v122 = *a1;
  BOOL v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v121 = v19;
  unint64_t v127 = v31;
  if ((v32 & 1) == 0)
  {
    char v39 = v31(a3, a4);
    BOOL v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v40 = v125(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v40 > 64)
      {
        int64_t v129 = -64LL;
        uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
        v43(&v129, &type metadata for Int, v44, a3, a4);
        char v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
        uint64_t v33 = v125;
        if ((v45 & 1) != 0) {
          goto LABEL_24;
        }
        goto LABEL_18;
      }

      unint64_t v50 = AssociatedTypeWitness;
      unint64_t v51 = v120;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v53 = v118;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v50,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
      LOBYTE(v5_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t v54 = *(void (**)(char *, uint64_t))(v11 + 8);
      v54(v30, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v50 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
        unint64_t v55 = 0LL;
        goto LABEL_64;
      }

      uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
    }

    else
    {
      if (v40 >= 64)
      {
        uint64_t v33 = v125;
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    }

    uint64_t v33 = v125;
    if (v49 < -64) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v34 = v33(a3, a4);
  if (v34 >= 64)
  {
    int64_t v129 = -64LL;
    char v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v46(&v129, &type metadata for Int, v47, a3, a4);
    char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    if ((v48 & 1) != 0) {
      goto LABEL_24;
    }
  }

  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    if (v37 < -64) {
      goto LABEL_24;
    }
  }

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64( unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64( a1,  a2,  a3,  a4,  a5,  0x25E8uLL);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance UInt64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64 and conformance UInt64,  a5);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt64()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10LL, 0)._countAndFlagsBits;
}

uint64_t *protocol witness for Strideable.distance(to:) in conformance UInt64@<X0>( uint64_t *result@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *v2;
  uint64_t v5 = *result - *v2;
  if (*result >= (unint64_t)*v2)
  {
    if (*result - *v2 >= 0) {
      goto LABEL_5;
    }
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Distance is not representable in Int",  36LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x64AuLL,  0);
  }

  if (v4 - v3 < 0) {
    goto LABEL_6;
  }
  uint64_t v5 = v3 - v4;
LABEL_5:
  *a2 = v5;
  return result;
}

uint64_t UInt64.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0LL, a1);
}

void protocol witness for Hashable.hash(into:) in conformance UInt64()
{
}

uint64_t UInt64._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt64@<X0>( void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t Int64._value.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Int64._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.init(_:)(float a1)
{
  return Int.init(_:)( "Float16 value cannot be converted to Int64 because it is either infinite or NaN",  79LL,  0x2A60uLL,  a1);
}

uint64_t Int.init(_:)(const char *a1, uint64_t a2, unint64_t a3, float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a1,  a2,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a3,  0);
  }
  __asm { FCVT            S0, H0 }

  return (uint64_t)_S0;
}

Swift::Int64 __swiftcall Int64.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int64 because it is either infinite or NaN",  77LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2AABuLL,  0);
  }
  if (a1 <= -9.2234e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int64 because the result would be less than Int64.min",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2AAEuLL,  0);
  }
  if (a1 >= 9.2234e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Float value cannot be converted to Int64 because the result would be greater than Int64.max",  91LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2AB1uLL,  0);
  }
  return (uint64_t)a1;
}

Swift::Int64 __swiftcall Int64.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int64 because it is either infinite or NaN",  78LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2AF3uLL,  0);
  }
  if (a1 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int64 because the result would be less than Int64.min",  89LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2AF6uLL,  0);
  }
  if (a1 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int64 because the result would be greater than Int64.max",  92LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2AF9uLL,  0);
  }
  return (uint64_t)a1;
}

BOOL static Int64.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

uint64_t *static Int64./= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64./= infix(_:_:)(a1, a2, 0x2BE7uLL, 0x2BEEuLL);
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.addingReportingOverflow(_:)(Swift::Int64 a1)
{
  BOOL v2 = __OFADD__(v1, a1);
  Swift::Int64 v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.subtractingReportingOverflow(_:)(Swift::Int64 a1)
{
  BOOL v2 = __OFSUB__(v1, a1);
  Swift::Int64 v3 = v1 - a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.multipliedReportingOverflow(by:)(Swift::Int64 by)
{
  Swift::Int64 v2 = v1 * by;
  Swift::Bool v3 = (unsigned __int128)(v1 * (__int128)by) >> 64 != (v1 * by) >> 63;
  Swift::Int64 v4 = v2;
  result.partialValue = v4;
  result.overfSwift::UInt64 low = v3;
  return result;
}

uint64_t *static Int64.%= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64.%= infix(_:_:)(a1, a2, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int64.& infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 & a1;
}

uint64_t static Int64.bitWidth.getter()
{
  return 64LL;
}

uint64_t Int64.Words._value.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*Int64.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.Words.count.getter()
{
  return 1LL;
}

uint64_t Int64.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t Int64.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t Int64.Words.indices.getter()
{
  return 0LL;
}

uint64_t Int64.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x2DCEuLL, 0x2DCFuLL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int64.Words( uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  Int64.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.magnitude.getter(uint64_t result)
{
  if (result < 0) {
    return -result;
  }
  return result;
}

Swift::tuple_quotient_Int64_remainder_Int64 __swiftcall Int64.dividingFullWidth(_:)( Swift::tuple_high_Int64_low_UInt64 a1)
{
  Swift::Int64 v2 = Int64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x2E5BuLL, 0x2E6CuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

BOOL static Int64.> infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int64(void *a1@<X8>)
{
  *a1 = 0x7FFFFFFFFFFFFFFFLL;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int64(void *a1@<X8>)
{
  *a1 = 0x8000000000000000LL;
}

Swift::Int64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int64( Swift::Int64 *a1, Swift::Int64 *a2, Swift::tuple_high_Int64_low_UInt64 *a3)
{
  Swift::tuple_quotient_Int64_remainder_Int64 v6 = Int64.dividingFullWidth(_:)(*a3);
  Swift::Int64 result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int64 and conformance Int64(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int64@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int64 and conformance Int64,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int64@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int64 and conformance Int64((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int64@<X0>( void *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2BE7uLL,  0);
  }
  if (*result == 0x8000000000000000LL && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x2BEEuLL,  0);
  }
  *a3 = *result / v3;
  return result;
}

uint64_t static Int64./ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int./ infix(_:_:)(a1, a2, 0x2BE7uLL, 0x2BEEuLL);
}

uint64_t static Int./ infix(_:_:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a3,  0);
  }
  if (a1 == 0x8000000000000000LL && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  return a1 / a2;
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64( a1,  a2,  a3,  a4,  0x2BE7uLL,  0x2BEEuLL);
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64(a1, a2, 0x2CCCuLL, 0x2CD1uLL, a3);
}

uint64_t static Int64.% infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int.% infix(_:_:)(a1, a2, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int.% infix(_:_:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a3,  0);
  }
  if (a1 == 0x8000000000000000LL && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  return a1 % a2;
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64( a1,  a2,  a3,  a4,  0x2CCCuLL,  0x2CD1uLL);
}

uint64_t static Int64.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int64@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64x2_t v126 = a5;
  uint64_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v114 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v122 = (char *)&v114 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v117 = (char *)&v114 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v114 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v124 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  char v30 = (char *)&v114 - v29;
  uint64_t v123 = *a1;
  BOOL v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v121 = v19;
  unint64_t v127 = v31;
  if ((v32 & 1) != 0)
  {
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      int64_t v129 = -64LL;
      char v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) == 0) {
        goto LABEL_19;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 >= -64) {
        goto LABEL_19;
      }
    }

    goto LABEL_18;
  }

  char v39 = v31(a3, a4);
  BOOL v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 >= 64)
    {
      uint64_t v33 = v125;
      goto LABEL_19;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
LABEL_17:
    uint64_t v33 = v125;
    if (v49 >= -64) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (v40 > 64)
  {
    int64_t v129 = -64LL;
    uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    char v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    uint64_t v33 = v125;
    if ((v45 & 1) == 0)
    {
LABEL_19:
      char v56 = v127(a3, a4);
      uint64_t v57 = v33(a3, a4);
      BOOL v125 = v33;
      if ((v56 & 1) != 0)
      {
        if (v57 > 64) {
          goto LABEL_21;
        }
      }

      else if (v57 > 63)
      {
LABEL_21:
        int64_t v129 = 64LL;
        unint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
        v60(&v129, &type metadata for Int, v61, a3, a4);
        char v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
        uint64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
        uint64_t result = v63(v30, a3);
        if ((v62 & 1) == 0)
        {
LABEL_26:
          uint64_t v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
          char v66 = v124;
          v65(v124, a2, a3);
          char v67 = v127(a3, a4);
          v65(v26, (uint64_t)v66, a3);
          if ((v67 & 1) == 0)
          {
            v63(v26, a3);
            uint64_t v70 = v124;
            unint64_t v68 = v125;
            signed int v71 = v122;
            uint64_t v79 = v125(a3, a4);
            goto LABEL_48;
          }

          unint64_t v68 = v125;
          uint64_t v69 = v125(a3, a4);
          v63(v26, a3);
          uint64_t v70 = v124;
          signed int v71 = v122;
          if (v69 <= 64)
          {
LABEL_47:
            uint64_t v79 = v68(a3, a4);
LABEL_48:
            uint64_t v99 = v79;
            v65(v71, (uint64_t)v70, a3);
            if (v99 < 65)
            {
              uint64_t v109 = v68(a3, a4);
              v63(v71, a3);
              BOOL v110 = v109 == 64;
              int v100 = v127;
              if (!v110 || (v127(a3, a4) & 1) != 0) {
                goto LABEL_62;
              }
            }

            else
            {
              v63(v71, a3);
              int v100 = v127;
            }

            uint64_t v101 = v121;
            v65(v121, (uint64_t)v70, a3);
            int64_t v129 = 0x7FFFFFFFFFFFFFFFLL;
            char v102 = v100(a3, a4);
            uint64_t v103 = v68(a3, a4);
            if ((v102 & 1) != 0)
            {
              if (v103 > 64)
              {
                int64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
                int64_t v108 = &v129;
                goto LABEL_60;
              }
            }

            else if (v103 > 63)
            {
              uint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
              int64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              int64_t v108 = &v128;
LABEL_60:
              v106(v108, &type metadata for Int, v107, a3, a4);
              char v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v101,  a3);
              v63(v30, a3);
              if ((v111 & 1) != 0) {
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
              }
              goto LABEL_61;
            }

            v65(v30, (uint64_t)v101, a3);
            (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
LABEL_61:
            v63(v101, a3);
LABEL_62:
            unint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            uint64_t result = v63(v70, a3);
            if ((v112 & 0x8000000000000000LL) == 0)
            {
              if (v112 < 0x40)
              {
                uint64_t v55 = v123 >> v112;
                goto LABEL_65;
              }

              goto LABEL_25;
            }

            if (v112 > 0xFFFFFFFFFFFFFFC0LL)
            {
              uint64_t v55 = v123 << -(char)v112;
              goto LABEL_65;
            }

            goto LABEL_18;
          }

          int64x2_t v115 = v63;
          BOOL v72 = v117;
          v65(v117, (uint64_t)v124, a3);
          int64_t v129 = 0x8000000000000000LL;
          uint64_t v73 = v127;
          if ((v127(a3, a4) & 1) != 0)
          {
            uint64_t v74 = v68(a3, a4);
            if (v74 < 64)
            {
              v65(v30, (uint64_t)v72, a3);
              uint64_t v77 = v72;
              uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              uint64_t v63 = v115;
              v115(v30, a3);
LABEL_41:
              if (v78 < v129) {
LABEL_70:
              }
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
              goto LABEL_45;
            }

            uint64_t v77 = v72;
            unint64_t v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
            v87(&v129, &type metadata for Int, v88, a3, a4);
            char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v77,  v30,  a3);
          }

          else
          {
            char v80 = v73(a3, a4);
            uint64_t v81 = v68(a3, a4);
            if ((v80 & 1) == 0)
            {
              uint64_t v63 = v115;
              if (v81 >= 64)
              {
                int64x2_t v113 = v117;
LABEL_46:
                v63(v113, a3);
                goto LABEL_47;
              }

              uint64_t v77 = v117;
              v65(v30, (uint64_t)v117, a3);
              uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v63(v30, a3);
              goto LABEL_41;
            }

            if (v81 <= 64)
            {
              unint64_t v91 = AssociatedTypeWitness;
              char v90 = (void (**)(char *, uint64_t, const char *))v120;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v93 = v118;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 8))( &qword_18180BE68,  256LL,  v91,  AssociatedConformanceWitness);
              v90[3](v93, a3, (const char *)v90);
              uint64_t v94 = v117;
              LOBYTE(v9_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                               + 16LL))( v117,  v30,  a3);
              v115(v30, a3);
              uint64_t v95 = v116;
              v65(v116, (uint64_t)v94, a3);
              if ((v90 & 1) != 0)
              {
                v115(v95, a3);
                goto LABEL_70;
              }

              int64_t v96 = v129;
              uint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              uint64_t v63 = v115;
              v115(v95, a3);
              BOOL v98 = v97 < v96;
              uint64_t v70 = v124;
              uint64_t v77 = v117;
              if (v98) {
                goto LABEL_70;
              }
LABEL_45:
              int64x2_t v113 = v77;
              goto LABEL_46;
            }

            signed int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
            v84(&v129, &type metadata for Int, v85, a3, a4);
            uint64_t v77 = v117;
            char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
          }

          char v89 = v86;
          uint64_t v63 = v115;
          v115(v30, a3);
          if ((v89 & 1) != 0) {
            goto LABEL_70;
          }
          goto LABEL_45;
        }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int64( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    BOOL v31 = v19;
    char v32 = *(uint64_t **)(a4 + 128);
    uint64_t v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      int64_t v144 = -64LL;
      uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      unint64_t v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if ((v52 & 1) == 0) {
        goto LABEL_19;
      }
    }

    else
    {
      uint64_t v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      char v39 = a1;
      uint64_t v40 = v31;
      if (v37 >= -64) {
        goto LABEL_19;
      }
    }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int64@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v120 = a5;
  int64x2_t v115 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v115,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64x2_t v113 = (char *)&v111 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v111 = (char *)&v111 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v111 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v117 = (char *)&v111 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  BOOL v112 = (char *)&v111 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v111 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v118 = (char *)&v111 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v111 - v28;
  uint64_t v119 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v121 = v30;
  if ((v31 & 1) == 0)
  {
    char v38 = v30(a3, a4);
    unint64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v124 = -64LL;
        uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        char v30 = v121;
        char v32 = v122;
        goto LABEL_20;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v115;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }

      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v53 < -64;
    }

    else
    {
      if (v39 >= 64)
      {
        char v30 = v121;
        char v32 = v122;
        goto LABEL_20;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -64;
    }

    char v30 = v121;
    char v32 = v122;
    if (v47) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }

  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 > -65) {
      goto LABEL_20;
    }
LABEL_19:
    uint64_t v54 = v120;
    uint64_t v55 = v119 >> 63;
    goto LABEL_50;
  }

  int64_t v124 = -64LL;
  uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
LABEL_20:
  unint64_t v122 = v32;
  char v56 = v30(a3, a4);
  uint64_t v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64) {
      goto LABEL_22;
    }
  }

  else if (v57 > 63)
  {
LABEL_22:
    int64_t v124 = 64LL;
    unint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v6_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    char v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v62(v29, a3);
LABEL_31:
    uint64_t v55 = 0LL;
    uint64_t v54 = v120;
    goto LABEL_50;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v62(v29, a3);
  if (v77 > 64) {
    goto LABEL_31;
  }
LABEL_23:
  uint64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v64 = v118;
  v63(v118, a2, a3);
  char v65 = v121(a3, a4);
  char v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    uint64_t v76 = v25;
    unint64_t v68 = v117;
    char v69 = v118;
    goto LABEL_33;
  }

  uint64_t v67 = v122(a3, a4);
  v62(v25, a3);
  unint64_t v68 = v117;
  char v69 = v118;
  if (v67 < 65) {
    goto LABEL_34;
  }
  uint64_t v70 = v112;
  v66(v112, v118, a3);
  int64_t v124 = 0x8000000000000000LL;
  signed int v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    char v91 = v71(a3, a4);
    uint64_t v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        unint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        uint64_t v70 = v112;
        char v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
        goto LABEL_55;
      }

      unint64_t v104 = AssociatedTypeWitness;
      uint64_t v103 = (void (**)(char *, uint64_t, const char *))v115;
      unint64_t v105 = swift_getAssociatedConformanceWitness( (uint64_t)v115,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      int64_t v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))( &qword_18180BE68,  256LL,  v104,  v105);
      v103[3](v106, a3, (const char *)v103);
      unint64_t v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v112,  v29,  a3);
      v62(v29, a3);
      int64_t v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_69;
      }

      int64_t v109 = v124;
      uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      BOOL v47 = v110 < v109;
      char v69 = v118;
      uint64_t v76 = v112;
      if (!v47) {
        goto LABEL_33;
      }
    }

    else
    {
      if (v92 >= 64)
      {
        uint64_t v76 = v112;
        goto LABEL_33;
      }

      uint64_t v101 = v112;
      v66(v29, v112, a3);
      uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      uint64_t v76 = v101;
      if (v102 >= v124) {
        goto LABEL_33;
      }
    }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int64( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    int8x16_t v131 = v19;
    uint64_t v132 = a1;
    char v41 = v29(a3, a4);
    char v32 = *(uint64_t **)(a4 + 128);
    uint64_t v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        int64_t v144 = -64LL;
        unint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        BOOL v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        if ((v48 & 1) != 0) {
          goto LABEL_18;
        }
        goto LABEL_19;
      }

      uint64_t v55 = v137;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      char v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
      unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        uint64_t v39 = v132;
        goto LABEL_18;
      }

      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }

    else
    {
      if (v42 >= 64)
      {
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        goto LABEL_19;
      }

      uint64_t v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }

    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -64) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  char v31 = v19;
  char v32 = *(uint64_t **)(a4 + 128);
  uint64_t v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if (v33 < 64)
  {
    uint64_t v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    uint64_t v39 = a1;
    uint64_t v40 = v31;
    if (v37 > -65) {
      goto LABEL_19;
    }
LABEL_18:
    uint64_t v61 = *v39 >> 63;
    goto LABEL_59;
  }

  int64_t v144 = -64LL;
  uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  unint64_t v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  uint64_t v39 = a1;
  uint64_t v40 = v31;
  if ((v52 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  char v62 = v141(a3, a4);
  uint64_t v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
LABEL_24:
    signed int v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v71, a3);
    if (v72 > 64) {
      goto LABEL_22;
    }
    goto LABEL_25;
  }

  if (v63 < 64) {
    goto LABEL_24;
  }
LABEL_21:
  int64_t v144 = 64LL;
  char v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
  unint64_t v68 = v142;
  v66(&v144, &type metadata for Int, v67, a3, a4);
  char v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
  uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  uint64_t result = v70(v68, a3);
  if ((v69 & 1) != 0)
  {
LABEL_22:
    uint64_t v61 = 0LL;
    goto LABEL_59;
  }

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int64( uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3, 0x2BE7uLL, 0x2BEEuLL);
  *a1 = result;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int64( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    uint64_t v10 = a3();
    if ((v11 & 0x100) != 0)
    {
      uint64_t v12 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10LL, a4);
      char v16 = v15;
      swift_bridgeObjectRelease(a2);
      int v14 = v16 & 1;
    }

    else
    {
      uint64_t v12 = v10;
      char v13 = v11;
      swift_bridgeObjectRelease(a2);
      int v14 = v13 & 1;
    }

    if (v14) {
      uint64_t v17 = 0LL;
    }
    else {
      uint64_t v17 = v12;
    }
  }

  else
  {
    swift_bridgeObjectRelease(a2);
    uint64_t v17 = 0LL;
    LOBYTE(v14) = 1;
  }

  *(void *)a5 = v17;
  *(_BYTE *)(a5 + 8) = v14;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int64 and conformance Int64,  a5);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int64()
{
  return _int64ToString(_:radix:uppercase:)( *v0,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

uint64_t *protocol witness for Strideable.distance(to:) in conformance Int64@<X0>( uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *v2;
  if (((*v2 ^ *result) & 0x8000000000000000LL) == 0)
  {
    BOOL v5 = __OFSUB__(v3, v4);
    uint64_t v4 = v3 - v4;
    if (!v5) {
      goto LABEL_15;
    }
    __break(1u);
  }

  if (v4 >= 0) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = -v4;
  }
  if (v3 < 0) {
    uint64_t v3 = -v3;
  }
  BOOL v7 = __CFADD__(v6, v3);
  uint64_t v8 = v6 + v3;
  if (v7)
  {
    __break(1u);
LABEL_17:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Distance is not representable in Int",  36LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x64AuLL,  0);
  }

  if (v8 < 0) {
    goto LABEL_17;
  }
  if (v4 < 0) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = -v8;
  }
LABEL_15:
  *a2 = v4;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int64@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if (__OFADD__(*v2, *result)) {
    __break(1u);
  }
  else {
    *a2 = *v2 + *result;
  }
  return result;
}

BOOL static Int64.<= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 >= a1;
}

void Int64.hash(into:)(int a1, Swift::UInt64 a2)
{
}

uint64_t Int64._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int64@<X0>( void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t UInt._value.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*UInt._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t UInt64.init(exactly:)(float _S0)
{
  __asm { FCVT            S1, H0 }

  if (_S1 <= -1.0) {
    return 0LL;
  }
  float v6 = _S0;
  _S0 = truncf(_S1);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }

  if ((~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1) {
    return 0LL;
  }
  else {
    return (unint64_t)_S1;
  }
}

Swift::UInt_optional __swiftcall UInt.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 1.8447e19) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (truncf(exactly) == exactly);
  if (v2) {
    Swift::UInt v3 = (unint64_t)exactly;
  }
  else {
    Swift::UInt v3 = 0LL;
  }
  char v4 = v2 ^ 1;
  result.unsigned int value = v3;
  result.is_nil = v4;
  return result;
}

Swift::UInt_optional __swiftcall UInt.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 1.84467441e19) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (trunc(exactly) == exactly);
  if (v2) {
    Swift::UInt v3 = (unint64_t)exactly;
  }
  else {
    Swift::UInt v3 = 0LL;
  }
  char v4 = v2 ^ 1;
  result.unsigned int value = v3;
  result.is_nil = v4;
  return result;
}

void *static UInt.+= infix(_:_:)(void *result, uint64_t a2)
{
  if (__CFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

unint64_t *static UInt.-= infix(_:_:)(unint64_t *result, unint64_t a2)
{
  if (*result < a2) {
    __break(1u);
  }
  else {
    *result -= a2;
  }
  return result;
}

unint64_t *static UInt.*= infix(_:_:)(unint64_t *result, unint64_t a2)
{
  if (is_mul_ok(*result, a2)) {
    *result *= a2;
  }
  else {
    __break(1u);
  }
  return result;
}

void *static UInt./= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x321DuLL,  0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.addingReportingOverflow(_:)(Swift::UInt a1)
{
  BOOL v2 = __CFADD__(v1, a1);
  Swift::UInt v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.subtractingReportingOverflow(_:)(Swift::UInt a1)
{
  BOOL v2 = v1 >= a1;
  Swift::UInt v3 = v1 - a1;
  Swift::Bool v4 = !v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.multipliedReportingOverflow(by:)(Swift::UInt by)
{
  Swift::UInt v2 = v1 * by;
  Swift::Bool v3 = !is_mul_ok(v1, by);
  Swift::UInt v4 = v2;
  result.partialValue = v4;
  result.overfSwift::UInt64 low = v3;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.dividedReportingOverflow(by:)(Swift::UInt by)
{
  Swift::UInt v2 = v1;
  if (by) {
    Swift::UInt v2 = v1 / by;
  }
  Swift::Bool v3 = by == 0;
  Swift::UInt v4 = v2;
  result.partialValue = v4;
  result.overfSwift::UInt64 low = v3;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.remainderReportingOverflow(dividingBy:)( Swift::UInt dividingBy)
{
  Swift::UInt v2 = v1;
  if (dividingBy) {
    Swift::UInt v2 = v1 % dividingBy;
  }
  Swift::Bool v3 = dividingBy == 0;
  Swift::UInt v4 = v2;
  result.partialValue = v4;
  result.overfSwift::UInt64 low = v3;
  return result;
}

void *static UInt.%= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x32F1uLL,  0);
  }
  *result %= a2;
  return result;
}

void *static UInt.&>>= infix(_:_:)(void *result, char a2)
{
  *result >>= a2;
  return result;
}

uint64_t UInt.Words._value.setter(uint64_t result)
{
  *Swift::UInt v1 = result;
  return result;
}

uint64_t (*UInt.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.Words.count.getter()
{
  return 1LL;
}

uint64_t UInt.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t UInt.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t UInt.Words.indices.getter()
{
  return 0LL;
}

uint64_t UInt.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x33EFuLL, 0x33F0uLL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt.Words( uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  UInt.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.multipliedFullWidth(by:)(unint64_t a1, unint64_t a2)
{
  return (a2 * (unsigned __int128)a1) >> 64;
}

Swift::tuple_quotient_UInt_remainder_UInt __swiftcall UInt.dividingFullWidth(_:)(Swift::tuple_high_UInt_low_UInt a1)
{
  Swift::UInt v2 = UInt64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x3463uLL, 0x3465uLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t UInt64.dividingFullWidth(_:)( unint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  if (a1 >= a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a5,  0);
  }
  return __udivti3();
}

unint64_t UInt.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

Swift::UInt __swiftcall UInt.signum()()
{
  return v0 != 0;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt( void *a1, void *a2)
{
  BOOL v3 = __CFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt( void *a1, void *a2)
{
  BOOL v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt( void *a1, unint64_t *a2)
{
  BOOL v3 = !is_mul_ok(*v2, *a2);
  *a1 = *v2 * *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt( void *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt( void *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

void *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt64( void *result, void *a2, void *a3)
{
  uint64_t v4 = *v3 * *a3;
  *Swift::tuple_quotient_UInt_remainder_UInt result = ((unint64_t)*v3 * (unsigned __int128)(unint64_t)*a3) >> 64;
  *a2 = v4;
  return result;
}

Swift::UInt protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt( Swift::UInt *a1, Swift::UInt *a2, Swift::tuple_high_UInt_low_UInt *a3)
{
  Swift::tuple_quotient_UInt_remainder_UInt v6 = UInt.dividingFullWidth(_:)(*a3);
  Swift::UInt result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

void *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt( void *result, void *a2)
{
  *result >>= *a2;
  return result;
}

void *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt@<X0>( void *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 9 <= 0x20 && (a2 & 1) == 0) {
    *a3 = *result;
  }
  else {
    *a3 = 0LL;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt and conformance UInt(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt and conformance UInt,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v49 = a6;
  uint64_t v9 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v48 = (char *)&v44 - v12;
  uint64_t v52 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  unint64_t v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v51 = (char *)&v44 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v44 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v44 - v20;
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v23 = v22(a2, a3);
  uint64_t v50 = a1;
  if ((v23 & 1) != 0)
  {
    uint64_t v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    char v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 32LL))( v21,  v19,  a2);
    uint64_t v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    v28(v21, a2);
    a1 = v50;
  }

  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v30 = a1;
  if (v29(a2, a3) >= 64)
  {
    uint64_t v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    unint64_t v53 = -1LL;
    char v31 = v22(a2, a3);
    uint64_t v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 65)
      {
        unint64_t v33 = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        uint64_t v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 40LL))( v51,  v19,  a2);
        uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        unint64_t v37 = v53;
        char v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        uint64_t v30 = v50;
        if ((v34 & 1) != 0)
        {
          unint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39) {
            goto LABEL_14;
          }
        }

        else
        {
          v36(v38, a2);
        }

        goto LABEL_16;
      }
    }

    else if (v32 <= 64)
    {
      uint64_t v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      unint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      uint64_t v30 = v50;
      if (v53 < v41) {
        goto LABEL_14;
      }
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }

    (*(void (**)(unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    uint64_t v35 = v51;
    char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v19,  v51,  a2);
    uint64_t v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    uint64_t v30 = v50;
    if ((v40 & 1) != 0) {
LABEL_14:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_16;
  }

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt and conformance UInt((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt()
{
  if (!*v0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return __clz(*v0) ^ 0x3F;
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x321DuLL,  0);
  }
  *a3 = *result / *a2;
  return result;
}

void *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt( void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x321DuLL,  0);
  }
  *result /= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x32F1uLL,  0);
  }
  *a3 = *result % *a2;
  return result;
}

void *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt( void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x32F1uLL,  0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt64@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64x2_t v126 = a5;
  uint64_t v120 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v118 = (char *)&v114 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  int64x2_t v116 = (char *)&v114 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v114 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v123 = (char *)&v114 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v117 = (char *)&v114 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v114 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v124 = (char *)&v114 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v114 - v29;
  unint64_t v122 = *a1;
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v121 = v19;
  unint64_t v127 = v31;
  if ((v32 & 1) != 0)
  {
    unint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      int64_t v129 = -64LL;
      uint64_t v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -64) {
        goto LABEL_24;
      }
    }
  }

  else
  {
    char v39 = v31(a3, a4);
    BOOL v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v40 = v125(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v40 > 64)
      {
        int64_t v129 = -64LL;
        uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
        v43(&v129, &type metadata for Int, v44, a3, a4);
        char v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
        unint64_t v33 = v125;
        if ((v45 & 1) != 0) {
          goto LABEL_24;
        }
        goto LABEL_18;
      }

      unint64_t v50 = AssociatedTypeWitness;
      unint64_t v51 = v120;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v53 = v118;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v50,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
      LOBYTE(v5_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      uint64_t v54 = *(void (**)(char *, uint64_t))(v11 + 8);
      v54(v30, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v50 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
        goto LABEL_24;
      }

      uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
    }

    else
    {
      if (v40 >= 64)
      {
        unint64_t v33 = v125;
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    }

    unint64_t v33 = v125;
    if (v49 < -64) {
      goto LABEL_24;
    }
  }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt64( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    int8x16_t v131 = v19;
    uint64_t v132 = a1;
    char v41 = v29(a3, a4);
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        int64_t v144 = -64LL;
        char v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        unint64_t v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        uint64_t v40 = v131;
        char v39 = v132;
        if ((v48 & 1) != 0) {
          goto LABEL_24;
        }
        goto LABEL_18;
      }

      char v55 = v137;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      char v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
      unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        unint64_t v61 = 0LL;
        char v39 = v132;
        goto LABEL_59;
      }

      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }

    else
    {
      if (v42 >= 64)
      {
        uint64_t v40 = v131;
        char v39 = v132;
        goto LABEL_18;
      }

      unint64_t v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }

    uint64_t v40 = v131;
    char v39 = v132;
    if (v54 < -64) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  char v31 = v19;
  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    int64_t v144 = -64LL;
    uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    unint64_t v51 = v142;
    v49(&v144, &type metadata for Int, v50, a3, a4);
    char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
    char v39 = a1;
    uint64_t v40 = v31;
    if ((v52 & 1) != 0) {
      goto LABEL_24;
    }
  }

  else
  {
    uint64_t v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    char v39 = a1;
    uint64_t v40 = v31;
    if (v37 < -64) {
      goto LABEL_24;
    }
  }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v118 = a5;
  int64x2_t v113 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v113,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v111 = (char *)&v109 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v109 = (char *)&v109 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  int64x2_t v116 = (char *)&v109 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  int64x2_t v115 = (char *)&v109 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  int64_t v110 = (char *)&v109 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v109 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  char v117 = (char *)&v109 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v109 - v28;
  unint64_t v114 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v31 = v30(a3, a4);
  uint64_t v119 = v30;
  if ((v31 & 1) != 0)
  {
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      int64_t v122 = -64LL;
      uint64_t v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v44(&v122, &type metadata for Int, v45, a3, a4);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v36 < -64) {
        goto LABEL_29;
      }
    }
  }

  else
  {
    char v38 = v30(a3, a4);
    uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v120(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v122 = -64LL;
        uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v122, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( a2,  v29,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        char v30 = v119;
        char v32 = v120;
        goto LABEL_18;
      }

      unint64_t v48 = AssociatedTypeWitness;
      uint64_t v49 = v113;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v113,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v51 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v48,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      char v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        unint64_t v53 = 0LL;
LABEL_48:
        unint64_t v88 = v118;
        goto LABEL_49;
      }

      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      BOOL v47 = v54 < -64;
    }

    else
    {
      if (v39 >= 64)
      {
        char v30 = v119;
        char v32 = v120;
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      BOOL v47 = v46 < -64;
    }

    char v30 = v119;
    char v32 = v120;
    if (v47) {
      goto LABEL_29;
    }
  }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt64( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v137 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v137,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int8x16_t v136 = (char *)&v131 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint16x8_t v134 = (char *)&v131 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v131 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v138 = (char *)&v131 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int8x16_t v135 = (char *)&v131 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int8x8_t v139 = (char *)&v131 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64x2_t v140 = (char *)&v131 - v27;
  MEMORY[0x1895F8858](v26);
  int8x16_t v142 = (char *)&v131 - v28;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  int8x16_t v141 = v29;
  unint64_t v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    int8x16_t v131 = v19;
    uint64_t v132 = a1;
    char v41 = v29(a3, a4);
    char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        int64_t v144 = -64LL;
        unint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        BOOL v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        if ((v48 & 1) != 0) {
          goto LABEL_24;
        }
        goto LABEL_18;
      }

      char v55 = v137;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      char v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
      unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        unint64_t v61 = 0LL;
        uint64_t v39 = v132;
        goto LABEL_59;
      }

      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }

    else
    {
      if (v42 >= 64)
      {
        uint64_t v40 = v131;
        uint64_t v39 = v132;
        goto LABEL_18;
      }

      unint64_t v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }

    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 < -64) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  char v31 = v19;
  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    int64_t v144 = -64LL;
    uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    unint64_t v51 = v142;
    v49(&v144, &type metadata for Int, v50, a3, a4);
    char v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v51,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
    uint64_t v39 = a1;
    uint64_t v40 = v31;
    if ((v52 & 1) != 0) {
      goto LABEL_24;
    }
  }

  else
  {
    uint64_t v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    uint64_t v39 = a1;
    uint64_t v40 = v31;
    if (v37 < -64) {
      goto LABEL_24;
    }
  }

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt( unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64( a1,  a2,  a3,  a4,  a5,  0x321DuLL);
}

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64( unint64_t *result, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v7 = *a3;
  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a6,  0);
  }
  unint64_t v8 = *v6 / v7;
  *a2 = *v6 % v7;
  *uint64_t result = v8;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt(void *a1)
{
  unint64_t v2 = *v1;
  if (*a1) {
    v2 %= *a1;
  }
  return v2 == 0;
}

void protocol witness for BinaryInteger.signum() in conformance UInt(void *a1@<X8>)
{
  *a1 = *v1 != 0LL;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance UInt64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type UInt and conformance UInt,  a5);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, uint64_t a6@<X8>)
{
  char v62 = a5;
  uint64_t v63 = a4;
  uint64_t v70 = a6;
  uint64_t v9 = *(void *)(a3[3] + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v60 - v12;
  uint64_t v14 = *(void *)(a2 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v11);
  unint64_t v61 = (char *)&v60 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v71 = (char *)&v60 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v60 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v60 - v22;
  uint64_t v65 = (uint64_t (*)(uint64_t, void *))a3[8];
  char v24 = v65(a2, a3);
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  uint64_t v72 = a1;
  unint64_t v67 = v25;
  v25(v23, a1, a2);
  uint64_t v64 = v21;
  unint64_t v68 = v13;
  unint64_t v69 = AssociatedTypeWitness;
  if ((v24 & 1) == 0)
  {
    uint64_t v27 = v9;
    char v66 = *(void (**)(char *, uint64_t))(v14 + 8);
    v66(v23, a2);
    uint64_t v32 = v72;
    uint64_t v34 = v14;
    uint64_t v35 = a3;
    goto LABEL_6;
  }

  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v27 = v9;
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v13, a2, v9);
  char v28 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3[4] + 8LL) + 16LL))(v23, v21, a2);
  uint64_t v29 = *(void (**)(char *, uint64_t))(v14 + 8);
  v29(v21, a2);
  v29(v23, a2);
  if ((v28 & 1) == 0)
  {
    uint64_t v34 = v14;
    uint64_t v35 = a3;
    char v66 = v29;
    uint64_t v32 = v72;
LABEL_6:
    uint64_t v36 = (uint64_t (*)(uint64_t, void *))v35[16];
    uint64_t v37 = v36(a2, v35);
    char v38 = v71;
    v67(v71, v32, a2);
    uint64_t v39 = v27;
    char v41 = v68;
    uint64_t v40 = v69;
    if (v37 <= 63)
    {
      uint64_t v29 = v66;
      v66(v38, a2);
      uint64_t v33 = v70;
LABEL_8:
      uint64_t v30 = ((uint64_t (*)(uint64_t, void *))v35[15])(a2, v35);
      char v31 = 0;
      goto LABEL_19;
    }

    unint64_t v73 = -1LL;
    char v42 = v65(a2, v35);
    uint64_t v43 = v36(a2, v35);
    if ((v42 & 1) != 0)
    {
      if (v43 < 65)
      {
        unint64_t v44 = swift_getAssociatedConformanceWitness( v39,  a2,  v40,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v44 + 8))( &qword_18180BE68,  256LL,  v40,  v44);
        unint64_t v45 = v41;
        unint64_t v46 = v64;
        (*(void (**)(char *, uint64_t, uint64_t))(v39 + 24))(v45, a2, v39);
        BOOL v47 = v71;
        char v48 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35[4] + 8LL) + 40LL))(v71, v46, a2);
        uint64_t v29 = v66;
        v66(v46, a2);
        unint64_t v49 = v73;
        unint64_t v50 = v61;
        (*(void (**)(char *, char *, uint64_t))(v34 + 32))(v61, v47, a2);
        if ((v48 & 1) == 0)
        {
          v29(v50, a2);
          uint64_t v33 = v70;
          uint64_t v32 = v72;
          goto LABEL_8;
        }

        unint64_t v51 = ((uint64_t (*)(uint64_t, void *))v35[15])(a2, v35);
        v29(v50, a2);
        BOOL v52 = v49 >= v51;
LABEL_17:
        uint64_t v33 = v70;
        uint64_t v32 = v72;
        if (v52) {
          goto LABEL_8;
        }
        goto LABEL_18;
      }
    }

    else if (v43 < 65)
    {
      uint64_t v57 = v64;
      (*(void (**)(char *, char *, uint64_t))(v34 + 32))(v64, v71, a2);
      unint64_t v58 = ((uint64_t (*)(uint64_t, void *))v35[15])(a2, v35);
      uint64_t v29 = v66;
      v66(v57, a2);
      BOOL v52 = v73 >= v58;
      goto LABEL_17;
    }

    unint64_t v53 = (void (*)(unint64_t *, uint64_t, uint64_t, uint64_t, void *))v35[12];
    uint64_t v54 = v62();
    char v55 = v64;
    v53(&v73, v63, v54, a2, v35);
    uint64_t v56 = v71;
    LOBYTE(v53) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v35[4] + 8LL) + 16LL))(v55, v71, a2);
    uint64_t v29 = v66;
    v66(v55, a2);
    v29(v56, a2);
    uint64_t v33 = v70;
    uint64_t v32 = v72;
LABEL_18:
    uint64_t v30 = 0LL;
    char v31 = 1;
    goto LABEL_19;
  }

  uint64_t v30 = 0LL;
  char v31 = 1;
  uint64_t v32 = v72;
  uint64_t v33 = v70;
LABEL_19:
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v32, a2);
  *(void *)uint64_t v33 = v30;
  *(_BYTE *)(v33 + 8) = v31;
  return result;
}

unint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance UInt64@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  if (is_mul_ok(*result, *a2)) {
    *a3 = *result * *a2;
  }
  else {
    __break(1u);
  }
  return result;
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt64( unint64_t *result, unint64_t *a2)
{
  if (is_mul_ok(*result, *a2)) {
    *result *= *a2;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt64@<X0>( uint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v4 = *v2;
  if ((*result & 0x8000000000000000LL) == 0)
  {
    BOOL v5 = __CFADD__(v4, v3);
    v3 += v4;
    if (!v5) {
      goto LABEL_7;
    }
    __break(1u);
  }

  unint64_t v6 = -(uint64_t)v3;
  BOOL v5 = v4 >= v6;
  unint64_t v3 = v4 - v6;
  if (!v5)
  {
    __break(1u);
    return result;
  }

unint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt64( uint64_t *a1, uint64_t a2, char a3, unint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  return specialized static Strideable<>._step(after:from:by:)(a1, a2, a3 & 1, *a4, *a5, *a6);
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt64@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt64( void *result, void *a2)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt64@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt64( void *result, void *a2)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

BOOL static UInt.<= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 >= a1;
}

BOOL static UInt.>= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 >= a2;
}

uint64_t UInt._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt@<X0>( void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t Int._value.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Int._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.init(exactly:)(float _S0)
{
  __asm { FCVT            S1, H0 }

  float v6 = _S0;
  _S0 = truncf(_S1);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }

  if ((~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1) {
    return 0LL;
  }
  else {
    return (uint64_t)_S1;
  }
}

Swift::Int_optional __swiftcall Int.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -9.2234e18;
  if (exactly >= 9.2234e18) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (truncf(exactly) == exactly);
  if (v2) {
    Swift::Int v3 = (uint64_t)exactly;
  }
  else {
    Swift::Int v3 = 0LL;
  }
  char v4 = v2 ^ 1;
  result.unsigned int value = v3;
  result.is_nil = v4;
  return result;
}

uint64_t *static Int.*= infix(_:_:)(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result * a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t *static Int./= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64./= infix(_:_:)(a1, a2, 0x3829uLL, 0x3830uLL);
}

uint64_t *static Int64./= infix(_:_:)(uint64_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a3,  0);
  }
  uint64_t v4 = *result;
  if (a2 == -1 && v4 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  *Swift::Int_optional result = v4 / a2;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.addingReportingOverflow(_:)(Swift::Int a1)
{
  BOOL v2 = __OFADD__(v1, a1);
  Swift::Int v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.subtractingReportingOverflow(_:)(Swift::Int a1)
{
  BOOL v2 = __OFSUB__(v1, a1);
  Swift::Int v3 = v1 - a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overfSwift::UInt64 low = v4;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.dividedReportingOverflow(by:)(Swift::Int by)
{
  Swift::Int v2 = v1;
  if (by)
  {
    if (by == -1 && v1 == 0x8000000000000000LL)
    {
      Swift::Bool v3 = 1;
      Swift::Int v4 = 0x8000000000000000LL;
    }

    else
    {
      Swift::Bool v3 = 0;
      Swift::Int v4 = v2 / by;
    }
  }

  else
  {
    Swift::Bool v3 = 1;
    Swift::Int v4 = v2;
  }

  result.partialValue = v4;
  result.overfSwift::UInt64 low = v3;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.remainderReportingOverflow(dividingBy:)( Swift::Int dividingBy)
{
  Swift::Int v2 = v1;
  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 0x8000000000000000LL)
    {
      Swift::Bool v3 = 1;
      Swift::Int v4 = 0LL;
    }

    else
    {
      Swift::Bool v3 = 0;
      Swift::Int v4 = v2 % dividingBy;
    }
  }

  else
  {
    Swift::Bool v3 = 1;
    Swift::Int v4 = v2;
  }

  result.partialValue = v4;
  result.overfSwift::UInt64 low = v3;
  return result;
}

uint64_t *static Int.%= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64.%= infix(_:_:)(a1, a2, 0x390EuLL, 0x3913uLL);
}

uint64_t *static Int64.%= infix(_:_:)(uint64_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a3,  0);
  }
  uint64_t v4 = *result;
  if (a2 == -1 && v4 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  *Swift::tuple_partialValue_Int_overflow_Bool result = v4 % a2;
  return result;
}

void *static Int.&= infix(_:_:)(void *result, uint64_t a2)
{
  *result &= a2;
  return result;
}

void *static Int.|= infix(_:_:)(void *result, uint64_t a2)
{
  *result |= a2;
  return result;
}

uint64_t *static Int.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  *result >>= a2;
  return result;
}

void *static Int.&<<= infix(_:_:)(void *result, char a2)
{
  *result <<= a2;
  return result;
}

uint64_t Int.Words._value.setter(uint64_t result)
{
  *Swift::Int v1 = result;
  return result;
}

uint64_t (*Int.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.Words.count.getter()
{
  return 1LL;
}

uint64_t Int.Words.startIndex.getter()
{
  return 0LL;
}

uint64_t Int.Words.endIndex.getter()
{
  return 1LL;
}

uint64_t Int.Words.indices.getter()
{
  return 0LL;
}

Swift::Int __swiftcall Int.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1LL);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1LL);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x3A11uLL, 0x3A12uLL);
}

uint64_t UInt64.Words.subscript.getter(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative word index",  19LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a3,  0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int.Words( uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  Int.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt64.Words@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if ((*result & 0x8000000000000000LL) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  uint64_t v4 = *v2;
  *a2 = *result;
  a2[1] = v3;
  a2[2] = v4;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int.Words( void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int.Words@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5( a1,  a2);
}

uint64_t Int64.multipliedFullWidth(by:)(uint64_t a1, uint64_t a2)
{
  return (unsigned __int128)(a2 * (__int128)a1) >> 64;
}

Swift::tuple_quotient_Int_remainder_Int __swiftcall Int.dividingFullWidth(_:)(Swift::tuple_high_Int_low_UInt a1)
{
  Swift::Int v2 = Int64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x3A9EuLL, 0x3AAFuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t Int64.dividingFullWidth(_:)( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  uint64_t result = __divti3();
  if (v7 != result >> 63) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Quotient is not representable",  29LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a5,  0);
  }
  return result;
}

unint64_t Int.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int( void *a1, void *a2)
{
  BOOL v3 = __OFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int( void *a1, void *a2)
{
  BOOL v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int( uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *v2 * *a2;
  BOOL v4 = (unsigned __int128)(*v2 * (__int128)*a2) >> 64 != v3 >> 63;
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int( int64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  int64_t v4 = *v2;
  if (*a2)
  {
    if (v3 == -1 && v4 == 0x8000000000000000LL)
    {
      uint64_t v6 = 1LL;
      int64_t v4 = 0x8000000000000000LL;
    }

    else
    {
      uint64_t v6 = 0LL;
      v4 /= v3;
    }
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  *a1 = v4;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int( uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *v2;
  if (!*a2) {
    goto LABEL_9;
  }
  if (v3 == -1 && v4 == 0x8000000000000000LL)
  {
    uint64_t v4 = 0LL;
LABEL_9:
    uint64_t v6 = 1LL;
    goto LABEL_7;
  }

  uint64_t v6 = 0LL;
  v4 %= v3;
LABEL_7:
  *a1 = v4;
  return v6;
}

void *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int64( void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *v3 * *a3;
  *uint64_t result = (unsigned __int128)(*v3 * (__int128)*a3) >> 64;
  *a2 = v4;
  return result;
}

Swift::Int protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int( Swift::Int *a1, Swift::Int *a2, Swift::tuple_high_Int_low_UInt *a3)
{
  Swift::tuple_quotient_Int_remainder_Int v6 = Int.dividingFullWidth(_:)(*a3);
  Swift::Int result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8(*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int()
{
  return __clz(*v0);
}

unint64_t *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int@<X0>( unint64_t *result@<X0>, void *a2@<X8>)
{
  *a2 = bswap64(*result);
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int(void *a1@<X8>)
{
  *a1 = bswap64(*v1);
}

uint64_t *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int@<X0>( uint64_t *result@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int( uint64_t *result, void *a2)
{
  *result >>= *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *result << *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int( void *result, void *a2)
{
  *result <<= *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

void *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

void *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

void *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int@<X0>( void *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 8 <= 0x40) {
    *a3 = *result;
  }
  else {
    *a3 = 0LL;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int and conformance Int,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, void *a6@<X8>)
{
  unint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, a2, v13, a3);
  if ((v39 & 1) != 0)
  {
    char v38 = (char *)static String._createEmpty(withInitialCapacity:)(80LL);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000LL) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._unint64_t object = (void *)0x80000001818B69D0LL;
      v26._uint64_t countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000LL) == 0)
      {
        uint64_t v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._uint64_t countAndFlagsBits = 0xD00000000000002ELL;
        v37._unint64_t object = (void *)0x80000001818B69F0LL;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v38,  v39,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int64@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v72 = a4;
  uint64_t v73 = a5;
  uint64_t v76 = a6;
  unint64_t v69 = *(const char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v69,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v68 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  uint64_t v70 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v74 = (char *)&v68 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  int64_t v20 = (char *)&v68 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  char v75 = (char *)&v68 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v68 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v68 - v26;
  char v78 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v28 = v78(a2, a3);
  uint64_t v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  uint64_t v79 = a1;
  uint64_t v77 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    uint64_t v71 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v30 = v71(a2, a3);
    int64_t v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 64)
    {
      int64_t v32 = v77;
      v77(v25, v79, a2);
      int64_t v81 = 0x8000000000000000LL;
      char v33 = v25;
      uint64_t v34 = v78;
      if ((v78(a2, a3) & 1) != 0)
      {
        uint64_t v35 = v71;
        if (v71(a2, a3) < 64)
        {
          uint64_t v36 = v75;
          v32(v75, v33, a2);
          uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          BOOL v38 = v37 < v81;
LABEL_18:
          char v42 = v33;
LABEL_19:
          unint64_t v46 = v79;
          if (!v38) {
            goto LABEL_20;
          }
          goto LABEL_39;
        }

        unint64_t v45 = v75;
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v81, v72, v73, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v33,  v45,  a2);
        v31(v45, a2);
        char v42 = v33;
        goto LABEL_11;
      }

      char v40 = v34(a2, a3);
      uint64_t v41 = v71(a2, a3);
      char v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 64)
        {
          unint64_t v49 = v69;
          unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v69,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
          unint64_t v51 = v75;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          char v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v51,  a2);
          v31(v51, a2);
          unint64_t v53 = v70;
          char v33 = v42;
          int64_t v32 = v77;
          v77(v70, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_39;
          }

          int64_t v54 = v81;
          uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          BOOL v38 = v55 < v54;
          uint64_t v35 = v71;
          goto LABEL_18;
        }

        uint64_t v43 = v75;
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v81, v72, v73, a2, a3);
        char v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v42,  v43,  a2);
        v31(v43, a2);
        int64_t v32 = v77;
        uint64_t v35 = v71;
LABEL_11:
        unint64_t v46 = v79;
        if ((v44 & 1) == 0)
        {
LABEL_20:
          v31(v42, a2);
          unint64_t v39 = v78;
          goto LABEL_23;
        }

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int and conformance Int((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int()
{
  if ((uint64_t)*v0 <= 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return __clz(*v0) ^ 0x3F;
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int()
{
  return __clz(__rbit64(*v0));
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int@<X0>( void *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  if (*result == 0x8000000000000000LL && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  *a3 = *result / v3;
  return result;
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64( a1,  a2,  a3,  a4,  0x3829uLL,  0x3830uLL);
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64( uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v6 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a5,  0);
  }
  uint64_t v7 = *result;
  if (v6 == -1 && v7 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a6,  0);
  }
  *uint64_t result = v7 / v6;
  return result;
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64(a1, a2, 0x390EuLL, 0x3913uLL, a3);
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64@<X0>( uint64_t *result@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X4>, unint64_t a4@<X5>, uint64_t *a5@<X8>)
{
  uint64_t v5 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a3,  0);
  }
  if (*result == 0x8000000000000000LL && v5 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  *a5 = *result % v5;
  return result;
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64( a1,  a2,  a3,  a4,  0x390EuLL,  0x3913uLL);
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64( uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v6 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a5,  0);
  }
  uint64_t v7 = *result;
  if (v6 == -1 && v7 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a6,  0);
  }
  *uint64_t result = v7 % v6;
  return result;
}

void *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

void *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

void *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int( void *result, void *a2)
{
  *result &= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

void *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int( void *result, void *a2)
{
  *result |= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

void *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int( void *result, void *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v100 = a7;
  uint64_t v93 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v93,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v91 = (char *)&v86 - v14;
  uint64_t v15 = *(void *)(a3 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v86 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  char v89 = (char *)&v86 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v94 = (char *)&v86 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v95 = (char *)&v86 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  char v90 = (char *)&v86 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  int64_t v96 = (char *)&v86 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v97 = (char *)&v86 - v30;
  MEMORY[0x1895F8858](v29);
  int64_t v32 = (char *)&v86 - v31;
  uint64_t v99 = *a1;
  char v33 = *(uint64_t (**)(void, void))(a4 + 64);
  if ((v33(a3, a4) & 1) == 0)
  {
    uint64_t v88 = a5;
    uint64_t v36 = a6;
    char v98 = v33;
    char v37 = v33(a3, a4);
    BOOL v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v38(a3, a4);
    uint64_t v101 = v38;
    if ((v37 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v103 = -64LL;
        a6 = v36;
        a5 = v88;
        (*(void (**)(int64_t *))(a4 + 96))(&v103);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v32,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
        char v33 = v98;
        if ((v40 & 1) == 0) {
          goto LABEL_20;
        }
LABEL_19:
        uint64_t v51 = 0LL;
        char v52 = v100;
        goto LABEL_60;
      }

      unint64_t v44 = AssociatedTypeWitness;
      unint64_t v45 = v93;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v93,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      BOOL v47 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v44,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v45 + 3))(v47, a3, v45);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v32,  a3);
      uint64_t v48 = *(void (**)(char *, uint64_t))(v15 + 8);
      v48(v32, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v18, a2, a3);
      if ((v44 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
        goto LABEL_19;
      }

      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
      BOOL v43 = v50 < -64;
    }

    else
    {
      if (v39 >= 64)
      {
        a6 = v36;
        a5 = v88;
        char v33 = v98;
        char v49 = v98(a3, a4);
        goto LABEL_21;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
      BOOL v43 = v42 < -64;
    }

    a6 = v36;
    a5 = v88;
    char v33 = v98;
    if (!v43) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  uint64_t v101 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  if (v101(a3, a4) >= 64)
  {
    int64_t v103 = -64LL;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    char v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v32,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
    if ((v41 & 1) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
  if (v34 < -64) {
    goto LABEL_19;
  }
LABEL_20:
  char v49 = v33(a3, a4);
LABEL_21:
  char v53 = v49;
  uint64_t v54 = v101(a3, a4);
  uint64_t v87 = a6;
  if ((v53 & 1) != 0)
  {
    if (v54 > 64) {
      goto LABEL_23;
    }
  }

  else if (v54 > 63)
  {
LABEL_23:
    int64_t v103 = 64LL;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    char v55 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v32,  a2,  a3);
    uint64_t v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
    uint64_t result = v56(v32, a3);
    if ((v55 & 1) == 0) {
      goto LABEL_24;
    }
LABEL_31:
    char v52 = v100;
    uint64_t v51 = v99 >> 63;
    goto LABEL_60;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
  uint64_t result = v56(v32, a3);
  if (v64 > 64) {
    goto LABEL_31;
  }
LABEL_24:
  uint64_t v57 = *(void (**)(void))(v15 + 16);
  char v58 = v97;
  v57();
  char v98 = v33;
  char v59 = v33(a3, a4);
  uint64_t v60 = v96;
  ((void (*)(char *, char *, uint64_t))v57)(v96, v58, a3);
  if ((v59 & 1) != 0)
  {
    uint64_t v61 = v101(a3, a4);
    v56(v60, a3);
    if (v61 <= 64) {
      goto LABEL_44;
    }
    uint64_t v62 = v90;
    ((void (*)(char *, char *, uint64_t))v57)(v90, v58, a3);
    int64_t v103 = 0x8000000000000000LL;
    uint64_t v63 = v98;
    if ((v98(a3, a4) & 1) != 0)
    {
      if (v101(a3, a4) < 64)
      {
LABEL_38:
        ((void (*)(char *, char *, uint64_t))v57)(v32, v62, a3);
        uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v56(v32, a3);
        if (v69 < v103) {
LABEL_66:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
        goto LABEL_42;
      }

      goto LABEL_35;
    }

    char v66 = v63(a3, a4);
    uint64_t v67 = v101(a3, a4);
    if ((v66 & 1) != 0)
    {
      if (v67 > 64)
      {
LABEL_35:
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
        char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v62,  v32,  a3);
        v56(v32, a3);
        if ((v68 & 1) != 0) {
          goto LABEL_66;
        }
        goto LABEL_42;
      }

      unint64_t v71 = AssociatedTypeWitness;
      uint64_t v70 = (void (**)(char *, uint64_t, const char *))v93;
      unint64_t v72 = swift_getAssociatedConformanceWitness( (uint64_t)v93,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v73 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v72 + 8))( &qword_18180BE68,  256LL,  v71,  v72);
      v70[3](v73, a3, (const char *)v70);
      LOBYTE(v7_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v62,  v32,  a3);
      v56(v32, a3);
      uint64_t v74 = v89;
      ((void (*)(char *, char *, uint64_t))v57)(v89, v62, a3);
      if ((v70 & 1) != 0)
      {
        v56(v74, a3);
        goto LABEL_66;
      }

      int64_t v75 = v103;
      uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v56(v74, a3);
      BOOL v43 = v76 < v75;
      char v58 = v97;
      if (v43) {
        goto LABEL_66;
      }
    }

    else if (v67 < 64)
    {
      goto LABEL_38;
    }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v97 = a5;
  uint64_t v98 = a6;
  uint64_t v91 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v91,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v89 = (char *)&v86 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v87 = (char *)&v86 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v86 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v93 = (char *)&v86 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v88 = (char *)&v86 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  unint64_t v94 = (char *)&v86 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  int64_t v96 = (char *)&v86 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v86 - v29;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v92 = v20;
  uint64_t v99 = v31;
  if ((v32 & 1) != 0)
  {
    unint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    if (v95(a3, a4) < 64)
    {
LABEL_10:
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      goto LABEL_11;
    }

    goto LABEL_6;
  }

  char v33 = v31(a3, a4);
  unint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v34 = v95(a3, a4);
  if ((v33 & 1) == 0)
  {
    if (v34 >= 64)
    {
      char v37 = a1;
      goto LABEL_15;
    }

    goto LABEL_10;
  }

  if (v34 > 64)
  {
LABEL_6:
    int64_t v101 = -64LL;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    char v37 = a1;
    if ((v35 & 1) != 0) {
      goto LABEL_12;
    }
    goto LABEL_15;
  }

  unint64_t v40 = AssociatedTypeWitness;
  char v41 = v91;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v91,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  BOOL v43 = v89;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v40,  AssociatedConformanceWitness);
  (*((void (**)(char *, uint64_t, const char *))v41 + 3))(v43, a3, v41);
  LOBYTE(v4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
  unint64_t v44 = *(void (**)(char *, uint64_t))(v12 + 8);
  v44(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
  if ((v40 & 1) != 0)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
    uint64_t v39 = 0LL;
    char v37 = a1;
    goto LABEL_59;
  }

  uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
LABEL_11:
  char v37 = a1;
  if (v38 < -64)
  {
LABEL_12:
    uint64_t v39 = 0LL;
    goto LABEL_59;
  }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v100 = a7;
  uint64_t v93 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v93,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v91 = (char *)&v86 - v14;
  uint64_t v15 = *(void *)(a3 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v86 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  char v89 = (char *)&v86 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v94 = (char *)&v86 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  unint64_t v95 = (char *)&v86 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  char v90 = (char *)&v86 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  int64_t v96 = (char *)&v86 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v97 = (char *)&v86 - v30;
  MEMORY[0x1895F8858](v29);
  char v32 = (char *)&v86 - v31;
  uint64_t v99 = *a1;
  char v33 = *(uint64_t (**)(void, void))(a4 + 64);
  if ((v33(a3, a4) & 1) == 0)
  {
    uint64_t v88 = a5;
    uint64_t v36 = a6;
    uint64_t v98 = v33;
    char v37 = v33(a3, a4);
    uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v39 = v38(a3, a4);
    int64_t v101 = v38;
    if ((v37 & 1) != 0)
    {
      if (v39 > 64)
      {
        int64_t v103 = -64LL;
        a6 = v36;
        a5 = v88;
        (*(void (**)(int64_t *))(a4 + 96))(&v103);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v32,  a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
        char v33 = v98;
        if ((v40 & 1) == 0) {
          goto LABEL_20;
        }
LABEL_19:
        uint64_t v51 = v100;
        uint64_t v52 = v99 >> 63;
        goto LABEL_60;
      }

      unint64_t v44 = AssociatedTypeWitness;
      char v45 = v93;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v93,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v47 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v44,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v45 + 3))(v47, a3, v45);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v32,  a3);
      char v48 = *(void (**)(char *, uint64_t))(v15 + 8);
      v48(v32, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v18, a2, a3);
      if ((v44 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
        goto LABEL_19;
      }

      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
      BOOL v43 = v50 < -64;
    }

    else
    {
      if (v39 >= 64)
      {
        a6 = v36;
        a5 = v88;
        char v33 = v98;
        char v49 = v98(a3, a4);
        goto LABEL_21;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
      BOOL v43 = v42 < -64;
    }

    a6 = v36;
    a5 = v88;
    char v33 = v98;
    if (!v43) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  int64_t v101 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  if (v101(a3, a4) >= 64)
  {
    int64_t v103 = -64LL;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    char v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v32,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
    if ((v41 & 1) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
  if (v34 <= -65) {
    goto LABEL_19;
  }
LABEL_20:
  char v49 = v33(a3, a4);
LABEL_21:
  char v53 = v49;
  uint64_t v54 = v101(a3, a4);
  uint64_t v87 = a6;
  if ((v53 & 1) != 0)
  {
    if (v54 > 64) {
      goto LABEL_23;
    }
  }

  else if (v54 >= 64)
  {
LABEL_23:
    int64_t v103 = 64LL;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    char v55 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v32,  a2,  a3);
    uint64_t v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
    uint64_t result = v56(v32, a3);
    if ((v55 & 1) == 0) {
      goto LABEL_24;
    }
LABEL_31:
    uint64_t v52 = 0LL;
    uint64_t v51 = v100;
    goto LABEL_60;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
  uint64_t result = v56(v32, a3);
  if (v64 > 64) {
    goto LABEL_31;
  }
LABEL_24:
  uint64_t v57 = *(void (**)(void))(v15 + 16);
  char v58 = v97;
  v57();
  uint64_t v98 = v33;
  char v59 = v33(a3, a4);
  char v60 = v96;
  ((void (*)(char *, char *, uint64_t))v57)(v96, v58, a3);
  if ((v59 & 1) != 0)
  {
    uint64_t v61 = v101(a3, a4);
    v56(v60, a3);
    if (v61 <= 64) {
      goto LABEL_44;
    }
    char v62 = v90;
    ((void (*)(char *, char *, uint64_t))v57)(v90, v58, a3);
    int64_t v103 = 0x8000000000000000LL;
    char v63 = v98;
    if ((v98(a3, a4) & 1) != 0)
    {
      if (v101(a3, a4) < 64)
      {
LABEL_38:
        ((void (*)(char *, char *, uint64_t))v57)(v32, v62, a3);
        uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v56(v32, a3);
        if (v69 < v103) {
LABEL_65:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
        goto LABEL_42;
      }

      goto LABEL_35;
    }

    char v66 = v63(a3, a4);
    uint64_t v67 = v101(a3, a4);
    if ((v66 & 1) != 0)
    {
      if (v67 > 64)
      {
LABEL_35:
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
        char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v62,  v32,  a3);
        v56(v32, a3);
        if ((v68 & 1) != 0) {
          goto LABEL_65;
        }
        goto LABEL_42;
      }

      unint64_t v71 = AssociatedTypeWitness;
      uint64_t v70 = (void (**)(char *, uint64_t, const char *))v93;
      unint64_t v72 = swift_getAssociatedConformanceWitness( (uint64_t)v93,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v73 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v72 + 8))( &qword_18180BE68,  256LL,  v71,  v72);
      v70[3](v73, a3, (const char *)v70);
      LOBYTE(v7_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v62,  v32,  a3);
      v56(v32, a3);
      BOOL v74 = v89;
      ((void (*)(char *, char *, uint64_t))v57)(v89, v62, a3);
      if ((v70 & 1) != 0)
      {
        v56(v74, a3);
        goto LABEL_65;
      }

      int64_t v75 = v103;
      uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v56(v74, a3);
      BOOL v43 = v76 < v75;
      char v58 = v97;
      if (v43) {
        goto LABEL_65;
      }
    }

    else if (v67 < 64)
    {
      goto LABEL_38;
    }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v98 = a5;
  uint64_t v99 = a6;
  uint64_t v92 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v92,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v90 = (char *)&v87 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v88 = (char *)&v87 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v87 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  unint64_t v94 = (char *)&v87 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  char v89 = (char *)&v87 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  unint64_t v95 = (char *)&v87 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v97 = (char *)&v87 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v87 - v29;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  uint64_t v93 = v20;
  uint64_t v100 = v31;
  if ((v32 & 1) == 0)
  {
    char v36 = v31(a3, a4);
    int64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v37 = v96(a3, a4);
    if ((v36 & 1) != 0)
    {
      if (v37 > 64) {
        goto LABEL_7;
      }
      unint64_t v40 = AssociatedTypeWitness;
      char v41 = v92;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      BOOL v43 = v90;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v40,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v41 + 3))(v43, a3, v41);
      LOBYTE(v4_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
      unint64_t v44 = *(void (**)(char *, uint64_t))(v12 + 8);
      v44(v30, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
      if ((v40 & 1) != 0)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
        char v35 = a1;
        uint64_t v45 = *a1 >> 63;
        goto LABEL_60;
      }

      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
    }

    else
    {
      if (v37 >= 64)
      {
        char v35 = a1;
        goto LABEL_17;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    }

    char v35 = a1;
    if (v39 >= -64) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  int64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  if (v96(a3, a4) < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    char v35 = a1;
    if (v33 > -65) {
      goto LABEL_17;
    }
LABEL_16:
    uint64_t v45 = *v35 >> 63;
    goto LABEL_60;
  }

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int( uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3, 0x3829uLL, 0x3830uLL);
  *a1 = result;
  return result;
}

uint64_t protocol witness for BinaryInteger.isMultiple(of:) in conformance Int(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1 == -1) {
    return 1LL;
  }
  uint64_t v3 = *v1;
  if (v2) {
    return v3 % v2 == 0;
  }
  else {
    return v3 == 0;
  }
}

void protocol witness for BinaryInteger.signum() in conformance Int(unint64_t *a1@<X8>)
{
  *a1 = (*v1 > 0) | (unint64_t)(*v1 >> 63);
}

void *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if (__OFSUB__(0LL, *result)) {
    __break(1u);
  }
  else {
    *a2 = -*result;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int()
{
  if (__OFSUB__(0LL, *v0)) {
    __break(1u);
  }
  else {
    void *v0 = -*v0;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int64( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type Int and conformance Int,  a5);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int64@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, uint64_t a6@<X8>)
{
  uint64_t v81 = a5;
  uint64_t v82 = a4;
  uint64_t v85 = a6;
  uint64_t v78 = *(char **)(*(void *)(a3 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v78,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v77 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v10);
  char v79 = (char *)&v77 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v80 = (char *)&v77 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v84 = (char *)&v77 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v77 - v21;
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  char v83 = (char *)&v77 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v77 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v29 = (char *)&v77 - v28;
  uint64_t v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v30 = v86(a2, a3);
  uint64_t v87 = v13;
  uint64_t v88 = a1;
  uint64_t v31 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v31(v29, a1, a2);
  BOOL v32 = (v30 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v33 = *(void (**)(char *, uint64_t))(v87 + 8);
  v33(v29, a2);
  v31(v27, v88, a2);
  if (!v32)
  {
    v33(v27, a2);
    char v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v37 = v88;
LABEL_10:
    uint64_t v38 = v35(a2, a3);
    goto LABEL_11;
  }

  int64_t v90 = 0x8000000000000000LL;
  uint64_t v34 = v86;
  if ((v86(a2, a3) & 1) != 0)
  {
    char v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    if (v35(a2, a3) >= 64)
    {
      uint64_t v60 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v61 = v81();
      uint64_t v62 = v83;
      v60(&v90, v82, v61, a2, a3);
      LOBYTE(v6_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v27,  v62,  a2);
      v33(v62, a2);
      v33(v27, a2);
      uint64_t v37 = v88;
    }

    else
    {
      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v33(v27, a2);
      uint64_t v37 = v88;
      if (v36 < v90) {
        goto LABEL_41;
      }
    }

    goto LABEL_10;
  }

  char v51 = v34(a2, a3);
  uint64_t v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v52 = v77(a2, a3);
  if ((v51 & 1) != 0)
  {
    if (v52 > 64)
    {
      char v53 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v54 = v81();
      uint64_t v55 = v83;
      v53(&v90, v82, v54, a2, a3);
      LOBYTE(v53) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v27,  v55,  a2);
      v33(v55, a2);
      v33(v27, a2);
      uint64_t v37 = v88;
      char v35 = v77;
      goto LABEL_10;
    }

    uint64_t v70 = (void (**)(char *, uint64_t, const char *))v78;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v78,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    unint64_t v72 = v83;
    v70[3](v12, a2, (const char *)v70);
    LOBYTE(v7_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v27,  v72,  a2);
    v33(v72, a2);
    int64_t v73 = v79;
    (*(void (**)(char *, char *, uint64_t))(v87 + 32))(v79, v27, a2);
    if ((v70 & 1) != 0)
    {
      v33(v73, a2);
      uint64_t v58 = 0LL;
      char v59 = 1;
      uint64_t v41 = v85;
      uint64_t v37 = v88;
      goto LABEL_42;
    }

    int64_t v74 = v90;
    uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v33(v73, a2);
    BOOL v64 = v75 < v74;
LABEL_39:
    uint64_t v37 = v88;
    char v35 = v77;
    if (v64)
    {
LABEL_41:
      uint64_t v58 = 0LL;
      char v59 = 1;
      uint64_t v41 = v85;
      goto LABEL_42;
    }

    goto LABEL_10;
  }

  if (v52 < 64)
  {
    uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v33(v27, a2);
    BOOL v64 = v63 < v90;
    goto LABEL_39;
  }

  v33(v27, a2);
  uint64_t v37 = v88;
  char v35 = v77;
  uint64_t v38 = v77(a2, a3);
LABEL_11:
  uint64_t v39 = v38;
  v31(v22, v37, a2);
  if (v39 >= 65)
  {
    v33(v22, a2);
    unint64_t v40 = v84;
    v31(v84, v37, a2);
    uint64_t v41 = v85;
    goto LABEL_15;
  }

  uint64_t v42 = v35(a2, a3);
  v33(v22, a2);
  if (v42 != 64)
  {
    unint64_t v40 = v84;
    v31(v84, v37, a2);
    uint64_t v41 = v85;
    goto LABEL_25;
  }

  char v43 = v86(a2, a3);
  unint64_t v40 = v84;
  v31(v84, v37, a2);
  uint64_t v41 = v85;
  if ((v43 & 1) != 0)
  {
LABEL_25:
    uint64_t v57 = v40;
    goto LABEL_26;
  }

void protocol witness for Numeric.magnitude.getter in conformance Int(uint64_t *a1@<X8>)
{
  uint64_t v2 = *v1;
  if (*v1 < 0) {
    uint64_t v2 = -v2;
  }
  *a1 = v2;
}

uint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance Int64@<X0>( uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *result * *a2;
  else {
    __break(1u);
  }
  return result;
}

uint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance Int64( uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result * *a2;
  else {
    __break(1u);
  }
  return result;
}

void *protocol witness for Strideable.distance(to:) in conformance Int@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if (__OFSUB__(*result, *v2)) {
    __break(1u);
  }
  else {
    *a2 = *result - *v2;
  }
  return result;
}

unint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int64( int64_t *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  int64_t v6 = *a4 + *a6;
  unint64_t v7 = 0x8000000000000000LL;
  if (__OFADD__(*a4, *a6)) {
    int64_t v6 = (v6 >> 63) ^ 0x8000000000000000LL;
  }
  else {
    unint64_t v7 = 0LL;
  }
  *a1 = v6;
  return v7;
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int64@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int64( void *result, void *a2)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int64@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int64( void *result, void *a2)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int(void *a1, void *a2)
{
  return *a1 < *a2;
}

void Int.hash(into:)(int a1, Swift::UInt a2)
{
}

uint64_t type metadata accessor for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for IndexingIterator);
}

uint64_t type metadata accessor for EnumeratedSequence.Iterator( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata( a1,  a2,  a3,  a4,  (uint64_t)&nominal type descriptor for EnumeratedSequence.Iterator);
}

uint64_t type metadata accessor for Optional(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata( a1,  a2,  a3,  a4,  &nominal type descriptor for Optional,  &flag for loading of canonical specialized generic type metadata for Optional);
}

uint64_t Int._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int@<X0>( void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

Swift::Int __swiftcall _unsafePlus(_:_:)(Swift::Int a1, Swift::Int a2)
{
  return a2 + a1;
}

Swift::Int __swiftcall _unsafeMinus(_:_:)(Swift::Int a1, Swift::Int a2)
{
  return a1 - a2;
}

uint64_t _IntegerAnyHashableBox._canonicalBox.getter@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v41 = a2;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 8LL);
  uint64_t v5 = *(void *)(*(void *)(v4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v38 - v8;
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v38 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v38 - v14;
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v38 - v16;
  uint64_t v42 = v18;
  uint64_t v39 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 16);
  uint64_t v40 = v2;
  v39((char *)&v38 - v16, v2, v3);
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  if ((v19(v3, v4) & 1) != 0)
  {
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 128))(v3, v4);
    if (v20 < 64)
    {
LABEL_10:
      uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
      uint64_t v26 = *(void (**)(char *, uint64_t))(v42 + 8);
      v26(v17, v3);
      if (v27 < 0) {
        goto LABEL_14;
      }
      goto LABEL_16;
    }
  }

  else
  {
    uint64_t v38 = v12;
    char v23 = v19(v3, v4);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 128))(v3, v4);
    if ((v23 & 1) == 0)
    {
      if (v20 < 64) {
        goto LABEL_10;
      }
      uint64_t v26 = *(void (**)(char *, uint64_t))(v42 + 8);
      v26(v17, v3);
LABEL_16:
      uint64_t v34 = v41;
      goto LABEL_17;
    }

    if (v20 <= 64)
    {
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      (*(void (**)(char *, uint64_t, uint64_t))(v5 + 24))(v9, v3, v5);
      char v29 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8LL) + 16LL))( v17,  v15,  v3);
      uint64_t v30 = v42;
      uint64_t v26 = *(void (**)(char *, uint64_t))(v42 + 8);
      v26(v15, v3);
      uint64_t v31 = *(void (**)(char *, char *, uint64_t))(v30 + 32);
      BOOL v32 = v38;
      v31(v38, v17, v3);
      if ((v29 & 1) == 0)
      {
        uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
        v26(v32, v3);
        uint64_t v34 = v41;
        if (v37 < 0)
        {
          uint64_t v33 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
          goto LABEL_15;
        }

uint64_t _IntegerAnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(ValueMetadata **)(a2 + 16);
  uint64_t v5 = *(void *)(*(void *)(a2 + 24) + 8LL);
  char v79 = *(const char **)(*(void *)(v5 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v79,  (uint64_t)v4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v78 = (char *)&v78 - v8;
  Description = (void (**)(char *, void, ValueMetadata *))v4[-1].Description;
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v78 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v78 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v78 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v78 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v80 = (char *)&v78 - v22;
  MEMORY[0x1895F8858](v21);
  uint64_t v24 = (char *)&v78 - v23;
  if (v4 == &type metadata for UInt64)
  {
    outlined init with copy of MirrorPath(a1, (uint64_t)v83);
    BOOL v32 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
    uint64_t v33 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
    uint64_t v35 = Description;
    uint64_t v34 = v82;
    Description[2](v24, v2, &type metadata for UInt64);
    uint64_t v36 = *(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 64);
    if ((v36(&type metadata for UInt64, v5) & 1) != 0)
    {
      char v37 = v36(&type metadata for UInt64, v5);
      uint64_t v38 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for UInt64, v5);
      if ((v37 & 1) != 0)
      {
        if (v38 <= 64)
        {
          uint64_t v41 = v79;
          unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v79,  (uint64_t)&type metadata for UInt64,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v43 = v78;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
          char v44 = v80;
          (*((void (**)(char *, ValueMetadata *, const char *))v41 + 3))(v43, &type metadata for UInt64, v41);
          char v45 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 32) + 8LL)
                                                                           + 32LL))( v24,  v44,  &type metadata for UInt64);
          char v46 = (void (*)(char *, ValueMetadata *))v35[1];
          v46(v44, &type metadata for UInt64);
          ((void (**)(char *, char *, ValueMetadata *))v35)[4](v20, v24, &type metadata for UInt64);
          if ((v45 & 1) == 0)
          {
            v46(v20, &type metadata for UInt64);
            return 0LL;
          }

          uint64_t v47 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for UInt64, v5);
          v46(v20, &type metadata for UInt64);
LABEL_19:
          BOOL v57 = v47 == v34;
LABEL_23:
          char v59 = v57;
          return v59 & 1;
        }

uint64_t _IntegerAnyHashableBox._hashValue.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 24) + 8LL) + 16LL) + 16LL))(*(void *)(a1 + 16));
}

uint64_t _IntegerAnyHashableBox._hash(into:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)(*(void *)(a2 + 24) + 8LL) + 16LL) + 24LL))( a1,  *(void *)(a2 + 16));
}

Swift::Int __swiftcall _IntegerAnyHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  return (*(uint64_t (**)(Swift::Int, void))(*(void *)(*(void *)(*(void *)(v1 + 24) + 8LL) + 16LL)
                                                       + 32LL))( _seed,  *(void *)(v1 + 16));
}

uint64_t _IntegerAnyHashableBox._unbox<A>()@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  int64_t v6 = *(swift **)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (uint64_t *)((char *)&v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *, uint64_t, swift *))(v9 + 16))(v8, v3, v6);
  int v10 = swift_dynamicCast(a3, v8, v6, a2, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a2 - 1) + 56LL))( a3,  v10 ^ 1u,  1LL,  a2);
}

uint64_t _ConcreteHashableBox._downCastConditional<A>(into:)( char *a1, uint64_t a2, const char *a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v9 = type metadata accessor for Optional(0LL, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v26 - v12;
  uint64_t v14 = *(swift **)(a2 + 16);
  uint64_t v15 = MEMORY[0x1895F8858](v11);
  uint64_t v17 = (uint64_t *)((char *)&v26 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v18 = *((void *)a3 - 1);
  MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v26 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t *, uint64_t, swift *))(v21 + 16))(v17, v5, v14);
  uint64_t v22 = swift_dynamicCast(v13, v17, v14, a3, 6uLL);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v18 + 56);
  if ((_DWORD)v22)
  {
    v23(v13, 0LL, 1LL, a3);
    uint64_t v24 = *(void (**)(char *, char *, const char *))(v18 + 32);
    v24(v20, v13, a3);
    v24(a1, v20, a3);
  }

  else
  {
    v23(v13, 1LL, 1LL, a3);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, v9);
  }

  return v22;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _IntegerAnyHashableBox<A>@<X0>( const char *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return _IntegerAnyHashableBox._unbox<A>()(a2, a1, a3);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _UInt128( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance _UInt128( a1,  a2,  (uint64_t (*)(uint64_t, void, void, void))specialized BinaryInteger._description(radix:uppercase:));
}

uint64_t < infix<A, B>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = a8;
  uint64_t v30 = a3;
  uint64_t v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, a6, 0LL, 0LL);
  uint64_t v32 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v29 - v17;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL);
  v19((char *)&v29 - v17, a1, a5);
  uint64_t v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16LL);
  uint64_t v22 = a2;
  uint64_t v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  uint64_t v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  else {
    char v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 16))(v18, v16, a5);
  }
  char v26 = v25;
  uint64_t v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 < v3;
  if (v4) {
    return *a1 < *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 >= v2;
  if (v4) {
    return *a2 >= *a1;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 >= v3;
  if (v4) {
    return *a1 >= *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 < v2;
  if (v4) {
    return *a2 < *a1;
  }
  else {
    return v5;
  }
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance _UInt128@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  BOOL v5 = __CFADD__(*result, *a2);
  BOOL v6 = __CFADD__(v3, v4);
  uint64_t v7 = v3 + v4;
  if (v6 || (v5 ? (BOOL v8 = v7 == -1) : (BOOL v8 = 0), v8)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x6BuLL,  0);
  }
  *a3 = *result + *a2;
  a3[1] = v7 + v5;
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance _UInt128( void *a1, uint64_t *a2)
{
  return specialized static _UInt128.+= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance _UInt128@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  unint64_t v6 = *a2;
  unint64_t v5 = a2[1];
  BOOL v7 = v3 >= v5;
  unint64_t v8 = v3 - v5;
  int v9 = !v7;
  BOOL v7 = v4 >= v6;
  unint64_t v10 = v4 - v6;
  if (v7)
  {
    if (v9) {
      goto LABEL_8;
    }
  }

  else
  {
    if (!v8) {
      LOBYTE(v9) = 1;
    }
    if ((v9 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x5FuLL,  0);
    --v8;
  }

  *a3 = v10;
  a3[1] = v8;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance _UInt128( unint64_t *a1, unint64_t *a2)
{
  return specialized static _UInt128.-= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t _UInt128.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  Swift::String::Index v232 = *(const char **)(swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)
                        + 16);
  unint64_t v231 = swift_getAssociatedTypeWitness( 0LL,  v232,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v231);
  unint64_t v230 = (char *)&v218 - v8;
  int v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  unint64_t v247 = *(v9 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  int64_t v222 = (char *)&v218 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  unint64_t v239 = (char *)&v218 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  char v243 = (char *)&v218 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v244 = (char *)&v218 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v246 = (char *)&v218 - v18;
  uint64_t v249 = v6;
  unint64_t v238 = *(const char **)(v6 + 16);
  unint64_t v237 = swift_getAssociatedTypeWitness( 0LL,  v238,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v19 = MEMORY[0x1895F8858](v237);
  unint64_t v236 = (char *)&v218 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v218 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  unint64_t v240 = (char *)&v218 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  int64_t v221 = (char *)&v218 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  Swift::String::Index v233 = (char *)&v218 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v32 = (char *)&v218 - v31;
  uint64_t v33 = MEMORY[0x1895F8858](v30);
  unint64_t v229 = (char *)&v218 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v224 = (char *)&v218 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  unint64_t v241 = (char *)&v218 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  unint64_t v242 = (char *)&v218 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v225 = (char *)&v218 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  char v45 = (char *)&v218 - v44;
  uint64_t v46 = MEMORY[0x1895F8858](v43);
  char v250 = (char *)&v218 - v47;
  MEMORY[0x1895F8858](v46);
  char v49 = (char *)&v218 - v48;
  uint64_t v248 = v50;
  unint64_t v51 = *(void (**)(char *, char *, uint64_t))(v50 + 16);
  unint64_t v251 = a1;
  Swift::String::Index v234 = v51;
  v51((char *)&v218 - v48, a1, a2);
  uint64_t v52 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v53 = v52(a2, a3);
  uint32x4_t v220 = v23;
  uint64_t v226 = v52;
  if ((v53 & 1) != 0)
  {
    unint64_t v235 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v54 = v235(a2, a3);
    if (v54 < 64)
    {
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v58 = *(void (**)(char *, uint64_t))(v248 + 8);
      char v59 = v49;
      goto LABEL_4;
    }

    goto LABEL_8;
  }

  char v61 = v52(a2, a3);
  unint64_t v235 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v54 = v235(a2, a3);
  if ((v61 & 1) == 0)
  {
    unint64_t v60 = v247;
    if (v54 < 64)
    {
      uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      uint64_t v58 = *(void (**)(char *, uint64_t))(v248 + 8);
      v58(v49, a2);
      if (v66 < 0) {
        goto LABEL_16;
      }
    }

    else
    {
      uint64_t v58 = *(void (**)(char *, uint64_t))(v248 + 8);
      v58(v49, a2);
    }

    goto LABEL_18;
  }

  if (v54 > 64)
  {
LABEL_8:
    unint64_t v252 = 0LL;
    uint64_t v62 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v63 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    unint64_t v64 = v250;
    v62(&v252, &type metadata for Int, v63, a2, a3);
    char v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v49,  v64,  a2);
    uint64_t v58 = *(void (**)(char *, uint64_t))(v248 + 8);
    v58(v64, a2);
    v58(v49, a2);
    unint64_t v60 = v247;
    if ((v65 & 1) == 0) {
      goto LABEL_18;
    }
LABEL_16:
    v58(v251, a2);
    return 0LL;
  }

  unint64_t v67 = v237;
  uint64_t v68 = v238;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v238,  a2,  v237,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  BOOL v70 = v236;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v67,  AssociatedConformanceWitness);
  unint64_t v71 = v250;
  (*((void (**)(char *, uint64_t, const char *))v68 + 3))(v70, a2, v68);
  LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v49,  v71,  a2);
  uint64_t v72 = v248;
  uint64_t v58 = *(void (**)(char *, uint64_t))(v248 + 8);
  v58(v71, a2);
  (*(void (**)(char *, char *, uint64_t))(v72 + 32))(v45, v49, a2);
  if ((v67 & 1) != 0)
  {
    v58(v45, a2);
    goto LABEL_16;
  }

  uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  char v59 = v45;
LABEL_4:
  v58(v59, a2);
  unint64_t v60 = v247;
  if (v57 < 0) {
    goto LABEL_16;
  }
LABEL_18:
  unint64_t v245 = v58;
  uint64x2_t v227 = v32;
  uint64_t v74 = v249;
  uint64_t v75 = a3;
  unint64_t v76 = v246;
  (*(void (**)(uint64_t, uint64_t))(v249 + 56))(a2, v249);
  uint64_t v228 = v75;
  unint64_t v77 = swift_getAssociatedConformanceWitness( v75,  a2,  (uint64_t)v9,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v78 = *(uint64_t (**)(unint64_t *))(v77 + 64);
  unint64_t v223 = v77;
  char v79 = v78(v9);
  uint64_t v80 = *(void (**)(char *, char *, unint64_t *))(v60 + 16);
  uint64_t v81 = v244;
  v80(v244, v76, v9);
  uint64_t v219 = (uint64_t (*)(unint64_t *, unint64_t))v78;
  if ((v79 & 1) != 0)
  {
    uint64_t v82 = v232;
    unint64_t v83 = v231;
    unint64_t v84 = swift_getAssociatedConformanceWitness( (uint64_t)v232,  (uint64_t)v9,  v231,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v85 = v81;
    uint64_t v86 = v230;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v84 + 8))( &qword_18180BE68,  256LL,  v83,  v84);
    uint64_t v87 = v243;
    (*((void (**)(char *, unint64_t *, const char *))v82 + 3))(v86, v9, v82);
    unint64_t v88 = swift_getAssociatedConformanceWitness( v249,  a2,  (uint64_t)v9,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    LOBYTE(v83) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v88 + 16))( v85,  v87,  v9,  v88);
    uint64_t v89 = *(void (**)(char *, unint64_t *))(v60 + 8);
    v89(v87, v9);
    int64_t v90 = v85;
    uint64_t v74 = v249;
    v89(v90, v9);
    if ((v83 & 1) != 0)
    {
LABEL_40:
      uint64_t v135 = ((uint64_t (*)(char *, unint64_t *))v89)(v76, v9);
      unint64_t v252 = -1LL;
      uint64_t v136 = v228;
      uint64_t v137 = *(void (**)(unint64_t *, ValueMetadata *))(v228 + 88);
      unint64_t v140 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v135, v138, v139);
      int8x16_t v141 = v250;
      unint64_t v247 = v140;
      v137(&v252, &type metadata for UInt64);
      int8x16_t v142 = v225;
      uint64_t v143 = v251;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v136 + 192))(v251, v141, a2, v136);
      int64_t v144 = v245;
      uint64_t v145 = ((uint64_t (*)(char *, uint64_t))v245)(v141, a2);
      unint64_t v252 = 64LL;
      unint64_t v146 = *(void (**)(void (*)(void, void, void), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v136 + 240);
      unint64_t v149 = lazy protocol witness table accessor for type Int and conformance Int(v145, v147, v148);
      v146((void (*)(void, void, void))v143, &v252, &type metadata for Int, v149, a2, v136);
      v144(v143, a2);
      unint64_t v150 = v241;
      unint64_t v251 = *(char **)(v248 + 32);
      ((void (*)(char *, char *, uint64_t))v251)(v241, v142, a2);
      unint64_t v151 = v226;
      char v152 = v226(a2, v136);
      int8x16_t v153 = v233;
      int8x16_t v154 = v234;
      if ((v152 & 1) != 0)
      {
        int64x2_t v155 = v233;
        int64x2_t v156 = v224;
        v234(v224, v150, a2);
        unint64_t v157 = v237;
        int64x2_t v158 = v238;
        unint64_t v159 = swift_getAssociatedConformanceWitness( (uint64_t)v238,  a2,  v237,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        int8x16_t v160 = v236;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v159 + 8))( &qword_18180BE68,  256LL,  v157,  v159);
        unint64_t v161 = v250;
        int64x2_t v162 = v160;
        int64_t v144 = v245;
        (*((void (**)(char *, uint64_t, const char *))v158 + 3))(v162, a2, v158);
        LOBYTE(v157) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v136 + 32) + 8LL)
                                                                          + 32LL))( v156,  v161,  a2);
        v144(v161, a2);
        if ((v157 & 1) == 0) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
        }
        v144(v156, a2);
        unint64_t v150 = v241;
        int8x16_t v153 = v155;
      }

      int8x16_t v163 = v235;
      if (v235(a2, v136) < 64)
      {
LABEL_57:
        uint64_t v249 = *(void *)(v136 + 120);
        uint64_t v181 = ((uint64_t (*)(uint64_t, uint64_t))v249)(a2, v136);
        int64x2_t v182 = v150;
        uint64_t v73 = v181;
        v144(v182, a2);
        int64x2_t v183 = v227;
        ((void (*)(char *, char *, uint64_t))v251)(v227, v242, a2);
        char v184 = v151(a2, v136);
        v154(v153, v183, a2);
        if ((v184 & 1) != 0)
        {
          unint64_t v185 = v237;
          int64x2_t v186 = v238;
          unint64_t v187 = swift_getAssociatedConformanceWitness( (uint64_t)v238,  a2,  v237,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          int8x16_t v188 = v151;
          int8x16_t v189 = v153;
          int8x16_t v190 = v236;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v187 + 8))( &qword_18180BE68,  256LL,  v185,  v187);
          int8x16_t v191 = v250;
          (*((void (**)(char *, uint64_t, const char *))v186 + 3))(v190, a2, v186);
          LOBYTE(v185) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v136 + 32) + 8LL)
                                                                            + 16LL))( v189,  v191,  a2);
          int8x16_t v192 = v191;
          int8x16_t v163 = v235;
          int64_t v144 = v245;
          v245(v192, a2);
          int8x16_t v193 = v189;
          unint64_t v151 = v188;
          int8x16_t v154 = v234;
          v144(v193, a2);
          if ((v185 & 1) != 0) {
            goto LABEL_74;
          }
        }

        else
        {
          v144(v153, a2);
        }

        uint8x16_t v194 = v227;
        uint64_t v195 = v163(a2, v136);
        v154(v240, v194, a2);
        if (v195 <= 63)
        {
          v144(v240, a2);
          goto LABEL_63;
        }

        unint64_t v252 = -1LL;
        char v198 = v151(a2, v136);
        uint16x8_t v199 = v163;
        char v200 = v198;
        uint64_t v201 = v199(a2, v136);
        if ((v200 & 1) != 0)
        {
          if (v201 < 65)
          {
            unint64_t v202 = v237;
            uint64x2_t v203 = v238;
            unint64_t v204 = swift_getAssociatedConformanceWitness( (uint64_t)v238,  a2,  v237,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64x2_t v205 = v236;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v204 + 8))( &qword_18180BE68,  256LL,  v202,  v204);
            uint32x4_t v206 = v250;
            (*((void (**)(char *, uint64_t, const char *))v203 + 3))(v205, a2, v203);
            uint64x2_t v207 = v240;
            LOBYTE(v202) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v136 + 32) + 8LL)
                                                                              + 40LL))( v240,  v206,  a2);
            uint64x2_t v208 = v245;
            v245(v206, a2);
            int8x16_t v209 = v220;
            unint64_t v210 = v252;
            ((void (*)(char *, char *, uint64_t))v251)(v220, v207, a2);
            if ((v202 & 1) != 0)
            {
              unint64_t v211 = ((uint64_t (*)(uint64_t, uint64_t))v249)(a2, v136);
              v208(v209, a2);
              BOOL v132 = v210 >= v211;
              int64_t v144 = v208;
              if (!v132) {
                goto LABEL_74;
              }
            }

            else
            {
              v208(v209, a2);
              int64_t v144 = v208;
            }

            goto LABEL_63;
          }
        }

        else if (v201 < 65)
        {
          unint64_t v215 = v250;
          ((void (*)(char *, char *, uint64_t))v251)(v250, v240, a2);
          unint64_t v216 = ((uint64_t (*)(uint64_t, uint64_t))v249)(a2, v136);
          unint64_t v217 = v215;
          int64_t v144 = v245;
          v245(v217, a2);
          if (v252 < v216)
          {
LABEL_74:
            v144(v227, a2);
            return 0LL;
          }

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance _UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128( (uint64_t (*)(void))_UInt128.init<A>(exactly:),  a1);
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration( a1,  a2,  (uint64_t (*)(void, void, void, void))specialized static _UInt128.* infix(_:_:),  a3);
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance _UInt128( unint64_t *a1, unint64_t *a2)
{
  return specialized static _UInt128.*= infix(_:_:)(a1, *a2, a2[1]);
}

void *protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance _UInt128@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if ((*result & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000028LL,  0x80000001818B7CB0LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x85uLL,  0);
  }
  *a2 = *result;
  a2[1] = 0LL;
  return result;
}

unint64_t specialized _wideMaskedShiftRight<A>(_:_:)( unint64_t *a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((a4 & 0x7Fu) >= 0x40uLL)
  {
    *a1 = a2 >> a4;
    return 0LL;
  }

  else if ((a4 & 0x7F) != 0)
  {
    *a1 = (a3 >> a4) | (a2 << -a4);
    return a2 >> a4;
  }

  else
  {
    *a1 = a3;
    return a2;
  }

uint64_t specialized _wideMaskedShiftRight<A>(_:_:)(uint64_t *a1, uint64_t a2, unint64_t a3, char a4)
{
  if ((a4 & 0x7Fu) >= 0x40uLL)
  {
    *a1 = a2 >> a4;
    return a2 >> 63;
  }

  else if ((a4 & 0x7F) != 0)
  {
    *a1 = (a3 >> a4) | (a2 << -a4);
    return a2 >> a4;
  }

  else
  {
    *a1 = a3;
    return a2;
  }

uint64_t (*protocol witness for Collection.subscript.read in conformance _UInt128.Words( uint64_t *a1, unint64_t *a2))()
{
  *a1 = _UInt128.Words.subscript.getter(*a2, *v2, v2[1], 0xC7uLL);
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 specialized _wideDivide22<A>(_:by:)( Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 a3, Swift::UInt64 a4, unint64_t a5, unint64_t a6)
{
  if (!(a5 | a6)) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000010LL,  0x80000001818B45F0LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x4CFuLL,  0);
  }
  high = (void *)a3.high;
  BOOL v9 = a6 < a4;
  if (a5 != a3.low) {
    BOOL v9 = a5 < a3.low;
  }
  if (v9)
  {
    if (a3.low)
    {
      if (a5)
      {
        unint64_t v10 = __clz(a5);
        if (v10)
        {
          a5 = (a6 >> -(char)v10) | (a5 << v10);
          a6 <<= v10;
          if (((0x80 - (_BYTE)v10) & 0x7F) != 0) {
            Swift::UInt64 v11 = (a4 >> (0x80 - v10)) | (a3.low << v10);
          }
          else {
            Swift::UInt64 v11 = a4;
          }
          Swift::UInt64 v12 = a4 >> (-(char)v10 & 0x3F);
          unint64_t v13 = a4 << v10;
          if (((0x80 - (_BYTE)v10) & 0x7Fu) <= 0x3FuLL) {
            a4 = v11;
          }
          else {
            a4 = a3.low >> (0x80 - v10);
          }
          a3.Swift::UInt64 low = v12 | (a3.low << v10);
        }

        else
        {
          unint64_t v13 = a4;
        }

        a3.high = a4;
        Swift::UInt64 v20 = specialized _wideDivide32<A>(_:by:)(&v25, &v24, a3, v13, a5, a6);
        Swift::UInt64 v15 = 0LL;
        unint64_t v22 = v24;
        Swift::UInt64 v21 = v25;
        *a1 = v20;
        if (v10)
        {
          unint64_t v22 = (v22 >> v10) | (v21 << -(char)v10);
          v21 >>= v10;
        }

        void *high = v22;
        *a2 = v21;
        return v15;
      }

      if (a6)
      {
        Swift::UInt64 v15 = a3.low / a6;
        if (a3.low % a6)
        {
          v16.Swift::UInt64 low = a4;
          v16.high = a3.low % a6;
          Swift::tuple_quotient_UInt64_remainder_UInt64 v19 = UInt64.dividingFullWidth(_:)(v16);
          Swift::UInt64 remainder = v19.remainder;
          Swift::UInt64 quotient = v19.quotient;
        }

        else
        {
          Swift::UInt64 quotient = a4 / a6;
          Swift::UInt64 remainder = a4 % a6;
        }

        *a1 = quotient;
        void *high = remainder;
        goto LABEL_30;
      }
    }

    else if (a6)
    {
      Swift::UInt64 v15 = 0LL;
      *(void *)a3.high = a4 % a6;
      *a1 = a4 / a6;
LABEL_30:
      *a2 = 0LL;
      return v15;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x25E8uLL,  0);
  }

  BOOL v14 = a3.low < a5;
  Swift::UInt64 v15 = 0LL;
  if (a5 == a3.low) {
    BOOL v14 = a4 < a6;
  }
  if (v14)
  {
    *a1 = 0LL;
    *a2 = a3.low;
    *(void *)a3.high = a4;
  }

  else
  {
    *a1 = 1LL;
    *a2 = 0LL;
    *(void *)a3.high = 0LL;
  }

  return v15;
}

Swift::tuple_high__UInt128_low__UInt128 __swiftcall _UInt128.multipliedFullWidth(by:)(Swift::_UInt128 by)
{
  Swift::UInt64 v3 = v1 * by.low;
  unint64_t v4 = (__PAIR128__(v2, v1) * by.low) >> 64;
  BOOL v5 = __CFADD__((v1 * (unsigned __int128)by.low) >> 64, v2 * by.low);
  unint64_t v6 = (v2 * (unsigned __int128)by.high) >> 64;
  uint64_t v7 = (v1 * (unsigned __int128)by.high) >> 64;
  uint64_t v8 = (v2 * (unsigned __int128)by.low) >> 64;
  unsigned __int128 v11 = __PAIR128__(v2 * by.high, v4) + v1 * by.high;
  BOOL v9 = __CFADD__(__CFADD__(v4, v1 * by.high), v2 * by.high) | __CFADD__(v5, *((void *)&v11 + 1));
  BOOL v10 = v5 + *((void *)&v11 + 1);
  uint64_t v12 = v9;
  BOOL v9 = __CFADD__(v8, v7);
  unint64_t v13 = v8 + v7;
  if (v9) {
    ++v6;
  }
  Swift::UInt64 v15 = (__PAIR128__(v6, v13) + __PAIR128__(v12, v10)) >> 64;
  Swift::UInt64 v14 = v13 + v10;
  Swift::UInt64 v16 = v3;
  Swift::UInt64 v17 = v11;
  result.low.high = v17;
  result.low.Swift::UInt64 low = v16;
  result.high.high = v15;
  result.high.Swift::UInt64 low = v14;
  return result;
}

Swift::UInt64 specialized _wideDivide42<A>(_:by:)( Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 a3, Swift::UInt64 a4, Swift::UInt64 a5, Swift::UInt64 a6, Swift::UInt64 a7, unint64_t a8)
{
  unint64_t v8 = a8;
  if (!(a7 | a8)) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000010LL,  0x80000001818B45F0LL | 0x8000000000000000LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x4F7uLL,  0);
  }
  Swift::UInt64 v9 = a7;
  BOOL v10 = a8 >= a4;
  if (a7 != a3.low) {
    BOOL v10 = a7 >= a3.low;
  }
  if (!v10) {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD00000000000001FLL,  0x80000001818B45B0LL | 0x8000000000000000LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x4FAuLL,  0);
  }
  unint64_t v11 = a6;
  Swift::UInt64 v12 = a5;
  high = (void *)a3.high;
  if (!(a3.low | a4))
  {
    a3.Swift::UInt64 low = a5;
    return specialized _wideDivide22<A>(_:by:)(a1, a2, a3, a6, a7, a8);
  }

  if (a7)
  {
    unint64_t v17 = __clz(a7);
    if (v17)
    {
      char v18 = 0x80 - v17;
      unint64_t v8 = a8 << v17;
      Swift::UInt64 v9 = (a8 >> -(char)v17) | (a7 << v17);
      a3.high = (a4 >> -(char)v17) | (a3.low << v17);
      unint64_t v19 = (128 - v17) & 0x7F;
      Swift::UInt64 v20 = a5 << v17;
      if (v19 > 0x3F)
      {
        Swift::UInt64 v25 = a5 >> v18;
      }

      else
      {
        Swift::UInt64 v21 = (a6 >> v18) | v20;
        Swift::UInt64 v22 = a5 >> v18;
        BOOL v23 = v19 == 0;
        if (v19) {
          Swift::UInt64 v24 = v22;
        }
        else {
          Swift::UInt64 v24 = a5;
        }
        if (v23) {
          Swift::UInt64 v25 = a6;
        }
        else {
          Swift::UInt64 v25 = v21;
        }
        a3.high |= v24;
      }

      a3.Swift::UInt64 low = v25 | (a4 << v17);
      Swift::UInt64 v12 = (a6 >> (-(char)v17 & 0x3F)) | v20;
      unint64_t v11 = a6 << v17;
      if (a3.high) {
        goto LABEL_30;
      }
    }

    else
    {
      a3.high = a5 | a3.low;
      a3.Swift::UInt64 low = a6 | a4;
      if (a3.high) {
        goto LABEL_30;
      }
    }

    BOOL v36 = v12 < v8;
    if (a3.low != v9) {
      BOOL v36 = a3.low < v9;
    }
    if (v36)
    {
      v46.high = a3.low;
      v46.Swift::UInt64 low = v12;
      Swift::UInt64 v37 = specialized _wideDivide32<A>(_:by:)(&v45, &v44, v46, v11, v9, v8);
      Swift::UInt64 quotient = 0LL;
      Swift::UInt64 v39 = v44;
      Swift::UInt64 v38 = v45;
      *a1 = v37;
      Swift::UInt64 v40 = (v39 >> v17) | (v38 << -(char)v17);
      BOOL v41 = v17 == 0;
      Swift::UInt64 v42 = v38 >> v17;
LABEL_31:
      if (!v41)
      {
        Swift::UInt64 v39 = v40;
        Swift::UInt64 v38 = v42;
      }

      void *high = v39;
      *a2 = v38;
      return quotient;
    }

uint64_t specialized _wideMaskedShiftLeft<A>(_:_:)( uint64_t *a1, unint64_t a2, unint64_t a3, char a4)
{
  unint64_t v4 = (a2 << a4) | (a3 >> -a4);
  if ((a4 & 0x7F) != 0) {
    uint64_t v5 = a3 << a4;
  }
  else {
    uint64_t v5 = a3;
  }
  if ((a4 & 0x7F) == 0) {
    unint64_t v4 = a2;
  }
  if ((a4 & 0x7Fu) <= 0x3FuLL)
  {
    uint64_t v6 = v4;
  }

  else
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = a3 << a4;
  }

  *a1 = v5;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance _UInt128( void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = v2[1];
  BOOL v5 = __CFADD__(*v2, *a2);
  BOOL v6 = __CFADD__(v4, v3);
  uint64_t v7 = v4 + v3;
  if (v6)
  {
    uint64_t v8 = 1LL;
    if (!v5)
    {
LABEL_12:
      uint64_t v9 = 0LL;
      goto LABEL_13;
    }
  }

  else
  {
    uint64_t v8 = v7 == -1 && v5;
    if (!v5) {
      goto LABEL_12;
    }
  }

  uint64_t v9 = 1LL;
LABEL_13:
  *a1 = *v2 + *a2;
  a1[1] = v9 + v7;
  return v8;
}

unint64_t protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance _UInt128( unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  BOOL v7 = v6 >= v4;
  unint64_t v8 = v6 - v4;
  int v9 = !v7;
  BOOL v7 = v5 >= v3;
  unint64_t v10 = v5 - v3;
  LODWORD(v3) = v5 < v3;
  if (v7)
  {
    if (v9)
    {
      unint64_t v3 = 1LL;
      unint64_t v11 = v8;
      goto LABEL_13;
    }

    unint64_t v11 = v8;
  }

  else
  {
    unint64_t v11 = v8 - 1;
    if ((v9 & 1) != 0)
    {
      unint64_t v3 = 1LL;
      goto LABEL_13;
    }
  }

  if (v8) {
    unint64_t v3 = 0LL;
  }
  else {
    unint64_t v3 = v3;
  }
LABEL_13:
  *a1 = v10;
  a1[1] = v11;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance _UInt128( unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  BOOL v7 = !is_mul_ok(v6, *a2);
  unint64_t v8 = v6 * *a2;
  BOOL v9 = !is_mul_ok(*v2, v4);
  unint64_t v10 = v8 + *v2 * v4;
  BOOL v11 = __CFADD__(v8, *v2 * v4);
  unint64_t v12 = v5 * v3;
  uint64_t v13 = (v5 * (unsigned __int128)v3) >> 64;
  unint64_t v14 = v10 + v13;
  BOOL v15 = __CFADD__(v10, v13);
  if (v4) {
    BOOL v16 = v6 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  uint64_t v17 = 1LL;
  if (v16)
  {
    unsigned int v18 = v9 || v11 || v15;
    if (v7) {
      uint64_t v17 = 1LL;
    }
    else {
      uint64_t v17 = v18;
    }
  }

  *a1 = v12;
  a1[1] = v14;
  return v17;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance _UInt128( Swift::UInt64 *a1, unint64_t *a2)
{
  unint64_t v4 = a2[1];
  Swift::UInt64 v6 = *v2;
  v5.Swift::UInt64 low = v2[1];
  unint64_t v7 = v4 | *a2;
  BOOL v8 = v7 == 0;
  if (v7)
  {
    v5.high = (Swift::UInt64)&v10;
    v5.Swift::UInt64 low = specialized _wideDivide22<A>(_:by:)(&v12, &v11, v5, v6, v4, *a2);
    Swift::UInt64 v6 = v12;
  }

  *a1 = v6;
  a1[1] = v5.low;
  return v8;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance _UInt128( Swift::UInt64 *a1, unint64_t *a2)
{
  unint64_t v4 = a2[1];
  Swift::UInt64 v6 = *v2;
  v5.Swift::UInt64 low = v2[1];
  unint64_t v7 = v4 | *a2;
  BOOL v8 = v7 == 0;
  if (v7)
  {
    v5.high = (Swift::UInt64)&v10;
    specialized _wideDivide22<A>(_:by:)(&v12, &v11, v5, v6, v4, *a2);
    Swift::UInt64 v6 = v10;
    v5.Swift::UInt64 low = v11;
  }

  *a1 = v6;
  a1[1] = v5.low;
  return v8;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128( uint64_t *a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, void, void, void))_UInt128.multipliedFullWidth(by:));
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance _UInt128( void *a1, void *a2, Swift::UInt64 *a3, Swift::UInt64 *a4)
{
  Swift::UInt64 v7 = *a3;
  Swift::UInt64 v8 = a3[1];
  Swift::UInt64 v10 = *a4;
  Swift::UInt64 v9 = a4[1];
  v17.high = (Swift::UInt64)&v14;
  v17.Swift::UInt64 low = v8;
  Swift::UInt64 result = specialized _wideDivide42<A>(_:by:)(&v16, &v15, v17, v7, v9, v10, v4[1], *v4);
  Swift::UInt64 v12 = v15;
  uint64_t v13 = v14;
  *a1 = v16;
  a1[1] = result;
  *a2 = v13;
  a2[1] = v12;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  return protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128( a1,  a2,  (uint64_t (*)(uint64_t, void, void, void))specialized _wideMaskedShiftRight<A>(_:_:),  a3);
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance _UInt128( uint64_t *a1, void *a2)
{
  return specialized static _UInt128.&>>= infix(_:_:)(a1, *a2);
}

uint64_t protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance _Int128@<X0>( unint64_t *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(a3, a1[1], *a1, *a2);
  a3[1] = result;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance _UInt128( uint64_t *a1, void *a2)
{
  return specialized static _Int128.&<<= infix(_:_:)(a1, *a2);
}

_OWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance _UInt128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = (*a2 * *result) >> 64;
  *a3 = *(void *)a2 * *(void *)result;
  a3[1] = v3;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance _UInt128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<D0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type _UInt128 and conformance _UInt128,  a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128( a1,  a2,  a3,  _UInt128.init<A>(exactly:),  0x85uLL,  a4);
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _UInt128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128( a1,  a2,  (uint64_t (*)(void))specialized static FixedWidthInteger._truncatingInit<A>(_:),  a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance _UInt128@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance _UInt128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance _UInt128@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration( a1,  a2,  (uint64_t (*)(void, void, void, void))specialized static _UInt128./ infix(_:_:),  a3);
}

Swift::UInt64 protocol witness for static BinaryInteger./= infix(_:_:) in conformance _UInt128( Swift::UInt64 *a1, unint64_t *a2)
{
  return specialized static _UInt128./= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance _UInt128@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration( a1,  a2,  specialized static _UInt128.% infix(_:_:),  a3);
}

Swift::UInt64 protocol witness for static BinaryInteger.%= infix(_:_:) in conformance _UInt128( Swift::UInt64 *a1, unint64_t *a2)
{
  return specialized static _UInt128.%= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance _UInt128@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v121 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v121,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v119 = (char *)&v116 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  Swift::UInt64 v15 = (char *)&v116 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  char v117 = (char *)&v116 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64x2_t v126 = (char *)&v116 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v124 = (char *)&v116 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v118 = (char *)&v116 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  BOOL v125 = (char *)&v116 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v127 = (char *)&v116 - v27;
  MEMORY[0x1895F8858](v26);
  Swift::tuple_quotient_UInt64_remainder_UInt64 v29 = (char *)&v116 - v28;
  unint64_t v30 = *a1;
  unint64_t v122 = a1[1];
  Swift::UInt64 v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  unint64_t v123 = v30;
  unint64_t v129 = v31;
  if ((v32 & 1) != 0)
  {
    Swift::UInt64 v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      uint64_t v131 = -128LL;
      Swift::tuple_high_UInt64_low_UInt64 v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v131, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      Swift::UInt64 v38 = v33;
      if ((v48 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      Swift::UInt64 v38 = v33;
      if (v37 < -128) {
        goto LABEL_24;
      }
    }

    goto LABEL_18;
  }

  unint64_t v128 = a5;
  char v39 = v31(a3, a4);
  Swift::UInt64 v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v40 = v38(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 >= 64)
    {
      a5 = v128;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    goto LABEL_17;
  }

  if (v40 > 64)
  {
    uint64_t v131 = -128LL;
    Swift::UInt64 v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v131, &type metadata for Int, v44, a3, a4);
    char v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    a5 = v128;
    if ((v45 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  unint64_t v50 = AssociatedTypeWitness;
  unint64_t v51 = v121;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v121,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v53 = v119;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v50,  AssociatedConformanceWitness);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v5_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t v54 = *(void (**)(char *, uint64_t))(v12 + 8);
  v54(v29, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
  if ((v50 & 1) == 0)
  {
    uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v54(v15, a3);
LABEL_17:
    a5 = v128;
    if (v49 < -128) {
      goto LABEL_24;
    }
LABEL_18:
    char v57 = v129(a3, a4);
    uint64_t v58 = v38(a3, a4);
    if ((v57 & 1) != 0)
    {
      if (v58 > 64) {
        goto LABEL_20;
      }
    }

    else if (v58 > 63)
    {
LABEL_20:
      uint64_t v131 = 128LL;
      char v61 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v62 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
      v61(&v131, &type metadata for Int, v62, a3, a4);
      char v63 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
      unint64_t v64 = *(void (**)(char *, uint64_t))(v12 + 8);
      v64(v29, a3);
      if ((v63 & 1) != 0) {
        goto LABEL_24;
      }
LABEL_25:
      unint64_t v128 = a5;
      uint64_t v66 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
      unint64_t v67 = v127;
      v66(v127, a2, a3);
      char v68 = v129(a3, a4);
      unint64_t v69 = v125;
      v66(v125, (uint64_t)v67, a3);
      unint64_t v116 = v38;
      if ((v68 & 1) == 0)
      {
        v64(v69, a3);
        unint64_t v71 = v126;
        goto LABEL_46;
      }

      uint64_t v70 = v38(a3, a4);
      v64(v69, a3);
      unint64_t v71 = v126;
      if (v70 <= 64) {
        goto LABEL_46;
      }
      uint64_t v72 = v118;
      v66(v118, (uint64_t)v67, a3);
      uint64_t v131 = 0x8000000000000000LL;
      uint64_t v73 = v129;
      if ((v129(a3, a4) & 1) != 0)
      {
        uint64_t v74 = v116(a3, a4);
        if (v74 < 64)
        {
          unint64_t v77 = v29;
LABEL_40:
          v66(v77, (uint64_t)v72, a3);
          uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v29, a3);
          if (v88 < v131) {
LABEL_69:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
          goto LABEL_44;
        }

        uint64_t v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
        v85(&v131, &type metadata for Int, v86, a3, a4);
        char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v72,  v29,  a3);
      }

      else
      {
        char v78 = v73(a3, a4);
        uint64_t v79 = v116(a3, a4);
        if ((v78 & 1) == 0)
        {
          if (v79 >= 64)
          {
            uint64_t v114 = v118;
LABEL_45:
            v64(v114, a3);
LABEL_46:
            uint64_t v98 = v116;
            uint64_t v99 = v116(a3, a4);
            uint64_t v100 = v124;
            v66(v124, (uint64_t)v67, a3);
            if (v99 < 65)
            {
              uint64_t v109 = v98(a3, a4);
              v64(v100, a3);
              BOOL v110 = v109 == 64;
              uint64_t v101 = v129;
              if (!v110 || (v129(a3, a4) & 1) != 0)
              {
LABEL_60:
                unint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v64(v67, a3);
                if ((v112 & 0x8000000000000000LL) != 0)
                {
                  a5 = v128;
                  if (v112 > 0xFFFFFFFFFFFFFF80LL)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    unint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v131, v122, v123, v115);
                    goto LABEL_63;
                  }
                }

                else
                {
                  a5 = v128;
                  if (v112 < 0x80)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    unint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v131, v122, v123, v113);
LABEL_63:
                    uint64_t v56 = v131;
                    goto LABEL_64;
                  }
                }

unint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance _UInt128( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v115 = a1;
  uint64_t v109 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v109,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v107 = (char *)&v104 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v104 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v105 = (char *)&v104 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v112 = (char *)&v104 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  BOOL v110 = (char *)&v104 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v106 = (char *)&v104 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  char v111 = (char *)&v104 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  char v113 = (char *)&v104 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v26 = (char *)&v104 - v25;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v31 = v27(a3, a4);
    uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v28 = v114(a3, a4);
    if ((v31 & 1) == 0)
    {
      if (v28 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }

    if (v28 <= 64)
    {
      uint64_t v104 = v27;
      unint64_t v55 = AssociatedTypeWitness;
      uint64_t v56 = v109;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v58 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v55,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v56 + 3))(v58, a3, v56);
      LOBYTE(v55) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v26,  a3);
      uint64_t v59 = *(void (**)(char *, uint64_t))(v9 + 8);
      v59(v26, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v55 & 1) != 0)
      {
        v59(v12, a3);
        goto LABEL_25;
      }

      uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v12, a3);
      uint64_t v27 = v104;
      if (v60 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }

unint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance _UInt128@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v121 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v121,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v119 = (char *)&v116 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v116 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v117 = (char *)&v116 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64x2_t v126 = (char *)&v116 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v124 = (char *)&v116 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v118 = (char *)&v116 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  BOOL v125 = (char *)&v116 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v127 = (char *)&v116 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v116 - v28;
  unint64_t v30 = *a1;
  unint64_t v122 = a1[1];
  char v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v31(a3, a4);
  unint64_t v123 = v30;
  unint64_t v129 = v31;
  if ((v32 & 1) != 0)
  {
    unint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      uint64_t v131 = -128LL;
      Swift::tuple_high_UInt64_low_UInt64 v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v131, &type metadata for Int, v47, a3, a4);
      char v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      uint64_t v38 = v33;
      if ((v48 & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      uint64_t v38 = v33;
      if (v37 < -128) {
        goto LABEL_24;
      }
    }

    goto LABEL_18;
  }

  unint64_t v128 = a5;
  char v39 = v31(a3, a4);
  uint64_t v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v40 = v38(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 >= 64)
    {
      a5 = v128;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    goto LABEL_17;
  }

  if (v40 > 64)
  {
    uint64_t v131 = -128LL;
    Swift::UInt64 v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v131, &type metadata for Int, v44, a3, a4);
    char v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    a5 = v128;
    if ((v45 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  unint64_t v50 = AssociatedTypeWitness;
  uint64_t v51 = v121;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v121,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v53 = v119;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v50,  AssociatedConformanceWitness);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v5_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000014LL,  0x80000001818B8460LL,  "Swift/FloatingPointTypes.swift",  30LL,  2,  0x12FAuLL, 0) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  uint64_t v54 = *(void (**)(char *, uint64_t))(v12 + 8);
  v54(v29, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
  if ((v50 & 1) == 0)
  {
    uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v54(v15, a3);
LABEL_17:
    a5 = v128;
    if (v49 < -128) {
      goto LABEL_24;
    }
LABEL_18:
    char v57 = v129(a3, a4);
    uint64_t v58 = v38(a3, a4);
    if ((v57 & 1) != 0)
    {
      if (v58 > 64) {
        goto LABEL_20;
      }
    }

    else if (v58 > 63)
    {
LABEL_20:
      uint64_t v131 = 128LL;
      char v61 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v62 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
      v61(&v131, &type metadata for Int, v62, a3, a4);
      char v63 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
      uint64_t v64 = *(void (**)(char *, uint64_t))(v12 + 8);
      v64(v29, a3);
      if ((v63 & 1) != 0) {
        goto LABEL_24;
      }
LABEL_25:
      unint64_t v128 = a5;
      uint64_t v66 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
      unint64_t v67 = v127;
      v66(v127, a2, a3);
      char v68 = v129(a3, a4);
      char v69 = v125;
      v66(v125, (uint64_t)v67, a3);
      uint64_t v116 = v38;
      if ((v68 & 1) == 0)
      {
        v64(v69, a3);
        unint64_t v71 = v126;
        goto LABEL_46;
      }

      uint64_t v70 = v38(a3, a4);
      v64(v69, a3);
      unint64_t v71 = v126;
      if (v70 <= 64) {
        goto LABEL_46;
      }
      char v72 = v118;
      v66(v118, (uint64_t)v67, a3);
      uint64_t v131 = 0x8000000000000000LL;
      uint64_t v73 = v129;
      if ((v129(a3, a4) & 1) != 0)
      {
        uint64_t v74 = v116(a3, a4);
        if (v74 < 64)
        {
          unint64_t v77 = v29;
LABEL_40:
          v66(v77, (uint64_t)v72, a3);
          uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v29, a3);
          if (v88 < v131) {
LABEL_69:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
          goto LABEL_44;
        }

        uint64_t v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
        v85(&v131, &type metadata for Int, v86, a3, a4);
        char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v72,  v29,  a3);
      }

      else
      {
        char v78 = v73(a3, a4);
        uint64_t v79 = v116(a3, a4);
        if ((v78 & 1) == 0)
        {
          if (v79 >= 64)
          {
            uint64_t v114 = v118;
LABEL_45:
            v64(v114, a3);
LABEL_46:
            unint64_t v98 = v116;
            uint64_t v99 = v116(a3, a4);
            unint64_t v100 = v124;
            v66(v124, (uint64_t)v67, a3);
            if (v99 < 65)
            {
              uint64_t v109 = v98(a3, a4);
              v64(v100, a3);
              BOOL v110 = v109 == 64;
              char v101 = v129;
              if (!v110 || (v129(a3, a4) & 1) != 0)
              {
LABEL_60:
                unint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v64(v67, a3);
                if ((v112 & 0x8000000000000000LL) != 0)
                {
                  a5 = v128;
                  if (v112 > 0xFFFFFFFFFFFFFF80LL)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    unint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v131, v122, v123, v115);
                    goto LABEL_63;
                  }
                }

                else
                {
                  a5 = v128;
                  if (v112 < 0x80)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    unint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v131, v122, v123, v113);
LABEL_63:
                    uint64_t v56 = v131;
                    goto LABEL_64;
                  }
                }

unint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance _UInt128( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v115 = a1;
  uint64_t v109 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v109,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v107 = (char *)&v104 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v104 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v105 = (char *)&v104 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v112 = (char *)&v104 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  BOOL v110 = (char *)&v104 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v106 = (char *)&v104 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  char v111 = (char *)&v104 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  char v113 = (char *)&v104 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v26 = (char *)&v104 - v25;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v31 = v27(a3, a4);
    uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v28 = v114(a3, a4);
    if ((v31 & 1) == 0)
    {
      if (v28 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }

    if (v28 <= 64)
    {
      uint64_t v104 = v27;
      unint64_t v55 = AssociatedTypeWitness;
      uint64_t v56 = v109;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v58 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v55,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v56 + 3))(v58, a3, v56);
      LOBYTE(v55) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v26,  a3);
      uint64_t v59 = *(void (**)(char *, uint64_t))(v9 + 8);
      v59(v26, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v55 & 1) != 0)
      {
        v59(v12, a3);
        goto LABEL_25;
      }

      uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v12, a3);
      uint64_t v27 = v104;
      if (v60 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }

Swift::UInt64 protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance _UInt128( void *a1, void *a2, unint64_t *a3)
{
  unint64_t v7 = *a3;
  unint64_t v6 = a3[1];
  v14.Swift::UInt64 low = v3[1];
  v14.high = (Swift::UInt64)&v11;
  Swift::UInt64 result = specialized _wideDivide22<A>(_:by:)(&v13, &v12, v14, *v3, v6, v7);
  Swift::UInt64 v9 = v12;
  uint64_t v10 = v11;
  *a1 = v13;
  a1[1] = result;
  *a2 = v10;
  a2[1] = v9;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance _UInt128(unint64_t *a1)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  Swift::UInt64 v5 = *v1;
  Swift::UInt64 v4 = v1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  if (v3 == v7 && v2 == v6)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    BOOL v13 = v5 == v16;
    BOOL v15 = v4 == v17;
  }

  else
  {
    uint64_t v9 = specialized static _UInt128.% infix(_:_:)(v5, v4, v2, v3);
    uint64_t v11 = v10;
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    BOOL v13 = v9 == v12;
    BOOL v15 = v11 == v14;
  }

  return v15 && v13;
}

void protocol witness for BinaryInteger.signum() in conformance _UInt128(void *a1@<X8>)
{
  *a1 = *v1 != 0LL;
  a1[1] = 0LL;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for Strideable.distance(to:) in conformance _UInt128( unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v5 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v7 = *v2;
  unint64_t v6 = v2[1];
  BOOL v8 = *a1 < *v2;
  if (v4 != v6) {
    BOOL v8 = v4 < v6;
  }
  if (v8)
  {
    unint64_t v9 = v7 - v5;
    unint64_t v10 = v6 - v4;
    BOOL v11 = v6 < v4;
    if (v7 >= v5)
    {
      if (v11) {
        goto LABEL_13;
      }
      goto LABEL_15;
    }

    if (!v10) {
      LOBYTE(v11) = 1;
    }
    if (!v11)
    {
      --v10;
LABEL_15:
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      BOOL v13 = v15 < v9;
      if (v14 != v10) {
        BOOL v13 = v14 < v10;
      }
      if (v13) {
LABEL_28:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Distance is not representable in Int",  36LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x64AuLL,  0);
      BOOL v16 = __OFSUB__(0LL, v9);
      unint64_t v12 = -(uint64_t)v9;
      if (!v16) {
        goto LABEL_27;
      }
      __break(1u);
      goto LABEL_21;
    }

uint64_t *protocol witness for Strideable.advanced(by:) in conformance _UInt128@<X0>( uint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  uint64_t v3 = *result;
  unint64_t v5 = *v2;
  unint64_t v4 = v2[1];
  if (*result < 0)
  {
    unint64_t v9 = -v3;
    BOOL v6 = v5 >= v9;
    unint64_t v7 = v5 - v9;
    uint64_t v10 = !v6;
    uint64_t v8 = v10 << 63 >> 63;
    if (!v4 && (v10 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x5FuLL,  0);
    }
  }

  else
  {
    BOOL v6 = __CFADD__(v5, v3);
    unint64_t v7 = v5 + v3;
    uint64_t v8 = v6;
    if (v4 == -1LL && (v8 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x6BuLL,  0);
    }
  }

  *a2 = v7;
  a2[1] = v8 + v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128( uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _Int128( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance _UInt128( a1,  a2,  (uint64_t (*)(uint64_t, void, void, void))specialized BinaryInteger._description(radix:uppercase:));
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _UInt128( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void, void, void))
{
  return a3(10LL, 0LL, *v3, v3[1]);
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance _Int128@<X0>( void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  BOOL v5 = __CFADD__(*result, *a2);
  BOOL v6 = __OFADD__(v3, v4);
  uint64_t v7 = v3 + v4;
  if (v6 || (v5 ? (BOOL v8 = v7 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v8 = 0), v8)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x25EuLL,  0);
  }
  *a3 = *result + *a2;
  a3[1] = v7 + v5;
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance _Int128( void *a1, uint64_t *a2)
{
  return specialized static _Int128.+= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance _Int128@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  unint64_t v6 = *a2;
  unint64_t v5 = a2[1];
  BOOL v7 = __OFSUB__(v3, v5);
  unint64_t v8 = v3 - v5;
  int v9 = v7;
  BOOL v10 = v4 >= v6;
  unint64_t v11 = v4 - v6;
  if (v10)
  {
    if (v9) {
      goto LABEL_8;
    }
  }

  else
  {
    if (v8 == 0x8000000000000000LL) {
      LOBYTE(v9) = 1;
    }
    if ((v9 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x252uLL,  0);
    --v8;
  }

  *a3 = v11;
  a3[1] = v8;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance _Int128( unint64_t *a1, uint64_t a2)
{
  return specialized static _Int128.-= infix(_:_:)(a1, *(void *)a2, *(void *)(a2 + 8));
}

uint64_t _Int128.init<A>(exactly:)(void (*a1)(char *, char *, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v247 = a3;
  uint64_t v4 = *(void *)(a3 + 24);
  uint64_t v225 = *(const char **)(v4 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v225,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v223 = (char *)&v215 - v7;
  uint64_t v243 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  unint64_t v216 = (char *)&v215 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v218 = (char *)&v215 - v11;
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  Swift::String::Index v234 = (char *)&v215 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v226 = (char *)&v215 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v229 = (char *)&v215 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v217 = (char *)&v215 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v230 = (char *)&v215 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::String::Index v233 = (char *)&v215 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::String::Index v232 = (char *)&v215 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  int64_t v222 = (char *)&v215 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  unint64_t v239 = (char *)&v215 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v238 = (char *)&v215 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v246 = (char *)&v215 - v33;
  MEMORY[0x1895F8858](v32);
  unint64_t v231 = (char *)&v215 - v34;
  uint64_t v242 = a2;
  unint64_t v35 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v4,  a2,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t v235 = *(const char **)(swift_getAssociatedConformanceWitness( v4,  a2,  v35,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)
                        + 16);
  unint64_t v36 = swift_getAssociatedTypeWitness( 0LL,  v235,  v35,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v36);
  uint64_t v38 = (char *)&v215 - v37;
  char v39 = swift_checkMetadataState(0LL, v35);
  uint64_t v40 = *(v39 - 1);
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  int64_t v221 = (char *)&v215 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  unint64_t v245 = (char *)&v215 - v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  unint64_t v47 = (char *)&v215 - v46;
  uint64_t v48 = MEMORY[0x1895F8858](v45);
  uint64_t v50 = (char *)&v215 - v49;
  MEMORY[0x1895F8858](v48);
  uint64_t v52 = (char *)&v215 - v51;
  char v53 = *(void (**)(void))(v4 + 56);
  unint64_t v241 = a1;
  uint64_t v54 = v4;
  uint64_t v55 = v242;
  v53();
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v247,  v55,  (uint64_t)v39,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  char v57 = *(uint64_t (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 64);
  unint64_t v244 = AssociatedConformanceWitness;
  uint64_t v228 = v57;
  LOBYTE(a1) = ((uint64_t (*)(unint64_t *))v57)(v39);
  uint64_t v58 = *(void (**)(char *, void (*)(void, void), unint64_t *))(v40 + 16);
  unint64_t v240 = v52;
  unint64_t v236 = v58;
  v58(v50, (void (*)(void, void))v52, v39);
  uint64_t v237 = v54;
  uint64x2_t v227 = v47;
  unint64_t v220 = v36;
  uint64_t v219 = v38;
  if ((a1 & 1) != 0)
  {
    uint64_t v59 = v235;
    unint64_t v60 = swift_getAssociatedConformanceWitness( (uint64_t)v235,  (uint64_t)v39,  v36,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v60 + 8))( &unk_18180BE68,  256LL,  v36,  v60);
    (*((void (**)(char *, unint64_t *, const char *))v59 + 3))(v38, v39, v59);
    unint64_t v61 = swift_getAssociatedConformanceWitness( v54,  v55,  (uint64_t)v39,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v62 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v61 + 16))( v50,  v47,  v39,  v61);
    char v63 = v47;
    uint64_t v64 = *(void (**)(char *, unint64_t *))(v40 + 8);
    v64(v63, v39);
    v64(v50, v39);
    uint64_t v65 = v240;
    uint64_t v66 = v55;
    if ((v62 & 1) != 0) {
      goto LABEL_19;
    }
  }

  else
  {
    uint64_t v64 = *(void (**)(char *, unint64_t *))(v40 + 8);
    v64(v50, v39);
    uint64_t v65 = v240;
    uint64_t v66 = v55;
  }

  unint64_t v67 = v244;
  unint64_t v68 = *(uint64_t (**)(unint64_t *, unint64_t))(v244 + 128);
  uint64_t v69 = v68(v39, v244);
  uint64_t v70 = v245;
  v236(v245, (void (*)(void, void))v65, v39);
  if (v69 <= 63)
  {
    v64(v70, v39);
    uint64_t v71 = v247;
    uint64_t v72 = v237;
    goto LABEL_34;
  }

  unint64_t v249 = -1LL;
  char v73 = v228(v39, v67);
  uint64_t v74 = v68(v39, v67);
  if ((v73 & 1) != 0)
  {
    unint64_t v240 = (char *)v64;
    uint64_t v71 = v247;
    uint64_t v72 = v237;
    if (v74 >= 65)
    {
      unint64_t v67 = v244;
      unint64_t v77 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v244 + 96);
      unint64_t v78 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v74, v75, v76);
      uint64_t v79 = v227;
      v77(&v249, &type metadata for UInt64, v78, v39, v67);
      unint64_t v80 = swift_getAssociatedConformanceWitness( v72,  v66,  (uint64_t)v39,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      uint64_t v81 = v245;
      char v82 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v80 + 16))( v79,  v245,  v39,  v80);
      unint64_t v83 = v79;
      uint64_t v64 = (void (*)(char *, unint64_t *))v240;
      ((void (*)(char *, unint64_t *))v240)(v83, v39);
      goto LABEL_12;
    }

    uint64_t v90 = v235;
    uint64_t v91 = v220;
    unint64_t v92 = swift_getAssociatedConformanceWitness( (uint64_t)v235,  (uint64_t)v39,  v220,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v93 = v219;
    (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v92 + 8))(&unk_18180BE68, 256LL, v91, v92);
    uint64_t v94 = v227;
    (*((void (**)(char *, unint64_t *, const char *))v90 + 3))(v93, v39, v90);
    unint64_t v95 = swift_getAssociatedConformanceWitness( v72,  v66,  (uint64_t)v39,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v96 = v245;
    LODWORD(v236) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v95 + 40))( v245,  v94,  v39,  v95);
    BOOL v97 = (void (*)(char *, unint64_t *))v240;
    ((void (*)(char *, unint64_t *))v240)(v94, v39);
    unint64_t v98 = v249;
    unint64_t v99 = v221;
    (*(void (**)(char *, char *, unint64_t *))(v40 + 32))(v221, v96, v39);
    if ((v236 & 1) != 0)
    {
      uint64_t v100 = v71;
      unint64_t v101 = v244;
      unint64_t v102 = (*(uint64_t (**)(unint64_t *, unint64_t))(v244 + 120))(v39, v244);
      v97(v99, v39);
      BOOL v103 = v98 >= v102;
      uint64_t v64 = v97;
      unint64_t v67 = v101;
      uint64_t v71 = v100;
      if (!v103)
      {
LABEL_19:
        uint64_t v106 = ((uint64_t (*)(char *, unint64_t *))v64)(v65, v39);
        unint64_t v249 = -1LL;
        uint64_t v107 = v247;
        unint64_t v108 = *(void (**)(unint64_t *, ValueMetadata *))(v247 + 88);
        unint64_t v111 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v106, v109, v110);
        unint64_t v112 = v246;
        unint64_t v240 = (char *)v111;
        v108(&v249, &type metadata for UInt64);
        char v113 = v231;
        uint64_t v114 = (char *)v241;
        (*(void (**)(void (*)(char *, char *, uint64_t), char *, uint64_t, uint64_t))(v107 + 192))( v241,  v112,  v66,  v107);
        uint64_t v115 = v243;
        uint64_t v116 = *(uint64_t (**)(char *, uint64_t))(v243 + 8);
        uint64_t v117 = v116(v112, v66);
        unint64_t v249 = 64LL;
        uint64_t v118 = *(void (**)(void (*)(void, void, void), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v107 + 240);
        unint64_t v121 = lazy protocol witness table accessor for type Int and conformance Int(v117, v119, v120);
        v118((void (*)(void, void, void))v114, &v249, &type metadata for Int, v121, v66, v107);
        v116(v114, v66);
        unint64_t v122 = *(void (**)(char *, char *, uint64_t))(v115 + 32);
        unint64_t v123 = v239;
        v122(v239, v113, v66);
        unint64_t v124 = *(char **)(v107 + 64);
        char v125 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v66, v107);
        uint64x2_t v126 = v233;
        unint64_t v245 = v124;
        unint64_t v241 = v122;
        if ((v125 & 1) != 0)
        {
          unint64_t v127 = v222;
          (*(void (**)(char *, char *, uint64_t))(v115 + 16))(v222, v123, v66);
          unint64_t v128 = v225;
          unint64_t v129 = AssociatedTypeWitness;
          unint64_t v130 = swift_getAssociatedConformanceWitness( (uint64_t)v225,  v66,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v131 = v223;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v130 + 8))( &unk_18180BE68,  256LL,  v129,  v130);
          BOOL v132 = v246;
          (*((void (**)(char *, uint64_t, const char *))v128 + 3))(v131, v66, v128);
          LOBYTE(v129) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v107 + 32) + 8LL)
                                                                            + 32LL))( v127,  v132,  v66);
          v116(v132, v66);
          if ((v129 & 1) == 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
          }
          v116(v127, v66);
          unint64_t v123 = v239;
          unint64_t v122 = v241;
          unint64_t v124 = v245;
        }

        unint64_t v244 = *(void *)(v107 + 128);
        if (((uint64_t (*)(uint64_t, uint64_t))v244)(v66, v107) < 64)
        {
LABEL_39:
          uint64_t v243 = *(void *)(v107 + 120);
          uint64_t v158 = ((uint64_t (*)(uint64_t, uint64_t))v243)(v66, v107);
          v116(v123, v66);
          v122(v126, v238, v66);
          char v159 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v66, v107);
          uint64_t v160 = v107;
          unint64_t v161 = *(void (**)(char *, char *, uint64_t))(v115 + 16);
          int64x2_t v162 = v230;
          v161(v230, v126, v66);
          if ((v159 & 1) != 0)
          {
            int8x16_t v163 = (uint64_t (*)(uint64_t, uint64_t))v244;
            uint64_t v164 = ((uint64_t (*)(uint64_t, uint64_t))v244)(v66, v160);
            v116(v162, v66);
            uint64_t v165 = v229;
            v161(v229, v126, v66);
            if (v164 >= 65)
            {
              unint64_t v249 = 0x8000000000000000LL;
              uint64_t v166 = v247;
              uint32x4_t v167 = v245;
              if ((((uint64_t (*)(uint64_t, uint64_t))v245)(v66, v247) & 1) != 0)
              {
                uint64_t v168 = v163(v66, v166);
                if (v168 < 64)
                {
                  uint64_t v171 = v66;
                  uint64_t v172 = v166;
LABEL_69:
                  uint64_t v203 = ((uint64_t (*)(uint64_t, uint64_t))v243)(v171, v172);
                  v116(v165, v66);
                  uint64x2_t v126 = v233;
                  goto LABEL_46;
                }
              }

              else
              {
                char v199 = ((uint64_t (*)(uint64_t, uint64_t))v167)(v66, v166);
                uint64_t v168 = v163(v66, v166);
                if ((v199 & 1) == 0)
                {
                  if (v168 >= 64)
                  {
                    v116(v165, v66);
                    uint64x2_t v126 = v233;
                    goto LABEL_46;
                  }

                  uint64_t v171 = v66;
                  uint64_t v172 = v247;
                  goto LABEL_69;
                }

                if (v168 <= 64)
                {
                  unint64_t v204 = v225;
                  unint64_t v205 = AssociatedTypeWitness;
                  unint64_t v206 = swift_getAssociatedConformanceWitness( (uint64_t)v225,  v66,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  uint64x2_t v207 = v223;
                  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v206 + 8))( &unk_18180BE68,  256LL,  v205,  v206);
                  uint64x2_t v208 = v246;
                  (*((void (**)(char *, uint64_t, const char *))v204 + 3))(v207, v66, v204);
                  uint64_t v209 = v247;
                  LOBYTE(v205) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v247 + 32)
                                                                                                + 8LL)
                                                                                    + 16LL))( v165,  v208,  v66);
                  v116(v208, v66);
                  unint64_t v210 = v216;
                  v122(v216, v165, v66);
                  if ((v205 & 1) != 0)
                  {
                    v116(v210, v66);
                    uint64x2_t v126 = v233;
                    goto LABEL_74;
                  }

                  unint64_t v211 = v210;
                  int64_t v212 = v249;
                  uint64_t v213 = ((uint64_t (*)(uint64_t, uint64_t))v243)(v66, v209);
                  v116(v211, v66);
                  uint64x2_t v126 = v233;
                  int8x16_t v163 = (uint64_t (*)(uint64_t, uint64_t))v244;
                  if (v213 < v212) {
                    goto LABEL_74;
                  }
LABEL_46:
                  uint64_t v173 = v247;
                  uint64_t v174 = v163(v66, v247);
                  unint64_t v175 = v226;
                  v161(v226, v126, v66);
                  if (v174 >= 65)
                  {
                    v116(v175, v66);
                    v161(v234, v126, v66);
                    int64x2_t v176 = (void (*)(uint64_t, uint64_t))v243;
LABEL_48:
                    unint64_t v249 = 0x7FFFFFFFFFFFFFFFLL;
                    uint64_t v177 = v247;
                    char v178 = ((uint64_t (*)(uint64_t, uint64_t))v245)(v66, v247);
                    uint64_t v179 = v163(v66, v177);
                    if ((v178 & 1) != 0)
                    {
                      if (v179 > 64)
                      {
                        int64x2_t v182 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v177 + 96);
                        unint64_t v183 = lazy protocol witness table accessor for type Int64 and conformance Int64( v179,  v180,  v181);
                        char v184 = v246;
                        v182(&v249, &type metadata for Int64, v183, v66, v177);
                        unint64_t v185 = v234;
                        char v186 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v177 + 32)
                                                                                              + 8LL)
                                                                                  + 16LL))( v184,  v234,  v66);
                        v116(v184, v66);
                        unint64_t v187 = v185;
                        goto LABEL_59;
                      }
                    }

                    else if (v179 > 63)
                    {
                      uint64_t v248 = 0x7FFFFFFFFFFFFFFFLL;
                      int8x16_t v192 = v246;
                      uint64_t v193 = ((uint64_t (*)(char *, char *, uint64_t))v122)(v246, v234, v66);
                      uint8x16_t v194 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v177 + 96);
                      unint64_t v197 = lazy protocol witness table accessor for type Int64 and conformance Int64(v193, v195, v196);
                      char v198 = v218;
                      v194(&v248, &type metadata for Int64, v197, v66, v177);
                      char v186 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v177 + 32)
                                                                                            + 8LL)
                                                                                + 16LL))( v198,  v192,  v66);
                      v116(v198, v66);
                      unint64_t v187 = v192;
LABEL_59:
                      v116(v187, v66);
                      if ((v186 & 1) == 0) {
                        goto LABEL_60;
                      }
LABEL_74:
                      v116(v126, v66);
                      return 0LL;
                    }

                    int8x16_t v191 = v246;
                    v122(v246, v234, v66);
                    v176(v66, v177);
                    v116(v191, v66);
LABEL_60:
                    v176(v66, v177);
                    v116(v126, v66);
                    return v158;
                  }

                  uint64_t v188 = v163(v66, v173);
                  v116(v175, v66);
                  if (v188 == 64)
                  {
                    char v189 = ((uint64_t (*)(uint64_t, uint64_t))v245)(v66, v173);
                    int8x16_t v190 = v234;
                    v161(v234, v126, v66);
                    int64x2_t v176 = (void (*)(uint64_t, uint64_t))v243;
                    if ((v189 & 1) == 0) {
                      goto LABEL_48;
                    }
                  }

                  else
                  {
                    int8x16_t v190 = v234;
                    v161(v234, v126, v66);
                    int64x2_t v176 = (void (*)(uint64_t, uint64_t))v243;
                  }

                  v116(v190, v66);
                  uint64_t v177 = v247;
                  goto LABEL_60;
                }

                uint64_t v166 = v247;
              }

              unint64_t v240 = *(char **)(v166 + 96);
              unint64_t v200 = lazy protocol witness table accessor for type Int64 and conformance Int64(v168, v169, v170);
              uint64_t v201 = v246;
              ((void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v240)( &v249,  &type metadata for Int64,  v200,  v66,  v166);
              char v202 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v166 + 32) + 8LL)
                                                                        + 16LL))( v165,  v201,  v66);
              v116(v201, v66);
              v116(v165, v66);
              uint64x2_t v126 = v233;
              if ((v202 & 1) != 0) {
                goto LABEL_74;
              }
              goto LABEL_46;
            }
          }

          else
          {
            v116(v162, v66);
            uint64_t v165 = v229;
            v161(v229, v126, v66);
            int8x16_t v163 = (uint64_t (*)(uint64_t, uint64_t))v244;
          }

          v116(v165, v66);
          goto LABEL_46;
        }

        unint64_t v133 = *(void (**)(char *, char *, uint64_t))(v115 + 16);
        v133(v232, v123, v66);
        unint64_t v249 = -1LL;
        char v134 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v66, v107);
        uint64_t v135 = ((uint64_t (*)(uint64_t, uint64_t))v244)(v66, v107);
        if ((v134 & 1) != 0)
        {
          if (v135 < 65)
          {
            uint64_t v136 = v225;
            unint64_t v137 = AssociatedTypeWitness;
            unint64_t v138 = swift_getAssociatedConformanceWitness( (uint64_t)v225,  v66,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            uint64_t v139 = v223;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v138 + 8))( &unk_18180BE68,  256LL,  v137,  v138);
            unint64_t v140 = v246;
            (*((void (**)(char *, uint64_t, const char *))v136 + 3))(v139, v66, v136);
            int8x16_t v141 = v232;
            LOBYTE(v137) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v107 + 32) + 8LL)
                                                                              + 40LL))( v232,  v140,  v66);
            v116(v140, v66);
            unint64_t v142 = v249;
            uint64_t v143 = v217;
            v133(v217, v141, v66);
            unint64_t v122 = v241;
            if ((v137 & 1) != 0)
            {
              unint64_t v144 = (*(uint64_t (**)(uint64_t, uint64_t))(v107 + 120))(v66, v107);
              v116(v143, v66);
              BOOL v103 = v142 >= v144;
              uint64_t v115 = v243;
              unint64_t v123 = v239;
              uint64_t v145 = v232;
              if (!v103) {
                goto LABEL_32;
              }
            }

            else
            {
              v116(v143, v66);
              uint64_t v115 = v243;
              unint64_t v123 = v239;
              uint64_t v145 = v232;
            }

            goto LABEL_38;
          }
        }

        else if (v135 < 65)
        {
          uint64_t v148 = v246;
          unint64_t v149 = v232;
          v133(v246, v232, v66);
          unint64_t v150 = (*(uint64_t (**)(uint64_t, uint64_t))(v107 + 120))(v66, v107);
          unint64_t v151 = v148;
          uint64_t v145 = v149;
          v116(v151, v66);
          unint64_t v123 = v239;
          unint64_t v122 = v241;
          if (v249 < v150) {
            goto LABEL_32;
          }
LABEL_38:
          v116(v145, v66);
          unint64_t v124 = v245;
          goto LABEL_39;
        }

        unint64_t v146 = v246;
        (*(void (**)(unint64_t *, ValueMetadata *, char *, uint64_t, uint64_t))(v107 + 96))( &v249,  &type metadata for UInt64,  v240,  v66,  v107);
        uint64_t v145 = v232;
        char v147 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v107 + 32) + 8LL) + 16LL))( v146,  v232,  v66);
        v116(v146, v66);
        unint64_t v123 = v239;
        unint64_t v122 = v241;
        if ((v147 & 1) != 0) {
LABEL_32:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
        goto LABEL_38;
      }
    }

    else
    {
      v97(v99, v39);
      uint64_t v64 = v97;
      unint64_t v67 = v244;
    }
  }

  else
  {
    uint64_t v71 = v247;
    uint64_t v72 = v237;
    if (v74 >= 65)
    {
      char v84 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
      unint64_t v85 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v74, v75, v76);
      unint64_t v86 = v64;
      char v87 = v227;
      v84(&v249, &type metadata for UInt64, v85, v39, v244);
      unint64_t v88 = swift_getAssociatedConformanceWitness( v72,  v66,  (uint64_t)v39,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      uint64_t v81 = v245;
      char v82 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v88 + 16))( v87,  v245,  v39,  v88);
      uint64_t v89 = v87;
      uint64_t v64 = v86;
      unint64_t v67 = v244;
      v64(v89, v39);
LABEL_12:
      v64(v81, v39);
      if ((v82 & 1) != 0) {
        goto LABEL_19;
      }
      goto LABEL_34;
    }

    uint64_t v104 = v227;
    (*(void (**)(char *, char *, unint64_t *))(v40 + 32))(v227, v245, v39);
    unint64_t v105 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v39, v67);
    v64(v104, v39);
    if (v249 < v105) {
      goto LABEL_19;
    }
  }

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.multipliedReportingOverflow(by:)(Swift::_Int128 by)
{
  if (v2)
  {
    if (!by.high)
    {
      int64_t v4 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
      by.high = 0LL;
      if (v2 >= 0)
      {
        LODWORD(v4) = 0;
      }

      else
      {
        unint64_t v1 = -(uint64_t)v1;
        int64_t v2 = v4;
        LODWORD(v4) = by.low != 0;
      }

      goto LABEL_19;
    }

    if (((v2 ^ by.high) & 0x8000000000000000LL) == 0)
    {
      if (v2 < 0)
      {
LABEL_17:
        int64_t v4 = ((unint64_t)v2 ^ by.high) >> 63;
        BOOL v5 = v1 == 0;
        unint64_t v1 = -(uint64_t)v1;
        int64_t v2 = -(v2 + !v5);
        if ((by.high & 0x8000000000000000LL) == 0) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }

      goto LABEL_9;
    }

    if (v2 < 0) {
      goto LABEL_17;
    }
    LODWORD(v4) = 1;
    if ((by.high & 0x8000000000000000LL) == 0) {
      goto LABEL_19;
    }
  }

  else
  {
    if ((by.high & 0x8000000000000000LL) == 0 || !v1)
    {
LABEL_9:
      LODWORD(v4) = 0;
      if ((by.high & 0x8000000000000000LL) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }

    int64_t v2 = 0LL;
    LODWORD(v4) = 1;
  }

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance _Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128( (uint64_t (*)(void))_Int128.init<A>(exactly:),  a1);
}

void protocol witness for Numeric.magnitude.getter in conformance _Int128(void *a1@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  uint64_t v5 = (unsigned __int128)-(__int128)__PAIR128__(v1, *v2) >> 64;
  if (v4 < 0)
  {
    uint64_t v3 = -*v2;
    uint64_t v4 = v5;
  }

  *a1 = v3;
  a1[1] = v4;
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance _Int128@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration( a1,  a2,  (uint64_t (*)(void, void, void, void))specialized static _Int128.* infix(_:_:),  a3);
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128( uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, uint64_t, uint64_t))_Int128.multipliedReportingOverflow(by:),  "Overflow in *=",  0x2A0uLL);
}

uint64_t *protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance _Int128@<X0>( uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *result >> 63;
  *a2 = *result;
  a2[1] = v2;
  return result;
}

uint64_t _UInt128.Words.subscript.getter(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Word index out of range",  23LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  a4,  0);
  }
  if (a1) {
    return a3;
  }
  else {
    return a2;
  }
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _Int128.Words( uint64_t *a1, unint64_t *a2))()
{
  *a1 = _UInt128.Words.subscript.getter(*a2, *v2, v2[1], 0x2BEuLL);
  return EnumeratedSequence._base.modify;
}

__n128 protocol witness for Collection.subscript.getter in conformance _UInt128.Words@<Q0>( unint64_t *a1@<X0>, __n128 *a2@<X8>)
{
  if ((*a1 & 0x8000000000000000LL) != 0 || (uint64_t v3 = a1[1], v3 >= 3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  a2->n128_u64[0] = *a1;
  a2->n128_u64[1] = v3;
  __n128 result = *v2;
  a2[1] = *v2;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance _Int128.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _Int128.Words( void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.multipliedReportingOverflow(by:)(Swift::UInt64 by)
{
  BOOL v5 = by != 0;
  uint64_t v6 = -(uint64_t)v1;
  unint64_t v7 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
  if (v2 >= 0)
  {
    uint64_t v6 = v1;
    unint64_t v7 = v2;
    BOOL v5 = 0;
  }

  uint64_t v8 = (v7 * (unsigned __int128)by) >> 64;
  Swift::UInt64 v9 = v7 * by;
  Swift::UInt64 v10 = v6 * by;
  uint64_t v11 = ((unint64_t)v6 * (unsigned __int128)by) >> 64;
  Swift::Int64 v12 = v9 + v11;
  BOOL v13 = __CFADD__(v9, v11);
  if (v8)
  {
    if (v5)
    {
      Swift::Int64 v14 = -v12;
      BOOL v13 = 1;
      uint64_t v15 = -(uint64_t)v10;
      if (!v10)
      {
LABEL_13:
        BOOL v16 = v15 != 0;
        uint64_t v17 = v15 - 1;
        uint64_t v18 = !v16;
        Swift::Int64 v12 = (__PAIR128__(v14, v17) + __PAIR128__(v18 << 63 >> 63, 1LL)) >> 64;
        Swift::UInt64 v10 = v17 + 1;
        if (v13) {
          goto LABEL_17;
        }
LABEL_19:
        char v19 = v5 ^ (v12 < 0);
        goto LABEL_20;
      }

Swift::tuple_quotient__Int128_remainder__Int128 __swiftcall _Int128.quotientAndRemainder(dividingBy:)( Swift::_Int128 dividingBy)
{
  Swift::UInt64 low = v1.low;
  Swift::UInt64 v4 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1.high) >> 64;
  int v5 = (v1.low & 0x8000000000000000LL) != 0LL;
  if ((v1.low & 0x8000000000000000LL) == 0LL) {
    Swift::UInt64 high = v1.high;
  }
  else {
    Swift::UInt64 high = -v1.high;
  }
  if ((v1.low & 0x8000000000000000LL) != 0LL) {
    v1.Swift::UInt64 low = v4;
  }
  Swift::Int64 v7 = (unsigned __int128)-(__int128)__PAIR128__(v4, dividingBy.low) >> 64;
  int v8 = dividingBy.high < 0;
  if (dividingBy.high >= 0) {
    Swift::UInt64 v9 = dividingBy.low;
  }
  else {
    Swift::UInt64 v9 = -dividingBy.low;
  }
  if (dividingBy.high >= 0) {
    Swift::Int64 v10 = dividingBy.high;
  }
  else {
    Swift::Int64 v10 = v7;
  }
  v1.Swift::UInt64 high = (Swift::UInt64)&v15;
  Swift::Int64 v11 = specialized _wideDivide22<A>(_:by:)((Swift::UInt64 *)&v17, (Swift::UInt64 *)&v16, v1, high, v10, v9);
  Swift::Int64 v13 = v16;
  Swift::UInt64 v12 = v17;
  Swift::UInt64 v14 = v15;
  if (v8 == v5)
  {
    if (v11 < 0) {
      goto LABEL_31;
    }
    if ((low & 0x8000000000000000LL) == 0) {
      goto LABEL_19;
    }
  }

  else
  {
    if (v11 == 0x8000000000000000LL && !v17)
    {
      Swift::Int64 v11 = 0x8000000000000000LL;
      if ((low & 0x8000000000000000LL) != 0) {
        goto LABEL_26;
      }
LABEL_19:
      if ((v16 & 0x8000000000000000LL) == 0) {
        goto LABEL_32;
      }
LABEL_31:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }

    if (v11 < 0) {
      goto LABEL_31;
    }
    Swift::UInt64 v12 = -v17;
    if (v17) {
      Swift::Int64 v11 = ~v11;
    }
    else {
      Swift::Int64 v11 = -v11;
    }
    if ((low & 0x8000000000000000LL) == 0) {
      goto LABEL_19;
    }
  }

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.remainderReportingOverflow(dividingBy:)( Swift::_Int128 dividingBy)
{
  Swift::UInt64 low = v1.low;
  if (dividingBy.high == -1)
  {
    if (dividingBy.low == -1LL && v1.low == 0x8000000000000000LL && !v1.high)
    {
      Swift::UInt64 low = 0LL;
      char v4 = 1;
      goto LABEL_38;
    }
  }

  else if (!dividingBy.high && !dividingBy.low)
  {
    char v4 = 1;
    goto LABEL_38;
  }

  Swift::UInt64 v5 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1.high) >> 64;
  int v6 = (v1.low & 0x8000000000000000LL) != 0LL;
  if ((v1.low & 0x8000000000000000LL) == 0LL) {
    Swift::UInt64 high = v1.high;
  }
  else {
    Swift::UInt64 high = -v1.high;
  }
  if ((v1.low & 0x8000000000000000LL) != 0LL) {
    v1.Swift::UInt64 low = v5;
  }
  Swift::Int64 v8 = (unsigned __int128)-(__int128)__PAIR128__(v5, dividingBy.low) >> 64;
  int v9 = dividingBy.high < 0;
  if (dividingBy.high >= 0) {
    Swift::UInt64 v10 = dividingBy.low;
  }
  else {
    Swift::UInt64 v10 = -dividingBy.low;
  }
  if (dividingBy.high >= 0) {
    Swift::Int64 v11 = dividingBy.high;
  }
  else {
    Swift::Int64 v11 = v8;
  }
  v1.Swift::UInt64 high = (Swift::UInt64)&v18;
  Swift::UInt64 v12 = specialized _wideDivide22<A>(_:by:)(&v20, (Swift::UInt64 *)&v19, v1, high, v11, v10);
  v1.Swift::UInt64 high = v18;
  if (v9 == v6)
  {
    if ((v12 & 0x8000000000000000LL) != 0) {
      goto LABEL_39;
    }
  }

  else
  {
    BOOL v14 = v12 != 0x8000000000000000LL || v20 != 0;
    if ((v12 & 0x8000000000000000LL) != 0 && v14) {
      goto LABEL_39;
    }
  }

  if ((low & 0x8000000000000000LL) == 0)
  {
    if ((v19 & 0x8000000000000000LL) == 0)
    {
      char v4 = 0;
      Swift::UInt64 low = v19;
      goto LABEL_38;
    }

Swift::tuple_high__Int128_low__UInt128 __swiftcall _Int128.multipliedFullWidth(by:)(Swift::_Int128 by)
{
  unint64_t v4 = v1;
  if (v2)
  {
    unint64_t v5 = v2;
    if (by.high)
    {
      BOOL v6 = ((v2 ^ by.high) & 0x8000000000000000LL) == 0LL;
      if ((v2 & 0x8000000000000000LL) == 0) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }

    if ((v2 & 0x8000000000000000LL) != 0)
    {
      BOOL v6 = 0;
LABEL_11:
      unint64_t v4 = -(uint64_t)v1;
      unint64_t v5 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1) >> 64;
LABEL_12:
      Swift::Int64 v8 = (unsigned __int128)-(__int128)__PAIR128__(v3, by.low) >> 64;
      if (by.high >= 0)
      {
        Swift::Int64 high = by.high;
      }

      else
      {
        by.Swift::UInt64 low = -by.low;
        Swift::Int64 high = v8;
      }

      goto LABEL_15;
    }

    Swift::Int64 high = 0LL;
    BOOL v6 = 1;
  }

  else
  {
    if (by.high)
    {
      unint64_t v5 = 0LL;
      BOOL v6 = by.high >= 0;
      goto LABEL_12;
    }

    Swift::Int64 high = 0LL;
    unint64_t v5 = 0LL;
    BOOL v6 = 1;
  }

Swift::tuple_quotient__Int128_remainder__Int128 __swiftcall _Int128.dividingFullWidth(_:)( Swift::tuple_high__Int128_low__UInt128 a1)
{
  uint64_t high = a1.low.high;
  Swift::UInt64 low = a1.low.low;
  Swift::Int64 v6 = a1.high.high;
  Swift::UInt64 v7 = a1.high.low;
  if (a1.high.high < 0)
  {
    Swift::Int64 v8 = -a1.high.high;
    if (a1.high.low)
    {
      Swift::Int64 v8 = ~a1.high.high;
      uint64_t v9 = 0LL;
    }

    else
    {
      uint64_t v9 = 1LL;
    }

    uint64_t v3 = v9 << 63 >> 63;
    if (a1.low.low) {
      Swift::UInt64 v10 = ~a1.low.high;
    }
    else {
      Swift::UInt64 v10 = -a1.low.high;
    }
    Swift::UInt64 v13 = -a1.low.low - 1;
    uint64_t v11 = (__PAIR128__(v10, a1.low.low) - 1) >> 64;
    BOOL v12 = __CFADD__(v13, 1LL);
    Swift::UInt64 low = -a1.low.low;
    LODWORD(v13) = v13 == -1LL;
    uint64_t high = ((uint64_t)((unint64_t)(a1.low.low == 0) << 63) >> 63) + v12 + v10;
    if (v11 == -1) {
      Swift::UInt64 v13 = v13;
    }
    else {
      Swift::UInt64 v13 = 0LL;
    }
    a1.low.uint64_t high = (__PAIR128__(v8, -a1.high.low - 1) + __PAIR128__(v3, v13)) >> 64;
    Swift::UInt64 v7 = -a1.high.low - 1 + v13;
  }

  else
  {
    a1.low.uint64_t high = a1.high.high;
  }

  int v14 = a1.high.high < 0;
  unint64_t v15 = -(uint64_t)v1;
  Swift::UInt64 v16 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
  int v17 = v2 < 0;
  if (v2 < 0)
  {
    Swift::UInt64 v18 = v16;
  }

  else
  {
    unint64_t v15 = v1;
    Swift::UInt64 v18 = v2;
  }

  a1.low.Swift::UInt64 low = (Swift::UInt64)&v23;
  Swift::Int64 v19 = specialized _wideDivide42<A>(_:by:)( (Swift::UInt64 *)&v25,  (Swift::UInt64 *)&v24,  (Swift::tuple_high_UInt64_low_UInt64)a1.low,  v7,  high,  low,  v18,  v15);
  Swift::Int64 v21 = v24;
  Swift::UInt64 v20 = v25;
  Swift::UInt64 v22 = v23;
  if (v14 == v17)
  {
    if (v19 < 0) {
      goto LABEL_35;
    }
    if ((v6 & 0x8000000000000000LL) == 0) {
      goto LABEL_23;
    }
  }

  else
  {
    if (v19 == 0x8000000000000000LL && !v25)
    {
      Swift::Int64 v19 = 0x8000000000000000LL;
      if (v6 < 0) {
        goto LABEL_30;
      }
LABEL_23:
      if ((v24 & 0x8000000000000000LL) == 0) {
        goto LABEL_36;
      }
LABEL_35:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }

    if (v19 < 0) {
      goto LABEL_35;
    }
    Swift::UInt64 v20 = -v25;
    if (v25) {
      Swift::Int64 v19 = ~v19;
    }
    else {
      Swift::Int64 v19 = -v19;
    }
    if ((v6 & 0x8000000000000000LL) == 0) {
      goto LABEL_23;
    }
  }

double protocol witness for static FixedWidthInteger.max.getter in conformance _Int128@<D0>(_OWORD *a1@<X8>)
{
  double result = NAN;
  *a1 = xmmword_1817FFFE0;
  return result;
}

double protocol witness for static FixedWidthInteger.min.getter in conformance _Int128@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = xmmword_1817FFFF0;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance _Int128( void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = v2[1];
  BOOL v5 = __CFADD__(*v2, *a2);
  BOOL v6 = __OFADD__(v4, v3);
  uint64_t v7 = v4 + v3;
  if (v6)
  {
    uint64_t v8 = 1LL;
    if (v5)
    {
LABEL_12:
      uint64_t v9 = 1LL;
      goto LABEL_13;
    }
  }

  else
  {
    uint64_t v8 = v7 == 0x7FFFFFFFFFFFFFFFLL && v5;
    if (v5) {
      goto LABEL_12;
    }
  }

  uint64_t v9 = 0LL;
LABEL_13:
  *a1 = *v2 + *a2;
  a1[1] = v9 + v7;
  return v8;
}

unint64_t protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance _Int128( unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  BOOL v7 = __OFSUB__(v6, v4);
  unint64_t v8 = v6 - v4;
  int v9 = v7;
  BOOL v10 = v5 >= v3;
  unint64_t v11 = v5 - v3;
  LODWORD(v3) = v5 < v3;
  if (v10)
  {
    if (v9)
    {
      unint64_t v3 = 1LL;
      unint64_t v12 = v8;
      goto LABEL_13;
    }

    unint64_t v12 = v8;
  }

  else
  {
    unint64_t v12 = v8 - 1;
    if ((v9 & 1) != 0)
    {
      unint64_t v3 = 1LL;
      goto LABEL_13;
    }
  }

  if (v8 == 0x8000000000000000LL) {
    unint64_t v3 = v3;
  }
  else {
    unint64_t v3 = 0LL;
  }
LABEL_13:
  *a1 = v11;
  a1[1] = v12;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance _Int128( Swift::UInt64 *a1, Swift::_Int128 *a2)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4 = _Int128.multipliedReportingOverflow(by:)(*a2);
  *a1 = v4.partialValue.low;
  a1[1] = v4.partialValue.high;
  return v4.overflow;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance _Int128( void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = *v2;
  unint64_t v7 = v2[1];
  if (v5 == -1)
  {
    if (v4 == -1 && v7 == 0x8000000000000000LL && v6 == 0)
    {
      uint64_t v6 = 0LL;
      uint64_t result = 1LL;
      unint64_t v7 = 0x8000000000000000LL;
      goto LABEL_16;
    }

    goto LABEL_15;
  }

  if (v5) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = v4 == 0;
  }
  if (!v8)
  {
LABEL_15:
    unsigned __int128 v12 = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(*(Swift::_Int128 *)&v4);
    uint64_t v6 = v12;
    unint64_t v7 = *((void *)&v12 + 1);
    uint64_t result = 0LL;
    goto LABEL_16;
  }

  uint64_t result = 1LL;
LABEL_16:
  *a1 = v6;
  a1[1] = v7;
  return result;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance _Int128( Swift::UInt64 *a1, Swift::_Int128 *a2)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4 = _Int128.remainderReportingOverflow(dividingBy:)(*a2);
  *a1 = v4.partialValue.low;
  a1[1] = v4.partialValue.high;
  return v4.overflow;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _Int128( uint64_t *a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, void, void, void))_Int128.multipliedFullWidth(by:));
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128( uint64_t *a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void, void, void, void))
{
  uint64_t result = a6(*a3, a3[1], *v6, v6[1]);
  *a1 = result;
  a1[1] = v10;
  *a2 = v11;
  a2[1] = v12;
  return result;
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance _Int128( Swift::UInt64 *a1, Swift::UInt64 *a2, uint64_t a3, Swift::UInt64 *a4)
{
  v7.high.Swift::UInt64 low = *(void *)a3;
  v7.high.uint64_t high = *(void *)(a3 + 8);
  v7.low.Swift::UInt64 low = *a4;
  v7.low.uint64_t high = a4[1];
  Swift::tuple_quotient__Int128_remainder__Int128 v8 = _Int128.dividingFullWidth(_:)(v7);
  *a1 = v8.quotient.low;
  a1[1] = v8.quotient.high;
  *a2 = v8.remainder.low;
  a2[1] = v8.remainder.high;
  return v8.quotient.low;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance _Int128()
{
  return vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v0)))));
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance _Int128()
{
  unint64_t v1 = v0[1];
  if (v1) {
    return __clz(v1);
  }
  else {
    return __clz(*v0) + 64;
  }
}

int8x16_t protocol witness for FixedWidthInteger.init(bigEndian:) in conformance _Int128@<Q0>( int8x16_t *a1@<X0>, int8x16_t *a2@<X8>)
{
  int8x16_t v2 = vrev64q_s8(*a1);
  int8x16_t result = vextq_s8(v2, v2, 8uLL);
  *a2 = result;
  return result;
}

__n128 protocol witness for FixedWidthInteger.init(littleEndian:) in conformance _Int128@<Q0>( __n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

int8x16_t protocol witness for FixedWidthInteger.bigEndian.getter in conformance _Int128@<Q0>( int8x16_t *a1@<X8>)
{
  int8x16_t v2 = vrev64q_s8(*v1);
  int8x16_t result = vextq_s8(v2, v2, 8uLL);
  *a1 = result;
  return result;
}

__n128 protocol witness for FixedWidthInteger.littleEndian.getter in conformance _Int128@<Q0>( __n128 *a1@<X8>)
{
  __n128 result = *v1;
  *a1 = *v1;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _Int128@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  return protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128( a1,  a2,  (uint64_t (*)(uint64_t, void, void, void))specialized _wideMaskedShiftRight<A>(_:_:),  a3);
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t (*a3)(uint64_t, void, void, void)@<X4>, uint64_t a4@<X8>)
{
  uint64_t result = a3(a4, a1[1], *a1, *a2);
  *(void *)(a4 + 8) = result;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance _Int128( uint64_t *a1, void *a2)
{
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(a1, a1[1], *a1, *a2);
  a1[1] = result;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance _Int128@<X0>( uint64_t *result@<X0>, unint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = *result;
  uint64_t v5 = result[1];
  unint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (!v7)
  {
    if ((v5 & 0x8000000000000000LL) == 0 || !v6)
    {
LABEL_9:
      LODWORD(v8) = 0;
      BOOL v9 = 0;
      if ((v5 & 0x8000000000000000LL) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }

    uint64_t v7 = 0LL;
    LODWORD(v8) = 1;
LABEL_18:
    BOOL v11 = v4 == 0;
    uint64_t v4 = -v4;
    uint64_t v5 = -(v5 + !v11);
    BOOL v9 = v8;
    goto LABEL_19;
  }

  if (v5)
  {
    if (((v7 ^ v5) & 0x8000000000000000LL) == 0)
    {
      if (v7 < 0)
      {
LABEL_17:
        BOOL v8 = (v7 ^ (unint64_t)v5) >> 63;
        BOOL v11 = v6 == 0;
        unint64_t v6 = -(uint64_t)v6;
        uint64_t v7 = -(v7 + !v11);
        BOOL v9 = v8;
        if ((v5 & 0x8000000000000000LL) == 0) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }

      goto LABEL_9;
    }

    if (v7 < 0) {
      goto LABEL_17;
    }
    LODWORD(v8) = 1;
    BOOL v9 = 1;
    if ((v5 & 0x8000000000000000LL) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  uint64_t v10 = (unsigned __int128)-(__int128)__PAIR128__(v3, v6) >> 64;
  uint64_t v5 = 0LL;
  if (v7 >= 0)
  {
    BOOL v9 = 0;
  }

  else
  {
    unint64_t v6 = -(uint64_t)v6;
    uint64_t v7 = v10;
    BOOL v9 = v4 != 0;
  }

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance _Int128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _Int128 and conformance _Int128(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _Int128@<D0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128( a1,  a2,  a3,  a4,  (uint64_t (*)(void))lazy protocol witness table accessor for type _Int128 and conformance _Int128,  a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<D0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _OWORD *a6@<X8>)
{
  unint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, a2, v13, a3);
  if ((v39 & 1) != 0)
  {
    *(void *)&__int128 v38 = static String._createEmpty(withInitialCapacity:)(80LL);
    *((void *)&v38 + 1) = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000LL) == 0)
    {
      Swift::UInt64 v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._unint64_t object = (void *)0x80000001818B69D0LL;
      v26._uint64_t countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000LL) == 0)
      {
        uint64_t v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._uint64_t countAndFlagsBits = 0xD00000000000002ELL;
        v37._unint64_t object = (void *)0x80000001818B69F0LL;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)v38,  *((unint64_t *)&v38 + 1),  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  (*(void (**)(uint64_t, unint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  double result = *(double *)&v38;
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _Int128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128( a1,  a2,  a3,  (uint64_t (*)(char *, uint64_t, uint64_t))_Int128.init<A>(exactly:),  0x27CuLL,  a4);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t (*a4)(char *, uint64_t, uint64_t)@<X5>, unint64_t a5@<X6>, uint64_t *a6@<X8>)
{
  uint64_t v9 = specialized _UInt128.init<A>(_:)(a1, a2, a3, a4, a5);
  uint64_t v11 = v10;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
  *a6 = v9;
  a6[1] = v11;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _Int128@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128( a1,  a2,  (uint64_t (*)(void))specialized static FixedWidthInteger._truncatingInit<A>(_:),  a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance _Int128@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _Int128 and conformance _Int128((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance _Int128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*(void *)v0, *(void *)(v0 + 8));
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance _Int128()
{
  if (*v0) {
    return __clz(__rbit64(*v0));
  }
  else {
    return __clz(__rbit64(v0[1])) + 64;
  }
}

double protocol witness for static BinaryInteger./ infix(_:_:) in conformance _Int128@<D0>( __int128 *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  Swift::UInt64 v4 = *(void *)a2;
  v7.uint64_t high = *(void *)(a2 + 8);
  __int128 v6 = *a1;
  v7.Swift::UInt64 low = v4;
  specialized static _Int128./= infix(_:_:)(&v6, v7);
  double result = *(double *)&v6;
  *a3 = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance _Int128( void *a1, Swift::_Int128 *a2)
{
  return specialized static _Int128./= infix(_:_:)(a1, *a2);
}

Swift::UInt64 protocol witness for static BinaryInteger.% infix(_:_:) in conformance _Int128@<X0>( Swift::_Int128 *a1@<X1>, Swift::UInt64 *a2@<X8>)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4 = _Int128.remainderReportingOverflow(dividingBy:)(*a1);
  if (v4.overflow) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in %=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x3DCuLL,  0);
  }
  *a2 = v4.partialValue.low;
  a2[1] = v4.partialValue.high;
  return v4.partialValue.low;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance _Int128( uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, uint64_t, uint64_t))_Int128.remainderReportingOverflow(dividingBy:),  "Overflow in %=",  0x3DCuLL);
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128( uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, uint64_t, uint64_t), const char *a6, unint64_t a7)
{
  uint64_t result = a5(*a2, a2[1], *a1, a1[1]);
  if ((v12 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a6,  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  a7,  0);
  }
  *a1 = result;
  a1[1] = v11;
  return result;
}

void *protocol witness for static BinaryInteger.~ prefix(_:) in conformance _UInt128@<X0>( void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[1];
  if (*result) {
    uint64_t v3 = ~v2;
  }
  else {
    uint64_t v3 = -v2;
  }
  BOOL v4 = *result == 0LL;
  *a2 = -*result - 1LL;
  a2[1] = v3 - v4;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.& infix(_:_:) in conformance _Int128@<Q0>( int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result = vandq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.&= infix(_:_:) in conformance _Int128( int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result = vandq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.| infix(_:_:) in conformance _Int128@<Q0>( int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result = vorrq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.|= infix(_:_:) in conformance _Int128( int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result = vorrq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.^ infix(_:_:) in conformance _Int128@<Q0>( int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result = veorq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.^= infix(_:_:) in conformance _Int128( int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result = veorq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance _Int128@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v108 = a5;
  unint64_t v102 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v102,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v100 = (char *)&v96 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v96 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unint64_t v98 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  BOOL v103 = (char *)&v96 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v104 = (char *)&v96 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v99 = (char *)&v96 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v96 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v105 = (char *)&v96 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v96 - v28;
  unint64_t v30 = *a1;
  uint64_t v106 = a1[1];
  unint64_t v107 = v30;
  int64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v31(a3, a4) & 1) != 0)
  {
    uint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v32 = v109(a3, a4);
    if (v32 < 64) {
      goto LABEL_9;
    }
  }

  else
  {
    char v35 = v31(a3, a4);
    uint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v32 = v109(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v32 >= 64) {
        goto LABEL_10;
      }
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v40 >= -128) {
        goto LABEL_10;
      }
      goto LABEL_25;
    }

    if (v32 <= 64)
    {
      BOOL v97 = v31;
      unint64_t v57 = AssociatedTypeWitness;
      uint64_t v58 = v102;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v102,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v60 = v100;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v57,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v58 + 3))(v60, a3, v58);
      LOBYTE(v57) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      unint64_t v61 = *(void (**)(char *, uint64_t))(v11 + 8);
      v61(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v57 & 1) != 0)
      {
        v61(v14, a3);
      }

      else
      {
        uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v61(v14, a3);
        int64_t v31 = v97;
        if (v62 >= -128)
        {
LABEL_10:
          char v41 = v31(a3, a4);
          uint64_t v42 = v109(a3, a4);
          if ((v41 & 1) != 0)
          {
            if (v42 > 64) {
              goto LABEL_12;
            }
          }

          else if (v42 > 63)
          {
LABEL_12:
            unint64_t v36 = 128LL;
            uint64_t v111 = 128LL;
            uint64_t v45 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
            v45(&v111, &type metadata for Int, v46, a3, a4);
            char v47 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
            uint64_t v48 = *(void (**)(char *, uint64_t))(v11 + 8);
            v48(v29, a3);
            if ((v47 & 1) != 0) {
              goto LABEL_49;
            }
            goto LABEL_17;
          }

          (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
          uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v48 = *(void (**)(char *, uint64_t))(v11 + 8);
          v48(v29, a3);
          if (v49 > 128)
          {
            unint64_t v36 = 128LL;
            goto LABEL_49;
          }

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance _Int128( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v113 = a1;
  uint64_t v109 = *(const char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v109,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v107 = (char *)&v103 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v103 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v103 - v14;
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v110 = (char *)&v103 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v112 = (char *)&v103 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v106 = (char *)&v103 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v103 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v111 = (char *)&v103 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v28 = (char *)&v103 - v27;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  unint64_t v105 = v15;
  if ((v30 & 1) != 0)
  {
    uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v114(a3, a4);
    if (v31 < 64) {
      goto LABEL_9;
    }
  }

  else
  {
    char v34 = v29(a3, a4);
    uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v114(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v31 >= 64) {
        goto LABEL_10;
      }
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
      if (v39 >= -128) {
        goto LABEL_10;
      }
      goto LABEL_27;
    }

    if (v31 <= 64)
    {
      uint64_t v104 = v29;
      unint64_t v61 = AssociatedTypeWitness;
      uint64_t v62 = v109;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v64 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v61,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v62 + 3))(v64, a3, v62);
      LOBYTE(v61) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v28,  a3);
      unint64_t v65 = *(void (**)(char *, uint64_t))(v9 + 8);
      v65(v28, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v61 & 1) != 0)
      {
        v65(v12, a3);
      }

      else
      {
        uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v65(v12, a3);
        uint64_t v29 = v104;
        if (v66 >= -128)
        {
LABEL_10:
          char v40 = v29(a3, a4);
          uint64_t v41 = v114(a3, a4);
          if ((v40 & 1) != 0)
          {
            if (v41 > 64) {
              goto LABEL_12;
            }
          }

          else if (v41 >= 64)
          {
LABEL_12:
            unint64_t v35 = 128LL;
            uint64_t v116 = 128LL;
            uint64_t v44 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
            v44(&v116, &type metadata for Int, v45, a3, a4);
            char v46 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v28,  a2,  a3);
            char v47 = *(void (**)(char *, uint64_t))(v9 + 8);
            v47(v28, a3);
            if ((v46 & 1) != 0) {
              goto LABEL_51;
            }
            goto LABEL_17;
          }

          (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
          uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          char v47 = *(void (**)(char *, uint64_t))(v9 + 8);
          v47(v28, a3);
          if (v48 > 128)
          {
            unint64_t v35 = 128LL;
            goto LABEL_51;
          }

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance _Int128@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v108 = a5;
  char v102 = *(char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v102,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v100 = (char *)&v96 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v96 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  char v98 = (char *)&v96 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v103 = (char *)&v96 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v104 = (char *)&v96 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v99 = (char *)&v96 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v96 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  unint64_t v105 = (char *)&v96 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v96 - v28;
  unint64_t v30 = *a1;
  uint64_t v106 = a1[1];
  unint64_t v107 = v30;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v31(a3, a4) & 1) != 0)
  {
    uint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v32 = v109(a3, a4);
    if (v32 < 64) {
      goto LABEL_9;
    }
  }

  else
  {
    char v35 = v31(a3, a4);
    uint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v32 = v109(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v32 >= 64) {
        goto LABEL_10;
      }
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v40 >= -128) {
        goto LABEL_10;
      }
      goto LABEL_25;
    }

    if (v32 <= 64)
    {
      unint64_t v97 = v31;
      unint64_t v57 = AssociatedTypeWitness;
      uint64_t v58 = v102;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v102,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v60 = v100;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v57,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v58 + 3))(v60, a3, v58);
      LOBYTE(v57) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
      unint64_t v61 = *(void (**)(char *, uint64_t))(v11 + 8);
      v61(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v57 & 1) != 0)
      {
        v61(v14, a3);
      }

      else
      {
        uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v61(v14, a3);
        uint64_t v31 = v97;
        if (v62 >= -128)
        {
LABEL_10:
          char v41 = v31(a3, a4);
          uint64_t v42 = v109(a3, a4);
          if ((v41 & 1) != 0)
          {
            if (v42 > 64) {
              goto LABEL_12;
            }
          }

          else if (v42 > 63)
          {
LABEL_12:
            unint64_t v36 = 128LL;
            uint64_t v111 = 128LL;
            unint64_t v45 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
            v45(&v111, &type metadata for Int, v46, a3, a4);
            char v47 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
            uint64_t v48 = *(void (**)(char *, uint64_t))(v11 + 8);
            v48(v29, a3);
            if ((v47 & 1) != 0) {
              goto LABEL_50;
            }
            goto LABEL_17;
          }

          (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
          uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v48 = *(void (**)(char *, uint64_t))(v11 + 8);
          v48(v29, a3);
          if (v49 > 128)
          {
            unint64_t v36 = 128LL;
            goto LABEL_50;
          }

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance _Int128( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v113 = a1;
  uint64_t v109 = *(const char **)(*(void *)(a4 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v109,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v107 = (char *)&v103 - v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  uint64_t v12 = (char *)&v103 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v103 - v14;
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v110 = (char *)&v103 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v112 = (char *)&v103 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v106 = (char *)&v103 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v103 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v111 = (char *)&v103 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v28 = (char *)&v103 - v27;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v30 = v29(a3, a4);
  unint64_t v105 = v15;
  if ((v30 & 1) != 0)
  {
    uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v114(a3, a4);
    if (v31 < 64) {
      goto LABEL_9;
    }
  }

  else
  {
    char v34 = v29(a3, a4);
    uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v114(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v31 >= 64) {
        goto LABEL_10;
      }
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
      if (v39 >= -128) {
        goto LABEL_10;
      }
      goto LABEL_27;
    }

    if (v31 <= 64)
    {
      uint64_t v104 = v29;
      unint64_t v61 = AssociatedTypeWitness;
      uint64_t v62 = v109;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v64 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v61,  AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v62 + 3))(v64, a3, v62);
      LOBYTE(v61) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v28,  a3);
      unint64_t v65 = *(void (**)(char *, uint64_t))(v9 + 8);
      v65(v28, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v61 & 1) != 0)
      {
        v65(v12, a3);
      }

      else
      {
        uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v65(v12, a3);
        uint64_t v29 = v104;
        if (v66 >= -128)
        {
LABEL_10:
          char v40 = v29(a3, a4);
          uint64_t v41 = v114(a3, a4);
          if ((v40 & 1) != 0)
          {
            if (v41 > 64) {
              goto LABEL_12;
            }
          }

          else if (v41 >= 64)
          {
LABEL_12:
            unint64_t v35 = 128LL;
            uint64_t v116 = 128LL;
            uint64_t v44 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
            v44(&v116, &type metadata for Int, v45, a3, a4);
            char v46 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v28,  a2,  a3);
            char v47 = *(void (**)(char *, uint64_t))(v9 + 8);
            v47(v28, a3);
            if ((v46 & 1) != 0) {
              goto LABEL_52;
            }
            goto LABEL_17;
          }

          (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
          uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          char v47 = *(void (**)(char *, uint64_t))(v9 + 8);
          v47(v28, a3);
          if (v48 > 128)
          {
            unint64_t v35 = 128LL;
            goto LABEL_52;
          }

Swift::UInt64 protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance _Int128( Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::_Int128 *a3)
{
  Swift::tuple_quotient__Int128_remainder__Int128 v6 = _Int128.quotientAndRemainder(dividingBy:)(*a3);
  *a1 = v6.quotient.low;
  a1[1] = v6.quotient.high;
  *a2 = v6.remainder.low;
  a2[1] = v6.remainder.high;
  return v6.quotient.low;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance _Int128(uint64_t *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

BOOL protocol witness for BinaryInteger.signum() in conformance _Int128@<W0>(BOOL *a1@<X8>)
{
  BOOL result = specialized BinaryInteger.signum()(*(void *)v1, *(void *)(v1 + 8));
  *a1 = result;
  a1[1] = v4;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _Int128( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    uint64_t v10 = a3();
    if ((v12 & 0x100) != 0)
    {
      uint64_t v13 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10LL, a4);
      uint64_t v14 = v17;
      char v19 = v18;
      swift_bridgeObjectRelease(a2);
      int v16 = v19 & 1;
    }

    else
    {
      uint64_t v13 = v10;
      uint64_t v14 = v11;
      char v15 = v12;
      swift_bridgeObjectRelease(a2);
      int v16 = v15 & 1;
    }

    if (v16) {
      uint64_t v20 = 0LL;
    }
    else {
      uint64_t v20 = v13;
    }
    if (v16) {
      uint64_t v21 = 0LL;
    }
    else {
      uint64_t v21 = v14;
    }
  }

  else
  {
    swift_bridgeObjectRelease(a2);
    uint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    LOBYTE(v16) = 1;
  }

  *(void *)a5 = v20;
  *(void *)(a5 + 8) = v21;
  *(_BYTE *)(a5 + 16) = v16;
}

void protocol witness for Strideable.distance(to:) in conformance _Int128( unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = *v2;
  uint64_t v7 = v2[1];
  if (v7)
  {
    if (v5)
    {
      if (v5 < 0 != v7 < 0)
      {
        if (v7 < 0)
        {
          BOOL v11 = v6 == 0;
          unint64_t v6 = -(uint64_t)v6;
          if (v11) {
            uint64_t v7 = -v7;
          }
          else {
            uint64_t v7 = ~v7;
          }
          char v8 = 1;
          if ((v5 & 0x8000000000000000LL) == 0) {
            goto LABEL_38;
          }
        }

        else
        {
          char v8 = 0;
          if ((v5 & 0x8000000000000000LL) == 0)
          {
            uint64_t v9 = v7 + v5;
            unint64_t v10 = v6 + v4;
            if (!__CFADD__(v6, v4)) {
              goto LABEL_45;
            }
            goto LABEL_44;
          }
        }

void protocol witness for Strideable.advanced(by:) in conformance _Int128(void *a1@<X8>)
{
  uint64_t v4 = *v1;
  uint64_t v3 = v1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  BOOL v7 = __CFADD__(v4, v5);
  uint64_t v8 = v3 + v6;
  if (__OFADD__(v3, v6) || (v7 ? (BOOL v9 = v8 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v9 = 0), v9)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x25EuLL,  0);
  }
  *a1 = v4 + v5;
  a1[1] = v8 + v7;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _Int128( uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128( uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, a4[1], *a5, a5[1], *a6);
}

Swift::UInt64 specialized _wideDivide32<A>(_:by:)( void *a1, unint64_t *a2, Swift::tuple_high_UInt64_low_UInt64 a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  Swift::UInt64 low = a3.low;
  Swift::UInt64 high = a3.high;
  if (a3.high == a5) {
    Swift::UInt64 result = -1LL;
  }
  else {
    Swift::UInt64 result = UInt64.dividingFullWidth(_:)(a3).quotient;
  }
  unint64_t v14 = result * a6;
  Swift::UInt64 v15 = (__PAIR128__(a5, a6) * result) >> 64;
  else {
    Swift::UInt64 v16 = (result * (unsigned __int128)a5) >> 64;
  }
  BOOL v17 = high >= v16;
  if (high != v16) {
    goto LABEL_14;
  }
LABEL_11:
  BOOL v17 = low >= v15;
  if (low != v15)
  {
    while (1)
    {
LABEL_14:
      if (v17) {
        goto LABEL_26;
      }
LABEL_15:
      BOOL v18 = __CFADD__(a4, a6);
      Swift::UInt64 v19 = low + a5;
      if (__CFADD__(low, a5)) {
        break;
      }
      if (v19 == -1LL)
      {
        if (!v18)
        {
          Swift::UInt64 low = -1LL;
          goto LABEL_10;
        }

        Swift::UInt64 low = 0LL;
LABEL_24:
        ++high;
        --result;
        a4 += a6;
        BOOL v17 = high >= v16;
        if (high == v16) {
          goto LABEL_11;
        }
      }

      else
      {
        Swift::UInt64 low = v19 + v18;
LABEL_10:
        a4 += a6;
        --result;
        BOOL v17 = high >= v16;
        if (high == v16) {
          goto LABEL_11;
        }
      }
    }

    Swift::UInt64 low = v19 + v18;
    goto LABEL_24;
  }

  if (a4 < v14) {
    goto LABEL_15;
  }
  Swift::UInt64 low = v15;
LABEL_26:
  BOOL v17 = a4 >= v14;
  unint64_t v20 = a4 - v14;
  uint64_t v21 = !v17;
  *a1 = low - v15 - v21;
  *a2 = v20;
  return result;
}

uint64_t < infix<A, B, C>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v35 = a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0LL, a7, a8, a9, 0LL, 0LL);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata3);
  BOOL v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  unint64_t v20 = (char *)&v32 - v19;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a7 - 8) + 16LL);
  v21((char *)&v32 - v19, a1, a7);
  uint64_t v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16LL);
  uint64_t v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  uint64_t v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  unint64_t v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a9 - 8) + 16LL);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  uint64_t v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  uint64_t v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  uint64_t v27 = v37;
  else {
    char v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 16))(v20, v18, a7, v27);
  }
  char v29 = v28;
  char v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t > infix<A, B>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = a8;
  uint64_t v30 = a3;
  uint64_t v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, a6, 0LL, 0LL);
  uint64_t v32 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  BOOL v18 = (char *)&v29 - v17;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL);
  v19((char *)&v29 - v17, a1, a5);
  unint64_t v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16LL);
  uint64_t v22 = a2;
  uint64_t v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  unint64_t v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  else {
    char v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 40))(v18, v16, a5);
  }
  char v26 = v25;
  uint64_t v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

uint64_t >= infix<A, B>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = a8;
  uint64_t v30 = a3;
  uint64_t v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, a6, 0LL, 0LL);
  uint64_t v32 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  BOOL v18 = (char *)&v29 - v17;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL);
  v19((char *)&v29 - v17, a1, a5);
  unint64_t v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16LL);
  uint64_t v22 = a2;
  uint64_t v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  unint64_t v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  else {
    char v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 32))(v18, v16, a5);
  }
  char v26 = v25;
  uint64_t v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

uint64_t *protocol witness for static SignedNumeric.- prefix(_:) in conformance _Int128@<X0>( uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  BOOL v4 = __OFSUB__(0LL, v2);
  uint64_t v5 = -v2;
  int v6 = v4;
  BOOL v7 = v3 == 0;
  uint64_t v8 = -v3;
  if (v7)
  {
    if (v6) {
      goto LABEL_8;
    }
  }

  else
  {
    if (v5 == 0x8000000000000000LL) {
      LOBYTE(v6) = 1;
    }
    if ((v6 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x252uLL,  0);
    --v5;
  }

  *a2 = v8;
  a2[1] = v5;
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance _Int128()
{
  uint64_t v2 = *v0;
  uint64_t v1 = v0[1];
  BOOL v3 = __OFSUB__(0LL, v1);
  uint64_t v4 = -v1;
  int v5 = v3;
  BOOL v6 = v2 == 0;
  uint64_t v7 = -v2;
  if (v6)
  {
    if (v5) {
      goto LABEL_8;
    }
  }

  else
  {
    if (v4 == 0x8000000000000000LL) {
      LOBYTE(v5) = 1;
    }
    if ((v5 & 1) != 0) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x252uLL,  0);
    --v4;
  }

  uint64_t *v0 = v7;
  v0[1] = v4;
}

_OWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance _Int128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result + *a2;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance _Int128@<X0>( _OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

uint64_t UnsafeMutableBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

  ;
}

char *UnsafeMutableBufferPointer._copyContents(initializing:)( char *__dst, uint64_t a2, char *__src, uint64_t a4, uint64_t a5)
{
  BOOL v6 = __src;
  if (a4 && a2)
  {
    if (a4 >= a2) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = a4;
    }
    UnsafeMutablePointer.initialize(from:count:)(__src, v7, __dst, a5);
    v6 += *(void *)(*(void *)(a5 - 8) + 72LL) * v7;
  }

  return v6;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>( a1,  (uint64_t (*)(void, void, void))UnsafeMutableBufferPointer.makeIterator(),  a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  (uint64_t)&protocol conformance descriptor for UnsafeMutableBufferPointer<A>);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, void, void, void))UnsafeMutableBufferPointer._copyContents(initializing:));
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.index(after:)(Swift::Int after)
{
  return UnsafeMutableBufferPointer.index(after:)(after, v1, v2, v3, 0xC9uLL);
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.formIndex(after:)(Swift::Int *after)
{
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.index(before:)(Swift::Int before)
{
  return UnsafeMutableBufferPointer.index(before:)(before, v1, v2, v3, 0xE5uLL);
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.formIndex(before:)(Swift::Int *before)
{
}

Swift::Int_optional __swiftcall UnsafeMutableBufferPointer.index(_:offsetBy:limitedBy:)( Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3 = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy, 0x10FuLL, 0x117uLL);
  Swift::Bool v5 = v4 & 1;
  result.unsigned int value = v3;
  result.is_nil = v5;
  return result;
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.swapAt(_:_:)(Swift::Int a1, Swift::Int a2)
{
  uint64_t v3 = v2;
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  unint64_t v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v4 != v5)
  {
    if ((v5 | v4) < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x17AuLL,  0);
    }
    if (v7 <= v4 || v7 <= v5) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x17BuLL,  0);
    }
    if (!v6) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x17CuLL,  0);
    }
    uint64_t v11 = *(void *)(v8 + 72);
    BOOL v12 = (char *)(v6 + v11 * v4);
    uint64_t v13 = (char *)(v6 + v11 * v5);
    uint64_t v14 = *(void (**)(char *, char *, uint64_t))(v8 + 32);
    v14(v10, v12, v3);
    UnsafeMutablePointer.moveInitialize(from:count:)(v13, 1LL, v12, v3);
    v14(v13, v10, v3);
  }

uint64_t UnsafeMutableBufferPointer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return UnsafeBufferPointer.subscript.getter(a1, a2, a3, a4, 0x206uLL, 0x207uLL, a5);
}

uint64_t UnsafeBufferPointer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  if (a3 <= a1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a6,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 16LL))( a7,  a2 + *(void *)(*(void *)(a4 - 8) + 72LL) * a1,  a4);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A@<X0>( void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *a2;
  if (*a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x206uLL,  0);
  }
  if (v4 >= a1[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x207uLL,  0);
  }
  uint64_t v5 = *(void *)(*(uint64_t *)((char *)a2 + a3 - 8) - 8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 16))(a4, *a1 + *(void *)(v5 + 72) * v4);
}

uint64_t key path setter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A( uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a3;
  if (*a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20DuLL,  0);
  }
  if (v4 >= a2[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
  }
  uint64_t v5 = *(void *)(*(uint64_t *)((char *)a3 + a4 - 8) - 8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 24))(*a2 + *(void *)(v5 + 72) * v4, a1);
}

uint64_t UnsafeMutableBufferPointer.subscript.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](a1);
  BOOL v12 = (char *)&v15 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, a1, v13);
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20DuLL,  0);
  }
  if (a4 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
  }
  (*(void (**)(uint64_t, uint64_t))(v10 + 8))(a1, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v10 + 40))(a3 + *(void *)(v10 + 72) * a2, v12, a5);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 40LL))( a3 + *(void *)(*(void *)(a5 - 8) + 72LL) * a2,  a1,  a5);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_unchecked:) : <A>UnsafeMutableBufferPointer<A>A( void *a1, void *a2)
{
  return UnsafeBufferPointer.subscript.getter(*a2, *a1);
}

uint64_t key path setter for UnsafeMutableBufferPointer.subscript(_unchecked:) : <A>UnsafeMutableBufferPointer<A>A( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a4 + a3 - 8);
  uint64_t v6 = UnsafeMutableBufferPointer.subscript.modify();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24LL))(v7, a1, v5);
  return ((uint64_t (*)(uint64_t *, void))v6)(&v9, 0LL);
}

uint64_t (*UnsafeMutableBufferPointer.subscript.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, 0x234uLL, 0x235uLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, a7, 0x23BuLL, 0x23CuLL);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A@<X0>( uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result = UnsafeMutableBufferPointer.subscript.getter(*a2, a2[1], *a1, a1[1], a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

char *key path setter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A( uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.subscript.setter( *a1,  a1[1],  a1[2],  a1[3],  *a3,  a3[1],  *a2,  a2[1],  *(uint64_t *)((char *)a3 + a4 - 8));
}

char *UnsafeMutableBufferPointer.subscript.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x26CuLL,  0);
  }
  if (a8 < a6) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x26DuLL,  0);
  }
  uint64_t v10 = (char *)(a6 - a5);
  if (__OFSUB__(a6, a5))
  {
    __break(1u);
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x26EuLL,  0);
  }

  uint64_t v15 = type metadata accessor for UnsafeMutableBufferPointer(255LL, a9, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v15, v16);
  uint64_t v19 = type metadata accessor for Slice(0LL, v15, WitnessTable, v18);
  uint64_t v21 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v19, v20);
  uint64_t result = (char *)Collection.count.getter(v19, v21);
  if (v10 != result) {
    goto LABEL_14;
  }
  if (a1 == a2) {
    return result;
  }
  if (!a7)
  {
    unint64_t v23 = 626LL;
    goto LABEL_18;
  }

  if (!a3)
  {
    unint64_t v23 = 627LL;
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v23,  0);
  }

  if (__OFSUB__(a2, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x129uLL,  0);
  }
  return UnsafeMutablePointer.assign(from:count:)( (char *)(a3 + *(void *)(*(void *)(a9 - 8) + 72LL) * a1),  a2 - a1,  (char *)(a7 + *(void *)(*(void *)(a9 - 8) + 72LL) * a5),  a9);
}

void (*UnsafeMutableBufferPointer.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6))(uint64_t **a1)
{
  BOOL v12 = malloc(0x48uLL);
  *a1 = v12;
  v12[7] = a5;
  v12[8] = a6;
  v12[5] = a3;
  v12[6] = a4;
  uint64_t v12[4] = a2;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x265uLL,  0);
  }
  if (a5 < a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x266uLL,  0);
  }
  *BOOL v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  uint64_t v12[3] = a5;
  return UnsafeMutableBufferPointer.subscript.modify;
}

void UnsafeMutableBufferPointer.subscript.modify(uint64_t **a1)
{
  uint64_t v1 = *a1;
  UnsafeMutableBufferPointer.subscript.setter( **a1,  v1[1],  v1[2],  (*a1)[3],  (*a1)[4],  (*a1)[5],  (*a1)[6],  (*a1)[7],  (*a1)[8]);
  free(v1);
}

uint64_t UnsafeMutableBufferPointer._withUnsafeMutableBufferPointerIfSupported<A>(_:)@<X0>( uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t result = a1(v3);
  if (!v4) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))(a3, 0LL, 1LL, a2);
  }
  return result;
}

BOOL UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<W0>( void (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = v4;
  uint64_t v11 = *v4;
  uint64_t v10 = v4[1];
  a1(v4);
  if (v5)
  {
    uint64_t v14 = v4[1];
    uint64_t v15 = *(void *)(a2 + 16);
    uint64_t v31 = *v6;
    uint64_t v32 = v11;
    uint64_t v16 = type metadata accessor for UnsafeMutablePointer(255LL, v15, v12, v13);
    uint64_t v19 = type metadata accessor for Optional(0LL, v16, v17, v18);
    uint64_t v30 = &protocol witness table for UnsafeMutablePointer<A>;
    uint64_t v20 = &v30;
  }

  else
  {
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL))(a4, 0LL, 1LL, a3);
    uint64_t v14 = v4[1];
    uint64_t v21 = *(void *)(a2 + 16);
    uint64_t v31 = *v6;
    uint64_t v32 = v11;
    uint64_t v24 = type metadata accessor for UnsafeMutablePointer(255LL, v21, v22, v23);
    uint64_t v19 = type metadata accessor for Optional(0LL, v24, v25, v26);
    uint64_t v29 = &protocol witness table for UnsafeMutablePointer<A>;
    uint64_t v20 = &v29;
  }

  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, v19, v20);
  BOOL result = specialized == infix<A, B>(_:_:)((uint64_t)&v32, v10, (uint64_t)&v31, v14, v19, WitnessTable);
  if (!result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed",  103LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x289uLL,  0);
  }
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeMutableBufferPointer<A>( void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  void v7[4] = UnsafeMutableBufferPointer.subscript.read(v7, *a2, *v3, v3[1], *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*UnsafeMutableBufferPointer.subscript.read( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v7 = *(void *)(a5 - 8);
  *a1 = a5;
  a1[1] = v7;
  a1[2] = malloc(*(void *)(v7 + 64));
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x206uLL,  0);
  }
  if (a4 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x207uLL,  0);
  }
  (*(void (**)(void))(v7 + 16))();
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>( a1,  (uint64_t (*)(void, void, void, void))UnsafeMutableBufferPointer.subscript.getter,  a2);
}

void *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  0x101uLL,  a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>( a1,  a2,  a3,  0x10FuLL,  0x117uLL,  a4);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, unint64_t a4@<X5>, unint64_t a5@<X6>, uint64_t a6@<X8>)
{
  uint64_t result = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(*a1, a2, *a3, a4, a5);
  *(void *)a6 = result;
  *(_BYTE *)(a6 + 8) = v8 & 1;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  0x129uLL);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  0x234uLL,  0x235uLL);
}

{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  0x23BuLL,  0x23CuLL);
}

void *protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>@<X0>( void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>(a1, 0xC9uLL, a2);
}

void *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  0xD7uLL);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  char v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *v9;
  uint64_t v12 = *v3;
  uint64_t v11 = v3[1];
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, v5);
  if (v10 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20DuLL,  0);
  }
  if (v10 >= v11) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
  }
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v6 + 40))(v12 + *(void *)(v6 + 72) * v10, v8, v5);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableBufferPointer<A>( uint64_t a1, void *a2))()
{
  if ((*a2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20DuLL,  0);
  }
  if (*a2 >= *(void *)(v2 + 8)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x20EuLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

char *protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableBufferPointer<A>( uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return UnsafeMutableBufferPointer.subscript.setter( *a1,  a1[1],  a1[2],  a1[3],  *a2,  a2[1],  *v3,  v3[1],  *(void *)(a3 + 16));
}

void (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableBufferPointer<A>( void *a1, uint64_t *a2, uint64_t a3))(uint64_t **a1)
{
  uint64_t v7 = malloc(0x48uLL);
  *a1 = v7;
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  void v7[4] = *a2;
  v7[5] = v9;
  uint64_t v10 = *v3;
  uint64_t v11 = v3[1];
  v7[6] = *v3;
  v7[7] = v11;
  v7[8] = *(void *)(a3 + 16);
  if (v8 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x265uLL,  0);
  }
  if (v11 < v9) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x266uLL,  0);
  }
  *uint64_t v7 = v8;
  v7[1] = v9;
  _OWORD v7[2] = v10;
  v7[3] = v11;
  return UnsafeMutableBufferPointer.subscript.modify;
}

void *protocol witness for MutableCollection.partition(by:) in conformance UnsafeMutableBufferPointer<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void protocol witness for MutableCollection.swapAt(_:_:) in conformance UnsafeMutableBufferPointer<A>( Swift::Int *a1, Swift::Int *a2)
{
}

uint64_t protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<X0>( uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeMutableBufferPointer._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3);
}

BOOL protocol witness for MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<W0>( void (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a3, a2, a4);
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>@<X0>( void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>( a1,  0xE5uLL,  a2);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  0xF3uLL);
}

uint64_t UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error),  (uint64_t (*)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_sSrsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_Sryqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSryxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5);
}

unint64_t UnsafeMutableBufferPointer.debugDescription.getter( uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = specialized static String._createEmpty(withInitialCapacity:)(22LL);
  uint64_t v10 = v6;
  unint64_t v11 = v7;
  v298._uint64_t countAndFlagsBits = v6;
  v298._unint64_t object = (void *)v7;
  unint64_t v12 = HIBYTE(v7) & 0xF;
  unint64_t v13 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000LL) != 0) {
    uint64_t v14 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v14 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (!v14 && (v6 & ~v7 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v298._uint64_t countAndFlagsBits = 0x203A747261747328LL;
    v298._unint64_t object = (void *)0xE800000000000000LL;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }

  if ((v7 & 0x2000000000000000LL) == 0 || v12 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000LL, 6LL, v8, v9);
    if ((v11 & 0x1000000000000000LL) == 0)
    {
      Swift::Int v25 = v14 + 8;
      if (!__OFADD__(v14, 8LL)) {
        goto LABEL_13;
      }
      goto LABEL_310;
    }

    goto LABEL_308;
  }

  uint64_t v15 = 8 * HIBYTE(v7);
  uint64_t v16 = (40LL << (v15 & 0x38)) | ((-255LL << (v15 & 0x38)) - 1) & v6;
  char v17 = (v15 + 8) & 0x38;
  uint64_t v18 = (-255LL << v17) - 1;
  uint64_t v19 = 115LL << v17;
  if (v12 >= 7)
  {
    unint64_t v21 = v19 | v18 & v7;
    char v20 = 8;
    goto LABEL_32;
  }

  uint64_t v16 = v19 | v18 & v16;
  if (v12 == 6)
  {
    char v20 = 0;
    unint64_t v21 = v7;
LABEL_32:
    uint64_t v33 = (116LL << v20) | ((-255LL << v20) - 1) & v21;
    char v34 = v12 + 3;
LABEL_33:
    uint64_t v35 = (97LL << (8 * (v34 & 7u))) | ((-255LL << (8 * (v34 & 7u))) - 1) & v33;
    char v36 = v12 + 4;
LABEL_34:
    uint64_t v37 = (114LL << (8 * (v36 & 7u))) | ((-255LL << (8 * (v36 & 7u))) - 1) & v35;
    char v38 = v12 + 5;
LABEL_35:
    uint64_t v39 = (116LL << (8 * (v38 & 7u))) | ((-255LL << (8 * (v38 & 7u))) - 1) & v37;
    char v40 = v12 + 6;
LABEL_36:
    uint64_t v41 = (58LL << (8 * (v40 & 7u))) | ((-255LL << (8 * (v40 & 7u))) - 1) & v39;
    char v42 = v12 + 7;
    goto LABEL_37;
  }

  uint64_t v16 = (116LL << ((v15 + 16) & 0x38)) | ((-255LL << ((v15 + 16) & 0x38)) - 1) & v16;
  if (v12 >= 5)
  {
    char v34 = 8;
    uint64_t v33 = v7;
    goto LABEL_33;
  }

  uint64_t v16 = (97LL << ((v15 + 24) & 0x38)) | ((-255LL << ((v15 + 24) & 0x38)) - 1) & v16;
  if (v12 == 4)
  {
    char v36 = 8;
    uint64_t v35 = v7;
    goto LABEL_34;
  }

  uint64_t v16 = (114LL << ((v15 + 32) & 0x38)) | ((-255LL << ((v15 + 32) & 0x38)) - 1) & v16;
  if (v12 >= 3)
  {
    char v38 = 8;
    uint64_t v37 = v7;
    goto LABEL_35;
  }

  uint64_t v16 = (116LL << ((v15 + 40) & 0x38)) | ((-255LL << ((v15 + 40) & 0x38)) - 1) & v16;
  if (v12 == 2)
  {
    char v40 = 8;
    uint64_t v39 = v7;
    goto LABEL_36;
  }

  uint64_t v16 = (58LL << ((v15 + 48) & 0x38)) | ((-255LL << ((v15 + 48) & 0x38)) - 1) & v16;
  if (!v12)
  {
    uint64_t v16 = (32LL << ((v15 + 56) & 0x38)) | ((-255LL << ((v15 + 56) & 0x38)) - 1) & v16;
    uint64_t v43 = v7;
    goto LABEL_38;
  }

  char v42 = 8;
  uint64_t v41 = v7;
LABEL_37:
  uint64_t v43 = (32LL << (8 * (v42 & 7u))) | ((-255LL << (8 * (v42 & 7u))) - 1) & v41;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  unint64_t v46 = 0xA000000000000000LL;
  if (!(v16 & 0x8080808080808080LL | v43 & 0x80808080808080LL)) {
    unint64_t v46 = 0xE000000000000000LL;
  }
  v298._uint64_t countAndFlagsBits = v16;
  v298._unint64_t object = (void *)((v46 & 0xFF00000000000000LL | (v12 << 56) | v43 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000LL);
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  a3 = 0xE300000000000000LL;
  a1 = 7104878LL;
  while (1)
  {
    uint64_t countAndFlagsBits = v298._countAndFlagsBits;
    unint64_t object = (unint64_t)v298._object;
    unint64_t v83 = ((unint64_t)v298._object >> 56) & 0xF;
    else {
      unint64_t v84 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v296 = a2;
    if (!v84 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._uint64_t countAndFlagsBits = a1;
      v298._unint64_t object = (void *)a3;
      goto LABEL_170;
    }

    uint64_t v10 = a3 & 0x2000000000000000LL;
    unint64_t v13 = HIBYTE(a3) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000LL) != 0 && v10)
    {
      unint64_t v85 = v83 + v13;
      if (v83 + v13 <= 0xF)
      {
        if (v13)
        {
          char v106 = 0;
          unint64_t v107 = 0LL;
          unint64_t v108 = (unint64_t)v298._object;
          do
          {
            unint64_t v109 = v83 + v107;
            unint64_t v110 = v107 + 1;
            if (v107 >= 8) {
              unint64_t v111 = a3;
            }
            else {
              unint64_t v111 = a1;
            }
            unint64_t v112 = v111 >> (v106 & 0x38);
            char v113 = (8 * v83 + v106) & 0x38;
            uint64_t v114 = (-255LL << v113) - 1;
            unint64_t v115 = (unint64_t)v112 << v113;
            unint64_t v116 = v115 | v114 & v108;
            unint64_t v117 = v115 | v114 & countAndFlagsBits;
            if (v109 < 8) {
              uint64_t countAndFlagsBits = v117;
            }
            else {
              unint64_t v108 = v116;
            }
            v106 += 8;
            unint64_t v107 = v110;
          }

          while (v13 != v110);
        }

        else
        {
          unint64_t v108 = (unint64_t)v298._object;
        }

        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(a3);
        unint64_t v144 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | v108 & 0x80808080808080LL)) {
          unint64_t v144 = 0xE000000000000000LL;
        }
        v298._uint64_t countAndFlagsBits = countAndFlagsBits;
        v298._unint64_t object = (void *)(v144 & 0xFF00000000000000LL | (v85 << 56) | v108 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }

      uint64_t v10 = 1LL;
    }

    int64_t v61 = a1 & 0xFFFFFFFFFFFFLL;
    uint64_t v86 = v10 ? HIBYTE(a3) & 0xF : a1 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a3, 2LL, v44, v45);
    if ((a3 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(a3, 4LL, v87, v88);
    a2 = v86;
    if ((object & 0x1000000000000000LL) != 0) {
      goto LABEL_293;
    }
LABEL_95:
    BOOL v91 = __OFADD__(v84, a2);
    Swift::Int v92 = v84 + a2;
    if (v91) {
      goto LABEL_295;
    }
LABEL_96:
    uint64_t v295 = v86;
    if ((countAndFlagsBits & ~object & 0x2000000000000000LL) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v92 >= 16)
      {
        uint64_t v93 = v298._countAndFlagsBits;
        unint64_t v11 = (unint64_t)v298._object;
        goto LABEL_105;
      }

      Swift::Int v25 = (Swift::Int)v298._object;
      if (((uint64_t)v298._object & 0x2000000000000000LL) != 0)
      {
        int v105 = 0;
        unint64_t v11 = (unint64_t)v298._object;
      }

      else
      {
        unint64_t v11 = (unint64_t)v298._object;
LABEL_128:
        int v105 = 1;
      }

LABEL_320:
    if ((v63 & 0x1000000000000000LL) != 0)
    {
      int64_t v61 = _StringGuts._foreignConvertedToSmall()(v61, v63);
      unint64_t v294 = v293;
      swift_bridgeObjectRelease(v63);
      unint64_t v63 = v294;
    }

    else
    {
      if ((v61 & 0x1000000000000000LL) != 0)
      {
        uint64_t v283 = (unsigned __int8 *)((v63 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v284 = v61 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v283 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v61, v63);
      }

      closure #1 in _StringGuts._convertedToSmall()(v283, v284, &v297);
      swift_bridgeObjectRelease(v63);
      unint64_t v63 = *((void *)&v297 + 1);
      int64_t v61 = v297;
    }

    if ((v63 & 0x1000000000000000LL) != 0)
    {
      int64_t v61 = _StringGuts._foreignConvertedToSmall()(v61, v63);
      unint64_t v294 = v293;
      swift_bridgeObjectRelease(v63);
      unint64_t v63 = v294;
    }

    else
    {
      if ((v61 & 0x1000000000000000LL) != 0)
      {
        uint64_t v283 = (unsigned __int8 *)((v63 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v284 = v61 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v283 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v61, v63);
      }

      closure #1 in _StringGuts._convertedToSmall()(v283, v284, &v297);
      swift_bridgeObjectRelease(v63);
      unint64_t v63 = *((void *)&v297 + 1);
      int64_t v61 = v297;
    }

LABEL_333:
      unint64_t v289 = 266LL;
LABEL_335:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v289,  0);
    }
  }

  else if (v191 <= 15)
  {
    unint64_t v192 = (unint64_t)v298._object;
    goto LABEL_232;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v191, v190);
  swift_bridgeObjectRelease_n(v155, 4LL);
  if ((v155 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v155);
    _StringGuts._foreignAppendInPlace(_:)(a3, v155, 0LL, v13);
  }

  else
  {
    if (a2)
    {
      swift_bridgeObjectRelease_n(v155, 2LL);
      *(void *)&__int128 v297 = a3;
      *((void *)&v297 + 1) = v155 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v195 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, a1, (uint64_t)&v297, a1);
      _StringGuts.appendInPlace(_:isASCII:)(v195, v196, (v155 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v155);
      goto LABEL_273;
    }

    if ((a3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v155);
      id v250 = (id)((v155 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v251 = v148;
    }

    else
    {
      id v250 = _StringObject.sharedUTF8.getter(a3, v155);
      uint64_t v251 = v287;
      swift_bridgeObjectRelease(v155);
      if (v251 < v148) {
LABEL_332:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    unint64_t v252 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v148, (uint64_t)v250, v251);
    _StringGuts.appendInPlace(_:isASCII:)(v252, v253, (a3 & 0x8000000000000000LL) != 0LL);
  }

  swift_bridgeObjectRelease_n(v155, 2LL);
LABEL_273:
  unint64_t v256 = v298._object;
  unint64_t v257 = ((unint64_t)v298._object >> 56) & 0xF;
  if (v257 || (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v298._object & 0x2000000000000000LL) == 0
      || (unint64_t v258 = specialized _SmallString.init(_:appending:)( v298._countAndFlagsBits,  (unint64_t)v298._object,  0x29uLL,  0xE100000000000000LL),  (v198 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v197, v198, v199);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      uint64_t v259 = v298._countAndFlagsBits;
      uint64_t v260 = (uint64_t)v298._object;
    }

    else
    {
      uint64_t v259 = v258;
      uint64_t v260 = v197;
      swift_bridgeObjectRelease((uint64_t)v256);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v298._object);
    uint64_t v260 = 0xE100000000000000LL;
    uint64_t v259 = 41LL;
  }

  unint64_t v261 = specialized static String.+ infix(_:_:)( 0xD00000000000001ALL,  0x8000000181800650LL | 0x8000000000000000LL,  v259,  v260);
  swift_bridgeObjectRelease(0x8000000181800650LL | 0x8000000000000000LL);
  swift_bridgeObjectRelease(v260);
  return v261;
}

      unint64_t v289 = 266LL;
LABEL_335:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v289,  0);
    }
  }

  else if (v191 <= 15)
  {
    unint64_t v192 = (unint64_t)v298._object;
    goto LABEL_232;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v191, v190);
  swift_bridgeObjectRelease_n(v155, 4LL);
  if ((v155 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v155);
    _StringGuts._foreignAppendInPlace(_:)(a3, v155, 0LL, v13);
  }

  else
  {
    if (a2)
    {
      swift_bridgeObjectRelease_n(v155, 2LL);
      *(void *)&__int128 v297 = a3;
      *((void *)&v297 + 1) = v155 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v195 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, a1, (uint64_t)&v297, a1);
      _StringGuts.appendInPlace(_:isASCII:)(v195, v196, (v155 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(v155);
      goto LABEL_273;
    }

    if ((a3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v155);
      id v250 = (id)((v155 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v251 = v148;
    }

    else
    {
      id v250 = _StringObject.sharedUTF8.getter(a3, v155);
      uint64_t v251 = v287;
      swift_bridgeObjectRelease(v155);
      if (v251 < v148) {
LABEL_332:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    unint64_t v252 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v148, (uint64_t)v250, v251);
    _StringGuts.appendInPlace(_:isASCII:)(v252, v253, (a3 & 0x8000000000000000LL) != 0LL);
  }

  swift_bridgeObjectRelease_n(v155, 2LL);
LABEL_273:
  unint64_t v256 = v298._object;
  unint64_t v257 = ((unint64_t)v298._object >> 56) & 0xF;
  if (v257 || (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v298._object & 0x2000000000000000LL) == 0
      || (unint64_t v258 = specialized _SmallString.init(_:appending:)( v298._countAndFlagsBits,  (unint64_t)v298._object,  0x29uLL,  0xE100000000000000LL),  (v198 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v197, v198, v199);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      uint64_t v259 = v298._countAndFlagsBits;
      uint64_t v260 = (uint64_t)v298._object;
    }

    else
    {
      uint64_t v259 = v258;
      uint64_t v260 = v197;
      swift_bridgeObjectRelease((uint64_t)v256);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v298._object);
    uint64_t v260 = 0xE100000000000000LL;
    uint64_t v259 = 41LL;
  }

  unint64_t v261 = specialized static String.+ infix(_:_:)( 0xD000000000000013LL,  0x8000000181800670LL | 0x8000000000000000LL,  v259,  v260);
  swift_bridgeObjectRelease(0x8000000181800670LL | 0x8000000000000000LL);
  swift_bridgeObjectRelease(v260);
  return v261;
}

            unint64_t v75 = 0LL;
          }

          size_t v249 = 286;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChild( this,  v249,  (swift::Demangle::__runtime::Node *)v75,  (uint64_t)v75,  a5);
        case 'i':
          a5 = (char *)swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
          unint64_t v224 = *((_DWORD *)v7 + 24);
          if (!v224) {
            goto LABEL_334;
          }
          unint64_t v225 = v224 - 1;
          unint64_t v226 = *((void *)v7 + 11);
          unint64_t v137 = *(unsigned __int16 **)(v226 + 8LL * (v224 - 1));
          unint64_t v227 = v137[8];
          if (v227 == 232)
          {
            *((_DWORD *)v7 + 24) = v225;
            goto LABEL_362;
          }

          if (v227 != 43)
          {
LABEL_334:
            unint64_t v137 = 0LL;
LABEL_362:
            this = v7;
            id v250 = 343;
            goto LABEL_365;
          }

          *((_DWORD *)v7 + 24) = v225;
          else {
            *((_DWORD *)v7 + 24) = v228;
          }
          unint64_t v135 = v7;
          unint64_t v136 = 343;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( v135,  v136,  (swift::Demangle::__runtime::Node *)v134,  (swift::Demangle::__runtime::Node *)v137,  a5);
        case 'j':
          a5 = (char *)swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
          char v229 = *((_DWORD *)v7 + 24);
          if (!v229) {
            goto LABEL_335;
          }
          uint64_t v230 = v229 - 1;
          unint64_t v231 = *((void *)v7 + 11);
          unint64_t v137 = *(unsigned __int16 **)(v231 + 8LL * (v229 - 1));
          unint64_t v232 = v137[8];
          if (v232 == 232)
          {
            *((_DWORD *)v7 + 24) = v230;
          }

          else
          {
            if (v232 == 43)
            {
              *((_DWORD *)v7 + 24) = v230;
              if (v229 == 1
                || (v233 = v229 - 2, unint64_t v134 = *(unsigned int **)(v231 + 8LL * v233), *((_WORD *)v134 + 8) != 232))
              {
                unint64_t v134 = 0LL;
              }

              else
              {
                *((_DWORD *)v7 + 24) = v233;
              }

              unint64_t v135 = v7;
              unint64_t v136 = 344;
              return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( v135,  v136,  (swift::Demangle::__runtime::Node *)v134,  (swift::Demangle::__runtime::Node *)v137,  a5);
            }

unint64_t _sSryxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1)
{
  return UnsafeMutableBufferPointer.debugDescription.getter(*v1, v1[1], *(void *)(a1 + 16));
}

uint64_t UnsafeBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeBufferPointer.init(_empty:)()
{
  return 0LL;
}

uint64_t UnsafeBufferPointer.Iterator._position.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*UnsafeBufferPointer.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeBufferPointer.Iterator._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeBufferPointer.Iterator._end.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*UnsafeBufferPointer.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a3, a4, a5);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeBufferPointer<A>@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>( a1,  (uint64_t (*)(void, void, void))UnsafeBufferPointer.makeIterator(),  a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>@<X0>( uint64_t a1@<X0>, uint64_t (*a2)(void, void, void)@<X2>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*v3, v3[1], *(void *)(a1 + 16));
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeBufferPointer<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  (uint64_t)&protocol conformance descriptor for UnsafeBufferPointer<A>);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(a3, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeBufferPointer<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, void, void, void))UnsafeBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, void, void, void))
{
  *a1 = a6(a2, a3, *v6, v6[1], *(void *)(a4 + 16));
  a1[1] = v8;
  return v9;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeBufferPointer<A>@<X0>( uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

Swift::Int __swiftcall UnsafeBufferPointer.index(after:)(Swift::Int after)
{
  return UnsafeMutableBufferPointer.index(after:)(after, v1, v2, v3, 0x5E7uLL);
}

uint64_t UnsafeMutableBufferPointer.index(after:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5 = __OFADD__(a1, 1LL);
  uint64_t result = a1 + 1;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.formIndex(after:)(Swift::Int *after)
{
}

void *UnsafeMutableBufferPointer.formIndex(after:)( void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (__OFADD__(*result, 1LL)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  ++*result;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.index(before:)(Swift::Int before)
{
  return UnsafeMutableBufferPointer.index(before:)(before, v1, v2, v3, 0x603uLL);
}

uint64_t UnsafeMutableBufferPointer.index(before:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5 = __OFSUB__(a1, 1LL);
  uint64_t result = a1 - 1;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.formIndex(before:)(Swift::Int *before)
{
}

void *UnsafeMutableBufferPointer.formIndex(before:)( void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (__OFSUB__(*result, 1LL)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  --*result;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.index(_:offsetBy:)(Swift::Int _, Swift::Int offsetBy)
{
  return UnsafeMutableBufferPointer.index(_:offsetBy:)(_, offsetBy, v2, v3, v4, 0x61FuLL);
}

uint64_t UnsafeMutableBufferPointer.index(_:offsetBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  BOOL v6 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v6) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a6,  0);
  }
  return result;
}

Swift::Int_optional __swiftcall UnsafeBufferPointer.index(_:offsetBy:limitedBy:)( Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3 = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy, 0x62DuLL, 0x635uLL);
  Swift::Bool v5 = v4 & 1;
  result.unsigned int value = v3;
  result.is_nil = v5;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.distance(from:to:)(Swift::Int from, Swift::Int to)
{
  return UnsafeMutableBufferPointer.distance(from:to:)(from, to, v2, v3, v4, 0x647uLL);
}

uint64_t UnsafeMutableBufferPointer.distance(from:to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  BOOL v6 = __OFSUB__(a2, a1);
  uint64_t result = a2 - a1;
  if (v6) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a6,  0);
  }
  return result;
}

uint64_t UnsafeMutableBufferPointer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + *(void *)(*(void *)(a3 - 8) + 72LL) * a1,  a3);
}

uint64_t UnsafeBufferPointer._failEarlyRangeCheck(_:bounds:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, 0x714uLL, 0x715uLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8)
{
  if (result < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a7,  0);
  }
  if (result >= a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a8,  0);
  }
  return result;
}

uint64_t UnsafeBufferPointer._failEarlyRangeCheck(_:bounds:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, a7, 0x71BuLL, 0x71CuLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  if (result < a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a8,  0);
  }
  if (a4 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a9,  0);
  }
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeBufferPointer<A>( void *a1, uint64_t *a2, uint64_t a3))()
{
  unint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  void v7[4] = UnsafeBufferPointer.subscript.read(v7, *a2, *v3, v3[1], *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>(void *a1)
{
  uint64_t v1 = (void *)*a1;
  (*(void (**)(void))(*a1 + 32LL))(*a1);
  free(v1);
}

uint64_t (*UnsafeBufferPointer.subscript.read( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v7 = *(void *)(a5 - 8);
  *a1 = a5;
  a1[1] = v7;
  a1[2] = malloc(*(void *)(v7 + 64));
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
  }
  if (a4 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  (*(void (**)(void))(v7 + 16))();
  return _ArrayBuffer.subscript.read;
}

void _ArrayBuffer.subscript.read(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  (*(void (**)(void *, void))(a1[1] + 8LL))(v1, *a1);
  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeBufferPointer<A>@<X0>( void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>( a1,  (uint64_t (*)(void, void, void, void))UnsafeBufferPointer.subscript.getter,  a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>@<X0>( void *a1@<X0>, uint64_t (*a2)(void, void, void, void)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], *v3, v3[1]);
  *a3 = result;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance UnsafeBufferPointer<A>@<X0>( uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = UnsafeBufferPointer.indices.getter(a1, *(void *)(v2 + 8));
  *a2 = 0LL;
  a2[1] = v5;
  return result;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance UnsafeBufferPointer<A>()
{
  return UnsafeBufferPointer.isEmpty.getter(*v0, v0[1]);
}

void *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeBufferPointer<A>@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  0x61FuLL,  a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>( a1,  a2,  a3,  0x62DuLL,  0x635uLL,  a4);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeBufferPointer<A>( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  0x647uLL);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeBufferPointer<A>( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  0x714uLL,  0x715uLL);
}

{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  a4,  0x71BuLL,  0x71CuLL);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>( void *result, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  if (*result < *a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  if (*result >= a2[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a6,  0);
  }
  return result;
}

{
  if (*result < *a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  if (a2[1] < result[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a6,  0);
  }
  return result;
}

void *protocol witness for Collection.index(after:) in conformance UnsafeBufferPointer<A>@<X0>( void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>(a1, 0x5E7uLL, a2);
}

void *protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>@<X0>( void *result@<X0>, unint64_t a2@<X3>, void *a3@<X8>)
{
  if (__OFADD__(*result, 1LL)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a2,  0);
  }
  *a3 = *result + 1LL;
  return result;
}

void *protocol witness for Collection.formIndex(after:) in conformance UnsafeBufferPointer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  0x5F5uLL);
}

void *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>( void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (__OFADD__(*result, 1LL)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a4,  0);
  }
  ++*result;
  return result;
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeBufferPointer<A>@<X0>( void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>( a1,  0x603uLL,  a2);
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>@<X0>( void *result@<X0>, unint64_t a2@<X3>, void *a3@<X8>)
{
  if (__OFSUB__(*result, 1LL)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a2,  0);
  }
  *a3 = *result - 1LL;
  return result;
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeBufferPointer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>( a1,  a2,  a3,  0x611uLL);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>( void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (__OFSUB__(*result, 1LL)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a4,  0);
  }
  --*result;
  return result;
}

void *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>( void *result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X4>, void *a4@<X8>)
{
  if (__OFADD__(*result, a2)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a3,  0);
  }
  *a4 = *result + a2;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>( void *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5 = __OFSUB__(*a2, *a1);
  uint64_t result = *a2 - *a1;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  a5,  0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.deallocate()()
{
  if (v0) {
    swift_slowDealloc(v0);
  }
}

uint64_t UnsafeBufferPointer.withMemoryRebound<A, B>(to:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error),  (uint64_t (*)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5);
}

uint64_t UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t (*a10)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  _OWORD v11[2] = a6;
  uint64_t v11[3] = a7;
  v11[4] = a8;
  v11[5] = a2;
  v11[6] = a3;
  return a10(a9, v11, a4, a5, a6, a7, a8);
}

unint64_t UnsafeBufferPointer.debugDescription.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = specialized static String._createEmpty(withInitialCapacity:)(22LL);
  uint64_t v10 = v6;
  unint64_t v11 = v7;
  v298._uint64_t countAndFlagsBits = v6;
  v298._unint64_t object = (void *)v7;
  unint64_t v12 = HIBYTE(v7) & 0xF;
  unint64_t v13 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000LL) != 0) {
    uint64_t v14 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v14 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (!v14 && (v6 & ~v7 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v298._uint64_t countAndFlagsBits = 0x203A747261747328LL;
    v298._unint64_t object = (void *)0xE800000000000000LL;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }

  if ((v7 & 0x2000000000000000LL) == 0 || v12 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000LL, 6LL, v8, v9);
    if ((v11 & 0x1000000000000000LL) == 0)
    {
      Swift::Int v25 = v14 + 8;
      if (!__OFADD__(v14, 8LL)) {
        goto LABEL_13;
      }
      goto LABEL_310;
    }

    goto LABEL_308;
  }

  uint64_t v15 = 8 * HIBYTE(v7);
  uint64_t v16 = (40LL << (v15 & 0x38)) | ((-255LL << (v15 & 0x38)) - 1) & v6;
  char v17 = (v15 + 8) & 0x38;
  uint64_t v18 = (-255LL << v17) - 1;
  uint64_t v19 = 115LL << v17;
  if (v12 >= 7)
  {
    unint64_t v21 = v19 | v18 & v7;
    char v20 = 8;
    goto LABEL_32;
  }

  uint64_t v16 = v19 | v18 & v16;
  if (v12 == 6)
  {
    char v20 = 0;
    unint64_t v21 = v7;
LABEL_32:
    uint64_t v33 = (116LL << v20) | ((-255LL << v20) - 1) & v21;
    char v34 = v12 + 3;
LABEL_33:
    uint64_t v35 = (97LL << (8 * (v34 & 7u))) | ((-255LL << (8 * (v34 & 7u))) - 1) & v33;
    char v36 = v12 + 4;
LABEL_34:
    uint64_t v37 = (114LL << (8 * (v36 & 7u))) | ((-255LL << (8 * (v36 & 7u))) - 1) & v35;
    char v38 = v12 + 5;
LABEL_35:
    uint64_t v39 = (116LL << (8 * (v38 & 7u))) | ((-255LL << (8 * (v38 & 7u))) - 1) & v37;
    char v40 = v12 + 6;
LABEL_36:
    uint64_t v41 = (58LL << (8 * (v40 & 7u))) | ((-255LL << (8 * (v40 & 7u))) - 1) & v39;
    char v42 = v12 + 7;
    goto LABEL_37;
  }

  uint64_t v16 = (116LL << ((v15 + 16) & 0x38)) | ((-255LL << ((v15 + 16) & 0x38)) - 1) & v16;
  if (v12 >= 5)
  {
    char v34 = 8;
    uint64_t v33 = v7;
    goto LABEL_33;
  }

  uint64_t v16 = (97LL << ((v15 + 24) & 0x38)) | ((-255LL << ((v15 + 24) & 0x38)) - 1) & v16;
  if (v12 == 4)
  {
    char v36 = 8;
    uint64_t v35 = v7;
    goto LABEL_34;
  }

  uint64_t v16 = (114LL << ((v15 + 32) & 0x38)) | ((-255LL << ((v15 + 32) & 0x38)) - 1) & v16;
  if (v12 >= 3)
  {
    char v38 = 8;
    uint64_t v37 = v7;
    goto LABEL_35;
  }

  uint64_t v16 = (116LL << ((v15 + 40) & 0x38)) | ((-255LL << ((v15 + 40) & 0x38)) - 1) & v16;
  if (v12 == 2)
  {
    char v40 = 8;
    uint64_t v39 = v7;
    goto LABEL_36;
  }

  uint64_t v16 = (58LL << ((v15 + 48) & 0x38)) | ((-255LL << ((v15 + 48) & 0x38)) - 1) & v16;
  if (!v12)
  {
    uint64_t v16 = (32LL << ((v15 + 56) & 0x38)) | ((-255LL << ((v15 + 56) & 0x38)) - 1) & v16;
    uint64_t v43 = v7;
    goto LABEL_38;
  }

  char v42 = 8;
  uint64_t v41 = v7;
LABEL_37:
  uint64_t v43 = (32LL << (8 * (v42 & 7u))) | ((-255LL << (8 * (v42 & 7u))) - 1) & v41;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000LL);
  unint64_t v46 = 0xA000000000000000LL;
  if (!(v16 & 0x8080808080808080LL | v43 & 0x80808080808080LL)) {
    unint64_t v46 = 0xE000000000000000LL;
  }
  v298._uint64_t countAndFlagsBits = v16;
  v298._unint64_t object = (void *)((v46 & 0xFF00000000000000LL | (v12 << 56) | v43 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000LL);
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  a3 = 0xE300000000000000LL;
  a1 = 7104878LL;
  while (1)
  {
    uint64_t countAndFlagsBits = v298._countAndFlagsBits;
    unint64_t object = (unint64_t)v298._object;
    unint64_t v83 = ((unint64_t)v298._object >> 56) & 0xF;
    else {
      unint64_t v84 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v296 = a2;
    if (!v84 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._uint64_t countAndFlagsBits = a1;
      v298._unint64_t object = (void *)a3;
      goto LABEL_170;
    }

    uint64_t v10 = a3 & 0x2000000000000000LL;
    unint64_t v13 = HIBYTE(a3) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000LL) != 0 && v10)
    {
      unint64_t v85 = v83 + v13;
      if (v83 + v13 <= 0xF)
      {
        if (v13)
        {
          char v106 = 0;
          unint64_t v107 = 0LL;
          unint64_t v108 = (unint64_t)v298._object;
          do
          {
            unint64_t v109 = v83 + v107;
            unint64_t v110 = v107 + 1;
            if (v107 >= 8) {
              unint64_t v111 = a3;
            }
            else {
              unint64_t v111 = a1;
            }
            unint64_t v112 = v111 >> (v106 & 0x38);
            char v113 = (8 * v83 + v106) & 0x38;
            uint64_t v114 = (-255LL << v113) - 1;
            unint64_t v115 = (unint64_t)v112 << v113;
            unint64_t v116 = v115 | v114 & v108;
            unint64_t v117 = v115 | v114 & countAndFlagsBits;
            if (v109 < 8) {
              uint64_t countAndFlagsBits = v117;
            }
            else {
              unint64_t v108 = v116;
            }
            v106 += 8;
            unint64_t v107 = v110;
          }

          while (v13 != v110);
        }

        else
        {
          unint64_t v108 = (unint64_t)v298._object;
        }

        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(a3);
        unint64_t v144 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | v108 & 0x80808080808080LL)) {
          unint64_t v144 = 0xE000000000000000LL;
        }
        v298._uint64_t countAndFlagsBits = countAndFlagsBits;
        v298._unint64_t object = (void *)(v144 & 0xFF00000000000000LL | (v85 << 56) | v108 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }

      uint64_t v10 = 1LL;
    }

    int64_t v61 = a1 & 0xFFFFFFFFFFFFLL;
    uint64_t v86 = v10 ? HIBYTE(a3) & 0xF : a1 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a3, 2LL, v44, v45);
    if ((a3 & 0x1000000000000000LL) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(a3, 4LL, v87, v88);
    a2 = v86;
    if ((object & 0x1000000000000000LL) != 0) {
      goto LABEL_293;
    }
LABEL_95:
    BOOL v91 = __OFADD__(v84, a2);
    Swift::Int v92 = v84 + a2;
    if (v91) {
      goto LABEL_295;
    }
LABEL_96:
    uint64_t v295 = v86;
    if ((countAndFlagsBits & ~object & 0x2000000000000000LL) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v92 >= 16)
      {
        uint64_t v93 = v298._countAndFlagsBits;
        unint64_t v11 = (unint64_t)v298._object;
        goto LABEL_105;
      }

      Swift::Int v25 = (Swift::Int)v298._object;
      if (((uint64_t)v298._object & 0x2000000000000000LL) != 0)
      {
        int v105 = 0;
        unint64_t v11 = (unint64_t)v298._object;
      }

      else
      {
        unint64_t v11 = (unint64_t)v298._object;
LABEL_128:
        int v105 = 1;
      }