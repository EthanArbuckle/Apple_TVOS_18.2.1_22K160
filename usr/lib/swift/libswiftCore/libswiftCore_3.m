float Float16.init(sign:exponentBitPattern:significandBitPattern:)(char a1, char a2, __int16 a3)
{
  return specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, a2, a3);
}

Swift::Float __swiftcall Float.init(sign:exponentBitPattern:significandBitPattern:)( Swift::FloatingPointSign sign, Swift::UInt exponentBitPattern, Swift::UInt32 significandBitPattern)
{
  return specialized Float.init(sign:exponentBitPattern:significandBitPattern:)( sign & 1,  exponentBitPattern,  significandBitPattern);
}

Swift::Double __swiftcall Double.init(sign:exponentBitPattern:significandBitPattern:)( Swift::FloatingPointSign sign, Swift::UInt exponentBitPattern, Swift::UInt64 significandBitPattern)
{
  return specialized Double.init(sign:exponentBitPattern:significandBitPattern:)( sign & 1,  exponentBitPattern,  significandBitPattern);
}

uint64_t specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(__n128 _Q0, __n128 _Q1)
{
  __asm
  {
    FCVT            S2, H0
    FCVT            S3, H1
  }

  if (_S3 < _S2) {
    return 1LL;
  }
  BOOL v8 = _Q1.n128_i16[0] >= 0;
  if ((_Q0.n128_u16[0] & 0x8000) != 0)
  {
    if (_Q1.n128_i16[0] < 0) {
      goto LABEL_5;
    }
    return _Q1.n128_i16[0] < 0;
  }

  if (_Q1.n128_i16[0] < 0) {
    return _Q1.n128_i16[0] < 0;
  }
LABEL_5:
  unsigned int v9 = (_Q1.n128_i16[0] >> 10) & 0x1F;
  unsigned int v10 = (_Q0.n128_i16[0] >> 10) & 0x1F;
  unsigned int v11 = _Q1.n128_i16[0] & 0x3FF;
  unsigned int v12 = _Q0.n128_u16[0] & 0x3FF;
  BOOL v14 = _Q1.n128_i16[0] >= 0 || v11 >= v12;
  if (v12 < v11) {
    BOOL v15 = _Q1.n128_i16[0] < 0;
  }
  else {
    BOOL v15 = v14;
  }
  if (v9 >= v10) {
    BOOL v8 = v15;
  }
  if (v10 < v9) {
    return _Q1.n128_i16[0] < 0;
  }
  else {
    return v8;
  }
}

uint64_t specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(float a1, float a2)
{
  if (a2 < a1) {
    return 1LL;
  }
  if ((LODWORD(a1) & 0x80000000) != 0)
  {
    if ((LODWORD(a2) & 0x80000000) != 0) {
      goto LABEL_5;
    }
    return LODWORD(a2) >> 31;
  }

  if ((LODWORD(a2) & 0x80000000) != 0) {
    return LODWORD(a2) >> 31;
  }
LABEL_5:
  unsigned int v3 = (LODWORD(a2) >> 23);
  unsigned int v4 = (LODWORD(a1) >> 23);
  unsigned int v5 = LODWORD(a2) & 0x7FFFFF;
  unsigned int v6 = LODWORD(a1) & 0x7FFFFF;
  BOOL v8 = a2 >= 0.0 || v5 >= v6;
  if (v6 < v5) {
    BOOL v9 = LODWORD(a2) >> 31;
  }
  else {
    BOOL v9 = v8;
  }
  if (v3 < v4) {
    BOOL v9 = a2 >= 0.0;
  }
  if (v4 < v3) {
    return LODWORD(a2) >> 31;
  }
  else {
    return v9;
  }
}

uint64_t specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(double a1, double a2)
{
  if (a2 < a1) {
    return 1LL;
  }
  uint64_t result = *(void *)&a2 >> 63;
  if ((*(void *)&a1 & 0x8000000000000000LL) != 0)
  {
    if ((*(void *)&a2 & 0x8000000000000000LL) == 0) {
      return result;
    }
  }

  else if ((*(void *)&a2 & 0x8000000000000000LL) != 0)
  {
    return result;
  }

  unint64_t v3 = (*(void *)&a2 >> 52) & 0x7FFLL;
  unint64_t v4 = (*(void *)&a1 >> 52) & 0x7FFLL;
  unint64_t v5 = *(void *)&a2 & 0xFFFFFFFFFFFFFLL;
  unint64_t v6 = *(void *)&a1 & 0xFFFFFFFFFFFFFLL;
  BOOL v8 = a2 >= 0.0 || v5 >= v6;
  if (v6 < v5) {
    BOOL v8 = *(void *)&a2 >> 63;
  }
  if (v3 < v4) {
    BOOL v8 = a2 >= 0.0;
  }
  if (v4 < v3) {
    return result;
  }
  else {
    return v8;
  }
}

BOOL BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v69 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v65 = AssociatedTypeWitness;
  uint64_t v66 = v8;
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  v68 = (char *)&v56 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  v67 = (char *)&v56 - v11;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  v16 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v56 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v14);
  v18 = (char *)&v56 - v17;
  uint64_t v19 = *(void *)(a3 + 16);
  uint64_t v20 = *(void *)(*(void *)(v19 + 24) + 8LL);
  uint64_t v21 = v4;
  uint64_t v22 = v4;
  uint64_t v23 = v69;
  uint64_t v60 = v13;
  v61 = v18;
  v62 = v16;
  uint64_t v64 = v19;
  uint64_t v25 = v21;
  uint64_t v26 = a2;
  uint64_t v27 = v64;
  v28 = *(uint64_t (**)(uint64_t, uint64_t))(v64 + 168);
  uint64_t v63 = v25;
  char v29 = v28(a2, v64);
  if ((v28(a2, v27) & 1) != 0)
  {
    if ((v29 & 1) == 0) {
      goto LABEL_7;
    }
  }

  else if ((v29 & 1) != 0)
  {
LABEL_7:
    uint64_t v30 = a2;
    goto LABEL_11;
  }

  v31 = *(void (**)(uint64_t, uint64_t))(a3 + 112);
  v32 = v61;
  v31(a2, a3);
  v33 = v62;
  v58 = v31;
  v31(a2, a3);
  uint64_t v59 = a3;
  unint64_t v34 = v12;
  uint64_t v35 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a3,  a2,  v12,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)
                                          + 8)
                              + 32LL)
                  + 8LL);
  char v36 = (*(uint64_t (**)(char *, uint64_t (*)(uint64_t, uint64_t), unint64_t, uint64_t))(v35 + 40))( v32,  v33,  v12,  v35);
  uint64_t v37 = v26;
  v38 = *(void (**)(uint64_t (*)(uint64_t, uint64_t), unint64_t))(v60 + 8);
  v38(v33, v34);
  v38((uint64_t (*)(uint64_t, uint64_t))v32, v34);
  if ((v36 & 1) == 0)
  {
    uint64_t v60 = v35;
    v40 = v58;
    v58(v37, v59);
    uint64_t v57 = v37;
    v40(v37, v59);
    char v41 = (*(uint64_t (**)(char *, uint64_t (*)(uint64_t, uint64_t), unint64_t))(v60 + 16))( v32,  v33,  v34);
    v38(v33, v34);
    v38((uint64_t (*)(uint64_t, uint64_t))v32, v34);
    if ((v41 & 1) != 0)
    {
      char v42 = v28(v57, v27);
    }

    else
    {
      v62 = v28;
      uint64_t v43 = v59;
      v44 = *(void (**)(uint64_t, uint64_t))(v59 + 120);
      v45 = v67;
      uint64_t v46 = v57;
      v44(v57, v59);
      v47 = v68;
      v44(v46, v43);
      uint64_t v48 = v43;
      uint64_t v49 = v65;
      v50 = v47;
      uint64_t v51 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( v48,  v46,  v65,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)
                                              + 8)
                                  + 32LL)
                      + 8LL);
      char v52 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v51 + 40))(v45, v50, v49, v51);
      v53 = *(void (**)(char *, uint64_t))(v66 + 8);
      v53(v50, v49);
      v53(v45, v49);
      if ((v52 & 1) != 0)
      {
        char v39 = v62(v46, v64);
        return v39 & 1;
      }

      uint64_t v54 = v59;
      v44(v46, v59);
      v44(v46, v54);
      char v55 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v51 + 16))(v45, v50, v49, v51);
      v53(v50, v49);
      v53(v45, v49);
      if ((v55 & 1) == 0) {
        return 1LL;
      }
      char v42 = v62(v46, v64);
    }

    return (v42 & 1) == 0;
  }

  uint64_t v30 = v37;
LABEL_11:
  char v39 = v28(v30, v27);
  return v39 & 1;
}

BOOL specialized static BinaryFloatingPoint<>._convert<A>(from:)( unint64_t *a1, unint64_t a2, uint64_t a3)
{
  if (!(a3 | a2))
  {
    *a1 = 0LL;
    return 1LL;
  }

  unint64_t v6 = (unsigned __int128)-(__int128)__PAIR128__(v3, a2) >> 64;
  if (a3 >= 0) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = -(uint64_t)a2;
  }
  if (a3 >= 0) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = v6;
  }
  int64_t v9 = specialized FixedWidthInteger._binaryLogarithm()(v7, v8);
  if (v9 > 1023)
  {
    if ((a3 & 0x8000000000000000LL) == 0)
    {
LABEL_10:
      BOOL result = 0LL;
      *a1 = 0x7FF0000000000000LL;
      return result;
    }

    goto LABEL_45;
  }

  unint64_t v11 = v9;
  unint64_t v12 = v9 - 52;
  if (v9 <= 52)
  {
    if (v8) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    }
    if (v9 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    *a1 = ((v9 << 52) + 0x3FF0000000000000LL) & 0xFFF0000000000000LL | a3 & 0x8000000000000000LL | (v7 << (52 - v9)) & 0xFFFFFFFFFFFFFLL;
    return 1LL;
  }

  unint64_t v13 = v9 - 53;
  uint64_t v14 = 1LL << (v9 - 53);
  uint64_t v15 = 1LL;
  unint64_t v16 = 1uLL >> (53 - v9);
  if (v9 == 53) {
    unint64_t v16 = 0LL;
  }
  else {
    uint64_t v15 = 1LL << (v9 - 53);
  }
  if (v13 > 0x3F) {
    uint64_t v15 = 0LL;
  }
  else {
    uint64_t v14 = v16;
  }
  if (v13 >= 0x80) {
    unint64_t v17 = 0LL;
  }
  else {
    unint64_t v17 = v14;
  }
  if (v13 >= 0x80) {
    unint64_t v18 = 0LL;
  }
  else {
    unint64_t v18 = v15;
  }
  unint64_t v19 = specialized static _UInt128.* infix(_:_:)(2uLL, 0LL, v18, v17);
  if (!v20 && !v19) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x5FuLL,  0);
  }
  unint64_t v21 = (v19 - 1) & v7;
  unint64_t v22 = ((__PAIR128__(v20, v19) - 1) >> 64) & v8;
  if (v12 >= 0x80)
  {
    LOBYTE(v23) = 0;
    unint64_t v24 = 0LL;
    if (v17 == v22) {
      goto LABEL_30;
    }
LABEL_38:
    if (v17 < v22) {
      goto LABEL_42;
    }
LABEL_39:
    if (v22 != v17 || v21 != v18 || (v23 & 1) == 0) {
      goto LABEL_48;
    }
    goto LABEL_42;
  }

  unint64_t v23 = v8 >> v12;
  if (v12 < 0x40) {
    unint64_t v23 = (v8 << (52 - v11)) | (v7 >> v12);
  }
  unint64_t v24 = v23 & 0xFFFFFFFFFFFFFLL;
  if (v17 != v22) {
    goto LABEL_38;
  }
LABEL_30:
  if (v18 >= v21) {
    goto LABEL_39;
  }
LABEL_42:
  if (v24 < 0xFFFFFFFFFFFFFLL)
  {
    ++v24;
  }

  else
  {
    if (v11 >= 0x3FF)
    {
      if ((a3 & 0x8000000000000000LL) == 0) {
        goto LABEL_10;
      }
LABEL_45:
      BOOL result = 0LL;
      *a1 = 0xFFF0000000000000LL;
      return result;
    }

    ++v11;
    unint64_t v24 = 0x10000000000000LL;
  }

uint64_t specialized static BinaryFloatingPoint<>._convert<A>(from:)( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v335 = a1;
  uint64_t v7 = *(void *)(a4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  v327 = *(char **)(AssociatedConformanceWitness + 16);
  unint64_t v319 = swift_getAssociatedTypeWitness( 0LL,  v327,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v319);
  v320 = (char *)&v297 - v10;
  uint64_t v329 = v7;
  v334 = *(char **)(v7 + 16);
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  v334,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v11);
  v333 = (char *)&v297 - v12;
  unint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v331 = *(v13 - 1);
  v332 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  v309 = (char *)&v297 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  v308 = (char *)&v297 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v318 = (char *)&v297 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v311 = (char *)&v297 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v321 = (char *)&v297 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v315 = (char *)&v297 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v28 = (char *)&v297 - v27;
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  v328 = (char *)&v297 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  v312 = (char *)&v297 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  v313 = (char *)&v297 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  v326 = (char *)&v297 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  v325 = (char *)&v297 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v330 = (uint64_t)&v297 - v40;
  uint64_t v41 = *(void *)(a3 - 8);
  uint64_t v42 = MEMORY[0x1895F8858](v39);
  v44 = (char *)&v297 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = MEMORY[0x1895F8858](v42);
  v306 = (char *)&v297 - v46;
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  v305 = (char *)&v297 - v48;
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  v323 = (char *)&v297 - v50;
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  v304 = (char *)&v297 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  v310 = (char *)&v297 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  v317 = (char *)&v297 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  v307 = (char *)&v297 - v58;
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  v324 = (char *)&v297 - v60;
  MEMORY[0x1895F8858](v59);
  v336 = (char *)&v297 - v61;
  v62 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v63 = v62(a3, a4);
  v316 = v28;
  unint64_t v314 = AssociatedConformanceWitness;
  if ((v63 & 1) == 0)
  {
    v71 = v62;
    uint64_t v72 = a2;
    char v73 = v62(a3, a4);
    uint64_t v74 = v72;
    v322 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v75 = v322(a3, a4);
    if ((v73 & 1) != 0)
    {
      if (v75 <= 64)
      {
        v90 = v334;
        v91 = *(void (**)(void *, uint64_t))(swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral)
                                                     + 8);
        uint64_t v92 = v11;
        uint64_t v93 = v41;
        v94 = v333;
        unint64_t v303 = v92;
        v91(&unk_18180BE68, 256LL);
        v95 = v336;
        v96 = v94;
        uint64_t v41 = v93;
        (*((void (**)(char *, uint64_t, const char *))v90 + 3))(v96, a3, v90);
        char v97 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 32LL))( v72,  v95,  a3);
        v98 = v95;
        v70 = *(void (**)(char *, uint64_t))(v93 + 8);
        v70(v98, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v93 + 16))(v44, v74, a3);
        if ((v97 & 1) != 0)
        {
          uint64_t v99 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v70(v44, a3);
          unint64_t v11 = v303;
          uint64_t v69 = v74;
          v62 = v71;
          if (!v99) {
            goto LABEL_19;
          }
          goto LABEL_24;
        }

        v70(v44, a3);
        unint64_t v11 = v303;
        uint64_t v69 = v74;
      }

      else
      {
        unint64_t v337 = 0LL;
        v78 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v79 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
        v80 = v336;
        v78(&v337, &type metadata for Int, v79, a3, a4);
        v81 = v80;
        uint64_t v69 = v72;
        char v82 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v72,  v80,  a3);
        v70 = *(void (**)(char *, uint64_t))(v41 + 8);
        v70(v81, a3);
        if ((v82 & 1) != 0) {
          goto LABEL_19;
        }
      }
    }

    else if (v75 < 64)
    {
      v88 = v336;
      uint64_t v69 = v72;
      (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v336, v72, a3);
      uint64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v70 = *(void (**)(char *, uint64_t))(v41 + 8);
      v70(v88, a3);
      if (!v89) {
        goto LABEL_19;
      }
    }

    else
    {
      unint64_t v337 = 0LL;
      v100 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
      v102 = v336;
      v100(&v337, &type metadata for Int, v101, a3, a4);
      uint64_t v69 = v72;
      char v103 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v72,  v102,  a3);
      v104 = v102;
      v70 = *(void (**)(char *, uint64_t))(v41 + 8);
      v70(v104, a3);
      if ((v103 & 1) != 0) {
        goto LABEL_19;
      }
    }

    v62 = v71;
    goto LABEL_24;
  }

  v322 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v64 = v322(a3, a4);
  if (v64 < 64)
  {
    v67 = v336;
    (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v336, a2, a3);
    uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v69 = a2;
    v70 = *(void (**)(char *, uint64_t))(v41 + 8);
    v70(v67, a3);
    if (v68) {
      goto LABEL_24;
    }
LABEL_19:
    unint64_t *v335 = 0LL;
LABEL_20:
    char v105 = 1;
    return v105 & 1;
  }

  unint64_t v337 = 0LL;
  v83 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
  uint64_t v69 = a2;
  v85 = v336;
  v83(&v337, &type metadata for Int, v84, a3, a4);
  v86 = v85;
  char v87 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v69,  v85,  a3);
  v70 = *(void (**)(char *, uint64_t))(v41 + 8);
  v70(v86, a3);
  if ((v87 & 1) != 0) {
    goto LABEL_19;
  }
LABEL_24:
  uint64_t v107 = v330;
  (*(void (**)(uint64_t))(v329 + 56))(a3);
  uint64_t v108 = (uint64_t)v332;
  unint64_t v109 = swift_getAssociatedConformanceWitness( a4,  a3,  (uint64_t)v332,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  v110 = *(uint64_t (**)(uint64_t))(v109 + 136);
  unint64_t v302 = v109;
  uint64_t v111 = v110(v108);
  if (v111 > 1023)
  {
    (*(void (**)(uint64_t, uint64_t))(v331 + 8))(v107, v108);
    char v112 = v62(a3, a4);
    v113 = v324;
    (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v324, v69, a3);
    if ((v112 & 1) != 0)
    {
      if ((v62(a3, a4) & 1) != 0)
      {
        uint64_t v114 = v322(a3, a4);
        if (v114 >= 64)
        {
          unint64_t v337 = 0LL;
          v117 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v118 = lazy protocol witness table accessor for type Int and conformance Int(v114, v115, v116);
          v119 = v336;
          v117(&v337, &type metadata for Int, v118, a3, a4);
          char v120 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v113,  v119,  a3);
          v70(v119, a3);
          v121 = v113;
          goto LABEL_125;
        }

        goto LABEL_54;
      }

      uint64_t v185 = v41;
      char v186 = v62(a3, a4);
      uint64_t v187 = v322(a3, a4);
      if ((v186 & 1) != 0)
      {
        if (v187 <= 64)
        {
          v216 = (void (**)(char *, uint64_t, const char *))v334;
          unint64_t v217 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v218 = v333;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v217 + 8))( &unk_18180BE68,  256LL,  v11,  v217);
          v219 = v336;
          v216[3](v218, a3, (const char *)v216);
          v220 = v324;
          LOBYTE(v216) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                            + 16LL))( v324,  v219,  a3);
          v70(v219, a3);
          (*(void (**)(char *, char *, uint64_t))(v185 + 32))(v307, v220, a3);
          if ((v216 & 1) != 0)
          {
            v70(v307, a3);
LABEL_126:
            char v105 = 0;
            unint64_t v203 = 0xFFF0000000000000LL;
            goto LABEL_127;
          }

          v247 = v307;
          uint64_t v201 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v202 = v247;
          goto LABEL_55;
        }

        unint64_t v337 = 0LL;
        v190 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v191 = lazy protocol witness table accessor for type Int and conformance Int(v187, v188, v189);
        v192 = v336;
        v190(&v337, &type metadata for Int, v191, a3, a4);
        v193 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
        v194 = v324;
        char v120 = v193(v324, v192, a3);
        v195 = v192;
        uint64_t v196 = a3;
LABEL_124:
        v70(v195, v196);
        v121 = v194;
LABEL_125:
        v70(v121, a3);
        if ((v120 & 1) != 0) {
          goto LABEL_126;
        }
LABEL_58:
        char v105 = 0;
        unint64_t v203 = 0x7FF0000000000000LL;
LABEL_127:
        unint64_t *v335 = v203;
        return v105 & 1;
      }

      v113 = v324;
      if (v187 < 64)
      {
LABEL_54:
        uint64_t v201 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v202 = v113;
LABEL_55:
        v70(v202, a3);
        if (v201 < 0) {
          goto LABEL_126;
        }
        goto LABEL_58;
      }
    }

    v70(v113, a3);
    goto LABEL_58;
  }

  v307 = (char *)v62;
  uint64_t v299 = v69;
  unint64_t v303 = v11;
  uint64_t v300 = v41;
  unint64_t v301 = v111;
  if (v111 <= 52)
  {
    v152 = v321;
    uint64_t v153 = (uint64_t)v332;
    (*(void (**)(char *, uint64_t, unint64_t *))(v331 + 32))(v321, v330, v332);
    unint64_t v154 = v302;
    uint64_t v330 = *(void *)(v302 + 64);
    if ((((uint64_t (*)(uint64_t, unint64_t))v330)(v153, v302) & 1) != 0)
    {
      uint64_t v155 = v331;
      v156 = v311;
      (*(void (**)(char *, char *, uint64_t))(v331 + 16))(v311, v152, v153);
      v157 = v327;
      unint64_t v158 = v319;
      unint64_t v159 = swift_getAssociatedConformanceWitness( (uint64_t)v327,  v153,  v319,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v160 = v320;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v159 + 8))( &unk_18180BE68,  256LL,  v158,  v159);
      v161 = v326;
      (*((void (**)(char *, uint64_t, const char *))v157 + 3))(v160, v153, v157);
      unint64_t v162 = swift_getAssociatedConformanceWitness( v329,  a3,  v153,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v163 = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v162 + 32))(v156, v161, v153, v162);
      v164 = v161;
      LOBYTE(v161) = v163;
      v165 = *(void (**)(char *, uint64_t))(v155 + 8);
      v165(v164, v153);
      v165(v156, v153);
      v152 = v321;
      unint64_t v154 = v302;
    }

    v166 = v326;
    v167 = *(uint64_t (**)(uint64_t, unint64_t))(v154 + 128);
    if (v167(v153, v154) < 64)
    {
LABEL_84:
      uint64_t v226 = (*(uint64_t (**)(uint64_t, unint64_t))(v154 + 120))(v153, v154);
      v227 = v152;
      uint64_t v228 = v226;
      (*(void (**)(char *, uint64_t))(v331 + 8))(v227, v153);
      v229 = v307;
      char v230 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
      v231 = v317;
      (*(void (**)(char *, uint64_t, uint64_t))(v300 + 16))(v317, v299, a3);
      if ((v230 & 1) != 0)
      {
        if ((((uint64_t (*)(uint64_t, uint64_t))v229)(a3, a4) & 1) != 0)
        {
          uint64_t v232 = v322(a3, a4);
          if (v232 < 64)
          {
            v235 = v317;
            uint64_t v236 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
LABEL_88:
            uint64_t v237 = v236;
            v238 = v235;
            goto LABEL_95;
          }

          goto LABEL_91;
        }

        char v239 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
        uint64_t v232 = v322(a3, a4);
        if ((v239 & 1) != 0)
        {
          if (v232 <= 64)
          {
            v248 = v334;
            uint64_t v249 = v303;
            unint64_t v250 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v303,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v251 = v333;
            (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v250 + 8))( &unk_18180BE68,  256LL,  v249,  v250);
            v252 = v336;
            (*((void (**)(char *, uint64_t, const char *))v248 + 3))(v251, a3, v248);
            v253 = v317;
            LOBYTE(v249) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                              + 16LL))( v317,  v252,  a3);
            v70(v252, a3);
            (*(void (**)(char *, char *, uint64_t))(v300 + 32))(v306, v253, a3);
            if ((v249 & 1) == 0)
            {
              v235 = v306;
              uint64_t v236 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              goto LABEL_88;
            }

            v70(v306, a3);
LABEL_102:
            unint64_t v246 = 0x8000000000000000LL;
LABEL_103:
            if ((v301 & 0x8000000000000000LL) == 0)
            {
              goto LABEL_20;
            }

LABEL_138:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
          }

            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
          }

        v165 = 258LL;
LABEL_139:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v165,  0);
      }

    if ((v160 & ~v161 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v161 & 0xFFFFFFFFFFFFFFFLL))
    {
      v1 = v288._countAndFlagsBits;
      uint64_t v10 = (unint64_t)v288._object;
      uint64_t v171 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
      if ((v172 & 1) != 0) {
        goto LABEL_262;
      }
      if (v2 <= 15 && ((v10 & 0x2000000000000000LL) != 0 || v171 < v169))
      {
LABEL_157:
        swift_bridgeObjectRelease_n((uint64_t)v159._object, 5LL);
        v180 = v288._countAndFlagsBits;
        unint64_t v179 = (unint64_t)v288._object;
        if (((uint64_t)v288._object & 0x2000000000000000LL) == 0)
        {
          if (((uint64_t)v288._object & 0x1000000000000000LL) != 0)
          {
            v180 = _StringGuts._foreignConvertedToSmall()(v288._countAndFlagsBits, (unint64_t)v288._object);
            unint64_t v179 = v283;
          }

          else
          {
            if ((v288._countAndFlagsBits & 0x1000000000000000LL) != 0)
            {
              uint64_t v275 = (unsigned __int8 *)(((uint64_t)v288._object & 0xFFFFFFFFFFFFFFFLL) + 32);
              v276 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              uint64_t v275 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
              v276 = v176;
            }

            swift_bridgeObjectRetain(v179, v176, v177, v178);
            closure #1 in _StringGuts._convertedToSmall()(v275, v276, &v287);
            swift_bridgeObjectRelease(v179);
            unint64_t v179 = *((void *)&v287 + 1);
            v180 = v287;
          }
        }

        v181._rawBits = (v166 << 16) | 1;
        v182._rawBits = 1LL;
        v183._rawBits = _StringGuts.validateScalarRange(_:)( v182,  v181,  v159._countAndFlagsBits,  (unint64_t)v159._object);
        if (v183._rawBits < 0x10000) {
          v183._rawBits |= 3;
        }
        uint64_t v185 = specialized String.init(_:)(v183, v184, v159._countAndFlagsBits, (unint64_t)v159._object);
        uint64_t v187 = v186;
        swift_bridgeObjectRelease((uint64_t)v159._object);
        if ((v187 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v187);
        }

        else if ((v187 & 0x1000000000000000LL) != 0)
        {
          uint64_t v185 = _StringGuts._foreignConvertedToSmall()(v185, v187);
          v285 = v284;
          swift_bridgeObjectRelease(v187);
          uint64_t v187 = v285;
        }

        else
        {
          if ((v185 & 0x1000000000000000LL) != 0)
          {
            char v277 = (unsigned __int8 *)((v187 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v278 = v185 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            char v277 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v185, v187);
          }

          closure #1 in _StringGuts._convertedToSmall()(v277, v278, &v287);
          swift_bridgeObjectRelease(v187);
          uint64_t v187 = *((void *)&v287 + 1);
          uint64_t v185 = v287;
        }

        uint64_t v188 = HIBYTE(v179) & 0xF;
        uint64_t v189 = HIBYTE(v187) & 0xF;
        v190 = v189 + v188;
        if ((unint64_t)(v189 + v188) <= 0xF)
        {
          if (v189)
          {
            unint64_t v191 = 0;
            v192 = 0LL;
            do
            {
              v193 = v188 + v192;
              v194 = v192 + 1;
              if (v192 >= 8) {
                v195 = v187;
              }
              else {
                v195 = v185;
              }
              uint64_t v196 = v195 >> (v191 & 0x38);
              char v197 = (8 * v188 + v191) & 0x38;
              v198 = (-255LL << v197) - 1;
              char v199 = (unint64_t)v196 << v197;
              uint64_t v200 = v199 | v198 & v179;
              uint64_t v201 = v199 | v198 & v180;
              if (v193 < 8) {
                v180 = v201;
              }
              else {
                unint64_t v179 = v200;
              }
              v191 += 8;
              v192 = v194;
            }

            while (v189 != v194);
          }

          swift_bridgeObjectRelease((uint64_t)v159._object);
          v202 = 0xA000000000000000LL;
          if (!(v180 & 0x8080808080808080LL | v179 & 0x80808080808080LL)) {
            v202 = 0xE000000000000000LL;
          }
          unint64_t v203 = (uint64_t)v288._object;
          v288._countAndFlagsBits = v180;
          v288._object = (void *)(v202 & 0xFF00000000000000LL | (v190 << 56) | v179 & 0xFFFFFFFFFFFFFFLL);
          goto LABEL_188;
        }

LABEL_91:
          unint64_t v337 = 0LL;
          v240 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v241 = lazy protocol witness table accessor for type Int and conformance Int(v232, v233, v234);
          v242 = v336;
          v240(&v337, &type metadata for Int, v241, a3, a4);
          v243 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
          v244 = v317;
          char v245 = v243(v317, v242, a3);
          v70(v242, a3);
          v70(v244, a3);
          if ((v245 & 1) == 0) {
            goto LABEL_98;
          }
          goto LABEL_102;
        }

        v231 = v317;
        if (v232 < 64)
        {
          uint64_t v237 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v238 = v231;
LABEL_95:
          v70(v238, a3);
          if (v237 < 0) {
            goto LABEL_102;
          }
LABEL_98:
          unint64_t v246 = 0LL;
          goto LABEL_103;
        }
      }

      v70(v231, a3);
      goto LABEL_98;
    }

    v298 = v70;
    v168 = *(void (**)(char *, char *, uint64_t))(v331 + 16);
    v168(v318, v152, v153);
    unint64_t v337 = -1LL;
    char v169 = ((uint64_t (*)(uint64_t, unint64_t))v330)(v153, v154);
    uint64_t v170 = v167(v153, v154);
    if ((v169 & 1) != 0)
    {
      if (v170 <= 64)
      {
        v173 = (void (**)(char *, uint64_t, const char *))v327;
        uint64_t v174 = (uint64_t)v332;
        unint64_t v175 = v319;
        unint64_t v176 = swift_getAssociatedConformanceWitness( (uint64_t)v327,  (uint64_t)v332,  v319,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v177 = v320;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v176 + 8))( &unk_18180BE68,  256LL,  v175,  v176);
        v178 = v166;
        v173[3](v177, v174, (const char *)v173);
        unint64_t v179 = swift_getAssociatedConformanceWitness( v329,  a3,  v174,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        v180 = v318;
        LOBYTE(v173) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v179 + 40))( v318,  v178,  v174,  v179);
        v181 = *(void (**)(char *, uint64_t))(v331 + 8);
        v181(v178, v174);
        unint64_t v182 = v337;
        v168(v308, v180, v174);
        if ((v173 & 1) != 0)
        {
          v183 = v308;
          uint64_t v153 = (uint64_t)v332;
          unint64_t v184 = (*(uint64_t (**)(unint64_t *))(v302 + 120))(v332);
          v181(v183, v153);
          if (v182 < v184) {
            goto LABEL_75;
          }
        }

        else
        {
          uint64_t v153 = (uint64_t)v332;
          v181(v308, (uint64_t)v332);
        }

        goto LABEL_83;
      }
    }

    else if (v170 <= 64)
    {
      uint64_t v153 = (uint64_t)v332;
      v168(v166, v318, (uint64_t)v332);
      unint64_t v221 = (*(uint64_t (**)(uint64_t))(v302 + 120))(v153);
      v181 = *(void (**)(char *, uint64_t))(v331 + 8);
      v181(v166, v153);
      if (v337 < v221) {
        goto LABEL_75;
      }
LABEL_83:
      v181(v318, v153);
      v70 = v298;
      unint64_t v154 = v302;
      v152 = v321;
      goto LABEL_84;
    }

    unint64_t v204 = v302;
    v205 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v302 + 96);
    unint64_t v206 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v170, v171, v172);
    uint64_t v153 = (uint64_t)v332;
    v205(&v337, &type metadata for UInt64, v206, v332, v204);
    unint64_t v207 = swift_getAssociatedConformanceWitness( v329,  a3,  v153,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    LOBYTE(v205) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v207 + 16))( v166,  v318,  v153,  v207);
    v181 = *(void (**)(char *, uint64_t))(v331 + 8);
    v181(v166, v153);
    if ((v205 & 1) != 0) {
LABEL_75:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_83;
  }

  uint64_t v122 = v111;
  v123 = v327;
  uint64_t v124 = (uint64_t)v332;
  unint64_t v125 = v319;
  v308 = (char *)(v111 - 52);
  unint64_t v126 = swift_getAssociatedConformanceWitness( (uint64_t)v327,  (uint64_t)v332,  v319,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v318 = *(char **)(v126 + 8);
  v321 = (char *)v126;
  v127 = v320;
  ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v318)( &qword_18180BE70,  512LL,  v125,  v126);
  v128 = v123;
  v317 = (char *)*((void *)v123 + 3);
  v129 = v326;
  uint64_t v130 = ((uint64_t (*)(char *, uint64_t, const char *))v317)(v127, v124, v128);
  unint64_t v337 = v122 - 53;
  unint64_t v131 = v302;
  v132 = *(void (**)(char *, unint64_t *, ValueMetadata *, char *, uint64_t, unint64_t))(v302 + 256);
  v311 = (char *)lazy protocol witness table accessor for type Int and conformance Int(v130, v133, v134);
  v132(v129, &v337, &type metadata for Int, v311, v124, v131);
  v324 = *(char **)(v331 + 8);
  ((void (*)(char *, uint64_t))v324)(v129, v124);
  ((void (*)(void *, uint64_t, unint64_t, char *))v318)(&unk_18180BE80, 768LL, v125, v321);
  v135 = v312;
  ((void (*)(char *, uint64_t, char *))v317)(v127, v124, v327);
  unint64_t v136 = v314;
  (*(void (**)(char *, char *, uint64_t, unint64_t))(v314 + 64))(v135, v325, v124, v314);
  ((void (*)(char *, uint64_t))v324)(v135, v124);
  ((void (*)(uint64_t *, uint64_t, unint64_t, char *))v318)(&qword_18180BE70, 512LL, v125, v321);
  ((void (*)(char *, uint64_t, char *))v317)(v127, v124, v327);
  v137 = v313;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v136 + 8) + 40LL))(v129, v135, v124);
  v138 = v324;
  ((void (*)(char *, uint64_t))v324)(v135, v124);
  ((void (*)(char *, uint64_t))v138)(v129, v124);
  unint64_t v139 = v302;
  uint64_t v140 = v330;
  (*(void (**)(uint64_t, char *, uint64_t, unint64_t))(v302 + 192))(v330, v137, v124, v302);
  ((void (*)(char *, uint64_t))v138)(v137, v124);
  unint64_t v337 = (unint64_t)v308;
  uint64_t v141 = v124;
  (*(void (**)(uint64_t, unint64_t *, ValueMetadata *, char *, uint64_t, unint64_t))(v139 + 240))( v140,  &v337,  &type metadata for Int,  v311,  v124,  v139);
  ((void (*)(uint64_t, uint64_t))v138)(v140, v124);
  unint64_t v314 = *(void *)(v139 + 120);
  uint64_t v142 = ((uint64_t (*)(uint64_t, unint64_t))v314)(v124, v139);
  ((void (*)(char *, uint64_t))v138)(v129, v141);
  uint64_t v330 = v142 & 0xFFFFFFFFFFFFFLL;
  unint64_t v143 = swift_getAssociatedConformanceWitness( v329,  a3,  v141,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  v144 = *(uint64_t (**)(char *, char *, uint64_t))(v143 + 40);
  v145 = v328;
  v146 = v325;
  uint64_t v329 = v143;
  char v147 = v144(v328, v325, v141);
  uint64_t v148 = v331;
  v149 = v316;
  (*(void (**)(char *, char *, uint64_t))(v331 + 16))(v316, v145, v141);
  v150 = v315;
  uint64_t v331 = *(void *)(v148 + 32);
  ((void (*)(char *, char *, uint64_t))v331)(v315, v146, v141);
  v298 = v70;
  if ((v147 & 1) != 0)
  {
    v151 = v324;
    ((void (*)(char *, uint64_t))v324)(v150, v141);
    ((void (*)(char *, uint64_t))v151)(v149, v141);
  }

  else
  {
    char v197 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8LL))(v149, v150, v141);
    v198 = v324;
    ((void (*)(char *, uint64_t))v324)(v150, v141);
    ((void (*)(char *, uint64_t))v198)(v149, v141);
    if ((v197 & 1) == 0 || (v142 & 1) == 0) {
      goto LABEL_64;
    }
  }

  if (v330 == 0xFFFFFFFFFFFFFLL)
  {
    if (v301 >= 0x3FF)
    {
      ((void (*)(char *, unint64_t *))v324)(v328, v332);
      char v199 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
      (*(void (**)(char *, uint64_t, uint64_t))(v300 + 16))(v310, v299, a3);
      if ((v199 & 1) != 0)
      {
        if ((((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4) & 1) != 0)
        {
          if (v322(a3, a4) < 64) {
            goto LABEL_131;
          }
LABEL_123:
          unint64_t v337 = 0LL;
          v285 = v336;
          (*(void (**)(unint64_t *, ValueMetadata *, char *, uint64_t, uint64_t))(a4 + 96))( &v337,  &type metadata for Int,  v311,  a3,  a4);
          v286 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
          v194 = v310;
          char v120 = v286(v310, v285, a3);
          v195 = v285;
          uint64_t v196 = a3;
          v70 = v298;
          goto LABEL_124;
        }

        char v283 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
        uint64_t v284 = v322(a3, a4);
        if ((v283 & 1) != 0)
        {
          if (v284 <= 64)
          {
            v291 = (void (**)(char *, uint64_t, const char *))v334;
            uint64_t v292 = v303;
            unint64_t v293 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v303,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v294 = v333;
            (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v293 + 8))( &unk_18180BE68,  256LL,  v292,  v293);
            v295 = v336;
            v291[3](v294, a3, (const char *)v291);
            v296 = v310;
            LOBYTE(v291) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                              + 16LL))( v310,  v295,  a3);
            v298(v295, a3);
            (*(void (**)(char *, char *, uint64_t))(v300 + 32))(v304, v296, a3);
            if ((v291 & 1) != 0)
            {
              v298(v304, a3);
              goto LABEL_126;
            }

            v287 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 120);
            v288 = &v336;
            goto LABEL_132;
          }

          goto LABEL_123;
        }

        if (v284 < 64)
        {
LABEL_131:
          v287 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 120);
          v288 = (char **)&v338;
LABEL_132:
          v289 = *(v288 - 32);
          uint64_t v290 = v287(a3, a4);
          v298(v289, a3);
          if (v290 < 0) {
            goto LABEL_126;
          }
          goto LABEL_58;
        }
      }

      v298(v310, a3);
      goto LABEL_58;
    }

    ++v301;
    uint64_t v200 = 0x10000000000000LL;
  }

  else
  {
    uint64_t v200 = v330 + 1;
  }

  uint64_t v330 = v200;
LABEL_64:
  v208 = v307;
  char v209 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v300 + 16))(v323, v299, a3);
  if ((v209 & 1) == 0) {
    goto LABEL_80;
  }
  if ((((uint64_t (*)(uint64_t, uint64_t))v208)(a3, a4) & 1) != 0)
  {
    if (v322(a3, a4) < 64) {
      goto LABEL_77;
    }
    goto LABEL_70;
  }

  char v210 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
  uint64_t v211 = v322(a3, a4);
  if ((v210 & 1) == 0)
  {
    if (v211 < 64)
    {
LABEL_77:
      v222 = v323;
      uint64_t v223 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      goto LABEL_78;
    }

          unint64_t v337 = 0LL;
          v240 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v241 = lazy protocol witness table accessor for type Int and conformance Int(v232, v233, v234);
          v242 = v336;
          v240(&v337, &type metadata for Int, v241, a3, a4);
          v243 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
          v244 = v317;
          char v245 = v243(v317, v242, a3);
          v70(v242, a3);
          v70(v244, a3);
          if ((v245 & 1) == 0) {
            goto LABEL_98;
          }
          goto LABEL_102;
        }

        v231 = v317;
        if (v232 < 64)
        {
          uint64_t v237 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v238 = v231;
LABEL_95:
          v70(v238, a3);
          if (v237 < 0) {
            goto LABEL_102;
          }
LABEL_98:
          unint64_t v246 = 0;
          goto LABEL_103;
        }
      }

      v70(v231, a3);
      goto LABEL_98;
    }

    v298 = v70;
    v168 = *(void (**)(char *, char *, uint64_t))(v331 + 16);
    v168(v318, v152, v153);
    LODWORD(v337) = -1;
    char v169 = ((uint64_t (*)(uint64_t, unint64_t))v330)(v153, v154);
    uint64_t v170 = v167(v153, v154);
    if ((v169 & 1) != 0)
    {
      if (v170 <= 32)
      {
        v173 = (void (**)(char *, uint64_t, const char *))v327;
        uint64_t v174 = (uint64_t)v332;
        unint64_t v175 = v319;
        unint64_t v176 = swift_getAssociatedConformanceWitness( (uint64_t)v327,  (uint64_t)v332,  v319,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v177 = v320;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v176 + 8))( &qword_18180BE68,  256LL,  v175,  v176);
        v178 = v166;
        v173[3](v177, v174, (const char *)v173);
        unint64_t v179 = swift_getAssociatedConformanceWitness( v329,  a3,  v174,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        v180 = v318;
        LOBYTE(v173) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v179 + 40))( v318,  v178,  v174,  v179);
        v181 = *(void (**)(char *, uint64_t))(v331 + 8);
        v181(v178, v174);
        unint64_t v182 = v337;
        v168(v308, v180, v174);
        if ((v173 & 1) != 0)
        {
          v183 = v308;
          uint64_t v153 = (uint64_t)v332;
          unint64_t v184 = (*(uint64_t (**)(unint64_t *))(v302 + 120))(v332);
          v181(v183, v153);
          if (v182 < v184) {
            goto LABEL_75;
          }
        }

        else
        {
          uint64_t v153 = (uint64_t)v332;
          v181(v308, (uint64_t)v332);
        }

        goto LABEL_83;
      }
    }

    else if (v170 <= 32)
    {
      uint64_t v153 = (uint64_t)v332;
      v168(v166, v318, (uint64_t)v332);
      unint64_t v221 = (*(uint64_t (**)(uint64_t))(v302 + 120))(v153);
      v181 = *(void (**)(char *, uint64_t))(v331 + 8);
      v181(v166, v153);
LABEL_83:
      v181(v318, v153);
      v70 = v298;
      unint64_t v154 = v302;
      v152 = v321;
      goto LABEL_84;
    }

    unint64_t v204 = v302;
    v205 = *(void (**)(char **, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v302 + 96);
    unint64_t v206 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v170, v171, v172);
    uint64_t v153 = (uint64_t)v332;
    v205(&v337, &type metadata for UInt32, v206, v332, v204);
    unint64_t v207 = swift_getAssociatedConformanceWitness( v329,  a3,  v153,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    LOBYTE(v205) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v207 + 16))( v166,  v318,  v153,  v207);
    v181 = *(void (**)(char *, uint64_t))(v331 + 8);
    v181(v166, v153);
    if ((v205 & 1) != 0) {
LABEL_75:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_83;
  }

  uint64_t v122 = v111;
  v123 = v327;
  uint64_t v124 = (uint64_t)v332;
  unint64_t v125 = v319;
  v308 = (char *)(v111 - 23);
  unint64_t v126 = swift_getAssociatedConformanceWitness( (uint64_t)v327,  (uint64_t)v332,  v319,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v318 = *(char **)(v126 + 8);
  v321 = (char *)v126;
  v127 = v320;
  ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v318)( &qword_18180BE70,  512LL,  v125,  v126);
  v128 = v123;
  v317 = (char *)*((void *)v123 + 3);
  v129 = v326;
  uint64_t v130 = ((uint64_t (*)(char *, uint64_t, const char *))v317)(v127, v124, v128);
  unint64_t v337 = (char *)(v122 - 24);
  unint64_t v131 = v302;
  v132 = *(void (**)(char *, char **, ValueMetadata *, char *, uint64_t, unint64_t))(v302 + 256);
  v311 = (char *)lazy protocol witness table accessor for type Int and conformance Int(v130, v133, v134);
  v132(v129, &v337, &type metadata for Int, v311, v124, v131);
  v324 = *(char **)(v331 + 8);
  ((void (*)(char *, uint64_t))v324)(v129, v124);
  ((void (*)(void *, uint64_t, unint64_t, char *))v318)(&unk_18180BE80, 768LL, v125, v321);
  v135 = v312;
  ((void (*)(char *, uint64_t, char *))v317)(v127, v124, v327);
  unint64_t v136 = v314;
  (*(void (**)(char *, char *, uint64_t, unint64_t))(v314 + 64))(v135, v325, v124, v314);
  ((void (*)(char *, uint64_t))v324)(v135, v124);
  ((void (*)(uint64_t *, uint64_t, unint64_t, char *))v318)(&qword_18180BE70, 512LL, v125, v321);
  ((void (*)(char *, uint64_t, char *))v317)(v127, v124, v327);
  v137 = v313;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v136 + 8) + 40LL))(v129, v135, v124);
  v138 = v324;
  ((void (*)(char *, uint64_t))v324)(v135, v124);
  ((void (*)(char *, uint64_t))v138)(v129, v124);
  unint64_t v139 = v302;
  uint64_t v140 = v330;
  (*(void (**)(char *, char *, uint64_t, unint64_t))(v302 + 192))(v330, v137, v124, v302);
  ((void (*)(char *, uint64_t))v138)(v137, v124);
  unint64_t v337 = v308;
  uint64_t v141 = v124;
  (*(void (**)(char *, char **, ValueMetadata *, char *, uint64_t, unint64_t))(v139 + 240))( v140,  &v337,  &type metadata for Int,  v311,  v124,  v139);
  ((void (*)(char *, uint64_t))v138)(v140, v124);
  unint64_t v314 = *(void *)(v139 + 120);
  uint64_t v142 = ((uint64_t (*)(uint64_t, unint64_t))v314)(v124, v139);
  ((void (*)(char *, uint64_t))v138)(v129, v141);
  LODWORD(v330) = v142 & 0x7FFFFF;
  unint64_t v143 = swift_getAssociatedConformanceWitness( v329,  a3,  v141,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  v144 = *(uint64_t (**)(char *, char *, uint64_t))(v143 + 40);
  v145 = v328;
  v146 = v325;
  uint64_t v329 = v143;
  char v147 = v144(v328, v325, v141);
  uint64_t v148 = v331;
  v149 = v316;
  (*(void (**)(char *, char *, uint64_t))(v331 + 16))(v316, v145, v141);
  v150 = v315;
  uint64_t v331 = *(void *)(v148 + 32);
  ((void (*)(char *, char *, uint64_t))v331)(v315, v146, v141);
  v298 = v70;
  if ((v147 & 1) != 0)
  {
    v151 = v324;
    ((void (*)(char *, uint64_t))v324)(v150, v141);
    ((void (*)(char *, uint64_t))v151)(v149, v141);
  }

  else
  {
    char v197 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8LL))(v149, v150, v141);
    v198 = v324;
    ((void (*)(char *, uint64_t))v324)(v150, v141);
    ((void (*)(char *, uint64_t))v198)(v149, v141);
    if ((v197 & 1) == 0 || (v142 & 1) == 0) {
      goto LABEL_64;
    }
  }

  if ((_DWORD)v330 == 0x7FFFFF)
  {
    if (v301 >= 0x7F)
    {
      ((void (*)(char *, unint64_t *))v324)(v328, v332);
      char v199 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
      (*(void (**)(char *, uint64_t, uint64_t))(v300 + 16))(v310, v299, a3);
      if ((v199 & 1) != 0)
      {
        if ((((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4) & 1) != 0)
        {
          if (v322(a3, a4) < 64) {
            goto LABEL_131;
          }
LABEL_123:
          unint64_t v337 = 0LL;
          v285 = v336;
          (*(void (**)(char **, ValueMetadata *, char *, uint64_t, uint64_t))(a4 + 96))( &v337,  &type metadata for Int,  v311,  a3,  a4);
          v286 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
          v194 = v310;
          char v120 = v286(v310, v285, a3);
          v195 = v285;
          uint64_t v196 = a3;
          v70 = v298;
          goto LABEL_124;
        }

        char v283 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
        uint64_t v284 = v322(a3, a4);
        if ((v283 & 1) != 0)
        {
          if (v284 <= 64)
          {
            v291 = (void (**)(char *, uint64_t, const char *))v334;
            uint64_t v292 = v303;
            unint64_t v293 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v303,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v294 = v333;
            (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v293 + 8))( &qword_18180BE68,  256LL,  v292,  v293);
            v295 = v336;
            v291[3](v294, a3, (const char *)v291);
            v296 = v310;
            LOBYTE(v291) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                              + 16LL))( v310,  v295,  a3);
            v298(v295, a3);
            (*(void (**)(char *, char *, uint64_t))(v300 + 32))(v304, v296, a3);
            if ((v291 & 1) != 0)
            {
              v298(v304, a3);
              goto LABEL_126;
            }

            v287 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 120);
            v288 = &v336;
            goto LABEL_132;
          }

          goto LABEL_123;
        }

        if (v284 < 64)
        {
LABEL_131:
          v287 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 120);
          v288 = (char **)&v338;
LABEL_132:
          v289 = *(v288 - 32);
          uint64_t v290 = v287(a3, a4);
          v298(v289, a3);
          if (v290 < 0) {
            goto LABEL_126;
          }
          goto LABEL_58;
        }
      }

      v298(v310, a3);
      goto LABEL_58;
    }

    ++v301;
    uint64_t v200 = 0x800000;
  }

  else
  {
    uint64_t v200 = (_DWORD)v330 + 1;
  }

  LODWORD(v330) = v200;
LABEL_64:
  v208 = v307;
  char v209 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v300 + 16))(v323, v299, a3);
  if ((v209 & 1) == 0) {
    goto LABEL_80;
  }
  if ((((uint64_t (*)(uint64_t, uint64_t))v208)(a3, a4) & 1) != 0)
  {
    if (v322(a3, a4) < 64) {
      goto LABEL_77;
    }
    goto LABEL_70;
  }

  char v210 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
  uint64_t v211 = v322(a3, a4);
  if ((v210 & 1) == 0)
  {
    if (v211 < 64)
    {
LABEL_77:
      v222 = v323;
      uint64_t v223 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      goto LABEL_78;
    }

                swift_release(v23);
                goto LABEL_92;
              }

              unint64_t v79 = v84;
            }
          }
        }

    (*(void (**)(char *, uint64_t, uint64_t, swift *))(v8 + 56))(v30, 1LL, 1LL, a2);
    swift_release((uint64_t)v40);
    unint64_t v109 = v37;
    goto LABEL_94;
  }

  if (v36)
  {
    if (v37 < 0) {
      uint64_t v47 = v37;
    }
    else {
      uint64_t v47 = v37 & 0xFFFFFFFFFFFFFF8LL;
    }
    uint64_t v48 = type metadata accessor for __CocoaSet.Iterator();
    uint64_t v49 = (unint64_t)swift_allocObject(v48, 0xE8uLL, 7uLL);
    v119 = 0LL;
    uint64_t v50 = 0LL;
    uint64_t v51 = 0LL;
    *(void *)(v49 + 208) = v47;
    *(void *)(v49 + 216) = 0LL;
    uint64_t v52 = v37;
    *(_OWORD *)(v49 + 16) = 0u;
    *(_OWORD *)(v49 + 32) = 0u;
    *(_OWORD *)(v49 + 48) = 0u;
    *(_OWORD *)(v49 + 64) = 0u;
    *(_OWORD *)(v49 + 80) = 0u;
    *(_OWORD *)(v49 + 96) = 0u;
    *(_OWORD *)(v49 + 112) = 0u;
    *(_OWORD *)(v49 + 128) = 0u;
    *(_OWORD *)(v49 + 144) = 0u;
    *(_OWORD *)(v49 + 160) = 0u;
    *(_OWORD *)(v49 + 176) = 0u;
    *(_OWORD *)(v49 + 192) = 0u;
    *(void *)(v49 + 224) = 0LL;
    uint64_t v53 = v49 | 0x8000000000000000LL;
  }

  else
  {
    uint64_t v52 = v37;
    v80 = -1LL << *(_BYTE *)(v37 + 32);
    uint64_t v50 = ~v80;
    v81 = *(void *)(v37 + 56);
    v119 = v37 + 56;
    char v82 = -v80;
    if (v82 < 64) {
      v83 = ~(-1LL << v82);
    }
    else {
      v83 = -1LL;
    }
    uint64_t v51 = v83 & v81;
    uint64_t v53 = v37;
  }

  unint64_t v84 = v53 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v116 = (v53 & 0x7FFFFFFFFFFFFFFFLL) + 80;
  v117 = (v53 & 0x7FFFFFFFFFFFFFFFLL) + 16;
  uint64_t v115 = (uint64_t *)v50;
  unint64_t v118 = (unint64_t)(v50 + 64) >> 6;
  swift_bridgeObjectRetain(v52, v31, v32, v33);
  uint64_t v122 = 0LL;
  char v120 = (swift *)&unk_189B8D230;
  v123 = v53;
  if ((v53 & 0x8000000000000000LL) != 0) {
    goto LABEL_62;
  }
  while (1)
  {
    if (v51)
    {
      v88 = __clz(__rbit64(v51));
      v51 &= v51 - 1;
      uint64_t v89 = v88 | (v122 << 6);
      goto LABEL_83;
    }

    v96 = v122 + 1;
    if (__OFADD__(v122, 1LL)) {
      goto LABEL_100;
    }
    if (v96 >= v118) {
      goto LABEL_93;
    }
    char v97 = *(void *)(v119 + 8 * v96);
    v98 = v122 + 1;
    if (!v97)
    {
      v98 = v122 + 2;
      if (v122 + 2 >= v118) {
        goto LABEL_93;
      }
      char v97 = *(void *)(v119 + 8 * v98);
      if (!v97) {
        break;
      }
    }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
    }

    v76[0] = a1;
    v76[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (!v6) {
      goto LABEL_91;
    }
    if (a1 == 43)
    {
      swift_bridgeObjectRetain(a2, a2, a3, a4);
      uint64_t v25 = 1;
      uint64_t v56 = specialized Collection.subscript.getter(1LL, (uint64_t)v76, v6);
      uint64_t v60 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v56, v57, v58, v59);
      if (!v61) {
        goto LABEL_85;
      }
      if (v60)
      {
        v62 = 0LL;
        while (1)
        {
          char v63 = *v60 - 48;
          if (v63 > 9) {
            goto LABEL_77;
          }
          uint64_t v64 = (unsigned __int128)(v62 * (__int128)10LL) >> 64;
          uint64_t v65 = 10 * v62;
          uint64_t v66 = v64 != v65 >> 63;
          uint64_t v23 = __OFADD__(v65, v63);
          v62 = v65 + v63;
          v67 = v23;
          uint64_t v25 = 1;
          if (!v66 && (v67 & 1) == 0)
          {
            uint64_t v25 = 0;
            ++v60;
            if (--v61) {
              continue;
            }
          }

          goto LABEL_85;
        }
      }
    }

    else
    {
      if (a1 != 45)
      {
        uint64_t v68 = 0LL;
        uint64_t v69 = (unsigned __int8 *)v76;
        while (1)
        {
          v70 = *v69 - 48;
          if (v70 > 9) {
            break;
          }
          v71 = (unsigned __int128)(v68 * (__int128)10LL) >> 64;
          uint64_t v72 = 10 * v68;
          char v73 = v71 != v72 >> 63;
          uint64_t v23 = __OFADD__(v72, v70);
          uint64_t v68 = v72 + v70;
          uint64_t v74 = v23;
          uint64_t v25 = 1;
          if (v73 || (v74 & 1) != 0) {
            goto LABEL_84;
          }
          ++v69;
          if (!--v6)
          {
            uint64_t v25 = 0;
            goto LABEL_84;
          }
        }

        uint64_t v25 = 1;
LABEL_84:
        swift_bridgeObjectRetain(a2, a2, a3, a4);
        goto LABEL_85;
      }

      swift_bridgeObjectRetain(a2, a2, a3, a4);
      uint64_t v25 = 1;
      uint64_t v26 = specialized Collection.subscript.getter(1LL, (uint64_t)v76, v6);
      uint64_t v30 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
      if (!v31)
      {
LABEL_85:
        uint64_t v77 = v25;
        goto LABEL_86;
      }

      if (v30)
      {
        uint64_t v32 = 0LL;
        while (1)
        {
          uint64_t v33 = *v30 - 48;
          if (v33 > 9) {
            break;
          }
          uint64_t v34 = (unsigned __int128)(v32 * (__int128)10LL) >> 64;
          uint64_t v35 = 10 * v32;
          uint64_t v36 = v34 != v35 >> 63;
          uint64_t v23 = __OFSUB__(v35, v33);
          uint64_t v32 = v35 - v33;
          uint64_t v37 = v23;
          uint64_t v25 = 1;
          if (!v36 && (v37 & 1) == 0)
          {
            uint64_t v25 = 0;
            ++v30;
            if (--v31) {
              continue;
            }
          }

          goto LABEL_85;
        }

          uint64_t v7 = 0LL;
          *__dst = 0;
          return v7;
        }

        if ((v5 & 0x80000000) == 0)
        {
          if (a3 < 4) {
            goto LABEL_91;
          }
          v44 = 6712937;
          goto LABEL_52;
        }

        if (a3 < 5) {
          goto LABEL_91;
        }
        __dst[4] = 0;
        uint64_t v46 = 1718511917;
        goto LABEL_60;
      }

      int64_t v9 = (v5 >> 23) - 126;
      unint64_t v8 = (v6 << 8) | 0x80000000;
    }

    else
    {
      if (!v6)
      {
        if ((v5 & 0x80000000) == 0)
        {
          if (a3 < 4) {
            goto LABEL_91;
          }
          v44 = 3157552;
LABEL_52:
          *(_DWORD *)__dst = v44;
          return 3LL;
        }

        if (a3 < 5) {
          goto LABEL_91;
        }
        __dst[4] = 0;
        uint64_t v46 = 808333357;
LABEL_60:
        *(_DWORD *)__dst = v46;
        return 4LL;
      }

      unint64_t v8 = v6 << 8;
      int64_t v9 = -125;
    }

    uint64_t v10 = v8 + 128;
    if (v6) {
      unint64_t v11 = -128;
    }
    else {
      unint64_t v11 = -64;
    }
    uint64_t v12 = v8 + v11;
    unint64_t v13 = (unint64_t)(20201781LL * v9) >> 26;
    if ((int)v13 <= 0)
    {
      uint64_t v14 = powersOf10_Exact128[(-2 * ((unint64_t)(20201781LL * v9) >> 26)) | 1];
      else {
        uint64_t v15 = v14 + 1;
      }
    }

    else
    {
      uint64_t v14 = powersOf10_negativeBinary32[(40 - v13)];
      uint64_t v15 = v14 + 1;
    }

    uint64_t v16 = 7 - v9 - ((-55732705 * ((unint64_t)(20201781LL * v9) >> 26)) >> 24);
    uint64_t v17 = ~(-1 << v16);
    uint64_t v18 = v15;
    uint64_t v19 = v15 * (unint64_t)v10 + 0xFFFFFFFF;
    uint64_t v20 = HIDWORD(v15);
    uint64_t v21 = (v20 * (unint64_t)v10 + v17 + HIDWORD(v19)) >> v16;
    uint64_t v22 = (((v14 * (unint64_t)v12) >> 32) + HIDWORD(v14) * (unint64_t)v12) >> v16;
    uint64_t v23 = (((v14 * (unint64_t)v10) >> 32) + HIDWORD(v14) * (unint64_t)v10) >> v16;
    uint64_t v24 = (v17 + v20 * (unint64_t)v12 + ((v18 * (unint64_t)v12 + 0xFFFFFFFF) >> 32)) >> v16;
    if ((v5 & 1) != 0) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = v22;
    }
    if ((v5 & 1) != 0) {
      uint64_t v26 = v23;
    }
    else {
      uint64_t v26 = v21;
    }
    uint64_t v27 = v26 - v25;
    if (HIBYTE(v26))
    {
      v28 = v26;
    }

    else
    {
      do
      {
        LODWORD(v13) = v13 - 1;
        v28 = 10 * v26;
        v27 *= 10LL;
        uint64_t v29 = v26 >= 0x1999999999999ALL;
        v26 *= 10LL;
      }

      while (!v29);
    }

    uint64_t v30 = &__dst[a3];
    uint64_t v31 = &__dst[a3 - 3];
    if (v31 < __dst) {
      goto LABEL_91;
    }
    uint64_t v32 = __dst;
    if ((v5 & 0x80000000) != 0)
    {
      *__dst = 45;
      uint64_t v32 = __dst + 1;
    }

    *(_WORD *)uint64_t v32 = *(_WORD *)&asciiDigitTable[(v28 >> 55) & 0x1FE];
    uint64_t v33 = (unint64_t)(v32 + 2);
    uint64_t v34 = v28 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v35 = 10 * v27;
    uint64_t v36 = 10 * v34;
    uint64_t v37 = (10 * v34) & 0xFFFFFFFFFFFFFELL;
    if (10 * v27 < v37)
    {
      while (v33 <= (unint64_t)v31)
      {
        uint64_t v38 = 100 * v27;
        *(_WORD *)uint64_t v33 = *(_WORD *)&asciiDigitTable[((100 * v34) >> 55) & 0xFE];
        v33 += 2LL;
        uint64_t v34 = (100 * v34) & 0xFFFFFFFFFFFFFCLL;
        uint64_t v35 = 1000 * v27;
        uint64_t v36 = 10 * v34;
        uint64_t v37 = (10 * v34) & 0xFFFFFFFFFFFFF8LL;
        v27 *= 100LL;
        if (v35 >= v37)
        {
          uint64_t v39 = (char *)(v33 - 2);
          uint64_t v27 = v38;
          if (v38 < v34) {
            goto LABEL_39;
          }
          goto LABEL_37;
        }
      }

      goto LABEL_91;
    }

    uint64_t v39 = v32;
    if (v27 >= v34)
    {
LABEL_37:
      uint64_t v35 = v27;
      uint64_t v37 = v34;
    }

    else
    {
LABEL_39:
      *(_BYTE *)uint64_t v33 = HIBYTE(v36) | 0x30;
      uint64_t v33 = (unint64_t)(v39 + 3);
    }

    if (v35 > (v37 | 0x100000000000000LL))
    {
      uint64_t v40 = v35 >> 1;
      uint64_t v41 = v35 - v35 / 3;
      if (!v6) {
        uint64_t v40 = v41;
      }
      uint64_t v42 = v40 - v37;
      if (((v42 + 0x800000) & 0xFFFFFFFF000000LL) == 0x80000000000000LL) {
        uint64_t v43 = (*(_BYTE *)(v33 - 1) - HIBYTE(v42)) & 0xFE;
      }
      else {
        uint64_t v43 = *(_BYTE *)(v33 - 1) - ((v42 + 0x80000000000000LL) >> 56);
      }
      *(_BYTE *)(v33 - 1) = v43;
    }

    uint64_t v47 = v9 == 25;
    if (!v6) {
      uint64_t v47 = 0;
    }
    uint64_t v48 = v33 - (void)v32 - 1;
    if (v9 > 25 || v47 || (int)v13 <= -5)
    {
      char *v32 = v32[1];
      else {
        v32[1] = 46;
      }
      *(_BYTE *)uint64_t v33 = 101;
      if ((v13 & 0x80000000) == 0LL) {
        uint64_t v51 = 43;
      }
      else {
        uint64_t v51 = 45;
      }
      if ((v13 & 0x80000000) == 0LL) {
        uint64_t v52 = v13;
      }
      else {
        uint64_t v52 = -(int)v13;
      }
      *(_BYTE *)(v33 + 1) = v51;
      uint64_t v53 = v33 + 2;
      if (v52 < 0x64)
      {
        uint64_t v54 = (__int16 *)(v33 + 2);
      }

      else
      {
        if (v52 < 0x3E8)
        {
          *(_BYTE *)(v33 + 2) = (unsigned __int16)v52 / 0x64u + 48;
          uint64_t v54 = (__int16 *)(v33 + 3);
        }

        else
        {
          *(_WORD *)(v33 + 2) = *(_WORD *)&asciiDigitTable[(v52 / 0x32uLL) & 0x7FFFFFE];
          uint64_t v54 = (__int16 *)(v33 + 4);
        }

        v52 %= 0x64u;
      }

      uint64_t v55 = *(_WORD *)&asciiDigitTable[2 * v52];
    }

    else
    {
      if ((v13 & 0x80000000) != 0)
      {
        memmove(&v32[-(int)v13], v32, v33 - (void)v32);
        memset(v32, 48, -(int)v13);
        v32[1] = 46;
        v33 += -(int)v13;
LABEL_97:
        *(_BYTE *)uint64_t v33 = 0;
        return (int)v33 - (int)__dst;
      }

      uint64_t v49 = v13 + 1LL;
      uint64_t v50 = v49 - v48;
      if ((int)v49 < (int)v48)
      {
        memmove(v32, v32 + 1, v13 + 1LL);
        v32[v49] = 46;
        goto LABEL_97;
      }

      memmove(v32, v32 + 1, v48);
      memset((void *)(v33 - 1), 48, v50);
      uint64_t v54 = (__int16 *)(v33 - 1 + v50);
      uint64_t v55 = 12334;
    }

    *uint64_t v54 = v55;
    uint64_t v33 = (unint64_t)(v54 + 1);
    goto LABEL_97;
  }

  return 0LL;
}

  uint64_t v41 = 0LL;
LABEL_92:
  this = (uint64_t *)swift::Demangle::__runtime::CharVector::append(v316, v26, v41, *(void **)(v5 + 12744));
  v71 = *((unsigned __int8 *)v4 + 18);
  uint64_t v72 = (swift::Demangle::__runtime::Node **)v4;
  if ((v71 - 1) >= 2)
  {
    if (v71 == 5)
    {
      char v73 = *(swift::Demangle::__runtime::Node ***)v4;
      uint64_t v72 = *(swift::Demangle::__runtime::Node ***)v4;
LABEL_100:
      uint64_t v74 = &v73[*((unsigned int *)v4 + 2)];
      goto LABEL_104;
    }

    uint64_t v72 = 0LL;
  }

  switch(v71)
  {
    case 1:
      uint64_t v74 = (swift::Demangle::__runtime::Node **)((char *)v4 + 8);
      break;
    case 2:
      uint64_t v74 = (swift::Demangle::__runtime::Node **)((char *)v4 + 16);
      break;
    case 5:
      char v73 = *(swift::Demangle::__runtime::Node ***)v4;
      goto LABEL_100;
    default:
      uint64_t v74 = 0LL;
      break;
  }

LABEL_80:
    v298(v323, a3);
    goto LABEL_81;
  }

  if (v211 > 64)
  {
LABEL_70:
    unint64_t v337 = 0LL;
    v212 = v336;
    (*(void (**)(unint64_t *, ValueMetadata *, char *, uint64_t, uint64_t))(a4 + 96))( &v337,  &type metadata for Int,  v311,  a3,  a4);
    v213 = v323;
    char v214 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v323,  v212,  a3);
    v215 = v298;
    v298(v212, a3);
    v215(v213, a3);
    if ((v214 & 1) == 0) {
      goto LABEL_81;
    }
LABEL_107:
    unint64_t v225 = 0x8000000000000000LL;
    goto LABEL_108;
  }

  v254 = v334;
  uint64_t v255 = v303;
  unint64_t v256 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v303,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v257 = v333;
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v256 + 8))(&unk_18180BE68, 256LL, v255, v256);
  v258 = v336;
  (*((void (**)(char *, uint64_t, const char *))v254 + 3))(v257, a3, v254);
  v259 = v323;
  LOBYTE(v255) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v323,  v258,  a3);
  v298(v258, a3);
  (*(void (**)(char *, char *, uint64_t))(v300 + 32))(v305, v259, a3);
  if ((v255 & 1) != 0)
  {
    v298(v305, a3);
    goto LABEL_107;
  }

  v222 = v305;
  uint64_t v223 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
LABEL_78:
  uint64_t v224 = v223;
  v298(v222, a3);
  if (v224 < 0) {
    goto LABEL_107;
  }
LABEL_81:
  unint64_t v225 = 0LL;
LABEL_108:
  unint64_t *v335 = ((v330 & 0xFFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)v301 << 52)) + 0x3FF0000000000000LL) | v225;
  unint64_t v260 = v302;
  v261 = *(uint64_t (**)(unint64_t *, unint64_t))(v302 + 64);
  uint64_t v262 = (uint64_t)v332;
  if ((v261(v332, v302) & 1) != 0)
  {
    goto LABEL_113;
  }

  char v263 = v261((unint64_t *)v262, v260);
  uint64_t v264 = (*(uint64_t (**)(uint64_t, unint64_t))(v260 + 128))(v262, v260);
  if ((v263 & 1) != 0)
  {
    if (v264 > 64)
    {
LABEL_113:
      unint64_t v337 = 0LL;
      v265 = v326;
      uint64_t v266 = (uint64_t)v332;
      (*(void (**)(unint64_t *, ValueMetadata *, char *, unint64_t *))(v302 + 96))( &v337,  &type metadata for Int,  v311,  v332);
      v267 = v328;
      char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8LL))(v328, v265, v266);
      v268 = v265;
      v269 = v324;
      ((void (*)(char *, uint64_t))v324)(v268, v266);
      ((void (*)(char *, uint64_t))v269)(v267, v266);
      return v105 & 1;
    }

    v273 = v320;
    ((void (*)(void *, uint64_t))v318)(&unk_18180BE68, 256LL);
    v274 = v326;
    uint64_t v275 = (uint64_t)v332;
    ((void (*)(char *, unint64_t *, char *))v317)(v273, v332, v327);
    v276 = v328;
    char v277 = (*(uint64_t (**)(char *, char *, uint64_t))(v329 + 32))(v328, v274, v275);
    ((void (*)(char *, uint64_t))v324)(v274, v275);
    ((void (*)(char *, char *, uint64_t))v331)(v309, v276, v275);
    char v105 = (v277 & 1) != 0 && ((uint64_t (*)(unint64_t *, unint64_t))v314)(v332, v302) == 0;
    ((void (*)(char *, unint64_t *))v324)(v309, v332);
  }

  else
  {
    if (v264 < 64)
    {
LABEL_116:
      v270 = v326;
      uint64_t v271 = (uint64_t)v332;
      ((void (*)(char *, char *, unint64_t *))v331)(v326, v328, v332);
      uint64_t v272 = ((uint64_t (*)(uint64_t, unint64_t))v314)(v271, v302);
      ((void (*)(char *, uint64_t))v324)(v270, v271);
      char v105 = v272 == 0;
      return v105 & 1;
    }

    unint64_t v337 = 0LL;
    v278 = v326;
    uint64_t v279 = (uint64_t)v332;
    (*(void (**)(unint64_t *, ValueMetadata *, char *, unint64_t *))(v302 + 96))( &v337,  &type metadata for Int,  v311,  v332);
    v280 = v328;
    char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8LL))(v328, v278, v279);
    v281 = v280;
    v282 = v324;
    ((void (*)(char *, uint64_t))v324)(v281, v279);
    ((void (*)(char *, uint64_t))v282)(v278, v279);
  }

  return v105 & 1;
}

    v298(v323, a3);
    goto LABEL_81;
  }

  if (v211 > 64)
  {
LABEL_70:
    unint64_t v337 = 0LL;
    v212 = v336;
    (*(void (**)(char **, ValueMetadata *, char *, uint64_t, uint64_t))(a4 + 96))( &v337,  &type metadata for Int,  v311,  a3,  a4);
    v213 = v323;
    char v214 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v323,  v212,  a3);
    v215 = v298;
    v298(v212, a3);
    v215(v213, a3);
    if ((v214 & 1) == 0) {
      goto LABEL_81;
    }
LABEL_107:
    unint64_t v225 = 0x80000000;
    goto LABEL_108;
  }

  v254 = v334;
  uint64_t v255 = v303;
  unint64_t v256 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v303,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v257 = v333;
  (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v256 + 8))( &qword_18180BE68,  256LL,  v255,  v256);
  v258 = v336;
  (*((void (**)(char *, uint64_t, const char *))v254 + 3))(v257, a3, v254);
  v259 = v323;
  LOBYTE(v255) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v323,  v258,  a3);
  v298(v258, a3);
  (*(void (**)(char *, char *, uint64_t))(v300 + 32))(v305, v259, a3);
  if ((v255 & 1) != 0)
  {
    v298(v305, a3);
    goto LABEL_107;
  }

  v222 = v305;
  uint64_t v223 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
LABEL_78:
  uint64_t v224 = v223;
  v298(v222, a3);
  if (v224 < 0) {
    goto LABEL_107;
  }
LABEL_81:
  unint64_t v225 = 0;
LABEL_108:
  unint64_t *v335 = ((v330 & 0x7FFFFF | ((unsigned __int16)v301 << 23)) + 1065353216) | v225;
  unint64_t v260 = v302;
  v261 = *(uint64_t (**)(unint64_t *, unint64_t))(v302 + 64);
  uint64_t v262 = (uint64_t)v332;
  if ((v261(v332, v302) & 1) != 0)
  {
    goto LABEL_113;
  }

  char v263 = v261((unint64_t *)v262, v260);
  uint64_t v264 = (*(uint64_t (**)(uint64_t, unint64_t))(v260 + 128))(v262, v260);
  if ((v263 & 1) != 0)
  {
    if (v264 > 64)
    {
LABEL_113:
      unint64_t v337 = 0LL;
      v265 = v326;
      uint64_t v266 = (uint64_t)v332;
      (*(void (**)(char **, ValueMetadata *, char *, unint64_t *))(v302 + 96))( &v337,  &type metadata for Int,  v311,  v332);
      v267 = v328;
      char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8LL))(v328, v265, v266);
      v268 = v265;
      v269 = v324;
      ((void (*)(char *, uint64_t))v324)(v268, v266);
      ((void (*)(char *, uint64_t))v269)(v267, v266);
      return v105 & 1;
    }

    v273 = v320;
    ((void (*)(uint64_t *, uint64_t))v318)(&qword_18180BE68, 256LL);
    v274 = v326;
    uint64_t v275 = (uint64_t)v332;
    ((void (*)(char *, unint64_t *, char *))v317)(v273, v332, v327);
    v276 = v328;
    char v277 = (*(uint64_t (**)(char *, char *, uint64_t))(v329 + 32))(v328, v274, v275);
    ((void (*)(char *, uint64_t))v324)(v274, v275);
    ((void (*)(char *, char *, uint64_t))v331)(v309, v276, v275);
    char v105 = (v277 & 1) != 0 && ((uint64_t (*)(unint64_t *, unint64_t))v314)(v332, v302) == 0;
    ((void (*)(char *, unint64_t *))v324)(v309, v332);
  }

  else
  {
    if (v264 < 64)
    {
LABEL_116:
      v270 = v326;
      uint64_t v271 = (uint64_t)v332;
      ((void (*)(char *, char *, unint64_t *))v331)(v326, v328, v332);
      uint64_t v272 = ((uint64_t (*)(uint64_t, unint64_t))v314)(v271, v302);
      ((void (*)(char *, uint64_t))v324)(v270, v271);
      char v105 = v272 == 0;
      return v105 & 1;
    }

    unint64_t v337 = 0LL;
    v278 = v326;
    uint64_t v279 = (uint64_t)v332;
    (*(void (**)(char **, ValueMetadata *, char *, unint64_t *))(v302 + 96))( &v337,  &type metadata for Int,  v311,  v332);
    v280 = v328;
    char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v329 + 8) + 8LL))(v328, v278, v279);
    v281 = v280;
    v282 = v324;
    ((void (*)(char *, uint64_t))v324)(v281, v279);
    ((void (*)(char *, uint64_t))v282)(v278, v279);
  }

  return v105 & 1;
}

    uint64_t v50 = 10 * (v42 & 0xFFFFFFF) + 0x8000000;
    if ((v50 & 0xFFFFFFE) != 0) {
      uint64_t v51 = v50 >> 28;
    }
    else {
      uint64_t v51 = (v50 >> 28) & 0xE;
    }
    if (v44) {
      uint64_t v52 = v51 > v46;
    }
    else {
      uint64_t v52 = 1;
    }
    if (!v52) {
      LOBYTE(v51) = v51 + 1;
    }
    *uint64_t v41 = (v51 + 48);
    return (char *)v41 + 1 - a2;
  }

uint64_t specialized static BinaryFloatingPoint<>._convert<A>(from:)( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v335 = a1;
  uint64_t v7 = *(void *)(a4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  v327 = *(char **)(AssociatedConformanceWitness + 16);
  unint64_t v319 = swift_getAssociatedTypeWitness( 0LL,  v327,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v319);
  v320 = (char *)&v297 - v10;
  uint64_t v329 = v7;
  v334 = *(char **)(v7 + 16);
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  v334,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v11);
  v333 = (char *)&v297 - v12;
  unint64_t v13 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v331 = *(v13 - 1);
  v332 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  v309 = (char *)&v297 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  v308 = (char *)&v297 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v318 = (char *)&v297 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v311 = (char *)&v297 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v321 = (char *)&v297 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v315 = (char *)&v297 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v28 = (char *)&v297 - v27;
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  v328 = (char *)&v297 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  v312 = (char *)&v297 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  v313 = (char *)&v297 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  v326 = (char *)&v297 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  v325 = (char *)&v297 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v330 = (char *)&v297 - v40;
  uint64_t v41 = *(void *)(a3 - 8);
  uint64_t v42 = MEMORY[0x1895F8858](v39);
  v44 = (char *)&v297 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = MEMORY[0x1895F8858](v42);
  v306 = (char *)&v297 - v46;
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  v305 = (char *)&v297 - v48;
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  v323 = (char *)&v297 - v50;
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  v304 = (char *)&v297 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  v310 = (char *)&v297 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  v317 = (char *)&v297 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  v307 = (char *)&v297 - v58;
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  v324 = (char *)&v297 - v60;
  MEMORY[0x1895F8858](v59);
  v336 = (char *)&v297 - v61;
  v62 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v63 = v62(a3, a4);
  v316 = v28;
  unint64_t v314 = AssociatedConformanceWitness;
  if ((v63 & 1) == 0)
  {
    v71 = v62;
    uint64_t v72 = a2;
    char v73 = v62(a3, a4);
    uint64_t v74 = v72;
    v322 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v75 = v322(a3, a4);
    if ((v73 & 1) != 0)
    {
      if (v75 <= 64)
      {
        v90 = v334;
        v91 = *(void (**)(uint64_t *, uint64_t))(swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral)
                                                        + 8);
        uint64_t v92 = v11;
        uint64_t v93 = v41;
        v94 = v333;
        unint64_t v303 = v92;
        v91(&qword_18180BE68, 256LL);
        v95 = v336;
        v96 = v94;
        uint64_t v41 = v93;
        (*((void (**)(char *, uint64_t, const char *))v90 + 3))(v96, a3, v90);
        char v97 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 32LL))( v72,  v95,  a3);
        v98 = v95;
        v70 = *(void (**)(char *, uint64_t))(v93 + 8);
        v70(v98, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v93 + 16))(v44, v74, a3);
        if ((v97 & 1) != 0)
        {
          uint64_t v99 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v70(v44, a3);
          unint64_t v11 = v303;
          uint64_t v69 = v74;
          v62 = v71;
          if (!v99) {
            goto LABEL_19;
          }
          goto LABEL_24;
        }

        v70(v44, a3);
        unint64_t v11 = v303;
        uint64_t v69 = v74;
      }

      else
      {
        unint64_t v337 = 0LL;
        v78 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v79 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
        v80 = v336;
        v78(&v337, &type metadata for Int, v79, a3, a4);
        v81 = v80;
        uint64_t v69 = v72;
        char v82 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v72,  v80,  a3);
        v70 = *(void (**)(char *, uint64_t))(v41 + 8);
        v70(v81, a3);
        if ((v82 & 1) != 0) {
          goto LABEL_19;
        }
      }
    }

    else if (v75 < 64)
    {
      v88 = v336;
      uint64_t v69 = v72;
      (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v336, v72, a3);
      uint64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v70 = *(void (**)(char *, uint64_t))(v41 + 8);
      v70(v88, a3);
      if (!v89) {
        goto LABEL_19;
      }
    }

    else
    {
      unint64_t v337 = 0LL;
      v100 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
      v102 = v336;
      v100(&v337, &type metadata for Int, v101, a3, a4);
      uint64_t v69 = v72;
      char v103 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v72,  v102,  a3);
      v104 = v102;
      v70 = *(void (**)(char *, uint64_t))(v41 + 8);
      v70(v104, a3);
      if ((v103 & 1) != 0) {
        goto LABEL_19;
      }
    }

    v62 = v71;
    goto LABEL_24;
  }

  v322 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v64 = v322(a3, a4);
  if (v64 < 64)
  {
    v67 = v336;
    (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v336, a2, a3);
    uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v69 = a2;
    v70 = *(void (**)(char *, uint64_t))(v41 + 8);
    v70(v67, a3);
    if (v68) {
      goto LABEL_24;
    }
LABEL_19:
    _DWORD *v335 = 0;
LABEL_20:
    char v105 = 1;
    return v105 & 1;
  }

  unint64_t v337 = 0LL;
  v83 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
  uint64_t v69 = a2;
  v85 = v336;
  v83(&v337, &type metadata for Int, v84, a3, a4);
  v86 = v85;
  char v87 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v69,  v85,  a3);
  v70 = *(void (**)(char *, uint64_t))(v41 + 8);
  v70(v86, a3);
  if ((v87 & 1) != 0) {
    goto LABEL_19;
  }
LABEL_24:
  uint64_t v107 = v330;
  (*(void (**)(uint64_t))(v329 + 56))(a3);
  uint64_t v108 = (uint64_t)v332;
  unint64_t v109 = swift_getAssociatedConformanceWitness( a4,  a3,  (uint64_t)v332,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  v110 = *(uint64_t (**)(uint64_t))(v109 + 136);
  unint64_t v302 = v109;
  uint64_t v111 = v110(v108);
  if (v111 > 127)
  {
    (*(void (**)(char *, uint64_t))(v331 + 8))(v107, v108);
    char v112 = v62(a3, a4);
    v113 = v324;
    (*(void (**)(char *, uint64_t, uint64_t))(v41 + 16))(v324, v69, a3);
    if ((v112 & 1) != 0)
    {
      if ((v62(a3, a4) & 1) != 0)
      {
        uint64_t v114 = v322(a3, a4);
        if (v114 >= 64)
        {
          unint64_t v337 = 0LL;
          v117 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v118 = lazy protocol witness table accessor for type Int and conformance Int(v114, v115, v116);
          v119 = v336;
          v117(&v337, &type metadata for Int, v118, a3, a4);
          char v120 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v113,  v119,  a3);
          v70(v119, a3);
          v121 = v113;
          goto LABEL_125;
        }

        goto LABEL_54;
      }

      uint64_t v185 = v41;
      char v186 = v62(a3, a4);
      uint64_t v187 = v322(a3, a4);
      if ((v186 & 1) != 0)
      {
        if (v187 <= 64)
        {
          v216 = (void (**)(char *, uint64_t, const char *))v334;
          unint64_t v217 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v11,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v218 = v333;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v217 + 8))( &qword_18180BE68,  256LL,  v11,  v217);
          v219 = v336;
          v216[3](v218, a3, (const char *)v216);
          v220 = v324;
          LOBYTE(v216) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                            + 16LL))( v324,  v219,  a3);
          v70(v219, a3);
          (*(void (**)(char *, char *, uint64_t))(v185 + 32))(v307, v220, a3);
          if ((v216 & 1) != 0)
          {
            v70(v307, a3);
LABEL_126:
            char v105 = 0;
            int v203 = -8388608;
            goto LABEL_127;
          }

          v247 = v307;
          uint64_t v201 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v202 = v247;
          goto LABEL_55;
        }

        unint64_t v337 = 0LL;
        v190 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v191 = lazy protocol witness table accessor for type Int and conformance Int(v187, v188, v189);
        v192 = v336;
        v190(&v337, &type metadata for Int, v191, a3, a4);
        v193 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
        v194 = v324;
        char v120 = v193(v324, v192, a3);
        v195 = v192;
        uint64_t v196 = a3;
LABEL_124:
        v70(v195, v196);
        v121 = v194;
LABEL_125:
        v70(v121, a3);
        if ((v120 & 1) != 0) {
          goto LABEL_126;
        }
LABEL_58:
        char v105 = 0;
        int v203 = 2139095040;
LABEL_127:
        _DWORD *v335 = v203;
        return v105 & 1;
      }

      v113 = v324;
      if (v187 < 64)
      {
LABEL_54:
        uint64_t v201 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v202 = v113;
LABEL_55:
        v70(v202, a3);
        if (v201 < 0) {
          goto LABEL_126;
        }
        goto LABEL_58;
      }
    }

    v70(v113, a3);
    goto LABEL_58;
  }

  v307 = (char *)v62;
  uint64_t v299 = v69;
  unint64_t v303 = v11;
  uint64_t v300 = v41;
  unint64_t v301 = v111;
  if (v111 <= 23)
  {
    v152 = v321;
    uint64_t v153 = (uint64_t)v332;
    (*(void (**)(char *, char *, unint64_t *))(v331 + 32))(v321, v330, v332);
    unint64_t v154 = v302;
    uint64_t v330 = *(char **)(v302 + 64);
    if ((((uint64_t (*)(uint64_t, unint64_t))v330)(v153, v302) & 1) != 0)
    {
      uint64_t v155 = v331;
      v156 = v311;
      (*(void (**)(char *, char *, uint64_t))(v331 + 16))(v311, v152, v153);
      v157 = v327;
      unint64_t v158 = v319;
      unint64_t v159 = swift_getAssociatedConformanceWitness( (uint64_t)v327,  v153,  v319,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v160 = v320;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v159 + 8))( &qword_18180BE68,  256LL,  v158,  v159);
      v161 = v326;
      (*((void (**)(char *, uint64_t, const char *))v157 + 3))(v160, v153, v157);
      unint64_t v162 = swift_getAssociatedConformanceWitness( v329,  a3,  v153,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v163 = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v162 + 32))(v156, v161, v153, v162);
      v164 = v161;
      LOBYTE(v161) = v163;
      v165 = *(void (**)(char *, uint64_t))(v155 + 8);
      v165(v164, v153);
      v165(v156, v153);
      v152 = v321;
      unint64_t v154 = v302;
    }

    v166 = v326;
    v167 = *(uint64_t (**)(uint64_t, unint64_t))(v154 + 128);
    if (v167(v153, v154) < 32)
    {
LABEL_84:
      int v226 = (*(uint64_t (**)(uint64_t, unint64_t))(v154 + 120))(v153, v154);
      v227 = v152;
      int v228 = v226;
      (*(void (**)(char *, uint64_t))(v331 + 8))(v227, v153);
      v229 = v307;
      char v230 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
      v231 = v317;
      (*(void (**)(char *, uint64_t, uint64_t))(v300 + 16))(v317, v299, a3);
      if ((v230 & 1) != 0)
      {
        if ((((uint64_t (*)(uint64_t, uint64_t))v229)(a3, a4) & 1) != 0)
        {
          uint64_t v232 = v322(a3, a4);
          if (v232 < 64)
          {
            v235 = v317;
            uint64_t v236 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
LABEL_88:
            uint64_t v237 = v236;
            v238 = v235;
            goto LABEL_95;
          }

          goto LABEL_91;
        }

        char v239 = ((uint64_t (*)(uint64_t, uint64_t))v307)(a3, a4);
        uint64_t v232 = v322(a3, a4);
        if ((v239 & 1) != 0)
        {
          if (v232 <= 64)
          {
            v248 = v334;
            uint64_t v249 = v303;
            unint64_t v250 = swift_getAssociatedConformanceWitness( (uint64_t)v334,  a3,  v303,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v251 = v333;
            (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v250 + 8))( &qword_18180BE68,  256LL,  v249,  v250);
            v252 = v336;
            (*((void (**)(char *, uint64_t, const char *))v248 + 3))(v251, a3, v248);
            v253 = v317;
            LOBYTE(v249) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                              + 16LL))( v317,  v252,  a3);
            v70(v252, a3);
            (*(void (**)(char *, char *, uint64_t))(v300 + 32))(v306, v253, a3);
            if ((v249 & 1) == 0)
            {
              v235 = v306;
              uint64_t v236 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              goto LABEL_88;
            }

            v70(v306, a3);
LABEL_102:
            unsigned int v246 = 0x80000000;
LABEL_103:
            if ((v301 & 0x8000000000000000LL) == 0)
            {
              _DWORD *v335 = (((_DWORD)v301 << 23) + 1065353216) & 0x7F800000 | (v228 << (23 - v301)) & 0x7FFFFF | v246;
              goto LABEL_20;
            }

uint64_t specialized static BinaryFloatingPoint<>._convert<A>(from:)( __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v337 = a1;
  uint64_t v7 = *(void *)(a4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v329 = *(char **)(AssociatedConformanceWitness + 16);
  unint64_t v326 = swift_getAssociatedTypeWitness( 0LL,  v329,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v326);
  v327 = (char *)&v300 - v9;
  v336 = *(char **)(v7 + 16);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  v336,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v10);
  v335 = (char *)&v300 - v11;
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v333 = (void (*)(void, void, void))*(v12 - 1);
  v334 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  v312 = (char *)&v300 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  v311 = (char *)&v300 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  v321 = (char *)&v300 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v314 = (char *)&v300 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  v322 = (char *)&v300 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  v318 = (char *)&v300 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (char *)&v300 - v26;
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v330 = (char *)&v300 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v315 = (char *)&v300 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v316 = (char *)&v300 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v332 = (char *)&v300 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v328 = (char *)&v300 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v339 = (char *)&v300 - v39;
  uint64_t v40 = *(void *)(a3 - 8);
  uint64_t v41 = MEMORY[0x1895F8858](v38);
  uint64_t v43 = (char *)&v300 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v44 = MEMORY[0x1895F8858](v41);
  v309 = (char *)&v300 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  v308 = (char *)&v300 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  v324 = (char *)&v300 - v49;
  uint64_t v50 = MEMORY[0x1895F8858](v48);
  v307 = (char *)&v300 - v51;
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  v313 = (char *)&v300 - v53;
  uint64_t v54 = MEMORY[0x1895F8858](v52);
  v320 = (char *)&v300 - v55;
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  v310 = (char *)&v300 - v57;
  uint64_t v58 = MEMORY[0x1895F8858](v56);
  v325 = (char *)&v300 - v59;
  MEMORY[0x1895F8858](v58);
  uint64_t v338 = (char *)&v300 - v60;
  uint64_t v61 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v62 = v61(a3, a4);
  uint64_t v331 = v61;
  unint64_t v319 = v27;
  if ((v62 & 1) != 0)
  {
    v323 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v63 = v323(a3, a4);
    uint64_t v66 = a2;
    if (v63 < 64)
    {
      v67 = v338;
      (*(void (**)(char *, uint64_t, uint64_t))(v40 + 16))(v338, a2, a3);
      uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v69 = *(void (**)(char *, uint64_t))(v40 + 8);
      v69(v67, a3);
      v70 = v339;
      if (v68) {
        goto LABEL_21;
      }
LABEL_17:
      *unint64_t v337 = 0;
LABEL_18:
      char v96 = 1;
      return v96 & 1;
    }

uint64_t static BinaryFloatingPoint<>._convert<A>(from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v561 = a7;
  uint64_t v566 = a6;
  v563 = (const char *)a5;
  uint64_t v569 = a2;
  uint64_t v555 = a1;
  uint64_t v11 = *(void *)(a6 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v11,  a4,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  v525 = *(const char **)(AssociatedConformanceWitness + 16);
  unint64_t v512 = swift_getAssociatedTypeWitness( 0LL,  v525,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v512);
  v511 = (char *)&v485 - v13;
  uint64_t v14 = *(void *)(a5 + 16);
  unint64_t v15 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v14,  a3,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  uint64_t v536 = *(void *)(swift_getAssociatedConformanceWitness( v14,  a3,  v15,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  v500 = *(char **)(*(void *)(v536 + 24) + 16LL);
  unint64_t v499 = swift_getAssociatedTypeWitness( 0LL,  v500,  v15,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v499);
  v498 = (char *)&v485 - v16;
  v533 = swift_checkMetadataState(0LL, v15);
  uint64_t v529 = *(v533 - 1);
  uint64_t v17 = MEMORY[0x1895F8858](v533);
  v488 = (char *)&v485 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  v489 = (char *)&v485 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  v513 = (char *)&v485 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  v496 = (char *)&v485 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  v497 = (char *)&v485 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  v521 = (char *)&v485 - v28;
  MEMORY[0x1895F8858](v27);
  v528 = (char *)&v485 - v29;
  v535 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v531 = *(v535 - 1);
  uint64_t v30 = MEMORY[0x1895F8858](v535);
  v491 = (char *)&v485 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v508 = (char *)&v485 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v509 = (char *)&v485 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v522 = (char *)&v485 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v506 = (char *)&v485 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v507 = (char *)&v485 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v524 = (char *)&v485 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  v523 = (char *)&v485 - v45;
  MEMORY[0x1895F8858](v44);
  v539 = (char *)&v485 - v46;
  uint64_t v532 = v11;
  v544 = *(char **)(v11 + 16);
  uint64_t v568 = a4;
  unint64_t v542 = swift_getAssociatedTypeWitness( 0LL,  v544,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v47 = MEMORY[0x1895F8858](v542);
  v543 = (char *)&v485 - v48;
  uint64_t v565 = *(void *)(a4 - 8);
  uint64_t v49 = MEMORY[0x1895F8858](v47);
  v492 = (char *)&v485 - ((v50 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v51 = MEMORY[0x1895F8858](v49);
  v520 = (char *)&v485 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  v487 = (char *)&v485 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  v517 = (char *)&v485 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  v485 = (char *)&v485 - v58;
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  v501 = (char *)&v485 - v60;
  uint64_t v61 = MEMORY[0x1895F8858](v59);
  v490 = (char *)&v485 - v62;
  uint64_t v63 = MEMORY[0x1895F8858](v61);
  v514 = (char *)&v485 - v64;
  uint64_t v65 = MEMORY[0x1895F8858](v63);
  v541 = (char *)&v485 - v66;
  MEMORY[0x1895F8858](v65);
  v558 = (char *)&v485 - v67;
  uint64_t v562 = *(void *)(a7 + 8);
  v571 = *(const char **)(*(void *)(v562 + 24) + 16LL);
  uint64_t v68 = v571;
  uint64_t v69 = v563;
  unint64_t v70 = swift_getAssociatedTypeWitness( 255LL,  v563,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  unint64_t v570 = swift_getAssociatedTypeWitness( 0LL,  v68,  v70,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v570);
  v557 = (char *)&v485 - v71;
  uint64_t v72 = swift_checkMetadataState(0LL, v70);
  uint64_t v559 = *(v72 - 1);
  uint64_t v73 = MEMORY[0x1895F8858](v72);
  v502 = (char *)&v485 - ((v74 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v75 = MEMORY[0x1895F8858](v73);
  v486 = (char *)&v485 - v76;
  uint64_t v77 = MEMORY[0x1895F8858](v75);
  v503 = (char *)&v485 - v78;
  uint64_t v79 = MEMORY[0x1895F8858](v77);
  v526 = (char *)&v485 - v80;
  uint64_t v81 = MEMORY[0x1895F8858](v79);
  v519 = (uint64_t (*)(void))((char *)&v485 - v82);
  uint64_t v83 = MEMORY[0x1895F8858](v81);
  v560 = (char *)&v485 - v84;
  uint64_t v85 = MEMORY[0x1895F8858](v83);
  v564 = (char *)&v485 - v86;
  uint64_t v87 = MEMORY[0x1895F8858](v85);
  v572 = (char *)&v485 - v88;
  uint64_t v556 = *(void *)(a3 - 8);
  uint64_t v89 = MEMORY[0x1895F8858](v87);
  v493 = (char *)&v485 - ((v90 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v91 = MEMORY[0x1895F8858](v89);
  v527 = (char *)&v485 - v92;
  MEMORY[0x1895F8858](v91);
  char v94 = (char *)&v485 - v93;
  uint64_t v538 = v14;
  uint64_t v494 = *(void *)(v14 + 16);
  uint64_t v95 = *(void *)(*(void *)(v494 + 8) + 16LL);
  unint64_t v96 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v95,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v96);
  uint64_t v98 = (char *)&v485 - v97;
  unint64_t v99 = swift_getAssociatedTypeWitness( 0LL,  v69,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawExponent);
  uint64_t v553 = *(void *)(v99 - 8);
  unint64_t v554 = v99;
  uint64_t v100 = MEMORY[0x1895F8858](v99);
  v515 = (char *)&v485 - ((v101 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v102 = MEMORY[0x1895F8858](v100);
  v516 = (char *)&v485 - v103;
  MEMORY[0x1895F8858](v102);
  char v105 = (char *)&v485 - v104;
  unint64_t v106 = swift_getAssociatedConformanceWitness( v95,  a3,  v96,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v107 = *(void (**)(void *, uint64_t))(v106 + 8);
  v550 = (void (*)(char *, uint64_t))v96;
  v548 = (uint64_t (*)(unint64_t *, uint64_t))v106;
  v547 = v107;
  ((void (*)(uint64_t *, uint64_t, unint64_t))v107)(&qword_18180BE70, 512LL, v96);
  uint64_t v108 = *(void (**)(uint64_t, uint64_t, unint64_t *))(v95 + 24);
  uint64_t v549 = (uint64_t)v98;
  v551 = (unint64_t *)v95;
  v546 = v108;
  v108((uint64_t)v98, a3, (unint64_t *)v95);
  uint64_t v109 = (void (*)(uint64_t, const char *))*((void *)v69 + 14);
  v552 = v105;
  v110 = v69;
  v109(a3, v69);
  unint64_t v111 = *(void (**)(char *, uint64_t))(v556 + 8);
  v495 = v94;
  char v112 = v94;
  char v113 = v72;
  v534 = v111;
  v111(v112, a3);
  unint64_t v114 = v570;
  uint64_t v115 = (uint64_t)v571;
  unint64_t v116 = swift_getAssociatedConformanceWitness( (uint64_t)v571,  (uint64_t)v72,  v570,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v556 = *(void *)(v116 + 8);
  uint64_t v117 = v557;
  ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v556)( &qword_18180BE70,  512LL,  v114,  v116);
  uint64_t v118 = v115;
  unint64_t v119 = *(void (**)(char *, unint64_t *, uint64_t))(v115 + 24);
  char v120 = v560;
  v121 = v117;
  v119(v117, v113, v118);
  uint64_t v122 = (uint64_t (*)(uint64_t, const char *))*((void *)v110 + 13);
  v567 = (void *)a3;
  v518 = v122;
  uint64_t v573 = v122(a3, v110);
  uint64_t v123 = *(void (**)(char *, uint64_t *, ValueMetadata *))(v562 + 256);
  unint64_t v126 = lazy protocol witness table accessor for type Int and conformance Int(v573, v124, v125);
  uint64_t v127 = v564;
  v128 = v120;
  unint64_t v545 = v126;
  v123(v120, &v573, &type metadata for Int);
  uint64_t v129 = v566;
  uint64_t v130 = *(void (**)(char *, unint64_t *))(v559 + 8);
  v130(v128, v113);
  unint64_t v131 = v121;
  uint64_t v132 = v568;
  unint64_t v505 = v116;
  ((void (*)(uint64_t *, uint64_t))v556)(&qword_18180BE70, 512LL);
  uint64_t v133 = v131;
  uint64_t v134 = v132;
  v504 = (void (*)(char *, unint64_t *, const char *))v119;
  v119(v133, v113, (uint64_t)v571);
  (*(void (**)(char *, char *, unint64_t *))(v561 + 88))(v572, v128, v113);
  v130(v128, v113);
  v130(v127, v113);
  v135 = *(uint64_t (**)(uint64_t, uint64_t))(v129 + 64);
  char v136 = v135(v132, v129);
  v530 = v135;
  if ((v136 & 1) == 0)
  {
    v540 = v130;
    char v144 = v135(v132, v129);
    uint64_t v145 = v129;
    v537 = *(uint64_t (**)(uint64_t, uint64_t))(v129 + 128);
    uint64_t v146 = v537(v132, v129);
    if ((v144 & 1) != 0)
    {
      uint64_t v143 = (uint64_t)v567;
      char v147 = v558;
      uint64_t v148 = v565;
      if (v146 > 64)
      {
        uint64_t v573 = 0LL;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v129 + 96))( &v573,  &type metadata for Int,  v545,  v132,  v129);
        char v149 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v129 + 16) + 8LL) + 8LL))( v569,  v147,  v132);
        unint64_t v142 = *(void (**)(char *, uint64_t))(v148 + 8);
        v150 = v147;
        goto LABEL_17;
      }

      unint64_t v159 = (void (**)(char *, uint64_t, const char *))v544;
      unint64_t v160 = v542;
      unint64_t v161 = swift_getAssociatedConformanceWitness( (uint64_t)v544,  v132,  v542,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v162 = v543;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v161 + 8))( &unk_18180BE68,  256LL,  v160,  v161);
      v159[3](v162, v132, (const char *)v159);
      uint64_t v129 = v145;
      uint64_t v163 = v569;
      LOBYTE(v159) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v145 + 32) + 8LL)
                                                                         + 32LL))( v569,  v147,  v134);
      uint64_t v164 = v148;
      unint64_t v142 = *(void (**)(char *, uint64_t))(v148 + 8);
      v142(v147, v134);
      v165 = *(void (**)(char *, uint64_t, uint64_t))(v164 + 16);
      v166 = v541;
      v165(v541, v163, v134);
      if ((v159 & 1) == 0)
      {
        v142(v166, v134);
        uint64_t v130 = v540;
        unint64_t v137 = v537;
        goto LABEL_22;
      }

      uint64_t v157 = (*(uint64_t (**)(uint64_t, uint64_t))(v145 + 120))(v134, v145);
      v142(v166, v134);
    }

    else
    {
      uint64_t v143 = (uint64_t)v567;
      uint64_t v155 = v558;
      uint64_t v156 = v565;
      if (v146 >= 64)
      {
        uint64_t v573 = 0LL;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v129 + 96))( &v573,  &type metadata for Int,  v545,  v132,  v129);
        char v149 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v129 + 16) + 8LL) + 8LL))( v569,  v155,  v132);
        unint64_t v142 = *(void (**)(char *, uint64_t))(v156 + 8);
        v150 = v155;
LABEL_17:
        uint64_t v134 = v132;
        v142(v150, v132);
        uint64_t v130 = v540;
        unint64_t v137 = v537;
        if ((v149 & 1) == 0) {
          goto LABEL_22;
        }
        goto LABEL_18;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v565 + 16))(v558, v569, v132);
      uint64_t v157 = (*(uint64_t (**)(uint64_t, uint64_t))(v129 + 120))(v132, v129);
      unint64_t v142 = *(void (**)(char *, uint64_t))(v156 + 8);
      unint64_t v158 = v155;
      uint64_t v134 = v132;
      v142(v158, v132);
    }

    uint64_t v130 = v540;
    unint64_t v137 = v537;
    if (!v157) {
      goto LABEL_18;
    }
    goto LABEL_22;
  }

  unint64_t v137 = *(uint64_t (**)(uint64_t, uint64_t))(v129 + 128);
  uint64_t v138 = v569;
  if (v137(v134, v129) < 64)
  {
    uint64_t v139 = v565;
    uint64_t v140 = v558;
    (*(void (**)(char *, uint64_t, uint64_t))(v565 + 16))(v558, v138, v134);
    uint64_t v141 = (*(uint64_t (**)(uint64_t, uint64_t))(v129 + 120))(v134, v129);
    unint64_t v142 = *(void (**)(char *, uint64_t))(v139 + 8);
    v142(v140, v134);
    uint64_t v143 = (uint64_t)v567;
    if (v141) {
      goto LABEL_22;
    }
LABEL_18:
    v130(v572, v113);
    (*(void (**)(char *, unint64_t))(v553 + 8))(v552, v554);
    uint64_t v167 = v549;
    v547(&unk_18180BE68, 256LL);
    v546(v167, v143, v551);
LABEL_19:
    char v168 = 1;
    return v168 & 1;
  }

  uint64_t v573 = 0LL;
  uint64_t v151 = v134;
  v152 = v558;
  (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v129 + 96))( &v573,  &type metadata for Int,  v545,  v151,  v129);
  char v153 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v129 + 16) + 8LL) + 8LL))( v138,  v152,  v151);
  unint64_t v142 = *(void (**)(char *, uint64_t))(v565 + 8);
  uint64_t v154 = v152;
  uint64_t v134 = v151;
  v142(v154, v151);
  uint64_t v143 = (uint64_t)v567;
  if ((v153 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_22:
  v540 = v130;
  v537 = v137;
  v551 = v113;
  v550 = v142;
  (*(void (**)(uint64_t))(v532 + 56))(v134);
  uint64_t v170 = v129;
  uint64_t v171 = v535;
  unint64_t v172 = swift_getAssociatedConformanceWitness( v170,  v134,  (uint64_t)v535,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v173 = (*(uint64_t (**)(unint64_t *, unint64_t))(v172 + 136))(v171, v172);
  uint64_t v174 = v538;
  uint64_t v175 = v527;
  v547 = *(void (**)(void *, uint64_t))(v538 + 120);
  v547((void *)v143, v538);
  unint64_t v176 = v528;
  v546 = *(void (**)(uint64_t, uint64_t, unint64_t *))(v174 + 176);
  ((void (*)(uint64_t, uint64_t))v546)(v143, v174);
  v534(v175, v143);
  uint64_t v177 = v536;
  v178 = *(uint64_t (**)(void))(v536 + 64);
  unint64_t v179 = v533;
  if ((((uint64_t (*)(unint64_t *, uint64_t))v178)(v533, v536) & 1) == 0)
  {
    char v185 = ((uint64_t (*)(unint64_t *, uint64_t))v178)(v179, v177);
    v548 = *(uint64_t (**)(unint64_t *, uint64_t))(v177 + 128);
    uint64_t v186 = v548(v179, v177);
    if ((v185 & 1) != 0)
    {
      uint64_t v549 = v172;
      if (v186 > 64)
      {
        uint64_t v573 = v173;
        uint64_t v187 = v173;
        uint64_t v188 = v521;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v177 + 96))( &v573,  &type metadata for Int,  v545,  v179,  v177);
        char v189 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v177 + 32) + 8LL)
                                                                             + 16LL))( v176,  v188,  v179);
        unsigned int v184 = *(void (**)(char *, unint64_t *))(v529 + 8);
        uint64_t v190 = v188;
        uint64_t v173 = v187;
        v184(v190, v179);
        unint64_t v191 = v176;
        goto LABEL_37;
      }

      int v200 = (void (**)(char *, unint64_t *, const char *))v500;
      unint64_t v201 = v499;
      unint64_t v202 = swift_getAssociatedConformanceWitness( (uint64_t)v500,  (uint64_t)v179,  v499,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      __int16 v203 = v498;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v202 + 8))( &unk_18180BE68,  256LL,  v201,  v202);
      unint64_t v204 = v176;
      v205 = v521;
      v200[3](v203, v179, (const char *)v200);
      LOBYTE(v200) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v177 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v204,  v205,  v179);
      uint64_t v206 = v529;
      unsigned int v184 = *(void (**)(char *, unint64_t *))(v529 + 8);
      v184(v205, v179);
      unint64_t v207 = *(void (**)(char *, char *, unint64_t *))(v206 + 32);
      unint64_t v208 = v497;
      v207(v497, v204, v179);
      if ((v200 & 1) != 0)
      {
        v184(v208, v179);
        unsigned int v182 = v572;
        goto LABEL_42;
      }

      uint64_t v214 = (*(uint64_t (**)(unint64_t *))(v536 + 120))(v179);
      v184(v208, v179);
      BOOL v199 = v214 < v173;
      unint64_t v172 = v549;
    }

    else
    {
      if (v186 >= 64)
      {
        uint64_t v549 = v172;
        uint64_t v209 = v173;
        uint64_t v210 = v529;
        char v211 = v496;
        (*(void (**)(char *, char *, unint64_t *))(v529 + 32))(v496, v176, v179);
        if (v209 <= 0)
        {
          unsigned int v184 = *(void (**)(char *, unint64_t *))(v210 + 8);
          v184(v211, v179);
          uint64_t v173 = v209;
          unint64_t v172 = v549;
          goto LABEL_60;
        }

        uint64_t v573 = v209;
        uint64_t v212 = v536;
        v213 = v521;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v536 + 96))( &v573,  &type metadata for Int,  v545,  v179,  v536);
        char v189 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v212 + 32) + 8LL)
                                                                             + 16LL))( v211,  v213,  v179);
        unsigned int v184 = *(void (**)(char *, unint64_t *))(v210 + 8);
        uint64_t v173 = v209;
        v184(v213, v179);
        unint64_t v191 = v211;
LABEL_37:
        v184(v191, v179);
        unint64_t v172 = v549;
        unsigned int v182 = v572;
        if ((v189 & 1) != 0) {
          goto LABEL_42;
        }
        goto LABEL_60;
      }

      uint64_t v198 = (*(uint64_t (**)(unint64_t *, uint64_t))(v177 + 120))(v179, v177);
      unsigned int v184 = *(void (**)(char *, unint64_t *))(v529 + 8);
      v184(v176, v179);
      BOOL v199 = v198 < v173;
    }

    unsigned int v182 = v572;
    if (v199) {
      goto LABEL_42;
    }
    goto LABEL_60;
  }

  v548 = *(uint64_t (**)(unint64_t *, uint64_t))(v177 + 128);
  uint64_t v180 = v548(v179, v177);
  uint64_t v181 = v177;
  unsigned int v182 = v572;
  if (v180 < 64)
  {
    uint64_t v183 = (*(uint64_t (**)(unint64_t *, uint64_t))(v181 + 120))(v179, v181);
    unsigned int v184 = *(void (**)(char *, unint64_t *))(v529 + 8);
    v184(v176, v179);
    if (v183 >= v173) {
      goto LABEL_60;
    }
LABEL_42:
    (*(void (**)(char *, unint64_t *))(v531 + 8))(v539, v171);
    v540(v182, v551);
    (*(void (**)(char *, unint64_t))(v553 + 8))(v552, v554);
    uint64_t v215 = v568;
    uint64_t v216 = v566;
    __int16 v217 = v530;
    char v218 = v530(v568, v566);
    v219 = v520;
    (*(void (**)(char *, uint64_t, uint64_t))(v565 + 16))(v520, v569, v215);
    uint64_t v220 = (uint64_t)v567;
    if ((v218 & 1) != 0)
    {
      if ((v217(v215, v216) & 1) != 0)
      {
        unsigned int v221 = v534;
        if (v537(v215, v216) < 64)
        {
          uint64_t v222 = (*(uint64_t (**)(uint64_t, uint64_t))(v216 + 120))(v215, v216);
          goto LABEL_54;
        }

        uint64_t v573 = 0LL;
        char v232 = v558;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v216 + 96))( &v573,  &type metadata for Int,  v545,  v215,  v216);
        char v229 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v216 + 32) + 8LL) + 16LL))( v219,  v232,  v215);
        uint64_t v233 = v550;
        v550(v232, v215);
        v233(v219, v215);
        goto LABEL_50;
      }

      unsigned int v221 = v534;
      char v223 = v217(v215, v216);
      uint64_t v224 = v537(v215, v216);
      if ((v223 & 1) != 0)
      {
        if (v224 <= 64)
        {
          unint64_t v326 = (void (**)(char *, uint64_t, const char *))v544;
          uint64_t v327 = v568;
          unint64_t v328 = v542;
          unint64_t v329 = swift_getAssociatedConformanceWitness( (uint64_t)v544,  v568,  v542,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v330 = v543;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v329 + 8))( &unk_18180BE68,  256LL,  v328,  v329);
          uint64_t v331 = v558;
          v326[3](v330, v327, (const char *)v326);
          v332 = v520;
          LOBYTE(v326) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v566 + 32) + 8LL)
                                                                            + 16LL))( v520,  v331,  v327);
          v550(v331, v327);
          (*(void (**)(char *, char *, uint64_t))(v565 + 32))(v492, v332, v327);
          if ((v326 & 1) != 0)
          {
            v550(v492, v568);
            uint64_t v220 = (uint64_t)v567;
          }

          else
          {
            v351 = v492;
            uint64_t v352 = v568;
            uint64_t v353 = (*(uint64_t (**)(uint64_t))(v566 + 120))(v568);
            v550(v351, v352);
            uint64_t v220 = (uint64_t)v567;
            if ((v353 & 0x8000000000000000LL) == 0) {
              goto LABEL_57;
            }
          }

          goto LABEL_102;
        }

        uint64_t v573 = 0LL;
        uint64_t v225 = v566;
        int v226 = v558;
        uint64_t v227 = v568;
        (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v566 + 96))( &v573,  &type metadata for Int,  v545,  v568,  v566);
        uint64_t v228 = v520;
        char v229 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v225 + 32) + 8LL) + 16LL))( v520,  v226,  v227);
        int v230 = v226;
        v231 = v550;
        v550(v230, v227);
        v231(v228, v227);
        uint64_t v220 = (uint64_t)v567;
LABEL_50:
        if ((v229 & 1) == 0) {
          goto LABEL_57;
        }
LABEL_102:
        v354 = v495;
        (*(void (**)(uint64_t))(v538 + 112))(v220);
        (*(void (**)(char *, uint64_t))(v494 + 16))(v354, v220);
        v221(v354, v220);
        goto LABEL_58;
      }

      uint64_t v220 = (uint64_t)v567;
      uint64_t v215 = v568;
      v219 = v520;
      if (v224 < 64)
      {
        uint64_t v222 = (*(uint64_t (**)(uint64_t, uint64_t))(v566 + 120))(v568, v566);
LABEL_54:
        uint64_t v234 = v222;
        v550(v219, v215);
        if (v234 < 0) {
          goto LABEL_102;
        }
LABEL_57:
        (*(void (**)(uint64_t))(v538 + 112))(v220);
LABEL_58:
        char v168 = 0;
        return v168 & 1;
      }
    }

    v550(v219, v215);
    goto LABEL_57;
  }

  uint64_t v573 = v173;
  unint64_t v192 = v178;
  unint64_t v193 = v172;
  uint64_t v194 = v173;
  v195 = v521;
  (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v181 + 96))( &v573,  &type metadata for Int,  v545,  v179,  v181);
  char v196 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v181 + 32) + 8LL) + 16LL))( v176,  v195,  v179);
  unsigned int v184 = *(void (**)(char *, unint64_t *))(v529 + 8);
  uint64_t v197 = v195;
  uint64_t v173 = v194;
  unint64_t v172 = v193;
  v178 = v192;
  unsigned int v182 = v572;
  v184(v197, v179);
  v184(v176, v179);
  if ((v196 & 1) != 0) {
    goto LABEL_42;
  }
LABEL_60:
  uint64_t v235 = (uint64_t)v567;
  uint64_t v236 = v563;
  uint64_t v237 = v518;
  if (v518((uint64_t)v567, v563) >= v173)
  {
    v282 = v551;
    char v283 = v540;
    v540(v572, v551);
    uint64_t v284 = v237(v235, v236) - v173;
    char v285 = v523;
    (*(void (**)(char *, char *, unint64_t *))(v531 + 32))(v523, v539, v171);
    uint64_t v286 = v562;
    v287 = v564;
    (*(void (**)(char *, unint64_t *, unint64_t, unint64_t *, uint64_t))(v562 + 88))( v285,  v171,  v172,  v282,  v562);
    uint64_t v573 = v284;
    v288 = v560;
    (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v286 + 96))( &v573,  &type metadata for Int,  v545,  v282,  v286);
    (*(void (**)(char *, char *, unint64_t *))(v561 + 216))(v287, v288, v282);
    v283(v288, v282);
    v283(v287, v282);
    uint64_t v289 = v568;
    uint64_t v290 = v566;
    v291 = v530;
    LOBYTE(v288) = v530(v568, v566);
    uint64_t v292 = v514;
    (*(void (**)(char *, uint64_t, uint64_t))(v565 + 16))(v514, v569, v289);
    if ((v288 & 1) != 0)
    {
      uint64_t v293 = v173;
      if ((v291(v289, v290) & 1) != 0)
      {
        if (v537(v289, v290) < 64)
        {
          v294 = *(uint64_t (**)(uint64_t))(v566 + 120);
          uint64_t v295 = (char **)&v546;
LABEL_123:
          v392 = *(v295 - 32);
          uint64_t v289 = v568;
          uint64_t v333 = v294(v568);
          v334 = v392;
LABEL_124:
          v550(v334, v289);
          if (v333 < 0) {
            goto LABEL_125;
          }
LABEL_92:
          LODWORD(v572) = 0;
LABEL_126:
          uint64_t v393 = v554;
          uint64_t v394 = v553;
          v395 = v552;
          v396 = v516;
          v397 = v515;
          uint64_t v573 = v293;
          v398 = v563;
          uint64_t v399 = (uint64_t)v567;
          uint64_t v400 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v563,  (uint64_t)v567,  v554,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)
                           + 8);
          (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v400 + 88))( &v573,  &type metadata for Int,  v545,  v393,  v400);
          (*(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v400 + 24) + 8LL) + 24LL))( v395,  v397,  v393);
          v401 = *(void (**)(char *, uint64_t))(v394 + 8);
          v401(v397, v393);
          v401(v395, v393);
          (*((void (**)(void, char *, uint64_t (*)(void), uint64_t, const char *))v398 + 7))( v572,  v396,  v519,  v399,  v398);
          goto LABEL_19;
        }

        goto LABEL_81;
      }

      char v308 = v291(v289, v290);
      uint64_t v309 = v537(v289, v290);
      if ((v308 & 1) != 0)
      {
        if (v309 <= 64)
        {
          v355 = (void (**)(char *, uint64_t, const char *))v544;
          uint64_t v356 = v568;
          unint64_t v357 = v542;
          unint64_t v358 = swift_getAssociatedConformanceWitness( (uint64_t)v544,  v568,  v542,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v359 = v543;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v358 + 8))( &unk_18180BE68,  256LL,  v357,  v358);
          v360 = v558;
          v355[3](v359, v356, (const char *)v355);
          v361 = v514;
          LOBYTE(v355) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v566 + 32) + 8LL)
                                                                            + 16LL))( v514,  v360,  v356);
          v550(v360, v356);
          (*(void (**)(char *, char *, uint64_t))(v565 + 32))(v490, v361, v356);
          if ((v355 & 1) != 0)
          {
            v550(v490, v568);
LABEL_125:
            LODWORD(v572) = 1;
            goto LABEL_126;
          }

          v294 = *(uint64_t (**)(uint64_t))(v566 + 120);
          uint64_t v295 = &v522;
          goto LABEL_123;
        }

LABEL_139:
            uint64_t v573 = 0LL;
            uint64_t v424 = v566;
            v425 = v558;
            uint64_t v426 = v568;
            (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v566 + 96))( &v573,  &type metadata for Int,  v545,  v568,  v566);
            v427 = v517;
            LOBYTE(v424) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v424 + 32) + 8LL)
                                                                              + 16LL))( v517,  v425,  v426);
            v428 = v425;
            v429 = v550;
            v550(v428, v426);
            v429(v427, v426);
            if ((v424 & 1) != 0) {
              goto LABEL_144;
            }
            goto LABEL_146;
          }

          uint64_t v413 = v568;
          if (v423 < 64)
          {
            v417 = *(uint64_t (**)(uint64_t))(v566 + 120);
            v419 = v517;
LABEL_143:
            uint64_t v430 = v417(v413);
            v550(v419, v413);
            if (v430 < 0)
            {
LABEL_144:
              uint64_t v431 = 1LL;
LABEL_147:
              uint64_t v573 = (uint64_t)v528;
              v432 = v563;
              uint64_t v433 = (uint64_t)v567;
              uint64_t v434 = v554;
              uint64_t v435 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v563,  (uint64_t)v567,  v554,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger)
                               + 8);
              v436 = v515;
              (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v435 + 88))( &v573,  &type metadata for Int,  v545,  v434,  v435);
              v437 = *(void (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v435 + 24) + 8LL) + 24LL);
              v438 = v516;
              v439 = v552;
              v437(v552, v436, v434);
              v440 = *(void (**)(char *, uint64_t))(v553 + 8);
              v440(v436, v434);
              v440(v439, v434);
              v441 = v564;
              (*(void (**)(char *, char *, unint64_t *))(v559 + 32))(v564, v526, v551);
              (*((void (**)(uint64_t, char *, char *, uint64_t, const char *))v432 + 7))( v431,  v438,  v441,  v433,  v432);
              uint64_t v442 = v549;
              v443 = *(uint64_t (**)(unint64_t *, uint64_t))(v549 + 64);
              v444 = v535;
              if ((v443(v535, v549) & 1) != 0)
              {
                goto LABEL_152;
              }

              char v445 = v443(v444, v442);
              uint64_t v446 = (*(uint64_t (**)(unint64_t *, uint64_t))(v442 + 128))(v444, v442);
              if ((v445 & 1) != 0)
              {
                if (v446 <= 64)
                {
                  v455 = v511;
                  ((void (*)(void *, uint64_t))v527)(&unk_18180BE68, 256LL);
                  v456 = v523;
                  v457 = v535;
                  ((void (*)(char *, unint64_t *, const char *))v520)(v455, v535, v525);
                  v458 = v522;
                  LOBYTE(v455) = (*((uint64_t (**)(char *, char *, unint64_t *))v539 + 4))( v522,  v456,  v457);
                  ((void (*)(char *, unint64_t *))v541)(v456, v457);
                  v272(v491, v458, v457);
                  char v168 = (v455 & 1) != 0
                      && (*(uint64_t (**)(unint64_t *))(v549 + 120))(v535) == 0;
                  ((void (*)(char *, unint64_t *))v541)(v491, v535);
                  return v168 & 1;
                }

  swift_bridgeObjectRelease(v52);
  uint64_t v93 = v97;
  if ((*(_BYTE *)v97 & 2) != 0) {
    char v94 = v56._rawBits | 3;
  }
  else {
    char v94 = v56._rawBits;
  }
  if ((v97[1] & 2) != 0) {
    uint64_t v95 = v75._rawBits | 3;
  }
  else {
    uint64_t v95 = v75._rawBits;
  }
  if (v95 >> 14 < v94 >> 14) {
LABEL_154:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  swift_bridgeObjectRelease(v97[3]);
  *uint64_t v93 = v94;
  v93[1] = v95;
  v93[2] = v50;
  v93[3] = v52;
}

        if (v86 == v249)
        {
          v270 = (uint64_t *)&v268;
          (*(void (**)(void *, uint64_t **))(v249[0] + 24LL))(v249, &v268);
        }

        else
        {
          v270 = (uint64_t *)(*(uint64_t (**)(void *))(*v86 + 16LL))(v86);
        }

  while (1)
  {
    if (!v101) {
      return 0LL;
    }
    swift::Demangle::__runtime::Node::addChild( v98,  v101,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v102,  v103);
    unint64_t v99 = *((void *)this + 4);
    if (v99) {
      goto LABEL_138;
    }
  }

LABEL_152:
                uint64_t v573 = 0LL;
                v447 = v523;
                v448 = v535;
                (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *))(v549 + 96))( &v573,  &type metadata for Int,  v545,  v535);
                v449 = v522;
                char v168 = (*(uint64_t (**)(char *, char *, unint64_t *))(*((void *)v539 + 1) + 8LL))( v522,  v447,  v448);
                v450 = v447;
                v451 = (void (*)(char *, unint64_t *))v541;
                ((void (*)(char *, unint64_t *))v541)(v450, v448);
                v451(v449, v448);
                return v168 & 1;
              }

              if (v446 < 64)
              {
LABEL_155:
                v452 = v523;
                v453 = v535;
                v272(v523, v522, v535);
                uint64_t v454 = (*(uint64_t (**)(unint64_t *))(v549 + 120))(v453);
                ((void (*)(char *, unint64_t *))v541)(v452, v453);
                char v168 = v454 == 0;
                return v168 & 1;
              }

              uint64_t v573 = 0LL;
              v459 = v523;
              v460 = v535;
              (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *))(v549 + 96))( &v573,  &type metadata for Int,  v545,  v535);
              v461 = v522;
              char v168 = (*(uint64_t (**)(char *, char *, unint64_t *))(*((void *)v539 + 1) + 8LL))( v522,  v459,  v460);
              v462 = v461;
              v463 = (void (*)(char *, unint64_t *))v541;
              ((void (*)(char *, unint64_t *))v541)(v462, v460);
              v463(v459, v460);
              return v168 & 1;
            }

            swift_bridgeObjectRelease(v154);
            swift_bridgeObjectRelease(v33);
            uint64_t v155 = 0xA000000000000000LL;
            if (!(v34 & 0x8080808080808080LL | v114 & 0x80808080808080LL)) {
              uint64_t v155 = 0xE000000000000000LL;
            }
            uint64_t v156 = v155 | (v40 << 56);
LABEL_155:
            v267 = v34;
            uint64_t v268 = v156 & 0xFF00000000000000LL | v114 & 0xFFFFFFFFFFFFFFLL;
            goto LABEL_204;
          }

          uint64_t v50 = 1LL;
        }

        uint64_t v41 = v77 & 0xFFFFFFFFFFFFLL;
        if (v50) {
          uint64_t v38 = HIBYTE(v78) & 0xF;
        }
        else {
          uint64_t v38 = v77 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v78, 2LL, v79, v80);
        if ((v33 & 0x1000000000000000LL) == 0)
        {
          swift_bridgeObjectRetain_n(v33, 4LL, v64, v65);
          uint64_t v82 = v38;
          if ((v39 & 0x1000000000000000LL) != 0) {
            goto LABEL_239;
          }
          goto LABEL_75;
        }

                      uint64_t v170 = 266LL;
LABEL_161:
                      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v170,  0);
                    }

    v95[0] = a4 & 0xFFFFFFFFFFFFFEFFLL;
    performOnMetadataCache<swift::MetadataResponse,swift_checkMetadataState::CheckStateCallbacks>(a3, v95);
    uint64_t v14 = (char *)__p;
    goto LABEL_153;
  }

  if (v15 == 255)
  {
    if (v81[0]) {
      goto LABEL_153;
    }
    goto LABEL_152;
  }

  if (v15 != 63) {
    goto LABEL_159;
  }
LABEL_153:
  if (v14)
  {
    uint64_t v86 = v14;
    operator delete(v14);
  }

    uint64_t v56 = 0LL;
LABEL_153:
    uint64_t v60 = *((unsigned __int8 *)v56 + 18);
    switch(v60)
    {
      case 1:
        uint64_t v61 = *((unsigned __int8 *)v56 + 18);
        break;
      case 5:
        uint64_t v61 = *((unsigned int *)v56 + 2);
        if (!(_DWORD)v61)
        {
LABEL_171:
          uint64_t v52 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
          if (!v52 || v52 + 24 > *((void *)this + 2))
          {
            uint64_t v48 = 2LL * *((void *)this + 4);
            if (v48 <= 0x20) {
              uint64_t v48 = 32LL;
            }
            *((void *)this + 4) = v48;
            uint64_t v49 = v48 + 8;
            uint64_t v50 = malloc(v48 + 8);
            uint64_t v51 = (char *)v50 + v49;
            char *v50 = *((void *)this + 3);
            uint64_t v52 = ((unint64_t)v50 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *((void *)this + 2) = v51;
            *((void *)this + 3) = v50;
          }

          *((void *)this + 1) = v52 + 24;
          *(_WORD *)(v52 + 16) = 275;
          *(_BYTE *)(v52 + 18) = 0;
          goto LABEL_136;
        }

        break;
      case 2:
        uint64_t v61 = 2LL;
        break;
      default:
        goto LABEL_171;
    }

    uint64_t v62 = 0LL;
    uint64_t v63 = 1;
    while (1)
    {
      uint64_t v64 = *((unsigned __int8 *)v56 + 18);
      if (v60 == 1) {
        goto LABEL_163;
      }
      if (v60 != 5)
      {
        uint64_t v64 = 2LL;
LABEL_163:
        if (v64 <= v62) {
          goto LABEL_168;
        }
        goto LABEL_164;
      }

      if (*((unsigned int *)v56 + 2) <= v62)
      {
LABEL_168:
        uint64_t v66 = 0LL;
        goto LABEL_169;
      }

LABEL_146:
            uint64_t v431 = 0LL;
            goto LABEL_147;
          }
        }

        v550(v517, v413);
        goto LABEL_146;
      }

LABEL_177:
  __break(1u);
  return result;
}

                    _assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)v214, v215, 0);
                  }

        unint64_t v169 = &TypeName->u8[v131];
        uint64_t v170 = v130 - v131;
        do
        {
          uint64_t v171 = *v169++;
          countAndFlagsBits |= (unint64_t)v171 << (v132 & 0x38);
          v132 += 8LL;
          --v170;
        }

        while (v170);
        goto LABEL_179;
      }

  v267 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    v267 = v450 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v268 = v435;
  if (v267 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236LL;
    v451 = 0xE200000000000000LL;
  }

  v159(4LL, v199, v203);
  char v445 = (uint64_t *)v1;
  v269 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v269, v268, v2);
  v270 = v445;
  uint64_t v271 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  uint64_t v272 = (void *)swift_getDynamicType(v271, v270, 1);
  LODWORD(v270) = swift_isOptionalType(v272);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v270)
  {
    memcpy(v150, v268, v2);
    uint64_t v273 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v273, 7uLL);
LABEL_184:
    uint64_t v274 = (uint64_t)v445;
    uint64_t v275 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v276 = (*(uint64_t (**)(uint64_t, uint64_t))(v275 + 8))(v274, v275);
    v278 = v277;
    specialized String.write<A>(to:)(&v450, v276, v277, v279);
    swift_bridgeObjectRelease(v278);
LABEL_185:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_188;
  }

  v280 = v431;
  memcpy(v431, v268, v2);
  if ((swift_dynamicCast((char *)&v444, v280, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t v281 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v281);
  }

  else
  {
    char v337 = v424;
    memcpy(v424, v268, v2);
    uint64_t v338 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v337, v1, v338, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v339 = (uint64_t)v445;
      v340 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v340 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v339,  v340);
      goto LABEL_185;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v361 = v416;
    memcpy(v416, v268, v2);
    v362 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v361, v1, v362, 6uLL)
      || (v449 = 0LL,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?),  v363 = v408,  memcpy(v408, v268, v2),  v364 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v447, v363, v1, v364, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_184;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v448 + 1) = v1;
    uint64_t v388 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v388, v268, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v389 = v444._object;
    v390 = v268;
    v391 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v390,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v391);
    swift_release((uint64_t)v389);
  }

uint64_t BinaryFloatingPoint<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
}

uint64_t BinaryFloatingPoint<>.init<A>(exactly:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v10 = (char *)&v17 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v14 = static BinaryFloatingPoint<>._convert<A>(from:)((uint64_t)v10, a1, a2, a3, v11, v12, v13);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  if ((v14 & 1) != 0)
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v8 + 32))(a4, v10, a2);
    uint64_t v15 = 0LL;
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v8 + 8))(v10, a2);
    uint64_t v15 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56))(a4, v15, 1LL, a2);
}

uint64_t _swift_stdlib_Hashable_isEqual_indirect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  unint64_t v10 = (char *)&v16 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v16 - v11;
  uint64_t v13 = *(void (**)(char *))(v7 + 16);
  v13((char *)&v16 - v11);
  ((void (*)(char *, uint64_t, uint64_t))v13)(v10, a2, a3);
  LOBYTE(a4) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a4 + 8) + 8LL))(v12, v10, a3);
  char v14 = *(void (**)(char *, uint64_t))(v7 + 8);
  v14(v10, a3);
  v14(v12, a3);
  return a4 & 1;
}

uint64_t _getErrorCode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v5 + 16))(v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a2, a3);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v7, a2);
  return v8;
}

uint64_t _ConcreteHashableBox._unbox<A>()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v10 = (const char *)type metadata accessor for _ConcreteHashableBox((const char *)0xFF, a2, a3, a4);
  uint64_t v13 = type metadata accessor for Optional(0LL, (uint64_t)v10, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v25[-1] - v15;
  v25[3] = a1;
  v25[4] = (uint64_t)&protocol witness table for _ConcreteHashableBox<A>;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v25);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))( boxed_opaque_existential_0Tm,  v6,  a1);
  uint64_t v18 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  int v19 = swift_dynamicCast(v16, v25, v18, v10, 6uLL);
  uint64_t v20 = *((void *)v10 - 1);
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v20 + 56);
  if (v19)
  {
    v21(v16, 0LL, 1LL, v10);
    uint64_t v22 = *(void *)(a2 - 8);
    (*(void (**)(uint64_t, char *, uint64_t))(v22 + 16))(a5, v16, a2);
    (*(void (**)(char *, const char *))(v20 + 8))(v16, v10);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v22 + 56))(a5, 0LL, 1LL, a2);
  }

  else
  {
    v21(v16, 1LL, 1LL, v10);
    (*(void (**)(char *, uint64_t))(v14 + 8))(v16, v13);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))( a5,  1LL,  1LL,  a2);
  }

uint64_t _ConcreteHashableBox._isEqual(to:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = type metadata accessor for Optional(0LL, v6, a3, a4);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)v20 - v10;
  uint64_t v12 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = a1[3];
  uint64_t v16 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v15);
  uint64_t v17 = *(void *)(a2 + 24);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 56))(v6, v17, v15, v16);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v12 + 48))(v11, 1LL, v6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
    return 2LL;
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v12 + 32))(v14, v11, v6);
    char v19 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(v17 + 8) + 8LL))(v20[1], v14, v6);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v6);
    return v19 & 1;
  }

uint64_t _ConcreteHashableBox._hashValue.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16LL))(*(void *)(a1 + 16));
}

uint64_t _ConcreteHashableBox._hash(into:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 24LL))(a1, *(void *)(a2 + 16));
}

Swift::Int __swiftcall _ConcreteHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  return (*(uint64_t (**)(Swift::Int, void))(*(void *)(v1 + 24) + 32LL))(_seed, *(void *)(v1 + 16));
}

uint64_t protocol witness for _AnyHashableBox._base.getter in conformance _ConcreteHashableBox<A>@<X0>( uint64_t a1@<X0>, void *a2@<X8>)
{
  return _ConcreteHashableBox._base.getter(a1, a2);
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _ConcreteHashableBox<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return _ConcreteHashableBox._unbox<A>()(a3, a1, a2, a4, a5);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _ConcreteHashableBox<A>( char *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return _ConcreteHashableBox._downCastConditional<A>(into:)(a1, a3, a2, a4) & 1;
}

double AnyHashable.init<A>(_:)@<D0>( uint64_t a1@<X0>, uint64_t (***a2)()@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (uint64_t)*(a2 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v22 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v12 == &type metadata for String)
  {
    char v19 = *(swift **)a1;
    uint64_t v20 = *(void *)(a1 + 8);
    *(void *)(a4 + 24) = &unk_189B88968;
    *(void *)(a4 + 32) = &protocol witness table for _ConcreteHashableBox<A>;
    *(void *)a4 = v19;
    *(void *)(a4 + 8) = v20;
    return result;
  }

  (*(void (**)(char *, uint64_t, uint64_t (***)()))(v8 + 16))(v11, a1, a2);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation);
  if ((swift_dynamicCast(&v25, v11, a2, v13, 6LL) & 1) == 0)
  {
    uint64_t v27 = 0LL;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v25,  &demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation?);
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    uint64_t v24 = 0LL;
    goto LABEL_7;
  }

  uint64_t v14 = *((void *)&v26 + 1);
  uint64_t v15 = v27;
  uint64_t v16 = __swift_project_boxed_opaque_existential_0Tm(&v25, *((uint64_t *)&v26 + 1));
  MEMORY[0x1895F8858](v16);
  (*(void (**)(char *))(v18 + 16))((char *)&v22 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  ((void (*)(__int128 *__return_ptr, uint64_t, _UNKNOWN **))v15[1])(&v22, v14, v15);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v25);
  if (!*((void *)&v23 + 1))
  {
LABEL_7:
    outlined destroy of AnyHashable?((uint64_t *)&v22);
    *((void *)&v26 + 1) = &unk_189B88A00;
    uint64_t v27 = &protocol witness table for _ConcreteHashableBox<A>;
    LOBYTE(v25) = 0;
    _swift_makeAnyHashableUpcastingToHashableBaseType((swift **)a1, (objc_object *)&v25, a2, a3);
    (*(void (**)(uint64_t, uint64_t (***)()))(v8 + 8))(a1, a2);
    goto LABEL_8;
  }

  (*(void (**)(uint64_t, uint64_t (***)()))(v8 + 8))(a1, a2);
  __int128 v25 = v22;
  __int128 v26 = v23;
  uint64_t v27 = v24;
LABEL_8:
  double result = *(double *)&v25;
  __int128 v21 = v26;
  *(_OWORD *)a4 = v25;
  *(_OWORD *)(a4 + 16) = v21;
  *(void *)(a4 + 32) = v27;
  return result;
}

uint64_t AnyHashable.base.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 48))(v1, v2);
}

uint64_t AnyHashable.hashValue.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 8))(v7, v1, v2);
  uint64_t v3 = v8;
  uint64_t v4 = v9;
  __swift_project_boxed_opaque_existential_0Tm(v7, v8);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 24))(v3, v4);
  __swift_destroy_boxed_opaque_existential_1Tm(v7);
  return v5;
}

uint64_t AnyHashable.hash(into:)(uint64_t a1)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_project_boxed_opaque_existential_0Tm(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32))(a1, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

Swift::Int __swiftcall AnyHashable._rawHashValue(seed:)(Swift::Int seed)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v9, v3, v4);
  uint64_t v5 = v10;
  uint64_t v6 = v11;
  __swift_project_boxed_opaque_existential_0Tm(v9, v10);
  Swift::Int v7 = (*(uint64_t (**)(Swift::Int, uint64_t, uint64_t))(v6 + 40))(seed, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v9);
  return v7;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance AnyHashable()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 8))(v7, v1, v2);
  uint64_t v3 = v8;
  uint64_t v4 = v9;
  __swift_project_boxed_opaque_existential_0Tm(v7, v8);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 24))(v3, v4);
  __swift_destroy_boxed_opaque_existential_1Tm(v7);
  return v5;
}

uint64_t protocol witness for Hashable.hash(into:) in conformance AnyHashable(uint64_t a1)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v8, v3, v4);
  uint64_t v5 = v9;
  uint64_t v6 = v10;
  __swift_project_boxed_opaque_existential_0Tm(v8, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32))(a1, v5, v6);
  return __swift_destroy_boxed_opaque_existential_1Tm(v8);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance AnyHashable(uint64_t a1)
{
  uint64_t v3 = v1[3];
  uint64_t v4 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v9, v3, v4);
  uint64_t v5 = v10;
  uint64_t v6 = v11;
  __swift_project_boxed_opaque_existential_0Tm(v9, v10);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 40))(a1, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v9);
  return v7;
}

uint64_t AnyHashable.description.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 48))(v5, v1, v2);
  v4[0] = 0LL;
  v4[1] = 0xE000000000000000LL;
  _print_unlocked<A, B>(_:_:)( (uint64_t)v5,  (uint64_t)v4,  (swift *)byte_189B8D218,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v5);
  return v4[0];
}

uint64_t specialized String.init<A>(describing:)(uint64_t a1)
{
  uint64_t v233 = 0LL;
  unint64_t v234 = 0xE000000000000000LL;
  uint64_t v235 = a1;
  uint64_t v2 = (uint64_t *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any.Type);
  uint64_t v227 = v2;
  v226[0] = a1;
  uint64_t v3 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(v226, (uint64_t)v2);
  DynamicType = (void *)swift_getDynamicType(v3, v2, 1);
  BOOL isOptionalType = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(v226);
  if (isOptionalType)
  {
    *(void *)&__int128 v229 = a1;
    uint64_t v6 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)v226, (uint64_t *)&v229, (swift *)v2, v6, 7uLL);
    uint64_t v7 = (uint64_t)v227;
    uint64_t v8 = v228;
    __swift_project_boxed_opaque_existential_0Tm(v226, (uint64_t)v227);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
    uint64_t v13 = v9;
    unint64_t v14 = v10;
    uint64_t v15 = v233;
    unint64_t v16 = v234;
    unint64_t v17 = HIBYTE(v234) & 0xF;
    if ((v234 & 0x2000000000000000LL) != 0) {
      unint64_t v18 = HIBYTE(v234) & 0xF;
    }
    else {
      unint64_t v18 = v233 & 0xFFFFFFFFFFFFLL;
    }
    if (v18 || (v233 & ~v234 & 0x2000000000000000LL) != 0)
    {
      uint64_t v19 = v10 & 0x2000000000000000LL;
      uint64_t v20 = HIBYTE(v10) & 0xF;
      if ((v234 & 0x2000000000000000LL) == 0 || !v19) {
        goto LABEL_11;
      }
      unint64_t v21 = v17 + v20;
      if (v17 + v20 > 0xF)
      {
        uint64_t v19 = 1LL;
LABEL_11:
        if (v19) {
          uint64_t v22 = HIBYTE(v10) & 0xF;
        }
        else {
          uint64_t v22 = v9 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v10, 2LL, v11, v12);
        if ((v14 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRetain_n(v14, 5LL, v23, v24);
          v194._rawBits = 1LL;
          v195._rawBits = (v22 << 16) | 1;
          v196._rawBits = _StringGuts.validateScalarRange(_:)(v194, v195, v13, v14);
          if (v196._rawBits < 0x10000) {
            v196._rawBits |= 3;
          }
          Swift::Int v28 = specialized Collection.count.getter(v196, v197, v13, v14);
          swift_bridgeObjectRelease(v14);
          if ((v16 & 0x1000000000000000LL) == 0)
          {
LABEL_16:
            BOOL v29 = __OFADD__(v18, v28);
            Swift::Int v30 = v18 + v28;
            if (!v29)
            {
LABEL_17:
              if ((v15 & ~v16 & 0x2000000000000000LL) != 0
                && swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL))
              {
                uint64_t v31 = v233;
                uint64_t v15 = v234;
                int64_t v32 = _StringGuts.nativeUnusedCapacity.getter(v233, v234);
                if ((v33 & 1) != 0) {
                  goto LABEL_250;
                }
                if (v30 >= 16) {
                  goto LABEL_28;
                }
                if ((v15 & 0x2000000000000000LL) == 0)
                {
                  unint64_t v16 = v15;
                  if (v32 < v28) {
                    goto LABEL_74;
                  }
                  goto LABEL_28;
                }

                int v63 = 0;
                unint64_t v16 = v15;
              }

              else
              {
                if (v30 >= 16)
                {
                  uint64_t v31 = v233;
                  uint64_t v15 = v234;
LABEL_28:
                  int64_t v37 = _StringGuts.nativeUnusedCapacity.getter(v31, v15);
                  unint64_t v16 = (v38 & 1) == 0 && v37 >= v28;
                  if ((v31 & ~v15 & 0x2000000000000000LL) != 0
                    && swift_isUniquelyReferenced_nonNull_native(v15 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if ((_DWORD)v16) {
                      goto LABEL_69;
                    }
                  }

                  else if ((v16 & 1) != 0)
                  {
LABEL_68:
                    _StringGuts.grow(_:)(v30);
LABEL_69:
                    swift_bridgeObjectRelease_n(v14, 4LL);
                    if ((v14 & 0x1000000000000000LL) == 0)
                    {
                      if (v19)
                      {
                        swift_bridgeObjectRelease_n(v14, 2LL);
                        uint64_t v60 = (v14 >> 62) & 1;
                        *(void *)&__int128 v229 = v13;
                        *((void *)&v229 + 1) = v14 & 0xFFFFFFFFFFFFFFLL;
                        uint64_t v61 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v14) & 0xF,  (uint64_t)&v229,  HIBYTE(v14) & 0xF);
LABEL_124:
                        _StringGuts.appendInPlace(_:isASCII:)(v61, v62, v60);
                        swift_bridgeObjectRelease(v14);
                        goto LABEL_176;
                      }

                      if ((v13 & 0x1000000000000000LL) != 0)
                      {
                        swift_bridgeObjectRelease(v14);
                        id v101 = (id)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
                        uint64_t v102 = v13 & 0xFFFFFFFFFFFFLL;
                        uint64_t v103 = v13 & 0xFFFFFFFFFFFFLL;
LABEL_157:
                        uint64_t v148 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v102, (uint64_t)v101, v103);
                        _StringGuts.appendInPlace(_:isASCII:)(v148, v149, v13 < 0);
LABEL_160:
                        swift_bridgeObjectRelease_n(v14, 2LL);
                        goto LABEL_176;
                      }

                      id v101 = _StringObject.sharedUTF8.getter(v13, v14);
                      uint64_t v103 = v217;
                      swift_bridgeObjectRelease(v14);
                      if (v103 >= (v13 & 0xFFFFFFFFFFFFLL))
                      {
                        uint64_t v102 = v13 & 0xFFFFFFFFFFFFLL;
                        goto LABEL_157;
                      }

LABEL_248:
                      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
                    }

                    swift_bridgeObjectRelease(v14);
                    uint64_t v81 = v13;
                    unint64_t v82 = v14;
                    uint64_t v83 = v22;
LABEL_159:
                    _StringGuts._foreignAppendInPlace(_:)(v81, v82, 0LL, v83);
                    goto LABEL_160;
                  }

                  uint64_t v56 = _StringGuts.nativeCapacity.getter(v233, v234);
                  if ((v57 & 1) != 0) {
                    uint64_t v58 = 0LL;
                  }
                  else {
                    uint64_t v58 = v56;
                  }
                  if (v58 + 0x4000000000000000LL >= 0)
                  {
                    uint64_t v59 = 2 * v58;
                    if (v59 > v30) {
                      Swift::Int v30 = v59;
                    }
                    goto LABEL_68;
                  }

                  __break(1u);
                  goto LABEL_225;
                }

                unint64_t v16 = v234;
                if ((v234 & 0x2000000000000000LL) == 0)
                {
                  uint64_t v15 = v234;
LABEL_74:
                  int v63 = 1;
                  goto LABEL_129;
                }

                int v63 = 0;
                uint64_t v15 = v234;
              }

          uint64_t v152 = 0;
          char v155 = 1;
        }

LABEL_215:
            __break(1u);
LABEL_216:
            if ((v16 & 0x1000000000000000LL) != 0)
            {
              uint64_t v20 = _StringGuts._foreignConvertedToSmall()(v20, v15);
              unint64_t v16 = v220;
            }

            else
            {
              if ((v20 & 0x1000000000000000LL) != 0)
              {
                BOOL v199 = (unsigned __int8 *)((v16 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v200 = v20 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                BOOL v199 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v20, v15);
                uint64_t v200 = v25;
              }

              swift_bridgeObjectRetain(v15, v25, v26, v27);
              closure #1 in _StringGuts._convertedToSmall()(v199, v200, &v229);
              swift_bridgeObjectRelease(v15);
              unint64_t v16 = *((void *)&v229 + 1);
              uint64_t v20 = v229;
            }

              unint64_t v201 = HIBYTE(a2) & 0xF;
              uint64_t v202 = HIBYTE(v185) & 0xF;
              if ((unint64_t)(v202 + v201) <= 0xF)
              {
                if (v202)
                {
                  Swift::String::Index v203 = 0;
                  Swift::String::Index v204 = 0LL;
                  do
                  {
                    Swift::String::Index v205 = v201 + v204;
                    Swift::String::Index v206 = v204 + 1;
                    if (v204 >= 8) {
                      Swift::Int v207 = v185;
                    }
                    else {
                      Swift::Int v207 = v32;
                    }
                    Swift::String::Index v208 = v207 >> (v203 & 0x38);
                    Swift::String::Index v209 = (8 * v201 + v203) & 0x38;
                    Swift::String::Index v210 = (-255LL << v209) - 1;
                    Swift::String::Index v211 = (unint64_t)v208 << v209;
                    Swift::Int v212 = v211 | v210 & a2;
                    v213 = v211 | v210 & v3;
                    if (v205 < 8) {
                      uint64_t v3 = v213;
                    }
                    else {
                      a2 = v212;
                    }
                    v203 += 8;
                    Swift::String::Index v204 = v206;
                  }

                  while (v202 != v206);
                }

                swift_bridgeObjectRelease(v27);
                swift_bridgeObjectRelease(0xE100000000000000LL);
                return v3;
              }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v7, 1LL);
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          uint64_t v202 = xmmword_1817FFDA0;
          unint64_t v173 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v202, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v173, v174, 1);
          swift_bridgeObjectRelease(0xE100000000000000LL);
          return v203;
        }

        __break(1u);
LABEL_216:
        if ((v34 & 0x1000000000000000LL) != 0)
        {
          uint64_t v41 = _StringGuts._foreignConvertedToSmall()(v41, v34);
          Swift::Int v207 = v206;
          swift_bridgeObjectRelease(v34);
          uint64_t v34 = v207;
        }

        else
        {
          if ((v41 & 0x1000000000000000LL) != 0)
          {
            Swift::Int v198 = (unsigned __int8 *)((v34 & 0xFFFFFFFFFFFFFFFLL) + 32);
            BOOL v199 = v41 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            Swift::Int v198 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v41, v34);
          }

          closure #1 in _StringGuts._convertedToSmall()(v198, v199, &v212);
          swift_bridgeObjectRelease(v34);
          uint64_t v34 = *((void *)&v212 + 1);
          uint64_t v41 = v212;
        }

    Swift::String::Index v196 = 266LL;
LABEL_217:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v196,  0);
  }

  while (1)
  {
    swift_bridgeObjectRetain_n(v9, 3LL, v36, (char *)v37);
    v141._rawBits = v8 & 0xFFFFFFFFFFFF0000LL | 1;
    v142._rawBits = v39 & 0xFFFFFFFFFFFF0000LL | 1;
    v143._rawBits = _StringGuts.validateScalarRange(_:)(v141, v142, v7._rawBits, v9);
    if (v143._rawBits < 0x10000) {
      v143._rawBits |= 3;
    }
    uint64_t v11 = v7._rawBits;
    v7._rawBits = specialized Collection.count.getter(v143, v144, v7._rawBits, v9);
    swift_bridgeObjectRelease(v9);
    uint64_t v27 = v221;
    uint64_t v25 = v222;
    if ((v222 & 0x1000000000000000LL) == 0) {
      goto LABEL_40;
    }
LABEL_135:
    char v145 = String.UTF8View._foreignCount()();
    uint64_t v42 = v145 + v7._rawBits;
    if (!__OFADD__(v145, v7._rawBits)) {
      goto LABEL_45;
    }
LABEL_137:
    __break(1u);
LABEL_138:
    swift_bridgeObjectRetain_n(v8, 3LL, v40, (char *)v41);
    v146._rawBits = v9 & 0xFFFFFFFFFFFF0000LL | 1;
    v147._rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
    v148._rawBits = _StringGuts.validateScalarRange(_:)(v146, v147, v213, v8);
    if (v148._rawBits < 0x10000) {
      v148._rawBits |= 3;
    }
    uint64_t v13 = specialized Collection.count.getter(v148, v149, v213, v8);
    swift_bridgeObjectRelease(v7._rawBits);
    uint64_t v85 = v8;
LABEL_74:
    swift_bridgeObjectRelease(v7._rawBits);
    swift_bridgeObjectRelease(v85);
    uint64_t v86 = startingAt;
    if ((v7._rawBits & 0x1000000000000000LL) != 0) {
      uint64_t v86 = String.UTF8View._foreignCount()();
    }
    swift_bridgeObjectRelease(v7._rawBits);
    uint64_t v87 = __OFADD__(v86, v13);
    unint64_t v10 = v86 + v13;
    if (v87)
    {
      __break(1u);
LABEL_142:
      v203._rawBits = a2._rawBits;
      Swift::String::Index v206 = a3;
      uint64_t v150 = a6;
      unint64_t v14 = a5;
      Swift::String::Index v210 = a4;
      v151._rawBits = _StringGuts.scalarAlignSlow(_:)(a2)._rawBits;
      a3 = v206;
      a4 = v210;
      a5 = v14;
      a6 = v150;
      a2._rawBits = v203._rawBits & 0xC | v151._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v7._rawBits & 1) == 0)
      {
LABEL_143:
        v203._rawBits = a2._rawBits;
        Swift::Int v207 = a3;
        uint64_t v152 = a6;
        unint64_t v14 = a5;
        Swift::String::Index v211 = a4;
        v153._rawBits = _StringGuts.scalarAlignSlow(_:)(v7)._rawBits;
        a2._rawBits = v203._rawBits;
        a3 = v207;
        a4 = v211;
        a5 = v14;
        a6 = v152;
        v7._rawBits = v7._rawBits & 0xC | v153._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      }

      goto LABEL_18;
    }

    if ((v12 & ~v7._rawBits & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v7._rawBits & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v88 = v222;
      uint64_t v89 = _StringGuts.nativeUnusedCapacity.getter(v221, v222);
      uint64_t v12 = v199;
      if ((v90 & 1) != 0) {
        goto LABEL_216;
      }
      if (v10 < 16 && ((v88 & 0x2000000000000000LL) != 0 || v89 < v13)) {
        goto LABEL_91;
      }
    }

    else
    {
      uint64_t v12 = v199;
      if (v10 <= 15)
      {
        uint64_t v88 = v222;
LABEL_91:
        swift_bridgeObjectRelease(v8);
        unint64_t v95 = v221;
        swift_bridgeObjectRetain(v88, v96, v97, v98);
        unint64_t v99 = _StringGuts._convertedToSmall()(v95, v88);
        id v101 = v100;
        swift_bridgeObjectRelease(v88);
        v102._rawBits = v9 & 0xFFFFFFFFFFFF0000LL | 1;
        v103._rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
        v104._rawBits = _StringGuts.validateScalarRange(_:)(v102, v103, v213, v8);
        if (v104._rawBits < 0x10000) {
          v104._rawBits |= 3;
        }
        Swift::String::Index v106 = specialized String.init(_:)(v104, v105, v213, v8);
        Swift::String::Index v108 = v107;
        swift_bridgeObjectRelease(v8);
        unint64_t v109 = _StringGuts._convertedToSmall()(v106, v108);
        unint64_t v111 = v110;
        swift_bridgeObjectRelease(v108);
        uint64_t v112 = specialized _SmallString.init(_:appending:)(v99, v101, v109, v111);
        if ((v114 & 1) != 0) {
          goto LABEL_215;
        }
        uint64_t v115 = v112;
        unint64_t v116 = v113;
        swift_bridgeObjectRelease(v88);
        unint64_t v221 = v115;
        unint64_t v222 = v116;
LABEL_96:
        uint64_t v39 = v197;
        unint64_t v18 = v198;
        goto LABEL_97;
      }
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v10, v13);
    swift_bridgeObjectRelease(v8);
    if ((v8 & 0x1000000000000000LL) != 0)
    {
      _StringGuts._foreignAppendInPlace(_:)(v213, v8, v208, v42);
      swift_bridgeObjectRelease(v8);
      goto LABEL_96;
    }

    uint64_t v39 = v197;
    unint64_t v18 = v198;
    if ((v8 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v8);
      unint64_t v131 = HIBYTE(v8) & 0xF;
      uint64_t v215 = v213;
      uint64_t v216 = v8 & 0xFFFFFFFFFFFFFFLL;
      if (v131 < v42) {
        goto LABEL_181;
      }
      unint64_t v132 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v208, v42, (uint64_t)&v215, v131);
      _StringGuts.appendInPlace(_:isASCII:)(v132, v133, (v8 & 0x4000000000000000LL) != 0);
    }

    else
    {
      if ((v213 & 0x1000000000000000LL) != 0)
      {
        uint64_t v91 = (id)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
        unint64_t v92 = v213 & 0xFFFFFFFFFFFFLL;
        if ((v213 & 0xFFFFFFFFFFFFLL) < v42) {
          goto LABEL_181;
        }
      }

      else
      {
        uint64_t v91 = _StringObject.sharedUTF8.getter(v213, v8);
        unint64_t v92 = v182;
        if (v182 < v42) {
          goto LABEL_181;
        }
      }

      unint64_t v93 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v208, v42, (uint64_t)v91, v92);
      _StringGuts.appendInPlace(_:isASCII:)(v93, v94, v213 < 0);
      swift_bridgeObjectRelease(v8);
    }

      uint64_t v182 = v177 & 0xFFFFFFFFFFFFLL;
      goto LABEL_216;
    }

    if ((v176 & 0x2000000000000000LL) == 0) {
      goto LABEL_215;
    }
    uint64_t v182 = HIBYTE(v176) & 0xF;
    unint64_t v192 = v180 + v182;
    if (v180 + v182 > 0xF)
    {
LABEL_216:
      _StringGuts.append(_:)(v177, v176, 0LL, v182);
      swift_bridgeObjectRelease(v178);
      char v177 = v254._countAndFlagsBits;
      uint64_t v178 = (unint64_t)v254._object;
    }

    else
    {
      if (v182)
      {
        unint64_t v193 = 0;
        Swift::String::Index v194 = 0LL;
        Swift::String::Index v195 = (unint64_t)v254._object;
        do
        {
          Swift::String::Index v196 = v180 + v194;
          Swift::String::Index v197 = v194 + 1;
          if (v194 >= 8) {
            Swift::Int v198 = v176;
          }
          else {
            Swift::Int v198 = v177;
          }
          BOOL v199 = v198 >> (v193 & 0x38);
          uint64_t v200 = (8 * v180 + v193) & 0x38;
          unint64_t v201 = (-255LL << v200) - 1;
          uint64_t v202 = (unint64_t)v199 << v200;
          Swift::String::Index v203 = v202 | v201 & v195;
          Swift::String::Index v204 = v202 | v201 & v179;
          if (v196 < 8) {
            unint64_t v179 = v204;
          }
          else {
            Swift::String::Index v195 = v203;
          }
          v193 += 8;
          Swift::String::Index v194 = v197;
        }

        while (v182 != v197);
      }

      else
      {
        Swift::String::Index v195 = (unint64_t)v254._object;
      }

      swift_bridgeObjectRelease((uint64_t)v254._object);
      swift_bridgeObjectRelease(v178);
      unint64_t v223 = 0xA000000000000000LL;
      if (!(v179 & 0x8080808080808080LL | v195 & 0x80808080808080LL)) {
        unint64_t v223 = 0xE000000000000000LL;
      }
      uint64_t v178 = v223 & 0xFF00000000000000LL | (v192 << 56) | v195 & 0xFFFFFFFFFFFFFFLL;
      v254._countAndFlagsBits = v179;
      v254._object = (void *)v178;
      char v177 = v179;
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v254._object);
    v254._countAndFlagsBits = v177;
    v254._object = (void *)v178;
  }

  unint64_t v186 = HIBYTE(v178) & 0xF;
  if ((v178 & 0x2000000000000000LL) == 0) {
    unint64_t v186 = v177 & 0xFFFFFFFFFFFFLL;
  }
  if (v186 || (v177 & ~v178 & 0x2000000000000000LL) != 0)
  {
    if ((v178 & 0x2000000000000000LL) == 0
      || (unint64_t v187 = specialized _SmallString.init(_:appending:)(v177, v178, 0x29uLL, 0xE100000000000000LL), (v184 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v183, v184, v185);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      char v188 = v254._countAndFlagsBits;
      uint64_t v189 = (uint64_t)v254._object;
    }

    else
    {
      char v188 = v187;
      uint64_t v189 = v183;
      swift_bridgeObjectRelease(v178);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v178);
    uint64_t v189 = 0xE100000000000000LL;
    char v188 = 41LL;
  }

  unint64_t v190 = specialized static String.+ infix(_:_:)( 0xD00000000000001DLL,  0x8000000181800690LL | 0x8000000000000000LL,  v188,  v189);
  swift_bridgeObjectRelease(0x8000000181800690LL | 0x8000000000000000LL);
  swift_bridgeObjectRelease(v189);
  return v190;
}

      uint64_t v182 = v177 & 0xFFFFFFFFFFFFLL;
      goto LABEL_216;
    }

    if ((v176 & 0x2000000000000000LL) == 0) {
      goto LABEL_215;
    }
    uint64_t v182 = HIBYTE(v176) & 0xF;
    unint64_t v192 = v180 + v182;
    if (v180 + v182 > 0xF)
    {
LABEL_216:
      _StringGuts.append(_:)(v177, v176, 0LL, v182);
      swift_bridgeObjectRelease(v178);
      char v177 = v254._countAndFlagsBits;
      uint64_t v178 = (unint64_t)v254._object;
    }

    else
    {
      if (v182)
      {
        unint64_t v193 = 0;
        Swift::String::Index v194 = 0LL;
        Swift::String::Index v195 = (unint64_t)v254._object;
        do
        {
          Swift::String::Index v196 = v180 + v194;
          Swift::String::Index v197 = v194 + 1;
          if (v194 >= 8) {
            Swift::Int v198 = v176;
          }
          else {
            Swift::Int v198 = v177;
          }
          BOOL v199 = v198 >> (v193 & 0x38);
          uint64_t v200 = (8 * v180 + v193) & 0x38;
          unint64_t v201 = (-255LL << v200) - 1;
          uint64_t v202 = (unint64_t)v199 << v200;
          Swift::String::Index v203 = v202 | v201 & v195;
          Swift::String::Index v204 = v202 | v201 & v179;
          if (v196 < 8) {
            unint64_t v179 = v204;
          }
          else {
            Swift::String::Index v195 = v203;
          }
          v193 += 8;
          Swift::String::Index v194 = v197;
        }

        while (v182 != v197);
      }

      else
      {
        Swift::String::Index v195 = (unint64_t)v254._object;
      }

      swift_bridgeObjectRelease((uint64_t)v254._object);
      swift_bridgeObjectRelease(v178);
      unint64_t v223 = 0xA000000000000000LL;
      if (!(v179 & 0x8080808080808080LL | v195 & 0x80808080808080LL)) {
        unint64_t v223 = 0xE000000000000000LL;
      }
      uint64_t v178 = v223 & 0xFF00000000000000LL | (v192 << 56) | v195 & 0xFFFFFFFFFFFFFFLL;
      v254._countAndFlagsBits = v179;
      v254._object = (void *)v178;
      char v177 = v179;
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v254._object);
    v254._countAndFlagsBits = v177;
    v254._object = (void *)v178;
  }

  unint64_t v186 = HIBYTE(v178) & 0xF;
  if ((v178 & 0x2000000000000000LL) == 0) {
    unint64_t v186 = v177 & 0xFFFFFFFFFFFFLL;
  }
  if (v186 || (v177 & ~v178 & 0x2000000000000000LL) != 0)
  {
    if ((v178 & 0x2000000000000000LL) == 0
      || (unint64_t v187 = specialized _SmallString.init(_:appending:)(v177, v178, 0x29uLL, 0xE100000000000000LL), (v184 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v183, v184, v185);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      char v188 = v254._countAndFlagsBits;
      uint64_t v189 = (uint64_t)v254._object;
    }

    else
    {
      char v188 = v187;
      uint64_t v189 = v183;
      swift_bridgeObjectRelease(v178);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v178);
    uint64_t v189 = 0xE100000000000000LL;
    char v188 = 41LL;
  }

  unint64_t v190 = specialized static String.+ infix(_:_:)( 0xD000000000000016LL,  0x80000001818006B0LL | 0x8000000000000000LL,  v188,  v189);
  swift_bridgeObjectRelease(0x80000001818006B0LL | 0x8000000000000000LL);
  swift_bridgeObjectRelease(v189);
  return v190;
}

LABEL_171:
      unint64_t v92 = v16;
LABEL_172:
      swift_bridgeObjectRelease(v16);
      swift_bridgeObjectRelease(v14);
      unint64_t v160 = 0xA000000000000000LL;
      if (!(v15 & 0x8080808080808080LL | v92 & 0x80808080808080LL)) {
        unint64_t v160 = 0xE000000000000000LL;
      }
      unint64_t v161 = v160 & 0xFF00000000000000LL | (v21 << 56) | v92 & 0xFFFFFFFFFFFFFFLL;
LABEL_175:
      uint64_t v233 = v15;
      unint64_t v234 = v161;
      goto LABEL_176;
    }

              if ((v32 & 0x1000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v33);
                unint64_t v124 = (id)((v33 & 0xFFFFFFFFFFFFFFFLL) + 32);
                unint64_t v126 = v41;
              }

              else
              {
                unint64_t v124 = _StringObject.sharedUTF8.getter(v32, v33);
                unint64_t v126 = v250;
                swift_bridgeObjectRelease(v33);
                if (v126 < v41) {
                  goto LABEL_243;
                }
              }

              unint64_t v125 = v41;
              goto LABEL_123;
            }

            uint64_t v34 = v268;
            uint64_t v84 = _StringGuts.nativeUnusedCapacity.getter(v267, v268);
            if ((v85 & 1) == 0)
            {
              if (v83 <= 15)
              {
                if ((v34 & 0x2000000000000000LL) == 0)
                {
                  uint64_t v39 = v34;
                  if (v84 < v82) {
                    goto LABEL_162;
                  }
                  goto LABEL_127;
                }

                unint64_t v157 = 0;
                uint64_t v39 = v34;
LABEL_186:
                swift_bridgeObjectRelease_n(v33, 5LL);
                id v101 = v267;
                if (!v157) {
                  goto LABEL_187;
                }
                goto LABEL_250;
              }

              goto LABEL_127;
            }

            *(void *)a4 = v17;
            *(void *)(a4 + 8) = 2LL;
            unint64_t v18 = 1;
            break;
          default:
            goto LABEL_150;
        }
      }

      else
      {
LABEL_150:
        unint64_t v18 = 0;
        *(_BYTE *)a4 = 0;
      }

LABEL_225:
      swift_bridgeObjectRetain_n(v14, 5LL, v48, v49);
      v203._rawBits = 1LL;
      v204._rawBits = (v19 << 16) | 1;
      v205._rawBits = _StringGuts.validateScalarRange(_:)(v203, v204, v13, v14);
      if (v205._rawBits < 0x10000) {
        v205._rawBits |= 3;
      }
      Swift::Int v52 = specialized Collection.count.getter(v205, v206, v13, v14);
      swift_bridgeObjectRelease(v14);
      if ((v16 & 0x1000000000000000LL) != 0)
      {
LABEL_228:
        Swift::Int v207 = String.UTF8View._foreignCount()();
        int64_t v53 = v207 + v52;
        if (!__OFADD__(v207, v52))
        {
LABEL_54:
          if ((v15 & ~v16 & 0x2000000000000000LL) == 0
            || !swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v53 > 15) {
              goto LABEL_102;
            }
            unint64_t v16 = v234;
            if ((v234 & 0x2000000000000000LL) == 0)
            {
              uint64_t v15 = v234;
LABEL_127:
              int v104 = 1;
              goto LABEL_180;
            }

            int v104 = 0;
            uint64_t v15 = v234;
            goto LABEL_180;
          }

          uint64_t v15 = v234;
          int64_t v54 = _StringGuts.nativeUnusedCapacity.getter(v233, v234);
          if ((v55 & 1) == 0)
          {
            if (v53 >= 16) {
              goto LABEL_102;
            }
            if ((v15 & 0x2000000000000000LL) == 0)
            {
              unint64_t v16 = v15;
              if (v54 < v52) {
                goto LABEL_127;
              }
LABEL_102:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v53, v52);
              swift_bridgeObjectRelease_n(v14, 4LL);
              if ((v14 & 0x1000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v14);
                uint64_t v81 = v13;
                unint64_t v82 = v14;
                uint64_t v83 = v19;
                goto LABEL_159;
              }

              if (v31)
              {
                swift_bridgeObjectRelease_n(v14, 2LL);
                uint64_t v60 = (v14 >> 62) & 1;
                *(void *)&__int128 v229 = v13;
                *((void *)&v229 + 1) = v14 & 0xFFFFFFFFFFFFFFLL;
                uint64_t v85 = v20;
                uint64_t v86 = v20;
LABEL_123:
                uint64_t v61 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v85, (uint64_t)&v229, v86);
                goto LABEL_124;
              }

              goto LABEL_154;
            }

            int v104 = 0;
            unint64_t v16 = v15;
LABEL_180:
            swift_bridgeObjectRelease_n(v14, 5LL);
            uint64_t v20 = v233;
            if (!v104) {
              goto LABEL_181;
            }
            goto LABEL_237;
          }

              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            }

                LOBYTE(v24) = 4;
                goto LABEL_67;
              }

              break;
            default:
              if (v11 < 0xA)
              {
                LOBYTE(v24) = 1;
                uint64_t v25 = 1;
                goto LABEL_67;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                uint64_t v25 = 1;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_195;
                }
                goto LABEL_226;
              }

              uint64_t v25 = 1;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  unint64_t v18 = 1;
                  goto LABEL_9;
                }

LABEL_250:
          unint64_t v219 = 258LL;
LABEL_251:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v219,  0);
        }

        goto LABEL_230;
      }

              char v120 = _StringObject.sharedUTF8.getter(v5, v13);
              unint64_t v122 = v238;
              swift_bridgeObjectRelease(v13);
              if (v122 < v244) {
                goto LABEL_253;
              }
              uint64_t v4 = v246;
              uint64_t v7 = v247;
              uint64_t v3 = v251;
              uint64_t v121 = v244;
LABEL_121:
              unint64_t v123 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v121, (uint64_t)v120, v122);
              _StringGuts.appendInPlace(_:isASCII:)(v123, v124, v5 < 0);
              swift_bridgeObjectRelease_n(v13, 2LL);
              goto LABEL_128;
            }

LABEL_231:
      swift_bridgeObjectRetain_n(v14, 5LL, v50, v51);
      v208._rawBits = 1LL;
      v209._rawBits = (v20 << 16) | 1;
      v210._rawBits = _StringGuts.validateScalarRange(_:)(v208, v209, v13, v14);
      if (v210._rawBits < 0x10000) {
        v210._rawBits |= 3;
      }
      Swift::Int v76 = specialized Collection.count.getter(v210, v211, v13, v14);
      swift_bridgeObjectRelease(v14);
      if ((v19 & 0x1000000000000000LL) != 0)
      {
LABEL_234:
        Swift::Int v212 = String.UTF8View._foreignCount()();
        int64_t v77 = v212 + v76;
        if (!__OFADD__(v212, v76)) {
          goto LABEL_91;
        }
        goto LABEL_236;
      }

LABEL_154:
        if ((v13 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v14);
          id v101 = (id)((v14 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v103 = v22;
        }

        else
        {
          id v101 = _StringObject.sharedUTF8.getter(v13, v14);
          uint64_t v103 = v218;
          swift_bridgeObjectRelease(v14);
          if (v103 < v22) {
            goto LABEL_248;
          }
        }

        uint64_t v102 = v22;
        goto LABEL_157;
      }

                    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v149, v148);
                    uint64_t v171 = v88 + 0x7FFFFFFFFFFFFFE0LL;
                    if (((v88 + 0x7FFFFFFFFFFFFFE0LL) & 0x1000000000000000LL) != 0)
                    {
                      unint64_t v180 = v171 | 0x8000000000000000LL;
                      _StringGuts._foreignAppendInPlace(_:)(0xD0000000000000AALL, v171 | 0x8000000000000000LL, 0LL, v6);
                      char v177 = v180;
LABEL_165:
                      swift_bridgeObjectRelease_n(v177, 2LL);
                    }

                    else
                    {
                      uint64_t v172 = v171 | 0x8000000000000000LL;
                      unint64_t v173 = ((v171 | 0x8000000000000000LL) >> 62) & 1;
                      if ((v172 & 0x2000000000000000LL) != 0) {
                        uint64_t v174 = v173;
                      }
                      else {
                        uint64_t v174 = 1;
                      }
                      swift_bridgeObjectRelease_n(v172, 5LL);
                      if ((v172 & 0x2000000000000000LL) == 0)
                      {
                        unint64_t v175 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v6,  ((v88 + 0x7FFFFFFFFFFFFFE0LL) & 0xFFFFFFFFFFFFFFFLL) + 32,  170LL);
                        _StringGuts.appendInPlace(_:isASCII:)(v175, v176, v174);
                        char v177 = (v88 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
                        goto LABEL_165;
                      }

                      swift_bridgeObjectRelease((v88 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
                      Swift::Int v212 = 0xD0000000000000AALL;
                      v213 = (v88 + 0x7FFFFFFFFFFFFFE0LL) & 0xFFFFFFFFFFFFFFLL;
                      unint64_t v193 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v6,  (uint64_t)&v212,  ((unint64_t)(v88 + 0x7FFFFFFFFFFFFFE0LL) >> 56) & 0xF);
                      _StringGuts.appendInPlace(_:isASCII:)(v193, v194, v174);
                      swift_bridgeObjectRelease((v88 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
                    }

            swift_bridgeObjectRelease(object);
            countAndFlagsBits = 0LL;
            uint64_t v7 = (void *)0xE000000000000000LL;
            goto LABEL_118;
          }

          char v38 = v26;
LABEL_105:
          uint64_t v60 = specialized _SmallString.init(_:appending:)(v38, v17, v4, object);
          if ((v62 & 1) == 0)
          {
            int v63 = v60;
            uint64_t v64 = v61;
            swift_bridgeObjectRelease(v17);
            swift_bridgeObjectRelease(object);
            v88._countAndFlagsBits = v63;
            v88._object = v64;
            object = (unint64_t)v64;
            uint64_t v4 = v63;
            goto LABEL_109;
          }

          goto LABEL_107;
        }

        if (*v23 == 0x2E6E69746C697542LL && *(void *)((char *)v23 + 3) == 0x746E492E6E69746CLL)
        {
LABEL_169:
          int64_t v77 = 11LL;
          if (v22 < 0xB) {
            int64_t v77 = v22;
          }
          uint64_t v78 = (char *)v23 + v77;
          int64_t v79 = v22 - v77;
          char v80 = v6;
          uint64_t v81 = 105;
        }

        else
        {
          if (v22 < 0xE)
          {
LABEL_163:
            if (*v23 != 0x2E6E69746C697542LL || *(void *)((char *)v23 + 3) != 0x6365562E6E69746CLL)
            {
LABEL_167:
              *(_DWORD *)a3 = 9;
              *(void *)(a3 + 8) = v3;
              Swift::Int v76 = 949;
LABEL_168:
              *(_DWORD *)(a3 + 16) = v76;
              return this;
            }

            unint64_t v82 = 11LL;
            if (v22 < 0xB) {
              unint64_t v82 = v22;
            }
            uint64_t v83 = (char *)v23 + v82;
            uint64_t v84 = v22 - v82;
            if (v22 >= 0xC)
            {
              uint64_t v91 = memchr(v83, 120, v22 - v82);
              uint64_t v85 = -1LL;
              if (v91) {
                uint64_t v85 = v91 - v83;
              }
            }

            else
            {
              uint64_t v85 = -1LL;
            }

            unint64_t v92 = v84 > v85;
            if (v84 >= v85) {
              unint64_t v93 = v85;
            }
            else {
              unint64_t v93 = v84;
            }
            BOOL v94 = (unsigned __int16 *)&v83[v93];
            unint64_t v95 = v92;
            if (v92) {
              BOOL v94 = (unsigned __int16 *)((char *)v94 + 1);
            }
            unint64_t v147 = v94;
            uint64_t v148 = v84 - v93 - v95;
            if (v148 == 10
              && ((v96 = *(void *)v94, uint64_t v97 = v94[4], v96 == 0x746E696F50776152LL) ? (v98 = v97 == 29285) : (v98 = 0),
                  v98))
            {
              uint64_t v102 = v6;
              uint64_t v103 = 112;
            }

            else
            {
              if (__swift::__runtime::llvm::StringRef::consume_front( (const void **)&v147,  "FPIEEE",  6uLL))
              {
                unint64_t v99 = v6;
                unint64_t v100 = 102;
              }

              else
              {
                this = __swift::__runtime::llvm::StringRef::consume_front((const void **)&v147, "Int", 3uLL);
                if (!(_DWORD)this)
                {
                  *(_DWORD *)a3 = 8;
                  *(void *)(a3 + 8) = v3;
                  Swift::Int v76 = 945;
                  goto LABEL_168;
                }

                unint64_t v99 = v6;
                unint64_t v100 = 105;
              }

              id v101 = swift::Demangle::__runtime::RemanglerBuffer::operator<<(v99, v100);
              swift::Demangle::__runtime::CharVector::append(v101, v147, v148, v101[2]);
              uint64_t v102 = v101;
              uint64_t v103 = 95;
            }

            swift::Demangle::__runtime::RemanglerBuffer::operator<<(v102, v103);
            swift::Demangle::__runtime::CharVector::append(v6, "Bv", 2uLL, *(void **)(v4 + 12744));
            uint64_t v88 = *(char **)(v4 + 12744);
            uint64_t v87 = v6;
            uint64_t v89 = v83;
            unint64_t v90 = v93;
            goto LABEL_213;
          }

LABEL_236:
      __break(1u);
LABEL_237:
      if ((v16 & 0x1000000000000000LL) != 0)
      {
        uint64_t v20 = _StringGuts._foreignConvertedToSmall()(v20, v15);
        unint64_t v16 = v223;
      }

      else
      {
        if ((v20 & 0x1000000000000000LL) != 0)
        {
          v213 = (unsigned __int8 *)((v16 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v214 = v20 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          v213 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v20, v15);
          uint64_t v214 = v73;
        }

        swift_bridgeObjectRetain(v15, v73, v74, v75);
        closure #1 in _StringGuts._convertedToSmall()(v213, v214, &v229);
        swift_bridgeObjectRelease(v15);
        unint64_t v16 = *((void *)&v229 + 1);
        uint64_t v20 = v229;
      }

        swift_bridgeObjectRetain_n(v33, 5LL, v64, v65);
        v235._rawBits = 1LL;
        v236._rawBits = (v38 << 16) | 1;
        v237._rawBits = _StringGuts.validateScalarRange(_:)(v235, v236, v32, v33);
        if (v237._rawBits < 0x10000) {
          v237._rawBits |= 3;
        }
        unint64_t v82 = specialized Collection.count.getter(v237, v238, v32, v33);
        swift_bridgeObjectRelease(v33);
        if ((v39 & 0x1000000000000000LL) != 0)
        {
LABEL_239:
          uint64_t v239 = String.UTF8View._foreignCount()();
          uint64_t v83 = v239 + v82;
          if (!__OFADD__(v239, v82))
          {
LABEL_76:
            if ((v34 & ~v39 & 0x2000000000000000LL) == 0
              || !swift_isUniquelyReferenced_nonNull_native(v39 & 0xFFFFFFFFFFFFFFFLL))
            {
              if (v83 <= 15)
              {
                uint64_t v39 = v268;
                if ((v268 & 0x2000000000000000LL) == 0)
                {
                  uint64_t v34 = v268;
LABEL_162:
                  unint64_t v157 = 1;
                  goto LABEL_186;
                }

                unint64_t v157 = 0;
                uint64_t v34 = v268;
                goto LABEL_186;
              }

        unint64_t v190 = 258LL;
        goto LABEL_237;
      }
    }

    else
    {
      unint64_t v21 = __OFADD__(v146, 1LL);
      uint64_t v7 = v146 + 1;
      if (!v21) {
        goto LABEL_183;
      }
    }

    __break(1u);
LABEL_217:
    if ((v5 & 0x1000000000000000LL) != 0)
    {
      uint64_t v12 = _StringGuts._foreignConvertedToSmall()(v12, v5);
      unint64_t v192 = v191;
      swift_bridgeObjectRelease(v5);
      uint64_t v5 = v192;
    }

    else
    {
      if ((v12 & 0x1000000000000000LL) != 0)
      {
        unint64_t v183 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v184 = v12 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v183 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v12, v5);
      }

      closure #1 in _StringGuts._convertedToSmall()(v183, v184, &v198);
      swift_bridgeObjectRelease(v5);
      uint64_t v5 = *((void *)&v198 + 1);
      uint64_t v12 = v198;
    }

              unint64_t v147 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 128);
              swift::Demangle::__runtime::Node::addChild(v147, v136, a2, v148, v149);
              Swift::String::Index v136 = (swift::Demangle::__runtime::Node *)v147;
              goto LABEL_237;
            }
          }

          else
          {
            unint64_t v141 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode( a2,  0xD100D0007BuLL >> (16 * v140));
            swift::Demangle::__runtime::Node::addChild(v141, v136, a2, v142, v143);
            Swift::String::Index v136 = (swift::Demangle::__runtime::Node *)v141;
            if ((v134 & 0x400) != 0) {
              goto LABEL_232;
            }
          }

          break;
        }

        if ((v134 & 0x800) == 0) {
          goto LABEL_237;
        }
        goto LABEL_236;
      case 771:
        int64_t v53 = *(unsigned int *)(a1 + 12);
        unint64_t v219 = (uint64_t *)(a1 + 16);
        int64_t v54 = (void *)(a1 + 16 + 8 * (((unint64_t)*(unsigned int *)(a1 + 8) >> 30) & 1));
        char v55 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 235);
        unint64_t v220 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 190);
        swift::Demangle::__runtime::Node::addChild(v220, v55, a2, v56, v57);
        unint64_t v221 = v53;
        if (!(_DWORD)v53) {
          goto LABEL_202;
        }
        uint64_t v58 = 8 * v53;
        uint64_t v59 = v54;
        break;
      case 772:
        uint64_t v41 = _swift_buildDemanglingForMetadata(*(void *)(a1 + 8), a2);
        if (!v41) {
          goto LABEL_349;
        }
        uint64_t v42 = (swift::Demangle::__runtime::Node *)v41;
        uint64_t v43 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
        swift::Demangle::__runtime::Node::addChild(v43, v42, a2, v44, v45);
        uint64_t v46 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 145);
        Node = v46;
        goto LABEL_111;
      case 773:
        Name = class_getName(*(Class *)(a1 + 8));
        uint64_t v61 = *((void *)a2 + 1);
        if (!v61 || (unint64_t)(v61 + 3) > *((void *)a2 + 2))
        {
          size_t v62 = 2LL * *((void *)a2 + 4);
          if (v62 <= 4) {
            size_t v62 = 4LL;
          }
          *((void *)a2 + 4) = v62;
          int v63 = v62 + 8;
          uint64_t v64 = malloc(v62 + 8);
          *uint64_t v64 = *((void *)a2 + 3);
          uint64_t v61 = (uint64_t)(v64 + 1);
          *((void *)a2 + 2) = (char *)v64 + v63;
          *((void *)a2 + 3) = v64;
        }

        *((void *)a2 + 1) = v61 + 3;
        *(_BYTE *)(v61 + 2) = 67;
        *(_WORD *)uint64_t v61 = 24415;
        uint64_t v65 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( a2,  153,  v61,  3LL);
        Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 24);
        swift::Demangle::__runtime::Node::addChild(Node, v65, a2, v66, v67);
        if (Name)
        {
          unint64_t v68 = strlen(Name);
          uint64_t v69 = v68;
          if (v68)
          {
            unint64_t v70 = (char *)*((void *)a2 + 1);
            if (!v70 || (unint64_t)&v70[v68] > *((void *)a2 + 2))
            {
              unint64_t v71 = 2LL * *((void *)a2 + 4);
              if (v71 <= v68 + 1) {
                unint64_t v71 = v68 + 1;
              }
              *((void *)a2 + 4) = v71;
              unint64_t v72 = v71 + 8;
              uint64_t v73 = malloc(v71 + 8);
              uint64_t v74 = (char *)v73 + v72;
              *uint64_t v73 = *((void *)a2 + 3);
              unint64_t v70 = (char *)(v73 + 1);
              *((void *)a2 + 2) = v74;
              *((void *)a2 + 3) = v73;
            }

            *((void *)a2 + 1) = &v70[v69];
            memmove(v70, Name, v69);
LABEL_218:
            uint64_t v49 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( a2,  101,  (uint64_t)v70,  v69);
            uint64_t v46 = Node;
LABEL_219:
            swift::Demangle::__runtime::Node::addChild(v46, v49, a2, v47, v48);
            return Node;
          }
        }

        else
        {
          uint64_t v69 = 0LL;
        }

        unint64_t v70 = 0LL;
        goto LABEL_218;
      case 774:
        uint64_t v75 = _swift_buildDemanglingForMetadata(*(void *)(a1 + 8), a2);
        if (!v75) {
          goto LABEL_349;
        }
        Swift::Int v76 = (swift::Demangle::__runtime::Node *)v75;
        uint64_t v46 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 69);
        Node = v46;
        uint64_t v49 = v76;
        goto LABEL_219;
      case 775:
        return Node;
      default:
        goto LABEL_349;
    }

    while (1)
    {
      uint64_t v81 = *v59 & 0xFFFFFFFFFFFFFFFELL;
      if ((*v59 & 1) == 0)
      {
        unint64_t v82 = swift::_buildDemanglingForContext((uint64_t **)v81, 0LL, 0LL, a2);
        if (!v82) {
          goto LABEL_349;
        }
        char v80 = v82;
        goto LABEL_144;
      }

      uint64_t v85 = v5;
      uint64_t v86 = (unsigned int *)v55;
      uint64_t v87 = *(_WORD **)(v81 + 8);
      if (v87) {
        uint64_t v88 = strlen(*(const char **)(v81 + 8));
      }
      else {
        uint64_t v88 = 0LL;
      }
      int v226 = 0LL;
      uint64_t v89 = swift::Demangle::__runtime::Demangler::demangleSymbol((uint64_t)a2, v87, v88, v225);
      unint64_t v90 = v226;
      if (v226 == v225)
      {
        unint64_t v90 = v225;
        uint64_t v91 = 4LL;
      }

      else
      {
        if (!v226) {
          goto LABEL_157;
        }
        uint64_t v91 = 5LL;
      }

      (*(void (**)(void))(*v90 + 8 * v91))();
LABEL_157:
      if (!v89)
      {
        unint64_t v93 = *((void *)a2 + 1);
        if (!v93 || (unint64_t)(v93 + 3) > *((void *)a2 + 2))
        {
          BOOL v94 = 2LL * *((void *)a2 + 4);
          if (v94 <= 4) {
            BOOL v94 = 4LL;
          }
          *((void *)a2 + 4) = v94;
          unint64_t v95 = v94 + 8;
          char v96 = malloc(v94 + 8);
          char *v96 = *((void *)a2 + 3);
          unint64_t v93 = (uint64_t)(v96 + 1);
          *((void *)a2 + 2) = (char *)v96 + v95;
          *((void *)a2 + 3) = v96;
        }

        *((void *)a2 + 1) = v93 + 3;
        *(_BYTE *)(v93 + 2) = 67;
        *(_WORD *)unint64_t v93 = 24415;
        uint64_t v97 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( a2,  153,  v93,  3LL);
        unint64_t v98 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 180);
        swift::Demangle::__runtime::Node::addChild(v98, v97, a2, v99, v100);
        if (v88)
        {
          id v101 = (char *)*((void *)a2 + 1);
          if (!v101 || (unint64_t)&v101[v88] > *((void *)a2 + 2))
          {
            uint64_t v102 = 2LL * *((void *)a2 + 4);
            if (v102 <= v88 + 1) {
              uint64_t v102 = v88 + 1;
            }
            *((void *)a2 + 4) = v102;
            uint64_t v103 = v102 + 8;
            int v104 = malloc(v102 + 8);
            Swift::String::Index v105 = (char *)v104 + v103;
            char *v104 = *((void *)a2 + 3);
            id v101 = (char *)(v104 + 1);
            *((void *)a2 + 2) = v105;
            *((void *)a2 + 3) = v104;
          }

          *((void *)a2 + 1) = &v101[v88];
          memmove(v101, v87, v88);
        }

        else
        {
          id v101 = 0LL;
        }

        Swift::String::Index v106 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( a2,  101,  (uint64_t)v101,  v88);
        swift::Demangle::__runtime::Node::addChild(v98, v106, a2, v107, v108);
        unint64_t v109 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
        swift::Demangle::__runtime::Node::addChild(v109, (swift::Demangle::__runtime::Node *)v98, a2, v110, v111);
        char v55 = (swift::Demangle::__runtime::Node *)v86;
        swift::Demangle::__runtime::Node::addChild(v86, (swift::Demangle::__runtime::Node *)v109, a2, v112, v113);
        uint64_t v5 = v85;
        goto LABEL_145;
      }

      unint64_t v92 = *(unsigned __int8 *)(v89 + 18);
      if ((v92 - 1) < 2)
      {
        char v55 = (swift::Demangle::__runtime::Node *)v86;
        uint64_t v5 = v85;
LABEL_175:
        char v80 = *(unsigned int **)v89;
        goto LABEL_180;
      }

      char v55 = (swift::Demangle::__runtime::Node *)v86;
      if (v92 == 5)
      {
        uint64_t v5 = v85;
        if (*(_DWORD *)(v89 + 8))
        {
          uint64_t v89 = *(void *)v89;
          goto LABEL_175;
        }

        char v80 = 0LL;
      }

      else
      {
        char v80 = 0LL;
        uint64_t v5 = v85;
      }

unint64_t specialized String.init<A>(describing:)(Swift::UInt64 a1)
{
  v22[0] = 0LL;
  v22[1] = 0xE000000000000000LL;
  uint64_t v20 = &type metadata for UnsafeMutableRawPointer;
  v19[0] = a1;
  uint64_t v2 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm( v19,  (uint64_t)&type metadata for UnsafeMutableRawPointer);
  DynamicType = (void *)swift_getDynamicType(v2, &type metadata for UnsafeMutableRawPointer.Kind, 1);
  BOOL isOptionalType = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(v19);
  if (isOptionalType)
  {
    unint64_t v5 = specialized _Pointer.debugDescription.getter(a1);
    swift_bridgeObjectRelease(0xE000000000000000LL);
  }

  else
  {
    Swift::UInt64 v18 = a1;
    uint64_t v6 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast( (char *)&v15,  (uint64_t *)&v18,  (swift *)&type metadata for UnsafeMutableRawPointer,  v6,  6uLL))
    {
      outlined init with take of MirrorPath(&v15, (uint64_t)v19);
      uint64_t v7 = v20;
      uint64_t v8 = v21;
      __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
      ((void (*)(void *, ValueMetadata *, _UNKNOWN **, ValueMetadata *, _UNKNOWN **))v8[1])( v22,  &type metadata for String,  &protocol witness table for String,  v7,  v8);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
      return v22[0];
    }

    else
    {
      uint64_t v17 = 0LL;
      __int128 v15 = 0u;
      __int128 v16 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v15,  &demangling cache variable for type metadata for TextOutputStreamable?);
      Swift::UInt64 v18 = a1;
      uint64_t v9 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
      if (swift_dynamicCast( (char *)&v15,  (uint64_t *)&v18,  (swift *)&type metadata for UnsafeMutableRawPointer,  v9,  6uLL))
      {
        outlined init with take of MirrorPath(&v15, (uint64_t)v19);
        unint64_t v10 = v20;
        uint64_t v11 = v21;
        __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
        unint64_t v12 = ((uint64_t (*)(ValueMetadata *, _UNKNOWN **))v11[1])(v10, v11);
      }

      else
      {
        uint64_t v17 = 0LL;
        __int128 v15 = 0u;
        __int128 v16 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v15,  &demangling cache variable for type metadata for CustomStringConvertible?);
        uint64_t v20 = &type metadata for UnsafeMutableRawPointer;
        unint64_t v21 = &protocol witness table for UnsafeMutableRawPointer;
        v19[0] = a1;
        uint64_t v13 = __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)&type metadata for UnsafeMutableRawPointer);
        unint64_t v12 = specialized _Pointer.debugDescription.getter(*v13);
      }

      unint64_t v5 = v12;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
    }
  }

  return v5;
}

uint64_t specialized String.init<A>(describing:)(void *a1)
{
  v22[0] = 0LL;
  v22[1] = 0xE000000000000000LL;
  uint64_t v20 = &type metadata for UnsafeRawPointer;
  v19[0] = (uint64_t)a1;
  uint64_t v2 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm( v19,  (uint64_t)&type metadata for UnsafeRawPointer);
  DynamicType = (void *)swift_getDynamicType(v2, &type metadata for UnsafeRawPointer.Kind, 1);
  BOOL isOptionalType = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(v19);
  if (isOptionalType)
  {
    uint64_t countAndFlagsBits = _rawPointerToString(_:)(a1)._countAndFlagsBits;
    swift_bridgeObjectRelease(0xE000000000000000LL);
  }

  else
  {
    Swift::UInt64 v18 = a1;
    uint64_t v6 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast( (char *)&v15,  (uint64_t *)&v18,  (swift *)&type metadata for UnsafeRawPointer,  v6,  6uLL))
    {
      outlined init with take of MirrorPath(&v15, (uint64_t)v19);
      uint64_t v7 = v20;
      uint64_t v8 = v21;
      __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
      ((void (*)(void *, ValueMetadata *, _UNKNOWN **, ValueMetadata *, _UNKNOWN **))v8[1])( v22,  &type metadata for String,  &protocol witness table for String,  v7,  v8);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
      return v22[0];
    }

    else
    {
      uint64_t v17 = 0LL;
      __int128 v15 = 0u;
      __int128 v16 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v15,  &demangling cache variable for type metadata for TextOutputStreamable?);
      Swift::UInt64 v18 = a1;
      uint64_t v9 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
      if (swift_dynamicCast( (char *)&v15,  (uint64_t *)&v18,  (swift *)&type metadata for UnsafeRawPointer,  v9,  6uLL))
      {
        outlined init with take of MirrorPath(&v15, (uint64_t)v19);
        unint64_t v10 = v20;
        uint64_t v11 = v21;
        __swift_project_boxed_opaque_existential_0Tm(v19, (uint64_t)v20);
        uint64_t v12 = ((uint64_t (*)(ValueMetadata *, _UNKNOWN **))v11[1])(v10, v11);
      }

      else
      {
        uint64_t v17 = 0LL;
        __int128 v15 = 0u;
        __int128 v16 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v15,  &demangling cache variable for type metadata for CustomStringConvertible?);
        uint64_t v20 = &type metadata for UnsafeRawPointer;
        unint64_t v21 = &protocol witness table for UnsafeRawPointer;
        v19[0] = (uint64_t)a1;
        uint64_t v13 = (Builtin::RawPointer *)__swift_project_boxed_opaque_existential_0Tm( v19,  (uint64_t)&type metadata for UnsafeRawPointer);
        uint64_t v12 = _rawPointerToString(_:)(*v13)._countAndFlagsBits;
      }

      uint64_t countAndFlagsBits = v12;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      __swift_destroy_boxed_opaque_existential_1Tm(v19);
    }
  }

  return countAndFlagsBits;
}

uint64_t String.init<A>(describing:)(uint64_t a1, swift *a2)
{
  uint64_t v4 = *((void *)a2 - 1);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (uint64_t *)((char *)&v258 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v8 = MEMORY[0x1895F8858](v5);
  unint64_t v10 = (uint64_t *)((char *)&v258 - v9);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (uint64_t *)((char *)&v258 - v12);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  __int128 v16 = (uint64_t *)((char *)&v258 - v15);
  MEMORY[0x1895F8858](v14);
  Swift::UInt64 v18 = (uint64_t *)((char *)&v258 - v17);
  unint64_t v267 = 0LL;
  unint64_t v268 = 0xE000000000000000LL;
  unint64_t v262 = (uint64_t *)v19;
  uint64_t v20 = __swift_allocate_boxed_opaque_existential_0Tm(&v260);
  unint64_t v21 = *(void (**)(uint64_t *, uint64_t, swift *))(v4 + 16);
  v21(v20, a1, a2);
  uint64_t v22 = v262;
  uint64_t v23 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v260, (uint64_t)v262);
  DynamicType = (void *)swift_getDynamicType(v23, v22, 1);
  LODWORD(v22) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v260);
  if ((_DWORD)v22)
  {
    (*(void (**)(uint64_t *, uint64_t, swift *))(v4 + 32))(v18, a1, a2);
    uint64_t v25 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v260, v18, a2, v25, 7uLL);
    uint64_t v26 = (uint64_t)v262;
    uint64_t v27 = v263;
    __swift_project_boxed_opaque_existential_0Tm(&v260, (uint64_t)v262);
    uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v27 + 8))(v26, v27);
    uint64_t v32 = v28;
    unint64_t v33 = v29;
    uint64_t v34 = v267;
    unint64_t v35 = v268;
    unint64_t v36 = HIBYTE(v268) & 0xF;
    if ((v268 & 0x2000000000000000LL) != 0) {
      unint64_t v37 = HIBYTE(v268) & 0xF;
    }
    else {
      unint64_t v37 = v267 & 0xFFFFFFFFFFFFLL;
    }
    if (v37 || (v267 & ~v268 & 0x2000000000000000LL) != 0)
    {
      uint64_t v38 = v29 & 0x2000000000000000LL;
      unint64_t v39 = HIBYTE(v29) & 0xF;
      if ((v268 & 0x2000000000000000LL) == 0 || !v38) {
        goto LABEL_11;
      }
      unint64_t v40 = v36 + v39;
      if (v36 + v39 > 0xF)
      {
        uint64_t v38 = 1LL;
LABEL_11:
        uint64_t v259 = v28 & 0xFFFFFFFFFFFFLL;
        if (v38) {
          uint64_t v41 = HIBYTE(v29) & 0xF;
        }
        else {
          uint64_t v41 = v28 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v29, 2LL, v30, v31);
        if ((v33 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRetain_n(v33, 5LL, v42, v43);
          v226._rawBits = 1LL;
          v227._rawBits = (v41 << 16) | 1;
          v228._rawBits = _StringGuts.validateScalarRange(_:)(v226, v227, v32, v33);
          if (v228._rawBits < 0x10000) {
            v228._rawBits |= 3;
          }
          Swift::Int v47 = specialized Collection.count.getter(v228, v229, v32, v33);
          swift_bridgeObjectRelease(v33);
          if ((v35 & 0x1000000000000000LL) == 0)
          {
LABEL_16:
            BOOL v48 = __OFADD__(v37, v47);
            Swift::Int v49 = v37 + v47;
            if (!v48)
            {
LABEL_17:
              if ((v34 & ~v35 & 0x2000000000000000LL) != 0
                && swift_isUniquelyReferenced_nonNull_native(v35 & 0xFFFFFFFFFFFFFFFLL))
              {
                uint64_t v50 = v267;
                uint64_t v34 = v268;
                int64_t v51 = _StringGuts.nativeUnusedCapacity.getter(v267, v268);
                if ((v52 & 1) != 0) {
                  goto LABEL_261;
                }
                if (v49 > 15) {
                  goto LABEL_32;
                }
                if ((v34 & 0x2000000000000000LL) == 0)
                {
                  unint64_t v35 = v34;
                  if (v51 < v47) {
                    goto LABEL_59;
                  }
                  goto LABEL_32;
                }

                int v73 = 0;
                unint64_t v35 = v34;
              }

              else
              {
                if (v49 >= 16)
                {
                  uint64_t v50 = v267;
                  uint64_t v34 = v268;
LABEL_32:
                  int64_t v56 = _StringGuts.nativeUnusedCapacity.getter(v50, v34);
                  uint64_t v59 = (v57 & 1) == 0 && v56 >= v47;
                  if ((v50 & ~v34 & 0x2000000000000000LL) != 0
                    && swift_isUniquelyReferenced_nonNull_native(v34 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if ((v59 & 1) != 0) {
                      goto LABEL_52;
                    }
                  }

                  else if ((v59 & 1) != 0)
                  {
LABEL_51:
                    _StringGuts.grow(_:)(v49);
LABEL_52:
                    swift_bridgeObjectRelease_n(v33, 4LL);
                    if ((v33 & 0x1000000000000000LL) == 0)
                    {
                      if (v38)
                      {
                        swift_bridgeObjectRelease_n(v33, 2LL);
                        uint64_t v69 = (v33 >> 62) & 1;
                        *(void *)&__int128 v264 = v32;
                        *((void *)&v264 + 1) = v33 & 0xFFFFFFFFFFFFFFLL;
                        unint64_t v70 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v33) & 0xF,  (uint64_t)&v264,  HIBYTE(v33) & 0xF);
LABEL_55:
                        LOBYTE(v72) = v69;
LABEL_56:
                        _StringGuts.appendInPlace(_:isASCII:)(v70, v71, v72);
                        swift_bridgeObjectRelease(v33);
                        goto LABEL_204;
                      }

                      if ((v32 & 0x1000000000000000LL) != 0)
                      {
                        swift_bridgeObjectRelease(v33);
                        id v124 = (id)((v33 & 0xFFFFFFFFFFFFFFFLL) + 32);
                        uint64_t v125 = v259;
                        uint64_t v126 = v259;
LABEL_123:
                        uint64_t v127 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v125, (uint64_t)v124, v126);
                        _StringGuts.appendInPlace(_:isASCII:)(v127, v128, v32 < 0);
                        goto LABEL_124;
                      }

                      goto LABEL_242;
                    }

                    swift_bridgeObjectRelease(v33);
                    uint64_t v86 = v32;
                    unint64_t v87 = v33;
                    uint64_t v88 = v41;
LABEL_84:
                    _StringGuts._foreignAppendInPlace(_:)(v86, v87, 0LL, v88);
LABEL_124:
                    swift_bridgeObjectRelease_n(v33, 2LL);
                    goto LABEL_204;
                  }

                  uint64_t v63 = _StringGuts.nativeCapacity.getter(v267, v268);
                  if ((v66 & 1) != 0) {
                    uint64_t v67 = 0LL;
                  }
                  else {
                    uint64_t v67 = v63;
                  }
                  if (v67 + 0x4000000000000000LL >= 0)
                  {
                    uint64_t v68 = 2 * v67;
                    if (v68 > v49) {
                      Swift::Int v49 = v68;
                    }
                    goto LABEL_51;
                  }

                  __break(1u);
                  goto LABEL_236;
                }

                unint64_t v35 = v268;
                if ((v268 & 0x2000000000000000LL) == 0)
                {
                  uint64_t v34 = v268;
LABEL_59:
                  int v73 = 1;
                  goto LABEL_132;
                }

                int v73 = 0;
                uint64_t v34 = v268;
              }

LABEL_132:
              swift_bridgeObjectRelease_n(v33, 5LL);
              unint64_t v39 = v267;
              if (!v73) {
                goto LABEL_133;
              }
              goto LABEL_227;
            }

        uint64_t v105 = v61 - 8;
        Swift::String::Index v106 = 8LL;
        if (v61 < 8) {
          Swift::String::Index v106 = v61;
        }
        if ((v106 & 0x8000000000000000LL) == 0)
        {
          if (v106 >= 8)
          {
            if (v106 >= 0x10)
            {
              Swift::Int v107 = v106 & 0xFFFFFFFFFFFFFFF0LL;
              Swift::String::Index v132 = vmovl_high_u8(*TypeName);
              Swift::String::Index v133 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v132.i8);
              Swift::String::Index v134 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
              Swift::String::Index v135 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v134.i8);
              unint64_t v136 = (int8x16_t)vmovl_high_u16(v132);
              unint64_t v137 = (int8x8_t)vextq_s8(v136, v136, 8uLL).u64[0];
              unint64_t v138 = (int8x16_t)vmovl_high_u16(v134);
              uint64_t v139 = (int8x8_t)vextq_s8(v138, v138, 8uLL).u64[0];
              *(int8x8_t *)v138.i8 = vorr_s8(*(int8x8_t *)v138.i8, *(int8x8_t *)v136.i8);
              v140.i64[0] = v138.u32[0];
              v140.i64[1] = v138.u32[1];
              uint64_t v141 = (int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1817FFCE0);
              *(int8x8_t *)v136.i8 = vorr_s8(*(int8x8_t *)v135.i8, *(int8x8_t *)v133.i8);
              v140.i64[0] = v136.u32[0];
              v140.i64[1] = v136.u32[1];
              char v142 = vorrq_s8((int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1817FFCD0), v141);
              *(int8x8_t *)v136.i8 = vorr_s8(v139, v137);
              v140.i64[0] = v136.u32[0];
              v140.i64[1] = v136.u32[1];
              unint64_t v143 = (int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1817FFCC0);
              *(int8x8_t *)v133.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v135, v135, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v133, v133, 8uLL));
              v140.i64[0] = v133.u32[0];
              v140.i64[1] = v133.u32[1];
              unint64_t v144 = vorrq_s8(v142, vorrq_s8((int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1817FFCB0), v143));
              uint64_t v4 = (uint64_t)vorr_s8(*(int8x8_t *)v144.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v144, v144, 8uLL));
              if (v106 == (v106 & 0xFFFFFFFFFFFFFFF0LL)) {
                goto LABEL_149;
              }
              int64_t v108 = 8 * v107;
              if ((v106 & 8) == 0) {
                goto LABEL_147;
              }
            }

            else
            {
              uint64_t v4 = 0LL;
              int64_t v108 = 0LL;
              Swift::Int v107 = 0LL;
            }

            uint64_t v109 = v107;
            int64_t v110 = vdupq_n_s64(v108);
            Swift::Int v107 = v106 & 0xFFFFFFFFFFFFFFF8LL;
            int64_t v108 = 8 * (v106 & 0xFFFFFFFFFFFFFFF8LL);
            char v111 = 0uLL;
            char v112 = (int8x16_t)(unint64_t)v4;
            unint64_t v113 = vaddq_s64(v110, (int64x2_t)xmmword_1817FFCC0);
            unint64_t v114 = vaddq_s64(v110, (int64x2_t)xmmword_1817FFCE0);
            unint64_t v115 = vaddq_s64(v110, (int64x2_t)xmmword_1817FFCB0);
            unint64_t v116 = vaddq_s64(v110, (int64x2_t)xmmword_1817FFCD0);
            unint64_t v117 = (uint8x8_t *)&TypeName->i8[v109];
            unint64_t v118 = (int8x16_t)vdupq_n_s64(0x38uLL);
            char v119 = v109 - (v106 & 0xFFFFFFFFFFFFFFF8LL);
            uint64_t v120 = vdupq_n_s64(0x40uLL);
            unint64_t v121 = 0uLL;
            unint64_t v122 = 0uLL;
            do
            {
              unint64_t v123 = *v117++;
              id v124 = vmovl_u8(v123);
              uint64_t v125 = vmovl_high_u16(v124);
              v126.i64[0] = v125.u32[2];
              v126.i64[1] = v125.u32[3];
              uint64_t v127 = v126;
              v126.i64[0] = v125.u32[0];
              v126.i64[1] = v125.u32[1];
              size_t v128 = v126;
              uint64_t v129 = vmovl_u16(*(uint16x4_t *)v124.i8);
              v126.i64[0] = v129.u32[2];
              v126.i64[1] = v129.u32[3];
              uint64_t v130 = v126;
              v126.i64[0] = v129.u32[0];
              v126.i64[1] = v129.u32[1];
              unint64_t v122 = vorrq_s8((int8x16_t)vshlq_u64(v127, (uint64x2_t)vandq_s8((int8x16_t)v113, v118)), v122);
              unint64_t v121 = vorrq_s8((int8x16_t)vshlq_u64(v128, (uint64x2_t)vandq_s8((int8x16_t)v114, v118)), v121);
              char v111 = vorrq_s8((int8x16_t)vshlq_u64(v130, (uint64x2_t)vandq_s8((int8x16_t)v115, v118)), v111);
              char v112 = vorrq_s8((int8x16_t)vshlq_u64(v126, (uint64x2_t)vandq_s8((int8x16_t)v116, v118)), v112);
              unint64_t v114 = vaddq_s64(v114, v120);
              unint64_t v115 = vaddq_s64(v115, v120);
              unint64_t v116 = vaddq_s64(v116, v120);
              unint64_t v113 = vaddq_s64(v113, v120);
              v119 += 8LL;
            }

            while (v119);
            uint64_t v131 = vorrq_s8(vorrq_s8(v112, v121), vorrq_s8(v111, v122));
            uint64_t v4 = (uint64_t)vorr_s8(*(int8x8_t *)v131.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v131, v131, 8uLL));
            if (v106 == v107)
            {
LABEL_149:
              if (v61 < 9)
              {
                uint64_t v149 = 0LL;
LABEL_165:
                v213 = 0xA000000000000000LL;
                if (((*(void *)&v149 | v4) & 0x8080808080808080LL) == 0) {
                  v213 = 0xE000000000000000LL;
                }
                uint64_t v3 = v213 | (v61 << 56) | *(void *)&v149;
                goto LABEL_168;
              }

              if (v105 < 8)
              {
                char v148 = 0LL;
                uint64_t v149 = 0LL;
                unint64_t v150 = 0LL;
LABEL_163:
                unint64_t v210 = v61 - v148 - 8;
                unint64_t v211 = &TypeName->u8[v148 + 8];
                do
                {
                  unint64_t v212 = *v211++;
                  *(void *)&v149 |= (unint64_t)v212 << (v150 & 0x38);
                  v150 += 8LL;
                  --v210;
                }

                while (v210);
                goto LABEL_165;
              }

              if (v105 >= 0x10)
              {
                unint64_t v174 = (uint8x16_t *)&TypeName->u64[1];
                char v148 = v105 & 0xFFFFFFFFFFFFFFF0LL;
                unint64_t v175 = (int64x2_t)xmmword_1817FFD60;
                unint64_t v176 = (int64x2_t)xmmword_1817FFD70;
                char v177 = (int64x2_t)xmmword_1817FFD80;
                uint64_t v178 = (int64x2_t)xmmword_1817FFD90;
                unint64_t v179 = (int64x2_t)xmmword_1817FFCC0;
                char v180 = (int64x2_t)xmmword_1817FFCE0;
                unint64_t v181 = (int8x16_t)vdupq_n_s64(0x38uLL);
                unint64_t v182 = vdupq_n_s64(0x80uLL);
                unint64_t v183 = (int64x2_t)xmmword_1817FFCB0;
                unint64_t v150 = 8 * (v105 & 0xFFFFFFFFFFFFFFF0LL);
                unint64_t v184 = 0uLL;
                unint64_t v185 = 0uLL;
                char v186 = (int64x2_t)xmmword_1817FFCD0;
                uint64_t v187 = v105 & 0xFFFFFFFFFFFFFFF0LL;
                unint64_t v188 = 0uLL;
                unint64_t v189 = 0uLL;
                unint64_t v190 = 0uLL;
                Swift::String::Index v191 = 0uLL;
                Swift::String::Index v192 = 0uLL;
                Swift::String::Index v193 = 0uLL;
                do
                {
                  Swift::String::Index v194 = *v174++;
                  unint64_t v195 = vmovl_u8(*(uint8x8_t *)v194.i8);
                  unint64_t v196 = vmovl_high_u16(v195);
                  v197.i64[0] = v196.u32[2];
                  v197.i64[1] = v196.u32[3];
                  uint64_t v198 = v197;
                  uint64_t v199 = vmovl_high_u8(v194);
                  uint64_t v200 = vmovl_u16(*(uint16x4_t *)v199.i8);
                  v197.i64[0] = v200.u32[2];
                  v197.i64[1] = v200.u32[3];
                  char v201 = v197;
                  v197.i64[0] = v200.u32[0];
                  v197.i64[1] = v200.u32[1];
                  unint64_t v202 = v197;
                  v197.i64[0] = v196.u32[0];
                  v197.i64[1] = v196.u32[1];
                  unint64_t v203 = v197;
                  unint64_t v204 = vmovl_u16(*(uint16x4_t *)v195.i8);
                  v197.i64[0] = v204.u32[2];
                  v197.i64[1] = v204.u32[3];
                  unint64_t v205 = v197;
                  unint64_t v206 = vmovl_high_u16(v199);
                  v197.i64[0] = v206.u32[0];
                  v197.i64[1] = v206.u32[1];
                  char v207 = v197;
                  v197.i64[0] = v204.u32[0];
                  v197.i64[1] = v204.u32[1];
                  uint64_t v208 = v197;
                  v197.i64[0] = v206.u32[2];
                  v197.i64[1] = v206.u32[3];
                  unint64_t v189 = vorrq_s8((int8x16_t)vshlq_u64(v198, (uint64x2_t)vandq_s8((int8x16_t)v179, v181)), v189);
                  Swift::String::Index v191 = vorrq_s8((int8x16_t)vshlq_u64(v201, (uint64x2_t)vandq_s8((int8x16_t)v177, v181)), v191);
                  unint64_t v190 = vorrq_s8((int8x16_t)vshlq_u64(v202, (uint64x2_t)vandq_s8((int8x16_t)v178, v181)), v190);
                  unint64_t v188 = vorrq_s8((int8x16_t)vshlq_u64(v203, (uint64x2_t)vandq_s8((int8x16_t)v180, v181)), v188);
                  unint64_t v185 = vorrq_s8((int8x16_t)vshlq_u64(v205, (uint64x2_t)vandq_s8((int8x16_t)v183, v181)), v185);
                  Swift::String::Index v192 = vorrq_s8((int8x16_t)vshlq_u64(v207, (uint64x2_t)vandq_s8((int8x16_t)v176, v181)), v192);
                  unint64_t v184 = vorrq_s8((int8x16_t)vshlq_u64(v208, (uint64x2_t)vandq_s8((int8x16_t)v186, v181)), v184);
                  Swift::String::Index v193 = vorrq_s8((int8x16_t)vshlq_u64(v197, (uint64x2_t)vandq_s8((int8x16_t)v175, v181)), v193);
                  char v180 = vaddq_s64(v180, v182);
                  unint64_t v183 = vaddq_s64(v183, v182);
                  char v186 = vaddq_s64(v186, v182);
                  unint64_t v179 = vaddq_s64(v179, v182);
                  uint64_t v178 = vaddq_s64(v178, v182);
                  char v177 = vaddq_s64(v177, v182);
                  unint64_t v176 = vaddq_s64(v176, v182);
                  unint64_t v175 = vaddq_s64(v175, v182);
                  v187 -= 16LL;
                }

                while (v187);
                unint64_t v209 = vorrq_s8( vorrq_s8(vorrq_s8(v184, v190), vorrq_s8(v188, v192)),  vorrq_s8(vorrq_s8(v185, v191), vorrq_s8(v189, v193)));
                uint64_t v149 = vorr_s8(*(int8x8_t *)v209.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v209, v209, 8uLL));
                if (v105 == v148) {
                  goto LABEL_165;
                }
                if ((v105 & 8) == 0) {
                  goto LABEL_163;
                }
              }

              else
              {
                uint64_t v149 = 0LL;
                unint64_t v150 = 0LL;
                char v148 = 0LL;
              }

              unint64_t v151 = v148;
              char v148 = v105 & 0xFFFFFFFFFFFFFFF8LL;
              unint64_t v152 = vdupq_n_s64(v150);
              unint64_t v150 = 8 * (v105 & 0xFFFFFFFFFFFFFFF8LL);
              unint64_t v153 = (int8x16_t)(unint64_t)v149;
              uint64_t v154 = 0uLL;
              unint64_t v155 = vaddq_s64(v152, (int64x2_t)xmmword_1817FFCC0);
              unint64_t v156 = vaddq_s64(v152, (int64x2_t)xmmword_1817FFCE0);
              int v157 = vaddq_s64(v152, (int64x2_t)xmmword_1817FFCB0);
              unint64_t v158 = vaddq_s64(v152, (int64x2_t)xmmword_1817FFCD0);
              uint64_t v159 = (uint8x8_t *)((char *)&TypeName->u64[1] + v151);
              uint64_t v160 = (int8x16_t)vdupq_n_s64(0x38uLL);
              unint64_t v161 = v151 - (v105 & 0xFFFFFFFFFFFFFFF8LL);
              unint64_t v162 = vdupq_n_s64(0x40uLL);
              unint64_t v163 = 0uLL;
              unint64_t v164 = 0uLL;
              do
              {
                Swift::String::Index v165 = *v159++;
                Swift::String::Index v166 = vmovl_u8(v165);
                Swift::String::Index v167 = vmovl_high_u16(v166);
                v168.i64[0] = v167.u32[2];
                v168.i64[1] = v167.u32[3];
                unint64_t v169 = v168;
                v168.i64[0] = v167.u32[0];
                v168.i64[1] = v167.u32[1];
                unint64_t v170 = v168;
                unint64_t v171 = vmovl_u16(*(uint16x4_t *)v166.i8);
                v168.i64[0] = v171.u32[2];
                v168.i64[1] = v171.u32[3];
                unint64_t v172 = v168;
                v168.i64[0] = v171.u32[0];
                v168.i64[1] = v171.u32[1];
                unint64_t v164 = vorrq_s8((int8x16_t)vshlq_u64(v169, (uint64x2_t)vandq_s8((int8x16_t)v155, v160)), v164);
                unint64_t v163 = vorrq_s8((int8x16_t)vshlq_u64(v170, (uint64x2_t)vandq_s8((int8x16_t)v156, v160)), v163);
                uint64_t v154 = vorrq_s8((int8x16_t)vshlq_u64(v172, (uint64x2_t)vandq_s8((int8x16_t)v157, v160)), v154);
                unint64_t v153 = vorrq_s8((int8x16_t)vshlq_u64(v168, (uint64x2_t)vandq_s8((int8x16_t)v158, v160)), v153);
                unint64_t v156 = vaddq_s64(v156, v162);
                int v157 = vaddq_s64(v157, v162);
                unint64_t v158 = vaddq_s64(v158, v162);
                unint64_t v155 = vaddq_s64(v155, v162);
                v161 += 8LL;
              }

              while (v161);
              unint64_t v173 = vorrq_s8(vorrq_s8(v153, v163), vorrq_s8(v154, v164));
              uint64_t v149 = vorr_s8(*(int8x8_t *)v173.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v173, v173, 8uLL));
              if (v105 == v148) {
                goto LABEL_165;
              }
              goto LABEL_163;
            }
          }

          else
          {
            Swift::Int v107 = 0LL;
            uint64_t v4 = 0LL;
            int64_t v108 = 0LL;
          }

LABEL_226:
            __break(1u);
LABEL_227:
            if ((v35 & 0x1000000000000000LL) != 0)
            {
              unint64_t v39 = _StringGuts._foreignConvertedToSmall()(v39, v34);
              unint64_t v35 = v252;
            }

            else
            {
              if ((v39 & 0x1000000000000000LL) != 0)
              {
                uint64_t v231 = (unsigned __int8 *)((v35 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v232 = v39 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                uint64_t v231 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v39, v34);
                uint64_t v232 = v44;
              }

              swift_bridgeObjectRetain(v34, v44, v45, v46);
              closure #1 in _StringGuts._convertedToSmall()(v231, v232, &v264);
              swift_bridgeObjectRelease(v34);
              unint64_t v35 = *((void *)&v264 + 1);
              unint64_t v39 = v264;
            }

              unint64_t v211 = v197 << 16;
              unint64_t v210 = 1LL;
            }

    unint64_t v268 = v263._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_227;
  }

  unint64_t v268 = ((unint64_t)v263._object >> 56) & 0xF;
  v278 = v266 + v268;
  if (v266 + v268 > 0xF)
  {
LABEL_227:
    _StringGuts.append(_:)(v263._countAndFlagsBits, (unint64_t)v263._object, 0LL, v268);
    v269 = (uint64_t)v263._object;
LABEL_228:
    swift_bridgeObjectRelease(v269);
    goto LABEL_229;
  }

  if (v268)
  {
    char v279 = 0;
    v280 = 0LL;
    do
    {
      uint64_t v281 = v266 + v280;
      v282 = v280 + 1;
      if (v280 >= 8) {
        char v283 = (unint64_t)v263._object;
      }
      else {
        char v283 = v263._countAndFlagsBits;
      }
      uint64_t v284 = v283 >> (v279 & 0x38);
      char v285 = (8 * v266 + v279) & 0x38;
      uint64_t v286 = (-255LL << v285) - 1;
      v287 = (unint64_t)v284 << v285;
      v288 = v287 | v286 & v264;
      uint64_t v289 = v287 | v286 & v265;
      if (v281 < 8) {
        __int128 v265 = v289;
      }
      else {
        __int128 v264 = v288;
      }
      v279 += 8;
      v280 = v282;
    }

    while (v268 != v282);
  }

  swift_bridgeObjectRelease((uint64_t)v263._object);
  uint64_t v290 = 0xA000000000000000LL;
  if (!(v265 & 0x8080808080808080LL | v264 & 0x80808080808080LL)) {
    uint64_t v290 = 0xE000000000000000LL;
  }
  v291 = (void *)(v290 & 0xFF00000000000000LL | (v278 << 56) | v264 & 0xFFFFFFFFFFFFFFLL);
  swift_bridgeObjectRelease((uint64_t)v315._object);
  v315._uint64_t countAndFlagsBits = v265;
  v315._object = v291;
LABEL_229:
  uint64_t v272 = v315._object;
  uint64_t v273 = ((unint64_t)v315._object >> 56) & 0xF;
  if (v273 || (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v315._object & 0x2000000000000000LL) == 0
      || (uint64_t v274 = specialized _SmallString.init(_:appending:)( v315._countAndFlagsBits,  (unint64_t)v315._object,  0LL,  0xE000000000000000LL),  (v270 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE000000000000000LL, (uint64_t)v272, v270, v271);
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      swift_bridgeObjectRelease_n(0xE000000000000000LL, 2LL);
    }

    else
    {
      uint64_t v275 = v274;
      v276 = v272;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      swift_bridgeObjectRelease((uint64_t)v315._object);
      v315._uint64_t countAndFlagsBits = v275;
      v315._object = v276;
    }
  }

  else
  {
    v315._uint64_t countAndFlagsBits = 0LL;
    v315._object = (void *)0xE000000000000000LL;
    swift_bridgeObjectRelease((uint64_t)v272);
  }

  return v315._countAndFlagsBits;
}

            uint64_t v30 = 0;
            uint64_t v26 = 0;
            uint64_t v27 = 0;
            uint64_t v28 = 14;
            goto LABEL_232;
          }
        }

        uint64_t v24 = 15;
        break;
      case 0x22u:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133) {
            goto LABEL_281;
          }
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A) {
              goto LABEL_281;
            }
            uint64_t v25 = 2;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 2;
              goto LABEL_67;
            }

            goto LABEL_226;
          }
        }

        uint64_t v24 = 2;
        break;
      default:
        if (v23 - 127488 < 0xFFFFFFE6)
        {
          switch(_swift_stdlib_getWordBreakProperty(v23))
          {
            case 0u:
              if (v11 < 0xA) {
                goto LABEL_45;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 < 0x405)
              {
LABEL_45:
                uint64_t v24 = 3;
                goto LABEL_33;
              }

              if (v11 < 0x202A) {
                goto LABEL_281;
              }
              uint64_t v25 = 3;
              if (v11 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_226;
              }
              LOBYTE(v24) = 3;
              goto LABEL_67;
            case 1u:
              if (v11 < 0xA) {
                goto LABEL_89;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 < 0x405)
              {
LABEL_89:
                uint64_t v24 = 6;
                goto LABEL_33;
              }

              if (v11 < 0x202A) {
                goto LABEL_281;
              }
              uint64_t v25 = 6;
              if (v11 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_226;
              }
              LOBYTE(v24) = 6;
              goto LABEL_67;
            case 2u:
              if (v11 < 0xA)
              {
                uint64_t v24 = 8;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                uint64_t v25 = 8;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_198;
                }
                goto LABEL_226;
              }

              uint64_t v25 = 8;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205) {
                  goto LABEL_69;
                }
LABEL_198:
                LOBYTE(v24) = 8;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 3u:
              if (v11 < 0xA)
              {
                uint64_t v24 = 7;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                uint64_t v25 = 7;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_201;
                }
                goto LABEL_226;
              }

              uint64_t v25 = 7;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205) {
                  goto LABEL_69;
                }
LABEL_201:
                LOBYTE(v24) = 7;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 4u:
              if (v11 < 0xA)
              {
                uint64_t v25 = 0;
                LOBYTE(v24) = 0;
                goto LABEL_34;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_204;
                }
                uint64_t v30 = 0;
                uint64_t v26 = 0;
                uint64_t v27 = 0;
                uint64_t v25 = 0;
                uint64_t v28 = 14;
                goto LABEL_232;
              }

              if (v11 == 34)
              {
                uint64_t v26 = 0;
                uint64_t v27 = 0;
                uint64_t v25 = 0;
                goto LABEL_38;
              }

              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  Swift::UInt64 v18 = 0;
                  goto LABEL_9;
                }

LABEL_133:
            v132._rawBits = (v41 << 16) | 1;
            v133._rawBits = 1LL;
            v134._rawBits = _StringGuts.validateScalarRange(_:)(v133, v132, v32, v33);
            if (v134._rawBits < 0x10000) {
              v134._rawBits |= 3;
            }
            unint64_t v136 = specialized String.init(_:)(v134, v135, v32, v33);
            unint64_t v138 = v137;
            swift_bridgeObjectRelease(v33);
            if ((v138 & 0x2000000000000000LL) != 0)
            {
              swift_bridgeObjectRelease(v138);
            }

            else if ((v138 & 0x1000000000000000LL) != 0)
            {
              unint64_t v136 = _StringGuts._foreignConvertedToSmall()(v136, v138);
              unint64_t v254 = v253;
              swift_bridgeObjectRelease(v138);
              unint64_t v138 = v254;
            }

            else
            {
              if ((v136 & 0x1000000000000000LL) != 0)
              {
                uint64_t v233 = (unsigned __int8 *)((v138 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v234 = v136 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                uint64_t v233 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v136, v138);
              }

              closure #1 in _StringGuts._convertedToSmall()(v233, v234, &v264);
              swift_bridgeObjectRelease(v138);
              unint64_t v138 = *((void *)&v264 + 1);
              unint64_t v136 = v264;
            }

            uint64_t v139 = HIBYTE(v35) & 0xF;
            uint64_t v140 = HIBYTE(v138) & 0xF;
            uint64_t v141 = v140 + v139;
            if ((unint64_t)(v140 + v139) <= 0xF)
            {
              if (v140)
              {
                char v142 = 0;
                unint64_t v143 = 0LL;
                do
                {
                  unint64_t v144 = v139 + v143;
                  unint64_t v145 = v143 + 1;
                  if (v143 >= 8) {
                    unint64_t v146 = v138;
                  }
                  else {
                    unint64_t v146 = v136;
                  }
                  unint64_t v147 = v146 >> (v142 & 0x38);
                  char v148 = (8 * v139 + v142) & 0x38;
                  uint64_t v149 = (-255LL << v148) - 1;
                  unint64_t v150 = (unint64_t)v147 << v148;
                  unint64_t v151 = v150 | v149 & v35;
                  unint64_t v152 = v150 | v149 & v39;
                  if (v144 < 8) {
                    unint64_t v39 = v152;
                  }
                  else {
                    unint64_t v35 = v151;
                  }
                  v142 += 8;
                  unint64_t v143 = v145;
                }

                while (v140 != v145);
              }

              swift_bridgeObjectRelease(v34);
              swift_bridgeObjectRelease(v33);
              unint64_t v153 = 0xA000000000000000LL;
              if (!(v39 & 0x8080808080808080LL | v35 & 0x80808080808080LL)) {
                unint64_t v153 = 0xE000000000000000LL;
              }
              unint64_t v267 = v39;
              unint64_t v268 = v153 & 0xFF00000000000000LL | (v141 << 56) | v35 & 0xFFFFFFFFFFFFFFLL;
              goto LABEL_204;
            }

            goto LABEL_260;
          }
        }

        else
        {
          swift_bridgeObjectRetain_n(v33, 4LL, v42, v43);
          Swift::Int v47 = v41;
          if ((v35 & 0x1000000000000000LL) == 0) {
            goto LABEL_16;
          }
        }

        Swift::Int v230 = String.UTF8View._foreignCount()();
        Swift::Int v49 = v230 + v47;
        if (!__OFADD__(v230, v47)) {
          goto LABEL_17;
        }
        goto LABEL_226;
      }

      if (v39)
      {
        char v112 = 0;
        unint64_t v113 = 0LL;
        unint64_t v114 = v268;
        do
        {
          unint64_t v115 = v36 + v113;
          unint64_t v116 = v113 + 1;
          if (v113 >= 8) {
            unint64_t v117 = v29;
          }
          else {
            unint64_t v117 = v28;
          }
          unint64_t v118 = v117 >> (v112 & 0x38);
          char v119 = (8 * v36 + v112) & 0x38;
          uint64_t v120 = (-255LL << v119) - 1;
          unint64_t v121 = (unint64_t)v118 << v119;
          unint64_t v122 = v121 | v120 & v114;
          unint64_t v123 = v121 | v120 & v34;
          if (v115 < 8) {
            uint64_t v34 = v123;
          }
          else {
            unint64_t v114 = v122;
          }
          v112 += 8;
          unint64_t v113 = v116;
        }

        while (v39 != v116);
      }

      else
      {
        unint64_t v114 = v268;
      }

      uint64_t v154 = v268;
      goto LABEL_152;
    }

    uint64_t v89 = v268;
LABEL_86:
    swift_bridgeObjectRelease(v89);
    unint64_t v267 = v32;
    unint64_t v268 = v33;
    goto LABEL_204;
  }

  v21(v16, a1, a2);
  if ((swift_dynamicCast((char *)&v260, v16, a2, (const char *)&type metadata for String, 6uLL) & 1) == 0)
  {
    v21(v13, a1, a2);
    uint64_t v60 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v264, v13, a2, v60, 6uLL))
    {
      (*(void (**)(uint64_t, swift *))(v4 + 8))(a1, a2);
      outlined init with take of MirrorPath(&v264, (uint64_t)&v260);
      uint64_t v61 = (uint64_t)v262;
      uint64_t v62 = v263;
      __swift_project_boxed_opaque_existential_0Tm(&v260, (uint64_t)v262);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v62 + 8))( &v267,  &type metadata for String,  &protocol witness table for String,  v61,  v62);
LABEL_204:
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v260);
      return v267;
    }

    uint64_t v266 = 0LL;
    __int128 v264 = 0u;
    __int128 v265 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v264,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v21(v10, a1, a2);
    uint64_t v74 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v264, v10, a2, v74, 6uLL))
    {
      (*(void (**)(uint64_t, swift *))(v4 + 8))(a1, a2);
      outlined init with take of MirrorPath(&v264, (uint64_t)&v260);
      uint64_t v75 = (uint64_t)v262;
      uint64_t v76 = v263;
      __swift_project_boxed_opaque_existential_0Tm(&v260, (uint64_t)v262);
      uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(v76 + 8))(v75, v76);
      uint64_t v32 = v77;
      unint64_t v33 = v78;
      uint64_t v34 = v267;
      unint64_t v39 = v268;
      unint64_t v81 = HIBYTE(v268) & 0xF;
      if ((v268 & 0x2000000000000000LL) != 0) {
        Swift::Int v49 = HIBYTE(v268) & 0xF;
      }
      else {
        Swift::Int v49 = v267 & 0xFFFFFFFFFFFFLL;
      }
      if (v49 || (v267 & ~v268 & 0x2000000000000000LL) != 0)
      {
        uint64_t v50 = v78 & 0x2000000000000000LL;
        uint64_t v59 = HIBYTE(v78) & 0xF;
        if ((v268 & 0x2000000000000000LL) != 0 && v50)
        {
          unint64_t v40 = v81 + v59;
          if (v81 + v59 <= 0xF)
          {
            if (v59)
            {
              char v180 = 0;
              unint64_t v181 = 0LL;
              unint64_t v114 = v268;
              do
              {
                unint64_t v182 = v81 + v181;
                unint64_t v183 = v181 + 1;
                if (v181 >= 8) {
                  unint64_t v184 = v78;
                }
                else {
                  unint64_t v184 = v77;
                }
                unint64_t v185 = v184 >> (v180 & 0x38);
                char v186 = (8 * v81 + v180) & 0x38;
                uint64_t v187 = (-255LL << v186) - 1;
                unint64_t v188 = (unint64_t)v185 << v186;
                unint64_t v189 = v188 | v187 & v114;
                unint64_t v190 = v188 | v187 & v34;
                if (v182 < 8) {
                  uint64_t v34 = v190;
                }
                else {
                  unint64_t v114 = v189;
                }
                v180 += 8;
                unint64_t v181 = v183;
              }

              while (v59 != v183);
              uint64_t v154 = v268;
            }

            else
            {
              unint64_t v114 = v268;
              uint64_t v154 = v268;
            }

    unint64_t v170 = 266LL;
    goto LABEL_135;
  }

  uint64_t v17 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v17 = a3 & 0xFFFFFFFFFFFFLL;
  }
  Swift::UInt64 v18 = v17 == 0;
  if (v17) {
    uint64_t v19 = 15LL;
  }
  else {
    uint64_t v19 = 0LL;
  }
  swift_bridgeObjectRetain(a4, v14, v15, v16);
  uint64_t v20 = specialized FlattenSequence<>.distance(from:to:)( v18,  v19,  v18,  1LL,  0LL,  1,  a3,  a4,  (void (*)(unint64_t *__return_ptr, uint64_t *))closure #3 in _StringGuts.replaceSubrange<A>(_:with:),  0LL);
  unint64_t v21 = a1 >> 16;
  uint64_t v22 = (a1 >> 16) + v20;
  if (__OFADD__(a1 >> 16, v20)) {
    goto LABEL_121;
  }
  a2 = (unint64_t)a2 >> 16;
  uint64_t v23 = v12 & 0xFFFFFFFFFFFFLL;
  if ((v11 & 0x2000000000000000LL) != 0) {
    uint64_t v23 = HIBYTE(v11) & 0xF;
  }
  uint64_t v24 = v23 - a2;
  uint64_t v25 = v22 + v24;
  if (!__OFADD__(v22, v24))
  {
    uint64_t v5 = v20;
    if (v25 < 16) {
      goto LABEL_111;
    }
    uint64_t v26 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v27 & 1) == 0 && v26 >= v25) {
      goto LABEL_111;
    }
    uint64_t v28 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v29 & 1) != 0)
    {
      unint64_t v145 = *(void *)(v6 + 8);
      if ((v145 & 0x1000000000000000LL) != 0)
      {
        uint64_t v30 = String.UTF8View._foreignCount()();
      }

      else if ((v145 & 0x2000000000000000LL) != 0)
      {
        uint64_t v30 = HIBYTE(v145) & 0xF;
      }

      else
      {
        uint64_t v30 = *(void *)v6 & 0xFFFFFFFFFFFFLL;
      }
    }

    else
    {
      uint64_t v30 = 2 * v28;
    }

    if (v30 > v25) {
      uint64_t v25 = v30;
    }
    unint64_t v146 = *(void *)(v6 + 8);
    if ((v146 & 0x1000000000000000LL) == 0)
    {
      unint64_t v147 = *(void *)v6;
      if ((v146 & 0x2000000000000000LL) != 0)
      {
        unint64_t v151 = v21;
        unint64_t v152 = a3;
        unint64_t v153 = HIBYTE(v146) & 0xF;
        __src = *(void *)v6;
        char v180 = v146 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v154 = v153 | 0xC000000000000000LL;
        if ((v146 & 0x4000000000000000LL) == 0) {
          uint64_t v154 = HIBYTE(v146) & 0xF;
        }
        unint64_t v155 = v154 | 0x3000000000000000LL;
        unint64_t v150 = _allocateStringStorage(codeUnitCapacity:)(v25);
        *(void *)(v150 + 16) = v156;
        *(void *)(v150 + 24) = v155;
        if (v156 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
          unint64_t v155 = *(void *)(v150 + 24);
        }

        *(_BYTE *)(v150 + 32 + (v155 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v153, (char *)(v150 + 32));
        a3 = v152;
        unint64_t v21 = v151;
      }

      else
      {
        if ((v147 & 0x1000000000000000LL) != 0)
        {
          char v148 = (char *)((v146 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v149 = v147 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          char v148 = (char *)_StringObject.sharedUTF8.getter(*(void *)v6, v146);
        }

        unint64_t v150 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v148,  v149,  v25,  v147 < 0);
      }

      int v157 = *(void *)(v150 + 24);
      swift_bridgeObjectRelease(*(void *)(v6 + 8));
      *(void *)uint64_t v6 = v157;
      *(void *)(v6 + 8) = v150;
      goto LABEL_111;
    }

          __break(1u);
          goto LABEL_134;
        }
      }

      else if ((v198 & 0x1000000000000000LL) != 0)
      {
        uint64_t v95 = (id)((v199 & 0xFFFFFFFFFFFFFFFLL) + 32);
        char v96 = v198 & 0xFFFFFFFFFFFFLL;
        if ((uint64_t)(v198 & 0xFFFFFFFFFFFFLL) >= v94)
        {
LABEL_32:
          unint64_t v97 = specialized UnsafeBufferPointer.init(rebasing:)(v40, v94, (uint64_t)v95, v96);
          unint64_t v37 = v188 >> 16;
          uint64_t v99 = (v188 >> 16) + v98;
          if (__OFADD__(v188 >> 16, v98))
          {
            __break(1u);
          }

          else
          {
            unint64_t v10 = v187 >> 16;
            unint64_t v100 = v36[1];
            if ((v100 & 0x2000000000000000LL) != 0) {
              uint64_t v101 = HIBYTE(v100) & 0xF;
            }
            else {
              uint64_t v101 = *v36 & 0xFFFFFFFFFFFFLL;
            }
            uint64_t v102 = v101 - v10;
            unint64_t v40 = v99 + v102;
            if (!__OFADD__(v99, v102))
            {
              uint64_t v6 = (char *)v97;
              __int128 v16 = v98;
              if (v40 < 16) {
                goto LABEL_109;
              }
              uint64_t v103 = _StringGuts.uniqueNativeCapacity.getter();
              if ((v104 & 1) == 0 && v103 >= v40) {
                goto LABEL_109;
              }
              uint64_t v105 = _StringGuts.uniqueNativeCapacity.getter();
              if ((v106 & 1) != 0)
              {
                unint64_t v153 = v36[1];
                if ((v153 & 0x1000000000000000LL) != 0)
                {
                  Swift::Int v107 = String.UTF8View._foreignCount()();
                }

                else if ((v153 & 0x2000000000000000LL) != 0)
                {
                  Swift::Int v107 = HIBYTE(v153) & 0xF;
                }

                else
                {
                  Swift::Int v107 = *v36 & 0xFFFFFFFFFFFFLL;
                }
              }

              else
              {
                Swift::Int v107 = 2 * v105;
              }

              if (v107 > v40) {
                unint64_t v40 = v107;
              }
              Swift::String::Index v133 = v36[1];
              if ((v133 & 0x1000000000000000LL) == 0)
              {
                Swift::String::Index v134 = *v36;
                if ((v133 & 0x2000000000000000LL) == 0)
                {
                  if ((v134 & 0x1000000000000000LL) != 0) {
                    goto LABEL_73;
                  }
                  goto LABEL_102;
                }

    unint64_t v138 = v7._rawBits & 0xFFFFFFFFFFFF0000LL;
    unint64_t v137 = 1LL;
LABEL_134:
    v138 |= v137 << 8;
    goto LABEL_135;
  }

  if ((v12 & 0x1000000000000000LL) != 0)
  {
    uint64_t v139 = (char *)((v15 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v140 = v12 & 0xFFFFFFFFFFFFLL;
    goto LABEL_126;
  }

    uint64_t v130 = v125 & 0xFFFFFFFFFFFF0000LL;
    uint64_t v129 = 1LL;
LABEL_134:
    v130 |= v129 << 8;
    goto LABEL_135;
  }

  if ((v116 & 0x1000000000000000LL) != 0)
  {
    uint64_t v131 = (char *)((v115 & 0xFFFFFFFFFFFFFFFLL) + 32);
    Swift::String::Index v132 = v116 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v131 = (char *)_StringObject.sharedUTF8.getter(v116, v115);
  }

  if (v126 + 1 == v132) {
    goto LABEL_133;
  }
  if (!v131) {
LABEL_214:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  Swift::String::Index v133 = *(unsigned __int16 *)&v131[v126];
LABEL_131:
  if (v133 != 2573 && (v133 & 0x80808080) == 0) {
    goto LABEL_133;
  }
LABEL_177:
  uint64_t v129 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v126);
  uint64_t v130 = v125 & 0xFFFFFFFFFFFF0000LL;
  if (v129 <= 63) {
    goto LABEL_134;
  }
LABEL_135:
  Swift::String::Index v134 = v130 | 5;
  if ((v125 & 2) != 0 && (v126 < v16 || _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v130 | 5)))) {
    Swift::String::Index v134 = v130 | 7;
  }
  *uint64_t v3 = v134;
  if (v16 != v17) {
    goto LABEL_140;
  }
}

        Swift::String::Index v167 = &TypeName->u8[v129];
        Swift::String::Index v168 = v128 - v129;
        do
        {
          unint64_t v169 = *v167++;
          countAndFlagsBits |= (unint64_t)v169 << (v130 & 0x38);
          v130 += 8LL;
          --v168;
        }

        while (v168);
        goto LABEL_135;
      }

  unint64_t v174 = v274;
  unint64_t v175 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000LL) == 0) {
    unint64_t v175 = v273 & 0xFFFFFFFFFFFFLL;
  }
  if (v175 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
  {
    if ((v274 & 0x2000000000000000LL) == 0
      || (unint64_t v176 = specialized _SmallString.init(_:appending:)(v273, v274, 0x202CuLL, 0xE200000000000000LL),
          (v170 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v169, v170, v171);
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      char v177 = v176;
      uint64_t v178 = v169;
      swift_bridgeObjectRelease(v174);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v273 = v177;
      uint64_t v274 = v178;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v274);
    uint64_t v273 = 8236LL;
    uint64_t v274 = 0xE200000000000000LL;
  }

  v102(3LL, v103, AssociatedConformanceWitness);
  unint64_t v268 = (uint64_t *)v2;
  unint64_t v179 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v179, v138, v3);
  char v180 = v268;
  unint64_t v181 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  unint64_t v182 = (void *)swift_getDynamicType(v181, v180, 1);
  LODWORD(v180) = swift_isOptionalType(v182);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if ((_DWORD)v180)
  {
    unint64_t v183 = v266;
    memcpy(v266, v138, v3);
    unint64_t v184 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v267, v183, v2, v184, 7uLL);
LABEL_143:
    unint64_t v185 = (uint64_t)v268;
    char v186 = v269;
    __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
    unint64_t v188 = (*(uint64_t (**)(uint64_t, uint64_t))(v186 + 8))(v185, v186);
    unint64_t v189 = v187;
    unint64_t v190 = HIBYTE(v274) & 0xF;
    if ((v274 & 0x2000000000000000LL) == 0) {
      unint64_t v190 = v273 & 0xFFFFFFFFFFFFLL;
    }
    if (v190 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v188, v187);
      swift_bridgeObjectRelease(v189);
    }

    else
    {
      swift_bridgeObjectRelease(v274);
      uint64_t v273 = v188;
      uint64_t v274 = v189;
    }

    goto LABEL_148;
  }

  Swift::String::Index v194 = v263;
  memcpy(v263, v138, v3);
  if ((swift_dynamicCast((char *)&v267, v194, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    unint64_t v195 = v267._object;
    String.append(_:)(v267);
    swift_bridgeObjectRelease((uint64_t)v195);
  }

  else
  {
    unint64_t v205 = v259;
    memcpy(v259, v138, v3);
    unint64_t v206 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v270, v205, v2, v206, 6uLL))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      char v207 = (uint64_t)v268;
      uint64_t v208 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v208 + 8))( &v273,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v207,  v208);
LABEL_148:
      __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      goto LABEL_151;
    }

    uint64_t v272 = 0LL;
    v270 = 0u;
    uint64_t v271 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for TextOutputStreamable?);
    Swift::Int v230 = v256;
    memcpy(v256, v138, v3);
    uint64_t v231 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v270, v230, v2, v231, 6uLL)
      || (uint64_t v272 = 0LL,
          v270 = 0u,
          uint64_t v271 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomStringConvertible?),  uint64_t v232 = v252,  memcpy(v252, v138, v3),  v233 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v270, v232, v2, v233, 6uLL)))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      goto LABEL_143;
    }

    uint64_t v272 = 0LL;
    v270 = 0u;
    uint64_t v271 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v271 + 1) = v2;
    Swift::String::Index v244 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
    memcpy(v244, v138, v3);
    Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
    Swift::Int v245 = v267._object;
    uint64_t v246 = v269;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v138,  &v267,  &v273,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v246);
    swift_release((uint64_t)v245);
  }

  unint64_t v255 = v567;
  unint64_t v256 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    unint64_t v256 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v256 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    if ((v567 & 0x2000000000000000LL) == 0
      || (unint64_t v257 = specialized _SmallString.init(_:appending:)(v566, v567, 0x202CuLL, 0xE200000000000000LL),
          (v259 & 1) != 0))
    {
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
    }

    else
    {
      unint64_t v260 = v257;
      unint64_t v261 = v258;
      swift_bridgeObjectRelease(v255);
      uint64_t v566 = v260;
      v567 = v261;
    }

    unint64_t v262 = 0xE200000000000000LL;
  }

  else
  {
    uint64_t v566 = 8236LL;
    v567 = 0xE200000000000000LL;
    unint64_t v262 = v255;
  }

  swift_bridgeObjectRelease(v262);
  uint64_t v263 = v550;
  v146(2LL, v162, AssociatedConformanceWitness);
  uint64_t v561 = (uint64_t *)v1;
  __int128 v264 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v264, v263, v2);
  __int128 v265 = v561;
  uint64_t v266 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  unint64_t v267 = (void *)swift_getDynamicType(v266, v265, 1);
  LODWORD(v265) = swift_isOptionalType(v267);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v265)
  {
    memcpy(v151, v263, v2);
    unint64_t v268 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v268, 7uLL);
    v269 = (uint64_t)v561;
    v270 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    uint64_t v271 = (*(uint64_t (**)(uint64_t, uint64_t))(v270 + 8))(v269, v270);
    uint64_t v275 = v271;
    v276 = v272;
    uint64_t v277 = v567;
    v278 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000LL) == 0) {
      v278 = v566 & 0xFFFFFFFFFFFFLL;
    }
    if (v278 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v271, v272);
    }

    else
    {
      swift_bridgeObjectRetain(v272, v272, v273, v274);
      swift_bridgeObjectRelease(v277);
      uint64_t v566 = v275;
      v567 = v276;
    }

    char v279 = v276;
    goto LABEL_149;
  }

  v280 = v541;
  memcpy(v541, v263, v2);
  if ((swift_dynamicCast((char *)&v560, v280, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    char v285 = v560._countAndFlagsBits;
    uint64_t v284 = v560._object;
    uint64_t v286 = v567;
    v287 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000LL) == 0) {
      v287 = v566 & 0xFFFFFFFFFFFFLL;
    }
    if (v287 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v560._countAndFlagsBits, (unint64_t)v560._object);
    }

    else
    {
      swift_bridgeObjectRetain((unint64_t)v560._object, v281, v282, v283);
      swift_bridgeObjectRelease(v286);
      uint64_t v566 = v285;
      v567 = (unint64_t)v284;
    }

    swift_bridgeObjectRelease((uint64_t)v284);
  }

  else
  {
    v414 = v532;
    memcpy(v532, v263, v2);
    char v415 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v414, v1, v415, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v416 = (uint64_t)v561;
      v417 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v417 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v416,  v417);
      goto LABEL_150;
    }

    uint64_t v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v446 = v524;
    memcpy(v524, v263, v2);
    v447 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v446, v1, v447, 6uLL)
      || (uint64_t v565 = 0LL,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  v448 = v514,  memcpy(v514, v263, v2),  v449 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v448, v1, v449, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v450 = (uint64_t)v561;
      v451 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      v452 = (*(uint64_t (**)(uint64_t, uint64_t))(v451 + 8))(v450, v451);
      uint64_t v454 = v453;
      specialized String.write<A>(to:)(&v566, v452, v453, v455);
      char v279 = v454;
LABEL_149:
      swift_bridgeObjectRelease(v279);
LABEL_150:
      __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
      goto LABEL_158;
    }

    uint64_t v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v487 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v487, v263, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v488 = v560._object;
    v489 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v263,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v489);
    swift_release((uint64_t)v488);
  }

LABEL_127:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v83, v82);
              swift_bridgeObjectRelease_n(v33, 4LL);
              if ((v33 & 0x1000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v33);
                uint64_t v86 = v32;
                unint64_t v87 = v33;
                uint64_t v88 = v38;
                goto LABEL_84;
              }

              if (v50)
              {
                swift_bridgeObjectRelease_n(v33, 2LL);
                uint64_t v69 = (v33 >> 62) & 1;
                *(void *)&__int128 v264 = v32;
                *((void *)&v264 + 1) = v33 & 0xFFFFFFFFFFFFFFLL;
                unint64_t v70 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v59, (uint64_t)&v264, v59);
                goto LABEL_55;
              }

  uint64_t v178 = _StringGuts.nativeUnusedCapacity.getter(v175, v96);
  unint64_t v181 = (v179 & 1) == 0 && v178 >= v173;
  if ((v175 & ~v96 & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v96 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v181) {
      goto LABEL_144;
    }
    goto LABEL_138;
  }

  if (!v181)
  {
LABEL_138:
    unint64_t v182 = _StringGuts.nativeCapacity.getter(v175, v96);
    if ((v183 & 1) != 0) {
      unint64_t v184 = 0LL;
    }
    else {
      unint64_t v184 = v182;
    }
    if (v184 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_347;
    }

    unint64_t v185 = 2 * v184;
    if (v185 > v174) {
      unint64_t v174 = v185;
    }
LABEL_144:
    _StringGuts.grow(_:)(v174);
  }

  swift_bridgeObjectRelease_n(v81, 4LL);
  if ((v81 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v81);
    _StringGuts._foreignAppendInPlace(_:)(v79, v81, 0LL, v367);
    swift_bridgeObjectRelease_n(v81, 2LL);
    uint64_t v62 = (uint64_t)v386;
    uint64_t v59 = v387;
    goto LABEL_153;
  }

  uint64_t v59 = v387;
  char v186 = v382;
  if (v89)
  {
    swift_bridgeObjectRelease_n(v81, 2LL);
    uint64_t v388 = v79;
    v389 = v81 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v187 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v62, (uint64_t)&v388, v62);
    _StringGuts.appendInPlace(_:isASCII:)(v187, v188, (v81 & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease(v81);
    uint64_t v62 = (uint64_t)v386;
    uint64_t v89 = (unint64_t)v378;
    goto LABEL_192;
  }

  if ((v79 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v81);
    char v201 = (id)((v81 & 0xFFFFFFFFFFFFFFFLL) + 32);
    unint64_t v202 = (uint64_t)v366;
    unint64_t v203 = (uint64_t)v366;
    uint64_t v62 = (uint64_t)v386;
    uint64_t v89 = (unint64_t)v378;
    goto LABEL_167;
  }

          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index range is out of bounds",  35LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  0xD2uLL,  0);
        }

  uint64_t v103 = _StringObject.sharedUTF8.getter(a3, v21);
  uint64_t v104 = v169;
  if (v169 < a2) {
    goto LABEL_128;
  }
LABEL_72:
  uint64_t v105 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v11, a2, (uint64_t)v103, v104);
  _StringGuts.appendInPlace(_:isASCII:)(v105, v106, a3 < 0);
  swift_bridgeObjectRelease(v21);
LABEL_93:
  unint64_t v143 = __src;
  unint64_t v144 = v180;
  swift_bridgeObjectRelease(*(void *)(a4 + 8));
  *(void *)a4 = v143;
  *(void *)(a4 + 8) = v144;
  return v175;
}

LABEL_261:
            unint64_t v251 = 258LL;
LABEL_262:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v251,  0);
          }

  __break(1u);
LABEL_262:
  v230._rawBits = specialized Collection.dropFirst(_:)(1LL, v246, v247);
  uint64_t v232 = v231;
  *(void *)&Swift::Int v245 = v34;
  *((void *)&v245 + 1) = v22;
  *(void *)&v248 = 0LL;
  *((void *)&v248 + 1) = 0xE000000000000000LL;
  specialized String.UnicodeScalarView.append<A>(contentsOf:)(v230, v249, v233, v231);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRelease(v232);
  return v245;
}

        v282 = 266LL;
        goto LABEL_263;
      }
    }

    else
    {
      if (v2 < 16) {
        goto LABEL_157;
      }
      uint64_t v1 = v288._countAndFlagsBits;
      unint64_t v10 = (unint64_t)v288._object;
    }

    unint64_t v173 = _StringGuts.nativeUnusedCapacity.getter(v1, v10);
    unint64_t v175 = (v174 & 1) != 0 || v173 < v169;
    uint64_t v3 = !v175;
    if ((v1 & ~v10 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v3 & 1) != 0) {
        goto LABEL_183;
      }
    }

    else if ((v3 & 1) != 0)
    {
      goto LABEL_182;
    }

    unint64_t v204 = _StringGuts.nativeCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
    unint64_t v206 = (v205 & 1) != 0 ? 0LL : v204;
    if (v206 + 0x4000000000000000LL >= 0) {
      break;
    }
    __break(1u);
LABEL_255:
    unint64_t v21 = _StringGuts._foreignConvertedToSmall()(v9, v10);
    uint64_t v22 = v279;
LABEL_17:
    v23._rawBits = 1LL;
    v24._rawBits = 1LL;
    v25._rawBits = _StringGuts.validateScalarRange(_:)(v23, v24, 0LL, 0xE000000000000000LL);
    if (v25._rawBits < 0x10000) {
      v25._rawBits |= 3;
    }
    uint64_t v27 = specialized String.init(_:)(v25, v26, 0LL, 0xE000000000000000LL);
    unint64_t v29 = v28;
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v30 = _StringGuts._convertedToSmall()(v27, v29);
    uint64_t v32 = v31;
    swift_bridgeObjectRelease(v29);
    unint64_t v33 = specialized _SmallString.init(_:appending:)(v21, v22, v30, v32);
    if ((v35 & 1) != 0) {
      goto LABEL_261;
    }
    unint64_t v36 = v33;
    unint64_t v37 = v34;
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v38 = (uint64_t)v288._object;
    v288._uint64_t countAndFlagsBits = v36;
    v288._object = v37;
  }

  char v207 = 2 * v206;
  if (v207 > v2) {
    uint64_t v2 = v207;
  }
LABEL_182:
  _StringGuts.grow(_:)(v2);
LABEL_183:
  swift_bridgeObjectRelease_n((uint64_t)v159._object, 4LL);
  if (((uint64_t)v159._object & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v159._object);
    _StringGuts._foreignAppendInPlace(_:)(v159._countAndFlagsBits, (unint64_t)v159._object, 0LL, v166);
  }

  else
  {
    if (v4)
    {
      swift_bridgeObjectRelease_n((uint64_t)v159._object, 2LL);
      *(void *)&v287 = v159._countAndFlagsBits;
      *((void *)&v287 + 1) = (uint64_t)v159._object & 0xFFFFFFFFFFFFFFLL;
      uint64_t v208 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v159._object >> 56) & 0xF,  (uint64_t)&v287,  ((unint64_t)v159._object >> 56) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v208, v209, ((uint64_t)v159._object & 0x4000000000000000LL) != 0);
      unint64_t v203 = (uint64_t)v159._object;
      goto LABEL_188;
    }

    if ((v159._countAndFlagsBits & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v159._object);
      unint64_t v225 = (id)(((uint64_t)v159._object & 0xFFFFFFFFFFFFFFFLL) + 32);
      Swift::String::Index v226 = v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      unint64_t v225 = _StringObject.sharedUTF8.getter(v159._countAndFlagsBits, (uint64_t)v159._object);
      Swift::String::Index v226 = v281;
      swift_bridgeObjectRelease((uint64_t)v159._object);
      if (v226 < (v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
LABEL_260:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    Swift::String::Index v227 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL,  (uint64_t)v225,  v226);
    _StringGuts.appendInPlace(_:isASCII:)(v227, v228, v159._countAndFlagsBits < 0);
  }

  swift_bridgeObjectRelease_n((uint64_t)v159._object, 2LL);
LABEL_205:
  unint64_t v116 = v288._countAndFlagsBits;
  unint64_t v115 = (uint64_t)v288._object;
  Swift::String::Index v229 = ((unint64_t)v288._object >> 56) & 0xF;
  Swift::Int v230 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  else {
    uint64_t v231 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v231 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000LL) == 0)
  {
    v288._uint64_t countAndFlagsBits = 0LL;
    v288._object = (void *)0xE000000000000000LL;
    Swift::String::Index v237 = v115;
    goto LABEL_244;
  }

  if (((uint64_t)v288._object & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(0xE000000000000000LL);
    Swift::String::Index v238 = 0xA000000000000000LL;
    if (!(v115 & 0x80808080808080LL | v116 & 0x8080808080808080LL)) {
      Swift::String::Index v238 = 0xE000000000000000LL;
    }
    Swift::Int v239 = (void *)(v238 & 0xFF00000000000000LL | (v229 << 56) | v115 & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v288._object);
    v288._uint64_t countAndFlagsBits = v116;
    v288._object = v239;
    return v288._countAndFlagsBits;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v210, v211);
  if ((v115 & 0x1000000000000000LL) != 0) {
    goto LABEL_238;
  }
  if ((v116 & ~v115 & 0x2000000000000000LL) != 0) {
    goto LABEL_213;
  }
LABEL_239:
  if (v230 > 15) {
    goto LABEL_218;
  }
LABEL_240:
  swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
  unint64_t v251 = v288._countAndFlagsBits;
  unint64_t v252 = v288._object;
  swift_bridgeObjectRetain((unint64_t)v288._object, v253, v254, v255);
  unint64_t v256 = _StringGuts._convertedToSmall()(v251, (unint64_t)v252);
  uint64_t v258 = v257;
  swift_bridgeObjectRelease((uint64_t)v252);
  v259._rawBits = 1LL;
  v260._rawBits = 1LL;
  v261._rawBits = _StringGuts.validateScalarRange(_:)(v259, v260, 0LL, 0xE000000000000000LL);
  if (v261._rawBits < 0x10000) {
    v261._rawBits |= 3;
  }
  uint64_t v263 = specialized String.init(_:)(v261, v262, 0LL, 0xE000000000000000LL);
  __int128 v265 = v264;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v266 = _StringGuts._convertedToSmall()(v263, v265);
  unint64_t v268 = v267;
  swift_bridgeObjectRelease(v265);
  v269 = specialized _SmallString.init(_:appending:)(v256, v258, v266, v268);
  if ((v271 & 1) != 0) {
    goto LABEL_261;
  }
  uint64_t v272 = v269;
  uint64_t v273 = v270;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  Swift::String::Index v237 = (uint64_t)v288._object;
  v288._uint64_t countAndFlagsBits = v272;
  v288._object = v273;
LABEL_244:
  swift_bridgeObjectRelease(v237);
  return v288._countAndFlagsBits;
}

              unint64_t v143 = v141 & 0xFFFFFFFFFFFFFFFELL;
              if ((v141 & 1) != 0) {
                unint64_t v144 = *(const char **)(v143 + 8);
              }
              else {
                unint64_t v144 = (const char *)(*(int *)(v143 + 8) + v143 + 8);
              }
              goto LABEL_371;
            case 1:
              Swift::String::Index v236 = a8;
              char v66 = (int *)(v13 + 8);
              uint64_t v67 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef( (_BYTE *)(*(int *)(v13 + 8) + v13 + 8),  a2);
              uint64_t v69 = v68;
              unint64_t v70 = *(void *)a5;
              if (v248)
              {
                if (v248 != v247)
                {
                  unint64_t v267 = (uint64_t *)(*(uint64_t (**)(void))(*v248 + 16LL))();
                  size_t v71 = v246;
                  if (v246) {
                    goto LABEL_117;
                  }
LABEL_178:
                  uint64_t v263 = 0LL;
                  goto LABEL_202;
                }

                unint64_t v267 = &v264;
                (*(void (**)(void *, uint64_t *))(v247[0] + 24LL))(v247, &v264);
                size_t v71 = v246;
                if (!v246) {
                  goto LABEL_178;
                }
              }

              else
              {
                unint64_t v267 = 0LL;
                size_t v71 = v246;
                if (!v246) {
                  goto LABEL_178;
                }
              }

LABEL_241:
          __break(1u);
LABEL_242:
          id v124 = _StringObject.sharedUTF8.getter(v32, v33);
          uint64_t v126 = v240;
          swift_bridgeObjectRelease(v33);
          if (v126 >= v259)
          {
            uint64_t v125 = v259;
            goto LABEL_123;
          }

      unint64_t v122 = getSuperclassForMaybeIncompleteMetadata(v122, v124, v125, v127 != 0);
      id v124 = v136;
      uint64_t v125 = 1;
      if (!v122) {
        goto LABEL_255;
      }
    }

    unint64_t v137 = 4;
    unint64_t v138 = &v176;
LABEL_246:
    uint64_t v139 = v137 - 1;
    uint64_t v140 = (v137 - 1) & ((v122 >> 4) ^ (v122 >> 9));
    uint64_t v141 = v138[2 * v140];
    if (v141 == v122)
    {
LABEL_247:
      char v142 = v138[2 * v140 + 1];
      if (v142)
      {
        if (v123)
        {
          uint64_t v129 = swift_getTypeName(v123, 1LL);
          uint64_t v131 = v130;
          Swift::String::Index v132 = swift_getTypeName(v122, 1LL);
          swift::warning( 0LL,  "Warning: '%.*s' conforms to protocol '%s', but it also inherits conformance from '%.*s'.  Relying on a parti cular conformance is undefined behaviour.\n",  v134,  v135,  v131,  v129,  (char *)v172 + v172[2] + 8,  v133,  v132);
        }

        else
        {
          uint64_t v126 = v142;
          unint64_t v123 = v122;
        }
      }
    }

    else
    {
      unint64_t v143 = 1;
      while (v141 != -4096)
      {
        unint64_t v144 = v140 + v143++;
        uint64_t v140 = v144 & v139;
        uint64_t v141 = v138[2 * v140];
        if (v141 == v122) {
          goto LABEL_247;
        }
      }
    }

    goto LABEL_241;
  }

  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  if (!v4)
  {
    WitnessTable = 0LL;
    uint64_t v9 = 0LL;
    goto LABEL_76;
  }

  while (1)
  {
    uint64_t v11 = (unint64_t)v172;
    getContextDescriptor((size_t)v4, (uint64_t)&v175);
    uint64_t v12 = v175;
    uint64_t v13 = v177[0];
    ObjCClassFromMetadataConditional = swift::swift_getObjCClassFromMetadataConditional(v4);
    uint64_t v15 = (unint64_t)ObjCClassFromMetadataConditional;
    if (!byte_18C486EA8) {
      break;
    }
    if (MEMORY[0x1895F8BD0]) {
      __int128 v16 = MEMORY[0x1895F8BB8] == 0LL;
    }
    else {
      __int128 v16 = 1;
    }
    if (v16
      || (!v13
        ? (foreign_type_protocol_conformance = _dyld_find_protocol_conformance_on_disk())
        : (foreign_type_protocol_conformance = _dyld_find_foreign_type_protocol_conformance_on_disk()),
          uint64_t v9 = v18,
          foreign_type_protocol_conformance == 2))
    {
      if (qword_18C486EB0 > v11 || unk_18C486EB8 <= v11) {
        goto LABEL_58;
      }
      if (v13)
      {
        foreign_type_protocol_conformance = _dyld_find_foreign_type_protocol_conformance();
        goto LABEL_64;
      }

      uint64_t v23 = qword_18C486EB0 <= v15 && unk_18C486EB8 > v15;
      if (v23
        || (uint64_t v9 = 0LL, foreign_type_protocol_conformance = 2LL, qword_18C486EB0 <= (unint64_t)v12)
        && unk_18C486EB8 > (unint64_t)v12)
      {
        foreign_type_protocol_conformance = _dyld_find_protocol_conformance();
        goto LABEL_64;
      }
    }

LABEL_243:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
        }

      uint64_t v13 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
      uint64_t v14 = v227;
      goto LABEL_7;
    }
  }

  Swift::String::Index v244 = a2;
  a2 = 0xE000000000000000LL;
  uint64_t v249 = 0LL;
  uint64_t v250 = 0xE000000000000000LL;
  uint64_t v25 = _StringGuts.nativeCapacity.getter(v11, v10);
  uint64_t v26 = 0LL;
  if ((v27 & 1) == 0)
  {
    uint64_t v28 = v25;
    if (v25 > 15)
    {
      unint64_t v29 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v30 & 1) != 0 || v29 < v28)
      {
        uint64_t v32 = 2 * _StringGuts.uniqueNativeCapacity.getter();
        if (v32 <= v28) {
          uint64_t v32 = v28;
        }
        if ((v31 & 1) != 0) {
          unint64_t v33 = v28;
        }
        else {
          unint64_t v33 = v32;
        }
        uint64_t v247 = 0LL;
        v248 = 0LL;
        a2 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( (char *)&v247,  0LL,  v33,  1);
        uint64_t v26 = *(void *)(a2 + 24);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        uint64_t v249 = v26;
        uint64_t v250 = a2;
      }

      else
      {
        uint64_t v26 = 0LL;
        a2 = 0xE000000000000000LL;
      }
    }
  }

  uint64_t v246 = a3;
  Swift::String::Index v241 = (unint64_t *)v5;
  Swift::String::Index v242 = *(void *)(v5 + 8);
  v34._rawBits = a1;
  Swift::String::Index v243 = *(void *)v5;
  uint64_t v5 = specialized Collection.subscript.getter(v34, *(void *)v5, v242);
  a3 = v37;
  a1 = v35;
  uint64_t v11 = v36;
  uint64_t v38 = v37 >> 16;
  to = (unint64_t)v5 >> 16;
  if ((v36 & 0x1000000000000000LL) == 0)
  {
    unint64_t v39 = v38 - ((unint64_t)v5 >> 16);
    swift_bridgeObjectRetain_n(v36, 2LL, v35, (char *)v36);
    if ((a2 & 0x1000000000000000LL) == 0) {
      goto LABEL_27;
    }
LABEL_218:
    uint64_t v208 = String.UTF8View._foreignCount()();
    uint64_t v43 = v208 + v39;
    if (!__OFADD__(v208, v39)) {
      goto LABEL_31;
    }
LABEL_220:
    __break(1u);
    goto LABEL_221;
  }

  swift_bridgeObjectRetain_n(v36, 3LL, v35, (char *)v36);
  v204._rawBits = v5 & 0xFFFFFFFFFFFF0000LL | 1;
  v205._rawBits = a3 & 0xFFFFFFFFFFFF0000LL | 1;
  v206._rawBits = _StringGuts.validateScalarRange(_:)(v204, v205, a1, v11);
  if (v206._rawBits < 0x10000) {
    v206._rawBits |= 3;
  }
  unint64_t v39 = specialized Collection.count.getter(v206, v207, a1, v11);
  swift_bridgeObjectRelease(v11);
  uint64_t v26 = v249;
  a2 = v250;
  if ((v250 & 0x1000000000000000LL) != 0) {
    goto LABEL_218;
  }
LABEL_27:
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v42 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v42 = v26 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v43 = v42 + v39;
  if (__OFADD__(v42, v39)) {
    goto LABEL_220;
  }
LABEL_31:
  Swift::Int v245 = a4;
  uint64_t v44 = a1;
  uint64_t v45 = v26 & ~a2;
  if ((v45 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(a2 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v46 = _StringGuts.nativeUnusedCapacity.getter(v26, a2);
    if ((v47 & 1) != 0) {
      goto LABEL_255;
    }
    if (v43 > 15) {
      goto LABEL_39;
    }
    if ((a2 & 0x2000000000000000LL) == 0)
    {
      if (v46 < v39)
      {
LABEL_63:
        swift_bridgeObjectRelease(v11);
        if ((a2 & 0x1000000000000000LL) != 0)
        {
          a1 = _StringGuts._foreignConvertedToSmall()(v249, a2);
          uint64_t v38 = v228;
        }

        else
        {
          if ((v249 & 0x1000000000000000LL) != 0)
          {
            uint64_t v62 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v63 = v249 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v62 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v249, a2);
            uint64_t v63 = v59;
          }

          swift_bridgeObjectRetain(a2, v59, v60, v61);
          closure #1 in _StringGuts._convertedToSmall()(v62, v63, &v247);
          swift_bridgeObjectRelease(a2);
          a1 = v247;
          uint64_t v38 = v248;
        }

        goto LABEL_70;
      }

LABEL_75:
        BOOL v48 = __OFADD__(v49, v82);
        int64_t v83 = v49 + v82;
        if (!v48) {
          goto LABEL_76;
        }
        goto LABEL_241;
      }

      goto LABEL_163;
    }

    uint64_t v266 = 0LL;
    __int128 v264 = 0u;
    __int128 v265 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v264,  &demangling cache variable for type metadata for CustomStringConvertible?);
    v21(v7, a1, a2);
    unint64_t v90 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (!swift_dynamicCast((char *)&v264, v7, a2, v90, 6uLL))
    {
      uint64_t v266 = 0LL;
      __int128 v264 = 0u;
      __int128 v265 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v264,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
      *((void *)&v265 + 1) = a2;
      uint64_t v129 = __swift_allocate_boxed_opaque_existential_0Tm(&v264);
      v21(v129, a1, a2);
      Mirror.init(reflecting:)((uint64_t *)&v264, (uint64_t)&v260);
      uint64_t v130 = v261;
      uint64_t v131 = v263;
      ((void (*)(uint64_t, unint64_t *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( a1,  &v260,  &v267,  0LL,  a2,  &type metadata for String,  &protocol witness table for String);
      (*(void (**)(uint64_t, swift *))(v4 + 8))(a1, a2);
      swift_release(v131);
      swift_release(v130);
      return v267;
    }

    (*(void (**)(uint64_t, swift *))(v4 + 8))(a1, a2);
    outlined init with take of MirrorPath(&v264, (uint64_t)&v260);
    uint64_t v91 = (uint64_t)v262;
    uint64_t v92 = v263;
    __swift_project_boxed_opaque_existential_0Tm(&v260, (uint64_t)v262);
    uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(v92 + 8))(v91, v92);
    uint64_t v32 = v93;
    unint64_t v33 = v94;
    uint64_t v34 = v267;
    unint64_t v39 = v268;
    unint64_t v97 = HIBYTE(v268) & 0xF;
    if ((v268 & 0x2000000000000000LL) != 0) {
      unint64_t v98 = HIBYTE(v268) & 0xF;
    }
    else {
      unint64_t v98 = v267 & 0xFFFFFFFFFFFFLL;
    }
    if (!v98 && (v267 & ~v268 & 0x2000000000000000LL) == 0)
    {
LABEL_163:
      uint64_t v89 = v39;
      goto LABEL_86;
    }

    uint64_t v99 = v94 & 0x2000000000000000LL;
    uint64_t v38 = HIBYTE(v94) & 0xF;
    if ((v268 & 0x2000000000000000LL) != 0 && v99)
    {
      unint64_t v100 = v97 + v38;
      if (v97 + v38 <= 0xF)
      {
        if (v38)
        {
          char v214 = 0;
          unint64_t v215 = 0LL;
          unint64_t v114 = v268;
          do
          {
            unint64_t v216 = v97 + v215;
            unint64_t v217 = v215 + 1;
            if (v215 >= 8) {
              unint64_t v218 = v94;
            }
            else {
              unint64_t v218 = v93;
            }
            unint64_t v219 = v218 >> (v214 & 0x38);
            char v220 = (8 * v97 + v214) & 0x38;
            uint64_t v221 = (-255LL << v220) - 1;
            unint64_t v222 = (unint64_t)v219 << v220;
            unint64_t v223 = v222 | v221 & v114;
            unint64_t v224 = v222 | v221 & v34;
            if (v216 < 8) {
              uint64_t v34 = v224;
            }
            else {
              unint64_t v114 = v223;
            }
            v214 += 8;
            unint64_t v215 = v217;
          }

          while (v38 != v217);
        }

        else
        {
          unint64_t v114 = v268;
        }

        swift_bridgeObjectRelease(v268);
        swift_bridgeObjectRelease(v33);
        unint64_t v225 = 0xA000000000000000LL;
        if (!(v34 & 0x8080808080808080LL | v114 & 0x80808080808080LL)) {
          unint64_t v225 = 0xE000000000000000LL;
        }
        unint64_t v156 = v225 | (v100 << 56);
        goto LABEL_155;
      }

      uint64_t v99 = 1LL;
    }

    uint64_t v41 = v93 & 0xFFFFFFFFFFFFLL;
    if (v99) {
      uint64_t v101 = HIBYTE(v94) & 0xF;
    }
    else {
      uint64_t v101 = v93 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v94, 2LL, v95, v96);
    if ((v33 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v33, 5LL, v102, v103);
      v241._rawBits = 1LL;
      v242._rawBits = (v101 << 16) | 1;
      v243._rawBits = _StringGuts.validateScalarRange(_:)(v241, v242, v32, v33);
      if (v243._rawBits < 0x10000) {
        v243._rawBits |= 3;
      }
      Swift::Int v107 = specialized Collection.count.getter(v243, v244, v32, v33);
      swift_bridgeObjectRelease(v33);
      if ((v39 & 0x1000000000000000LL) == 0)
      {
LABEL_103:
        BOOL v48 = __OFADD__(v98, v107);
        int64_t v108 = v98 + v107;
        if (!v48)
        {
LABEL_104:
          if ((v34 & ~v39 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v39 & 0xFFFFFFFFFFFFFFFLL))
          {
            uint64_t v109 = v268;
            int64_t v110 = _StringGuts.nativeUnusedCapacity.getter(v267, v268);
            if ((v111 & 1) != 0) {
              goto LABEL_261;
            }
            if (v108 <= 15 && ((v109 & 0x2000000000000000LL) != 0 || v110 < v107))
            {
LABEL_166:
              swift_bridgeObjectRelease_n(v33, 5LL);
              unint64_t v158 = v267;
              swift_bridgeObjectRetain(v109, v159, v160, v161);
              unint64_t v162 = _StringGuts._convertedToSmall()(v158, v109);
              unint64_t v164 = v163;
              swift_bridgeObjectRelease(v109);
              v165._rawBits = (v101 << 16) | 1;
              v166._rawBits = 1LL;
              v167._rawBits = _StringGuts.validateScalarRange(_:)(v166, v165, v32, v33);
              if (v167._rawBits < 0x10000) {
                v167._rawBits |= 3;
              }
              unint64_t v169 = specialized String.init(_:)(v167, v168, v32, v33);
              unint64_t v171 = v170;
              swift_bridgeObjectRelease(v33);
              unint64_t v172 = _StringGuts._convertedToSmall()(v169, v171);
              unint64_t v174 = v173;
              swift_bridgeObjectRelease(v171);
              unint64_t v175 = specialized _SmallString.init(_:appending:)(v162, v164, v172, v174);
              if ((v177 & 1) == 0)
              {
                uint64_t v178 = v175;
                unint64_t v179 = v176;
                swift_bridgeObjectRelease(v109);
                swift_bridgeObjectRelease(v33);
                unint64_t v267 = v178;
                unint64_t v268 = v179;
                goto LABEL_204;
              }

          int64_t v51 = 1860LL;
LABEL_76:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v51,  0);
        }

        char v57 = a5;
        uint64_t v58 = a6 & 0xFFFFFFFFFFFFFFLL;
        if (a7 < 0) {
          goto LABEL_75;
        }
        if ((uint64_t)(HIBYTE(a6) & 0xF) >= a8)
        {
          uint64_t v41 = a8 - a7;
          if (v41 >= 0)
          {
            if ((_DWORD)v17)
            {
              if ((a9 & 1) != 0 || v21 == v41)
              {
                if (v41 >= v21) {
                  uint64_t v42 = v21;
                }
                else {
                  uint64_t v42 = v41;
                }
                uint64_t v38 = _swift_stdlib_memcmp(v20, (char *)&v57 + a7, v42);
                unint64_t v39 = v38;
                unint64_t v40 = v23 - v41;
                goto LABEL_44;
              }

              return 0;
            }

            uint64_t v54 = (char *)&v57 + a7;
            uint64_t v43 = v41;
            return _stringCompareFastUTF8Abnormal(_:_:expecting:)((uint64_t)v20, v21, (uint64_t)v54, v43, v15);
          }

      uint64_t v65 = (unint64_t)v63[2];
      uint64_t v64 = (unint64_t)v63[3];
      if (v65 >= v64 >> 1)
      {
        uint64_t v63 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v64 > 1),  v65 + 1,  1,  (uint64_t)v63);
        unint64_t v87 = v63;
      }

      v63[2] = (__objc2_class *)(v65 + 1);
      char v66 = &v63[v65];
      *((_DWORD *)v66 + 8) = v61;
      *((_WORD *)v66 + 18) = WORD2(v61);
      uint64_t v62 = v16;
LABEL_78:
      uint64_t v61 = specialized Unicode._InternalNFD.Iterator.next()();
      uint64_t v19 = 0;
      if ((v61 & 0x1000000000000LL) == 0) {
        goto LABEL_79;
      }
      uint64_t v68 = 0;
      __int128 v16 = 0LL;
      uint64_t v19 = 1;
      if ((v83 & 1) == 0) {
        goto LABEL_109;
      }
      goto LABEL_122;
    }

  uint64_t v95 = HIBYTE(v88) & 0xF;
  if ((v88 & 0x2000000000000000LL) == 0) {
    uint64_t v95 = v87 & 0xFFFFFFFFFFFFLL;
  }
  if (v95 || (v87 & ~v88 & 0x2000000000000000LL) != 0)
  {
    if ((v88 & 0x2000000000000000LL) == 0
      || (char v96 = specialized _SmallString.init(_:appending:)(v87, v88, 0x283EuLL, 0xE200000000000000LL), (v93 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v92, v93, v94);
      _StringGuts.append(_:)(10302LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      unint64_t v97 = v96;
      unint64_t v98 = v92;
      swift_bridgeObjectRelease(v88);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v273 = v97;
      uint64_t v274 = v98;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v88);
    uint64_t v273 = 10302LL;
    uint64_t v274 = 0xE200000000000000LL;
  }

  uint64_t v99 = *(const char **)(v1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v99,  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD4Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v99,  (uint64_t)v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v102 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v103 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v102(0LL, v103, AssociatedConformanceWitness);
  unint64_t v268 = (uint64_t *)v2;
  uint64_t v104 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v104, v46, v3);
  uint64_t v105 = v268;
  Swift::String::Index v106 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  DynamicType = (void *)swift_getDynamicType(v106, v105, 1);
  LODWORD(v105) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if ((_DWORD)v105)
  {
    int64_t v108 = v266;
    memcpy(v266, v46, v3);
    uint64_t v109 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v267, v108, v2, v109, 7uLL);
    int64_t v110 = (uint64_t)v268;
    char v111 = v269;
    __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
    unint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t))(v111 + 8))(v110, v111);
    unint64_t v114 = v112;
    unint64_t v115 = HIBYTE(v274) & 0xF;
    if ((v274 & 0x2000000000000000LL) == 0) {
      unint64_t v115 = v273 & 0xFFFFFFFFFFFFLL;
    }
    if (v115 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
    {
LABEL_88:
      _StringGuts.append(_:)(v113, v112);
      swift_bridgeObjectRelease(v114);
LABEL_89:
      __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      goto LABEL_92;
    }

    swift::getTypePackByMangledName((uint64_t)v26, v28, v273, v271, (uint64_t)&v260);
    uint64_t v44 = v272;
    if (v272 == v271)
    {
      uint64_t v44 = v271;
      uint64_t v45 = 4LL;
    }

    else
    {
      if (!v272) {
        goto LABEL_80;
      }
      uint64_t v45 = 5LL;
    }

    (*(void (**)(void))(*v44 + 8 * v45))();
LABEL_80:
    uint64_t v46 = v274;
    if (v274 == v273)
    {
      uint64_t v46 = v273;
      Swift::Int v47 = 4LL;
      goto LABEL_84;
    }

    if (v274)
    {
      Swift::Int v47 = 5LL;
LABEL_84:
      (*(void (**)(void))(*v46 + 8 * v47))();
    }

    if (v262 == 1)
    {
      BOOL v48 = v260;
      Swift::Int v49 = v261;
      *(void *)(a9 + 8) = v261;
      uint64_t v50 = (void *)v49(v48, 2LL, 0LL);
LABEL_87:
      *(void *)a9 = v50;
      *(_BYTE *)(a9 + 16) = 1;
      goto LABEL_381;
    }

    if (v262) {
      int64_t v51 = 0LL;
    }
    else {
      int64_t v51 = v260;
    }
    char v52 = *(_DWORD *)v13 & 0x1F;
    switch(v52)
    {
      case 0:
        unint64_t v256 = &v258;
        unint64_t v257 = 0x400000000LL;
        if ((v51 & 1) == 0) {
          goto LABEL_430;
        }
        uint64_t v53 = v51 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v54 = *(void *)((v51 & 0xFFFFFFFFFFFFFFFELL) - 8);
        if (!v54) {
          goto LABEL_165;
        }
        unint64_t v55 = 0LL;
        int64_t v56 = (int *)(v13 + 8);
        do
        {
          uint64_t v59 = *(void *)(v53 + 8 * v55);
          unint64_t v268 = 0LL;
          uint64_t v60 = *v56;
          if ((v60 & 2) != 0)
          {
            uint64_t v62 = (unint64_t)v56 + (v60 & 0xFFFFFFFFFFFFFFFCLL);
            if ((v60 & 1) != 0) {
              uint64_t v62 = *(void *)v62;
            }
            uint64_t v61 = (const char *)(v62 | 1);
          }

          else if ((v60 & 0xFFFFFFFD) != 0)
          {
            uint64_t v61 = (char *)v56 + (v60 & 0xFFFFFFFFFFFFFFFCLL);
            if ((v60 & 1) != 0) {
              uint64_t v61 = *(const char **)v61;
            }
          }

          else
          {
            uint64_t v61 = 0LL;
          }

          uint64_t v63 = swift::_conformsToProtocol(0LL, v59, v61, (uint64_t *)&v268);
          uint64_t v64 = *v56;
          if ((v63 & 1) == 0)
          {
            if ((v64 & 2) != 0)
            {
              unint64_t v203 = (unint64_t)v56 + (v64 & 0xFFFFFFFFFFFFFFFCLL);
              if ((v64 & 1) != 0) {
                unint64_t v203 = *(void *)v203;
              }
              char v111 = v203 | 1;
              goto LABEL_366;
            }

            if ((v64 & 0xFFFFFFFD) != 0)
            {
              char v111 = (uint64_t)v56 + (v64 & 0xFFFFFFFFFFFFFFFCLL);
              if ((v64 & 1) == 0)
              {
                if (!v111) {
                  goto LABEL_377;
                }
LABEL_366:
                unint64_t v204 = v111 & 0xFFFFFFFFFFFFFFFELL;
                if ((v111 & 1) != 0) {
                  unint64_t v205 = *(const char **)(v204 + 8);
                }
                else {
                  unint64_t v205 = (const char *)(*(int *)(v204 + 8) + v204 + 8);
                }
                goto LABEL_378;
              }

              char v111 = *(void *)v111;
              if (v111) {
                goto LABEL_366;
              }
            }

  uint64_t v5 = (void *)&unk_18C486000;
LABEL_76:
  if (v6) {
    uint64_t v28 = v7 == 255;
  }
  else {
    uint64_t v28 = 0;
  }
  unint64_t v29 = v28;
  if (*v169) {
    uint64_t v30 = 1;
  }
  else {
    uint64_t v30 = v29;
  }
  *unint64_t v169 = v30;
  if (qword_18C486EB0 && byte_18C486EC1)
  {
    uint64_t v159 = WitnessTable;
    unint64_t v161 = v9;
    uint64_t v32 = (uint64_t)v172;
    uint64_t v31 = (uint64_t)v173;
    unint64_t v33 = v171;
    unint64_t v175 = v177;
    unint64_t v176 = (__swift::__runtime::llvm *)0x800000000LL;
    do
      uint64_t v34 = __ldaxr(&qword_18C486ED0);
    while (__stxr(v34 + 1, &qword_18C486ED0));
    if (qword_18C486ED8)
    {
      unint64_t v35 = atomic_load((unint64_t *)qword_18C486ED8);
      if (v35)
      {
        unint64_t v36 = qword_18C486ED8 + 8;
        spida = qword_18C486ED8 + 8 + 16 * v35;
        while (1)
        {
          unint64_t v37 = *(int **)v36;
          uint64_t v38 = *(int **)(v36 + 8);
          Swift::String::Index v168 = v36;
          while (v37 != v38)
          {
            unint64_t v39 = (int *)((char *)v37 + *v37);
            unint64_t v40 = *v39;
            if ((_DWORD)v40)
            {
              uint64_t v41 = (void *)((char *)v39 + (v40 & 0xFFFFFFFFFFFFFFFELL));
              if ((v40 & 1) != 0) {
                uint64_t v41 = (void *)*v41;
              }
              if (v41 != (void *)v32) {
                goto LABEL_95;
              }
            }

            else if (v32)
            {
              goto LABEL_95;
            }

            uint64_t v42 = v39 + 1;
            uint64_t v43 = (v39[3] >> 3) & 7;
            if (v43 == 1)
            {
              uint64_t v45 = *(const char **)((char *)v42 + *v42);
              if (v45) {
                goto LABEL_110;
              }
            }

            else if (!v43)
            {
              uint64_t v44 = *v42;
              if ((_DWORD)v44)
              {
                uint64_t v45 = (char *)v42 + v44;
                if ((int *)((char *)v42 + v44))
                {
LABEL_110:
                  if (!v31) {
                    goto LABEL_95;
                  }
                  goto LABEL_114;
                }
              }
            }

            uint64_t v46 = swift::TargetProtocolConformanceDescriptor<swift::InProcess>::getCanonicalTypeMetadata((uint64_t)v39);
            if (v46)
            {
              if (!v31) {
                goto LABEL_95;
              }
              uint64_t v45 = (const char *)v46;
              Swift::Int v47 = 0;
              goto LABEL_117;
            }

            if (!v31) {
              goto LABEL_95;
            }
            uint64_t v45 = 0LL;
LABEL_114:
            getContextDescriptor(v31, (uint64_t)buf);
            Swift::Int v47 = 1;
LABEL_117:
            BOOL v48 = getSuperclassForMaybeIncompleteMetadata(v31, 0LL, 0, v33 != 0);
            if (!v48) {
              goto LABEL_95;
            }
            uint64_t v50 = v48;
            int64_t v51 = v49;
            while ((v47 & 1) == 0)
            {
LABEL_120:
              uint64_t v50 = getSuperclassForMaybeIncompleteMetadata(v50, v51, 1, v33 != 0);
              int64_t v51 = v52;
              if (!v50) {
                goto LABEL_95;
              }
            }

            getContextDescriptor(v50, (uint64_t)buf);
            uint64_t v45 = (const char *)v50;
LABEL_125:
            if (v45)
            {
LABEL_126:
              uint64_t v53 = v176;
              if (v176 >= (unint64_t)HIDWORD(v176))
              {
                __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod( (uint64_t)&v175,  v177,  v176 + 1LL,  8LL);
                uint64_t v53 = v176;
              }

              *((void *)v175 + v53) = v39;
              LODWORD(v176) = (_DWORD)v176 + 1;
            }

LABEL_260:
              unint64_t v251 = 266LL;
              goto LABEL_262;
            }
          }

          else if (v108 <= 15)
          {
            uint64_t v109 = v268;
            goto LABEL_166;
          }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v108, v107);
          swift_bridgeObjectRelease_n(v33, 4LL);
          if ((v33 & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v33);
            uint64_t v86 = v32;
            unint64_t v87 = v33;
            uint64_t v88 = v101;
            goto LABEL_84;
          }

          if (v99)
          {
            swift_bridgeObjectRelease_n(v33, 2LL);
            *(void *)&__int128 v264 = v32;
            *((void *)&v264 + 1) = v33 & 0xFFFFFFFFFFFFFFLL;
            unint64_t v70 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v33) & 0xF,  (uint64_t)&v264,  HIBYTE(v33) & 0xF);
            uint64_t v72 = (v33 >> 62) & 1;
            goto LABEL_56;
          }

          goto LABEL_171;
        }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }

      goto LABEL_82;
    }

    if ((v66->i16[0] & 0x8080) == 0)
    {
      char v66 = (uint8x16_t *)((char *)v66 + 2);
      goto LABEL_78;
    }

LABEL_187:
        v191._rawBits = (v38 << 16) | 1;
        v192._rawBits = 1LL;
        v193._rawBits = _StringGuts.validateScalarRange(_:)(v192, v191, v32, v33);
        if (v193._rawBits < 0x10000) {
          v193._rawBits |= 3;
        }
        unint64_t v195 = specialized String.init(_:)(v193, v194, v32, v33);
        unint64_t v197 = v196;
        swift_bridgeObjectRelease(v33);
        if ((v197 & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v197);
        }

        else if ((v197 & 0x1000000000000000LL) != 0)
        {
          unint64_t v195 = _StringGuts._foreignConvertedToSmall()(v195, v197);
          unint64_t v257 = v256;
          swift_bridgeObjectRelease(v197);
          unint64_t v197 = v257;
        }

        else
        {
          if ((v195 & 0x1000000000000000LL) != 0)
          {
            v248 = (unsigned __int8 *)((v197 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v249 = v195 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            v248 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v195, v197);
          }

          closure #1 in _StringGuts._convertedToSmall()(v248, v249, &v264);
          swift_bridgeObjectRelease(v197);
          unint64_t v197 = *((void *)&v264 + 1);
          unint64_t v195 = v264;
        }

        uint64_t v198 = HIBYTE(v39) & 0xF;
        uint64_t v199 = HIBYTE(v197) & 0xF;
        uint64_t v200 = v199 + v198;
        if ((unint64_t)(v199 + v198) <= 0xF)
        {
          if (v199)
          {
            char v201 = 0;
            unint64_t v202 = 0LL;
            do
            {
              unint64_t v203 = v198 + v202;
              unint64_t v204 = v202 + 1;
              if (v202 >= 8) {
                unint64_t v205 = v197;
              }
              else {
                unint64_t v205 = v195;
              }
              unint64_t v206 = v205 >> (v201 & 0x38);
              char v207 = (8 * v198 + v201) & 0x38;
              uint64_t v208 = (-255LL << v207) - 1;
              unint64_t v209 = (unint64_t)v206 << v207;
              unint64_t v210 = v209 | v208 & v39;
              unint64_t v211 = v209 | v208 & v101;
              if (v203 < 8) {
                uint64_t v101 = v211;
              }
              else {
                unint64_t v39 = v210;
              }
              v201 += 8;
              unint64_t v202 = v204;
            }

            while (v199 != v204);
          }

          swift_bridgeObjectRelease(v34);
          swift_bridgeObjectRelease(v33);
          unint64_t v212 = 0xA000000000000000LL;
          if (!(v101 & 0x8080808080808080LL | v39 & 0x80808080808080LL)) {
            unint64_t v212 = 0xE000000000000000LL;
          }
          unint64_t v267 = v101;
          unint64_t v268 = v212 & 0xFF00000000000000LL | (v200 << 56) | v39 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_204;
        }

        goto LABEL_260;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(v33, 4LL, v102, v103);
      Swift::Int v107 = v101;
      if ((v39 & 0x1000000000000000LL) == 0) {
        goto LABEL_103;
      }
    }

    Swift::Int v245 = String.UTF8View._foreignCount()();
    int64_t v108 = v245 + v107;
    if (!__OFADD__(v245, v107)) {
      goto LABEL_104;
    }
    goto LABEL_249;
  }

  (*(void (**)(uint64_t, swift *))(v4 + 8))(a1, a2);
  uint64_t v54 = v260;
  uint64_t v53 = v261;
  unint64_t v55 = HIBYTE(v268) & 0xF;
  if ((v268 & 0x2000000000000000LL) == 0) {
    unint64_t v55 = v267 & 0xFFFFFFFFFFFFLL;
  }
  if (v55 || (v267 & ~v268 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(v260, v261);
    swift_bridgeObjectRelease(v53);
  }

  else
  {
    swift_bridgeObjectRelease(v268);
    unint64_t v267 = v54;
    unint64_t v268 = v53;
  }

  return v267;
}

          if ((v39 & ~v36 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v36 & 0xFFFFFFFFFFFFFFFLL))
          {
            Swift::String::Index v166 = _StringGuts.nativeUnusedCapacity.getter(v39, v36);
            if ((v162 & 1) != 0) {
              goto LABEL_309;
            }
            Swift::String::Index v167 = (v36 >> 61) & 1;
            if (v166 < v40) {
              LOBYTE(v167) = 1;
            }
            if (v45 <= 15 && (v167 & 1) != 0)
            {
LABEL_194:
              swift_bridgeObjectRetain(v36, v162, v46, v47);
              Swift::String::Index v168 = _StringGuts._convertedToSmall()(v39, v36);
              unint64_t v169 = v43;
              unint64_t v171 = v170;
              swift_bridgeObjectRelease(v36);
              v172._rawBits = (v37 << 16) | 1;
              v173._rawBits = 1LL;
              unint64_t v174 = _StringGuts.validateScalarRange(_:)(v173, v172, v169, a2);
              uint64_t v178 = v175;
              if (v174 >= 0x10000) {
                unint64_t v179 = v174;
              }
              else {
                unint64_t v179 = v174 | 3;
              }
              swift_bridgeObjectRetain(a2, v175, v176, v177);
              v180._rawBits = v179;
              v181._rawBits = v178;
              unint64_t v182 = specialized String.init(_:)(v180, v181, v169, a2);
              unint64_t v184 = v183;
              swift_bridgeObjectRelease(a2);
              unint64_t v185 = _StringGuts._convertedToSmall()(v182, v184);
              uint64_t v187 = v186;
              swift_bridgeObjectRelease(v184);
              unint64_t v188 = specialized _SmallString.init(_:appending:)(v168, v171, v185, v187);
              if ((v190 & 1) != 0) {
                goto LABEL_308;
              }
              Swift::String::Index v191 = v188;
              Swift::String::Index v192 = v189;
              swift_bridgeObjectRelease(v36);
              uint64_t v307 = v191;
              char v308 = v192;
              a2 = (unint64_t)v300;
              uint64_t v43 = v302;
              goto LABEL_208;
            }
          }

          else if (v45 <= 15)
          {
            goto LABEL_194;
          }

          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v45, v40);
          if ((a2 & 0x1000000000000000LL) != 0)
          {
            _StringGuts._foreignAppendInPlace(_:)(v43, a2, 0LL, v37);
          }

          else if ((a2 & 0x2000000000000000LL) != 0)
          {
            unint64_t v305 = v43;
            uint64_t v306 = v293;
            if (v295 < v37) {
              goto LABEL_284;
            }
            unint64_t v255 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v37, (uint64_t)&v305, v295);
            _StringGuts.appendInPlace(_:isASCII:)(v255, v256, (a2 & 0x4000000000000000LL) != 0);
          }

          else
          {
            unint64_t v195 = v292;
            unint64_t v196 = v297;
            if ((v43 & 0x1000000000000000LL) == 0)
            {
              unint64_t v195 = (uint64_t)_StringObject.sharedUTF8.getter(v43, a2);
              unint64_t v196 = v276;
            }

            unint64_t v197 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v37, v195, v196);
            _StringGuts.appendInPlace(_:isASCII:)(v197, v198, v43 < 0);
          }

        unint64_t v251 = 258LL;
LABEL_188:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v251,  0);
      }
    }

    else if (v68 > 15)
    {
      goto LABEL_29;
    }

    swift_bridgeObjectRelease(v63);
    swift_bridgeObjectRetain(v66, v76, v77, v78);
    uint64_t v79 = _StringGuts._convertedToSmall()(v67, v66);
    unint64_t v81 = v80;
    swift_bridgeObjectRelease(v66);
    v82._rawBits = v59 & 0xFFFFFFFFFFFF0000LL | 1;
    v83._rawBits = v61 & 0xFFFFFFFFFFFF0000LL | 1;
    v84._rawBits = _StringGuts.validateScalarRange(_:)(v82, v83, v62, v63);
    if (v84._rawBits < 0x10000) {
      v84._rawBits |= 3;
    }
    uint64_t v86 = specialized String.init(_:)(v84, v85, v62, v63);
    uint64_t v88 = v87;
    swift_bridgeObjectRelease(v63);
    uint64_t v89 = _StringGuts._convertedToSmall()(v86, v88);
    uint64_t v91 = v90;
    swift_bridgeObjectRelease(v88);
    uint64_t v92 = HIBYTE(v81) & 0xF;
    uint64_t v93 = HIBYTE(v91) & 0xF;
    unint64_t v94 = v93 + v92;
    if ((unint64_t)(v93 + v92) > 0xF)
    {
LABEL_186:
      unint64_t v251 = 266LL;
      goto LABEL_188;
    }

    uint64_t v95 = v265;
    if (v93)
    {
      char v96 = 0;
      unint64_t v97 = 0LL;
      do
      {
        unint64_t v98 = v92 + v97;
        uint64_t v99 = v97 + 1;
        if (v97 >= 8) {
          unint64_t v100 = v91;
        }
        else {
          unint64_t v100 = v89;
        }
        uint64_t v101 = v100 >> (v96 & 0x38);
        uint64_t v102 = (8 * v92 + v96) & 0x38;
        uint64_t v103 = (-255LL << v102) - 1;
        uint64_t v104 = (unint64_t)v101 << v102;
        uint64_t v105 = v104 | v103 & v81;
        Swift::String::Index v106 = v104 | v103 & v79;
        if (v98 < 8) {
          uint64_t v79 = v106;
        }
        else {
          unint64_t v81 = v105;
        }
        v96 += 8;
        unint64_t v97 = v99;
      }

      while (v93 != v99);
    }

    swift_bridgeObjectRelease(v66);
    Swift::Int v107 = 0xA000000000000000LL;
    if (!(v79 & 0x8080808080808080LL | v81 & 0x80808080808080LL)) {
      Swift::Int v107 = 0xE000000000000000LL;
    }
    __src = v79;
    v270 = v107 & 0xFF00000000000000LL | (v94 << 56) | v81 & 0xFFFFFFFFFFFFFFLL;
    goto LABEL_70;
  }

  unint64_t v254 = v38;
  unint64_t v252 = v37;
  unint64_t v253 = v36;
  if (!swift_isUniquelyReferenced_nonNull_native(v42 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v41 = *v266;
    uint64_t v42 = v266[1];
    goto LABEL_14;
  }

  uint64_t v43 = *(void *)(Description + 16);
  uint64_t v45 = (Swift::UInt64)v263;
  uint64_t v44 = v264;
  ((void (*)(uint64_t *, unint64_t *, ValueMetadata *))v43)(v40, v264, v263);
  if (!swift_dynamicCast( (char *)&__src,  v40,  (swift *)v45,  (const char *)&type metadata for String,  6uLL))
  {
    ((void (*)(uint64_t *, unint64_t *, Swift::UInt64))v43)(v35, v44, v45);
    uint64_t v46 = v272;
    if ((v272 & 0x1000000000000000LL) != 0)
    {
LABEL_140:
      swift_bridgeObjectRelease(v46);
      uint64_t v44 = v264;
LABEL_141:
      ((void (*)(char *, unint64_t *, Swift::UInt64))v43)(v20, v44, v45);
      char v214 = v254;
      (*(void (**)(uint64_t, char *, Swift::UInt64))(Description + 32))(v254, v20, v45);
      unint64_t v215 = (void *)(v214 + *(int *)(v9 + 44));
      *unint64_t v215 = closure #3 in _StringGuts.replaceSubrange<A>(_:with:);
      v215[1] = 0LL;
      unint64_t v216 = v255;
      uint64_t v46 = WitnessTable;
      unint64_t v217 = v259;
      unint64_t v218 = v260;
      FlattenSequence<>.startIndex.getter(v259, WitnessTable, v260, v255);
      (*(void (**)(Swift::UInt64, Swift::Int))(v6 + 72))(v45, v6);
      unint64_t v219 = v257;
      char v220 = (char *)v15 + *(int *)(v257 + 44);
      *(void *)char v220 = 0LL;
      v220[8] = 1;
      uint64_t v20 = (char *)FlattenSequence<>.distance(from:to:)((uint64_t)v216, (uint64_t)v15, v217, v46, (uint64_t)v218);
      uint64_t v221 = *(void (**)(unint64_t *, uint64_t))(v256 + 8);
      v221(v15, v219);
      Swift::Int v47 = ((uint64_t (*)(char *, uint64_t))v221)(v216, v219);
      uint64_t v50 = (const char *)(v265 >> 16);
      unint64_t v222 = &v20[v265 >> 16];
      if (__OFADD__(v265 >> 16, v20))
      {
        __break(1u);
      }

      else
      {
        uint64_t v109 = v262 >> 16;
        Description = (uint64_t)v266;
        unint64_t v223 = v266[1];
        if ((v223 & 0x2000000000000000LL) != 0) {
          unint64_t v224 = HIBYTE(v223) & 0xF;
        }
        else {
          unint64_t v224 = *v266 & 0xFFFFFFFFFFFFLL;
        }
        unint64_t v225 = v224 - v109;
        Swift::String::Index v226 = (uint64_t)&v222[v225];
        if (!__OFADD__(v222, v225))
        {
          if (v226 < 16) {
            goto LABEL_169;
          }
          Swift::String::Index v227 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v228 & 1) == 0 && v227 >= v226) {
            goto LABEL_169;
          }
          Swift::String::Index v229 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v230 & 1) != 0)
          {
            uint64_t v232 = *(void *)(Description + 8);
            if ((v232 & 0x1000000000000000LL) != 0)
            {
              uint64_t v231 = String.UTF8View._foreignCount()();
            }

            else if ((v232 & 0x2000000000000000LL) != 0)
            {
              uint64_t v231 = HIBYTE(v232) & 0xF;
            }

            else
            {
              uint64_t v231 = *(void *)Description & 0xFFFFFFFFFFFFLL;
            }
          }

          else
          {
            uint64_t v231 = 2 * v229;
          }

          if (v231 <= v226) {
            int64_t v110 = v226;
          }
          else {
            int64_t v110 = v231;
          }
          uint64_t v233 = *(void *)(Description + 8);
          if ((v233 & 0x1000000000000000LL) == 0)
          {
            uint64_t v234 = *(void *)Description;
            if ((v233 & 0x2000000000000000LL) != 0)
            {
              Swift::String::Index v238 = HIBYTE(v233) & 0xF;
              __src = *(void *)Description;
              v270 = v233 & 0xFFFFFFFFFFFFFFLL;
              Swift::Int v239 = v238 | 0xC000000000000000LL;
              if ((v233 & 0x4000000000000000LL) == 0) {
                Swift::Int v239 = HIBYTE(v233) & 0xF;
              }
              uint64_t v240 = v239 | 0x3000000000000000LL;
              Swift::String::Index v237 = _allocateStringStorage(codeUnitCapacity:)(v110);
              *(void *)(v237 + 16) = v241;
              *(void *)(v237 + 24) = v240;
              if (v241 < 0)
              {
                *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
                uint64_t v240 = *(void *)(v237 + 24);
              }

              *(_BYTE *)(v237 + 32 + (v240 & 0xFFFFFFFFFFFFLL)) = 0;
              specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v238, (char *)(v237 + 32));
            }

            else
            {
              if ((v234 & 0x1000000000000000LL) != 0)
              {
                Swift::String::Index v235 = (char *)((v233 & 0xFFFFFFFFFFFFFFFLL) + 32);
                Swift::String::Index v236 = v234 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                Swift::String::Index v235 = (char *)_StringObject.sharedUTF8.getter(*(void *)Description, v233);
              }

              Swift::String::Index v237 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v235,  v236,  v110,  v234 < 0);
            }

            Swift::String::Index v242 = *(void *)(v237 + 24);
            swift_bridgeObjectRelease(*(void *)(Description + 8));
            *(void *)Description = v242;
            *(void *)(Description + 8) = v237;
            goto LABEL_169;
          }

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance AnyHashable()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 48))(v5, v1, v2);
  v4[0] = 0LL;
  v4[1] = 0xE000000000000000LL;
  _print_unlocked<A, B>(_:_:)( (uint64_t)v5,  (uint64_t)v4,  (swift *)byte_189B8D218,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v5);
  return v4[0];
}

unint64_t AnyHashable.debugDescription.getter()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = v0[4];
  __swift_project_boxed_opaque_existential_0Tm(v0, v1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v2 + 48))(v11, v1, v2);
  uint64_t v9 = 0LL;
  unint64_t v10 = 0xE000000000000000LL;
  _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)v11,  (uint64_t)&v9,  (swift *)byte_189B8D218,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t v3 = v10;
  unint64_t v4 = specialized static String.+ infix(_:_:)(0x6168736148796E41uLL, 0xEC00000028656C62LL, v9, v10);
  unint64_t v6 = v5;
  swift_bridgeObjectRelease(v3);
  unint64_t v7 = specialized static String.+ infix(_:_:)(v4, v6, 41LL, 0xE100000000000000LL);
  swift_bridgeObjectRelease(v6);
  return v7;
}

uint64_t AnyHashable.customMirror.getter@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  unint64_t v4 = swift_allocObject(v3, 0x50uLL, 7uLL);
  *((_OWORD *)v4 + 1) = xmmword_1817FFC60;
  v4[4] = 0x65756C6176LL;
  v4[5] = 0xE500000000000000LL;
  uint64_t v5 = v1[3];
  uint64_t v6 = v1[4];
  __swift_project_boxed_opaque_existential_0Tm(v1, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(v5, v6);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)( (uint64_t)v8,  (uint64_t)v4,  8,  0LL,  0LL,  a1);
}

__n128 protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance AnyHashable@<Q0>( uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = *(void *)(v1 + 32);
  return result;
}

uint64_t _swift_makeAnyHashableUsingDefaultRepresentation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = type metadata accessor for _ConcreteHashableBox(0LL, a3, a4, a4);
  uint64_t v11 = &protocol witness table for _ConcreteHashableBox<A>;
  unint64_t v7 = __swift_allocate_boxed_opaque_existential_0Tm(&v9);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(v7, a1, a3);
  return outlined assign with take of AnyHashable(&v9, a2);
}

double _swift_convertToAnyHashableIndirect(uint64_t a1, uint64_t a2, uint64_t (***a3)(), uint64_t a4)
{
  uint64_t v8 = (char *)&v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v9 + 16))(v8);
  AnyHashable.init<A>(_:)((uint64_t)v8, a3, a4, (uint64_t)v13);
  double result = *(double *)v13;
  __int128 v11 = v13[1];
  *(_OWORD *)a2 = v13[0];
  *(_OWORD *)(a2 + 16) = v11;
  *(void *)(a2 + 32) = v14;
  return result;
}

uint64_t _swift_anyHashableDownCastConditionalIndirect(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for Optional(0LL, a3, a3, a4);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  __int128 v11 = (char *)&v27[-1] - v10;
  uint64_t v12 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v27[-1] - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  outlined init with copy of AnyHashable(a1, (uint64_t)v28);
  uint64_t v15 = v29;
  uint64_t v16 = v30;
  __swift_project_boxed_opaque_existential_0Tm(v28, v29);
  if (((*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v16 + 64))(a2, a3, v15, v16) & 1) != 0)
  {
    uint64_t v17 = 1LL;
  }

  else
  {
    uint64_t v18 = v29;
    uint64_t v19 = v30;
    __swift_project_boxed_opaque_existential_0Tm(v28, v29);
    (*(void (**)(id *__return_ptr, uint64_t, uint64_t))(v19 + 48))(v27, v18, v19);
    v27[0] = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v27, (uint64_t *)&unk_189B8D218, v20, v21);
    char v22 = swift_dynamicCast(v11, v27, &unk_189B8D230, a3, 6LL);
    uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 56);
    if ((v22 & 1) != 0)
    {
      uint64_t v17 = 1LL;
      v23(v11, 0LL, 1LL, a3);
      uint64_t v24 = *(void (**)(char *, char *, uint64_t))(v12 + 32);
      v24(v14, v11, a3);
      v24(a2, v14, a3);
    }

    else
    {
      v23(v11, 1LL, 1LL, a3);
      (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
      uint64_t v17 = 0LL;
    }
  }

  outlined destroy of AnyHashable(v28);
  return v17;
}

uint64_t UnsafeRawPointer.load<A>(fromByteOffset:as:)@<X0>( char a1@<W0>, char a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return UnsafeRawPointer.load<A>(fromByteOffset:as:)(a1, a2, a3, 0x1B8uLL, a4);
}

uint64_t static UInt64.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

BOOL static UInt64.>= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 >= a2;
}

BOOL static UInt64.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 < a2;
}

BOOL static UInt64.> infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 < a1;
}

unint64_t static UInt.- infix(_:_:)(unint64_t a1, unint64_t a2)
{
  BOOL v2 = a1 >= a2;
  unint64_t result = a1 - a2;
  if (!v2) {
    __break(1u);
  }
  return result;
}

uint64_t static Int.& infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 & a1;
}

uint64_t FixedWidthInteger.init(littleEndian:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a3, a1);
}

{
  return FixedWidthInteger.init(littleEndian:)(a1, a2, a3);
}

double Hasher.init(_rawSeed:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = a1 ^ 0x736F6D6570736575LL;
  *(void *)(a3 + 16) = a2 ^ 0x646F72616E646F6DLL;
  *(void *)(a3 + 24) = a1 ^ 0x6C7967656E657261LL;
  *(void *)(a3 + 32) = a2 ^ 0x7465646279746573LL;
  double result = 0.0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  return result;
}

uint64_t static Hasher._isDeterministic.getter()
{
  return qword_18C487060;
}

uint64_t static Hasher._executionSeed.getter()
{
  return _swift_stdlib_Hashing_parameters;
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt a1)
{
  uint64_t v2 = HIBYTE(*v1) & 7;
  Swift::UInt v3 = *v1 + 0x800000000000000LL;
  if (v2)
  {
    Swift::UInt v3 = (a1 >> ((-8 * v2) & 0x38)) | ((*v1 & 0xFF00000000000000LL) + 0x800000000000000LL);
    Swift::UInt v4 = (a1 << (8 * v2)) | *v1 & 0xFFFFFFFFFFFFFFLL;
  }

  else
  {
    Swift::UInt v4 = a1;
  }

  Swift::UInt v5 = v1[4] ^ v4;
  Swift::UInt v6 = v1[2];
  Swift::UInt v7 = v6 + v1[1];
  Swift::UInt v8 = v7 ^ __ROR8__(v6, 51);
  Swift::UInt v9 = v1[3] + v5;
  uint64_t v10 = __ROR8__(v5, 48);
  Swift::UInt v11 = (v9 ^ v10) + __ROR8__(v7, 32);
  v1[4] = v11 ^ __ROR8__(v9 ^ v10, 43);
  v1[2] = (v9 + v8) ^ __ROR8__(v8, 47);
  v1[3] = __ROR8__(v9 + v8, 32);
  *uint64_t v1 = v3;
  v1[1] = v11 ^ v4;
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt64 a1)
{
  uint64_t v2 = HIBYTE(*v1) & 7;
  Swift::UInt64 v3 = *v1 + 0x800000000000000LL;
  if (v2)
  {
    Swift::UInt64 v3 = (a1 >> ((-8 * v2) & 0x38)) | ((*v1 & 0xFF00000000000000LL) + 0x800000000000000LL);
    Swift::UInt64 v4 = (a1 << (8 * v2)) | *v1 & 0xFFFFFFFFFFFFFFLL;
  }

  else
  {
    Swift::UInt64 v4 = a1;
  }

  Swift::UInt64 v5 = v1[4] ^ v4;
  Swift::UInt64 v6 = v1[2];
  Swift::UInt64 v7 = v6 + v1[1];
  Swift::UInt64 v8 = v7 ^ __ROR8__(v6, 51);
  Swift::UInt64 v9 = v1[3] + v5;
  uint64_t v10 = __ROR8__(v5, 48);
  Swift::UInt64 v11 = (v9 ^ v10) + __ROR8__(v7, 32);
  v1[4] = v11 ^ __ROR8__(v9 ^ v10, 43);
  v1[2] = (v9 + v8) ^ __ROR8__(v8, 47);
  v1[3] = __ROR8__(v9 + v8, 32);
  *uint64_t v1 = v3;
  v1[1] = v11 ^ v4;
}

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt32 a1)
{
  uint64_t v2 = *v1;
  unint64_t v3 = HIBYTE(*v1) & 7;
  char v4 = 8 * v3;
  if (v3 > 3)
  {
    unint64_t v5 = ((unint64_t)a1 << v4) | v2 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v6 = v2 & 0xFF00000000000000LL;
    unint64_t v7 = a1 >> ((-8 * v3) & 0x38);
    if (v3 == 4) {
      unint64_t v7 = 0LL;
    }
    uint64_t v8 = (v6 | v7) + 0x400000000000000LL;
    unint64_t v9 = v1[4] ^ v5;
    uint64_t v10 = v1[2];
    uint64_t v11 = v10 + v1[1];
    uint64_t v12 = v11 ^ __ROR8__(v10, 51);
    unint64_t v13 = v1[3] + v9;
    unint64_t v14 = v13 ^ __ROR8__(v9, 48);
    unint64_t v15 = v14 + __ROR8__(v11, 32);
    unint64_t v16 = v13 + v12;
    v1[3] = __ROR8__(v16, 32);
    v1[4] = v15 ^ __ROR8__(v14, 43);
    v1[1] = v15 ^ v5;
    v1[2] = v16 ^ __ROR8__(v12, 47);
    *uint64_t v1 = v8;
  }

  else
  {
    *uint64_t v1 = (((unint64_t)a1 << v4) | v2) + 0x400000000000000LL;
  }

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt16 a1)
{
  uint64_t v2 = *v1;
  unint64_t v3 = HIBYTE(*v1) & 7;
  char v4 = 8 * v3;
  if (v3 > 5)
  {
    unint64_t v5 = ((unint64_t)a1 << v4) | v2 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v6 = v2 & 0xFF00000000000000LL;
    unint64_t v7 = a1 >> ((-8 * v3) & 0x38);
    if (v3 == 6) {
      unint64_t v7 = 0LL;
    }
    uint64_t v8 = (v6 | v7) + 0x200000000000000LL;
    unint64_t v9 = v1[4] ^ v5;
    uint64_t v10 = v1[2];
    uint64_t v11 = v10 + v1[1];
    uint64_t v12 = v11 ^ __ROR8__(v10, 51);
    unint64_t v13 = v1[3] + v9;
    unint64_t v14 = v13 ^ __ROR8__(v9, 48);
    unint64_t v15 = v14 + __ROR8__(v11, 32);
    unint64_t v16 = v13 + v12;
    v1[3] = __ROR8__(v16, 32);
    v1[4] = v15 ^ __ROR8__(v14, 43);
    v1[1] = v15 ^ v5;
    v1[2] = v16 ^ __ROR8__(v12, 47);
    *uint64_t v1 = v8;
  }

  else
  {
    *uint64_t v1 = (((unint64_t)a1 << v4) | v2) + 0x200000000000000LL;
  }

Swift::Void __swiftcall Hasher._combine(_:)(Swift::UInt8 a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = HIBYTE(*v1) & 7;
  char v4 = 8 * v3;
  if (v3 == 7)
  {
    unint64_t v5 = v2 & 0xFF00000000000000LL;
    unint64_t v6 = ((unint64_t)a1 << v4) | v2 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v7 = v1[4] ^ v6;
    uint64_t v8 = v1[2];
    uint64_t v9 = v8 + v1[1];
    uint64_t v10 = v9 ^ __ROR8__(v8, 51);
    unint64_t v11 = v1[3] + v7;
    unint64_t v12 = v11 ^ __ROR8__(v7, 48);
    unint64_t v13 = v12 + __ROR8__(v9, 32);
    unint64_t v14 = v11 + v10;
    v1[3] = __ROR8__(v14, 32);
    v1[4] = v13 ^ __ROR8__(v12, 43);
    v1[1] = v13 ^ v6;
    v1[2] = v14 ^ __ROR8__(v10, 47);
  }

  else
  {
    unint64_t v5 = ((unint64_t)a1 << v4) | v2;
  }

  *uint64_t v1 = v5 + 0x100000000000000LL;
}

Swift::Void __swiftcall Hasher._combine(bytes:count:)(Swift::UInt64 bytes, Swift::Int count)
{
  unint64_t v3 = *v2;
  uint64_t v4 = HIBYTE(*v2) & 7;
  unint64_t v5 = v4 + count;
  if (__CFADD__(v4, count))
  {
    __break(1u);
  }

  else
  {
    char v6 = 8 * v4;
    if (v5 > 7)
    {
      unint64_t v7 = HIBYTE(v3);
      Swift::UInt64 v8 = (bytes << v6) | v3 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v9 = (v7 + count);
      Swift::UInt64 v10 = bytes >> (-v6 & 0x38);
      if (v5 == 8) {
        Swift::UInt64 v11 = 0LL;
      }
      else {
        Swift::UInt64 v11 = v10;
      }
      Swift::UInt64 v12 = v11 | (v9 << 56);
      Swift::UInt64 v13 = v2[4] ^ v8;
      Swift::UInt64 v14 = v2[2];
      Swift::UInt64 v15 = v14 + v2[1];
      uint64_t v16 = v15 ^ __ROR8__(v14, 51);
      Swift::UInt64 v17 = v2[3] + v13;
      uint64_t v18 = __ROR8__(v13, 48);
      Swift::UInt64 v19 = (v17 ^ v18) + __ROR8__(v15, 32);
      uint64_t v20 = v19 ^ __ROR8__(v17 ^ v18, 43);
      Swift::UInt64 v21 = v17 + v16;
      v2[3] = __ROR8__(v21, 32);
      v2[4] = v20;
      v2[1] = v19 ^ v8;
      v2[2] = v21 ^ __ROR8__(v16, 47);
      *uint64_t v2 = v12;
    }

    else
    {
      *uint64_t v2 = ((bytes << v6) | v3) + (count << 56);
    }
  }

Swift::Void __swiftcall Hasher.combine(bytes:)(Swift::UnsafeRawBufferPointer bytes)
{
  if (bytes._position.value._rawValue
    && (char *)bytes._end.value._rawValue - (char *)bytes._position.value._rawValue >= 1)
  {
    if (bytes._position.value._rawValue >= (Builtin::RawPointer)0xFFFFFFFFFFFFFFF8LL)
    {
      __break(1u);
    }

    else
    {
      uint64_t v1 = (_BYTE *)(((unint64_t)bytes._position.value._rawValue + 7) & 0xFFFFFFFFFFFFFFF8LL);
      BOOL v2 = v1 >= bytes._position.value._rawValue;
      int64_t v3 = v1 - (char *)bytes._position.value._rawValue;
      if (v2)
      {
        if ((v3 & 0x8000000000000000LL) == 0)
        {
          __asm { BR              X12 }
        }

uint64_t static Hasher._hash(seed:_:)(uint64_t a1, uint64_t a2)
{
  return specialized static Hasher._hash(seed:_:)(a1, a2);
}

{
  return specialized static Hasher._hash(seed:_:)(a1, a2);
}

uint64_t static UInt64.bitWidth.getter()
{
  return 64LL;
}

uint64_t static Hasher._hash(seed:bytes:)(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  if (a2 && (uint64_t)(a3 - a2) >= 1)
  {
    if (a2 >= 0xFFFFFFFFFFFFFFF8LL)
    {
      __break(1u);
    }

    else
    {
      unint64_t v4 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      int64_t v5 = v4 - a2;
      if (v4 >= a2)
      {
        if ((v5 & 0x8000000000000000LL) == 0)
        {
          __asm { BR              X17 }
        }

double _hashContainerDefaultMaxLoadFactorInverse.getter()
{
  return 1.33333333;
}

double static Double./ infix(_:_:)(double a1, double a2)
{
  return a1 / a2;
}

uint64_t UnsafeMutableRawPointer.load<A>(fromByteOffset:as:)@<X0>( char a1@<W0>, char a2@<W2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return UnsafeRawPointer.load<A>(fromByteOffset:as:)(a1, a2, a3, 0x4F9uLL, a4);
}

uint64_t UnsafeRawPointer.load<A>(fromByteOffset:as:)@<X0>( char a1@<W0>, char a2@<W2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v5 = *(void *)(a3 - 8);
  if ((*(_BYTE *)(v5 + 80) & (a2 + a1)) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  a4,  0);
  }
  return (*(uint64_t (**)(uint64_t))(v5 + 16))(a5);
}

uint64_t _HashTable.bucketCount.getter(uint64_t a1, uint64_t a2)
{
  return a2 + 1;
}

char *static ManagedBuffer.create(minimumCapacity:makingHeaderWith:)(uint64_t a1, void (*a2)(void))
{
  uint64_t v5 = *(void *)(v2 + 80);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(*(void *)(v2 + 88) - 8LL);
  uint64_t v11 = (char *)swift_allocObject( v2,  ((*(unsigned __int8 *)(v10 + 80) + (unint64_t)*(unsigned int *)(v2 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80))
                + *(void *)(v10 + 72) * v7,
                  *(unsigned __int8 *)(v10 + 80) | (unint64_t)*(unsigned __int16 *)(v2 + 52));
  a2();
  if (v3) {
    swift_release((uint64_t)v11);
  }
  else {
    (*(void (**)(char *, char *, uint64_t))(v6 + 32))(&v11[*(void *)(*(void *)v11 + 96LL)], v9, v5);
  }
  return v11;
}

void __BridgingHashBuffer.deinit()
{
  int64_t v1 = 0LL;
  uint64_t v3 = *(void **)(v0 + 24);
  uint64_t v2 = *(void *)(v0 + 32);
  if (v2 + 1 < 64) {
    uint64_t v4 = ~(-1LL << (v2 + 1));
  }
  else {
    uint64_t v4 = -1LL;
  }
  unint64_t v5 = v4 & *v3;
  int64_t v6 = (unint64_t)(v2 + 64) >> 6;
  while (1)
  {
    if (v5)
    {
      unint64_t v7 = __clz(__rbit64(v5));
      v5 &= v5 - 1;
      unint64_t v8 = v7 | (v1 << 6);
      goto LABEL_6;
    }

    if (__OFADD__(v1++, 1LL)) {
      goto LABEL_20;
    }
    if (v1 >= v6)
    {
LABEL_18:
      swift_unknownObjectRelease(*(id *)(v0 + 16));
      return;
    }

    unint64_t v10 = v3[v1];
    if (!v10) {
      break;
    }
LABEL_17:
    unint64_t v5 = (v10 - 1) & v10;
    unint64_t v8 = __clz(__rbit64(v10)) + (v1 << 6);
LABEL_6:
    swift_arrayDestroy(v0 + 40 + 8 * v8, 1LL, (uint64_t)&unk_189B8D230);
  }

  int64_t v11 = v1 + 1;
  if (v1 + 1 >= v6) {
    goto LABEL_18;
  }
  unint64_t v10 = v3[v11];
  if (v10)
  {
    ++v1;
    goto LABEL_17;
  }

  while (1)
  {
    int64_t v1 = v11 + 1;
    if (__OFADD__(v11, 1LL)) {
      break;
    }
    if (v1 >= v6) {
      goto LABEL_18;
    }
    unint64_t v10 = v3[v1];
    ++v11;
    if (v10) {
      goto LABEL_17;
    }
  }

  __break(1u);
LABEL_20:
  __break(1u);
}

uint64_t ManagedBuffer.firstElementAddress.getter()
{
  uint64_t v1 = *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)v0 + 88LL) - 8LL) + 80LL);
  return v0 + ((v1 + *(unsigned int *)(*(void *)v0 + 48LL)) & ~v1);
}

void __BridgingHashBuffer.__deallocating_deinit()
{
}

void __BridgingHashBuffer.__allocating_init(_doNotCallMe:)()
{
  inited = swift_initStackObject(v0, v2);
  swift_release((uint64_t)inited);
  __break(1u);
}

uint64_t _HashTable.words.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_HashTable.words.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _HashTable.bucketMask.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

unint64_t _HashTable.wordCount.getter(uint64_t a1, uint64_t a2)
{
  return (unint64_t)(a2 + 64) >> 6;
}

Swift::Double __swiftcall Double.init(_:)(Swift::Int a1)
{
  return (double)a1;
}

double static Double.* infix(_:_:)(double a1, double a2)
{
  return a1 * a2;
}

Swift::Int __swiftcall Int.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (a1 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (a1 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  return (uint64_t)a1;
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(unsigned __int16 a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return 16LL - (unsigned __int16)(__clz(a1) - 15);
}

{
  if ((__int16)a1 <= 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return 16LL - (unsigned __int16)(__clz(a1) - 15);
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(unsigned int a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return 32LL - (__clz(a1) + 1);
}

unint64_t specialized FixedWidthInteger._binaryLogarithm()(unint64_t a1, unint64_t a2)
{
  if (!(a2 | a1)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v2 = v3;
  }
  return 127 - v2;
}

{
  unint64_t v2;
  unint64_t v3;
  if (!(a1 | a2)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v2 = v3;
  }
  return 127 - v2;
}

{
  unint64_t v2;
  unint64_t v3;
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  unint64_t v2 = __clz(a2);
  unint64_t v3 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v2 = v3;
  }
  return 127 - v2;
}

unint64_t specialized FixedWidthInteger._binaryLogarithm()(unint64_t a1, int64_t a2)
{
  BOOL v2 = a1 != 0;
  if (a2) {
    BOOL v2 = a2 > 0;
  }
  if (!v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  unint64_t v3 = __clz(a2);
  unint64_t v4 = __clz(a1) + 64;
  if (!a2) {
    unint64_t v3 = v4;
  }
  return 127 - v3;
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(unsigned __int8 a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return 8LL - (__clz(a1) - 23);
}

{
  if ((char)a1 <= 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return 8LL - (__clz(a1) - 23);
}

uint64_t specialized FixedWidthInteger._binaryLogarithm()(signed int a1)
{
  if (a1 <= 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  return 32LL - (__clz(a1) + 1);
}

Swift::Int __swiftcall FixedWidthInteger._binaryLogarithm()()
{
  uint64_t v3 = v1;
  uint64_t v4 = v0;
  uint64_t v23 = *(void *)(v1 + 8);
  uint64_t v5 = *(void *)(*(void *)(v23 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v0,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v22 - v8;
  uint64_t v10 = *(void *)(v4 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v7);
  uint64_t v13 = (char *)&v22 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v22 - v14;
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v22 = v2;
  v16((char *)&v22 - v14, v2, v4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 24))(v9, v4, v5);
  char v18 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v23 + 32) + 8LL) + 40LL))( v15,  v13,  v4);
  uint64_t v19 = *(void (**)(char *, uint64_t))(v10 + 8);
  v19(v13, v4);
  if ((v18 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x8F1uLL,  0);
  }
  v19(v15, v4);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 56))(v4, v3);
  return v20 + ~(*(uint64_t (**)(uint64_t, uint64_t))(v3 + 152))(v4, v3);
}

uint64_t _HashTable.Bucket.offset.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_HashTable.Bucket.offset.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.Bucket.init(word:bit:)(Swift::Int word, Swift::Int bit)
{
  return (Swift::_HashTable::Bucket)(bit + (word << 6));
}

unint64_t _HashTable.Bucket.word.getter(unint64_t a1)
{
  return a1 >> 6;
}

uint64_t _HashTable.Bucket.bit.getter(char a1)
{
  return a1 & 0x3F;
}

BOOL static _HashTable.Bucket.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _HashTable.Bucket( void *a1, void *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _HashTable.Bucket( void *a1, void *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _HashTable.Bucket( void *a1, void *a2)
{
  return *a2 < *a1;
}

uint64_t _HashTable.Index.age.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _HashTable.Index( uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xD5uLL,  0);
  }
  return *(void *)a1 == *(void *)a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance _HashTable.Index( uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xE2uLL,  0);
  }
  return *(void *)a1 < *(void *)a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _HashTable.Index( uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a1 + 8)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xE2uLL,  0);
  }
  return *(void *)a2 >= *(void *)a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _HashTable.Index( uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xE2uLL,  0);
  }
  return *(void *)a1 >= *(void *)a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _HashTable.Index( uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a1 + 8)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't compare indices belonging to different collections",  56LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0xE2uLL,  0);
  }
  return *(void *)a2 < *(void *)a1;
}

uint64_t _HashTable.Iterator.wordIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t (*_HashTable.Iterator.wordIndex.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _HashTable.Iterator.word.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t (*_HashTable.Iterator.word.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

  ;
}

void protocol witness for IteratorProtocol.next() in conformance _HashTable.Iterator(uint64_t a1@<X8>)
{
  unint64_t v2 = v1[3];
  if (v2)
  {
    char v3 = 0;
    v1[3] = (v2 - 1) & v2;
    unint64_t v4 = __clz(__rbit64(v2)) | (v1[2] << 6);
LABEL_14:
    *(void *)a1 = v4;
    *(_BYTE *)(a1 + 8) = v3;
    return;
  }

  uint64_t v5 = v1[2];
  int64_t v6 = v5 + 1;
  if (!__OFADD__(v5, 1LL))
  {
    int64_t v7 = (unint64_t)(v1[1] + 64) >> 6;
    if (v6 < v7)
    {
      v1[2] = v6;
      uint64_t v8 = *v1;
      unint64_t v9 = *(void *)(*v1 + 8 * v6);
      v1[3] = v9;
      if (v9)
      {
LABEL_6:
        char v3 = 0;
        v1[3] = (v9 - 1) & v9;
        unint64_t v4 = __clz(__rbit64(v9)) + (v6 << 6);
        goto LABEL_14;
      }

      int64_t v6 = v5 + 2;
      if (v5 + 2 < v7)
      {
        v1[2] = v6;
        unint64_t v9 = *(void *)(v8 + 8 * v6);
        v1[3] = v9;
        if (v9) {
          goto LABEL_6;
        }
        uint64_t v10 = v5 + 3;
        while (v7 != v10)
        {
          v1[2] = v10;
          unint64_t v9 = *(void *)(v8 + 8 * v10);
          v1[3] = v9;
          ++v10;
          if (v9)
          {
            int64_t v6 = v10 - 1;
            goto LABEL_6;
          }
        }
      }
    }

    unint64_t v4 = 0LL;
    char v3 = 1;
    goto LABEL_14;
  }

  __break(1u);
}

void protocol witness for Sequence.makeIterator() in conformance _HashTable(void *a1@<X8>)
{
  uint64_t v2 = *(void *)(v1 + 8);
  if (v2 + 1 < 64) {
    uint64_t v3 = ~(-1LL << (v2 + 1));
  }
  else {
    uint64_t v3 = -1LL;
  }
  uint64_t v4 = v3 & **(void **)v1;
  *a1 = *(void *)v1;
  a1[1] = v2;
  a1[2] = 0LL;
  a1[3] = v4;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance _HashTable()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*(void **)v0, *(void *)(v0 + 8));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _HashTable( void *a1, unint64_t *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *(void **)v3, *(void *)(v3 + 8));
}

Swift::Bool __swiftcall _HashTable.isValid(_:)(Swift::_HashTable::Bucket a1)
{
  return a1.offset >= 0 && v1 + 1 > a1.offset;
}

Swift::Void __swiftcall _HashTable.checkOccupied(_:)(Swift::_HashTable::Bucket a1)
{
  if (a1.offset < 0
    || v2 + 1 <= a1.offset
    || ((*(void *)(v1 + (((unint64_t)a1.offset >> 3) & 0xFFFFFFFFFFFFF8LL)) >> SLOBYTE(a1.offset)) & 1) == 0)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Collection elements using an invalid Index",  63LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0x130uLL,  0);
  }

Swift::_HashTable::Bucket __swiftcall _HashTable._firstOccupiedBucket(fromWord:)(Swift::Int fromWord)
{
  result.offset = v2 + 1;
  Swift::Int v5 = (unint64_t)(v2 + 64) >> 6;
  if (v5 > fromWord)
  {
    unint64_t v6 = *(void *)(v1 + 8 * fromWord);
    if (v6)
    {
      Swift::Int v7 = fromWord;
      return (Swift::_HashTable::Bucket)(__clz(__rbit64(v6)) + (v7 << 6));
    }

    else
    {
      Swift::Int v8 = v5 - 1;
      while (v8 != fromWord)
      {
        Swift::Int v7 = fromWord + 1;
        unint64_t v6 = *(void *)(v1 + 8 + 8 * fromWord++);
        if (v6) {
          return (Swift::_HashTable::Bucket)(__clz(__rbit64(v6)) + (v7 << 6));
        }
      }
    }
  }

  return result;
}

Swift::_HashTable::Bucket __swiftcall _HashTable.previousHole(before:)(Swift::_HashTable::Bucket before)
{
  int64_t v3 = (unint64_t)before.offset >> 6;
  uint64_t v4 = *(void *)(v1 + 8 * ((unint64_t)before.offset >> 6)) | (-1LL << SLOBYTE(before.offset));
  if (v4 == -1)
  {
    char v6 = 0;
    do
    {
      if (--v3 < 0 && (v6 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Hash table has no holes",  23LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0x17DuLL,  0);
      }
      v6 |= v3 < 0;
      if (v3 < 0) {
        int64_t v3 = ((unint64_t)(v2 + 64) >> 6) - 1;
      }
      uint64_t v7 = *(void *)(v1 + 8 * v3);
    }

    while (v7 == -1);
    unint64_t v5 = (v3 << 6) - __clz(~v7);
  }

  else
  {
    unint64_t v5 = (before.offset & 0xFFFFFFFFFFFFFFC0LL) - __clz(~v4);
  }

  return (Swift::_HashTable::Bucket)(v5 + 63);
}

Swift::_HashTable::Bucket __swiftcall _HashTable.nextHole(atOrAfter:)(Swift::_HashTable::Bucket atOrAfter)
{
  unint64_t v3 = (unint64_t)atOrAfter.offset >> 6;
  unint64_t v4 = (-1LL << SLOBYTE(atOrAfter.offset)) & ~*(void *)(v1 + 8 * ((unint64_t)atOrAfter.offset >> 6));
  if (v4) {
    return (Swift::_HashTable::Bucket)(__clz(__rbit64(v4)) | atOrAfter.offset & 0xFFFFFFFFFFFFFFC0LL);
  }
  unint64_t v6 = (unint64_t)(v2 + 64) >> 6;
  do
  {
    if (++v3 == v6 && (v4 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Hash table has no holes",  23LL,  2,  "Swift/HashTable.swift",  21LL,  2,  0x198uLL,  0);
    }
    BOOL v7 = v3 == v6;
    if (v3 == v6) {
      unint64_t v3 = 0LL;
    }
    LOBYTE(v4) = v7 | v4;
    uint64_t v8 = *(void *)(v1 + 8 * v3);
  }

  while (v8 == -1);
  return (Swift::_HashTable::Bucket)(__clz(__rbit64(~v8)) + (v3 << 6));
}

uint64_t static FixedWidthInteger.&+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  BOOL v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v8 + 80))(v7);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v7, a3);
}

char *_HashTable.copyContents(of:)(char *__src, int a2, char *__dst, uint64_t a4)
{
  unint64_t v4 = (unint64_t)(a4 + 64) >> 6;
  if (__dst != __src || &__src[8 * v4] <= __dst) {
    return (char *)memmove(__dst, __src, 8 * v4);
  }
  return __src;
}

char *specialized UnsafeMutablePointer.moveInitialize(from:count:)( char *__src, size_t __len, char *__dst, const char *a4, uint64_t a5, unint64_t a6)
{
  if ((__len & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a4,  a5,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  a6,  0);
  }
  if (__dst != __src || &__src[__len] <= __dst) {
    return (char *)memmove(__dst, __src, __len);
  }
  return __src;
}

char *UnsafeMutablePointer.assign(from:count:)(char *__src, uint64_t a2, char *__dst, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.update with negative count",  47LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x3DEuLL,  0);
  }
  if (__dst < __src || &__src[*(void *)(*(void *)(a4 - 8) + 72LL) * a2] <= __dst) {
    return swift_arrayAssignWithCopyFrontToBack(__dst, __src, a2, a4);
  }
  if (__dst != __src) {
    return swift_arrayAssignWithCopyBackToFront(__dst, __src, a2, a4);
  }
  return __src;
}

Swift::Int _HashTable.delete<A>(at:with:)( Swift::_HashTable::Bucket before, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  Swift::Int offset = before.offset;
  unint64_t v8 = (before.offset + 1) & a4;
  if ((*(void *)(a3 + 8 * (v8 >> 6)) & (1LL << v8)) != 0)
  {
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(a3 + 8 * (v8 >> 6)) & (1LL << v8)) != 0)
    {
      Swift::Int v12 = (before.offset + 1) & a4;
      uint64_t v13 = *(uint64_t (**)(unint64_t, uint64_t, uint64_t))(a6 + 8);
      for (before.Swift::Int offset = v13(v8, a5, a6); ; before.Swift::Int offset = v13(v8, a5, a6))
      {
        Swift::Int v14 = before.offset & a4;
        if (offset >= v12)
        {
          if (v14 < v12) {
            goto LABEL_5;
          }
        }

        else if (v14 >= v12)
        {
          goto LABEL_4;
        }

        if (offset >= v14)
        {
LABEL_4:
          before.Swift::Int offset = (*(uint64_t (**)(unint64_t, Swift::Int, uint64_t, uint64_t))(a6 + 16))( v8,  offset,  a5,  a6);
          Swift::Int offset = v8;
        }

uint64_t Identifiable<>.id.getter()
{
  return v0;
}

uint64_t DefaultIndices._elements.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))(a2, v2);
}

uint64_t DefaultIndices._elements.setter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 40LL))(v2, a1);
}

uint64_t (*DefaultIndices._elements.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t DefaultIndices._startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter( a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index,  a2);
}

uint64_t DefaultIndices._startIndex.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
}

uint64_t (*DefaultIndices._startIndex.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t DefaultIndices._endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return DefaultIndices._endIndex.getter( a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index,  a2);
}

uint64_t DefaultIndices._endIndex.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 40);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( v4,  a1,  AssociatedTypeWitness);
}

uint64_t (*DefaultIndices._endIndex.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t DefaultIndices.init(_elements:startIndex:endIndex:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = type metadata accessor for DefaultIndices(0LL, a4, (uint64_t)a5, v11);
  uint64_t v13 = a6 + *(int *)(v12 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v16 = *(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL);
  v16(v13, a2, AssociatedTypeWitness);
  return ((uint64_t (*)(uint64_t, uint64_t, unint64_t))v16)( a6 + *(int *)(v12 + 40),  a3,  AssociatedTypeWitness);
}

uint64_t DiscontiguousSlice.Index.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a2,  v4,  AssociatedTypeWitness);
}

uint64_t DefaultIndices.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 40);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a2,  v4,  AssociatedTypeWitness);
}

uint64_t DefaultIndices.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a3,  a1,  AssociatedTypeWitness);
}

{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v12;
  uint64_t v13;
  void (*v15)(uint64_t, uint64_t, unint64_t);
  BOOL v7 = *(void *)(a2 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 16LL))(a3, v3, v7);
  unint64_t v8 = a3 + *(int *)(a2 + 36);
  unint64_t v9 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v9,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v15 = *(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL);
  v15(v8, a1, AssociatedTypeWitness);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = a1
      + *(int *)(type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12) + 36);
  return ((uint64_t (*)(uint64_t, uint64_t, unint64_t))v15)( a3 + *(int *)(a2 + 40),  v13,  AssociatedTypeWitness);
}

uint64_t DefaultIndices.index(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 184LL))(a1, *(void *)(a2 + 16));
}

uint64_t DefaultIndices.formIndex(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 192LL))(a1, *(void *)(a2 + 16));
}

uint64_t DefaultIndices.indices.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a2, v2);
}

uint64_t DefaultIndices.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 136LL))( a1,  a2,  *(void *)(a3 + 16));
}

uint64_t DefaultIndices.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a4 + 24) + 144LL))( a1,  a2,  a3,  *(void *)(a4 + 16));
}

uint64_t DefaultIndices.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 152LL))( a1,  a2,  *(void *)(a3 + 16));
}

uint64_t (*protocol witness for Collection.subscript.read in conformance DefaultIndices<A>( unint64_t **a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = (unint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (unint64_t)DefaultIndices.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*DefaultIndices.subscript.read(unint64_t *a1, uint64_t a2, uint64_t a3))()
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 24),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  *a1 = AssociatedTypeWitness;
  unint64_t v5 = *(void *)(AssociatedTypeWitness - 8);
  a1[1] = v5;
  a1[2] = (unint64_t)malloc(*(void *)(v5 + 64));
  (*(void (**)(void))(v5 + 16))();
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance DefaultIndices<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance DefaultIndices<A>( a1,  (void (*)(uint64_t))DefaultIndices.startIndex.getter,  (uint64_t)&protocol conformance descriptor for DefaultIndices<A>,  a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t DefaultIndices<>.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 32))(a1, *(void *)(a2 + 16));
}

uint64_t DefaultIndices<>.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 40))(a1, *(void *)(a2 + 16));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DefaultIndices<>.index(before:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> DefaultIndices<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return DefaultIndices<>.formIndex(before:)(a1, a2, *(void *)(a3 - 8));
}

Swift::String_optional __swiftcall readLine(strippingNewline:)(Swift::Bool strippingNewline)
{
  __linep[1] = *(char **)MEMORY[0x1895F89C0];
  __linep[0] = 0LL;
  uint64_t Line_stdin = swift_stdlib_readLine_stdin(__linep);
  unint64_t v3 = (uint8x16_t *)__linep[0];
  if (Line_stdin >= 1)
  {
    if (!__linep[0]) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
    }
    int64_t v4 = Line_stdin;
    int64_t v5 = validateUTF8(_:)((uint64_t *)__linep[0], Line_stdin);
    if ((v7 & 1) != 0) {
      uint64_t v8 = repairUTF8(_:firstKnownBrokenRange:)(v3->i8, v4, v5, v6);
    }
    else {
      uint64_t v8 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v3, v4, v5 & 1);
    }
    uint64_t v14 = v8;
    unint64_t v15 = v9;
    uint64_t v29 = v8;
    unint64_t v30 = v9;
    if (!strippingNewline) {
      goto LABEL_26;
    }
    swift_bridgeObjectRetain(v9, v9, v10, v11);
    uint64_t v16 = specialized BidirectionalCollection.last.getter(v14, v15);
    if (v17)
    {
      uint64_t v18 = v17;
      if (v16 == 10 && v17 == 0xE100000000000000LL)
      {
        swift_bridgeObjectRelease(v15);
        swift_bridgeObjectRelease(0xE100000000000000LL);
LABEL_24:
        specialized RangeReplaceableCollection<>.removeLast()();
        uint64_t v23 = v25;
        goto LABEL_25;
      }

      if ((~v17 & 0x6000000000000000LL) != 0)
      {
        char v19 = _stringCompareInternal(_:_:expecting:)(v16, v17, 10LL, 0xE100000000000000LL, 0);
        swift_bridgeObjectRelease(v18);
        if ((v19 & 1) != 0)
        {
          swift_bridgeObjectRelease(v15);
          goto LABEL_24;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v17);
      }
    }

    uint64_t v20 = specialized BidirectionalCollection.last.getter(v14, v15);
    unint64_t v22 = v21;
    swift_bridgeObjectRelease(v15);
    if (v22)
    {
      if (v20 == 2573 && v22 == 0xE200000000000000LL)
      {
        swift_bridgeObjectRelease(0xE200000000000000LL);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        goto LABEL_24;
      }

      if ((~v22 & 0x6000000000000000LL) != 0)
      {
        char v24 = _stringCompareInternal(_:_:expecting:)(v20, v22, 2573LL, 0xE200000000000000LL, 0);
        swift_bridgeObjectRelease(v22);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        if ((v24 & 1) == 0)
        {
LABEL_26:
          uint64_t v12 = v29;
          uint64_t v13 = (void *)v30;
          _swift_stdlib_free(v3);
          goto LABEL_27;
        }

        goto LABEL_24;
      }

      swift_bridgeObjectRelease(v22);
    }

    uint64_t v23 = 0xE200000000000000LL;
LABEL_25:
    swift_bridgeObjectRelease(v23);
    goto LABEL_26;
  }

  _swift_stdlib_free(__linep[0]);
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
LABEL_27:
  uint64_t v26 = v12;
  uint64_t v27 = v13;
  result.value._object = v27;
  result.value._uint64_t countAndFlagsBits = v26;
  return result;
}

uint64_t specialized RangeReplaceableCollection<>.removeLast()()
{
  uint64_t v2 = *v0;
  unint64_t v1 = v0[1];
  uint64_t v3 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    uint64_t v3 = *v0 & 0xFFFFFFFFFFFFLL;
  }
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x363uLL,  0);
  }
  uint64_t v4 = 7LL;
  if (((v1 >> 60) & ((v2 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v4 = 11LL;
  }
  v5._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(v4 | (v3 << 16)))._rawBits;
  if (!(v5._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  Swift::UInt64 rawBits = v5._rawBits;
  if ((v1 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 v15 = String.UnicodeScalarView._foreignIndex(before:)(v5)._rawBits;
  }

  else
  {
    if ((v1 & 0x2000000000000000LL) != 0)
    {
      v17[0] = v2;
      v17[1] = v1 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v11 = (char *)v17 + (v5._rawBits >> 16);
      if ((*(v11 - 1) & 0xC0) == 0x80)
      {
        uint64_t v12 = 0LL;
        uint64_t v13 = v11 - 2;
        do
          int v14 = v13[v12--] & 0xC0;
        while (v14 == 128);
        uint64_t v10 = 1 - v12;
      }

      else
      {
        uint64_t v10 = 1LL;
      }
    }

    else
    {
      if ((v2 & 0x1000000000000000LL) != 0) {
        char v7 = (char *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        char v7 = (char *)_StringObject.sharedUTF8.getter(v2, v1);
      }
      uint64_t v8 = 0LL;
      do
        int v9 = v7[(rawBits >> 16) - 1 + v8--] & 0xC0;
      while (v9 == 128);
      uint64_t v10 = -v8;
    }

    Swift::UInt64 v15 = (rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
  }

  return specialized RangeReplaceableCollection.remove(at:)(v15);
}

{
  uint64_t v0;
  unint64_t v1;
  if (!*(void *)(*(void *)v0 + 16LL)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x363uLL,  0);
  }
  unint64_t v1 = specialized Array._customRemoveLast()();
  if ((v1 & 0x1000000000000LL) != 0) {
    unint64_t v1 = specialized Array.remove(at:)(*(void *)(*(void *)v0 + 16LL) - 1LL);
  }
  return v1 & 0xFFFFFFFFFFFFLL;
}

{
  void *v0;
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  Swift::String::Index v4;
  unint64_t v1 = v0[1];
  uint64_t v2 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = *v0 & 0xFFFFFFFFFFFFLL;
  }
  if (!v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x363uLL,  0);
  }
  uint64_t v3 = 7LL;
  if (((v1 >> 60) & ((*v0 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v3 = 11LL;
  }
  v4._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)(v3 | (v2 << 16)))._rawBits;
  return String.remove(at:)(v4)._countAndFlagsBits;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  void *v6;
  void *v7;
  id v8;
  unint64_t v1 = *v0;
  if (!((unint64_t)*v0 >> 62))
  {
    if (*(void *)((v1 & 0xFFFFFFFFFFFFF8LL) + 0x10)) {
      goto LABEL_3;
    }
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x363uLL,  0);
  }

  if (v1 < 0) {
    int64_t v6 = (void *)*v0;
  }
  else {
    int64_t v6 = (void *)(v1 & 0xFFFFFFFFFFFFFF8LL);
  }
  if (!objc_msgSend(v6, sel_count)) {
    goto LABEL_11;
  }
LABEL_3:
  Swift::String_optional result = specialized Array._customRemoveLast()();
  if (result) {
    return result;
  }
  uint64_t v3 = *v0;
  if ((unint64_t)*v0 >> 62)
  {
    if (v3 < 0) {
      char v7 = (void *)*v0;
    }
    else {
      char v7 = (void *)(v3 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v8 = objc_msgSend(v7, sel_count);
    Swift::String::Index v5 = __OFSUB__(v8, 1LL);
    Swift::String_optional result = (uint64_t)v8 - 1;
    if (!v5) {
      return specialized Array.remove(at:)(result);
    }
  }

  else
  {
    uint64_t v4 = *(void *)((v3 & 0xFFFFFFFFFFFFF8LL) + 0x10);
    Swift::String::Index v5 = __OFSUB__(v4, 1LL);
    Swift::String_optional result = v4 - 1;
    if (!v5) {
      return specialized Array.remove(at:)(result);
    }
  }

  __break(1u);
  return result;
}

uint64_t RangeReplaceableCollection<>.removeLast()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return RangeReplaceableCollection<>.removeLast()(a1, a2, a3, 0x363uLL, a4);
}

{
  return RangeReplaceableCollection<>.removeLast()(a1, a2, a3, 0x3AEuLL, a4);
}

uint64_t _parseIntegerDigits<A>(ascii:radix:isNegative:)@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v78 = a1;
  uint64_t v75 = a7;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v72 = (char *)&v64 - v13;
  uint64_t v73 = a6;
  uint64_t v14 = *(void *)(a6 + 8);
  uint64_t v15 = *(void *)(*(void *)(v14 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v15,  a5,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v17 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v19 = (char *)&v64 - v18;
  uint64_t v77 = *(void *)(a5 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  size_t v71 = (char *)&v64 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v74 = (char *)&v64 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v64 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v31 = (char *)&v64 - v30;
  if (!a2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v77 + 56))(v75, 1LL, 1LL, a5);
  }
  LODWORD(v68) = a4;
  int v32 = a3 + 48;
  int v33 = a3 + 55;
  int v34 = a3 + 87;
  if (a3 <= 10) {
    int v34 = 97;
  }
  int v65 = v34;
  if (a3 <= 10) {
    int v33 = 65;
  }
  int v66 = v33;
  uint64_t v82 = a3;
  unint64_t v35 = *(void (**)(char *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v14 + 96);
  if (a3 > 10) {
    int v32 = 58;
  }
  int v69 = v32;
  unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
  uint64_t v76 = v14;
  unint64_t v70 = v35;
  v35((char *)&v82, &type metadata for Int, v36, a5, v14);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v15,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v38 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v15 + 24))(v19, a5, v15);
  uint64_t v41 = v78;
  uint64_t v42 = v74;
  if (!v78)
  {
LABEL_25:
    uint64_t v58 = v77;
    (*(void (**)(char *, uint64_t))(v77 + 8))(v31, a5);
    uint64_t v59 = v75;
    (*(void (**)(uint64_t, char *, uint64_t))(v58 + 32))(v75, v26, a5);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v58 + 56))(v59, 0LL, 1LL, a5);
  }

  uint64_t v43 = 10LL;
  if ((v68 & 1) != 0) {
    uint64_t v43 = 11LL;
  }
  uint64_t v68 = v43;
  uint64_t v44 = v71;
  while (1)
  {
    unsigned int v45 = *v41;
    unint64_t v78 = v41;
    uint64_t v67 = a2;
    char v79 = v45 - 48;
    unint64_t v46 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v38, v39, v40);
    Swift::Int v47 = &v79;
    uint64_t v48 = a5;
    uint64_t v49 = v76;
LABEL_22:
    v70(v47, &type metadata for UInt8, v46, v48, v49);
    uint64_t v51 = v73;
    char v52 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v73 + 96))(v44, v31, a5, v73);
    uint64_t v53 = v77;
    uint64_t v54 = *(void (**)(char *, uint64_t))(v77 + 8);
    v54(v26, a5);
    unint64_t v55 = *(void (**)(char *, char *, uint64_t))(v53 + 32);
    v55(v26, v44, a5);
    char v56 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v51 + 8 * v68))(v44, v42, a5, v51);
    v54(v42, a5);
    v54(v26, a5);
    char v57 = v72;
    v55(v72, v44, a5);
    uint64_t v38 = ((uint64_t (*)(char *, char *, uint64_t))v55)(v26, v57, a5);
    if ((v52 & 1) != 0 || (v56 & 1) != 0)
    {
      v54(v26, a5);
      v54(v31, a5);
      uint64_t v61 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v77 + 56);
      return v61(v75, 1LL, 1LL, a5);
    }

    uint64_t v41 = v78 + 1;
    a2 = v67 - 1;
    if (v67 == 1) {
      goto LABEL_25;
    }
  }

  uint64_t v50 = v76;
  if (v45 >= 0x41 && v45 < v66)
  {
    unint64_t v78 = v41;
    uint64_t v67 = a2;
    char v80 = v45 - 55;
    unint64_t v46 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v38, v39, v40);
    Swift::Int v47 = &v80;
LABEL_21:
    uint64_t v48 = a5;
    uint64_t v49 = v50;
    goto LABEL_22;
  }

  if (v45 >= 0x61 && v45 < v65)
  {
    unint64_t v78 = v41;
    uint64_t v67 = a2;
    char v81 = v45 - 87;
    unint64_t v46 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v38, v39, v40);
    Swift::Int v47 = &v81;
    goto LABEL_21;
  }

  uint64_t v62 = v77;
  uint64_t v63 = *(void (**)(char *, uint64_t))(v77 + 8);
  v63(v26, a5);
  v63(v31, a5);
  uint64_t v61 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v62 + 56);
  return v61(v75, 1LL, 1LL, a5);
}

uint64_t UnsafeBufferPointer.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    if (v4 == v2[1])
    {
      char v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 56);
      uint64_t v8 = a2;
      uint64_t v9 = 1LL;
    }

    else
    {
      *uint64_t v2 = v4 + *(void *)(v6 + 72);
      (*(void (**)(uint64_t))(v6 + 16))(a2);
      char v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 56);
      uint64_t v8 = a2;
      uint64_t v9 = 0LL;
    }

    uint64_t v10 = v5;
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    char v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 56LL);
    uint64_t v8 = a2;
    uint64_t v9 = 1LL;
  }

  return v7(v8, v9, 1LL, v10);
}

BOOL static UInt8.>= infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a1 >= a2;
}

uint64_t specialized UnsafeBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0 || a4 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid slice",  13LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x76EuLL,  0);
  }
  uint64_t v4 = a3 + a1;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  uint64_t v5 = a2 - a1;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (v5 && !v4) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
  }
  return v4;
}

uint64_t UnsafeBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t v26 = a4;
  uint64_t v10 = type metadata accessor for UnsafeBufferPointer((const char *)0xFF, a5, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, v10, v11);
  uint64_t v14 = type metadata accessor for Slice(0LL, v10, WitnessTable, v13);
  uint64_t v15 = *(void *)(v14 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v14 + 24),  v15,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v17 = *(void (**)(uint64_t *, uint64_t *, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL);
  v17(v21, &v23, AssociatedTypeWitness);
  if ((v21[0] & 0x8000000000000000LL) != 0) {
    goto LABEL_10;
  }
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t v26 = a4;
  v17(&v22, (uint64_t *)((char *)&v23 + *(int *)(v14 + 36)), AssociatedTypeWitness);
  uint64_t v18 = v22;
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t v26 = a4;
  (*(void (**)(void *, char *, uint64_t))(*(void *)(v15 - 8) + 16LL))( v21,  (char *)&v23 + *(int *)(v14 + 40),  v15);
  if (v21[1] < v18) {
LABEL_10:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid slice",  13LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x76EuLL,  0);
  if (a3)
  {
    uint64_t result = a3 + *(void *)(*(void *)(a5 - 8) + 72LL) * a1;
    BOOL v20 = a2 == a1;
    if (a2 - a1 >= 0) {
      goto LABEL_5;
    }
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t result = 0LL;
  BOOL v20 = a2 == a1;
  if (a2 - a1 < 0) {
    goto LABEL_9;
  }
LABEL_5:
  if (!v20 && !result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
  }
  return result;
}

{
  uint64_t result;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  if (a3)
  {
    uint64_t result = a3 + *(void *)(*(void *)(a5 - 8) + 72LL) * a1;
    uint64_t v8 = a2 - a1;
    char v7 = v8 == 0;
    if (v8 >= 0) {
      goto LABEL_3;
    }
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t result = 0LL;
  uint64_t v9 = a2 - a1;
  char v7 = v9 == 0;
  if (v9 < 0) {
    goto LABEL_7;
  }
LABEL_3:
  if (!v7 && !result) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
  }
  return result;
}

uint64_t specialized _parseInteger<A, B>(ascii:radix:)(uint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  if ((v6 & 0x1000000000000000LL) == 0)
  {
    if ((v6 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }

  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  void v14[2];
  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  if ((v6 & 0x1000000000000000LL) == 0)
  {
    if ((v6 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }

  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  void v14[2];
  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  if ((v6 & 0x1000000000000000LL) == 0)
  {
    if ((v6 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }

  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void v14[2];
  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  if ((v6 & 0x1000000000000000LL) == 0)
  {
    if ((v6 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }

  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }

{
  unint64_t v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void v14[2];
  unint64_t v6 = a2;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  if ((v6 & 0x1000000000000000LL) == 0)
  {
    if ((v6 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v9 = HIBYTE(v6) & 0xF;
    v14[0] = a1;
    v14[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v8 = v14;
    goto LABEL_7;
  }

  a1 = specialized static String._copying(_:)(a1, v6);
  unint64_t v11 = v10;
  swift_bridgeObjectRelease(v6);
  unint64_t v6 = v11;
  if ((v11 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = a1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v8 = _StringObject.sharedUTF8.getter(a1, v6);
  }

void specialized _parseInteger<A, B>(ascii:radix:)( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  unint64_t v9 = a2;
  swift_bridgeObjectRetain(a2, a2, a3, a4);
  if ((v9 & 0x1000000000000000LL) != 0)
  {
    a1 = specialized static String._copying(_:)(a1, v9);
    unint64_t v15 = v14;
    swift_bridgeObjectRelease(v9);
    unint64_t v9 = v15;
    if ((v15 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    v16[0] = a1;
    v16[1] = v9 & 0xFFFFFFFFFFFFFFLL;
    specialized closure #1 in _parseInteger<A, B>(ascii:radix:)( (unsigned __int8 *)v16,  HIBYTE(v9) & 0xF,  a3,  (uint64_t)a4,  a5,  a6);
    swift_bridgeObjectRelease(v9);
    return;
  }

  if ((v9 & 0x2000000000000000LL) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((a1 & 0x1000000000000000LL) != 0)
  {
    __int16 v12 = (unsigned __int8 *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v13 = a1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    __int16 v12 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, v9);
  }

  specialized closure #1 in _parseInteger<A, B>(ascii:radix:)(v12, v13, a3, (uint64_t)a4, a5, a6);
  swift_bridgeObjectRelease(v9);
}

void _parseInteger<A, B>(ascii:radix:)( uint64_t a1@<X0>, uint64_t a2@<X1>, swift *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t v14 = (void *)((char *)v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(Swift::UInt64 *))(v15 + 16))(v14);
  Swift::UInt64 v16 = String.init<A>(_:)(v14, a3, *(void *)(a5 + 40));
  uint64_t v18 = v16;
  unint64_t v19 = v17;
  if ((v17 & 0x1000000000000000LL) != 0)
  {
    uint64_t v18 = specialized static String._copying(_:)(v16, v17);
    unint64_t v23 = v22;
    swift_bridgeObjectRelease(v19);
    unint64_t v19 = v23;
    if ((v23 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    uint64_t v24 = HIBYTE(v19) & 0xF;
    v39[0] = v18;
    v39[1] = v19 & 0xFFFFFFFFFFFFFFLL;
    if (!v24) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
    }
    if (v18 == 43)
    {
      uint64_t v34 = specialized Collection.subscript.getter(1LL, (uint64_t)v39, v24);
      uint64_t v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v34, v35, v36, v37);
      uint64_t v31 = a7;
    }

    else
    {
      if (v18 == 45)
      {
        uint64_t v25 = specialized Collection.subscript.getter(1LL, (uint64_t)v39, v24);
        uint64_t v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
        uint64_t v31 = a7;
        uint64_t v32 = a2;
        int v33 = 1;
LABEL_14:
        _parseIntegerDigits<A>(ascii:radix:isNegative:)(v29, v30, v32, v33, a4, a6, v31);
        goto LABEL_15;
      }

      uint64_t v29 = (unsigned __int8 *)v39;
      uint64_t v31 = a7;
      uint64_t v30 = HIBYTE(v19) & 0xF;
    }

    uint64_t v32 = a2;
    int v33 = 0;
    goto LABEL_14;
  }

  if ((v17 & 0x2000000000000000LL) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((v18 & 0x1000000000000000LL) != 0)
  {
    BOOL v20 = (unsigned __int8 *)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v21 = v18 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    BOOL v20 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v18, v19);
  }

  closure #1 in _parseInteger<A, B>(ascii:radix:)(v20, v21, a2, a4, a6, a7);
LABEL_15:
  swift_bridgeObjectRelease(v19);
}

uint64_t specialized String.init<A>(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 16 || a2._rawBits >> 16 != v6)
  {
    uint64_t v5 = specialized static String._copying(_:)(a1, a2, a3, a4);
    swift_bridgeObjectRelease(a4);
  }

  return v5;
}

Swift::UInt64 String.init<A>(_:)(Swift::UInt64 *a1, swift *a2, uint64_t a3)
{
  uint64_t v6 = *((void *)a2 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (uint64_t *)((char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  if (v9 == &type metadata for String) {
    return *a1;
  }
  if (a2 == (swift *)&type metadata for Substring)
  {
    v11._Swift::UInt64 rawBits = *a1;
    v12._Swift::UInt64 rawBits = a1[1];
    unint64_t v13 = a1[3];
    uint64_t v10 = specialized String.init(_:)(v11, v12, a1[2], v13);
    swift_bridgeObjectRelease(v13);
  }

  else
  {
    (*(void (**)(uint64_t *, Swift::UInt64 *, swift *))(v6 + 16))(v8, a1, a2);
    if ((swift_dynamicCast((char *)&v15, v8, a2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
    {
      (*(void (**)(Swift::UInt64 *, swift *))(v6 + 8))(a1, a2);
      return v15;
    }

    else
    {
      uint64_t v10 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 8) + 8LL))(a2);
      (*(void (**)(Swift::UInt64 *, swift *))(v6 + 8))(a1, a2);
    }
  }

  return v10;
}

unint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)( unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v6 = a1;
  int v7 = *a1;
  if (v7 == 43)
  {
    uint64_t v37 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v5);
    uint64_t v41 = specialized UnsafeBufferPointer.init(rebasing:)(v37, v38, v39, v40);
    if (!v42) {
      return 0LL;
    }
    uint64_t v44 = (unsigned __int8 *)v41;
    unsigned __int8 v45 = a3 + 48;
    unsigned __int8 v46 = a3 + 55;
    unsigned __int8 v47 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }

    else
    {
      unsigned __int8 v47 = 97;
      unsigned __int8 v46 = 65;
    }

    if (v41)
    {
      unint64_t v19 = 0LL;
      uint64_t v48 = 0LL;
      unint64_t v49 = abs64(a3);
      unint64_t v50 = -(v43 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
      while (1)
      {
        unsigned int v51 = *v44;
        if (v51 < 0x30 || v51 >= v45)
        {
          if (v51 < 0x41 || v51 >= v46)
          {
            unint64_t result = 0LL;
            if (v51 < 0x61 || v51 >= v47) {
              return result;
            }
            char v52 = -87;
          }

          else
          {
            char v52 = -55;
          }
        }

        else
        {
          char v52 = -48;
        }

        unsigned __int128 v53 = __PAIR128__(v48 ^ (unint64_t)(v48 >> 63), v19 ^ (v48 >> 63)) - __PAIR128__(v48 >> 63, v48 >> 63);
        else {
          BOOL v54 = 1;
        }
        char v57 = !v54
           || (*((unint64_t *)&v53 + 1) * (unsigned __int128)v49) >> 64 != 0
           || (v50 * (unsigned __int128)(unint64_t)v53) >> 64 != 0;
        unint64_t v58 = (__PAIR128__(v50, v49) * v53) >> 64;
        else {
          char v59 = v57;
        }
        unint64_t v60 = v53 * v49;
        if ((v48 ^ (a3 >> 63)) < 0)
        {
          if ((v59 & 1) != 0) {
            return 0LL;
          }
          BOOL v35 = v60 == 0;
          unint64_t v60 = -(uint64_t)v60;
          unint64_t v58 = -(uint64_t)(v58 + !v35);
          LOBYTE(v61) = v60 != 0;
        }

        else
        {
          if ((v59 & 1) != 0) {
            return 0LL;
          }
          unint64_t v61 = v58 >> 63;
        }

        unint64_t result = 0LL;
        BOOL v35 = __CFADD__(v60, (v51 + v52));
        uint64_t v48 = (__PAIR128__(v58, v60) + (v51 + v52)) >> 64;
        unint64_t v19 = v60 + (v51 + v52);
        BOOL v62 = __OFADD__(v35, v58);
        if ((v61 & 1) != 0 || v62) {
          return result;
        }
        ++v44;
        if (!--v42) {
          return v19;
        }
      }
    }

    return 0LL;
  }

  if (v7 == 45)
  {
    uint64_t v8 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v5);
    uint64_t v12 = specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13) {
      return 0LL;
    }
    uint64_t v15 = (unsigned __int8 *)v12;
    unsigned __int8 v16 = a3 + 48;
    unsigned __int8 v17 = a3 + 55;
    unsigned __int8 v18 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }

    else
    {
      unsigned __int8 v18 = 97;
      unsigned __int8 v17 = 65;
    }

    if (v12)
    {
      unint64_t v19 = 0LL;
      uint64_t v20 = 0LL;
      unint64_t v21 = abs64(a3);
      unint64_t v22 = -(v14 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
      while (1)
      {
        unsigned int v23 = *v15;
        if (v23 < 0x30 || v23 >= v16)
        {
          if (v23 < 0x41 || v23 >= v17)
          {
            unint64_t result = 0LL;
            if (v23 < 0x61 || v23 >= v18) {
              return result;
            }
            char v24 = -87;
          }

          else
          {
            char v24 = -55;
          }
        }

        else
        {
          char v24 = -48;
        }

        unsigned __int128 v26 = __PAIR128__(v20 ^ (unint64_t)(v20 >> 63), v19 ^ (v20 >> 63)) - __PAIR128__(v20 >> 63, v20 >> 63);
        BOOL v28 = v27 && (*((unint64_t *)&v26 + 1) * (unsigned __int128)v21) >> 64 == 0;
        BOOL v29 = v28 && (v22 * (unsigned __int128)(unint64_t)v26) >> 64 == 0;
        BOOL v30 = !v29;
        unint64_t v31 = (__PAIR128__(v22, v21) * v26) >> 64;
        unint64_t v33 = v26 * v21;
        if ((v20 ^ (a3 >> 63)) < 0)
        {
          if ((v32 & 1) != 0) {
            return 0LL;
          }
          BOOL v35 = v33 == 0;
          unint64_t v33 = -(uint64_t)v33;
          unint64_t v31 = -(uint64_t)(v31 + !v35);
          LOBYTE(v34) = v33 != 0;
        }

        else
        {
          if ((v32 & 1) != 0) {
            return 0LL;
          }
          unint64_t v34 = v31 >> 63;
        }

        unint64_t result = 0LL;
        BOOL v35 = v33 >= (v23 + v24);
        uint64_t v20 = (__PAIR128__(v31, v33) - (v23 + v24)) >> 64;
        unint64_t v19 = v33 - (v23 + v24);
        BOOL v36 = __OFSUB__(v31, !v35);
        if ((v34 & 1) != 0 || v36) {
          break;
        }
        ++v15;
        if (!--v13) {
          return v19;
        }
      }

      return result;
    }

    return 0LL;
  }

  unint64_t v63 = 0LL;
  uint64_t v64 = 0LL;
  unsigned __int8 v65 = a3 + 48;
  unsigned __int8 v66 = a3 + 55;
  unsigned __int8 v67 = a3 + 87;
  if (a3 > 10)
  {
    unsigned __int8 v65 = 58;
  }

  else
  {
    unsigned __int8 v67 = 97;
    unsigned __int8 v66 = 65;
  }

  unint64_t v68 = abs64(a3);
  unint64_t v69 = -(v3 + ((a3 ^ (unint64_t)(a3 >> 63)) < a3 >> 63));
  while (1)
  {
    unsigned int v70 = *v6;
    if (v70 < 0x30 || v70 >= v65)
    {
      if (v70 < 0x41 || v70 >= v66)
      {
        unint64_t result = 0LL;
        if (v70 < 0x61 || v70 >= v67) {
          return result;
        }
        char v71 = -87;
      }

      else
      {
        char v71 = -55;
      }
    }

    else
    {
      char v71 = -48;
    }

    unsigned __int128 v72 = __PAIR128__(v64 ^ (unint64_t)(v64 >> 63), v63 ^ (v64 >> 63)) - __PAIR128__(v64 >> 63, v64 >> 63);
    else {
      BOOL v73 = 1;
    }
    char v76 = !v73
       || (*((unint64_t *)&v72 + 1) * (unsigned __int128)v68) >> 64 != 0
       || (v69 * (unsigned __int128)(unint64_t)v72) >> 64 != 0;
    unint64_t v77 = (__PAIR128__(v69, v68) * v72) >> 64;
    unint64_t v78 = v72 * v68;
    if ((v64 ^ (a3 >> 63)) < 0)
    {
      if ((v76 & 1) != 0) {
        return 0LL;
      }
      BOOL v35 = v78 == 0;
      unint64_t v78 = -(uint64_t)v78;
      unint64_t v77 = -(uint64_t)(v77 + !v35);
      LOBYTE(v79) = v78 != 0;
    }

    else
    {
      if ((v76 & 1) != 0) {
        return 0LL;
      }
      unint64_t v79 = v77 >> 63;
    }

    unint64_t result = 0LL;
    BOOL v35 = __CFADD__(v78, (v70 + v71));
    uint64_t v64 = (__PAIR128__(v77, v78) + (v70 + v71)) >> 64;
    unint64_t v63 = v78 + (v70 + v71);
    BOOL v80 = __OFADD__(v35, v77);
    if ((v79 & 1) != 0 || v80) {
      break;
    }
    ++v6;
    if (!--v5) {
      return v63;
    }
  }

  return result;
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  char v21;
  unint64_t result;
  unsigned __int8 v23;
  BOOL v24;
  char v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  unint64_t v31;
  unint64_t v32;
  BOOL v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unint64_t v45;
  uint64_t v46;
  unsigned int v47;
  char v48;
  unsigned __int8 v49;
  BOOL v50;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  BOOL v59;
  uint64_t v60;
  unint64_t v61;
  unsigned __int8 v62;
  unsigned __int8 v63;
  unsigned __int8 v64;
  uint64_t v65;
  unsigned int v66;
  char v67;
  unsigned __int8 v68;
  BOOL v69;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  BOOL v77;
  BOOL v78;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  uint64_t v6 = *a1;
  if (v6 == 43)
  {
    BOOL v35 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    uint64_t v39 = specialized UnsafeBufferPointer.init(rebasing:)(v35, v36, v37, v38);
    if (!v40) {
      return 0LL;
    }
    uint64_t v41 = (unsigned __int8 *)v39;
    uint64_t v42 = a3 + 55;
    uint64_t v43 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v44 = 58;
    }

    else
    {
      uint64_t v43 = 97;
      uint64_t v42 = 65;
      uint64_t v44 = a3 + 48;
    }

    if (!v39) {
      return 0LL;
    }
    unsigned __int8 v17 = 0LL;
    unsigned __int8 v45 = 0LL;
    unsigned __int8 v46 = a3 >> 63;
    while (1)
    {
      unsigned __int8 v47 = *v41;
      if (v47 < 0x30 || v47 >= v44)
      {
        if (v47 < 0x41 || v47 >= v42)
        {
          unint64_t result = 0LL;
          if (v47 < 0x61 || v47 >= v43) {
            return result;
          }
          uint64_t v48 = -87;
        }

        else
        {
          uint64_t v48 = -55;
        }
      }

      else
      {
        uint64_t v48 = -48;
      }

      unint64_t result = 0LL;
      unint64_t v49 = v47 + v48;
      if (v45) {
        unint64_t v50 = a3 >= 0;
      }
      else {
        unint64_t v50 = 1;
      }
      unsigned __int128 v53 = !v50
         || (v45 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
         || ((unint64_t)v46 * (unsigned __int128)v17) >> 64 != 0;
      BOOL v54 = v46 * v17 + v45 * a3;
      unint64_t v55 = (v17 * (unsigned __int128)(unint64_t)a3) >> 64;
      BOOL v30 = __CFADD__(v55, v54);
      char v56 = v55 + v54;
      if (v30) {
        unsigned __int128 v53 = 1;
      }
      char v57 = v17 * a3;
      BOOL v30 = __CFADD__(v57, v49);
      unsigned __int8 v17 = v57 + v49;
      unint64_t v58 = v30;
      BOOL v30 = __CFADD__(v30, v56);
      unsigned __int8 v45 = v58 + v56;
      char v59 = v30;
      if ((v53 & 1) != 0 || v59) {
        break;
      }
      ++v41;
      if (!--v40) {
        return v17;
      }
    }
  }

  else
  {
    if (v6 == 45)
    {
      int v7 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
      uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
      if (!v12) {
        return 0LL;
      }
      uint64_t v13 = (unsigned __int8 *)v11;
      uint64_t v14 = a3 + 55;
      uint64_t v15 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v16 = 58;
      }

      else
      {
        uint64_t v15 = 97;
        uint64_t v14 = 65;
        unsigned __int8 v16 = a3 + 48;
      }

      if (v11)
      {
        unsigned __int8 v17 = 0LL;
        unsigned __int8 v18 = 0LL;
        unint64_t v19 = a3 >> 63;
        while (1)
        {
          uint64_t v20 = *v13;
          if (v20 < 0x30 || v20 >= v16)
          {
            if (v20 < 0x41 || v20 >= v14)
            {
              unint64_t result = 0LL;
              if (v20 < 0x61 || v20 >= v15) {
                return result;
              }
              unint64_t v21 = -87;
            }

            else
            {
              unint64_t v21 = -55;
            }
          }

          else
          {
            unint64_t v21 = -48;
          }

          unint64_t result = 0LL;
          unsigned int v23 = v20 + v21;
          if (v18) {
            char v24 = a3 >= 0;
          }
          else {
            char v24 = 1;
          }
          BOOL v27 = !v24
             || (v18 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
             || ((unint64_t)v19 * (unsigned __int128)v17) >> 64 != 0;
          BOOL v28 = v19 * v17 + v18 * a3;
          BOOL v29 = (v17 * (unsigned __int128)(unint64_t)a3) >> 64;
          BOOL v30 = __CFADD__(v29, v28);
          unint64_t v31 = v29 + v28;
          if (v30) {
            BOOL v27 = 1;
          }
          char v32 = v17 * a3;
          BOOL v30 = v32 >= v23;
          unsigned __int8 v17 = v32 - v23;
          unint64_t v33 = v30;
          BOOL v30 = v31 >= !v30;
          unsigned __int8 v18 = v31 - !v33;
          unint64_t v34 = !v30;
          if ((v27 & 1) != 0 || v34) {
            break;
          }
          ++v13;
          if (!--v12) {
            return v17;
          }
        }

        return result;
      }

      return 0LL;
    }

    unint64_t v60 = 0LL;
    unint64_t v61 = 0LL;
    BOOL v62 = a3 + 48;
    unint64_t v63 = a3 + 55;
    uint64_t v64 = a3 + 87;
    if (a3 > 10)
    {
      BOOL v62 = 58;
    }

    else
    {
      uint64_t v64 = 97;
      unint64_t v63 = 65;
    }

    unsigned __int8 v65 = a3 >> 63;
    while (1)
    {
      unsigned __int8 v66 = *v5;
      if (v66 < 0x30 || v66 >= v62)
      {
        if (v66 < 0x41 || v66 >= v63)
        {
          unint64_t result = 0LL;
          if (v66 < 0x61 || v66 >= v64) {
            return result;
          }
          unsigned __int8 v67 = -87;
        }

        else
        {
          unsigned __int8 v67 = -55;
        }
      }

      else
      {
        unsigned __int8 v67 = -48;
      }

      unint64_t result = 0LL;
      unint64_t v68 = v66 + v67;
      if (v61) {
        unint64_t v69 = a3 >= 0;
      }
      else {
        unint64_t v69 = 1;
      }
      unsigned __int128 v72 = !v69
         || (v61 * (unsigned __int128)(unint64_t)a3) >> 64 != 0
         || ((unint64_t)v65 * (unsigned __int128)(unint64_t)v60) >> 64 != 0;
      BOOL v73 = v65 * v60 + v61 * a3;
      uint64_t v74 = ((unint64_t)v60 * (unsigned __int128)(unint64_t)a3) >> 64;
      BOOL v30 = __CFADD__(v74, v73);
      uint64_t v75 = v74 + v73;
      if (v30) {
        unsigned __int128 v72 = 1;
      }
      char v76 = v60 * a3;
      BOOL v30 = __CFADD__(v76, v68);
      unint64_t v60 = v76 + v68;
      unint64_t v77 = v30;
      BOOL v30 = __CFADD__(v30, v75);
      unint64_t v61 = v77 + v75;
      unint64_t v78 = v30;
      if ((v72 & 1) != 0 || v78) {
        break;
      }
      ++v5;
      if (!--v4) {
        return v60;
      }
    }
  }

  return result;
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned int v17;
  unsigned int v18;
  char v19;
  unsigned int v20;
  unsigned __int8 v21;
  unint64_t v22;
  BOOL v23;
  BOOL v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned int v35;
  unsigned int v36;
  char v37;
  unsigned __int8 v38;
  unint64_t v39;
  BOOL v40;
  char v41;
  unsigned int v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  unsigned int v46;
  char v47;
  unsigned __int8 v48;
  unint64_t v49;
  BOOL v50;
  char v51;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  uint64_t v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    unsigned __int128 v26 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    BOOL v30 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
    if (!v31)
    {
      uint64_t v20 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }

    char v32 = a3 + 55;
    unint64_t v33 = a3 + 87;
    if (a3 > 10)
    {
      unint64_t v34 = 58;
    }

    else
    {
      unint64_t v33 = 97;
      char v32 = 65;
      unint64_t v34 = a3 + 48;
    }

    if (!v30) {
      goto LABEL_67;
    }
    BOOL v35 = 0;
    do
    {
      BOOL v36 = *v30;
      if (v36 < 0x30 || v36 >= v34)
      {
        if (v36 < 0x41 || v36 >= v32)
        {
          uint64_t v20 = 0;
          int v7 = 1;
          if (v36 < 0x61 || v36 >= v33) {
            return v20 | ((unint64_t)v7 << 32);
          }
          uint64_t v37 = -87;
        }

        else
        {
          uint64_t v37 = -55;
        }
      }

      else
      {
        uint64_t v37 = -48;
      }

      uint64_t v20 = 0;
      uint64_t v38 = v36 + v37;
      uint64_t v39 = v35 * (unint64_t)a3;
      uint64_t v40 = (v39 & 0xFFFFFFFF00000000LL) != 0;
      char v24 = __CFADD__((_DWORD)v39, v38);
      BOOL v35 = v39 + v38;
      uint64_t v41 = v24;
      int v7 = 1;
      if (v40) {
        break;
      }
      if ((v41 & 1) != 0) {
        break;
      }
      int v7 = 0;
      ++v30;
      uint64_t v20 = v35;
      --v31;
    }

    while (v31);
  }

  else
  {
    if (v6 == 45)
    {
      int v7 = 1;
      uint64_t v8 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
      uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
      if (!v13)
      {
        uint64_t v20 = 0;
        return v20 | ((unint64_t)v7 << 32);
      }

      uint64_t v14 = a3 + 55;
      uint64_t v15 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v16 = 58;
      }

      else
      {
        uint64_t v15 = 97;
        uint64_t v14 = 65;
        unsigned __int8 v16 = a3 + 48;
      }

      if (v12)
      {
        unsigned __int8 v17 = 0;
        do
        {
          unsigned __int8 v18 = *v12;
          if (v18 < 0x30 || v18 >= v16)
          {
            if (v18 < 0x41 || v18 >= v14)
            {
              uint64_t v20 = 0;
              int v7 = 1;
              if (v18 < 0x61 || v18 >= v15) {
                return v20 | ((unint64_t)v7 << 32);
              }
              unint64_t v19 = -87;
            }

            else
            {
              unint64_t v19 = -55;
            }
          }

          else
          {
            unint64_t v19 = -48;
          }

          uint64_t v20 = 0;
          unint64_t v21 = v18 + v19;
          unint64_t v22 = v17 * (unint64_t)a3;
          unsigned int v23 = (v22 & 0xFFFFFFFF00000000LL) != 0;
          char v24 = v22 >= v21;
          unsigned __int8 v17 = v22 - v21;
          uint64_t v25 = !v24;
          int v7 = 1;
          if (v23) {
            break;
          }
          if ((v25 & 1) != 0) {
            break;
          }
          int v7 = 0;
          ++v12;
          uint64_t v20 = v17;
          --v13;
        }

        while (v13);
        return v20 | ((unint64_t)v7 << 32);
      }

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned int v17;
  unsigned int v18;
  char v19;
  unsigned int v20;
  unsigned __int8 v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned int v35;
  unsigned int v36;
  char v37;
  unsigned __int8 v38;
  uint64_t v39;
  BOOL v40;
  char v41;
  unsigned int v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  unsigned int v46;
  char v47;
  unsigned __int8 v48;
  uint64_t v49;
  BOOL v50;
  char v51;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  uint64_t v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    unsigned __int128 v26 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    BOOL v30 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
    if (!v31)
    {
      uint64_t v20 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }

    char v32 = a3 + 55;
    unint64_t v33 = a3 + 87;
    if (a3 > 10)
    {
      unint64_t v34 = 58;
    }

    else
    {
      unint64_t v33 = 97;
      char v32 = 65;
      unint64_t v34 = a3 + 48;
    }

    if (!v30) {
      goto LABEL_67;
    }
    BOOL v35 = 0;
    do
    {
      BOOL v36 = *v30;
      if (v36 < 0x30 || v36 >= v34)
      {
        if (v36 < 0x41 || v36 >= v32)
        {
          uint64_t v20 = 0;
          int v7 = 1;
          if (v36 < 0x61 || v36 >= v33) {
            return v20 | ((unint64_t)v7 << 32);
          }
          uint64_t v37 = -87;
        }

        else
        {
          uint64_t v37 = -55;
        }
      }

      else
      {
        uint64_t v37 = -48;
      }

      uint64_t v20 = 0;
      uint64_t v38 = v36 + v37;
      uint64_t v39 = (int)v35 * (uint64_t)(int)a3;
      uint64_t v40 = v39 != (int)v39;
      char v24 = __OFADD__((_DWORD)v39, v38);
      BOOL v35 = v39 + v38;
      uint64_t v41 = v24;
      int v7 = 1;
      if (v40) {
        break;
      }
      if ((v41 & 1) != 0) {
        break;
      }
      int v7 = 0;
      ++v30;
      uint64_t v20 = v35;
      --v31;
    }

    while (v31);
  }

  else
  {
    if (v6 == 45)
    {
      int v7 = 1;
      uint64_t v8 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
      uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
      if (!v13)
      {
        uint64_t v20 = 0;
        return v20 | ((unint64_t)v7 << 32);
      }

      uint64_t v14 = a3 + 55;
      uint64_t v15 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v16 = 58;
      }

      else
      {
        uint64_t v15 = 97;
        uint64_t v14 = 65;
        unsigned __int8 v16 = a3 + 48;
      }

      if (v12)
      {
        unsigned __int8 v17 = 0;
        do
        {
          unsigned __int8 v18 = *v12;
          if (v18 < 0x30 || v18 >= v16)
          {
            if (v18 < 0x41 || v18 >= v14)
            {
              uint64_t v20 = 0;
              int v7 = 1;
              if (v18 < 0x61 || v18 >= v15) {
                return v20 | ((unint64_t)v7 << 32);
              }
              unint64_t v19 = -87;
            }

            else
            {
              unint64_t v19 = -55;
            }
          }

          else
          {
            unint64_t v19 = -48;
          }

          uint64_t v20 = 0;
          unint64_t v21 = v18 + v19;
          unint64_t v22 = (int)v17 * (uint64_t)(int)a3;
          unsigned int v23 = v22 != (int)v22;
          char v24 = __OFSUB__((_DWORD)v22, v21);
          unsigned __int8 v17 = v22 - v21;
          uint64_t v25 = v24;
          int v7 = 1;
          if (v23) {
            break;
          }
          if ((v25 & 1) != 0) {
            break;
          }
          int v7 = 0;
          ++v12;
          uint64_t v20 = v17;
          --v13;
        }

        while (v13);
        return v20 | ((unint64_t)v7 << 32);
      }

uint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)( unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v23 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    BOOL v27 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v23, v24, v25, v26);
    if (!v28)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }

    unsigned __int8 v29 = a3 + 55;
    unsigned __int8 v30 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v31 = 58;
    }

    else
    {
      unsigned __int8 v30 = 97;
      unsigned __int8 v29 = 65;
      unsigned __int8 v31 = a3 + 48;
    }

    if (v27)
    {
      LOBYTE(v32) = 0;
      while (1)
      {
        unsigned int v33 = *v27;
        if (v33 < 0x30 || v33 >= v31)
        {
          if (v33 < 0x41 || v33 >= v29)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v33 < 0x61 || v33 >= v30) {
              return v20 | (v7 << 8);
            }
            char v34 = -87;
          }

          else
          {
            char v34 = -55;
          }
        }

        else
        {
          char v34 = -48;
        }

        unsigned __int8 v20 = 0;
        __int16 v35 = v32 * a3;
        int v7 = 1;
        if ((v35 & 0xFF00) == 0)
        {
          unsigned int v32 = v35 + (v33 + v34);
          if (((v32 >> 8) & 1) == 0)
          {
            int v7 = 0;
            ++v27;
            unsigned __int8 v20 = v32;
            if (--v28) {
              continue;
            }
          }
        }

        return v20 | (v7 << 8);
      }
    }
  }

  else
  {
    if (v6 != 45)
    {
      LOBYTE(v36) = 0;
      unsigned __int8 v37 = a3 + 55;
      unsigned __int8 v38 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v39 = 58;
      }

      else
      {
        unsigned __int8 v38 = 97;
        unsigned __int8 v37 = 65;
        unsigned __int8 v39 = a3 + 48;
      }

      while (1)
      {
        unsigned int v40 = *v5;
        if (v40 < 0x30 || v40 >= v39)
        {
          if (v40 < 0x41 || v40 >= v37)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v40 < 0x61 || v40 >= v38) {
              return v20 | (v7 << 8);
            }
            char v41 = -87;
          }

          else
          {
            char v41 = -55;
          }
        }

        else
        {
          char v41 = -48;
        }

        unsigned __int8 v20 = 0;
        __int16 v42 = v36 * a3;
        int v7 = 1;
        if ((v42 & 0xFF00) == 0)
        {
          unsigned int v36 = v42 + (v40 + v41);
          if (((v36 >> 8) & 1) == 0)
          {
            int v7 = 0;
            ++v5;
            unsigned __int8 v20 = v36;
            if (--v4) {
              continue;
            }
          }
        }

        return v20 | (v7 << 8);
      }
    }

    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }

    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }

    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }

    if (v12)
    {
      LOBYTE(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 8);
            }
            char v19 = -87;
          }

          else
          {
            char v19 = -55;
          }
        }

        else
        {
          char v19 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = v17 * a3;
        int v17 = (v17 * a3) - v21;
        int v7 = 1;
        if ((v22 & 0xFF00) == 0 && (v17 & 0xFFFFFF00) == 0)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }

        return v20 | (v7 << 8);
      }
    }
  }

  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 8);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  int v17;
  unsigned int v18;
  char v19;
  unsigned __int8 v20;
  char v21;
  int v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  int v34;
  unsigned int v35;
  char v36;
  char v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned int v45;
  char v46;
  char v47;
  int v48;
  int v49;
  BOOL v50;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v25 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    unsigned __int8 v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
    if (!v30)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }

    unsigned __int8 v31 = a3 + 55;
    unsigned int v32 = a3 + 87;
    if (a3 > 10)
    {
      unsigned int v33 = 58;
    }

    else
    {
      unsigned int v32 = 97;
      unsigned __int8 v31 = 65;
      unsigned int v33 = a3 + 48;
    }

    if (v29)
    {
      LOBYTE(v34) = 0;
      while (1)
      {
        __int16 v35 = *v29;
        if (v35 < 0x30 || v35 >= v33)
        {
          if (v35 < 0x41 || v35 >= v31)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v35 < 0x61 || v35 >= v32) {
              return v20 | (v7 << 8);
            }
            unsigned int v36 = -87;
          }

          else
          {
            unsigned int v36 = -55;
          }
        }

        else
        {
          unsigned int v36 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v37 = v35 + v36;
        unsigned __int8 v38 = (char)v34 * (char)a3;
        unsigned __int8 v39 = (char)(v34 * a3);
        char v34 = v39 + v37;
        unsigned int v40 = v34 != (char)(v39 + v37);
        int v7 = 1;
        if (v39 == v38 && !v40)
        {
          int v7 = 0;
          ++v29;
          unsigned __int8 v20 = v34;
          if (--v30) {
            continue;
          }
        }

        return v20 | (v7 << 8);
      }
    }
  }

  else
  {
    if (v6 != 45)
    {
      LOBYTE(v41) = 0;
      __int16 v42 = a3 + 55;
      uint64_t v43 = a3 + 87;
      if (a3 > 10)
      {
        uint64_t v44 = 58;
      }

      else
      {
        uint64_t v43 = 97;
        __int16 v42 = 65;
        uint64_t v44 = a3 + 48;
      }

      while (1)
      {
        unsigned __int8 v45 = *v5;
        if (v45 < 0x30 || v45 >= v44)
        {
          if (v45 < 0x41 || v45 >= v42)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v45 < 0x61 || v45 >= v43) {
              return v20 | (v7 << 8);
            }
            unsigned __int8 v46 = -87;
          }

          else
          {
            unsigned __int8 v46 = -55;
          }
        }

        else
        {
          unsigned __int8 v46 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v47 = v45 + v46;
        uint64_t v48 = (char)v41 * (char)a3;
        unint64_t v49 = (char)(v41 * a3);
        char v41 = v49 + v47;
        unint64_t v50 = v41 != (char)(v49 + v47);
        int v7 = 1;
        if (v49 == v48 && !v50)
        {
          int v7 = 0;
          ++v5;
          unsigned __int8 v20 = v41;
          if (--v4) {
            continue;
          }
        }

        return v20 | (v7 << 8);
      }
    }

    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 8);
    }

    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }

    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }

    if (v12)
    {
      LOBYTE(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 8);
            }
            char v19 = -87;
          }

          else
          {
            char v19 = -55;
          }
        }

        else
        {
          char v19 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = (char)v17 * (char)a3;
        uint64_t v23 = (char)(v17 * a3);
        int v17 = v23 - v21;
        uint64_t v24 = v17 != (char)(v23 - v21);
        int v7 = 1;
        if (v23 == v22 && !v24)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }

        return v20 | (v7 << 8);
      }
    }
  }

  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 8);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  int v17;
  unsigned int v18;
  char v19;
  unsigned __int16 v20;
  unsigned __int8 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  uint64_t v28;
  unsigned __int8 v29;
  unsigned __int8 v30;
  unsigned __int8 v31;
  int v32;
  unsigned int v33;
  char v34;
  int v35;
  int v36;
  unsigned __int8 v37;
  unsigned __int8 v38;
  unsigned __int8 v39;
  unsigned int v40;
  char v41;
  int v42;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v23 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    BOOL v27 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v23, v24, v25, v26);
    if (!v28)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }

    unsigned __int8 v29 = a3 + 55;
    unsigned __int8 v30 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v31 = 58;
    }

    else
    {
      unsigned __int8 v30 = 97;
      unsigned __int8 v29 = 65;
      unsigned __int8 v31 = a3 + 48;
    }

    if (v27)
    {
      LOWORD(v32) = 0;
      while (1)
      {
        unsigned int v33 = *v27;
        if (v33 < 0x30 || v33 >= v31)
        {
          if (v33 < 0x41 || v33 >= v29)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v33 < 0x61 || v33 >= v30) {
              return v20 | (v7 << 16);
            }
            char v34 = -87;
          }

          else
          {
            char v34 = -55;
          }
        }

        else
        {
          char v34 = -48;
        }

        unsigned __int8 v20 = 0;
        __int16 v35 = (unsigned __int16)v32 * (unsigned __int16)a3;
        int v7 = 1;
        if ((v35 & 0xFFFF0000) == 0)
        {
          unsigned int v32 = (unsigned __int16)v35 + (v33 + v34);
          if ((v32 & 0x10000) == 0)
          {
            int v7 = 0;
            ++v27;
            unsigned __int8 v20 = v32;
            if (--v28) {
              continue;
            }
          }
        }

        return v20 | (v7 << 16);
      }
    }
  }

  else
  {
    if (v6 != 45)
    {
      LOWORD(v36) = 0;
      unsigned __int8 v37 = a3 + 55;
      unsigned __int8 v38 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v39 = 58;
      }

      else
      {
        unsigned __int8 v38 = 97;
        unsigned __int8 v37 = 65;
        unsigned __int8 v39 = a3 + 48;
      }

      while (1)
      {
        unsigned int v40 = *v5;
        if (v40 < 0x30 || v40 >= v39)
        {
          if (v40 < 0x41 || v40 >= v37)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v40 < 0x61 || v40 >= v38) {
              return v20 | (v7 << 16);
            }
            char v41 = -87;
          }

          else
          {
            char v41 = -55;
          }
        }

        else
        {
          char v41 = -48;
        }

        unsigned __int8 v20 = 0;
        __int16 v42 = (unsigned __int16)v36 * (unsigned __int16)a3;
        int v7 = 1;
        if ((v42 & 0xFFFF0000) == 0)
        {
          unsigned int v36 = (unsigned __int16)v42 + (v40 + v41);
          if ((v36 & 0x10000) == 0)
          {
            int v7 = 0;
            ++v5;
            unsigned __int8 v20 = v36;
            if (--v4) {
              continue;
            }
          }
        }

        return v20 | (v7 << 16);
      }
    }

    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }

    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }

    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }

    if (v12)
    {
      LOWORD(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 16);
            }
            char v19 = -87;
          }

          else
          {
            char v19 = -55;
          }
        }

        else
        {
          char v19 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = (unsigned __int16)v17 * (unsigned __int16)a3;
        int v17 = (unsigned __int16)(v17 * a3) - v21;
        int v7 = 1;
        if ((v22 & 0xFFFF0000) == 0 && (v17 & 0xFFFF0000) == 0)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }

        return v20 | (v7 << 16);
      }
    }
  }

  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 16);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  int v17;
  unsigned int v18;
  char v19;
  unsigned __int16 v20;
  unsigned __int8 v21;
  int v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  int v34;
  unsigned int v35;
  char v36;
  unsigned __int8 v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned int v45;
  char v46;
  unsigned __int8 v47;
  int v48;
  int v49;
  BOOL v50;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    int v7 = 1;
    uint64_t v25 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    unsigned __int8 v29 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
    if (!v30)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }

    unsigned __int8 v31 = a3 + 55;
    unsigned int v32 = a3 + 87;
    if (a3 > 10)
    {
      unsigned int v33 = 58;
    }

    else
    {
      unsigned int v32 = 97;
      unsigned __int8 v31 = 65;
      unsigned int v33 = a3 + 48;
    }

    if (v29)
    {
      LOWORD(v34) = 0;
      while (1)
      {
        __int16 v35 = *v29;
        if (v35 < 0x30 || v35 >= v33)
        {
          if (v35 < 0x41 || v35 >= v31)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v35 < 0x61 || v35 >= v32) {
              return v20 | (v7 << 16);
            }
            unsigned int v36 = -87;
          }

          else
          {
            unsigned int v36 = -55;
          }
        }

        else
        {
          unsigned int v36 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v37 = v35 + v36;
        unsigned __int8 v38 = (__int16)v34 * (__int16)a3;
        unsigned __int8 v39 = (__int16)(v34 * a3);
        char v34 = v39 + v37;
        unsigned int v40 = v34 != (__int16)(v39 + v37);
        int v7 = 1;
        if (v39 == v38 && !v40)
        {
          int v7 = 0;
          ++v29;
          unsigned __int8 v20 = v34;
          if (--v30) {
            continue;
          }
        }

        return v20 | (v7 << 16);
      }
    }
  }

  else
  {
    if (v6 != 45)
    {
      LOWORD(v41) = 0;
      __int16 v42 = a3 + 55;
      uint64_t v43 = a3 + 87;
      if (a3 > 10)
      {
        uint64_t v44 = 58;
      }

      else
      {
        uint64_t v43 = 97;
        __int16 v42 = 65;
        uint64_t v44 = a3 + 48;
      }

      while (1)
      {
        unsigned __int8 v45 = *v5;
        if (v45 < 0x30 || v45 >= v44)
        {
          if (v45 < 0x41 || v45 >= v42)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v45 < 0x61 || v45 >= v43) {
              return v20 | (v7 << 16);
            }
            unsigned __int8 v46 = -87;
          }

          else
          {
            unsigned __int8 v46 = -55;
          }
        }

        else
        {
          unsigned __int8 v46 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v47 = v45 + v46;
        uint64_t v48 = (__int16)v41 * (__int16)a3;
        unint64_t v49 = (__int16)(v41 * a3);
        char v41 = v49 + v47;
        unint64_t v50 = v41 != (__int16)(v49 + v47);
        int v7 = 1;
        if (v49 == v48 && !v50)
        {
          int v7 = 0;
          ++v5;
          unsigned __int8 v20 = v41;
          if (--v4) {
            continue;
          }
        }

        return v20 | (v7 << 16);
      }
    }

    int v7 = 1;
    uint64_t v8 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    uint64_t v12 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v8, v9, v10, v11);
    if (!v13)
    {
      unsigned __int8 v20 = 0;
      return v20 | (v7 << 16);
    }

    unsigned __int8 v14 = a3 + 55;
    unsigned __int8 v15 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v16 = 58;
    }

    else
    {
      unsigned __int8 v15 = 97;
      unsigned __int8 v14 = 65;
      unsigned __int8 v16 = a3 + 48;
    }

    if (v12)
    {
      LOWORD(v17) = 0;
      while (1)
      {
        unsigned int v18 = *v12;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v14)
          {
            unsigned __int8 v20 = 0;
            int v7 = 1;
            if (v18 < 0x61 || v18 >= v15) {
              return v20 | (v7 << 16);
            }
            char v19 = -87;
          }

          else
          {
            char v19 = -55;
          }
        }

        else
        {
          char v19 = -48;
        }

        unsigned __int8 v20 = 0;
        unsigned __int8 v21 = v18 + v19;
        __int16 v22 = (__int16)v17 * (__int16)a3;
        uint64_t v23 = (__int16)(v17 * a3);
        int v17 = v23 - v21;
        uint64_t v24 = v17 != (__int16)(v23 - v21);
        int v7 = 1;
        if (v23 == v22 && !v24)
        {
          int v7 = 0;
          ++v12;
          unsigned __int8 v20 = v17;
          if (--v13) {
            continue;
          }
        }

        return v20 | (v7 << 16);
      }
    }
  }

  unsigned __int8 v20 = 0;
  int v7 = 0;
  return v20 | (v7 << 16);
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  uint64_t v17;
  unsigned int v18;
  char v19;
  uint64_t result;
  unsigned __int8 v21;
  uint64_t v22;
  BOOL v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  uint64_t v35;
  unsigned int v36;
  char v37;
  unsigned __int8 v38;
  uint64_t v39;
  BOOL v40;
  BOOL v41;
  uint64_t v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unsigned __int8 v45;
  unsigned int v46;
  char v47;
  unsigned __int8 v48;
  uint64_t v49;
  BOOL v50;
  BOOL v51;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    uint64_t v25 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    unsigned __int8 v29 = specialized UnsafeBufferPointer.init(rebasing:)(v25, v26, v27, v28);
    if (!v30) {
      return 0LL;
    }
    unsigned __int8 v31 = (unsigned __int8 *)v29;
    unsigned int v32 = a3 + 48;
    unsigned int v33 = a3 + 55;
    char v34 = a3 + 87;
    if (a3 > 10)
    {
      unsigned int v32 = 58;
    }

    else
    {
      char v34 = 97;
      unsigned int v33 = 65;
    }

    if (!v29) {
      return 0LL;
    }
    __int16 v35 = 0LL;
    do
    {
      unsigned int v36 = *v31;
      if (v36 < 0x30 || v36 >= v32)
      {
        if (v36 < 0x41 || v36 >= v33)
        {
          unint64_t result = 0LL;
          if (v36 < 0x61 || v36 >= v34) {
            return result;
          }
          unsigned __int8 v37 = -87;
        }

        else
        {
          unsigned __int8 v37 = -55;
        }
      }

      else
      {
        unsigned __int8 v37 = -48;
      }

      unint64_t result = 0LL;
      unsigned __int8 v38 = v36 + v37;
      unsigned __int8 v39 = v35 * a3;
      unsigned int v40 = (unsigned __int128)(v35 * (__int128)a3) >> 64 != (v35 * a3) >> 63;
      __int16 v35 = v35 * a3 + v38;
      char v41 = __OFADD__(v39, v38);
      if (v40) {
        break;
      }
      if (v41) {
        break;
      }
      ++v31;
      unint64_t result = v35;
      --v30;
    }

    while (v30);
  }

  else
  {
    if (v6 == 45)
    {
      int v7 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
      uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
      if (!v12) {
        return 0LL;
      }
      uint64_t v13 = (unsigned __int8 *)v11;
      unsigned __int8 v14 = a3 + 48;
      unsigned __int8 v15 = a3 + 55;
      unsigned __int8 v16 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v14 = 58;
      }

      else
      {
        unsigned __int8 v16 = 97;
        unsigned __int8 v15 = 65;
      }

      if (v11)
      {
        int v17 = 0LL;
        do
        {
          unsigned int v18 = *v13;
          if (v18 < 0x30 || v18 >= v14)
          {
            if (v18 < 0x41 || v18 >= v15)
            {
              unint64_t result = 0LL;
              if (v18 < 0x61 || v18 >= v16) {
                return result;
              }
              char v19 = -87;
            }

            else
            {
              char v19 = -55;
            }
          }

          else
          {
            char v19 = -48;
          }

          unint64_t result = 0LL;
          unsigned __int8 v21 = v18 + v19;
          __int16 v22 = v17 * a3;
          uint64_t v23 = (unsigned __int128)(v17 * (__int128)a3) >> 64 != (v17 * a3) >> 63;
          int v17 = v17 * a3 - v21;
          uint64_t v24 = __OFSUB__(v22, v21);
          if (v23) {
            break;
          }
          if (v24) {
            break;
          }
          ++v13;
          unint64_t result = v17;
          --v12;
        }

        while (v12);
        return result;
      }

      return 0LL;
    }

    __int16 v42 = 0LL;
    uint64_t v43 = a3 + 48;
    uint64_t v44 = a3 + 55;
    unsigned __int8 v45 = a3 + 87;
    if (a3 > 10)
    {
      uint64_t v43 = 58;
    }

    else
    {
      unsigned __int8 v45 = 97;
      uint64_t v44 = 65;
    }

    do
    {
      unsigned __int8 v46 = *v5;
      if (v46 < 0x30 || v46 >= v43)
      {
        if (v46 < 0x41 || v46 >= v44)
        {
          unint64_t result = 0LL;
          if (v46 < 0x61 || v46 >= v45) {
            return result;
          }
          unsigned __int8 v47 = -87;
        }

        else
        {
          unsigned __int8 v47 = -55;
        }
      }

      else
      {
        unsigned __int8 v47 = -48;
      }

      unint64_t result = 0LL;
      uint64_t v48 = v46 + v47;
      unint64_t v49 = v42 * a3;
      unint64_t v50 = (unsigned __int128)(v42 * (__int128)a3) >> 64 != (v42 * a3) >> 63;
      __int16 v42 = v42 * a3 + v48;
      unsigned int v51 = __OFADD__(v49, v48);
      if (v50) {
        break;
      }
      if (v51) {
        break;
      }
      ++v5;
      unint64_t result = v42;
      --v4;
    }

    while (v4);
  }

  return result;
}

LABEL_67:
      unsigned __int8 v20 = 0;
      int v7 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }

    __int16 v42 = 0;
    uint64_t v43 = a3 + 55;
    uint64_t v44 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }

    else
    {
      uint64_t v44 = 97;
      uint64_t v43 = 65;
      unsigned __int8 v45 = a3 + 48;
    }

    do
    {
      unsigned __int8 v46 = *v5;
      if (v46 < 0x30 || v46 >= v45)
      {
        if (v46 < 0x41 || v46 >= v43)
        {
          unsigned __int8 v20 = 0;
          int v7 = 1;
          if (v46 < 0x61 || v46 >= v44) {
            return v20 | ((unint64_t)v7 << 32);
          }
          unsigned __int8 v47 = -87;
        }

        else
        {
          unsigned __int8 v47 = -55;
        }
      }

      else
      {
        unsigned __int8 v47 = -48;
      }

      unsigned __int8 v20 = 0;
      uint64_t v48 = v46 + v47;
      unint64_t v49 = v42 * (unint64_t)a3;
      unint64_t v50 = (v49 & 0xFFFFFFFF00000000LL) != 0;
      uint64_t v24 = __CFADD__((_DWORD)v49, v48);
      __int16 v42 = v49 + v48;
      unsigned int v51 = v24;
      int v7 = 1;
      if (v50) {
        break;
      }
      if ((v51 & 1) != 0) {
        break;
      }
      int v7 = 0;
      ++v5;
      unsigned __int8 v20 = v42;
      --v4;
    }

    while (v4);
  }

  return v20 | ((unint64_t)v7 << 32);
}

      unsigned __int8 v20 = 0;
      int v7 = 0;
      return v20 | ((unint64_t)v7 << 32);
    }

    __int16 v42 = 0;
    uint64_t v43 = a3 + 55;
    uint64_t v44 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }

    else
    {
      uint64_t v44 = 97;
      uint64_t v43 = 65;
      unsigned __int8 v45 = a3 + 48;
    }

    do
    {
      unsigned __int8 v46 = *v5;
      if (v46 < 0x30 || v46 >= v45)
      {
        if (v46 < 0x41 || v46 >= v43)
        {
          unsigned __int8 v20 = 0;
          int v7 = 1;
          if (v46 < 0x61 || v46 >= v44) {
            return v20 | ((unint64_t)v7 << 32);
          }
          unsigned __int8 v47 = -87;
        }

        else
        {
          unsigned __int8 v47 = -55;
        }
      }

      else
      {
        unsigned __int8 v47 = -48;
      }

      unsigned __int8 v20 = 0;
      uint64_t v48 = v46 + v47;
      unint64_t v49 = (int)v42 * (uint64_t)(int)a3;
      unint64_t v50 = v49 != (int)v49;
      uint64_t v24 = __OFADD__((_DWORD)v49, v48);
      __int16 v42 = v49 + v48;
      unsigned int v51 = v24;
      int v7 = 1;
      if (v50) {
        break;
      }
      if ((v51 & 1) != 0) {
        break;
      }
      int v7 = 0;
      ++v5;
      unsigned __int8 v20 = v42;
      --v4;
    }

    while (v4);
  }

  return v20 | ((unint64_t)v7 << 32);
}

    if (value > 0xBF)
    {
      if (value - 55204 > 0xFFFFD45B) {
        specialized Unicode._InternalNFD.Iterator.decomposeHangul(_:)(value);
      }
      else {
        specialized Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)(value, v19);
      }
      goto LABEL_73;
    }

  unint64_t v118 = *((void *)v115 + 3);
  if (!v118) {
    goto LABEL_108;
  }
  char v119 = (void **)(v118 + 8 * v116);
  uint64_t v120 = *v119;
  *((void *)v115 + 27) = v116 + 1;
  swift_unknownObjectRetain(v120, v106, v107, v108);
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    unint64_t v161 = v120;
    swift_dynamicCast(v105, &v161, v155, a2, 7LL);
    unint64_t v121 = v105;
    unint64_t v122 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
  }

  else
  {
    unint64_t v122 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
    v122(v104, 1LL, 1LL, a2);
    _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v120, (uint64_t)a2, v104);
    swift_unknownObjectRelease(v120);
    uint64_t v125 = v140;
    uint64_t v126 = v145;
    uint64_t v127 = v104;
    size_t v128 = v141;
    (*(void (**)(uint64_t, uint64_t *, uint64_t))(v140 + 16))(v145, v127, v141);
    (*(void (**)(uint64_t *, uint64_t))(v125 + 8))(v153, v128);
    unint64_t v121 = v151;
    (*(void (**)(char *, uint64_t, uint64_t *))(v8 + 32))(v151, v126, a2);
  }

  unint64_t v123 = v109;
  id v124 = v60;
  while (1)
  {
    v122((uint64_t *)v121, 0LL, 1LL, a2);
    Swift::String::Index v133 = v150;
    (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v150, v121, a2);
    Swift::String::Index v134 = swift_dynamicCast(v19, v133, a2, &type metadata for String, 6LL);
    Swift::String::Index v135 = Description;
    Description[7](v19, v134 ^ 1u, 1LL, &type metadata for String);
    if (((unsigned int (*)(char *, uint64_t, ValueMetadata *))v135[6])(v19, 1LL, &type metadata for String) == 1)
    {
      swift_release((uint64_t)v162);
      outlined consume of [A : B].Iterator._Variant<A, B>(v157);
      (*(void (**)(char *, uint64_t))(v143 + 8))(v19, v144);
      return 0LL;
    }

    int64_t v110 = (void (*)(char *, char *, ValueMetadata *))v135[4];
    char v111 = v149;
    v110(v149, v19, &type metadata for String);
    char v112 = (uint64_t)v158;
    v110(v158, v111, &type metadata for String);
    unint64_t v114 = type metadata accessor for _NativeSet(0LL, (uint64_t)&type metadata for String, v160, v113);
    _NativeSet._unsafeUpdate(with:)(v112, v114);
    uint64_t v109 = v123;
    unint64_t v60 = v124;
    uint64_t v104 = v153;
    uint64_t v105 = v151;
    unint64_t v61 = v157;
    if ((v157 & 0x8000000000000000LL) != 0) {
      goto LABEL_63;
    }
LABEL_75:
    if (v60)
    {
      id v124 = (v60 - 1) & v60;
      uint64_t v129 = __clz(__rbit64(v60)) | (v109 << 6);
      unint64_t v123 = v109;
      goto LABEL_89;
    }

    uint64_t v130 = v109 + 1;
    if (__OFADD__(v109, 1LL)) {
      goto LABEL_106;
    }
    uint64_t v131 = *(void *)&v154[8 * v130];
    unint64_t v123 = v109 + 1;
    if (!v131)
    {
      unint64_t v123 = v109 + 2;
      uint64_t v131 = *(void *)&v154[8 * v123];
      if (!v131) {
        break;
      }
    }

      unsigned int v51 = 1861LL;
      goto LABEL_76;
    }
  }

  char v57 = a1;
  unint64_t v58 = a2 & 0xFFFFFFFFFFFFFFLL;
  if (a3 < 0) {
    goto LABEL_75;
  }
  unsigned __int8 v30 = a4 - a3;
  if (a4 - a3 < 0) {
    goto LABEL_70;
  }
  unsigned __int8 v31 = (char *)&v57 + a3;
  if ((a6 & 0x2000000000000000LL) == 0)
  {
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      unsigned int v32 = (id)((a6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      unsigned int v33 = a5 & 0xFFFFFFFFFFFFLL;
      if (a7 < 0) {
        goto LABEL_75;
      }
    }

    else
    {
      unsigned int v32 = _StringObject.sharedUTF8.getter(a5, a6);
      unsigned int v33 = v55;
      if (a7 < 0) {
        goto LABEL_75;
      }
    }

    if (v33 >= a8)
    {
      __int16 v35 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a7, a8, (uint64_t)v32, v33);
      unsigned int v36 = v34;
      if ((_DWORD)v17)
      {
        if ((a9 & 1) != 0 || v30 == v34)
        {
          if (v34 >= v30) {
            unsigned __int8 v37 = v30;
          }
          else {
            unsigned __int8 v37 = v34;
          }
          unsigned __int8 v38 = _swift_stdlib_memcmp(v31, v35, v37);
          unsigned __int8 v39 = v38;
          unsigned int v40 = v30 - v36;
LABEL_44:
          if (!v38) {
            unsigned __int8 v39 = v40;
          }
LABEL_59:
          uint64_t v48 = v39 == 0;
          unint64_t v49 = v39 < 0;
          unint64_t v50 = v48;
          if ((a9 & 1) != 0) {
            return v49;
          }
          else {
            return v50;
          }
        }

        return 0;
      }

      unsigned __int8 v20 = v31;
      unsigned __int8 v21 = v30;
      BOOL v54 = v35;
      uint64_t v43 = v36;
      return _stringCompareFastUTF8Abnormal(_:_:expecting:)((uint64_t)v20, v21, (uint64_t)v54, v43, v15);
    }

    goto LABEL_67;
  }

  v56[0] = a5;
  v56[1] = a6 & 0xFFFFFFFFFFFFFFLL;
  if (a7 < 0) {
    goto LABEL_75;
  }
  uint64_t v43 = a8 - a7;
  if (a8 - a7 < 0) {
    goto LABEL_70;
  }
  if (!(_DWORD)v17)
  {
    unsigned __int8 v20 = (char *)&v57 + a3;
    unsigned __int8 v21 = v30;
    BOOL v54 = (char *)v56 + a7;
    return _stringCompareFastUTF8Abnormal(_:_:expecting:)((uint64_t)v20, v21, (uint64_t)v54, v43, v15);
  }

  uint64_t v44 = v30 - v43;
  if (v30 == v43 || (a9 & 1) != 0)
  {
    if (v43 >= v30) {
      unsigned __int8 v46 = v30;
    }
    else {
      unsigned __int8 v46 = a8 - a7;
    }
    unsigned __int8 v47 = _swift_stdlib_memcmp(v31, (char *)v56 + a7, v46);
    unsigned __int8 v39 = v47;
    if (!v47) {
      unsigned __int8 v39 = v44;
    }
    goto LABEL_59;
  }

  return 0;
}

                if (!_swift_stdlib_isLinkingConsonant(v21)) {
                  goto LABEL_18;
                }
              }

              else
              {
LABEL_81:
                isLinkingConsonant = _swift_stdlib_isLinkingConsonant(v21);
                if (v25 != 12 || !isLinkingConsonant) {
                  goto LABEL_18;
                }
              }

              if ((*((_BYTE *)v91 + v22) & 0xC0) == 0x80)
              {
                uint64_t v44 = v19;
                do
                  unsigned __int8 v45 = v90[v44--] & 0xC0;
                while (v45 == 128);
                __int16 v22 = v44 - 1;
              }

              HIDWORD(v46) = _decodeScalar(_:startingAt:)((uint64_t)v91, v35, v22) - 2381;
              LODWORD(v46) = HIDWORD(v46);
              unsigned __int8 v47 = ((v46 >> 7) < 9) & (0x15Bu >> (v46 >> 7));
              while (1)
              {
                uint64_t v48 = specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( v22,  a2,  (uint64_t)v91);
                if ((v50 & 1) != 0) {
                  goto LABEL_18;
                }
                unsigned int v51 = v48;
                __int16 v22 = v49;
                char v52 = Unicode._GraphemeBreakProperty.init(from:)(v48);
                if (_swift_stdlib_isLinkingConsonant(v51)) {
                  break;
                }
                if (v52 != 12)
                {
                  HIDWORD(v54) = v51 - 2381;
                  LODWORD(v54) = v51 - 2381;
                  unsigned __int128 v53 = v54 >> 7;
                  if (v53 <= 8) {
                    v47 |= 0x15Bu >> v53;
                  }
                }
              }

              if ((v47 & 1) == 0) {
                goto LABEL_18;
              }
            }

            break;
        }
      }

      else
      {
        if (v26 > 0xCu) {
          goto LABEL_176;
        }
        if (((1 << v26) & 0x1204) == 0)
        {
          if (((1 << v26) & 3) == 0) {
LABEL_176:
          }
            _swift_stdlib_isLinkingConsonant(v21);
LABEL_18:
          int v6 = v89;
          return v6 - v19;
        }
      }

            if ((v60 & ~v59 & 0x2000000000000000LL) != 0
              && swift_isUniquelyReferenced_nonNull_native(v59 & 0xFFFFFFFFFFFFFFFLL))
            {
              char v76 = v246;
              uint64_t v75 = v247;
              unint64_t v77 = _StringGuts.nativeUnusedCapacity.getter(v246, v247);
              if ((v78 & 1) != 0)
              {
LABEL_272:
                Swift::String::Index v235 = 258LL;
LABEL_273:
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v235,  0);
              }

              if (v74 > 15) {
                goto LABEL_82;
              }
              if ((v75 & 0x2000000000000000LL) == 0)
              {
                unint64_t v79 = v75;
                if (v77 < v70)
                {
LABEL_119:
                  char v112 = 1;
                  goto LABEL_155;
                }

    uint64_t v64 = HIBYTE(v13) & 0xF;
    unsigned __int8 v65 = HIBYTE(v63) & 0xF;
    unsigned __int8 v66 = v65 + v64;
    if (v65)
    {
      unsigned __int8 v67 = 0;
      unint64_t v68 = 0LL;
      do
      {
        unint64_t v69 = v64 + v68;
        unsigned int v70 = v68 + 1;
        if (v68 >= 8) {
          char v71 = v63;
        }
        else {
          char v71 = v61;
        }
        unsigned __int128 v72 = v71 >> (v67 & 0x38);
        BOOL v73 = (8 * v64 + v67) & 0x38;
        uint64_t v74 = (-255LL << v73) - 1;
        uint64_t v75 = (unint64_t)v72 << v73;
        char v76 = v75 | v74 & v13;
        unint64_t v77 = v75 | v74 & v10;
        if (v69 < 8) {
          uint64_t v10 = v77;
        }
        else {
          uint64_t v13 = v76;
        }
        v67 += 8;
        unint64_t v68 = v70;
      }

      while (v65 != v70);
    }

    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(0xE800000000000000LL);
    unint64_t v78 = 0xA000000000000000LL;
    if (!(v10 & 0x8080808080808080LL | v13 & 0x80808080808080LL)) {
      unint64_t v78 = 0xE000000000000000LL;
    }
    v298._uint64_t countAndFlagsBits = v10;
    v298._object = (void *)(v78 & 0xFF00000000000000LL | (v66 << 56) | v13 & 0xFFFFFFFFFFFFFFLL);
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    *(void *)&uint64_t v297 = a1;
    unint64_t v79 = (swift *)type metadata accessor for UnsafeMutablePointer(0LL, a3, v44, (uint64_t)v45);
    a1 = String.init<A>(describing:)((uint64_t)&v297, v79);
    a3 = v80;
  }

  swift_bridgeObjectRetain_n(a3, 5LL, v87, v88);
  v263._Swift::UInt64 rawBits = 1LL;
  v264._Swift::UInt64 rawBits = (v86 << 16) | 1;
  v265._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v263, v264, a1, a3);
  if (v265._rawBits < 0x10000) {
    v265._rawBits |= 3;
  }
  a2 = specialized Collection.count.getter(v265, v266, a1, a3);
  swift_bridgeObjectRelease(a3);
  if ((object & 0x1000000000000000LL) == 0) {
    goto LABEL_95;
  }
LABEL_293:
  unint64_t v267 = String.UTF8View._foreignCount()();
  uint64_t v92 = v267 + a2;
  if (!__OFADD__(v267, a2)) {
    goto LABEL_96;
  }
LABEL_295:
  __break(1u);
LABEL_296:
  swift_bridgeObjectRetain_n(a3, 5LL, v89, v90);
  v268._Swift::UInt64 rawBits = 1LL;
  v269._Swift::UInt64 rawBits = (v61 << 16) | 1;
  v270._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v268, v269, a1, a3);
  if (v270._rawBits < 0x10000) {
    v270._rawBits |= 3;
  }
  uint64_t v154 = specialized Collection.count.getter(v270, v271, a1, a3);
  swift_bridgeObjectRelease(a3);
  char v148 = v298._countAndFlagsBits;
  uint64_t v11 = (unint64_t)v298._object;
LABEL_299:
  uint64_t v272 = String.UTF8View._foreignCount()();
  unint64_t v155 = v272 + v154;
  if (!__OFADD__(v272, v154)) {
    goto LABEL_188;
  }
LABEL_301:
  __break(1u);
LABEL_302:
  swift_bridgeObjectRetain_n(v155, 5LL, v152, v153);
  v273._Swift::UInt64 rawBits = 1LL;
  v274._Swift::UInt64 rawBits = (v13 << 16) | 1;
  v275._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v273, v274, a3, v155);
  if (v275._rawBits < 0x10000) {
    v275._rawBits |= 3;
  }
  unint64_t v190 = specialized Collection.count.getter(v275, v276, a3, v155);
  swift_bridgeObjectRelease(v155);
  if ((v10 & 0x1000000000000000LL) == 0) {
    goto LABEL_219;
  }
LABEL_305:
  uint64_t v277 = String.UTF8View._foreignCount()();
  Swift::String::Index v191 = v277 + v190;
  if (__OFADD__(v277, v190)) {
    goto LABEL_307;
  }
LABEL_220:
  if ((v11 & ~v10 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
  {
    Swift::String::Index v192 = (unint64_t)v298._object;
    Swift::String::Index v193 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v194 & 1) != 0)
    {
LABEL_334:
      uint64_t v289 = 258LL;
      goto LABEL_335;
    }

    if (v191 <= 15 && ((v192 & 0x2000000000000000LL) != 0 || v193 < v190))
    {
LABEL_232:
      swift_bridgeObjectRelease_n(v155, 5LL);
      uint64_t v200 = v298._countAndFlagsBits;
      swift_bridgeObjectRetain(v192, v201, v202, v203);
      unint64_t v204 = _StringGuts._convertedToSmall()(v200, v192);
      unint64_t v206 = v205;
      swift_bridgeObjectRelease(v192);
      v207._Swift::UInt64 rawBits = (v13 << 16) | 1;
      v208._Swift::UInt64 rawBits = 1LL;
      v209._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v208, v207, a3, v155);
      if (v209._rawBits < 0x10000) {
        v209._rawBits |= 3;
      }
      unint64_t v211 = specialized String.init(_:)(v209, v210, a3, v155);
      v213 = v212;
      swift_bridgeObjectRelease(v155);
      char v214 = _StringGuts._convertedToSmall()(v211, v213);
      unint64_t v216 = v215;
      swift_bridgeObjectRelease(v213);
      unint64_t v217 = specialized _SmallString.init(_:appending:)(v204, v206, v214, v216);
      if ((v219 & 1) == 0)
      {
        char v220 = v217;
        uint64_t v221 = v218;
        swift_bridgeObjectRelease(v192);
        swift_bridgeObjectRelease(v155);
        v298._uint64_t countAndFlagsBits = v220;
        v298._object = v221;
        goto LABEL_273;
      }

    uint64_t v64 = HIBYTE(v13) & 0xF;
    unsigned __int8 v65 = HIBYTE(v63) & 0xF;
    unsigned __int8 v66 = v65 + v64;
    if (v65)
    {
      unsigned __int8 v67 = 0;
      unint64_t v68 = 0LL;
      do
      {
        unint64_t v69 = v64 + v68;
        unsigned int v70 = v68 + 1;
        if (v68 >= 8) {
          char v71 = v63;
        }
        else {
          char v71 = v61;
        }
        unsigned __int128 v72 = v71 >> (v67 & 0x38);
        BOOL v73 = (8 * v64 + v67) & 0x38;
        uint64_t v74 = (-255LL << v73) - 1;
        uint64_t v75 = (unint64_t)v72 << v73;
        char v76 = v75 | v74 & v13;
        unint64_t v77 = v75 | v74 & v10;
        if (v69 < 8) {
          uint64_t v10 = v77;
        }
        else {
          uint64_t v13 = v76;
        }
        v67 += 8;
        unint64_t v68 = v70;
      }

      while (v65 != v70);
    }

    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(0xE800000000000000LL);
    unint64_t v78 = 0xA000000000000000LL;
    if (!(v10 & 0x8080808080808080LL | v13 & 0x80808080808080LL)) {
      unint64_t v78 = 0xE000000000000000LL;
    }
    v298._uint64_t countAndFlagsBits = v10;
    v298._object = (void *)(v78 & 0xFF00000000000000LL | (v66 << 56) | v13 & 0xFFFFFFFFFFFFFFLL);
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    *(void *)&uint64_t v297 = a1;
    unint64_t v79 = (swift *)type metadata accessor for UnsafePointer(0LL, a3, v44, (uint64_t)v45);
    a1 = String.init<A>(describing:)((uint64_t)&v297, v79);
    a3 = v80;
  }

  swift_bridgeObjectRetain_n(a3, 5LL, v87, v88);
  v263._Swift::UInt64 rawBits = 1LL;
  v264._Swift::UInt64 rawBits = (v86 << 16) | 1;
  v265._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v263, v264, a1, a3);
  if (v265._rawBits < 0x10000) {
    v265._rawBits |= 3;
  }
  a2 = specialized Collection.count.getter(v265, v266, a1, a3);
  swift_bridgeObjectRelease(a3);
  if ((object & 0x1000000000000000LL) == 0) {
    goto LABEL_95;
  }
LABEL_293:
  unint64_t v267 = String.UTF8View._foreignCount()();
  uint64_t v92 = v267 + a2;
  if (!__OFADD__(v267, a2)) {
    goto LABEL_96;
  }
LABEL_295:
  __break(1u);
LABEL_296:
  swift_bridgeObjectRetain_n(a3, 5LL, v89, v90);
  v268._Swift::UInt64 rawBits = 1LL;
  v269._Swift::UInt64 rawBits = (v61 << 16) | 1;
  v270._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v268, v269, a1, a3);
  if (v270._rawBits < 0x10000) {
    v270._rawBits |= 3;
  }
  uint64_t v154 = specialized Collection.count.getter(v270, v271, a1, a3);
  swift_bridgeObjectRelease(a3);
  char v148 = v298._countAndFlagsBits;
  uint64_t v11 = (unint64_t)v298._object;
LABEL_299:
  uint64_t v272 = String.UTF8View._foreignCount()();
  unint64_t v155 = v272 + v154;
  if (!__OFADD__(v272, v154)) {
    goto LABEL_188;
  }
LABEL_301:
  __break(1u);
LABEL_302:
  swift_bridgeObjectRetain_n(v155, 5LL, v152, v153);
  v273._Swift::UInt64 rawBits = 1LL;
  v274._Swift::UInt64 rawBits = (v13 << 16) | 1;
  v275._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v273, v274, a3, v155);
  if (v275._rawBits < 0x10000) {
    v275._rawBits |= 3;
  }
  unint64_t v190 = specialized Collection.count.getter(v275, v276, a3, v155);
  swift_bridgeObjectRelease(v155);
  if ((v10 & 0x1000000000000000LL) == 0) {
    goto LABEL_219;
  }
LABEL_305:
  uint64_t v277 = String.UTF8View._foreignCount()();
  Swift::String::Index v191 = v277 + v190;
  if (__OFADD__(v277, v190)) {
    goto LABEL_307;
  }
LABEL_220:
  if ((v11 & ~v10 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
  {
    Swift::String::Index v192 = (unint64_t)v298._object;
    Swift::String::Index v193 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v194 & 1) != 0)
    {
LABEL_334:
      uint64_t v289 = 258LL;
      goto LABEL_335;
    }

    if (v191 <= 15 && ((v192 & 0x2000000000000000LL) != 0 || v193 < v190))
    {
LABEL_232:
      swift_bridgeObjectRelease_n(v155, 5LL);
      uint64_t v200 = v298._countAndFlagsBits;
      swift_bridgeObjectRetain(v192, v201, v202, v203);
      unint64_t v204 = _StringGuts._convertedToSmall()(v200, v192);
      unint64_t v206 = v205;
      swift_bridgeObjectRelease(v192);
      v207._Swift::UInt64 rawBits = (v13 << 16) | 1;
      v208._Swift::UInt64 rawBits = 1LL;
      v209._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v208, v207, a3, v155);
      if (v209._rawBits < 0x10000) {
        v209._rawBits |= 3;
      }
      unint64_t v211 = specialized String.init(_:)(v209, v210, a3, v155);
      v213 = v212;
      swift_bridgeObjectRelease(v155);
      char v214 = _StringGuts._convertedToSmall()(v211, v213);
      unint64_t v216 = v215;
      swift_bridgeObjectRelease(v213);
      unint64_t v217 = specialized _SmallString.init(_:appending:)(v204, v206, v214, v216);
      if ((v219 & 1) == 0)
      {
        char v220 = v217;
        uint64_t v221 = v218;
        swift_bridgeObjectRelease(v192);
        swift_bridgeObjectRelease(v155);
        v298._uint64_t countAndFlagsBits = v220;
        v298._object = v221;
        goto LABEL_273;
      }

    BOOL v62 = HIBYTE(v12) & 0xF;
    unint64_t v63 = HIBYTE(v61) & 0xF;
    uint64_t v64 = v63 + v62;
    if (v63)
    {
      unsigned __int8 v65 = 0;
      unsigned __int8 v66 = 0LL;
      do
      {
        unsigned __int8 v67 = v62 + v66;
        unint64_t v68 = v66 + 1;
        if (v66 >= 8) {
          unint64_t v69 = v61;
        }
        else {
          unint64_t v69 = v2;
        }
        unsigned int v70 = v69 >> (v65 & 0x38);
        char v71 = (8 * v62 + v65) & 0x38;
        unsigned __int128 v72 = (-255LL << v71) - 1;
        BOOL v73 = (unint64_t)v70 << v71;
        uint64_t v74 = v73 | v72 & v12;
        uint64_t v75 = v73 | v72 & v9;
        if (v67 < 8) {
          uint64_t v9 = v75;
        }
        else {
          uint64_t v12 = v74;
        }
        v65 += 8;
        unsigned __int8 v66 = v68;
      }

      while (v63 != v68);
    }

    swift_bridgeObjectRelease(countAndFlagsBits);
    swift_bridgeObjectRelease(0xE800000000000000LL);
    char v76 = 0xA000000000000000LL;
    if (!(v9 & 0x8080808080808080LL | v12 & 0x80808080808080LL)) {
      char v76 = 0xE000000000000000LL;
    }
    v254._uint64_t countAndFlagsBits = v9;
    v254._object = (void *)(v76 & 0xFF00000000000000LL | (v64 << 56) | v12 & 0xFFFFFFFFFFFFFFLL);
    unint64_t v251 = object;
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    uint64_t v12 = specialized String.init<A>(describing:)(a1);
    uint64_t v9 = v77;
  }

  swift_bridgeObjectRetain_n(v9, 5LL, v83, v84);
  v224._Swift::UInt64 rawBits = 1LL;
  v225._Swift::UInt64 rawBits = (v82 << 16) | 1;
  v226._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v224, v225, v12, v9);
  if (v226._rawBits < 0x10000) {
    v226._rawBits |= 3;
  }
  uint64_t v82 = specialized Collection.count.getter(v226, v227, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((object & 0x1000000000000000LL) == 0) {
    goto LABEL_95;
  }
LABEL_270:
  Swift::String::Index v228 = String.UTF8View._foreignCount()();
  uint64_t v88 = v228 + v82;
  if (!__OFADD__(v228, v82)) {
    goto LABEL_96;
  }
LABEL_272:
  __break(1u);
LABEL_273:
  swift_bridgeObjectRetain_n(v9, 5LL, v85, v86);
  v229._Swift::UInt64 rawBits = 1LL;
  v230._Swift::UInt64 rawBits = (object << 16) | 1;
  v231._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v229, v230, v12, v9);
  if (v231._rawBits < 0x10000) {
    v231._rawBits |= 3;
  }
  uint64_t v11 = specialized Collection.count.getter(v231, v232, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((v2 & 0x1000000000000000LL) == 0) {
    goto LABEL_184;
  }
LABEL_276:
  uint64_t v233 = String.UTF8View._foreignCount()();
  unint64_t v146 = v233 + v11;
  if (__OFADD__(v233, v11)) {
    goto LABEL_278;
  }
LABEL_185:
  if ((countAndFlagsBits & ~v2 & 0x2000000000000000LL) != 0
    && swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v147 = (unint64_t)v254._object;
    char v148 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v149 & 1) != 0)
    {
LABEL_303:
      Swift::String::Index v244 = 258LL;
      goto LABEL_304;
    }

    if (v146 <= 15 && ((v147 & 0x2000000000000000LL) != 0 || v148 < (uint64_t)v11))
    {
LABEL_197:
      swift_bridgeObjectRelease_n(v9, 5LL);
      unint64_t v152 = v254._countAndFlagsBits;
      swift_bridgeObjectRetain(v147, v153, v154, v155);
      unint64_t v156 = _StringGuts._convertedToSmall()(v152, v147);
      unint64_t v158 = v157;
      swift_bridgeObjectRelease(v147);
      v159._Swift::UInt64 rawBits = (object << 16) | 1;
      v160._Swift::UInt64 rawBits = 1LL;
      v161._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v160, v159, v12, v9);
      if (v161._rawBits < 0x10000) {
        v161._rawBits |= 3;
      }
      unint64_t v163 = specialized String.init(_:)(v161, v162, v12, v9);
      Swift::String::Index v165 = v164;
      swift_bridgeObjectRelease(v9);
      Swift::String::Index v166 = _StringGuts._convertedToSmall()(v163, v165);
      Swift::String::Index v168 = v167;
      swift_bridgeObjectRelease(v165);
      unint64_t v169 = specialized _SmallString.init(_:appending:)(v156, v158, v166, v168);
      unint64_t v171 = v252;
      if ((v172 & 1) == 0)
      {
        unint64_t v173 = v169;
        unint64_t v174 = v170;
        swift_bridgeObjectRelease(v147);
        swift_bridgeObjectRelease(v9);
        v254._uint64_t countAndFlagsBits = v173;
        v254._object = v174;
        goto LABEL_204;
      }

    BOOL v62 = HIBYTE(v12) & 0xF;
    unint64_t v63 = HIBYTE(v61) & 0xF;
    uint64_t v64 = v63 + v62;
    if (v63)
    {
      unsigned __int8 v65 = 0;
      unsigned __int8 v66 = 0LL;
      do
      {
        unsigned __int8 v67 = v62 + v66;
        unint64_t v68 = v66 + 1;
        if (v66 >= 8) {
          unint64_t v69 = v61;
        }
        else {
          unint64_t v69 = v2;
        }
        unsigned int v70 = v69 >> (v65 & 0x38);
        char v71 = (8 * v62 + v65) & 0x38;
        unsigned __int128 v72 = (-255LL << v71) - 1;
        BOOL v73 = (unint64_t)v70 << v71;
        uint64_t v74 = v73 | v72 & v12;
        uint64_t v75 = v73 | v72 & v9;
        if (v67 < 8) {
          uint64_t v9 = v75;
        }
        else {
          uint64_t v12 = v74;
        }
        v65 += 8;
        unsigned __int8 v66 = v68;
      }

      while (v63 != v68);
    }

    swift_bridgeObjectRelease(countAndFlagsBits);
    swift_bridgeObjectRelease(0xE800000000000000LL);
    char v76 = 0xA000000000000000LL;
    if (!(v9 & 0x8080808080808080LL | v12 & 0x80808080808080LL)) {
      char v76 = 0xE000000000000000LL;
    }
    v254._uint64_t countAndFlagsBits = v9;
    v254._object = (void *)(v76 & 0xFF00000000000000LL | (v64 << 56) | v12 & 0xFFFFFFFFFFFFFFLL);
    unint64_t v251 = object;
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    uint64_t v12 = specialized String.init<A>(describing:)((void *)a1);
    uint64_t v9 = v77;
  }

  swift_bridgeObjectRetain_n(v9, 5LL, v83, v84);
  v224._Swift::UInt64 rawBits = 1LL;
  v225._Swift::UInt64 rawBits = (v82 << 16) | 1;
  v226._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v224, v225, v12, v9);
  if (v226._rawBits < 0x10000) {
    v226._rawBits |= 3;
  }
  uint64_t v82 = specialized Collection.count.getter(v226, v227, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((object & 0x1000000000000000LL) == 0) {
    goto LABEL_95;
  }
LABEL_270:
  Swift::String::Index v228 = String.UTF8View._foreignCount()();
  uint64_t v88 = v228 + v82;
  if (!__OFADD__(v228, v82)) {
    goto LABEL_96;
  }
LABEL_272:
  __break(1u);
LABEL_273:
  swift_bridgeObjectRetain_n(v9, 5LL, v85, v86);
  v229._Swift::UInt64 rawBits = 1LL;
  v230._Swift::UInt64 rawBits = (object << 16) | 1;
  v231._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v229, v230, v12, v9);
  if (v231._rawBits < 0x10000) {
    v231._rawBits |= 3;
  }
  uint64_t v11 = specialized Collection.count.getter(v231, v232, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((v2 & 0x1000000000000000LL) == 0) {
    goto LABEL_184;
  }
LABEL_276:
  uint64_t v233 = String.UTF8View._foreignCount()();
  unint64_t v146 = v233 + v11;
  if (__OFADD__(v233, v11)) {
    goto LABEL_278;
  }
LABEL_185:
  if ((countAndFlagsBits & ~v2 & 0x2000000000000000LL) != 0
    && swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v147 = (unint64_t)v254._object;
    char v148 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v149 & 1) != 0)
    {
LABEL_303:
      Swift::String::Index v244 = 258LL;
      goto LABEL_304;
    }

    if (v146 <= 15 && ((v147 & 0x2000000000000000LL) != 0 || v148 < (uint64_t)v11))
    {
LABEL_197:
      swift_bridgeObjectRelease_n(v9, 5LL);
      unint64_t v152 = v254._countAndFlagsBits;
      swift_bridgeObjectRetain(v147, v153, v154, v155);
      unint64_t v156 = _StringGuts._convertedToSmall()(v152, v147);
      unint64_t v158 = v157;
      swift_bridgeObjectRelease(v147);
      v159._Swift::UInt64 rawBits = (object << 16) | 1;
      v160._Swift::UInt64 rawBits = 1LL;
      v161._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v160, v159, v12, v9);
      if (v161._rawBits < 0x10000) {
        v161._rawBits |= 3;
      }
      unint64_t v163 = specialized String.init(_:)(v161, v162, v12, v9);
      Swift::String::Index v165 = v164;
      swift_bridgeObjectRelease(v9);
      Swift::String::Index v166 = _StringGuts._convertedToSmall()(v163, v165);
      Swift::String::Index v168 = v167;
      swift_bridgeObjectRelease(v165);
      unint64_t v169 = specialized _SmallString.init(_:appending:)(v156, v158, v166, v168);
      unint64_t v171 = v252;
      if ((v172 & 1) == 0)
      {
        unint64_t v173 = v169;
        unint64_t v174 = v170;
        swift_bridgeObjectRelease(v147);
        swift_bridgeObjectRelease(v9);
        v254._uint64_t countAndFlagsBits = v173;
        v254._object = v174;
        goto LABEL_204;
      }

  if (v32 == 1) {
    goto LABEL_68;
  }
  return v31;
}

        WordBreakProperty = _swift_stdlib_getWordBreakProperty(v11);
        uint64_t v26 = 0;
        BOOL v27 = 0;
        uint64_t v28 = 8;
        unsigned __int8 v30 = 1;
        switch(WordBreakProperty)
        {
          case 0:
          case 1:
            goto LABEL_68;
          case 2:
            goto LABEL_232;
          case 3:
            uint64_t v26 = 0;
            uint64_t v28 = 7;
            BOOL v27 = 1;
            goto LABEL_232;
          case 4:
            uint64_t v26 = 0;
            BOOL v27 = 0;
            uint64_t v28 = 0;
            goto LABEL_232;
          case 5:
            uint64_t v26 = 0;
            BOOL v27 = 0;
            uint64_t v28 = 11;
            goto LABEL_232;
          case 6:
            uint64_t v26 = 0;
            BOOL v27 = 0;
            uint64_t v28 = 9;
            goto LABEL_232;
          case 7:
            uint64_t v26 = 0;
            BOOL v27 = 0;
            uint64_t v28 = 10;
            goto LABEL_232;
          case 8:
            BOOL v27 = 0;
            uint64_t v28 = 13;
            uint64_t v26 = 1;
            goto LABEL_232;
          case 9:
            uint64_t v26 = 0;
            BOOL v27 = 0;
            uint64_t v28 = 5;
            goto LABEL_232;
          case 10:
            if (v25 == 16) {
              goto LABEL_9;
            }
            uint64_t v26 = 0;
            BOOL v27 = 0;
            uint64_t v28 = 16;
            break;
          case 11:
            if (v25 == 17) {
              goto LABEL_9;
            }
            uint64_t v26 = 0;
            BOOL v27 = 0;
            uint64_t v28 = 4;
            break;
          default:
            if (v25 == 1) {
              goto LABEL_281;
            }
            uint64_t v26 = 0;
            BOOL v27 = 0;
            unsigned __int8 v30 = 1;
            uint64_t v28 = 1;
            break;
        }

        goto LABEL_232;
      }

  *a4 = v7;
  a4[1] = v52;
  a4[2] = v53;
}

  uint64_t v43 = checkTransitiveCompleteness(v6, a2, a3, a4);
  uint64_t v11 = v43;
  unsigned int v70 = v44;
  if (v43) {
    unsigned int v32 = 3;
  }
  else {
    unsigned int v32 = 4;
  }
  *(_BYTE *)(a2 + 17) = v32;
  if (v43) {
    goto LABEL_71;
  }
LABEL_109:
  unint64_t v55 = *(void *)(v66 + 16);
  *(void *)(v66 + 16) = 0LL;
  char v56 = v6;
  if (v55)
  {
    uint64_t v11 = 0LL;
    goto LABEL_119;
  }

  char v57 = 0LL;
LABEL_120:
  unint64_t v58 = *(os_unfair_lock_s **)a2;
  os_unfair_lock_lock(*(os_unfair_lock_t *)a2);
  atomic_store(v57 | v32, (unint64_t *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a2 + 8) + 8LL));
  char v59 = *(void **)(a2 + 8);
  if (*v59 == 1LL)
  {
    unint64_t v60 = (void *)v59[2];
    v59[2] = 0LL;
    unint64_t v61 = v56;
    if (v60) {
      operator delete(v60);
    }
    swift_slowDealloc(v59);
  }

  else
  {
    --*v59;
    unint64_t v61 = v56;
  }

  os_unfair_lock_unlock(v58);
  *(_BYTE *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0LL;
  if ((v32 - 1) >= 4u) {
LABEL_127:
  }
    abort();
  return v61;
}

  if (v24)
  {
    char v34 = v33;
    goto LABEL_69;
  }

unint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)( unsigned __int8 *a1, uint64_t a2, int64_t a3)
{
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    uint64_t v26 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    uint64_t v30 = specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
    if (!v31) {
      return 0LL;
    }
    unsigned int v32 = (unsigned __int8 *)v30;
    unsigned __int8 v33 = a3 + 48;
    unsigned __int8 v34 = a3 + 55;
    unsigned __int8 v35 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v33 = 58;
    }

    else
    {
      unsigned __int8 v35 = 97;
      unsigned __int8 v34 = 65;
    }

    if (!v30) {
      return 0LL;
    }
    unint64_t v36 = 0LL;
    do
    {
      unsigned int v37 = *v32;
      if (v37 < 0x30 || v37 >= v33)
      {
        if (v37 < 0x41 || v37 >= v34)
        {
          unint64_t result = 0LL;
          if (v37 < 0x61 || v37 >= v35) {
            return result;
          }
          char v38 = -87;
        }

        else
        {
          char v38 = -55;
        }
      }

      else
      {
        char v38 = -48;
      }

      unint64_t result = 0LL;
      unsigned __int8 v39 = v37 + v38;
      BOOL v40 = !is_mul_ok(v36, a3);
      unint64_t v41 = v36 * a3;
      BOOL v24 = __CFADD__(v41, v39);
      unint64_t v36 = v41 + v39;
      char v42 = v24;
      if (v40) {
        break;
      }
      if ((v42 & 1) != 0) {
        break;
      }
      ++v32;
      unint64_t result = v36;
      --v31;
    }

    while (v31);
  }

  else
  {
    if (v6 == 45)
    {
      uint64_t v7 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
      uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
      if (!v12) {
        return 0LL;
      }
      uint64_t v13 = (unsigned __int8 *)v11;
      unsigned __int8 v14 = a3 + 48;
      unsigned __int8 v15 = a3 + 55;
      unsigned __int8 v16 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v14 = 58;
      }

      else
      {
        unsigned __int8 v16 = 97;
        unsigned __int8 v15 = 65;
      }

      if (v11)
      {
        unint64_t v17 = 0LL;
        do
        {
          unsigned int v18 = *v13;
          if (v18 < 0x30 || v18 >= v14)
          {
            if (v18 < 0x41 || v18 >= v15)
            {
              unint64_t result = 0LL;
              if (v18 < 0x61 || v18 >= v16) {
                return result;
              }
              char v19 = -87;
            }

            else
            {
              char v19 = -55;
            }
          }

          else
          {
            char v19 = -48;
          }

          unint64_t result = 0LL;
          unsigned __int8 v21 = v18 + v19;
          BOOL v22 = !is_mul_ok(v17, a3);
          unint64_t v23 = v17 * a3;
          BOOL v24 = v23 >= v21;
          unint64_t v17 = v23 - v21;
          char v25 = !v24;
          if (v22) {
            break;
          }
          if ((v25 & 1) != 0) {
            break;
          }
          ++v13;
          unint64_t result = v17;
          --v12;
        }

        while (v12);
        return result;
      }

      return 0LL;
    }

    unint64_t v43 = 0LL;
    unsigned __int8 v44 = a3 + 48;
    unsigned __int8 v45 = a3 + 55;
    unsigned __int8 v46 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v44 = 58;
    }

    else
    {
      unsigned __int8 v46 = 97;
      unsigned __int8 v45 = 65;
    }

    do
    {
      unsigned int v47 = *v5;
      if (v47 < 0x30 || v47 >= v44)
      {
        if (v47 < 0x41 || v47 >= v45)
        {
          unint64_t result = 0LL;
          if (v47 < 0x61 || v47 >= v46) {
            return result;
          }
          char v48 = -87;
        }

        else
        {
          char v48 = -55;
        }
      }

      else
      {
        char v48 = -48;
      }

      unint64_t result = 0LL;
      unsigned __int8 v49 = v47 + v48;
      BOOL v50 = !is_mul_ok(v43, a3);
      unint64_t v51 = v43 * a3;
      BOOL v24 = __CFADD__(v51, v49);
      unint64_t v43 = v51 + v49;
      char v52 = v24;
      if (v50) {
        break;
      }
      if ((v52 & 1) != 0) {
        break;
      }
      ++v5;
      unint64_t result = v43;
      --v4;
    }

    while (v4);
  }

  return result;
}

{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned int v20;
  char v21;
  unint64_t result;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  unint64_t v26;
  BOOL v27;
  BOOL v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unsigned __int8 v37;
  unsigned __int8 v38;
  unsigned __int8 v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unsigned __int8 v45;
  unsigned __int8 v46;
  unsigned __int8 v47;
  unint64_t v48;
  unsigned int v49;
  char v50;
  BOOL v51;
  BOOL v52;
  BOOL v53;
  unint64_t v54;
  BOOL v55;
  BOOL v56;
  unint64_t v57;
  BOOL v58;
  int v59;
  unsigned int v60;
  char v61;
  BOOL v62;
  BOOL v63;
  BOOL v64;
  unint64_t v65;
  BOOL v66;
  BOOL v67;
  unint64_t v68;
  int v69;
  uint64_t v4 = a2;
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 == 43)
  {
    uint64_t v30 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    unsigned __int8 v34 = specialized UnsafeBufferPointer.init(rebasing:)(v30, v31, v32, v33);
    if (v35)
    {
      unint64_t v36 = (unsigned __int8 *)v34;
      unsigned int v37 = a3 + 48;
      char v38 = a3 + 55;
      unsigned __int8 v39 = a3 + 87;
      if (a3 > 10)
      {
        unsigned int v37 = 58;
      }

      else
      {
        unsigned __int8 v39 = 97;
        char v38 = 65;
      }

      if (!v34) {
        return 0LL;
      }
      BOOL v40 = 0LL;
      unint64_t v41 = 0LL;
      char v42 = a3 >> 63;
      while (1)
      {
        unint64_t v60 = *v36;
        if (v60 < 0x30 || v60 >= v37)
        {
          if (v60 < 0x41 || v60 >= v38)
          {
            unint64_t result = 0LL;
            if (v60 < 0x61 || v60 >= v39) {
              return result;
            }
            unint64_t v61 = -87;
          }

          else
          {
            unint64_t v61 = -55;
          }
        }

        else
        {
          unint64_t v61 = -48;
        }

        unint64_t result = 0LL;
        BOOL v62 = !is_mul_ok(v41, a3);
        unint64_t v63 = !is_mul_ok(v40, v42);
        uint64_t v64 = __CFADD__(v41 * a3, v40 * v42);
        unsigned __int8 v65 = (a3 * __PAIR128__(v41, v40)) >> 64;
        unsigned __int8 v66 = __CFADD__(v41 * a3 + v40 * v42, (v40 * (unsigned __int128)(unint64_t)a3) >> 64);
        unsigned __int8 v67 = a3 >= 0 || v41 == 0;
        if (!v67 || v62 || v63 || v64) {
          break;
        }
        unint64_t v68 = v40 * a3;
        unint64_t v58 = __CFADD__(v68, (v60 + v61));
        BOOL v40 = v68 + (v60 + v61);
        unint64_t v69 = v58;
        if (v65 == -1LL)
        {
          if (((v69 | v66) & 1) != 0) {
            return 0LL;
          }
          unint64_t v41 = -1LL;
        }

        else if (v69)
        {
          if (v66) {
            return 0LL;
          }
          unint64_t v41 = v65 + 1;
        }

        else
        {
          unint64_t v41 = v65;
          if (v66) {
            return 0LL;
          }
        }

        ++v36;
        if (!--v35) {
          return v40;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  else if (v6 == 45)
  {
    uint64_t v7 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v4);
    uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
    if (v12)
    {
      uint64_t v13 = (unsigned __int8 *)v11;
      unsigned __int8 v14 = a3 + 48;
      unsigned __int8 v15 = a3 + 55;
      unsigned __int8 v16 = a3 + 87;
      if (a3 > 10)
      {
        unsigned __int8 v14 = 58;
      }

      else
      {
        unsigned __int8 v16 = 97;
        unsigned __int8 v15 = 65;
      }

      if (v11)
      {
        unint64_t v17 = 0LL;
        unsigned int v18 = 0LL;
        char v19 = a3 >> 63;
        while (1)
        {
          unsigned __int8 v20 = *v13;
          if (v20 < 0x30 || v20 >= v14)
          {
            if (v20 < 0x41 || v20 >= v15)
            {
              unint64_t result = 0LL;
              if (v20 < 0x61 || v20 >= v16) {
                return result;
              }
              unsigned __int8 v21 = -87;
            }

            else
            {
              unsigned __int8 v21 = -55;
            }
          }

          else
          {
            unsigned __int8 v21 = -48;
          }

          unint64_t result = 0LL;
          unint64_t v23 = !is_mul_ok(v18, a3);
          BOOL v24 = !is_mul_ok(v17, v19);
          char v25 = __CFADD__(v18 * a3, v17 * v19);
          uint64_t v26 = (a3 * __PAIR128__(v18, v17)) >> 64;
          uint64_t v27 = __CFADD__(v18 * a3 + v17 * v19, (v17 * (unsigned __int128)(unint64_t)a3) >> 64);
          uint64_t v28 = a3 >= 0 || v18 == 0;
          if (!v28 || v23 || v24 || v25) {
            return result;
          }
          uint64_t v29 = v17 * a3;
          unint64_t result = v29 - (v20 + v21);
          if (v26) {
            goto LABEL_37;
          }
          if (v27) {
            return 0LL;
          }
LABEL_38:
          ++v13;
          unint64_t v17 = v29 - (v20 + v21);
          unsigned int v18 = v26;
          if (!--v12) {
            return result;
          }
        }

        if (!v26) {
          return 0LL;
        }
        --v26;
LABEL_37:
        if (v27) {
          return 0LL;
        }
        goto LABEL_38;
      }

      return 0LL;
    }

    return 0LL;
  }

  else
  {
    unint64_t v43 = 0LL;
    unsigned __int8 v44 = 0LL;
    unsigned __int8 v45 = a3 + 48;
    unsigned __int8 v46 = a3 + 55;
    unsigned int v47 = a3 + 87;
    if (a3 > 10)
    {
      unsigned __int8 v45 = 58;
    }

    else
    {
      unsigned int v47 = 97;
      unsigned __int8 v46 = 65;
    }

    char v48 = a3 >> 63;
    while (1)
    {
      unsigned __int8 v49 = *v5;
      if (v49 < 0x30 || v49 >= v45)
      {
        if (v49 < 0x41 || v49 >= v46)
        {
          unint64_t result = 0LL;
          if (v49 < 0x61 || v49 >= v47) {
            return result;
          }
          BOOL v50 = -87;
        }

        else
        {
          BOOL v50 = -55;
        }
      }

      else
      {
        BOOL v50 = -48;
      }

      unint64_t result = 0LL;
      unint64_t v51 = !is_mul_ok(v44, a3);
      char v52 = !is_mul_ok(v43, v48);
      unsigned __int128 v53 = __CFADD__(v44 * a3, v43 * v48);
      BOOL v54 = (a3 * __PAIR128__(v44, v43)) >> 64;
      unint64_t v55 = __CFADD__(v44 * a3 + v43 * v48, (v43 * (unsigned __int128)(unint64_t)a3) >> 64);
      char v56 = a3 >= 0 || v44 == 0;
      if (!v56 || v51 || v52 || v53) {
        break;
      }
      char v57 = v43 * a3;
      unint64_t v58 = __CFADD__(v57, (v49 + v50));
      unint64_t v43 = v57 + (v49 + v50);
      char v59 = v58;
      if (v54 == -1LL)
      {
        if (((v59 | v55) & 1) != 0) {
          return 0LL;
        }
        unsigned __int8 v44 = -1LL;
      }

      else if (v59)
      {
        if (v55) {
          return 0LL;
        }
        unsigned __int8 v44 = v54 + 1;
      }

      else
      {
        unsigned __int8 v44 = v54;
        if (v55) {
          return 0LL;
        }
      }

      ++v5;
      if (!--v4) {
        return v43;
      }
    }
  }

  return result;
}

Swift::UInt64 specialized closure #1 in _parseInteger<A, B>(ascii:radix:)( unsigned __int8 *a1, uint64_t a2, Swift::_Int128 by)
{
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  uint64_t low = by.low;
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  int v6 = *a1;
  if (v6 != 43)
  {
    if (v6 != 45)
    {
      else {
        unsigned __int8 v37 = LOBYTE(by.low) + 87;
      }
      else {
        unsigned __int8 v38 = LOBYTE(by.low) + 55;
      }
      else {
        unsigned __int8 v39 = 58;
      }
      while (1)
      {
        unsigned int v40 = *v5;
        if (v40 < 0x30 || v40 >= v39)
        {
          if (v40 < 0x41 || v40 >= v38)
          {
            v20.partialValue.uint64_t low = 0LL;
            if (v40 < 0x61 || v40 >= v37) {
              return v20.partialValue.low;
            }
            char v41 = -87;
          }

          else
          {
            char v41 = -55;
          }
        }

        else
        {
          char v41 = -48;
        }

        unsigned __int8 v42 = v40 + v41;
        v43.uint64_t low = low;
        v43.high = low >> 63;
        Swift::tuple_partialValue__Int128_overflow_Bool v20 = _Int128.multipliedReportingOverflow(by:)(v43);
        int v44 = *(_DWORD *)&v20.overflow;
        *(void *)&v20.overfuint64_t low = v20.partialValue.low + v42;
        BOOL v46 = __CFADD__(v20.partialValue.low, v42);
        if (v20.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
        {
          if (((v46 | v44) & 1) != 0) {
            goto LABEL_97;
          }
        }

        else if (v46)
        {
          if ((v44 & 1) != 0) {
            goto LABEL_97;
          }
        }

        else if ((v44 & 1) != 0)
        {
          goto LABEL_97;
        }

        ++v5;
        if (!--v4) {
          goto LABEL_98;
        }
      }
    }

    uint64_t v7 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, a2);
    uint64_t v11 = specialized UnsafeBufferPointer.init(rebasing:)(v7, v8, v9, v10);
    if (!v12)
    {
      v20.partialValue.uint64_t low = 0LL;
      return v20.partialValue.low;
    }

    uint64_t v13 = (unsigned __int8 *)v11;
    if (low <= 10) {
      unsigned __int8 v14 = 97;
    }
    else {
      unsigned __int8 v14 = low + 87;
    }
    if (low <= 10) {
      unsigned __int8 v15 = 65;
    }
    else {
      unsigned __int8 v15 = low + 55;
    }
    if (low <= 10) {
      unsigned __int8 v16 = low + 48;
    }
    else {
      unsigned __int8 v16 = 58;
    }
    if (v11)
    {
      uint64_t v17 = v12;
      do
      {
        unsigned int v18 = *v13;
        if (v18 < 0x30 || v18 >= v16)
        {
          if (v18 < 0x41 || v18 >= v15)
          {
            v20.partialValue.uint64_t low = 0LL;
            if (v18 < 0x61 || v18 >= v14) {
              return v20.partialValue.low;
            }
            char v19 = -87;
          }

          else
          {
            char v19 = -55;
          }
        }

        else
        {
          char v19 = -48;
        }

        unsigned __int8 v21 = v18 + v19;
        v22.uint64_t low = low;
        v22.high = low >> 63;
        Swift::tuple_partialValue__Int128_overflow_Bool v20 = _Int128.multipliedReportingOverflow(by:)(v22);
        BOOL v24 = v20.partialValue.low >= v21;
        v20.partialValue.low -= v21;
        int v25 = !v24;
        if (v20.partialValue.high == 0x8000000000000000LL)
        {
          if (((*(_DWORD *)&v20.overflow | v25) & 1) != 0) {
            goto LABEL_97;
          }
        }

        else if (v20.overflow)
        {
          goto LABEL_97;
        }

        ++v13;
        --v17;
      }

      while (v17);
      return v20.partialValue.low;
    }

uint64_t closure #1 in _parseInteger<A, B>(ascii:radix:)@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, uint64_t a5@<X6>, uint64_t a6@<X8>)
{
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  int v10 = *a1;
  if (v10 == 43)
  {
    uint64_t v18 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, a2);
    a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v18, v19, v20, v21);
    uint64_t v15 = a6;
LABEL_7:
    uint64_t v16 = a3;
    int v17 = 0;
    return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
  }

  if (v10 != 45)
  {
    uint64_t v15 = a6;
    goto LABEL_7;
  }

  uint64_t v11 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, a2);
  a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v11, v12, v13, v14);
  uint64_t v15 = a6;
  uint64_t v16 = a3;
  int v17 = 1;
  return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
}

uint64_t FixedWidthInteger.init<A>(_:radix:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, swift *a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v71 = a4;
  uint64_t v72 = a1;
  uint64_t v70 = a5;
  uint64_t v7 = *((void *)a3 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v59 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  BOOL v73 = v10;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v10,  (uint64_t)a3,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UTF8View);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v59 - v13;
  uint64_t v17 = type metadata accessor for Optional((const char *)0xFF, a2, v15, v16);
  uint64_t v20 = type metadata accessor for Optional(0LL, v17, v18, v19);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  unint64_t v23 = (char *)&v59 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v59 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = MEMORY[0x1895F8858](v27);
  if ((unint64_t)(v31 - 37) <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Radix not in range 2...36",  25LL,  2,  "Swift/IntegerParsing.swift",  26LL,  2,  0x80uLL,  0);
  }
  uint64_t v61 = v12;
  uint64_t v62 = (uint64_t)&v59 - v30;
  uint64_t v63 = v29;
  uint64_t v64 = v28;
  uint64_t v65 = v33;
  uint64_t v66 = v32;
  uint64_t v68 = v7;
  uint64_t v69 = v31;
  unsigned __int8 v67 = v9;
  uint64_t v34 = a2;
  uint64_t v35 = v71;
  if (((*(uint64_t (**)(swift *))(*(void *)(*((void *)v73 + 1) + 8LL) + 104LL))(a3) & 1) != 0)
  {
    (*(void (**)(uint64_t, swift *))(v68 + 8))(v72, a3);
    uint64_t v52 = *(void *)(a2 - 8);
  }

  else
  {
    uint64_t v36 = (uint64_t)v73;
    unsigned __int8 v37 = (uint64_t (*)(swift *, const char *))*((void *)v73 + 15);
    unint64_t v60 = v23;
    uint64_t v38 = v72;
    uint64_t v39 = v37(a3, v73);
    uint64_t v59 = (uint64_t)&v59;
    MEMORY[0x1895F8858](v39);
    *(&v59 - 6) = a2;
    *(&v59 - 5) = (uint64_t)a3;
    uint64_t v56 = v35;
    uint64_t v57 = v36;
    uint64_t v58 = v69;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v36,  (uint64_t)a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UTF8View: Collection);
    uint64_t v41 = v17;
    (*(void (**)(uint64_t (*)@<X0>(unsigned __int8 *@<X0>, uint64_t@<X1>, uint64_t@<X8>), uint64_t *, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 72LL))( partial apply for closure #1 in FixedWidthInteger.init<A>(_:radix:),  &v59 - 8,  v17,  AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v61 + 8))(v14, AssociatedTypeWitness);
    uint64_t v43 = (uint64_t)v67;
    uint64_t v42 = v68;
    uint64_t v44 = v38;
    unsigned __int8 v45 = v60;
    (*(void (**)(char *, uint64_t, swift *))(v68 + 32))(v67, v44, a3);
    uint64_t v47 = v63;
    uint64_t v46 = v64;
    (*(void (**)(char *, char *, uint64_t))(v63 + 32))(v45, v26, v64);
    uint64_t v48 = v66;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v66 + 48))(v45, 1LL, v41) == 1)
    {
      uint64_t v49 = v62;
      _parseInteger<A, B>(ascii:radix:)(v43, v69, a3, v34, (uint64_t)v73, v71, v62);
      (*(void (**)(uint64_t, swift *))(v42 + 8))(v43, a3);
      (*(void (**)(char *, uint64_t))(v47 + 8))(v45, v46);
      Swift::_Int128 v50 = *(void (**)(uint64_t, char *, uint64_t))(v48 + 32);
    }

    else
    {
      (*(void (**)(uint64_t, swift *))(v42 + 8))(v43, a3);
      Swift::_Int128 v50 = *(void (**)(uint64_t, char *, uint64_t))(v48 + 32);
      uint64_t v49 = v62;
      v50(v62, v45, v41);
    }

    uint64_t v51 = v65;
    v50(v65, (char *)v49, v41);
    uint64_t v52 = *(void *)(v34 - 8);
    if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v52 + 48))(v51, 1LL, v34) != 1)
    {
      uint64_t v54 = v70;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v52 + 32))(v70, v51, v34);
      uint64_t v53 = 0LL;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v52 + 56))(v54, v53, 1LL, v34);
    }

    (*(void (**)(uint64_t, uint64_t))(v48 + 8))(v51, v41);
  }

  uint64_t v53 = 1LL;
  uint64_t v54 = v70;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v52 + 56))(v54, v53, 1LL, v34);
}

uint64_t specialized closure #1 in _parseInteger<A, B>(ascii:radix:)@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  unint64_t v145 = a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a4, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v147 = (char *)&v138 - v12;
  uint64_t v148 = a5;
  uint64_t v150 = *(void *)(a5 + 8);
  uint64_t v13 = *(void *)(*(void *)(v150 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v15 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v151 = *(void *)(a4 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v138 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  MEMORY[0x1895F8858](v20);
  uint64_t v22 = MEMORY[0x1895F8858]((char *)&v138 - v21);
  uint64_t v24 = (char *)&v138 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v149 = (char *)&v138 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v146 = (char *)&v138 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v31 = (char *)&v138 - v30;
  uint64_t v32 = MEMORY[0x1895F8858](v29);
  uint64_t v34 = (char *)&v138 - v33;
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  uint64_t v40 = a2;
  uint64_t v42 = (char *)&v138 - v41;
  if (v40 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  int v43 = *a1;
  if (v43 == 43)
  {
    unint64_t v77 = v39;
    unint64_t v144 = v38;
    uint64_t v149 = v37;
    uint64_t v78 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, v40);
    uint64_t v82 = specialized UnsafeBufferPointer.init(rebasing:)(v78, v79, v80, v81);
    if (v83)
    {
      char v85 = (char *)v82;
      uint64_t v142 = v83;
      int v86 = a3 + 48;
      int v87 = a3 + 55;
      int v88 = a3 + 87;
      if (a3 <= 10) {
        int v88 = 97;
      }
      int v138 = v88;
      if (a3 <= 10) {
        int v87 = 65;
      }
      int v139 = v87;
      uint64_t v152 = a3;
      uint64_t v89 = v150;
      unint64_t v90 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v150 + 96);
      if (a3 > 10) {
        int v86 = 58;
      }
      int v141 = v86;
      unint64_t v91 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      unint64_t v143 = v90;
      v90(&v152, &type metadata for Int, v91, a4, v89);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
      uint64_t v93 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, uint64_t))(v13 + 24))(v77, a4, v13);
      if (!v85)
      {
LABEL_49:
        uint64_t v75 = v151;
        (*(void (**)(char *, uint64_t))(v151 + 8))(v149, a4);
        char v76 = v145;
        (*(void (**)(char *, char *, uint64_t))(v75 + 32))(v145, v19, a4);
        goto LABEL_50;
      }

      char v96 = v146;
      while (1)
      {
        unsigned int v97 = *v85;
        if (v97 < 0x30 || v97 >= v141)
        {
          if (v97 < 0x41 || v97 >= v139)
          {
            if (v97 < 0x61 || v97 >= v138)
            {
              uint64_t v134 = v151;
              Swift::String::Index v135 = *(void (**)(char *, uint64_t))(v151 + 8);
              v135(v19, a4);
              goto LABEL_81;
            }

            uint64_t v140 = v85;
            char v98 = v97 - 87;
          }

          else
          {
            uint64_t v140 = v85;
            char v98 = v97 - 55;
          }

          LOBYTE(v152) = v98;
        }

        else
        {
          uint64_t v140 = v85;
          LOBYTE(v152) = v97 - 48;
        }

        unint64_t v99 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v93, v94, v95);
        unint64_t v100 = v144;
        v143(&v152, &type metadata for UInt8, v99, a4, v150);
        uint64_t v101 = v148;
        char v102 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v148 + 96))(v96, v149, a4, v148);
        uint64_t v103 = v151;
        uint64_t v71 = *(void (**)(char *, uint64_t))(v151 + 8);
        v71(v19, a4);
        uint64_t v104 = *(void (**)(char *, char *, uint64_t))(v103 + 32);
        v104(v19, v96, a4);
        char v105 = (*(uint64_t (**)(char *, unsigned __int8 *, uint64_t, uint64_t))(v101 + 80))(v96, v100, a4, v101);
        v71((char *)v100, a4);
        v71(v19, a4);
        Swift::String::Index v106 = v147;
        v104(v147, v96, a4);
        uint64_t v93 = ((uint64_t (*)(char *, char *, uint64_t))v104)(v19, v106, a4);
        if ((v102 & 1) != 0 || (v105 & 1) != 0) {
          break;
        }
        char v85 = v140 + 1;
        if (!--v142) {
          goto LABEL_49;
        }
      }

      v71(v19, a4);
      Swift::String::Index v133 = v149;
LABEL_76:
      v71(v133, a4);
    }

uint64_t closure #1 in FixedWidthInteger.init<A>(_:radix:)@<X0>( unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  int v10 = *a1;
  if (v10 == 43)
  {
    uint64_t v18 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, a2);
    a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v18, v19, v20, v21);
    uint64_t v15 = a6;
LABEL_7:
    uint64_t v16 = a3;
    int v17 = 0;
    return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
  }

  if (v10 != 45)
  {
    uint64_t v15 = a6;
    goto LABEL_7;
  }

  uint64_t v11 = specialized Collection.subscript.getter(1LL, (uint64_t)a1, a2);
  a1 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v11, v12, v13, v14);
  uint64_t v15 = a6;
  uint64_t v16 = a3;
  int v17 = 1;
  return _parseIntegerDigits<A>(ascii:radix:isNegative:)(a1, a2, v16, v17, a4, a5, v15);
}

Swift::UInt16 __swiftcall _ascii16(_:)(Swift::Unicode::Scalar a1)
{
  if (a1._value >= 0x10000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  return a1._value;
}

BOOL static UInt32.>= infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a1 >= a2;
}

BOOL static UInt32.<= infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a2 >= a1;
}

uint64_t _asciiDigit<A, B>(codeUnit:radix:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v55 = a2;
  uint64_t v56 = a7;
  int v53 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v53,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v52 = (char *)&v52 - v14;
  uint64_t v15 = *(void *)(a4 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  int v54 = (char *)&v52 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v52 - v19;
  uint64_t v21 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v23, a1, a3);
  __int16 v24 = (*(uint64_t (**)(uint64_t))(*(void *)(a5 + 8) + 120LL))(a3);
  (*(void (**)(char *, uint64_t))(v21 + 8))(v23, a3);
  if ((unsigned __int16)(v24 - 58) > 0xFFF5u)
  {
    __int16 v26 = -48;
LABEL_7:
    uint64_t v25 = v15;
    goto LABEL_8;
  }

  if ((unsigned __int16)(v24 - 91) > 0xFFE5u)
  {
    __int16 v26 = -55;
    goto LABEL_7;
  }

  uint64_t v25 = v15;
  __int16 v26 = -87;
LABEL_8:
  unsigned __int16 v27 = v26 + v24;
  char v28 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 64))(a4, a6);
  uint64_t v29 = v55;
  uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6);
  if ((v28 & 1) != 0)
  {
    if (v30 >= 17)
    {
      unsigned __int16 v57 = v27;
      uint64_t v33 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      unint64_t v34 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v30, v31, v32);
      uint64_t v35 = (__int16 *)&v57;
      goto LABEL_13;
    }

    uint64_t v40 = v53;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v53,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v42 = v52;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*((void (**)(char *, uint64_t, const char *))v40 + 3))(v42, a4, v40);
    char v43 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 40LL))( v29,  v20,  a4);
    uint64_t v44 = *(void (**)(char *, uint64_t))(v25 + 8);
    v44(v20, a4);
    uint64_t v45 = v54;
    (*(void (**)(char *, uint64_t, uint64_t))(v25 + 16))(v54, v29, a4);
    if ((v43 & 1) == 0)
    {
      v44(v45, a4);
      goto LABEL_21;
    }

    unsigned __int16 v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    uint64_t v37 = ((uint64_t (*)(char *, uint64_t))v44)(v45, a4);
    goto LABEL_18;
  }

  if (v30 <= 16)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v25 + 16))(v20, v29, a4);
    unsigned __int16 v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    uint64_t v37 = (*(uint64_t (**)(char *, uint64_t))(v25 + 8))(v20, a4);
LABEL_18:
LABEL_21:
    uint64_t v50 = 1LL;
    uint64_t v49 = v56;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 56))(v49, v50, 1LL, a4);
  }

  unsigned __int16 v58 = v27;
  uint64_t v33 = *(void (**)(__int16 *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  unint64_t v34 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v30, v31, v32);
  uint64_t v35 = (__int16 *)&v58;
LABEL_13:
  v33(v35, &type metadata for UInt16, v34, a4, a6);
  char v36 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v20,  v29,  a4);
  uint64_t v37 = (*(uint64_t (**)(char *, uint64_t))(v25 + 8))(v20, a4);
  if ((v36 & 1) == 0) {
    goto LABEL_21;
  }
LABEL_19:
  unsigned __int16 v59 = v27;
  uint64_t v47 = *(void (**)(unsigned __int16 *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  unint64_t v48 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v37, v38, v39);
  uint64_t v49 = v56;
  v47(&v59, &type metadata for UInt16, v48, a4, a6);
  uint64_t v50 = 0LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 56))(v49, v50, 1LL, a4);
}

uint64_t UInt16.init(_builtinIntegerLiteral:)(unsigned __int16 *a1, unint64_t a2)
{
  if (a2 >> 9 <= 8 && (a2 & 1) == 0) {
    return *a1;
  }
  else {
    return 0LL;
  }
}

uint64_t _parseUnsignedASCII<A, B>(first:rest:radix:positive:)@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X7>, char *a9@<X8>, uint64_t a10)
{
  int v119 = a4;
  uint64_t v115 = a2;
  id v124 = a9;
  uint64_t v125 = a1;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a6, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  Swift::String::Index v106 = (char *)&v93 - v16;
  uint64_t v116 = a5;
  unint64_t v117 = a7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a7,  a5,  (uint64_t)&protocol requirements base descriptor for IteratorProtocol,  associated type descriptor for IteratorProtocol.Element);
  uint64_t v103 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v18, v19);
  uint64_t v102 = *(void *)(v103 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v103);
  unint64_t v114 = (char *)&v93 - v21;
  uint64_t v113 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](v20);
  uint64_t v109 = (char *)&v93 - v22;
  uint64_t v112 = a8;
  uint64_t v23 = *(void *)(a8 + 8);
  uint64_t v101 = *(const char **)(*(void *)(v23 + 24) + 16LL);
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  v101,  a6,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  uint64_t v100 = (uint64_t)&v93 - v26;
  unsigned __int16 v27 = *(void **)(a6 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v120 = (char *)&v93 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  char v105 = (char *)&v93 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v104 = (char *)&v93 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  int v111 = (char *)&v93 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v99 = (char *)&v93 - v37;
  MEMORY[0x1895F8858](v36);
  unint64_t v123 = (char *)&v93 - v38;
  uint64_t v41 = type metadata accessor for Optional(0LL, a6, v39, v40);
  uint64_t v42 = *(void *)(v41 - 8);
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  Swift::Int v107 = (char *)&v93 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v121 = (uint64_t)&v93 - v46;
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  uint64_t v49 = (char *)&v93 - v48;
  MEMORY[0x1895F8858](v47);
  uint64_t v122 = a3;
  unint64_t v118 = AssociatedTypeWitness;
  uint64_t v50 = AssociatedTypeWitness;
  int v52 = (char *)&v93 - v51;
  uint64_t v110 = a10;
  uint64_t v108 = v23;
  _asciiDigit<A, B>(codeUnit:radix:)((uint64_t)v125, a3, v50, a6, a10, v23, (uint64_t)&v93 - v51);
  uint64_t v125 = v27;
  int v53 = (unsigned int (*)(char *, uint64_t, uint64_t))v27[6];
  if (v53(v52, 1LL, a6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v42 + 8))(v52, v41);
LABEL_21:
    uint64_t v89 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v125[7];
    return v89((uint64_t)v124, 1LL, 1LL, a6);
  }

  int v54 = *(void (**)(char *, char *, uint64_t))(v42 + 16);
  v54(v49, v52, v41);
  if (v53(v49, 1LL, a6) == 1)
  {
    uint64_t v55 = *(void (**)(char *, uint64_t))(v42 + 8);
    v55(v52, v41);
    v55(v49, v41);
    goto LABEL_21;
  }

  char v96 = (void (*)(char *, uint64_t, uint64_t))v54;
  uint64_t v56 = v123;
  char v98 = (void (*)(char *, char *, uint64_t))v125[4];
  v98(v123, v49, a6);
  uint64_t v57 = v118;
  uint64_t v97 = v41;
  if ((v119 & 1) == 0)
  {
    unsigned __int16 v58 = v101;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v101,  a6,  v24,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v60 = (char *)v100;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v24,  AssociatedConformanceWitness);
    uint64_t v61 = v111;
    (*((void (**)(char *, uint64_t, const char *))v58 + 3))(v60, a6, v58);
    uint64_t v62 = v99;
    char v63 = (*(uint64_t (**)(char *, char *, uint64_t))(v112 + 88))(v99, v56, a6);
    unsigned int v64 = (void (*)(char *, uint64_t))v125[1];
    v64(v61, a6);
    v64(v56, a6);
    if ((v63 & 1) != 0)
    {
      v64(v62, a6);
      (*(void (**)(char *, uint64_t))(v42 + 8))(v52, v97);
      goto LABEL_21;
    }

    v98(v56, v62, a6);
    uint64_t v41 = v97;
  }

  char v65 = (char *)*((void *)v117 + 2);
  unint64_t v66 = v114;
  ((void (*)(uint64_t))v65)(v116);
  uint64_t v67 = v113;
  uint64_t v101 = *(const char **)(v113 + 48);
  if (((unsigned int (*)(char *, uint64_t, uint64_t))v101)(v66, 1LL, v57) != 1)
  {
    unint64_t v99 = v65;
    uint64_t v71 = *(void (**)(void, void, void))(v67 + 32);
    uint64_t v72 = 10LL;
    if ((v119 & 1) == 0) {
      uint64_t v72 = 11LL;
    }
    uint64_t v100 = v72;
    uint64_t v95 = v42;
    uint64_t v94 = v71;
    while (1)
    {
      uint64_t v73 = (uint64_t)v109;
      v71(v109, v66, v57);
      uint64_t v74 = v121;
      _asciiDigit<A, B>(codeUnit:radix:)(v73, v122, v57, a6, v110, v108, v121);
      (*(void (**)(uint64_t, uint64_t))(v67 + 8))(v73, v57);
      if (v53((char *)v74, 1LL, a6) == 1)
      {
        unint64_t v90 = v125;
        ((void (*)(char *, uint64_t))v125[1])(v123, a6);
        unint64_t v91 = *(void (**)(uint64_t, uint64_t))(v42 + 8);
        v91(v74, v41);
        uint64_t v92 = v52;
        goto LABEL_25;
      }

      uint64_t v75 = v107;
      v96(v107, v74, v41);
      unsigned int v76 = v53(v75, 1LL, a6);
      unint64_t v77 = v123;
      if (v76 == 1) {
        break;
      }
      uint64_t v78 = v104;
      uint64_t v79 = v98;
      v98(v104, v75, a6);
      uint64_t v80 = v112;
      uint64_t v81 = v105;
      int v119 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v112 + 96))(v105, v122, a6, v112);
      uint64_t v82 = (void (*)(char *, uint64_t))v125[1];
      v82(v77, a6);
      uint64_t v83 = v111;
      char v84 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v80 + 8 * v100))(v111, v78, a6, v80);
      v82(v81, a6);
      char v85 = v78;
      uint64_t v42 = v95;
      v82(v85, a6);
      int v86 = v106;
      v79(v106, v83, a6);
      int v87 = v86;
      uint64_t v41 = v97;
      v79(v120, v87, a6);
      uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v42 + 8);
      v68(v121, v41);
      if ((v119 & 1) != 0 || (v84 & 1) != 0)
      {
        v82(v120, a6);
        v68((uint64_t)v52, v41);
        goto LABEL_21;
      }

      uint64_t v56 = v123;
      v98(v123, v120, a6);
      unint64_t v66 = v114;
      ((void (*)(uint64_t, const char *))v99)(v116, v117);
      uint64_t v57 = v118;
      int v88 = ((uint64_t (*)(char *, uint64_t, unint64_t))v101)(v66, 1LL, v118);
      uint64_t v67 = v113;
      uint64_t v71 = v94;
      if (v88 == 1) {
        goto LABEL_10;
      }
    }

    unint64_t v90 = v125;
    ((void (*)(char *, uint64_t))v125[1])(v123, a6);
    unint64_t v91 = *(void (**)(uint64_t, uint64_t))(v42 + 8);
    v91(v74, v41);
    v91((uint64_t)v52, v41);
    uint64_t v92 = v75;
LABEL_25:
    v91((uint64_t)v92, v41);
    uint64_t v89 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v90[7];
    return v89((uint64_t)v124, 1LL, 1LL, a6);
  }

  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v42 + 8);
LABEL_10:
  v68((uint64_t)v52, v41);
  (*(void (**)(char *, uint64_t))(v102 + 8))(v66, v103);
  char v69 = v124;
  v98(v124, v56, a6);
  return ((uint64_t (*)(char *, void, uint64_t, uint64_t))v125[7])(v69, 0LL, 1LL, a6);
}

uint64_t _parseASCII<A, B>(codeUnits:radix:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, char *a8@<X8>)
{
  uint64_t v189 = a2;
  uint64_t v190 = a6;
  unint64_t v197 = a8;
  uint64_t v198 = a4;
  uint64_t v188 = a7;
  uint64_t v196 = *(void *)(a7 + 8);
  uint64_t v11 = *(const char **)(*(void *)(v196 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for IteratorProtocol,  associated type descriptor for IteratorProtocol.Element);
  unint64_t v184 = v11;
  unint64_t v183 = swift_getAssociatedTypeWitness( 0LL,  v11,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v183);
  unint64_t v182 = (char *)&v169 - v13;
  uint64_t v14 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v15 = *(v14 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v179 = (char *)&v169 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v185 = (char *)&v169 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  char v180 = (char *)&v169 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v181 = (char *)&v169 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::String::Index v194 = (char *)&v169 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  Swift::String::Index v193 = (char *)&v169 - v27;
  MEMORY[0x1895F8858](v26);
  unint64_t v195 = (uint64_t *)((char *)&v169 - v28);
  uint64_t v31 = type metadata accessor for Optional(0LL, (uint64_t)v14, v29, v30);
  uint64_t v32 = *(void *)(v31 - 8);
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v187 = (char *)&v169 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  Swift::String::Index v192 = (char *)&v169 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v39 = (char *)&v169 - v38;
  MEMORY[0x1895F8858](v37);
  uint64_t v40 = *(void (**)(uint64_t, const char *))(a5 + 16);
  uint64_t v41 = a1;
  uint64_t v42 = a3;
  uint64_t v43 = a3;
  uint64_t v45 = (char *)&v169 - v44;
  Swift::String::Index v191 = (const char *)a5;
  char v186 = v40;
  v40(v43, (const char *)a5);
  uint64_t v46 = *(unsigned int (**)(char *, uint64_t, unint64_t *))(v15 + 48);
  if (v46(v45, 1LL, v14) == 1)
  {
    (*(void (**)(char *, uint64_t))(v32 + 8))(v45, v31);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v198 - 8) + 56LL))(v197, 1LL, 1LL);
  }

  uint64_t v47 = *(void (**)(char *, char *, uint64_t))(v32 + 16);
  v47(v39, v45, v31);
  if (v46(v39, 1LL, v14) == 1)
  {
    uint64_t v48 = *(void (**)(char *, uint64_t))(v32 + 8);
    v48(v45, v31);
    v48(v39, v31);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v198 - 8) + 56LL))(v197, 1LL, 1LL);
  }

  unint64_t v170 = v47;
  unint64_t v172 = (unsigned int (*)(char *, uint64_t, uint64_t))v46;
  uint64_t v175 = v32;
  uint64_t v177 = v31;
  uint64_t v50 = v195;
  unint64_t v171 = *(void (**)(char *, char *, unint64_t *))(v15 + 32);
  v171((char *)v195, v39, v14);
  uint64_t v51 = v196;
  int v52 = *(uint64_t (**)(unint64_t *, uint64_t))(v196 + 64);
  char v53 = v52(v14, v196);
  uint64_t v54 = (uint64_t)v14;
  unint64_t v174 = (uint64_t (*)(uint64_t, uint64_t))v52;
  unint64_t v176 = v45;
  uint64_t v178 = v41;
  if ((v53 & 1) == 0)
  {
    unint64_t v173 = *(uint64_t (**)(unint64_t *, uint64_t))(v51 + 128);
    uint64_t v71 = v173(v14, v51);
    uint64_t v74 = v50;
    uint64_t v59 = v42;
    if (v71 >= 16)
    {
      v199[0] = 43;
      int v87 = *(void (**)(_WORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v196 + 96);
      unint64_t v88 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v71, v72, v73);
      unsigned int v76 = v193;
      v87(v199, &type metadata for UInt16, v88, v14, v196);
      uint64_t v65 = v196;
      char v68 = (*(uint64_t (**)(void *, char *, unint64_t *))(*(void *)(*(void *)(v196 + 16) + 8LL)
                                                                            + 8LL))( v74,  v76,  v14);
      char v69 = *(void (**)(char *, uint64_t))(v15 + 8);
      v69(v76, v54);
      uint64_t v60 = v194;
      (*(void (**)(char *, void *, uint64_t))(v15 + 16))(v194, v74, v54);
      goto LABEL_22;
    }

    uint64_t v75 = *(void (**)(char *, void *, unint64_t *))(v15 + 16);
    unsigned int v76 = v193;
    v75(v193, v74, v14);
    __int16 v77 = (*(uint64_t (**)(unint64_t *, uint64_t))(v196 + 120))(v14, v196);
    char v69 = *(void (**)(char *, uint64_t))(v15 + 8);
    v69(v76, v54);
    uint64_t v60 = v194;
    v75(v194, v74, (unint64_t *)v54);
    uint64_t v65 = v196;
    uint64_t v78 = v197;
    uint64_t v79 = v59;
    if (v77 != 43LL) {
      goto LABEL_35;
    }
    goto LABEL_23;
  }

  char v55 = v52(v14, v51);
  unint64_t v173 = *(uint64_t (**)(unint64_t *, uint64_t))(v51 + 128);
  uint64_t v56 = v173(v14, v51);
  uint64_t v59 = v42;
  if ((v55 & 1) == 0)
  {
    if (v56 >= 16)
    {
      v199[0] = 43;
      uint64_t v98 = v196;
      unint64_t v99 = *(void (**)(_WORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v196 + 96);
      unint64_t v100 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v56, v57, v58);
      unsigned int v64 = v193;
      v99(v199, &type metadata for UInt16, v100, v14, v98);
      uint64_t v65 = v98;
      uint64_t v67 = v195;
      char v68 = v101(v195, v64, v14);
      char v69 = *(void (**)(char *, uint64_t))(v15 + 8);
      v69(v64, v54);
      uint64_t v70 = *(void (**)(char *, void *, uint64_t))(v15 + 16);
      uint64_t v60 = v194;
      goto LABEL_21;
    }

    uint64_t v80 = *(void (**)(char *, void *, unint64_t *))(v15 + 16);
    uint64_t v81 = v193;
    uint64_t v82 = v195;
    v80(v193, v195, v14);
    uint64_t v83 = v196;
    uint64_t v84 = v59;
    __int16 v85 = (*(uint64_t (**)(unint64_t *, uint64_t))(v196 + 120))(v14, v196);
    char v69 = *(void (**)(char *, uint64_t))(v15 + 8);
    v69(v81, v54);
    uint64_t v86 = v84;
    uint64_t v60 = v194;
    v80(v194, v82, (unint64_t *)v54);
    uint64_t v79 = v86;
    uint64_t v65 = v83;
    unsigned int v76 = v81;
    uint64_t v78 = v197;
    if (v85 != 43LL) {
      goto LABEL_35;
    }
LABEL_23:
    v69(v60, v54);
    uint64_t v103 = v191;
    goto LABEL_24;
  }

  uint64_t v60 = v194;
  if (v56 > 16)
  {
    v199[0] = 43;
    uint64_t v61 = v196;
    uint64_t v62 = *(void (**)(_WORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v196 + 96);
    unint64_t v63 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v56, v57, v58);
    unsigned int v64 = v193;
    v62(v199, &type metadata for UInt16, v63, v14, v61);
    uint64_t v65 = v61;
    unint64_t v66 = *(uint64_t (**)(void *, char *, unint64_t *))(*(void *)(*(void *)(v61 + 16) + 8LL) + 8LL);
    uint64_t v67 = v195;
    char v68 = v66(v195, v64, v14);
    char v69 = *(void (**)(char *, uint64_t))(v15 + 8);
    v69(v64, v54);
    uint64_t v70 = *(void (**)(char *, void *, uint64_t))(v15 + 16);
LABEL_21:
    uint64_t v102 = v67;
    unsigned int v76 = v64;
    v70(v60, v102, v54);
LABEL_22:
    uint64_t v78 = v197;
    uint64_t v79 = v59;
    if ((v68 & 1) != 0) {
      goto LABEL_23;
    }
    goto LABEL_35;
  }

  unint64_t v90 = v183;
  uint64_t v89 = (uint64_t)v184;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v184,  (uint64_t)v14,  v183,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v92 = v182;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v90,  AssociatedConformanceWitness);
  uint64_t v93 = v193;
  (*(void (**)(char *, unint64_t *, uint64_t))(v89 + 24))(v92, v14, v89);
  uint64_t v94 = v195;
  uint64_t v65 = v196;
  LOBYTE(v90) = (*(uint64_t (**)(void *, char *, unint64_t *))(*(void *)(*(void *)(v196 + 32)
                                                                                            + 8LL)
                                                                                + 32LL))( v195,  v93,  v14);
  char v69 = *(void (**)(char *, uint64_t))(v15 + 8);
  v69(v93, v54);
  uint64_t v95 = *(void (**)(char *, void *, uint64_t))(v15 + 16);
  char v96 = v181;
  v95(v181, v94, v54);
  uint64_t v79 = v59;
  if ((v90 & 1) == 0)
  {
    v69(v96, v54);
    v95(v60, v94, v54);
    uint64_t v78 = v197;
    unsigned int v76 = v193;
    goto LABEL_35;
  }

  __int16 v97 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 120))(v54, v65);
  v69(v96, v54);
  v95(v60, v94, v54);
  uint64_t v78 = v197;
  unsigned int v76 = v193;
  if (v97 == 43LL) {
    goto LABEL_23;
  }
LABEL_35:
  unint64_t v123 = v174;
  if ((v174(v54, v65) & 1) == 0)
  {
    char v127 = v194;
    uint64_t v128 = v173((unint64_t *)v54, v65);
    if (v128 >= 16)
    {
      v199[0] = 45;
      goto LABEL_49;
    }

    v171(v76, v127, (unint64_t *)v54);
    goto LABEL_44;
  }

  char v124 = v123(v54, v65);
  uint64_t v125 = v65;
  char v126 = v124;
  char v127 = v194;
  uint64_t v128 = v173((unint64_t *)v54, v125);
  if ((v126 & 1) == 0)
  {
    if (v128 >= 16) {
      goto LABEL_48;
    }
    v171(v76, v127, (unint64_t *)v54);
    uint64_t v65 = v196;
LABEL_44:
    __int16 v136 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 120))(v54, v65);
    unint64_t v137 = v193;
    goto LABEL_45;
  }

  if (v128 > 16)
  {
LABEL_48:
    v199[0] = 45;
    uint64_t v65 = v196;
LABEL_49:
    int v138 = *(void (**)(_WORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v65 + 96);
    unint64_t v139 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v128, v129, v130);
    v138(v199, &type metadata for UInt16, v139, v54, v65);
    char v140 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v65 + 16) + 8LL) + 8LL))( v127,  v76,  v54);
    v69(v76, v54);
    v69(v127, v54);
    uint64_t v103 = v191;
    if ((v140 & 1) != 0) {
      goto LABEL_24;
    }
LABEL_50:
    int v141 = (char *)v195;
    _parseUnsignedASCII<A, B>(first:rest:radix:positive:)(v195, v178, v189, 1, v79, v198, v103, v190, v78, v188);
    v69(v141, v54);
    return (*(uint64_t (**)(char *, uint64_t))(v175 + 8))(v176, v177);
  }

  unint64_t v131 = v183;
  uint64_t v132 = (uint64_t)v184;
  unint64_t v133 = swift_getAssociatedConformanceWitness( (uint64_t)v184,  v54,  v183,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v134 = v182;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v133 + 8))( &unk_18180BE68,  256LL,  v131,  v133);
  (*(void (**)(char *, uint64_t, uint64_t))(v132 + 24))(v134, v54, v132);
  uint64_t v65 = v196;
  LOBYTE(v131) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v196 + 32) + 8LL) + 32LL))( v127,  v76,  v54);
  v69(v76, v54);
  Swift::String::Index v135 = v180;
  v171(v180, v127, (unint64_t *)v54);
  if ((v131 & 1) == 0)
  {
    v69(v135, v54);
    uint64_t v103 = v191;
    goto LABEL_50;
  }

  __int16 v136 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 120))(v54, v65);
  unint64_t v137 = v135;
LABEL_45:
  v69(v137, v54);
  uint64_t v103 = v191;
  if (v136 != 45LL) {
    goto LABEL_50;
  }
LABEL_24:
  uint64_t v104 = v192;
  v186(v79, v103);
  char v105 = v172;
  unsigned int v106 = v172(v104, 1LL, v54);
  Swift::Int v107 = v187;
  if (v106 == 1)
  {
    v69((char *)v195, v54);
    uint64_t v108 = *(void (**)(char *, uint64_t))(v175 + 8);
    uint64_t v109 = v177;
    v108(v192, v177);
    uint64_t v110 = v176;
LABEL_28:
    v108(v110, v109);
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v198 - 8) + 56LL))(v78, 1LL, 1LL);
  }

  uint64_t v109 = v177;
  v170(v187, v192, v177);
  if (v105(v107, 1LL, v54) == 1)
  {
    v69((char *)v195, v54);
    int v111 = v107;
    uint64_t v108 = *(void (**)(char *, uint64_t))(v175 + 8);
    v108(v192, v109);
    v108(v176, v109);
    uint64_t v110 = v111;
    goto LABEL_28;
  }

  v171(v185, v107, (unint64_t *)v54);
  uint64_t v112 = v174;
  if ((v174(v54, v65) & 1) == 0)
  {
    uint64_t v142 = (char *)v195;
    uint64_t v143 = v173((unint64_t *)v54, v65);
    if (v143 >= 16)
    {
      v199[0] = 45;
      uint64_t v150 = *(void (**)(_WORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v65 + 96);
      unint64_t v151 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v143, v144, v145);
      unint64_t v197 = (char *)v79;
      uint64_t v152 = v193;
      v150(v199, &type metadata for UInt16, v151, v54, v65);
      char v153 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v65 + 16) + 8LL) + 8LL))( v142,  v152,  v54);
      uint64_t v79 = (uint64_t)v197;
      v69(v152, v54);
      v69(v142, v54);
      uint64_t v122 = v177;
      if ((v153 & 1) == 0) {
        goto LABEL_67;
      }
      goto LABEL_64;
    }

    unint64_t v146 = v193;
    unint64_t v147 = v193;
    uint64_t v148 = v142;
    goto LABEL_56;
  }

  char v113 = v112(v54, v65);
  uint64_t v114 = v173((unint64_t *)v54, v65);
  if ((v113 & 1) == 0)
  {
    if (v114 >= 16)
    {
      v199[0] = 45;
      unint64_t v162 = *(void (**)(_WORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v65 + 96);
      unint64_t v163 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v114, v115, v116);
      unint64_t v197 = (char *)v79;
      unint64_t v164 = v193;
      v162(v199, &type metadata for UInt16, v163, v54, v65);
      Swift::String::Index v165 = *(uint64_t (**)(void *, char *, uint64_t))(*(void *)(*(void *)(v65 + 16) + 8LL) + 8LL);
      Swift::String::Index v166 = (char *)v195;
      LOBYTE(v162) = v165(v195, v164, v54);
      uint64_t v79 = (uint64_t)v197;
      v69(v164, v54);
      v69(v166, v54);
      uint64_t v122 = v177;
      goto LABEL_67;
    }

    unint64_t v146 = v193;
    unint64_t v147 = v193;
    uint64_t v148 = (char *)v195;
LABEL_56:
    v171(v147, v148, (unint64_t *)v54);
    __int16 v149 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 120))(v54, v65);
    v69(v146, v54);
    uint64_t v122 = v177;
    if (v149 != 45LL) {
      goto LABEL_67;
    }
    goto LABEL_64;
  }

  unint64_t v197 = (char *)v79;
  if (v114 <= 16)
  {
    unint64_t v155 = v183;
    uint64_t v154 = (uint64_t)v184;
    unint64_t v156 = swift_getAssociatedConformanceWitness( (uint64_t)v184,  v54,  v183,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    int v157 = v182;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v156 + 8))( &unk_18180BE68,  256LL,  v155,  v156);
    unint64_t v158 = v193;
    (*(void (**)(char *, uint64_t, uint64_t))(v154 + 24))(v157, v54, v154);
    uint64_t v159 = (char *)v195;
    LOBYTE(v155) = (*(uint64_t (**)(void *, char *, uint64_t))(*(void *)(*(void *)(v65 + 32) + 8LL) + 32LL))( v195,  v158,  v54);
    v69(v158, v54);
    uint64_t v160 = v179;
    v171(v179, v159, (unint64_t *)v54);
    if ((v155 & 1) != 0)
    {
      __int16 v161 = (*(uint64_t (**)(uint64_t, uint64_t))(v65 + 120))(v54, v65);
      v69(v160, v54);
      uint64_t v122 = v177;
      uint64_t v79 = (uint64_t)v197;
      if (v161 != 45LL) {
        goto LABEL_67;
      }
      goto LABEL_64;
    }

    v69(v160, v54);
    uint64_t v122 = v177;
    uint64_t v79 = (uint64_t)v197;
LABEL_67:
    Swift::String::Index v167 = v185;
    _parseUnsignedASCII<A, B>(first:rest:radix:positive:)(v185, v178, v189, 1, v79, v198, v103, v190, v78, v188);
    goto LABEL_65;
  }

  v199[0] = 45;
  unint64_t v117 = *(void (**)(_WORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v65 + 96);
  unint64_t v118 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v114, v115, v116);
  int v119 = v193;
  v117(v199, &type metadata for UInt16, v118, v54, v65);
  uint64_t v120 = *(uint64_t (**)(void *, char *, uint64_t))(*(void *)(*(void *)(v65 + 16) + 8LL) + 8LL);
  uint64_t v121 = (char *)v195;
  LOBYTE(v117) = v120(v195, v119, v54);
  v69(v119, v54);
  v69(v121, v54);
  uint64_t v122 = v177;
  uint64_t v79 = (uint64_t)v197;
LABEL_64:
  Swift::String::Index v167 = v185;
  _parseUnsignedASCII<A, B>(first:rest:radix:positive:)(v185, v178, v189, 0, v79, v198, v103, v190, v78, v188);
LABEL_65:
  v69(v167, v54);
  Swift::String::Index v168 = *(void (**)(char *, uint64_t))(v175 + 8);
  v168(v192, v122);
  return ((uint64_t (*)(char *, uint64_t))v168)(v176, v122);
}

uint64_t static FixedWidthInteger._parseASCIISlowPath<A, B>(codeUnits:radix:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X6>, uint64_t a6@<X7>, char *a7@<X8>, uint64_t a8)
{
  return _parseASCII<A, B>(codeUnits:radix:)(a1, a2, a3, a4, a5, a6, a8, a7);
}

uint64_t ExpressibleByIntegerLiteral<>.init(integerLiteral:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a3, a1);
}

uint64_t static AdditiveArithmetic.+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(v9 + 24))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

uint64_t static AdditiveArithmetic.-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(v9 + 40))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

uint64_t static AdditiveArithmetic<>.zero.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v7 = (char *)&v10 - v6;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(a3 + 24))(v7, a1, a3);
}

Swift::Void __swiftcall SignedNumeric.negate()()
{
  uint64_t v3 = v0;
  uint64_t v4 = v2;
  uint64_t v5 = *(void *)(v1 + 8);
  uint64_t v6 = *(void *)(v5 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v0,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v19 - v9;
  uint64_t v11 = *(void *)(v3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v8);
  uint64_t v14 = (char *)&v19 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v19 - v15;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v10, v3, v6);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v5 + 8) + 40LL))(v14, v2, v3);
  uint64_t v18 = *(void (**)(uint64_t, uint64_t))(v11 + 8);
  v18(v4, v3);
  v18((uint64_t)v14, v3);
  (*(void (**)(uint64_t, char *, uint64_t))(v11 + 32))(v4, v16, v3);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  unint64_t AssociatedConformanceWitness;
  void (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  uint64_t v3 = v2;
  uint64_t v4 = v0;
  uint64_t v5 = *(void *)(v1 + 8);
  uint64_t v6 = *(void *)(v5 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v0,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v19 - v9;
  uint64_t v11 = *(void *)(v4 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v8);
  uint64_t v14 = (char *)&v19 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v19 - v15;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v10, v4, v6);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v5 + 8) + 40LL))(v14, v2, v4);
  uint64_t v18 = *(void (**)(uint64_t, uint64_t))(v11 + 8);
  v18(v3, v4);
  v18((uint64_t)v14, v4);
  (*(void (**)(uint64_t, char *, uint64_t))(v11 + 32))(v3, v16, v4);
}

uint64_t static AdditiveArithmetic.+ prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a3, a1);
}

uint64_t BinaryInteger._lowWord.getter(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)
                                         + 8)
                             + 8LL)
                 + 8LL);
  unint64_t v6 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](v6);
  uint64_t v9 = (char *)&v12 - v8;
  (*(void (**)(uint64_t, uint64_t))(a2 + 112))(a1, a2);
  (*(void (**)(unint64_t, uint64_t))(v5 + 32))(AssociatedTypeWitness, v5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  AssociatedTypeWitness,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( &v12,  v6,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t))(v7 + 8))(v9, v6);
  if (v13) {
    return 0LL;
  }
  else {
    return v12;
  }
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t AssociatedConformanceWitness;
  uint64_t v12;
  char v13;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)
                                         + 8)
                             + 8LL)
                 + 8LL);
  unint64_t v6 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1895F8858](v6);
  uint64_t v9 = (char *)&v12 - v8;
  (*(void (**)(uint64_t, uint64_t))(a2 + 112))(a1, a2);
  (*(void (**)(unint64_t, uint64_t))(v5 + 32))(AssociatedTypeWitness, v5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  AssociatedTypeWitness,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( &v12,  v6,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t))(v7 + 8))(v9, v6);
  if (v13) {
    return 0LL;
  }
  else {
    return v12;
  }
}

Swift::Int __swiftcall BinaryInteger._binaryLogarithm()()
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = v0;
  uint64_t v6 = *(void *)(v1[3] + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v0,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v34 - v9;
  uint64_t v11 = *(void *)(v5 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v8);
  uint64_t v14 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v34 - v15;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))((char *)&v34 - v15, v2, v5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v10, v5, v6);
  char v18 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v4[4] + 8LL) + 40LL))(v16, v14, v5);
  uint64_t v19 = *(void (**)(char *, uint64_t))(v11 + 8);
  v19(v14, v5);
  if ((v18 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x4F7uLL,  0);
  }
  v19(v16, v5);
  uint64_t v20 = (uint64_t (*)(uint64_t, void *))v4[16];
  uint64_t v21 = v20(v5, v4);
  uint64_t v22 = v21 + 62;
  if (v21 - 1 >= 0) {
    uint64_t v22 = v21 - 1;
  }
  uint64_t v23 = v22 >> 6;
  unint64_t v34 = v22 & 0xFFFFFFFFFFFFFFC0LL;
  uint64_t v35 = (void (*)(char *, uint64_t))(v21 - 1);
  unint64_t v24 = v21 - 1 - (v22 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v25 = v20(v5, v4);
  unint64_t v37 = ~v24 + v25;
  uint64_t v26 = (void (*)(uint64_t, unint64_t *, ValueMetadata *, unint64_t, uint64_t, void *))v4[30];
  unint64_t v29 = lazy protocol witness table accessor for type Int and conformance Int(v25, v27, v28);
  v26(v3, &v37, &type metadata for Int, v29, v5, v4);
  uint64_t v36 = (uint64_t (*)(uint64_t, void *))v4[15];
  unint64_t v30 = v36(v5, v4);
  v19(v14, v5);
  if (!v30)
  {
    unint64_t v31 = v34 - (void)v35;
    uint64_t v35 = v19;
    unint64_t v32 = v31 - 65;
    do
    {
      --v23;
      unint64_t v37 = v20(v5, v4) + v32;
      v26(v3, &v37, &type metadata for Int, v29, v5, v4);
      unint64_t v30 = v36(v5, v4);
      v35(v14, v5);
      v32 -= 64LL;
    }

    while (!v30);
  }

  return ((v23 << 6) | 0x3F) - __clz(v30);
}

uint64_t static BinaryInteger.& infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 200))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 200))(a5, a2, a3, a4);
}

uint64_t static BinaryInteger.| infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 216))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 216))(a5, a2, a3, a4);
}

uint64_t static BinaryInteger.^ infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 232))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 232))(a5, a2, a3, a4);
}

uint64_t static BinaryInteger.>> infix<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 248))( a7,  a2,  a3,  a4,  a5,  a6);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a7, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 248))( a7,  a2,  a4,  a6,  a3,  a5);
}

uint64_t static BinaryInteger.<< infix<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 264))( a7,  a2,  a3,  a4,  a5,  a6);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a7, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 264))( a7,  a2,  a4,  a6,  a3,  a5);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)( _OWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  uint64_t result = __udivti3();
  *a1 = __PAIR128__(a5, a4) - __PAIR128__(v11, result) * __PAIR128__(a3, a2);
  return result;
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(int *a1, int a2, int a3)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FCAuLL,  0);
  }
  if (a2 == -1 && a3 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1FD1uLL,  0);
  }
  *a1 = a3 % a2;
  return (a3 / a2);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(_WORD *a1, __int16 a2, __int16 a3)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13C4uLL,  0);
  }
  if (a2 == -1 && (unsigned __int16)a3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x13CBuLL,  0);
  }
  *a1 = a3 % a2;
  return (a3 / a2);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)( unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!(a2 | a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/Int128.swift",  18LL,  2,  0x126uLL,  0);
  }
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || (unint64_t v10 = a4 | a5 ^ 0x8000000000000000LL) != 0)
  {
    uint64_t result = __divti3();
    unint64_t v12 = (__PAIR128__(a5, a4) - __PAIR128__(v13, result) * __PAIR128__(a3, a2)) >> 64;
    unint64_t v10 = a4 - result * a2;
  }

  else
  {
    uint64_t result = 0LL;
    unint64_t v12 = 0LL;
  }

  *a1 = v10;
  a1[1] = v12;
  return result;
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)(_BYTE *a1, char a2, char a3)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7C3uLL,  0);
  }
  if (a2 == -1 && a3 == 128) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x7CAuLL,  0);
  }
  *a1 = a3 % a2;
  return (a3 / a2);
}

uint64_t specialized BinaryInteger.quotientAndRemainder(dividingBy:)( uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a4,  0);
  }
  if (a2 == -1 && a3 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  a5,  0);
  }
  *a1 = a3 % a2;
  return a3 / a2;
}

uint64_t BinaryInteger.quotientAndRemainder(dividingBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = v5;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 152))(v6, a3, a4, a5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 168))(v6, a3, a4, a5);
}

BOOL specialized BinaryInteger.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 | a2)
  {
    a3 = __umodti3();
    a4 = v4;
  }

  return (a3 | a4) == 0;
}

BOOL specialized BinaryInteger.isMultiple(of:)(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned int v2 = a2;
  if (a1) {
    unsigned int v2 = a2 % a1;
  }
  return v2 == 0;
}

BOOL specialized BinaryInteger.isMultiple(of:)(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned int v2 = a2;
  if (a1) {
    unsigned int v2 = a2 % a1;
  }
  return v2 == 0;
}

BOOL specialized BinaryInteger.isMultiple(of:)(unsigned int a1, unsigned int a2)
{
  if (a1) {
    a2 %= a1;
  }
  return a2 == 0;
}

uint64_t BinaryInteger.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  uint64_t v8 = *(const char **)(swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)
                      + 16);
  unint64_t v99 = swift_getAssociatedTypeWitness( 0LL,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v99);
  uint64_t v98 = &v95[-v9];
  unint64_t v10 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v110 = *(v10 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v101 = &v95[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  Swift::Int v107 = &v95[-v14];
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v108 = &v95[-v16];
  MEMORY[0x1895F8858](v15);
  uint64_t v109 = &v95[-v17];
  char v105 = *(const char **)(v6 + 16);
  unint64_t v104 = swift_getAssociatedTypeWitness( 0LL,  v105,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v18 = MEMORY[0x1895F8858](v104);
  uint64_t v103 = &v95[-v19];
  uint64_t v112 = *(void *)(a2 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  __int16 v97 = &v95[-((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v24 = &v95[-v23];
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = &v95[-v25];
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v28 = v27(a2, a3);
  unint64_t v100 = v8;
  if ((v28 & 1) != 0)
  {
    unsigned int v106 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v29 = v106(a2, a3);
    if (v29 < 64)
    {
      uint64_t v32 = v112;
      (*(void (**)(_BYTE *, uint64_t, uint64_t))(v112 + 16))(v26, a1, a2);
      goto LABEL_12;
    }

    uint64_t v113 = 0LL;
    uint64_t v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v46(&v113, &type metadata for Int, v47, a2, a3);
    char v48 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(*(void *)(*(void *)(a3 + 16) + 8LL) + 8LL))( a1,  v26,  a2);
    goto LABEL_15;
  }

  char v33 = v27(a2, a3);
  unint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v102 = a1;
  unsigned int v106 = v34;
  uint64_t v35 = v34(a2, a3);
  if ((v33 & 1) != 0)
  {
    if (v35 <= 64)
    {
      unint64_t v38 = v104;
      uint64_t v39 = v105;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v105,  a2,  v104,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v41 = v103;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v38,  AssociatedConformanceWitness);
      (*((void (**)(_BYTE *, uint64_t, const char *))v39 + 3))(v41, a2, v39);
      uint64_t v42 = v102;
      int v96 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 32LL))( v102,  v26,  a2);
      uint64_t v43 = v112;
      uint64_t v44 = *(void (**)(_BYTE *, uint64_t))(v112 + 8);
      v44(v26, a2);
      (*(void (**)(_BYTE *, uint64_t, uint64_t))(v43 + 16))(v24, v42, a2);
      if ((v96 & 1) != 0)
      {
        uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v44(v24, a2);
        if (!v45) {
          goto LABEL_16;
        }
      }

      else
      {
        v44(v24, a2);
      }

BOOL specialized BinaryInteger.signum()(uint64_t a1, unint64_t a2)
{
  if (a2) {
    BOOL v2 = (uint64_t)a2 > 0;
  }
  else {
    BOOL v2 = a1 != 0;
  }
  return v2 - (a2 >> 63);
}

uint64_t BinaryInteger.signum()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v32 = a3;
  uint64_t v31 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(v31 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v30 - v8;
  uint64_t v10 = *(void *)(a1 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v7);
  uint64_t v30 = (char *)&v30 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v30 - v14;
  MEMORY[0x1895F8858](v13);
  unint64_t v34 = (char *)&v30 - v16;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v35 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  v35(&unk_18180BE68, 256LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 24);
  v18(v9, a1, v5);
  uint64_t v19 = *(void *)(*(void *)(a2 + 32) + 8LL);
  char v20 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v19 + 40))(v33, v15, a1, v19);
  uint64_t v21 = *(void (**)(char *, uint64_t))(v10 + 8);
  v21(v15, a1);
  if ((v20 & 1) != 0)
  {
    uint64_t v22 = &qword_18180BE70;
    uint64_t v23 = 512LL;
  }

  else
  {
    uint64_t v22 = (uint64_t *)&unk_18180BE68;
    uint64_t v23 = 256LL;
  }

  v35(v22, v23, AssociatedTypeWitness, AssociatedConformanceWitness);
  v18(v9, a1, v5);
  v35(&unk_18180BE68, 256LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  v18(v9, a1, v5);
  char v24 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v19 + 16))(v33, v15, a1, v19);
  v21(v15, a1);
  if ((v24 & 1) != 0)
  {
    uint64_t v25 = &qword_18180BE70;
    uint64_t v26 = 512LL;
  }

  else
  {
    uint64_t v25 = (uint64_t *)&unk_18180BE68;
    uint64_t v26 = 256LL;
  }

  v35(v25, v26, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v27 = v30;
  v18(v9, a1, v5);
  char v28 = v34;
  (*(void (**)(char *, char *, uint64_t))(*(void *)(v31 + 8) + 40LL))(v34, v27, a1);
  v21(v27, a1);
  return ((uint64_t (*)(char *, uint64_t))v21)(v28, a1);
}

uint64_t BinaryInteger.init()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v3,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v6 = (char *)&v9 - v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v3,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(v3 + 24))(v6, a1, v3);
}

uint64_t specialized BinaryInteger._description(radix:uppercase:)( unint64_t a1, char a2, Swift::UInt64 a3, Swift::UInt64 a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Radix must be between 2 and 36",  30LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x5E1uLL,  0);
  }
  Swift::UInt64 v4 = a4;
  Swift::UInt64 v5 = a3;
  if (!(a4 | a3)) {
    return 48LL;
  }
  uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v20.i16[0] = vaddlv_u8(v20);
  uint64_t v21 = v20.u32[0];
  unint64_t v22 = __clz(__rbit64(a1));
  char v37 = a1 - 1;
  uint64_t v23 = &_swiftEmptyArrayStorage;
  do
  {
    if (v21 == 1)
    {
      if (v22 >= 0x40)
      {
        Swift::UInt64 v24 = v4 >> (v22 & 0x3F);
        Swift::UInt64 v4 = 0LL;
      }

      else if (v22)
      {
        Swift::UInt64 v24 = (v4 << (-(char)v22 & 0x3F)) | (v5 >> v22);
        v4 >>= v22;
      }

      else
      {
        Swift::UInt64 v24 = v5;
      }

      unsigned __int8 v25 = v5 & v37;
      Swift::UInt64 v5 = v24;
      if (a1 < 0xB)
      {
LABEL_24:
        char v27 = v25 + 48;
        goto LABEL_30;
      }
    }

    else
    {
      v41.high = (Swift::UInt64)&v38;
      v41.uint64_t low = v4;
      Swift::UInt64 v4 = specialized _wideDivide22<A>(_:by:)((Swift::UInt64 *)&v40, &v39, v41, v5, 0LL, a1);
      Swift::UInt64 v5 = (Swift::UInt64)v40;
      unsigned __int8 v25 = v38;
      if (a1 < 0xB) {
        goto LABEL_24;
      }
    }

    if (v25 < 0xAu) {
      goto LABEL_24;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v23);
    if ((a2 & 1) != 0)
    {
      char v27 = v25 + 55;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_25;
      }
    }

    else
    {
      char v27 = v25 + 87;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_25;
      }
    }

uint64_t specialized BinaryInteger._description(radix:uppercase:)( unint64_t a1, char a2, Swift::UInt64 a3, uint64_t a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Radix must be between 2 and 36",  30LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x5E1uLL,  0);
  }
  if (a4 | a3)
  {
    Swift::UInt64 v6 = (unsigned __int128)-(__int128)__PAIR128__(v4, a3) >> 64;
    if (a4 >= 0) {
      Swift::UInt64 v7 = a3;
    }
    else {
      Swift::UInt64 v7 = -(uint64_t)a3;
    }
    if (a4 >= 0) {
      Swift::UInt64 v8 = a4;
    }
    else {
      Swift::UInt64 v8 = v6;
    }
    if (!(v8 | v7))
    {
      uint64_t v9 = &_swiftEmptyArrayStorage;
LABEL_13:
      uint64_t v45 = v9;
      if (a4 < 0)
      {
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v9)) {
          uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v9[2]->isa + 1,  1,  (uint64_t)v9);
        }
        size_t v11 = v9[2];
        unint64_t v10 = (unint64_t)v9[3];
        if ((unint64_t)v11 >= v10 >> 1) {
          uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v10 > 1),  (int64_t)&v11->isa + 1,  1,  (uint64_t)v9);
        }
        v9[2] = (__objc2_class *)((char *)&v11->isa + 1);
        *((_BYTE *)&v11->info + (void)v9) = 45;
        uint64_t v45 = v9;
      }

      specialized MutableCollection<>.reverse()();
      Swift::UInt64 v15 = (Swift::UInt64)v45;
      size_t v16 = (size_t)v45[2];
      if (v16)
      {
        if (v16 > 0xF)
        {
          unint64_t v17 = v16 | 0xF000000000000000LL;
          int64_t v18 = _allocateStringStorage(codeUnitCapacity:)((int64_t)v45[2]);
          uint64_t v20 = v19;
          *(void *)(v18 + 16) = v19;
          *(void *)(v18 + 24) = v16 | 0xF000000000000000LL;
          swift_bridgeObjectRetain(v15, v19, v21, v22);
          if (v20 < 0)
          {
            *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
            unint64_t v17 = *(void *)(v18 + 24);
          }

          *(_BYTE *)(v18 + 32 + (v17 & 0xFFFFFFFFFFFFLL)) = 0;
          specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v15 + 32), v16, (char *)(v18 + 32));
          uint64_t v5 = *(void *)(v18 + 24);
          goto LABEL_61;
        }

        uint64_t v34 = 8LL;
        if (v16 < 8) {
          uint64_t v34 = (uint64_t)v45[2];
        }
        uint64_t v5 = *((unsigned __int8 *)v45 + 32);
        if (v34 != 1)
        {
          v5 |= (unint64_t)*((unsigned __int8 *)v45 + 33) << 8;
          if (v34 != 2)
          {
            v5 |= (unint64_t)*((unsigned __int8 *)v45 + 34) << 16;
            if (v34 != 3)
            {
              v5 |= (unint64_t)*((unsigned __int8 *)v45 + 35) << 24;
              if (v34 != 4)
              {
                v5 |= (unint64_t)*((unsigned __int8 *)v45 + 36) << 32;
                if (v34 != 5)
                {
                  v5 |= (unint64_t)*((unsigned __int8 *)v45 + 37) << 40;
                  if (v34 != 6)
                  {
                    v5 |= (unint64_t)*((unsigned __int8 *)v45 + 38) << 48;
                    if (v34 != 7) {
                      v5 |= (unint64_t)*((unsigned __int8 *)v45 + 39) << 56;
                    }
                  }
                }
              }
            }
          }
        }

        uint64_t v35 = 0LL;
        if (v16 >= 9)
        {
          uint64_t v36 = 0LL;
          char v37 = (unsigned __int8 *)(v45 + 5);
          size_t v38 = v16 - 8;
          do
          {
            if (v16 - 8 <= v16 - 9) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
            }
            unsigned int v39 = *v37++;
            v35 |= (unint64_t)v39 << v36;
            v36 += 8LL;
            --v38;
          }

          while (v38);
        }
      }

      else
      {
        uint64_t v5 = 0LL;
      }

      swift_bridgeObjectRetain((unint64_t)v45, v12, v13, v14);
LABEL_61:
      swift_bridgeObjectRelease_n(v15, 2LL);
      return v5;
    }

    uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
    v25.i16[0] = vaddlv_u8(v25);
    uint64_t v26 = v25.u32[0];
    unint64_t v27 = __clz(__rbit64(a1));
    char v42 = a1 - 1;
    uint64_t v9 = &_swiftEmptyArrayStorage;
    while (1)
    {
      if (v26 == 1)
      {
        if (v27 >= 0x40)
        {
          Swift::UInt64 v28 = v8 >> (v27 & 0x3F);
          Swift::UInt64 v8 = 0LL;
        }

        else if (v27)
        {
          Swift::UInt64 v28 = (v8 << (-(char)v27 & 0x3F)) | (v7 >> v27);
          v8 >>= v27;
        }

        else
        {
          Swift::UInt64 v28 = v7;
        }

        unsigned __int8 v29 = v7 & v42;
        Swift::UInt64 v7 = v28;
        if (a1 < 0xB)
        {
LABEL_38:
          char v31 = v29 + 48;
          goto LABEL_39;
        }
      }

      else
      {
        v46.high = (Swift::UInt64)&v43;
        v46.uint64_t low = v8;
        Swift::UInt64 v8 = specialized _wideDivide22<A>(_:by:)((Swift::UInt64 *)&v45, &v44, v46, v7, 0LL, a1);
        Swift::UInt64 v7 = (Swift::UInt64)v45;
        unsigned __int8 v29 = v43;
        if (a1 < 0xB) {
          goto LABEL_38;
        }
      }

      if (v29 < 0xAu) {
        goto LABEL_38;
      }
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v9);
      if ((a2 & 1) != 0)
      {
        char v31 = v29 + 55;
        if (!isUniquelyReferenced_nonNull_native) {
          goto LABEL_44;
        }
      }

      else
      {
        char v31 = v29 + 87;
        if (!isUniquelyReferenced_nonNull_native) {
LABEL_44:
        }
          uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v9[2]->isa + 1,  1,  (uint64_t)v9);
      }

uint64_t specialized BinaryInteger._description(radix:uppercase:)( unint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Radix must be between 2 and 36",  30LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x5E1uLL,  0);
  }
  if (!(a3 | a4)) {
    return 48LL;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v5.i16[0] = vaddlv_u8(v5);
  uint64_t v6 = v5.u32[0];
  unint64_t v7 = (a3 ^ (a4 >> 63)) - (a4 >> 63);
  char v9 = __clz(__rbit64(a1));
  char v10 = a1 - 1;
  size_t v11 = &_swiftEmptyArrayStorage;
  do
  {
    if (v6 == 1)
    {
      unsigned __int8 v12 = v7 & v10;
      if ((v9 & 0x40) != 0) {
        unint64_t v7 = v8 >> v9;
      }
      else {
        unint64_t v7 = ((2 * v8) << ~v9) | (v7 >> v9);
      }
      if ((v9 & 0x40) != 0) {
        unint64_t v8 = 0LL;
      }
      else {
        v8 >>= v9;
      }
      if (a1 < 0xB)
      {
LABEL_19:
        char v16 = v12 + 48;
        goto LABEL_25;
      }
    }

    else
    {
      uint64_t v13 = __udivti3();
      unint64_t v8 = v14;
      unsigned __int8 v12 = v7 - v13 * a1;
      unint64_t v7 = v13;
      if (a1 < 0xB) {
        goto LABEL_19;
      }
    }

    if (v12 < 0xAu) {
      goto LABEL_19;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v11);
    if ((a2 & 1) != 0)
    {
      char v16 = v12 + 55;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }

    else
    {
      char v16 = v12 + 87;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }

uint64_t specialized BinaryInteger._description(radix:uppercase:)( unint64_t a1, char a2, unint64_t a3, unint64_t a4)
{
  if (a1 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Radix must be between 2 and 36",  30LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x5E1uLL,  0);
  }
  unint64_t v4 = a4;
  unint64_t v5 = a3;
  if (!(a3 | a4)) {
    return 48LL;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v8.i16[0] = vaddlv_u8(v8);
  uint64_t v9 = v8.u32[0];
  char v10 = __clz(__rbit64(a1));
  char v38 = a1 - 1;
  size_t v11 = &_swiftEmptyArrayStorage;
  do
  {
    if (v9 == 1)
    {
      unsigned __int8 v12 = v5 & v38;
      if ((v10 & 0x40) != 0) {
        unint64_t v5 = v4 >> v10;
      }
      else {
        unint64_t v5 = ((2 * v4) << ~v10) | (v5 >> v10);
      }
      if ((v10 & 0x40) != 0) {
        unint64_t v4 = 0LL;
      }
      else {
        v4 >>= v10;
      }
      if (a1 < 0xB)
      {
LABEL_19:
        char v16 = v12 + 48;
        goto LABEL_25;
      }
    }

    else
    {
      uint64_t v13 = __udivti3();
      unint64_t v4 = v14;
      unsigned __int8 v12 = v5 - v13 * a1;
      unint64_t v5 = v13;
      if (a1 < 0xB) {
        goto LABEL_19;
      }
    }

    if (v12 < 0xAu) {
      goto LABEL_19;
    }
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v11);
    if ((a2 & 1) != 0)
    {
      char v16 = v12 + 55;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }

    else
    {
      char v16 = v12 + 87;
      if (isUniquelyReferenced_nonNull_native) {
        goto LABEL_20;
      }
    }

Swift::String __swiftcall BinaryInteger._description(radix:uppercase:)(Swift::Int radix, Swift::Bool uppercase)
{
  uint64_t v4 = v2;
  BOOL v160 = uppercase;
  unint64_t v171 = (__objc2_class **)radix;
  i = (uint64_t (**)(uint64_t, void))v3;
  uint64_t v5 = *(void *)(v3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  v2,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, AssociatedTypeWitness, AssociatedTypeWitness, 0LL, 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  Swift::String::Index v167 = (char *)&v145 - v7;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  Swift::String::Index v166 = *(const char **)(AssociatedConformanceWitness + 16);
  unint64_t v158 = swift_getAssociatedTypeWitness( 0LL,  v166,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](v158);
  unint64_t v170 = (char *)&v145 - v9;
  uint64_t v175 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v155 = (char *)&v145 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v159 = (char *)&v145 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  char v16 = (char *)&v145 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v145 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  size_t v22 = (char *)&v145 - v21;
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  int64_t v25 = (char *)&v145 - v24;
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  uint64_t v28 = (char *)&v145 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v145 - v29;
  uint64_t v31 = *(void *)(v5 + 16);
  unint64_t v32 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v31,  v4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v33 = MEMORY[0x1895F8858](v32);
  uint64_t v34 = MEMORY[0x1895F8858](v33);
  uint64_t v35 = MEMORY[0x1895F8858](v34);
  if ((unint64_t)v171 - 37 <= 0xFFFFFFFFFFFFFFDCLL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Radix must be between 2 and 36",  30LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x5E1uLL,  0);
  }
  unint64_t v153 = v39;
  uint64_t v150 = v38;
  uint64_t v151 = v35;
  uint64_t v154 = (uint64_t)&v145 - v36;
  uint64_t v149 = v37;
  Swift::String::Index v165 = v28;
  uint64_t v169 = v30;
  unint64_t v172 = v22;
  unint64_t v173 = v25;
  uint64_t v152 = v19;
  unint64_t v174 = v16;
  uint64_t v157 = v5;
  uint64_t v40 = (uint64_t)i;
  unint64_t v41 = v164;
  if (i[16](v4, i) <= 64)
  {
    char v51 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 64))(v4, v40);
    unint64_t v52 = v153;
    uint64_t v53 = v154;
    (*(void (**)(uint64_t, void, uint64_t))(v153 + 16))(v154, v41, v4);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 120))(v4, v40);
    (*(void (**)(uint64_t, uint64_t))(v52 + 8))(v53, v4);
    BOOL v55 = v160;
    if ((v51 & 1) != 0)
    {
      unint64_t countAndFlagsBits = _int64ToString(_:radix:uppercase:)( v54,  (uint64_t)v171,  v55,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    }

    else
    {
      Swift::String v78 = _uint64ToString(_:radix:uppercase:)(v54, (Swift::Int64)v171, v55);
      object = v78._object;
      unint64_t countAndFlagsBits = v78._countAndFlagsBits;
    }

    uint64_t v50 = countAndFlagsBits;
    int64_t v49 = (int64_t)object;
    goto LABEL_78;
  }

  uint64_t v42 = v31;
  uint64_t v43 = v151;
  unint64_t v44 = swift_getAssociatedConformanceWitness( v31,  v4,  v151,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v45 = v150;
  unint64_t v147 = *(void (**)(void *, uint64_t, uint64_t, unint64_t))(v44 + 8);
  v147(&unk_18180BE68, 256LL, v43, v44);
  Swift::tuple_high_UInt64_low_UInt64 v46 = *(void (**)(uint64_t, uint64_t, uint64_t))(v31 + 24);
  uint64_t v47 = v154;
  unint64_t v146 = v46;
  v46(v45, v4, v42);
  LOBYTE(v43) = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(*(void *)(v40 + 16) + 8LL) + 8LL))( v41,  v47,  v4);
  unint64_t v48 = v153;
  uint64_t v148 = *(void (**)(uint64_t, uint64_t))(v153 + 8);
  v148(v47, v4);
  if ((v43 & 1) != 0)
  {
    int64_t v49 = 0xE100000000000000LL;
    uint64_t v50 = 48LL;
    goto LABEL_78;
  }

  unint64_t v145 = v44;
  uint8x8_t v58 = (uint8x8_t)vcnt_s8((int8x8_t)v171);
  v58.i16[0] = vaddlv_u8(v58);
  uint64_t v162 = v58.u32[0];
  uint64_t v177 = v171;
  uint64_t v59 = v4;
  unint64_t v60 = swift_getAssociatedConformanceWitness( v40,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v61 = *(void (**)(__objc2_class ***, ValueMetadata *))(v60 + 88);
  unint64_t v64 = lazy protocol witness table accessor for type Int and conformance Int(v60, v62, v63);
  uint64_t v65 = v169;
  unint64_t v163 = v64;
  v61(&v177, &type metadata for Int);
  char v66 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 64))(v59, v40);
  uint64_t v67 = *(void (**)(uint64_t, void, uint64_t))(v48 + 16);
  uint64_t v68 = v149;
  v67(v149, v41, v59);
  if ((v66 & 1) != 0)
  {
    uint64_t v69 = v150;
    ((void (*)(void *, uint64_t))v147)(&unk_18180BE68, 256LL);
    uint64_t v70 = v154;
    v146(v69, v59, v42);
    LODWORD(v151) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(v40 + 32) + 8LL)
                                                                         + 16LL))( v68,  v70,  v59);
    unint64_t v71 = v148;
    v148(v70, v59);
    uint64_t v72 = v157;
    uint64_t v73 = v159;
    uint64_t v75 = v172;
    uint64_t v74 = v173;
    uint64_t v76 = v68;
    uint64_t v77 = v165;
  }

  else
  {
    LODWORD(v151) = 0;
    uint64_t v72 = v157;
    uint64_t v73 = v159;
    uint64_t v75 = v172;
    uint64_t v74 = v173;
    uint64_t v76 = v68;
    uint64_t v77 = v165;
    unint64_t v71 = v148;
  }

  v71(v76, v59);
  uint64_t v79 = *(void (**)(uint64_t, uint64_t))(v72 + 56);
  uint64_t v154 = v59;
  v79(v59, v72);
  unint64_t v153 = __clz(__rbit64((unint64_t)v171));
  uint64_t v177 = &_swiftEmptyArrayStorage;
  unint64_t v80 = *(uint64_t (***)(uint64_t, void))(v60 + 64);
  unint64_t v164 = (void (*)(void, void, void))v175[2];
  if (v160) {
    int v81 = 55;
  }
  else {
    int v81 = 87;
  }
  BOOL v160 = v81;
  for (i = v80; ; unint64_t v80 = i)
  {
    v164(v74, v77, AssociatedTypeWitness);
    char v82 = ((uint64_t (*)(unint64_t, unint64_t))v80)(AssociatedTypeWitness, v60);
    uint64_t v83 = (uint64_t (*)(unint64_t, unint64_t))v80;
    uint64_t v85 = v167;
    unint64_t v84 = TupleTypeMetadata2;
    if ((v82 & 1) != 0)
    {
      if ((*(uint64_t (**)(unint64_t, unint64_t))(v60 + 128))(AssociatedTypeWitness, v60) >= 64)
      {
        unint64_t v176 = 0LL;
        (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t, unint64_t))(v60 + 96))( &v176,  &type metadata for Int,  v163,  AssociatedTypeWitness,  v60);
        uint64_t v101 = *(uint64_t (**)(char *, char *, unint64_t))(*(void *)(swift_getAssociatedConformanceWitness( v157,  v154,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable)
                                                                                      + 8)
                                                                          + 8LL);
        char v102 = v101(v74, v75, AssociatedTypeWitness);
        goto LABEL_31;
      }

      uint64_t v86 = (*(uint64_t (**)(unint64_t, unint64_t))(v60 + 120))(AssociatedTypeWitness, v60);
      goto LABEL_28;
    }

    char v87 = v83(AssociatedTypeWitness, v60);
    uint64_t v88 = (*(uint64_t (**)(unint64_t, unint64_t))(v60 + 128))(AssociatedTypeWitness, v60);
    if ((v87 & 1) == 0) {
      break;
    }
    if (v88 > 64) {
      goto LABEL_30;
    }
    char v89 = v166;
    unint64_t v90 = v158;
    unint64_t v91 = swift_getAssociatedConformanceWitness( (uint64_t)v166,  AssociatedTypeWitness,  v158,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    unint64_t v92 = v170;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v91 + 8))( &unk_18180BE68,  256LL,  v90,  v91);
    (*((void (**)(char *, unint64_t, const char *))v89 + 3))(v92, AssociatedTypeWitness, v89);
    unint64_t v93 = swift_getAssociatedConformanceWitness( v157,  v154,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    uint64_t v94 = v173;
    LOBYTE(v90) = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v93 + 32))( v173,  v75,  AssociatedTypeWitness,  v93);
    uint64_t v95 = v175;
    int v96 = v75;
    __int16 v97 = (void (*)(char *, unint64_t))v175[1];
    v97(v96, AssociatedTypeWitness);
    uint64_t v98 = (void (*)(char *, char *, unint64_t))v95[4];
    unint64_t v99 = v152;
    v98(v152, v94, AssociatedTypeWitness);
    if ((v90 & 1) != 0)
    {
      uint64_t v100 = (*(uint64_t (**)(unint64_t, unint64_t))(v60 + 120))(AssociatedTypeWitness, v60);
      v97(v99, AssociatedTypeWitness);
      uint64_t v73 = v159;
      uint64_t v65 = v169;
      if (!v100) {
        goto LABEL_47;
      }
    }

    else
    {
      v97(v99, AssociatedTypeWitness);
      uint64_t v73 = v159;
      uint64_t v65 = v169;
    }

Swift::String __swiftcall _uint64ToString(_:radix:uppercase:)( Swift::UInt64 _, Swift::Int64 radix, Swift::Bool uppercase)
{
  unint64_t v3 = _int64ToString(_:radix:uppercase:)( _,  radix,  uppercase,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_uint64ToString);
  result._object = v4;
  result._unint64_t countAndFlagsBits = v3;
  return result;
}

unint64_t _int64ToString(_:radix:uppercase:)( uint64_t a1, uint64_t a2, char a3, uint64_t (*a4)(__int128 *, uint64_t, uint64_t, uint64_t, void))
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (a2 < 10)
  {
    uint64_t v29 = 0LL;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 __src = 0u;
    __int128 v26 = 0u;
    uint64_t v4 = a4(&__src, 72LL, a1, a2, a3 & 1);
    if ((v4 & 0x8000000000000000LL) == 0)
    {
      size_t v5 = v4;
      if (v4)
      {
        if ((unint64_t)v4 <= 0xF)
        {
          uint64_t v6 = v4 - 8;
          uint64_t v7 = 8LL;
          if (v4 < 8) {
            uint64_t v7 = v4;
          }
          unint64_t result = __src;
          if (v7 != 1)
          {
            unint64_t result = __src | ((unint64_t)BYTE1(__src) << 8);
            if (v7 != 2)
            {
              result |= (unint64_t)BYTE2(__src) << 16;
              if (v7 != 3)
              {
                result |= (unint64_t)BYTE3(__src) << 24;
                if (v7 != 4)
                {
                  result |= (unint64_t)BYTE4(__src) << 32;
                  if (v7 != 5)
                  {
                    result |= (unint64_t)BYTE5(__src) << 40;
                    if (v7 != 6)
                    {
                      result |= (unint64_t)BYTE6(__src) << 48;
                      if (v7 != 7) {
                        result |= (unint64_t)BYTE7(__src) << 56;
                      }
                    }
                  }
                }
              }
            }
          }

          uint64_t v9 = 0LL;
          if (v5 >= 9)
          {
            uint64_t v10 = 0LL;
            uint64_t v11 = (unsigned __int8 *)&__src + 8;
            unint64_t v12 = v6 & ~(v6 >> 63);
            while (v12 > v5 - 9)
            {
              unsigned int v13 = *v11++;
              v9 |= (unint64_t)v13 << v10;
              v10 += 8LL;
              if (!--v6) {
                return result;
              }
            }

            goto LABEL_42;
          }

          return result;
        }

uint64_t Int.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t Int.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

void specialized MutableCollection<>.reverse()()
{
  uint8x8_t v1 = (__objc2_class **)*v0;
  uint64_t v2 = *(void *)(*v0 + 16);
  if (v2) {
    BOOL v3 = v2 == 1;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
    uint64_t *v0 = (uint64_t)v1;
    if (!isUniquelyReferenced_nonNull_native) {
      uint8x8_t v1 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v1);
    }
    unint64_t v5 = 0LL;
    uint64_t *v0 = (uint64_t)v1;
    uint64_t v6 = v2 + 31;
    do
    {
      if (v5 != v6 - 32)
      {
        unint64_t v8 = (unint64_t)v1[2];
        if (v5 >= v8 || v6 - 32 >= v8) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }
        char v9 = *((_BYTE *)v1 + v5 + 32);
        *((_BYTE *)v1 + v5 + 32) = *((_BYTE *)v1 + v6);
        *((_BYTE *)v1 + v6) = v9;
      }

      ++v5;
      int64_t v7 = v6 - 33;
      --v6;
    }

    while ((uint64_t)v5 < v7);
    uint64_t *v0 = (uint64_t)v1;
  }

{
  uint64_t *v0;
  __objc2_class **v1;
  uint64_t v2;
  unint64_t v3;
  BOOL isUniquelyReferenced_nonNull_native;
  _WORD *v5;
  _WORD *v6;
  uint64_t v7;
  unint64_t v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint8x8_t v1 = (__objc2_class **)*v0;
  uint64_t v2 = *(void *)(*v0 + 16);
  if (v2)
  {
    BOOL v3 = v2 - 1;
    if (v2 != 1)
    {
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
      uint64_t *v0 = (uint64_t)v1;
      if (!isUniquelyReferenced_nonNull_native) {
        uint8x8_t v1 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v1);
      }
      uint64_t *v0 = (uint64_t)v1;
      unint64_t v5 = (_WORD *)&v1[v2 + 3] + 2;
      uint64_t v6 = (_WORD *)v1 + 18;
      int64_t v7 = 1LL;
      do
      {
        if (v7 - 1 != v3)
        {
          char v9 = (unint64_t)v1[2];
          if (v7 - 1 >= v9 || v3 >= v9) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
          }
          uint64_t v10 = *v6;
          uint64_t v11 = *((_DWORD *)v6 - 1);
          unint64_t v12 = *v5;
          *((_DWORD *)v6 - 1) = *((_DWORD *)v5 - 1);
          *uint64_t v6 = v12;
          *((_DWORD *)v5 - 1) = v11;
          *unint64_t v5 = v10;
        }

        --v3;
        v5 -= 4;
        v6 += 4;
      }

      while (v7++ < (uint64_t)v3);
      uint64_t *v0 = (uint64_t)v1;
    }
  }

uint64_t MutableCollection<>.reverse()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = a3;
  uint64_t v30 = a2;
  uint64_t v4 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v4,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v9 = (char *)&v25 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  unint64_t v12 = (char *)&v25 - v11;
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v25 - v13;
  unint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 104);
  uint64_t v29 = v4;
  uint64_t result = v15(a1, v4);
  if ((result & 1) == 0)
  {
    uint64_t v17 = v29;
    (*(void (**)(uint64_t, uint64_t))(v29 + 64))(a1, v29);
    (*(void (**)(uint64_t, uint64_t))(v17 + 72))(a1, v17);
    (*(void (**)(char *, uint64_t))(v30 + 32))(v9, a1);
    __int128 v26 = *(void (**)(char *, unint64_t))(v6 + 8);
    v26(v9, AssociatedTypeWitness);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v17,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    unint64_t v19 = AssociatedTypeWitness;
    uint64_t v20 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                       + 16);
    unint64_t v27 = AssociatedConformanceWitness;
    if ((((uint64_t (*)(char *, char *, unint64_t))v20)(v14, v12, v19) & 1) != 0)
    {
      uint64_t v21 = *(void (**)(char *, char *, uint64_t, uint64_t))(v28 + 64);
      size_t v22 = *(void (**)(char *, uint64_t, uint64_t))(v29 + 192);
      unint64_t v23 = *(void (**)(char *, uint64_t, uint64_t))(v30 + 40);
      do
      {
        v21(v14, v12, a1, v28);
        v22(v14, a1, v29);
        v23(v12, a1, v30);
      }

      while ((v20(v14, v12, v19, v27) & 1) != 0);
    }

    unsigned int v24 = (uint64_t (*)(char *, unint64_t))v26;
    v26(v12, v19);
    return v24(v14, v19);
  }

  return result;
}

uint64_t BinaryInteger.distance(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v370 = (uint64_t (*)(void, void))a1;
  uint64_t v4 = a2;
  uint64_t v5 = *(void *)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a2,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v336 = *(const char **)(AssociatedConformanceWitness + 16);
  unint64_t v335 = swift_getAssociatedTypeWitness( 0LL,  v336,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v335);
  v334 = (char *)&v332 - v7;
  uint64_t v353 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v359 = *(v353 - 1);
  uint64_t v8 = MEMORY[0x1895F8858](v353);
  char v337 = (char *)&v332 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  v351 = (char *)&v332 - v11;
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v350 = (char *)&v332 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v356 = (char *)&v332 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  char v343 = (char *)&v332 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v357 = (char *)&v332 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v361 = (unint64_t)&v332 - v21;
  MEMORY[0x1895F8858](v20);
  uint64_t v352 = (char *)&v332 - v22;
  unint64_t v23 = *(const char **)(v5 + 16);
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  v23,  v4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  unint64_t v27 = (char *)&v332 - v26;
  uint64_t v368 = *(void *)(v4 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v333 = (char *)&v332 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v349 = (char *)&v332 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v347 = (char *)&v332 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v354 = (char *)&v332 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v342 = (char *)&v332 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  unint64_t v358 = (char *)&v332 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v339 = (char *)&v332 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  uint64_t v348 = (uint64_t (*)(char *, char *, uint64_t, char *))((char *)&v332 - v43);
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  uint64_t v341 = (char *)&v332 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  v360 = (char *)&v332 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  uint64_t v50 = (char *)&v332 - v49;
  uint64_t v51 = MEMORY[0x1895F8858](v48);
  uint64_t v365 = (uint64_t)&v332 - v52;
  uint64_t v53 = MEMORY[0x1895F8858](v51);
  uint64_t v338 = (char *)&v332 - v54;
  uint64_t v55 = MEMORY[0x1895F8858](v53);
  v340 = (char *)&v332 - v56;
  uint64_t v57 = MEMORY[0x1895F8858](v55);
  v346 = (char *)&v332 - v58;
  uint64_t v59 = MEMORY[0x1895F8858](v57);
  v345 = (char *)&v332 - v60;
  uint64_t v61 = MEMORY[0x1895F8858](v59);
  uint64_t v63 = (char *)&v332 - v62;
  uint64_t v64 = MEMORY[0x1895F8858](v61);
  v355 = (char *)&v332 - v65;
  uint64_t v66 = MEMORY[0x1895F8858](v64);
  uint64_t v68 = (char *)&v332 - v67;
  MEMORY[0x1895F8858](v66);
  uint64_t v364 = (uint64_t)&v332 - v69;
  uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  uint64_t v366 = a3;
  v367 = v70;
  char v71 = v70(v4, a3);
  v362 = v23;
  v363 = v63;
  if ((v71 & 1) == 0)
  {
    unint64_t v361 = v24;
    uint64_t v101 = v366;
    char v102 = *(char **)(*(void *)(v366 + 32) + 8LL);
    char v103 = (*((uint64_t (**)(uint64_t (*)(uint64_t, unint64_t), uint64_t (*)(void, void), uint64_t, char *))v102
            + 5))( v369,  v370,  v4,  v102);
    unint64_t v104 = *(void (**)(uint64_t (*)(uint64_t, unint64_t), uint64_t, uint64_t))(*(void *)(v5 + 8) + 40LL);
    if ((v103 & 1) != 0)
    {
      uint64_t v365 = (uint64_t)v102;
      uint64_t v105 = v364;
      v104(v369, (uint64_t)v370, v4);
      char v106 = v367(v4, v101);
      uint64_t v107 = v101;
      uint64_t v108 = v368;
      uint64_t v101 = *(void *)(v368 + 16);
      ((void (*)(char *, uint64_t, uint64_t))v101)(v68, v105, v4);
      uint64_t v109 = v107;
      BOOL v110 = (v106 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(v107 + 128))(v4, v107) > 64;
      char v102 = *(char **)(v108 + 8);
      ((void (*)(char *, uint64_t))v102)(v68, v4);
      uint64_t v135 = v355;
      ((void (*)(char *, uint64_t, uint64_t))v101)(v355, v364, v4);
      if (!v110)
      {
        ((void (*)(char *, uint64_t))v102)(v135, v4);
        uint64_t v137 = *(uint64_t (**)(uint64_t, uint64_t))(v109 + 128);
        uint64_t v143 = v364;
        uint64_t v141 = v4;
        uint64_t v144 = v345;
        goto LABEL_45;
      }

      int64_t v372 = 0x8000000000000000LL;
      uint64_t v136 = v367;
      if ((v367(v4, v109) & 1) != 0)
      {
        uint64_t v137 = *(uint64_t (**)(uint64_t, uint64_t))(v109 + 128);
        uint64_t v138 = v137(v4, v109);
        uint64_t v141 = v4;
        if (v138 >= 64)
        {
          uint64_t v272 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v109 + 96);
          unint64_t v273 = lazy protocol witness table accessor for type Int and conformance Int(v138, v139, v140);
          uint64_t v274 = v363;
          v272(&v372, &type metadata for Int, v273, v4, v109);
          char v275 = (*(uint64_t (**)(char *, char *, uint64_t))(v365 + 16))(v135, v274, v4);
          ((void (*)(char *, uint64_t))v102)(v274, v4);
          ((void (*)(char *, uint64_t))v102)(v135, v4);
          uint64_t v143 = v364;
          uint64_t v144 = v345;
          if ((v275 & 1) != 0) {
            goto LABEL_124;
          }
        }

        else
        {
          uint64_t v142 = (*(uint64_t (**)(uint64_t, uint64_t))(v109 + 120))(v4, v109);
          ((void (*)(char *, uint64_t))v102)(v135, v4);
          uint64_t v143 = v364;
          uint64_t v144 = v345;
          if (v142 < v372) {
            goto LABEL_124;
          }
        }

        goto LABEL_45;
      }

      char v207 = v136(v4, v109);
      uint64_t v137 = *(uint64_t (**)(uint64_t, uint64_t))(v109 + 128);
      unint64_t v370 = (uint64_t (*)(void, void))v4;
      uint64_t v208 = v137(v4, v109);
      if ((v207 & 1) != 0)
      {
        if (v208 <= 64)
        {
          uint64_t v293 = v135;
          uint64_t v294 = v361;
          uint64_t v295 = (uint64_t)v362;
          uint64_t v296 = (uint64_t)v370;
          unint64_t v297 = swift_getAssociatedConformanceWitness( (uint64_t)v362,  (uint64_t)v370,  v361,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v297 + 8))( &unk_18180BE68,  256LL,  v294,  v297);
          uint64_t v4 = (uint64_t)v363;
          v298 = v27;
          uint64_t v141 = v296;
          (*(void (**)(char *, uint64_t, uint64_t))(v295 + 24))(v298, v296, v295);
          LOBYTE(v294) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v365 + 16))(v293, v4, v296);
          ((void (*)(uint64_t, uint64_t))v102)(v4, v296);
          uint64_t v299 = v338;
          (*(void (**)(char *, char *, uint64_t))(v368 + 32))(v338, v293, v296);
          if ((v294 & 1) != 0)
          {
            v355 = v102;
            ((void (*)(char *, uint64_t))v102)(v299, v296);
            goto LABEL_168;
          }

          int64_t v300 = v372;
          uint64_t v109 = v366;
          uint64_t v301 = (*(uint64_t (**)(uint64_t, uint64_t))(v366 + 120))(v141, v366);
          ((void (*)(char *, uint64_t))v102)(v299, v141);
          BOOL v284 = v301 < v300;
          uint64_t v143 = v364;
          uint64_t v144 = v345;
          if (!v284) {
            goto LABEL_45;
          }
        }

        else
        {
          uint64_t v109 = v366;
          unint64_t v211 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v366 + 96);
          unint64_t v212 = lazy protocol witness table accessor for type Int and conformance Int(v208, v209, v210);
          v213 = v363;
          uint64_t v141 = (uint64_t)v370;
          v211(&v372, &type metadata for Int, v212, (uint64_t)v370, v109);
          char v214 = (*(uint64_t (**)(char *, char *, uint64_t))(v365 + 16))(v135, v213, v141);
          ((void (*)(char *, uint64_t))v102)(v213, v141);
          ((void (*)(char *, uint64_t))v102)(v135, v141);
          uint64_t v143 = v364;
          uint64_t v144 = v345;
          if ((v214 & 1) == 0) {
            goto LABEL_45;
          }
        }
      }

      else
      {
        uint64_t v144 = v345;
        if (v208 >= 64)
        {
          uint64_t v141 = (uint64_t)v370;
          ((void (*)(char *, uint64_t (*)(uint64_t, unint64_t)))v102)(v355, v370);
          uint64_t v109 = v366;
          uint64_t v143 = v364;
          goto LABEL_45;
        }

        uint64_t v109 = v366;
        v280 = v355;
        uint64_t v141 = (uint64_t)v370;
        uint64_t v281 = (*(uint64_t (**)(uint64_t, uint64_t))(v366 + 120))((uint64_t)v370, v366);
        ((void (*)(char *, uint64_t))v102)(v280, v141);
        uint64_t v143 = v364;
        if (v281 >= v372)
        {
LABEL_45:
          uint64_t v163 = v137(v141, v109);
          ((void (*)(char *, uint64_t, uint64_t))v101)(v144, v143, v141);
          if (v163 >= 65)
          {
            uint64_t v164 = v109;
            ((void (*)(char *, uint64_t))v102)(v144, v141);
            Swift::String::Index v165 = v346;
            ((void (*)(char *, uint64_t, uint64_t))v101)(v346, v143, v141);
LABEL_47:
            int64_t v372 = 0x7FFFFFFFFFFFFFFFLL;
            char v166 = v367(v141, v164);
            uint64_t v167 = v137(v141, v164);
            if ((v166 & 1) != 0)
            {
              if (v167 > 64)
              {
                unint64_t v170 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v164 + 96);
                unint64_t v171 = lazy protocol witness table accessor for type Int and conformance Int(v167, v168, v169);
                uint64_t v4 = (uint64_t)v363;
                v170(&v372, &type metadata for Int, v171, v141, v164);
                char v172 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(v365 + 16))(v4, v165, v141);
                ((void (*)(uint64_t, uint64_t))v102)(v4, v141);
                uint64_t v173 = (uint64_t)v165;
                goto LABEL_108;
              }
            }

            else if (v167 > 63)
            {
              uint64_t v371 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v4 = (uint64_t)v363;
              uint64_t v238 = (*(uint64_t (**)(char *, char *, uint64_t))(v368 + 32))(v363, v165, v141);
              Swift::Int v239 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v164 + 96);
              unint64_t v242 = lazy protocol witness table accessor for type Int and conformance Int(v238, v240, v241);
              Swift::String::Index v243 = v340;
              v239(&v371, &type metadata for Int, v242, v141, v164);
              char v172 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v365 + 16))(v243, v4, v141);
              ((void (*)(char *, uint64_t))v102)(v243, v141);
              uint64_t v173 = v4;
LABEL_108:
              ((void (*)(uint64_t, uint64_t))v102)(v173, v141);
              if ((v172 & 1) == 0) {
                goto LABEL_109;
              }
LABEL_124:
              unint64_t v370 = (uint64_t (*)(void, void))v141;
              v355 = v102;
              ((void (*)(uint64_t, uint64_t))v102)(v364, v141);
              goto LABEL_169;
            }

            unint64_t v204 = v363;
            (*(void (**)(char *, char *, uint64_t))(v368 + 32))(v363, v165, v141);
            (*(void (**)(uint64_t, uint64_t))(v164 + 120))(v141, v164);
            unint64_t v205 = v204;
LABEL_95:
            ((void (*)(char *, uint64_t))v102)(v205, v141);
LABEL_109:
            uint64_t v244 = (*(uint64_t (**)(uint64_t, uint64_t))(v164 + 120))(v141, v164);
            ((void (*)(uint64_t, uint64_t))v102)(v143, v141);
            BOOL v231 = __OFSUB__(0LL, v244);
            uint64_t v230 = -v244;
            if (!v231) {
              return v230;
            }
            __break(1u);
            goto LABEL_112;
          }

          uint64_t v198 = v137(v141, v109);
          ((void (*)(char *, uint64_t))v102)(v144, v141);
          if (v198 == 64)
          {
            uint64_t v164 = v109;
            char v199 = v367(v141, v109);
            Swift::String::Index v165 = v346;
            ((void (*)(char *, uint64_t, uint64_t))v101)(v346, v143, v141);
            if ((v199 & 1) == 0) {
              goto LABEL_47;
            }
          }

          else
          {
            uint64_t v164 = v109;
            Swift::String::Index v165 = v346;
            ((void (*)(char *, uint64_t, uint64_t))v101)(v346, v143, v141);
          }

          unint64_t v205 = v165;
          goto LABEL_95;
        }
      }

      v355 = v102;
      ((void (*)(uint64_t, uint64_t (*)(uint64_t, unint64_t)))v102)(v364, v370);
      goto LABEL_169;
    }

    uint64_t v127 = v365;
    v104(v370, (uint64_t)v369, v4);
    uint64_t v128 = v367;
    char v129 = v367(v4, v101);
    uint64_t v130 = v368;
    uint64_t v131 = *(void (**)(char *, uint64_t, uint64_t))(v368 + 16);
    v131(v50, v127, v4);
    BOOL v132 = (v129 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(v101 + 128))(v4, v101) > 64;
    uint64_t v154 = *(void (**)(char *, uint64_t))(v130 + 8);
    v154(v50, v4);
    unint64_t v155 = v360;
    v131(v360, v365, v4);
    if (v132)
    {
      v355 = (char *)v154;
      int64_t v372 = 0x8000000000000000LL;
      if ((v128(v4, v101) & 1) != 0)
      {
        unint64_t v156 = *(uint64_t (**)(uint64_t, uint64_t))(v101 + 128);
        uint64_t v157 = v360;
        uint64_t v158 = v156(v4, v101);
        uint64_t v141 = v4;
        if (v158 >= 64)
        {
          v276 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v101 + 96);
          unint64_t v277 = lazy protocol witness table accessor for type Int and conformance Int(v158, v159, v160);
          v278 = v363;
          v276(&v372, &type metadata for Int, v277, v141, v101);
          char v279 = (*((uint64_t (**)(char *, char *, uint64_t, char *))v102 + 2))(v157, v278, v141, v102);
          uint64_t v137 = (uint64_t (*)(uint64_t, uint64_t))v355;
          ((void (*)(char *, uint64_t))v355)(v278, v141);
          v137((uint64_t)v157, v141);
          uint64_t v162 = v365;
          uint64_t v4 = (uint64_t)v348;
          if ((v279 & 1) != 0)
          {
LABEL_126:
            unint64_t v370 = (uint64_t (*)(void, void))v141;
            goto LABEL_167;
          }
        }

        else
        {
          uint64_t v161 = (*(uint64_t (**)(uint64_t, uint64_t))(v101 + 120))(v4, v101);
          uint64_t v137 = (uint64_t (*)(uint64_t, uint64_t))v355;
          ((void (*)(char *, uint64_t))v355)(v157, v4);
          uint64_t v162 = v365;
          uint64_t v4 = (uint64_t)v348;
          if (v161 < v372) {
            goto LABEL_126;
          }
        }

uint64_t SignedInteger<>.init<A>(exactly:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v219 = a4;
  uint64_t v221 = a1;
  uint64_t v214 = a6;
  uint64_t v217 = *(void *)(a4 + 8);
  unint64_t v205 = *(const char **)(*(void *)(v217 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v205,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v203 = (char *)&v191 - v9;
  uint64_t v202 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t v201 = swift_getAssociatedTypeWitness( 0LL,  v202,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](v201);
  uint64_t v200 = (char *)&v191 - v11;
  v213 = (uint64_t (*)(void, void))a2;
  uint64_t v216 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  char v199 = (char *)&v191 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v198 = (char *)&v191 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v209 = (char *)&v191 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  char v194 = (char *)&v191 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v195 = (char *)&v191 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v208 = (char *)&v191 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v206 = (char *)&v191 - v25;
  uint64_t v26 = *(void *)(a3 - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v196 = (char *)&v191 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  char v197 = (char *)&v191 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v218 = (char *)&v191 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  unint64_t v211 = (char *)&v191 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v37 = (char *)&v191 - v36;
  uint64_t v38 = MEMORY[0x1895F8858](v35);
  uint64_t v40 = (char *)&v191 - v39;
  uint64_t v41 = MEMORY[0x1895F8858](v38);
  uint64_t v210 = (char *)&v191 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  uint64_t v45 = (char *)&v191 - v44;
  MEMORY[0x1895F8858](v43);
  uint64_t v47 = (char *)&v191 - v46;
  uint64_t v48 = a5;
  unint64_t v212 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  char v49 = v212(a3, a5);
  uint64_t v50 = v26;
  uint64_t v51 = *(void (**)(char *, uint64_t, uint64_t))(v26 + 16);
  v51(v47, (uint64_t)v221, a3);
  uint64_t v52 = v219;
  uint64_t v207 = v50;
  char v215 = v51;
  uint64_t v222 = v48;
  if ((v49 & 1) == 0)
  {
    uint64_t v77 = *(void (**)(char *, uint64_t))(v50 + 8);
    v77(v47, a3);
    v51(v45, (uint64_t)v221, a3);
    uint64_t v61 = (uint64_t)v213;
    uint64_t v56 = v45;
LABEL_10:
    uint64_t v64 = a3;
    v77(v56, a3);
    uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t))(v222 + 128);
    uint64_t v79 = v217;
    goto LABEL_11;
  }

  unint64_t v191 = v40;
  uint64_t v192 = v37;
  uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v48 + 128);
  uint64_t v193 = v53(a3, v48);
  unint64_t v220 = *(void (**)(char *, uint64_t))(v50 + 8);
  v220(v47, a3);
  uint64_t v54 = v213;
  uint64_t v55 = (*(uint64_t (**)(void, uint64_t))(v52 + 56))(v213, v52);
  v51(v45, (uint64_t)v221, a3);
  uint64_t v56 = v45;
  if (v55 >= v193)
  {
    uint64_t v77 = v220;
    uint64_t v61 = (uint64_t)v54;
    goto LABEL_10;
  }

  uint64_t v57 = v52;
  uint64_t v193 = (uint64_t)v45;
  uint64_t v58 = v53;
  uint64_t v59 = v206;
  (*(void (**)(uint64_t (*)(void, void), uint64_t))(v57 + 72))(v54, v57);
  uint64_t v60 = v212;
  uint64_t v61 = (uint64_t)v54;
  int v62 = v212(a3, v222);
  uint64_t v63 = v217;
  uint64_t v64 = a3;
  if (((v62 ^ (*(unsigned int (**)(uint64_t, uint64_t))(v217 + 64))(v61, v217)) & 1) == 0)
  {
    uint64_t v123 = v193;
    uint64_t v124 = v58(v64, v222);
    if (v124 >= (*(uint64_t (**)(uint64_t, uint64_t))(v63 + 128))(v61, v63))
    {
      uint64_t v154 = v222;
      unint64_t v155 = v210;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v222 + 96))(v59, v61, v63, v64, v222);
      char v156 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v154 + 32) + 8LL) + 16LL))( v123,  v155,  v64);
      uint64_t v77 = v220;
      v220(v155, v64);
      v77((char *)v123, v64);
      uint64_t v79 = v63;
      uint64_t v80 = v214;
      if ((v156 & 1) != 0) {
        goto LABEL_32;
      }
      goto LABEL_11;
    }

    uint64_t v125 = v208;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v63 + 96))(v123, v64, v222, v61, v63);
    char v126 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v63 + 32) + 8LL) + 16LL))( v125,  v59,  v61);
    uint64_t v127 = *(void (**)(char *, uint64_t))(v216 + 8);
    v127(v125, v61);
    v127(v59, v61);
    uint64_t v79 = v63;
    uint64_t v80 = v214;
    goto LABEL_44;
  }

  uint64_t v65 = v222;
  char v66 = v60(a3, v222);
  uint64_t v67 = v58(a3, v65);
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(v63 + 128))(v61, v63);
  if ((v66 & 1) == 0)
  {
    if (v67 >= v68)
    {
      unint64_t v172 = AssociatedTypeWitness;
      uint64_t v173 = v205;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v205,  v61,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v175 = v203;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v172,  AssociatedConformanceWitness);
      char v176 = v208;
      (*((void (**)(char *, uint64_t, const char *))v173 + 3))(v175, v61, v173);
      uint64_t v79 = v217;
      LOBYTE(v172) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v217 + 32) + 8LL)
                                                                        + 40LL))( v59,  v176,  v61);
      uint64_t v177 = v216;
      uint64_t v178 = *(void (**)(char *, uint64_t))(v216 + 8);
      v178(v176, v61);
      (*(void (**)(char *, uint64_t, uint64_t))(v207 + 32))(v192, v193, v64);
      uint64_t v179 = *(void (**)(char *, char *, uint64_t))(v177 + 32);
      char v180 = v194;
      v179(v194, v59, v61);
      uint64_t v80 = v214;
      uint64_t v77 = v220;
      if ((v172 & 1) != 0)
      {
        uint64_t v181 = v222;
        unint64_t v182 = v210;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v222 + 96))(v180, v61, v79, v64, v222);
        char v183 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v181 + 32) + 8LL) + 16LL);
        uint64_t v184 = v192;
        char v185 = v183(v192, v182, v64);
        v77(v182, v64);
        v77(v184, v64);
        if ((v185 & 1) != 0) {
          goto LABEL_32;
        }
      }

      else
      {
        v178(v180, v61);
        v77(v192, v64);
      }

      goto LABEL_11;
    }

    uint64_t v79 = v217;
    char v152 = v208;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v217 + 96))(v193, v64, v222, v61, v217);
    char v126 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v79 + 32) + 8LL) + 16LL))( v152,  v59,  v61);
    unint64_t v153 = *(void (**)(char *, uint64_t))(v216 + 8);
    v153(v152, v61);
    v153(v59, v61);
    uint64_t v80 = v214;
LABEL_44:
    uint64_t v77 = v220;
    if ((v126 & 1) != 0) {
      goto LABEL_32;
    }
    goto LABEL_11;
  }

  if (v68 >= v67)
  {
    uint64_t v160 = v202;
    unint64_t v161 = v201;
    unint64_t v162 = swift_getAssociatedConformanceWitness( (uint64_t)v202,  a3,  v201,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v163 = v200;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v162 + 8))( &unk_18180BE68,  256LL,  v161,  v162);
    uint64_t v164 = v210;
    (*((void (**)(char *, uint64_t, const char *))v160 + 3))(v163, a3, v160);
    uint64_t v165 = a3;
    uint64_t v166 = v193;
    LOBYTE(v161) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v222 + 32) + 8LL) + 16LL))( v193,  v164,  a3);
    uint64_t v167 = v220;
    v220(v164, v165);
    uint64_t v168 = v191;
    uint64_t v169 = v166;
    uint64_t v64 = v165;
    (*(void (**)(char *, uint64_t, uint64_t))(v207 + 32))(v191, v169, v165);
    uint64_t v170 = v216;
    unint64_t v171 = v195;
    (*(void (**)(char *, char *, uint64_t))(v216 + 32))(v195, v59, v61);
    uint64_t v80 = v214;
    if ((v161 & 1) != 0)
    {
      (*(void (**)(char *, uint64_t))(v170 + 8))(v171, v61);
      v167(v168, v64);
      v167(v221, v64);
      goto LABEL_33;
    }

    char v186 = v167;
    uint64_t v79 = v217;
    char v187 = v208;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v217 + 96))(v168, v64, v222, v61, v217);
    char v188 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v79 + 32) + 8LL) + 16LL))( v187,  v171,  v61);
    uint64_t v189 = *(void (**)(char *, uint64_t))(v170 + 8);
    uint64_t v190 = v187;
    uint64_t v80 = v214;
    v189(v190, v61);
    v189(v171, v61);
    uint64_t v77 = v186;
    if ((v188 & 1) != 0) {
      goto LABEL_32;
    }
  }

  else
  {
    uint64_t v69 = v222;
    uint64_t v70 = v210;
    uint64_t v71 = v217;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v222 + 96))(v59, v61, v217, v64, v222);
    uint64_t v72 = *(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v69 + 32) + 8LL) + 16LL);
    uint64_t v73 = v64;
    uint64_t v74 = v193;
    char v75 = v72(v193, v70, v73);
    uint64_t v76 = v70;
    uint64_t v77 = v220;
    v220(v76, v73);
    uint64_t v78 = v74;
    uint64_t v64 = v73;
    uint64_t v79 = v71;
    v77((char *)v78, v64);
    uint64_t v80 = v214;
    if ((v75 & 1) != 0) {
      goto LABEL_32;
    }
  }

uint64_t BinaryInteger.advanced(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 64))(v11, v10);
  if ((v12 & 1) == 0)
  {
    if (a1 < 0)
    {
      uint64_t v30 = -a1;
      uint64_t v27 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 88);
      unint64_t v28 = lazy protocol witness table accessor for type UInt and conformance UInt(v12, v13, v14);
      v27(&v30, &type metadata for UInt, v28, a2, a3);
      (*(void (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 24) + 8LL) + 40LL))(v3, v9, a2);
      return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, a2);
    }

    uint64_t v30 = a1;
    uint64_t v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 88);
    unint64_t v25 = lazy protocol witness table accessor for type UInt and conformance UInt(v12, v13, v14);
    uint64_t v26 = &type metadata for UInt;
LABEL_8:
    v24(&v30, v26, v25, a2, a3);
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 24) + 8LL) + 24LL))(v3, v9, a2);
    return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, a2);
  }

  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3);
  if (v15 > 63)
  {
    uint64_t v30 = a1;
    uint64_t v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v25 = lazy protocol witness table accessor for type Int and conformance Int(v15, v16, v17);
    uint64_t v26 = &type metadata for Int;
    goto LABEL_8;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, v3, a2);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v9, a2);
  if (__OFADD__(v18, a1))
  {
    __break(1u);
  }

  else
  {
    uint64_t v30 = v18 + a1;
    uint64_t v22 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 88);
    unint64_t v23 = lazy protocol witness table accessor for type Int and conformance Int(result, v20, v21);
    return v22(&v30, &type metadata for Int, v23, a2, a3);
  }

  return result;
}

uint64_t FixedWidthInteger.bitWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

BOOL static BinaryInteger.!= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(void))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))() & 1) == 0;
}

BOOL static BinaryInteger.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))(a2, a1) & 1) == 0;
}

BOOL static BinaryInteger.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(void))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))() & 1) == 0;
}

uint64_t static BinaryInteger.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))(a2, a1) & 1;
}

uint64_t specialized FixedWidthInteger.multipliedFullWidth(by:)( _OWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5 = (a5 * (unsigned __int128)a2) >> 64;
  if (__CFADD__((__PAIR128__(a5, a4) * a2) >> 64, a4 * a3)) {
    uint64_t v6 = ((a4 * (unsigned __int128)a3) >> 64) + 1;
  }
  else {
    uint64_t v6 = (a4 * (unsigned __int128)a3) >> 64;
  }
  *a1 = __PAIR128__(a3, a2) * __PAIR128__(a5, a4);
  return v5 + a5 * a3 + v6;
}

uint64_t specialized FixedWidthInteger.multipliedFullWidth(by:)( _OWORD *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  *a1 = __PAIR128__(a3, a2) * __PAIR128__(a5, a4);
  return (a5 >> 63) * a2
       + __CFADD__((a4 * (unsigned __int128)a2) >> 64, a5 * a2)
       + (((unint64_t)a5 * (unsigned __int128)a2) >> 64)
       + a5 * a3
       + a4 * (a3 >> 63)
       + __CFADD__((__PAIR128__(a5, a4) * a2) >> 64, a4 * a3)
       + ((a4 * (unsigned __int128)(unint64_t)a3) >> 64);
}

uint64_t FixedWidthInteger.multipliedFullWidth(by:)( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v6 = v5;
  uint64_t v100 = a2;
  uint64_t v98 = a1;
  uint64_t v115 = a5[1];
  unsigned __int8 v116 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v115 + 24),  a4,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  uint64_t v103 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = v103;
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v99 = (uint64_t)&v91 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  char v106 = (void (*)(char *, unint64_t *, const char *))((char *)&v91 - v14);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v117 = (void (*)(char *, unint64_t *, const char *))((char *)&v91 - v16);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v109 = (uint64_t *)((char *)&v91 - v18);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v108 = (uint64_t)&v91 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v23 = (char *)&v91 - v22;
  uint64_t v112 = *(void *)(a4 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v97 = (void (*)(char *, unint64_t *, const char *))((char *)&v91
                                                                      - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v96 = (void (*)(char *, unint64_t *, const char *))((char *)&v91 - v27);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v95 = (void (*)(char *, unint64_t *, const char *))((char *)&v91 - v29);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v32 = (char *)&v91 - v31;
  uint64_t v33 = MEMORY[0x1895F8858](v30);
  uint64_t v113 = (char *)&v91 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v114 = (uint64_t *)((char *)&v91 - v36);
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v39 = (void (*)(char *, unint64_t *, const char *))((char *)&v91 - v38);
  char v105 = (char *)&v91 - v38;
  MEMORY[0x1895F8858](v37);
  uint64_t v41 = (char *)&v91 - v40;
  uint64_t v107 = (char *)&v91 - v40;
  uint64_t v111 = v23;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( (void (*)(char *, unint64_t *, const char *))((char *)&v91 - v40),  (uint64_t)v23,  v6,  a4,  a4,  (uint64_t)a5,  (uint64_t)a5);
  uint64_t v42 = v39;
  uint64_t v43 = v108;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( v42,  v108,  (void (*)(void, void))v116,  a4,  a4,  (uint64_t)a5,  (uint64_t)a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  uint64_t v44 = AssociatedTypeWitness;
  (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 232))( v23,  v43,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  char v94 = *(void (**)(void, uint64_t, unint64_t))(v10 + 16);
  uint64_t v45 = v117;
  v94(v117, v43, AssociatedTypeWitness);
  uint64_t v46 = v115;
  uint64_t v101 = *(void (**)(void (*)(char *, unint64_t *, const char *), uint64_t, void *, uint64_t, uint64_t))(v115 + 88);
  uint64_t v47 = v101;
  uint64_t v48 = (void *)swift_getAssociatedConformanceWitness( v115,  a4,  v44,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  unsigned __int8 v116 = v48;
  v47(v45, v44, v48, a4, v46);
  uint64_t v104 = (void (*)(char *, char *, uint64_t, void *))a5[29];
  char v49 = v113;
  uint64_t v50 = v32;
  v104(v41, v32, a4, a5);
  uint64_t v51 = *(void (**)(char *, uint64_t))(v112 + 8);
  v51(v32, a4);
  uint64_t v52 = v117;
  uint64_t v53 = (uint64_t)v106;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( v117,  (uint64_t)v106,  (void (*)(void, void))v109,  a4,  v44,  (uint64_t)a5,  AssociatedConformanceWitness);
  uint64_t v103 = *(void *)(v103 + 8);
  ((void (*)(uint64_t, uint64_t))v103)(v53, v44);
  char v102 = v50;
  uint64_t v54 = v52;
  uint64_t v55 = v101;
  v101(v54, v44, v48, a4, v46);
  int v93 = (void (*)(void (*)(char *, unint64_t *, const char *), void (*)(char *, unint64_t *, const char *), uint64_t, void *))a5[10];
  uint64_t v56 = (void (*)(void, void))v114;
  v93( (void (*)(char *, unint64_t *, const char *))v114,  (void (*)(char *, unint64_t *, const char *))v50,  a4,  a5);
  v51(v50, a4);
  v51(v49, a4);
  uint64_t v57 = v117;
  uint64_t v92 = v44;
  v94(v117, (uint64_t)v111, v44);
  uint64_t v58 = v95;
  uint64_t v59 = v115;
  v55(v57, v44, v116, a4, v115);
  uint64_t v60 = v102;
  uint64_t v61 = v105;
  v104((char *)v58, v105, a4, a5);
  v51((char *)v58, a4);
  int v62 = v96;
  uint64_t v63 = v117;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( v96,  (uint64_t)v117,  v56,  a4,  a4,  (uint64_t)a5,  (uint64_t)a5);
  v51((char *)v62, a4);
  uint64_t v64 = v92;
  v101(v63, v92, v116, a4, v59);
  uint64_t v65 = v60;
  char v66 = v93;
  v93((void (*)(char *, unint64_t *, const char *))v113, v58, a4, a5);
  v51((char *)v58, a4);
  v51(v65, a4);
  v104(v107, v61, a4, a5);
  uint64_t v67 = v97;
  uint64_t v68 = v117;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( v97,  (uint64_t)v117,  (void (*)(void, void))v114,  a4,  a4,  (uint64_t)a5,  (uint64_t)a5);
  uint64_t v69 = v64;
  uint64_t v70 = v64;
  uint64_t v71 = (void (*)(void (*)(char *, unint64_t *, const char *), uint64_t))v103;
  ((void (*)(void (*)(char *, unint64_t *, const char *), uint64_t))v103)(v68, v69);
  v66(v58, v67, a4, a5);
  v51((char *)v67, a4);
  v51((char *)v62, a4);
  uint64_t v72 = v62;
  uint64_t v73 = v62;
  uint64_t v74 = v117;
  char v75 = v113;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( v72,  (uint64_t)v117,  (void (*)(void, void))v113,  a4,  a4,  (uint64_t)a5,  (uint64_t)a5);
  v71(v74, v70);
  uint64_t v76 = v102;
  v66((void (*)(char *, unint64_t *, const char *))v102, v73, a4, a5);
  v51((char *)v73, a4);
  v51((char *)v58, a4);
  (*(void (**)(uint64_t, char *, uint64_t))(v112 + 16))(v98, v76, a4);
  uint64_t v77 = v106;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( v58,  (uint64_t)v106,  (void (*)(void, void))v75,  a4,  a4,  (uint64_t)a5,  (uint64_t)a5);
  v51((char *)v58, a4);
  uint64_t v78 = (*(uint64_t (**)(uint64_t))(v115 + 128))(a4);
  v51(v76, a4);
  v51(v75, a4);
  v51((char *)v114, a4);
  uint64_t v79 = (void (*)(char *, uint64_t))v103;
  ((void (*)(uint64_t, uint64_t))v103)(v108, v70);
  v51(v105, a4);
  v79(v111, v70);
  uint64_t v80 = ((uint64_t (*)(char *, uint64_t))v51)(v107, a4);
  if (v78 >= 0) {
    uint64_t v83 = v78;
  }
  else {
    uint64_t v83 = v78 + 1;
  }
  uint64_t v118 = v83 >> 1;
  uint64_t v84 = v116;
  uint64_t v85 = (void (*)(void (*)(char *, unint64_t *, const char *), uint64_t *, ValueMetadata *, unint64_t, uint64_t, void *))v116[32];
  unint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
  char v87 = v117;
  v85(v77, &v118, &type metadata for Int, v86, v70, v84);
  v79((char *)v77, v70);
  uint64_t v88 = v99;
  char v89 = (char *)v109;
  split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( v77,  v99,  (void (*)(void, void))v109,  a4,  v70,  (uint64_t)a5,  AssociatedConformanceWitness);
  v79((char *)v77, v70);
  v79(v89, v70);
  ((void (*)(void (*)(char *, unint64_t *, const char *), uint64_t, uint64_t, void *))v84[26])( v87,  v88,  v70,  v84);
  v79((char *)v88, v70);
  return ((uint64_t (*)(void (*)(char *, unint64_t *, const char *), uint64_t))v79)(v87, v70);
}

uint64_t FixedWidthInteger.init(bigEndian:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return FixedWidthInteger.init(bigEndian:)(a1, a2, a3);
}

{
  (*(void (**)(uint64_t, uint64_t))(a3 + 192))(a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(a1, a2);
}

uint64_t FixedWidthInteger.bigEndian.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 192))();
}

uint64_t static FixedWidthInteger.&>> infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 208))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 208))(a5, a2, a3, a4);
}

uint64_t static FixedWidthInteger.&>>= infix(_:_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v18 - v12;
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v18 - v14;
  (*(void (**)(char *))(v7 + 16))(v10);
  (*(void (**)(char *, uint64_t, void, uint64_t, void))(*(void *)(a4 + 8) + 96LL))( v10,  a3,  *(void *)(a4 + 8),  a3,  *(void *)(a4 + 8));
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a4 + 200))(a1, v13, a3, a4);
  uint64_t v16 = *(void (**)(char *, uint64_t))(v7 + 8);
  v16(a1, a3);
  v16(v13, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v7 + 32))(a1, v15, a3);
}

uint64_t static FixedWidthInteger.&>>= infix<A>(_:_:)( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v24 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v11);
  uint64_t v18 = (char *)&v24 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v24 - v19;
  (*(void (**)(char *))(v21 + 16))(v13);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a5 + 8) + 96LL))(v13, a4, a6, a3);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 200))(a1, v18, a3, a5);
  uint64_t v22 = *(void (**)(char *, uint64_t))(v15 + 8);
  v22(a1, a3);
  v22(v18, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v15 + 32))(a1, v20, a3);
}

uint64_t static FixedWidthInteger.&<< infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 224))(a5, a2, a3, a4);
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 224))(a5, a2, a3, a4);
}

uint64_t static FixedWidthInteger.&<<= infix(_:_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v18 - v12;
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v18 - v14;
  (*(void (**)(char *))(v7 + 16))(v10);
  (*(void (**)(char *, uint64_t, void, uint64_t, void))(*(void *)(a4 + 8) + 96LL))( v10,  a3,  *(void *)(a4 + 8),  a3,  *(void *)(a4 + 8));
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a4 + 216))(a1, v13, a3, a4);
  uint64_t v16 = *(void (**)(char *, uint64_t))(v7 + 8);
  v16(a1, a3);
  v16(v13, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v7 + 32))(a1, v15, a3);
}

uint64_t static FixedWidthInteger.&<<= infix<A>(_:_:)( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v24 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v11);
  uint64_t v18 = (char *)&v24 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v24 - v19;
  (*(void (**)(char *))(v21 + 16))(v13);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a5 + 8) + 96LL))(v13, a4, a6, a3);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a5 + 216))(a1, v18, a3, a5);
  uint64_t v22 = *(void (**)(char *, uint64_t))(v15 + 8);
  v22(a1, a3);
  v22(v18, a3);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v15 + 32))(a1, v20, a3);
}

uint64_t split #1 <A><A1>(_:) in FixedWidthInteger.multipliedFullWidth(by:)( void (*a1)(char *, unint64_t *, const char *), uint64_t a2, void (*a3)(void, void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v53 = a1;
  uint64_t v54 = a3;
  uint64_t v59 = a2;
  uint64_t v9 = *(void *)(a7 + 8);
  uint64_t v10 = *(const char **)(v9 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a5,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  uint64_t v61 = *(const char **)(swift_getAssociatedConformanceWitness( (uint64_t)v10,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)
                       + 16);
  unint64_t v60 = swift_getAssociatedTypeWitness( 0LL,  v61,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](v60);
  uint64_t v56 = (char *)&v47 - v13;
  uint64_t v14 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v47 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v57 = *(v17 - 1);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v52 = (char *)&v47 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v47 - v21;
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v55 = (char *)&v47 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v58 = (char *)&v47 - v26;
  MEMORY[0x1895F8858](v25);
  uint64_t v50 = a7;
  uint64_t v51 = (char *)&v47 - v27;
  uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 56))(a5, a7);
  if (v28 >= 0) {
    uint64_t v31 = v28;
  }
  else {
    uint64_t v31 = v28 + 1;
  }
  uint64_t v49 = v31 >> 1;
  uint64_t v62 = v31 >> 1;
  uint64_t v32 = *(void (**)(void (*)(void, void), uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v9 + 240);
  unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v28, v29, v30);
  uint64_t v33 = v54;
  v32(v54, &v62, &type metadata for Int, v48, a5, v9);
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v14 + 16))(v16, v33, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a5,  (uint64_t)v17,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v35 = *(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                              + 96);
  v35(v16, a5, v9, v17, AssociatedConformanceWitness);
  unint64_t v36 = v60;
  uint64_t v37 = v61;
  unint64_t v38 = swift_getAssociatedConformanceWitness( (uint64_t)v61,  (uint64_t)v17,  v60,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v54 = *(void (**)(void, void))(v38 + 8);
  uint64_t v39 = v56;
  ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v54)(&qword_18180BE70, 512LL, v36, v38);
  uint64_t v53 = (void (*)(char *, unint64_t *, const char *))*((void *)v37 + 3);
  v53(v39, v17, v37);
  uint64_t v62 = v49;
  uint64_t v40 = v52;
  v35((char *)&v62, (uint64_t)&type metadata for Int, v48, v17, AssociatedConformanceWitness);
  unint64_t v41 = swift_getAssociatedConformanceWitness( v50,  a5,  (uint64_t)v17,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  uint64_t v42 = v55;
  (*(void (**)(char *, char *, unint64_t *, unint64_t))(v41 + 216))(v22, v40, v17, v41);
  uint64_t v43 = *(void (**)(char *, unint64_t *))(v57 + 8);
  v43(v40, v17);
  v43(v22, v17);
  v54(&qword_18180BE70, 512LL);
  v53(v39, v17, v61);
  uint64_t v44 = v58;
  (*(void (**)(char *, char *, unint64_t *, unint64_t))(v41 + 88))(v58, v22, v17, v41);
  v43(v22, v17);
  v43(v42, v17);
  uint64_t v45 = v51;
  (*(void (**)(char *, char *, unint64_t *, unint64_t))(AssociatedConformanceWitness + 192))( v51,  v44,  v17,  AssociatedConformanceWitness);
  v43(v44, v17);
  return ((uint64_t (*)(char *, unint64_t *))v43)(v45, v17);
}

uint64_t static FixedWidthInteger.&>> infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v20 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v17 = (char *)&v20 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v18 + 16))(v13);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a5 + 8) + 96LL))(v13, a4, a6, a3);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 200))(a1, v17, a3, a5);
  return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v17, a3);
}

uint64_t specialized RandomNumberGenerator.next<A>(upperBound:)(unint64_t a1)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "upperBound cannot be zero.",  26LL,  2,  "Swift/Random.swift",  18LL,  2,  0x6AuLL,  0);
  }
  unint64_t __buf = 0LL;
  swift_stdlib_random(&__buf, 8uLL);
  uint64_t result = (__buf * (unsigned __int128)a1) >> 64;
  if (__buf * a1 < a1)
  {
    unint64_t v3 = -(uint64_t)a1 % a1;
    if (v3 > __buf * a1)
    {
      do
      {
        unint64_t __buf = 0LL;
        swift_stdlib_random(&__buf, 8uLL);
      }

      while (v3 > __buf * a1);
      return (__buf * (unsigned __int128)a1) >> 64;
    }
  }

  return result;
}

uint64_t specialized RandomNumberGenerator.next<A>(upperBound:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "upperBound cannot be zero.",  26LL,  2,  "Swift/Random.swift",  18LL,  2,  0x6AuLL,  0);
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 8);
  uint64_t v7 = v6(a2, a3);
  unint64_t v8 = v7 * a1;
  uint64_t result = ((unint64_t)v7 * (unsigned __int128)a1) >> 64;
  if (v8 < a1)
  {
    unint64_t v10 = -(uint64_t)a1 % a1;
    if (v10 > v8)
    {
      do
        uint64_t v11 = v6(a2, a3);
      while (v10 > v11 * a1);
      return ((unint64_t)v11 * (unsigned __int128)a1) >> 64;
    }
  }

  return result;
}

uint64_t specialized RandomNumberGenerator.next<A>(upperBound:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v179 = a4;
  uint64_t v209 = a3;
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t v7 = *(void *)(v6 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t v191 = *(const char **)(swift_getAssociatedConformanceWitness( v7,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)
                        + 16);
  unint64_t v190 = swift_getAssociatedTypeWitness( 0LL,  v191,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v190);
  uint64_t v189 = (char *)&v177 - v9;
  uint64_t v197 = v7;
  uint64_t v195 = *(const char **)(v7 + 16);
  unint64_t v194 = swift_getAssociatedTypeWitness( 0LL,  v195,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v194);
  uint64_t v193 = (char *)&v177 - v10;
  uint64_t v11 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v196 = *(v11 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v177 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unint64_t v182 = (char *)&v177 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  char v188 = (char *)&v177 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  char v187 = (char *)&v177 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  char v215 = (char *)&v177 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  v213 = (char *)&v177 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v200 = (char *)&v177 - v25;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a2, (uint64_t)v11, "high low ", 0LL);
  uint64_t v184 = *(TupleTypeMetadata2 - 1);
  uint64_t v26 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v211 = (char *)&v177 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v214 = (char *)&v177 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v32 = (char *)&v177 - v31;
  uint64_t v33 = MEMORY[0x1895F8858](v30);
  uint64_t v181 = (char *)&v177 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  char v186 = (char *)&v177 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  char v185 = (char *)&v177 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  unint64_t v41 = (char *)&v177 - v40;
  uint64_t v42 = MEMORY[0x1895F8858](v39);
  unint64_t v212 = (char *)&v177 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  uint64_t v205 = (uint64_t)&v177 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  unint64_t v48 = (char *)&v177 - v47;
  MEMORY[0x1895F8858](v46);
  uint64_t v50 = (char *)&v177 - v49;
  uint64_t v206 = v51;
  uint64_t v52 = *(void (**)(char *, char *, uint64_t))(v51 + 16);
  uint64_t v210 = a1;
  uint64_t v198 = v52;
  v52((char *)&v177 - v49, a1, a2);
  uint64_t v53 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 64);
  char v54 = v53(a2, v6);
  uint64_t v208 = v53;
  uint64_t v178 = v41;
  char v183 = v14;
  uint64_t v177 = v32;
  if ((v54 & 1) != 0)
  {
    uint64_t v207 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 128);
    uint64_t v55 = v207(a2, v6);
    if (v55 >= 64)
    {
LABEL_12:
      uint64_t v216 = 0LL;
      uint64_t v69 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
      unint64_t v70 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
      v69(&v216, &type metadata for Int, v70, a2, v6);
      char v71 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 16) + 8LL) + 8LL))( v50,  v48,  a2);
      uint64_t v64 = *(void (**)(char *, uint64_t))(v206 + 8);
      v64(v48, a2);
      uint64_t v67 = v210;
      uint64_t v68 = TupleTypeMetadata2;
      if ((v71 & 1) == 0) {
        goto LABEL_13;
      }
LABEL_57:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "upperBound cannot be zero.",  26LL,  2,  "Swift/Random.swift",  18LL,  2,  0x6AuLL,  0);
    }

    goto LABEL_9;
  }

  char v58 = v53(a2, v6);
  uint64_t v207 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 128);
  uint64_t v55 = v207(a2, v6);
  if ((v58 & 1) == 0)
  {
    if (v55 >= 64) {
      goto LABEL_12;
    }
LABEL_9:
    v198(v48, v50, a2);
    uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 120))(a2, v6);
    uint64_t v64 = *(void (**)(char *, uint64_t))(v206 + 8);
    char v66 = v48;
LABEL_10:
    v64(v66, a2);
    uint64_t v67 = v210;
    uint64_t v68 = TupleTypeMetadata2;
    if (v65) {
      goto LABEL_13;
    }
    goto LABEL_57;
  }

  if (v55 > 64) {
    goto LABEL_12;
  }
  uint64_t v59 = v214;
  unint64_t v60 = v195;
  unint64_t v61 = v194;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v195,  a2,  v194,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v63 = v193;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v61,  AssociatedConformanceWitness);
  (*((void (**)(char *, uint64_t, const char *))v60 + 3))(v63, a2, v60);
  LOBYTE(v61) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8LL) + 32LL))( v50,  v48,  a2);
  uint64_t v64 = *(void (**)(char *, uint64_t))(v206 + 8);
  v64(v48, a2);
  v198(v59, v50, a2);
  if ((v61 & 1) != 0)
  {
    uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 120))(a2, v6);
    char v66 = v59;
    goto LABEL_10;
  }

  v64(v59, a2);
  uint64_t v67 = v210;
  uint64_t v68 = TupleTypeMetadata2;
LABEL_13:
  v64(v50, a2);
  uint64_t v72 = v205;
  uint64_t v73 = v209;
  specialized static FixedWidthInteger._random<A>(using:)(a2, v209, v205);
  uint64_t v74 = &v211[*((int *)v68 + 12)];
  char v199 = *(void (**)(void))(v73 + 120);
  v199();
  uint64_t v214 = (char *)v64;
  v64((char *)v72, a2);
  char v75 = v200;
  unint64_t v203 = *(void (**)(char *, char *, unint64_t *))(v196 + 16);
  unint64_t v204 = v74;
  v203(v200, v74, v11);
  unint64_t v76 = swift_getAssociatedConformanceWitness( v6,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v77 = *(uint64_t (**)(unint64_t *, unint64_t))(v76 + 64);
  uint64_t v78 = v67;
  int v79 = v77(v11, v76);
  int v80 = v208(a2, v6);
  uint64_t v202 = v77;
  if (((v79 ^ v80) & 1) == 0)
  {
    unint64_t v201 = *(uint64_t (**)(unint64_t *, unint64_t))(v76 + 128);
    uint64_t v87 = v201(v11, v76);
    uint64_t v88 = v78;
    if (v87 >= v207(a2, v6))
    {
      v198(v48, v78, a2);
      uint64_t v84 = v213;
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v76 + 96))( v48,  a2,  v6,  v11,  v76);
      unint64_t v91 = swift_getAssociatedConformanceWitness( v197,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      char v86 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v91 + 16))( v75,  v84,  v11,  v91);
      goto LABEL_23;
    }

    (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v6 + 96))( v75,  v11,  v76,  a2,  v6);
    char v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v48,  v78,  a2);
    goto LABEL_21;
  }

  char v81 = v77(v11, v76);
  unint64_t v201 = *(uint64_t (**)(unint64_t *, unint64_t))(v76 + 128);
  uint64_t v82 = v201(v11, v76);
  uint64_t v83 = v207(a2, v6);
  if ((v81 & 1) == 0)
  {
    if (v82 >= v83)
    {
      char v106 = v195;
      unint64_t v107 = v194;
      unint64_t v108 = swift_getAssociatedConformanceWitness( (uint64_t)v195,  a2,  v194,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v109 = v193;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v108 + 8))( &unk_18180BE68,  256LL,  v107,  v108);
      (*((void (**)(char *, uint64_t, const char *))v106 + 3))(v109, a2, v106);
      uint64_t v110 = v210;
      LOBYTE(v107) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8LL) + 40LL))( v210,  v48,  a2);
      uint64_t v111 = (void (*)(char *, uint64_t))v214;
      ((void (*)(char *, uint64_t))v214)(v48, a2);
      uint64_t v112 = v183;
      (*(void (**)(char *, char *, unint64_t *))(v196 + 32))(v183, v200, v11);
      uint64_t v113 = v177;
      v198(v177, v110, a2);
      if ((v107 & 1) == 0)
      {
        v111(v113, a2);
        (*(void (**)(char *, unint64_t *))(v196 + 8))(v112, v11);
        goto LABEL_55;
      }

      uint64_t v114 = v213;
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v76 + 96))( v113,  a2,  v6,  v11,  v76);
      unint64_t v115 = swift_getAssociatedConformanceWitness( v197,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      unsigned __int8 v116 = v114;
      char v90 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v115 + 16))( v112,  v114,  v11,  v115);
      uint64_t v117 = *(void (**)(char *, unint64_t *))(v196 + 8);
      v117(v116, v11);
      v117(v112, v11);
      goto LABEL_30;
    }

    (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v6 + 96))( v75,  v11,  v76,  a2,  v6);
    uint64_t v88 = v210;
    char v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v48,  v210,  a2);
LABEL_21:
    char v90 = v89;
    ((void (*)(char *, uint64_t))v214)(v48, a2);
    goto LABEL_31;
  }

  if (v83 < v82)
  {
    uint64_t v78 = v210;
    v198(v48, v210, a2);
    uint64_t v84 = v213;
    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v76 + 96))( v48,  a2,  v6,  v11,  v76);
    unint64_t v85 = swift_getAssociatedConformanceWitness( v197,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v75 = v200;
    char v86 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v85 + 16))( v200,  v84,  v11,  v85);
LABEL_23:
    char v90 = v86;
    uint64_t v92 = *(void (**)(char *, unint64_t *))(v196 + 8);
    v92(v84, v11);
    v92(v75, v11);
    uint64_t v88 = v78;
    goto LABEL_31;
  }

  int v93 = v191;
  unint64_t v94 = v190;
  unint64_t v95 = swift_getAssociatedConformanceWitness( (uint64_t)v191,  (uint64_t)v11,  v190,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v96 = v189;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v95 + 8))( &unk_18180BE68,  256LL,  v94,  v95);
  uint64_t v97 = v213;
  uint64_t v98 = v96;
  uint64_t v99 = v196;
  (*((void (**)(char *, unint64_t *, const char *))v93 + 3))(v98, v11, v93);
  unint64_t v100 = swift_getAssociatedConformanceWitness( v197,  a2,  (uint64_t)v11,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  uint64_t v101 = v200;
  LOBYTE(v94) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v100 + 16))( v200,  v97,  v11,  v100);
  char v102 = *(void (**)(char *, unint64_t *))(v99 + 8);
  v102(v97, v11);
  uint64_t v103 = *(void (**)(char *, char *, unint64_t *))(v99 + 32);
  uint64_t v104 = v182;
  v103(v182, v101, v11);
  char v105 = v181;
  v198(v181, v210, a2);
  if ((v94 & 1) == 0)
  {
    (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v6 + 96))( v104,  v11,  v76,  a2,  v6);
    char v90 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v48,  v105,  a2);
    uint64_t v118 = (void (*)(char *, uint64_t))v214;
    ((void (*)(char *, uint64_t))v214)(v48, a2);
    v118(v105, a2);
LABEL_30:
    uint64_t v88 = v210;
LABEL_31:
    int v119 = TupleTypeMetadata2;
    uint64_t v120 = v184;
    if ((v90 & 1) == 0) {
      goto LABEL_56;
    }
    goto LABEL_32;
  }

  ((void (*)(char *, uint64_t))v214)(v105, a2);
  v102(v104, v11);
  uint64_t v88 = v210;
LABEL_32:
  uint64_t v121 = v88;
  uint64_t v122 = v195;
  unint64_t v123 = v194;
  unint64_t v124 = swift_getAssociatedConformanceWitness( (uint64_t)v195,  a2,  v194,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v125 = *(char **)(v124 + 8);
  char v126 = v193;
  char v183 = (char *)v124;
  unint64_t v182 = v125;
  ((void (*)(void *, uint64_t, unint64_t))v125)(&unk_18180BE68, 256LL, v123);
  uint64_t v127 = (char *)*((void *)v122 + 3);
  unint64_t v128 = v178;
  char v129 = v122;
  uint64_t v130 = v196;
  uint64_t v181 = v127;
  ((void (*)(char *, uint64_t, const char *))v127)(v126, a2, v129);
  (*(void (**)(char *, char *, uint64_t))(v209 + 88))(v48, v121, a2);
  uint64_t v131 = v128;
  BOOL v132 = (void (*)(char *, uint64_t))v214;
  ((void (*)(char *, uint64_t))v214)(v131, a2);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(v6 + 168))(v48, v121, a2, v6);
  v132(v48, a2);
  uint64_t v200 = (char *)v6;
  uint64_t v133 = v204;
  char v180 = v48;
  while (1)
  {
    unint64_t v140 = v215;
    v203(v215, v133, v11);
    unint64_t v141 = v202;
    int v142 = v202(v11, v76);
    if (((v142 ^ v208(a2, v6)) & 1) == 0)
    {
      uint64_t v146 = v201(v11, v76);
      uint64_t v144 = v212;
      if (v146 >= v207(a2, v6))
      {
        v198(v48, v144, a2);
        uint64_t v134 = v6;
        uint64_t v135 = v213;
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v76 + 96))( v48,  a2,  v134,  v11,  v76);
        goto LABEL_34;
      }

uint64_t RandomNumberGenerator.next<A>(upperBound:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char *a6@<X8>)
{
  uint64_t v231 = a4;
  uint64_t v230 = a2;
  unint64_t v203 = a6;
  uint64_t v235 = a5;
  uint64_t v8 = *(void *)(a5 + 8);
  uint64_t v9 = *(void *)(v8 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  v213 = *(const char **)(swift_getAssociatedConformanceWitness( v9,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)
                        + 16);
  unint64_t v212 = swift_getAssociatedTypeWitness( 0LL,  v213,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v212);
  unint64_t v211 = (char *)&v198 - v11;
  uint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v239 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v209 = (char *)&v198 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v217 = (char *)&v198 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v240 = (char *)&v198 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v205 = (char *)&v198 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  unint64_t v204 = (char *)&v198 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v25 = (char *)&v198 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v206 = (char *)&v198 - v26;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, (uint64_t)v12, "high low ", 0LL);
  uint64_t v202 = *(TupleTypeMetadata2 - 1);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v236 = (char *)&v198 - v27;
  uint64_t v220 = v9;
  uint64_t v216 = *(const char **)(v9 + 16);
  unint64_t v215 = swift_getAssociatedTypeWitness( 0LL,  v216,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v28 = MEMORY[0x1895F8858](v215);
  uint64_t v214 = (char *)&v198 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v208 = (char *)&v198 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v207 = (char *)&v198 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v198 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  uint64_t v219 = (char *)&v198 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  char v199 = (char *)&v198 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v200 = (char *)&v198 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  uint64_t v229 = (uint64_t)&v198 - v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  uint64_t v238 = (char *)&v198 - v46;
  uint64_t v47 = MEMORY[0x1895F8858](v45);
  uint64_t v49 = (char *)&v198 - v48;
  MEMORY[0x1895F8858](v47);
  uint64_t v51 = (char *)&v198 - v50;
  uint64_t v233 = v52;
  uint64_t v53 = *(void (**)(char *, char *, uint64_t))(v52 + 16);
  Swift::String::Index v237 = a1;
  uint64_t v221 = v53;
  v53((char *)&v198 - v50, a1, a3);
  char v54 = *(unsigned int (**)(uint64_t, uint64_t))(v8 + 64);
  uint64_t v241 = v8;
  char v55 = v54(a3, v8);
  unint64_t v228 = v54;
  unint64_t v201 = v36;
  if ((v55 & 1) != 0)
  {
    uint64_t v234 = *(uint64_t (**)(uint64_t))(v241 + 128);
    uint64_t v56 = v234(a3);
    if (v56 < 64)
    {
      v221(v49, v51, a3);
      uint64_t v59 = (*(uint64_t (**)(uint64_t))(v241 + 120))(a3);
      unint64_t v60 = *(void (**)(char *, uint64_t))(v233 + 8);
      v60(v49, a3);
      unint64_t v61 = v236;
      if (!v59) {
        goto LABEL_19;
      }
      goto LABEL_21;
    }

    uint64_t v242 = 0LL;
    uint64_t v72 = v241;
    uint64_t v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v241 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
    v73(&v242, &type metadata for Int, v74, a3, v72);
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v72 + 16) + 8LL) + 8LL))( v51,  v49,  a3);
    unint64_t v60 = *(void (**)(char *, uint64_t))(v233 + 8);
    v60(v49, a3);
    unint64_t v61 = v236;
    if ((v75 & 1) != 0) {
LABEL_19:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "upperBound cannot be zero.",  26LL,  2,  "Swift/Random.swift",  18LL,  2,  0x6AuLL,  0);
  }

  else
  {
    uint64_t v62 = v241;
    char v63 = v54(a3, v241);
    uint64_t v234 = *(uint64_t (**)(uint64_t))(v62 + 128);
    uint64_t v64 = ((uint64_t (*)(uint64_t, uint64_t))v234)(a3, v62);
    if ((v63 & 1) != 0)
    {
      uint64_t v67 = v236;
      if (v64 <= 64)
      {
        uint64_t v77 = v216;
        unint64_t v78 = v215;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v216,  a3,  v215,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        int v80 = v214;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v78,  AssociatedConformanceWitness);
        (*((void (**)(char *, uint64_t, const char *))v77 + 3))(v80, a3, v77);
        LOBYTE(v78) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v241 + 32) + 8LL)
                                                                         + 32LL))( v51,  v49,  a3);
        unint64_t v60 = *(void (**)(char *, uint64_t))(v233 + 8);
        v60(v49, a3);
        char v81 = v238;
        v221(v238, v51, a3);
        if ((v78 & 1) != 0)
        {
          uint64_t v82 = (*(uint64_t (**)(uint64_t))(v241 + 120))(a3);
          v60(v81, a3);
          unint64_t v61 = v67;
          if (!v82) {
            goto LABEL_19;
          }
        }

        else
        {
          v60(v81, a3);
          unint64_t v61 = v67;
        }
      }

      else
      {
        uint64_t v242 = 0LL;
        uint64_t v68 = v241;
        uint64_t v69 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v241 + 96);
        unint64_t v70 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
        v69(&v242, &type metadata for Int, v70, a3, v68);
        char v71 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 16) + 8LL) + 8LL))( v51,  v49,  a3);
        unint64_t v60 = *(void (**)(char *, uint64_t))(v233 + 8);
        v60(v49, a3);
        unint64_t v61 = v67;
        if ((v71 & 1) != 0) {
          goto LABEL_19;
        }
      }
    }

    else
    {
      unint64_t v61 = v236;
      if (v64 < 64)
      {
        v221(v49, v51, a3);
        uint64_t v76 = (*(uint64_t (**)(uint64_t))(v241 + 120))(a3);
        unint64_t v60 = *(void (**)(char *, uint64_t))(v233 + 8);
        v60(v49, a3);
        if (!v76) {
          goto LABEL_19;
        }
      }

      else
      {
        uint64_t v242 = 0LL;
        uint64_t v83 = v241;
        uint64_t v84 = v236;
        unint64_t v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v241 + 96);
        unint64_t v86 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
        v85(&v242, &type metadata for Int, v86, a3, v83);
        unint64_t v61 = v84;
        char v87 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v83 + 16) + 8LL) + 8LL))( v51,  v49,  a3);
        unint64_t v60 = *(void (**)(char *, uint64_t))(v233 + 8);
        v60(v49, a3);
        if ((v87 & 1) != 0) {
          goto LABEL_19;
        }
      }
    }
  }

uint64_t static FixedWidthInteger.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized static FixedWidthInteger.random<A>(in:using:)(a1, a2, a2, a3);
}

uint64_t specialized static FixedWidthInteger.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v52 = a2;
  uint64_t v53 = a5;
  uint64_t v8 = *(void *)(a4 + 8);
  uint64_t v9 = *(const char **)(v8 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v9,  a3,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v9,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v45 = *(const char **)(AssociatedConformanceWitness + 16);
  unint64_t v43 = swift_getAssociatedTypeWitness( 0LL,  v45,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v43);
  uint64_t v42 = (char *)&v40 - v12;
  uint64_t v44 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v40 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  unint64_t v51 = *(v15 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v48 = (char *)&v40 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v47 = (char *)&v40 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v40 - v21;
  MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v40 - v23;
  type metadata accessor for ClosedRange(0LL, a3, *(void *)(*(void *)(v8 + 32) + 8LL), v25);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(a4 + 88);
  uint64_t v49 = a1;
  v26(v14, a1, a3, a4);
  unint64_t v27 = swift_getAssociatedConformanceWitness( v8,  a3,  (uint64_t)v15,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v40 = *(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v27 + 96);
  uint64_t v41 = v14;
  v40(v14, a3, v8, v15, v27);
  uint64_t v50 = a4;
  unint64_t v28 = swift_getAssociatedConformanceWitness( a4,  a3,  (uint64_t)v15,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  (*(void (**)(unint64_t *, unint64_t))(v28 + 64))(v15, v28);
  unint64_t v29 = swift_getAssociatedConformanceWitness( (uint64_t)v9,  a3,  (uint64_t)v15,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  LOBYTE(AssociatedTypeWitness) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v29 + 8)
                                                                                                + 8LL))( v24,  v22,  v15);
  uint64_t v30 = *(void (**)(char *, unint64_t *))(v51 + 8);
  v30(v22, v15);
  if ((AssociatedTypeWitness & 1) != 0)
  {
    v30(v24, v15);
    specialized static FixedWidthInteger._random<A>(using:)((uint64_t)v15, v28, (uint64_t)v22);
  }

  else
  {
    unint64_t v51 = v27;
    uint64_t v31 = v45;
    unint64_t v32 = v43;
    unint64_t v33 = swift_getAssociatedConformanceWitness( (uint64_t)v45,  (uint64_t)v15,  v43,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v34 = v42;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))( &qword_18180BE70,  512LL,  v32,  v33);
    (*((void (**)(char *, unint64_t *, const char *))v31 + 3))(v34, v15, v31);
    (*(void (**)(char *, char *, unint64_t *))(*(void *)(AssociatedConformanceWitness + 8) + 32LL))( v24,  v22,  v15);
    v30(v22, v15);
    uint64_t v35 = v41;
    (*(void (**)(char *, uint64_t, uint64_t))(v44 + 16))(v41, v49, a3);
    uint64_t v36 = v47;
    v40(v35, a3, v8, v15, v51);
    swift_getAssociatedConformanceWitness( v50,  a3,  (uint64_t)v15,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: UnsignedInteger);
    uint64_t v37 = v48;
    specialized RandomNumberGenerator.next<A>(upperBound:)(v24, (uint64_t)v15, v28, v48);
    v30(v24, v15);
    (*(void (**)(char *, char *, unint64_t *, unint64_t))(v28 + 80))(v22, v37, v15, v28);
    v30(v37, v15);
    uint64_t v38 = v36;
    unint64_t v27 = v51;
    v30(v38, v15);
  }

  return (*(uint64_t (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v8 + 96))( v22,  v15,  v27,  a3,  v8);
}

uint64_t static FixedWidthInteger.random<A>(in:using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v57 = a2;
  uint64_t v58 = a6;
  uint64_t v56 = a4;
  uint64_t v59 = a7;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(const char **)(v10 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v11,  a3,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v11,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric);
  uint64_t v49 = *(const char **)(AssociatedConformanceWitness + 16);
  unint64_t v47 = swift_getAssociatedTypeWitness( 0LL,  v49,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v13 = MEMORY[0x1895F8858](v47);
  uint64_t v46 = (char *)&v44 - v14;
  uint64_t v48 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v44 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  unint64_t v54 = *(v17 - 1);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v52 = (char *)&v44 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v51 = (char *)&v44 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v44 - v23;
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v44 - v25;
  type metadata accessor for ClosedRange(0LL, a3, *(void *)(*(void *)(v10 + 32) + 8LL), v27);
  unint64_t v28 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(a5 + 88);
  uint64_t v53 = a1;
  v28(v16, a1, a3, a5);
  unint64_t v29 = swift_getAssociatedConformanceWitness( v10,  a3,  (uint64_t)v17,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v29 + 96);
  uint64_t v55 = v10;
  uint64_t v45 = v30;
  v30(v16, a3, v10, v17, v29);
  unint64_t v31 = swift_getAssociatedConformanceWitness( a5,  a3,  (uint64_t)v17,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
  (*(void (**)(unint64_t *, unint64_t))(v31 + 64))(v17, v31);
  unint64_t v32 = swift_getAssociatedConformanceWitness( (uint64_t)v11,  a3,  (uint64_t)v17,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  LOBYTE(AssociatedTypeWitness) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v32 + 8)
                                                                                                + 8LL))( v26,  v24,  v17);
  unint64_t v33 = *(void (**)(char *, unint64_t *))(v54 + 8);
  v33(v24, v17);
  if ((AssociatedTypeWitness & 1) != 0)
  {
    v33(v26, v17);
    static FixedWidthInteger._random<A>(using:)(v57, (uint64_t)v17, v56, v31, v58, (uint64_t)v24);
    uint64_t v34 = v55;
  }

  else
  {
    unint64_t v54 = v29;
    uint64_t v35 = v49;
    unint64_t v36 = v47;
    unint64_t v37 = swift_getAssociatedConformanceWitness( (uint64_t)v49,  (uint64_t)v17,  v47,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v38 = v46;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v37 + 8))( &qword_18180BE70,  512LL,  v36,  v37);
    (*((void (**)(char *, unint64_t *, const char *))v35 + 3))(v38, v17, v35);
    (*(void (**)(char *, char *, unint64_t *))(*(void *)(AssociatedConformanceWitness + 8) + 32LL))( v26,  v24,  v17);
    v33(v24, v17);
    (*(void (**)(char *, uint64_t, uint64_t))(v48 + 16))(v16, v53, a3);
    uint64_t v39 = v51;
    uint64_t v40 = v55;
    v45(v16, a3, v55, v17, v54);
    uint64_t v41 = v52;
    RandomNumberGenerator.next<A>(upperBound:)(v26, v56, (uint64_t)v17, v58, v31, v52);
    v33(v26, v17);
    (*(void (**)(char *, char *, unint64_t *, unint64_t))(v31 + 80))(v24, v41, v17, v31);
    v33(v41, v17);
    uint64_t v42 = v39;
    unint64_t v29 = v54;
    v33(v42, v17);
    uint64_t v34 = v40;
  }

  return (*(uint64_t (**)(char *, unint64_t *, unint64_t, uint64_t))(v34 + 96))( v24,  v17,  v29,  a3);
}

uint64_t RandomNumberGenerator.next<A>()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static FixedWidthInteger._random<A>(using:)(v5, a2, a1, a4, a3, a5);
}

uint64_t static FixedWidthInteger.random(in:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return specialized static FixedWidthInteger.random<A>(in:using:)(a1, a2, a2, a3, a4);
}

uint64_t static FixedWidthInteger._nonMaskingRightShiftGeneric<A>(_:_:)( uint64_t a1, void (*a2)(char *, uint64_t, uint64_t), uint64_t a3, void (*a4)(char *, uint64_t), char *a5, uint64_t a6)
{
  uint64_t v229 = a2;
  uint64_t v227 = a1;
  uint64_t v221 = *((void *)a5 + 1);
  uint64_t v220 = *(const char **)(*(void *)(v221 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v220,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v217 = (char *)&v202 - v11;
  uint64_t v219 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v225 = (char *)&v202 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v224 = (char *)&v202 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v226 = (char *)&v202 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v228 = (char *)&v202 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v21 = (uint64_t)&v202 - v20;
  uint64_t v208 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t v207 = swift_getAssociatedTypeWitness( 0LL,  v208,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v22 = MEMORY[0x1895F8858](v207);
  uint64_t v206 = (char *)&v202 - v23;
  uint64_t v24 = *((void *)a4 - 1);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  unint64_t v203 = (char *)&v202 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v209 = (char *)&v202 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v212 = (char *)&v202 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  unint64_t v204 = (char *)&v202 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v210 = (char *)&v202 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  unint64_t v215 = (char *)&v202 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v205 = (char *)&v202 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v41 = (char *)&v202 - v40;
  uint64_t v42 = MEMORY[0x1895F8858](v39);
  uint64_t v44 = (char *)&v202 - v43;
  MEMORY[0x1895F8858](v42);
  uint64_t v46 = (char *)&v202 - v45;
  unint64_t v47 = (uint64_t (*)(uint64_t, char *))*((void *)a5 + 7);
  unint64_t v223 = a5;
  uint64_t v230 = v47;
  uint64_t v48 = v47(a3, a5);
  uint64_t v49 = -v48;
  if (__OFSUB__(0LL, v48))
  {
    __break(1u);
    goto LABEL_82;
  }

  uint64_t v222 = (uint64_t)v46;
  uint64_t v50 = *(uint64_t (**)(void *, uint64_t))(a6 + 64);
  char v51 = v50(a4, a6);
  uint64_t v216 = v21;
  unint64_t v211 = (uint64_t (*)(void, void))v50;
  if ((v51 & 1) == 0)
  {
    char v61 = v50(a4, a6);
    uint64_t v214 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
    uint64_t v62 = v214(a4, a6);
    if ((v61 & 1) == 0)
    {
      uint64_t v56 = v222;
      uint64_t v44 = v223;
      if (v62 >= 64)
      {
        uint64_t v93 = (*(uint64_t (**)(char *, void, void (*)(char *, uint64_t)))(v24 + 16))( v41,  v229,  a4);
        if (v49 <= 0)
        {
          uint64_t v58 = *(void (**)(char *, void *))(v24 + 8);
          v58(v41, a4);
        }

        else
        {
          v232[0] = v49;
          uint64_t v96 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
          unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
          v96(v232, &type metadata for Int, v97, a4, a6);
          char v98 = (*(uint64_t (**)(char *, uint64_t, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                                 + 16LL))( v41,  v56,  a4);
          uint64_t v58 = *(void (**)(char *, void *))(v24 + 8);
          v58((char *)v56, a4);
          v58(v41, a4);
          char v71 = v225;
          if ((v98 & 1) != 0) {
            goto LABEL_28;
          }
        }

uint64_t static FixedWidthInteger.>>= infix<A>(_:_:)( uint64_t a1, void (*a2)(void, void, void), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = a6;
  uint64_t v8 = (void (*)(char *, uint64_t))a4;
  uint64_t v233 = a2;
  uint64_t v236 = a1;
  uint64_t v214 = *(char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v214,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v212 = (char *)&v209 - v10;
  uint64_t v227 = *(void *)(a5 + 8);
  uint64_t v11 = *(const char **)(*(void *)(v227 + 24) + 16LL);
  unint64_t v225 = swift_getAssociatedTypeWitness( 0LL,  v11,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](v225);
  uint64_t v224 = (char *)&v209 - v13;
  uint64_t v226 = *(void *)(a3 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v230 = (char *)&v209 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v229 = (char *)&v209 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v234 = (char *)&v209 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v235 = (char *)&v209 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v223 = (char *)&v209 - v23;
  uint64_t v24 = *((void *)v8 - 1);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (uint64_t)&v209 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v30 = (char *)&v209 - v29;
  uint64_t v31 = MEMORY[0x1895F8858](v28);
  unint64_t v211 = (char *)&v209 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v35 = (char *)&v209 - v34;
  uint64_t v36 = MEMORY[0x1895F8858](v33);
  uint64_t v218 = (char *)&v209 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  uint64_t v217 = (char *)&v209 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  uint64_t v210 = (char *)&v209 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  unint64_t v215 = (char *)&v209 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  uint64_t v221 = (char *)&v209 - v45;
  MEMORY[0x1895F8858](v44);
  uint64_t v232 = (char *)&v209 - v46;
  unint64_t v47 = *(char **)(a5 + 56);
  uint64_t v237 = a5;
  uint64_t v231 = v47;
  uint64_t v48 = ((uint64_t (*)(uint64_t, uint64_t))v47)(a3, a5);
  uint64_t v49 = -v48;
  if (__OFSUB__(0LL, v48))
  {
    __break(1u);
    goto LABEL_85;
  }

  uint64_t v209 = v35;
  uint64_t v50 = *(uint64_t (**)(void *, uint64_t))(v6 + 64);
  char v51 = v50(v8, v6);
  uint64_t v228 = v24;
  uint64_t v222 = v11;
  uint64_t v219 = v50;
  if ((v51 & 1) != 0)
  {
    uint64_t v52 = v233;
    uint64_t v220 = *(uint64_t (**)(void *, uint64_t))(v6 + 128);
    uint64_t v53 = v220(v8, v6);
    if (v53 < 64)
    {
      uint64_t v56 = v228;
      uint64_t v57 = v232;
      (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v228 + 16))(v232, v52, v8);
      uint64_t v58 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
      uint64_t v59 = *(void (**)(char *, void *))(v56 + 8);
      v59(v57, v8);
      BOOL v60 = v58 < v49;
      uint64_t v61 = v237;
      goto LABEL_14;
    }

    v239[0] = v49;
    char v71 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    unint64_t v69 = v232;
    v71(v239, &type metadata for Int, v72, v8, v6);
    char v70 = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                          + 16LL))( v52,  v69,  v8);
    goto LABEL_9;
  }

  char v62 = v50(v8, v6);
  uint64_t v63 = v233;
  uint64_t v220 = *(uint64_t (**)(void *, uint64_t))(v6 + 128);
  uint64_t v64 = v220(v8, v6);
  if ((v62 & 1) == 0)
  {
    uint64_t v73 = v237;
    if (v64 < 64)
    {
      unint64_t v74 = v232;
      (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v24 + 16))(v232, v63, v8);
      uint64_t v75 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
      uint64_t v59 = *(void (**)(char *, void *))(v24 + 8);
      v59(v74, v8);
      BOOL v60 = v75 < v49;
      uint64_t v61 = v73;
LABEL_14:
      uint64_t v30 = v231;
      if (!v60) {
        goto LABEL_15;
      }
      goto LABEL_50;
    }

    uint64_t v97 = (*(uint64_t (**)(uint64_t, void, void (*)(char *, uint64_t)))(v24 + 16))(v27, v63, v8);
    if (v49 <= 0)
    {
      uint64_t v59 = *(void (**)(char *, void *))(v24 + 8);
      v59((char *)v27, v8);
      uint64_t v61 = v73;
      uint64_t v30 = v231;
      goto LABEL_15;
    }

    v239[0] = v49;
    unint64_t v100 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
    unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
    uint64_t v102 = v232;
    v100(v239, &type metadata for Int, v101, v8, v6);
    char v103 = (*(uint64_t (**)(uint64_t, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                            + 16LL))( v27,  v102,  v8);
    uint64_t v104 = v102;
    uint64_t v59 = *(void (**)(char *, void *))(v24 + 8);
    v59(v104, v8);
    v59((char *)v27, v8);
    uint64_t v61 = v73;
    uint64_t v30 = v231;
    if ((v103 & 1) == 0) {
      goto LABEL_15;
    }
LABEL_50:
    uint64_t v96 = ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v61);
    goto LABEL_51;
  }

  if (v64 > 64)
  {
    v239[0] = v49;
    char v67 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
    unint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
    unint64_t v69 = v232;
    v67(v239, &type metadata for Int, v68, v8, v6);
    char v70 = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                          + 16LL))( v63,  v69,  v8);
LABEL_9:
    uint64_t v59 = *(void (**)(char *, void *))(v228 + 8);
    v59(v69, v8);
    uint64_t v61 = v237;
    uint64_t v30 = v231;
    if ((v70 & 1) == 0) {
      goto LABEL_15;
    }
    goto LABEL_50;
  }

  unint64_t v89 = v214;
  unint64_t v90 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v214,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v92 = v63;
  uint64_t v93 = v212;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v90,  AssociatedConformanceWitness);
  uint64_t v94 = v232;
  (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v89 + 3))(v93, v8, v89);
  LOBYTE(v90) = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                                + 16LL))( v92,  v94,  v8);
  uint64_t v95 = v228;
  uint64_t v59 = *(void (**)(char *, void *))(v228 + 8);
  v59(v94, v8);
  (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v95 + 16))(v30, v92, v8);
  if ((v90 & 1) == 0)
  {
    uint64_t v144 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
    v59(v30, v8);
    BOOL v60 = v144 < v49;
    uint64_t v61 = v237;
    uint64_t v30 = v231;
    if (!v60)
    {
LABEL_15:
      uint64_t v216 = v59;
      uint64_t v76 = ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v61);
      uint64_t v77 = v219;
      char v78 = v219(v8, v6);
      uint64_t v79 = v220(v8, v6);
      if ((v78 & 1) != 0)
      {
        uint64_t v82 = v228;
        if (v79 > 64)
        {
          v239[0] = v76;
          char v83 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
          unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
          unint64_t v85 = v232;
          v83(v239, &type metadata for Int, v84, v8, v6);
          unint64_t v86 = v233;
          char v87 = (*(uint64_t (**)(char *, void, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                                + 16LL))( v85,  v233,  v8);
          v216(v85, v8);
          if ((v87 & 1) == 0)
          {
            uint64_t v88 = *(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(v82 + 16);
            goto LABEL_31;
          }

          goto LABEL_55;
        }

        uint64_t v88 = *(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(v228 + 16);
      }

      else
      {
        if (v79 > 63)
        {
          uint64_t v88 = *(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(v228 + 16);
          unint64_t v107 = v211;
          uint64_t v108 = v88(v211, (char *)v233, v8);
          if (v76 < 0)
          {
            v216(v107, v8);
            goto LABEL_55;
          }

          v239[0] = v76;
          char v111 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
          unint64_t v112 = lazy protocol witness table accessor for type Int and conformance Int(v108, v109, v110);
          unint64_t v113 = v232;
          v111(v239, &type metadata for Int, v112, v8, v6);
          char v114 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                                 + 16LL))( v113,  v107,  v8);
          uint64_t v115 = v216;
          v216(v113, v8);
          v115(v107, v8);
          unint64_t v86 = v233;
          if ((v114 & 1) != 0)
          {
LABEL_55:
            uint64_t v27 = ((uint64_t (*)(uint64_t, uint64_t))v30)(a3, v237);
LABEL_60:
            uint64_t v145 = v235;
            uint64_t v35 = v230;
            goto LABEL_61;
          }

uint64_t static FixedWidthInteger._nonMaskingRightShift(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v50 = a2;
  uint64_t v51 = a1;
  unint64_t v47 = a5;
  uint64_t v7 = *(void *)(a4 + 8);
  uint64_t v8 = *(void *)(*(void *)(v7 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v46 - v11;
  uint64_t v49 = *(char **)(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v46 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v46 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v46 - v19;
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  uint64_t v48 = v7;
  char v22 = v21(a3, v7);
  uint64_t v46 = v18;
  uint64_t v52 = v20;
  if ((v22 & 1) != 0)
  {
    uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    if (__OFSUB__(v23, 1LL))
    {
      __break(1u);
      goto LABEL_16;
    }

    uint64_t v53 = v23 - 1;
    uint64_t v26 = v48;
    uint64_t v27 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v48 + 96);
    unint64_t v28 = lazy protocol witness table accessor for type Int and conformance Int(v23, v24, v25);
    v27(&v53, &type metadata for Int, v28, a3, v26);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v51, v18, a3, a4);
    uint64_t v29 = v18;
    uint64_t v18 = v49;
    (*((void (**)(char *, uint64_t))v49 + 1))(v29, a3);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  }

  else
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a3, v8);
    uint64_t v26 = v48;
    uint64_t v18 = v49;
  }

  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a3, v8);
  uint64_t v31 = (void (*)(char *, uint64_t))*((void *)v18 + 1);
  uint64_t v32 = v50;
  if (v50 < 0)
  {
    v31(v52, a3);
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    uint64_t v12 = v47;
    if (!__OFSUB__(0LL, v40))
    {
      if (-v40 < v32)
      {
        uint64_t v41 = ((uint64_t (*)(char *, uint64_t))v31)(v15, a3);
        uint64_t v53 = -v32;
        uint64_t v42 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v26 + 96);
        unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v43, v44);
        uint64_t v38 = v46;
        v42(&v53, &type metadata for Int, v45, a3, v26);
        (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 216))(v51, v38, a3, a4);
        return ((uint64_t (*)(char *, uint64_t))v31)(v38, a3);
      }

      return (*((uint64_t (**)(char *, char *, uint64_t))v18 + 4))(v12, v15, a3);
    }

uint64_t static FixedWidthInteger._nonMaskingLeftShiftGeneric<A>(_:_:)( uint64_t a1, void (*a2)(char *, uint64_t, uint64_t), uint64_t a3, void (*a4)(char *, uint64_t), char *a5, uint64_t a6)
{
  uint64_t v228 = a1;
  uint64_t v229 = a2;
  uint64_t v220 = *((void *)a5 + 1);
  uint64_t v224 = *(const char **)(*(void *)(v220 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v224,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v217 = (char *)&v202 - v11;
  uint64_t v219 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v226 = (char *)&v202 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unint64_t v223 = (char *)&v202 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v225 = (char *)&v202 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v227 = (char *)&v202 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v21 = (uint64_t)&v202 - v20;
  uint64_t v208 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t v207 = swift_getAssociatedTypeWitness( 0LL,  v208,  (uint64_t)a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v22 = MEMORY[0x1895F8858](v207);
  unint64_t v206 = (char *)&v202 - v23;
  uint64_t v24 = *((void *)a4 - 1);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  unint64_t v203 = (char *)&v202 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v209 = (char *)&v202 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v212 = (char *)&v202 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v204 = (char *)&v202 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v210 = (char *)&v202 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  unint64_t v215 = (char *)&v202 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v205 = (char *)&v202 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v41 = (char *)&v202 - v40;
  uint64_t v42 = MEMORY[0x1895F8858](v39);
  uint64_t v44 = (char *)&v202 - v43;
  MEMORY[0x1895F8858](v42);
  uint64_t v46 = (char *)&v202 - v45;
  unint64_t v47 = (uint64_t (*)(uint64_t, char *))*((void *)a5 + 7);
  uint64_t v222 = a5;
  uint64_t v230 = v47;
  uint64_t v48 = v47(a3, a5);
  uint64_t v49 = -v48;
  if (__OFSUB__(0LL, v48))
  {
    __break(1u);
    goto LABEL_82;
  }

  uint64_t v221 = v46;
  uint64_t v50 = *(uint64_t (**)(void *, uint64_t))(a6 + 64);
  char v51 = v50(a4, a6);
  uint64_t v216 = v21;
  unint64_t v211 = (uint64_t (*)(void, void))v50;
  if ((v51 & 1) == 0)
  {
    char v61 = v50(a4, a6);
    uint64_t v214 = *(uint64_t (**)(void *, uint64_t))(a6 + 128);
    uint64_t v62 = v214(a4, a6);
    if ((v61 & 1) == 0)
    {
      uint64_t v56 = v221;
      uint64_t v44 = v222;
      if (v62 >= 64)
      {
        uint64_t v93 = (*(uint64_t (**)(char *, void, void (*)(char *, uint64_t)))(v24 + 16))( v41,  v229,  a4);
        if (v49 <= 0)
        {
          uint64_t v58 = *(void (**)(char *, void *))(v24 + 8);
          v58(v41, a4);
        }

        else
        {
          v232[0] = v49;
          uint64_t v96 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
          unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
          v96(v232, &type metadata for Int, v97, a4, a6);
          char v98 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                                + 16LL))( v41,  v56,  a4);
          uint64_t v58 = *(void (**)(char *, void *))(v24 + 8);
          v58(v56, a4);
          v58(v41, a4);
          char v71 = v224;
          if ((v98 & 1) != 0) {
            goto LABEL_28;
          }
        }

uint64_t static FixedWidthInteger.<<= infix<A>(_:_:)( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = a6;
  uint64_t v8 = (void (*)(char *, uint64_t))a4;
  uint64_t v247 = a1;
  uint64_t v228 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v228,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v226 = (char *)&v222 - v11;
  uint64_t v240 = *(void *)(a5 + 8);
  uint64_t v239 = *(const char **)(*(void *)(v240 + 24) + 16LL);
  unint64_t v238 = swift_getAssociatedTypeWitness( 0LL,  v239,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](v238);
  uint64_t v237 = (char *)&v222 - v13;
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v246 = (char *)&v222 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  Swift::String::Index v243 = (char *)&v222 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  Swift::Int v245 = (char *)&v222 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v241 = (char *)&v222 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v236 = (char *)&v222 - v24;
  uint64_t v242 = *((void *)v8 - 1);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v27 = (uint64_t)&v222 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v30 = (char *)&v222 - v29;
  uint64_t v31 = MEMORY[0x1895F8858](v28);
  unint64_t v225 = (char *)&v222 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  unint64_t v223 = (char *)&v222 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  uint64_t v230 = (char *)&v222 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  uint64_t v232 = (char *)&v222 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  uint64_t v224 = (char *)&v222 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v43 = (char *)&v222 - v42;
  uint64_t v44 = MEMORY[0x1895F8858](v41);
  uint64_t v231 = (char *)&v222 - v45;
  MEMORY[0x1895F8858](v44);
  uint64_t v244 = (char *)&v222 - v46;
  unint64_t v47 = *(char **)(a5 + 56);
  uint64_t v248 = a5;
  uint64_t v249 = v47;
  uint64_t v48 = ((uint64_t (*)(uint64_t, uint64_t))v47)(a3, a5);
  uint64_t v49 = -v48;
  if (__OFSUB__(0LL, v48))
  {
    __break(1u);
    goto LABEL_81;
  }

  unint64_t v250 = (void (*)(void))a2;
  uint64_t v50 = *(uint64_t (**)(void *, uint64_t))(v6 + 64);
  char v51 = v50(v8, v6);
  uint64_t v234 = v14;
  uint64_t v235 = v50;
  uint64_t v229 = v43;
  if ((v51 & 1) == 0)
  {
    char v62 = v50(v8, v6);
    uint64_t v63 = *(uint64_t (**)(void *, uint64_t))(v6 + 128);
    uint64_t v64 = v63(v8, v6);
    if ((v62 & 1) == 0)
    {
      uint64_t v233 = v63;
      char v61 = (uint64_t (*)(uint64_t))v249;
      if (v64 >= 64)
      {
        uint64_t v86 = v242;
        uint64_t v87 = (*(uint64_t (**)(uint64_t, void (*)(void), void (*)(char *, uint64_t)))(v242 + 16))( v27,  v250,  v8);
        uint64_t v14 = v234;
        if (v49 <= 0)
        {
          uint64_t v59 = *(void (**)(char *, void *))(v86 + 8);
          v59((char *)v27, v8);
          uint64_t v60 = v248;
          goto LABEL_24;
        }

        v252[0] = v49;
        unint64_t v90 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
        unint64_t v91 = lazy protocol witness table accessor for type Int and conformance Int(v87, v88, v89);
        uint64_t v92 = v244;
        v90(v252, &type metadata for Int, v91, v8, v6);
        char v93 = (*(uint64_t (**)(uint64_t, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL)
                                                                                               + 16LL))( v27,  v92,  v8);
        uint64_t v59 = *(void (**)(char *, void *))(v86 + 8);
        uint64_t v94 = v92;
        char v61 = (uint64_t (*)(uint64_t))v249;
        v59(v94, v8);
        v59((char *)v27, v8);
        uint64_t v60 = v248;
        if ((v93 & 1) != 0) {
          goto LABEL_21;
        }
      }

      else
      {
        uint64_t v74 = v242;
        char v75 = v244;
        (*(void (**)(char *, void (*)(void), void (*)(char *, uint64_t)))(v242 + 16))( v244,  v250,  v8);
        uint64_t v76 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
        uint64_t v59 = *(void (**)(char *, void *))(v74 + 8);
        v59(v75, v8);
        uint64_t v14 = v234;
        uint64_t v60 = v248;
        if (v76 < v49) {
          goto LABEL_21;
        }
      }

uint64_t static FixedWidthInteger._nonMaskingLeftShift(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v47 = a2;
  uint64_t v48 = a1;
  uint64_t v44 = a5;
  uint64_t v7 = *(void *)(a4 + 8);
  uint64_t v8 = *(void *)(*(void *)(v7 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v42 - v11;
  uint64_t v46 = *(void (***)(char *, uint64_t))(a3 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v45 = (char *)&v42 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v42 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (void (**)(char *, uint64_t))((char *)&v42 - v18);
  char v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 64))(a3, v7);
  uint64_t v43 = (char *)v19;
  if ((v20 & 1) != 0)
  {
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    if (__OFSUB__(v21, 1LL))
    {
      __break(1u);
      goto LABEL_16;
    }

    uint64_t v49 = v21 - 1;
    uint64_t v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    unint64_t v25 = lazy protocol witness table accessor for type Int and conformance Int(v21, v22, v23);
    v24(&v49, &type metadata for Int, v25, a3, v7);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v48, v17, a3, a4);
    uint64_t v19 = v46;
    v46[1](v17, a3);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  }

  else
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a3, v8);
    uint64_t v19 = v46;
  }

  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  uint64_t v27 = v45;
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a3, v8);
  uint64_t v28 = v19[1];
  uint64_t v29 = v47;
  if (v47 < 0)
  {
    v28(v27, a3);
    uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
    uint64_t v12 = v44;
    if (!__OFSUB__(0LL, v36))
    {
      if (-v36 < v29)
      {
        uint64_t v37 = ((uint64_t (*)(char *, uint64_t))v28)(v43, a3);
        uint64_t v49 = -v29;
        uint64_t v38 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
        unint64_t v41 = lazy protocol witness table accessor for type Int and conformance Int(v37, v39, v40);
        v38(&v49, &type metadata for Int, v41, a3, v7);
        (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v48, v17, a3, a4);
        return ((uint64_t (*)(char *, uint64_t))v28)(v17, a3);
      }

      return ((uint64_t (*)(char *, char *, uint64_t))v19[4])(v12, v43, a3);
    }

BOOL specialized static FixedWidthInteger._convert<A>(from:)(uint64_t a1, double a2)
{
  uint64_t v4 = (*(void *)&a2 >> 52) & 0x7FFLL;
  unint64_t v5 = *(void *)&a2 & 0xFFFFFFFFFFFFFLL;
  if (!(v4 | *(void *)&a2 & 0xFFFFFFFFFFFFFLL))
  {
    *(void *)a1 = 0LL;
    *(void *)(a1 + 8) = 0LL;
    BOOL result = 1LL;
    goto LABEL_50;
  }

  if (v4 == 2047 || (int64_t v6 = Double.exponent.getter(a2), v6 >= 128))
  {
    BOOL result = 0LL;
    *(void *)a1 = 0LL;
    *(void *)(a1 + 8) = 0LL;
    *(_BYTE *)(a1 + 16) = 1;
    return result;
  }

  uint64_t v7 = v6;
  uint64_t v8 = Double.significandWidth.getter(a2);
  BOOL result = v7 >= v8;
  uint64_t v10 = v8 + __clz(__rbit64(v5));
  unint64_t v11 = v7 - v10;
  if (__OFSUB__(v7, v10))
  {
    __break(1u);
    goto LABEL_35;
  }

  if (v10 > 127)
  {
    unint64_t v12 = v5 >> (v10 - v7);
    if (v11 <= 0xFFFFFFFFFFFFFFC0LL) {
      unint64_t v12 = 0LL;
    }
    unint64_t v13 = v5 << v11;
    if (v11 >= 0x40) {
      unint64_t v13 = 0LL;
    }
    if ((v11 & 0x8000000000000000LL) == 0LL) {
      unint64_t v12 = v13;
    }
    uint64_t v10 = 0LL;
    if (v11 - 65 >= 0xFFFFFFFFFFFFFF7FLL) {
      unint64_t v5 = v12;
    }
    else {
      unint64_t v5 = 0LL;
    }
  }

  else
  {
    if (v11 - 129 < 0xFFFFFFFFFFFFFEFFLL)
    {
LABEL_7:
      uint64_t v10 = 0LL;
      unint64_t v5 = 0LL;
      goto LABEL_17;
    }

    if ((v11 & 0x8000000000000000LL) != 0)
    {
      unint64_t v23 = v5 >> (v10 - v7);
      uint64_t v10 = 0LL;
      if (v11 <= 0xFFFFFFFFFFFFFF80LL) {
        unint64_t v5 = 0LL;
      }
      else {
        unint64_t v5 = v23;
      }
    }

    else
    {
      if (v11 >= 0x80) {
        goto LABEL_7;
      }
      if (v11 > 0x3F)
      {
        uint64_t v10 = v5 << v11;
        unint64_t v5 = 0LL;
      }

      else if (v11)
      {
        uint64_t v10 = v5 >> (v10 - v7);
        v5 <<= v11;
      }

      else
      {
        uint64_t v10 = 0LL;
      }
    }
  }

LABEL_35:
  if (a2 >= 0.0 || (unint64_t v17 = v10 | v5) != 0)
  {
    BOOL result = 0LL;
    unint64_t v18 = 0LL;
    LOBYTE(v17) = 1;
  }

  else
  {
    unint64_t v18 = 0x8000000000000000LL;
  }

  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = v18;
  *(_BYTE *)(a1 + 16) = v17;
  return result;
}

    unint64_t v78 = v27;
LABEL_36:
    v79._Swift::UInt64 rawBits = 1LL;
    v80._Swift::UInt64 rawBits = 131073LL;
    v81._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v79, v80, 0x202CuLL, 0xE200000000000000LL);
    if (v81._rawBits < 0x10000) {
      v81._rawBits |= 3;
    }
    uint64_t v83 = specialized String.init(_:)(v81, v82, 0x202CuLL, 0xE200000000000000LL);
    unint64_t v85 = v84;
    swift_bridgeObjectRelease(0xE200000000000000LL);
    if ((v85 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v85);
    }

    else if ((v85 & 0x1000000000000000LL) != 0)
    {
      uint64_t v83 = _StringGuts._foreignConvertedToSmall()(v83, v85);
      uint64_t v182 = v181;
      swift_bridgeObjectRelease(v85);
      unint64_t v85 = v182;
    }

    else
    {
      if ((v83 & 0x1000000000000000LL) != 0)
      {
        uint64_t v175 = (unsigned __int8 *)((v85 & 0xFFFFFFFFFFFFFFFLL) + 32);
        char v176 = v83 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v175 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v83, v85);
      }

      closure #1 in _StringGuts._convertedToSmall()(v175, v176, &v255);
      swift_bridgeObjectRelease(v85);
      unint64_t v85 = *((void *)&v255 + 1);
      uint64_t v83 = v255;
    }

    uint64_t v86 = HIBYTE(v78) & 0xF;
    uint64_t v87 = HIBYTE(v85) & 0xF;
    uint64_t v88 = v87 + v86;
    if (v87)
    {
      uint64_t v89 = 0;
      unint64_t v90 = 0LL;
      do
      {
        unint64_t v91 = v86 + v90;
        uint64_t v92 = v90 + 1;
        if (v90 >= 8) {
          char v93 = v85;
        }
        else {
          char v93 = v83;
        }
        uint64_t v94 = v93 >> (v89 & 0x38);
        uint64_t v95 = (8 * v86 + v89) & 0x38;
        uint64_t v96 = (-255LL << v95) - 1;
        uint64_t v97 = (unint64_t)v94 << v95;
        uint64_t v98 = v97 | v96 & v78;
        char v99 = v97 | v96 & v32;
        if (v91 < 8) {
          uint64_t v32 = v99;
        }
        else {
          unint64_t v78 = v98;
        }
        v89 += 8;
        unint64_t v90 = v92;
      }

      while (v87 != v92);
    }

    swift_bridgeObjectRelease(v27);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    uint64_t v100 = 0xE000000000000000LL;
    if (v32 & 0x8080808080808080LL | v78 & 0x80808080808080LL) {
      uint64_t v100 = 0xA000000000000000LL;
    }
    unint64_t v257 = v32;
    unint64_t v258 = v100 & 0xFF00000000000000LL | (v88 << 56) | v78 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v57 = v233;
    uint64_t v10 = v251;
    uint64_t v26 = v238;
LABEL_82:
    uint64_t v32 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v32, &v254);
    *((_OWORD *)inited + 1) = v249;
    inited[7] = a2;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v59(boxed_opaque_existential_0Tm, v10, a2);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v257);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v119 = v257;
    char v118 = v258;
    uint64_t v120 = HIBYTE(v258) & 0xF;
    uint64_t v27 = v257 & 0xFFFFFFFFFFFFLL;
    if ((v258 & 0x2000000000000000LL) != 0) {
      uint64_t v121 = HIBYTE(v258) & 0xF;
    }
    else {
      uint64_t v121 = v257 & 0xFFFFFFFFFFFFLL;
    }
    if (!v121 && (v257 & ~v258 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v258);
      unint64_t v257 = 8250LL;
      unint64_t v258 = 0xE200000000000000LL;
      TupleTypeMetadata2 = v245;
LABEL_4:
      unint64_t v5 = v57;
      unint64_t v18 = v244;
      goto LABEL_5;
    }

    if ((v258 & 0x2000000000000000LL) != 0 && v120 <= 0xD)
    {
      uint64_t v122 = 8 * (HIBYTE(v258) & 7);
      unint64_t v123 = (-255LL << v122) - 1;
      char v124 = 58LL << v122;
      uint64_t v125 = v120 + 1;
      if (v120 >= 8)
      {
        uint64_t v126 = v124 | v123 & v258;
        TupleTypeMetadata2 = v245;
LABEL_131:
        uint64_t v160 = (32LL << (8 * (v125 & 7u))) | ((-255LL << (8 * (v125 & 7u))) - 1) & v126;
      }

      else
      {
        uint64_t v119 = v124 | v123 & v257;
        TupleTypeMetadata2 = v245;
        if (v120 == 7)
        {
          uint64_t v125 = 8;
          uint64_t v126 = v258;
          goto LABEL_131;
        }

        uint64_t v119 = (32LL << (8 * (v125 & 7u))) | ((-255LL << (8 * (v125 & 7u))) - 1) & v119;
        uint64_t v160 = v258;
      }

      swift_bridgeObjectRelease(v258);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v167 = 0xE000000000000000LL;
      if (v119 & 0x8080808080808080LL | v160 & 0x80808080808080LL) {
        unint64_t v167 = 0xA000000000000000LL;
      }
      unint64_t v257 = v119;
      unint64_t v258 = (v167 & 0xFF00000000000000LL | (v120 << 56) | v160 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
      goto LABEL_4;
    }

    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v116, v117);
    if ((v118 & 0x1000000000000000LL) != 0)
    {
      unint64_t v170 = String.UTF8View._foreignCount()();
      uint64_t v127 = v170 + 2;
      if (__OFADD__(v170, 2LL)) {
        goto LABEL_240;
      }
    }

    else
    {
      char v70 = __OFADD__(v121, 2LL);
      uint64_t v127 = v121 + 2;
      if (v70) {
        goto LABEL_240;
      }
    }

    char v128 = v119 & ~v118;
    if ((v128 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v118 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v127 > 15) {
        goto LABEL_120;
      }
      goto LABEL_100;
    }

    char v129 = _StringGuts.nativeUnusedCapacity.getter(v119, v118);
    if ((v130 & 1) != 0) {
      goto LABEL_257;
    }
    if (v127 > 15)
    {
LABEL_120:
      char v157 = _StringGuts.nativeUnusedCapacity.getter(v119, v118);
      uint64_t v27 = (v158 & 1) == 0 && v157 > 1;
      if ((v128 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v118 & 0xFFFFFFFFFFFFFFFLL))
      {
        unint64_t v5 = v57;
        unint64_t v18 = v244;
        if ((v27 & 1) != 0) {
          goto LABEL_140;
        }
LABEL_133:
        uint64_t v161 = _StringGuts.nativeCapacity.getter(v119, v118);
        if ((v162 & 1) != 0) {
          uint64_t v163 = 0LL;
        }
        else {
          uint64_t v163 = v161;
        }
        if (v163 + 0x4000000000000000LL < 0) {
          goto LABEL_242;
        }
        uint64_t v164 = 2 * v163;
        if (v164 > v127) {
          uint64_t v127 = v164;
        }
      }

      else
      {
        unint64_t v5 = v57;
        unint64_t v18 = v244;
        if ((v27 & 1) == 0) {
          goto LABEL_133;
        }
      }

      _StringGuts.grow(_:)(v127);
LABEL_140:
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
      uint64_t v255 = v232;
      uint64_t v165 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v255, 2LL);
      _StringGuts.appendInPlace(_:isASCII:)(v165, v166, 1);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      TupleTypeMetadata2 = v245;
      goto LABEL_5;
    }

    if ((v118 & 0x2000000000000000LL) == 0)
    {
      if (v129 > 1) {
        goto LABEL_120;
      }
LABEL_100:
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
      unint64_t v18 = v244;
      if ((v118 & 0x2000000000000000LL) != 0)
      {
        uint64_t v134 = v118;
      }

      else if ((v118 & 0x1000000000000000LL) != 0)
      {
        uint64_t v119 = _StringGuts._foreignConvertedToSmall()(v119, v118);
        uint64_t v134 = v180;
      }

      else
      {
        if ((v119 & 0x1000000000000000LL) != 0)
        {
          uint64_t v174 = (unsigned __int8 *)((v118 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          uint64_t v174 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v119, v118);
          uint64_t v27 = v131;
        }

        swift_bridgeObjectRetain(v118, v131, v132, v133);
        closure #1 in _StringGuts._convertedToSmall()(v174, v27, &v255);
        swift_bridgeObjectRelease(v118);
        uint64_t v134 = *((void *)&v255 + 1);
        uint64_t v119 = v255;
      }

      goto LABEL_102;
    }

    swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
    uint64_t v134 = v118;
    unint64_t v18 = v244;
LABEL_102:
    v135._Swift::UInt64 rawBits = 1LL;
    v136._Swift::UInt64 rawBits = 131073LL;
    v137._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v135, v136, 0x203AuLL, 0xE200000000000000LL);
    if (v137._rawBits < 0x10000) {
      v137._rawBits |= 3;
    }
    unint64_t v139 = specialized String.init(_:)(v137, v138, 0x203AuLL, 0xE200000000000000LL);
    unint64_t v141 = v140;
    swift_bridgeObjectRelease(0xE200000000000000LL);
    if ((v141 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v141);
    }

    else if ((v141 & 0x1000000000000000LL) != 0)
    {
      unint64_t v139 = _StringGuts._foreignConvertedToSmall()(v139, v141);
      unint64_t v179 = v178;
      swift_bridgeObjectRelease(v141);
      unint64_t v141 = v179;
    }

    else
    {
      if ((v139 & 0x1000000000000000LL) != 0)
      {
        uint64_t v172 = (unsigned __int8 *)((v141 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v173 = v139 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v172 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v139, v141);
      }

      closure #1 in _StringGuts._convertedToSmall()(v172, v173, &v255);
      swift_bridgeObjectRelease(v141);
      unint64_t v141 = *((void *)&v255 + 1);
      unint64_t v139 = v255;
    }

    uint64_t v142 = HIBYTE(v134) & 0xF;
    char v143 = HIBYTE(v141) & 0xF;
    uint64_t v144 = v143 + v142;
    if (v143)
    {
      uint64_t v145 = 0;
      uint64_t v146 = 0LL;
      do
      {
        unint64_t v147 = v142 + v146;
        unint64_t v148 = v146 + 1;
        if (v146 >= 8) {
          uint64_t v149 = v141;
        }
        else {
          uint64_t v149 = v139;
        }
        unint64_t v150 = v149 >> (v145 & 0x38);
        unint64_t v151 = (8 * v142 + v145) & 0x38;
        uint64_t v152 = (-255LL << v151) - 1;
        char v153 = (unint64_t)v150 << v151;
        unint64_t v154 = v153 | v152 & v134;
        uint64_t v155 = v153 | v152 & v119;
        if (v147 < 8) {
          uint64_t v119 = v155;
        }
        else {
          uint64_t v134 = v154;
        }
        v145 += 8;
        uint64_t v146 = v148;
      }

      while (v143 != v148);
    }

    swift_bridgeObjectRelease(v118);
    swift_bridgeObjectRelease(0xE200000000000000LL);
    uint64_t v156 = 0xE000000000000000LL;
    if (v119 & 0x8080808080808080LL | v134 & 0x80808080808080LL) {
      uint64_t v156 = 0xA000000000000000LL;
    }
    unint64_t v257 = v119;
    unint64_t v258 = v156 & 0xFF00000000000000LL | (v144 << 56) | v134 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v5 = v233;
    TupleTypeMetadata2 = v245;
    uint64_t v26 = v238;
LABEL_5:
    uint64_t v29 = swift_initStackObject(v32, v253);
    *((_OWORD *)v29 + 1) = v249;
    v29[7] = v3;
    uint64_t v30 = (char *)__swift_allocate_boxed_opaque_existential_0Tm(v29 + 4);
    v248(v30, v252, v3);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)v29,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v257);
    swift_bridgeObjectRelease((uint64_t)v29);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v28 = 0LL;
    uint64_t v27 = v256;
    uint64_t v10 = v251;
  }

  unint64_t v3 = v257;
  uint64_t v27 = v258;
  uint64_t v32 = HIBYTE(v258) & 0xF;
  a2 = v257 & 0xFFFFFFFFFFFFLL;
  if ((v258 & 0x2000000000000000LL) != 0) {
    uint64_t v184 = HIBYTE(v258) & 0xF;
  }
  else {
    uint64_t v184 = v257 & 0xFFFFFFFFFFFFLL;
  }
  if (!v184 && (v257 & ~v258 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v258);
    return 93LL;
  }

  if ((v258 & 0x2000000000000000LL) == 0 || v32 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v55, v56);
    if ((v27 & 0x1000000000000000LL) != 0) {
      goto LABEL_244;
    }
    char v70 = __OFADD__(v184, 1LL);
    uint64_t v185 = v184 + 1;
    if (!v70) {
      goto LABEL_192;
    }
    goto LABEL_246;
  }

  if (v32 < 8) {
    unint64_t v3 = (93LL << (8 * (HIBYTE(v258) & 7u))) | ((-255LL << (8 * (HIBYTE(v258) & 7u))) - 1) & v257;
  }
  swift_bridgeObjectRelease(v258);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v3;
}

      uint64_t v80 = (v54 - 1) & v54;
      unint64_t v81 = v50;
    }
  }

  uint64_t v58 = v56 + 1;
  if (v56 + 1 >= v78) {
    goto LABEL_54;
  }
  uint64_t v57 = *(void *)(v77 + 8 * v58);
  if (v57)
  {
    ++v56;
    goto LABEL_45;
  }

  while (1)
  {
    uint64_t v56 = v58 + 1;
    if (__OFADD__(v58, 1LL)) {
      break;
    }
    if (v56 >= v78) {
      goto LABEL_54;
    }
    uint64_t v57 = *(void *)(v77 + 8 * v56);
    ++v58;
    if (v57) {
      goto LABEL_45;
    }
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  unint64_t v21 = a2;
  BOOL v22 = a3 & 0xFFFFFFFFFFFFFFLL;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return specialized static String._uncheckedFromUTF8(_:)((uint8x16_t *)((char *)&v21 + v7), v6);
}

  (*(void (**)(char *, uint64_t, uint64_t, char *))(v7 + 56))(v17, 1LL, 1LL, a3);
  outlined consume of [A : B].Iterator._Variant<A, B>(v30);
  Hasher._combine(_:)(v40);
}

  unint64_t v11 = 0LL;
  unint64_t v17 = 0LL;
  unint64_t v18 = a2 - 8;
  uint64_t v19 = 8LL;
  if (a2 < 8) {
    uint64_t v19 = a2;
  }
  unint64_t v20 = v19 & ~(v19 >> 63);
  unint64_t v21 = v19 - 1;
  BOOL v22 = (unsigned __int8 *)a1;
  do
  {
    if (v20 <= v21) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
    }
    unint64_t v23 = *v22++;
    v11 |= (unint64_t)v23 << (v17 & 0x38);
    v17 += 8LL;
    --v19;
  }

  while (v19);
  if (a2 >= 9)
  {
    if (v18 < 8)
    {
      uint64_t v24 = 0LL;
      unint64_t v25 = 0LL;
      uint64_t v26 = 0LL;
LABEL_55:
      uint64_t v86 = a2 - v24 - 8;
      uint64_t v87 = (unsigned __int8 *)(v24 + a1 + 8);
      do
      {
        uint64_t v88 = *v87++;
        *(void *)&v25 |= (unint64_t)v88 << (v26 & 0x38);
        v26 += 8LL;
        --v86;
      }

      while (v86);
      goto LABEL_57;
    }

    if (v18 >= 0x10)
    {
      uint64_t v50 = (uint8x16_t *)(a1 + 8);
      uint64_t v24 = v18 & 0xFFFFFFFFFFFFFFF0LL;
      char v51 = (int64x2_t)xmmword_1817FFD60;
      uint64_t v52 = (int64x2_t)xmmword_1817FFD70;
      uint64_t v53 = (int64x2_t)xmmword_1817FFD80;
      uint64_t v54 = (int64x2_t)xmmword_1817FFD90;
      uint64_t v26 = 8 * (v18 & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v55 = 0uLL;
      uint64_t v56 = (int8x16_t)vdupq_n_s64(0x38uLL);
      uint64_t v57 = vdupq_n_s64(0x80uLL);
      uint64_t v58 = v18 & 0xFFFFFFFFFFFFFFF0LL;
      uint64_t v59 = (int64x2_t)xmmword_1817FFCC0;
      uint64_t v60 = 0uLL;
      char v61 = 0uLL;
      char v62 = (int64x2_t)xmmword_1817FFCE0;
      uint64_t v63 = 0uLL;
      uint64_t v64 = 0uLL;
      uint64_t v65 = (int64x2_t)xmmword_1817FFCB0;
      uint64_t v66 = 0uLL;
      char v67 = 0uLL;
      unint64_t v68 = (int64x2_t)xmmword_1817FFCD0;
      unint64_t v69 = 0uLL;
      do
      {
        char v70 = *v50++;
        char v71 = vmovl_u8(*(uint8x8_t *)v70.i8);
        unint64_t v72 = vmovl_high_u16(v71);
        v73.i64[0] = v72.u32[2];
        v73.i64[1] = v72.u32[3];
        uint64_t v74 = v73;
        char v75 = vmovl_high_u8(v70);
        uint64_t v76 = vmovl_u16(*(uint16x4_t *)v75.i8);
        v73.i64[0] = v76.u32[2];
        v73.i64[1] = v76.u32[3];
        uint64_t v77 = v73;
        v73.i64[0] = v76.u32[0];
        v73.i64[1] = v76.u32[1];
        unint64_t v78 = v73;
        v73.i64[0] = v72.u32[0];
        v73.i64[1] = v72.u32[1];
        unint64_t v79 = v73;
        uint64_t v80 = vmovl_u16(*(uint16x4_t *)v71.i8);
        v73.i64[0] = v80.u32[2];
        v73.i64[1] = v80.u32[3];
        unint64_t v81 = v73;
        uint64_t v82 = vmovl_high_u16(v75);
        v73.i64[0] = v82.u32[0];
        v73.i64[1] = v82.u32[1];
        uint64_t v83 = v73;
        v73.i64[0] = v80.u32[0];
        v73.i64[1] = v80.u32[1];
        unint64_t v84 = v73;
        v73.i64[0] = v82.u32[2];
        v73.i64[1] = v82.u32[3];
        uint64_t v63 = vorrq_s8((int8x16_t)vshlq_u64(v74, (uint64x2_t)vandq_s8((int8x16_t)v59, v56)), v63);
        uint64_t v66 = vorrq_s8((int8x16_t)vshlq_u64(v77, (uint64x2_t)vandq_s8((int8x16_t)v53, v56)), v66);
        uint64_t v64 = vorrq_s8((int8x16_t)vshlq_u64(v78, (uint64x2_t)vandq_s8((int8x16_t)v54, v56)), v64);
        char v61 = vorrq_s8((int8x16_t)vshlq_u64(v79, (uint64x2_t)vandq_s8((int8x16_t)v62, v56)), v61);
        uint64_t v60 = vorrq_s8((int8x16_t)vshlq_u64(v81, (uint64x2_t)vandq_s8((int8x16_t)v65, v56)), v60);
        char v67 = vorrq_s8((int8x16_t)vshlq_u64(v83, (uint64x2_t)vandq_s8((int8x16_t)v52, v56)), v67);
        uint64_t v55 = vorrq_s8((int8x16_t)vshlq_u64(v84, (uint64x2_t)vandq_s8((int8x16_t)v68, v56)), v55);
        unint64_t v69 = vorrq_s8((int8x16_t)vshlq_u64(v73, (uint64x2_t)vandq_s8((int8x16_t)v51, v56)), v69);
        char v62 = vaddq_s64(v62, v57);
        uint64_t v65 = vaddq_s64(v65, v57);
        unint64_t v68 = vaddq_s64(v68, v57);
        uint64_t v59 = vaddq_s64(v59, v57);
        uint64_t v54 = vaddq_s64(v54, v57);
        uint64_t v53 = vaddq_s64(v53, v57);
        uint64_t v52 = vaddq_s64(v52, v57);
        char v51 = vaddq_s64(v51, v57);
        v58 -= 16LL;
      }

      while (v58);
      unint64_t v85 = vorrq_s8(vorrq_s8(vorrq_s8(v55, v64), vorrq_s8(v61, v67)), vorrq_s8(vorrq_s8(v60, v66), vorrq_s8(v63, v69)));
      unint64_t v25 = vorr_s8(*(int8x8_t *)v85.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL));
      if (v18 == v24) {
        goto LABEL_57;
      }
      if ((v18 & 8) == 0) {
        goto LABEL_55;
      }
    }

    else
    {
      unint64_t v25 = 0LL;
      uint64_t v26 = 0LL;
      uint64_t v24 = 0LL;
    }

    uint64_t v27 = v24;
    uint64_t v24 = v18 & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v28 = vdupq_n_s64(v26);
    uint64_t v26 = 8 * (v18 & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v29 = 0uLL;
    uint64_t v30 = (int8x16_t)(unint64_t)v25;
    uint64_t v31 = vaddq_s64(v28, (int64x2_t)xmmword_1817FFCC0);
    uint64_t v32 = vaddq_s64(v28, (int64x2_t)xmmword_1817FFCE0);
    uint64_t v33 = vaddq_s64(v28, (int64x2_t)xmmword_1817FFCB0);
    unint64_t v34 = vaddq_s64(v28, (int64x2_t)xmmword_1817FFCD0);
    uint64_t v35 = (uint8x8_t *)(v27 + a1 + 8);
    uint64_t v36 = (int8x16_t)vdupq_n_s64(0x38uLL);
    uint64_t v37 = v27 - (v18 & 0xFFFFFFFFFFFFFFF8LL);
    uint64_t v38 = vdupq_n_s64(0x40uLL);
    uint64_t v39 = 0uLL;
    uint64_t v40 = 0uLL;
    do
    {
      unint64_t v41 = *v35++;
      uint64_t v42 = vmovl_u8(v41);
      uint64_t v43 = vmovl_high_u16(v42);
      v44.i64[0] = v43.u32[2];
      v44.i64[1] = v43.u32[3];
      uint64_t v45 = v44;
      v44.i64[0] = v43.u32[0];
      v44.i64[1] = v43.u32[1];
      uint64_t v46 = v44;
      uint64_t v47 = vmovl_u16(*(uint16x4_t *)v42.i8);
      v44.i64[0] = v47.u32[2];
      v44.i64[1] = v47.u32[3];
      uint64_t v48 = v44;
      v44.i64[0] = v47.u32[0];
      v44.i64[1] = v47.u32[1];
      uint64_t v40 = vorrq_s8((int8x16_t)vshlq_u64(v45, (uint64x2_t)vandq_s8((int8x16_t)v31, v36)), v40);
      uint64_t v39 = vorrq_s8((int8x16_t)vshlq_u64(v46, (uint64x2_t)vandq_s8((int8x16_t)v32, v36)), v39);
      uint64_t v29 = vorrq_s8((int8x16_t)vshlq_u64(v48, (uint64x2_t)vandq_s8((int8x16_t)v33, v36)), v29);
      uint64_t v30 = vorrq_s8((int8x16_t)vshlq_u64(v44, (uint64x2_t)vandq_s8((int8x16_t)v34, v36)), v30);
      uint64_t v32 = vaddq_s64(v32, v38);
      uint64_t v33 = vaddq_s64(v33, v38);
      unint64_t v34 = vaddq_s64(v34, v38);
      uint64_t v31 = vaddq_s64(v31, v38);
      v37 += 8LL;
    }

    while (v37);
    uint64_t v49 = vorrq_s8(vorrq_s8(v30, v39), vorrq_s8(v29, v40));
    unint64_t v25 = vorr_s8(*(int8x8_t *)v49.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL));
    if (v18 == v24) {
      goto LABEL_57;
    }
    goto LABEL_55;
  }

  unint64_t v25 = 0LL;
LABEL_57:
  uint64_t v89 = 0xA000000000000000LL;
  if (((*(void *)&v25 | v11) & 0x8080808080808080LL) == 0) {
    uint64_t v89 = 0xE000000000000000LL;
  }
  unint64_t v13 = v89 | (a2 << 56) | *(void *)&v25;
LABEL_34:
  v91[3] = (uint64_t)&type metadata for String;
  v91[0] = v11;
  v91[1] = v13;
  return Mirror.init(reflecting:)(v91, a4);
}

        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v89)) {
          uint64_t v36 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v89[2]->isa + 1,  1,  (uint64_t)v89);
        }
        unint64_t v41 = (unint64_t)v36[2];
        uint64_t v40 = (unint64_t)v36[3];
        if (v41 >= v40 >> 1) {
          uint64_t v36 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v40 > 1),  v41 + 1,  1,  (uint64_t)v36);
        }
        v36[2] = (__objc2_class *)(v41 + 1);
        uint64_t v35 = &v36[v41];
        *((_DWORD *)v35 + 8) = v17;
        *((_WORD *)v35 + 18) = WORD2(v17);
        uint64_t v89 = v36;
LABEL_23:
        unint64_t v17 = specialized Unicode._InternalNFD.Iterator.next()();
        uint64_t v33 = 0;
        if ((v17 & 0x1000000000000LL) != 0)
        {
          LODWORD(v17) = v34;
          LOBYTE(v20) = 0;
          goto LABEL_56;
        }
      }

      unint64_t v17 = Composition;
LABEL_49:
      uint64_t v32 = specialized Unicode._InternalNFD.Iterator.next()();
      LOBYTE(v20) = 0;
      uint64_t v33 = 0;
      unint64_t v34 = v17;
      if ((v32 & 0x1000000000000LL) == 0) {
        continue;
      }
      break;
    }

  if (__OFADD__(v20, offsetBy))
  {
    __break(1u);
    goto LABEL_44;
  }

  v18.value = String.UTF16View._nativeGetIndex(for:)(v20 + offsetBy);
LABEL_37:
  is_nil = 0;
LABEL_38:
  v18.is_nil = is_nil;
  return v18;
}

  unint64_t v17 = ((v12 - (1 - v14)) << 16) | 5;
  if (v14 == -3) {
    BOOL result = (rawBits & 0xFFFFFFFFFFFF0000LL) - 245756;
  }
  else {
    BOOL result = v17;
  }
LABEL_38:
  *a1 = result;
  return result;
}

  unint64_t v16 = ((v11 - (1 - v13)) << 16) | 5;
  if (v13 == -3) {
    return (Swift::String::Index)((before._rawBits & 0xFFFFFFFFFFFF0000LL) - 245756);
  }
  else {
    return (Swift::String::Index)v16;
  }
}

  unint64_t v18 = ((v13 - (1 - v15)) << 16) | 5;
  if (v15 == -3) {
    unint64_t v12 = (rawBits & 0xFFFFFFFFFFFF0000LL) - 245756;
  }
  else {
    unint64_t v12 = v18;
  }
LABEL_38:
  before->_Swift::UInt64 rawBits = v12;
}

  unint64_t v90 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
  v63(v65, v5);
  unint64_t v91 = *((_BYTE *)v4 + 4);
  *v4 |= v90 << v91;
  BOOL result = specialized _UIntBuffer._elementWidth.getter(v5, v101);
  *((_BYTE *)v4 + 4) = result + v91;
  return result;
}

  *a5 = v68;
  a5[1] = v46;
}

    if ((v34 & 0x8000000000000000LL) != 0 || (uint64_t v36 = *(void *)(a2 + 16), v34 >= v36))
    {
LABEL_85:
      uint64_t v55 = 675LL;
      goto LABEL_86;
    }

    uint64_t v37 = *(void *)(v68 + 8 * v34);
    if (v31 == v22)
    {
      unint64_t v21 = v37 + 1;
    }

    else
    {
      if ((unint64_t)v31 > 0x7FFFFFFFFFFFFFFELL)
      {
        uint64_t v38 = -(v31 + 1);
        if (__OFSUB__(0LL, v31 + 1))
        {
          __break(1u);
          return result;
        }
      }

      else
      {
        uint64_t v38 = v31;
      }

      if ((v38 & 0x8000000000000000LL) != 0 || v38 >= v36) {
        goto LABEL_85;
      }
      if (v37 >= *(void *)(v68 + 8 * v38)) {
        unint64_t v21 = v37 + 1;
      }
      else {
        unint64_t v21 = *(void *)(v68 + 8 * v38);
      }
    }

    uint64_t v30 = _StringGuts.nativeCapacity.getter(v3, v5);
    if ((v31 & 1) != 0) {
      uint64_t v32 = 0LL;
    }
    else {
      uint64_t v32 = v30;
    }
    if (v32 + 0x4000000000000000LL < 0) {
      goto LABEL_293;
    }
    uint64_t v33 = 2 * v32;
    if (v33 > v22) {
      BOOL v22 = v33;
    }
    goto LABEL_41;
  }

  if (!v29) {
    goto LABEL_35;
  }
LABEL_42:
  swift_bridgeObjectRelease_n((uint64_t)v8._object, 4LL);
  if (((uint64_t)v8._object & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v8._object);
    _StringGuts._foreignAppendInPlace(_:)(v8._countAndFlagsBits, (unint64_t)v8._object, 0LL, v330);
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
    goto LABEL_89;
  }

  if (v14)
  {
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
    uint64_t v332 = v8._countAndFlagsBits;
    uint64_t v333 = (uint64_t)v8._object & 0xFFFFFFFFFFFFFFLL;
    unint64_t v34 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v8._object >> 56) & 0xF,  (uint64_t)&v332,  ((unint64_t)v8._object >> 56) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v34, v35, ((uint64_t)v8._object & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease((uint64_t)v8._object);
LABEL_89:
    uint64_t v2 = v331;
    goto LABEL_90;
  }

  if ((v8._countAndFlagsBits & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v8._object);
    uint64_t v77 = (id)(((uint64_t)v8._object & 0xFFFFFFFFFFFFFFFLL) + 32);
    unint64_t v78 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    unint64_t v79 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    uint64_t v2 = v331;
  }

  else
  {
    uint64_t v77 = _StringObject.sharedUTF8.getter(v8._countAndFlagsBits, (uint64_t)v8._object);
    unint64_t v79 = v325;
    swift_bridgeObjectRelease((uint64_t)v8._object);
    if (v79 < (v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
      goto LABEL_300;
    }
    uint64_t v2 = v331;
    unint64_t v78 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }

  uint64_t v80 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v78, (uint64_t)v77, v79);
  _StringGuts.appendInPlace(_:isASCII:)(v80, v81, v8._countAndFlagsBits < 0);
  swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
LABEL_90:
  TypeName = (uint8x16_t *)swift_getTypeName(v2, 0);
  if (v84 < 0) {
    goto LABEL_270;
  }
  uint64_t v87 = v84;
  if (!v84)
  {
    unint64_t countAndFlagsBits = 0LL;
    uint64_t v0 = 0xE000000000000000LL;
LABEL_198:
    object = 0LL;
    goto LABEL_199;
  }

  uint64_t v88 = (uint64_t *)TypeName;
  uint64_t v89 = TypeName;
  if ((v84 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080LL) != 0) {
      goto LABEL_112;
    }
    uint64_t v89 = TypeName + 1;
    while (v89 < (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFF0LL])
    {
      unint64_t v90 = v89->i64[0];
      unint64_t v91 = v89->i64[1];
      ++v89;
      if (((v91 | v90) & 0x8080808080808080LL) != 0) {
        goto LABEL_112;
      }
    }
  }

  if (v89 < (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFF8LL])
  {
    if ((v89->i64[0] & 0x8080808080808080LL) != 0) {
      goto LABEL_112;
    }
    uint64_t v89 = (uint8x16_t *)((char *)v89 + 8);
  }

  if (v89 < (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v89->i32[0] & 0x80808080) != 0) {
      goto LABEL_112;
    }
    uint64_t v89 = (uint8x16_t *)((char *)v89 + 4);
  }

  if (v89 >= (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_108:
    if (v89 >= (uint8x16_t *)&TypeName->i8[v84] || (v89->i8[0] & 0x80000000) == 0)
    {
      if (v84 > 15)
      {
        uint64_t v92 = 1;
LABEL_152:
        uint64_t v0 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( TypeName->i8,  v84,  v84,  v92 & 1);
        object = 0LL;
        unint64_t countAndFlagsBits = *(void *)(v0 + 24);
        goto LABEL_199;
      }

          v48(v25, a3);
LABEL_36:
          char v75 = v109;
          uint64_t v76 = v109(a3, a4);
          uint64_t v77 = v104;
          v50(v104, (uint64_t)v51, a3);
          if (v76 < 65)
          {
            unint64_t v78 = v75(a3, a4);
            v48(v77, a3);
            if (v78 != 64 || (v31(a3, a4) & 1) != 0) {
              goto LABEL_48;
            }
          }

          else
          {
            v48(v77, a3);
          }

          unint64_t v79 = v103;
          v50(v103, (uint64_t)v51, a3);
          uint64_t v111 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v80 = v31(a3, a4);
          unint64_t v81 = v109(a3, a4);
          if ((v80 & 1) != 0)
          {
            if (v81 > 64)
            {
              unint64_t v84 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
              uint64_t v86 = &v111;
              goto LABEL_46;
            }
          }

          else if (v81 > 63)
          {
            uint64_t v110 = 0x7FFFFFFFFFFFFFFFLL;
            unint64_t v84 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
            uint64_t v86 = &v110;
LABEL_46:
            v84(v86, &type metadata for Int, v85, a3, a4);
            uint64_t v87 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v79,  a3);
            v48(v29, a3);
            if ((v87 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_47;
          }

          v50(v29, (uint64_t)v79, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v29, a3);
LABEL_47:
          v48(v79, a3);
LABEL_48:
          uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v51, a3);
          goto LABEL_49;
        }
      }

          v48(v25, a3);
LABEL_36:
          char v75 = v109;
          uint64_t v76 = v109(a3, a4);
          uint64_t v77 = v104;
          v50(v104, (uint64_t)v51, a3);
          if (v76 < 65)
          {
            uint64_t v86 = v75(a3, a4);
            v48(v77, a3);
            if (v86 != 64 || (v31(a3, a4) & 1) != 0) {
              goto LABEL_49;
            }
          }

          else
          {
            v48(v77, a3);
          }

          unint64_t v78 = v103;
          v50(v103, (uint64_t)v51, a3);
          uint64_t v111 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v79 = v31(a3, a4);
          uint64_t v80 = v109(a3, a4);
          if ((v79 & 1) != 0)
          {
            if (v80 > 64)
            {
              uint64_t v83 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
              unint64_t v85 = &v111;
              goto LABEL_47;
            }
          }

          else if (v80 > 63)
          {
            uint64_t v110 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v83 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v84 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
            unint64_t v85 = &v110;
LABEL_47:
            v83(v85, &type metadata for Int, v84, a3, a4);
            uint64_t v87 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v78,  a3);
            v48(v29, a3);
            if ((v87 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_48;
          }

          v50(v29, (uint64_t)v78, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v29, a3);
LABEL_48:
          v48(v78, a3);
LABEL_49:
          uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v51, a3);
          goto LABEL_50;
        }
      }

        unint64_t v18 = HIDWORD(v17);
        LODWORD(v6) = *a1;
        break;
      default:
        abort();
    }
  }

  uint64_t v33 = a1[8];
  unint64_t v34 = 8LL * v18;
  uint64_t v35 = (v6 & 0x10000000) == 0;
  if ((v6 & 0x10000000) != 0) {
    uint64_t v36 = 0;
  }
  else {
    uint64_t v36 = a1[8];
  }
  uint64_t v37 = v36 + v18;
  if (v35) {
    uint64_t v38 = v17;
  }
  else {
    uint64_t v38 = v33 + v17;
  }
  if (v35) {
    uint64_t v39 = v34;
  }
  else {
    uint64_t v39 = -8LL * (v33 + v17);
  }
  BOOL result = v38 | (v37 << 32);
  *(_DWORD *)(a2 + 8) = v38;
  *(_DWORD *)(a2 + 12) = v37;
  atomic_store(v39, (unint64_t *)a2);
  return result;
}

  if (!result) {
    return result;
  }
  unint64_t v21 = 5LL;
  return (void *)(*(uint64_t (**)(void))(*result + 8 * v21))();
}

  if (!result) {
    return result;
  }
  unint64_t v21 = 5LL;
  return (void *)(*(uint64_t (**)(void))(*result + 8 * v21))();
}

  unint64_t v16 = 0LL;
  while (2)
  {
    if (v16) {
      std::string::append(this, "><", 2uLL);
    }
    unint64_t v17 = a2;
    unint64_t v18 = (_DWORD *)*((void *)v17 + v16);
    uint64_t v19 = *v18;
    if (!*v18)
    {
LABEL_37:
      continue;
    }

    break;
  }

  unint64_t v20 = 0LL;
  while (2)
  {
    if (v20)
    {
      std::string::append(this, ", ", 2uLL);
      if (v20 >= 0x80)
      {
        std::string::append(this, "...", 3uLL);
        goto LABEL_37;
      }
    }

    unint64_t v21 = *((unsigned __int8 *)a2 + 18);
    BOOL v22 = 1;
    unint64_t v23 = v10 - v9;
    uint64_t v24 = v9;
    while (2)
    {
      unint64_t v25 = *((unsigned __int8 *)a2 + 18);
      switch(v21)
      {
        case 1:
LABEL_55:
          if (v25 <= v24) {
            break;
          }
LABEL_56:
          uint64_t v26 = a2;
          uint64_t v27 = (uint64_t *)*((void *)v26 + v24);
          goto LABEL_61;
        case 5:
          goto LABEL_56;
        case 2:
          unint64_t v25 = 2LL;
          goto LABEL_55;
      }

      uint64_t v27 = 0LL;
LABEL_61:
      if (*((_WORD *)v27 + 8) != 42) {
        goto LABEL_50;
      }
      uint64_t v28 = *((unsigned __int8 *)v27 + 18);
      if (v28 == 5 && *((_DWORD *)v27 + 2))
      {
        uint64_t v27 = (uint64_t *)*v27;
LABEL_66:
        uint64_t v29 = (void *)*v27;
      }

      else
      {
        uint64_t v29 = 0LL;
      }

      if (*((_WORD *)v29 + 8) != 232) {
        goto LABEL_50;
      }
      uint64_t v30 = *((unsigned __int8 *)v29 + 18);
      if (v30 == 5 && *((_DWORD *)v29 + 2))
      {
        uint64_t v29 = (void *)*v29;
LABEL_73:
        uint64_t v31 = (void *)*v29;
      }

      else
      {
        uint64_t v31 = 0LL;
      }

      if (*((_WORD *)v31 + 8) != 38) {
        goto LABEL_50;
      }
      uint64_t v32 = *((unsigned __int8 *)v31 + 18);
      uint64_t v33 = (void **)v31;
      if (**v33 != v20) {
        goto LABEL_50;
      }
      if (v32 == 5) {
        uint64_t v31 = (void *)*v31;
      }
      if (*(void *)v31[1] != v16)
      {
LABEL_50:
        BOOL v22 = ++v24 < v10;
        if (!--v23) {
          break;
        }
        continue;
      }

      break;
    }

    if (v22) {
      std::string::append(this, "each ", 5uLL);
    }
LABEL_83:
    char v51 = v20;
    uint64_t v52 = v16;
    cap = this[3].__r_.__value_.__l.__cap_;
    if (cap)
    {
      (*(void (**)(void **__return_ptr, std::string::size_type, uint64_t *, unint64_t *))(*(void *)cap + 48LL))( __p,  cap,  &v52,  &v51);
      if ((v50 & 0x80u) == 0) {
        uint64_t v35 = __p;
      }
      else {
        uint64_t v35 = (void **)__p[0];
      }
      if ((v50 & 0x80u) == 0) {
        uint64_t v36 = v50;
      }
      else {
        uint64_t v36 = (std::string::size_type)__p[1];
      }
      std::string::append(this, (const std::string::value_type *)v35, v36);
      if (++v20 == v19) {
        goto LABEL_37;
      }
      continue;
    }

    break;
  }

  std::__throw_bad_function_call[abi:nn180100]();
  std::function<std::string ()(unsigned long long,unsigned long long)>::operator()();
}

    unint64_t v3 = v64;
    v64->__begin_ = v27;
    v64->__end_ = v15;
    v64->__end_cap_.__value_ = (unsigned int *)&v26[4 * v66];
    if (v21) {
      operator delete(v21);
    }
    unint64_t v13 = v65;
    goto LABEL_14;
  }

  *((_DWORD *)this + 3184) = v12 + 1;
  v14[v12] = 121;
LABEL_36:
  BOOL result = swift::Demangle::__runtime::CharVector::append((char **)this + 1591, "XZ", 2uLL, this[1593]);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

      unint64_t v5 = (const void **)*v5;
      goto LABEL_36;
    }

    unint64_t v13 = (void *)*((void *)this + 1593);
    unint64_t v14 = (_BYTE *)v13[1];
    if (&v12[v11] == v14)
    {
      unint64_t v16 = (unint64_t)&v12[v11 + 1];
      unint64_t v15 = v13[2];
      if (v16 <= v15)
      {
        v13[1] = v16;
        LODWORD(v17) = 1;
LABEL_25:
        *((_DWORD *)this + 3185) = v11 + v17;
        goto LABEL_26;
      }
    }

    else
    {
      unint64_t v15 = v13[2];
    }

    else {
      unint64_t v17 = (2 * v11);
    }
    unint64_t v18 = v17 + v11;
    if (v14) {
      uint64_t v19 = (unint64_t)&v14[v17 + v11] > v15;
    }
    else {
      uint64_t v19 = 1;
    }
    unint64_t v12 = (_BYTE *)v13[1];
    if (v19)
    {
      unint64_t v20 = 2LL * v13[4];
      if (v20 <= v18 + 1) {
        unint64_t v20 = v18 + 1;
      }
      v13[4] = v20;
      uint64_t v29 = v17;
      unint64_t v17 = v20 + 8;
      unint64_t v21 = malloc(v20 + 8);
      *unint64_t v21 = v13[3];
      unint64_t v12 = v21 + 1;
      BOOL v22 = (char *)v21 + v17;
      LODWORD(v17) = v29;
      _OWORD v13[2] = v22;
      v13[3] = v21;
    }

    v13[1] = &v12[v18];
    if ((_DWORD)v11)
    {
      memcpy(v12, *((const void **)this + 1591), v11);
      LODWORD(v11) = *((_DWORD *)this + 3185);
      uint64_t v10 = *((_DWORD *)this + 3184);
    }

    *((void *)this + 1591) = v12;
    goto LABEL_25;
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  uint64_t v8 = (_DWORD *)(a4 + 16);
LABEL_37:
  *uint64_t v8 = 0;
}

uint64_t static FixedWidthInteger._convert<A>(from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v325 = *(void *)(a3 - 8);
  uint64_t v326 = a1;
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v299 = (char *)&v286 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  v298 = (char *)&v286 - v13;
  MEMORY[0x1895F8858](v12);
  unint64_t v297 = (char *)&v286 - v14;
  uint64_t v337 = v15;
  uint64_t v339 = *(void *)(v15 + 8);
  uint64_t v16 = *(void *)(v339 + 24);
  uint64_t v302 = *(const char **)(v16 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v302,  v17,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v301 = (char *)&v286 - v18;
  unint64_t v19 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v16,  a3,  (uint64_t)&protocol requirements base descriptor for Numeric,  associated type descriptor for Numeric.Magnitude);
  uint64_t v289 = v16;
  int64_t v311 = *(const char **)(swift_getAssociatedConformanceWitness( v16,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)
                        + 16);
  unint64_t v312 = swift_getAssociatedTypeWitness( 0LL,  v311,  v19,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v312);
  int64_t v313 = (char *)&v286 - v20;
  uint64_t v343 = a3;
  uint64_t v291 = type metadata accessor for Optional((const char *)0xFF, a3, v21, v22);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v291, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v290 = (char *)&v286 - v24;
  uint64_t v341 = swift_checkMetadataState(0LL, v19);
  uint64_t v328 = *(v341 - 1);
  uint64_t v25 = MEMORY[0x1895F8858](v341);
  uint64_t v309 = (char *)&v286 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v310 = (char *)&v286 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v288 = (char *)&v286 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  char v292 = (char *)&v286 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  uint64_t v327 = (char *)&v286 - v34;
  MEMORY[0x1895F8858](v33);
  uint64_t v332 = (char *)&v286 - v35;
  unint64_t v319 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  associated type descriptor for BinaryFloatingPoint.RawSignificand);
  uint64_t v314 = *(void *)(v319 - 8);
  uint64_t v36 = MEMORY[0x1895F8858](v319);
  uint64_t v315 = (char *)&v286 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  uint64_t v39 = (char *)&v286 - v38;
  unint64_t v333 = a6;
  uint64_t v40 = *(void *)(a6 + 16);
  unint64_t v41 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v40,  a4,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  associated type descriptor for FloatingPoint.Exponent);
  uint64_t v42 = a2;
  uint64_t v335 = *(void *)(swift_getAssociatedConformanceWitness( v40,  a4,  v41,  (uint64_t)&protocol requirements base descriptor for FloatingPoint,  (uint64_t)&associated conformance descriptor for FloatingPoint.FloatingPoint.Exponent: SignedInteger)
                   + 8);
  uint64_t v317 = *(void *)(v335 + 24);
  uint64_t v43 = *(const char **)(v317 + 16);
  unint64_t v305 = swift_getAssociatedTypeWitness( 0LL,  v43,  v41,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v305);
  uint64_t v303 = (char *)&v286 - v44;
  uint64_t v45 = swift_checkMetadataState(0LL, v41);
  uint64_t v336 = (void (**)(char *, void, unint64_t *))*(v45 - 1);
  uint64_t v46 = MEMORY[0x1895F8858](v45);
  uint64_t v295 = (char *)&v286 - ((v47 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  BOOL v316 = (char *)&v286 - v49;
  uint64_t v50 = MEMORY[0x1895F8858](v48);
  uint64_t v293 = (char *)&v286 - v51;
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  uint64_t v294 = (char *)&v286 - v53;
  uint64_t v54 = MEMORY[0x1895F8858](v52);
  unint64_t v318 = (char *)&v286 - v55;
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  uint64_t v306 = (char *)&v286 - v57;
  uint64_t v58 = MEMORY[0x1895F8858](v56);
  int64_t v330 = (char *)&v286 - v59;
  uint64_t v60 = MEMORY[0x1895F8858](v58);
  unint64_t v329 = (char *)&v286 - v61;
  MEMORY[0x1895F8858](v60);
  v342 = (char *)&v286 - v62;
  int64_t v324 = *(const char **)(*(void *)(*(void *)(v40 + 16) + 8LL) + 16LL);
  unint64_t v63 = swift_getAssociatedTypeWitness( 0LL,  v324,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v64 = MEMORY[0x1895F8858](v63);
  uint64_t v322 = (char *)&v286 - v65;
  uint64_t v66 = *(void *)(a4 - 8);
  uint64_t v67 = MEMORY[0x1895F8858](v64);
  char v308 = (char *)&v286 - ((v68 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v69 = MEMORY[0x1895F8858](v67);
  v323 = (char *)&v286 - v70;
  MEMORY[0x1895F8858](v69);
  unint64_t v72 = (char *)&v286 - v71;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v40 + 384))(a4, v40) & 1) != 0)
  {
    uint64_t v248 = v302;
    uint64_t v249 = v343;
    unint64_t v250 = AssociatedTypeWitness;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v302,  v343,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    unint64_t v252 = v301;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v250,  AssociatedConformanceWitness);
    uint64_t v253 = v326;
    (*((void (**)(char *, uint64_t, const char *))v248 + 3))(v252, v249, v248);
    char v160 = 1;
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v325 + 56))(v253, 0LL, 1LL, v249);
    return v160 & 1;
  }

  uint64_t v73 = *(uint64_t (**)(uint64_t, uint64_t))(v40 + 376);
  uint64_t v338 = v40;
  if ((v73(a4, v40) & 1) == 0) {
    goto LABEL_46;
  }
  uint64_t v331 = *(uint64_t (**)(void))(v339 + 64);
  char v74 = v331();
  char v75 = *(void (**)(char *, uint64_t, uint64_t))(v66 + 16);
  uint64_t v340 = v42;
  uint64_t v307 = v75;
  v75(v72, v42, a4);
  unint64_t v304 = v63;
  if ((v74 & 1) != 0)
  {
    uint64_t v76 = *(void (**)(char *, uint64_t))(v66 + 8);
    v76(v72, a4);
    uint64_t v77 = v338;
    unint64_t v78 = v342;
    unint64_t v79 = v336;
    uint64_t v80 = v39;
    goto LABEL_6;
  }

  unint64_t v81 = v324;
  unint64_t v82 = swift_getAssociatedConformanceWitness( (uint64_t)v324,  a4,  v63,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v83 = v322;
  (*(void (**)(void *, uint64_t))(v82 + 8))(&unk_18180BE78, 257LL);
  unint64_t v84 = v323;
  (*((void (**)(char *, uint64_t, const char *))v81 + 3))(v83, a4, v81);
  uint64_t v85 = v338;
  char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v338 + 24) + 8LL) + 40LL))( v72,  v84,  a4);
  uint64_t v76 = *(void (**)(char *, uint64_t))(v66 + 8);
  uint64_t v77 = v85;
  v76(v84, a4);
  v76(v72, a4);
  unint64_t v78 = v342;
  unint64_t v79 = v336;
  uint64_t v80 = v39;
  if ((v86 & 1) != 0)
  {
LABEL_6:
    uint64_t v287 = v43;
    uint64_t v87 = *(void (**)(uint64_t, uint64_t))(v77 + 176);
    uint64_t v334 = a4;
    v87(a4, v77);
    uint64_t v296 = *(uint64_t (**)(void))(v337 + 56);
    uint64_t v88 = v296();
    uint64_t v89 = v335;
    unint64_t v90 = *(uint64_t (**)(unint64_t *, uint64_t))(v335 + 64);
    char v91 = v90(v45, v335);
    unint64_t v321 = v90;
    if ((v91 & 1) != 0)
    {
      uint64_t v320 = *(uint64_t (**)(unint64_t *, uint64_t))(v89 + 128);
      uint64_t v92 = v320(v45, v89);
      if (v92 < 64)
      {
        uint64_t v95 = v329;
        ((void (**)(char *, char *, unint64_t *))v79)[2](v329, v78, v45);
        goto LABEL_18;
      }

      uint64_t v344 = v88;
      uint64_t v103 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v89 + 96);
      unint64_t v104 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      uint64_t v95 = v329;
      v103(&v344, &type metadata for Int, v104, v45, v89);
      char v102 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32) + 8LL)
                                                                           + 16LL))( v78,  v95,  v45);
      goto LABEL_13;
    }

    char v96 = v90(v45, v89);
    uint64_t v320 = *(uint64_t (**)(unint64_t *, uint64_t))(v89 + 128);
    uint64_t v97 = v320(v45, v89);
    if ((v96 & 1) != 0)
    {
      if (v97 > 64)
      {
        uint64_t v344 = v88;
        uint64_t v100 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v89 + 96);
        unint64_t v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
        uint64_t v95 = v329;
        v100(&v344, &type metadata for Int, v101, v45, v89);
        unint64_t v78 = v342;
        char v102 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32) + 8LL)
                                                                             + 16LL))( v342,  v95,  v45);
LABEL_13:
        char v105 = v102;
        uint64_t v106 = (void (*)(char *, unint64_t *))v79[1];
        v106(v95, v45);
        if ((v105 & 1) != 0) {
          goto LABEL_19;
        }
        goto LABEL_45;
      }

      uint64_t v306 = v80;
      uint64_t v129 = (uint64_t)v287;
      unint64_t v130 = v305;
      unint64_t v131 = swift_getAssociatedConformanceWitness( (uint64_t)v287,  (uint64_t)v45,  v305,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v132 = v303;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v131 + 8))( &unk_18180BE68,  256LL,  v130,  v131);
      uint64_t v95 = v329;
      (*(void (**)(char *, unint64_t *, uint64_t))(v129 + 24))(v132, v45, v129);
      uint64_t v133 = v342;
      char v134 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32) + 8LL)
                                                                           + 16LL))( v342,  v95,  v45);
      uint64_t v106 = (void (*)(char *, unint64_t *))v79[1];
      v106(v95, v45);
      char v135 = v330;
      ((void (**)(char *, char *, unint64_t *))v79)[2](v330, v133, v45);
      if ((v134 & 1) != 0)
      {
        v106(v135, v45);
        unint64_t v78 = v342;
        uint64_t v80 = v306;
        goto LABEL_19;
      }

      uint64_t v158 = (*(uint64_t (**)(unint64_t *, uint64_t))(v89 + 120))(v45, v89);
      v106(v135, v45);
      BOOL v159 = v158 < v88;
      unint64_t v78 = v342;
      uint64_t v80 = v306;
      if (!v159)
      {
LABEL_45:
        v106(v78, v45);
        goto LABEL_46;
      }
    }

    else
    {
      if (v97 < 64)
      {
        uint64_t v95 = v329;
        unint64_t v78 = v342;
        ((void (**)(char *, char *, unint64_t *))v79)[2](v329, v342, v45);
LABEL_18:
        uint64_t v107 = (*(uint64_t (**)(unint64_t *, uint64_t))(v89 + 120))(v45, v89);
        uint64_t v106 = (void (*)(char *, unint64_t *))v79[1];
        v106(v95, v45);
        if (v107 < v88) {
          goto LABEL_19;
        }
        goto LABEL_45;
      }

      uint64_t v136 = v306;
      uint64_t v137 = ((uint64_t (*)(char *, char *, unint64_t *))v79[2])(v306, v342, v45);
      uint64_t v95 = v329;
      if (v88 <= 0)
      {
        uint64_t v106 = (void (*)(char *, unint64_t *))v79[1];
        v106(v136, v45);
        unint64_t v78 = v342;
        goto LABEL_45;
      }

      uint64_t v344 = v88;
      uint64_t v140 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v89 + 96);
      unint64_t v141 = lazy protocol witness table accessor for type Int and conformance Int(v137, v138, v139);
      uint64_t v142 = v136;
      v140(&v344, &type metadata for Int, v141, v45, v89);
      char v143 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v89 + 32) + 8LL)
                                                                           + 16LL))( v136,  v95,  v45);
      uint64_t v106 = (void (*)(char *, unint64_t *))v79[1];
      v106(v95, v45);
      v106(v142, v45);
      unint64_t v78 = v342;
      if ((v143 & 1) == 0) {
        goto LABEL_45;
      }
    }

unint64_t specialized FixedWidthInteger.init<A>(_:)(double a1)
{
  if ((v58 & 1) != 0)
  {
    unint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(80LL);
    unint64_t v4 = v3;
    unint64_t v56 = v2;
    unint64_t v57 = v3;
    TypeName = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for Double, 0);
    if (v6 < 0) {
      goto LABEL_66;
    }
    uint64_t v7 = (uint8x16_t *)TypeName;
    int64_t v8 = v6;
    int64_t v9 = validateUTF8(_:)(TypeName, v6);
    if ((v11 & 1) != 0) {
      unint64_t v12 = repairUTF8(_:firstKnownBrokenRange:)(v7->i8, v8, v9, v10);
    }
    else {
      unint64_t v12 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v7, v8, v9 & 1);
    }
    unint64_t v14 = v12;
    unint64_t v15 = v13;
    uint64_t v16 = HIBYTE(v4) & 0xF;
    if ((v4 & 0x2000000000000000LL) == 0) {
      uint64_t v16 = v2 & 0xFFFFFFFFFFFFLL;
    }
    if (!v16 && (v2 & ~v4 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v4);
      unint64_t v56 = v14;
      unint64_t v57 = v15;
      goto LABEL_21;
    }

    if ((v4 & 0x2000000000000000LL) != 0)
    {
      if ((v13 & 0x2000000000000000LL) != 0)
      {
        unint64_t v18 = specialized _SmallString.init(_:appending:)(v2, v4, v12, v13);
        if ((v20 & 1) == 0)
        {
          unint64_t v21 = v18;
          unint64_t v22 = v19;
          swift_bridgeObjectRelease(v4);
          swift_bridgeObjectRelease(v15);
          unint64_t v56 = v21;
          unint64_t v57 = v22;
          unint64_t v15 = v22;
          unint64_t v14 = v21;
          goto LABEL_21;
        }

        goto LABEL_19;
      }
    }

    else if ((v13 & 0x2000000000000000LL) != 0)
    {
LABEL_19:
      uint64_t v17 = HIBYTE(v15) & 0xF;
      goto LABEL_20;
    }

    uint64_t v17 = v12 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v14, v15, 0LL, v17);
    swift_bridgeObjectRelease(v15);
    unint64_t v14 = v56;
    unint64_t v15 = v57;
LABEL_21:
    uint64_t v23 = HIBYTE(v15) & 0xF;
    if ((v15 & 0x2000000000000000LL) == 0) {
      uint64_t v23 = v14 & 0xFFFFFFFFFFFFLL;
    }
    if (v23 || (v14 & ~v15 & 0x2000000000000000LL) != 0)
    {
      if ((v15 & 0x2000000000000000LL) != 0
        && (0x80000001818B69D0LL & 0x2000000000000000LL) != 0
        && (unint64_t v24 = specialized _SmallString.init(_:appending:)( v14,  v15,  0xD00000000000001ELL,  0x80000001818B69D0LL | 0x8000000000000000LL),  (v26 & 1) == 0))
      {
        unint64_t v27 = v24;
        unint64_t v28 = v25;
        swift_bridgeObjectRelease(v15);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
        unint64_t v56 = v27;
        unint64_t v57 = v28;
      }

      else
      {
        if ((0x80000001818B69D0LL & 0x2000000000000000LL) != 0) {
          unint64_t v29 = (0x80000001818B69D0LL >> 56) & 0xF;
        }
        else {
          unint64_t v29 = 30LL;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001818B69D0LL | 0x8000000000000000LL, 0LL, v29);
        swift_bridgeObjectRelease(0x80000001818B69D0LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v15);
      unint64_t v56 = 0xD00000000000001ELL;
      unint64_t v57 = 0x80000001818B69D0LL | 0x8000000000000000LL;
    }

    uint64_t v30 = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for _Int128, 0);
    if ((v31 & 0x8000000000000000LL) == 0)
    {
      uint64_t v32 = (uint8x16_t *)v30;
      int64_t v33 = v31;
      int64_t v34 = validateUTF8(_:)(v30, v31);
      if ((v36 & 1) != 0) {
        unint64_t v37 = repairUTF8(_:firstKnownBrokenRange:)(v32->i8, v33, v34, v35);
      }
      else {
        unint64_t v37 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v32, v33, v34 & 1);
      }
      unint64_t v39 = v37;
      unint64_t v40 = v38;
      uint64_t v41 = v57;
      unint64_t v42 = HIBYTE(v57) & 0xF;
      if ((v57 & 0x2000000000000000LL) == 0) {
        unint64_t v42 = v56 & 0xFFFFFFFFFFFFLL;
      }
      if (!v42 && (v56 & ~v57 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v57);
        unint64_t v56 = v39;
        unint64_t v57 = v40;
        goto LABEL_52;
      }

      if ((v57 & 0x2000000000000000LL) != 0)
      {
        if ((v38 & 0x2000000000000000LL) != 0)
        {
          unint64_t v44 = specialized _SmallString.init(_:appending:)(v56, v57, v37, v38);
          if ((v46 & 1) == 0)
          {
            unint64_t v47 = v44;
            unint64_t v48 = v45;
            swift_bridgeObjectRelease(v41);
            swift_bridgeObjectRelease(v40);
            unint64_t v56 = v47;
            unint64_t v57 = v48;
            unint64_t v40 = v48;
            unint64_t v39 = v47;
            goto LABEL_52;
          }

          goto LABEL_50;
        }
      }

      else if ((v38 & 0x2000000000000000LL) != 0)
      {
LABEL_50:
        uint64_t v43 = HIBYTE(v40) & 0xF;
        goto LABEL_51;
      }

      uint64_t v43 = v37 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v39, v40, 0LL, v43);
      swift_bridgeObjectRelease(v40);
      unint64_t v39 = v56;
      unint64_t v40 = v57;
LABEL_52:
      uint64_t v49 = HIBYTE(v40) & 0xF;
      if ((v40 & 0x2000000000000000LL) == 0) {
        uint64_t v49 = v39 & 0xFFFFFFFFFFFFLL;
      }
      if (v49 || (v39 & ~v40 & 0x2000000000000000LL) != 0)
      {
        if ((v40 & 0x2000000000000000LL) != 0
          && (0x80000001818B69F0LL & 0x2000000000000000LL) != 0
          && (unint64_t v52 = specialized _SmallString.init(_:appending:)( v39,  v40,  0xD00000000000002ELL,  0x80000001818B69F0LL | 0x8000000000000000LL),  (v54 & 1) == 0))
        {
          uint64_t v51 = (char *)v52;
          unint64_t v50 = v53;
          swift_bridgeObjectRelease(v40);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
        }

        else
        {
          if ((0x80000001818B69F0LL & 0x2000000000000000LL) != 0) {
            unint64_t v55 = (0x80000001818B69F0LL >> 56) & 0xF;
          }
          else {
            unint64_t v55 = 46LL;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001818B69F0LL | 0x8000000000000000LL, 0LL, v55);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
          uint64_t v51 = (char *)v56;
          unint64_t v50 = v57;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v40);
        unint64_t v50 = 0x80000001818B69F0LL | 0x8000000000000000LL;
        uint64_t v51 = (char *)0xD00000000000002ELL;
      }

      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v51,  v50,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
    }

uint64_t FixedWidthInteger.init<A>(_:)@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  unint64_t v15 = (char *)&v72 - v14;
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v72 - v14, a1, a2, a3, a4, a5);
  uint64_t v16 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v16 + 48))(v15, 1LL, a2) == 1)
  {
    (*(void (**)(char *, uint64_t))(v13 + 8))(v15, v12);
    unint64_t v18 = specialized static String._createEmpty(withInitialCapacity:)(80LL);
    unint64_t v20 = v19;
    unint64_t v72 = v18;
    unint64_t v73 = v19;
    TypeName = (uint64_t *)swift_getTypeName(a3, 0);
    if (v22 < 0) {
      goto LABEL_66;
    }
    uint64_t v23 = (uint8x16_t *)TypeName;
    int64_t v24 = v22;
    int64_t v25 = validateUTF8(_:)(TypeName, v22);
    if ((v27 & 1) != 0) {
      unint64_t v28 = repairUTF8(_:firstKnownBrokenRange:)(v23->i8, v24, v25, v26);
    }
    else {
      unint64_t v28 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v23, v24, v25 & 1);
    }
    unint64_t v30 = v28;
    unint64_t v31 = v29;
    uint64_t v32 = HIBYTE(v20) & 0xF;
    if ((v20 & 0x2000000000000000LL) == 0) {
      uint64_t v32 = v18 & 0xFFFFFFFFFFFFLL;
    }
    if (!v32 && (v18 & ~v20 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v20);
      unint64_t v72 = v30;
      unint64_t v73 = v31;
      goto LABEL_21;
    }

    if ((v20 & 0x2000000000000000LL) != 0)
    {
      if ((v29 & 0x2000000000000000LL) != 0)
      {
        unint64_t v34 = specialized _SmallString.init(_:appending:)(v18, v20, v28, v29);
        if ((v36 & 1) == 0)
        {
          unint64_t v37 = v34;
          unint64_t v38 = v35;
          swift_bridgeObjectRelease(v31);
          swift_bridgeObjectRelease(v20);
          unint64_t v72 = v37;
          unint64_t v73 = v38;
          unint64_t v31 = v38;
          unint64_t v30 = v37;
          goto LABEL_21;
        }

        goto LABEL_19;
      }
    }

    else if ((v29 & 0x2000000000000000LL) != 0)
    {
LABEL_19:
      uint64_t v33 = HIBYTE(v31) & 0xF;
      goto LABEL_20;
    }

    uint64_t v33 = v28 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v30, v31, 0LL, v33);
    swift_bridgeObjectRelease(v31);
    unint64_t v30 = v72;
    unint64_t v31 = v73;
LABEL_21:
    uint64_t v39 = HIBYTE(v31) & 0xF;
    if ((v31 & 0x2000000000000000LL) == 0) {
      uint64_t v39 = v30 & 0xFFFFFFFFFFFFLL;
    }
    if (v39 || (v30 & ~v31 & 0x2000000000000000LL) != 0)
    {
      if ((v31 & 0x2000000000000000LL) != 0
        && ((unint64_t)"Swift/Random.swift" & 0x2000000000000000LL) != 0
        && (unint64_t v40 = specialized _SmallString.init(_:appending:)(v30, v31, 0xD00000000000001ELL, 0x80000001818B69D0LL),
            (v42 & 1) == 0))
      {
        unint64_t v43 = v40;
        unint64_t v44 = v41;
        swift_bridgeObjectRelease(v31);
        unint64_t v72 = v43;
        unint64_t v73 = v44;
      }

      else
      {
        else {
          unint64_t v45 = 30LL;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001818B69D0LL, 0LL, v45);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v31);
      unint64_t v72 = 0xD00000000000001ELL;
      unint64_t v73 = 0x80000001818B69D0LL;
    }

    char v46 = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v47 & 0x8000000000000000LL) == 0)
    {
      unint64_t v48 = (uint8x16_t *)v46;
      int64_t v49 = v47;
      int64_t v50 = validateUTF8(_:)(v46, v47);
      if ((v52 & 1) != 0) {
        unint64_t v53 = repairUTF8(_:firstKnownBrokenRange:)(v48->i8, v49, v50, v51);
      }
      else {
        unint64_t v53 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v48, v49, v50 & 1);
      }
      unint64_t v55 = v53;
      unint64_t v56 = v54;
      uint64_t v57 = v73;
      unint64_t v58 = HIBYTE(v73) & 0xF;
      if ((v73 & 0x2000000000000000LL) == 0) {
        unint64_t v58 = v72 & 0xFFFFFFFFFFFFLL;
      }
      if (!v58 && (v72 & ~v73 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v73);
        unint64_t v72 = v55;
        unint64_t v73 = v56;
        goto LABEL_52;
      }

      if ((v73 & 0x2000000000000000LL) != 0)
      {
        if ((v54 & 0x2000000000000000LL) != 0)
        {
          unint64_t v60 = specialized _SmallString.init(_:appending:)(v72, v73, v53, v54);
          if ((v62 & 1) == 0)
          {
            unint64_t v63 = v60;
            unint64_t v64 = v61;
            swift_bridgeObjectRelease(v56);
            swift_bridgeObjectRelease(v57);
            unint64_t v72 = v63;
            unint64_t v73 = v64;
            unint64_t v56 = v64;
            unint64_t v55 = v63;
            goto LABEL_52;
          }

          goto LABEL_50;
        }
      }

      else if ((v54 & 0x2000000000000000LL) != 0)
      {
LABEL_50:
        uint64_t v59 = HIBYTE(v56) & 0xF;
        goto LABEL_51;
      }

      uint64_t v59 = v53 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v55, v56, 0LL, v59);
      swift_bridgeObjectRelease(v56);
      unint64_t v55 = v72;
      unint64_t v56 = v73;
LABEL_52:
      uint64_t v65 = HIBYTE(v56) & 0xF;
      if ((v56 & 0x2000000000000000LL) == 0) {
        uint64_t v65 = v55 & 0xFFFFFFFFFFFFLL;
      }
      if (v65 || (v55 & ~v56 & 0x2000000000000000LL) != 0)
      {
        if ((v56 & 0x2000000000000000LL) != 0
          && (0x80000001818B69F0LL & 0x2000000000000000LL) != 0
          && (unint64_t v68 = specialized _SmallString.init(_:appending:)( v55,  v56,  0xD00000000000002ELL,  0x80000001818B69F0LL | 0x8000000000000000LL),  (v70 & 1) == 0))
        {
          uint64_t v67 = (char *)v68;
          unint64_t v66 = v69;
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
          swift_bridgeObjectRelease(v56);
        }

        else
        {
          if ((0x80000001818B69F0LL & 0x2000000000000000LL) != 0) {
            unint64_t v71 = (0x80000001818B69F0LL >> 56) & 0xF;
          }
          else {
            unint64_t v71 = 46LL;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001818B69F0LL | 0x8000000000000000LL, 0LL, v71);
          swift_bridgeObjectRelease(0x80000001818B69F0LL | 0x8000000000000000LL);
          uint64_t v67 = (char *)v72;
          unint64_t v66 = v73;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v56);
        unint64_t v66 = 0x80000001818B69F0LL | 0x8000000000000000LL;
        uint64_t v67 = (char *)0xD00000000000002ELL;
      }

      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  v67,  v66,  "Swift/Integers.swift",  20LL,  2,  0xBFFuLL,  0);
    }

uint64_t FixedWidthInteger.init<A>(exactly:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = type metadata accessor for Optional(0LL, a2, a3, a4);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v22 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  unint64_t v18 = (char *)&v22 - v17;
  LOBYTE(a5) = static FixedWidthInteger._convert<A>(from:)((uint64_t)&v22 - v17, a1, a2, a3, a4, a5);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(a1, a3);
  if ((a5 & 1) != 0)
  {
    (*(void (**)(char *, char *, uint64_t))(v13 + 32))(v16, v18, v12);
    uint64_t v19 = *(void *)(a2 - 8);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v19 + 48))(v16, 1LL, a2) != 1)
    {
      (*(void (**)(uint64_t, char *, uint64_t))(v19 + 32))(a6, v16, a2);
      uint64_t v20 = 0LL;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 56))(a6, v20, 1LL, a2);
    }

    (*(void (**)(char *, uint64_t))(v13 + 8))(v16, v12);
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v13 + 8))(v18, v12);
    uint64_t v19 = *(void *)(a2 - 8);
  }

  uint64_t v20 = 1LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 56))(a6, v20, 1LL, a2);
}

uint64_t FixedWidthInteger.init<A>(clamping:)@<X0>( void (*a1)(void, void)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7 = a4;
  uint64_t v154 = a1;
  uint64_t v149 = a6;
  uint64_t v10 = *(void *)(a4 + 8);
  char v143 = *(const char **)(*(void *)(v10 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v143,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v141 = (char *)&v129 - v11;
  uint64_t v140 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t v139 = swift_getAssociatedTypeWitness( 0LL,  v140,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](v139);
  uint64_t v138 = (char *)&v129 - v13;
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v133 = (char *)&v129 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  char v134 = (char *)&v129 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v137 = (char *)&v129 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v136 = (char *)&v129 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v155 = (char *)&v129 - v24;
  uint64_t v152 = *(void *)(a2 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v132 = (char *)&v129 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v131 = (char *)&v129 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v153 = (char *)&v129 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v129 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  char v135 = (char *)&v129 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v151 = (char *)&v129 - v37;
  MEMORY[0x1895F8858](v36);
  uint64_t v39 = (char *)&v129 - v38;
  unint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 72);
  uint64_t v150 = v7;
  unint64_t v130 = v40;
  v40(a2, v7);
  unint64_t v41 = *(unsigned int (**)(uint64_t, uint64_t))(a5 + 64);
  LODWORD(v7) = v41(a3, a5);
  unint64_t v148 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 64);
  int v42 = v148(a2, v10);
  unint64_t v147 = v41;
  if (((v7 ^ v42) & 1) == 0)
  {
    uint64_t v50 = v14;
    unint64_t v48 = v154;
    unint64_t v146 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v51 = v146(a3, a5);
    unint64_t v145 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 128);
    if (v51 >= v145(a2, v10))
    {
      unint64_t v60 = v155;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v39, a2, v10, a3, a5);
      char v54 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                            + 16LL))( v48,  v60,  a3);
      (*(void (**)(char *, uint64_t))(v50 + 8))(v60, a3);
      goto LABEL_11;
    }

    char v52 = v155;
    (*(void (**)(char *, void (*)(void, void), uint64_t))(v50 + 16))(v155, v48, a3);
    unint64_t v53 = v151;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))(v52, a3, a5, a2, v10);
    char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL) + 16LL))( v53,  v39,  a2);
    unint64_t v55 = *(void (**)(char *, uint64_t))(v152 + 8);
    v55(v53, a2);
LABEL_9:
    v55(v39, a2);
LABEL_11:
    uint64_t v61 = v150;
LABEL_12:
    char v62 = v153;
    if ((v54 & 1) == 0) {
      goto LABEL_23;
    }
LABEL_16:
    (*(void (**)(void, uint64_t))(v50 + 8))(v48, a3);
    return v130(a2, v61);
  }

  uint64_t v144 = v14;
  char v43 = v41(a3, a5);
  unint64_t v146 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
  uint64_t v44 = v146(a3, a5);
  unint64_t v45 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 128);
  uint64_t v46 = v45(a2, v10);
  if ((v43 & 1) == 0)
  {
    unint64_t v145 = v45;
    if (v44 >= v46)
    {
      unint64_t v74 = AssociatedTypeWitness;
      char v75 = v143;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v143,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v77 = v141;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v74,  AssociatedConformanceWitness);
      unint64_t v78 = v151;
      (*((void (**)(char *, uint64_t, const char *))v75 + 3))(v77, a2, v75);
      LOBYTE(v74) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL) + 40LL))( v39,  v78,  a2);
      uint64_t v79 = v152;
      uint64_t v80 = *(void (**)(char *, uint64_t))(v152 + 8);
      v80(v78, a2);
      unint64_t v81 = v137;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v144 + 16))(v137, v154, a3);
      (*(void (**)(char *, char *, uint64_t))(v79 + 32))(v33, v39, a2);
      unint64_t v82 = v155;
      if ((v74 & 1) == 0)
      {
        v80(v33, a2);
        uint64_t v50 = v144;
        (*(void (**)(char *, uint64_t))(v144 + 8))(v81, a3);
        uint64_t v61 = v150;
        char v62 = v153;
        unint64_t v48 = v154;
        goto LABEL_23;
      }

      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v33, a2, v10, a3, a5);
      char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v81,  v82,  a3);
      uint64_t v50 = v144;
      uint64_t v83 = *(void (**)(char *, uint64_t))(v144 + 8);
      v83(v82, a3);
      v83(v81, a3);
      uint64_t v61 = v150;
      unint64_t v48 = v154;
      goto LABEL_12;
    }

    uint64_t v56 = v144;
    unint64_t v48 = v154;
    uint64_t v57 = v155;
    (*(void (**)(char *, void (*)(void, void), uint64_t))(v144 + 16))(v155, v154, a3);
    unint64_t v58 = v151;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))(v57, a3, a5, a2, v10);
    char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL) + 16LL))( v58,  v39,  a2);
    unint64_t v55 = *(void (**)(char *, uint64_t))(v152 + 8);
    uint64_t v59 = v58;
    uint64_t v50 = v56;
    v55(v59, a2);
    goto LABEL_9;
  }

  if (v46 < v44)
  {
    unint64_t v145 = v45;
    uint64_t v47 = v155;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v39, a2, v10, a3, a5);
    unint64_t v48 = v154;
    char v49 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                          + 16LL))( v154,  v47,  a3);
    uint64_t v50 = v144;
    (*(void (**)(char *, uint64_t))(v144 + 8))(v47, a3);
    goto LABEL_20;
  }

  unint64_t v63 = v139;
  unint64_t v64 = v140;
  unint64_t v65 = swift_getAssociatedConformanceWitness( (uint64_t)v140,  a3,  v139,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v66 = v138;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v65 + 8))( &qword_18180BE68,  256LL,  v63,  v65);
  uint64_t v67 = v155;
  (*((void (**)(char *, uint64_t, const char *))v64 + 3))(v66, a3, v64);
  unint64_t v68 = v154;
  LOBYTE(v63) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                                + 16LL))( v154,  v67,  a3);
  uint64_t v69 = v144;
  unint64_t v145 = *(uint64_t (**)(uint64_t, uint64_t))(v144 + 8);
  v145((uint64_t)v67, a3);
  char v70 = v136;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v69 + 16))(v136, v68, a3);
  uint64_t v71 = v152;
  unint64_t v72 = v135;
  (*(void (**)(char *, char *, uint64_t))(v152 + 32))(v135, v39, a2);
  if ((v63 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v71 + 8))(v72, a2);
    v145((uint64_t)v70, a3);
    unint64_t v48 = v154;
    uint64_t v50 = v144;
    uint64_t v61 = v150;
    goto LABEL_16;
  }

  unint64_t v145 = v45;
  unint64_t v84 = v72;
  uint64_t v85 = v151;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))(v70, a3, a5, a2, v10);
  char v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL) + 16LL))( v85,  v84,  a2);
  char v86 = *(void (**)(char *, uint64_t))(v71 + 8);
  v86(v85, a2);
  v86(v84, a2);
  unint64_t v48 = v154;
  uint64_t v50 = v144;
LABEL_20:
  char v62 = v153;
  uint64_t v61 = v150;
  if ((v49 & 1) != 0) {
    goto LABEL_16;
  }
LABEL_23:
  uint64_t v154 = *(void (**)(void, void))(v61 + 64);
  v154(a2, v61);
  uint64_t v87 = v148;
  int v88 = v148(a2, v10);
  if (((v88 ^ v147(a3, a5)) & 1) != 0)
  {
    char v89 = v87(a2, v10);
    unint64_t v90 = v48;
    char v91 = v89;
    uint64_t v92 = v145(a2, v10);
    uint64_t v93 = v90;
    uint64_t v94 = v146(a3, a5);
    if ((v91 & 1) != 0)
    {
      if (v94 >= v92)
      {
        unint64_t v106 = AssociatedTypeWitness;
        uint64_t v107 = v143;
        unint64_t v108 = swift_getAssociatedConformanceWitness( (uint64_t)v143,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v109 = v141;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v108 + 8))( &qword_18180BE68,  256LL,  v106,  v108);
        char v110 = v151;
        (*((void (**)(char *, uint64_t, const char *))v107 + 3))(v109, a2, v107);
        uint64_t v111 = v153;
        LOBYTE(v106) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL)
                                                                          + 16LL))( v153,  v110,  a2);
        uint64_t v112 = v152;
        unint64_t v151 = *(char **)(v152 + 8);
        ((void (*)(char *, uint64_t))v151)(v110, a2);
        uint64_t v113 = v131;
        (*(void (**)(char *, char *, uint64_t))(v112 + 32))(v131, v111, a2);
        uint64_t v95 = v50;
        uint64_t v114 = *(void (**)(char *, void (*)(void, void), uint64_t))(v50 + 16);
        int v115 = v134;
        unint64_t v90 = v93;
        v114(v134, v93, a3);
        if ((v106 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t))(v95 + 8))(v115, a3);
          ((void (*)(char *, uint64_t))v151)(v113, a2);
          goto LABEL_40;
        }

        uint64_t v127 = v155;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v113, a2, v10, a3, a5);
        char v103 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v127,  v115,  a3);
        uint64_t v128 = *(void (**)(char *, uint64_t))(v95 + 8);
        v128(v127, a3);
        v128(v115, a3);
        goto LABEL_35;
      }

      uint64_t v95 = v50;
      char v96 = v155;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v50 + 16))(v155, v90, a3);
      uint64_t v97 = v151;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))(v96, a3, a5, a2, v10);
      char v62 = v153;
      char v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL) + 16LL))( v153,  v97,  a2);
      goto LABEL_33;
    }

    if (v92 < v94)
    {
      char v102 = v155;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v153, a2, v10, a3, a5);
      char v103 = (*(uint64_t (**)(char *, void (*)(void, void), uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                             + 16LL))( v102,  v90,  a3);
      uint64_t v95 = v50;
      (*(void (**)(char *, uint64_t))(v50 + 8))(v102, a3);
      goto LABEL_35;
    }

    unint64_t v116 = v139;
    uint64_t v117 = v140;
    unint64_t v118 = swift_getAssociatedConformanceWitness( (uint64_t)v140,  a3,  v139,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v119 = v138;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v118 + 8))( &qword_18180BE68,  256LL,  v116,  v118);
    uint64_t v120 = v155;
    (*((void (**)(char *, uint64_t, const char *))v117 + 3))(v119, a3, v117);
    unint64_t v90 = v93;
    LOBYTE(v116) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 40LL))( v93,  v120,  a3);
    unint64_t v121 = *(void (**)(char *, uint64_t))(v50 + 8);
    v121(v120, a3);
    int v122 = v132;
    (*(void (**)(char *, char *, uint64_t))(v152 + 32))(v132, v153, a2);
    uint64_t v144 = v50;
    unint64_t v123 = v133;
    (*(void (**)(char *, void (*)(void, void), uint64_t))(v50 + 16))(v133, v90, a3);
    if ((v116 & 1) == 0)
    {
      v121(v123, a3);
      (*(void (**)(char *, uint64_t))(v152 + 8))(v122, a2);
      return (*(uint64_t (**)(void (*)(void, void), uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))( v90,  a3,  a5,  a2,  v10);
    }

    char v124 = v151;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))(v123, a3, a5, a2, v10);
    char v125 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL) + 16LL))( v122,  v124,  a2);
    uint64_t v126 = *(void (**)(char *, uint64_t))(v152 + 8);
    v126(v124, a2);
    v126(v122, a2);
    uint64_t v95 = v144;
    if ((v125 & 1) != 0) {
      goto LABEL_40;
    }
  }

  else
  {
    uint64_t v99 = v145(a2, v10);
    unint64_t v90 = v48;
    if (v99 >= v146(a3, a5))
    {
      unint64_t v104 = v155;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v50 + 16))(v155, v48, a3);
      uint64_t v95 = v50;
      uint64_t v97 = v151;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))(v104, a3, a5, a2, v10);
      char v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v10 + 32) + 8LL) + 16LL))( v62,  v97,  a2);
LABEL_33:
      char v103 = v98;
      char v105 = *(void (**)(char *, uint64_t))(v152 + 8);
      v105(v97, a2);
      v105(v62, a2);
LABEL_35:
      if ((v103 & 1) == 0) {
        return (*(uint64_t (**)(void (*)(void, void), uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))( v90,  a3,  a5,  a2,  v10);
      }
LABEL_40:
      (*(void (**)(void, uint64_t))(v95 + 8))(v90, a3);
      return ((uint64_t (*)(uint64_t, uint64_t))v154)(a2, v150);
    }

    uint64_t v100 = v155;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v62, a2, v10, a3, a5);
    char v101 = (*(uint64_t (**)(char *, void (*)(void, void), uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                           + 16LL))( v100,  v48,  a3);
    (*(void (**)(char *, uint64_t))(v50 + 8))(v100, a3);
    uint64_t v95 = v50;
    if ((v101 & 1) != 0) {
      goto LABEL_40;
    }
  }

  return (*(uint64_t (**)(void (*)(void, void), uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 96))( v90,  a3,  a5,  a2,  v10);
}

  ;
}

uint64_t specialized static FixedWidthInteger._truncatingInit<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v23)(uint64_t *__return_ptr, uint64_t, unint64_t);
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  uint64_t v30 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v29 = (char *)&v26 - v6;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)
                                         + 8)
                             + 8LL)
                 + 8LL);
  uint64_t v28 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v31 = *(void *)(v28 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](v28);
  uint64_t v10 = (char *)&v26 - v9;
  uint64_t v27 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(*(void *)(a3 + 24) + 16LL);
  unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = (char *)&v26 - v15;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v13,  a2,  v14,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v14,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 24))(v16, a2, v13);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v30,  v12,  a2);
  (*(void (**)(char *, uint64_t))(v27 + 8))(v12, a2);
  uint64_t v19 = v18 << 63 >> 63;
  uint64_t v20 = a2;
  uint64_t v21 = v28;
  (*(void (**)(uint64_t, uint64_t))(a3 + 112))(v20, a3);
  (*(void (**)(unint64_t, uint64_t))(v7 + 32))(AssociatedTypeWitness, v7);
  unint64_t v22 = swift_getAssociatedConformanceWitness( v7,  AssociatedTypeWitness,  v21,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v23 = *(void (**)(uint64_t *__return_ptr, uint64_t, unint64_t))(v22 + 16);
  v23(&v32, v21, v22);
  if ((v33 & 1) != 0)
  {
    uint64_t v24 = v19;
  }

  else
  {
    uint64_t v24 = v32;
    v23(&v32, v21, v22);
    if ((v33 & 1) == 0) {
      v23(&v32, v21, v22);
    }
  }

  (*(void (**)(char *, uint64_t))(v31 + 8))(v10, v21);
  return v24;
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t AssociatedConformanceWitness;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t v39 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v38 = (char *)&v36 - v6;
  uint64_t v7 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)
                                         + 8)
                             + 8LL)
                 + 8LL);
  uint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v36 = *(void *)(v8 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v36 - v10;
  uint64_t v37 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v36 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v14 = *(void *)(*(void *)(a3 + 24) + 16LL);
  uint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v36 - v16;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v14,  a2,  v15,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v15,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 24))(v17, a2, v14);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v39,  v13,  a2);
  (*(void (**)(char *, uint64_t))(v37 + 8))(v13, a2);
  uint64_t v20 = v19 << 63 >> 63;
  (*(void (**)(uint64_t, uint64_t))(a3 + 112))(a2, a3);
  (*(void (**)(unint64_t, uint64_t))(v7 + 32))(AssociatedTypeWitness, v7);
  uint64_t v21 = v7;
  unint64_t v22 = v8;
  uint64_t v23 = swift_getAssociatedConformanceWitness( v21,  AssociatedTypeWitness,  v8,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(v23 + 16);
  uint64_t v27 = v20;
  uint64_t v28 = v20;
  while (1)
  {
    v26(&v40, v22, v23);
    if ((v41 & 1) != 0) {
      break;
    }
    uint64_t v29 = v24 < 0x80;
    if (v25) {
      uint64_t v29 = v25 < 0;
    }
    if (!v29) {
      break;
    }
    uint64_t v30 = v40 ^ v20;
    if ((v24 & 0x7F) != 0) {
      uint64_t v31 = v40 ^ v20;
    }
    else {
      uint64_t v31 = 0LL;
    }
    if ((v24 & 0x7F) >= 0x40) {
      uint64_t v30 = 0LL;
    }
    v28 ^= v30;
    v27 ^= v31;
    uint64_t v32 = v24 >= 0xFFFFFFFFFFFFFFC0LL;
    if (v24 < 0xFFFFFFFFFFFFFFC0LL) {
      uint64_t v33 = v25;
    }
    else {
      uint64_t v33 = v25 + 1;
    }
    v24 += 64LL;
    uint64_t v34 = v25 == 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v25 = v33;
    if (v34)
    {
      uint64_t v25 = v33;
      if (v32) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in +=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x264uLL,  0);
      }
    }
  }

  (*(void (**)(char *, unint64_t))(v36 + 8))(v11, v22);
  return v28;
}

uint64_t static FixedWidthInteger._truncatingInit<A>(_:)@<X0>( uint64_t (*a1)(char *, char *, uint64_t, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  char v70 = a1;
  uint64_t v75 = a6;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  associated type descriptor for BinaryInteger.Words);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v67 = (char *)&v61 - v11;
  uint64_t v71 = a5;
  unint64_t v66 = *(const char **)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.BinaryInteger.Words: RandomAccessCollection)
                                               + 8)
                                   + 8LL)
                       + 8LL);
  uint64_t v69 = AssociatedTypeWitness;
  unint64_t v79 = swift_getAssociatedTypeWitness( 0LL,  v66,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v68 = *(void *)(v79 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v79);
  unint64_t v78 = (char *)&v61 - v13;
  uint64_t v77 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unint64_t v74 = (char *)&v61 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v73 = (char *)&v61 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v80 = (char *)&v61 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  unint64_t v81 = (char *)&v61 - v21;
  MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v61 - v22;
  uint64_t v76 = *(void *)(a4 + 8);
  uint64_t v72 = *(void *)(v76 + 24);
  unint64_t v64 = *(const char **)(v72 + 16);
  unint64_t v63 = swift_getAssociatedTypeWitness( 0LL,  v64,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v24 = MEMORY[0x1895F8858](v63);
  uint64_t v26 = (char *)&v61 - v25;
  uint64_t v65 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v61 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = *(void *)(*(void *)(a5 + 24) + 16LL);
  unint64_t v30 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v29,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v30);
  uint64_t v32 = (char *)&v61 - v31;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v29,  a3,  v30,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v30,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v29 + 24))(v32, a3, v29);
  uint64_t v34 = (*(uint64_t (**)(uint64_t (*)(char *, char *, uint64_t, uint64_t), char *, uint64_t))(*(void *)(*(void *)(v71 + 32) + 8LL) + 16LL))( v70,  v28,  a3);
  uint64_t v35 = *(void (**)(char *))(v65 + 8);
  uint64_t v36 = a3;
  uint64_t v37 = v63;
  uint64_t v65 = v36;
  v35(v28);
  uint64_t v38 = v64;
  unint64_t v39 = swift_getAssociatedConformanceWitness( (uint64_t)v64,  a2,  v37,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v40 = v26;
  char v62 = *(void (**)(void *, uint64_t, uint64_t, unint64_t))(v39 + 8);
  v62(&unk_18180BE68, 256LL, v37, v39);
  unint64_t v41 = v38;
  int v42 = (void (*)(char *, uint64_t, const char *))*((void *)v38 + 3);
  uint64_t v43 = v76;
  uint64_t v61 = v34;
  if ((v34 & 1) != 0)
  {
    uint64_t v44 = v42;
    v42(v40, a2, v41);
    (*(void (**)(char *, uint64_t, uint64_t))(v43 + 184))(v23, a2, v43);
    (*(void (**)(char *, uint64_t))(v77 + 8))(v23, a2);
  }

  else
  {
    uint64_t v44 = v42;
    v42(v40, a2, v41);
  }

  v62(&unk_18180BE68, 256LL, v37, v39);
  unint64_t v45 = v81;
  v44(v40, a2, v41);
  uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a2, a4);
  uint64_t v47 = *(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 136);
  v47(v46, a2, a4);
  (*(void (**)(uint64_t))(v71 + 112))(v65);
  unint64_t v48 = v66;
  uint64_t v49 = v69;
  (*((void (**)(uint64_t, const char *))v66 + 4))(v69, v66);
  uint64_t v50 = (uint64_t)v48;
  unint64_t v51 = v79;
  unint64_t v52 = swift_getAssociatedConformanceWitness( v50,  v49,  v79,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v71 = *(void *)(v52 + 16);
  ((void (*)(uint64_t *__return_ptr, unint64_t, unint64_t))v71)(&v82, v51, v52);
  if ((v83 & 1) == 0)
  {
    uint64_t v53 = v82;
    uint64_t v54 = *(void *)(*(void *)(v76 + 32) + 8LL);
    char v70 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v54 + 16);
    uint64_t v69 = v61 << 63 >> 63;
    unint64_t v55 = v74;
    do
    {
      if ((v70(v45, v80, a2, v54) & 1) == 0) {
        break;
      }
      v47(v53 ^ v69, a2, a4);
      uint64_t v56 = v73;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(a4 + 216))(v55, v81, a2, a4);
      uint64_t v57 = *(void (**)(char *, uint64_t))(v77 + 8);
      v57(v55, a2);
      (*(void (**)(uint64_t, char *, uint64_t))(v76 + 232))(v75, v56, a2);
      unint64_t v58 = v56;
      unint64_t v45 = v81;
      v57(v58, a2);
      v47(64LL, a2, a4);
      (*(void (**)(char *, char *, uint64_t))(*(void *)(v72 + 8) + 32LL))(v45, v23, a2);
      v57(v23, a2);
      ((void (*)(uint64_t *__return_ptr, unint64_t, unint64_t))v71)(&v82, v79, v52);
      uint64_t v53 = v82;
    }

    while (v83 != 1);
  }

  (*(void (**)(char *, unint64_t))(v68 + 8))(v78, v79);
  uint64_t v59 = *(void (**)(char *, uint64_t))(v77 + 8);
  v59(v80, a2);
  return ((uint64_t (*)(char *, uint64_t))v59)(v45, a2);
}

uint64_t static FixedWidthInteger._highBitIndex.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(a2 + 56))();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 136))(v4 - 1, a1, a2);
}

uint64_t static FixedWidthInteger.&-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v8 + 88))(v7);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v7, a3);
}

uint64_t static FixedWidthInteger.&*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v10 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v8 + 96))(v7, a1);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v7, a3);
}

uint64_t specialized static FixedWidthInteger._random<A>(using:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v55 = *(void *)(v6 + 24);
  unint64_t v52 = *(const char **)(v55 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v52,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v51 = (char *)&v48 - v8;
  uint64_t v56 = *(void *)(a1 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v48 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v48 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v48 - v18;
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 56);
  if (v20(a1, a2) < 65)
  {
    uint64_t __buf = 0LL;
    swift_stdlib_random(&__buf, 8uLL);
    uint64_t v43 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
    unint64_t v47 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v44, v45, v46);
    return v43(&__buf, &type metadata for UInt64, v47, a1, v6);
  }

  else
  {
    uint64_t v49 = a3;
    uint64_t v53 = a2;
    uint64_t v21 = v20(a1, a2);
    uint64_t v22 = v21 + 63;
    if (v21 >= 0) {
      uint64_t v22 = v21;
    }
    uint64_t v50 = v22;
    uint64_t v23 = v21 - (v22 & 0xFFFFFFFFFFFFFFC0LL);
    uint64_t v24 = v52;
    unint64_t v25 = AssociatedTypeWitness;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v52,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v27 = v51;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v25,  AssociatedConformanceWitness);
    uint64_t v28 = (void (*)(char *, uint64_t, const char *))*((void *)v24 + 3);
    unint64_t AssociatedTypeWitness = (unint64_t)v19;
    v28(v27, a1, v24);
    int64_t v29 = ((v23 > 0) | (unint64_t)(v23 >> 63)) + (v50 >> 6);
    if (v29 < 0) {
      goto LABEL_12;
    }
    if (v29)
    {
      uint64_t v30 = 0LL;
      for (uint64_t i = 0x200000000000000LL; ; --i)
      {
        uint64_t __buf = 0LL;
        swift_stdlib_random(&__buf, 8uLL);
        uint64_t v32 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v6 + 96);
        unint64_t v36 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v33, v34, v35);
        uint64_t v37 = v32(&__buf, &type metadata for UInt64, v36, a1, v6);
        if (!i) {
          break;
        }
        uint64_t __buf = v30;
        unint64_t v40 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
        v32(&__buf, &type metadata for Int, v40, a1, v6);
        (*(void (**)(char *, char *, uint64_t))(v53 + 216))(v14, v11, a1);
        unint64_t v41 = *(void (**)(char *, uint64_t))(v56 + 8);
        v41(v11, a1);
        v41(v14, a1);
        (*(void (**)(unint64_t, char *, uint64_t))(*(void *)(v55 + 8) + 32LL))( AssociatedTypeWitness,  v17,  a1);
        v41(v17, a1);
        v30 += 64LL;
        if (!--v29) {
          return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v56 + 32))( v49,  AssociatedTypeWitness,  a1);
        }
      }

      __break(1u);
LABEL_12:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v56 + 32))(v49, AssociatedTypeWitness, a1);
  }

uint64_t static FixedWidthInteger._random<A>(using:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v57 = a1;
  uint64_t v58 = a3;
  uint64_t v50 = a6;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v55 = *(void *)(v9 + 24);
  unint64_t v52 = *(const char **)(v55 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v52,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v51 = (char *)&v48 - v11;
  uint64_t v56 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v48 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v48 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v48 - v21;
  uint64_t v23 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 56);
  if (v23(a2, a4) <= 64)
  {
    uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 8))(v58, a5);
    uint64_t v44 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v9 + 96);
    unint64_t v47 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v59, v45, v46);
    return v44(&v59, &type metadata for UInt64, v47, a2, v9);
  }

  else
  {
    uint64_t v53 = a5;
    uint64_t v24 = v23(a2, a4);
    uint64_t v25 = v24 + 63;
    if (v24 >= 0) {
      uint64_t v25 = v24;
    }
    uint64_t v49 = v25;
    uint64_t v48 = v24 - (v25 & 0xFFFFFFFFFFFFFFC0LL);
    uint64_t v26 = v52;
    unint64_t v27 = AssociatedTypeWitness;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v52,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    int64_t v29 = v51;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v27,  AssociatedConformanceWitness);
    uint64_t v30 = (void (*)(char *, uint64_t, const char *))*((void *)v26 + 3);
    unint64_t AssociatedTypeWitness = (unint64_t)v22;
    v30(v29, a2, v26);
    int64_t v31 = ((v48 > 0) | (unint64_t)(v48 >> 63)) + (v49 >> 6);
    if (v31 < 0) {
      goto LABEL_12;
    }
    unint64_t v52 = (const char *)a4;
    if (v31)
    {
      uint64_t v32 = 0LL;
      unint64_t v51 = *(char **)(v53 + 8);
      for (uint64_t i = 0x200000000000000LL; ; --i)
      {
        uint64_t v59 = ((uint64_t (*)(uint64_t, uint64_t))v51)(v58, v53);
        uint64_t v34 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v9 + 96);
        unint64_t v37 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v59, v35, v36);
        uint64_t v38 = v34(&v59, &type metadata for UInt64, v37, a2, v9);
        if (!i) {
          break;
        }
        uint64_t v59 = v32;
        unint64_t v41 = lazy protocol witness table accessor for type Int and conformance Int(v38, v39, v40);
        v34(&v59, &type metadata for Int, v41, a2, v9);
        (*((void (**)(char *, char *, uint64_t))v52 + 27))(v17, v14, a2);
        int v42 = *(void (**)(char *, uint64_t))(v56 + 8);
        v42(v14, a2);
        v42(v17, a2);
        (*(void (**)(unint64_t, char *, uint64_t))(*(void *)(v55 + 8) + 32LL))( AssociatedTypeWitness,  v20,  a2);
        v42(v20, a2);
        v32 += 64LL;
        if (!--v31) {
          return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v56 + 32))( v50,  AssociatedTypeWitness,  a2);
        }
      }

      __break(1u);
LABEL_12:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v56 + 32))(v50, AssociatedTypeWitness, a2);
  }

uint64_t UnsignedInteger.magnitude.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a2, v2);
}

uint64_t static UnsignedInteger.isSigned.getter()
{
  return 0LL;
}

uint64_t UnsignedInteger<>.init<A>(exactly:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X5>, uint64_t a6@<X8>)
{
  unint64_t v130 = a1;
  uint64_t v127 = a6;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v124 = a4;
  uint64_t v125 = v9;
  int v115 = *(const char **)(*(void *)(v9 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v115,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v113 = (char *)&v107 - v11;
  uint64_t v129 = a2;
  uint64_t v126 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v117 = (char *)&v107 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unint64_t v116 = (char *)&v107 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v107 - v17;
  MEMORY[0x1895F8858](v16);
  unint64_t v121 = (char *)&v107 - v19;
  uint64_t v20 = *(void *)(a5[3] + 16LL);
  unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v20,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  uint64_t v24 = (char *)&v107 - v23;
  uint64_t v25 = *(void *)(a3 - 8);
  uint64_t v26 = MEMORY[0x1895F8858](v22);
  uint64_t v111 = (char *)&v107 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v112 = (char *)&v107 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v128 = (char *)&v107 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v107 - v33;
  MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v107 - v35;
  uint64_t v120 = (uint64_t (*)(uint64_t, void *))a5[8];
  char v37 = v120(a3, a5);
  unint64_t v123 = *(void (**)(char *, uint64_t, uint64_t))(v25 + 16);
  v123(v36, (uint64_t)v130, a3);
  unint64_t v118 = v18;
  uint64_t v119 = v34;
  unint64_t v110 = v21;
  uint64_t v109 = v24;
  if ((v37 & 1) != 0)
  {
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v20,  a3,  v21,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v21,  AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v20 + 24))(v24, a3, v20);
    char v39 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a5[4] + 8LL) + 16LL))(v36, v34, a3);
    uint64_t v40 = *(void (**)(char *, uint64_t))(v25 + 8);
    v40(v34, a3);
    v40(v36, a3);
    uint64_t v42 = v126;
    uint64_t v41 = v127;
    uint64_t v43 = (void (*)(char *, uint64_t, uint64_t))v20;
    uint64_t v44 = a5;
    if ((v39 & 1) != 0) {
      goto LABEL_27;
    }
  }

  else
  {
    uint64_t v40 = *(void (**)(char *, uint64_t))(v25 + 8);
    v40(v36, a3);
    uint64_t v43 = (void (*)(char *, uint64_t, uint64_t))v20;
    uint64_t v44 = a5;
  }

  uint64_t v108 = v25;
  int v122 = v40;
  uint64_t v45 = (uint64_t (*)(uint64_t, void *))v44[16];
  uint64_t v46 = v130;
  uint64_t v47 = v45(a3, v44);
  uint64_t v48 = v124;
  uint64_t v49 = v129;
  uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(v124 + 56))(v129, v124);
  unint64_t v51 = v128;
  v123(v128, (uint64_t)v46, a3);
  if (v47 < v50)
  {
    v122(v51, a3);
    uint64_t v42 = v126;
    uint64_t v41 = v127;
    goto LABEL_7;
  }

  unint64_t v123 = v43;
  uint64_t v55 = v121;
  (*(void (**)(uint64_t, uint64_t))(v48 + 64))(v49, v48);
  uint64_t v56 = v125;
  uint64_t v57 = *(uint64_t (**)(uint64_t, uint64_t))(v125 + 64);
  int v58 = v57(v49, v125);
  if (((v58 ^ v120(a3, v44)) & 1) != 0)
  {
    char v59 = v57(v49, v56);
    uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(v56 + 128))(v49, v56);
    uint64_t v61 = v45(a3, v44);
    if ((v59 & 1) != 0)
    {
      if (v61 >= v60)
      {
        unint64_t v75 = AssociatedTypeWitness;
        uint64_t v76 = v115;
        unint64_t v77 = swift_getAssociatedConformanceWitness( (uint64_t)v115,  v49,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v78 = v113;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v77 + 8))( &unk_18180BE68,  256LL,  v75,  v77);
        unint64_t v79 = v55;
        uint64_t v80 = v118;
        (*((void (**)(char *, uint64_t, const char *))v76 + 3))(v78, v49, v76);
        LOBYTE(v75) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v56 + 32) + 8LL)
                                                                         + 16LL))( v79,  v80,  v49);
        uint64_t v81 = v56;
        uint64_t v82 = *(void (**)(char *, uint64_t))(v126 + 8);
        char v83 = v80;
        uint64_t v42 = v126;
        v82(v83, v49);
        unint64_t v84 = v116;
        (*(void (**)(char *, char *, uint64_t))(v42 + 32))(v116, v79, v49);
        uint64_t v85 = v112;
        (*(void (**)(char *, char *, uint64_t))(v108 + 32))(v112, v128, a3);
        uint64_t v40 = v122;
        if ((v75 & 1) != 0)
        {
          v122(v85, a3);
          v82(v84, v49);
          uint64_t v41 = v127;
        }

        else
        {
          unint64_t v104 = v119;
          ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v44[12])(v84, v49, v81, a3, v44);
          char v105 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v44[4] + 8LL) + 16LL))(v104, v85, a3);
          v40(v104, a3);
          v40(v85, a3);
          uint64_t v41 = v127;
          if ((v105 & 1) == 0) {
            goto LABEL_7;
          }
        }

uint64_t static UnsignedInteger<>.min.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a2 + 8) + 24LL) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v3,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v6 = (char *)&v9 - v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v3,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(v3 + 24))(v6, a1, v3);
}

uint64_t specialized UnsignedInteger<>.dividingFullWidth(_:)( uint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7)
{
  if (!(a6 | a7)) {
    _assertionFailure(_:_:file:line:flags:)( "Precondition failed",  19LL,  2LL,  (char *)0xD000000000000010LL,  0x80000001818B45F0LL,  "Swift/Integers.swift",  20LL,  2,  0xDB6uLL,  0);
  }
  if (__PAIR128__(a3, a2) >= __PAIR128__(a7, a6)) {
    _assertionFailure(_:_:file:line:flags:)( "Precondition failed",  19LL,  2LL,  (char *)0xD00000000000002ALL,  0x80000001818BABE0LL,  "Swift/Integers.swift",  20LL,  2,  0xDB7uLL,  0);
  }
  unint64_t v8 = __clz(a7);
  unint64_t v9 = __clz(a6) + 64;
  if (!a7) {
    unint64_t v8 = v9;
  }
  if (a6 & (a6 - 1) | a7 & ((a6 != 0) + a7 - 1))
  {
    char v20 = v8 & 0x7F;
    char v21 = ~(_BYTE)v8;
    else {
      unint64_t v22 = a5 >> -(char)v8;
    }
    uint64_t v23 = ((2 * a5) << (v8 - 1)) | (a4 >> -(char)v8);
    if (!v8)
    {
      uint64_t v23 = 0LL;
      unint64_t v22 = 0LL;
    }

    if ((v8 & 0x40) != 0) {
      unint64_t v24 = a6 << v8;
    }
    else {
      unint64_t v24 = (a7 << v8) | (a6 >> 1 >> ~(_BYTE)v8);
    }
    if ((v8 & 0x40) != 0) {
      unint64_t v25 = 0LL;
    }
    else {
      unint64_t v25 = a6 << v8;
    }
    unint64_t v26 = (a3 << v8) | (a2 >> 1 >> v21);
    uint64_t v27 = a2 << v8;
    if ((v8 & 0x40) != 0)
    {
      unint64_t v26 = a2 << v8;
      uint64_t v27 = 0LL;
    }

    unint64_t v28 = v22 | v26;
    uint64_t v29 = v23 | v27;
    unint64_t v30 = (a5 << v8) | (a4 >> 1 >> v21);
    unint64_t v31 = a4 << v8;
    if ((v20 & 0x40) != 0) {
      unint64_t v32 = v31;
    }
    else {
      unint64_t v32 = v30;
    }
    if ((v20 & 0x40) != 0) {
      unint64_t v33 = 0LL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v25)
    {
      uint64_t v34 = specialized generateHalfDigit #1 <A>(high:low:) in UnsignedInteger<>.dividingFullWidth(_:)( v23 | v27,  v28,  v32,  0LL,  v24,  0LL,  0xFFFFFFFFFFFFFFFFLL,  0LL,  v25,  64);
      unsigned __int128 v36 = __PAIR128__(v29, v32) - __PAIR128__(v35, v34) * __PAIR128__(v24, v25);
      uint64_t result = specialized generateHalfDigit #1 <A>(high:low:) in UnsignedInteger<>.dividingFullWidth(_:)( v36,  *((unint64_t *)&v36 + 1),  v33,  0LL,  v24,  0LL,  0xFFFFFFFFFFFFFFFFLL,  0LL,  v25,  64);
      unint64_t v38 = ((v33 - __PAIR128__(v37, result) * __PAIR128__(v24, v25)) >> 64) + v36;
      uint64_t v39 = v38 >> v20;
      uint64_t v19 = ((2 * v38) << ~v20) | ((v33 - result * v25) >> v20);
      if ((v20 & 0x40) != 0)
      {
        uint64_t v19 = v39;
        uint64_t v18 = 0LL;
      }

      else
      {
        uint64_t v18 = v39;
      }
    }

    else
    {
      if (!v24) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
      }
      __udivti3();
      uint64_t result = __udivti3();
      unint64_t v40 = v32 - result * v24;
      uint64_t v18 = v40 >> v20;
      uint64_t v19 = ((2 * v40) << ~v20) | (v33 >> v20);
      if ((v20 & 0x40) != 0)
      {
        uint64_t v19 = v18;
        uint64_t v18 = 0LL;
      }
    }
  }

  else
  {
    char v10 = v8 + 1;
    char v11 = 127 - v8;
    char v12 = v11 & 0x7F;
    uint64_t v13 = ((2 * a5) << ~v11) | (a4 >> v11);
    uint64_t v14 = a5 >> v11;
    if ((v12 & 0x40) != 0) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v13;
    }
    if ((v10 & 0x40) != 0) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = a2 << v10;
    }
    uint64_t result = v15 | v16;
    uint64_t v18 = ((a6 != 0) + a7 - 1) & a5;
    uint64_t v19 = (a6 - 1) & a4;
  }

  *a1 = v19;
  a1[1] = v18;
  return result;
}

uint64_t specialized generateHalfDigit #1 <A>(high:low:) in UnsignedInteger<>.dividingFullWidth(_:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, __int128 a9, char a10)
{
  if (!(a5 | a6)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/UInt128.swift",  19LL,  2,  0x112uLL,  0);
  }
  uint64_t result = __udivti3();
  unint64_t v21 = (__PAIR128__(a2, a1) - __PAIR128__(v19, result) * __PAIR128__(a6, a5)) >> 64;
  unint64_t v20 = a1 - result * a5;
  char v22 = a10 & 0x7F;
  do
  {
    if (__PAIR128__(a8, a7) >= __PAIR128__(v19, result))
    {
      unint64_t v24 = (v21 << v22) | (v20 >> 1 >> ~v22);
      uint64_t v25 = v20 << v22;
      if ((a10 & 0x40) != 0)
      {
        unint64_t v24 = v20 << v22;
        uint64_t v25 = 0LL;
      }

      if (__PAIR128__(v24 | a4, v25 | a3) >= __PAIR128__(v19, result) * a9) {
        break;
      }
    }

    BOOL v23 = result-- != 0;
    uint64_t v19 = v23 + v19 - 1;
    unint64_t v21 = (__PAIR128__(v21, v20) + __PAIR128__(a6, a5)) >> 64;
    v20 += a5;
  }

  while (__PAIR128__(a8, a7) >= __PAIR128__(v21, v20));
  return result;
}

void static SignedInteger._maskingAdd(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD00000000000002CLL,  0x80000001818B6A20LL,  "Swift/Integers.swift",  20LL,  2,  0xEDDuLL,  0);
}

void static SignedInteger._maskingSubtract(_:_:)()
{
}

{
  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD00000000000002CLL,  0x80000001818B6A20LL,  "Swift/Integers.swift",  20LL,  2,  0xEE2uLL,  0);
}

uint64_t static SignedInteger.isSigned.getter()
{
  return 1LL;
}

uint64_t static SignedInteger<>.min.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v5);
  unint64_t v9 = (char *)&v19 - v8;
  uint64_t v11 = *(void *)(*(void *)(*(void *)(v10 + 8) + 24LL) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v19 - v13;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE78,  257LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 24))(v14, a1, v11);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(a1, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 136))(v16 - 1, a1, a2);
  (*(void (**)(char *, char *, uint64_t, uint64_t))(a2 + 216))(v9, v7, a1, a2);
  uint64_t v17 = *(void (**)(char *, uint64_t))(v4 + 8);
  v17(v7, a1);
  return ((uint64_t (*)(char *, uint64_t))v17)(v9, a1);
}

uint64_t specialized SignedInteger<>.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL) {
    return 1LL;
  }
  if (!(a1 | a2)) {
    return (a3 | a4) == 0;
  }
  uint64_t v5 = __modti3();
  return (v5 | v6) == 0;
}

BOOL specialized SignedInteger<>.isMultiple(of:)(char a1, char a2)
{
  if (a1 == -1) {
    return 1LL;
  }
  if (a1) {
    return a2 % a1 == 0;
  }
  else {
    return a2 == 0;
  }
}

BOOL specialized SignedInteger<>.isMultiple(of:)(__int16 a1, __int16 a2)
{
  if (a1 == -1) {
    return 1LL;
  }
  if (a1) {
    return a2 % a1 == 0;
  }
  else {
    return a2 == 0;
  }
}

BOOL specialized SignedInteger<>.isMultiple(of:)(int a1, int a2)
{
  if (a1 == -1LL) {
    return 1LL;
  }
  if (a1)
  {
    if (a1 == -1 && a2 == 0x80000000) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow in remainder operation",  54LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x20B4uLL,  0);
    }
    return a2 % a1 == 0;
  }

  else
  {
    return a2 == 0;
  }

BOOL specialized SignedInteger<>.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 | a1)
  {
    if (a2 == -1 && a1 == -1) {
      return 1LL;
    }
    Swift::tuple_partialValue__Int128_overflow_Bool v6 = _Int128.remainderReportingOverflow(dividingBy:)(*(Swift::_Int128 *)&a1);
    if (v6.overflow) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in %=",  14LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x3DCuLL,  0);
    }
    Swift::UInt64 v4 = v6.partialValue.high | v6.partialValue.low;
  }

  else
  {
    Swift::UInt64 v4 = a4 | a3;
  }

  return v4 == 0;
}

uint64_t SignedInteger<>.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v92 = *(const char **)(*(void *)(v5 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v92,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v91 = (char *)&v87 - v8;
  uint64_t v9 = *(void *)(a2 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  unint64_t v88 = (char *)&v87 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v93 = (char *)&v87 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unint64_t v90 = (char *)&v87 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v89 = (char *)&v87 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v20 = (char *)&v87 - v19;
  MEMORY[0x1895F8858](v18);
  char v22 = (char *)&v87 - v21;
  BOOL v23 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  if ((v23(a2, v5) & 1) == 0)
  {
    char v27 = v23(a2, v5);
    uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v24 = v95(a2, v5);
    if ((v27 & 1) != 0)
    {
      if (v24 > 64) {
        goto LABEL_12;
      }
      unint64_t v28 = v92;
      uint64_t v29 = *(void (**)(void *, uint64_t))(swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral)
                                                   + 8);
      unint64_t v30 = AssociatedTypeWitness;
      uint64_t v31 = v9;
      unint64_t v32 = v91;
      unint64_t v87 = v30;
      v29(&unk_18180BE68, 256LL);
      unint64_t v33 = v32;
      uint64_t v9 = v31;
      (*((void (**)(char *, uint64_t, const char *))v28 + 3))(v33, a2, v28);
      char v34 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8LL) + 32LL))( a1,  v22,  a2);
      unint64_t v35 = *(void (**)(char *, uint64_t))(v31 + 8);
      v35(v22, a2);
      (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v20, a1, a2);
      if ((v34 & 1) == 0)
      {
        v35(v20, a2);
        unint64_t AssociatedTypeWitness = v87;
        goto LABEL_24;
      }

      uint64_t v36 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      v35(v20, a2);
      unint64_t AssociatedTypeWitness = v87;
      if (v36) {
        goto LABEL_24;
      }
LABEL_13:
      if ((v23(a2, v5) & 1) != 0)
      {
        uint64_t v41 = v94;
        uint64_t v42 = v95(a2, v5);
        if (v42 >= 64) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }

      char v45 = v23(a2, v5);
      uint64_t v41 = v94;
      uint64_t v42 = v95(a2, v5);
      if ((v45 & 1) != 0)
      {
        if (v42 <= 64)
        {
          uint64_t v46 = v92;
          unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v48 = v91;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
          (*((void (**)(char *, uint64_t, const char *))v46 + 3))(v48, a2, v46);
          char v49 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8LL) + 32LL))( v41,  v22,  a2);
          v35(v22, a2);
          char v22 = v89;
          (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v89, v41, a2);
          goto LABEL_52;
        }
      }

      else if (v42 < 64)
      {
LABEL_20:
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v22, v41, a2);
        uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
        unint64_t v51 = v22;
LABEL_49:
        v35(v51, a2);
        char v54 = v50 == 0;
        return v54 & 1;
      }

uint64_t specialized SignedInteger<>.dividingFullWidth(_:)( uint64_t *a1, unint64_t a2, int64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a3;
  BOOL v11 = __CFSUB__(0LL, v7, a4 == 0);
  unint64_t v12 = (unsigned __int128)-(__int128)__PAIR128__(v7, a4) >> 64;
  int v13 = !v11;
  uint64_t v14 = v13 ^ 1u;
  int64_t v15 = ~a3;
  BOOL v11 = __CFADD__(v14, ~a2);
  unint64_t v16 = v14 + ~a2;
  if (v11) {
    int64_t v15 = -a3;
  }
  if (a3 < 0)
  {
    a4 = -(uint64_t)a4;
    a5 = v12;
    a2 = v16;
    a3 = v15;
  }

  uint64_t result = specialized UnsignedInteger<>.dividingFullWidth(_:)( (uint64_t *)&v24,  a2,  a3,  a4,  a5,  v17,  *((unint64_t *)&v17 + 1));
  if (((a7 ^ v9) & 0x8000000000000000LL) == 0)
  {
    if ((v19 & 0x8000000000000000LL) == 0)
    {
      uint64_t v21 = v25;
      if ((v25 & 0x8000000000000000LL) == 0) {
        goto LABEL_11;
      }
    }

uint64_t static SignedInteger<>._maskingAdd(_:_:)@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 80))(a2);
}

uint64_t static SignedInteger<>._maskingSubtract(_:_:)@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 88))(a2);
}

uint64_t (*JoinedSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t *JoinedSequence._separator.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain(*(unint64_t **)(v4 + *(int *)(a1 + 44)), a2, a3, a4);
}

uint64_t JoinedSequence._separator.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a2 + 44);
  uint64_t result = swift_release(*(void *)(v2 + v4));
  *(void *)(v2 + v4) = a1;
  return result;
}

uint64_t (*JoinedSequence._separator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t JoinedSequence.init<A>(base:separator:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a3, a5);
  uint64_t result = type metadata accessor for JoinedSequence(0LL, a2, a4, a6);
  *(void *)(a7 + *(int *)(result + 44)) = v13;
  return result;
}

void JoinedSequence.Iterator._JoinIteratorState.hash(into:)(uint64_t a1, unsigned __int8 a2)
{
}

Swift::Int JoinedSequence.Iterator._JoinIteratorState.hashValue.getter(unsigned __int8 a1)
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance JoinedSequence<A>.Iterator._JoinIteratorState()
{
  return JoinedSequence.Iterator._JoinIteratorState.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance JoinedSequence<A>.Iterator._JoinIteratorState( uint64_t a1)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance JoinedSequence<A>.Iterator._JoinIteratorState( uint64_t a1)
{
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  JoinedSequence.Iterator._JoinIteratorState.hash(into:)((uint64_t)v3, *v1);
  return Hasher._finalize()();
}

uint64_t JoinedSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t JoinedSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*JoinedSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t FlattenSequence.Iterator._inner.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 44);
  __int128 v5 = *(const char **)(a1 + 32);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v7 = swift_getAssociatedTypeWitness( 255LL,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = type metadata accessor for Optional(0LL, v7, v8, v9);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 16LL))(a2, v4, v10);
}

uint64_t FlattenSequence.Iterator._inner.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 44);
  __int128 v5 = *(const char **)(a2 + 32);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v7 = swift_getAssociatedTypeWitness( 255LL,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v10 = type metadata accessor for Optional(0LL, v7, v8, v9);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v10 - 8) + 40LL))(v4, a1, v10);
}

uint64_t (*JoinedSequence.Iterator._inner.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t *JoinedSequence.Iterator._separatorData.getter( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain(*(unint64_t **)(v4 + *(int *)(a1 + 48)), a2, a3, a4);
}

uint64_t JoinedSequence.Iterator._separatorData.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a2 + 48);
  uint64_t result = swift_release(*(void *)(v2 + v4));
  *(void *)(v2 + v4) = a1;
  return result;
}

uint64_t (*JoinedSequence.Iterator._separatorData.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

unint64_t *JoinedSequence.Iterator._separator.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain(*(unint64_t **)(v4 + *(int *)(a1 + 52)), a2, a3, a4);
}

uint64_t JoinedSequence.Iterator._separator.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v6 = (uint64_t *)(v3 + *(int *)(a3 + 52));
  uint64_t result = swift_release(*v6);
  *Swift::tuple_partialValue__Int128_overflow_Bool v6 = a1;
  v6[1] = a2;
  return result;
}

uint64_t (*JoinedSequence.Iterator._separator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t JoinedSequence.Iterator._state.getter(uint64_t a1)
{
  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 56));
}

uint64_t JoinedSequence.Iterator._state.setter(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(v2 + *(int *)(a2 + 56)) = result;
  return result;
}

uint64_t (*JoinedSequence.Iterator._state.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t JoinedSequence.Iterator.init<A>(base:separator:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, const char *a4@<X4>, uint64_t a5@<X5>, const char *a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v13 = (int *)type metadata accessor for JoinedSequence.Iterator(0LL, a2, (uint64_t)a4, (uint64_t)a6);
  uint64_t v14 = a7 + v13[11];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  a6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v16 - 8) + 56LL))( v14,  1LL,  1LL,  v16);
  unsigned __int128 v17 = (void *)(a7 + v13[13]);
  *unsigned __int128 v17 = 0LL;
  v17[1] = 0LL;
  *(_BYTE *)(a7 + v13[14]) = 0;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  a4,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v18 - 8) + 32LL))(a7, a1, v18);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a3, a5);
  *(void *)(a7 + v13[12]) = result;
  return result;
}

void JoinedSequence.Iterator.next()(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  v31[10] = a2;
  __int128 v5 = (const char *)a1[3];
  Swift::tuple_partialValue__Int128_overflow_Bool v6 = (const char *)a1[4];
  uint64_t v32 = a1[2];
  unint64_t v33 = v5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v32,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v35 = swift_getAssociatedTypeWitness( 255LL,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0LL, v35, v8, v9);
  v31[17] = *(void *)(v10 - 8);
  v31[18] = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  v31[14] = (char *)v31 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  v31[9] = (char *)v31 - v13;
  v31[19] = v6;
  unint64_t v34 = swift_getAssociatedTypeWitness( 255LL,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v16 = type metadata accessor for Optional(0LL, v34, v14, v15);
  v31[15] = *(void *)(v16 - 8);
  v31[16] = v16;
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  v31[6] = (char *)v31 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  v31[4] = (char *)v31 - v20;
  MEMORY[0x1895F8858](v19);
  v31[11] = (char *)v31 - v21;
  uint64_t v24 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v22, v23);
  v31[7] = *(void *)(v24 - 8);
  v31[8] = v24;
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  v31[5] = (char *)v31 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  v31[20] = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v27);
  v31[13] = (char *)v31 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v28);
  v31[12] = (char *)v31 - v30;
  __asm { BR              X9 }

void sub_18155DE1C()
{
  uint64_t v3 = (uint64_t *)(v0 + *(int *)(v1 + 52));
  uint64_t v4 = *v3;
  if (*v3)
  {
    unint64_t v5 = v3[1];
    unint64_t v6 = *(void *)(v4 + 16);
    if (v5 == v6)
    {
      uint64_t v7 = *(void *)(v2 - 176);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(v2 - 96) - 8LL) + 56LL))(v7, 1LL, 1LL);
      (*(void (**)(uint64_t, void))(*(void *)(v2 - 152) + 8LL))(v7, *(void *)(v2 - 144));
      JUMPOUT(0x18155DE00LL);
    }

    if (v5 < v6)
    {
      uint64_t v8 = *(void *)(v2 - 96);
      uint64_t v9 = *(void *)(v8 - 8);
      unint64_t v10 = v4
      v3[1] = v5 + 1;
      uint64_t v11 = *(void *)(v2 - 176);
      (*(void (**)(uint64_t, unint64_t, uint64_t))(v9 + 16))(v11, v10, v8);
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v9 + 56))(v11, 0LL, 1LL, v8);
      (*(void (**)(void, uint64_t, void))(*(void *)(v2 - 152) + 32LL))( *(void *)(v2 - 208),  v11,  *(void *)(v2 - 144));
      JUMPOUT(0x18155E1CCLL);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }

  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Join.swift",  16LL,  2,  0x76uLL,  0);
}

uint64_t sub_18155DE70()
{
  *(void *)(v5 - 264) = v3;
  uint64_t v6 = v0 + v4[11];
  uint64_t v7 = *(void *)(v5 - 104);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v8 + 48);
  *(void *)(v5 - 272) = v9;
  if (v9(v6, 1LL, v7) == 1) {
    JUMPOUT(0x18155E28CLL);
  }
  uint64_t v10 = v2 + 8;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(*(void *)(v5 - 136), v1, v7, v2, v2 + 8);
  uint64_t v12 = *(void *)(v5 - 216);
  (*(void (**)(uint64_t, unint64_t))(AssociatedConformanceWitness + 16))( v7,  AssociatedConformanceWitness);
  uint64_t v13 = *(void *)(*(void *)(v5 - 96) - 8LL);
  *(void *)(v5 - 280) = v8;
  *(void *)(v5 - 288) = v13;
  uint64_t v14 = v6;
  uint64_t v15 = (_DWORD *)(v2 + 24);
  uint64_t v16 = v2;
  uint64_t v18 = *(void *)(v5 - 120);
  uint64_t v17 = *(const char **)(v5 - 112);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness(255LL, v17, v18, v16, v15);
  unint64_t v20 = swift_getAssociatedConformanceWitness((uint64_t)v17, v18, AssociatedTypeWitness, v16, v10);
  uint64_t v21 = *(void (**)(unint64_t *, unint64_t))(v20 + 16);
  uint64_t v22 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  uint64_t v23 = *(void *)(v5 - 248);
  v21(v22, v20);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 128) + 48LL))(v23, 1LL, v1) == 1)
  {
    (*(void (**)(uint64_t, void))(*(void *)(v5 - 232) + 8LL))(v23, *(void *)(v5 - 224));
    uint64_t v24 = 1LL;
    uint64_t v25 = *(void *)(v5 - 104);
    uint64_t v26 = *(void *)(v5 - 256);
  }

  else
  {
    uint64_t v26 = *(void *)(v5 - 256);
    (*(void (**)(uint64_t))(*(void *)(v5 - 136) + 32LL))(v1);
    uint64_t v24 = 0LL;
    uint64_t v25 = *(void *)(v5 - 104);
  }

  uint64_t v27 = v14;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 280) + 56LL))(v26, v24, 1LL, v25);
  uint64_t v28 = *(void *)(v5 - 168);
  uint64_t v29 = v26;
  uint64_t v30 = *(void *)(v5 - 160);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v28 + 40))(v14, v29, v30);
  uint64_t v31 = *(void *)(v5 - 240);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v28 + 16))(v31, v27, v30);
  int v32 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 - 272))(v31, 1LL, v25);
  (*(void (**)(uint64_t, uint64_t))(v28 + 8))(v31, v30);
  if (v32 != 1)
  {
    uint64_t v36 = *(void *)(v0 + v4[12]);
    uint64_t v37 = *(void *)(v5 - 264);
    if (*(void *)(v36 + 16))
    {
      swift_retain(*(unint64_t **)(v0 + v4[12]), v33, v34, v35);
      (*(void (**)(void, void))(*(void *)(v5 - 152) + 8LL))( *(void *)(v5 - 216),  *(void *)(v5 - 144));
      unint64_t v38 = (uint64_t *)(v0 + v4[13]);
      swift_release(*v38);
      *unint64_t v38 = v36;
      v38[1] = 0LL;
      *(_BYTE *)(v0 + v37) = 2;
    }

    else
    {
      (*(void (**)(void, void))(*(void *)(v5 - 152) + 8LL))( *(void *)(v5 - 216),  *(void *)(v5 - 144));
    }

    JUMPOUT(0x18155DCE8LL);
  }

  (*(void (**)(void, void))(*(void *)(v5 - 152) + 8LL))(*(void *)(v5 - 216), *(void *)(v5 - 144));
  *(_BYTE *)(v0 + *(void *)(v5 - 264)) = 3;
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(v5 - 288) + 56LL))( *(void *)(v5 - 208),  1LL,  1LL,  *(void *)(v5 - 96));
}

uint64_t JoinedSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 32))( (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v2,  v5);
  uint64_t v8 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t, uint64_t))(v8 + 32))(v5, v8);
  uint64_t v9 = *(void *)(v2 + *(int *)(a1 + 44));
  uint64_t v10 = *(const char **)(a1 + 32);
  uint64_t v11 = (int *)type metadata accessor for JoinedSequence.Iterator(0LL, v5, v8, (uint64_t)v10);
  uint64_t v12 = a2 + v11[11];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v8,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  v10,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v14 - 8) + 56LL))( v12,  1LL,  1LL,  v14);
  uint64_t v16 = (void *)(a2 + v11[13]);
  *uint64_t v16 = 0LL;
  v16[1] = 0LL;
  *(_BYTE *)(a2 + v11[14]) = 0;
  *(void *)(a2 + v11[12]) = v9;
  return result;
}

__objc2_class **JoinedSequence._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  char v78 = associated type descriptor for Sequence.Element;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v74 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v5 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v69 = (char *)&v67 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  unint64_t v68 = (char *)&v67 - v8;
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v67 - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v71 = *(void *)(v13 - 8);
  uint64_t v72 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v67 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  char v70 = (char *)&v67 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v67 - v20;
  uint64_t v22 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v67 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v82 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v2,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v75 = *(void *)(v82 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v82);
  unint64_t v80 = (char *)&v67 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v81 = (char *)&v67 - v27;
  unint64_t v79 = *(const char **)(a1 + 32);
  unint64_t v73 = swift_getAssociatedTypeWitness( 0LL,  v79,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  v78);
  unint64_t v84 = &_swiftEmptyArrayStorage;
  uint64_t v76 = a1;
  uint64_t v28 = *(unint64_t **)(v77 + *(int *)(a1 + 44));
  unint64_t v29 = v28[2];
  uint64_t v30 = *(void (**)(char *))(v22 + 16);
  uint64_t v31 = v3;
  v30(v24);
  int v32 = *(void (**)(uint64_t, uint64_t))(v2 + 32);
  if (v29)
  {
    uint64_t v33 = v80;
    v32(v31, v2);
    unint64_t v34 = v82;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v2,  v31,  v82,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v36 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v37 = v70;
    v36(v34, AssociatedConformanceWitness);
    unint64_t v38 = (char *)v36;
    uint64_t v39 = v74;
    uint64_t v67 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v74 + 48);
    if (v67(v37, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, unint64_t))(v75 + 8))(v33, v34);
      (*(void (**)(uint64_t))(*(void *)(v76 - 8) + 8LL))(v77);
      (*(void (**)(char *))(v71 + 8))(v37);
    }

    else
    {
      char v78 = (_DWORD *)AssociatedConformanceWitness;
      unint64_t v52 = *(void (**)(char *, char *, unint64_t))(v39 + 32);
      unint64_t v53 = v68;
      v52(v68, v37, AssociatedTypeWitness);
      v52(v10, v53, AssociatedTypeWitness);
      uint64_t v56 = type metadata accessor for ContiguousArray(0LL, v73, v54, v55);
      uint64_t v81 = v38;
      ContiguousArray.append<A>(contentsOf:)((uint64_t)v10, v56, AssociatedTypeWitness, (uint64_t)v79);
      ((void (*)(unint64_t, _DWORD *))v81)(v34, v78);
      uint64_t v57 = v67;
      unsigned int v58 = v67(v16, 1LL, AssociatedTypeWitness);
      unint64_t v59 = v34;
      uint64_t v60 = v69;
      if (v58 != 1)
      {
        do
        {
          v52(v60, v16, AssociatedTypeWitness);
          unint64_t v83 = v28;
          swift_retain(v28, v61, v62, v63);
          uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v56, v64);
          ContiguousArray.append<A>(contentsOf:)((uint64_t)&v83, v56, v56, WitnessTable);
          v52(v10, v60, AssociatedTypeWitness);
          ContiguousArray.append<A>(contentsOf:)((uint64_t)v10, v56, AssociatedTypeWitness, (uint64_t)v79);
          ((void (*)(unint64_t, _DWORD *))v81)(v59, v78);
        }

        while (v57(v16, 1LL, AssociatedTypeWitness) != 1);
      }

      (*(void (**)(char *, unint64_t))(v75 + 8))(v80, v59);
      (*(void (**)(uint64_t))(*(void *)(v76 - 8) + 8LL))(v77);
      (*(void (**)(char *))(v71 + 8))(v16);
    }
  }

  else
  {
    v32(v3, v2);
    unint64_t v40 = v82;
    unint64_t v41 = swift_getAssociatedConformanceWitness( v2,  v3,  v82,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v42 = *(void (**)(unint64_t, unint64_t))(v41 + 16);
    v42(v40, v41);
    uint64_t v43 = v74;
    uint64_t v44 = *(uint64_t (**)(char *, uint64_t, unint64_t))(v74 + 48);
    int v45 = v44(v21, 1LL, AssociatedTypeWitness);
    uint64_t v46 = v79;
    uint64_t v47 = v73;
    if (v45 != 1)
    {
      uint64_t v48 = *(void (**)(char *, char *, unint64_t))(v43 + 32);
      do
      {
        v48(v10, v21, AssociatedTypeWitness);
        uint64_t v51 = type metadata accessor for ContiguousArray(0LL, v47, v49, v50);
        ContiguousArray.append<A>(contentsOf:)((uint64_t)v10, v51, AssociatedTypeWitness, (uint64_t)v46);
        v42(v82, v41);
      }

      while (v44(v21, 1LL, AssociatedTypeWitness) != 1);
    }

    (*(void (**)(char *, unint64_t))(v75 + 8))(v81, v82);
    (*(void (**)(uint64_t))(*(void *)(v76 - 8) + 8LL))(v77);
  }

  return v84;
}

uint64_t Sequence<>.joined<A>(separator:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a3, a5);
  uint64_t result = type metadata accessor for JoinedSequence(0LL, a2, a4, a6);
  *(void *)(a7 + *(int *)(result + 44)) = v16;
  return result;
}

uint64_t static AnyKeyPath.rootType.getter()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t static AnyKeyPath.valueType.getter()
{
  return v1;
}

unint64_t AnyKeyPath._kvcKeyPathString.getter()
{
  unint64_t result = *(void *)(v0 + 16);
  if (result)
  {
    uint64_t v2 = -(uint64_t)result;
    if (__OFSUB__(0LL, result))
    {
      __break(1u);
    }

    else
    {
      BOOL v3 = __OFSUB__(v2, 1LL);
      uint64_t v4 = v2 - 1;
      if (!v3)
      {
        if (v4 < 0) {
          return specialized String.init(validatingUTF8:)(result);
        }
        else {
          return 0LL;
        }
      }
    }

    __break(1u);
  }

  return result;
}

void static AnyKeyPath._rootAndValueType.getter()
{
}

void *static AnyKeyPath._create(capacityInBytes:initializedBy:)( uint64_t a1, void (*a2)(void *, char *))
{
  uint64_t v5 = a1 + 3;
  if (a1 >= 0) {
    uint64_t v5 = a1;
  }
  uint64_t v6 = swift_allocObject( v2,  ((*(unsigned int *)(v2 + 48) + 3LL) & 0x1FFFFFFFCLL) + (v5 & 0xFFFFFFFFFFFFFFFCLL),  *(unsigned __int16 *)(v2 + 52) | 3LL);
  v6[2] = 0LL;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }
  uint64_t v7 = v6;
  a2(v6 + 3, (char *)v6 + a1 + 24);
  return v7;
}

unint64_t specialized AnyKeyPath.withBuffer<A>(_:)(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  if ((((_BYTE)a1 + 24) & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  uint64_t v4 = v3;
  LODWORD(v6) = *(_DWORD *)(a1 + 24);
  BOOL v183 = (int)v6 < 0;
  BOOL v184 = (v6 & 0x40000000) != 0;
  v6 &= 0xFFFFFFuLL;
  uint64_t v181 = a1 + 32;
  uint64_t v182 = a1 + 32 + v6;
  if ((_DWORD)v6)
  {
    uint64_t v177 = v3;
    uint64_t v178 = *(uint64_t (**)(void))(a3 + 120);
    unint64_t v7 = v178();
    while (1)
    {
      uint64_t v13 = (unint64_t *)v7;
      uint64_t v15 = KeyPathBuffer.next()();
      uint64_t v17 = v16;
      uint64_t v19 = v18;
      unint64_t v20 = v14;
      if (v14)
      {
        unint64_t v7 = v14;
      }

      else
      {
        v178();
        unint64_t v7 = v21;
      }

      RawKeyPathComponent.value.getter(v15, v17, v19, (uint64_t *)v185);
      outlined init with take of KeyPathComponent(v185, (uint64_t)&v194);
      if (v195 >> 61 != 5
        || ((uint64_t v22 = v197 | v198 | v199, v195 != 0xA000000000000000LL) || v22 | v194 | v200 | v196)
        && ((uint64_t v23 = v22 | v196, v200) || v195 != 0xA000000000000000LL || v194 != 1 || v23)
        && (v200 || v195 != 0xA000000000000000LL || v194 != 2 || v23))
      {
        unint64_t v24 = *a2;
        unint64_t v25 = a2[1];
        uint64_t v26 = HIBYTE(v25) & 0xF;
        if ((v25 & 0x2000000000000000LL) == 0) {
          uint64_t v26 = *a2 & 0xFFFFFFFFFFFFLL;
        }
        if (v26 || (v24 & ~v25 & 0x2000000000000000LL) != 0)
        {
          if ((v25 & 0x2000000000000000LL) != 0)
          {
            unint64_t v27 = specialized _SmallString.init(_:appending:)(v24, v25, 0x2EuLL, 0xE100000000000000LL);
            if ((v29 & 1) == 0)
            {
              unint64_t v30 = v27;
              unint64_t v31 = v28;
              swift_bridgeObjectRelease(0xE100000000000000LL);
              swift_bridgeObjectRelease(a2[1]);
              *a2 = v30;
              a2[1] = v31;
              goto LABEL_32;
            }
          }

          _StringGuts.append(_:)(46LL, 0xE100000000000000LL, 0LL, 1LL);
          uint64_t v32 = 0xE100000000000000LL;
        }

        else
        {
          *a2 = 46LL;
          a2[1] = 0xE100000000000000LL;
          uint64_t v32 = v25;
        }

        swift_bridgeObjectRelease(v32);
      }

LABEL_203:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
          }

          uint64_t v90 = v80 & 0xFFFFFFFFFFFFLL;
          goto LABEL_152;
        }

        unint64_t v49 = v48 + 1;
        uint64_t v50 = swift_reflectionMirror_recursiveChildOffset((uint64_t)v13, v48);
        unint64_t v48 = v49;
      }

      while (v50 != v45);
      __s._uint64_t countAndFlagsBits = 0LL;
      __s._object = 0LL;
      __int16 v180 = 0;
      swift_reflectionMirror_recursiveChildMetadata((uint64_t *)v13, (const char *)(v49 - 1), (char **)&__s);
      uint64_t v51 = (uint64_t *)__s._countAndFlagsBits;
      if (!__s._countAndFlagsBits) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while implicitly unwrapping an Optional value",  68LL,  2,  "Swift/KeyPath.swift",  19LL,  2,  0x1036uLL,  0);
      }
      size_t v52 = _swift_stdlib_strlen((const char *)__s._countAndFlagsBits);
      if ((v52 & 0x8000000000000000LL) != 0) {
        goto LABEL_203;
      }
      v53._uint64_t countAndFlagsBits = (uint64_t)_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n( v51,  v52);
      uint64_t v54 = v53._object;
      String.append(_:)(v53);
      swift_bridgeObjectRelease((uint64_t)v54);
      if (__s._object) {
        ((void (*)(uint64_t *))__s._object)(v51);
      }
LABEL_8:
      if (!v20)
      {
        unint64_t v170 = *a2;
        swift_bridgeObjectRetain(a2[1], v10, v11, v12);
        uint64_t v4 = v177;
        goto LABEL_200;
      }
    }
  }

  v172._uint64_t countAndFlagsBits = 0x666C65732ELL;
  v172._object = (void *)0xE500000000000000LL;
  String.append(_:)(v172);
  swift_bridgeObjectRelease(0xE500000000000000LL);
  unint64_t v170 = *a2;
  swift_bridgeObjectRetain(a2[1], v173, v174, v175);
LABEL_200:
  if (!v4) {
    return v170;
  }
  return v171;
}

uint64_t AnyKeyPath._storedInlineOffset.getter()
{
  uint64_t v1 = specialized KeyPathBuffer.init(base:)(v0 + 24);
  uint64_t v20 = v1;
  uint64_t v21 = v2;
  if (v1 && v2 != v1)
  {
    uint64_t v3 = 0LL;
    while (1)
    {
      uint64_t v5 = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5( v20,  v21);
      if (!v5) {
        goto LABEL_52;
      }
      unint64_t v7 = v6 - (void)v5 - 4;
      if (__OFSUB__(v6 - (void)v5, 4LL))
      {
        __break(1u);
LABEL_47:
        __break(1u);
LABEL_48:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
      }

      if ((v7 & 0x8000000000000000LL) != 0) {
        goto LABEL_45;
      }
      unint64_t v8 = *v5;
      uint64_t v9 = (v8 >> 24) & 0x7F;
      if (v9 == 1 || v9 == 3)
      {
        unint64_t v11 = 4LL * ((~(_DWORD)v8 & 0x7FFFFF) == 0LL);
      }

      else
      {
        if (v9 != 2)
        {
          unint64_t v11 = 0LL;
          goto LABEL_32;
        }

        if ((v8 & 0x400000) != 0) {
          unint64_t v11 = 28LL;
        }
        else {
          unint64_t v11 = 20LL;
        }
        if ((v8 & 0x80000) != 0)
        {
          if ((v8 & 0x400000) != 0) {
            uint64_t v12 = 6LL;
          }
          else {
            uint64_t v12 = 4LL;
          }
          uint64_t v13 = (uint64_t)&v5[v12 + 2];
          if ((v13 & 7) != 0) {
            goto LABEL_48;
          }
          uint64_t v14 = *(void *)v13;
          BOOL v15 = __OFADD__(v11 + 16, v14);
          v11 += 16 + v14;
          if (v15)
          {
            __break(1u);
LABEL_51:
            __break(1u);
LABEL_52:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
          }

          if ((v8 & 0x10) != 0)
          {
            BOOL v15 = __OFADD__(v11, 8LL);
            v11 += 8LL;
            if (v15) {
              goto LABEL_51;
            }
          }

          if ((v11 & 0x8000000000000000LL) != 0) {
LABEL_45:
          }
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
        }
      }

      if (v7 < v11) {
        goto LABEL_45;
      }
LABEL_32:
      uint64_t v16 = v5 + 1;
      uint64_t v20 = (uint64_t)v5 + v11 + 4;
      uint64_t v21 = v6;
      if (v7 == v11)
      {
        uint64_t v17 = 0LL;
      }

      else
      {
        uint64_t v18 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v20, 1LL);
        if (!v18) {
          goto LABEL_52;
        }
        uint64_t v17 = *v18;
      }

      if (v9 != 1) {
        return 0LL;
      }
      uint64_t v19 = v8 & 0x7FFFFF;
      if ((v8 & 0x7FFFFF) == 0x7FFFFF)
      {
        if (v11 < 4) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer.load out of bounds",  41LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x55EuLL,  0);
        }
        uint64_t v19 = *v16;
      }

      BOOL v15 = __OFADD__(v3, v19);
      v3 += v19;
      if (v15) {
        goto LABEL_47;
      }
      if (!v17) {
        return v3;
      }
    }
  }

  return 0LL;
}

uint64_t KeyPathBuffer.next()()
{
  uint64_t v1 = (unsigned int *)specialized _pop<A>(from:as:count:)((uint64_t *)v0, 1LL);
  if (!v1) {
    goto LABEL_9;
  }
  uint64_t v2 = *v1;
  if ((v2 & 0x80000000) != 0) {
    *(_BYTE *)(v0 + 17) = 0;
  }
  uint64_t v3 = *(void *)v0;
  uint64_t v4 = RawKeyPathComponent.bodySize.getter(v2, *(void *)v0);
  specialized UnsafeRawBufferPointer.init<A>(_:)(v3, v4);
  specialized _pop<A>(from:as:count:)((uint64_t *)v0, v4);
  if (*(void *)v0)
  {
    if (*(void *)(v0 + 8) != *(void *)v0 && !specialized _pop<A>(from:as:count:)((uint64_t *)v0, 1LL)) {
LABEL_9:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  return v2;
}

uint64_t AnyKeyPath.deinit()
{
  return v0;
}

void AnyKeyPath.__deallocating_deinit()
{
}

Swift::Int AnyKeyPath.hashValue.getter()
{
  return Hasher._finalize()();
}

void AnyKeyPath.hash(into:)()
{
  if ((((_BYTE)v0 + 24) & 3) != 0) {
LABEL_76:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  uint64_t v1 = *(_DWORD *)(v0 + 24) & 0xFFFFFF;
  uint64_t v32 = v0 + 32;
  uint64_t v33 = v0 + 32 + v1;
  if ((_DWORD)v1)
  {
    uint64_t v2 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v32, 1LL);
    if (!v2) {
LABEL_74:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    while (1)
    {
      unsigned int v3 = *v2;
      uint64_t v4 = v32;
      int v5 = HIBYTE(*v2) & 0x7F;
      if (v5 == 1 || v5 == 3)
      {
        if ((~v3 & 0x7FFFFF) != 0) {
          goto LABEL_17;
        }
        uint64_t v7 = 4LL;
      }

      else
      {
        if (v5 != 2)
        {
LABEL_17:
          uint64_t v7 = 0LL;
          uint64_t v8 = 0LL;
          uint64_t v9 = 0LL;
          if (!v32) {
            goto LABEL_28;
          }
          goto LABEL_27;
        }

        uint64_t v7 = 28LL;
        if ((v3 & 0x400000) == 0) {
          uint64_t v7 = 20LL;
        }
        if ((v3 & 0x80000) != 0)
        {
          if (!v32) {
            goto LABEL_74;
          }
          uint64_t v10 = 24LL;
          if ((v3 & 0x400000) == 0) {
            uint64_t v10 = 16LL;
          }
          uint64_t v11 = v32 + v10 + 4;
          if ((v11 & 7) != 0) {
            goto LABEL_76;
          }
          uint64_t v12 = v7 + 16;
          uint64_t v13 = *(void *)v11;
          BOOL v14 = __OFADD__(v12, v13);
          uint64_t v7 = v12 + v13;
          if (v14)
          {
            __break(1u);
LABEL_79:
            __break(1u);
LABEL_80:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
          }

          if ((v3 & 0x10) != 0)
          {
            BOOL v14 = __OFADD__(v7, 8LL);
            v7 += 8LL;
            if (v14) {
              goto LABEL_79;
            }
          }

          if (v7 < 0) {
            goto LABEL_77;
          }
          goto LABEL_27;
        }
      }

      if (!v32) {
        goto LABEL_80;
      }
LABEL_27:
      uint64_t v8 = v32 + v7;
      uint64_t v9 = v7;
LABEL_28:
      specialized _pop<A>(from:as:count:)(&v32, v9);
      if (v32 && v33 != v32)
      {
        uint64_t v19 = (Swift::UInt *)specialized _pop<A>(from:as:count:)(&v32, 1LL);
        if (!v19) {
          goto LABEL_74;
        }
        Swift::UInt v15 = *v19;
        if (v5 == 1)
        {
LABEL_38:
          unsigned int v20 = v3 & 0x7FFFFF;
          if ((v3 & 0x7FFFFF) == 0x7FFFFF) {
            unsigned int v20 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0LL, v4, v8);
          }
          Swift::UInt v17 = v20;
          Swift::UInt v18 = 0LL;
          goto LABEL_41;
        }
      }

      else
      {
        Swift::UInt v15 = 0LL;
        if (v5 == 1) {
          goto LABEL_38;
        }
      }

      if (v5 == 2)
      {
        uint64_t v21 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(4LL, v4, v8);
        if (!v4) {
          goto LABEL_74;
        }
        Swift::UInt v22 = v21;
        if ((v3 & 0x80000) != 0)
        {
          uint64_t v27 = 24LL;
          if ((v3 & 0x400000) != 0) {
            uint64_t v28 = 24LL;
          }
          else {
            uint64_t v28 = 16LL;
          }
          uint64_t v29 = v4 + v28 + 4;
          if ((v3 & 0x10) == 0) {
            uint64_t v27 = 16LL;
          }
          if ((v29 & 7) != 0) {
            goto LABEL_76;
          }
          if ((*(void *)v29 & 0x8000000000000000LL) != 0) {
LABEL_77:
          }
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
          if (((v29 + 8) & 7) != 0) {
            goto LABEL_76;
          }
          uint64_t v25 = *(void *)(v29 + 8);
          if ((v3 & 0x10) != 0)
          {
            if (((v29 + 16) & 7) != 0) {
              goto LABEL_76;
            }
            uint64_t v26 = *(void *)(v29 + 16);
          }

          else
          {
            uint64_t v26 = 0LL;
          }

          uint64_t v23 = v29 + v27;
          uint64_t v24 = v29 + v27 + *(void *)v29;
        }

        else
        {
          uint64_t v23 = 0LL;
          uint64_t v24 = 0LL;
          uint64_t v25 = 0LL;
          uint64_t v26 = 0LL;
        }

        if ((v3 & 0x200000) != 0) {
          Swift::UInt v30 = 1LL;
        }
        else {
          Swift::UInt v30 = (v3 >> 19) & 2;
        }
        if ((v3 & 0x400000) != 0)
        {
          if ((v3 & 0x800000) != 0) {
            Swift::UInt v31 = 6LL;
          }
          else {
            Swift::UInt v31 = 7LL;
          }
        }

        else
        {
          Swift::UInt v31 = 5LL;
        }

        Hasher._combine(_:)(v31);
        Hasher._combine(_:)(v22);
        Hasher._combine(_:)(v30);
        appendHashFromArgument #1 (_:) in KeyPathComponent.hash(into:)(v23, v24, v25, v26);
        goto LABEL_72;
      }

      if (v5 != 3)
      {
        if ((v3 & 0xFFFFFF) != 0)
        {
          if ((v3 & 0xFFFFFF) == 1) {
            Hasher._combine(_:)(4uLL);
          }
          else {
            Hasher._combine(_:)(3uLL);
          }
        }

        else
        {
          Hasher._combine(_:)(2uLL);
        }

        goto LABEL_72;
      }

      unsigned int v16 = v3 & 0x7FFFFF;
      if ((v3 & 0x7FFFFF) == 0x7FFFFF) {
        unsigned int v16 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0LL, v4, v8);
      }
      Swift::UInt v17 = v16;
      Swift::UInt v18 = 1LL;
LABEL_41:
      Hasher._combine(_:)(v18);
      Hasher._combine(_:)(v17);
LABEL_72:
      if (!v15) {
        return;
      }
      Hasher._combine(_:)(v15);
      uint64_t v2 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v32, 1LL);
      if (!v2) {
        goto LABEL_74;
      }
    }
  }

void ObjectIdentifier.hash(into:)(int a1, Swift::UInt a2)
{
}

uint64_t RawKeyPathComponent.value.getter@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  unsigned int v5 = result;
  unsigned int v7 = BYTE3(result) & 0x7F;
  if (v7 == 1)
  {
    uint64_t v8 = result & 0x7FFFFF;
    if ((_DWORD)v8 == 0x7FFFFF)
    {
      unint64_t result = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0LL, a2, a3);
      unint64_t v14 = 0LL;
      uint64_t v9 = 0LL;
      uint64_t v10 = 0LL;
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
      uint64_t v13 = 0LL;
      uint64_t v8 = result;
    }

    else
    {
      unint64_t v14 = 0LL;
      uint64_t v9 = 0LL;
      uint64_t v10 = 0LL;
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
      uint64_t v13 = 0LL;
    }

    goto LABEL_33;
  }

  if (v7 != 2)
  {
    if (v7 == 3)
    {
      uint64_t v8 = result & 0x7FFFFF;
      if ((_DWORD)v8 == 0x7FFFFF)
      {
        unint64_t result = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0LL, a2, a3);
        uint64_t v9 = 0LL;
        uint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
        uint64_t v12 = 0LL;
        uint64_t v13 = 0LL;
        unint64_t v14 = 0x2000000000000000LL;
        uint64_t v8 = result;
      }

      else
      {
        uint64_t v9 = 0LL;
        uint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
        uint64_t v12 = 0LL;
        uint64_t v13 = 0LL;
        unint64_t v14 = 0x2000000000000000LL;
      }
    }

    else
    {
      uint64_t v8 = result & 0xFFFFFF;
      if ((result & 0xFFFFFF) != 0)
      {
        if ((_DWORD)v8 == 1) {
          uint64_t v8 = 2LL;
        }
        else {
          uint64_t v8 = 1LL;
        }
        unint64_t v14 = 0xA000000000000000LL;
        uint64_t v9 = 0LL;
        uint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
        uint64_t v12 = 0LL;
        uint64_t v13 = 0LL;
      }

      else
      {
        unint64_t v14 = 0xA000000000000000LL;
        uint64_t v9 = result & 0xFFFFFF;
        uint64_t v10 = v9;
        uint64_t v11 = v9;
        uint64_t v12 = v9;
        uint64_t v13 = v9;
      }
    }

    goto LABEL_33;
  }

  unint64_t result = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(4LL, a2, a3);
  if ((v5 & 0x200000) != 0) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = (v5 >> 19) & 2;
  }
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  uint64_t v8 = result;
  if ((v5 & 0x80000) != 0)
  {
    uint64_t v10 = RawKeyPathComponent._computedArguments.getter(v5, a2);
    uint64_t v16 = RawKeyPathComponent._computedArgumentSize.getter(v5, a2);
    if (v16 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
    }
    uint64_t v17 = v16;
    unint64_t result = RawKeyPathComponent._computedArgumentHeaderPointer.getter(v5, a2);
    if (((result + 8) & 7) == 0)
    {
      uint64_t v12 = *(void *)(result + 8);
      if ((v5 & 0x10) == 0)
      {
        uint64_t v13 = 0LL;
LABEL_28:
        uint64_t v11 = v10 + v17;
        goto LABEL_29;
      }

      unint64_t result = RawKeyPathComponent._computedArguments.getter(v5, a2);
      if (((result - 8) & 7) == 0)
      {
        uint64_t v13 = *(void *)(result - 8);
        goto LABEL_28;
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }

  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
LABEL_29:
  uint64_t v9 = a2 + 12;
  unint64_t v14 = v15 | 0x6000000000000000LL;
  if ((v5 & 0x800000) == 0) {
    unint64_t v14 = v15 | 0x8000000000000000LL;
  }
  if ((v5 & 0x400000) == 0) {
    unint64_t v14 = v15 | 0x4000000000000000LL;
  }
LABEL_33:
  *a4 = v8;
  a4[1] = v14;
  a4[2] = v9;
  a4[3] = v10;
  a4[4] = v11;
  a4[5] = v12;
  a4[6] = v13;
  return result;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance AnyKeyPath()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance AnyKeyPath()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance AnyKeyPath()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance AnyKeyPath( void **a1, void **a2)
{
  return specialized static AnyKeyPath.== infix(_:_:)(*a1, *a2);
}

uint64_t PartialKeyPath.deinit()
{
  return v0;
}

uint64_t static KeyPath._rootAndValueType.getter()
{
  return *(void *)(v0 + 144);
}

uint64_t KeyPath._projectReadOnly(from:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = *v4;
  uint64_t v8 = *(void *)(*v4 + 152LL);
  uint64_t v9 = type metadata accessor for Optional(0LL, v8, a2, a3);
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v41 - v11;
  uint64_t v13 = v4[2];
  if (v13)
  {
    BOOL v14 = __OFSUB__(0LL, v13);
    uint64_t v15 = -v13;
    if (v14) {
      goto LABEL_43;
    }
    BOOL v14 = __OFSUB__(v15, 1LL);
    uint64_t v16 = v15 - 1;
    if (v14)
    {
LABEL_44:
      __break(1u);
      goto LABEL_45;
    }

    if ((v16 & 0x8000000000000000LL) == 0)
    {
      if ((*(void *)(*(void *)(*(void *)(v7 + 144) - 8LL) + 64LL) & 0x8000000000000000LL) != 0) {
LABEL_39:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16LL))(a4, a1 + v16, v8);
    }
  }

  uint64_t v42 = a4;
  uint64_t v18 = *(void *)(v7 + 144);
  v47[3] = v18;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v47);
  uint64_t v20 = *(void *)(v18 - 8);
  (*(void (**)(void *, uint64_t, uint64_t))(v20 + 16))(boxed_opaque_existential_0Tm, a1, v18);
  uint64_t v21 = specialized KeyPathBuffer.init(base:)((uint64_t)(v4 + 3));
  if (!v21 || v22 == v21)
  {
    uint64_t v23 = *(void *)(v8 - 8);
    if (*(void *)(v20 + 64) == *(void *)(v23 + 64))
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v23 + 16))(v42, a1, v8);
      return __swift_destroy_boxed_opaque_existential_1Tm(v47);
    }

Swift::UnsafeRawPointer __swiftcall UnsafeRawPointer.advanced(by:)(Swift::Int by)
{
  return (Swift::UnsafeRawPointer)(v1 + by);
}

void specialized project2 #1 <A, B><A1><A2>(_:) in project #1 <A, B><A1>(_:) in closure #2 in KeyPath._projectReadOnly(from:)( unsigned int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, uint64_t a10)
{
  uint64_t v26 = a6;
  int v28 = a5;
  uint64_t v35 = a4;
  uint64_t v37 = a2;
  uint64_t v38 = a3;
  unsigned int v36 = a1;
  uint64_t v29 = a9;
  v40[7] = *MEMORY[0x1895F89C0];
  uint64_t v22 = type metadata accessor for Optional(0LL, a8, a3, a4);
  void v21[2] = *(void *)(v22 - 8);
  MEMORY[0x1895F8858](v22);
  uint64_t v23 = (char *)v21 - v11;
  uint64_t v24 = type metadata accessor for Optional(0LL, a10, v12, v13);
  uint64_t v25 = *(void *)(v24 - 8);
  uint64_t v14 = *(void *)(v25 + 64);
  uint64_t v15 = MEMORY[0x1895F8858](v24);
  v21[1] = (char *)v21 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v31 = *(void *)(a10 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v32 = (char *)v21 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  MEMORY[0x1895F8858](v19);
  uint64_t v33 = a10;
  uint64_t v34 = a7;
  uint64_t v30 = type metadata accessor for RawKeyPathComponent.ProjectionResult(0LL, a10, a7, v20);
  MEMORY[0x1895F8858](v30);
  RawKeyPathComponent.value.getter(v36, v37, v38, (uint64_t *)v39);
  outlined init with take of KeyPathComponent(v39, (uint64_t)v40);
  __asm { BR              X16 }

uint64_t sub_181560CA4@<X0>(uint64_t a1@<X8>)
{
  *(void *)(v6 - 144) = v1 & 0x1FFFFFFFFFFFFFFFLL;
  if ((v2 & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  uint64_t v7 = a1 - (void)v3;
  if (v4) {
    BOOL v8 = v3 == 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = v7;
  }
  if (v8) {
    uint64_t v10 = v2;
  }
  else {
    uint64_t v10 = v3;
  }
  (*v2)(*(void *)(v6 - 272), v10, v9);
  uint64_t v11 = *(void *)(v6 - 280);
  uint64_t v12 = *(void *)(v6 - 288);
  uint64_t v13 = *(_BYTE **)(v6 - 296);
  uint64_t v14 = *(void *)(v6 - 304);
  swift_storeEnumTagMultiPayload(v5, *(void *)(v6 - 312), 0);
  uint64_t v15 = *(void (**)(uint64_t, _BYTE *, uint64_t))(v14 + 32);
  v15((uint64_t)v13, v5, v12);
  if ((*(_DWORD *)(v6 - 324) & 1) != 0)
  {
    uint64_t v16 = *(void *)(v11 - 8);
    if (*(void *)(v6 - 336) != *(void *)(v16 + 64)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }
    uint64_t v17 = *(void *)(v6 - 320);
    (*(void (**)(uint64_t, _BYTE *, uint64_t))(v16 + 16))(v17, v13, v11);
    (*(void (**)(_BYTE *, uint64_t))(v14 + 8))(v13, v12);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v16 + 56))(v17, 0LL, 1LL, v11);
  }

  else
  {
    *(void *)(v6 - 216) = v12;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm((void *)(v6 - 240));
    v15((uint64_t)boxed_opaque_existential_0Tm, v13, v12);
    uint64_t v20 = *(uint64_t **)(v6 - 344);
    __swift_destroy_boxed_opaque_existential_1Tm(v20);
    outlined init with take of Any((_OWORD *)(v6 - 240), v20);
    return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56LL))( *(void *)(v6 - 320),  1LL,  1LL,  v11);
  }

void RawKeyPathComponent._projectReadOnly<A, B, C>(_:to:endingWith:)( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>, uint64_t a9)
{
  uint64_t v33 = a8;
  uint64_t v34 = a1;
  uint64_t v31 = a9;
  v36[7] = *MEMORY[0x1895F89C0];
  uint64_t v24 = type metadata accessor for Optional(0LL, a6, a2, a3);
  v23[2] = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v25 = (char *)v23 - v14;
  uint64_t v28 = type metadata accessor for Optional(0LL, a7, v15, v16);
  uint64_t v27 = *(void *)(v28 - 8);
  uint64_t v17 = *(void *)(v27 + 64);
  uint64_t v18 = MEMORY[0x1895F8858](v28);
  v23[1] = (char *)v23 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v26 = (char *)v23 - v20;
  uint64_t v32 = a7;
  uint64_t v30 = *(void *)(a7 - 8);
  uint64_t v21 = *(void *)(v30 + 64);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  v23[0] = (char *)v23 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = a6;
  MEMORY[0x1895F8858](v22);
  RawKeyPathComponent.value.getter(a3, a4, a5, (uint64_t *)v35);
  outlined init with take of KeyPathComponent(v35, (uint64_t)v36);
  __asm { BR              X12 }

void sub_18156148C(uint64_t a1@<X8>)
{
  *(void *)(v5 - 144) = a1 & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v6 = (void (*)(void, uint64_t, uint64_t))ComputedAccessorsPtr.getter<A, B>()(v3);
  if (v4) {
    BOOL v7 = v2 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = v1 - v2;
  }
  if (v7) {
    uint64_t v9 = v3;
  }
  else {
    uint64_t v9 = v2;
  }
  uint64_t v10 = *(_BYTE **)(v5 - 256);
  v6(*(void *)(v5 - 248), v9, v8);
  size_t v12 = type metadata accessor for RawKeyPathComponent.ProjectionResult( 0LL,  *(void *)(v5 - 264),  *(void *)(v5 - 272),  v11);
  swift_storeEnumTagMultiPayload(v10, v12, 0);
}

uint64_t KeyPath.deinit()
{
  if (((v0 + 24) & 3) != 0) {
LABEL_59:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  int v1 = *(_DWORD *)(v0 + 24);
  if ((v1 & 0x80000000) == 0)
  {
    uint64_t v28 = v0 + 32;
    uint64_t v29 = v0 + 32 + (*(void *)&v1 & 0xFFFFFFLL);
    while (1)
    {
      uint64_t v2 = (_DWORD *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5( v28,  v29);
      if (!v2) {
        goto LABEL_63;
      }
      uint64_t v4 = v2;
      unint64_t v5 = v3 - (void)v2 - 4;
      if (__OFSUB__(v3 - (void)v2, 4LL))
      {
        __break(1u);
        goto LABEL_59;
      }

      if ((v5 & 0x8000000000000000LL) != 0) {
        goto LABEL_57;
      }
      int v6 = *v2;
      int v7 = HIBYTE(*v2) & 0x7F;
      if (v7 == 1 || v7 == 3) {
        break;
      }
      if (v7 == 2)
      {
        unint64_t v9 = 28LL;
        if ((v6 & 0x400000) == 0) {
          unint64_t v9 = 20LL;
        }
        if ((v6 & 0x80000) != 0)
        {
          if ((v6 & 0x400000) != 0) {
            uint64_t v10 = 6LL;
          }
          else {
            uint64_t v10 = 4LL;
          }
          uint64_t v11 = (uint64_t)&v2[v10 + 2];
          if ((v11 & 7) != 0) {
            goto LABEL_59;
          }
          unint64_t v12 = v9 + 16;
          uint64_t v13 = *(void *)v11;
          BOOL v14 = __OFADD__(v12, v13);
          unint64_t v9 = v12 + v13;
          if (v14)
          {
            __break(1u);
LABEL_61:
            __break(1u);
LABEL_62:
            __break(1u);
LABEL_63:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
          }

          if ((v6 & 0x10) != 0)
          {
            BOOL v14 = __OFADD__(v9, 8LL);
            v9 += 8LL;
            if (v14) {
              goto LABEL_62;
            }
          }

          if ((v9 & 0x8000000000000000LL) != 0) {
LABEL_57:
          }
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
        }

        goto LABEL_14;
      }

      unint64_t v9 = 0LL;
LABEL_30:
      uint64_t v28 = (uint64_t)v2 + v9 + 4;
      uint64_t v29 = v3;
      if (v5 == v9)
      {
        uint64_t v15 = 0LL;
      }

      else
      {
        uint64_t v16 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v28, 1LL);
        if (!v16) {
          goto LABEL_63;
        }
        uint64_t v15 = *v16;
      }

      BOOL v17 = (v6 & 0x7D000000) != 0x1000000 && v7 == 2;
      if (v17 && (v6 & 0x80000) != 0)
      {
        if ((v6 & 0x400000) != 0) {
          uint64_t v18 = 6LL;
        }
        else {
          uint64_t v18 = 4LL;
        }
        uint64_t v19 = &v4[v18];
        uint64_t v20 = (uint64_t)&v4[v18 + 4];
        if ((v20 & 7) != 0) {
          goto LABEL_59;
        }
        uint64_t v21 = *(void (***)(uint64_t *, uint64_t))v20;
        uint64_t v22 = *v21;
        if (v22)
        {
          uint64_t v23 = (uint64_t *)(v19 + 2);
          if ((v6 & 0x10) != 0) {
            uint64_t v24 = 3LL;
          }
          else {
            uint64_t v24 = 2LL;
          }
          uint64_t v25 = *v23;
          if ((v6 & 0x10) != 0)
          {
            uint64_t v26 = v23[2];
          }

          else
          {
            uint64_t v26 = 0LL;
          }

          if (__OFSUB__(v25, v26)) {
            goto LABEL_61;
          }
          v22(&v23[v24], v25 - v26);
        }
      }

      if (!v15) {
        return v0;
      }
    }

    unint64_t v9 = 4LL * ((~v6 & 0x7FFFFF) == 0);
LABEL_14:
    if (v5 < v9) {
      goto LABEL_57;
    }
    goto LABEL_30;
  }

  return v0;
}

void KeyPath.__deallocating_deinit()
{
}

uint64_t WritableKeyPath._projectMutableAddress(from:)(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = *v1;
  uint64_t v4 = v1[2];
  if (v4)
  {
    BOOL v5 = __OFSUB__(0LL, v4);
    uint64_t v6 = -v4;
    if (v5) {
      goto LABEL_38;
    }
    BOOL v5 = __OFSUB__(v6, 1LL);
    uint64_t v7 = v6 - 1;
    if (v5)
    {
LABEL_39:
      __break(1u);
LABEL_40:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
    }

    if ((v7 & 0x8000000000000000LL) == 0) {
      return a1 + v7;
    }
  }

  uint64_t v8 = *(void *)(v3 + 168);
  uint64_t v30 = 0LL;
  uint64_t v9 = specialized KeyPathBuffer.init(base:)((uint64_t)(v1 + 3));
  uint64_t v28 = v9;
  unint64_t v29 = v10;
  if (v9 && v10 != v9)
  {
    do
    {
      uint64_t v11 = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5( v28,  v29);
      if (!v11) {
        goto LABEL_43;
      }
      unint64_t v13 = v12 - (void)v11 - 4;
      if (__OFSUB__(v12 - (void)v11, 4LL))
      {
        __break(1u);
LABEL_38:
        __break(1u);
        goto LABEL_39;
      }

      if ((v13 & 0x8000000000000000LL) != 0) {
        goto LABEL_36;
      }
      uint64_t v14 = (uint64_t)(v11 + 1);
      uint64_t v15 = *v11;
      unsigned int v16 = BYTE3(v15) & 0x7F;
      if (v16 != 1)
      {
        if (v16 == 2)
        {
          if ((v15 & 0x400000) != 0) {
            unint64_t v17 = 28LL;
          }
          else {
            unint64_t v17 = 20LL;
          }
          if ((v15 & 0x80000) != 0)
          {
            uint64_t v18 = 6LL;
            if ((v15 & 0x400000) == 0) {
              uint64_t v18 = 4LL;
            }
            uint64_t v19 = (uint64_t)&v11[v18 + 2];
            if ((v19 & 7) != 0) {
              goto LABEL_40;
            }
            unint64_t v20 = v17 + 16;
            uint64_t v21 = *(void *)v19;
            BOOL v5 = __OFADD__(v20, v21);
            unint64_t v17 = v20 + v21;
            if (v5)
            {
              __break(1u);
LABEL_42:
              __break(1u);
LABEL_43:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            }

            if ((v15 & 0x10) != 0)
            {
              BOOL v5 = __OFADD__(v17, 8LL);
              v17 += 8LL;
              if (v5) {
                goto LABEL_42;
              }
            }

            if ((v17 & 0x8000000000000000LL) != 0) {
              goto LABEL_36;
            }
          }

          goto LABEL_27;
        }

        if (v16 != 3)
        {
          unint64_t v17 = 0LL;
          uint64_t v22 = (uint64_t)(v11 + 1);
          goto LABEL_30;
        }
      }

      unint64_t v17 = 4LL * ((~(_DWORD)v15 & 0x7FFFFF) == 0);
LABEL_27:
      if (v13 < v17) {
LABEL_36:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
      uint64_t v22 = v14 + v17;
LABEL_30:
      uint64_t v28 = v22;
      unint64_t v29 = v14 + v13;
      if (v13 == v17)
      {
        specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)( v2,  (uint64_t)&v30,  v15,  v14,  v22,  v8,  *(void *)(v3 + 176));
        return v26;
      }

      uint64_t v23 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v28, 1LL);
      if (!v23) {
        goto LABEL_43;
      }
      uint64_t v24 = *v23;
      specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)( v2,  (uint64_t)&v30,  v15,  v14,  v22,  v8,  *v23);
      uint64_t v2 = v25;
      uint64_t v8 = v24;
    }

    while (v24);
  }

  return v2;
}

void WritableKeyPath.__deallocating_deinit()
{
}

char *ReferenceWritableKeyPath._projectMutableAddress(from:)(uint64_t a1)
{
  v68[1] = *MEMORY[0x1895F89C0];
  uint64_t v3 = *v1;
  v68[0] = 0LL;
  uint64_t v4 = specialized KeyPathBuffer.init(base:)((uint64_t)(v1 + 3));
  __int16 v6 = v5;
  uint64_t v66 = v4;
  unint64_t v67 = v7;
  uint64_t v56 = v3;
  uint64_t v8 = *(void *)(v3 + 192);
  uint64_t v65 = v8;
  uint64_t v9 = __swift_allocate_boxed_opaque_existential_0Tm(&v64);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16LL))(v9, a1, v8);
  if ((v6 & 0x100) != 0)
  {
    do
    {
      uint64_t v10 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v66, 1LL);
      if (!v10) {
        goto LABEL_67;
      }
      uint64_t v11 = *v10;
      uint64_t v12 = v66;
      unsigned int v13 = BYTE3(v11) & 0x7F;
      if (v13 == 1 || v13 == 3)
      {
        if ((~(_DWORD)v11 & 0x7FFFFF) != 0) {
          goto LABEL_16;
        }
        uint64_t v15 = 4LL;
      }

      else
      {
        if (v13 != 2)
        {
LABEL_16:
          uint64_t v15 = 0LL;
          uint64_t v16 = 0LL;
          uint64_t v17 = 0LL;
          if (!v66) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }

        uint64_t v15 = 28LL;
        if ((v11 & 0x400000) == 0) {
          uint64_t v15 = 20LL;
        }
        if ((v11 & 0x80000) != 0)
        {
          if (!v66) {
            goto LABEL_67;
          }
          uint64_t v18 = 24LL;
          if ((v11 & 0x400000) == 0) {
            uint64_t v18 = 16LL;
          }
          uint64_t v19 = v66 + v18 + 4;
          if ((v19 & 7) != 0) {
            goto LABEL_62;
          }
          uint64_t v20 = v15 + 16;
          uint64_t v21 = *(void *)v19;
          BOOL v22 = __OFADD__(v20, v21);
          uint64_t v15 = v20 + v21;
          if (v22)
          {
            __break(1u);
LABEL_64:
            __break(1u);
LABEL_65:
            __break(1u);
LABEL_66:
            __break(1u);
LABEL_67:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
          }

          if ((v11 & 0x10) != 0)
          {
            BOOL v22 = __OFADD__(v15, 8LL);
            v15 += 8LL;
            if (v22) {
              goto LABEL_65;
            }
          }

          if (v15 < 0) {
            goto LABEL_60;
          }
          goto LABEL_26;
        }
      }

      if (!v66) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
      }
LABEL_26:
      uint64_t v16 = v66 + v15;
      uint64_t v17 = v15;
LABEL_27:
      specialized _pop<A>(from:as:count:)(&v66, v17);
      if (!v66) {
        goto LABEL_67;
      }
      if (v67 == v66) {
        goto LABEL_67;
      }
      uint64_t v23 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v66, 1LL);
      if (!v23) {
        goto LABEL_67;
      }
      uint64_t v24 = *v23;
      outlined init with copy of Any((uint64_t)&v64, (uint64_t)v60);
      uint64_t v58 = v61;
      uint64_t v57 = __swift_project_boxed_opaque_existential_0Tm(v60, v61);
      uint64_t v25 = *(void *)(v56 + 200);
      uint64_t v27 = type metadata accessor for RawKeyPathComponent.ProjectionResult(0LL, v24, v25, v26);
      unint64_t v59 = &v55;
      uint64_t v28 = *(void *)(v27 - 8);
      uint64_t v29 = *(void *)(v28 + 64);
      MEMORY[0x1895F8858](v27);
      uint64_t v30 = (char *)&v55 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      RawKeyPathComponent._projectReadOnly<A, B, C>(_:to:endingWith:)( (uint64_t)v57,  v31,  v11,  v12,  v16,  v58,  v24,  (uint64_t)v30,  v25);
      uint64_t v63 = v24;
      uint64_t v32 = __swift_allocate_boxed_opaque_existential_0Tm(&v62);
      MEMORY[0x1895F8858](v32);
      (*(void (**)(char *, char *, uint64_t))(v28 + 16))(v30, v30, v27);
      (*(void (**)(char *, uint64_t))(v28 + 8))(v30, v27);
      (*(void (**)(void *, char *, uint64_t))(*(void *)(v24 - 8) + 32LL))(v32, v30, v24);
      __swift_destroy_boxed_opaque_existential_1Tm(v60);
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v64);
      outlined init with take of Any(&v62, &v64);
    }

    while ((v11 & 0x80000000) == 0);
  }

  uint64_t v33 = v65;
  uint64_t v34 = __swift_project_boxed_opaque_existential_0Tm(&v64, v65);
  uint64_t v35 = *(void *)(v33 - 8);
  uint64_t v36 = *(void *)(v35 + 64);
  MEMORY[0x1895F8858](v34);
  uint64_t v37 = (char *)&v55 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v35 + 16))(v37);
  if (v36 < 0) {
LABEL_60:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  (*(void (**)(char *, uint64_t))(v35 + 8))((char *)&v55 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0LL), v33);
  while (1)
  {
    uint64_t v38 = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5( v66,  v67);
    if (!v38) {
      goto LABEL_67;
    }
    unint64_t v40 = v39 - (void)v38 - 4;
    if (__OFSUB__(v39 - (void)v38, 4LL))
    {
      __break(1u);
LABEL_62:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
    }

    if ((v40 & 0x8000000000000000LL) != 0) {
      goto LABEL_60;
    }
    uint64_t v41 = (uint64_t)(v38 + 1);
    uint64_t v42 = *v38;
    unsigned int v43 = BYTE3(v42) & 0x7F;
    if (v43 != 1)
    {
      if (v43 == 2)
      {
        if ((v42 & 0x400000) != 0) {
          unint64_t v44 = 28LL;
        }
        else {
          unint64_t v44 = 20LL;
        }
        if ((v42 & 0x80000) != 0)
        {
          uint64_t v45 = 6LL;
          if ((v42 & 0x400000) == 0) {
            uint64_t v45 = 4LL;
          }
          uint64_t v46 = (uint64_t)&v38[v45 + 2];
          if ((v46 & 7) != 0) {
            goto LABEL_62;
          }
          unint64_t v47 = v44 + 16;
          uint64_t v48 = *(void *)v46;
          BOOL v22 = __OFADD__(v47, v48);
          unint64_t v44 = v47 + v48;
          if (v22) {
            goto LABEL_64;
          }
          if ((v42 & 0x10) != 0)
          {
            BOOL v22 = __OFADD__(v44, 8LL);
            v44 += 8LL;
            if (v22) {
              goto LABEL_66;
            }
          }

          if ((v44 & 0x8000000000000000LL) != 0) {
            goto LABEL_60;
          }
        }

        goto LABEL_51;
      }

      if (v43 != 3)
      {
        unint64_t v44 = 0LL;
        uint64_t v49 = (uint64_t)(v38 + 1);
        goto LABEL_54;
      }
    }

    unint64_t v44 = 4LL * ((~(_DWORD)v42 & 0x7FFFFF) == 0);
LABEL_51:
    if (v40 < v44) {
      goto LABEL_60;
    }
    uint64_t v49 = v41 + v44;
LABEL_54:
    uint64_t v66 = v49;
    unint64_t v67 = v41 + v40;
    if (v40 == v44) {
      break;
    }
    uint64_t v50 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v66, 1LL);
    if (!v50) {
      goto LABEL_67;
    }
    uint64_t v51 = *v50;
    specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)( (uint64_t)v37,  (uint64_t)v68,  v42,  v41,  v49,  v33,  *v50);
    uint64_t v37 = v52;
    uint64_t v33 = v51;
    if (!v51) {
      goto LABEL_59;
    }
  }

  specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)( (uint64_t)v37,  (uint64_t)v68,  v42,  v41,  v49,  v33,  *(void *)(v56 + 200));
  uint64_t v37 = v53;
LABEL_59:
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v64);
  return v37;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance ComputedPropertyID()
{
  Swift::UInt v1 = *(unsigned __int8 *)(v0 + 8);
  Hasher._combine(_:)(*(void *)v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance ComputedPropertyID()
{
  Swift::UInt v1 = *(unsigned __int8 *)(v0 + 8);
  Hasher._combine(_:)(*(void *)v0);
  Hasher._combine(_:)(v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance ComputedPropertyID()
{
  Swift::UInt v1 = *(unsigned __int8 *)(v0 + 8);
  Hasher._combine(_:)(*(void *)v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance ComputedPropertyID( uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2 && *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
}

uint64_t ComputedAccessorsPtr.getter<A, B>()(uint64_t a1)
{
  if ((a1 & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  return *(void *)a1;
}

uint64_t ComputedAccessorsPtr.nonmutatingSetter<A, B>()(uint64_t a1)
{
  if (((a1 + 8) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  return *(void *)(a1 + 8);
}

uint64_t ComputedArgumentWitnessesPtr.equals.getter(uint64_t a1)
{
  if (((a1 + 16) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  return *(void *)(a1 + 16);
}

uint64_t ComputedArgumentWitnessesPtr.hash.getter(uint64_t a1)
{
  if (((a1 + 24) & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  return *(void *)(a1 + 24);
}

void KeyPathComponent.hash(into:)()
{
  __asm { BR              X10 }

void sub_181562874()
{
}

void sub_181562904( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v17 == 0xA000000000000000LL && (v16 | a12 | v15 | v12 | v14 | v13) == 0)
  {
    Hasher._combine(_:)(2uLL);
  }

  else if (v17 == 0xA000000000000000LL && v15 == 1 && !(v16 | a12 | v12 | v14 | v13))
  {
    Hasher._combine(_:)(3uLL);
  }

  else
  {
    Hasher._combine(_:)(4uLL);
  }

  JUMPOUT(0x1815628E8LL);
}

void appendHashFromArgument #1 (_:) in KeyPathComponent.hash(into:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t))ComputedArgumentWitnessesPtr.hash.getter(a3);
    if (a1)
    {
      if (!__OFSUB__(a2 - a1, a4))
      {
        Swift::UInt v8 = v7(a1, a2 - a1 - a4);
        if (v8) {
          Hasher._combine(_:)(v8);
        }
        return;
      }

      __break(1u);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

Swift::Int protocol witness for Hashable.hashValue.getter in conformance KeyPathComponent()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance KeyPathComponent()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance KeyPathComponent()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance KeyPathComponent( __int128 *a1, __int128 *a2)
{
  specialized static KeyPathComponent.== infix(_:_:)(v5);
  return v3 & 1;
}

void ClassHolder.__deallocating_deinit()
{
}

void MutatingWritebackBuffer.__deallocating_deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)v1 + 88LL);
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1895F8858](a1);
  __int16 v5 = (char *)&v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __int16 v6 = *(void (**)(char *, void, void, void))(v1 + 32);
  uint64_t v8 = v1 + *(void *)(v7 + 136);
  (*(void (**)(char *, uint64_t, uint64_t))(v3 + 16))(v5, v8, v2);
  v6(v5, *(void *)(v1 + 24), *(void *)(v1 + 40), *(void *)(v1 + 48));
  uint64_t v9 = *(void (**)(char *, uint64_t))(v3 + 8);
  v9(v5, v2);
  swift_unknownObjectRelease(*(id *)(v1 + 16));
  v9((char *)v8, v2);
  swift_deallocClassInstance(v1);
}

void NonmutatingWritebackBuffer.__deallocating_deinit(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *((void *)*v1 + 11);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  __int16 v6 = (char *)&v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void (**)(char *, char *, void, void))((char *)v1 + v2[14]);
  uint64_t v8 = (char *)v1 + v2[17];
  (*(void (**)(char *, char *, uint64_t))(v4 + 16))(v6, v8, v3);
  uint64_t v9 = (char *)v1 + *((void *)*v1 + 13);
  v7(v6, v9, *(id *)((char *)v1 + *((void *)*v1 + 15)), *(id *)((char *)v1 + *((void *)*v1 + 16)));
  uint64_t v10 = *(void (**)(char *, uint64_t))(v4 + 8);
  v10(v6, v3);
  swift_unknownObjectRelease(v1[2]);
  (*(void (**)(char *))(*(void *)(v2[10] - 8LL) + 8LL))(v9);
  v10(v8, v3);
  swift_deallocClassInstance((uint64_t)v1);
}

uint64_t static UInt32.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

uint64_t RawKeyPathComponent.Header.patternComponentBodySize.getter(unsigned int a1)
{
  switch(HIBYTE(a1) & 0x7F)
  {
    case 0:
      uint64_t result = 4 * (a1 & 0xFFFFFF) + 4;
      break;
    case 1:
    case 3:
      if ((~a1 & 0x7FFFFE) != 0) {
        uint64_t result = 4LL * ((a1 & 0x7FFFFF) == 8388605);
      }
      else {
        uint64_t result = 4LL;
      }
      break;
    case 2:
      uint64_t v2 = 12LL;
      if ((a1 & 0x400000) == 0) {
        uint64_t v2 = 8LL;
      }
      if ((a1 & 0x80000) != 0) {
        uint64_t result = v2 + 12;
      }
      else {
        uint64_t result = v2;
      }
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t RawKeyPathComponent.Header.propertyDescriptorBodySize.getter(unsigned int a1)
{
  if (!a1) {
    return 0LL;
  }
  switch(HIBYTE(a1) & 0x7F)
  {
    case 0:
      uint64_t result = 4 * (a1 & 0xFFFFFF) + 4;
      break;
    case 1:
    case 3:
      if ((~a1 & 0x7FFFFE) != 0) {
        uint64_t result = 4LL * ((a1 & 0x7FFFFF) == 8388605);
      }
      else {
        uint64_t result = 4LL;
      }
      break;
    case 2:
      if ((a1 & 0x400000) != 0) {
        uint64_t result = 12LL;
      }
      else {
        uint64_t result = 8LL;
      }
      break;
    default:
      return 0LL;
  }

  return result;
}

uint64_t RawKeyPathComponent.bodySize.getter(unsigned int a1, uint64_t a2)
{
  int v3 = HIBYTE(a1) & 0x7F;
  if (v3 == 1) {
    return 4LL * ((~a1 & 0x7FFFFF) == 0);
  }
  if (v3 != 2)
  {
    if (v3 == 3) {
      return 4LL * ((~a1 & 0x7FFFFF) == 0);
    }
    return 0LL;
  }

  if ((a1 & 0x400000) != 0) {
    uint64_t result = 28LL;
  }
  else {
    uint64_t result = 20LL;
  }
  if ((a1 & 0x80000) != 0)
  {
    uint64_t v5 = result + 16;
    uint64_t v6 = RawKeyPathComponent._computedArgumentSize.getter(a1, a2);
    BOOL v7 = __OFADD__(v5, v6);
    uint64_t result = v5 + v6;
    if (v7)
    {
      __break(1u);
      return result;
    }

    if ((a1 & 0x10) != 0)
    {
      BOOL v7 = __OFADD__(result, 8LL);
      result += 8LL;
      if (v7)
      {
        __break(1u);
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t RawKeyPathComponent._computedArgumentSize.getter(int a1, uint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  uint64_t v2 = 24LL;
  if ((a1 & 0x400000) == 0) {
    uint64_t v2 = 16LL;
  }
  uint64_t v3 = a2 + v2 + 4;
  if ((v3 & 7) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  return *(void *)v3;
}

uint64_t specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer.load with negative offset",  48LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x55DuLL,  0);
  }
  uint64_t v3 = a1 + 4;
  if (__OFADD__(a1, 4LL))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }

  if (!a2)
  {
    if (v3 < 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x560uLL,  0);
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer.load out of bounds",  41LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x55EuLL,  0);
  }

  if (a3 - a2 < v3) {
    goto LABEL_12;
  }
  if (((a2 + a1) & 3) != 0) {
    goto LABEL_9;
  }
  return *(unsigned int *)(a2 + a1);
}

{
  uint64_t v3;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer.load with negative offset",  48LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x55DuLL,  0);
  }
  uint64_t v3 = a1 + 8;
  if (__OFADD__(a1, 8LL))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }

  if (!a2)
  {
    if (v3 < 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x560uLL,  0);
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer.load out of bounds",  41LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x55EuLL,  0);
  }

  if (a3 - a2 < v3) {
    goto LABEL_12;
  }
  if (((a2 + a1) & 7) != 0) {
    goto LABEL_9;
  }
  return *(void *)(a2 + a1);
}

uint64_t UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer.load with negative offset",  48LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x55DuLL,  0);
  }
  uint64_t v5 = *(void *)(a4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  BOOL v7 = __OFADD__(a1, v6);
  uint64_t v8 = a1 + v6;
  if (v7)
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }

  if (!a2)
  {
    if (v8 < 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x560uLL,  0);
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer.load out of bounds",  41LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x55EuLL,  0);
  }

  if (a3 - a2 < v8) {
    goto LABEL_12;
  }
  return (*(uint64_t (**)(uint64_t))(v5 + 16))(a5);
}

uint64_t RawKeyPathComponent._computedArgumentHeaderPointer.getter(int a1, uint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  uint64_t v2 = 24LL;
  if ((a1 & 0x400000) == 0) {
    uint64_t v2 = 16LL;
  }
  return a2 + v2 + 4;
}

uint64_t RawKeyPathComponent._computedArguments.getter(int a1, uint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  uint64_t v2 = 24LL;
  if ((a1 & 0x400000) != 0) {
    uint64_t v3 = 24LL;
  }
  else {
    uint64_t v3 = 16LL;
  }
  uint64_t v4 = a2 + v3;
  if ((a1 & 0x10) == 0) {
    uint64_t v2 = 16LL;
  }
  return v4 + v2 + 4;
}

Swift::Void __swiftcall RawKeyPathComponent.clone(into:endOfReferencePrefix:)( Swift::UnsafeMutableRawBufferPointer *into, Swift::Bool endOfReferencePrefix)
{
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  unsigned int v7 = v2;
  if (endOfReferencePrefix) {
    unsigned int v9 = 0x80000000;
  }
  else {
    unsigned int v9 = 0;
  }
  rawValue = (char *)into->_position.value._rawValue;
  uint64_t v11 = into->_end.value._rawValue;
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes( v9 & 0x80000000 | v2 & 0x7FFFFFFF,  0LL,  (uint64_t)into->_position.value._rawValue,  (uint64_t)v11);
  int v12 = HIBYTE(v7) & 0x7F;
  if (v12 == 1)
  {
LABEL_7:
    if ((~v7 & 0x7FFFFF) == 0)
    {
      uint64_t v13 = specialized UnsafeRawBufferPointer.load<A>(fromByteOffset:as:)(0LL, v6, v5);
      specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v13, 4LL, (uint64_t)rawValue, (uint64_t)v11);
      uint64_t v14 = 8LL;
      goto LABEL_10;
    }

uint64_t specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes with negative offset",  61LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1BCuLL,  0);
  }
  uint64_t v4 = a2 + 8;
  if (__OFADD__(a2, 8LL)) {
    __break(1u);
  }
  if (!a3)
  {
    if (v4 < 1) {
      goto LABEL_5;
    }
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes out of bounds",  54LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1BDuLL,  0);
  }

  if (a4 - a3 < v4) {
    goto LABEL_7;
  }
LABEL_5:
  *(void *)(a3 + a2) = result;
  return result;
}

{
  uint64_t v4;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes with negative offset",  61LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1BCuLL,  0);
  }
  uint64_t v4 = a2 + 4;
  if (__OFADD__(a2, 4LL)) {
    __break(1u);
  }
  if (!a3)
  {
    if (v4 < 1) {
      goto LABEL_5;
    }
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes out of bounds",  54LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1BDuLL,  0);
  }

  if (a4 - a3 < v4) {
    goto LABEL_7;
  }
LABEL_5:
  *(_DWORD *)(a3 + a2) = result;
  return result;
}

{
  uint64_t v4;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes with negative offset",  61LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1BCuLL,  0);
  }
  uint64_t v4 = a2 + 8;
  if (!__OFADD__(a2, 8LL))
  {
    if (a3)
    {
      if (a4 - a3 >= v4)
      {
LABEL_5:
        *(void *)(a3 + a2) = result;
        return result;
      }
    }

    else if (v4 < 1)
    {
      goto LABEL_5;
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer.storeBytes out of bounds",  54LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x1BDuLL,  0);
  }

  __break(1u);
  return result;
}

uint64_t specialized _pop<A>(from:as:count:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (!*a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v3 = a1[1] - v2;
  BOOL v4 = __OFSUB__(v3, a2);
  uint64_t v5 = v3 - a2;
  if (v4)
  {
    __break(1u);
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v5 < 0) {
    goto LABEL_8;
  }
  *a1 = v2 + a2;
  a1[1] = v2 + a2 + v5;
  return v2;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result = _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZypXp_Tgm5(*a1, a1[1]);
  if ((unint64_t)(a2 - 0x1000000000000000LL) >> 61 != 7)
  {
    __break(1u);
    goto LABEL_8;
  }

  if (!result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  if (a2 < 0) {
LABEL_8:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  uint64_t v6 = v5 - result - 8 * a2;
  if (__OFSUB__(v5 - result, 8 * a2))
  {
    __break(1u);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v6 < 0) {
    goto LABEL_10;
  }
  unsigned int v7 = result + 8 * a2;
  *a1 = v7;
  a1[1] = v7 + v6;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result = _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(*a1, a1[1]);
  if ((unint64_t)(a2 - 0x2000000000000000LL) >> 62 != 3)
  {
    __break(1u);
    goto LABEL_8;
  }

  if (!result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  if (a2 < 0) {
LABEL_8:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  uint64_t v6 = v5 - result - 4 * a2;
  if (__OFSUB__(v5 - result, 4 * a2))
  {
    __break(1u);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v6 < 0) {
    goto LABEL_10;
  }
  unsigned int v7 = result + 4 * a2;
  *a1 = v7;
  a1[1] = v7 + v6;
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result = _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs5Int32V_Tgm5Tm(*a1, a1[1]);
  if ((unint64_t)(a2 - 0x2000000000000000LL) >> 62 != 3)
  {
    __break(1u);
    goto LABEL_8;
  }

  if (!result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  if (a2 < 0) {
LABEL_8:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  uint64_t v6 = v5 - result - 4 * a2;
  if (__OFSUB__(v5 - result, 4 * a2))
  {
    __break(1u);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v6 < 0) {
    goto LABEL_10;
  }
  unsigned int v7 = result + 4 * a2;
  *a1 = v7;
  a1[1] = v7 + v6;
  return result;
}

uint64_t _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZypXp_Tgm5(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if ((result & 7) == 0) {
    return result;
  }
  uint64_t v3 = -(int)result & 7LL;
  result += v3;
  if (__OFADD__(v2, v3))
  {
    __break(1u);
LABEL_13:
    __break(1u);
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v2) {
    uint64_t v4 = a2 - v2;
  }
  else {
    uint64_t v4 = 0LL;
  }
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5) {
    goto LABEL_13;
  }
  if (v6 < 0) {
    goto LABEL_14;
  }
  if (v6)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  return result;
}

uint64_t _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5( uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  if ((result & 3) == 0) {
    return result;
  }
  uint64_t v3 = -(int)result & 3LL;
  result += v3;
  if (__OFADD__(v2, v3))
  {
    __break(1u);
    goto LABEL_11;
  }

  uint64_t v4 = a2 - v2;
  BOOL v5 = __OFSUB__(v4, v3);
  uint64_t v6 = v4 - v3;
  if (v5)
  {
LABEL_11:
    __break(1u);
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v6 < 0) {
    goto LABEL_12;
  }
  if (v6)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  return result;
}

uint64_t _ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs5Int32V_Tgm5Tm( uint64_t result, uint64_t a2)
{
  if (result && (result & 3) != 0)
  {
    uint64_t v2 = -(int)result & 3LL;
    if (__OFADD__(result, v2))
    {
      __break(1u);
    }

    else
    {
      BOOL v3 = __OFSUB__(a2 - result, v2);
      uint64_t v4 = a2 - result - v2;
      if (!v3) {
        return specialized UnsafeRawBufferPointer.init<A>(_:)(result + v2, v4);
      }
    }

    __break(1u);
  }

  return result;
}

Swift::UnsafeMutableRawBufferPointer __swiftcall UnsafeMutableRawBufferPointer.init(mutating:)( Swift::UnsafeMutableRawBufferPointer mutating)
{
  if (!mutating._position.value._rawValue) {
    mutating._end.value._rawValue = 0LL;
  }
  return mutating;
}

Swift::UnsafeMutableRawBufferPointer __swiftcall KeyPathBuffer.Builder.pushRaw(size:alignment:)( Swift::Int size, Swift::Int alignment)
{
  unint64_t v3 = *v2;
  if (!*v2) {
LABEL_17:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  if (__OFSUB__(alignment, 1LL))
  {
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  Swift::Int v4 = v3 & (alignment - 1);
  if (v4)
  {
    Swift::Int v5 = alignment - v4;
    if (__OFSUB__(alignment, v4))
    {
LABEL_16:
      __break(1u);
      goto LABEL_17;
    }

    uint64_t v6 = (char *)(v3 + v5);
    if (size < 0) {
LABEL_12:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  else
  {
    Swift::Int v5 = 0LL;
    uint64_t v6 = (char *)*v2;
    if (size < 0) {
      goto LABEL_12;
    }
  }

  unint64_t v7 = v2[1] - v3;
  BOOL v8 = __OFSUB__(v7, size);
  unint64_t v9 = v7 - size;
  if (v8) {
    goto LABEL_14;
  }
  BOOL v8 = __OFSUB__(v9, v5);
  unint64_t v10 = v9 - v5;
  if (v8)
  {
LABEL_15:
    __break(1u);
    goto LABEL_16;
  }

  if ((v10 & 0x8000000000000000LL) != 0) {
    goto LABEL_12;
  }
  uint64_t v11 = &v6[size];
  *uint64_t v2 = (unint64_t)&v6[size];
  v2[1] = (unint64_t)&v6[size + v10];
  int v12 = v6;
  result._end.value._rawValue = v11;
  result._position.value._rawValue = v12;
  return result;
}

Swift::UnsafeMutableRawPointer __swiftcall UnsafeMutableRawPointer.advanced(by:)(Swift::Int by)
{
  return (Swift::UnsafeMutableRawPointer)(v1 + by);
}

uint64_t swift_getAtPartialKeyPath@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(void *)a2;
  (*(void (**)(void))(*(void *)a2 + 120LL))();
  uint64_t v8 = v7;
  uint64_t v10 = type metadata accessor for KeyPath(0LL, *(void *)(v6 + 136), v7, v9);
  if (!swift_dynamicCastClass(a2, v10)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  a3[3] = v8;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(a3);
  return KeyPath._projectReadOnly(from:)(a1, v12, v13, (uint64_t)boxed_opaque_existential_0Tm);
}

uint64_t swift_getAtKeyPath@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return KeyPath._projectReadOnly(from:)(a1, a2, a3, a4);
}

double swift_getAtAnyKeyPath@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, swift *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (const char *)(*(uint64_t (**)(void))(*(void *)a2 + 120LL))();
  return openRoot #1 <A><A1>(_:) in _getAtAnyKeyPath<A>(root:keyPath:)(a1, a2, v9, a3, v8, a4);
}

double openRoot #1 <A><A1>(_:) in _getAtAnyKeyPath<A>(root:keyPath:)@<D0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, swift *a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v32 = a3;
  uint64_t v33 = a2;
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v10 = type metadata accessor for Optional(0LL, (uint64_t)a5, a3, (uint64_t)a4);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v31 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (uint64_t *)((char *)&v31 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v18 = *((void *)a5 - 1);
  MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v31 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t *, uint64_t, swift *))(v21 + 16))(v17, a1, a4);
  int v22 = swift_dynamicCast(v14, v17, a4, a5, 6uLL);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v18 + 56);
  if (v22)
  {
    v23(v14, 0LL, 1LL, a5);
    (*(void (**)(char *, char *, const char *))(v18 + 32))(v20, v14, a5);
    uint64_t v24 = v32;
    uint64_t v26 = type metadata accessor for KeyPath(0LL, (uint64_t)a5, v32, v25);
    if (!swift_dynamicCastClass(v33, v26)) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
    }
    *(void *)(a6 + 24) = v24;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm((void *)a6);
    KeyPath._projectReadOnly(from:)((uint64_t)v20, v28, v29, (uint64_t)boxed_opaque_existential_0Tm);
    (*(void (**)(char *, const char *))(v18 + 8))(v20, a5);
  }

  else
  {
    v23(v14, 1LL, 1LL, a5);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    double result = 0.0;
    *(_OWORD *)a6 = 0u;
    *(_OWORD *)(a6 + 16) = 0u;
  }

  return result;
}

char *_swift_modifyAtWritableKeyPath_impl(uint64_t a1, uint64_t a2)
{
  else {
    return (char *)WritableKeyPath._projectMutableAddress(from:)(a1);
  }
}

char *_swift_modifyAtReferenceWritableKeyPath_impl(uint64_t a1)
{
  return ReferenceWritableKeyPath._projectMutableAddress(from:)(a1);
}

void swift_setAtWritableKeyPath(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  else {
    uint64_t v6 = WritableKeyPath._projectMutableAddress(from:)(a1);
  }
  uint64_t v8 = v7;
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v5 + 176) - 8LL) + 40LL))(v6, a3);
  swift_unknownObjectRelease(v8);
}

void swift_setAtReferenceWritableKeyPath(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = ReferenceWritableKeyPath._projectMutableAddress(from:)(a1);
  uint64_t v7 = v6;
  (*(void (**)(char *, uint64_t))(*(void *)(*(void *)(v4 + 200) - 8LL) + 40LL))(v5, a3);
  swift_unknownObjectRelease(v7);
}

uint64_t _AppendKeyPath<>.appending(path:)(unint64_t *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v6 = v5;
  uint64_t v10 = v7;
  uint64_t v11 = type metadata accessor for KeyPath(0LL, v4, v6, v8);
  if (!swift_dynamicCastClass((uint64_t)v2, v11)
    || (uint64_t v13 = type metadata accessor for KeyPath(0LL, v6, v10, v12), !swift_dynamicCastClass((uint64_t)a1, v13))
    || (uint64_t v15 = type metadata accessor for KeyPath(0LL, v4, v10, v14),
        uint64_t v9 = _appendingKeyPaths<A, B, C, D>(root:leaf:)(v2, a1, v15),
        uint64_t v18 = v9,
        _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)&v18, (uint64_t)v2, (uint64_t)a1),
        uint64_t v16 = type metadata accessor for AnyKeyPath(),
        !swift_dynamicCastClass(v9, v16)))
  {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  return v9;
}

uint64_t _tryToAppendKeyPaths<A>(root:leaf:)(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(unint64_t *))(*a1 + 120))(a1);
  uint64_t v8 = v7;
  if (v7 == (*(uint64_t (**)(void))(*a2 + 120))()) {
    return open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)( a1,  a2,  a3,  v6,  v8,  v9);
  }
  else {
    return 0LL;
  }
}

uint64_t _AppendKeyPath.appending<A>(path:)(unint64_t *a1)
{
  uint64_t v2 = v1;
  unint64_t v4 = *v1;
  uint64_t v5 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v7 = v6;
  uint64_t v12 = v8;
  uint64_t v13 = type metadata accessor for PartialKeyPath(0LL, *(void *)(v4 + 136), v9, v10);
  return open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)( v2,  a1,  v13,  v5,  v7,  v12);
}

uint64_t _AppendKeyPath.appending<A, B, C>(path:)(unint64_t *a1)
{
  uint64_t v2 = v1;
  unint64_t v4 = *v1;
  unint64_t v5 = *a1;
  uint64_t v6 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v8 = v7;
  uint64_t v12 = v9;
  uint64_t v13 = type metadata accessor for KeyPath(0LL, *(void *)(v4 + 136), *(void *)(v5 + 152), v10);
  return open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)( v2,  a1,  v13,  v6,  v8,  v12);
}

{
  unint64_t *v1;
  unint64_t *v2;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v2 = v1;
  unint64_t v4 = *v1;
  unint64_t v5 = *a1;
  uint64_t v6 = (*(uint64_t (**)(void))(*v1 + 120))();
  uint64_t v8 = v7;
  uint64_t v12 = v9;
  uint64_t v13 = type metadata accessor for KeyPath(0LL, v6, v8, v10);
  if (!swift_dynamicCastClass((uint64_t)v2, v13)
    || (uint64_t v15 = type metadata accessor for KeyPath(0LL, v8, v12, v14), !swift_dynamicCastClass((uint64_t)a1, v15))
    || (uint64_t v17 = type metadata accessor for KeyPath(0LL, v6, v12, v16),
        uint64_t v11 = _appendingKeyPaths<A, B, C, D>(root:leaf:)(v2, a1, v17),
        uint64_t v21 = v11,
        _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)&v21, (uint64_t)v2, (uint64_t)a1),
        uint64_t v19 = type metadata accessor for ReferenceWritableKeyPath( 0LL,  *(void *)(v4 + 136),  *(void *)(v5 + 200),  v18),  !swift_dynamicCastClass(v11, v19)))
  {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  return v11;
}

uint64_t _AppendKeyPath.appending<A, B, C>(path:)(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for KeyPath(0LL, *(void *)(a2 + 144), *(void *)(*a1 + 152), a4);
  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, v6);
}

{
  unint64_t *v4;
  uint64_t v6;
  uint64_t v6 = type metadata accessor for ReferenceWritableKeyPath(0LL, *(void *)(*v4 + 144), *(void *)(*a1 + 200), a4);
  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, v6);
}

{
  unint64_t *v4;
  uint64_t v6;
  uint64_t v6 = type metadata accessor for WritableKeyPath(0LL, *(void *)(*v4 + 168), *(void *)(*a1 + 176), a4);
  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, v6);
}

{
  unint64_t *v4;
  uint64_t v6;
  uint64_t v6 = type metadata accessor for ReferenceWritableKeyPath(0LL, *(void *)(*v4 + 168), *(void *)(*a1 + 200), a4);
  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, v6);
}

{
  unint64_t *v4;
  uint64_t v6;
  uint64_t v6 = type metadata accessor for ReferenceWritableKeyPath(0LL, *(void *)(*v4 + 192), *(void *)(*a1 + 176), a4);
  return _appendingKeyPaths<A, B, C, D>(root:leaf:)(v4, a1, v6);
}

uint64_t _appendingKeyPaths<A, B, C, D>(root:leaf:)(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  char v7 = (*(uint64_t (**)(unint64_t *))(*a1 + 160))(a1);
  int v9 = (*(unsigned __int8 (**)(void))(v6 + 160))();
  if (!v9) {
    goto LABEL_6;
  }
  if (v9 != 1)
  {
LABEL_7:
    type metadata accessor for ReferenceWritableKeyPath(0LL, *(void *)(a3 + 144), *(void *)(a3 + 152), v8);
    goto LABEL_8;
  }

  if (!v7)
  {
LABEL_6:
    type metadata accessor for KeyPath(0LL, *(void *)(a3 + 144), *(void *)(a3 + 152), v8);
    goto LABEL_8;
  }

  if (v7 != 1) {
    goto LABEL_7;
  }
  type metadata accessor for WritableKeyPath(0LL, *(void *)(a3 + 144), *(void *)(a3 + 152), v8);
LABEL_8:
  uint64_t v10 = specialized KeyPathBuffer.init(base:)((uint64_t)(a1 + 3));
  uint64_t v12 = v11;
  v49[0] = v10;
  v49[1] = v11;
  char v50 = v13 & 1;
  char v51 = v14 & 1;
  uint64_t v15 = specialized KeyPathBuffer.init(base:)((uint64_t)(a2 + 3));
  if (v15)
  {
    uint64_t v17 = v16 - v15;
    if (v16 != v15)
    {
      if (!v10 || (uint64_t v22 = v12 - v10, v12 == v10))
      {
        if (swift_dynamicCastClass((uint64_t)a2, a3))
        {
          swift_retain(a2, v23, v24, v25);
          uint64_t v21 = a2;
          goto LABEL_44;
        }

LABEL_60:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
      }

      uint64_t v26 = a1[2];
      if (v26)
      {
        uint64_t v27 = -v26;
        if (__OFSUB__(0LL, v26))
        {
LABEL_50:
          __break(1u);
          goto LABEL_51;
        }

        BOOL v28 = __OFSUB__(v27, 1LL);
        uint64_t v29 = v27 - 1;
        if (v28)
        {
LABEL_51:
          __break(1u);
          goto LABEL_52;
        }

        if ((v29 & 0x8000000000000000LL) == 0) {
          goto LABEL_30;
        }
      }

      uint64_t v30 = a2[2];
      if (!v30) {
        goto LABEL_30;
      }
      uint64_t v31 = -v30;
      if (__OFSUB__(0LL, v30))
      {
        __break(1u);
      }

      else
      {
        uint64_t v32 = v31 - 1;
        if (!__OFSUB__(v31, 1LL))
        {
          size_t v33 = 0LL;
          if (!v26 || (v32 & 0x8000000000000000LL) == 0) {
            goto LABEL_31;
          }
          size_t v34 = _swift_stdlib_strlen((const char *)v26);
          size_t v35 = _swift_stdlib_strlen((const char *)v30);
          size_t v36 = v34 + 1;
          if (__OFADD__(v34, 1LL))
          {
LABEL_58:
            __break(1u);
            goto LABEL_59;
          }

          BOOL v28 = __OFADD__(v36, v35);
          size_t v37 = v36 + v35;
          if (v28)
          {
LABEL_59:
            __break(1u);
            goto LABEL_60;
          }

          BOOL v28 = __OFADD__(v37, 1LL);
          size_t v33 = v37 + 1;
          if (!v28)
          {
LABEL_31:
            if (__OFADD__(v22, 7LL))
            {
              __break(1u);
            }

            else
            {
              unint64_t v38 = (v22 + 7) & 0xFFFFFFFFFFFFFFF8LL;
              BOOL v28 = __OFADD__(v38, v17);
              uint64_t v39 = v38 + v17;
              if (!v28)
              {
                uint64_t v40 = v39 + 16;
                if (!__OFADD__(v39, 16LL))
                {
                  uint64_t v41 = v40 + v33;
                  if (!__OFADD__(v40, v33))
                  {
                    BOOL v28 = __OFADD__(v41, 3LL);
                    uint64_t v42 = v41 + 3;
                    if (!v28)
                    {
                      uint64_t v43 = MEMORY[0x1895F8858](v42 & 0xFFFFFFFFFFFFFFFCLL);
                      uint64_t v21 = static AnyKeyPath._create(capacityInBytes:initializedBy:)( v43,  (void (*)(void *, char *))partial apply for closure #1 in closure #1 in closure #1 in _appendingKeyPaths<A, B, C, D>(root:leaf:));
                      unint64_t v44 = a1[2];
                      if (!v44) {
                        goto LABEL_40;
                      }
                      uint64_t v45 = -(uint64_t)v44;
                      if (!__OFSUB__(0LL, v44))
                      {
                        BOOL v28 = __OFSUB__(v45, 1LL);
                        uint64_t v46 = v45 - 1;
                        if (!v28)
                        {
                          if ((v46 & 0x8000000000000000LL) == 0) {
                            goto LABEL_43;
                          }
LABEL_40:
                          unint64_t v47 = a2[2];
                          if (!v47) {
                            goto LABEL_43;
                          }
                          if (!__OFSUB__(0LL, v47))
                          {
                            if (!__OFSUB__(-(uint64_t)v47, 1LL))
                            {
LABEL_43:
                              goto LABEL_60;
                            }

                            goto LABEL_57;
                          }

      if (!v39)
      {
LABEL_74:
        char v14 = 0;
        uint64_t v56 = v20;
        uint64_t v57 = 0;
        goto LABEL_11;
      }

      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v13))
      {
        uint64_t v43 = (int64_t)&v38->isa + 1;
LABEL_64:
        char v13 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v43,  1,  (uint64_t)v13);
      }

  *a1 = rawBits;
  a1[1] = a5;
  a1[2] = v8;
  a1[3] = v7;
  a1[4] = v22._rawBits;
  return v13;
}

  *size_t v52 = v51;
  return result;
}

  *char v51 = v52;
  return result;
}

  *size_t v35 = v45;
  return result;
}

                uint64_t v26 = 0LL;
                ++v25;
                break;
              case 2:
                uint64_t v31 = 2LL;
LABEL_56:
                if (v31 > v25) {
                  goto LABEL_57;
                }
                goto LABEL_60;
              default:
                uint64_t v26 = 0LL;
                ++v25;
                break;
            }
          }

          else
          {
LABEL_40:
            ++v25;
          }
        }

        if (!v26)
        {
LABEL_68:
          uint64_t v12 = 0LL;
          goto LABEL_69;
        }

        std::string::append(&v118, *(const std::string::value_type **)v26, *(void *)(v26 + 8));
        std::string::append(&v118, "(");
        size_t v33 = swift::Demangle::__runtime::Node::findByKind(v20, 290LL, 1);
        if (!v33) {
          goto LABEL_118;
        }
        size_t v34 = v33;
        size_t v35 = *(unsigned __int8 *)(v33 + 18);
        if (v35 - 1 < 2 || v35 == 5 && *(_DWORD *)(v33 + 8))
        {
          for (j = 0LL; ; ++j)
          {
            uint64_t v41 = v35;
            if (v35 == 1) {
              goto LABEL_87;
            }
            if (v35 != 5) {
              break;
            }
LABEL_88:
            if (v35 == 1)
            {
              if (j) {
                goto LABEL_81;
              }
            }

            else if (v35 == 5)
            {
            }

            else if (v35 != 2 || j >= 2)
            {
              goto LABEL_81;
            }

            uint64_t v42 = v34;
            if (v35 - 1 >= 2) {
              uint64_t v42 = *(void *)v34;
            }
            uint64_t v43 = *(void *)(v42 + 8 * j);
            if (v43)
            {
              unint64_t v44 = *(unsigned __int16 *)(v43 + 16);
              if (v44 == 275)
              {
                uint64_t v40 = "_:";
LABEL_80:
                std::string::append(&v118, v40);
                goto LABEL_81;
              }

              if (v44 == 101)
              {
                std::string::append(&v118, *(const std::string::value_type **)v43, *(void *)(v43 + 8));
                uint64_t v40 = ":";
                goto LABEL_80;
              }
            }

                uint64_t v8 = (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v11,  (swift::Demangle::__runtime::Node *)v27,  (swift::Demangle::__runtime::Node *)v18,  (char *)v32);
                if (!v20) {
                  return (unint64_t)v8;
                }
                goto LABEL_65;
              }

uint64_t _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (!v3) {
    return result;
  }
  BOOL v4 = __OFSUB__(0LL, v3);
  uint64_t v5 = -v3;
  if (v4)
  {
    __break(1u);
    goto LABEL_14;
  }

  BOOL v4 = __OFSUB__(v5, 1LL);
  uint64_t v6 = v5 - 1;
  if (v4)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  if ((v6 & 0x8000000000000000LL) == 0)
  {
    uint64_t v7 = *(void *)(a3 + 16);
    if (v7)
    {
      BOOL v4 = __OFSUB__(0LL, v7);
      uint64_t v8 = -v7;
      if (!v4)
      {
        BOOL v4 = __OFSUB__(v8, 1LL);
        uint64_t v9 = v8 - 1;
        if (!v4)
        {
          if (v9 < 0) {
            return result;
          }
          BOOL v4 = __OFADD__(v6, v9);
          uint64_t v10 = v6 + v9;
          if (!v4)
          {
            if ((v10 & 0x8000000000000000LL) == 0) {
              *(void *)(*(void *)result + 16LL) = ~v10;
            }
            return result;
          }

uint64_t open3 #1 <A><A1><A2><A3>(_:) in open2 #1 <A><A1><A2>(_:) in open #1 <A><A1>(_:) in _tryToAppendKeyPaths<A>(root:leaf:)( unint64_t *a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = type metadata accessor for KeyPath(0LL, a4, a5, a4);
  if (!swift_dynamicCastClass((uint64_t)a1, v12)
    || (uint64_t v14 = type metadata accessor for KeyPath(0LL, a5, a6, v13), !swift_dynamicCastClass((uint64_t)a2, v14))
    || (uint64_t v16 = type metadata accessor for KeyPath(0LL, a4, a6, v15),
        uint64_t v17 = _appendingKeyPaths<A, B, C, D>(root:leaf:)(a1, a2, v16),
        uint64_t v19 = v17,
        _processOffsetForAppendedKeyPath(appendedKeyPath:root:leaf:)((uint64_t)&v19, (uint64_t)a1, (uint64_t)a2),
        !swift_dynamicCastClass(v17, a3)))
  {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  return v17;
}

Swift::UnsafeRawPointer __swiftcall _swift_getKeyPath(pattern:arguments:)( Swift::UnsafeMutableRawPointer pattern, Swift::UnsafeRawPointer arguments)
{
  if ((*((_BYTE *)pattern._rawValue + 23) & 0x3F) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Reserved bits set to an unexpected bit pattern",  46LL,  2,  "Swift/KeyPath.swift",  19LL,  2,  0x7B5uLL,  0);
  }
  uint64_t v5 = *(int *)pattern._rawValue;
  if ((_DWORD)v5)
  {
    uint64_t v6 = (unint64_t **)((char *)pattern._rawValue + v5);
    if ((v6 & 7) != 0)
    {
      unint64_t v22 = 440LL;
LABEL_24:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  v22,  0);
    }

    uint64_t v7 = *v6;
    if (*v6)
    {
      swift_retain(*v6, (uint64_t)arguments._rawValue, v2, v3);
      return (Swift::UnsafeRawPointer)v7;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  _getKeyPathClassAndInstanceSizeFromPattern(_:_:)((uint64_t)pattern._rawValue + 4, (uint64_t)arguments._rawValue);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v10 = static AnyKeyPath._create(capacityInBytes:initializedBy:)( v9,  (void (*)(void *, char *))partial apply for closure #1 in _swift_getKeyPath(pattern:arguments:));
  uint64_t v14 = (int *)((char *)pattern._rawValue + 16);
  if ((((uint64_t)pattern._rawValue + 16) & 3) != 0)
  {
LABEL_23:
    unint64_t v22 = 1273LL;
    goto LABEL_24;
  }

  uint64_t v7 = v10;
  uint64_t v15 = *v14;
  if ((_DWORD)v15)
  {
    uint64_t v16 = (char *)v14 + v15;
    if (!v16) {
LABEL_13:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    v10[2] = (unint64_t)v16;
  }

  else
  {
    v10[2] = 0LL;
  }

  if (v6)
  {
    swift_retain(v10, v11, v12, v13);
    while (1)
    {
      uint64_t v20 = (unint64_t *)__ldaxr((unint64_t *)v6);
      if (v20) {
        break;
      }
    }

    __clrex();
    swift_retain(v20, v17, v18, v19);
    swift_release_n((uint64_t)v7, 2LL);
    return (Swift::UnsafeRawPointer)v20;
  }

  return (Swift::UnsafeRawPointer)v7;
}

uint64_t _getKeyPathClassAndInstanceSizeFromPattern(_:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 8LL;
  __int16 v8 = 1;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = a2;
  int v13 = 0;
  uint64_t v14 = &_swiftEmptyArrayStorage;
  specialized _walkKeyPathPattern<A>(_:walker:)(a1, &v7);
  if (HIBYTE(v8) == 1) {
    LOBYTE(v8) = 0;
  }
  if (!v9)
  {
    unint64_t v6 = 3425LL;
    goto LABEL_13;
  }

  if (!v10)
  {
    unint64_t v6 = 3423LL;
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/KeyPath.swift",  19LL,  2,  v6,  0);
  }

  if ((_BYTE)v8)
  {
    else {
      uint64_t v3 = type metadata accessor for ReferenceWritableKeyPath(0LL, v9, v10, v2);
    }
  }

  else
  {
    uint64_t v3 = type metadata accessor for KeyPath(0LL, v9, v10, v2);
  }

  uint64_t v4 = v3;
  swift_bridgeObjectRelease((uint64_t)v14);
  return v4;
}

unint64_t _instantiateKeyPathBuffer(_:_:_:_:)(uint64_t a1, _DWORD *a2, _BYTE *a3, void *a4, void *a5)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  unint64_t v6 = a3 - (_BYTE *)a2 - 8;
  if (__OFSUB__(a3 - (_BYTE *)a2, 8LL))
  {
    __break(1u);
LABEL_20:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if ((v6 & 0x8000000000000000LL) != 0) {
    goto LABEL_20;
  }
  v14[0].value._rawValue = a2 + 2;
  v14[1].value._rawValue = a3;
  v14[2].value._rawValue = 0LL;
  v14[3].value._rawValue = a5;
  v14[4].value._rawValue = a4;
  unsigned int v15 = 0;
  uint64_t v16 = &_swiftEmptyArrayStorage;
  char v17 = 1;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  specialized _walkKeyPathPattern<A>(_:walker:)(a1, v14);
  if (HIDWORD(v6)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  uint64_t v7 = v18;
  if (v17 != 1)
  {
    if (v18) {
      goto LABEL_7;
    }
LABEL_10:
    *a2 = v6;
    goto LABEL_11;
  }

  LODWORD(v6) = v6 | 0x80000000;
  if (!v18) {
    goto LABEL_10;
  }
LABEL_7:
  *a2 = v6 | 0x40000000;
  if ((v7 & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
  }
  *v7 |= 0x80000000;
LABEL_11:
  __int16 v8 = v16[2];
  if (v8)
  {
    uint64_t v9 = (char *)(v16 + 4);
    char v10 = 1;
    do
    {
      char v11 = *v9++;
      v10 &= v11;
      __int16 v8 = (__objc2_class *)((char *)v8 - 1);
    }

    while (v8);
  }

  else
  {
    char v10 = 1;
  }

  swift_bridgeObjectRelease((uint64_t)v16);
  uint64_t v12 = v15;
  LOBYTE(v14[0].value._rawValue) = (v10 & 1) == 0;
  if ((v10 & 1) == 0) {
    uint64_t v12 = 0LL;
  }
  return v12 | ((unint64_t)((v10 & 1) == 0) << 32);
}

BOOL static UInt8.<= infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a2 >= a1;
}

uint64_t _getTypeByMangledNameInEnvironmentOrContext(_:_:genericEnvironmentOrContext:genericArguments:)( unsigned __int8 *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((a3 & 1) != 0) {
    return swift_getTypeByMangledNameInContext(a1, a2, a3 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    return swift_getTypeByMangledNameInEnvironment(a1, a2, a3, a4);
  }
}

uint64_t _Pointer.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (a1)
  {
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(a3 + 56))(a4, a1, a2);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  return (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56LL))(a4, v6, 1LL, a2);
}

Swift::UnsafeRawPointer __swiftcall _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)( Swift::UnsafeRawPointer _, Swift::UnsafeRawPointer_optional genericEnvironment, Swift::UnsafeRawPointer_optional arguments)
{
  uint64_t v4 = (uint8x16_t *)((char *)_._rawValue - 1);
  unsigned int v3 = *((unsigned __int8 *)_._rawValue - 1);
  uint64_t v5 = (char *)_._rawValue - 1;
  if (!*((_BYTE *)_._rawValue - 1))
  {
LABEL_13:
    uint64_t v10 = v5 - (_BYTE *)v4;
    if (v5 - (_BYTE *)v4 == 0x7FFFFFFFFFFFFFFFLL)
    {
      __break(1u);
    }

    else if ((v10 & 0x8000000000000000LL) == 0)
    {
      _._rawValue = (Builtin::RawPointer)_getTypeByMangledNameInEnvironmentOrContext(_:_:genericEnvironmentOrContext:genericArguments:)( (unsigned __int8 *)_._rawValue - 1,  v5 - (_BYTE *)v4,  (uint64_t)genericEnvironment.value._rawValue,  (uint64_t)arguments.value._rawValue);
      if (_._rawValue) {
        return _;
      }
      int64_t v11 = validateUTF8(_:)(v4->i64, v10);
      if ((v13 & 1) != 0) {
        uint64_t v14 = repairUTF8(_:firstKnownBrokenRange:)(v4->i8, v10, v11, v12);
      }
      else {
        uint64_t v14 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v4, v10, v11 & 1);
      }
      unint64_t v16 = v14;
      unint64_t v17 = v15;
      unint64_t v18 = specialized static String._createEmpty(withInitialCapacity:)(41LL);
      uint64_t v20 = v19;
      unint64_t v44 = v18;
      unint64_t v45 = v19;
      uint64_t v21 = HIBYTE(v19) & 0xF;
      if ((v19 & 0x2000000000000000LL) == 0) {
        uint64_t v21 = v18 & 0xFFFFFFFFFFFFLL;
      }
      if (v21 || (v18 & ~v19 & 0x2000000000000000LL) != 0)
      {
        if ((v19 & 0x2000000000000000LL) == 0
          || (0x80000001818BB1E0LL & 0x2000000000000000LL) == 0
          || (unint64_t v27 = specialized _SmallString.init(_:appending:)( v18,  v19,  0xD000000000000026LL,  0x80000001818BB1E0LL | 0x8000000000000000LL),  (v29 & 1) != 0))
        {
          if ((0x80000001818BB1E0LL & 0x2000000000000000LL) != 0) {
            unint64_t v30 = (0x80000001818BB1E0LL >> 56) & 0xF;
          }
          else {
            unint64_t v30 = 38LL;
          }
          _StringGuts.append(_:)(0xD000000000000026LL, 0x80000001818BB1E0LL | 0x8000000000000000LL, 0LL, v30);
          swift_bridgeObjectRelease(0x80000001818BB1E0LL | 0x8000000000000000LL);
          unint64_t v22 = v44;
          unint64_t v26 = v45;
LABEL_36:
          uint64_t v31 = HIBYTE(v26) & 0xF;
          if ((v26 & 0x2000000000000000LL) == 0) {
            uint64_t v31 = v22 & 0xFFFFFFFFFFFFLL;
          }
          if (!v31 && (v22 & ~v26 & 0x2000000000000000LL) == 0)
          {
            swift_bridgeObjectRetain(v17, v23, v24, v25);
            swift_bridgeObjectRelease(v26);
            unint64_t v44 = v16;
            unint64_t v45 = v17;
            goto LABEL_51;
          }

          if ((v26 & 0x2000000000000000LL) != 0)
          {
            if ((v17 & 0x2000000000000000LL) != 0)
            {
              unint64_t v33 = specialized _SmallString.init(_:appending:)(v22, v26, v16, v17);
              if ((v35 & 1) == 0)
              {
                unint64_t v36 = v33;
                unint64_t v37 = v34;
                swift_bridgeObjectRelease(v26);
                unint64_t v44 = v36;
                unint64_t v45 = v37;
                unint64_t v17 = v37;
                unint64_t v16 = v36;
                goto LABEL_51;
              }

              goto LABEL_49;
            }
          }

          else if ((v17 & 0x2000000000000000LL) != 0)
          {
LABEL_49:
            uint64_t v32 = HIBYTE(v17) & 0xF;
            goto LABEL_50;
          }

          uint64_t v32 = v16 & 0xFFFFFFFFFFFFLL;
LABEL_50:
          _StringGuts.append(_:)(v16, v17, 0LL, v32);
          unint64_t v16 = v44;
          unint64_t v17 = v45;
LABEL_51:
          uint64_t v38 = HIBYTE(v17) & 0xF;
          if ((v17 & 0x2000000000000000LL) == 0) {
            uint64_t v38 = v16 & 0xFFFFFFFFFFFFLL;
          }
          if (v38 || (v16 & ~v17 & 0x2000000000000000LL) != 0)
          {
            if ((v17 & 0x2000000000000000LL) == 0
              || (unint64_t v41 = specialized _SmallString.init(_:appending:)(v16, v17, 0x27uLL, 0xE100000000000000LL),
                  (v43 & 1) != 0))
            {
              _StringGuts.append(_:)(39LL, 0xE100000000000000LL, 0LL, 1LL);
              swift_bridgeObjectRelease(0xE100000000000000LL);
              uint64_t v40 = v44;
              unint64_t v39 = v45;
            }

            else
            {
              uint64_t v40 = v41;
              unint64_t v39 = v42;
              swift_bridgeObjectRelease(v17);
              swift_bridgeObjectRelease(0xE100000000000000LL);
            }
          }

          else
          {
            swift_bridgeObjectRelease(v17);
            unint64_t v39 = 0xE100000000000000LL;
            uint64_t v40 = 39LL;
          }

          _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)v40,  v39,  "Swift/KeyPath.swift",  19LL,  2,  0xB16uLL,  0);
        }

        unint64_t v22 = v27;
        unint64_t v26 = v28;
        swift_bridgeObjectRelease(v20);
        swift_bridgeObjectRelease(0x80000001818BB1E0LL | 0x8000000000000000LL);
      }

      else
      {
        unint64_t v22 = 0xD000000000000026LL;
        swift_bridgeObjectRelease(v19);
        unint64_t v26 = 0x80000001818BB1E0LL | 0x8000000000000000LL;
      }

      unint64_t v44 = v22;
      unint64_t v45 = v26;
      goto LABEL_36;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  if (v3 != 255)
  {
    uint64_t v5 = (char *)_._rawValue - 1;
    do
    {
LABEL_8:
      uint64_t v7 = 9LL;
      if (v3 > 0x1F) {
        uint64_t v7 = 1LL;
      }
      BOOL v8 = v3 > 0x17;
      uint64_t v9 = 5LL;
      if (v8) {
        uint64_t v9 = v7;
      }
      v5 += v9;
      unsigned int v3 = *v5;
    }

    while (*v5);
    goto LABEL_13;
  }

  uint64_t v5 = (char *)_._rawValue - 1;
  if (*(_BYTE *)_._rawValue != 9) {
    goto LABEL_8;
  }
  uint64_t v6 = (uint64_t (*)(Builtin::RawPointer))((char *)_._rawValue + *(int *)((char *)_._rawValue + 1) + 1);
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  return (Swift::UnsafeRawPointer)v6(arguments.value._rawValue);
}

uint64_t UnsafeRawPointer.bindMemory<A>(to:capacity:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

Swift::UnsafeRawPointer __swiftcall _resolveRelativeIndirectableAddress(_:_:)( Swift::UnsafeRawPointer a1, Swift::Int32 a2)
{
  if ((a2 & 1) != 0)
  {
    if (__OFSUB__(a2, 1))
    {
      __break(1u);
    }

    else
    {
      unsigned int v3 = (Swift::UnsafeRawPointer *)((char *)a1._rawValue + a2 - 1);
      if (!v3) {
        goto LABEL_11;
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }

  result._rawValue = (char *)a1._rawValue + a2;
  if (!result._rawValue) {
LABEL_11:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  return result;
}

uint64_t static Int32.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

uint64_t static Int32.- infix(_:_:)(int a1, int a2)
{
  BOOL v2 = __OFSUB__(a1, a2);
  uint64_t result = (a1 - a2);
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(uint64_t a1, uint64_t a2)
{
  if (((a1 + a2) & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  }
  uint64_t result = *(int *)(a1 + a2) + a1 + a2;
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  return result;
}

Swift::UnsafeRawPointer specialized _walkKeyPathPattern<A>(_:walker:)(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 0LL);
  uint64_t v5 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 4LL);
  uint64_t v6 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 8LL);
  specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 12LL);
  a2[4] = v4;
  v7.value._Builtin::RawPointer rawValue = (Builtin::RawPointer)a2[5];
  *((Swift::UnsafeRawPointer *)a2 + 2) = _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)( (Swift::UnsafeRawPointer)v5,  (Swift::UnsafeRawPointer_optional)v4,  v7);
  result._Builtin::RawPointer rawValue = _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)( (Swift::UnsafeRawPointer)v6,  (Swift::UnsafeRawPointer_optional)v4,  v7)._rawValue;
  a2[3] = (uint64_t)result._rawValue;
  if ((((_BYTE)a1 + 16) & 3) != 0) {
    goto LABEL_74;
  }
  uint64_t v9 = a1 + 20;
  uint64_t v10 = a1 + 20 + (*(_DWORD *)(a1 + 16) & 0xFFFFFF);
  uint64_t v53 = a1 + 20;
  uint64_t v54 = v10;
  while (v54 != v9)
  {
    result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized _pop<A>(from:as:count:)(&v53, 1LL);
    if (!result._rawValue) {
      goto LABEL_85;
    }
    int v11 = *(_DWORD *)result._rawValue;
    int v12 = HIBYTE(*(_DWORD *)result._rawValue) & 0x7F;
    uint64_t v13 = *(_DWORD *)result._rawValue & 0xFFFFFF;
    if (v12)
    {
      if ((v11 & 0x7D000000) != 0x1000000)
      {
        if (v12 == 2)
        {
          popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( *(_DWORD *)result._rawValue,  &v53);
          uint64_t v21 = v20;
          result._Builtin::RawPointer rawValue = (Builtin::RawPointer)popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( v11,  &v53);
          if (v21)
          {
            if ((v11 & 0x800000) == 0)
            {
              char v22 = 2;
              goto LABEL_37;
            }
          }

          else
          {
            char v22 = 0;
LABEL_37:
            *((_BYTE *)a2 + 8) = v22;
          }

          uint64_t v41 = *a2 + 4;
          if (__OFADD__(*a2, 4LL)) {
            goto LABEL_76;
          }
          *a2 = v41;
          BOOL v23 = __OFADD__(v41, 7LL);
          uint64_t v42 = v41 + 7;
          if (v23) {
            goto LABEL_77;
          }
          unint64_t v43 = v42 & 0xFFFFFFFFFFFFFFF8LL;
          BOOL v23 = __OFADD__(v43, 16LL);
          uint64_t v44 = v43 + 16;
          if (v23) {
            goto LABEL_78;
          }
          *a2 = v44;
          if (v21)
          {
            BOOL v23 = __OFADD__(v44, 8LL);
            v44 += 8LL;
            if (v23) {
              goto LABEL_79;
            }
            *a2 = v44;
          }

          if (result._rawValue)
          {
            uint64_t v45 = v44 + 16;
            if (__OFADD__(v44, 16LL)) {
              goto LABEL_80;
            }
            result._Builtin::RawPointer rawValue = (Builtin::RawPointer)((uint64_t (*)(uint64_t))result._rawValue)(a2[5]);
            char v35 = (char *)result._rawValue + v45;
            if (__OFADD__(v45, result._rawValue)) {
              goto LABEL_81;
            }
LABEL_53:
            *a2 = (uint64_t)v35;
          }

          uint64_t v34 = v53;
          if (!v53) {
            return result;
          }
          goto LABEL_55;
        }

        if ((_DWORD)v13)
        {
          if ((_DWORD)v13 == 1)
          {
            *((_WORD *)a2 + 4) = 256;
            char v35 = (char *)(*a2 + 4);
            if (__OFADD__(*a2, 4LL)) {
              goto LABEL_82;
            }
          }

          else
          {
            char v35 = (char *)(*a2 + 4);
            if (__OFADD__(*a2, 4LL)) {
              goto LABEL_84;
            }
          }
        }

        else
        {
          *((_WORD *)a2 + 4) = 256;
          char v35 = (char *)(*a2 + 4);
          if (__OFADD__(*a2, 4LL)) {
            goto LABEL_83;
          }
        }

        goto LABEL_53;
      }

      uint64_t v14 = &v53;
      uint64_t v15 = *(unsigned int *)result._rawValue;
    }

    else
    {
      uint64_t v16 = v53;
      if (!v53) {
        goto LABEL_85;
      }
      unint64_t v17 = (int *)specialized _pop<A>(from:as:count:)(&v53, 1LL);
      if (!v17) {
        goto LABEL_85;
      }
      uint64_t v18 = *v17;
      if ((v18 & 1) != 0)
      {
        BOOL v23 = __OFSUB__((_DWORD)v18, 1);
        int v24 = v18 - 1;
        if (v23)
        {
          __break(1u);
LABEL_76:
          __break(1u);
LABEL_77:
          __break(1u);
LABEL_78:
          __break(1u);
LABEL_79:
          __break(1u);
LABEL_80:
          __break(1u);
LABEL_81:
          __break(1u);
LABEL_82:
          __break(1u);
LABEL_83:
          __break(1u);
LABEL_84:
          __break(1u);
LABEL_85:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }

        uint64_t v25 = (unsigned int **)(v16 + v24);
        if (!v25) {
          goto LABEL_85;
        }
        unint64_t v19 = *v25;
      }

      else
      {
        unint64_t v19 = (unsigned int *)(v16 + v18);
        if (!(v16 + v18)) {
          goto LABEL_85;
        }
      }

      uint64_t v26 = *v19;
      result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized _pop<A>(from:as:count:)(&v53, v13);
      if (!(_DWORD)v26) {
        goto LABEL_61;
      }
      Builtin::RawPointer rawValue = result._rawValue;
      uint64_t v29 = v27;
      unint64_t v30 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v53, 1LL);
      if (!v30) {
        goto LABEL_85;
      }
      unsigned int v31 = *v30;
      uint64_t v32 = RawKeyPathComponent.Header.patternComponentBodySize.getter(*v30);
      uint64_t v33 = RawKeyPathComponent.Header.propertyDescriptorBodySize.getter(v26);
      v52[0] = (uint64_t)(v19 + 1);
      v52[1] = (uint64_t)v19 + v33 + 4;
      if ((BYTE3(v26) & 0x7D | 2) != 3)
      {
        popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v26, v52);
        uint64_t v37 = v36;
        if ((HIBYTE(v31) & 0x7F) == 2 && (v31 & 0x80000) != 0)
        {
          popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v31, &v53);
          uint64_t v38 = (uint64_t (*)(void))popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( v31,  &v53);
          uint64_t v39 = v48;
          uint64_t v40 = v49;
        }

        else
        {
          specialized _pop<A>(from:as:count:)(&v53, v32);
          uint64_t v38 = 0LL;
          uint64_t v39 = 0LL;
          uint64_t v40 = 0LL;
        }

        if ((_DWORD)v13) {
          uint64_t v50 = (uint64_t)rawValue;
        }
        else {
          uint64_t v50 = 0LL;
        }
        if ((_DWORD)v13) {
          uint64_t v51 = v29;
        }
        else {
          uint64_t v51 = 0LL;
        }
        result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized GetKeyPathClassAndInstanceSizeFromPattern.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)( (v26 >> 23) & 1,  v37,  v38,  v39,  v40,  v50,  v51,  (_DWORD)v13 == 0);
        uint64_t v34 = v53;
        if (!v53) {
          return result;
        }
        goto LABEL_55;
      }

      specialized _pop<A>(from:as:count:)(&v53, v32);
      uint64_t v14 = v52;
      uint64_t v15 = v26;
    }

    result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( v15,  v14,  a2);
    uint64_t v34 = v53;
    if (!v53) {
      return result;
    }
LABEL_55:
    if (v54 == v34) {
      return result;
    }
    result._Builtin::RawPointer rawValue = (Builtin::RawPointer)specialized _pop<A>(from:as:count:)(&v53, 1LL);
    if (__OFADD__(*a2, 7LL))
    {
      __break(1u);
LABEL_73:
      __break(1u);
LABEL_74:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
    }

    unint64_t v46 = (*a2 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    BOOL v23 = __OFADD__(v46, 8LL);
    uint64_t v47 = v46 + 8;
    if (v23) {
      goto LABEL_73;
    }
    *a2 = v47;
LABEL_61:
    uint64_t v9 = v53;
    if (!v53) {
      return result;
    }
  }

  return result;
}

void specialized _walkKeyPathPattern<A>(_:walker:)(uint64_t a1, Swift::UnsafeRawPointer_optional *a2)
{
  uint64_t v4 = specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 0LL);
  specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 4LL);
  specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 8LL);
  specialized _loadRelativeAddress<A>(at:fromByteOffset:as:)(a1, 12LL);
  a2[2].value._Builtin::RawPointer rawValue = (Builtin::RawPointer)v4;
  if ((((_BYTE)a1 + 16) & 3) != 0) {
LABEL_80:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
  uint64_t v5 = a1 + 20;
  uint64_t v6 = a1 + 20 + (*(_DWORD *)(a1 + 16) & 0xFFFFFF);
  uint64_t v73 = a1 + 20;
  uint64_t v74 = v6;
  while (v74 != v5)
  {
    Swift::UnsafeRawPointer_optional v7 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v73, 1LL);
    if (!v7) {
      goto LABEL_82;
    }
    unsigned int v8 = *v7;
    int v9 = HIBYTE(*v7) & 0x7F;
    uint64_t v10 = *v7 & 0xFFFFFF;
    if (v9)
    {
      if ((v8 & 0x7D000000) == 0x1000000)
      {
        specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(*v7, &v73);
      }

      else if (v9 == 2)
      {
        uint64_t v15 = popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(*v7, &v73);
        unsigned int v17 = v16;
        uint64_t v19 = v18;
        uint64_t v21 = v20;
        int v24 = (uint64_t (*)(void))popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( v8,  &v73);
        int v25 = (v8 >> 19) & 2;
        if ((v8 & 0x200000) != 0) {
          LOBYTE(v25) = 1;
        }
        int v26 = v8 & 0xF;
        if ((v8 & 0xF) != 0)
        {
          if (v26 == 2) {
            char v27 = 2;
          }
          else {
            char v27 = 3;
          }
          if (v26 == 3) {
            LOBYTE(v26) = 1;
          }
          else {
            LOBYTE(v26) = v27;
          }
        }

        InstantiateKeyPathBuffer.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)( (v8 & 0x800000) != 0,  v25,  v26,  v15,  v17,  v19,  v21,  v24,  v22,  v23,  0LL,  0LL,  1);
      }

      else if ((_DWORD)v10)
      {
        if ((_DWORD)v10 == 1)
        {
          Builtin::RawPointer rawValue = (__objc2_class **)a2[6].value._rawValue;
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)rawValue);
          a2[6].value._Builtin::RawPointer rawValue = rawValue;
          if (!isUniquelyReferenced_nonNull_native)
          {
            Builtin::RawPointer rawValue = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&rawValue[2]->isa + 1,  1,  (uint64_t)rawValue);
            a2[6].value._Builtin::RawPointer rawValue = rawValue;
          }

          unint64_t v43 = rawValue[2];
          unint64_t v42 = (unint64_t)rawValue[3];
          if ((unint64_t)v43 >= v42 >> 1) {
            Builtin::RawPointer rawValue = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v42 > 1),  (int64_t)&v43->isa + 1,  1,  (uint64_t)rawValue);
          }
          rawValue[2] = (__objc2_class *)((char *)&v43->isa + 1);
          *((_BYTE *)&v43->info + (void)rawValue) = 0;
          a2[6].value._Builtin::RawPointer rawValue = rawValue;
          if (!a2->value._rawValue) {
            goto LABEL_82;
          }
          a2[9].value._Builtin::RawPointer rawValue = a2->value._rawValue;
          specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(67108865);
        }

        else
        {
          uint64_t v57 = (__objc2_class **)a2[6].value._rawValue;
          BOOL v58 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v57);
          a2[6].value._Builtin::RawPointer rawValue = v57;
          if (!v58)
          {
            uint64_t v57 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v57[2]->isa + 1,  1,  (uint64_t)v57);
            a2[6].value._Builtin::RawPointer rawValue = v57;
          }

          unint64_t v60 = v57[2];
          unint64_t v59 = (unint64_t)v57[3];
          if ((unint64_t)v60 >= v59 >> 1) {
            uint64_t v57 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v59 > 1),  (int64_t)&v60->isa + 1,  1,  (uint64_t)v57);
          }
          v57[2] = (__objc2_class *)((char *)&v60->isa + 1);
          *((_BYTE *)&v60->info + (void)v57) = 0;
          a2[6].value._Builtin::RawPointer rawValue = v57;
          if (!a2->value._rawValue) {
            goto LABEL_82;
          }
          a2[9].value._Builtin::RawPointer rawValue = a2->value._rawValue;
          specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(67108866);
        }
      }

      else
      {
        uint64_t v53 = (__objc2_class **)a2[6].value._rawValue;
        BOOL v54 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v53);
        a2[6].value._Builtin::RawPointer rawValue = v53;
        if (!v54)
        {
          uint64_t v53 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v53[2]->isa + 1,  1,  (uint64_t)v53);
          a2[6].value._Builtin::RawPointer rawValue = v53;
        }

        uint64_t v56 = v53[2];
        unint64_t v55 = (unint64_t)v53[3];
        if ((unint64_t)v56 >= v55 >> 1) {
          uint64_t v53 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v55 > 1),  (int64_t)&v56->isa + 1,  1,  (uint64_t)v53);
        }
        v53[2] = (__objc2_class *)((char *)&v56->isa + 1);
        *((_BYTE *)&v56->info + (void)v53) = 0;
        a2[6].value._Builtin::RawPointer rawValue = v53;
        if (!a2->value._rawValue) {
          goto LABEL_82;
        }
        a2[9].value._Builtin::RawPointer rawValue = a2->value._rawValue;
        specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(0x4000000);
      }

      goto LABEL_73;
    }

    uint64_t v11 = v73;
    if (!v73) {
      goto LABEL_82;
    }
    int v12 = (int *)specialized _pop<A>(from:as:count:)(&v73, 1LL);
    if (!v12) {
      goto LABEL_82;
    }
    uint64_t v13 = *v12;
    if ((v13 & 1) != 0)
    {
      BOOL v28 = __OFSUB__((_DWORD)v13, 1);
      int v29 = v13 - 1;
      if (v28)
      {
        __break(1u);
LABEL_82:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
      }

      unint64_t v30 = (unsigned int **)(v11 + v29);
      if (!v30) {
        goto LABEL_82;
      }
      uint64_t v14 = *v30;
    }

    else
    {
      uint64_t v14 = (unsigned int *)(v11 + v13);
      if (!(v11 + v13)) {
        goto LABEL_82;
      }
    }

    unsigned int v31 = *v14;
    uint64_t v32 = specialized _pop<A>(from:as:count:)(&v73, v10);
    if (v31)
    {
      uint64_t v34 = (int *)v32;
      uint64_t v35 = v33;
      uint64_t v36 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v73, 1LL);
      if (!v36) {
        goto LABEL_82;
      }
      unsigned int v37 = *v36;
      uint64_t v38 = RawKeyPathComponent.Header.patternComponentBodySize.getter(*v36);
      uint64_t v39 = RawKeyPathComponent.Header.propertyDescriptorBodySize.getter(v31);
      v72[0] = (uint64_t)(v14 + 1);
      v72[1] = (uint64_t)v14 + v39 + 4;
      if ((HIBYTE(v31) & 0x7D | 2) == 3)
      {
        specialized _pop<A>(from:as:count:)(&v73, v38);
        specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v31, v72);
      }

      else
      {
        uint64_t v71 = popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v31, v72);
        unsigned int v45 = v44;
        uint64_t v47 = v46;
        uint64_t v49 = v48;
        if ((HIBYTE(v37) & 0x7F) == 2 && (v37 & 0x80000) != 0)
        {
          popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)(v37, &v73);
          uint64_t v50 = (uint64_t (*)(void))popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( v37,  &v73);
        }

        else
        {
          specialized _pop<A>(from:as:count:)(&v73, v38);
          uint64_t v50 = 0LL;
          uint64_t v51 = 0LL;
          size_t v52 = 0LL;
        }

        int v61 = (v31 >> 19) & 2;
        if ((v31 & 0x200000) != 0) {
          LOBYTE(v61) = 1;
        }
        int v62 = v31 & 0xF;
        if ((v31 & 0xF) != 0)
        {
          if (v62 == 2) {
            char v63 = 2;
          }
          else {
            char v63 = 3;
          }
          if (v62 == 3) {
            LOBYTE(v62) = 1;
          }
          else {
            LOBYTE(v62) = v63;
          }
        }

        if ((_DWORD)v10) {
          __int128 v64 = v34;
        }
        else {
          __int128 v64 = 0LL;
        }
        if ((_DWORD)v10) {
          uint64_t v65 = v35;
        }
        else {
          uint64_t v65 = 0LL;
        }
        InstantiateKeyPathBuffer.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)( (v31 & 0x800000) != 0,  v61,  v62,  v71,  v45,  v47,  v49,  v50,  v51,  v52,  v64,  v65,  (_DWORD)v10 == 0);
      }

uint64_t specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( uint64_t result, uint64_t *a2, uint64_t *a3)
{
  unsigned int v4 = result;
  int v5 = result & 0x7FFFFF;
  if ((result & 0x7FFFFF) == 0x7FFFFD)
  {
    v6._Builtin::RawPointer rawValue = (Builtin::RawPointer)*a2;
    if (!*a2 || (Swift::UnsafeRawPointer_optional v7 = (Swift::Int32 *)specialized _pop<A>(from:as:count:)(a2, 1LL)) == 0LL) {
LABEL_23:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    Swift::UnsafeRawPointer result = (uint64_t)_resolveRelativeIndirectableAddress(_:_:)(v6, *v7)._rawValue;
    goto LABEL_9;
  }

  if (v5 == 8388606 || v5 == 0x7FFFFF)
  {
    Swift::UnsafeRawPointer result = specialized _pop<A>(from:as:count:)(a2, 1LL);
    if (!result) {
      goto LABEL_23;
    }
LABEL_9:
    int v8 = 0;
    goto LABEL_11;
  }

  int v8 = 1;
LABEL_11:
  if ((HIBYTE(v4) & 0x7F) == 1)
  {
    if ((v4 & 0x800000) != 0) {
      goto LABEL_16;
    }
    LOBYTE(v9) = 0;
  }

  else
  {
    int v9 = (v4 >> 22) & 2;
  }

  *((_BYTE *)a3 + 8) = v9;
LABEL_16:
  uint64_t v10 = *a3;
  if (v8)
  {
    uint64_t v11 = v10 + 4;
    if (!__OFADD__(v10, 4LL)) {
      goto LABEL_21;
    }
    __break(1u);
  }

  uint64_t v11 = v10 + 8;
  if (__OFADD__(v10, 8LL))
  {
    __break(1u);
    goto LABEL_23;
  }

void specialized visitStored #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( unsigned int a1, uint64_t *a2)
{
  uint64_t rawValue = a1 & 0x7FFFFF;
  switch((_DWORD)rawValue)
  {
    case 0x7FFFFD:
      v6._uint64_t rawValue = (Builtin::RawPointer)*a2;
      if (!*a2) {
        goto LABEL_16;
      }
      Swift::UnsafeRawPointer_optional v7 = (Swift::Int32 *)specialized _pop<A>(from:as:count:)(a2, 1LL);
      if (!v7) {
        goto LABEL_16;
      }
      uint64_t rawValue = (uint64_t)_resolveRelativeIndirectableAddress(_:_:)(v6, *v7)._rawValue;
      char v5 = 3;
      break;
    case 0x7FFFFE:
      int v8 = (unsigned int *)specialized _pop<A>(from:as:count:)(a2, 1LL);
      if (!v8) {
        goto LABEL_16;
      }
      uint64_t rawValue = *v8;
      char v5 = 2;
      break;
    case 0x7FFFFF:
      unsigned int v4 = (unsigned int *)specialized _pop<A>(from:as:count:)(a2, 1LL);
      if (v4)
      {
        uint64_t rawValue = *v4;
        char v5 = 1;
        break;
      }

uint64_t popComputedAccessors #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( int a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2
    || !specialized _pop<A>(from:as:count:)(a2, 1LL)
    || (uint64_t v5 = *a2) == 0
    || (Swift::UnsafeRawPointer v6 = (int *)specialized _pop<A>(from:as:count:)(a2, 1LL)) == 0LL
    || !(v5 + *v6)
    || (a1 & 0x400000) != 0
    && ((v7 = *a2) == 0 || (int v8 = (int *)specialized _pop<A>(from:as:count:)(a2, 1LL)) == 0LL || !(v7 + *v8)))
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  return v2;
}

uint64_t popComputedArguments #1 <A>(header:componentBuffer:) in _walkKeyPathPattern<A>(_:walker:)( int a1, uint64_t *a2)
{
  if ((a1 & 0x80000) == 0) {
    return 0LL;
  }
  uint64_t v4 = *a2;
  if (!*a2
    || (uint64_t v5 = (int *)specialized _pop<A>(from:as:count:)(a2, 1LL)) == 0LL
    || (uint64_t v2 = v4 + *v5) == 0
    || (uint64_t v6 = *a2) == 0
    || (uint64_t v7 = (int *)specialized _pop<A>(from:as:count:)(a2, 1LL)) == 0LL)
  {
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  uint64_t v8 = *v7;
  if ((_DWORD)v8)
  {
    if (!(v6 + v8)) {
      goto LABEL_16;
    }
    uint64_t v9 = *a2;
    if (!*a2) {
      goto LABEL_16;
    }
  }

  else
  {
    uint64_t v9 = *a2;
    if (!*a2) {
      goto LABEL_16;
    }
  }

  uint64_t v10 = (int *)specialized _pop<A>(from:as:count:)(a2, 1LL);
  if (!v10 || !(v9 + *v10)) {
    goto LABEL_16;
  }
  return v2;
}

uint64_t specialized InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)()
{
  uint64_t v1 = *v0;
  if (!*v0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  if ((v1 & 3) != 0) {
    uint64_t v2 = 4 - (*v0 & 3);
  }
  else {
    uint64_t v2 = 0LL;
  }
  return v1 + v2;
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v1 = *v0;
  if (!*v0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  if ((v1 & 7) != 0) {
    uint64_t v2 = 8 - (*v0 & 7);
  }
  else {
    uint64_t v2 = 0LL;
  }
  return v1 + v2;
}

uint64_t InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *v2;
  if (!*v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL);
  if ((v4 & v3) != 0) {
    uint64_t v5 = v4 - (v4 & v3) + 1;
  }
  else {
    uint64_t v5 = 0LL;
  }
  return v3 + v5;
}

_DWORD *specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(int a1)
{
  Swift::UnsafeRawPointer result = (_DWORD *)specialized InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)();
  *Swift::UnsafeRawPointer result = a1;
  uint64_t v5 = *v1;
  if (*v1) {
    uint64_t v5 = v1[1] - v5;
  }
  BOOL v6 = __OFSUB__(v5, 4LL);
  uint64_t v7 = v5 - 4;
  if (v6)
  {
    __break(1u);
    goto LABEL_8;
  }

  BOOL v6 = __OFSUB__(v7, v4);
  uint64_t v8 = v7 - v4;
  if (v6)
  {
LABEL_8:
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if (v8 < 0) {
    goto LABEL_9;
  }
  *uint64_t v1 = (uint64_t)(result + 1);
  v1[1] = (uint64_t)result + v8 + 4;
  return result;
}

void *specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(uint64_t a1)
{
  Swift::UnsafeRawPointer result = (void *)specialized InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)();
  *Swift::UnsafeRawPointer result = a1;
  uint64_t v5 = *v1;
  if (*v1) {
    uint64_t v5 = v1[1] - v5;
  }
  BOOL v6 = __OFSUB__(v5, 8LL);
  uint64_t v7 = v5 - 8;
  if (v6)
  {
    __break(1u);
    goto LABEL_8;
  }

  BOOL v6 = __OFSUB__(v7, v4);
  uint64_t v8 = v7 - v4;
  if (v6)
  {
LABEL_8:
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if (v8 < 0) {
    goto LABEL_9;
  }
  *uint64_t v1 = (uint64_t)(result + 1);
  v1[1] = (uint64_t)result + v8 + 8;
  return result;
}

void *InstantiateKeyPathBuffer.pushDest<A>(_:)(const void *a1, uint64_t a2)
{
  size_t v4 = *(void *)(*(void *)(a2 - 8) + 64LL);
  uint64_t v5 = (char *)InstantiateKeyPathBuffer.adjustDestForAlignment<A>(of:)((uint64_t)a1, a2);
  if ((v4 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  uint64_t v7 = v5;
  uint64_t v8 = v6;
  Swift::UnsafeRawPointer result = memcpy(v5, a1, v4);
  uint64_t v10 = *v2;
  if (*v2) {
    uint64_t v10 = v2[1] - v10;
  }
  BOOL v11 = __OFSUB__(v10, v4);
  size_t v12 = v10 - v4;
  if (v11)
  {
    __break(1u);
    goto LABEL_10;
  }

  BOOL v11 = __OFSUB__(v12, v8);
  size_t v13 = v12 - v8;
  if (v11)
  {
LABEL_10:
    __break(1u);
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if ((v13 & 0x8000000000000000LL) != 0) {
    goto LABEL_11;
  }
  *uint64_t v2 = (uint64_t)&v7[v4];
  v2[1] = (uint64_t)&v7[v4 + v13];
  return result;
}

void InstantiateKeyPathBuffer.visitStoredComponent(kind:mutable:offset:)( char a1, char a2, uint64_t a3, char a4)
{
  if (*v4)
  {
    uint64_t v8 = v4[9];
    v4[9] = *v4;
    uint64_t v9 = (__objc2_class **)v4[6];
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v9);
    v4[6] = v9;
    if ((a1 & 1) != 0)
    {
      if (!isUniquelyReferenced_nonNull_native)
      {
        uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v9[2]->isa + 1,  1,  (uint64_t)v9);
        v4[6] = v9;
      }

      uint64_t v14 = v9[2];
      unint64_t v13 = (unint64_t)v9[3];
      if ((unint64_t)v14 >= v13 >> 1) {
        uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v13 > 1),  (int64_t)&v14->isa + 1,  1,  (uint64_t)v9);
      }
      v9[2] = (__objc2_class *)((char *)&v14->isa + 1);
      *((_BYTE *)&v14->info + (void)v9) = 0;
      v4[6] = v9;
      if ((a2 & 1) != 0) {
        v4[8] = v8;
      }
    }

    else
    {
      if (!isUniquelyReferenced_nonNull_native)
      {
        uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v9[2]->isa + 1,  1,  (uint64_t)v9);
        v4[6] = v9;
      }

      size_t v12 = v9[2];
      unint64_t v11 = (unint64_t)v9[3];
      if ((unint64_t)v12 >= v11 >> 1) {
        uint64_t v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v11 > 1),  (int64_t)&v12->isa + 1,  1,  (uint64_t)v9);
      }
      v9[2] = (__objc2_class *)((char *)&v12->isa + 1);
      *((_BYTE *)&v12->info + (void)v9) = 1;
      v4[6] = v9;
    }

    __asm { BR              X10 }
  }

  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
}

_DWORD *static UInt32.+= infix(_:_:)(_DWORD *result, int a2)
{
  if (__CFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

void *InstantiateKeyPathBuffer.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)( char a1, char a2, char a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t (*a8)(void), uint64_t a9, uint64_t (*a10)(uint64_t, uint64_t), int *a11, uint64_t a12, char a13)
{
  LOBYTE(v19) = a2;
  uint64_t v21 = (__objc2_class **)v13[6];
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v21);
  v13[6] = (uint64_t)v21;
  uint64_t v49 = a6;
  if (!isUniquelyReferenced_nonNull_native) {
    goto LABEL_55;
  }
  while (1)
  {
    int v24 = v21[2];
    unint64_t v23 = (unint64_t)v21[3];
    if ((unint64_t)v24 >= v23 >> 1) {
      uint64_t v21 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v23 > 1),  (int64_t)&v24->isa + 1,  1,  (uint64_t)v21);
    }
    void v21[2] = (__objc2_class *)((char *)&v24->isa + 1);
    *((_BYTE *)&v24->info + (void)v21) = 0;
    v13[6] = (uint64_t)v21;
    if (!*v13) {
LABEL_63:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    uint64_t v25 = v13[9];
    v13[9] = *v13;
    if (a7 && (a1 & 1) == 0) {
      v13[8] = v25;
    }
    if ((v19 - 1) > 1u) {
      __asm { BR              X10 }
    }

    char v26 = (a13 & 1) == 0 && a8 != 0LL;
    char v27 = (a13 & 1) == 0 || a8 != 0LL;
    int v28 = specialized RawKeyPathComponent.Header.init(computedWithIDKind:mutating:settable:hasArguments:instantiatedFromExternalWithArguments:)( v19,  a1 & 1,  a7 != 0,  v27,  v26);
    specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(v28);
    specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(a5);
    Swift::UnsafeRawPointer result = specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(v49);
    if (a7) {
      Swift::UnsafeRawPointer result = specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(a7);
    }
    uint64_t v19 = a12;
    if (a8) {
      break;
    }
    if ((a13 & 1) != 0) {
      return result;
    }
    specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(8 * a12);
    Swift::UnsafeRawPointer result = specialized InstantiateKeyPathBuffer.pushDest<A>(_:)((uint64_t)&swift_keyPathGenericWitnessTable);
    if (a12 < 0) {
LABEL_50:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
LABEL_34:
    if (!a12) {
      return result;
    }
    a8 = (uint64_t (*)(void))a11;
    if (!a11) {
      goto LABEL_63;
    }
    a7 = 8LL;
    uint64_t v40 = a11;
    while (1)
    {
      uint64_t v41 = *v40++;
      v42._uint64_t rawValue = (char *)a8 + v41;
      Swift::UnsafeRawPointer result = _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)( v42,  (Swift::UnsafeRawPointer_optional)v13[2],  (Swift::UnsafeRawPointer_optional)v13[3])._rawValue;
      uint64_t v43 = *v13;
      if (!*v13) {
        goto LABEL_63;
      }
      uint64_t v44 = (v43 & 7) != 0 ? 8 - (*v13 & 7) : 0LL;
      *(void *)(v43 + v44) = result;
      uint64_t v45 = v43 + v44 + 8;
      uint64_t v46 = v13[1] - v43;
      BOOL v38 = __OFSUB__(v46, 8LL);
      uint64_t v47 = v46 - 8;
      if (v38) {
        break;
      }
      BOOL v38 = __OFSUB__(v47, v44);
      uint64_t v48 = v47 - v44;
      if (v38) {
        goto LABEL_54;
      }
      if (v48 < 0) {
        goto LABEL_52;
      }
      *unint64_t v13 = v45;
      v13[1] = v45 + v48;
      a8 = (uint64_t (*)(void))((char *)a8 + 4);
      if (!--v19) {
        return result;
      }
    }

    __break(1u);
LABEL_54:
    __break(1u);
LABEL_55:
    uint64_t v21 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v21[2]->isa + 1,  1,  (uint64_t)v21);
    v13[6] = (uint64_t)v21;
  }

  uint64_t v30 = v13[3];
  uint64_t v31 = a8(v30);
  if (__OFADD__(v31, v32))
  {
    __break(1u);
LABEL_57:
    __break(1u);
LABEL_58:
    __break(1u);
LABEL_59:
    __break(1u);
LABEL_60:
    __break(1u);
LABEL_61:
    __break(1u);
LABEL_62:
    __break(1u);
    JUMPOUT(0x181567B1CLL);
  }

  uint64_t v33 = v31;
  uint64_t v34 = (v31 + v32) & ~v32;
  if ((a13 & 1) == 0)
  {
    if (__OFADD__(v34, 7LL)) {
      goto LABEL_58;
    }
    unint64_t v35 = (v34 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v34 = v35 + 8 * a12;
    if (__OFADD__(v35, 8 * a12)) {
      goto LABEL_60;
    }
  }

  specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(v34);
  specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(a9);
  if (ComputedAccessorsPtr.getter<A, B>()(a9)) {
    *((_BYTE *)v13 + 56) = 0;
  }
  if ((a13 & 1) == 0)
  {
    specialized InstantiateKeyPathBuffer.pushDest<A>(_:)(8 * a12);
  }

  uint64_t v36 = *v13;
  if (!*v13) {
    goto LABEL_63;
  }
  Swift::UnsafeRawPointer result = (void *)a10(v30, *v13);
  uint64_t v37 = v13[1] - v36;
  BOOL v38 = __OFSUB__(v37, v33);
  uint64_t v39 = v37 - v33;
  if (v38) {
    goto LABEL_57;
  }
  if (v39 < 0) {
LABEL_52:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  *unint64_t v13 = v36 + v33;
  v13[1] = v36 + v33 + v39;
  if ((a13 & 1) == 0)
  {
    if (a12 < 0) {
      goto LABEL_50;
    }
    goto LABEL_34;
  }

  return result;
}

void _createOffsetBasedKeyPath(root:value:offset:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for KeyPath(0LL, (uint64_t)a1, a2, a4);
  swift_allocObject(v5, ((*(unsigned int *)(v5 + 48) + 3LL) & 0x1FFFFFFFCLL) + 12, *(unsigned __int16 *)(v5 + 52) | 3LL)[2] = 0LL;
  Swift::UnsafeMutableRawBufferPointer v6 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes( 2147483652LL,  0LL,  (uint64_t)v6._position.value._rawValue,  (uint64_t)v6._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  Swift::UInt MetadataKind = swift_getMetadataKind(a1);
  _MetadataKind.init(rawValue:)(MetadataKind);
  __asm { BR              X11 }

uint64_t sub_181567C80( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, uint64_t a10, int a11, uint64_t a12, Swift::UnsafeMutableRawBufferPointer into, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if ((v19 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  if (HIDWORD(v19)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&v24, 0);
  Swift::UInt MetadataKind = swift_getMetadataKind(v20);
  _MetadataKind.init(rawValue:)(MetadataKind);
  if (LOBYTE(v24._position.value._rawValue) == 1) {
    *(void *)(v21 + 16) = ~v19;
  }
  return v21;
}

uint64_t _rerootKeyPath<A>(_:to:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = specialized KeyPathBuffer.init(base:)((uint64_t)(a1 + 3));
  if (v5) {
    uint64_t v7 = v6 - v5;
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v8 = *a1;
  uint64_t v9 = *(uint64_t (**)(void))(*a1 + 120);
  uint64_t v10 = v9();
  v9();
  uint64_t v12 = v11;
  if (v8 == type metadata accessor for ReferenceWritableKeyPath(0LL, v10, v11, v13))
  {
    type metadata accessor for ReferenceWritableKeyPath(0LL, a3, v12, v14);
  }

  else
  {
    if (v8 != type metadata accessor for KeyPath(0LL, v10, v12, v14)) {
      goto LABEL_11;
    }
    type metadata accessor for KeyPath(0LL, a3, v12, v15);
  }

  if (__OFADD__(v7, 8LL))
  {
    __break(1u);
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000027LL,  0x80000001818B6B30LL,  "Swift/KeyPath.swift",  19LL,  2,  0xFB6uLL,  0);
  }

  uint64_t v16 = MEMORY[0x1895F8858](v7 + 8);
  unsigned int v17 = static AnyKeyPath._create(capacityInBytes:initializedBy:)( v16,  (void (*)(void *, char *))partial apply for closure #2 in _rerootKeyPath<A>(_:to:));
  uint64_t v20 = (const char *)type metadata accessor for PartialKeyPath(0LL, a3, v18, v19);
  return swift_dynamicCastClassUnconditional((int64_t)v17, v20, 0LL, 0LL, 0LL);
}

unint64_t AnyKeyPath.debugDescription.getter()
{
  uint64_t v2 = (uint64_t)v0;
  unint64_t v3 = *v0;
  uint64_t v4 = specialized static String._createEmpty(withInitialCapacity:)(3LL);
  unint64_t v8 = v4;
  uint64_t v9 = v5;
  unint64_t v187 = v4;
  unint64_t v188 = v5;
  unint64_t v10 = HIBYTE(v5) & 0xF;
  uint64_t v11 = v4 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000LL) != 0) {
    uint64_t v12 = HIBYTE(v5) & 0xF;
  }
  else {
    uint64_t v12 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (!v12 && (v4 & ~v5 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v5);
    unint64_t v187 = 92LL;
    unint64_t v188 = 0xE100000000000000LL;
    goto LABEL_70;
  }

  if ((v5 & 0x2000000000000000LL) == 0 || v10 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v6, v7);
    if ((v9 & 0x1000000000000000LL) != 0) {
      goto LABEL_185;
    }
    Swift::Int v21 = v12 + 1;
    if (!__OFADD__(v12, 1LL)) {
      goto LABEL_18;
    }
LABEL_187:
    __break(1u);
    goto LABEL_188;
  }

  uint64_t v13 = 8 * (HIBYTE(v5) & 7);
  uint64_t v14 = (-255LL << v13) - 1;
  uint64_t v15 = 92LL << v13;
  unint64_t v16 = v15 | v14 & v5;
  unint64_t v17 = v15 | v14 & v4;
  if (v10 >= 8) {
    unint64_t v18 = v16;
  }
  else {
    unint64_t v18 = v5;
  }
  if (v10 < 8) {
    unint64_t v8 = v17;
  }
  swift_bridgeObjectRelease(v5);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  unint64_t v19 = 0xA000000000000000LL;
  if (!(v8 & 0x8080808080808080LL | v18 & 0x80808080808080LL)) {
    unint64_t v19 = 0xE000000000000000LL;
  }
  unint64_t v20 = (v19 & 0xFF00000000000000LL | (v10 << 56) | v18 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL;
LABEL_69:
  unint64_t v187 = v8;
  unint64_t v188 = v20;
  while (1)
  {
LABEL_70:
    Swift::Int v185 = v3;
    uint64_t v61 = (*(uint64_t (**)(void))(v3 + 120))();
    uint64_t v62 = specialized String.init<A>(describing:)(v61);
    uint64_t v11 = v62;
    unint64_t v8 = v63;
    uint64_t v9 = v187;
    unint64_t v3 = v188;
    unint64_t v66 = HIBYTE(v188) & 0xF;
    if ((v188 & 0x2000000000000000LL) != 0) {
      unint64_t v67 = HIBYTE(v188) & 0xF;
    }
    else {
      unint64_t v67 = v187 & 0xFFFFFFFFFFFFLL;
    }
    if (!v67 && (v187 & ~v188 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v188);
      unint64_t v187 = v11;
      unint64_t v188 = v8;
      goto LABEL_121;
    }

    uint64_t v68 = v63 & 0x2000000000000000LL;
    unint64_t v43 = HIBYTE(v63) & 0xF;
    if ((v188 & 0x2000000000000000LL) == 0 || !v68)
    {
      uint64_t v184 = v2;
      goto LABEL_78;
    }

    unint64_t v88 = v66 + v43;
    if (v66 + v43 <= 0xF) {
      break;
    }
    uint64_t v184 = v2;
    uint64_t v68 = 1LL;
LABEL_78:
    if (v68) {
      uint64_t v2 = HIBYTE(v63) & 0xF;
    }
    else {
      uint64_t v2 = v62 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v63, 2LL, v64, v65);
    if ((v8 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v8, 5LL, v69, v70);
      v159._Swift::UInt64 rawBits = 1LL;
      v160._Swift::UInt64 rawBits = (v2 << 16) | 1;
      v161._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v159, v160, v11, v8);
      if (v161._rawBits < 0x10000) {
        v161._rawBits |= 3;
      }
      Swift::Int v71 = specialized Collection.count.getter(v161, v162, v11, v8);
      swift_bridgeObjectRelease(v8);
      if ((v3 & 0x1000000000000000LL) == 0)
      {
LABEL_83:
        BOOL v72 = __OFADD__(v67, v71);
        Swift::Int v1 = v67 + v71;
        if (!v72) {
          goto LABEL_84;
        }
        goto LABEL_184;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(v8, 4LL, v69, v70);
      Swift::Int v71 = v2;
      if ((v3 & 0x1000000000000000LL) == 0) {
        goto LABEL_83;
      }
    }

    Swift::Int v163 = String.UTF8View._foreignCount()();
    Swift::Int v1 = v163 + v71;
    if (!__OFADD__(v163, v71))
    {
LABEL_84:
      if ((v9 & ~v3 & 0x2000000000000000LL) == 0
        || !swift_isUniquelyReferenced_nonNull_native(v3 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v1 >= 16)
        {
          uint64_t v183 = v11 & 0xFFFFFFFFFFFFLL;
          uint64_t v73 = v187;
          uint64_t v9 = v188;
          goto LABEL_93;
        }

        unint64_t v3 = v188;
        if ((v188 & 0x2000000000000000LL) == 0)
        {
          uint64_t v9 = v188;
          goto LABEL_116;
        }

        int v87 = 0;
        uint64_t v9 = v188;
        goto LABEL_137;
      }

      uint64_t v183 = v11 & 0xFFFFFFFFFFFFLL;
      uint64_t v73 = v187;
      uint64_t v9 = v188;
      int64_t v74 = _StringGuts.nativeUnusedCapacity.getter(v187, v188);
      if ((v75 & 1) == 0)
      {
        if (v1 > 15) {
          goto LABEL_93;
        }
        if ((v9 & 0x2000000000000000LL) == 0)
        {
          unint64_t v3 = v9;
          if (v74 < v71)
          {
LABEL_116:
            int v87 = 1;
            goto LABEL_137;
          }

LABEL_184:
    __break(1u);
LABEL_185:
    Swift::Int v164 = String.UTF8View._foreignCount()();
    Swift::Int v21 = v164 + 1;
    if (__OFADD__(v164, 1LL)) {
      goto LABEL_187;
    }
LABEL_18:
    unint64_t v22 = v8 & ~v9;
    if ((v22 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
      if ((v24 & 1) != 0) {
        goto LABEL_211;
      }
      if (v21 <= 15)
      {
        if ((v9 & 0x2000000000000000LL) != 0) {
          goto LABEL_51;
        }
        if (v23 <= 0) {
          goto LABEL_46;
        }
      }
    }

    else if (v21 <= 15)
    {
      if ((v9 & 0x2000000000000000LL) != 0)
      {
LABEL_51:
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        uint64_t v11 = v9;
      }

      else
      {
LABEL_46:
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        if ((v9 & 0x1000000000000000LL) != 0) {
          goto LABEL_206;
        }
        if ((v8 & 0x1000000000000000LL) != 0)
        {
          BOOL v38 = (unsigned __int8 *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          BOOL v38 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v8, v9);
          uint64_t v11 = v35;
        }

        swift_bridgeObjectRetain(v9, v35, v36, v37);
        closure #1 in _StringGuts._convertedToSmall()(v38, v11, v186);
        swift_bridgeObjectRelease(v9);
        uint64_t v11 = *((void *)&v186[0] + 1);
        unint64_t v8 = *(void *)&v186[0];
      }

  uint64_t v326 = v553;
  uint64_t v327 = v567;
  uint64_t v328 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    uint64_t v328 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v328 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    uint64_t v327 = 0xE200000000000000LL;
  }

  else
  {
    uint64_t v566 = 8236LL;
    v567 = 0xE200000000000000LL;
  }

  swift_bridgeObjectRelease(v327);
  v146(5LL, v162, AssociatedConformanceWitness);
  uint64_t v561 = (uint64_t *)v1;
  unint64_t v329 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v329, v326, v2);
  int64_t v330 = v561;
  uint64_t v331 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  uint64_t v332 = (void *)swift_getDynamicType(v331, v330, 1);
  LODWORD(v330) = swift_isOptionalType(v332);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v330)
  {
    memcpy(v151, v326, v2);
    unint64_t v333 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v333, 7uLL);
LABEL_191:
    uint64_t v334 = (uint64_t)v561;
    uint64_t v335 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    uint64_t v336 = (*(uint64_t (**)(uint64_t, uint64_t))(v335 + 8))(v334, v335);
    uint64_t v338 = v337;
    specialized String.write<A>(to:)(&v566, v336, v337, v339);
    swift_bridgeObjectRelease(v338);
LABEL_192:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_195;
  }

  uint64_t v340 = v544;
  memcpy(v544, v326, v2);
  if ((swift_dynamicCast((char *)&v560, v340, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t v341 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v341);
  }

  else
  {
    uint64_t v426 = v535;
    memcpy(v535, v326, v2);
    v427 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v426, v1, v427, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v428 = (uint64_t)v561;
      v429 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v429 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v428,  v429);
      goto LABEL_192;
    }

    uint64_t v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v464 = v527;
    memcpy(v527, v326, v2);
    uint64_t v465 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v464, v1, v465, 6uLL)
      || (uint64_t v565 = 0LL,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?),  unint64_t v466 = v517,  memcpy(v517, v326, v2),  v467 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v563, v466, v1, v467, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_191;
    }

    uint64_t v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v564 + 1) = v1;
    v496 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v496, v326, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v497 = v560._object;
    v498 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v326,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v498);
    swift_release((uint64_t)v497);
  }

  if (*(_BYTE *)(a1 + 32))
  {
    std::string::append((std::string *)a1, " : ", 3uLL);
    goto LABEL_206;
  }

LABEL_188:
  int64_t v134 = String.UTF8View._foreignCount()();
  if ((v8 & ~v9 & 0x2000000000000000LL) == 0) {
    goto LABEL_189;
  }
LABEL_167:
  if (!swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL)) {
    goto LABEL_189;
  }
  unint64_t v136 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
  if ((v137 & 1) != 0) {
    goto LABEL_211;
  }
  if (v134 <= 15 && (v136 & 0x8000000000000000LL) != 0) {
    goto LABEL_171;
  }
LABEL_190:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v134, 0LL);
  swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
  v186[0] = 0uLL;
  unint64_t v165 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)v186, 0LL);
  _StringGuts.appendInPlace(_:isASCII:)(v165, v166, 1);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  unint64_t v8 = v187;
  unint64_t v157 = v188;
LABEL_191:
  unint64_t v187 = v8;
  unint64_t v188 = v157;
  unint64_t v167 = specialized AnyKeyPath.withBuffer<A>(_:)(v2, &v187, v1);
  swift_bridgeObjectRelease(v188);
  return v167;
}

    if ((v148 & ~v11 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v157 = _StringGuts.nativeUnusedCapacity.getter(v148, v11);
      if ((v158 & 1) != 0) {
        goto LABEL_334;
      }
      if (v155 <= 15 && ((v11 & 0x2000000000000000LL) != 0 || v157 < v154))
      {
LABEL_198:
        swift_bridgeObjectRelease_n(a3, 5LL);
        Swift::String::Index v161 = v298._countAndFlagsBits;
        swift_bridgeObjectRetain(v11, v162, v163, v164);
        unint64_t v165 = _StringGuts._convertedToSmall()(v161, v11);
        unint64_t v167 = v166;
        swift_bridgeObjectRelease(v11);
        v168._Swift::UInt64 rawBits = (v61 << 16) | 1;
        v169._Swift::UInt64 rawBits = 1LL;
        v170._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v169, v168, a1, a3);
        if (v170._rawBits < 0x10000) {
          v170._rawBits |= 3;
        }
        uint64_t v172 = specialized String.init(_:)(v170, v171, a1, a3);
        uint64_t v174 = v173;
        swift_bridgeObjectRelease(a3);
        uint64_t v175 = _StringGuts._convertedToSmall()(v172, v174);
        unint64_t v177 = v176;
        swift_bridgeObjectRelease(v174);
        unint64_t v178 = specialized _SmallString.init(_:appending:)(v165, v167, v175, v177);
        unint64_t v180 = v296;
        if ((v181 & 1) != 0) {
          goto LABEL_333;
        }
        unint64_t v182 = v178;
        uint64_t v183 = v179;
        swift_bridgeObjectRelease(v11);
        swift_bridgeObjectRelease(a3);
        v298._uint64_t countAndFlagsBits = v182;
        v298._object = v183;
        goto LABEL_205;
      }
    }

    else if (v155 <= 15)
    {
      goto LABEL_198;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v155, v154);
    swift_bridgeObjectRelease_n(a3, 4LL);
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0LL, v61);
      swift_bridgeObjectRelease_n(a3, 2LL);
      goto LABEL_204;
    }

    if (a2)
    {
      swift_bridgeObjectRelease_n(a3, 2LL);
      *(void *)&unint64_t v297 = a1;
      *((void *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
      Swift::String::Index v159 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v10, (uint64_t)&v297, v10);
      _StringGuts.appendInPlace(_:isASCII:)(v159, v160, (a3 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(a3);
LABEL_204:
      unint64_t v180 = v296;
      goto LABEL_205;
    }

    if ((a1 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(a3);
      unint64_t v246 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v247 = v13;
    }

    else
    {
      unint64_t v246 = _StringObject.sharedUTF8.getter(a1, a3);
      uint64_t v247 = v286;
      swift_bridgeObjectRelease(a3);
    }

    unint64_t v180 = v296;
    uint64_t v248 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v13, (uint64_t)v246, v247);
    _StringGuts.appendInPlace(_:isASCII:)(v248, v249, a1 < 0);
    swift_bridgeObjectRelease_n(a3, 2LL);
LABEL_205:
    uint64_t v184 = _int64ToString(_:radix:uppercase:)( v180,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    a3 = v184;
    unint64_t v155 = v185;
    uint64_t v11 = v298._countAndFlagsBits;
    unint64_t v10 = (uint64_t)v298._object;
    unint64_t v188 = ((unint64_t)v298._object >> 56) & 0xF;
    else {
      uint64_t v61 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v61 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._uint64_t countAndFlagsBits = a3;
      v298._object = (void *)v155;
      goto LABEL_273;
    }

    a2 = v185 & 0x2000000000000000LL;
    a1 = HIBYTE(v185) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000LL) != 0 && a2)
    {
      uint64_t v189 = v188 + a1;
      if (v188 + a1 <= 0xF)
      {
        if (a1)
        {
          uint64_t v234 = 0;
          uint64_t v235 = 0LL;
          uint64_t v236 = (unint64_t)v298._object;
          do
          {
            uint64_t v237 = v188 + v235;
            uint64_t v238 = v235 + 1;
            if (v235 >= 8) {
              unint64_t v239 = v185;
            }
            else {
              unint64_t v239 = v184;
            }
            uint64_t v240 = v239 >> (v234 & 0x38);
            uint64_t v241 = (8 * v188 + v234) & 0x38;
            uint64_t v242 = (-255LL << v241) - 1;
            Swift::String::Index v243 = (unint64_t)v240 << v241;
            uint64_t v244 = v243 | v242 & v236;
            uint64_t v245 = v243 | v242 & v11;
            if (v237 < 8) {
              uint64_t v11 = v245;
            }
            else {
              uint64_t v236 = v244;
            }
            v234 += 8;
            uint64_t v235 = v238;
          }

          while (a1 != v238);
        }

        else
        {
          uint64_t v236 = (unint64_t)v298._object;
        }

        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(v155);
        uint64_t v255 = 0xA000000000000000LL;
        if (!(v11 & 0x8080808080808080LL | v236 & 0x80808080808080LL)) {
          uint64_t v255 = 0xE000000000000000LL;
        }
        v298._uint64_t countAndFlagsBits = v11;
        v298._object = (void *)(v255 & 0xFF00000000000000LL | (v189 << 56) | v236 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_273;
      }

      a2 = 1LL;
    }

    unint64_t v148 = v184 & 0xFFFFFFFFFFFFLL;
    if (a2) {
      uint64_t v13 = HIBYTE(v185) & 0xF;
    }
    else {
      uint64_t v13 = v184 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v185, 2LL, v186, v187);
    if ((v155 & 0x1000000000000000LL) != 0) {
      goto LABEL_302;
    }
    swift_bridgeObjectRetain_n(v155, 4LL, v152, v153);
    uint64_t v190 = v13;
    if ((v10 & 0x1000000000000000LL) != 0) {
      goto LABEL_305;
    }
LABEL_219:
    unint64_t v91 = __OFADD__(v61, v190);
    uint64_t v191 = v61 + v190;
    if (!v91) {
      goto LABEL_220;
    }
LABEL_307:
    __break(1u);
LABEL_308:
    v278 = String.UTF8View._foreignCount()();
    int64_t v25 = v278 + 8;
    if (__OFADD__(v278, 8LL))
    {
LABEL_310:
      __break(1u);
      goto LABEL_311;
    }

    if ((v148 & ~v11 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v157 = _StringGuts.nativeUnusedCapacity.getter(v148, v11);
      if ((v158 & 1) != 0) {
        goto LABEL_334;
      }
      if (v155 <= 15 && ((v11 & 0x2000000000000000LL) != 0 || v157 < v154))
      {
LABEL_198:
        swift_bridgeObjectRelease_n(a3, 5LL);
        Swift::String::Index v161 = v298._countAndFlagsBits;
        swift_bridgeObjectRetain(v11, v162, v163, v164);
        unint64_t v165 = _StringGuts._convertedToSmall()(v161, v11);
        unint64_t v167 = v166;
        swift_bridgeObjectRelease(v11);
        v168._Swift::UInt64 rawBits = (v61 << 16) | 1;
        v169._Swift::UInt64 rawBits = 1LL;
        v170._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v169, v168, a1, a3);
        if (v170._rawBits < 0x10000) {
          v170._rawBits |= 3;
        }
        uint64_t v172 = specialized String.init(_:)(v170, v171, a1, a3);
        uint64_t v174 = v173;
        swift_bridgeObjectRelease(a3);
        uint64_t v175 = _StringGuts._convertedToSmall()(v172, v174);
        unint64_t v177 = v176;
        swift_bridgeObjectRelease(v174);
        unint64_t v178 = specialized _SmallString.init(_:appending:)(v165, v167, v175, v177);
        unint64_t v180 = v296;
        if ((v181 & 1) != 0) {
          goto LABEL_333;
        }
        unint64_t v182 = v178;
        uint64_t v183 = v179;
        swift_bridgeObjectRelease(v11);
        swift_bridgeObjectRelease(a3);
        v298._uint64_t countAndFlagsBits = v182;
        v298._object = v183;
        goto LABEL_205;
      }
    }

    else if (v155 <= 15)
    {
      goto LABEL_198;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v155, v154);
    swift_bridgeObjectRelease_n(a3, 4LL);
    if ((a3 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0LL, v61);
      swift_bridgeObjectRelease_n(a3, 2LL);
      goto LABEL_204;
    }

    if (a2)
    {
      swift_bridgeObjectRelease_n(a3, 2LL);
      *(void *)&unint64_t v297 = a1;
      *((void *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
      Swift::String::Index v159 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v10, (uint64_t)&v297, v10);
      _StringGuts.appendInPlace(_:isASCII:)(v159, v160, (a3 & 0x4000000000000000LL) != 0);
      swift_bridgeObjectRelease(a3);
LABEL_204:
      unint64_t v180 = v296;
      goto LABEL_205;
    }

    if ((a1 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(a3);
      unint64_t v246 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v247 = v13;
    }

    else
    {
      unint64_t v246 = _StringObject.sharedUTF8.getter(a1, a3);
      uint64_t v247 = v286;
      swift_bridgeObjectRelease(a3);
    }

    unint64_t v180 = v296;
    uint64_t v248 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v13, (uint64_t)v246, v247);
    _StringGuts.appendInPlace(_:isASCII:)(v248, v249, a1 < 0);
    swift_bridgeObjectRelease_n(a3, 2LL);
LABEL_205:
    uint64_t v184 = _int64ToString(_:radix:uppercase:)( v180,  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    a3 = v184;
    unint64_t v155 = v185;
    uint64_t v11 = v298._countAndFlagsBits;
    unint64_t v10 = (uint64_t)v298._object;
    unint64_t v188 = ((unint64_t)v298._object >> 56) & 0xF;
    else {
      uint64_t v61 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v61 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._uint64_t countAndFlagsBits = a3;
      v298._object = (void *)v155;
      goto LABEL_273;
    }

    a2 = v185 & 0x2000000000000000LL;
    a1 = HIBYTE(v185) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000LL) != 0 && a2)
    {
      uint64_t v189 = v188 + a1;
      if (v188 + a1 <= 0xF)
      {
        if (a1)
        {
          uint64_t v234 = 0;
          uint64_t v235 = 0LL;
          uint64_t v236 = (unint64_t)v298._object;
          do
          {
            uint64_t v237 = v188 + v235;
            uint64_t v238 = v235 + 1;
            if (v235 >= 8) {
              unint64_t v239 = v185;
            }
            else {
              unint64_t v239 = v184;
            }
            uint64_t v240 = v239 >> (v234 & 0x38);
            uint64_t v241 = (8 * v188 + v234) & 0x38;
            uint64_t v242 = (-255LL << v241) - 1;
            Swift::String::Index v243 = (unint64_t)v240 << v241;
            uint64_t v244 = v243 | v242 & v236;
            uint64_t v245 = v243 | v242 & v11;
            if (v237 < 8) {
              uint64_t v11 = v245;
            }
            else {
              uint64_t v236 = v244;
            }
            v234 += 8;
            uint64_t v235 = v238;
          }

          while (a1 != v238);
        }

        else
        {
          uint64_t v236 = (unint64_t)v298._object;
        }

        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(v155);
        uint64_t v255 = 0xA000000000000000LL;
        if (!(v11 & 0x8080808080808080LL | v236 & 0x80808080808080LL)) {
          uint64_t v255 = 0xE000000000000000LL;
        }
        v298._uint64_t countAndFlagsBits = v11;
        v298._object = (void *)(v255 & 0xFF00000000000000LL | (v189 << 56) | v236 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_273;
      }

      a2 = 1LL;
    }

    unint64_t v148 = v184 & 0xFFFFFFFFFFFFLL;
    if (a2) {
      uint64_t v13 = HIBYTE(v185) & 0xF;
    }
    else {
      uint64_t v13 = v184 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v185, 2LL, v186, v187);
    if ((v155 & 0x1000000000000000LL) != 0) {
      goto LABEL_302;
    }
    swift_bridgeObjectRetain_n(v155, 4LL, v152, v153);
    uint64_t v190 = v13;
    if ((v10 & 0x1000000000000000LL) != 0) {
      goto LABEL_305;
    }
LABEL_219:
    unint64_t v91 = __OFADD__(v61, v190);
    uint64_t v191 = v61 + v190;
    if (!v91) {
      goto LABEL_220;
    }
LABEL_307:
    __break(1u);
LABEL_308:
    v278 = String.UTF8View._foreignCount()();
    int64_t v25 = v278 + 8;
    if (__OFADD__(v278, 8LL))
    {
LABEL_310:
      __break(1u);
      goto LABEL_311;
    }

  uint64_t v282 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    uint64_t v282 = v450 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v283 = v440;
  if (v282 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236LL;
    v451 = 0xE200000000000000LL;
  }

  v159(5LL, v199, v203);
  char v445 = (uint64_t *)v1;
  unint64_t v284 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v284, v283, v2);
  unint64_t v285 = v445;
  uint64_t v286 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  uint64_t v287 = (void *)swift_getDynamicType(v286, v285, 1);
  LODWORD(v285) = swift_isOptionalType(v287);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v285)
  {
    memcpy(v150, v283, v2);
    unint64_t v288 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v288, 7uLL);
LABEL_195:
    uint64_t v289 = (uint64_t)v445;
    unint64_t v290 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    uint64_t v291 = (*(uint64_t (**)(uint64_t, uint64_t))(v290 + 8))(v289, v290);
    uint64_t v293 = v292;
    specialized String.write<A>(to:)(&v450, v291, v292, v294);
    swift_bridgeObjectRelease(v293);
LABEL_196:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_199;
  }

  uint64_t v295 = v432;
  memcpy(v432, v283, v2);
  if ((swift_dynamicCast((char *)&v444, v295, v1, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint64_t v296 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v296);
  }

  else
  {
    uint64_t v341 = v425;
    memcpy(v425, v283, v2);
    v342 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v341, v1, v342, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      uint64_t v343 = (uint64_t)v445;
      uint64_t v344 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v344 + 8))( &v450,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v343,  v344);
      goto LABEL_196;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v365 = v417;
    memcpy(v417, v283, v2);
    uint64_t v366 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v365, v1, v366, 6uLL)
      || (v449 = 0LL,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomStringConvertible?),  v367 = v409,  memcpy(v409, v283, v2),  uint64_t v368 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v447, v367, v1, v368, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_195;
    }

    v449 = 0LL;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v447,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v448 + 1) = v1;
    v392 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v392, v283, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    uint64_t v393 = v444._object;
    uint64_t v394 = v283;
    v395 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v394,  &v444,  &v450,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v395);
    swift_release((uint64_t)v393);
  }

Swift::Void __swiftcall String.append(_:)(Swift::String a1)
{
  object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  unint64_t v6 = v3[1];
  uint64_t v7 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = *v3 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 || (*v3 & ~v6 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(a1._countAndFlagsBits, (unint64_t)a1._object);
  }

  else
  {
    swift_bridgeObjectRetain((unint64_t)a1._object, (uint64_t)a1._object, v1, v2);
    swift_bridgeObjectRelease(v6);
    *unint64_t v3 = countAndFlagsBits;
    v3[1] = (uint64_t)object;
  }

uint64_t Sequence.first(where:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, char *a5@<X8>)
{
  uint64_t v37 = a4;
  uint64_t v35 = a1;
  uint64_t v36 = a2;
  uint64_t v33 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v39 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v10 = (char *)&v33 - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  unint64_t v16 = (char *)&v33 - v15;
  uint64_t v17 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v14);
  unint64_t v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v34 = *(void *)(v20 - 8);
  MEMORY[0x1895F8858](v20);
  unint64_t v22 = (char *)&v33 - v21;
  (*(void (**)(char *, unint64_t, uint64_t))(v17 + 16))(v19, v38, a3);
  uint64_t v23 = (uint64_t)v37;
  (*((void (**)(uint64_t, const char *))v37 + 4))(a3, v37);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v23,  a3,  v20,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int64_t v25 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v37 = v22;
  unint64_t v38 = v20;
  v25(v20, AssociatedConformanceWitness);
  uint64_t v26 = v39;
  char v27 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v39 + 48);
  if (v27(v16, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_6:
    (*(void (**)(const char *, unint64_t))(v34 + 8))(v37, v38);
    uint64_t v30 = 1LL;
    uint64_t v31 = v33;
  }

  else
  {
    BOOL v28 = *(void (**)(char *, char *, unint64_t))(v26 + 32);
    while (1)
    {
      v28(v10, v16, AssociatedTypeWitness);
      char v29 = v35(v10);
      if (v5)
      {
        (*(void (**)(char *, unint64_t))(v39 + 8))(v10, AssociatedTypeWitness);
        return (*(uint64_t (**)(const char *, unint64_t))(v34 + 8))(v37, v38);
      }

      if ((v29 & 1) != 0) {
        break;
      }
      (*(void (**)(char *, unint64_t))(v39 + 8))(v10, AssociatedTypeWitness);
      v25(v38, AssociatedConformanceWitness);
      if (v27(v16, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_6;
      }
    }

    (*(void (**)(const char *, unint64_t))(v34 + 8))(v37, v38);
    uint64_t v31 = v33;
    v28(v33, v10, AssociatedTypeWitness);
    uint64_t v30 = 0LL;
  }

  return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v39 + 56))( v31,  v30,  1LL,  AssociatedTypeWitness);
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance AnyKeyPath()
{
  return AnyKeyPath.debugDescription.getter();
}

uint64_t KeyValuePairs.startIndex.getter()
{
  return 0LL;
}

Swift::Int KeyValuePairs.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Array._getCount()();
}

uint64_t KeyValuePairs.subscript.getter( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v23 = a2;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a5, a6, 0LL, 0LL);
  uint64_t v12 = *(TupleTypeMetadata2 - 1);
  uint64_t v13 = *(void *)(v12 + 64);
  uint64_t v14 = (uint64_t *)MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v16 = (char *)&v23 - v15;
  char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v14, v14);
  char v18 = ((a4 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
  Array._checkSubscript(_:wasNativeTypeChecked:)( a3,  (a4 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
  if ((v18 & 1) != 0)
  {
    (*(void (**)(char *, unint64_t, unint64_t *))(v12 + 16))( v16,  a4 + ((*(unsigned __int8 *)(v12 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80))
    + *(void *)(v12 + 72) * a3,
      TupleTypeMetadata2);
  }

  else
  {
    id v21 = _ArrayBuffer._getElementSlowPath(_:)(a3, a4, (uint64_t *)TupleTypeMetadata2);
    unint64_t v22 = v21;
    if (v13 != 8)
    {
      swift_unknownObjectRelease(v21);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    id v24 = v21;
    (*(void (**)(char *, id *, unint64_t *))(v12 + 16))(v16, &v24, TupleTypeMetadata2);
    swift_unknownObjectRelease(v22);
  }

  unint64_t v19 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  (*(void (**)(uint64_t, char *, uint64_t))(*(void *)(a5 - 8) + 32LL))(a1, v16, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(a6 - 8) + 32LL))(v23, v19, a6);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance KeyValuePairs<A, B>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance KeyValuePairs<A, B>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for KeyValuePairs<A, B>,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance KeyValuePairs<A, B>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance KeyValuePairs<A, B>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance KeyValuePairs<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance KeyValuePairs<A, B>@<X0>( uint64_t a1@<X0>, Swift::Int *a2@<X8>)
{
  Swift::Int result = KeyValuePairs.endIndex.getter(*v2, *(void *)(a1 + 16), *(void *)(a1 + 24));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance KeyValuePairs<A, B>( void *a1, unint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t v8 = *(void *)(a3 + 24);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v8, "key value ", 0LL);
  v7[4] = TupleTypeMetadata2;
  uint64_t v11 = *(TupleTypeMetadata2 - 1);
  v7[5] = v11;
  uint64_t v12 = (char *)malloc(*(void *)(v11 + 64));
  v7[6] = v12;
  uint64_t v13 = KeyValuePairs.subscript.read(v7, *a2, *v3, v9, v8);
  uint64_t v15 = v14;
  v7[7] = v13;
  (*(void (**)(char *))(*(void *)(v9 - 8) + 16LL))(v12);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16LL))( &v12[*((int *)TupleTypeMetadata2 + 12)],  v15,  v8);
  return protocol witness for Collection.subscript.read in conformance KeyValuePairs<A, B>;
}

void (*KeyValuePairs.subscript.read( void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t a1)
{
  unint64_t v10 = malloc(0x28uLL);
  *a1 = v10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a4, a5, 0LL, 0LL);
  uint64_t v12 = *(TupleTypeMetadata2 - 1);
  size_t v24 = *(void *)(v12 + 64);
  uint64_t v13 = (char *)malloc(v24);
  v10[1] = v13;
  uint64_t v25 = a4;
  uint64_t v14 = swift_getTupleTypeMetadata2(0LL, a4, a5, "key value ", 0LL);
  v10[2] = v14;
  uint64_t v15 = *(v14 - 1);
  v10[3] = v15;
  unint64_t v16 = (char *)malloc(*(void *)(v15 + 64));
  v10[4] = v16;
  char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( (uint64_t)TupleTypeMetadata2,  (uint64_t *)TupleTypeMetadata2);
  char v18 = ((a3 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
  Array._checkSubscript(_:wasNativeTypeChecked:)( a2,  (a3 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
  if ((v18 & 1) != 0)
  {
    (*(void (**)(char *, unint64_t, unint64_t *))(v12 + 16))( v13,  a3 + ((*(unsigned __int8 *)(v12 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80))
    + *(void *)(v12 + 72) * a2,
      TupleTypeMetadata2);
  }

  else
  {
    id v22 = _ArrayBuffer._getElementSlowPath(_:)(a2, a3, (uint64_t *)TupleTypeMetadata2);
    uint64_t v23 = v22;
    if (v24 != 8)
    {
      swift_unknownObjectRelease(v22);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    *unint64_t v10 = v22;
    (*(void (**)(char *, void *, unint64_t *))(v12 + 16))(v13, v10, TupleTypeMetadata2);
    swift_unknownObjectRelease(v23);
  }

  unint64_t v19 = &v16[*((int *)v14 + 12)];
  unint64_t v20 = &v13[*((int *)TupleTypeMetadata2 + 12)];
  (*(void (**)(char *, char *))(*(void *)(v25 - 8) + 32LL))(v16, v13);
  (*(void (**)(char *, char *))(*(void *)(a5 - 8) + 32LL))(v19, v20);
  return KeyValuePairs.subscript.read;
}

void KeyValuePairs.subscript.read(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 32LL);
  unint64_t v3 = *(void **)(*(void *)a1 + 8LL);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 24LL) + 8LL))( v2,  *(void *)(*(void *)a1 + 16LL));
  free(v2);
  free(v3);
  free(v1);
}

uint64_t protocol witness for Collection.indices.getter in conformance KeyValuePairs<A, B>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance KeyValuePairs<A, B>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance KeyValuePairs<A, B>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for KeyValuePairs<A, B>,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *(*a5)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, a3);
  Swift::Int result = a5(&v10, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v10;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance KeyValuePairs<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance KeyValuePairs<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance KeyValuePairs<A, B>( uint64_t a1)
{
  return KeyValuePairs.description.getter(*v1, *(void *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t KeyValuePairs.description.getter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v247 = *(void *)(a3 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  unint64_t v252 = (char *)&v229 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v246 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v229 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v11, v12, 0LL, 0LL);
  uint64_t v236 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = *(void *)(v236 + 64);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v16 = (char *)&v229 - v15;
  uint64_t v17 = swift_getTupleTypeMetadata2(0LL, a2, v3, "key value ", 0LL);
  uint64_t v18 = *(v17 - 1);
  MEMORY[0x1895F8858](v17);
  uint64_t v237 = (char *)&v229 - v19;
  unint64_t v242 = v20;
  uint64_t v240 = type metadata accessor for Optional(0LL, v20, v21, v22);
  uint64_t v239 = *(void *)(v240 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v240);
  uint64_t v241 = (char *)&v229 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v23);
  uint64_t v26 = (char *)&v229 - v25;
  Swift::Int v243 = Array._getCount()();
  if (!v243) {
    return 6109787LL;
  }
  uint64_t v234 = v16;
  uint64_t v230 = v14;
  uint64_t v27 = 0LL;
  uint64_t v257 = 91LL;
  unint64_t v258 = 0xE100000000000000LL;
  uint64_t v256 = 0LL;
  unint64_t v235 = v5 & 0xC000000000000001LL;
  uint64_t v28 = 1LL;
  __int128 v249 = xmmword_1817FFC60;
  __int128 v232 = xmmword_1817FFD10;
  __int128 v231 = xmmword_1817FFC70;
  uint64_t v233 = v5;
  uint64_t v251 = v10;
  uint64_t v245 = TupleTypeMetadata2;
  uint64_t v238 = v26;
  uint64_t v244 = v18;
  while (1)
  {
    uint64_t v250 = v28;
    if (v27 == v243)
    {
      uint64_t v31 = v241;
      unint64_t v32 = v242;
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t))(v18 + 56))(v241, 1LL, 1LL, v242);
    }

    else
    {
      BOOL v33 = v235 == 0;
      char v34 = v33 | ~_swift_isClassOrObjCExistentialType((uint64_t)TupleTypeMetadata2, (uint64_t *)TupleTypeMetadata2);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v34 & 1);
      if ((v34 & 1) != 0)
      {
        uint64_t v35 = v3;
        unint64_t v36 = v5
        unint64_t v37 = v5;
        unint64_t v38 = v234;
        (*(void (**)(char *, unint64_t, unint64_t *))(v236 + 16))( v234,  v36,  TupleTypeMetadata2);
      }

      else
      {
        unint64_t v37 = v5;
        id v168 = _ArrayBuffer._getElementSlowPath(_:)(v27, v5, (uint64_t *)TupleTypeMetadata2);
        uint64_t v169 = v168;
        if (v230 != 8)
        {
          swift_unknownObjectRelease(v168);
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }

        uint64_t v35 = v3;
        *(void *)&__int128 v255 = v168;
        unint64_t v38 = v234;
        (*(void (**)(char *, __int128 *, unint64_t *))(v236 + 16))(v234, &v255, TupleTypeMetadata2);
        swift_unknownObjectRelease(v169);
      }

      unint64_t v32 = v242;
      uint64_t v39 = v237;
      Swift::String::Index v40 = &v237[*(int *)(v242 + 48)];
      Swift::String::Index v41 = &v38[*((int *)TupleTypeMetadata2 + 12)];
      Swift::String::Index v42 = *(void (**)(char *, char *, unint64_t))(v246 + 32);
      v42(v237, v38, a2);
      unint64_t v43 = *(void (**)(char *, char *, uint64_t))(v247 + 32);
      unint64_t v44 = v41;
      uint64_t v45 = v35;
      v43(v40, v44, v35);
      uint64_t v31 = v241;
      uint64_t v46 = v39;
      uint64_t v3 = v45;
      v42(v241, v46, a2);
      v43(&v31[*(int *)(v32 + 48)], v40, v45);
      swift_bridgeObjectRetain(v37, v47, v48, v49);
      Swift::Int v50 = Array._getCount()();
      if (v50 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
      }
      uint64_t v5 = v37;
      *(void *)&__int128 v255 = 0LL;
      *((void *)&v255 + 1) = v50;
      uint64_t v52 = type metadata accessor for KeyValuePairs(0LL, a2, v45, v51);
      uint64_t WitnessTable = (const char *)swift_getWitnessTable( &protocol conformance descriptor for KeyValuePairs<A, B>,  v52,  v53);
      specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)&v256, (uint64_t)&v255, v52, WitnessTable);
      swift_bridgeObjectRelease(v37);
      if (__OFADD__(v27, 1LL))
      {
        __break(1u);
LABEL_240:
        __break(1u);
LABEL_241:
        __break(1u);
LABEL_242:
        __break(1u);
LABEL_243:
        __break(1u);
LABEL_244:
        Swift::Int v221 = String.UTF8View._foreignCount()();
        uint64_t v185 = v221 + 1;
        if (!__OFADD__(v221, 1LL))
        {
LABEL_192:
          uint64_t v186 = v3 & ~v27;
          if ((v186 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL))
          {
            int64_t v187 = _StringGuts.nativeUnusedCapacity.getter(v3, v27);
            if ((v188 & 1) != 0)
            {
LABEL_257:
              unint64_t v225 = 258LL;
            }

            else
            {
              if (v185 > 15) {
                goto LABEL_198;
              }
              if ((v27 & 0x2000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
                goto LABEL_210;
              }

              if (v187 > 0) {
                goto LABEL_198;
              }
LABEL_209:
              swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
              if ((v27 & 0x2000000000000000LL) != 0)
              {
LABEL_210:
                a2 = v27;
              }

              else if ((v27 & 0x1000000000000000LL) != 0)
              {
                uint64_t v3 = _StringGuts._foreignConvertedToSmall()(v3, v27);
                a2 = v228;
              }

              else
              {
                if ((v3 & 0x1000000000000000LL) != 0)
                {
                  uint64_t v224 = (unsigned __int8 *)((v27 & 0xFFFFFFFFFFFFFFFLL) + 32);
                }

                else
                {
                  uint64_t v224 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v27);
                  a2 = v193;
                }

                swift_bridgeObjectRetain(v27, v193, v194, v195);
                closure #1 in _StringGuts._convertedToSmall()(v224, a2, &v255);
                swift_bridgeObjectRelease(v27);
                a2 = *((void *)&v255 + 1);
                uint64_t v3 = v255;
              }

              v196._Swift::UInt64 rawBits = 65537LL;
              v197._Swift::UInt64 rawBits = 1LL;
              v198._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v197, v196, 0x5DuLL, 0xE100000000000000LL);
              if (v198._rawBits < 0x10000) {
                v198._rawBits |= 3;
              }
              unint64_t v32 = specialized String.init(_:)(v198, v199, 0x5DuLL, 0xE100000000000000LL);
              uint64_t v185 = v200;
              swift_bridgeObjectRelease(0xE100000000000000LL);
              if ((v185 & 0x2000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v185);
                goto LABEL_215;
              }

LABEL_247:
              if ((v185 & 0x1000000000000000LL) != 0)
              {
                unint64_t v32 = _StringGuts._foreignConvertedToSmall()(v32, v185);
                uint64_t v227 = v226;
                swift_bridgeObjectRelease(v185);
                uint64_t v185 = v227;
              }

              else
              {
                if ((v32 & 0x1000000000000000LL) != 0)
                {
                  uint64_t v222 = (unsigned __int8 *)((v185 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v223 = v32 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  uint64_t v222 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v32, v185);
                }

                closure #1 in _StringGuts._convertedToSmall()(v222, v223, &v255);
                swift_bridgeObjectRelease(v185);
                uint64_t v185 = *((void *)&v255 + 1);
                unint64_t v32 = v255;
              }

        if (v33 == v94) {
          goto LABEL_305;
        }
        v507 = (unsigned __int16 *)((char *)v10 + 16);
        v516 = v94;
        v521 = v9 + 1;
        while (1)
        {
          BOOL v104 = *(const char **)v33;
          if (*(_WORD *)(*(void *)v33 + 16LL) == 232)
          {
            uint64_t v105 = *((unsigned __int8 *)v104 + 18);
            if ((v105 - 1) >= 2)
            {
              if (v105 != 5 || !*((_DWORD *)v104 + 2))
              {
                BOOL v104 = 0LL;
                goto LABEL_258;
              }

              BOOL v104 = *(const char **)v104;
            }

            BOOL v104 = *(const char **)v104;
          }

LABEL_256:
              unint64_t v225 = 266LL;
            }

            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v225,  0);
          }

          if (v185 <= 15) {
            goto LABEL_209;
          }
LABEL_198:
          int64_t v189 = _StringGuts.nativeUnusedCapacity.getter(v3, v27);
          BOOL v192 = (v190 & 1) == 0 && v189 > 0;
          if ((v186 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v192) {
              goto LABEL_234;
            }
LABEL_227:
            uint64_t v214 = _StringGuts.nativeCapacity.getter(v3, v27);
            if ((v215 & 1) != 0) {
              uint64_t v216 = 0LL;
            }
            else {
              uint64_t v216 = v214;
            }
            if (v216 + 0x4000000000000000LL < 0)
            {
              __break(1u);
              goto LABEL_256;
            }

            uint64_t v217 = 2 * v216;
            if (v217 > v185) {
              uint64_t v185 = v217;
            }
          }

          else if (!v192)
          {
            goto LABEL_227;
          }

          _StringGuts.grow(_:)(v185);
LABEL_234:
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          __int128 v255 = xmmword_1817FFC80;
          uint64_t v218 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v255, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v218, v219, 1);
          swift_bridgeObjectRelease(0xE100000000000000LL);
          return v257;
        }

LABEL_246:
        __break(1u);
        goto LABEL_247;
      }

      uint64_t v256 = v27 + 1;
      uint64_t v18 = v244;
      (*(void (**)(char *, void, uint64_t, unint64_t))(v244 + 56))(v31, 0LL, 1LL, v32);
      uint64_t v10 = v251;
      uint64_t v26 = v238;
    }

    (*(void (**)(char *, char *, uint64_t))(v239 + 32))(v26, v31, v240);
    uint64_t v57 = v5;
    unint64_t v58 = &v26[*(int *)(v32 + 48)];
    unint64_t v59 = *(void (**)(char *, char *, unint64_t))(v246 + 32);
    v59(v10, v26, a2);
    uint64_t v248 = *(void (**)(char *, char *, uint64_t))(v247 + 32);
    v248(v252, v58, v3);
    if ((v250 & 1) != 0) {
      goto LABEL_82;
    }
    unint64_t v32 = v257;
    uint64_t v27 = v258;
    unint64_t v62 = HIBYTE(v258) & 0xF;
    uint64_t v63 = v257 & 0xFFFFFFFFFFFFLL;
    if ((v258 & 0x2000000000000000LL) != 0) {
      unint64_t v64 = HIBYTE(v258) & 0xF;
    }
    else {
      unint64_t v64 = v257 & 0xFFFFFFFFFFFFLL;
    }
    if (!v64 && (v257 & ~v258 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v258);
      uint64_t v257 = 8236LL;
      unint64_t v112 = 0xE200000000000000LL;
      goto LABEL_80;
    }

    if ((v258 & 0x2000000000000000LL) != 0 && v62 <= 0xD)
    {
      unint64_t v65 = 8 * (HIBYTE(v258) & 7);
      uint64_t v66 = (-255LL << v65) - 1;
      uint64_t v67 = 44LL << v65;
      char v68 = v62 + 1;
      if (v62 >= 8)
      {
        uint64_t v69 = v67 | v66 & v258;
LABEL_65:
        uint64_t v105 = (32LL << (8 * (v68 & 7u))) | ((-255LL << (8 * (v68 & 7u))) - 1) & v69;
      }

      else
      {
        unint64_t v32 = v67 | v66 & v257;
        if (v62 == 7)
        {
          char v68 = 8;
          uint64_t v69 = v258;
          goto LABEL_65;
        }

        unint64_t v32 = (32LL << (8 * (v68 & 7u))) | ((-255LL << (8 * (v68 & 7u))) - 1) & v32;
        uint64_t v105 = v258;
      }

      swift_bridgeObjectRelease(v258);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v113 = 0xE000000000000000LL;
      if (v32 & 0x8080808080808080LL | v105 & 0x80808080808080LL) {
        unint64_t v113 = 0xA000000000000000LL;
      }
      unint64_t v112 = (v113 & 0xFF00000000000000LL | (v62 << 56) | v105 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
      uint64_t v257 = v32;
LABEL_80:
      unint64_t v258 = v112;
LABEL_81:
      uint64_t v10 = v251;
      goto LABEL_82;
    }

    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v60, v61);
    if ((v27 & 0x1000000000000000LL) != 0)
    {
      Swift::Int v171 = String.UTF8View._foreignCount()();
      Swift::Int v71 = v171 + 2;
      if (__OFADD__(v171, 2LL)) {
        goto LABEL_241;
      }
    }

    else
    {
      BOOL v70 = __OFADD__(v64, 2LL);
      Swift::Int v71 = v64 + 2;
      if (v70) {
        goto LABEL_241;
      }
    }

    unint64_t v72 = v32 & ~v27;
    if ((v72 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v73 = _StringGuts.nativeUnusedCapacity.getter(v32, v27);
      if ((v74 & 1) != 0) {
        goto LABEL_257;
      }
      if (v71 > 15)
      {
LABEL_54:
        int64_t v101 = _StringGuts.nativeUnusedCapacity.getter(v32, v27);
        BOOL v104 = (v102 & 1) == 0 && v101 > 1;
        if ((v72 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v27 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v104) {
            goto LABEL_74;
          }
LABEL_67:
          uint64_t v106 = _StringGuts.nativeCapacity.getter(v32, v27);
          if ((v107 & 1) != 0) {
            uint64_t v108 = 0LL;
          }
          else {
            uint64_t v108 = v106;
          }
          if (v108 + 0x4000000000000000LL < 0) {
            goto LABEL_243;
          }
          uint64_t v109 = 2 * v108;
          if (v109 > v71) {
            Swift::Int v71 = v109;
          }
        }

        else if (!v104)
        {
          goto LABEL_67;
        }

        _StringGuts.grow(_:)(v71);
LABEL_74:
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
        __int128 v255 = v231;
        Swift::String::Index v110 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v255, 2LL);
        _StringGuts.appendInPlace(_:isASCII:)(v110, v111, 1);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        goto LABEL_81;
      }

      if ((v27 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        goto LABEL_35;
      }

      if (v73 > 1) {
        goto LABEL_54;
      }
    }

    else if (v71 > 15)
    {
      goto LABEL_54;
    }

    swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
    if ((v27 & 0x2000000000000000LL) == 0)
    {
      if ((v27 & 0x1000000000000000LL) != 0)
      {
        unint64_t v32 = _StringGuts._foreignConvertedToSmall()(v32, v27);
        unint64_t v78 = v183;
      }

      else
      {
        if ((v32 & 0x1000000000000000LL) != 0)
        {
          unint64_t v177 = (unsigned __int8 *)((v27 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          unint64_t v177 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v32, v27);
          uint64_t v63 = v75;
        }

        swift_bridgeObjectRetain(v27, v75, v76, v77);
        closure #1 in _StringGuts._convertedToSmall()(v177, v63, &v255);
        swift_bridgeObjectRelease(v27);
        unint64_t v78 = *((void *)&v255 + 1);
        unint64_t v32 = v255;
      }

      goto LABEL_36;
    }

uint64_t LazyCollectionProtocol.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 32LL))();
}

uint64_t LazyCollectionProtocol<>.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 32LL))();
}

uint64_t LazySequence<>.startIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.indices.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 184))(a1, *(void *)(a2 + 16));
}

uint64_t LazyDropWhileSequence<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = (uint64_t (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(a3 + 80))( v12,  a1,  v6,  a3);
  uint64_t v9 = v8;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a4,  v9,  AssociatedTypeWitness);
  return v7(v12, 0LL);
}

uint64_t LazySequence<>.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))(*(void *)(a1 + 16));
}

uint64_t LazySequence<>._customIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 120))(a1, *(void *)(a2 + 16));
}

uint64_t LazySequence<>._customLastIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 128))(a1, *(void *)(a2 + 16));
}

uint64_t LazySequence<>.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a4 + 136))(a1, a2, *(void *)(a3 + 16));
}

uint64_t LazySequence<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a4 + 152))(a1, a2, *(void *)(a3 + 16));
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2)
{
  return LazySequence<>.startIndex.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection.endIndex.getter in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2)
{
  return LazySequence<>.endIndex.getter(a1, *(void *)(a2 - 8));
}

void LazyDropWhileSequence<>.subscript.read(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 48LL);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 40LL) + 8LL))( v2,  *(void *)(*(void *)a1 + 32LL));
  free(v2);
  free(v1);
}

uint64_t protocol witness for Collection.indices.getter in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2)
{
  return LazySequence<>.indices.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection.isEmpty.getter in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2)
{
  return LazySequence<>.isEmpty.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection.count.getter in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2)
{
  return LazySequence<>.count.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazySequence<>._customIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection._customLastIndexOfEquatableElement(_:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazySequence<>._customLastIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 - 8));
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return LazySequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, *(void *)(a5 - 8));
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazySequence<>.index(after:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, const char *))LazySequence<>.index(after:));
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, const char *))
{
  uint64_t v7 = *(const char **)(a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v13 - v10;
  a4(a1, a2, v7);
  (*(void (**)(uint64_t, unint64_t))(v9 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v9 + 32))(a1, v11, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t, uint64_t))LazySequence<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyDropWhileSequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *(void *)(a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v13 - v10;
  a4(a1, a2, v7);
  (*(void (**)(uint64_t, unint64_t))(v9 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v9 + 32))(a1, v11, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8LL));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return LazySequence<>.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, *(void *)(*(void *)(a5 - 8) + 8LL));
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.distance(from:to:)(a1, a2, a3, *(void *)(*(void *)(a4 - 8) + 8LL));
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(*(void *)(*(void *)(a4 - 8) + 8LL) + 8LL));
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return LazySequence<>.index(_:offsetBy:limitedBy:)( a1,  a2,  a3,  a4,  *(void *)(*(void *)(*(void *)(a5 - 8) + 8LL) + 8LL));
}

uint64_t protocol witness for RandomAccessCollection.distance(from:to:) in conformance <> LazySequence<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return LazySequence<>.distance(from:to:)(a1, a2, a3, *(void *)(*(void *)(*(void *)(a4 - 8) + 8LL) + 8LL));
}

uint64_t LazySequenceProtocol.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t LazySequenceProtocol<>.lazy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t (*LazySequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazySequence.init(_base:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a3, a1);
}

uint64_t LazySequence.makeIterator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *))(v4 + 32))((char *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 32LL))(v2);
}

uint64_t LazySequence.underestimatedCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40LL))(*(void *)(a1 + 16));
}

uint64_t LazySequence._copyContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *(void *)(a4 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 32))( (char *)&v13 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v4,  v9);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a4 + 24) + 64LL))(a1, a2, a3, v9);
}

uint64_t LazySequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 48LL))(a1, *(void *)(a2 + 16));
}

uint64_t LazySequence._copyToContiguousArray()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *))(v4 + 32))((char *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 56LL))(v2);
}

uint64_t LazySequence.elements.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))(a2, v2);
}

BOOL static Unicode.UTF16._isASCII(_:)(unsigned __int16 a1)
{
  return a1 < 0x80u;
}

Swift::Bool __swiftcall _isASCII(_:)(Swift::UInt8 a1)
{
  return (a1 & 0x80) == 0;
}

Swift::Bool __swiftcall _isContinuation(_:)(Swift::UInt8 a1)
{
  return (a1 & 0xC0) == 128;
}

BOOL static Unicode.UTF8.isContinuation(_:)(char a1)
{
  return (a1 & 0xC0) == 128;
}

uint64_t Substring._wholeString.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return a3;
}

void String._withUTF8<A>(_:)(uint64_t (*a1)(void *, uint64_t), uint64_t a2, uint64_t a3, char *a4)
{
}

void Substring._withUTF8<A>(_:)( void (*a1)(char *, int64_t), uint64_t a2, uint64_t a3, char *a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
}

Swift::Bool __swiftcall _branchHint(_:expected:)(Swift::Bool _, Swift::Bool expected)
{
  return _;
}

void String._nativeCopyUTF16CodeUnits(into:range:)()
{
}

uint64_t String.UTF16View._shortHeuristic.getter()
{
  return 32LL;
}

uint64_t withExtendedLifetime<A, B>(_:_:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

{
  return a2();
}

uint64_t withUnsafePointer<A, B>(to:_:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

{
  return a2();
}

uint64_t _StringGuts.withCString<A>(_:)( void (*a1)(__objc2_class **), uint64_t a2, unint64_t a3, char *a4)
{
  if (((unint64_t)a4 & 0x1000000000000000LL) != 0
    || !((unint64_t)a4 & 0x2000000000000000LL | a3 & 0x1000000000000000LL))
  {
    return _StringGuts._slowWithCString<A>(_:)(a1, a2, a3, a4);
  }

  MEMORY[0x1895F8858](a1);
  if ((v5 & 0x2000000000000000LL) != 0)
  {
    v9[0] = v4;
    v9[1] = v5 & 0xFFFFFFFFFFFFFFLL;
    return v6(v9);
  }

  else
  {
    if ((v4 & 0x1000000000000000LL) == 0 && _StringObject.sharedUTF8.getter(v4, v5) && v8 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    return partial apply for closure #1 in _StringGuts.withCString<A>(_:)();
  }

uint64_t _IndexBox._base.getter@<X0>(uint64_t a1@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 80LL) - 8LL) + 16LL))( a1,  v1 + *(void *)(*(void *)v1 + 96LL));
}

uint64_t _IndexBox._base.setter(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(*(void *)v1 + 80LL) - 8LL) + 40LL))( v1 + *(void *)(*(void *)v1 + 96LL),  a1);
}

uint64_t (*ManagedBuffer.header.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

void _IndexBox.__deallocating_deinit()
{
}

uint64_t ManagedBuffer.headerAddress.getter()
{
  return v0 + *(void *)(*(void *)v0 + 96LL);
}

uint64_t ManagedBuffer.capacity.getter()
{
  uint64_t v1 = *v0;
  size_t v2 = _swift_stdlib_malloc_size(v0);
  uint64_t v3 = *(void *)(*(void *)(v1 + 88) - 8LL);
  uint64_t v4 = *(void *)(v3 + 72);
  if (!v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  int64_t v5 = v2
     - ((*(unsigned __int8 *)(v3 + 80) + (unint64_t)*(unsigned int *)(*v0 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
  if (v4 == -1 && v5 == 0x8000000000000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  return v5 / v4;
}

uint64_t ManagedBuffer.withUnsafeMutablePointerToHeader<A>(_:)(uint64_t (*a1)(uint64_t))
{
  return a1(v1 + *(void *)(*(void *)v1 + 96LL));
}

uint64_t ManagedBuffer.withUnsafeMutablePointerToElements<A>(_:)(uint64_t (*a1)(uint64_t))
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)v1 + 88LL) - 8LL) + 80LL);
  return a1(v1 + ((v2 + *(unsigned int *)(*(void *)v1 + 48LL)) & ~v2));
}

uint64_t ManagedBuffer.withUnsafeMutablePointers<A>(_:)(uint64_t (*a1)(uint64_t, uint64_t))
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)v1 + 88LL) - 8LL) + 80LL);
  return a1(v1 + *(void *)(*(void *)v1 + 96LL), v1 + ((v2 + *(unsigned int *)(*(void *)v1 + 48LL)) & ~v2));
}

uint64_t (*ManagedBufferPointer._nativeBuffer.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)( uint64_t a1, uint64_t a2, void (*a3)(id, uint64_t (*)(void *a1, uint64_t a2, uint64_t a3, char *a4), _BYTE *), uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v38 = a3;
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = *(void *)(v11 + 64);
  uint64_t v13 = (uint64_t *)MEMORY[0x1895F8858](a1);
  uint64_t result = static ManagedBufferPointer._checkValidBufferClass(_:creating:)(v13, 1, v14, v15);
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ManagedBufferPointer must have non-negative capacity",  52LL,  2,  "Swift/ManagedBuffer.swift",  25LL,  2,  0x14DuLL,  0);
  }
  uint64_t v17 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v18 = (v17 + 16) & ~v17;
  uint64_t v19 = v18 + v12;
  if (__OFADD__(v18, v12))
  {
    __break(1u);
    goto LABEL_16;
  }

  uint64_t v20 = *(void *)(a6 - 8);
  unint64_t v21 = *(unsigned __int8 *)(v20 + 80) + 1LL;
  BOOL v22 = __CFADD__(v19, v21);
  uint64_t v23 = v19 + v21;
  if (v22)
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }

  uint64_t v24 = *(void *)(v20 + 72);
  uint64_t v25 = a2 * v24;
  if ((unsigned __int128)(a2 * (__int128)v24) >> 64 != (a2 * v24) >> 63)
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

  uint64_t v26 = (v23 - 1) & -(uint64_t)v21;
  if (__OFADD__(v26, v25))
  {
LABEL_18:
    __break(1u);
    return result;
  }

  unint64_t v27 = v17 + 1;
  if (v21 > v27) {
    unint64_t v27 = v21;
  }
  if (v27 <= 8) {
    unint64_t v27 = 8LL;
  }
  uint64_t v28 = swift_bufferAllocate(a1, v26 + v25, v27 - 1);
  char v29 = (void *)MEMORY[0x1895F8858](v28);
  uint64_t v35 = a5;
  uint64_t v36 = a6;
  id v33 = swift_unknownObjectRetain(v29, v30, v31, v32);
  v38( v33,  partial apply for closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:),  v34);
  swift_unknownObjectRelease(v28);
  if (v6) {
    swift_unknownObjectRelease(v28);
  }
  else {
    (*(void (**)(char *, char *, uint64_t))(v11 + 32))( (char *)v28 + v18,  (char *)&v37 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL),  a5);
  }
  return (uint64_t)v28;
}

void *ManagedBufferPointer.init(bufferClass:minimumCapacity:)( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (void *)static ManagedBufferPointer._checkValidBufferClass(_:creating:)(a1, 1, a3, a4);
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ManagedBufferPointer must have non-negative capacity",  52LL,  2,  "Swift/ManagedBuffer.swift",  25LL,  2,  0x14DuLL,  0);
  }
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v11 = (v10 + 16) & ~v10;
  uint64_t v12 = *(void *)(v9 + 64);
  BOOL v13 = __OFADD__(v11, v12);
  uint64_t v14 = v11 + v12;
  if (v13)
  {
    __break(1u);
    goto LABEL_13;
  }

  uint64_t v15 = *(void *)(a4 - 8);
  unint64_t v16 = *(unsigned __int8 *)(v15 + 80) + 1LL;
  BOOL v17 = __CFADD__(v14, v16);
  uint64_t v18 = v14 + v16;
  if (v17)
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v19 = *(void *)(v15 + 72);
  uint64_t v20 = a2 * v19;
  if ((unsigned __int128)(a2 * (__int128)v19) >> 64 != (a2 * v19) >> 63)
  {
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }

  uint64_t v21 = (v18 - 1) & -(uint64_t)v16;
  if (__OFADD__(v21, v20))
  {
LABEL_15:
    __break(1u);
    return result;
  }

  unint64_t v22 = v10 + 1;
  if (v16 > v22) {
    unint64_t v22 = v16;
  }
  if (v22 <= 8) {
    unint64_t v22 = 8LL;
  }
  return swift_bufferAllocate((uint64_t)a1, v21 + v20, v22 - 1);
}

uint64_t closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)( void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  id v7 = swift_unknownObjectRetain(a1, a2, a3, a4);
  uint64_t v8 = (const void *)ManagedBufferPointer.init(unsafeBufferObject:)((unint64_t)v7, a2);
  size_t v9 = _swift_stdlib_malloc_size(v8);
  uint64_t v10 = *(void *)(a2 - 8);
  unint64_t v11 = (*(unsigned __int8 *)(v10 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = *(void *)(v10 + 64);
  uint64_t v13 = v11 + v12;
  if (__OFADD__(v11, v12))
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80) + 1LL;
  BOOL v16 = __CFADD__(v13, v15);
  uint64_t v17 = v13 + v15;
  if (v16)
  {
LABEL_10:
    __break(1u);
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }

  uint64_t v18 = *(void *)(v14 + 72);
  if (!v18) {
    goto LABEL_11;
  }
  int64_t v19 = v9 - ((v17 - 1) & -v15);
  if (v19 == 0x8000000000000000LL && v18 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  swift_release((uint64_t)a1);
  return v19 / v18;
}

unint64_t ManagedBufferPointer.init(unsafeBufferObject:)(unint64_t a1, uint64_t a2)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  _swift_getObjCClassInstanceExtents(ObjectType);
  if (v5 < 0) {
    goto LABEL_8;
  }
  if (v5 == 16) {
    goto LABEL_6;
  }
  _swift_getObjCClassInstanceExtents(ObjectType);
  if (v6 < 0) {
LABEL_8:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  uint64_t v7 = *(void *)(a2 - 8);
  unint64_t v8 = (*(unsigned __int8 *)(v7 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80);
  uint64_t v9 = *(void *)(v7 + 64);
  BOOL v10 = __OFADD__(v8, v9);
  uint64_t v11 = v8 + v9;
  if (v10)
  {
    __break(1u);
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ManagedBufferPointer buffer class has illegal stored properties",  63LL,  2,  "Swift/ManagedBuffer.swift",  25LL,  2,  0x1F5uLL,  0);
  }

  if (v6 != v11) {
    goto LABEL_11;
  }
LABEL_6:
  if ((_swift_objcClassUsesNativeSwiftReferenceCounting(ObjectType) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ManagedBufferPointer buffer class must be non-@objc",  51LL,  2,  "Swift/ManagedBuffer.swift",  25LL,  2,  0x1FDuLL,  0);
  }
  return a1;
}

uint64_t ManagedBufferPointer.capacity.getter(const void *a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = _swift_stdlib_malloc_size(a1);
  uint64_t v6 = *(void *)(a2 - 8);
  unint64_t v7 = (*(unsigned __int8 *)(v6 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = v7 + v8;
  if (__OFADD__(v7, v8))
  {
    __break(1u);
    goto LABEL_10;
  }

  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80) + 1LL;
  BOOL v12 = __CFADD__(v9, v11);
  uint64_t v13 = v9 + v11;
  if (v12)
  {
LABEL_10:
    __break(1u);
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }

  uint64_t v14 = *(void *)(v10 + 72);
  if (!v14) {
    goto LABEL_11;
  }
  int64_t v15 = v5 - ((v13 - 1) & -v11);
  if (v15 == 0x8000000000000000LL && v14 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  return v15 / v14;
}

uint64_t static ManagedBufferPointer._checkValidBufferClass(_:creating:)( uint64_t *a1, char a2, uint64_t a3, uint64_t a4)
{
  if (v8 < 0) {
    goto LABEL_10;
  }
  if (v8 == 16) {
    goto LABEL_8;
  }
  if ((a2 & 1) != 0)
  {
    uint64_t v10 = (uint64_t *)type metadata accessor for ManagedBuffer(0LL, a3, a4, v9);
    if (!swift_dynamicCastMetatype(a1, v10)) {
LABEL_13:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ManagedBufferPointer buffer class has illegal stored properties",  63LL,  2,  "Swift/ManagedBuffer.swift",  25LL,  2,  0x1F5uLL,  0);
  }

  _swift_getObjCClassInstanceExtents((uint64_t)a1);
  if (v11 < 0) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  uint64_t v12 = *(void *)(a3 - 8);
  unint64_t v13 = (*(unsigned __int8 *)(v12 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  uint64_t v14 = *(void *)(v12 + 64);
  BOOL v15 = __OFADD__(v13, v14);
  uint64_t v16 = v13 + v14;
  if (v15)
  {
    __break(1u);
    goto LABEL_13;
  }

  if (v11 != v16) {
    goto LABEL_13;
  }
LABEL_8:
  uint64_t result = _swift_objcClassUsesNativeSwiftReferenceCounting((uint64_t)a1);
  if ((result & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ManagedBufferPointer buffer class must be non-@objc",  51LL,  2,  "Swift/ManagedBuffer.swift",  25LL,  2,  0x1FDuLL,  0);
  }
  return result;
}

uint64_t static ManagedBufferPointer._elementOffset.getter(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result - 8);
  unint64_t v3 = (*(unsigned __int8 *)(v2 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80);
  uint64_t v4 = *(void *)(v2 + 64);
  BOOL v5 = __OFADD__(v3, v4);
  uint64_t v6 = v3 + v4;
  if (v5)
  {
    __break(1u);
  }

  else
  {
    uint64_t v7 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL) + 1LL;
    BOOL v8 = __CFADD__(v6, v7);
    uint64_t v9 = v6 + v7;
    if (!v8) {
      return (v9 - 1) & -v7;
    }
  }

  __break(1u);
  return result;
}

uint64_t static ManagedBufferPointer._alignmentMask.getter(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(*(void *)(a1 - 8) + 80LL);
  else {
    LODWORD(v3) = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL) + 1;
  }
  else {
    uint64_t v3 = v3;
  }
  return v3 - 1;
}

uint64_t ManagedBufferPointer.header.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))( a3,  a1 + ((*(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL)),  a2);
}

uint64_t _ss20ManagedBufferPointerVsRi__rlE6headerxvpRi__r0_lAByxq_GTK@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(a2 + a1 - 16);
  BOOL v5 = (uint64_t (*)(uint64_t *, void))ManagedBufferPointer.header.read();
  (*(void (**)(uint64_t))(*(void *)(v4 - 8) + 16LL))(a3);
  return v5(&v7, 0LL);
}

uint64_t _ss20ManagedBufferPointerVsRi__rlE6headerxvpRi__r0_lAByxq_GTk( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a4 + a3 - 16);
  type metadata accessor for ManagedBufferPointer(0LL, v5, *(void *)(a4 + a3 - 8), a4);
  uint64_t v6 = (uint64_t (*)(uint64_t *, void))ManagedBufferPointer.header.modify();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24LL))(v7, a1, v5);
  return v6(&v9, 0LL);
}

uint64_t ManagedBufferPointer._headerPointer.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL);
  return a1 + ((v2 + 16) & ~v2);
}

uint64_t ManagedBufferPointer.header.setter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 40LL))( *v2 + ((*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8LL) + 80LL)),  a1);
}

uint64_t ManagedBufferPointer._elementPointer.getter(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 - 8);
  unint64_t v4 = (*(unsigned __int8 *)(v3 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  uint64_t v5 = *(void *)(v3 + 64);
  BOOL v6 = __OFADD__(v4, v5);
  uint64_t v7 = v4 + v5;
  if (v6)
  {
    __break(1u);
  }

  else
  {
    uint64_t v8 = *(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL) + 1LL;
    BOOL v9 = __CFADD__(v7, v8);
    uint64_t v10 = v7 + v8;
    if (!v9)
    {
      result += (v10 - 1) & -v8;
      return result;
    }
  }

  __break(1u);
  return result;
}

uint64_t ManagedBufferPointer.withUnsafeMutablePointerToHeader<A>(_:)( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(a4 - 8) + 80LL);
  return a1(a3 + ((v4 + 16) & ~v4));
}

uint64_t (*ManagedBufferPointer.withUnsafeMutablePointerToElements<A>(_:)( uint64_t (*result)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t)
{
  uint64_t v5 = *(void *)(a4 - 8);
  unint64_t v6 = (*(unsigned __int8 *)(v5 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  uint64_t v7 = *(void *)(v5 + 64);
  BOOL v8 = __OFADD__(v6, v7);
  uint64_t v9 = v6 + v7;
  if (v8)
  {
    __break(1u);
  }

  else
  {
    uint64_t v10 = *(unsigned __int8 *)(*(void *)(a5 - 8) + 80LL) + 1LL;
    BOOL v11 = __CFADD__(v9, v10);
    uint64_t v12 = v9 + v10;
    if (!v11) {
      return (uint64_t (*)(uint64_t))result(a3 + ((v12 - 1) & -v10));
    }
  }

  __break(1u);
  return result;
}

uint64_t (*ManagedBufferPointer.withUnsafeMutablePointers<A>(_:)( uint64_t (*result)(unint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(unint64_t, uint64_t)
{
  uint64_t v5 = *(void *)(a4 - 8);
  unint64_t v6 = (*(unsigned __int8 *)(v5 + 80) + 16LL) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  uint64_t v7 = *(void *)(v5 + 64);
  uint64_t v8 = v6 + v7;
  if (__OFADD__(v6, v7))
  {
    __break(1u);
  }

  else
  {
    uint64_t v9 = *(unsigned __int8 *)(*(void *)(a5 - 8) + 80LL) + 1LL;
    BOOL v10 = __CFADD__(v8, v9);
    uint64_t v11 = v8 + v9;
    if (!v10) {
      return (uint64_t (*)(unint64_t, uint64_t))result(a3 + v6, a3 + ((v11 - 1) & -v9));
    }
  }

  __break(1u);
  return result;
}

uint64_t static ManagedBufferPointer._headerOffset.getter(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(*(void *)(a1 - 8) + 80LL);
  return (v1 + 16) & ~v1;
}

BOOL static ManagedBufferPointer.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance ManagedBufferPointer<A, B>( uint64_t *a1, uint64_t *a2)
{
  return static ManagedBufferPointer.== infix(_:_:)(*a1, *a2);
}

uint64_t isKnownUniquelyReferenced<A>(_:)(unint64_t *a1)
{
  return swift_isUniquelyReferenced_nonNull(*a1);
}

uint64_t isKnownUniquelyReferenced<A>(_:)(uint64_t *a1)
{
  return swift_isUniquelyReferenced(*a1);
}

uint64_t (*LazyMapSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyMapSequence.init(_base:transform:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t result = type metadata accessor for LazyMapSequence(0LL, a4, a5, a6);
  uint64_t v14 = (void *)(a7 + *(int *)(result + 44));
  *uint64_t v14 = a2;
  v14[1] = a3;
  return result;
}

uint64_t (*LazyMapSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyMapSequence._transform.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (uint64_t *)(v4 + *(int *)(a1 + 44));
  uint64_t v6 = *v5;
  swift_retain((unint64_t *)v5[1], a2, a3, a4);
  return v6;
}

uint64_t LazyMapSequence.Iterator.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 32),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a2,  v2,  AssociatedTypeWitness);
}

uint64_t LazyMapSequence.Iterator.init(_base:_transform:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, const char *a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a7,  a1,  AssociatedTypeWitness);
  uint64_t result = type metadata accessor for LazyMapSequence.Iterator(0LL, a4, a5, (uint64_t)a6);
  uint64_t v16 = (void *)(a7 + *(int *)(result + 44));
  *uint64_t v16 = a2;
  v16[1] = a3;
  return result;
}

unint64_t specialized LazyMapSequence.Iterator.next()()
{
  void (*v7)(void *__return_ptr, Swift::UInt32 *);
  uint64_t v8;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v10;
  void v11[2];
  Swift::UInt32 value;
  uint64_t v1 = v0[2];
  uint64_t v2 = v0[3];
  if (v1 >= v2)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v3 = v0[1];
    if ((v3 & 0x1000000000000000LL) != 0)
    {
      BOOL v10 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v1 << 16));
      Swift::Int scalarLength = v10.scalarLength;
      v5._value = (Swift::UInt32)v10._0;
    }

    else
    {
      if ((v3 & 0x2000000000000000LL) != 0)
      {
        v11[0] = *v0;
        v11[1] = v3 & 0xFFFFFFFFFFFFFFLL;
        v5._value = *((unsigned __int8 *)v11 + v1);
        if (*((char *)v11 + v1) < 0) {
          __asm { BR              X10 }
        }
      }

      else
      {
        if ((*v0 & 0x1000000000000000LL) != 0) {
          uint64_t v4 = (unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          uint64_t v4 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(*v0, v0[1]);
        }
        v5._value = v4[v1];
        if ((char)v4[v1] < 0) {
          __asm { BR              X11 }
        }
      }

      Swift::Int scalarLength = 1LL;
    }

    v0[2] += scalarLength;
    uint64_t v7 = (void (*)(void *__return_ptr, Swift::UInt32 *))v0[4];
    value = v5._value;
    v7(v11, &value);
    uint64_t v8 = LODWORD(v11[0]);
  }

  LOBYTE(v11[0]) = v1 >= v2;
  return v8 | ((unint64_t)(v1 >= v2) << 32);
}

{
  Swift::String::Index *v0;
  Swift::UInt64 rawBits;
  Swift::UInt64 v2;
  Swift::UInt64 v3;
  Swift::UInt64 v4;
  Swift::UInt64 v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  Swift::UInt64 v13;
  unint64_t v14;
  Swift::UInt64 v15;
  uint64_t v17;
  uint64_t v18;
  Swift::Int v19;
  Swift::Int v20;
  id v21;
  uint64_t v22;
  uint8x16_t *v23;
  uint64_t v24;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t v34;
  Swift::UInt64 v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  Swift::Int v41;
  int64_t v42;
  char *v43;
  uint64_t v44;
  Swift::Int v45;
  int v46;
  char *v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  Swift::Int v53;
  char *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  void (*v58)(unint64_t *__return_ptr, void *);
  uint64_t v59;
  Swift::String v60;
  Swift::Int v61;
  Swift::String::Index v62;
  uint64_t v63;
  uint64_t v64;
  Swift::String::Index v65;
  Swift::Int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  Swift::String::Index v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void v78[2];
  unint64_t v79;
  uint64_t v80;
  Swift::UInt64 rawBits = v0[4]._rawBits;
  uint64_t v2 = v0[1]._rawBits;
  uint64_t v3 = rawBits >> 14;
  uint64_t v4 = v2 >> 14;
  if (rawBits >> 14 == v2 >> 14) {
    return 0LL;
  }
  uint64_t v6 = v0->_rawBits;
  uint64_t v7 = v0[2]._rawBits;
  uint64_t v8 = v0[3]._rawBits;
  uint64_t v9 = (v7 >> 59) & 1;
  if ((v8 & 0x1000000000000000LL) == 0) {
    LOBYTE(v9) = 1;
  }
  BOOL v10 = v0[4]._rawBits & 0xC;
  uint64_t v11 = 4LL << v9;
  if ((rawBits & 1) == 0 || v10 == v11)
  {
    BOOL v15 = rawBits >> 14;
    unint64_t v13 = v0[4]._rawBits;
    if (v10 == v11)
    {
      unint64_t v13 = _StringGuts._slowEnsureMatchingEncoding(_:)(v0[4])._rawBits;
      BOOL v15 = v13 >> 14;
    }

    if (v15 < v6 >> 14 || v15 >= v4) {
      goto LABEL_19;
    }
    if ((v13 & 1) == 0) {
      unint64_t v13 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v13)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
    }
  }

  else
  {
    uint64_t v12 = v3 < v4 && v3 >= v6 >> 14;
    unint64_t v13 = v0[4]._rawBits;
    if (!v12)
    {
      uint64_t v14 = 143LL;
      goto LABEL_45;
    }
  }

  uint64_t v17 = (v13 >> 8) & 0x3F;
  uint64_t v18 = v13 >> 16;
  int64_t v19 = v2 >> 16;
  if (!v17)
  {
    if (v18 == v19)
    {
      uint64_t v17 = 0LL;
      goto LABEL_25;
    }

    if ((v8 & 0x1000000000000000LL) == 0)
    {
      if ((v8 & 0x2000000000000000LL) != 0)
      {
        Swift::String::Index v79 = v7;
        Swift::String::Index v80 = v8 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v45 = v18 + 1;
        if (v18 + 1 == (HIBYTE(v8) & 0xF)) {
          goto LABEL_70;
        }
        uint64_t v46 = *(unsigned __int16 *)((char *)&v79 + v18);
      }

      else
      {
        if ((v7 & 0x1000000000000000LL) != 0)
        {
          unint64_t v43 = (char *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
          unint64_t v44 = v7 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          unint64_t v43 = (char *)_StringObject.sharedUTF8.getter(v7, v8);
        }

        uint64_t v45 = v18 + 1;
        if (v18 + 1 == v44)
        {
LABEL_70:
          if (v19 >= v45) {
            int64_t v19 = v45;
          }
          if (v19 >= v18)
          {
LABEL_29:
            if ((v8 & 0x2000000000000000LL) != 0)
            {
              Swift::String::Index v79 = v7;
              Swift::String::Index v80 = v8 & 0xFFFFFFFFFFFFFFLL;
              if ((uint64_t)(HIBYTE(v8) & 0xF) >= v19)
              {
                uint64_t v24 = v19 - v18;
                if (v19 - v18 < 0) {
                  _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
                }
                uint64_t v23 = (uint8x16_t *)((char *)&v79 + v18);
                goto LABEL_36;
              }
            }

            else if ((v7 & 0x1000000000000000LL) != 0)
            {
              uint64_t v21 = (id)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
              unint64_t v22 = v7 & 0xFFFFFFFFFFFFLL;
              if ((uint64_t)(v7 & 0xFFFFFFFFFFFFLL) >= v19)
              {
LABEL_32:
                uint64_t v23 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v18, v19, (uint64_t)v21, v22);
LABEL_36:
                uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v23, v24);
                goto LABEL_37;
              }
            }

            else
            {
              uint64_t v21 = _StringObject.sharedUTF8.getter(v7, v8);
              unint64_t v22 = v61;
              if (v61 >= v19) {
                goto LABEL_32;
              }
            }

            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
          }

uint64_t specialized LazyMapSequence.Iterator.next()()
{
  void (*v18)(uint64_t *__return_ptr, void *);
  Swift::String v20;
  unint64_t v21;
  uint64_t v22;
  void v23[2];
  uint64_t v24;
  uint64_t v25;
  Swift::Int v1 = v0[2];
  if (v1 >= v0[3]) {
    return 0LL;
  }
  uint64_t v2 = *v0;
  unint64_t v3 = v0[1];
  if ((v3 & 0x1000000000000000LL) != 0)
  {
LABEL_30:
    Swift::Int v9 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v1);
    Swift::Int v6 = v9 + v1;
    uint64_t v10 = *v0;
    unint64_t v11 = v0[1];
    if ((v11 & 0x1000000000000000LL) != 0) {
      goto LABEL_31;
    }
    goto LABEL_17;
  }

  if ((v3 & 0x2000000000000000LL) != 0)
  {
    uint64_t v24 = *v0;
    uint64_t v25 = v3 & 0xFFFFFFFFFFFFFFLL;
    Swift::Int v6 = v1 + 1;
    if (v1 + 1 == (HIBYTE(v3) & 0xF)) {
      goto LABEL_16;
    }
    int v7 = *(unsigned __int16 *)((char *)&v24 + v1);
  }

  else
  {
    if ((v2 & 0x1000000000000000LL) != 0)
    {
      uint64_t v4 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v4 = (char *)_StringObject.sharedUTF8.getter(*v0, v0[1]);
    }

    Swift::Int v6 = v1 + 1;
    if (v1 + 1 == v5) {
      goto LABEL_16;
    }
    if (!v4) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    }
    int v7 = *(unsigned __int16 *)&v4[v1];
  }

  if (v7 == 2573 || (v7 & 0x8080) != 0) {
    goto LABEL_30;
  }
LABEL_16:
  Swift::Int v9 = 1LL;
  uint64_t v10 = *v0;
  unint64_t v11 = v0[1];
  if ((v11 & 0x1000000000000000LL) != 0)
  {
LABEL_31:
    uint64_t v20 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v1, v6);
    object = v20._object;
    uint64_t countAndFlagsBits = v20._countAndFlagsBits;
    goto LABEL_28;
  }

LABEL_119:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  uint64_t v53 = 0LL;
LABEL_102:
  v51 |= v53 << 8;
LABEL_103:
  uint64_t v57 = 8LL;
  if (v33) {
    uint64_t v57 = 4LL;
  }
  v0[4]._Swift::UInt64 rawBits = v29 & 2 | v57 | v51 | 1;
  unint64_t v58 = (void (*)(unint64_t *__return_ptr, void *))v0[5]._rawBits;
  v78[0] = v27;
  v78[1] = v28;
  unint64_t v59 = v28;
  v58(&v79, v78);
  swift_bridgeObjectRelease(v59);
  return v79;
}

uint64_t LazyMapSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v29 = a2;
  uint64_t v4 = *(const char **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v28 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v26 = (char *)&v26 - v7;
  uint64_t v27 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t v10 = *(void *)(v27 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v27);
  uint64_t v13 = (char *)&v26 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  BOOL v15 = (char *)&v26 - v14;
  unint64_t v16 = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  v16,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v18 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
  int64_t v19 = swift_checkMetadataState(0LL, v16);
  v18(v19, AssociatedConformanceWitness);
  uint64_t v20 = *(void (**)(char *))(v2 + *(int *)(a1 + 44));
  uint64_t v21 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
  uint64_t v22 = v28;
  v21(v13, v15, v27);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v22 + 48))(v13, 1LL, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8LL) + 56LL))( v29,  1LL,  1LL);
  }
  uint64_t v24 = v26;
  (*(void (**)(char *, char *, unint64_t))(v22 + 32))(v26, v13, AssociatedTypeWitness);
  uint64_t v25 = v29;
  v20(v24);
  (*(void (**)(char *, unint64_t))(v22 + 8))(v24, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(*(void *)(a1 + 24) - 8LL) + 56LL))( v25,  0LL,  1LL);
}

__n128 LazyMapSequence.makeIterator()@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 32))( (char *)&v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v2,  v6);
  uint64_t v9 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t, uint64_t))(v9 + 32))(v6, v9);
  uint64_t v10 = *(int *)(a1 + 44);
  uint64_t v11 = type metadata accessor for LazyMapSequence.Iterator(0LL, v6, *(void *)(a1 + 24), v9);
  __n128 result = *(__n128 *)(v3 + v10);
  *(__n128 *)(a2 + *(int *)(v11 + 4swift_endAccess((swift::runtime::SwiftTLSContext *)(v0 + 4)) = result;
  return result;
}

uint64_t LazyMapSequence.underestimatedCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 40LL))(*(void *)(a1 + 16));
}

Swift::Int specialized LazyMapSequence<>.formIndex(after:)(unint64_t *a1)
{
  unint64_t v4 = *v1;
  unint64_t v3 = v1[1];
  uint64_t v5 = v1[2];
  unint64_t v6 = v1[3];
  unint64_t rawBits = *a1;
  int v8 = (v6 & 0x1000000000000000LL) == 0 || (v5 & 0x800000000000000LL) != 0;
  unint64_t v9 = rawBits & 0xC;
  uint64_t v10 = 4LL << v8;
  unint64_t v11 = v3 >> 14;
  if ((rawBits & 2) != 0 && v9 != v10)
  {
    if (rawBits >> 14 >= v4 >> 14 && rawBits >> 14 < v11) {
      goto LABEL_27;
    }
    unint64_t v13 = 267LL;
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v13,  0);
  }

  if (v9 == v10) {
    unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  unint64_t v14 = v4 >> 14;
  if (rawBits >> 14 < v4 >> 14 || rawBits >> 14 >= v11)
  {
    unint64_t v13 = 43LL;
    goto LABEL_20;
  }

  if ((rawBits & 1) != 0)
  {
    if ((v4 & 2) != 0) {
      goto LABEL_23;
    }
  }

  else
  {
    int v39 = v8;
    char v31 = rawBits;
    v32._unint64_t rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    uint64_t v33 = v31 & 0xC;
    unint64_t v14 = v4 >> 14;
    int v8 = v39;
    unint64_t rawBits = v33 | v32._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((v4 & 2) != 0)
    {
LABEL_23:
      if ((rawBits & 2) != 0) {
        goto LABEL_27;
      }
    }
  }

  if (rawBits >> 14 != v14 && rawBits >> 14 != v11) {
    unint64_t rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(rawBits, v4, v3, v5, v6);
  }
LABEL_27:
  uint64_t v16 = (rawBits >> 8) & 0x3F;
  Swift::Int v17 = rawBits >> 16;
  int64_t v18 = v3 >> 16;
  if (v16) {
    goto LABEL_42;
  }
  if (v17 == v18)
  {
    uint64_t v16 = 0LL;
    goto LABEL_42;
  }

  if ((v6 & 0x1000000000000000LL) != 0) {
    goto LABEL_69;
  }
  if ((v6 & 0x2000000000000000LL) == 0)
  {
    if ((v5 & 0x1000000000000000LL) != 0)
    {
      int64_t v19 = (char *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v20 = v5 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      Swift::Int v37 = rawBits >> 16;
      int64_t v38 = v18;
      int64_t v19 = (char *)_StringObject.sharedUTF8.getter(v5, v6);
      int64_t v18 = v38;
      Swift::Int v17 = v37;
    }

    if (v17 + 1 == v20) {
      goto LABEL_41;
    }
    if (!v19) {
      goto LABEL_72;
    }
    int v21 = *(unsigned __int16 *)&v19[v17];
    if (v21 == 2573) {
      goto LABEL_69;
    }
LABEL_40:
    if ((v21 & 0x80808080) == 0) {
      goto LABEL_41;
    }
    goto LABEL_69;
  }

  uint64_t v40 = v5;
  uint64_t v41 = v6 & 0xFFFFFFFFFFFFFFLL;
  if (v17 + 1 == (HIBYTE(v6) & 0xF))
  {
LABEL_41:
    uint64_t v16 = 1LL;
    goto LABEL_42;
  }

  int v21 = *(unsigned __int16 *)((char *)&v40 + v17);
  if (v21 != 2573) {
    goto LABEL_40;
  }
LABEL_69:
  Swift::Int v34 = v17;
  int64_t v35 = v18;
  Swift::Int v36 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v17);
  int64_t v18 = v35;
  uint64_t v16 = v36;
  Swift::Int v17 = v34;
LABEL_42:
  uint64_t v22 = v16 + v17;
  if (v18 < v22) {
    uint64_t v22 = v18;
  }
  uint64_t v23 = v22 << 16;
  Swift::Int v24 = v22 & 0xFFFFFFFFFFFFLL;
  if ((v22 & 0xFFFFFFFFFFFFLL) == v18)
  {
    Swift::Int result = 0LL;
LABEL_61:
    v23 |= result << 8;
    goto LABEL_62;
  }

  if ((v6 & 0x1000000000000000LL) == 0)
  {
    if ((v6 & 0x2000000000000000LL) != 0)
    {
      uint64_t v40 = v5;
      uint64_t v41 = v6 & 0xFFFFFFFFFFFFFFLL;
      if (v24 + 1 == (HIBYTE(v6) & 0xF)) {
        goto LABEL_60;
      }
      int v28 = *(unsigned __int16 *)((char *)&v40 + v24);
LABEL_55:
      if (v28 == 2573 || (v28 & 0x8080) != 0) {
        goto LABEL_65;
      }
LABEL_60:
      Swift::Int result = 1LL;
      goto LABEL_61;
    }

    if ((v5 & 0x1000000000000000LL) != 0)
    {
      uint64_t v26 = (char *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v27 = v5 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v26 = (char *)_StringObject.sharedUTF8.getter(v5, v6);
    }

    if (v24 + 1 == v27) {
      goto LABEL_60;
    }
    if (v26)
    {
      int v28 = *(unsigned __int16 *)&v26[v24];
      goto LABEL_55;
    }

uint64_t LazyMapSequence<>.formIndex(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 192))(a1, *(void *)(a2 + 16));
}

uint64_t specialized LazyMapSequence<>.subscript.getter( Swift::String::Index a1, uint64_t a2, uint64_t a3, void (*a4)(void *__return_ptr, Swift::UInt32 *))
{
  v7._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)(a1)._rawBits;
  if ((a3 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v7._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
  }

  else
  {
    Swift::UInt64 v8 = v7._rawBits >> 16;
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      v12[0] = a2;
      v12[1] = a3 & 0xFFFFFFFFFFFFFFLL;
      Swift::UInt32 value = *((unsigned __int8 *)v12 + v8);
      if (*((char *)v12 + v8) < 0) {
        __asm { BR              X10 }
      }
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0) {
        unint64_t v9 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        unint64_t v9 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      Swift::UInt32 value = v9[v8];
      if ((char)v9[v8] < 0) {
        __asm { BR              X11 }
      }
    }
  }

  Swift::UInt32 v13 = value;
  a4(v12, &v13);
  return LODWORD(v12[0]);
}

uint64_t specialized LazyMapSequence<>.subscript.getter( Swift::String::Index a1, uint64_t a2, unint64_t a3, void (*a4)(uint64_t *__return_ptr, void *))
{
  v7._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)(a1)._rawBits;
  uint64_t v8 = (v7._rawBits >> 8) & 0x3F;
  int64_t v9 = v7._rawBits >> 16;
  if (v8) {
    goto LABEL_24;
  }
  uint64_t v10 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000LL) != 0) {
    uint64_t v11 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v11 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7._rawBits >> 14 != 4 * v11)
  {
    if ((a3 & 0x1000000000000000LL) != 0) {
      goto LABEL_39;
    }
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v27 = a2;
      uint64_t v28 = a3 & 0xFFFFFFFFFFFFFFLL;
      if (v9 + 1 != (HIBYTE(a3) & 0xF))
      {
        int v15 = *(unsigned __int16 *)((char *)&v27 + v9);
        if (v15 == 2573 || (v15 & 0x80808080) != 0) {
          goto LABEL_39;
        }
      }
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0) {
        Swift::UInt32 v13 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt32 v13 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      if (v9 + 1 != v10)
      {
        if (!v13) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }
        int v14 = *(unsigned __int16 *)&v13[v9];
        if (v14 == 2573 || (v14 & 0x80808080) != 0)
        {
LABEL_39:
          uint64_t v8 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9);
          int64_t v12 = v8 + v9;
          if ((a3 & 0x1000000000000000LL) == 0) {
            goto LABEL_25;
          }
LABEL_40:
          Swift::String v25 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v9, v12);
          object = v25._object;
          uint64_t countAndFlagsBits = v25._countAndFlagsBits;
          goto LABEL_34;
        }
      }
    }

    uint64_t v8 = 1LL;
LABEL_24:
    int64_t v12 = v8 + v9;
    if ((a3 & 0x1000000000000000LL) == 0) {
      goto LABEL_25;
    }
    goto LABEL_40;
  }

  uint64_t v8 = 0LL;
  int64_t v12 = v7._rawBits >> 16;
  if ((a3 & 0x1000000000000000LL) != 0) {
    goto LABEL_40;
  }
LABEL_25:
  if (v12 < v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if ((a3 & 0x2000000000000000LL) != 0)
  {
    uint64_t v27 = a2;
    uint64_t v28 = a3 & 0xFFFFFFFFFFFFFFLL;
    if ((uint64_t)(HIBYTE(a3) & 0xF) >= v12)
    {
      if (v8 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      int64_t v19 = (uint8x16_t *)((char *)&v27 + v9);
      goto LABEL_33;
    }

    goto LABEL_37;
  }

  if ((a2 & 0x1000000000000000LL) == 0)
  {
    id v17 = _StringObject.sharedUTF8.getter(a2, a3);
    uint64_t v18 = v24;
    if (v24 >= v12) {
      goto LABEL_29;
    }
LABEL_37:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  id v17 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
  uint64_t v18 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0xFFFFFFFFFFFFLL) < v12) {
    goto LABEL_37;
  }
LABEL_29:
  int64_t v19 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v9, v12, (uint64_t)v17, v18);
LABEL_33:
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v19, v8);
LABEL_34:
  uint64_t v22 = (uint64_t)object;
  v26[0] = countAndFlagsBits;
  v26[1] = object;
  a4(&v27, v26);
  swift_bridgeObjectRelease(v22);
  return v27;
}

uint64_t specialized LazyMapSequence<>.subscript.getter(Swift::UInt64 rawBits)
{
  void (*v6)(uint64_t *__return_ptr, void *);
  char v7;
  Swift::UInt64 v8;
  uint64_t v9;
  Swift::UInt64 v10;
  unint64_t v12;
  uint64_t v14;
  Swift::Int v15;
  Swift::Int v16;
  Swift::Int v17;
  Swift::Int v18;
  id v19;
  uint64_t v20;
  uint8x16_t *v21;
  uint64_t v22;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v25;
  char *v27;
  uint64_t v28;
  Swift::Int v29;
  int v30;
  Swift::String v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  Swift::Int v35;
  Swift::Int v36;
  void v37[2];
  uint64_t v38;
  uint64_t v39;
  unint64_t v2 = *v1;
  unint64_t v3 = v1[1];
  uint64_t v4 = v1[2];
  unint64_t v5 = v1[3];
  unint64_t v6 = (void (*)(uint64_t *__return_ptr, void *))v1[4];
  Swift::String::Index v7 = (v5 & 0x1000000000000000LL) == 0 || (v4 & 0x800000000000000LL) != 0;
  uint64_t v8 = rawBits & 0xC;
  int64_t v9 = 4LL << v7;
  uint64_t v10 = v3 >> 14;
  if ((rawBits & 1) != 0 && v8 != v9)
  {
    if (rawBits >> 14 >= v2 >> 14 && rawBits >> 14 < v10) {
      goto LABEL_23;
    }
    int64_t v12 = 143LL;
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v12,  0);
  }

  if (v8 == v9) {
    unint64_t rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  }
  if (rawBits >> 14 < v2 >> 14 || rawBits >> 14 >= v10)
  {
    int64_t v12 = 43LL;
    goto LABEL_20;
  }

  if ((rawBits & 1) == 0) {
    unint64_t rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  }
LABEL_23:
  int v14 = (rawBits >> 8) & 0x3F;
  int v15 = rawBits >> 16;
  uint64_t v16 = v3 >> 16;
  if (v14) {
    goto LABEL_26;
  }
  if (v15 == v16)
  {
    int v14 = 0LL;
    goto LABEL_26;
  }

  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_60;
  }
  if ((v5 & 0x2000000000000000LL) != 0)
  {
    int64_t v38 = v4;
    int v39 = v5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v29 = v15 + 1;
    if (v15 + 1 != (HIBYTE(v5) & 0xF))
    {
      uint64_t v30 = *(unsigned __int16 *)((char *)&v38 + v15);
      goto LABEL_49;
    }

uint64_t LazyMapSequence<>.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = &v15[-v10];
  int64_t v12 = *(void (**)(_BYTE *))(v3 + *(int *)(a2 + 44));
  Swift::UInt32 v13 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(a3 + 80))( v15,  a1,  v7,  a3);
  (*(void (**)(_BYTE *))(v9 + 16))(v11);
  v13(v15, 0LL);
  v12(v11);
  return (*(uint64_t (**)(_BYTE *, unint64_t))(v9 + 8))(v11, AssociatedTypeWitness);
}

unint64_t *LazyMapSequence<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a2 + 16);
  (*(void (**)(uint64_t, uint64_t))(a3 + 88))(a1, v8);
  uint64_t v9 = (uint64_t *)(v4 + *(int *)(a2 + 44));
  uint64_t v11 = *v9;
  uint64_t v10 = (unint64_t *)v9[1];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a3,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v13 = *(void *)(a2 + 24);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
  int v15 = (void *)(a4
                 + *(int *)(type metadata accessor for LazyMapSequence( 0LL,  AssociatedTypeWitness,  v13,  *(void *)(AssociatedConformanceWitness + 8))
                          + 44));
  *int v15 = v11;
  v15[1] = v10;
  return swift_retain(v10, v16, v17, v18);
}

uint64_t LazySequence<>.index(_:offsetBy:limitedBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a5 + 144))(a1, a2, a3, *(void *)(a4 + 16));
}

unint64_t specialized LazyMapSequence<>.distance(from:to:)( Swift::String::Index a1, Swift::String::Index a2, uint64_t a3)
{
  unint64_t rawBits = a1._rawBits;
  unint64_t v7 = *v3;
  unint64_t v6 = v3[1];
  uint64_t v8 = v3[2];
  unint64_t v9 = v3[3];
  char v10 = (v9 & 0x1000000000000000LL) == 0 || (v8 & 0x800000000000000LL) != 0;
  uint64_t v11 = a1._rawBits & 0xC;
  uint64_t v12 = 4LL << v10;
  Swift::UInt64 v13 = v6 >> 14;
  if ((a1._rawBits & 2) == 0 || v11 == v12)
  {
    if (v11 == v12) {
      goto LABEL_98;
    }
    goto LABEL_12;
  }

  if (a1._rawBits >> 14 < v7 >> 14 || v13 < a1._rawBits >> 14)
  {
LABEL_10:
    unint64_t v15 = 296LL;
    goto LABEL_17;
  }

uint64_t (*protocol witness for Collection.subscript.read in conformance <> LazyMapSequence<A, B>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x28uLL);
  *a1 = v8;
  v8[4] = LazyMapSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*LazyMapSequence<>.subscript.read(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = malloc(0x40uLL);
  *a1 = v8;
  uint64_t v9 = *(void *)(a3 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  v9,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = malloc(*(void *)(v11 + 64));
  uint64_t v13 = *(void *)(a3 + 24);
  v8[4] = v12;
  v8[5] = v13;
  uint64_t v14 = *(void *)(v13 - 8);
  v8[6] = v14;
  v8[7] = malloc(*(void *)(v14 + 64));
  unint64_t v15 = *(void (**)(void *))(v4 + *(int *)(a3 + 44));
  uint64_t v16 = (void (*)(void *, void))(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(a4 + 80))( v8,  a2,  v9,  a4);
  (*(void (**)(void *))(v11 + 16))(v12);
  v16(v8, 0LL);
  v15(v12);
  (*(void (**)(void *, unint64_t))(v11 + 8))(v12, AssociatedTypeWitness);
  return LazyMapSequence<>.subscript.read;
}

unint64_t *protocol witness for Collection.subscript.getter in conformance <> LazyMapSequence<A, B>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyMapSequence<>.subscript.getter(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> LazyDropWhileSequence<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a2 - 8),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v5, v6);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56LL))(a3, 1LL, 1LL, v7);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyMapSequence<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LazyMapSequence<>.formIndex(after:)(a1, a2, *(void *)(a3 - 8));
}

unint64_t *LazyMapSequence.map<A>(_:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v32 = a5;
  int v33 = a2;
  uint64_t v31 = a1;
  uint64_t v8 = *(void *)(a3 - 8);
  uint64_t v9 = *(void *)(v8 + 64);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v16, v5, v13);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v11, v5, a3);
  uint64_t v17 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v18 = (v17 + 64) & ~v17;
  uint64_t v19 = (char *)swift_allocObject((uint64_t)&unk_189B78348, v18 + v9, v17 | 7);
  uint64_t v20 = *(void *)(a3 + 24);
  uint64_t v21 = *(void *)(a3 + 32);
  *((void *)v19 + 2) = v13;
  *((void *)v19 + 3) = v20;
  *((void *)v19 + 4) = a4;
  *((void *)v19 + 5) = v21;
  uint64_t v22 = v33;
  *((void *)v19 + 6) = v31;
  *((void *)v19 + 7) = v22;
  (*(void (**)(char *, char *, uint64_t))(v8 + 32))(&v19[v18], v11, a3);
  Swift::Int v23 = *(void (**)(uint64_t, char *, uint64_t))(v14 + 32);
  uint64_t v24 = v32;
  v23(v32, v16, v13);
  uint64_t v25 = (uint64_t (**)(uint64_t))(v24
                                         + *(int *)(type metadata accessor for LazyMapSequence(0LL, v13, a4, v21) + 44));
  *uint64_t v25 = partial apply for closure #1 in LazyMapSequence.map<A>(_:);
  v25[1] = (uint64_t (*)(uint64_t))v19;
  return swift_retain(v33, v26, v27, v28);
}

uint64_t closure #1 in LazyMapSequence.map<A>(_:)( uint64_t a1, void (*a2)(char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = type metadata accessor for LazyMapSequence(0LL, v13, v14, v15);
  (*(void (**)(uint64_t))(a4 + *(int *)(v16 + 44)))(a1);
  a2(v12);
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v12, a6);
}

unint64_t *LazyMapSequence<>.map<A>(_:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7 = v6;
  uint64_t v32 = a1;
  int v33 = a2;
  uint64_t v34 = a6;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = *(void *)(v11 + 64);
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v31 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(v15 + 16);
  uint64_t v31 = *(void *)(v16 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v31 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v18, v7, v16);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, v7, a3);
  uint64_t v20 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v21 = (v20 + 64) & ~v20;
  uint64_t v22 = (char *)swift_allocObject((uint64_t)&unk_189B78370, v21 + v12, v20 | 7);
  uint64_t v23 = *(void *)(a3 + 24);
  *((void *)v22 + 2) = v16;
  *((void *)v22 + 3) = v23;
  *((void *)v22 + 4) = a4;
  *((void *)v22 + 5) = a5;
  uint64_t v24 = v33;
  *((void *)v22 + 6) = v32;
  *((void *)v22 + 7) = v24;
  (*(void (**)(char *, char *, uint64_t))(v11 + 32))(&v22[v21], v14, a3);
  uint64_t v25 = v34;
  (*(void (**)(uint64_t, char *, uint64_t))(v31 + 32))(v34, v18, v16);
  uint64_t v26 = (uint64_t (**)(uint64_t))(v25
                                         + *(int *)(type metadata accessor for LazyMapSequence( 0LL,  v16,  a4,  *(void *)(a5 + 8))
                                                  + 44));
  *uint64_t v26 = partial apply for closure #1 in LazyMapSequence<>.map<A>(_:);
  v26[1] = (uint64_t (*)(uint64_t))v22;
  return swift_retain(v24, v27, v28, v29);
}

uint64_t closure #1 in LazyMapSequence<>.map<A>(_:)( uint64_t a1, void (*a2)(char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v18 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = type metadata accessor for LazyMapSequence(0LL, v14, v15, *(void *)(v13 + 8));
  (*(void (**)(uint64_t))(a4 + *(int *)(v16 + 44)))(a1);
  a2(v12);
  return (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v12, a6);
}

uint64_t static MemoryLayout.stride(ofValue:)(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a2 - 8) + 72LL);
}

uint64_t static MemoryLayout.alignment(ofValue:)(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL) + 1LL;
}

uint64_t static MemoryLayout.offset(of:)()
{
  return AnyKeyPath._storedInlineOffset.getter();
}

uint64_t Unicode.Scalar._value.setter(uint64_t result)
{
  *Swift::Int v1 = result;
  return result;
}

uint64_t (*Unicode.Scalar._value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::UInt32 a1)
{
  BOOL v1 = HIWORD(a1) > 0x10u || a1 >> 11 == 27;
  unsigned __int8 v2 = v1;
  uint64_t v3 = a1;
  if (v1) {
    uint64_t v3 = 0LL;
  }
  return (Swift::Unicode::Scalar_optional)(v3 | ((unint64_t)v2 << 32));
}

BOOL static UInt32.< infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a1 < a2;
}

BOOL static UInt32.> infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a2 < a1;
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::UInt16 a1)
{
  if (a1 >> 11 == 27) {
    Swift::UInt16 v1 = 0;
  }
  else {
    Swift::UInt16 v1 = a1;
  }
  return (Swift::Unicode::Scalar_optional)(v1 | ((unint64_t)(a1 >> 11 == 27) << 32));
}

Swift::Unicode::Scalar __swiftcall Unicode.Scalar.init(_:)(Swift::UInt8 a1)
{
  *(_DWORD *)&a1 = a1;
  LOBYTE(result._value) = a1;
  return result;
}

Swift::String __swiftcall Unicode.Scalar.escaped(asASCII:)(Swift::Bool asASCII)
{
  unsigned int v2 = v1;
  Swift::String_optional v5 = Unicode.Scalar._escaped(asASCII:)(asASCII);
  object = v5.value._object;
  uint64_t countAndFlagsBits = v5.value._countAndFlagsBits;
  if (!v5.value._object) {
    uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v2);
  }
  result._object = object;
  result._uint64_t countAndFlagsBits = countAndFlagsBits;
  return result;
}

uint64_t lowNibbleAsHex #1 (_:) in Unicode.Scalar._escaped(asASCII:)(char a1)
{
  if ((a1 & 0xFu) >= 0xA) {
    unsigned int v1 = (a1 & 0xF) + 55;
  }
  else {
    unsigned int v1 = a1 & 0xF | 0x30;
  }
  return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v1);
}

uint64_t static UInt32.+ infix(_:_:)(int a1, int a2)
{
  BOOL v2 = __CFADD__(a1, a2);
  uint64_t result = (a1 + a2);
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t static UInt32.- infix(_:_:)(unsigned int a1, unsigned int a2)
{
  BOOL v2 = a1 >= a2;
  uint64_t result = a1 - a2;
  if (!v2) {
    __break(1u);
  }
  return result;
}

BOOL Unicode.Scalar.isASCII.getter(unsigned int a1)
{
  return a1 < 0x80;
}

uint64_t protocol witness for _ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:) in conformance Unicode.Scalar@<X0>( uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

_DWORD *protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void Unicode.Scalar.debugDescription.getter(void *a1)
{
  uint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(4LL);
  uint64_t v7 = v3;
  unint64_t object = v4;
  uint64_t v177 = v3;
  unint64_t v178 = v4;
  unint64_t v9 = HIBYTE(v4) & 0xF;
  uint64_t countAndFlagsBits = v3 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000LL) != 0) {
    uint64_t v11 = HIBYTE(v4) & 0xF;
  }
  else {
    uint64_t v11 = v3 & 0xFFFFFFFFFFFFLL;
  }
  if (!v11 && (v3 & ~v4 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v4);
    uint64_t v177 = 34LL;
    unint64_t v178 = 0xE100000000000000LL;
    goto LABEL_70;
  }

  if ((v4 & 0x2000000000000000LL) == 0 || v9 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v5, v6);
    if ((object & 0x1000000000000000LL) != 0) {
      goto LABEL_195;
    }
    BOOL v20 = __OFADD__(v11, 1LL);
    Swift::Int v21 = v11 + 1;
    if (!v20) {
      goto LABEL_18;
    }
LABEL_197:
    __break(1u);
    goto LABEL_198;
  }

  uint64_t v12 = 8 * (HIBYTE(v4) & 7);
  uint64_t v13 = (-255LL << v12) - 1;
  uint64_t v14 = 34LL << v12;
  unint64_t v15 = v14 | v13 & v4;
  uint64_t v16 = v14 | v13 & v3;
  if (v9 >= 8) {
    unint64_t v17 = v15;
  }
  else {
    unint64_t v17 = v4;
  }
  if (v9 < 8) {
    uint64_t v7 = v16;
  }
  swift_bridgeObjectRelease(v4);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  unint64_t v18 = 0xA000000000000000LL;
  if (!(v7 & 0x8080808080808080LL | v17 & 0x80808080808080LL)) {
    unint64_t v18 = 0xE000000000000000LL;
  }
  unint64_t v19 = (v18 & 0xFF00000000000000LL | (v9 << 56) | v17 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL;
  while (2)
  {
    uint64_t v177 = v7;
    unint64_t v178 = v19;
    while (1)
    {
LABEL_70:
      Swift::String_optional v61 = Unicode.Scalar._escaped(asASCII:)(1);
      if (v61.value._object)
      {
        uint64_t countAndFlagsBits = v61.value._countAndFlagsBits;
        unint64_t object = (unint64_t)v61.value._object;
        a1 = 0LL;
      }

      else
      {
        unsigned int v62 = a1;
        a1 = 0LL;
        uint64_t countAndFlagsBits = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v62);
        unint64_t object = v63;
      }

      uint64_t v7 = v177;
      unint64_t v1 = v178;
      unint64_t v64 = HIBYTE(v178) & 0xF;
      if ((v178 & 0x2000000000000000LL) != 0) {
        unint64_t v65 = HIBYTE(v178) & 0xF;
      }
      else {
        unint64_t v65 = v177 & 0xFFFFFFFFFFFFLL;
      }
      if (!v65 && (v177 & ~v178 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v178);
        uint64_t v177 = countAndFlagsBits;
        unint64_t v178 = object;
        goto LABEL_160;
      }

      uint64_t v66 = object & 0x2000000000000000LL;
      unint64_t v9 = HIBYTE(object) & 0xF;
      if ((v178 & 0x2000000000000000LL) != 0 && v66)
      {
        unint64_t v86 = v64 + v9;
        if (v64 + v9 <= 0xF)
        {
          if (v9)
          {
            char v87 = 0;
            unint64_t v88 = 0LL;
            unint64_t v89 = v178;
            do
            {
              unint64_t v90 = v64 + v88;
              unint64_t v91 = v88 + 1;
              if (v88 >= 8) {
                unint64_t v92 = object;
              }
              else {
                unint64_t v92 = countAndFlagsBits;
              }
              unint64_t v93 = v92 >> (v87 & 0x38);
              char v94 = (8 * v64 + v87) & 0x38;
              uint64_t v95 = (-255LL << v94) - 1;
              unint64_t v96 = (unint64_t)v93 << v94;
              unint64_t v97 = v96 | v95 & v89;
              unint64_t v98 = v96 | v95 & v7;
              if (v90 < 8) {
                uint64_t v7 = v98;
              }
              else {
                unint64_t v89 = v97;
              }
              v87 += 8;
              unint64_t v88 = v91;
            }

            while (v9 != v91);
          }

          else
          {
            unint64_t v89 = v178;
          }

          swift_bridgeObjectRelease(v178);
          swift_bridgeObjectRelease(object);
          unint64_t v128 = 0xA000000000000000LL;
          if (!(v7 & 0x8080808080808080LL | v89 & 0x80808080808080LL)) {
            unint64_t v128 = 0xE000000000000000LL;
          }
          uint64_t v177 = v7;
          unint64_t v178 = v128 & 0xFF00000000000000LL | (v86 << 56) | v89 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_160;
        }

        uint64_t v66 = 1LL;
      }

      a1 = (void *)(countAndFlagsBits & 0xFFFFFFFFFFFFLL);
      uint64_t v67 = v66 ? HIBYTE(object) & 0xF : countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      swift_bridgeObjectRetain_n(object, 2LL, v59, v60);
      if ((object & 0x1000000000000000LL) != 0) {
        break;
      }
      swift_bridgeObjectRetain_n(object, 4LL, v68, v69);
      Swift::Int v70 = v67;
      if ((v1 & 0x1000000000000000LL) != 0) {
        goto LABEL_192;
      }
LABEL_85:
      BOOL v20 = __OFADD__(v65, v70);
      Swift::Int v71 = v65 + v70;
      if (!v20) {
        goto LABEL_86;
      }
LABEL_194:
      __break(1u);
LABEL_195:
      Swift::Int v158 = String.UTF8View._foreignCount()();
      Swift::Int v21 = v158 + 1;
      if (__OFADD__(v158, 1LL)) {
        goto LABEL_197;
      }
LABEL_18:
      unint64_t v9 = v7 & ~object;
      if ((v9 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v7, object);
        if ((v23 & 1) != 0) {
          goto LABEL_222;
        }
        if (v21 <= 15)
        {
          if ((object & 0x2000000000000000LL) != 0) {
            goto LABEL_51;
          }
          if (v22 <= 0) {
            goto LABEL_46;
          }
        }
      }

      else if (v21 <= 15)
      {
        if ((object & 0x2000000000000000LL) != 0)
        {
LABEL_51:
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
          uint64_t countAndFlagsBits = object;
        }

        else
        {
LABEL_46:
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
          if ((object & 0x1000000000000000LL) != 0) {
            goto LABEL_217;
          }
          if ((v7 & 0x1000000000000000LL) != 0)
          {
            uint64_t v37 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            uint64_t v37 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, object);
            uint64_t countAndFlagsBits = v34;
          }

          swift_bridgeObjectRetain(object, v34, v35, v36);
          closure #1 in _StringGuts._convertedToSmall()(v37, countAndFlagsBits, v176);
          swift_bridgeObjectRelease(object);
          uint64_t countAndFlagsBits = *((void *)&v176[0] + 1);
          uint64_t v7 = *(void *)&v176[0];
        }

LABEL_222:
      unint64_t v169 = 258LL;
      goto LABEL_223;
    }

    break;
  }

  if (v71 >= 16)
  {
    unint64_t v43 = v177;
    uint64_t v7 = v178;
    goto LABEL_95;
  }

  unint64_t v1 = v178;
  if ((v178 & 0x2000000000000000LL) == 0)
  {
    uint64_t v7 = v178;
    goto LABEL_118;
  }

  int v85 = 0;
  uint64_t v7 = v178;
LABEL_138:
  a1 = 0LL;
  swift_bridgeObjectRelease_n(object, 5LL);
  unint64_t v9 = v177;
  if (v85) {
    goto LABEL_201;
  }
  while (2)
  {
    v106._unint64_t rawBits = (v175 << 16) | 1;
    v107._unint64_t rawBits = 1LL;
    v108._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v107, v106, countAndFlagsBits, object);
    if (v108._rawBits < 0x10000) {
      v108._rawBits |= 3;
    }
    unint64_t v110 = specialized String.init(_:)(v108, v109, countAndFlagsBits, object);
    unint64_t v112 = v111;
    swift_bridgeObjectRelease(object);
    if ((v112 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v112);
    }

    else if ((v112 & 0x1000000000000000LL) != 0)
    {
      unint64_t v110 = _StringGuts._foreignConvertedToSmall()(v110, v112);
      unint64_t v172 = v171;
      swift_bridgeObjectRelease(v112);
      unint64_t v112 = v172;
    }

    else
    {
      if ((v110 & 0x1000000000000000LL) != 0)
      {
        char v162 = (unsigned __int8 *)((v112 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v163 = v110 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        char v162 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v110, v112);
      }

      closure #1 in _StringGuts._convertedToSmall()(v162, v163, v176);
      if (a1) {
        goto LABEL_230;
      }
      swift_bridgeObjectRelease(v112);
      unint64_t v112 = *((void *)&v176[0] + 1);
      unint64_t v110 = *(void *)&v176[0];
    }

    uint64_t v113 = HIBYTE(v1) & 0xF;
    uint64_t v114 = HIBYTE(v112) & 0xF;
    uint64_t v115 = v114 + v113;
    if (v114)
    {
      char v116 = 0;
      unint64_t v117 = 0LL;
      do
      {
        unint64_t v118 = v113 + v117;
        unint64_t v119 = v117 + 1;
        if (v117 >= 8) {
          unint64_t v120 = v112;
        }
        else {
          unint64_t v120 = v110;
        }
        unint64_t v121 = v120 >> (v116 & 0x38);
        char v122 = (8 * v113 + v116) & 0x38;
        uint64_t v123 = (-255LL << v122) - 1;
        unint64_t v124 = (unint64_t)v121 << v122;
        unint64_t v125 = v124 | v123 & v1;
        unint64_t v126 = v124 | v123 & v9;
        if (v118 < 8) {
          unint64_t v9 = v126;
        }
        else {
          unint64_t v1 = v125;
        }
        v116 += 8;
        unint64_t v117 = v119;
      }

      while (v114 != v119);
    }

    swift_bridgeObjectRelease(v7);
    swift_bridgeObjectRelease(object);
    unint64_t v127 = 0xA000000000000000LL;
    if (!(v9 & 0x8080808080808080LL | v1 & 0x80808080808080LL)) {
      unint64_t v127 = 0xE000000000000000LL;
    }
    uint64_t v177 = v9;
    unint64_t v178 = v127 & 0xFF00000000000000LL | (v115 << 56) | v1 & 0xFFFFFFFFFFFFFFLL;
LABEL_160:
    uint64_t v7 = v177;
    unint64_t object = v178;
    if ((v178 & 0x2000000000000000LL) != 0) {
      unint64_t v129 = HIBYTE(v178) & 0xF;
    }
    else {
      unint64_t v129 = v177 & 0xFFFFFFFFFFFFLL;
    }
    if (!v129 && (v177 & ~v178 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v178);
      return;
    }

    if ((v178 & 0x2000000000000000LL) != 0 && (HIBYTE(v178) & 0xF) != 0xF)
    {
      swift_bridgeObjectRelease(v178);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return;
    }

    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v83, v84);
    if ((object & 0x1000000000000000LL) == 0)
    {
      uint64_t countAndFlagsBits = v129 + 1;
      if (!__OFADD__(v129, 1LL)) {
        goto LABEL_170;
      }
LABEL_200:
      __break(1u);
LABEL_201:
      if ((v1 & 0x1000000000000000LL) != 0)
      {
        unint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, v7);
        unint64_t v1 = v170;
      }

      else
      {
        if ((v9 & 0x1000000000000000LL) != 0)
        {
          uint64_t v160 = (unsigned __int8 *)((v1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v161 = v9 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v160 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v7);
          uint64_t v161 = v103;
        }

        swift_bridgeObjectRetain(v7, v103, v104, v105);
        closure #1 in _StringGuts._convertedToSmall()(v160, v161, v176);
        if (a1) {
          goto LABEL_230;
        }
        swift_bridgeObjectRelease(v7);
        unint64_t v1 = *((void *)&v176[0] + 1);
        unint64_t v9 = *(void *)&v176[0];
      }

      continue;
    }

    break;
  }

    Swift::Int v157 = _StringGuts._slowEnsureMatchingEncoding(_:)(v7)._rawBits;
    goto LABEL_156;
  }

  unint64_t v18 = v7._rawBits >> 16;
  v203._unint64_t rawBits = a2._rawBits;
  uint64_t v12 = a2._rawBits >> 16;
  if ((v9 & ~v10 & 0x2000000000000000LL) != 0)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL);
    unint64_t v9 = v17[2];
    uint64_t v10 = v17[3];
    if (isUniquelyReferenced_nonNull_native)
    {
      if ((v201 & 0x1000000000000000LL) == 0)
      {
        int64_t v22 = v208 >> 16;
        if ((v201 & 0x2000000000000000LL) != 0)
        {
          int64_t v24 = HIBYTE(v201) & 0xF;
          Swift::Int v221 = v200;
          uint64_t v222 = v201 & 0xFFFFFFFFFFFFFFLL;
          if (v24 < v22) {
            goto LABEL_181;
          }
          char v23 = (uint64_t *)&v221;
          goto LABEL_65;
        }

        if ((v200 & 0x1000000000000000LL) != 0)
        {
          char v23 = (uint64_t *)((v201 & 0xFFFFFFFFFFFFFFFLL) + 32);
          int64_t v24 = v200 & 0xFFFFFFFFFFFFLL;
          if ((v200 & 0xFFFFFFFFFFFFLL) < v22) {
            goto LABEL_181;
          }
LABEL_65:
          int64_t v72 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v204 >> 16, v22, (uint64_t)v23, v24);
          Swift::String::Index v39 = specialized _StringGuts.uniqueNativeReplaceSubrange(_:with:isASCII:)( v7._rawBits,  v203._rawBits,  v72,  v73);
          goto LABEL_99;
        }

        char v23 = (uint64_t *)_StringObject.sharedUTF8.getter(v200, v201);
        int64_t v24 = v180;
        if (v180 >= v22) {
          goto LABEL_65;
        }
LABEL_181:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }

      unint64_t rawBits = v208;
      Swift::Int v221 = v204;
      uint64_t v222 = v208;
      uint64_t v223 = v200;
      uint64_t v224 = v201;
      Swift::String::Index v156 = (Swift::Int)closure #3 in _StringGuts.replaceSubrange<A>(_:with:);
      unint64_t v225 = closure #3 in _StringGuts.replaceSubrange<A>(_:with:);
      uint64_t v226 = 0LL;
      swift_bridgeObjectRetain(v201, v201, v20, v21);
      uint64_t v167 = specialized FlattenSequence<>.startIndex.getter();
      unint64_t v170 = specialized FlattenSequence<>.distance(from:to:)(v167, v169, v168 & 1, v208, 0LL, 1);
      unint64_t v171 = v18 + v170;
      if (__OFADD__(v18, v170))
      {
        __break(1u);
      }

      else
      {
        unint64_t v172 = v9 & 0xFFFFFFFFFFFFLL;
        if ((v10 & 0x2000000000000000LL) != 0) {
          unint64_t v172 = HIBYTE(v10) & 0xF;
        }
        unint64_t v173 = v172 - v12;
        startingAt = v18 + v170;
        unint64_t v174 = v171 + v173;
        if (!__OFADD__(v171, v173))
        {
          unint64_t v121 = v170;
          v7._rawBits >>= 16;
          unint64_t v9 = v12;
          uint64_t v12 = v18;
          if (v174 < 16) {
            goto LABEL_214;
          }
          uint64_t v175 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v176 & 1) == 0 && v175 >= v174) {
            goto LABEL_214;
          }
          uint64_t v177 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v178 & 1) != 0)
          {
            int64_t v187 = *(void *)(v213 + 24);
            if ((v187 & 0x1000000000000000LL) != 0)
            {
              unint64_t v179 = String.UTF8View._foreignCount()();
            }

            else if ((v187 & 0x2000000000000000LL) != 0)
            {
              unint64_t v179 = HIBYTE(v187) & 0xF;
            }

            else
            {
              unint64_t v179 = *(void *)(v213 + 16) & 0xFFFFFFFFFFFFLL;
            }
          }

          else
          {
            unint64_t v179 = 2 * v177;
          }

          if (v179 <= v174) {
            uint64_t v160 = v174;
          }
          else {
            uint64_t v160 = v179;
          }
          char v188 = *(void *)(v213 + 24);
          if ((v188 & 0x1000000000000000LL) == 0)
          {
            int64_t v189 = *(void *)v8;
            if ((v188 & 0x2000000000000000LL) != 0)
            {
              BOOL v192 = (v188 >> 62) & 1;
              char v215 = v189;
              uint64_t v216 = v188 & 0xFFFFFFFFFFFFFFLL;
              char v190 = (char *)&v215;
              uint64_t v191 = HIBYTE(v188) & 0xF;
            }

            else
            {
              if ((v189 & 0x1000000000000000LL) != 0)
              {
                char v190 = (char *)((v188 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v191 = v189 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                char v190 = (char *)_StringObject.sharedUTF8.getter(v189, v188);
              }

              BOOL v192 = v189 >> 63;
            }

            uint64_t v193 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v190,  v191,  v160,  v192);
            uint64_t v194 = *(void *)(v193 + 24);
            swift_bridgeObjectRelease(*(void *)(v213 + 24));
            *(void *)(v213 + 16) = v194;
            *(void *)(v213 + 24) = v193;
            goto LABEL_213;
          }

                LOBYTE(v24) = 16;
                goto LABEL_67;
              }

              goto LABEL_230;
            case 0xBu:
              if (v11 < 0xA)
              {
                int64_t v24 = 4;
                goto LABEL_33;
              }

              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                char v25 = 4;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_225;
                }
                goto LABEL_226;
              }

              char v25 = 4;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  unint64_t v18 = 4;
                  goto LABEL_9;
                }

LABEL_186:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(countAndFlagsBits, 1LL);
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
  v176[0] = xmmword_1817FFD50;
  char v151 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)v176, 1LL);
  _StringGuts.appendInPlace(_:isASCII:)(v151, v152, 1);
  if (a1)
  {
LABEL_230:
    swift_errorRelease(a1);
    __break(1u);
    swift_errorRelease(a1);
    swift_bridgeObjectRelease(object);
    __break(1u);
  }

  else
  {
    swift_bridgeObjectRelease(0xE100000000000000LL);
  }

            swift_bridgeObjectRetain_n(a1, 5LL, v18, v19);
            v200._unint64_t rawBits = 1LL;
            v201._unint64_t rawBits = (v13 << 16) | 1;
            v202._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v200, v201, v6, a1);
            if (v202._rawBits < 0x10000) {
              v202._rawBits |= 3;
            }
            char v87 = specialized Collection.count.getter(v202, v203, v6, a1);
            swift_bridgeObjectRelease(a1);
            if ((v22 & 0x1000000000000000LL) == 0)
            {
LABEL_79:
              Swift::Int v21 = __OFADD__(v10, v87);
              unint64_t v88 = (int64_t)&v10[v87];
              if (!v21) {
                goto LABEL_80;
              }
              goto LABEL_191;
            }

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Unicode.Scalar()
{
  return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(*v0);
}

void protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Unicode.Scalar()
{
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::String a1)
{
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  unint64_t v3 = specialized Collection.first.getter(a1._countAndFlagsBits, (unint64_t)a1._object);
  if ((v3 & 0x100000000LL) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)object);
    goto LABEL_5;
  }

  unsigned int v4 = v3;
  Swift::UInt64 rawBits = specialized Collection.count.getter(countAndFlagsBits, (unint64_t)object)._rawBits;
  swift_bridgeObjectRelease((uint64_t)object);
  if (rawBits != 1)
  {
LABEL_5:
    unsigned int v4 = 0;
    unsigned __int8 v6 = 1;
    return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v6 << 32));
  }

  unsigned __int8 v6 = 0;
  return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v6 << 32));
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Unicode.Scalar( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = specialized Collection.first.getter(a1, a2);
  if ((v6 & 0x100000000LL) != 0)
  {
    swift_bridgeObjectRelease(a2);
    goto LABEL_5;
  }

  int v7 = v6;
  Swift::UInt64 rawBits = specialized Collection.count.getter(a1, a2)._rawBits;
  swift_bridgeObjectRelease(a2);
  if (rawBits != 1)
  {
LABEL_5:
    int v7 = 0;
    char v9 = 1;
    goto LABEL_6;
  }

  char v9 = 0;
LABEL_6:
  *(_DWORD *)a3 = v7;
  *(_BYTE *)(a3 + 4) = v9;
}

void Unicode.Scalar.hash(into:)(int a1, Swift::UInt32 a2)
{
}

Swift::Int Unicode.Scalar.hashValue.getter()
{
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Unicode.Scalar()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Unicode.Scalar()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Unicode.Scalar()
{
  return Hasher._finalize()();
}

Swift::Unicode::Scalar_optional __swiftcall Unicode.Scalar.init(_:)(Swift::Int a1)
{
  unint64_t v1 = HIDWORD(a1);
  unsigned int v2 = a1 - 57344;
  if (WORD1(a1) <= 0x10u) {
    Swift::Int v3 = a1;
  }
  else {
    Swift::Int v3 = 0LL;
  }
  char v4 = ((_DWORD)a1 != 55295) & __CFADD__(v2, 2049);
  if (v2 <= 0xFFFFF7FF) {
    Swift::Int v5 = v3;
  }
  else {
    Swift::Int v5 = 0LL;
  }
  if (v4) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = WORD1(a1) > 0x10u;
  }
  BOOL v7 = v1 == 0;
  if (v1) {
    Swift::Int v8 = 0LL;
  }
  else {
    Swift::Int v8 = v5;
  }
  unsigned __int8 v9 = !v7 || v6;
  return (Swift::Unicode::Scalar_optional)(v8 | ((unint64_t)v9 << 32));
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Unicode::Scalar a1)
{
  *(void *)&a1._Swift::UInt32 value = a1._value;
  LODWORD(result) = a1;
  return result;
}

BOOL static Unicode.Scalar.< infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Unicode.Scalar( _DWORD *a1, _DWORD *a2)
{
  return *a2 < *a1;
}

uint64_t Unicode.Scalar.UTF16View.value.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Unicode.Scalar.UTF16View.value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.Scalar.UTF16View.startIndex.getter()
{
  return 0LL;
}

uint64_t Unicode.Scalar.UTF16View.endIndex.getter(unsigned int a1)
{
  if (HIWORD(a1)) {
    return 2LL;
  }
  else {
    return 1LL;
  }
}

uint64_t static Unicode.UTF16.width(_:)(unsigned int a1)
{
  if (HIWORD(a1)) {
    return 2LL;
  }
  else {
    return 1LL;
  }
}

uint64_t Unicode.Scalar.UTF16View.subscript.getter(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = WORD1(a2);
  if (a1 == 1)
  {
    if (v2) {
      return a2 & 0x3FF | 0xFFFFDC00;
    }
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
  }

  if (!v2) {
    return a2;
  }
  uint64_t result = (unsigned __int16)((a2 + 67043328) >> 10) + 55296;
  if ((result & 0x10000) != 0)
  {
    __break(1u);
    goto LABEL_9;
  }

  return result;
}

uint64_t static Unicode.UTF16.trailSurrogate(_:)(unsigned int a1)
{
  if (!HIWORD(a1)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
  }
  return a1 & 0x3FF | 0xFFFFDC00;
}

uint64_t static Unicode.UTF16.leadSurrogate(_:)(unsigned int a1)
{
  if (!HIWORD(a1)) {
LABEL_4:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x43uLL,  0);
  uint64_t result = (unsigned __int16)((a1 + 67043328) >> 10) + 55296;
  if ((result & 0x10000) != 0)
  {
    __break(1u);
    goto LABEL_4;
  }

  return result;
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View( a1,  a2,  a3,  (uint64_t (*)(void, void, uint64_t))specialized RandomAccessCollection<>.distance(from:to:),  (uint64_t (*)(uint64_t, uint64_t, uint64_t))specialized RandomAccessCollection<>.index(_:offsetBy:),  a4);
}

unint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Unicode.Scalar.UTF16View@<X0>( uint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t *protocol witness for BidirectionalCollection.formIndex(before:) in conformance Unicode.Scalar.UTF16View( unint64_t *result)
{
  unint64_t v2 = *result - 1;
  if (__OFSUB__(*result, 1LL))
  {
    __break(1u);
  }

  else
  {
    if (*(_WORD *)(v1 + 2))
    {
      if (v2 >= 2) {
        goto LABEL_4;
      }
    }

    else if (*result != 1)
    {
LABEL_4:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
    }

    *unint64_t result = v2;
  }

  return result;
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Unicode.Scalar.UTF16View@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3);
  *a3 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Unicode.Scalar.UTF16View( uint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2);
}

void protocol witness for Collection.endIndex.getter in conformance Unicode.Scalar.UTF16View( uint64_t *a1@<X8>)
{
  uint64_t v2 = 1LL;
  if (*(_WORD *)(v1 + 2)) {
    uint64_t v2 = 2LL;
  }
  *a1 = v2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Unicode.Scalar.UTF16View( _WORD *a1, uint64_t *a2))()
{
  *a1 = Unicode.Scalar.UTF16View.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

uint64_t protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View@<X0>( void *a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View( a1,  (uint64_t (*)(void, void, void))specialized Collection<>.subscript.getter,  a2);
}

void protocol witness for Collection.indices.getter in conformance Unicode.Scalar.UTF16View(void *a1@<X8>)
{
  uint64_t v2 = 1LL;
  if (*(_WORD *)(v1 + 2)) {
    uint64_t v2 = 2LL;
  }
  *a1 = 0LL;
  a1[1] = v2;
}

unint64_t protocol witness for Collection.index(after:) in conformance Unicode.Scalar.UTF16View@<X0>( unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t *protocol witness for Collection.formIndex(after:) in conformance Unicode.Scalar.UTF16View( unint64_t *result)
{
  unint64_t v2 = *result;
  if (*(_WORD *)(v1 + 2))
  {
    if (v2 >= 2) {
      goto LABEL_3;
    }
  }

  else if (v2)
  {
LABEL_3:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  *unint64_t result = v2 + 1;
  return result;
}

unint64_t protocol witness for Sequence.underestimatedCount.getter in conformance Unicode.Scalar.UTF16View()
{
  if (HIWORD(*v0)) {
    unint64_t v1 = 2LL;
  }
  else {
    unint64_t v1 = 1LL;
  }
  return specialized RandomAccessCollection<>.distance(from:to:)(0LL, v1, *v0);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance Unicode.Scalar.UTF16View()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode.Scalar.UTF16View( uint64_t a1, _WORD *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t Unicode.Scalar.UTF8View.value.setter(uint64_t result)
{
  *unint64_t v1 = result;
  return result;
}

uint64_t (*Unicode.Scalar.UTF8View.value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.Scalar.UTF8View.startIndex.getter()
{
  return 0LL;
}

uint64_t Unicode.Scalar.UTF8View.endIndex.getter(unsigned int a1)
{
  uint64_t v1 = 2LL;
  uint64_t v2 = 3LL;
  if (a1 >= 0x10000) {
    uint64_t v2 = 4LL;
  }
  if (a1 > 0x7FF) {
    uint64_t v1 = v2;
  }
  if (a1 >= 0x80) {
    return v1;
  }
  else {
    return 1LL;
  }
}

uint64_t Unicode.Scalar.UTF8View.subscript.getter(unint64_t a1, unsigned int a2)
{
  if ((a1 & 0x8000000000000000LL) != 0) {
    goto LABEL_7;
  }
  if (a2 > 0x7F)
  {
    if (a2 > 0x7FF)
    {
      if (HIWORD(a2))
      {
        if (a1 < 4) {
          return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
        }
      }

      else if (a1 < 3)
      {
        return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
      }
    }

    else if (a1 < 2)
    {
      return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
    }

uint64_t _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n( unsigned int a1, uint64_t (*a2)(uint64_t *))
{
  if (a1 >= 0x80)
  {
    int v4 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v5 = (v4 | (a1 >> 6) & 0x3F) << 8;
      int v6 = (((v5 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v2 = (v5 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v2 = v6;
      }
    }

    else
    {
      unsigned int v2 = (v4 | (a1 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v2 = a1 + 1;
  }

  uint64_t v7 = (v2 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (__clz(v2) >> 3))));
  return a2(&v7);
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(uint64_t result, unint64_t *a2)
{
  uint64_t v2 = 0LL;
  int v3 = (result & 0x3F) << 8;
  unsigned int v4 = (v3 | (result >> 6)) + 33217;
  unsigned int v5 = (v3 | (result >> 6) & 0x3F) << 8;
  unsigned int v6 = (((v5 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
  unsigned int v7 = (v5 | (result >> 12)) + 8487393;
  if (WORD1(result)) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v8 = v4;
  }
  uint64_t v9 = 4 - (__clz(v8) >> 3);
  uint64_t v24 = (v8 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * v9));
  unint64_t v10 = *a2;
  do
  {
    uint64_t v21 = *((unsigned __int8 *)&v24 + v2);
    uint64_t v22 = HIBYTE(v10) & 7;
    char v23 = 8 * v22;
    if (v22 == 7)
    {
      unint64_t v11 = v10 & 0xFF00000000000000LL;
      uint64_t v12 = (v21 << v23) | v10 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v13 = a2[4] ^ v12;
      unint64_t v14 = a2[2];
      unint64_t v15 = v14 + a2[1];
      uint64_t v16 = v15 ^ __ROR8__(v14, 51);
      uint64_t v17 = a2[3] + v13;
      uint64_t v18 = v17 ^ __ROR8__(v13, 48);
      uint64_t v19 = v18 + __ROR8__(v15, 32);
      uint64_t v20 = v17 + v16;
      a2[3] = __ROR8__(v20, 32);
      a2[4] = v19 ^ __ROR8__(v18, 43);
      a2[1] = v19 ^ v12;
      a2[2] = v20 ^ __ROR8__(v16, 47);
    }

    else
    {
      unint64_t v11 = (v21 << v23) | v10;
    }

    ++v2;
    unint64_t v10 = v11 + 0x100000000000000LL;
  }

  while (v9 != v2);
  *a2 = v10;
  return result;
}

__objc2_class **specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1, uint64_t *a2)
{
  if (a1 >= 0x80)
  {
    int v7 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v8 = (v7 | (a1 >> 6) & 0x3F) << 8;
      int v9 = (((v8 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v4 = (v8 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v4 = v9;
      }
    }

    else
    {
      unsigned int v4 = (v7 | (a1 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v4 = a1 + 1;
  }

  v11[1] = v2;
  v11[2] = v3;
  unsigned int v5 = __clz(v4);
  uint64_t v10 = 4 - (v5 >> 3);
  v11[0] = (__objc2_class *)((v4 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (v5 >> 3)))));
  return specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v11, &v10, a2);
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1, uint64_t (*a2)(void))
{
  if (a1 >= 0x80)
  {
    int v8 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v9 = (v8 | (a1 >> 6) & 0x3F) << 8;
      int v10 = (((v9 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v4 = (v9 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v4 = v10;
      }
    }

    else
    {
      unsigned int v4 = (v8 | (a1 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v4 = a1 + 1;
  }

  unsigned int v5 = __clz(v4);
  uint64_t v11 = (v4 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (32 - (v5 & 0x18)));
  uint64_t result = a2();
  if (!v2)
  {
    unsigned int v7 = v5 >> 3;
    if (v7 != 3)
    {
      uint64_t result = ((uint64_t (*)(void))a2)(BYTE1(v11));
      if (v7 != 2)
      {
        uint64_t result = ((uint64_t (*)(void))a2)(BYTE2(v11));
        if (v7 != 1) {
          return ((uint64_t (*)(void))a2)(BYTE3(v11));
        }
      }
    }
  }

  return result;
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1)
{
  if (a1 >= 0x80)
  {
    int v4 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v5 = (v4 | (a1 >> 6) & 0x3F) << 8;
      int v6 = (((v5 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v1 = (v5 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v1 = v6;
      }
    }

    else
    {
      unsigned int v1 = (v4 | (a1 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v1 = a1 + 1;
  }

  unsigned int v2 = __clz(v1);
  var8.i64[0] = (v1 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (v2 >> 3))));
  return specialized static String._uncheckedFromUTF8(_:)(&var8, 4 - (v2 >> 3));
}

uint64_t specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(unsigned int a1, unint64_t a2)
{
  if (a1 >= 0x80)
  {
    int v5 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      int v6 = (v5 | (a1 >> 6) & 0x3F) << 8;
      int v7 = (((v6 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      unsigned int v2 = (v6 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1)) {
        unsigned int v2 = v7;
      }
    }

    else
    {
      unsigned int v2 = (v5 | (a1 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v2 = a1 + 1;
  }

  unint64_t v3 = 4 - (__clz(v2) >> 3);
  uint64_t v8 = (v2 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * v3));
  if ((a2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
  }
  if (v3 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }
  return *((unsigned __int8 *)&v8 + a2);
}

uint64_t Unicode.Scalar.withUTF8CodeUnits<A>(_:)( uint64_t (*a1)(uint64_t *), uint64_t a2, unsigned int a3)
{
  if (a3 >= 0x80)
  {
    int v5 = (a3 & 0x3F) << 8;
    if (a3 >= 0x800)
    {
      int v6 = (v5 | (a3 >> 6) & 0x3F) << 8;
      int v7 = (((v6 | (a3 >> 12) & 0x3F) << 8) | (a3 >> 18)) - 2122219023;
      unsigned int v3 = (v6 | (a3 >> 12)) + 8487393;
      if (HIWORD(a3)) {
        unsigned int v3 = v7;
      }
    }

    else
    {
      unsigned int v3 = (v5 | (a3 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v3 = a3 + 1;
  }

  uint64_t v8 = (v3 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (__clz(v3) >> 3))));
  return a1(&v8);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF8View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View( a1,  a2,  a3,  (uint64_t (*)(void, void, uint64_t))specialized RandomAccessCollection<>.distance(from:to:),  (uint64_t (*)(uint64_t, uint64_t, uint64_t))specialized RandomAccessCollection<>.index(_:offsetBy:),  a4);
}

unint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Unicode.Scalar.UTF8View@<X0>( uint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance Unicode.Scalar.UTF8View( uint64_t *a1)
{
  unint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v1);
  *a1 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Unicode.Scalar.UTF8View@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3);
  *a3 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Unicode.Scalar.UTF8View( unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2);
}

void protocol witness for Collection.endIndex.getter in conformance Unicode.Scalar.UTF8View( uint64_t *a1@<X8>)
{
  unsigned int v2 = *v1;
  uint64_t v3 = 2LL;
  uint64_t v4 = 3LL;
  if (*v1 >= 0x10000) {
    uint64_t v4 = 4LL;
  }
  if (v2 > 0x7FF) {
    uint64_t v3 = v4;
  }
  if (v2 >= 0x80) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = 1LL;
  }
  *a1 = v5;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Unicode.Scalar.UTF8View( _BYTE *a1, unint64_t *a2))()
{
  *a1 = Unicode.Scalar.UTF8View.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

uint64_t protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF8View@<X0>( void *a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View( a1,  (uint64_t (*)(void, void, void))specialized Collection<>.subscript.getter,  a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance Unicode.Scalar.UTF16View@<X0>( void *a1@<X0>, uint64_t (*a2)(void, void, void)@<X3>, uint64_t a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], *v3);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 16) = v7;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance Unicode.Scalar.UTF8View@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.indices.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance Unicode.Scalar.UTF16View@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, void, uint64_t)@<X5>, uint64_t (*a5)(uint64_t, uint64_t, uint64_t)@<X6>, uint64_t a6@<X8>)
{
  uint64_t v10 = *a1;
  uint64_t v11 = *v6;
  uint64_t v12 = a4(*a1, *a3, v11);
  if (a2 < 1)
  {
    if (v12 <= 0 && v12 > a2) {
      goto LABEL_4;
    }
LABEL_10:
    uint64_t result = a5(v10, a2, v11);
    char v14 = 0;
    goto LABEL_11;
  }

unint64_t protocol witness for Collection.index(after:) in conformance Unicode.Scalar.UTF8View@<X0>( unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2);
  *a2 = result;
  return result;
}

unint64_t protocol witness for Collection.formIndex(after:) in conformance Unicode.Scalar.UTF8View( unint64_t *a1)
{
  unint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v1);
  *a1 = result;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Unicode.Scalar.UTF8View(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = *v1;
  *(void *)(a1 + 8) = 0LL;
}

unint64_t protocol witness for Collection.count.getter in conformance Unicode.Scalar.UTF8View()
{
  unsigned int v1 = *v0;
  uint64_t v2 = 2LL;
  uint64_t v3 = 3LL;
  if (*v0 >= 0x10000) {
    uint64_t v3 = 4LL;
  }
  if (v1 > 0x7FF) {
    uint64_t v2 = v3;
  }
  if (v1 >= 0x80) {
    unint64_t v4 = v2;
  }
  else {
    unint64_t v4 = 1LL;
  }
  return specialized RandomAccessCollection<>.distance(from:to:)(0LL, v4, v1);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance Unicode.Scalar.UTF8View()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode.Scalar.UTF8View( uint64_t a1, _BYTE *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t static Unicode.UTF32._replacementCodeUnit.getter()
{
  return 65533LL;
}

uint64_t static Unicode.UTF8.encode(_:)(unsigned int a1)
{
  if (a1 > 0x7F)
  {
    int v3 = (a1 & 0x3F) << 8;
    int v4 = (v3 | (a1 >> 6) & 0x3F) << 8;
    int v5 = (((v4 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
    unsigned int v6 = (v4 | (a1 >> 12)) + 8487393;
    if (HIWORD(a1)) {
      unsigned int v6 = v5;
    }
    unsigned int v1 = (v3 | (a1 >> 6)) + 33217;
    if (a1 > 0x7FF) {
      return v6;
    }
  }

  else
  {
    return a1 + 1;
  }

  return v1;
}

uint64_t _ValidUTF8Buffer._bytes.getter(unsigned int a1)
{
  return (a1 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * ((4 - (__clz(a1) >> 3)) & 7)));
}

void specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)(char *a1, size_t *a2, void *a3)
{
  size_t v3 = *a2;
  if ((*a2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v5 = a3[1] & 0xFFFFFFFFFFFFFFFLL;
  specialized UnsafeMutablePointer.initialize(from:count:)( a1,  *a2,  (char *)(v5 + (*(void *)(v5 + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
  uint64_t v6 = *(void *)(v5 + 24) & 0xFFFFFFFFFFFFLL;
  if (__OFADD__(v6, v3))
  {
    __break(1u);
  }

  else
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v6 + v3, 0);
    *a3 = *(void *)(v5 + 24);
  }

__objc2_class **specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)( __objc2_class **result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  if (*a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (v3)
  {
    uint64_t v5 = (char *)result;
    uint64_t v6 = *a3;
    do
    {
      char v7 = *v5;
      unint64_t result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(v6);
      *a3 = v6;
      if ((result & 1) == 0)
      {
        unint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v6 + 16) + 1LL,  1,  v6);
        uint64_t v6 = (uint64_t)result;
        *a3 = (uint64_t)result;
      }

      unint64_t v9 = *(void *)(v6 + 16);
      unint64_t v8 = *(void *)(v6 + 24);
      if (v9 >= v8 >> 1)
      {
        unint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v8 > 1),  v9 + 1,  1,  v6);
        uint64_t v6 = (uint64_t)result;
      }

      ++v5;
      *(void *)(v6 + 16) = v9 + 1;
      *(_BYTE *)(v6 + v9 + 32) = v7;
      *a3 = v6;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t Float.customMirror.getter@<X0>(uint64_t a1@<X8>, float a2@<S0>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0LL, 0LL, a1, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Float@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0LL, 0LL, a1, *v1);
}

void Float.customPlaygroundQuickLook.getter(uint64_t a1@<X8>, float a2@<S0>)
{
  *(float *)a1 = a2;
  *(_BYTE *)(a1 + 32) = 3;
}

float protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Float@<S0>( uint64_t a1@<X8>)
{
  float result = *v1;
  *(float *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 3;
  return result;
}

uint64_t Double.customMirror.getter@<X0>(uint64_t a1@<X8>, double a2@<D0>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0LL, 0LL, a1, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Double@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(8, 0LL, 0LL, a1, *v1);
}

void Double.customPlaygroundQuickLook.getter(uint64_t a1@<X8>, double a2@<D0>)
{
  *(double *)a1 = a2;
  *(_BYTE *)(a1 + 32) = 4;
}

double protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Double@<D0>( uint64_t a1@<X8>)
{
  double result = *v1;
  *(double *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 4;
  return result;
}

uint64_t Bool.customMirror.getter@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Bool@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t Bool.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = result;
  a2[32] = 13;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Bool( _BYTE *a1@<X8>)
{
  *a1 = *v1;
  a1[32] = 13;
}

uint64_t String.customMirror.getter@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  8,  0LL,  0LL,  a5);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return protocol witness for CustomReflectable.customMirror.getter in conformance String( a1,  a2,  (uint64_t (*)(uint64_t, unint64_t, uint64_t, void, void))specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:),  a4);
}

unint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance String@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v5 = v4[1];
  *(void *)a4 = *v4;
  *(void *)(a4 + 8) = v5;
  *(_BYTE *)(a4 + 32) = 0;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

uint64_t Character.customMirror.getter@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  8,  0LL,  0LL,  a5);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Character( uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return protocol witness for CustomReflectable.customMirror.getter in conformance String( a1,  a2,  (uint64_t (*)(uint64_t, unint64_t, uint64_t, void, void))specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:),  a4);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance String( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, unint64_t, uint64_t, void, void), char *a4)
{
  uint64_t v6 = *v4;
  unint64_t v5 = v4[1];
  swift_bridgeObjectRetain(v5, a2, (uint64_t)a3, a4);
  return a3(v6, v5, 8LL, 0LL, 0LL);
}

unint64_t Character.customPlaygroundQuickLook.getter@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  *(void *)a5 = a1;
  *(void *)(a5 + 8) = a2;
  *(_BYTE *)(a5 + 32) = 0;
  return swift_bridgeObjectRetain(a2, a2, a3, a4);
}

uint64_t Unicode.Scalar.customMirror.getter@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Unicode.Scalar@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t Unicode.Scalar.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(_BYTE *)(a2 + 32) = 2;
  return result;
}

uint64_t UInt8.customMirror.getter@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt8@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t UInt8.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(_BYTE *)(a2 + 32) = 2;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt8( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 2;
}

uint64_t Int8.customMirror.getter@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int8@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t Int8.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (char)result;
  *(_BYTE *)(a2 + 32) = 1;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int8( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 1;
}

uint64_t UInt16.customMirror.getter@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt16@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t UInt16.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (unsigned __int16)result;
  *(_BYTE *)(a2 + 32) = 2;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt16( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 2;
}

uint64_t Int16.customMirror.getter@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int16@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t Int16.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (__int16)result;
  *(_BYTE *)(a2 + 32) = 1;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int16( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 1;
}

uint64_t UInt32.customMirror.getter@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt32@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t UInt32.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(_BYTE *)(a2 + 32) = 2;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt32( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 2;
}

uint64_t Int32.customMirror.getter@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int32@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t Int32.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = (int)result;
  *(_BYTE *)(a2 + 32) = 1;
  return result;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int32( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 1;
}

uint64_t UInt64.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt64@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UInt64( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 2;
}

uint64_t Int64.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int64@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Int64( uint64_t a1@<X8>)
{
  *(void *)a1 = *v1;
  *(_BYTE *)(a1 + 32) = 1;
}

uint64_t UInt.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t UInt.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(_BYTE *)(a2 + 32) = 2;
  return result;
}

uint64_t Int.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, 8, 0LL, 0LL, a2);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int@<X0>(uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, 8, 0LL, 0LL, a1);
}

uint64_t Int.customPlaygroundQuickLook.getter@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = result;
  *(_BYTE *)(a2 + 32) = 1;
  return result;
}

uint64_t UInt128.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  8,  0LL,  0LL,  a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UInt128@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( *v1,  v1[1],  8,  0LL,  0LL,  a1);
}

uint64_t Int128.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( a1,  a2,  8,  0LL,  0LL,  a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Int128@<X0>( uint64_t a1@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)( *v1,  v1[1],  8,  0LL,  0LL,  a1);
}

Swift::Bool __swiftcall _isPowerOf2(_:)(Swift::UInt a1)
{
  return a1 && (a1 & (a1 - 1)) == 0;
}

id _autorelease(_:)(void *a1)
{
  id v1 = a1;
  return swift_unknownObjectRetain(v1, v2, v3, v4);
}

Swift::String_optional __swiftcall _getFunctionFullNameFromMangledName(mangledName:)(Swift::String mangledName)
{
  id v1 = specialized _copyCollectionToContiguousArray<A>(_:)( mangledName._countAndFlagsBits,  (unint64_t)mangledName._object);
  FunctionFullNameFromMangledName = (uint8x16_t *)swift_getFunctionFullNameFromMangledName(v1 + 4, (size_t)v1[2]);
  uint64_t v4 = v3;
  swift_release((uint64_t)v1);
  if (v4)
  {
    if (v4 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    int64_t v5 = validateUTF8(_:)(FunctionFullNameFromMangledName->i64, v4);
    if ((v7 & 1) != 0) {
      uint64_t v8 = repairUTF8(_:firstKnownBrokenRange:)(FunctionFullNameFromMangledName->i8, v4, v5, v6);
    }
    else {
      uint64_t v8 = specialized static String._uncheckedFromUTF8(_:isASCII:)(FunctionFullNameFromMangledName, v4, v5 & 1);
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    unint64_t v9 = 0LL;
  }

  result.value._unint64_t object = v9;
  result.value._uint64_t countAndFlagsBits = v8;
  return result;
}

uint64_t UnsafeBufferPointer.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

BOOL static UInt.> infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 < a1;
}

uint64_t _typeName(_:qualified:)(unint64_t a1, char a2)
{
  TypeName = (uint64_t *)swift_getTypeName(a1, a2);
  if (v3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v4 = (uint8x16_t *)TypeName;
  int64_t v5 = v3;
  int64_t v6 = validateUTF8(_:)(TypeName, v3);
  if ((v8 & 1) != 0) {
    return repairUTF8(_:firstKnownBrokenRange:)(v4->i8, v5, v6, v7);
  }
  else {
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(v4, v5, v6 & 1);
  }
}

uint64_t _mangledTypeName(_:)(unint64_t a1)
{
  MangledTypeName = (uint64_t *)swift_getMangledTypeName(a1);
  if (v2 < 1) {
    return 0LL;
  }
  uint64_t v3 = (uint8x16_t *)MangledTypeName;
  int64_t v4 = v2;
  int64_t v5 = validateUTF8(_:)(MangledTypeName, v2);
  if ((v7 & 1) != 0)
  {
    repairUTF8(_:firstKnownBrokenRange:)(v3->i8, v4, v5, v6);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "repairs made to _mangledTypeName, this is not expected since names should be valid UTF-8",  88LL,  2,  "Swift/Misc.swift",  16LL,  2,  0x74uLL,  0);
  }

  return specialized static String._uncheckedFromUTF8(_:isASCII:)(v3, v4, v5 & 1);
}

uint64_t _typeByName(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2);
  uint64_t TypeByMangledNameUntrusted = swift_stdlib_getTypeByMangledNameUntrusted( (unsigned __int8 *)v2 + 32,  (unint64_t)v2[2]);
  swift_release((uint64_t)v2);
  return TypeByMangledNameUntrusted;
}

uint64_t MutableCollection.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  unint64_t v63 = a4;
  uint64_t v64 = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v56 = (char *)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v54 = (char *)&v51 - v11;
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  unint64_t v15 = (char *)&v51 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v51 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v51 - v20;
  MEMORY[0x1895F8858](v19);
  char v23 = (char *)&v51 - v22;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v60 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v25);
  uint64_t v57 = *(void *)(v60 - 8);
  uint64_t v26 = MEMORY[0x1895F8858](v60);
  char v53 = (char *)&v51 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  unint64_t v55 = (char *)&v51 - v28;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(a2, v6);
  char v29 = *(void (**)(uint64_t, uint64_t))(v6 + 72);
  uint64_t v61 = a2;
  uint64_t v62 = v4;
  uint64_t v59 = v6;
  v29(a2, v6);
  uint64_t v30 = *(void (**)(char *, char *, unint64_t))(v12 + 16);
  v30(v18, v23, AssociatedTypeWitness);
  unint64_t v52 = v21;
  v30(v15, v21, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v18,  v15,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = v12;
  uint64_t v32 = *(void (**)(char *, unint64_t))(v12 + 8);
  v32(v15, AssociatedTypeWitness);
  v32(v18, AssociatedTypeWitness);
  size_t v33 = TupleTypeMetadata2;
  uint64_t v34 = v54;
  uint64_t v35 = &v54[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v36 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
  v36(v54, v23, AssociatedTypeWitness);
  v36(v35, v52, AssociatedTypeWitness);
  uint64_t v37 = v56;
  Swift::String::Index v38 = &v56[*((int *)v33 + 12)];
  v30(v56, v34, AssociatedTypeWitness);
  v30(v38, v35, AssociatedTypeWitness);
  Swift::String::Index v39 = v53;
  v36(v53, v37, AssociatedTypeWitness);
  v32(v38, AssociatedTypeWitness);
  Swift::String::Index v40 = &v37[*((int *)v33 + 12)];
  v36(v37, v34, AssociatedTypeWitness);
  v36(v40, v35, AssociatedTypeWitness);
  uint64_t v41 = v60;
  v36(&v39[*(int *)(v60 + 36)], v40, AssociatedTypeWitness);
  v32(v37, AssociatedTypeWitness);
  uint64_t v42 = v57;
  unint64_t v43 = v55;
  (*(void (**)(char *, char *, uint64_t))(v57 + 32))(v55, v39, v41);
  uint64_t v44 = v59;
  uint64_t v46 = v61;
  uint64_t v45 = v62;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v59 + 176))(v64, v43, v61, v59);
  (*(void (**)(char *, uint64_t))(v42 + 8))(v43, v41);
  uint64_t v48 = type metadata accessor for Slice(0LL, v46, v44, v47);
  unint64_t v49 = v63;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v46 - 8) + 16LL))(&v63[*(int *)(v48 + 40)], v45, v46);
  (*(void (**)(char *, uint64_t, uint64_t))(v42 + 16))(v39, v64, v41);
  v36(v49, v39, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, char *, unint64_t))v36)( &v49[*(int *)(v48 + 36)],  &v39[*(int *)(v41 + 36)],  AssociatedTypeWitness);
}

uint64_t key path getter for MutableCollection.subscript(_:) : <A>AA@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return MutableCollection.subscript.getter(a1, *(void *)(a2 + a1 - 16), *(void *)(a2 + a1 - 8), a3);
}

uint64_t key path setter for MutableCollection.subscript(_:) : <A>AA( uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  return specialized MutableCollection<>.subscript.setter(a1, a3, *(void *)&a3[a4 - 16], *(void *)&a3[a4 - 8]);
}

uint64_t MutableCollection.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v8,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v8,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  (*(void (**)(char *, uint64_t))(*(void *)(v12 - 8) + 8LL))(a2, v12);
  uint64_t v14 = type metadata accessor for Slice(0LL, a3, (uint64_t)v8, v13);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v14 - 8) + 8LL))(a1, v14);
}

uint64_t _writeBackMutableSlice<A, B>(_:bounds:slice:)( uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v142 = a3;
  uint64_t v138 = a6;
  unint64_t v139 = a2;
  uint64_t v11 = *(void *)(a6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 8),  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v135 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v136 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v134 = (char *)&v118 - v13;
  unint64_t v14 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v11,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v14, v14, "lower upper ", 0LL);
  uint64_t v15 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v147 = (char *)&v118 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v129 = (char *)&v118 - v18;
  uint64_t v19 = *(void *)(v14 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  unint64_t v120 = (char *)&v118 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v132 = (char *)&v118 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::String::Index v140 = (char *)&v118 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  Swift::String::Index v143 = (char *)&v118 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  unint64_t v148 = (char *)&v118 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  char v131 = (char *)&v118 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  unint64_t v149 = (char *)&v118 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  int64_t v130 = (char *)&v118 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  Swift::String::Index v38 = (char *)&v118 - v37;
  uint64_t v39 = MEMORY[0x1895F8858](v36);
  uint64_t v41 = (char *)&v118 - v40;
  uint64_t v42 = MEMORY[0x1895F8858](v39);
  MEMORY[0x1895F8858](v42);
  uint64_t v44 = (char *)&v118 - v43;
  uint64_t v141 = a7;
  uint64_t v45 = a7;
  uint64_t v47 = v46;
  uint64_t v144 = a5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v45,  a5,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v127 = type metadata accessor for Range(0LL, v14, AssociatedConformanceWitness, v49);
  uint64_t v126 = *(void *)(v127 - 8);
  uint64_t v50 = MEMORY[0x1895F8858](v127);
  char v122 = (char *)&v118 - ((v51 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  unint64_t v124 = (char *)&v118 - v53;
  MEMORY[0x1895F8858](v52);
  unint64_t v55 = (char *)&v118 - ((v54 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v125 = v56;
  uint64_t v57 = *(void (**)(void))(v56 + 16);
  uint64_t v123 = v55;
  v57();
  (*(void (**)(uint64_t, uint64_t))(v11 + 64))(a4, v11);
  unint64_t v58 = *(void (**)(uint64_t, uint64_t))(v11 + 72);
  uint64_t v137 = a1;
  uint64_t v145 = v11;
  uint64_t v146 = a4;
  v58(a4, v11);
  uint64_t v59 = v19;
  uint64_t v60 = *(void (**)(char *, char *, unint64_t))(v19 + 16);
  v60(v41, v44, v14);
  unint64_t v121 = v47;
  v60(v38, v47, v14);
  uint64_t v61 = v41;
  uint64_t v62 = v38;
  unint64_t v63 = v38;
  unint64_t v64 = v14;
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v41,  v63,  v14,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v119 = AssociatedConformanceWitness;
  uint64_t v65 = v59;
  uint64_t v66 = *(void (**)(char *, unint64_t))(v59 + 8);
  v66(v62, v14);
  v66(v61, v14);
  char v150 = v60;
  uint64_t v67 = TupleTypeMetadata2;
  uint64_t v68 = v129;
  uint64_t v69 = &v129[*((int *)TupleTypeMetadata2 + 12)];
  Swift::Int v70 = *(void (**)(char *, char *, unint64_t))(v65 + 32);
  v70(v129, v44, v14);
  v70(v69, v121, v14);
  Swift::Int v71 = v147;
  int64_t v72 = &v147[*((int *)v67 + 12)];
  char v73 = v150;
  v150(v147, v68, v14);
  v73(v72, v69, v14);
  int64_t v74 = v122;
  v70(v122, v71, v14);
  v66(v72, v14);
  char v75 = &v71[*((int *)v67 + 12)];
  v70(v71, v68, v14);
  v70(v75, v69, v14);
  uint64_t v76 = v127;
  v70(&v74[*(int *)(v127 + 36)], v75, v14);
  unint64_t v147 = (char *)v66;
  v66(v71, v14);
  uint64_t v77 = v126;
  char v78 = v124;
  (*(void (**)(char *, char *, uint64_t))(v126 + 32))(v124, v74, v76);
  uint64_t v79 = v146;
  uint64_t v80 = v139;
  Swift::String::Index v81 = v123;
  (*(void (**)(char *, char *, uint64_t))(v145 + 176))(v139, v78, v146);
  (*(void (**)(char *, uint64_t))(v77 + 8))(v78, v76);
  (*(void (**)(char *, uint64_t))(v125 + 8))(v81, v79);
  size_t v82 = v130;
  uint64_t v83 = v150;
  v150(v130, v80, v14);
  unint64_t v84 = &v80[*(int *)(v76 + 36)];
  int v85 = v149;
  v83(v149, v84, v14);
  uint64_t v86 = v141;
  char v87 = v131;
  uint64_t v88 = v144;
  (*(void (**)(uint64_t, uint64_t))(v141 + 64))(v144, v141);
  unint64_t v89 = v148;
  (*(void (**)(uint64_t, uint64_t))(v86 + 72))(v88, v86);
  uint64_t v90 = *(void *)(v119 + 8);
  unint64_t v91 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v90 + 8);
  LOBYTE(v81) = v91(v82, v85, v14, v90);
  unint64_t v92 = v143;
  unint64_t v93 = v150;
  v150(v143, v89, v64);
  char v94 = (char *)v91;
  uint64_t v95 = v93;
  unint64_t v139 = v94;
  if ((v81 & 1) != 0)
  {
LABEL_6:
    ((void (*)(char *, unint64_t))v147)(v92, v64);
  }

  else
  {
    unint64_t v133 = v64;
    while (1)
    {
      char v96 = ((uint64_t (*)(char *, char *, unint64_t, uint64_t))v94)(v87, v92, v64, v90);
      ((void (*)(char *, unint64_t))v147)(v92, v64);
      if ((v96 & 1) != 0) {
        break;
      }
      unint64_t v97 = v140;
      v95(v140, v82, v64);
      uint64_t v98 = v141;
      uint64_t v99 = v144;
      uint64_t v100 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v141 + 80))(v151, v87, v144, v141);
      int64_t v101 = v87;
      size_t v102 = v134;
      (*(void (**)(char *))(v135 + 16))(v134);
      ((void (*)(char *, void))v100)(v151, 0LL);
      uint64_t v103 = v146;
      (*(void (**)(char *, char *, uint64_t))(v138 + 24))(v102, v97, v146);
      uint64_t v104 = v103;
      char v87 = v101;
      unint64_t v105 = v133;
      unint64_t v92 = v143;
      (*(void (**)(char *, uint64_t))(v145 + 192))(v82, v104);
      Swift::String::Index v106 = *(void (**)(char *, uint64_t, uint64_t))(v98 + 192);
      uint64_t v107 = v99;
      uint64_t v95 = v150;
      uint64_t v108 = v98;
      char v94 = v139;
      v106(v87, v107, v108);
      LOBYTE(v10_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  0LL,  0xE000000000000000LL,  "Swift/LegacyABI.swift",  21LL,  2,  0x50uLL, 0) = ((uint64_t (*)(char *, char *, unint64_t, uint64_t))v94)(v82, v149, v105, v90);
      unint64_t v64 = v105;
      v95(v92, v148, v105);
      if ((v100 & 1) != 0) {
        goto LABEL_6;
      }
    }
  }

  Swift::String::Index v109 = v132;
  v95(v132, v149, v64);
  if ((((uint64_t (*)(char *, char *, unint64_t, uint64_t))v94)(v82, v109, v64, v90) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Cannot replace a slice of a MutableCollection with a slice of a smaller size",  76LL,  2,  "Swift/WriteBackMutableSlice.swift",  33LL,  2,  0x29uLL,  0);
  }
  unint64_t v110 = v109;
  unint64_t v111 = (void (*)(char *, unint64_t))v147;
  ((void (*)(char *, unint64_t))v147)(v110, v64);
  unint64_t v112 = v120;
  uint64_t v146 = v90;
  uint64_t v113 = v148;
  v95(v120, v148, v64);
  uint64_t v114 = v87;
  uint64_t v115 = v140;
  v95(v140, v114, v64);
  char v116 = ((uint64_t (*)(char *, char *, unint64_t, uint64_t))v139)(v115, v112, v64, v146);
  v111(v115, v64);
  if ((v116 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Cannot replace a slice of a MutableCollection with a slice of a larger size",  75LL,  2,  "Swift/WriteBackMutableSlice.swift",  33LL,  2,  0x2CuLL,  0);
  }
  v111(v112, v64);
  v111(v113, v64);
  v111(v114, v64);
  v111(v149, v64);
  return ((uint64_t (*)(char *, unint64_t))v111)(v82, v64);
}

uint64_t (*MutableCollection.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v9 = malloc(0x58uLL);
  *a1 = v9;
  v9[1] = a4;
  void v9[2] = v4;
  *uint64_t v9 = a3;
  uint64_t v10 = *(const char **)(a4 + 8);
  uint64_t v12 = type metadata accessor for Slice(0LL, a3, (uint64_t)v10, v11);
  uint64_t v9[3] = v12;
  uint64_t v13 = *(void *)(v12 - 8);
  v9[4] = v13;
  size_t v14 = *(void *)(v13 + 64);
  v9[5] = malloc(v14);
  uint64_t v15 = (char *)malloc(v14);
  v9[6] = v15;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v10,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v19 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v18);
  v9[7] = v19;
  uint64_t v20 = *(void *)(v19 - 8);
  v9[8] = v20;
  size_t v21 = *(void *)(v20 + 64);
  v9[9] = malloc(v21);
  v9[10] = malloc(v21);
  (*(void (**)(void))(v20 + 16))();
  MutableCollection.subscript.getter(a2, a3, a4, v15);
  return MutableCollection.subscript.modify;
}

void MutableCollection<>.subscript.modify(uint64_t **a1, char a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (char *)(*a1)[9];
  uint64_t v6 = (*a1)[7];
  uint64_t v5 = (*a1)[8];
  char v7 = (void *)(*a1)[5];
  uint64_t v8 = (void *)(*a1)[6];
  uint64_t v9 = (*a1)[3];
  uint64_t v10 = (*a1)[1];
  uint64_t v11 = (*a1)[2];
  uint64_t v12 = **a1;
  uint64_t v17 = (*a1)[4];
  uint64_t v18 = (char *)(*a1)[10];
  if ((a2 & 1) != 0)
  {
    (*(void (**)(void *, void *, uint64_t))((*a1)[4] + 16))(v7, v8, v9);
    (*(void (**)(char *, char *, uint64_t))(v5 + 32))(v4, v18, v6);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v9, v13);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v11, v4, (uint64_t)v7, v12, v9, v10, WitnessTable);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v4, v6);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v17 + 8);
    v15(v7, v9);
  }

  else
  {
    uint64_t v16 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v9, a3);
    _writeBackMutableSlice<A, B>(_:bounds:slice:)(v11, v18, (uint64_t)v8, v12, v9, v10, v16);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v18, v6);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v17 + 8);
  }

  v15(v8, v9);
  free(v18);
  free(v4);
  free(v8);
  free(v7);
  free(v3);
}

void MutableCollection.subscript.getter()
{
}

void key path getter for MutableCollection.subscript(_:) : <A>AA()
{
}

void key path setter for MutableCollection.subscript(_:) : <A>AA()
{
}

uint64_t key path getter for MutableCollection<>.subscript(_:) : <A>AA@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return MutableCollection<>.subscript.getter(a1, *(void *)(a2 + a1 - 16), *(void *)(a2 + a1 - 8), a3);
}

uint64_t MutableCollection.moveSubranges(_:to:)@<X0>( uint64_t *a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  size_t v102 = a5;
  uint64_t v123 = a4;
  uint64_t v9 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v11 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v116 = (char *)&v101 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  unint64_t v128 = (char *)&v101 - v13;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v127 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v112 = *(void *)(v127 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v127);
  unint64_t v105 = (char *)&v101 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  unint64_t v121 = (char *)&v101 - v18;
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v110 = (char *)&v101 - v20;
  size_t v21 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v19);
  uint64_t v107 = (char *)&v101 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  Swift::String::Index v106 = (char *)&v101 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v113 = (char *)&v101 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  unint64_t v111 = (char *)&v101 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v114 = (char *)&v101 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v104 = (uint64_t)&v101 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v118 = (char *)&v101 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v117 = (char *)&v101 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  uint64_t v40 = (char *)&v101 - v39;
  uint64_t v41 = MEMORY[0x1895F8858](v38);
  uint64_t v125 = (uint64_t)&v101 - v42;
  MEMORY[0x1895F8858](v41);
  uint64_t v44 = (char *)&v101 - v43;
  uint64_t v120 = *a1;
  uint64_t v132 = *(void (**)(uint64_t, uint64_t))(v9 + 64);
  v132(a3, v9);
  uint64_t v45 = *(uint64_t (**)(char *, void (*)(void, void), uint64_t, uint64_t))(v9 + 152);
  uint64_t v108 = v45(v44, (void (*)(void, void))a2, a3, v9);
  uint64_t v46 = (void (*)(char *, unint64_t))v21[1];
  v46(v44, AssociatedTypeWitness);
  Swift::String::Index v109 = *(void (**)(uint64_t, uint64_t))(v9 + 72);
  v109(a3, v9);
  uint64_t v103 = v45(a2, (void (*)(void, void))v44, a3, v9);
  uint64_t v126 = v46;
  v46(v44, AssociatedTypeWitness);
  uint64_t v124 = v5;
  uint64_t v122 = a3;
  uint64_t v115 = v9;
  v132(a3, v9);
  uint64_t v47 = (void (*)(uint64_t, uint64_t))a2;
  uint64_t v48 = v40;
  uint64_t v49 = (void (*)(char *, char *, unint64_t))v21[2];
  uint64_t v50 = v117;
  v49(v117, v40, AssociatedTypeWitness);
  int64_t v130 = v47;
  uint64_t v51 = v118;
  uint64_t v132 = (void (*)(uint64_t, uint64_t))v49;
  ((void (*)(void))v49)();
  unint64_t v119 = *(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24);
  if ((v119(v50, v51, AssociatedTypeWitness) & 1) == 0) {
    goto LABEL_5;
  }
  uint64_t v52 = v126;
  v126(v51, AssociatedTypeWitness);
  v52(v50, AssociatedTypeWitness);
  uint64_t v54 = v128;
  uint64_t v53 = TupleTypeMetadata2;
  unint64_t v55 = &v128[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v56 = (void (*)(char *, char *, unint64_t))v21[4];
  v56(v128, v48, AssociatedTypeWitness);
  uint64_t v57 = (void (*)(char *, char *, unint64_t))v132;
  ((void (*)(char *, void (*)(uint64_t, uint64_t), unint64_t))v132)( v55,  v130,  AssociatedTypeWitness);
  unint64_t v58 = v116;
  uint64_t v59 = &v116[*((int *)v53 + 12)];
  v57(v116, v54, AssociatedTypeWitness);
  v57(v59, v55, AssociatedTypeWitness);
  uint64_t v60 = v121;
  v56(v121, v58, AssociatedTypeWitness);
  v52(v59, AssociatedTypeWitness);
  uint64_t v61 = &v58[*((int *)v53 + 12)];
  v56(v58, v54, AssociatedTypeWitness);
  v56(v61, v55, AssociatedTypeWitness);
  uint64_t v62 = v127;
  unint64_t v63 = &v60[*(int *)(v127 + 36)];
  uint64_t v118 = (char *)v56;
  v56(v63, v61, AssociatedTypeWitness);
  v52(v58, AssociatedTypeWitness);
  uint64_t v64 = v112;
  uint64_t v65 = (uint64_t)v110;
  unint64_t v117 = *(char **)(v112 + 32);
  uint64_t v66 = ((uint64_t (*)(char *, char *, uint64_t))v117)(v110, v60, v62);
  MEMORY[0x1895F8858](v66);
  uint64_t v67 = v122;
  uint64_t v98 = v122;
  uint64_t v99 = v123;
  uint64_t v100 = v120;
  MutableCollection._indexedStablePartition(count:range:by:)( v108,  v65,  partial apply for closure #1 in MutableCollection.moveSubranges(_:to:),  (uint64_t)(&v101 - 6),  v122,  v123,  v125);
  uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v64 + 8);
  v68(v65, v62);
  uint64_t v69 = v114;
  v109(v67, v115);
  Swift::Int v70 = v111;
  v57(v111, (char *)v130, AssociatedTypeWitness);
  Swift::Int v71 = v113;
  v57(v113, v69, AssociatedTypeWitness);
  if ((((uint64_t (*)(char *, char *, unint64_t, unint64_t))v119)( v70,  v71,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    goto LABEL_5;
  }
  int64_t v72 = v126;
  v126(v71, AssociatedTypeWitness);
  v72(v70, AssociatedTypeWitness);
  int64_t v74 = v128;
  char v73 = TupleTypeMetadata2;
  char v75 = &v128[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v76 = (void (*)(char *, char *, unint64_t))v132;
  ((void (*)(char *, void (*)(uint64_t, uint64_t), unint64_t))v132)( v128,  v130,  AssociatedTypeWitness);
  int64_t v130 = v68;
  uint64_t v77 = (void (*)(char *, char *, unint64_t))v118;
  ((void (*)(char *, char *, unint64_t))v118)(v75, v69, AssociatedTypeWitness);
  char v78 = &v58[*((int *)v73 + 12)];
  v76(v58, v74, AssociatedTypeWitness);
  v76(v78, v75, AssociatedTypeWitness);
  uint64_t v79 = v121;
  v77(v121, v58, AssociatedTypeWitness);
  v72(v78, AssociatedTypeWitness);
  uint64_t v80 = &v58[*((int *)v73 + 12)];
  v77(v58, v74, AssociatedTypeWitness);
  v77(v80, v75, AssociatedTypeWitness);
  uint64_t v81 = v127;
  v77(&v79[*(int *)(v127 + 36)], v80, AssociatedTypeWitness);
  v72(v58, AssociatedTypeWitness);
  uint64_t v82 = (uint64_t)v105;
  uint64_t v83 = ((uint64_t (*)(char *, char *, uint64_t))v117)(v105, v79, v81);
  MEMORY[0x1895F8858](v83);
  uint64_t v98 = v122;
  uint64_t v99 = v123;
  uint64_t v100 = v120;
  uint64_t v84 = v104;
  MutableCollection._indexedStablePartition(count:range:by:)( v103,  v82,  (uint64_t (*)(uint64_t))partial apply for closure #2 in MutableCollection.moveSubranges(_:to:),  (uint64_t)(&v101 - 6),  v122,  v123,  v104);
  v130(v82, v81);
  int v85 = v106;
  uint64_t v86 = (void (*)(char *, uint64_t, unint64_t))v132;
  ((void (*)(char *, uint64_t, unint64_t))v132)(v106, v125, AssociatedTypeWitness);
  char v87 = v107;
  v86(v107, v84, AssociatedTypeWitness);
  if ((((uint64_t (*)(char *, char *, unint64_t, unint64_t))v119)( v85,  v87,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
LABEL_5:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v88 = v126;
  v126(v87, AssociatedTypeWitness);
  v88(v85, AssociatedTypeWitness);
  uint64_t v90 = v128;
  unint64_t v89 = TupleTypeMetadata2;
  unint64_t v91 = &v128[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v92 = (void (*)(char *, uint64_t, unint64_t))v118;
  ((void (*)(char *, uint64_t, unint64_t))v118)(v128, v125, AssociatedTypeWitness);
  v92(v91, v84, AssociatedTypeWitness);
  unint64_t v93 = &v58[*((int *)v89 + 12)];
  char v94 = (void (*)(char *, char *, unint64_t))v132;
  ((void (*)(char *, char *, unint64_t))v132)(v58, v90, AssociatedTypeWitness);
  v94(v93, v91, AssociatedTypeWitness);
  uint64_t v95 = v102;
  v92(v102, (uint64_t)v58, AssociatedTypeWitness);
  v88(v93, AssociatedTypeWitness);
  char v96 = &v58[*((int *)v89 + 12)];
  v92(v58, (uint64_t)v90, AssociatedTypeWitness);
  v92(v96, (uint64_t)v91, AssociatedTypeWitness);
  v92(&v95[*(int *)(v127 + 36)], (uint64_t)v96, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, unint64_t))v88)(v58, AssociatedTypeWitness);
}

uint64_t RangeSet.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  return RangeSet.Ranges._contains(_:)(a1, v5) & 1;
}

uint64_t MutableCollection._swapNonemptySubrangePrefixes(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v51 = a4;
  uint64_t v52 = a2;
  uint64_t v40 = a1;
  uint64_t v9 = *(void *)(a6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  a5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v47 = a5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v38 - v16;
  MEMORY[0x1895F8858](v15);
  uint64_t v39 = v18;
  uint64_t v19 = *(void (**)(void))(v18 + 16);
  uint64_t v50 = (char *)&v38 - v20;
  v19();
  ((void (*)(uint64_t, uint64_t, unint64_t))v19)(v52, v51, AssociatedTypeWitness);
  uint64_t v48 = v9;
  uint64_t v49 = a6;
  size_t v21 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(a6 + 64);
  uint64_t v45 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 192);
  uint64_t v46 = v21;
  uint64_t v22 = (char *)(a3 + *(int *)(v13 + 36));
  unint64_t v43 = AssociatedTypeWitness;
  uint64_t v44 = v22;
  uint64_t v23 = *(void *)(AssociatedConformanceWitness + 8);
  uint64_t v41 = *(uint64_t (**)(uint64_t, char *, unint64_t, uint64_t))(v23 + 8);
  uint64_t v42 = v17;
  uint64_t v24 = v47;
  while (1)
  {
    uint64_t v25 = v50;
    uint64_t v26 = v23;
    uint64_t v27 = v13;
    uint64_t v28 = v14;
    uint64_t v29 = v52;
    v46(v50, v52, v24, v49);
    uint64_t v30 = v48;
    uint64_t v31 = v45;
    v45((uint64_t)v25, v24, v48);
    uint64_t v32 = v29;
    uint64_t v13 = v27;
    uint64_t v23 = v26;
    uint64_t v33 = v42;
    v31(v32, v24, v30);
    uint64_t v34 = v41;
    char v35 = v41((uint64_t)v25, v44, AssociatedTypeWitness, v23);
    uint64_t v14 = v28;
    (*(void (**)(char *, uint64_t, uint64_t))(v28 + 16))(v33, v51, v13);
    if ((v35 & 1) != 0) {
      break;
    }
    char v36 = v34(v52, &v33[*(int *)(v13 + 36)], AssociatedTypeWitness, v23);
    (*(void (**)(char *, uint64_t))(v28 + 8))(v33, v13);
    if ((v36 & 1) != 0) {
      return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v39 + 32))(v40, v50, AssociatedTypeWitness);
    }
  }

  (*(void (**)(char *, uint64_t))(v28 + 8))(v33, v13);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v39 + 32))(v40, v50, AssociatedTypeWitness);
}

uint64_t (*_NativeDictionary._storage.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _NativeDictionary.age.getter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

Swift::Void __swiftcall _NativeDictionary.invalidateIndices()()
{
}

uint64_t _NativeDictionary.uncheckedInitialize(at:toKey:value:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a6 - 8) + 32LL))( *(void *)(a4 + 56) + *(void *)(*(void *)(a6 - 8) + 72LL) * a1,  a3,  a6);
}

unint64_t _NativeDictionary.find(_:hashValue:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, a4);
}

uint64_t specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(uint64_t a1, char a2)
{
  uint64_t v3 = v2;
  uint64_t v5 = (int64x2_t *)*v2;
  if (*(void *)(*v2 + 24LL) > a1) {
    a1 = *(void *)(*v2 + 24LL);
  }
  uint64_t v9 = (void *)specialized static _DictionaryStorage.resize(original:capacity:move:)( a1,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<ObjectIdentifier, Int>);
  if (v5[1].i64[0])
  {
    char v30 = a2;
    uint64_t v29 = v3;
    int64_t v10 = 0LL;
    uint64_t v11 = v5 + 4;
    uint64_t v12 = 1LL << v5[2].i8[0];
    uint64_t v13 = -1LL;
    if (v12 < 64) {
      uint64_t v13 = ~(-1LL << v12);
    }
    unint64_t v14 = v13 & v5[4].i64[0];
    int64_t v15 = (unint64_t)(v12 + 63) >> 6;
    if (!v14) {
      goto LABEL_8;
    }
LABEL_7:
    unint64_t v16 = __clz(__rbit64(v14));
    v14 &= v14 - 1;
    for (unint64_t i = v16 | (v10 << 6); ; unint64_t i = __clz(__rbit64(v19)) + (v10 << 6))
    {
      uint64_t v21 = 8 * i;
      uint64_t v22 = *(void *)(v5[3].i64[0] + v21);
      uint64_t v23 = *(void *)(v5[3].i64[1] + v21);
      uint64_t v24 = specialized static Hasher._hash(seed:_:)(v9[5], v22);
      unint64_t v25 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(v22, v24);
      if ((v6 & 1) != 0) {
        goto LABEL_31;
      }
      *(void *)((char *)v9 + ((v25 >> 3) & 0x1FFFFFFFFFFFFFF8LL) + 64) |= 1LL << v25;
      uint64_t v26 = 8 * v25;
      *(void *)(v9[6] + v26) = v22;
      *(void *)(v9[7] + v26) = v23;
      ++v9[2];
      if (v14) {
        goto LABEL_7;
      }
LABEL_8:
      if (__OFADD__(v10++, 1LL)) {
        goto LABEL_30;
      }
      if (v10 >= v15) {
        break;
      }
      unint64_t v19 = v11->u64[v10];
      if (!v19)
      {
        int64_t v20 = v10 + 1;
        if (v10 + 1 >= v15) {
          break;
        }
        unint64_t v19 = v11->u64[v20];
        if (!v19)
        {
          while (1)
          {
            int64_t v10 = v20 + 1;
            if (__OFADD__(v20, 1LL)) {
              break;
            }
            if (v10 >= v15) {
              goto LABEL_21;
            }
            unint64_t v19 = v11->u64[v10];
            ++v20;
            if (v19) {
              goto LABEL_17;
            }
          }

          __break(1u);
LABEL_30:
          __break(1u);
LABEL_31:
          swift_retain((unint64_t *)v5, v6, v7, v8);
          KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for ObjectIdentifier);
        }

        ++v10;
      }

{
  int64x2_t **v2;
  int64x2_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  int64x2_t *v8;
  uint64_t v9;
  int64x2_t *v10;
  uint64_t v11;
  unint64_t v12;
  int64_t v13;
  uint64_t result;
  int64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v22;
  int64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  _OWORD *v27;
  uint64_t v28;
  _OWORD v29[2];
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v8 = (int64x2_t *)specialized static _DictionaryStorage.allocate(capacity:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_28;
  }
  uint64_t v9 = 1LL << v4[2].i8[0];
  int64_t v10 = v4 + 4;
  uint64_t v11 = -1LL;
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  uint64_t v12 = v11 & v4[4].i64[0];
  uint64_t v13 = (unint64_t)(v9 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain((unint64_t *)v4, v5, v6, v7);
  int64_t v15 = 0LL;
  while (1)
  {
    if (v12)
    {
      unint64_t v19 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      int64_t v20 = v19 | (v15 << 6);
      goto LABEL_21;
    }

    if (__OFADD__(v15++, 1LL)) {
      goto LABEL_30;
    }
    if (v15 >= v13) {
      break;
    }
    uint64_t v22 = v10->u64[v15];
    if (!v22)
    {
      uint64_t v23 = v15 + 1;
      if (v15 + 1 >= v13) {
        break;
      }
      uint64_t v22 = v10->u64[v23];
      if (!v22)
      {
        while (1)
        {
          int64_t v15 = v23 + 1;
          if (__OFADD__(v23, 1LL)) {
            break;
          }
          if (v15 >= v13) {
            goto LABEL_23;
          }
          uint64_t v22 = v10->u64[v15];
          ++v23;
          if (v22) {
            goto LABEL_20;
          }
        }

        __break(1u);
LABEL_30:
        __break(1u);
        return result;
      }

      ++v15;
    }

{
  int64x2_t **v2;
  int64x2_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  int64x2_t *v8;
  uint64_t v9;
  int64x2_t *v10;
  uint64_t v11;
  unint64_t v12;
  int64_t v13;
  uint64_t result;
  int64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v19;
  int64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _OWORD v25[2];
  __int128 v26[2];
  uint64_t v27;
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v8 = (int64x2_t *)specialized static _DictionaryStorage.allocate(capacity:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_28;
  }
  uint64_t v9 = 1LL << v4[2].i8[0];
  int64_t v10 = v4 + 4;
  uint64_t v11 = -1LL;
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  uint64_t v12 = v11 & v4[4].i64[0];
  uint64_t v13 = (unint64_t)(v9 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain((unint64_t *)v4, v5, v6, v7);
  int64_t v15 = 0LL;
  while (1)
  {
    if (v12)
    {
      unint64_t v16 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      uint64_t v17 = v16 | (v15 << 6);
      goto LABEL_21;
    }

    if (__OFADD__(v15++, 1LL)) {
      goto LABEL_30;
    }
    if (v15 >= v13) {
      break;
    }
    unint64_t v19 = v10->u64[v15];
    if (!v19)
    {
      int64_t v20 = v15 + 1;
      if (v15 + 1 >= v13) {
        break;
      }
      unint64_t v19 = v10->u64[v20];
      if (!v19)
      {
        while (1)
        {
          int64_t v15 = v20 + 1;
          if (__OFADD__(v20, 1LL)) {
            break;
          }
          if (v15 >= v13) {
            goto LABEL_23;
          }
          unint64_t v19 = v10->u64[v15];
          ++v20;
          if (v19) {
            goto LABEL_20;
          }
        }

        __break(1u);
LABEL_30:
        __break(1u);
        return result;
      }

      ++v15;
    }

{
  void *v2;
  void *v3;
  int64x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  void *v9;
  int64_t v10;
  int64x2_t *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int64_t v15;
  unint64_t v16;
  unint64_t i;
  unint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  void *v29;
  char v30;
  uint64_t v3 = v2;
  uint64_t v5 = (int64x2_t *)*v2;
  if (*(void *)(*v2 + 24LL) > a1) {
    a1 = *(void *)(*v2 + 24LL);
  }
  uint64_t v9 = (void *)specialized static _DictionaryStorage.resize(original:capacity:move:)( a1,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
  if (v5[1].i64[0])
  {
    char v30 = a2;
    uint64_t v29 = v3;
    int64_t v10 = 0LL;
    uint64_t v11 = v5 + 4;
    uint64_t v12 = 1LL << v5[2].i8[0];
    uint64_t v13 = -1LL;
    if (v12 < 64) {
      uint64_t v13 = ~(-1LL << v12);
    }
    unint64_t v14 = v13 & v5[4].i64[0];
    int64_t v15 = (unint64_t)(v12 + 63) >> 6;
    if (!v14) {
      goto LABEL_8;
    }
LABEL_7:
    unint64_t v16 = __clz(__rbit64(v14));
    v14 &= v14 - 1;
    for (unint64_t i = v16 | (v10 << 6); ; unint64_t i = __clz(__rbit64(v19)) + (v10 << 6))
    {
      uint64_t v21 = 8 * i;
      uint64_t v22 = *(void *)(v5[3].i64[0] + v21);
      uint64_t v23 = *(void *)(v5[3].i64[1] + v21);
      uint64_t v24 = specialized static Hasher._hash(seed:_:)(v9[5], v22);
      unint64_t v25 = specialized __RawDictionaryStorage.find<A>(_:hashValue:)(v22, v24);
      if ((v6 & 1) != 0) {
        goto LABEL_31;
      }
      *(void *)((char *)v9 + ((v25 >> 3) & 0x1FFFFFFFFFFFFFF8LL) + 64) |= 1LL << v25;
      uint64_t v26 = 8 * v25;
      *(void *)(v9[6] + v26) = v22;
      *(void *)(v9[7] + v26) = v23;
      ++v9[2];
      if (v14) {
        goto LABEL_7;
      }
LABEL_8:
      if (__OFADD__(v10++, 1LL)) {
        goto LABEL_30;
      }
      if (v10 >= v15) {
        break;
      }
      unint64_t v19 = v11->u64[v10];
      if (!v19)
      {
        int64_t v20 = v10 + 1;
        if (v10 + 1 >= v15) {
          break;
        }
        unint64_t v19 = v11->u64[v20];
        if (!v19)
        {
          while (1)
          {
            int64_t v10 = v20 + 1;
            if (__OFADD__(v20, 1LL)) {
              break;
            }
            if (v10 >= v15) {
              goto LABEL_21;
            }
            unint64_t v19 = v11->u64[v10];
            ++v20;
            if (v19) {
              goto LABEL_17;
            }
          }

          __break(1u);
LABEL_30:
          __break(1u);
LABEL_31:
          swift_retain((unint64_t *)v5, v6, v7, v8);
          KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for Int);
        }

        ++v10;
      }

unint64_t specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)( uint64_t a1, char a2)
{
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  char v35 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_27;
  }
  uint64_t v34 = v2;
  uint64_t v8 = 1LL << v4[2].i8[0];
  uint64_t v9 = v4 + 4;
  uint64_t v10 = -1LL;
  if (v8 < 64) {
    uint64_t v10 = ~(-1LL << v8);
  }
  unint64_t v11 = v10 & v4[4].i64[0];
  int64_t v12 = (unint64_t)(v8 + 63) >> 6;
  unint64_t result = (unint64_t)swift_retain((unint64_t *)v4, v5, v6, v7);
  int64_t v17 = 0LL;
  while (1)
  {
    if (v11)
    {
      unint64_t v18 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v19 = v18 | (v17 << 6);
      goto LABEL_20;
    }

    if (__OFADD__(v17++, 1LL)) {
      goto LABEL_29;
    }
    if (v17 >= v12) {
      break;
    }
    unint64_t v21 = v9->u64[v17];
    if (!v21)
    {
      int64_t v22 = v17 + 1;
      if (v17 + 1 >= v12) {
        break;
      }
      unint64_t v21 = v9->u64[v22];
      if (!v21)
      {
        while (1)
        {
          int64_t v17 = v22 + 1;
          if (__OFADD__(v22, 1LL)) {
            break;
          }
          if (v17 >= v12) {
            goto LABEL_22;
          }
          unint64_t v21 = v9->u64[v17];
          ++v22;
          if (v21) {
            goto LABEL_19;
          }
        }

        __break(1u);
LABEL_29:
        __break(1u);
        return result;
      }

      ++v17;
    }

{
  int64x2_t **v2;
  int64x2_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  int64x2_t *v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v21;
  int64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int64x2_t *v28;
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  unint64_t v28 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_27;
  }
  uint64_t v8 = 1LL << v4[2].i8[0];
  uint64_t v9 = v4 + 4;
  uint64_t v10 = -1LL;
  if (v8 < 64) {
    uint64_t v10 = ~(-1LL << v8);
  }
  unint64_t v11 = v10 & v4[4].i64[0];
  int64_t v12 = (unint64_t)(v8 + 63) >> 6;
  unint64_t result = (unint64_t)swift_retain((unint64_t *)v4, v5, v6, v7);
  int64_t v17 = 0LL;
  while (1)
  {
    if (v11)
    {
      unint64_t v18 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v19 = v18 | (v17 << 6);
      goto LABEL_20;
    }

    if (__OFADD__(v17++, 1LL)) {
      goto LABEL_29;
    }
    if (v17 >= v12) {
      break;
    }
    unint64_t v21 = v9->u64[v17];
    if (!v21)
    {
      int64_t v22 = v17 + 1;
      if (v17 + 1 >= v12) {
        break;
      }
      unint64_t v21 = v9->u64[v22];
      if (!v21)
      {
        while (1)
        {
          int64_t v17 = v22 + 1;
          if (__OFADD__(v22, 1LL)) {
            break;
          }
          if (v17 >= v12) {
            goto LABEL_22;
          }
          unint64_t v21 = v9->u64[v17];
          ++v22;
          if (v21) {
            goto LABEL_19;
          }
        }

        __break(1u);
LABEL_29:
        __break(1u);
        return result;
      }

      ++v17;
    }

void specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(uint64_t a1, char a2)
{
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v8 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_29;
  }
  uint64_t v9 = 1LL << v4[2].i8[0];
  uint64_t v10 = v4 + 4;
  uint64_t v11 = -1LL;
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  unint64_t v12 = v11 & v4[4].i64[0];
  int64_t v13 = (unint64_t)(v9 + 63) >> 6;
  swift_retain((unint64_t *)v4, v5, v6, v7);
  int64_t v14 = 0LL;
  while (1)
  {
    if (v12)
    {
      unint64_t v18 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v19 = v18 | (v14 << 6);
      goto LABEL_21;
    }

    if (__OFADD__(v14++, 1LL)) {
      goto LABEL_31;
    }
    if (v14 >= v13) {
      break;
    }
    unint64_t v21 = v10->u64[v14];
    if (!v21)
    {
      int64_t v22 = v14 + 1;
      if (v14 + 1 >= v13) {
        break;
      }
      unint64_t v21 = v10->u64[v22];
      if (!v21)
      {
        while (1)
        {
          int64_t v14 = v22 + 1;
          if (__OFADD__(v22, 1LL)) {
            break;
          }
          if (v14 >= v13) {
            goto LABEL_23;
          }
          unint64_t v21 = v10->u64[v14];
          ++v22;
          if (v21) {
            goto LABEL_20;
          }
        }

        __break(1u);
LABEL_31:
        __break(1u);
        return;
      }

      ++v14;
    }

{
  int64x2_t **v2;
  int64x2_t *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  int64x2_t *v8;
  uint64_t v9;
  int64x2_t *v10;
  uint64_t v11;
  unint64_t v12;
  int64_t v13;
  int64_t v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v24;
  int64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t *v29;
  uint64_t v30;
  _OWORD v31[2];
  uint64_t v32;
  uint64_t v4 = *v2;
  if ((*v2)[1].i64[1] > a1) {
    a1 = (*v2)[1].i64[1];
  }
  uint64_t v8 = (int64x2_t *)specialized static _DictionaryStorage.resize(original:capacity:move:)(a1);
  if (!v4[1].i64[0]) {
    goto LABEL_29;
  }
  uint64_t v9 = 1LL << v4[2].i8[0];
  uint64_t v10 = v4 + 4;
  uint64_t v11 = -1LL;
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  unint64_t v12 = v11 & v4[4].i64[0];
  int64_t v13 = (unint64_t)(v9 + 63) >> 6;
  swift_retain((unint64_t *)v4, v5, v6, v7);
  int64_t v14 = 0LL;
  while (1)
  {
    if (v12)
    {
      unint64_t v21 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      int64_t v22 = v21 | (v14 << 6);
      goto LABEL_21;
    }

    if (__OFADD__(v14++, 1LL)) {
      goto LABEL_31;
    }
    if (v14 >= v13) {
      break;
    }
    unint64_t v24 = v10->u64[v14];
    if (!v24)
    {
      unint64_t v25 = v14 + 1;
      if (v14 + 1 >= v13) {
        break;
      }
      unint64_t v24 = v10->u64[v25];
      if (!v24)
      {
        while (1)
        {
          int64_t v14 = v25 + 1;
          if (__OFADD__(v25, 1LL)) {
            break;
          }
          if (v14 >= v13) {
            goto LABEL_23;
          }
          unint64_t v24 = v10->u64[v14];
          ++v25;
          if (v24) {
            goto LABEL_20;
          }
        }

        __break(1u);
LABEL_31:
        __break(1u);
        return;
      }

      ++v14;
    }

uint64_t specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)( uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v46 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *v3;
  if (*(void *)(*v3 + 24) > v7) {
    uint64_t v7 = *(void *)(*v3 + 24);
  }
  uint64_t v54 = *(void *)(v8 + 32);
  uint64_t v12 = specialized static _DictionaryStorage.allocate(capacity:)(v7, v5, v54);
  uint64_t v16 = v12;
  if (!*(void *)(v11 + 16)) {
    goto LABEL_29;
  }
  uint64_t v52 = v10;
  unint64_t v53 = v5;
  uint64_t v46 = v3;
  uint64_t v17 = 1LL << *(_BYTE *)(v11 + 32);
  uint64_t v18 = *(void *)(v11 + 64);
  uint64_t v49 = (int64x2_t *)(v11 + 64);
  uint64_t v19 = -1LL;
  if (v17 < 64) {
    uint64_t v19 = ~(-1LL << v17);
  }
  unint64_t v20 = v19 & v18;
  int64_t v48 = (unint64_t)(v17 + 63) >> 6;
  unint64_t v55 = (void *)v12;
  uint64_t v50 = v12 + 64;
  swift_retain((unint64_t *)v11, v13, v14, v15);
  int64_t v21 = 0LL;
  int v47 = a2;
  uint64_t v22 = 16LL;
  if ((a2 & 1) != 0) {
    uint64_t v22 = 32LL;
  }
  uint64_t v51 = v22;
  uint64_t v23 = v6;
  uint64_t v24 = (uint64_t)v52;
  unint64_t v25 = v53;
  uint64_t v26 = v54;
  if (!v20) {
    goto LABEL_10;
  }
LABEL_9:
  uint64_t v56 = (v20 - 1) & v20;
  int64_t v57 = v21;
  for (unint64_t i = __clz(__rbit64(v20)) | (v21 << 6); ; unint64_t i = __clz(__rbit64(v31)) + (v29 << 6))
  {
    uint64_t v33 = *(void *)(v23 + 72);
    (*(void (**)(uint64_t, unint64_t, unint64_t))(v23 + v51))( v24,  *(void *)(v11 + 48) + v33 * i,  v25);
    uint64_t v34 = v11;
    uint64_t v35 = *(void *)(v11 + 56) + 16 * i;
    char v36 = *(_BYTE *)(v35 + 8);
    uint64_t v37 = *(void *)v35;
    uint64_t v38 = v55;
    uint64_t v39 = (*(uint64_t (**)(void, unint64_t, uint64_t))(v26 + 32))(v55[5], v25, v26);
    unint64_t v40 = __RawDictionaryStorage.find<A>(_:hashValue:)(v24, v39, v25);
    if ((v41 & 1) != 0) {
      goto LABEL_33;
    }
    unint64_t v42 = v40;
    *(void *)(v50 + ((v40 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v40;
    (*(void (**)(unint64_t, uint64_t, unint64_t))(v23 + 32))(v38[6] + v33 * v40, v24, v25);
    uint64_t v43 = v38[7] + 16 * v42;
    *(void *)uint64_t v43 = v37;
    *(_BYTE *)(v43 + 8) = v36;
    ++v38[2];
    uint64_t v11 = v34;
    unint64_t v20 = v56;
    int64_t v21 = v57;
    if (v56) {
      goto LABEL_9;
    }
LABEL_10:
    BOOL v28 = __OFADD__(v21, 1LL);
    int64_t v29 = v21 + 1;
    if (v28) {
      goto LABEL_32;
    }
    uint64_t v30 = v49;
    if (v29 >= v48) {
      break;
    }
    unint64_t v31 = v49->u64[v29];
    if (!v31)
    {
      int64_t v32 = v29 + 1;
      if (v29 + 1 >= v48) {
        break;
      }
      unint64_t v31 = v49->u64[v32];
      if (!v31)
      {
        while (1)
        {
          int64_t v29 = v32 + 1;
          if (__OFADD__(v32, 1LL)) {
            break;
          }
          if (v29 >= v48) {
            goto LABEL_23;
          }
          unint64_t v31 = v49->u64[v29];
          ++v32;
          if (v31) {
            goto LABEL_19;
          }
        }

        __break(1u);
LABEL_32:
        __break(1u);
LABEL_33:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v25);
      }

      ++v29;
    }

Swift::Void __swiftcall _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)( Swift::Int capacity, Swift::Bool moveElements)
{
  BOOL v4 = moveElements;
  uint64_t v5 = *(void *)(v2 + 24);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](capacity);
  uint64_t v9 = (char *)&v46 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(*(void *)(v10 + 16) - 8LL);
  uint64_t v12 = MEMORY[0x1895F8858](v7);
  unint64_t v58 = (char *)&v46 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v59 = v13;
  uint64_t v16 = *v3;
  if (*(void *)(*v3 + 24) > v12) {
    uint64_t v12 = *(void *)(*v3 + 24);
  }
  uint64_t v57 = *(void *)(v14 + 32);
  uint64_t v17 = specialized static _DictionaryStorage.resize(original:capacity:move:)(v12, v13, v5, v57);
  uint64_t v21 = v17;
  if (!*(void *)(v16 + 16)) {
    goto LABEL_26;
  }
  uint64_t v55 = v6;
  uint64_t v56 = v5;
  int v47 = v3;
  uint64_t v22 = 1LL << *(_BYTE *)(v16 + 32);
  uint64_t v23 = *(void *)(v16 + 64);
  uint64_t v50 = (int64x2_t *)(v16 + 64);
  uint64_t v24 = -1LL;
  if (v22 < 64) {
    uint64_t v24 = ~(-1LL << v22);
  }
  unint64_t v25 = v24 & v23;
  int64_t v49 = (unint64_t)(v22 + 63) >> 6;
  uint64_t v60 = (void *)v17;
  uint64_t v51 = v17 + 64;
  swift_retain((unint64_t *)v16, v18, v19, v20);
  int64_t v26 = 0LL;
  BOOL v48 = v4;
  uint64_t v27 = 16LL;
  if (v4) {
    uint64_t v27 = 32LL;
  }
  uint64_t v53 = v27;
  uint64_t v54 = v9;
  uint64_t v52 = v16;
  uint64_t v28 = (uint64_t)v58;
  unint64_t v29 = v59;
  uint64_t v30 = v9;
  uint64_t v32 = v55;
  uint64_t v31 = v56;
  if (!v25) {
    goto LABEL_10;
  }
LABEL_9:
  uint64_t v63 = (v25 - 1) & v25;
  for (unint64_t i = __clz(__rbit64(v25)) | (v26 << 6); ; unint64_t i = __clz(__rbit64(v36)) + (v26 << 6))
  {
    uint64_t v37 = *(void *)(v16 + 48);
    uint64_t v62 = *(void *)(v11 + 72);
    uint64_t v38 = v53;
    (*(void (**)(uint64_t, unint64_t, unint64_t))(v11 + v53))(v28, v37 + v62 * i, v29);
    uint64_t v39 = *(void *)(v16 + 56);
    uint64_t v61 = *(void *)(v32 + 72);
    (*(void (**)(char *, unint64_t, uint64_t))(v32 + v38))(v30, v39 + v61 * i, v31);
    unint64_t v40 = v60;
    uint64_t v41 = (*(uint64_t (**)(void, unint64_t, uint64_t))(v57 + 32))(v60[5], v29, v57);
    unint64_t v42 = __RawDictionaryStorage.find<A>(_:hashValue:)(v28, v41, v29);
    if ((v43 & 1) != 0) {
      goto LABEL_30;
    }
    unint64_t v44 = v42;
    *(void *)(v51 + ((v42 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v42;
    (*(void (**)(unint64_t, uint64_t, unint64_t))(v11 + 32))(v40[6] + v62 * v42, v28, v29);
    (*(void (**)(unint64_t, char *, uint64_t))(v32 + 32))(v40[7] + v61 * v44, v30, v31);
    ++v40[2];
    uint64_t v16 = v52;
    unint64_t v25 = v63;
    if (v63) {
      goto LABEL_9;
    }
LABEL_10:
    int64_t v34 = v26 + 1;
    if (__OFADD__(v26, 1LL)) {
      goto LABEL_29;
    }
    uint64_t v35 = v50;
    if (v34 >= v49) {
      break;
    }
    unint64_t v36 = v50->u64[v34];
    ++v26;
    if (!v36)
    {
      while (1)
      {
        int64_t v26 = v34 + 1;
        if (__OFADD__(v34, 1LL)) {
          break;
        }
        if (v26 >= v49) {
          goto LABEL_20;
        }
        unint64_t v36 = v50->u64[v26];
        ++v34;
        if (v36) {
          goto LABEL_16;
        }
      }

      __break(1u);
LABEL_29:
      __break(1u);
LABEL_30:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v29);
    }

Swift::Void __swiftcall _NativeDictionary.resize(capacity:)(Swift::Int capacity)
{
}

Swift::Void __swiftcall _NativeDictionary.copyAndResize(capacity:)(Swift::Int capacity)
{
}

uint64_t specialized _NativeDictionary.ensureUnique(isUnique:capacity:)(char a1, uint64_t a2)
{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)( a1,  a2,  (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:),  (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)( a1,  a2,  (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:),  (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)( a1,  a2,  (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:),  (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)( a1,  a2,  (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:),  (void (*)(void))specialized _NativeDictionary.copy());
}

{
  return specialized _NativeDictionary.ensureUnique(isUnique:capacity:)( a1,  a2,  (void (*)(uint64_t, uint64_t))specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:),  (void (*)(void))specialized _NativeDictionary.copy());
}

uint64_t specialized _NativeDictionary.ensureUnique(isUnique:capacity:)( char a1, uint64_t a2, void (*a3)(uint64_t, uint64_t), void (*a4)(void))
{
  uint64_t v5 = *(void *)(*(void *)v4 + 24LL);
  if (v5 >= a2 && (a1 & 1) != 0) {
    return 0LL;
  }
  if ((a1 & 1) != 0)
  {
    uint64_t v6 = 1LL;
    a3(a2, 1LL);
  }

  else if (v5 < a2)
  {
    a3(a2, 0LL);
    return 1LL;
  }

  else
  {
    a4();
    return 0LL;
  }

  return v6;
}

Swift::Bool __swiftcall _NativeDictionary.ensureUnique(isUnique:capacity:)(Swift::Bool isUnique, Swift::Int capacity)
{
  Swift::Int v4 = *(void *)(*(void *)v2 + 24LL);
  if (v4 >= capacity)
  {
    if (!isUnique) {
      _NativeDictionary.copy()();
    }
  }

  else
  {
    if (isUnique)
    {
      Swift::Int v5 = capacity;
      Swift::Bool v6 = 1;
    }

    else
    {
      Swift::Int v5 = capacity;
      Swift::Bool v6 = 0;
    }

    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v5, v6);
  }

  return v4 < capacity;
}

Swift::_HashTable::Bucket __swiftcall _NativeDictionary.validatedBucket(for:)(Swift::_HashTable::Index a1)
{
  if (a1.bucket.offset < 0
    || 1LL << *(_BYTE *)(v1 + 32) <= a1.bucket.offset
    || ((*(void *)(v1 + (((unint64_t)a1.bucket.offset >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> SLOBYTE(a1.bucket.offset)) & 1) == 0
    || *(_DWORD *)(v1 + 36) != a1.age)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  0x119uLL,  0);
  }

  return a1.bucket;
}

uint64_t _NativeDictionary.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  if (*(void *)(a2 + 16) && (unint64_t v9 = __RawDictionaryStorage.find<A>(_:)(a1, a3, a5), (v10 & 1) != 0))
  {
    uint64_t v11 = *(void *)(a2 + 56);
    uint64_t v12 = *(void *)(a4 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v12 + 16))(a6, v11 + *(void *)(v12 + 72) * v9, a4);
    uint64_t v13 = 0LL;
  }

  else
  {
    uint64_t v12 = *(void *)(a4 - 8);
    uint64_t v13 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 56))(a6, v13, 1LL, a4);
}

void $defer #1 <A, B>() in _NativeDictionary.subscript.modify( uint64_t a1, int a2, void **a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v32[0] = a5;
  v32[1] = a8;
  unint64_t v34 = a4;
  uint64_t v35 = a3;
  int v36 = a2;
  uint64_t v33 = a6;
  uint64_t v10 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)v32 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = type metadata accessor for Optional(0LL, v15, v13, v14);
  uint64_t v17 = *(void *)(v16 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v20 = (char *)v32 - v19;
  uint64_t v21 = *(void *)(a7 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v18);
  uint64_t v24 = (char *)v32 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v22);
  int64_t v26 = (char *)v32 - v25;
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))(v20, a1, v16);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v21 + 48))(v20, 1LL, a7) == 1)
  {
    uint64_t v27 = v35;
    (*(void (**)(char *, uint64_t))(v17 + 8))(v20, v16);
    if ((v36 & 1) != 0)
    {
      v28.Swift::Int offset = v34;
      swift_arrayDestroy((*v27)[6] + *(void *)(v10 + 72) * v34, 1LL, v33);
      _NativeDictionary._delete(at:)(v28);
    }
  }

  else
  {
    unint64_t v29 = *(void (**)(char *, char *, uint64_t))(v21 + 32);
    v29(v26, v20, a7);
    uint64_t v30 = *v35;
    if ((v36 & 1) != 0)
    {
      v29((char *)(v30[7] + *(void *)(v21 + 72) * v34), v26, a7);
    }

    else
    {
      uint64_t v31 = v33;
      (*(void (**)(char *, void, uint64_t))(v10 + 16))(v12, v32[0], v33);
      v29(v24, v26, a7);
      _NativeDictionary._insert(at:key:value:)(v34, (uint64_t)v12, (uint64_t)v24, v30, v31, a7);
    }
  }

uint64_t key path getter for _NativeDictionary.subscript(_:isUnique:) : <A, B>_NativeDictionary<A, B>AB@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = *(void *)(a3 + a2 - 16);
  uint64_t v6 = *a1;
  if (*(void *)(*a1 + 16)
    && (unint64_t v7 = __RawDictionaryStorage.find<A>(_:)(a2, *(void *)(a3 + a2 - 24), *(void *)(a3 + a2 - 8)), (v8 & 1) != 0))
  {
    uint64_t v9 = *(void *)(v6 + 56);
    uint64_t v10 = *(void *)(v5 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v10 + 16))(a4, v9 + *(void *)(v10 + 72) * v7, v5);
    uint64_t v11 = 0LL;
  }

  else
  {
    uint64_t v10 = *(void *)(v5 - 8);
    uint64_t v11 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a4, v11, 1LL, v5);
}

uint64_t key path setter for _NativeDictionary.subscript(_:isUnique:) : <A, B>_NativeDictionary<A, B>AB( uint64_t a1, void **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = a1;
  unint64_t v6 = *(void *)(a4 + a3 - 24);
  uint64_t v7 = *(void *)(a4 + a3 - 16);
  uint64_t v8 = *(void *)(a4 + a3 - 8);
  uint64_t v9 = type metadata accessor for Optional(0LL, v7, a3, a4);
  uint64_t v36 = *(void *)(v9 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v34 - v11;
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v34 - v13;
  uint64_t v37 = v15;
  (*(void (**)(char *, uint64_t, unint64_t))(v15 + 16))((char *)&v34 - v13, a3, v6);
  char v16 = *(_BYTE *)(a3 + *((int *)swift_getTupleTypeMetadata2(0LL, v6, (uint64_t)&type metadata for Bool, 0LL, 0LL) + 12));
  uint64_t v17 = *a2;
  unint64_t v18 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, v6, v8);
  uint64_t v20 = v17[2];
  BOOL v21 = (v19 & 1) == 0;
  Swift::Int v22 = v20 + v21;
  if (__OFADD__(v20, v21))
  {
    __break(1u);
    goto LABEL_9;
  }

  char v23 = v19;
  unint64_t v39 = v18;
  uint64_t v35 = v9;
  uint64_t v24 = v8;
  type metadata accessor for _NativeDictionary(0LL, v6, v7, v8);
  if (_NativeDictionary.ensureUnique(isUnique:capacity:)(v16, v22))
  {
    unint64_t v39 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v14, v6, v8);
    if ((v23 & 1) != (v25 & 1)) {
LABEL_9:
    }
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v6);
  }

  unint64_t v34 = a2;
  if ((v23 & 1) != 0)
  {
    uint64_t v26 = (*a2)[7];
    uint64_t v27 = *(void *)(v7 - 8);
    unint64_t v28 = v39;
    (*(void (**)(char *, unint64_t, uint64_t))(v27 + 32))(v12, v26 + *(void *)(v27 + 72) * v39, v7);
    uint64_t v29 = 0LL;
  }

  else
  {
    uint64_t v27 = *(void *)(v7 - 8);
    uint64_t v29 = 1LL;
    unint64_t v28 = v39;
  }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v27 + 56))(v12, v29, 1LL, v7);
  uint64_t v30 = v35;
  uint64_t v31 = v36;
  uint64_t v32 = *(void (**)(char *, uint64_t))(v36 + 8);
  v32(v12, v35);
  (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v12, v38, v30);
  $defer #1 <A, B>() in _NativeDictionary.subscript.modify((uint64_t)v12, v23 & 1, v34, v28, (uint64_t)v14, v6, v7, v24);
  v32(v12, v30);
  return (*(uint64_t (**)(char *, unint64_t))(v37 + 8))(v14, v6);
}

uint64_t _NativeDictionary.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = (void **)v4;
  char v7 = a3;
  uint64_t v38 = a1;
  uint64_t v9 = a4[3];
  uint64_t v37 = type metadata accessor for Optional(0LL, v9, a3, (uint64_t)a4);
  uint64_t v39 = *(void *)(v37 - 8);
  MEMORY[0x1895F8858](v37);
  uint64_t v11 = (char *)&v36 - v10;
  uint64_t v12 = (void *)*v4;
  unint64_t v13 = a4[2];
  uint64_t v14 = a4[4];
  unint64_t v16 = __RawDictionaryStorage.find<A>(_:)(a2, v13, v14);
  uint64_t v17 = v12[2];
  BOOL v18 = (v15 & 1) == 0;
  Swift::Int v19 = v17 + v18;
  if (__OFADD__(v17, v18))
  {
    __break(1u);
    goto LABEL_14;
  }

  char v20 = v15;
  Swift::Int v21 = v12[3];
  uint64_t v36 = a2;
  if (v21 < v19 || (v7 & 1) == 0)
  {
    if (v21 >= v19 && (v7 & 1) == 0)
    {
      unint64_t v22 = v16;
      _NativeDictionary.copy()();
      unint64_t v16 = v22;
      goto LABEL_7;
    }

    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v19, v7 & 1);
    uint64_t v29 = a2;
    uint64_t v24 = v14;
    unint64_t v30 = __RawDictionaryStorage.find<A>(_:)(v29, v13, v14);
    if ((v20 & 1) == (v31 & 1))
    {
      unint64_t v16 = v30;
      uint64_t v23 = v38;
      uint64_t v25 = v37;
      if ((v20 & 1) != 0) {
        goto LABEL_8;
      }
LABEL_11:
      uint64_t v26 = *(void *)(v9 - 8);
      uint64_t v28 = 1LL;
      unint64_t v27 = v16;
      goto LABEL_12;
    }

void KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(unint64_t a1)
{
  uint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(196LL);
  uint64_t v6 = v2;
  unint64_t v7 = v3;
  uint64_t v214 = v2;
  unint64_t v215 = v3;
  uint64_t v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) != 0) {
    uint64_t v9 = HIBYTE(v3) & 0xF;
  }
  else {
    uint64_t v9 = v2 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v10 = "Duplicate keys of type '";
  if (!v9 && (v2 & ~v3 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v3);
    unint64_t v11 = 0x80000001818B6E00LL | 0x8000000000000000LL;
    uint64_t v214 = 0xD000000000000018LL;
LABEL_59:
    unint64_t v215 = v11;
    goto LABEL_60;
  }

  if ((v3 & 0x2000000000000000LL) != 0 && (0x80000001818B6E00LL & 0x2000000000000000LL) != 0)
  {
    unint64_t v12 = v8 + ((0x80000001818B6E00LL >> 56) & 0xF);
    if (v12 <= 0xF)
    {
      unint64_t v55 = (0x80000001818B6E00LL >> 56) & 0xF;
      if (v55)
      {
        char v57 = 0;
        uint64_t v58 = 0LL;
        unint64_t v56 = v3;
        do
        {
          uint64_t v59 = v8 + v58;
          uint64_t v60 = v58 + 1;
          unint64_t v61 = 0x80000001818B6E00LL | 0x8000000000000000LL;
          if (v58 < 8) {
            unint64_t v61 = 0xD000000000000018LL;
          }
          unint64_t v62 = v61 >> (v57 & 0x38);
          char v63 = (8 * v8 + v57) & 0x38;
          uint64_t v64 = (-255LL << v63) - 1;
          unint64_t v65 = (unint64_t)v62 << v63;
          unint64_t v66 = v65 | v64 & v56;
          unint64_t v67 = v65 | v64 & v6;
          if (v59 < 8) {
            uint64_t v6 = v67;
          }
          else {
            unint64_t v56 = v66;
          }
          v57 += 8;
          uint64_t v58 = v60;
        }

        while (v55 != v60);
      }

      else
      {
        unint64_t v56 = v3;
      }

      swift_bridgeObjectRelease(v3);
      swift_bridgeObjectRelease(0x80000001818B6E00LL | 0x8000000000000000LL);
      unint64_t v68 = 0xA000000000000000LL;
      if (!(v6 & 0x8080808080808080LL | v56 & 0x80808080808080LL)) {
        unint64_t v68 = 0xE000000000000000LL;
      }
      unint64_t v11 = v68 & 0xFF00000000000000LL | (v12 << 56) | v56 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_58;
    }
  }

  uint64_t v13 = 0x80000001818B6E00LL | 0x8000000000000000LL;
  if ((0x80000001818B6E00LL & 0x2000000000000000LL) != 0) {
    uint64_t v14 = (0x80000001818B6E00LL >> 56) & 0xF;
  }
  else {
    uint64_t v14 = 24LL;
  }
  swift_bridgeObjectRetain_n(0x80000001818B6E00LL | 0x8000000000000000LL, 2LL, v4, v5);
  if ((0x80000001818B6E00LL & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain_n(0x80000001818B6E00LL | 0x8000000000000000LL, 5LL, v15, v16);
    v195._Swift::UInt64 rawBits = 1LL;
    v196._Swift::UInt64 rawBits = (v14 << 16) | 1;
    v197._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v195,  v196,  0xD000000000000018LL,  0x80000001818B6E00LL | 0x8000000000000000LL);
    if (v197._rawBits < 0x10000) {
      v197._rawBits |= 3;
    }
    uint64_t v20 = specialized Collection.count.getter( v197,  v198,  0xD000000000000018LL,  0x80000001818B6E00LL | 0x8000000000000000LL);
    swift_bridgeObjectRelease(0x80000001818B6E00LL | 0x8000000000000000LL);
    if ((v7 & 0x1000000000000000LL) == 0)
    {
LABEL_15:
      BOOL v21 = __OFADD__(v9, v20);
      int64_t v22 = v9 + v20;
      if (!v21) {
        goto LABEL_16;
      }
      goto LABEL_185;
    }
  }

  else
  {
    swift_bridgeObjectRetain_n(0x80000001818B6E00LL | 0x8000000000000000LL, 4LL, v15, v16);
    uint64_t v20 = v14;
    if ((v7 & 0x1000000000000000LL) == 0) {
      goto LABEL_15;
    }
  }

  Swift::Int v199 = String.UTF8View._foreignCount()();
  int64_t v22 = v199 + v20;
  if (!__OFADD__(v199, v20))
  {
LABEL_16:
    if ((v6 & ~v7 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v7 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v6, v7);
      if ((v17 & 1) != 0) {
        goto LABEL_160;
      }
      if (v22 > 15 || (v7 & 0x2000000000000000LL) == 0 && v23 >= v20)
      {
LABEL_22:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v22, v20);
        if ((0x80000001818B6E00LL & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)( 0xD000000000000018LL,  0x80000001818B6E00LL | 0x8000000000000000LL,  0LL,  v14);
          unint64_t v27 = 0x80000001818B6E00LL | 0x8000000000000000LL;
        }

        else
        {
          char v24 = (0x80000001818B6E00LL & 0x2000000000000000LL) == 0 || (0x80000001818B6E00LL & 0x4000000000000000LL) != 0;
          swift_bridgeObjectRelease_n(0x80000001818B6E00LL | 0x8000000000000000LL, 5LL);
          if ((0x80000001818B6E00LL & 0x2000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(0x80000001818B6E00LL | 0x8000000000000000LL);
            unint64_t v212 = 0xD000000000000018LL;
            unint64_t v213 = 0x80000001818B6E00LL & 0xFFFFFFFFFFFFFFLL;
            uint64_t v126 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v14,  (uint64_t)&v212,  (0x80000001818B6E00LL >> 56) & 0xF);
            _StringGuts.appendInPlace(_:isASCII:)(v126, v127, v24);
            swift_bridgeObjectRelease(0x80000001818B6E00LL | 0x8000000000000000LL);
LABEL_60:
            TypeName = (uint64_t *)swift_getTypeName(a1, 0);
            if (v70 < 0) {
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
            }
            Swift::Int v71 = (uint8x16_t *)TypeName;
            int64_t v72 = v70;
            int64_t v73 = validateUTF8(_:)(TypeName, v70);
            if ((v75 & 1) != 0) {
              uint64_t v76 = repairUTF8(_:firstKnownBrokenRange:)(v71->i8, v72, v73, v74);
            }
            else {
              uint64_t v76 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v71, v72, v73 & 1);
            }
            uint64_t v6 = v76;
            a1 = v77;
            unint64_t v7 = v214;
            int64_t v22 = v215;
            unint64_t v80 = HIBYTE(v215) & 0xF;
            if ((v215 & 0x2000000000000000LL) != 0) {
              uint64_t v10 = (const char *)(HIBYTE(v215) & 0xF);
            }
            else {
              uint64_t v10 = (const char *)(v214 & 0xFFFFFFFFFFFFLL);
            }
            if (!v10 && (v214 & ~v215 & 0x2000000000000000LL) == 0)
            {
              swift_bridgeObjectRelease(v215);
              uint64_t v214 = v6;
              unint64_t v215 = a1;
              goto LABEL_126;
            }

            uint64_t v20 = v77 & 0x2000000000000000LL;
            uint64_t v14 = HIBYTE(v77) & 0xF;
            if ((v215 & 0x2000000000000000LL) != 0 && v20)
            {
              unint64_t v83 = v80 + v14;
              if (v80 + v14 <= 0xF)
              {
                if (v14)
                {
                  char v130 = 0;
                  unint64_t v131 = 0LL;
                  unint64_t v125 = v215;
                  do
                  {
                    unint64_t v132 = v80 + v131;
                    unint64_t v133 = v131 + 1;
                    if (v131 >= 8) {
                      unint64_t v134 = v77;
                    }
                    else {
                      unint64_t v134 = v76;
                    }
                    unint64_t v135 = v134 >> (v130 & 0x38);
                    char v136 = (8 * v80 + v130) & 0x38;
                    uint64_t v137 = (-255LL << v136) - 1;
                    unint64_t v138 = (unint64_t)v135 << v136;
                    unint64_t v139 = v138 | v137 & v125;
                    unint64_t v140 = v138 | v137 & v7;
                    if (v132 < 8) {
                      unint64_t v7 = v140;
                    }
                    else {
                      unint64_t v125 = v139;
                    }
                    v130 += 8;
                    unint64_t v131 = v133;
                  }

                  while (v14 != v133);
                }

                else
                {
                  unint64_t v125 = v215;
                }

                swift_bridgeObjectRelease(v215);
                swift_bridgeObjectRelease(a1);
                unint64_t v141 = 0xA000000000000000LL;
                if (!(v7 & 0x8080808080808080LL | v125 & 0x80808080808080LL)) {
                  unint64_t v141 = 0xE000000000000000LL;
                }
                uint64_t v214 = v7;
                unint64_t v215 = v141 & 0xFF00000000000000LL | (v83 << 56) | v125 & 0xFFFFFFFFFFFFFFLL;
                goto LABEL_126;
              }

              uint64_t v20 = 1LL;
            }

            uint64_t v211 = v76 & 0xFFFFFFFFFFFFLL;
            if (v20) {
              uint64_t v13 = HIBYTE(v77) & 0xF;
            }
            else {
              uint64_t v13 = v76 & 0xFFFFFFFFFFFFLL;
            }
            swift_bridgeObjectRetain_n(v77, 2LL, v78, v79);
            if ((a1 & 0x1000000000000000LL) == 0)
            {
              swift_bridgeObjectRetain_n(a1, 4LL, v18, v19);
              Swift::Int v87 = v13;
              if ((v22 & 0x1000000000000000LL) == 0) {
                goto LABEL_79;
              }
              goto LABEL_189;
            }

LABEL_160:
                  unint64_t v170 = 258LL;
                  goto LABEL_161;
                }

LABEL_197:
                __break(1u);
LABEL_198:
                id v92 = _StringObject.sharedUTF8.getter(v6, a1);
                uint64_t v94 = v210;
                swift_bridgeObjectRelease(a1);
                if (v94 < v211) {
                  _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
                }
                uint64_t v93 = v211;
LABEL_92:
                uint64_t v95 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v93, (uint64_t)v92, v94);
                _StringGuts.appendInPlace(_:isASCII:)(v95, v96, v6 < 0);
LABEL_110:
                swift_bridgeObjectRelease_n(a1, 2LL);
              }
            }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
  }

  unint64_t v28 = HIBYTE(a2) & 0xF;
  v102[0] = a1;
  v102[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (!v28) {
    goto LABEL_197;
  }
  if (a1 == 43)
  {
    uint64_t v8 = 1;
    unint64_t v67 = specialized Collection.subscript.getter(1LL, (uint64_t)v102, HIBYTE(a2) & 0xF);
    Swift::Int v71 = specialized UnsafeBufferPointer.init(rebasing:)(v67, v68, v69, v70);
    if (v72)
    {
      int64_t v73 = (unsigned __int8 *)v71;
      int64_t v74 = low + 87;
      if (low <= 10) {
        int64_t v74 = 97;
      }
      unint64_t v104 = v74;
      if (low <= 10) {
        char v75 = 65;
      }
      else {
        char v75 = low + 55;
      }
      if (low <= 10) {
        uint64_t v76 = low + 48;
      }
      else {
        uint64_t v76 = 58;
      }
      if (v71)
      {
        unint64_t v77 = v72;
        do
        {
          uint64_t v94 = *v73;
          if (v94 < 0x30 || v94 >= v76)
          {
            if (v94 < 0x41 || v94 >= v75)
            {
              v22.partialValue.uint64_t low = 0LL;
              uint64_t v8 = 1;
              uint64_t v95 = -87;
            }

            else
            {
              uint64_t v95 = -55;
            }
          }

          else
          {
            uint64_t v95 = -48;
          }

          size_t v96 = v94 + v95;
          v97.uint64_t low = low;
          v97.high = low >> 63;
          int64_t v22 = _Int128.multipliedReportingOverflow(by:)(v97);
          unint64_t v98 = *(_DWORD *)&v22.overflow;
          *(void *)&v22.overfuint64_t low = v22.partialValue.low + v96;
          unint64_t v99 = __CFADD__(v22.partialValue.low, v96);
          if (v22.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
          {
            if (((v99 | v98) & 1) != 0) {
              goto LABEL_191;
            }
          }

          else if (v99)
          {
            if ((v98 & 1) != 0)
            {
LABEL_191:
              v22.partialValue.uint64_t low = 0LL;
              uint64_t v8 = 1;
              goto LABEL_193;
            }
          }

          else if ((v98 & 1) != 0)
          {
            goto LABEL_191;
          }

          ++v73;
          --v77;
        }

        while (v77);
LABEL_192:
        uint64_t v8 = 0;
        v22.partialValue.uint64_t low = *(void *)&v22.overflow;
        goto LABEL_193;
      }

      goto LABEL_120;
    }

    goto LABEL_199;
  }

  if (a1 != 45)
  {
    uint64_t v78 = LODWORD(by.low) + 87;
    unint64_t v104 = v78;
    else {
      uint64_t v79 = LOBYTE(by.low) + 55;
    }
    else {
      unint64_t v80 = 58;
    }
    uint64_t v81 = (unsigned __int8 *)v102;
    while (1)
    {
      uint64_t v82 = *v81;
      if (v82 < 0x30 || v82 >= v80)
      {
        if (v82 < 0x41 || v82 >= v79)
        {
          v22.partialValue.uint64_t low = 0LL;
          uint64_t v8 = 1;
          unint64_t v83 = -87;
        }

        else
        {
          unint64_t v83 = -55;
        }
      }

      else
      {
        unint64_t v83 = -48;
      }

      uint64_t v84 = v82 + v83;
      v85.uint64_t low = low;
      v85.high = low >> 63;
      int64_t v22 = _Int128.multipliedReportingOverflow(by:)(v85);
      uint64_t v86 = *(_DWORD *)&v22.overflow;
      *(void *)&v22.overfuint64_t low = v22.partialValue.low + v84;
      Swift::Int v87 = __CFADD__(v22.partialValue.low, v84);
      if (v22.partialValue.high == 0x7FFFFFFFFFFFFFFFLL)
      {
        if (((v87 | v86) & 1) != 0) {
          goto LABEL_191;
        }
      }

      else if (v87)
      {
        if ((v86 & 1) != 0) {
          goto LABEL_191;
        }
      }

      else if ((v86 & 1) != 0)
      {
        goto LABEL_191;
      }

      ++v81;
      if (!--v28) {
        goto LABEL_192;
      }
    }
  }

  uint64_t v8 = 1;
  unint64_t v29 = specialized Collection.subscript.getter(1LL, (uint64_t)v102, HIBYTE(a2) & 0xF);
  Swift::String::Index v33 = specialized UnsafeBufferPointer.init(rebasing:)(v29, v30, v31, v32);
  if (!v34) {
    goto LABEL_198;
  }
  unint64_t v35 = (unsigned __int8 *)v33;
  if (low <= 10) {
    unint64_t v36 = 97;
  }
  else {
    unint64_t v36 = low + 87;
  }
  if (low <= 10) {
    unint64_t v37 = 65;
  }
  else {
    unint64_t v37 = low + 55;
  }
  if (low <= 10) {
    unint64_t v38 = low + 48;
  }
  else {
    unint64_t v38 = 58;
  }
  if (v33)
  {
    unint64_t v39 = v34;
    do
    {
      uint64_t v40 = *v35;
      if (v40 < 0x30 || v40 >= v38)
      {
        if (v40 < 0x41 || v40 >= v37)
        {
          v22.partialValue.uint64_t low = 0LL;
          uint64_t v8 = 1;
          if (v40 < 0x61 || v40 >= v36) {
            goto LABEL_193;
          }
          uint64_t v41 = -87;
        }

        else
        {
          uint64_t v41 = -55;
        }
      }

      else
      {
        uint64_t v41 = -48;
      }

      uint64_t v42 = v40 + v41;
      v43.uint64_t low = low;
      v43.high = low >> 63;
      int64_t v22 = _Int128.multipliedReportingOverflow(by:)(v43);
      size_t v26 = v22.partialValue.low >= v42;
      v22.partialValue.low -= v42;
      unint64_t v45 = !v26;
      if (v22.partialValue.high == 0x8000000000000000LL)
      {
        if (((*(_DWORD *)&v22.overflow | v45) & 1) != 0) {
          goto LABEL_191;
        }
      }

      else if (v22.overflow)
      {
        goto LABEL_191;
      }

      uint64_t v8 = 0;
      ++v35;
      --v39;
    }

    while (v39);
    goto LABEL_193;
  }

      abort();
    }

    if (v10 == 2)
    {
      unint64_t v12 = (unsigned __int16 ***)*a2;
      goto LABEL_30;
    }

    goto LABEL_48;
  }

  unint64_t v12 = (unsigned __int16 ***)a2;
  if (v8 != 180)
  {
    if (v8 != 181) {
      goto LABEL_24;
    }
    goto LABEL_25;
  }

LABEL_191:
            __break(1u);
            goto LABEL_192;
          }

          uint64_t v25 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v14,  (0x80000001818B6E00LL & 0xFFFFFFFFFFFFFFFLL) + 32,  24LL);
          _StringGuts.appendInPlace(_:isASCII:)(v25, v26, v24);
          unint64_t v27 = 0x80000001818B6E00LL | 0x8000000000000000LL;
        }

        swift_bridgeObjectRelease_n(v27, 2LL);
        goto LABEL_60;
      }
    }

    else if (v22 > 15)
    {
      goto LABEL_22;
    }

    swift_bridgeObjectRetain(v7, v17, v18, v19);
    uint64_t v6 = _StringGuts._convertedToSmall()(v6, v7);
    unint64_t v29 = v28;
    swift_bridgeObjectRelease(v7);
    v30._Swift::UInt64 rawBits = (v14 << 16) | 1;
    v31._Swift::UInt64 rawBits = 1LL;
    v32._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v31,  v30,  0xD000000000000018LL,  0x80000001818B6E00LL | 0x8000000000000000LL);
    if (v32._rawBits < 0x10000) {
      v32._rawBits |= 3;
    }
    unint64_t v34 = specialized String.init(_:)(v32, v33, 0xD000000000000018LL, 0x80000001818B6E00LL | 0x8000000000000000LL);
    unint64_t v36 = v35;
    swift_bridgeObjectRelease(0x80000001818B6E00LL | 0x8000000000000000LL);
    unint64_t v37 = _StringGuts._convertedToSmall()(v34, v36);
    unint64_t v39 = v38;
    swift_bridgeObjectRelease(v36);
    uint64_t v40 = HIBYTE(v29) & 0xF;
    uint64_t v41 = HIBYTE(v39) & 0xF;
    uint64_t v42 = v41 + v40;
    if (v41)
    {
      char v43 = 0;
      unint64_t v44 = 0LL;
      do
      {
        unint64_t v45 = v40 + v44;
        unint64_t v46 = v44 + 1;
        if (v44 >= 8) {
          unint64_t v47 = v39;
        }
        else {
          unint64_t v47 = v37;
        }
        unint64_t v48 = v47 >> (v43 & 0x38);
        char v49 = (8 * v40 + v43) & 0x38;
        uint64_t v50 = (-255LL << v49) - 1;
        unint64_t v51 = (unint64_t)v48 << v49;
        unint64_t v52 = v51 | v50 & v29;
        unint64_t v53 = v51 | v50 & v6;
        if (v45 < 8) {
          uint64_t v6 = v53;
        }
        else {
          unint64_t v29 = v52;
        }
        v43 += 8;
        unint64_t v44 = v46;
      }

      while (v41 != v46);
    }

    swift_bridgeObjectRelease(v7);
    swift_bridgeObjectRelease(0x80000001818B6E00LL | 0x8000000000000000LL);
    unint64_t v54 = 0xA000000000000000LL;
    if (!(v6 & 0x8080808080808080LL | v29 & 0x80808080808080LL)) {
      unint64_t v54 = 0xE000000000000000LL;
    }
    unint64_t v11 = v54 & 0xFF00000000000000LL | (v42 << 56) | v29 & 0xFFFFFFFFFFFFFFLL;
LABEL_58:
    uint64_t v214 = v6;
    goto LABEL_59;
  }

LABEL_185:
  __break(1u);
  goto LABEL_186;
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }
    }

    else if (v50 > 15)
    {
      goto LABEL_55;
    }

    swift_bridgeObjectRelease(v7._rawBits);
    uint64_t v58 = v182;
    swift_bridgeObjectRetain(v8, v59, v60, v61);
    unint64_t v62 = _StringGuts._convertedToSmall()(v58, v8);
    uint64_t v64 = v63;
    swift_bridgeObjectRelease(v8);
    v65._Swift::UInt64 rawBits = v11 & 0xFFFFFFFFFFFF0000LL | 1;
    v66._Swift::UInt64 rawBits = v15 & 0xFFFFFFFFFFFF0000LL | 1;
    v67._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v65, v66, v179, v7._rawBits);
    if (v67._rawBits < 0x10000) {
      v67._rawBits |= 3;
    }
    uint64_t v69 = specialized String.init(_:)(v67, v68, v179, v7._rawBits);
    Swift::Int v71 = v70;
    swift_bridgeObjectRelease(v7._rawBits);
    int64_t v72 = _StringGuts._convertedToSmall()(v69, v71);
    int64_t v74 = v73;
    swift_bridgeObjectRelease(v71);
    char v75 = specialized _SmallString.init(_:appending:)(v62, v64, v72, v74);
    if ((v77 & 1) == 0)
    {
      uint64_t v78 = v75;
      uint64_t v79 = v76;
      swift_bridgeObjectRelease(v8);
      uint64_t v182 = v78;
      uint64_t v183 = v79;
      goto LABEL_69;
    }

          if (v6[8] != 101) {
            return 0LL;
          }
          unint64_t v105 = *(const void **)v6;
          unint64_t v106 = *((void *)v6 + 1);
          if (v64)
          {
            unint64_t v107 = v162;
LABEL_206:
            if (v81) {
              unint64_t v117 = v107 == 0;
            }
            else {
              unint64_t v117 = 1;
            }
            unint64_t v118 = (uint64_t *)&v158;
            if (!v117) {
              unint64_t v118 = &v162;
            }
            char v119 = *v118;
            uint64_t v120 = (const void **)&v161;
            if (v117) {
              uint64_t v120 = (const void **)&v157;
            }
            if (v106 != v119 || v106 && memcmp(v105, *v120, v106)) {
              return 0LL;
            }
            unint64_t v121 = *((unsigned __int8 *)a2 + 18);
            if (v121 != 5) {
              goto LABEL_22;
            }
            goto LABEL_218;
          }

          unint64_t v107 = *((int *)v28 + 2);
          unint64_t v108 = &v28[v107 + 8];
          if (v108)
          {
            unint64_t v109 = strlen(&v28[v107 + 8]);
            if ((v28[2] & 4) == 0) {
              goto LABEL_190;
            }
LABEL_192:
            uint64_t v151 = *(const void **)v6;
            Swift::String::Index v200 = 0LL;
            v201[0] = 0LL;
            Swift::Int v199 = 0LL;
            unint64_t v141 = v109;
            uint64_t v111 = &v108[v109];
            uint64_t v112 = &v108[v109 + 1];
            char v113 = strlen(v112);
            uint64_t v146 = (unint64_t)v108;
            if (v113)
            {
              unint64_t v7 = 0LL;
              Swift::String::Index v156 = 0LL;
              uint64_t v6 = 0LL;
              unint64_t v114 = v111;
              while (1)
              {
                unint64_t v116 = *((unsigned __int8 *)v111 + 1);
                switch(v116)
                {
                  case 'S':
                    Swift::String::Index v156 = v111 + 2;
                    unint64_t v115 = &v200;
                    break;
                  case 'R':
                    uint64_t v6 = v111 + 2;
                    unint64_t v115 = &v199;
                    break;
                  case 'N':
                    unint64_t v7 = (char *)(v111 + 2);
                    unint64_t v115 = v201;
                    unint64_t v108 = (char *)(v111 + 2);
                    break;
                  default:
                    goto LABEL_196;
                }

                unint64_t v114 = &v112[v113];
                *unint64_t v115 = v113 - 1;
LABEL_196:
                uint64_t v111 = &v112[v113];
                v112 += v113 + 1;
                char v113 = strlen(v112);
                if (!v113)
                {
                  uint64_t v2 = v200;
                  unint64_t v107 = v201[0];
                  uint64_t v111 = v114;
                  unint64_t v3 = v199;
                  uint64_t v10 = &v157;
                  goto LABEL_204;
                }
              }
            }

            unint64_t v3 = 0LL;
            uint64_t v2 = 0LL;
            unint64_t v107 = 0LL;
            unint64_t v7 = 0LL;
            Swift::String::Index v156 = 0LL;
            uint64_t v6 = 0LL;
LABEL_204:
            uint64_t v110 = (char *)(v111 - v108);
            uint64_t v81 = 1;
            uint64_t v4 = v146;
            unint64_t v105 = v151;
            unint64_t v109 = v141;
            uint64_t v5 = v156;
          }

          else
          {
            unint64_t v109 = 0LL;
            if ((v28[2] & 4) != 0) {
              goto LABEL_192;
            }
LABEL_190:
            unint64_t v7 = 0LL;
            uint64_t v81 = 0;
            uint64_t v4 = (unint64_t)v108;
            uint64_t v110 = (char *)v109;
          }

          Swift::String::Index v157 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))v4;
          Swift::String::Index v158 = v109;
          unint64_t v159 = v108;
          unint64_t v160 = v110;
          unint64_t v161 = (uint64_t)v7;
          unint64_t v162 = v107;
          unint64_t v163 = (char *)v5;
          unint64_t v164 = v2;
          __s1 = v6;
          unint64_t v166 = v3;
          char v167 = v81;
          uint64_t v2 = 1LL;
          LOBYTE(v168) = 1;
          goto LABEL_206;
        }

        if ((v65 & 1) == 0)
        {
          uint64_t v81 = v167;
          uint64_t v78 = v166;
          if (!v167) {
            goto LABEL_185;
          }
          goto LABEL_184;
        }

        uint64_t v78 = *((int *)v28 + 2);
        uint64_t v79 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))&v28[v78 + 8];
        if (v79) {
          unint64_t v80 = strlen(&v28[v78 + 8]);
        }
        else {
          unint64_t v80 = 0LL;
        }
        Swift::String::Index v155 = v28;
        if ((v28[2] & 4) == 0)
        {
          unint64_t v7 = 0LL;
          uint64_t v81 = 0;
          id v92 = v79;
          uint64_t v93 = (const char *)v80;
LABEL_183:
          Swift::String::Index v157 = v79;
          Swift::String::Index v158 = v80;
          unint64_t v159 = (char *)v92;
          unint64_t v160 = (char *)v93;
          unint64_t v161 = (uint64_t)v7;
          unint64_t v162 = v3;
          unint64_t v163 = v28;
          unint64_t v164 = v2;
          __s1 = (void *)v4;
          unint64_t v166 = v78;
          char v167 = v81;
          uint64_t v64 = 1;
          LOBYTE(v168) = 1;
          unint64_t v28 = v155;
          if (!v81) {
            goto LABEL_185;
          }
LABEL_184:
          if (v78) {
            return 0LL;
          }
          goto LABEL_185;
        }

        Swift::String::Index v200 = 0LL;
        v201[0] = 0LL;
        Swift::Int v199 = 0LL;
        uint64_t v145 = v80;
        uint64_t v94 = (char *)v79 + v80;
        uint64_t v95 = v79;
        size_t v96 = (char *)v79 + v80 + 1;
        unint64_t v97 = strlen(v96);
        if (!v97)
        {
          uint64_t v78 = 0LL;
          uint64_t v2 = 0LL;
          unint64_t v3 = 0LL;
          unint64_t v7 = 0LL;
          int64_t v150 = 0LL;
          id v92 = v95;
          uint64_t v79 = v95;
          unint64_t v28 = 0LL;
LABEL_182:
          uint64_t v93 = (const char *)(v94 - (const char *)v92);
          uint64_t v81 = 1;
          unint64_t v80 = v145;
          uint64_t v4 = v150;
          goto LABEL_183;
        }

        unint64_t v7 = 0LL;
        int64_t v150 = 0LL;
        unint64_t v140 = v95;
        id v92 = v95;
        unint64_t v28 = 0LL;
        unint64_t v98 = v94;
        while (2)
        {
          Swift::String::Index v100 = *((unsigned __int8 *)v94 + 1);
          switch(v100)
          {
            case 'S':
              unint64_t v28 = (char *)(v94 + 2);
              unint64_t v99 = &v200;
LABEL_157:
              unint64_t v98 = &v96[v97];
              *unint64_t v99 = v97 - 1;
              break;
            case 'R':
              int64_t v150 = (unint64_t)(v94 + 2);
              unint64_t v99 = &v199;
              goto LABEL_157;
            case 'N':
              unint64_t v7 = (char *)(v94 + 2);
              unint64_t v99 = v201;
              id v92 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))(v94 + 2);
              goto LABEL_157;
          }

          uint64_t v94 = &v96[v97];
          v96 += v97 + 1;
          unint64_t v97 = strlen(v96);
          if (!v97)
          {
            uint64_t v2 = v200;
            unint64_t v3 = v201[0];
            uint64_t v94 = v98;
            uint64_t v78 = v199;
            uint64_t v10 = &v157;
            uint64_t v79 = v140;
            goto LABEL_182;
          }

          continue;
        }
      }

      goto LABEL_96;
    }

    unint64_t v51 = (unsigned int *)(v9 + 8);
    unint64_t v52 = *((int *)v9 + 2);
    unint64_t v53 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))&v9[v52 + 8];
    if (v53)
    {
      unint64_t v54 = strlen(&v9[v52 + 8]);
      uint64_t v4 = *(unsigned int *)v9;
      if ((v4 & 0x40000) != 0) {
        goto LABEL_85;
      }
LABEL_99:
      uint64_t v59 = 0LL;
      unint64_t v3 = 0LL;
      uint64_t v60 = v53;
      unint64_t v66 = (const char *)v54;
LABEL_114:
      Swift::String::Index v157 = v53;
      Swift::String::Index v158 = v54;
      unint64_t v159 = (char *)v60;
      unint64_t v160 = (char *)v66;
      unint64_t v161 = v59;
      unint64_t v162 = v52;
      unint64_t v163 = v7;
      unint64_t v164 = (uint64_t)v51;
      __s1 = v6;
      unint64_t v166 = v2;
      char v167 = v3;
      LOBYTE(v168) = 1;
      uint64_t v10 = &v157;
      unint64_t v65 = 0;
      uint64_t v64 = 1;
      goto LABEL_123;
    }

    unint64_t v54 = 0LL;
    uint64_t v4 = *(unsigned int *)v9;
    if ((v4 & 0x40000) == 0) {
      goto LABEL_99;
    }
LABEL_85:
    unint64_t v147 = v4;
    Swift::String::Index v200 = 0LL;
    v201[0] = 0LL;
    Swift::Int v199 = 0LL;
    unint64_t v142 = v54;
    unint64_t v55 = (char *)v53 + v54;
    unint64_t v56 = v53;
    char v57 = (char *)v53 + v54 + 1;
    uint64_t v58 = strlen(v57);
    if (!v58)
    {
      uint64_t v2 = 0LL;
      unint64_t v51 = 0LL;
      unint64_t v52 = 0LL;
      uint64_t v59 = 0LL;
      unint64_t v7 = 0LL;
      uint64_t v60 = v56;
      unint64_t v53 = v56;
      uint64_t v6 = 0LL;
LABEL_113:
      unint64_t v66 = (const char *)(v55 - (const char *)v60);
      unint64_t v3 = 1LL;
      uint64_t v4 = v147;
      unint64_t v54 = v142;
      goto LABEL_114;
    }

    unint64_t v152 = v28;
    uint64_t v59 = 0LL;
    unint64_t v7 = 0LL;
    unint64_t v138 = v56;
    uint64_t v60 = v56;
    uint64_t v6 = 0LL;
    unint64_t v61 = v55;
    while (2)
    {
      char v63 = *((unsigned __int8 *)v55 + 1);
      switch(v63)
      {
        case 'S':
          unint64_t v7 = (char *)(v55 + 2);
          unint64_t v62 = &v200;
LABEL_88:
          unint64_t v61 = &v57[v58];
          *unint64_t v62 = v58 - 1;
          break;
        case 'R':
          uint64_t v6 = v55 + 2;
          unint64_t v62 = &v199;
          goto LABEL_88;
        case 'N':
          uint64_t v59 = (uint64_t)(v55 + 2);
          unint64_t v62 = v201;
          uint64_t v60 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))(v55 + 2);
          goto LABEL_88;
      }

      unint64_t v55 = &v57[v58];
      v57 += v58 + 1;
      uint64_t v58 = strlen(v57);
      if (!v58)
      {
        unint64_t v51 = (unsigned int *)v200;
        unint64_t v52 = v201[0];
        unint64_t v55 = v61;
        uint64_t v2 = v199;
        unint64_t v28 = v152;
        unint64_t v53 = v138;
        goto LABEL_113;
      }

      continue;
    }
  }

  if (*((_WORD *)a2 + 8) != 71) {
    return 0LL;
  }
  BOOL v21 = *((unsigned __int8 *)a2 + 18);
  int64_t v22 = a2;
  if (v21 != 2)
  {
    if (v21 != 5 || *((_DWORD *)a2 + 2) < 2u) {
      return 0LL;
    }
    int64_t v22 = *(const char **)a2;
  }

  int64_t v23 = (swift::Demangle::__runtime::Node *)*((void *)v22 + 1);
  Swift::String::Index v158 = 0LL;
  unint64_t v159 = 0LL;
  unint64_t v160 = 0LL;
  unint64_t v162 = 0LL;
  LOBYTE(v163) = 0;
  Swift::String::Index v198 = 0LL;
  __s1 = 0LL;
  unint64_t v166 = 0LL;
  unint64_t v164 = 0LL;
  char v167 = 0;
  uint64_t v168 = 0u;
  unint64_t v169 = 0u;
  unint64_t v170 = 0u;
  int64_t v171 = 0u;
  unint64_t v172 = 0u;
  unint64_t v173 = 0u;
  char v174 = 0u;
  uint64_t v175 = 0u;
  size_t v176 = 0u;
  unint64_t v177 = 0u;
  unint64_t v178 = 0u;
  unint64_t v179 = 0u;
  unint64_t v180 = 0u;
  char v181 = 0u;
  uint64_t v182 = 0u;
  uint64_t v183 = 0u;
  uint64_t v184 = 0u;
  unint64_t v185 = 0u;
  unint64_t v186 = 0u;
  char v187 = 0u;
  uint64_t v188 = 0u;
  unint64_t v189 = 0u;
  unint64_t v190 = 0u;
  unint64_t v191 = 0u;
  unint64_t v192 = 0u;
  uint64_t v193 = 0u;
  size_t v194 = 0u;
  Swift::String::Index v195 = 0u;
  Swift::String::Index v196 = 0;
  unint64_t v161 = 2400LL;
  Swift::String::Index v157 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))off_189B8D828;
  ContextDescriptor = (const char *)_findContextDescriptor(v23, (swift::Demangle::__runtime::Demangler *)&v157);
  ExtendedTypeContextDescriptor = (const char *)_findExtendedTypeContextDescriptor(v9, &v157, v201);
  if (ContextDescriptor && ExtendedTypeContextDescriptor)
  {
    goto LABEL_233;
  }

  uint64_t v41 = v201[0];
  uint64_t v42 = *((unsigned __int16 *)v23 + 8);
  char v43 = *((unsigned __int8 *)v23 + 18);
  unint64_t v44 = (unsigned __int16 ***)v23;
  if (v43 != 2)
  {
    if (v43 != 5 || *((_DWORD *)v23 + 2) != 2) {
      goto LABEL_233;
    }
    unint64_t v44 = *(unsigned __int16 ****)v23;
  }

  if ((unint64_t v45 = *v44, *((_WORD *)v45 + 8) != 153)
    || v45[1] != (unsigned __int16 *)3
    || ((unint64_t v46 = *v45, v47 = *v46, v48 = *((unsigned __int8 *)v46 + 2), v47 == 24415) ? (v49 = v48 == 67) : (v49 = 0), !v49))
  {
LABEL_233:
    unint64_t v27 = 1;
    goto LABEL_234;
  }

  if (v43 == 2)
  {
LABEL_78:
    uint64_t v50 = *((void *)v23 + 1);
  }

  else
  {
    if (*((_DWORD *)v23 + 2) >= 2u)
    {
      int64_t v23 = *(swift::Demangle::__runtime::Node **)v23;
      goto LABEL_78;
    }

    uint64_t v50 = 0LL;
  }

  if (*(_WORD *)(v50 + 16) != 101) {
    goto LABEL_233;
  }
  unint64_t v122 = *(const void **)v50;
  unint64_t v123 = *(void *)(v50 + 8);
  unint64_t v124 = *(unsigned __int8 *)(v201[0] + 18LL);
  unint64_t v125 = (unsigned __int16 ***)v201[0];
  if (v124 != 2)
  {
    if (v124 != 5 || *(_DWORD *)(v201[0] + 8LL) != 2) {
      goto LABEL_233;
    }
    unint64_t v125 = *(unsigned __int16 ****)v201[0];
  }

  uint64_t v126 = *v125;
  size_t v127 = *v126;
  unint64_t v128 = *v127;
  size_t v129 = *((unsigned __int8 *)v127 + 2);
  if (v128 != 24415 || v129 != 67) {
    goto LABEL_233;
  }
  if (v124 == 2)
  {
LABEL_248:
    char v136 = *(void *)(v41 + 8);
  }

  else
  {
    if (*(_DWORD *)(v201[0] + 8LL) >= 2u)
    {
      uint64_t v41 = *(void *)v201[0];
      goto LABEL_248;
    }

    char v136 = 0LL;
  }

  if (*(_WORD *)(v136 + 16) == 101 && v123 == *(void *)(v136 + 8))
  {
    uint64_t v10 = &v157;
LABEL_37:
    size_t v26 = *((unsigned __int8 *)a2 + 18);
    if ((v26 - 1) >= 2)
    {
      if (v26 != 5 || !*((_DWORD *)a2 + 2))
      {
        unint64_t v27 = 0;
        a2 = 0LL;
        goto LABEL_234;
      }

      a2 = *(const char **)a2;
    }

    unint64_t v27 = 0;
    a2 = *(const char **)a2;
    goto LABEL_234;
  }

  unint64_t v27 = 1;
  uint64_t v10 = &v157;
LABEL_234:
  Swift::String::Index v157 = off_189B8E500;
  unint64_t v131 = v198;
  if (v198 == v197)
  {
    unint64_t v131 = v197;
    unint64_t v132 = 4LL;
LABEL_238:
    (*(void (**)(void))(*v131 + 8 * v132))();
  }

  else if (v198)
  {
    unint64_t v132 = 5LL;
    goto LABEL_238;
  }

  Swift::String::Index v157 = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(v160);
  if (v162) {
    *(_BYTE *)(v162 + 48) = 0;
  }
  if ((v27 & 1) == 0) {
    goto LABEL_242;
  }
  return 0LL;
}

__objc2_class **specialized _NativeDictionary.extractDictionary(using:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v40 = a1;
  uint64_t v41 = a2;
  uint64_t v47 = *(void *)(a5 - 8);
  uint64_t v48 = a6;
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  unint64_t v11 = (char *)&v40 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unint64_t v46 = (char *)&v40 - v15;
  if (!v13) {
    return &_swiftEmptyDictionarySingleton;
  }
  if (a4[2] != a3)
  {
    uint64_t v45 = specialized static _DictionaryStorage.allocate(capacity:)(a3, a5, v48);
    if (v41 < 1) {
      unint64_t v16 = 0LL;
    }
    else {
      unint64_t v16 = *v40;
    }
    uint64_t v17 = 0LL;
    uint64_t v42 = v45 + 64;
    char v43 = v11;
    uint64_t v44 = a5;
    unint64_t v18 = a5;
    uint64_t v19 = (uint64_t)v43;
    while (1)
    {
      uint64_t v51 = a3;
      if (v16)
      {
        uint64_t v49 = (v16 - 1) & v16;
        uint64_t v50 = v17;
        unint64_t v20 = __clz(__rbit64(v16)) | (v17 << 6);
      }

      else
      {
        uint64_t v21 = v17 + 1;
        if (__OFADD__(v17, 1LL)) {
          goto LABEL_29;
        }
        if (v21 >= v41) {
          return (__objc2_class **)v45;
        }
        unint64_t v22 = v40[v21];
        uint64_t v23 = v17 + 1;
        if (!v22)
        {
          uint64_t v23 = v17 + 2;
          if (v17 + 2 >= v41) {
            return (__objc2_class **)v45;
          }
          unint64_t v22 = v40[v23];
          if (!v22)
          {
            uint64_t v24 = v17 + 3;
            if (v17 + 3 >= v41) {
              return (__objc2_class **)v45;
            }
            unint64_t v22 = v40[v24];
            if (!v22)
            {
              while (1)
              {
                uint64_t v23 = v24 + 1;
                if (__OFADD__(v24, 1LL)) {
                  break;
                }
                if (v23 >= v41) {
                  return (__objc2_class **)v45;
                }
                unint64_t v22 = v40[v23];
                ++v24;
                if (v22) {
                  goto LABEL_22;
                }
              }

__objc2_class **_NativeDictionary.extractDictionary(using:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v49 = a6;
  uint64_t v50 = a7;
  unint64_t v39 = a1;
  uint64_t v40 = a2;
  uint64_t v44 = *(void *)(a6 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v47 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  unint64_t v46 = (char *)&v39 - v12;
  uint64_t v48 = v13;
  uint64_t v42 = *(void *)(v13 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v45 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  char v43 = (char *)&v39 - v19;
  if (!v17) {
    return &_swiftEmptyDictionarySingleton;
  }
  if (a4[2] == a3)
  {
    swift_retain(a4, v16, v17, v18);
    return (__objc2_class **)a4;
  }

  type metadata accessor for _DictionaryStorage(0LL, v48, v49, v50);
  uint64_t result = (__objc2_class **)static _DictionaryStorage.allocate(capacity:)(a3);
  uint64_t v41 = result;
  if (v40 < 1) {
    unint64_t v21 = 0LL;
  }
  else {
    unint64_t v21 = *v39;
  }
  uint64_t v22 = 0LL;
  uint64_t v23 = v43;
  unint64_t v25 = v48;
  uint64_t v24 = v49;
  while (1)
  {
    if (v21)
    {
      unint64_t v26 = __clz(__rbit64(v21));
      v21 &= v21 - 1;
      unint64_t v27 = v26 | (v22 << 6);
      goto LABEL_21;
    }

    BOOL v28 = __OFADD__(v22++, 1LL);
    if (v28) {
      goto LABEL_27;
    }
    if (v22 >= v40) {
      return v41;
    }
    unint64_t v29 = v39[v22];
    if (!v29) {
      break;
    }
LABEL_20:
    unint64_t v21 = (v29 - 1) & v29;
    unint64_t v27 = __clz(__rbit64(v29)) + (v22 << 6);
LABEL_21:
    uint64_t v31 = v42;
    (*(void (**)(char *, unint64_t, unint64_t))(v42 + 16))( v23,  a4[6] + *(void *)(v42 + 72) * v27,  v25);
    uint64_t v32 = v44;
    unint64_t v33 = a4[7] + *(void *)(v44 + 72) * v27;
    uint64_t v34 = v46;
    (*(void (**)(char *, unint64_t, uint64_t))(v44 + 16))(v46, v33, v24);
    unint64_t v35 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
    uint64_t v36 = (uint64_t)v45;
    v35(v45, v23, v25);
    unint64_t v37 = *(void (**)(char *, char *, uint64_t))(v32 + 32);
    uint64_t v38 = (uint64_t)v47;
    v37(v47, v34, v24);
    uint64_t result = (__objc2_class **)_NativeDictionary._unsafeInsertNew(key:value:)(v36, v38, v41, v25, v24, v50);
    BOOL v28 = __OFSUB__(a3--, 1LL);
    if (v28)
    {
      __break(1u);
      goto LABEL_26;
    }

    if (!a3) {
      return v41;
    }
  }

  uint64_t v30 = v22 + 1;
  if (v22 + 1 >= v40) {
    return v41;
  }
  unint64_t v29 = v39[v30];
  if (v29)
  {
    ++v22;
    goto LABEL_20;
  }

  while (1)
  {
    uint64_t v22 = v30 + 1;
    if (__OFADD__(v30, 1LL)) {
      break;
    }
    if (v22 >= v40) {
      return v41;
    }
    unint64_t v29 = v39[v22];
    ++v30;
    if (v29) {
      goto LABEL_20;
    }
  }

Swift::Int __swiftcall _NativeDictionary.hashValue(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  uint64_t v7 = *(void *)(v2 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](at.offset);
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v7 + 16))(v10, *(void *)(v11 + 48) + *(void *)(v7 + 72) * v8);
  Swift::Int v12 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v4 + 32))(*(void *)(v6 + 40), v5, v4);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v5);
  return v12;
}

uint64_t protocol witness for _HashTableDelegate.hashValue(at:) in conformance _NativeDictionary<A, B>( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *v2;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v8, *(void *)(v9 + 48) + *(void *)(v5 + 72) * v6, v4);
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a2 + 32) + 32LL))(*(void *)(v9 + 40), v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v4);
  return v10;
}

char *protocol witness for _HashTableDelegate.moveEntry(from:to:) in conformance _NativeDictionary<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *v3;
  UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(*(void *)(v7 + 48) + *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 72LL) * a1),  1LL,  (char *)(*(void *)(v7 + 48) + *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 72LL) * a2),  *(void *)(a3 + 16));
  return UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(*(void *)(v7 + 56) + *(void *)(*(void *)(*(void *)(a3 + 24) - 8LL) + 72LL) * a1),  1LL,  (char *)(*(void *)(v7 + 56) + *(void *)(*(void *)(*(void *)(a3 + 24) - 8LL) + 72LL) * a2),  *(void *)(a3 + 24));
}

Swift::Int specialized _NativeDictionary._delete(at:)(Swift::_HashTable::Bucket before, uint64_t a2)
{
  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1LL << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1LL << v6)) != 0)
    {
      unint64_t v11 = (before.offset + 1) & v7;
      do
      {
        uint64_t v13 = (unint64_t *)(*(void *)(a2 + 48) + 16 * v6);
        unint64_t v14 = *v13;
        unint64_t v15 = v13[1];
        uint64_t v16 = _swift_stdlib_Hashing_parameters ^ *(void *)(a2 + 40);
        v31[0] = 0LL;
        v31[1] = v16 ^ 0x736F6D6570736575LL;
        v31[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
        v31[3] = v16 ^ 0x6C7967656E657261LL;
        v31[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
        __int128 v32 = 0u;
        __int128 v33 = 0u;
        swift_bridgeObjectRetain(v15, v8.offset, v9.offset, (char *)v10.offset);
        String.hash(into:)(v31, v14, v15);
        swift_bridgeObjectRelease(v15);
        before.Swift::Int offset = Hasher._finalize()();
        unint64_t v17 = before.offset & v7;
        if (offset >= (uint64_t)v11)
        {
          if (v17 < v11) {
            goto LABEL_5;
          }
        }

        else if (v17 >= v11)
        {
          goto LABEL_11;
        }

        if (offset >= (uint64_t)v17)
        {
LABEL_11:
          uint64_t v18 = *(void *)(a2 + 48);
          uint64_t v19 = (_OWORD *)(v18 + 16 * offset);
          unint64_t v20 = (_OWORD *)(v18 + 16 * v6);
          if (offset != v6 || v19 >= v20 + 1) {
            *uint64_t v19 = *v20;
          }
          uint64_t v21 = *(void *)(a2 + 56);
          uint64_t v22 = (_OWORD *)(v21 + 32 * offset);
          uint64_t v23 = (_OWORD *)(v21 + 32 * v6);
          if (offset != v6 || (Swift::Int offset = v6, v22 >= v23 + 2))
          {
            __int128 v12 = v23[1];
            *uint64_t v22 = *v23;
            v22[1] = v12;
            Swift::Int offset = v6;
          }
        }

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  Swift::Int v15;
  uint64_t v18;
  unint64_t v19;
  __int128 *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  _OWORD *v24;
  _OWORD *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v33[3];
  uint64_t v34;
  uint64_t v35;
  uint64_t v36[3];
  uint64_t v37;
  uint64_t v38;
  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1LL << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1LL << v6)) != 0)
    {
      Swift::_HashTable::Bucket v8 = (before.offset + 1) & v7;
      do
      {
        outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v6, (uint64_t)v36);
        Swift::_HashTable::Bucket v9 = *(void *)(a2 + 40);
        Swift::_HashTable::Bucket v10 = v37;
        unint64_t v11 = v38;
        __swift_project_boxed_opaque_existential_0Tm(v36, v37);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v11 + 8))(v33, v10, v11);
        __int128 v12 = v34;
        uint64_t v13 = v35;
        __swift_project_boxed_opaque_existential_0Tm(v33, v34);
        unint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 40))(v9, v12, v13);
        __swift_destroy_boxed_opaque_existential_1Tm(v33);
        before.Swift::Int offset = (Swift::Int)outlined destroy of AnyHashable(v36);
        unint64_t v15 = v14 & v7;
        if (offset >= (uint64_t)v8)
        {
          if (v15 >= v8 && offset >= v15)
          {
LABEL_16:
            uint64_t v18 = *(void *)(a2 + 48);
            uint64_t v19 = v18 + 40 * offset;
            unint64_t v20 = (__int128 *)(v18 + 40 * v6);
            if (offset != v6 || v19 >= (unint64_t)v20 + 40)
            {
              uint64_t v21 = *v20;
              uint64_t v22 = v20[1];
              *(void *)(v19 + 32) = *((void *)v20 + 4);
              *(_OWORD *)uint64_t v19 = v21;
              *(_OWORD *)(v19 + 16) = v22;
            }

            uint64_t v23 = *(void *)(a2 + 56);
            uint64_t v24 = (_OWORD *)(v23 + 16 * offset);
            uint64_t v25 = (_OWORD *)(v23 + 16 * v6);
            if (offset != v6 || (Swift::Int offset = v6, v24 >= v25 + 1))
            {
              *uint64_t v24 = *v25;
              Swift::Int offset = v6;
            }
          }
        }

        else if (v15 >= v8 || offset >= v15)
        {
          goto LABEL_16;
        }

        unint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    uint64_t v26 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    uint64_t v27 = *v26;
    BOOL v28 = (-1LL << offset) - 1;
  }

  else
  {
    uint64_t v26 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    BOOL v28 = *v26;
    uint64_t v27 = (-1LL << SLOBYTE(before.offset)) - 1;
  }

  *uint64_t v26 = v28 & v27;
  uint64_t v29 = *(void *)(a2 + 16);
  uint64_t v30 = __OFSUB__(v29, 1LL);
  uint64_t v31 = v29 - 1;
  if (v30)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v31;
    ++*(_DWORD *)(a2 + 36);
  }

  return before.offset;
}

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  Swift::Int v16;
  uint64_t v19;
  unint64_t v20;
  __int128 *v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _OWORD *v25;
  _OWORD *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v34[3];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37[3];
  uint64_t v38;
  uint64_t v39;
  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1LL << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1LL << v6)) != 0)
    {
      Swift::_HashTable::Bucket v8 = (before.offset + 1) & v7;
      do
      {
        outlined init with copy of AnyHashable(*(void *)(a2 + 48) + 40 * v6, (uint64_t)v37);
        Swift::_HashTable::Bucket v10 = *(void *)(a2 + 40);
        unint64_t v11 = v38;
        __int128 v12 = v39;
        __swift_project_boxed_opaque_existential_0Tm(v37, v38);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v12 + 8))(v34, v11, v12);
        uint64_t v13 = v35;
        unint64_t v14 = v36;
        __swift_project_boxed_opaque_existential_0Tm(v34, v35);
        unint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 40))(v10, v13, v14);
        __swift_destroy_boxed_opaque_existential_1Tm(v34);
        before.Swift::Int offset = (Swift::Int)outlined destroy of AnyHashable(v37);
        uint64_t v16 = v15 & v7;
        if (offset >= (uint64_t)v8)
        {
          if (v16 >= v8 && offset >= v16)
          {
LABEL_16:
            uint64_t v19 = *(void *)(a2 + 48);
            unint64_t v20 = v19 + 40 * offset;
            uint64_t v21 = (__int128 *)(v19 + 40 * v6);
            if (offset != v6 || v20 >= (unint64_t)v21 + 40)
            {
              uint64_t v22 = *v21;
              uint64_t v23 = v21[1];
              *(void *)(v20 + 32) = *((void *)v21 + 4);
              *(_OWORD *)unint64_t v20 = v22;
              *(_OWORD *)(v20 + 16) = v23;
            }

            uint64_t v24 = *(void *)(a2 + 56);
            uint64_t v25 = (_OWORD *)(v24 + 32 * offset);
            uint64_t v26 = (_OWORD *)(v24 + 32 * v6);
            if (offset != v6 || (Swift::Int offset = v6, v25 >= v26 + 2))
            {
              Swift::_HashTable::Bucket v9 = v26[1];
              *uint64_t v25 = *v26;
              v25[1] = v9;
              Swift::Int offset = v6;
            }
          }
        }

        else if (v16 >= v8 || offset >= v16)
        {
          goto LABEL_16;
        }

        unint64_t v6 = (v6 + 1) & v7;
      }

      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0);
    }

    uint64_t v27 = (uint64_t *)(v4 + 8 * ((unint64_t)offset >> 6));
    BOOL v28 = *v27;
    uint64_t v29 = (-1LL << offset) - 1;
  }

  else
  {
    uint64_t v27 = (uint64_t *)(v4 + 8 * ((unint64_t)before.offset >> 6));
    uint64_t v29 = *v27;
    BOOL v28 = (-1LL << SLOBYTE(before.offset)) - 1;
  }

  *uint64_t v27 = v29 & v28;
  uint64_t v30 = *(void *)(a2 + 16);
  uint64_t v31 = __OFSUB__(v30, 1LL);
  __int128 v32 = v30 - 1;
  if (v31)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a2 + 16) = v32;
    ++*(_DWORD *)(a2 + 36);
  }

  return before.offset;
}

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  Swift::_HashTable::Bucket v8;
  Swift::_HashTable::Bucket v9;
  Swift::_HashTable::Bucket v10;
  unint64_t v11;
  __int128 v12;
  __int128 v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  _OWORD *v21;
  uint64_t v22;
  unint64_t v23;
  __int128 *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  unint64_t v32[5];
  __int128 v33;
  __int128 v34;
  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1LL << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1LL << v6)) != 0)
    {
      unint64_t v11 = (before.offset + 1) & v7;
      do
      {
        unint64_t v14 = (unint64_t *)(*(void *)(a2 + 48) + 16 * v6);
        unint64_t v15 = *v14;
        uint64_t v16 = v14[1];
        unint64_t v17 = _swift_stdlib_Hashing_parameters ^ *(void *)(a2 + 40);
        v32[0] = 0LL;
        v32[1] = v17 ^ 0x736F6D6570736575LL;
        void v32[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
        v32[3] = v17 ^ 0x6C7967656E657261LL;
        v32[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
        __int128 v33 = 0u;
        uint64_t v34 = 0u;
        swift_bridgeObjectRetain(v16, v8.offset, v9.offset, (char *)v10.offset);
        String.hash(into:)(v32, v15, v16);
        swift_bridgeObjectRelease(v16);
        before.Swift::Int offset = Hasher._finalize()();
        uint64_t v18 = before.offset & v7;
        if (offset >= (uint64_t)v11)
        {
          if (v18 < v11) {
            goto LABEL_5;
          }
        }

        else if (v18 >= v11)
        {
          goto LABEL_11;
        }

        if (offset >= (uint64_t)v18)
        {
LABEL_11:
          uint64_t v19 = *(void *)(a2 + 48);
          unint64_t v20 = (_OWORD *)(v19 + 16 * offset);
          uint64_t v21 = (_OWORD *)(v19 + 16 * v6);
          if (offset != v6 || v20 >= v21 + 1) {
            *unint64_t v20 = *v21;
          }
          uint64_t v22 = *(void *)(a2 + 56);
          uint64_t v23 = v22 + 40 * offset;
          uint64_t v24 = (__int128 *)(v22 + 40 * v6);
          if (offset != v6 || (Swift::Int offset = v6, v23 >= (unint64_t)v24 + 40))
          {
            __int128 v12 = *v24;
            uint64_t v13 = v24[1];
            *(void *)(v23 + 32) = *((void *)v24 + 4);
            *(_OWORD *)uint64_t v23 = v12;
            *(_OWORD *)(v23 + 16) = v13;
            Swift::Int offset = v6;
          }
        }

{
  Swift::Int offset;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  Swift::_HashTable::Bucket v8;
  Swift::_HashTable::Bucket v9;
  Swift::_HashTable::Bucket v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  _OWORD *v19;
  uint64_t v20;
  _OWORD *v21;
  _OWORD *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  unint64_t v30[5];
  __int128 v31;
  __int128 v32;
  Swift::Int offset = before.offset;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = (before.offset + 1) & ~v5;
  if (((1LL << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    before.Swift::Int offset = _HashTable.previousHole(before:)(before).offset;
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1LL << v6)) != 0)
    {
      unint64_t v11 = (before.offset + 1) & v7;
      do
      {
        __int128 v12 = (unint64_t *)(*(void *)(a2 + 48) + 16 * v6);
        uint64_t v13 = *v12;
        unint64_t v14 = v12[1];
        unint64_t v15 = _swift_stdlib_Hashing_parameters ^ *(void *)(a2 + 40);
        v30[0] = 0LL;
        v30[1] = v15 ^ 0x736F6D6570736575LL;
        _OWORD v30[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
        v30[3] = v15 ^ 0x6C7967656E657261LL;
        v30[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
        uint64_t v31 = 0u;
        __int128 v32 = 0u;
        swift_bridgeObjectRetain(v14, v8.offset, v9.offset, (char *)v10.offset);
        String.hash(into:)(v30, v13, v14);
        swift_bridgeObjectRelease(v14);
        before.Swift::Int offset = Hasher._finalize()();
        uint64_t v16 = before.offset & v7;
        if (offset >= (uint64_t)v11)
        {
          if (v16 < v11) {
            goto LABEL_5;
          }
        }

        else if (v16 >= v11)
        {
          goto LABEL_11;
        }

        if (offset >= (uint64_t)v16)
        {
LABEL_11:
          unint64_t v17 = *(void *)(a2 + 48);
          uint64_t v18 = (_OWORD *)(v17 + 16 * offset);
          uint64_t v19 = (_OWORD *)(v17 + 16 * v6);
          if (offset != v6 || v18 >= v19 + 1) {
            char *v18 = *v19;
          }
          unint64_t v20 = *(void *)(a2 + 56);
          uint64_t v21 = (_OWORD *)(v20 + 16 * offset);
          uint64_t v22 = (_OWORD *)(v20 + 16 * v6);
          if (offset != v6 || (Swift::Int offset = v6, v21 >= v22 + 1))
          {
            *uint64_t v21 = *v22;
            Swift::Int offset = v6;
          }
        }

Swift::Void __swiftcall _NativeDictionary._delete(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v4 = v2;
  uint64_t v5 = v1;
  Swift::Int offset = at.offset;
  uint64_t v45 = *(void *)(v2 - 8);
  uint64_t v46 = v3;
  uint64_t v7 = MEMORY[0x1895F8858](at.offset);
  Swift::_HashTable::Bucket v10 = (char *)&v41 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = v11 + 64;
  uint64_t v13 = -1LL << *(_BYTE *)(v11 + 32);
  unint64_t v14 = (v7 + 1) & ~v13;
  if (((1LL << v14) & *(void *)(v11 + 64 + 8 * (v14 >> 6))) != 0)
  {
    uint64_t v41 = v8;
    uint64_t v15 = ~v13;
    v16.Swift::Int offset = _HashTable.previousHole(before:)((Swift::_HashTable::Bucket)offset).offset;
    if ((*(void *)(v12 + 8 * (v14 >> 6)) & (1LL << v14)) != 0)
    {
      unint64_t v43 = (v16.offset + 1) & v15;
      uint64_t v44 = *(uint64_t (**)(void, uint64_t, uint64_t))(v46 + 32);
      uint64_t v17 = *(void *)(v45 + 72);
      uint64_t v42 = *(void (**)(char *, unint64_t, uint64_t))(v45 + 16);
      uint64_t v18 = v15;
      do
      {
        uint64_t v19 = v17;
        int64_t v20 = v17 * v14;
        uint64_t v21 = v18;
        v42(v10, *(void *)(v5 + 48) + v17 * v14, v4);
        uint64_t v22 = v44(*(void *)(v5 + 40), v4, v46);
        (*(void (**)(char *, uint64_t))(v45 + 8))(v10, v4);
        uint64_t v18 = v21;
        Swift::Int v23 = v22 & v21;
        if (offset >= (uint64_t)v43)
        {
          if (v23 >= v43 && offset >= v23)
          {
LABEL_16:
            uint64_t v26 = *(void *)(v5 + 48);
            uint64_t v27 = (char *)(v26 + v19 * offset);
            BOOL v28 = (char *)(v26 + v20);
            if (v19 * offset < v20 || v27 >= &v28[v19])
            {
              swift_arrayInitWithTakeFrontToBack(v27, v28, 1LL, v4);
            }

            else if (v19 * offset != v20)
            {
              swift_arrayInitWithTakeBackToFront(v27, v28, 1LL, v4);
            }

            uint64_t v29 = *(void *)(v5 + 56);
            uint64_t v30 = *(void *)(*(void *)(v41 - 8) + 72LL);
            Swift::Int v31 = v30 * offset;
            __int128 v32 = (char *)(v29 + v30 * offset);
            __int128 v33 = (char *)(v29 + v30 * v14);
            if (v30 * offset < (uint64_t)(v30 * v14) || v32 >= &v33[v30])
            {
              swift_arrayInitWithTakeFrontToBack(v32, v33, 1LL, v41);
              Swift::Int offset = v14;
              uint64_t v17 = v19;
              uint64_t v18 = v21;
            }

            else
            {
              Swift::Int offset = v14;
              uint64_t v17 = v19;
              uint64_t v18 = v21;
              if (v31 != v30 * v14)
              {
                swift_arrayInitWithTakeBackToFront(v32, v33, 1LL, v41);
                uint64_t v18 = v21;
                uint64_t v17 = v19;
                Swift::Int offset = v14;
              }
            }

            goto LABEL_5;
          }
        }

        else if (v23 >= v43 || offset >= v23)
        {
          goto LABEL_16;
        }

        uint64_t v17 = v19;
LABEL_5:
        unint64_t v14 = (v14 + 1) & v18;
      }

      while (((*(void *)(v12 + ((v14 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v14) & 1) != 0);
    }

    unint64_t v35 = (uint64_t *)(v12 + 8 * ((unint64_t)offset >> 6));
    uint64_t v36 = *v35;
    uint64_t v37 = (-1LL << offset) - 1;
  }

  else
  {
    unint64_t v35 = (uint64_t *)(v12 + 8 * ((unint64_t)offset >> 6));
    uint64_t v37 = *v35;
    uint64_t v36 = (-1LL << offset) - 1;
  }

  *unint64_t v35 = v37 & v36;
  uint64_t v38 = *(void *)(v5 + 16);
  BOOL v39 = __OFSUB__(v38, 1LL);
  uint64_t v40 = v38 - 1;
  if (v39)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v5 + 16) = v40;
    ++*(_DWORD *)(v5 + 36);
  }

__objc2_class **_ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFADs13_UnsafeBitsetVKXEfU_AhByxSiSgGxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxAIIsgnndzo_AJsAK_pSHRzAIRs_r0_lIetyggozo_Tp5( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, uint64_t *), uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v28 = a2;
  uint64_t v29 = a7;
  uint64_t v34 = a4;
  uint64_t v30 = a1;
  uint64_t v38 = a6;
  uint64_t v8 = *(void *)(a6 - 8);
  uint64_t result = (__objc2_class **)MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int64_t v12 = 0LL;
  unint64_t v35 = (unint64_t *)v13;
  uint64_t v14 = *(void *)(v13 + 64);
  uint64_t v31 = 0LL;
  uint64_t v32 = v13 + 64;
  uint64_t v15 = 1LL << *(_BYTE *)(v13 + 32);
  uint64_t v16 = -1LL;
  if (v15 < 64) {
    uint64_t v16 = ~(-1LL << v15);
  }
  unint64_t v17 = v16 & v14;
  int64_t v33 = (unint64_t)(v15 + 63) >> 6;
  uint64_t v18 = v38;
  while (v17)
  {
    unint64_t v19 = __clz(__rbit64(v17));
    v17 &= v17 - 1;
    unint64_t v20 = v19 | (v12 << 6);
LABEL_15:
    uint64_t v24 = v35;
    (*(void (**)(char *, unint64_t, uint64_t))(v8 + 16))(v11, v35[6] + *(void *)(v8 + 72) * v20, v18);
    uint64_t v25 = v24[7] + 16 * v20;
    uint64_t v26 = *(void *)v25;
    LOBYTE(v25) = *(_BYTE *)(v25 + 8);
    uint64_t v36 = v26;
    char v37 = v25;
    char v27 = v34(v11, &v36);
    uint64_t result = (__objc2_class **)(*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v18);
    if (v7) {
      return result;
    }
    if ((v27 & 1) != 0)
    {
      *(unint64_t *)((char *)v30 + ((v20 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v20;
      BOOL v21 = __OFADD__(v31++, 1LL);
      if (v21) {
        goto LABEL_28;
      }
    }
  }

  BOOL v21 = __OFADD__(v12++, 1LL);
  if (v21)
  {
    __break(1u);
    goto LABEL_27;
  }

  if (v12 >= v33) {
    return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v35, v38, v29);
  }
  unint64_t v22 = *(void *)(v32 + 8 * v12);
  if (v22)
  {
LABEL_14:
    unint64_t v17 = (v22 - 1) & v22;
    unint64_t v20 = __clz(__rbit64(v22)) + (v12 << 6);
    goto LABEL_15;
  }

  int64_t v23 = v12 + 1;
  if (v12 + 1 >= v33) {
    return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v35, v38, v29);
  }
  unint64_t v22 = *(void *)(v32 + 8 * v23);
  if (v22) {
    goto LABEL_13;
  }
  int64_t v23 = v12 + 2;
  if (v12 + 2 >= v33) {
    return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v35, v38, v29);
  }
  unint64_t v22 = *(void *)(v32 + 8 * v23);
  if (v22)
  {
LABEL_13:
    int64_t v12 = v23;
    goto LABEL_14;
  }

  while (1)
  {
    int64_t v12 = v23 + 1;
    if (__OFADD__(v23, 1LL)) {
      break;
    }
    if (v12 >= v33) {
      return specialized _NativeDictionary.extractDictionary(using:count:)(v30, v28, v31, v35, v38, v29);
    }
    unint64_t v22 = *(void *)(v32 + 8 * v12);
    ++v23;
    if (v22) {
      goto LABEL_14;
    }
  }

__objc2_class **closure #1 in _NativeDictionary.filter(_:)@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(char *, char *)@<X3>, uint64_t a4@<X6>, uint64_t a5@<X7>, __objc2_class ***a6@<X8>)
{
  uint64_t v37 = a5;
  uint64_t v38 = a1;
  uint64_t v35 = a2;
  uint64_t v36 = a6;
  uint64_t v50 = a4;
  uint64_t v46 = *(void *)(a4 - 8);
  uint64_t v47 = a3;
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v45 = (char *)&v35 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v49 = v8;
  uint64_t v44 = *(void *)(v8 - 8);
  uint64_t result = (__objc2_class **)MEMORY[0x1895F8858](v6);
  unint64_t v43 = (char *)&v35 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int64_t v11 = 0LL;
  uint64_t v48 = (unint64_t *)v12;
  uint64_t v13 = *(void *)(v12 + 64);
  uint64_t v39 = 0LL;
  uint64_t v40 = v12 + 64;
  uint64_t v14 = 1LL << *(_BYTE *)(v12 + 32);
  uint64_t v15 = -1LL;
  if (v14 < 64) {
    uint64_t v15 = ~(-1LL << v14);
  }
  unint64_t v16 = v15 & v13;
  int64_t v41 = (unint64_t)(v14 + 63) >> 6;
  uint64_t v18 = v43;
  uint64_t v17 = v44;
  uint64_t v19 = v49;
  uint64_t v20 = v46;
  while (v16)
  {
    uint64_t v51 = (v16 - 1) & v16;
    int64_t v52 = v11;
    unint64_t v21 = __clz(__rbit64(v16)) | (v11 << 6);
LABEL_16:
    uint64_t v26 = v48;
    (*(void (**)(char *, unint64_t, uint64_t))(v17 + 16))( v18,  v48[6] + *(void *)(v17 + 72) * v21,  v19);
    unint64_t v27 = v26[7];
    uint64_t v28 = *(void *)(v20 + 72);
    unint64_t v42 = v21;
    unint64_t v29 = v27 + v28 * v21;
    uint64_t v30 = v45;
    uint64_t v31 = v50;
    (*(void (**)(char *, unint64_t, uint64_t))(v20 + 16))(v45, v29, v50);
    uint64_t v32 = v53;
    char v33 = v47(v18, v30);
    (*(void (**)(char *, uint64_t))(v20 + 8))(v30, v31);
    uint64_t result = (__objc2_class **)(*(uint64_t (**)(char *, uint64_t))(v17 + 8))(v18, v19);
    uint64_t v53 = v32;
    if (v32) {
      return result;
    }
    unint64_t v16 = v51;
    int64_t v11 = v52;
    if ((v33 & 1) != 0)
    {
      *(unint64_t *)((char *)v38 + ((v42 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v42;
      BOOL v22 = __OFADD__(v39++, 1LL);
      if (v22)
      {
        __break(1u);
LABEL_21:
        uint64_t v34 = v36;
        uint64_t result = _NativeDictionary.extractDictionary(using:count:)(v38, v35, v39, v48, v49, v50, v37);
        *uint64_t v34 = result;
        return result;
      }
    }
  }

  BOOL v22 = __OFADD__(v11, 1LL);
  int64_t v23 = v11 + 1;
  if (v22) {
    goto LABEL_24;
  }
  if (v23 >= v41) {
    goto LABEL_21;
  }
  unint64_t v24 = *(void *)(v40 + 8 * v23);
  if (v24)
  {
LABEL_15:
    uint64_t v51 = (v24 - 1) & v24;
    int64_t v52 = v23;
    unint64_t v21 = __clz(__rbit64(v24)) + (v23 << 6);
    goto LABEL_16;
  }

  int64_t v25 = v23 + 1;
  if (v23 + 1 >= v41) {
    goto LABEL_21;
  }
  unint64_t v24 = *(void *)(v40 + 8 * v25);
  if (v24)
  {
    ++v23;
    goto LABEL_15;
  }

  while (1)
  {
    int64_t v23 = v25 + 1;
    if (__OFADD__(v25, 1LL)) {
      break;
    }
    if (v23 >= v41) {
      goto LABEL_21;
    }
    unint64_t v24 = *(void *)(v40 + 8 * v23);
    ++v25;
    if (v24) {
      goto LABEL_15;
    }
  }

  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

uint64_t (*_NativeDictionary.Iterator.iterator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _NativeDictionary.Iterator.init(_:)@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1LL;
  uint64_t v3 = -1LL << *(_BYTE *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t result = a1 + 64;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1LL << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0LL;
  a2[4] = v2 & v5;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _NativeDictionary<A, B>@<X0>( void *a1@<X8>)
{
  return _NativeDictionary.makeIterator()(*v1, a1);
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _NativeDictionary<A, B>.Iterator@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = result;
  unint64_t v5 = v2[4];
  if (v5)
  {
    v2[4] = (v5 - 1) & v5;
    unint64_t v6 = __clz(__rbit64(v5)) | (v2[3] << 6);
LABEL_3:
    uint64_t v7 = *v2;
    uint64_t v8 = *(void *)(*v2 + 48LL);
    uint64_t v9 = *(void *)(result + 16);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)(v9 - 8) + 16LL))( a2,  v8 + *(void *)(*(void *)(v9 - 8) + 72LL) * v6,  v9);
    uint64_t v10 = *(void *)(v7 + 56);
    uint64_t v11 = *(void *)(v3 + 24);
    uint64_t v12 = *(void *)(v11 - 8);
    uint64_t v13 = v10 + *(void *)(v12 + 72) * v6;
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v11, "key value ", 0LL);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a2 + *((int *)TupleTypeMetadata2 + 12), v13, v11);
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 56);
    uint64_t v16 = a2;
    uint64_t v17 = 0LL;
    uint64_t v18 = TupleTypeMetadata2;
    return v15(v16, v17, 1LL, v18);
  }

  uint64_t v19 = v2[3];
  int64_t v20 = v19 + 1;
  if (!__OFADD__(v19, 1LL))
  {
    int64_t v21 = (unint64_t)(v2[2] + 64LL) >> 6;
    if (v20 < v21)
    {
      v2[3] = v20;
      uint64_t v22 = v2[1];
      unint64_t v23 = *(void *)(v22 + 8 * v20);
      v2[4] = v23;
      if (v23)
      {
LABEL_11:
        v2[4] = (v23 - 1) & v23;
        unint64_t v6 = __clz(__rbit64(v23)) + (v20 << 6);
        goto LABEL_3;
      }

      uint64_t v24 = v19 + 2;
      while (v21 != v24)
      {
        v2[3] = v24;
        unint64_t v23 = *(void *)(v22 + 8 * v24);
        v2[4] = v23;
        ++v24;
        if (v23)
        {
          int64_t v20 = v24 - 1;
          goto LABEL_11;
        }
      }
    }

    uint64_t v18 = swift_getTupleTypeMetadata2(0LL, *(void *)(result + 16), *(void *)(result + 24), "key value ", 0LL);
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(*(v18 - 1) + 56);
    uint64_t v16 = a2;
    uint64_t v17 = 1LL;
    return v15(v16, v17, 1LL, v18);
  }

  __break(1u);
  return result;
}

uint64_t _NativeSet._storage.setter(uint64_t a1)
{
  uint64_t result = swift_release(*v1);
  *uint64_t v1 = a1;
  return result;
}

uint64_t (*_NativeSet._storage.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

__objc2_class **_NativeSet.init()()
{
  return &_swiftEmptySetSingleton;
}

__objc2_class **static __RawSetStorage.empty.getter()
{
  return &_swiftEmptySetSingleton;
}

__objc2_class **_NativeSet.init(capacity:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return &_swiftEmptySetSingleton;
  }
  type metadata accessor for _SetStorage(0LL, a2, a3, a4);
  return (__objc2_class **)static _SetStorage.allocate(capacity:)(a1);
}

uint64_t specialized static _SetStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v2 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v2 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
  }

  else
  {
    char v5 = 64 - __clz(v4 - 1);
    else {
      char v6 = v5;
    }
    return (uint64_t)specialized static _SetStorage.allocate(scale:age:seed:)(v6, 0x100000000LL, 0LL, 1);
  }

  return result;
}

uint64_t static _SetStorage.allocate(capacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1LL;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v2 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v2 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  BOOL v3 = __OFADD__(v1, 1LL);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
  }

  else
  {
    char v5 = 64 - __clz(v4 - 1);
    else {
      char v6 = v5;
    }
    return (uint64_t)static _SetStorage.allocate(scale:age:seed:)(v6, 0x100000000LL, 0LL, 1);
  }

  return result;
}

__objc2_class **_NativeSet.init(_:)(void *a1, char *a2, uint64_t a3)
{
  return _NativeSet.init(_:capacity:)(a1, (uint64_t)objc_msgSend(a1, sel_count), a2, a3);
}

id __CocoaSet.count.getter(void *a1)
{
  return objc_msgSend(a1, sel_count);
}

__objc2_class **_NativeSet.init(_:capacity:)(void *a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v18 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (!a2)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptySetSingleton;
  }

  uint64_t v45 = v14;
  uint64_t v46 = v16;
  uint64_t v43 = v11;
  uint64_t v44 = v13;
  uint64_t v42 = v15;
  type metadata accessor for _SetStorage(0LL, (uint64_t)a3, a4, v12);
  char v19 = specialized static _HashTable.scale(forCapacity:)(a2);
  unsigned int v20 = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)a1);
  LOBYTE(v48) = 0;
  int64_t v21 = static _SetStorage.allocate(scale:age:seed:)(v19, v20, 0LL, 1);
  uint64_t v48 = v21;
  uint64_t v22 = type metadata accessor for __CocoaSet.Iterator();
  uint64_t v26 = swift_allocObject(v22, 0xE8uLL, 7uLL);
  uint64_t v27 = 0LL;
  *((_OWORD *)v26 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v26 + 5) = 0u;
  v26[27] = 0LL;
  uint64_t v28 = v26 + 27;
  *((_OWORD *)v26 + 2) = 0u;
  *((_OWORD *)v26 + 3) = 0u;
  *((_OWORD *)v26 + 4) = 0u;
  *((_OWORD *)v26 + 6) = 0u;
  *((_OWORD *)v26 + 7) = 0u;
  *((_OWORD *)v26 + 8) = 0u;
  *((_OWORD *)v26 + 9) = 0u;
  *((_OWORD *)v26 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 0) = 0u;
  *((_OWORD *)v26 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v26 + 12) = 0u;
  v26[26] = a1;
  v26[28] = 0LL;
  while (v27 != v26[28])
  {
LABEL_7:
    uint64_t v30 = v26[3];
    if (!v30) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
    }
    if ((unint64_t)(v27 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_21:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
    }

    uint64_t v31 = (void **)(v30 + 8 * v27);
    uint64_t v32 = *v31;
    uint64_t *v28 = v27 + 1;
    swift_unknownObjectRetain(v32, v23, v24, v25);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      uint64_t v47 = v32;
      swift_dynamicCast(v18, (uint64_t *)&v47, (swift *)&unk_189B8D230, a3, 7uLL);
    }

    else
    {
      uint64_t v36 = v44;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v46 + 56))(v44, 1LL, 1LL, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v32, (uint64_t)a3, v36);
      swift_unknownObjectRelease(v32);
      uint64_t v37 = v42;
      uint64_t v38 = v36;
      uint64_t v39 = v43;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(v45 + 16))(v42, v38, v43);
      if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(v46 + 48))(v37, 1LL, a3) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v45 + 8))(v44, v39);
      (*(void (**)(char *, uint64_t, char *))(v46 + 32))(v18, v37, a3);
      int64_t v21 = v48;
    }

    unint64_t v34 = v21[2];
    if (v21[3] <= v34)
    {
      Swift::Int v35 = v34 + 1;
      type metadata accessor for _NativeSet(0LL, (uint64_t)a3, a4, v33);
      _NativeSet.resize(capacity:)(v35);
      int64_t v21 = v48;
    }

    _NativeSet._unsafeInsertNew(_:)((uint64_t)v18, (uint64_t)v21, (uint64_t)a3, a4);
    uint64_t v27 = *v28;
    if (*v28 < 0) {
      goto LABEL_18;
    }
  }

  id v29 = objc_msgSend((id)v26[26], sel_countByEnumeratingWithState_objects_count_, v26 + 2, v26 + 10, 16);
  v26[28] = v29;
  if (v29)
  {
    uint64_t v27 = 0LL;
    uint64_t *v28 = 0LL;
    goto LABEL_7;
  }

  v26[27] = -1LL;
LABEL_18:
  swift_release((uint64_t)v26);
  return (__objc2_class **)v21;
}

uint64_t static _SetStorage.convert(_:capacity:)(uint64_t a1, uint64_t a2)
{
  return static _DictionaryStorage.convert(_:capacity:)( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))static _SetStorage.allocate(scale:age:seed:));
}

uint64_t static _DictionaryStorage.convert(_:capacity:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, void, uint64_t))
{
  uint64_t v4 = specialized static _HashTable.scale(forCapacity:)(a2);
  uint64_t v5 = specialized static Hasher._hash(seed:_:)(0LL, a1);
  return a3(v4, v5, 0LL, 1LL);
}

double __CocoaSet.makeIterator()(uint64_t a1)
{
  return __CocoaDictionary.makeIterator()(a1, type metadata accessor for __CocoaSet.Iterator);
}

double __CocoaDictionary.makeIterator()(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2();
  uint64_t v4 = swift_allocObject(v3, 0xE8uLL, 7uLL);
  double result = 0.0;
  *((_OWORD *)v4 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 0) = 0u;
  *((_OWORD *)v4 + 1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0u;
  *((_OWORD *)v4 + 12) = 0u;
  v4[27] = 0LL;
  v4[28] = 0LL;
  v4[26] = a1;
  return result;
}

id __CocoaSet.Iterator.next()(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = *(void *)(v4 + 216);
  if (v5 < 0) {
    return 0LL;
  }
  if (v5 != *(void *)(v4 + 224)) {
    goto LABEL_5;
  }
  id result = objc_msgSend(*(id *)(v4 + 208), sel_countByEnumeratingWithState_objects_count_, v4 + 16, v4 + 80, 16);
  *(void *)(v4 + 224) = result;
  if (result)
  {
    uint64_t v5 = 0LL;
    *(void *)(v4 + 216) = 0LL;
LABEL_5:
    uint64_t v7 = *(void *)(v4 + 24);
    if (!v7) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x254uLL,  0);
    }
    if ((unint64_t)(v5 - 0x1000000000000000LL) >> 61 == 7)
    {
      uint64_t v8 = (void **)(v7 + 8 * v5);
      if ((v8 & 7) == 0)
      {
        uint64_t v9 = *v8;
        *(void *)(v4 + 216) = v5 + 1;
        return swift_unknownObjectRetain(v9, a2, a3, a4);
      }
    }

    else
    {
      __break(1u);
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
  }

  *(void *)(v4 + 216) = -1LL;
  return result;
}

uint64_t _NativeSet.insertNew(_:isUnique:)(uint64_t a1, char a2, uint64_t a3)
{
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 <= v6 || (a2 & 1) == 0)
  {
    Swift::Int v8 = v6 + 1;
    if ((a2 & 1) != 0)
    {
      _NativeSet.resize(capacity:)(v8);
    }

    else if (v7 <= v6)
    {
      _NativeSet.copyAndResize(capacity:)(v8);
    }

    else
    {
      _NativeSet.copy()();
    }
  }

  return _NativeSet._unsafeInsertNew(_:)(a1, *v3, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t _NativeSet.capacity.getter(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t __RawSetStorage._bucketCount.getter()
{
  return 1LL << *(_BYTE *)(v0 + 32);
}

uint64_t _NativeSet.hashTable.getter(uint64_t a1)
{
  return a1 + 56;
}

uint64_t __RawSetStorage._hashTable.getter()
{
  return v0 + 56;
}

uint64_t _NativeSet.age.getter(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t _NativeSet._elements.getter(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

Swift::Void __swiftcall _NativeSet.invalidateIndices()()
{
}

uint64_t _NativeSet.uncheckedElement(at:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  *(void *)(a2 + 48) + *(void *)(*(void *)(a3 - 8) + 72LL) * a1);
}

uint64_t _NativeSet.uncheckedInitialize(at:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32LL))( *(void *)(a3 + 48) + *(void *)(*(void *)(a4 - 8) + 72LL) * a1,  a2,  a4);
}

uint64_t _NativeSet.hashValue(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
}

unint64_t _NativeSet.find(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v28 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(v11 + 40);
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 32);
  uint64_t v30 = a1;
  uint64_t v16 = v14(v12, v15, v13);
  uint64_t v17 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v18 = v16 & ~v17;
  uint64_t v31 = a2;
  uint64_t v19 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v18 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v18) & 1) != 0)
  {
    uint64_t v29 = ~v17;
    uint64_t v20 = *(void *)(a4 + 8);
    int64_t v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v20 + 8);
    uint64_t v22 = v8;
    uint64_t v23 = *(void *)(v8 + 72);
    uint64_t v24 = v22;
    int64_t v25 = *(void (**)(char *, unint64_t, uint64_t))(v22 + 16);
    do
    {
      v25(v10, *(void *)(v31 + 48) + v23 * v18, a3);
      char v26 = v21(v10, v30, a3, v20);
      (*(void (**)(char *, uint64_t))(v24 + 8))(v10, a3);
      if ((v26 & 1) != 0) {
        break;
      }
      unint64_t v18 = (v18 + 1) & v29;
    }

    while (((*(void *)(v19 + ((v18 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v18) & 1) != 0);
  }

  return v18;
}

unint64_t _NativeSet.find(_:hashValue:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = -1LL << *(_BYTE *)(v9 + 32);
  unint64_t v12 = v11 & ~v10;
  uint64_t v24 = v9;
  uint64_t v13 = v9 + 56;
  if (((*(void *)(v9 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v12) & 1) != 0)
  {
    uint64_t v22 = ~v10;
    uint64_t v14 = *(void *)(v5 + 8);
    uint64_t v15 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v14 + 8);
    uint64_t v16 = *(void *)(v6 + 72);
    uint64_t v17 = v6;
    unint64_t v18 = *(void (**)(char *, unint64_t, uint64_t))(v6 + 16);
    do
    {
      v18(v8, *(void *)(v24 + 48) + v16 * v12, a4);
      char v19 = v15(v8, v23, a4, v14);
      (*(void (**)(char *, uint64_t))(v17 + 8))(v8, a4);
      if ((v19 & 1) != 0) {
        break;
      }
      unint64_t v12 = (v12 + 1) & v22;
    }

    while (((*(void *)(v13 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v12) & 1) != 0);
  }

  return v12;
}

Swift::Int specialized _NativeSet.resize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  uint64_t v7 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000LL, 0LL, 1);
  if (!*(void *)(v2 + 16)) {
    goto LABEL_26;
  }
  uint64_t v8 = 1LL << *(_BYTE *)(v2 + 32);
  uint64_t v9 = (void *)(v2 + 56);
  uint64_t v10 = -1LL;
  if (v8 < 64) {
    uint64_t v10 = ~(-1LL << v8);
  }
  unint64_t v11 = v10 & *(void *)(v2 + 56);
  int64_t v12 = (unint64_t)(v8 + 63) >> 6;
  Swift::Int result = (Swift::Int)swift_retain((unint64_t *)v2, v4, v5, v6);
  int64_t v14 = 0LL;
  while (1)
  {
    if (v11)
    {
      unint64_t v15 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v16 = v15 | (v14 << 6);
      goto LABEL_8;
    }

    int64_t v17 = v14 + 1;
    if (__OFADD__(v14, 1LL))
    {
      __break(1u);
LABEL_28:
      __break(1u);
      return result;
    }

    if (v17 >= v12) {
      goto LABEL_22;
    }
    unint64_t v18 = v9[v17];
    ++v14;
    if (!v18)
    {
      int64_t v14 = v17 + 1;
      if (v17 + 1 >= v12) {
        goto LABEL_22;
      }
      unint64_t v18 = v9[v14];
      if (!v18) {
        break;
      }
    }

void specialized _NativeSet.resize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  LOBYTE(v22[0]) = 1;
  uint64_t v7 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000LL, 0LL, 1);
  if (!*(void *)(v2 + 16)) {
    goto LABEL_26;
  }
  uint64_t v8 = 1LL << *(_BYTE *)(v2 + 32);
  uint64_t v9 = (void *)(v2 + 56);
  uint64_t v10 = -1LL;
  if (v8 < 64) {
    uint64_t v10 = ~(-1LL << v8);
  }
  unint64_t v11 = v10 & *(void *)(v2 + 56);
  int64_t v12 = (unint64_t)(v8 + 63) >> 6;
  swift_retain((unint64_t *)v2, v4, v5, v6);
  int64_t v13 = 0LL;
  while (1)
  {
    if (v11)
    {
      unint64_t v14 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v15 = v14 | (v13 << 6);
      goto LABEL_8;
    }

    int64_t v18 = v13 + 1;
    if (__OFADD__(v13, 1LL))
    {
      __break(1u);
LABEL_28:
      __break(1u);
      return;
    }

    if (v18 >= v12) {
      goto LABEL_22;
    }
    unint64_t v19 = v9[v18];
    ++v13;
    if (!v19)
    {
      int64_t v13 = v18 + 1;
      if (v18 + 1 >= v12) {
        goto LABEL_22;
      }
      unint64_t v19 = v9[v13];
      if (!v19) {
        break;
      }
    }

uint64_t specialized _NativeSet.resize(capacity:)( uint64_t a1, uint64_t (*a2)(void), uint64_t (*a3)(void, void *))
{
  uint64_t v6 = *v3;
  if (*(void *)(*v3 + 24) > a1) {
    a1 = *(void *)(*v3 + 24);
  }
  char v7 = specialized static _HashTable.scale(forCapacity:)(a1);
  unint64_t v11 = specialized static _SetStorage.allocate(scale:age:seed:)(v7, 0x100000000LL, 0LL, 1, a2);
  if (!*(void *)(v6 + 16)) {
    goto LABEL_26;
  }
  uint64_t v12 = 1LL << *(_BYTE *)(v6 + 32);
  int64_t v13 = (void *)(v6 + 56);
  uint64_t v14 = -1LL;
  if (v12 < 64) {
    uint64_t v14 = ~(-1LL << v12);
  }
  unint64_t v15 = v14 & *(void *)(v6 + 56);
  int64_t v16 = (unint64_t)(v12 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain((unint64_t *)v6, v8, v9, v10);
  int64_t v18 = 0LL;
  while (1)
  {
    if (v15)
    {
      unint64_t v19 = __clz(__rbit64(v15));
      v15 &= v15 - 1;
      unint64_t v20 = v19 | (v18 << 6);
      goto LABEL_8;
    }

    int64_t v21 = v18 + 1;
    if (__OFADD__(v18, 1LL))
    {
      __break(1u);
LABEL_28:
      __break(1u);
      return result;
    }

    if (v21 >= v16) {
      goto LABEL_22;
    }
    unint64_t v22 = v13[v21];
    ++v18;
    if (!v22)
    {
      int64_t v18 = v21 + 1;
      if (v21 + 1 >= v16) {
        goto LABEL_22;
      }
      unint64_t v22 = v13[v18];
      if (!v22) {
        break;
      }
    }

Swift::Void __swiftcall _NativeSet.resize(capacity:)(Swift::Int capacity)
{
  char v3 = v2;
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](capacity);
  uint64_t v10 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *v2;
  if (*(void *)(*v2 + 24LL) <= v6) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = *(void *)(*v2 + 24LL);
  }
  uint64_t v13 = *(void *)(v7 + 24);
  type metadata accessor for _SetStorage(0LL, v4, v13, v8);
  char v14 = specialized static _HashTable.scale(forCapacity:)(v12);
  char v32 = 1;
  int64_t v18 = static _SetStorage.allocate(scale:age:seed:)(v14, 0x100000000LL, 0LL, 1);
  if (*(void *)(v11 + 16))
  {
    uint64_t v31 = v3;
    uint64_t v19 = 1LL << *(_BYTE *)(v11 + 32);
    unint64_t v20 = (void *)(v11 + 56);
    uint64_t v21 = -1LL;
    if (v19 < 64) {
      uint64_t v21 = ~(-1LL << v19);
    }
    unint64_t v22 = v21 & *(void *)(v11 + 56);
    int64_t v23 = (unint64_t)(v19 + 63) >> 6;
    swift_retain((unint64_t *)v11, v15, v16, v17);
    int64_t v24 = 0LL;
    while (1)
    {
      if (v22)
      {
        unint64_t v25 = __clz(__rbit64(v22));
        v22 &= v22 - 1;
        unint64_t v26 = v25 | (v24 << 6);
      }

      else
      {
        if (__OFADD__(v24++, 1LL)) {
          goto LABEL_27;
        }
        if (v24 >= v23)
        {
LABEL_21:
          swift_release(v11);
          uint64_t v30 = 1LL << *(_BYTE *)(v11 + 32);
          if (v30 > 63) {
            specialized UnsafeMutablePointer.assign(repeating:count:)( 0LL,  (unint64_t)(v30 + 63) >> 6,  (int64x2_t *)(v11 + 56));
          }
          else {
            *unint64_t v20 = -1LL << v30;
          }
          char v3 = v31;
          *(void *)(v11 + 16) = 0LL;
          break;
        }

        unint64_t v28 = v20[v24];
        if (!v28)
        {
          int64_t v29 = v24 + 1;
          if (v24 + 1 >= v23) {
            goto LABEL_21;
          }
          unint64_t v28 = v20[v29];
          if (!v28)
          {
            while (1)
            {
              int64_t v24 = v29 + 1;
              if (__OFADD__(v29, 1LL)) {
                break;
              }
              if (v24 >= v23) {
                goto LABEL_21;
              }
              unint64_t v28 = v20[v24];
              ++v29;
              if (v28) {
                goto LABEL_20;
              }
            }

            __break(1u);
LABEL_27:
            __break(1u);
            return;
          }

          ++v24;
        }

void *static _SetStorage.resize(original:capacity:move:)(uint64_t a1, uint64_t a2)
{
  char v2 = specialized static _HashTable.scale(forCapacity:)(a2);
  return static _SetStorage.allocate(scale:age:seed:)(v2, 0x100000000LL, 0LL, 1);
}

uint64_t _NativeSet.count.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__n128 specialized _NativeSet._unsafeInsertNew(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 8))(v32, v5, v6);
  uint64_t v7 = v33;
  uint64_t v8 = v34;
  __swift_project_boxed_opaque_existential_0Tm(v32, v33);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 40))(v4, v7, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v32);
  uint64_t v10 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v11 = v9 & ~v10;
  uint64_t v27 = a2;
  uint64_t v12 = a2 + 56;
  unint64_t v13 = v11 >> 6;
  uint64_t v14 = *(void *)(a2 + 56 + 8 * (v11 >> 6));
  uint64_t v15 = 1LL << v11;
  if (((1LL << v11) & v14) != 0)
  {
    uint64_t v16 = ~v10;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v27 + 48) + 40 * v11, (uint64_t)v32);
      uint64_t v17 = v33;
      uint64_t v18 = v34;
      __swift_project_boxed_opaque_existential_0Tm(v32, v33);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v18 + 8))(v29, v17, v18);
      uint64_t v19 = v30;
      uint64_t v20 = v31;
      __swift_project_boxed_opaque_existential_0Tm(v29, v30);
      uint64_t v21 = *(void *)(a1 + 24);
      uint64_t v22 = *(void *)(a1 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)a1, v21);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v22 + 8))(v28, v21, v22);
      char v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v20 + 16))(v28, v19, v20);
      __swift_destroy_boxed_opaque_existential_1Tm(v28);
      if (v23 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v29);
        outlined destroy of AnyHashable(v32);
      }

      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v29);
        outlined destroy of AnyHashable(v32);
        if ((v23 & 1) != 0) {
          ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
        }
      }

      unint64_t v11 = (v11 + 1) & v16;
      unint64_t v13 = v11 >> 6;
      uint64_t v14 = *(void *)(v12 + 8 * (v11 >> 6));
      uint64_t v15 = 1LL << v11;
    }

    while ((v14 & (1LL << v11)) != 0);
  }

  *(void *)(v12 + 8 * v13) = v15 | v14;
  uint64_t v24 = *(void *)(v27 + 48) + 40 * v11;
  __n128 result = *(__n128 *)a1;
  __int128 v26 = *(_OWORD *)(a1 + 16);
  *(void *)(v24 + 32) = *(void *)(a1 + 32);
  *(__n128 *)uint64_t v24 = result;
  *(_OWORD *)(v24 + 16) = v26;
  ++*(void *)(v27 + 16);
  return result;
}

uint64_t specialized _NativeSet._unsafeInsertNew(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(a2 + 40), a1);
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = result & ~v5;
  uint64_t v7 = a2 + 56;
  unint64_t v8 = v6 >> 6;
  uint64_t v9 = *(void *)(a2 + 56 + 8 * (v6 >> 6));
  uint64_t v10 = 1LL << v6;
  uint64_t v11 = *(void *)(a2 + 48);
  if (((1LL << v6) & v9) != 0)
  {
    uint64_t v12 = ~v5;
    do
    {
      if (*(void *)(v11 + 8 * v6) == a1) {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for ObjectIdentifier);
      }
      unint64_t v6 = (v6 + 1) & v12;
      unint64_t v8 = v6 >> 6;
      uint64_t v9 = *(void *)(v7 + 8 * (v6 >> 6));
      uint64_t v10 = 1LL << v6;
    }

    while ((v9 & (1LL << v6)) != 0);
  }

  *(void *)(v7 + 8 * v8) = v10 | v9;
  *(void *)(v11 + 8 * v6) = a1;
  ++*(void *)(a2 + 16);
  return result;
}

{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(a2 + 40), a1);
  uint64_t v5 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v6 = result & ~v5;
  uint64_t v7 = a2 + 56;
  unint64_t v8 = v6 >> 6;
  uint64_t v9 = *(void *)(a2 + 56 + 8 * (v6 >> 6));
  uint64_t v10 = 1LL << v6;
  uint64_t v11 = *(void *)(a2 + 48);
  if (((1LL << v6) & v9) != 0)
  {
    uint64_t v12 = ~v5;
    do
    {
      if (*(void *)(v11 + 8 * v6) == a1) {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for Int);
      }
      unint64_t v6 = (v6 + 1) & v12;
      unint64_t v8 = v6 >> 6;
      uint64_t v9 = *(void *)(v7 + 8 * (v6 >> 6));
      uint64_t v10 = 1LL << v6;
    }

    while ((v9 & (1LL << v6)) != 0);
  }

  *(void *)(v7 + 8 * v8) = v10 | v9;
  *(void *)(v11 + 8 * v6) = a1;
  ++*(void *)(a2 + 16);
  return result;
}

Swift::Int specialized _NativeSet._unsafeInsertNew(_:)(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = _swift_stdlib_Hashing_parameters ^ *(void *)(a3 + 40);
  v22[0] = 0LL;
  v22[1] = v6 ^ 0x736F6D6570736575LL;
  _OWORD v22[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v22[3] = v6 ^ 0x6C7967656E657261LL;
  v22[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  String.hash(into:)(v22, a1, a2);
  Swift::Int result = Hasher._finalize()();
  uint64_t v8 = -1LL << *(_BYTE *)(a3 + 32);
  unint64_t v9 = result & ~v8;
  uint64_t v10 = a3 + 56;
  unint64_t v11 = v9 >> 6;
  uint64_t v12 = *(void *)(a3 + 56 + 8 * (v9 >> 6));
  uint64_t v13 = 1LL << v9;
  if (((1LL << v9) & v12) != 0)
  {
    uint64_t v14 = ~v8;
    uint64_t v15 = *(void *)(a3 + 48);
    do
    {
      uint64_t v16 = (Swift::Int *)(v15 + 16 * v9);
      Swift::Int result = *v16;
      unint64_t v17 = v16[1];
      BOOL v18 = *v16 == a1 && v17 == a2;
      if (v18
        || ((~v17 & 0x6000000000000000LL) == 0 ? (BOOL v19 = (a2 & 0x2000000000000000LL) == 0) : (BOOL v19 = 1),
            !v19 ? (BOOL v20 = (a2 & 0x4000000000000000LL) == 0) : (BOOL v20 = 1),
            v20 && (Swift::Int result = _stringCompareInternal(_:_:expecting:)(result, v17, a1, a2, 0), (result & 1) != 0)))
      {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for String);
      }

      unint64_t v9 = (v9 + 1) & v14;
      unint64_t v11 = v9 >> 6;
      uint64_t v12 = *(void *)(v10 + 8 * (v9 >> 6));
      uint64_t v13 = 1LL << v9;
    }

    while ((v12 & (1LL << v9)) != 0);
  }

  *(void *)(v10 + 8 * v1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v13 | v12;
  uint64_t v21 = (unint64_t *)(*(void *)(a3 + 48) + 16 * v9);
  *uint64_t v21 = a1;
  v21[1] = a2;
  ++*(void *)(a3 + 16);
  return result;
}

uint64_t _NativeSet._unsafeInsertNew(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(v11 + 40);
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 32);
  uint64_t v33 = a1;
  uint64_t v16 = v14(v12, v15, v13);
  uint64_t v17 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v18 = v16 & ~v17;
  uint64_t v34 = a2;
  unint64_t v19 = v18 >> 6;
  uint64_t v32 = a2 + 56;
  uint64_t v20 = *(void *)(a2 + 56 + 8 * (v18 >> 6));
  uint64_t v21 = 1LL << v18;
  if (((1LL << v18) & v20) != 0)
  {
    uint64_t v22 = ~v17;
    uint64_t v23 = *(void *)(a4 + 8);
    __int128 v24 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 8);
    uint64_t v25 = *(void *)(v8 + 72);
    __int128 v26 = *(void (**)(char *, unint64_t, uint64_t))(v8 + 16);
    do
    {
      v26(v10, *(void *)(v34 + 48) + v25 * v18, a3);
      char v27 = v24(v10, v33, a3, v23);
      (*(void (**)(char *, uint64_t))(v8 + 8))(v10, a3);
      if ((v27 & 1) != 0) {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(a3);
      }
      unint64_t v18 = (v18 + 1) & v22;
      unint64_t v19 = v18 >> 6;
      uint64_t v20 = *(void *)(v32 + 8 * (v18 >> 6));
      uint64_t v21 = 1LL << v18;
    }

    while ((v20 & (1LL << v18)) != 0);
  }

  else
  {
    uint64_t v25 = *(void *)(v8 + 72);
  }

  uint64_t v28 = v33;
  *(void *)(v32 + 8 * v19) = v21 | v20;
  uint64_t v29 = v34;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v8 + 32))( *(void *)(v34 + 48) + v25 * v18,  v28,  a3);
  ++*(void *)(v29 + 16);
  return result;
}

uint64_t specialized _NativeSet.copyAndResize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  uint64_t v6 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000LL, 0LL, 1);
  if (!*(void *)(v2 + 16))
  {
LABEL_23:
    uint64_t result = swift_release(v2);
    *uint64_t v1 = (uint64_t)v6;
    return result;
  }

  uint64_t v7 = 1LL << *(_BYTE *)(v2 + 32);
  uint64_t v8 = v2 + 56;
  uint64_t v9 = -1LL;
  if (v7 < 64) {
    uint64_t v9 = ~(-1LL << v7);
  }
  unint64_t v10 = v9 & *(void *)(v2 + 56);
  int64_t v11 = (unint64_t)(v7 + 63) >> 6;
  uint64_t result = swift_retain_n(v2, 2LL, v4, v5);
  int64_t v16 = 0LL;
  while (1)
  {
    if (v10)
    {
      unint64_t v17 = __clz(__rbit64(v10));
      v10 &= v10 - 1;
      unint64_t v18 = v17 | (v16 << 6);
      goto LABEL_8;
    }

    int64_t v22 = v16 + 1;
    if (__OFADD__(v16, 1LL))
    {
      __break(1u);
      goto LABEL_25;
    }

    if (v22 >= v11) {
      goto LABEL_22;
    }
    unint64_t v23 = *(void *)(v8 + 8 * v22);
    ++v16;
    if (!v23)
    {
      int64_t v16 = v22 + 1;
      if (v22 + 1 >= v11) {
        goto LABEL_22;
      }
      unint64_t v23 = *(void *)(v8 + 8 * v16);
      if (!v23) {
        break;
      }
    }

void specialized _NativeSet.copyAndResize(capacity:)(uint64_t a1)
{
  uint64_t v2 = *v1;
  if (*(void *)(*v1 + 24) > a1) {
    a1 = *(void *)(*v1 + 24);
  }
  char v3 = specialized static _HashTable.scale(forCapacity:)(a1);
  v19[0] = 1;
  uint64_t v7 = specialized static _SetStorage.allocate(scale:age:seed:)(v3, 0x100000000LL, 0LL, 1);
  if (!*(void *)(v2 + 16))
  {
    swift_release(v2);
LABEL_24:
    *uint64_t v1 = (uint64_t)v7;
    return;
  }

  uint64_t v8 = 1LL << *(_BYTE *)(v2 + 32);
  uint64_t v9 = v2 + 56;
  uint64_t v10 = -1LL;
  if (v8 < 64) {
    uint64_t v10 = ~(-1LL << v8);
  }
  unint64_t v11 = v10 & *(void *)(v2 + 56);
  int64_t v12 = (unint64_t)(v8 + 63) >> 6;
  swift_retain((unint64_t *)v2, v4, v5, v6);
  int64_t v13 = 0LL;
  while (1)
  {
    if (v11)
    {
      unint64_t v14 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v15 = v14 | (v13 << 6);
      goto LABEL_8;
    }

    int64_t v16 = v13 + 1;
    if (__OFADD__(v13, 1LL))
    {
      __break(1u);
      goto LABEL_26;
    }

    if (v16 >= v12) {
      goto LABEL_22;
    }
    unint64_t v17 = *(void *)(v9 + 8 * v16);
    ++v13;
    if (!v17)
    {
      int64_t v13 = v16 + 1;
      if (v16 + 1 >= v12) {
        goto LABEL_22;
      }
      unint64_t v17 = *(void *)(v9 + 8 * v13);
      if (!v17) {
        break;
      }
    }

uint64_t specialized _NativeSet.copyAndResize(capacity:)( uint64_t a1, uint64_t (*a2)(void), uint64_t (*a3)(void, void *))
{
  uint64_t v6 = *v3;
  if (*(void *)(*v3 + 24) > a1) {
    a1 = *(void *)(*v3 + 24);
  }
  char v7 = specialized static _HashTable.scale(forCapacity:)(a1);
  unint64_t v11 = specialized static _SetStorage.allocate(scale:age:seed:)(v7, 0x100000000LL, 0LL, 1, a2);
  if (!*(void *)(v6 + 16))
  {
LABEL_23:
    uint64_t result = swift_release(v6);
    *char v3 = (uint64_t)v11;
    return result;
  }

  uint64_t v12 = 1LL << *(_BYTE *)(v6 + 32);
  uint64_t v13 = v6 + 56;
  uint64_t v14 = -1LL;
  if (v12 < 64) {
    uint64_t v14 = ~(-1LL << v12);
  }
  unint64_t v15 = v14 & *(void *)(v6 + 56);
  int64_t v16 = (unint64_t)(v12 + 63) >> 6;
  uint64_t result = (uint64_t)swift_retain((unint64_t *)v6, v8, v9, v10);
  int64_t v18 = 0LL;
  while (1)
  {
    if (v15)
    {
      unint64_t v19 = __clz(__rbit64(v15));
      v15 &= v15 - 1;
      unint64_t v20 = v19 | (v18 << 6);
      goto LABEL_8;
    }

    int64_t v21 = v18 + 1;
    if (__OFADD__(v18, 1LL))
    {
      __break(1u);
      goto LABEL_25;
    }

    if (v21 >= v16) {
      goto LABEL_22;
    }
    unint64_t v22 = *(void *)(v13 + 8 * v21);
    ++v18;
    if (!v22)
    {
      int64_t v18 = v21 + 1;
      if (v21 + 1 >= v16) {
        goto LABEL_22;
      }
      unint64_t v22 = *(void *)(v13 + 8 * v18);
      if (!v22) {
        break;
      }
    }

Swift::Void __swiftcall _NativeSet.copyAndResize(capacity:)(Swift::Int capacity)
{
  char v3 = v2;
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](capacity);
  uint64_t v10 = (char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *v2;
  if (*(void *)(*v2 + 24LL) <= v6) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = *(void *)(*v2 + 24LL);
  }
  uint64_t v13 = *(void *)(v7 + 24);
  type metadata accessor for _SetStorage(0LL, v4, v13, v8);
  char v14 = specialized static _HashTable.scale(forCapacity:)(v12);
  char v31 = 1;
  int64_t v18 = static _SetStorage.allocate(scale:age:seed:)(v14, 0x100000000LL, 0LL, 1);
  if (!*(void *)(v11 + 16))
  {
    swift_release(v11);
LABEL_23:
    *char v3 = v18;
    return;
  }

  uint64_t v30 = v3;
  uint64_t v19 = 1LL << *(_BYTE *)(v11 + 32);
  uint64_t v20 = v11 + 56;
  uint64_t v21 = -1LL;
  if (v19 < 64) {
    uint64_t v21 = ~(-1LL << v19);
  }
  unint64_t v22 = v21 & *(void *)(v11 + 56);
  int64_t v23 = (unint64_t)(v19 + 63) >> 6;
  swift_retain((unint64_t *)v11, v15, v16, v17);
  int64_t v24 = 0LL;
  while (1)
  {
    if (v22)
    {
      unint64_t v25 = __clz(__rbit64(v22));
      v22 &= v22 - 1;
      unint64_t v26 = v25 | (v24 << 6);
      goto LABEL_9;
    }

    if (__OFADD__(v24++, 1LL)) {
      goto LABEL_25;
    }
    if (v24 >= v23)
    {
LABEL_21:
      swift_release_n(v11, 2LL);
      char v3 = v30;
      goto LABEL_23;
    }

    unint64_t v28 = *(void *)(v20 + 8 * v24);
    if (!v28) {
      break;
    }
LABEL_20:
    unint64_t v22 = (v28 - 1) & v28;
    unint64_t v26 = __clz(__rbit64(v28)) + (v24 << 6);
LABEL_9:
    (*(void (**)(char *, unint64_t, uint64_t))(v5 + 16))( v10,  *(void *)(v11 + 48) + *(void *)(v5 + 72) * v26,  v4);
    _NativeSet._unsafeInsertNew(_:)((uint64_t)v10, (uint64_t)v18, v4, v13);
  }

  int64_t v29 = v24 + 1;
  if (v24 + 1 >= v23) {
    goto LABEL_21;
  }
  unint64_t v28 = *(void *)(v20 + 8 * v29);
  if (v28)
  {
    ++v24;
    goto LABEL_20;
  }

  while (1)
  {
    int64_t v24 = v29 + 1;
    if (__OFADD__(v29, 1LL)) {
      break;
    }
    if (v24 >= v23) {
      goto LABEL_21;
    }
    unint64_t v28 = *(void *)(v20 + 8 * v24);
    ++v29;
    if (v28) {
      goto LABEL_20;
    }
  }

  __break(1u);
LABEL_25:
  __break(1u);
}

void *specialized _NativeSet.copy()()
{
  uint64_t v1 = *v0;
  uint64_t v2 = specialized static _SetStorage.allocate(scale:age:seed:)( *(_BYTE *)(*v0 + 32),  *(unsigned int *)(*v0 + 36),  *(void **)(*v0 + 40),  0);
  uint64_t v6 = v2;
  if (!*(void *)(v1 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v6;
    return result;
  }

  uint64_t result = v2 + 7;
  uint64_t v8 = v1 + 56;
  unint64_t v9 = (unint64_t)((1LL << *((_BYTE *)v6 + 32)) + 63) >> 6;
  int64_t v11 = 0LL;
  v6[2] = *(void *)(v1 + 16);
  uint64_t v12 = 1LL << *(_BYTE *)(v1 + 32);
  uint64_t v13 = -1LL;
  if (v12 < 64) {
    uint64_t v13 = ~(-1LL << v12);
  }
  unint64_t v14 = v13 & *(void *)(v1 + 56);
  int64_t v15 = (unint64_t)(v12 + 63) >> 6;
  while (1)
  {
    if (v14)
    {
      unint64_t v16 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v17 = v16 | (v11 << 6);
      goto LABEL_12;
    }

    int64_t v22 = v11 + 1;
    if (__OFADD__(v11, 1LL))
    {
      __break(1u);
      goto LABEL_28;
    }

    if (v22 >= v15) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v8 + 8 * v22);
    ++v11;
    if (!v23)
    {
      int64_t v11 = v22 + 1;
      if (v22 + 1 >= v15) {
        goto LABEL_26;
      }
      unint64_t v23 = *(void *)(v8 + 8 * v11);
      if (!v23) {
        break;
      }
    }

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  void *v3;
  char v4;
  void *v5;
  void *v6;
  void *result;
  uint64_t v8;
  unint64_t v9;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  int64_t v22;
  unint64_t v23;
  int64_t v24;
  _OWORD v25[2];
  uint64_t v26;
  uint64_t v1 = *v0;
  uint64_t v2 = *(unsigned int *)(*v0 + 36);
  uint64_t v3 = *(void **)(*v0 + 40);
  uint64_t v4 = *(_BYTE *)(*v0 + 32);
  LOBYTE(v25[0]) = 0;
  uint64_t v5 = specialized static _SetStorage.allocate(scale:age:seed:)(v4, v2, v3, 0);
  uint64_t v6 = v5;
  if (!*(void *)(v1 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release(v1);
    uint64_t *v0 = (uint64_t)v6;
    return result;
  }

  uint64_t result = v5 + 7;
  uint64_t v8 = v1 + 56;
  unint64_t v9 = (unint64_t)((1LL << *((_BYTE *)v6 + 32)) + 63) >> 6;
  int64_t v11 = 0LL;
  v6[2] = *(void *)(v1 + 16);
  uint64_t v12 = 1LL << *(_BYTE *)(v1 + 32);
  uint64_t v13 = -1LL;
  if (v12 < 64) {
    uint64_t v13 = ~(-1LL << v12);
  }
  unint64_t v14 = v13 & *(void *)(v1 + 56);
  int64_t v15 = (unint64_t)(v12 + 63) >> 6;
  while (1)
  {
    if (v14)
    {
      unint64_t v16 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v17 = v16 | (v11 << 6);
      goto LABEL_12;
    }

    int64_t v22 = v11 + 1;
    if (__OFADD__(v11, 1LL))
    {
      __break(1u);
      goto LABEL_28;
    }

    if (v22 >= v15) {
      goto LABEL_26;
    }
    unint64_t v23 = *(void *)(v8 + 8 * v22);
    ++v11;
    if (!v23)
    {
      int64_t v11 = v22 + 1;
      if (v22 + 1 >= v15) {
        goto LABEL_26;
      }
      unint64_t v23 = *(void *)(v8 + 8 * v11);
      if (!v23) {
        break;
      }
    }

void *specialized _NativeSet.copy()(uint64_t (*a1)(void))
{
  uint64_t v2 = *v1;
  uint64_t v3 = specialized static _SetStorage.allocate(scale:age:seed:)( *(_BYTE *)(*v1 + 32),  *(unsigned int *)(*v1 + 36),  *(void **)(*v1 + 40),  0,  a1);
  uint64_t v4 = v3;
  if (!*(void *)(v2 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release(v2);
    *uint64_t v1 = (uint64_t)v4;
    return result;
  }

  uint64_t result = v3 + 7;
  uint64_t v6 = v2 + 56;
  unint64_t v7 = (unint64_t)((1LL << *((_BYTE *)v4 + 32)) + 63) >> 6;
  int64_t v9 = 0LL;
  void v4[2] = *(void *)(v2 + 16);
  uint64_t v10 = 1LL << *(_BYTE *)(v2 + 32);
  uint64_t v11 = -1LL;
  if (v10 < 64) {
    uint64_t v11 = ~(-1LL << v10);
  }
  unint64_t v12 = v11 & *(void *)(v2 + 56);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  while (1)
  {
    if (v12)
    {
      unint64_t v14 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v15 = v14 | (v9 << 6);
      goto LABEL_12;
    }

    int64_t v16 = v9 + 1;
    if (__OFADD__(v9, 1LL))
    {
      __break(1u);
      goto LABEL_28;
    }

    if (v16 >= v13) {
      goto LABEL_26;
    }
    unint64_t v17 = *(void *)(v6 + 8 * v16);
    ++v9;
    if (!v17)
    {
      int64_t v9 = v16 + 1;
      if (v16 + 1 >= v13) {
        goto LABEL_26;
      }
      unint64_t v17 = *(void *)(v6 + 8 * v9);
      if (!v17) {
        break;
      }
    }

Swift::Void __swiftcall _NativeSet.copy()()
{
  uint64_t v2 = v1;
  uint64_t v3 = *(void *)(v0 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = ((uint64_t (*)())MEMORY[0x1895F8858])();
  unint64_t v7 = (char *)&v30 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *v1;
  type metadata accessor for _SetStorage(0LL, v3, *(void *)(v5 + 24), v9);
  uint64_t v10 = *(unsigned int *)(v8 + 36);
  uint64_t v11 = *(void **)(v8 + 40);
  char v12 = *(_BYTE *)(v8 + 32);
  char v31 = 0;
  int64_t v13 = static _SetStorage.allocate(scale:age:seed:)(v12, v10, v11, 0);
  unint64_t v14 = v13;
  if (!*(void *)(v8 + 16))
  {
    swift_release(v8);
LABEL_26:
    *uint64_t v2 = (uint64_t)v14;
    return;
  }

  uint64_t v30 = v2;
  unint64_t v15 = v13 + 7;
  uint64_t v16 = v8 + 56;
  unint64_t v17 = (unint64_t)((1LL << *((_BYTE *)v14 + 32)) + 63) >> 6;
  int64_t v19 = 0LL;
  void v14[2] = *(void *)(v8 + 16);
  uint64_t v20 = 1LL << *(_BYTE *)(v8 + 32);
  uint64_t v21 = -1LL;
  if (v20 < 64) {
    uint64_t v21 = ~(-1LL << v20);
  }
  unint64_t v22 = v21 & *(void *)(v8 + 56);
  int64_t v23 = (unint64_t)(v20 + 63) >> 6;
  while (1)
  {
    if (v22)
    {
      unint64_t v24 = __clz(__rbit64(v22));
      v22 &= v22 - 1;
      unint64_t v25 = v24 | (v19 << 6);
      goto LABEL_12;
    }

    if (__OFADD__(v19++, 1LL)) {
      goto LABEL_28;
    }
    if (v19 >= v23)
    {
LABEL_24:
      swift_release(v8);
      uint64_t v2 = v30;
      goto LABEL_26;
    }

    unint64_t v28 = *(void *)(v16 + 8 * v19);
    if (!v28) {
      break;
    }
LABEL_23:
    unint64_t v22 = (v28 - 1) & v28;
    unint64_t v25 = __clz(__rbit64(v28)) + (v19 << 6);
LABEL_12:
    unint64_t v26 = *(void *)(v4 + 72) * v25;
    (*(void (**)(char *, unint64_t, uint64_t))(v4 + 16))(v7, *(void *)(v8 + 48) + v26, v3);
    (*(void (**)(unint64_t, char *, uint64_t))(v4 + 32))(v14[6] + v26, v7, v3);
  }

  int64_t v29 = v19 + 1;
  if (v19 + 1 >= v23) {
    goto LABEL_24;
  }
  unint64_t v28 = *(void *)(v16 + 8 * v29);
  if (v28)
  {
    ++v19;
    goto LABEL_23;
  }

  while (1)
  {
    int64_t v19 = v29 + 1;
    if (__OFADD__(v29, 1LL)) {
      break;
    }
    if (v19 >= v23) {
      goto LABEL_24;
    }
    unint64_t v28 = *(void *)(v16 + 8 * v19);
    ++v29;
    if (v28) {
      goto LABEL_23;
    }
  }

  __break(1u);
LABEL_28:
  __break(1u);
}

void *static _SetStorage.copy(original:)(uint64_t a1)
{
  return static _SetStorage.allocate(scale:age:seed:)( *(_BYTE *)(a1 + 32),  *(unsigned int *)(a1 + 36),  *(void **)(a1 + 40),  0);
}

Swift::Bool __swiftcall _NativeSet.ensureUnique(isUnique:capacity:)(Swift::Bool isUnique, Swift::Int capacity)
{
  Swift::Int v4 = *(void *)(*(void *)v2 + 24LL);
  if (v4 >= capacity)
  {
    if (!isUnique) {
      _NativeSet.copy()();
    }
  }

  else if (isUnique)
  {
    _NativeSet.resize(capacity:)(capacity);
  }

  else
  {
    _NativeSet.copyAndResize(capacity:)(capacity);
  }

  return v4 < capacity;
}

Swift::_HashTable::Bucket __swiftcall _NativeSet.validatedBucket(for:)(Swift::_HashTable::Index a1)
{
  if (a1.bucket.offset < 0
    || 1LL << *(_BYTE *)(v1 + 32) <= a1.bucket.offset
    || ((*(void *)(v1 + (((unint64_t)a1.bucket.offset >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> SLOBYTE(a1.bucket.offset)) & 1) == 0
    || *(_DWORD *)(v1 + 36) != a1.age)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  0x10AuLL,  0);
  }

  return a1.bucket;
}

uint64_t _NativeSet.validatedBucket(for:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6)
{
  uint64_t v10 = a1;
  uint64_t v40 = *((void *)a5 - 1);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  int64_t v13 = (char *)&v38 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v41 = (char *)&v38 - v14;
  if ((v15 & 1) != 0)
  {
    if (v10 >= 0) {
      uint64_t v17 = v10 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v17 = v10;
    }
    uint64_t v18 = type metadata accessor for __CocoaSet.Index.Storage();
    swift_bridgeObjectRetain(v10, v19, v20, v21);
    if (!swift_dynamicCastClass(v17, v18)) {
      goto LABEL_24;
    }
    if (!swift_dynamicCastClass(v17, v18)) {
LABEL_24:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
    uint64_t v25 = *(void *)(v17 + 24);
    if (*(void *)(v25 + 16) <= a2) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1E1uLL,  0);
    }
    unint64_t v26 = *(void **)(v25 + 8 * a2 + 24);
    swift_unknownObjectRetain(v26, v22, v23, v24);
    outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
    _forceBridgeFromObjectiveC<A>(_:_:)(v26, a5, v27, v41);
    swift_unknownObjectRelease(v26);
    uint64_t v28 = (*(uint64_t (**)(void, char *, uint64_t))(a6 + 32))(*(void *)(a4 + 40), a5, a6);
    uint64_t v29 = -1LL << *(_BYTE *)(a4 + 32);
    uint64_t v10 = v28 & ~v29;
    uint64_t v38 = a4 + 56;
    uint64_t v39 = a4;
    if (((*(void *)(a4 + 56 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v10) & 1) == 0)
    {
      (*(void (**)(char *, char *))(v40 + 8))(v41, a5);
LABEL_20:
      unint64_t v16 = 287LL;
LABEL_7:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  v16,  0);
    }

    uint64_t v30 = ~v29;
    uint64_t v31 = *(void *)(a6 + 8);
    uint64_t v32 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v31 + 8);
    uint64_t v33 = *(void *)(v40 + 72);
    uint64_t v34 = *(void (**)(char *, uint64_t, char *))(v40 + 16);
    while (1)
    {
      v34(v13, *(void *)(v39 + 48) + v33 * v10, a5);
      char v35 = v32(v13, v41, a5, v31);
      uint64_t v36 = *(void (**)(char *, char *))(v40 + 8);
      v36(v13, a5);
      if ((v35 & 1) != 0) {
        break;
      }
      uint64_t v10 = (v10 + 1) & v30;
      if (((*(void *)(v38 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v10) & 1) == 0)
      {
        v36(v41, a5);
        goto LABEL_20;
      }
    }

    v36(v41, a5);
  }

  else if (v10 < 0 {
         || 1LL << *(_BYTE *)(a4 + 32) <= v10
  }
         || ((*(void *)(a4 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> v10) & 1) == 0
         || *(_DWORD *)(a4 + 36) != (_DWORD)a2)
  {
    unint64_t v16 = 266LL;
    goto LABEL_7;
  }

  return v10;
}

unint64_t Set.Index._asCocoa.getter(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((a3 & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x567uLL,  0);
  }
  return swift_bridgeObjectRetain(a1, a2, a3, a4);
}

uint64_t __CocoaSet.Index.age.getter(uint64_t a1, uint64_t a2)
{
  return __CocoaDictionary.Index.age.getter(a1, a2, type metadata accessor for __CocoaSet.Index.Storage);
}

uint64_t __CocoaDictionary.Index.age.getter(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  uint64_t v4 = a3();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  return specialized static Hasher._hash(seed:_:)(0LL, *(void *)(v3 + 16));
}

id __CocoaSet.Index.element.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)specialized __CocoaSet.Index.element.getter(a1, a2);
  return swift_unknownObjectRetain(v2, v3, v4, v5);
}

BOOL Set.Index._isNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  return (a3 & 1) == 0;
}

void Set.Index._asNative.getter(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x55AuLL,  0);
  }
}

uint64_t _NativeSet.startIndex.getter(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 56);
  if (v1)
  {
    uint64_t v2 = 0LL;
    return __clz(__rbit64(v1)) + v2;
  }

  else
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = 1LL << *(_BYTE *)(a1 + 32);
    unint64_t v4 = ((unint64_t)(v3 + 63) >> 6) - 1;
    uint64_t v5 = (unint64_t *)(a1 + 64);
    while (v4)
    {
      unint64_t v6 = *v5++;
      unint64_t v1 = v6;
      --v4;
      v2 += 64LL;
      if (v6) {
        return __clz(__rbit64(v1)) + v2;
      }
    }
  }

  return v3;
}

  ;
}

uint64_t _NativeSet.endIndex.getter(uint64_t a1)
{
  return 1LL << *(_BYTE *)(a1 + 32);
}

int64_t specialized _NativeSet.index(after:)(unint64_t a1, int a2, char a3, uint64_t a4)
{
  if ((a3 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x55AuLL,  0);
  }
  if ((a1 & 0x8000000000000000LL) != 0
    || (int64_t result = 1LL << *(_BYTE *)(a4 + 32), result <= (uint64_t)a1)
    || (v6 = a1 >> 6, v7 = a4 + 56, unint64_t v8 = *(void *)(a4 + 56 + 8 * (a1 >> 6)), ((v8 >> a1) & 1) == 0)
    || *(_DWORD *)(a4 + 36) != a2)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  0x10AuLL,  0);
  }

  unint64_t v9 = v8 & (-2LL << (a1 & 0x3F));
  if (v9) {
    return __clz(__rbit64(v9)) | a1 & 0xFFFFFFFFFFFFFFC0LL;
  }
  unint64_t v10 = v6 + 1;
  unint64_t v11 = (unint64_t)(result + 63) >> 6;
  if (v6 + 1 < v11)
  {
    unint64_t v12 = *(void *)(v7 + 8 * v10);
    if (v12) {
      return __clz(__rbit64(v12)) + (v10 << 6);
    }
    unint64_t v10 = v6 + 2;
    if (v6 + 2 < v11)
    {
      unint64_t v12 = *(void *)(v7 + 8 * v10);
      if (v12) {
        return __clz(__rbit64(v12)) + (v10 << 6);
      }
      while (v11 - 3 != v6)
      {
        unint64_t v12 = *(void *)(a4 + 80 + 8 * v6++);
        if (v12)
        {
          unint64_t v10 = v6 + 2;
          return __clz(__rbit64(v12)) + (v10 << 6);
        }
      }
    }
  }

  return result;
}

int64_t _NativeSet.index(after:)(unint64_t a1, int a2, char a3, uint64_t a4)
{
  if ((a3 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/Set.swift",  15LL,  2,  0x55AuLL,  0);
  }
  if ((a1 & 0x8000000000000000LL) != 0
    || (int64_t result = 1LL << *(_BYTE *)(a4 + 32), result <= (uint64_t)a1)
    || (unint64_t v6 = a1 >> 6, v7 = *(void *)(a4 + 56 + 8 * (a1 >> 6)), ((v7 >> a1) & 1) == 0)
    || *(_DWORD *)(a4 + 36) != a2)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  0x10AuLL,  0);
  }

  unint64_t v8 = v7 & (-2LL << (a1 & 0x3F));
  if (v8) {
    return __clz(__rbit64(v8)) | a1 & 0xFFFFFFFFFFFFFFC0LL;
  }
  unint64_t v9 = v6 + 1;
  unint64_t v10 = (unint64_t)(result + 63) >> 6;
  if (v6 + 1 < v10)
  {
    unint64_t v11 = *(void *)(a4 + 56 + 8 * v9);
    if (v11)
    {
      return __clz(__rbit64(v11)) + (v9 << 6);
    }

    else
    {
      while (v10 - 2 != v6)
      {
        unint64_t v11 = *(void *)(a4 + 72 + 8 * v6++);
        if (v11)
        {
          unint64_t v9 = v6 + 1;
          return __clz(__rbit64(v11)) + (v9 << 6);
        }
      }
    }
  }

  return result;
}

unint64_t _NativeSet.index(for:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v9 = (char *)&v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (!*(void *)(v10 + 16)) {
    return 0LL;
  }
  uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
  uint64_t v12 = -1LL << *(_BYTE *)(a2 + 32);
  unint64_t v13 = v11 & ~v12;
  uint64_t v23 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) == 0) {
    return 0LL;
  }
  uint64_t v14 = a1;
  uint64_t v22 = ~v12;
  uint64_t v15 = *(void *)(a4 + 8);
  unint64_t v16 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 8);
  uint64_t v17 = *(void *)(v24 + 72);
  uint64_t v18 = *(void (**)(char *, unint64_t, uint64_t))(v24 + 16);
  while (1)
  {
    v18(v9, *(void *)(a2 + 48) + v17 * v13, a3);
    char v19 = v16(v9, v14, a3, v15);
    (*(void (**)(char *, uint64_t))(v24 + 8))(v9, a3);
    if ((v19 & 1) != 0) {
      break;
    }
    unint64_t v13 = (v13 + 1) & v22;
    if (((*(void *)(v23 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) == 0) {
      return 0LL;
    }
  }

  return v13;
}

uint64_t _NativeSet.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v9 = (char *)&v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (*(void *)(v10 + 16)
    && (uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4),
        uint64_t v12 = -1LL << *(_BYTE *)(a2 + 32),
        unint64_t v13 = v11 & ~v12,
        uint64_t v23 = a2 + 56,
        ((*(void *)(a2 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) != 0))
  {
    uint64_t v14 = a1;
    uint64_t v22 = ~v12;
    uint64_t v15 = *(void *)(a4 + 8);
    unint64_t v16 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 8);
    uint64_t v17 = *(void *)(v24 + 72);
    uint64_t v18 = *(void (**)(char *, unint64_t, uint64_t))(v24 + 16);
    do
    {
      v18(v9, *(void *)(a2 + 48) + v17 * v13, a3);
      char v19 = v16(v9, v14, a3, v15);
      (*(void (**)(char *, uint64_t))(v24 + 8))(v9, a3);
      if ((v19 & 1) != 0) {
        break;
      }
      unint64_t v13 = (v13 + 1) & v22;
    }

    while (((*(void *)(v23 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) != 0);
  }

  else
  {
    char v19 = 0;
  }

  return v19 & 1;
}

uint64_t _NativeSet.element(at:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, char *a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v45 = *((void *)a4 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v40 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v44 = (char *)&v40 - v15;
  if ((v16 & 1) == 0)
  {
    if ((a1 & 0x8000000000000000LL) == 0
      && 1LL << *(_BYTE *)(a3 + 32) > a1
      && ((*(void *)(a3 + (((unint64_t)a1 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> a1) & 1) != 0
      && *(_DWORD *)(a3 + 36) == (_DWORD)a2)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, char *))(v45 + 16))( a6,  *(void *)(a3 + 48) + *(void *)(v45 + 72) * a1,  a4);
    }

    unint64_t v39 = 266LL;
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  v39,  0);
  }

  if (a1 >= 0) {
    uint64_t v18 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v18 = a1;
  }
  uint64_t v19 = type metadata accessor for __CocoaSet.Index.Storage();
  swift_bridgeObjectRetain(a1, v20, v21, v22);
  if (!swift_dynamicCastClass(v18, v19)) {
    goto LABEL_25;
  }
  if (!swift_dynamicCastClass(v18, v19)) {
LABEL_25:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  uint64_t v26 = *(void *)(v18 + 24);
  if (*(void *)(v26 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1E1uLL,  0);
  }
  uint64_t v41 = a6;
  uint64_t v27 = *(void **)(v26 + 8 * a2 + 24);
  swift_unknownObjectRetain(v27, v23, v24, v25);
  outlined consume of [A : B].Index._Variant<A, B>(a1, a2, 1);
  _forceBridgeFromObjectiveC<A>(_:_:)(v27, a4, v28, v44);
  swift_unknownObjectRelease(v27);
  uint64_t v29 = (*(uint64_t (**)(void, char *, uint64_t))(a5 + 32))(*(void *)(a3 + 40), a4, a5);
  uint64_t v30 = -1LL << *(_BYTE *)(a3 + 32);
  unint64_t v31 = v29 & ~v30;
  uint64_t v42 = a3 + 56;
  uint64_t v43 = a3;
  if (((*(void *)(a3 + 56 + ((v31 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v31) & 1) == 0)
  {
    (*(void (**)(char *, char *))(v45 + 8))(v44, a4);
LABEL_19:
    unint64_t v39 = 287LL;
    goto LABEL_23;
  }

  uint64_t v32 = ~v30;
  uint64_t v33 = *(void *)(a5 + 8);
  uint64_t v34 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v33 + 8);
  uint64_t v35 = *(void *)(v45 + 72);
  uint64_t v36 = *(void (**)(char *, unint64_t, char *))(v45 + 16);
  while (1)
  {
    v36(v14, *(void *)(v43 + 48) + v35 * v31, a4);
    char v37 = v34(v14, v44, a4, v33);
    uint64_t v38 = *(void (**)(char *, char *))(v45 + 8);
    v38(v14, a4);
    if ((v37 & 1) != 0) {
      break;
    }
    unint64_t v31 = (v31 + 1) & v32;
    if (((*(void *)(v42 + ((v31 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v31) & 1) == 0)
    {
      v38(v44, a4);
      goto LABEL_19;
    }
  }

  v38(v44, a4);
  return ((uint64_t (*)(uint64_t, unint64_t, char *))v36)(v41, *(void *)(v43 + 48) + v35 * v31, a4);
}

void ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(uint64_t a1)
{
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(186LL);
  unint64_t v9 = v5;
  unint64_t v10 = v6;
  unint64_t v343 = v5;
  unint64_t v344 = v6;
  uint64_t v11 = HIBYTE(v6) & 0xF;
  uint64_t v12 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000LL) != 0) {
    uint64_t v13 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v13 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v13 && (v5 & ~v6 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v6);
    unint64_t v14 = 0x80000001818B6F40LL | 0x8000000000000000LL;
    unint64_t v343 = 0xD00000000000001CLL;
    goto LABEL_86;
  }

  int64_t v3 = (int64_t)"Duplicate elements of type '";
  if ((v6 & 0x2000000000000000LL) != 0 && (0x80000001818B6F40LL & 0x2000000000000000LL) != 0)
  {
    unint64_t v15 = v11 + ((0x80000001818B6F40LL >> 56) & 0xF);
    if (v15 <= 0xF)
    {
      unint64_t v38 = (0x80000001818B6F40LL >> 56) & 0xF;
      if (v38)
      {
        char v59 = 0;
        uint64_t v60 = 0LL;
        unint64_t v39 = v6;
        do
        {
          uint64_t v61 = v11 + v60;
          uint64_t v62 = v60 + 1;
          unint64_t v63 = 0x80000001818B6F40LL | 0x8000000000000000LL;
          if (v60 < 8) {
            unint64_t v63 = 0xD00000000000001CLL;
          }
          unint64_t v64 = v63 >> (v59 & 0x38);
          char v65 = (8 * v11 + v59) & 0x38;
          uint64_t v66 = (-255LL << v65) - 1;
          unint64_t v67 = (unint64_t)v64 << v65;
          unint64_t v68 = v67 | v66 & v39;
          unint64_t v69 = v67 | v66 & v9;
          if (v61 < 8) {
            unint64_t v9 = v69;
          }
          else {
            unint64_t v39 = v68;
          }
          v59 += 8;
          uint64_t v60 = v62;
        }

        while (v38 != v62);
      }

      else
      {
        unint64_t v39 = v6;
      }

      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x80000001818B6F40LL | 0x8000000000000000LL);
      unint64_t v70 = 0xA000000000000000LL;
      if (!(v9 & 0x8080808080808080LL | v39 & 0x80808080808080LL)) {
        unint64_t v70 = 0xE000000000000000LL;
      }
      unint64_t v14 = v70 & 0xFF00000000000000LL | (v15 << 56) | v39 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_85;
    }
  }

  int64_t v2 = 0x80000001818B6F40LL | 0x8000000000000000LL;
  if ((0x80000001818B6F40LL & 0x2000000000000000LL) != 0) {
    uint64_t v16 = (0x80000001818B6F40LL >> 56) & 0xF;
  }
  else {
    uint64_t v16 = 28LL;
  }
  swift_bridgeObjectRetain_n(0x80000001818B6F40LL | 0x8000000000000000LL, 2LL, v7, v8);
  if ((0x80000001818B6F40LL & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRetain_n(0x80000001818B6F40LL | 0x8000000000000000LL, 5LL, v17, v18);
    v317._Swift::UInt64 rawBits = 1LL;
    v318._Swift::UInt64 rawBits = (v16 << 16) | 1;
    v319._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v317,  v318,  0xD00000000000001CLL,  0x80000001818B6F40LL | 0x8000000000000000LL);
    if (v319._rawBits < 0x10000) {
      v319._rawBits |= 3;
    }
    int64_t v1 = specialized Collection.count.getter( v319,  v320,  0xD00000000000001CLL,  0x80000001818B6F40LL | 0x8000000000000000LL);
    swift_bridgeObjectRelease(0x80000001818B6F40LL | 0x8000000000000000LL);
    if ((v10 & 0x1000000000000000LL) == 0)
    {
LABEL_15:
      BOOL v22 = __OFADD__(v13, v1);
      uint64_t v23 = v13 + v1;
      if (!v22)
      {
LABEL_16:
        int64_t v2 = v9 & ~v10;
        if ((v2 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v9, v10);
          if ((v19 & 1) != 0)
          {
LABEL_247:
            unint64_t v188 = 258LL;
            goto LABEL_248;
          }

          if (v23 > 15) {
            goto LABEL_24;
          }
          if ((v10 & 0x2000000000000000LL) == 0)
          {
            if (v24 < v1)
            {
LABEL_35:
              if ((v10 & 0x1000000000000000LL) == 0)
              {
                if ((v9 & 0x1000000000000000LL) != 0)
                {
                  uint64_t v29 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
                }

                else
                {
                  uint64_t v29 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v10);
                  uint64_t v12 = v19;
                }

                swift_bridgeObjectRetain(v10, v19, v20, v21);
                closure #1 in _StringGuts._convertedToSmall()(v29, v12, &v341);
                swift_bridgeObjectRelease(v10);
                unint64_t v9 = v341;
                uint64_t v12 = v342;
                goto LABEL_58;
              }

              goto LABEL_328;
            }

LABEL_335:
      swift_errorRelease((id)v9);
      __break(1u);
      while (1)
      {
        swift_errorRelease((id)v9);
        swift_bridgeObjectRelease(v12 | 0x8000000000000000LL);
        __break(1u);
LABEL_337:
        uint64_t v105 = v339;
LABEL_138:
        unint64_t v106 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v105, (uint64_t)v104, v16);
        _StringGuts.appendInPlace(_:isASCII:)(v106, v107, v12 < 0);
        if (!v9) {
          goto LABEL_195;
        }
        swift_errorRelease((id)v9);
        swift_bridgeObjectRelease(a1);
        __break(1u);
LABEL_140:
        if (((*(void *)(v16 + 8) | *(void *)v16) & 0x8080808080808080LL) == 0)
        {
          unint64_t v108 = v16 + v79;
          uint64_t v78 = (uint64_t *)(v16 + 16);
          while ((unint64_t)v78 < v108)
          {
            uint64_t v109 = *v78;
            uint64_t v110 = v78[1];
            v78 += 2;
            if (((v110 | v109) & 0x8080808080808080LL) != 0) {
              goto LABEL_144;
            }
          }

          goto LABEL_98;
        }

      int8x16_t v293 = 266LL;
LABEL_337:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v293,  0);
    }

    break;
  }

            uint64_t v137 = 0LL;
          }

          this = v7;
          unsigned int v250 = 344;
LABEL_365:
          uint64_t v78 = v137;
          unint64_t v75 = (unsigned __int16 *)a5;
          return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v250,  (swift::Demangle::__runtime::Node *)v78,  (swift::Demangle::__runtime::Node *)v75,  a5);
        case 'r':
          int8x16_t v234 = *((_DWORD *)this + 24);
          if (!v234) {
            goto LABEL_336;
          }
          uint16x8_t v235 = v234 - 1;
          int8x16_t v236 = *((void *)this + 11);
          unint64_t v75 = *(unsigned __int16 **)(v236 + 8LL * (v234 - 1));
          uint16x8_t v237 = v75[8];
          if (v237 == 232)
          {
            *((_DWORD *)this + 24) = v235;
          }

          else
          {
            if (v237 == 43)
            {
              *((_DWORD *)this + 24) = v235;
              else {
                *((_DWORD *)this + 24) = v238;
              }
              unsigned int v250 = 280;
              return (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v250,  (swift::Demangle::__runtime::Node *)v78,  (swift::Demangle::__runtime::Node *)v75,  a5);
            }

LABEL_183:
        uint64_t v12 = (uint64_t)swift_allocError( (uint64_t)&unk_189B86A70,  (uint64_t)&protocol witness table for UTF8ValidationError,  0LL,  0);
        unint64_t v9 = v12;
        swift_willThrow();
        swift_errorRelease((id)v12);
        uint64_t v119 = specialized Collection.subscript.getter(v10, v16, a1);
        uint64_t v23 = findInvalidRange #1 (_:) in validateUTF8(_:)(v119, v120, v121, v122);
        unint64_t v341 = 0LL;
        unint64_t v342 = 0xE000000000000000LL;
        if (__OFADD__(a1, 15LL)) {
          goto LABEL_310;
        }
        uint64_t v12 = v123;
        _StringGuts.reserveCapacity(_:)(a1 + 15);
        unint64_t v9 = 0LL;
        while (2)
        {
          uint64_t v124 = specialized Collection.subscript.getter(v23, v16, a1);
          uint64_t v128 = v341 & 0xFFFFFFFFFFFFLL;
          if ((v342 & 0x2000000000000000LL) != 0) {
            uint64_t v128 = HIBYTE(v342) & 0xF;
          }
          BOOL v22 = __OFADD__(v128, a1);
          uint64_t v129 = v128 + a1;
          if (v22)
          {
            __break(1u);
LABEL_193:
            __break(1u);
LABEL_194:
            _StringGuts._foreignAppendInPlace(_:)(v12, a1, 0LL, v340);
LABEL_195:
            swift_bridgeObjectRelease_n(a1, 2LL);
            goto LABEL_212;
          }

          uint64_t v130 = v124;
          if (__OFADD__(v129, 3LL)) {
            goto LABEL_193;
          }
          uint64_t v131 = v125;
          int64_t v2 = v126;
          uint64_t v132 = v127;
          _StringGuts.reserveCapacity(_:)(v129 + 3);
          unint64_t v133 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v130, v131, v2, v132);
          _StringGuts.appendInPlace(_:isASCII:)(v133, v134, 0);
          size_t v345 = 3LL;
          uint64_t v346 = 12435439LL;
          specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v346, &v345, &v341);
          uint64_t v135 = specialized Collection.subscript.getter(v12, v16, a1);
          uint64_t v16 = specialized UnsafeBufferPointer.init(rebasing:)(v135, v136, v137, v138);
          a1 = v139;
          uint64_t v140 = validateUTF8(_:)((uint64_t *)v16, v139);
          if ((v73 & 1) != 0)
          {
            uint64_t v23 = v140;
            uint64_t v12 = v141;
            if (!a1) {
              goto LABEL_303;
            }
            continue;
          }

          break;
        }

        _StringGuts.appendInPlace(_:isASCII:)((char *)v16, a1, 0);
LABEL_303:
        uint64_t v12 = v341;
        a1 = v342;
LABEL_91:
        uint64_t v16 = v343;
        unint64_t v10 = v344;
        unint64_t v75 = HIBYTE(v344) & 0xF;
        if ((v344 & 0x2000000000000000LL) != 0) {
          int64_t v3 = HIBYTE(v344) & 0xF;
        }
        else {
          int64_t v3 = v343 & 0xFFFFFFFFFFFFLL;
        }
        if (!v3 && (v343 & ~v344 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v344);
          unint64_t v343 = v12;
          unint64_t v344 = a1;
          goto LABEL_212;
        }

        int64_t v1 = a1 & 0x2000000000000000LL;
        uint64_t v23 = HIBYTE(a1) & 0xF;
        if ((v344 & 0x2000000000000000LL) == 0 || !v1) {
          break;
        }
        unint64_t v81 = v75 + v23;
        if (v75 + v23 > 0xF)
        {
          int64_t v1 = 1LL;
          break;
        }

        if (v23)
        {
          char v146 = 0;
          unint64_t v147 = 0LL;
          int64_t v2 = v344;
          do
          {
            unint64_t v148 = v75 + v147;
            unint64_t v149 = v147 + 1;
            if (v147 >= 8) {
              unint64_t v150 = a1;
            }
            else {
              unint64_t v150 = v12;
            }
            unint64_t v151 = v150 >> (v146 & 0x38);
            char v152 = (8 * v75 + v146) & 0x38;
            uint64_t v153 = (-255LL << v152) - 1;
            unint64_t v154 = (unint64_t)v151 << v152;
            unint64_t v155 = v154 | v153 & v2;
            unint64_t v156 = v154 | v153 & v16;
            if (v148 < 8) {
              uint64_t v16 = v156;
            }
            else {
              int64_t v2 = v155;
            }
            v146 += 8;
            unint64_t v147 = v149;
          }

          while (v23 != v149);
        }

        else
        {
          int64_t v2 = v344;
        }

        swift_bridgeObjectRelease(v344);
        swift_bridgeObjectRelease(a1);
        unint64_t v157 = 0xA000000000000000LL;
        if (!(v16 & 0x8080808080808080LL | v2 & 0x80808080808080LL)) {
          unint64_t v157 = 0xE000000000000000LL;
        }
        unint64_t v343 = v16;
        unint64_t v344 = v157 & 0xFF00000000000000LL | (v81 << 56) | v2 & 0xFFFFFFFFFFFFFFLL;
LABEL_212:
        unint64_t v10 = v343;
        a1 = v344;
        unint64_t v158 = HIBYTE(v344) & 0xF;
        if ((v344 & 0x2000000000000000LL) != 0) {
          unint64_t v159 = HIBYTE(v344) & 0xF;
        }
        else {
          unint64_t v159 = v343 & 0xFFFFFFFFFFFFLL;
        }
        int64_t v3 = (int64_t)"' were found in a Set.\n"
                             "This usually means either that the type violates Hashable's requirements, or\n"
                             "that members of such a set were mutated after insertion.";
        if (!v159 && (v343 & ~v344 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v344);
          unint64_t v343 = 0xD00000000000009CLL;
          unint64_t v344 = 0x80000001818B6F60LL | 0x8000000000000000LL;
          goto LABEL_265;
        }

        if ((v344 & 0x2000000000000000LL) != 0 && (0x80000001818B6F60LL & 0x2000000000000000LL) != 0)
        {
          unint64_t v160 = v158 + ((0x80000001818B6F60LL >> 56) & 0xF);
          if (v160 <= 0xF)
          {
            unint64_t v192 = (0x80000001818B6F60LL >> 56) & 0xF;
            if (v192)
            {
              char v194 = 0;
              uint64_t v195 = 0LL;
              unint64_t v193 = v344;
              do
              {
                uint64_t v196 = v158 + v195;
                uint64_t v197 = v195 + 1;
                unint64_t v198 = 0xD00000000000009CLL;
                if (v195 >= 8) {
                  unint64_t v198 = 0x80000001818B6F60LL | 0x8000000000000000LL;
                }
                unint64_t v199 = v198 >> (v194 & 0x38);
                char v200 = (8 * v158 + v194) & 0x38;
                uint64_t v201 = (-255LL << v200) - 1;
                unint64_t v202 = (unint64_t)v199 << v200;
                unint64_t v203 = v202 | v201 & v193;
                unint64_t v204 = v202 | v201 & v10;
                if (v196 < 8) {
                  unint64_t v10 = v204;
                }
                else {
                  unint64_t v193 = v203;
                }
                v194 += 8;
                uint64_t v195 = v197;
              }

              while (v192 != v197);
            }

            else
            {
              unint64_t v193 = v344;
            }

            swift_bridgeObjectRelease(v344);
            swift_bridgeObjectRelease(0x80000001818B6F60LL | 0x8000000000000000LL);
            unint64_t v205 = 0xA000000000000000LL;
            if (!(v10 & 0x8080808080808080LL | v193 & 0x80808080808080LL)) {
              unint64_t v205 = 0xE000000000000000LL;
            }
            unint64_t v343 = v10;
            unint64_t v344 = v205 & 0xFF00000000000000LL | (v160 << 56) | v193 & 0xFFFFFFFFFFFFFFLL;
            goto LABEL_265;
          }
        }

        int64_t v1 = 0x80000001818B6F60LL | 0x8000000000000000LL;
        if ((0x80000001818B6F60LL & 0x2000000000000000LL) != 0) {
          uint64_t v16 = (0x80000001818B6F60LL >> 56) & 0xF;
        }
        else {
          uint64_t v16 = 156LL;
        }
        swift_bridgeObjectRetain_n(0x80000001818B6F60LL | 0x8000000000000000LL, 2LL, v76, v77);
        if ((0x80000001818B6F60LL & 0x1000000000000000LL) == 0)
        {
          swift_bridgeObjectRetain_n(0x80000001818B6F60LL | 0x8000000000000000LL, 4LL, v161, v162);
          Swift::Int v166 = v16;
          if ((a1 & 0x1000000000000000LL) == 0) {
            goto LABEL_226;
          }
LABEL_324:
          Swift::Int v334 = String.UTF8View._foreignCount()();
          int64_t v167 = v334 + v166;
          if (!__OFADD__(v334, v166)) {
            goto LABEL_227;
          }
LABEL_326:
          __break(1u);
LABEL_327:
          __break(1u);
LABEL_328:
          unint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, v10);
          uint64_t v12 = v335;
LABEL_58:
          v40._Swift::UInt64 rawBits = (v16 << 16) | 1;
          v41._Swift::UInt64 rawBits = 1LL;
          v42._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v41,  v40,  0xD00000000000001CLL,  (v3 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
          if (v42._rawBits < 0x10000) {
            v42._rawBits |= 3;
          }
          uint64_t v23 = specialized String.init(_:)( v42,  v43,  0xD00000000000001CLL,  (v3 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
          uint64_t v16 = v44;
          swift_bridgeObjectRelease((v3 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
          if ((v16 & 0x2000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v16);
            goto LABEL_62;
          }

        unint64_t v37 = v295;
        goto LABEL_184;
      }

          _StringGuts._foreignGrow(_:)(v110);
LABEL_169:
          uint64x2_t v243 = *(void *)(Description + 8);
          v268[0] = v46;
          v268[1] = v260;
          int8x16_t v267 = swift_getWitnessTable(&protocol conformance descriptor for <> FlattenSequence<A>, v259, v268);
          int8x16_t v244 = v253;
          swift_getWitnessTable(&protocol conformance descriptor for <> LazySequence<A>, v253, &v267);
          int8x16_t v245 = v109;
          int8x16_t v246 = v254;
          __StringStorage.replace<A>(from:to:with:replacementCount:)((uint64_t)v50, v245, v254, (uint64_t)v20, v244);
          (*(void (**)(uint64_t, uint64_t))(v252 + 8))(v246, v244);
          *(void *)Description = *(void *)(v243 + 24);
          return v50;
        }
      }

      __break(1u);
      goto LABEL_176;
    }

    unint64_t v108 = v270;
    uint64_t v109 = __src >> 16;
    uint64_t v110 = v270 >> 16;
    if ((v272 & 0x2000000000000000LL) != 0)
    {
      unint64_t v191 = HIBYTE(v272) & 0xF;
      __int128 __src = v271;
      uint32x4_t v270 = v272 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v192 = v266;
      if (v191 >= v110)
      {
        unint64_t v193 = specialized UnsafeBufferPointer.init(rebasing:)(v109, v108 >> 16, (uint64_t)&__src, v191);
        unint64_t v50 = (const char *)(v265 >> 16);
        uint64_t v195 = (v265 >> 16) + v194;
        if (!__OFADD__(v265 >> 16, v194))
        {
          uint64_t v196 = v262 >> 16;
          uint64_t v197 = v192[1];
          if ((v197 & 0x2000000000000000LL) != 0) {
            unint64_t v198 = HIBYTE(v197) & 0xF;
          }
          else {
            unint64_t v198 = *v192 & 0xFFFFFFFFFFFFLL;
          }
          unint64_t v199 = v198 - v196;
          Description = v195 + v199;
          if (!__OFADD__(v195, v199))
          {
            char v200 = (char *)v193;
            uint64_t v201 = v194;
            if (Description >= 16)
            {
              unint64_t v202 = _StringGuts.uniqueNativeCapacity.getter();
              if ((v203 & 1) != 0 || v202 < Description) {
                _StringGuts.grow(_:)(Description);
              }
            }

            unint64_t v204 = v192[1];
            __StringStorage.replace(from:to:with:)((uint64_t)v50, v196, v200, v201);
            swift_bridgeObjectRelease(v46);
            char *v192 = *(void *)(v204 + 24);
            return v50;
          }

          goto LABEL_182;
        }

        goto LABEL_180;
      }
    }

    else
    {
      unint64_t v15 = v266;
      if ((v271 & 0x1000000000000000LL) != 0)
      {
        uint64_t v111 = (id)((v272 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v112 = v271 & 0xFFFFFFFFFFFFLL;
        if ((uint64_t)(v271 & 0xFFFFFFFFFFFFLL) >= v110)
        {
LABEL_57:
          char v113 = specialized UnsafeBufferPointer.init(rebasing:)(v109, v110, (uint64_t)v111, v112);
          unint64_t v50 = (const char *)(v265 >> 16);
          unsigned __int8 v115 = (v265 >> 16) + v114;
          if (!__OFADD__(v265 >> 16, v114))
          {
            unint64_t v51 = v262 >> 16;
            int v116 = v15[1];
            if ((v116 & 0x2000000000000000LL) != 0) {
              unsigned int v117 = HIBYTE(v116) & 0xF;
            }
            else {
              unsigned int v117 = *v15 & 0xFFFFFFFFFFFFLL;
            }
            unsigned int v118 = v117 - v51;
            Description = v115 + v118;
            if (!__OFADD__(v115, v118))
            {
              unint64_t v48 = (char *)v113;
              unint64_t v49 = v114;
              if (Description < 16)
              {
LABEL_66:
                uint64_t v121 = v15[1];
                __StringStorage.replace(from:to:with:)((uint64_t)v50, v51, v48, v49);
                *unint64_t v15 = *(void *)(v121 + 24);
                swift_bridgeObjectRelease(v46);
                return v50;
              }

  uint64_t v139 = (char *)_StringObject.sharedUTF8.getter(v12, v15);
LABEL_126:
  if (v8 + 1 == v140) {
    goto LABEL_133;
  }
  if (!v139) {
LABEL_214:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  uint64_t v141 = *(unsigned __int16 *)&v139[v8];
LABEL_131:
  if (v141 != 2573 && (v141 & 0x80808080) == 0) {
    goto LABEL_133;
  }
LABEL_179:
  uint64_t v137 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v8);
  uint64_t v138 = v7._rawBits & 0xFFFFFFFFFFFF0000LL;
  if (v137 <= 63) {
    goto LABEL_134;
  }
LABEL_135:
  unint64_t v142 = v138 | 5;
  if ((v7._rawBits & 2) != 0
    && (v8 < v20 || _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v138 | 5))))
  {
    unint64_t v142 = v138 | 7;
  }

  v19->_Swift::UInt64 rawBits = v142;
LABEL_140:
  if (v6._rawBits) {
LABEL_141:
  }
    v19[1]._Swift::UInt64 rawBits = (v21 << 16) | 5;
}

        std::string::push_back((std::string *)a1, 32);
        goto LABEL_206;
      }

      uint64_t v78 = *((unsigned __int8 *)v76 + 18);
      unint64_t v75 = 0LL;
      if (v78 == 5)
      {
        unint64_t v75 = 0LL;
        if (*((_DWORD *)v76 + 2)) {
          break;
        }
      }
    }

    uint64_t v76 = *(swift::Demangle::__runtime::Node **)v76;
LABEL_195:
    unint64_t v75 = *(swift::Demangle::__runtime::Node **)v76;
    goto LABEL_196;
  }

LABEL_317:
          unint64_t v327 = v10;
          if ((v16 & 0x1000000000000000LL) != 0)
          {
            uint64_t v23 = _StringGuts._foreignConvertedToSmall()(v23, v16);
            uint64_t v338 = v337;
            swift_bridgeObjectRelease(v16);
            uint64_t v16 = v338;
            unint64_t v10 = v327;
          }

          else
          {
            if ((v23 & 0x1000000000000000LL) != 0)
            {
              uint64_t v328 = (unsigned __int8 *)((v16 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v329 = v23 & 0xFFFFFFFFFFFFLL;
            }

            else
            {
              uint64_t v328 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v23, v16);
            }

            closure #1 in _StringGuts._convertedToSmall()(v328, v329, &v341);
            swift_bridgeObjectRelease(v16);
            uint64_t v23 = v341;
            uint64_t v16 = v342;
          }

LABEL_267:
              unint64_t v208 = a1 - 8;
              unint64_t v209 = 8LL;
              if (a1 < 8) {
                unint64_t v209 = a1;
              }
              if ((v209 & 0x8000000000000000LL) != 0) {
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
              }
              if (v209 < 8)
              {
                unint64_t v210 = 0LL;
                uint64_t v12 = 0LL;
                unint64_t v211 = 0LL;
                goto LABEL_280;
              }

              if (v209 >= 0x10)
              {
                unint64_t v210 = v209 & 0xFFFFFFFFFFFFFFF0LL;
                uint16x8_t v235 = vmovl_high_u8(*(uint8x16_t *)v16);
                int8x16_t v236 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v235.i8);
                uint16x8_t v237 = vmovl_u8(*(uint8x8_t *)v16);
                int8x16_t v238 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v237.i8);
                int8x16_t v239 = (int8x16_t)vmovl_high_u16(v235);
                int8x8_t v240 = (int8x8_t)vextq_s8(v239, v239, 8uLL).u64[0];
                int8x16_t v241 = (int8x16_t)vmovl_high_u16(v237);
                int8x8_t v242 = (int8x8_t)vextq_s8(v241, v241, 8uLL).u64[0];
                *(int8x8_t *)v241.i8 = vorr_s8(*(int8x8_t *)v241.i8, *(int8x8_t *)v239.i8);
                v243.i64[0] = v241.u32[0];
                v243.i64[1] = v241.u32[1];
                int8x16_t v244 = (int8x16_t)vshlq_u64(v243, (uint64x2_t)xmmword_1817FFCE0);
                *(int8x8_t *)v239.i8 = vorr_s8(*(int8x8_t *)v238.i8, *(int8x8_t *)v236.i8);
                v243.i64[0] = v239.u32[0];
                v243.i64[1] = v239.u32[1];
                int8x16_t v245 = vorrq_s8((int8x16_t)vshlq_u64(v243, (uint64x2_t)xmmword_1817FFCD0), v244);
                *(int8x8_t *)v239.i8 = vorr_s8(v242, v240);
                v243.i64[0] = v239.u32[0];
                v243.i64[1] = v239.u32[1];
                int8x16_t v246 = (int8x16_t)vshlq_u64(v243, (uint64x2_t)xmmword_1817FFCC0);
                *(int8x8_t *)v236.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v238, v238, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v236, v236, 8uLL));
                v243.i64[0] = v236.u32[0];
                v243.i64[1] = v236.u32[1];
                int8x16_t v247 = vorrq_s8(v245, vorrq_s8((int8x16_t)vshlq_u64(v243, (uint64x2_t)xmmword_1817FFCB0), v246));
                uint64_t v12 = (uint64_t)vorr_s8(*(int8x8_t *)v247.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v247, v247, 8uLL));
                if (v209 != (v209 & 0xFFFFFFFFFFFFFFF0LL))
                {
                  unint64_t v211 = 8 * v210;
                  if ((v209 & 8) == 0) {
                    goto LABEL_280;
                  }
                  goto LABEL_274;
                }
              }

              else
              {
                uint64_t v12 = 0LL;
                unint64_t v211 = 0LL;
                unint64_t v210 = 0LL;
LABEL_274:
                unint64_t v212 = v210;
                int64x2_t v213 = vdupq_n_s64(v211);
                unint64_t v210 = v209 & 0xFFFFFFFFFFFFFFF8LL;
                unint64_t v211 = 8 * (v209 & 0xFFFFFFFFFFFFFFF8LL);
                int8x16_t v214 = 0uLL;
                int8x16_t v215 = (int8x16_t)(unint64_t)v12;
                int64x2_t v216 = vaddq_s64(v213, (int64x2_t)xmmword_1817FFCC0);
                int64x2_t v217 = vaddq_s64(v213, (int64x2_t)xmmword_1817FFCE0);
                int64x2_t v218 = vaddq_s64(v213, (int64x2_t)xmmword_1817FFCB0);
                int64x2_t v219 = vaddq_s64(v213, (int64x2_t)xmmword_1817FFCD0);
                uint64_t v220 = (uint8x8_t *)(v16 + v212);
                int8x16_t v221 = (int8x16_t)vdupq_n_s64(0x38uLL);
                unint64_t v222 = v212 - (v209 & 0xFFFFFFFFFFFFFFF8LL);
                int64x2_t v223 = vdupq_n_s64(0x40uLL);
                int8x16_t v224 = 0uLL;
                int8x16_t v225 = 0uLL;
                do
                {
                  uint8x8_t v226 = *v220++;
                  uint16x8_t v227 = vmovl_u8(v226);
                  uint32x4_t v228 = vmovl_high_u16(v227);
                  v229.i64[0] = v228.u32[2];
                  v229.i64[1] = v228.u32[3];
                  uint64x2_t v230 = v229;
                  v229.i64[0] = v228.u32[0];
                  v229.i64[1] = v228.u32[1];
                  uint64x2_t v231 = v229;
                  uint32x4_t v232 = vmovl_u16(*(uint16x4_t *)v227.i8);
                  v229.i64[0] = v232.u32[2];
                  v229.i64[1] = v232.u32[3];
                  uint64x2_t v233 = v229;
                  v229.i64[0] = v232.u32[0];
                  v229.i64[1] = v232.u32[1];
                  int8x16_t v225 = vorrq_s8((int8x16_t)vshlq_u64(v230, (uint64x2_t)vandq_s8((int8x16_t)v216, v221)), v225);
                  int8x16_t v224 = vorrq_s8((int8x16_t)vshlq_u64(v231, (uint64x2_t)vandq_s8((int8x16_t)v217, v221)), v224);
                  int8x16_t v214 = vorrq_s8((int8x16_t)vshlq_u64(v233, (uint64x2_t)vandq_s8((int8x16_t)v218, v221)), v214);
                  int8x16_t v215 = vorrq_s8((int8x16_t)vshlq_u64(v229, (uint64x2_t)vandq_s8((int8x16_t)v219, v221)), v215);
                  int64x2_t v217 = vaddq_s64(v217, v223);
                  int64x2_t v218 = vaddq_s64(v218, v223);
                  int64x2_t v219 = vaddq_s64(v219, v223);
                  int64x2_t v216 = vaddq_s64(v216, v223);
                  v222 += 8LL;
                }

                while (v222);
                int8x16_t v234 = vorrq_s8(vorrq_s8(v215, v224), vorrq_s8(v214, v225));
                uint64_t v12 = (uint64_t)vorr_s8(*(int8x8_t *)v234.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v234, v234, 8uLL));
                if (v209 != v210)
                {
LABEL_280:
                  uint64_t v248 = (unsigned __int8 *)(v16 + v210);
                  unint64_t v249 = v209 - v210;
                  do
                  {
                    unsigned int v250 = *v248++;
                    v12 |= (unint64_t)v250 << (v211 & 0x38);
                    v211 += 8LL;
                    --v249;
                  }

                  while (v249);
                }
              }

              if (a1 < 9)
              {
                int8x8_t v252 = 0LL;
              }

              else
              {
                if (v208 < 8)
                {
                  unint64_t v251 = 0LL;
                  int8x8_t v252 = 0LL;
                  unint64_t v253 = 0LL;
                  goto LABEL_296;
                }

                if (v208 >= 0x10)
                {
                  unint64_t v277 = (uint8x16_t *)(v16 + 8);
                  unint64_t v251 = v208 & 0xFFFFFFFFFFFFFFF0LL;
                  int64x2_t v278 = (int64x2_t)xmmword_1817FFD60;
                  int64x2_t v279 = (int64x2_t)xmmword_1817FFD70;
                  int64x2_t v280 = (int64x2_t)xmmword_1817FFD80;
                  int64x2_t v281 = (int64x2_t)xmmword_1817FFD90;
                  int64x2_t v282 = (int64x2_t)xmmword_1817FFCC0;
                  int64x2_t v283 = (int64x2_t)xmmword_1817FFCE0;
                  int8x16_t v284 = (int8x16_t)vdupq_n_s64(0x38uLL);
                  int64x2_t v285 = vdupq_n_s64(0x80uLL);
                  int64x2_t v286 = (int64x2_t)xmmword_1817FFCB0;
                  unint64_t v253 = 8 * (v208 & 0xFFFFFFFFFFFFFFF0LL);
                  int8x16_t v287 = 0uLL;
                  int8x16_t v288 = 0uLL;
                  int64x2_t v289 = (int64x2_t)xmmword_1817FFCD0;
                  unint64_t v290 = v208 & 0xFFFFFFFFFFFFFFF0LL;
                  int8x16_t v291 = 0uLL;
                  int8x16_t v292 = 0uLL;
                  int8x16_t v293 = 0uLL;
                  int8x16_t v294 = 0uLL;
                  int8x16_t v295 = 0uLL;
                  int8x16_t v296 = 0uLL;
                  do
                  {
                    uint8x16_t v297 = *v277++;
                    uint16x8_t v298 = vmovl_u8(*(uint8x8_t *)v297.i8);
                    uint32x4_t v299 = vmovl_high_u16(v298);
                    v300.i64[0] = v299.u32[2];
                    v300.i64[1] = v299.u32[3];
                    uint64x2_t v301 = v300;
                    uint16x8_t v302 = vmovl_high_u8(v297);
                    uint32x4_t v303 = vmovl_u16(*(uint16x4_t *)v302.i8);
                    v300.i64[0] = v303.u32[2];
                    v300.i64[1] = v303.u32[3];
                    uint64x2_t v304 = v300;
                    v300.i64[0] = v303.u32[0];
                    v300.i64[1] = v303.u32[1];
                    uint64x2_t v305 = v300;
                    v300.i64[0] = v299.u32[0];
                    v300.i64[1] = v299.u32[1];
                    uint64x2_t v306 = v300;
                    uint32x4_t v307 = vmovl_u16(*(uint16x4_t *)v298.i8);
                    v300.i64[0] = v307.u32[2];
                    v300.i64[1] = v307.u32[3];
                    uint64x2_t v308 = v300;
                    uint32x4_t v309 = vmovl_high_u16(v302);
                    v300.i64[0] = v309.u32[0];
                    v300.i64[1] = v309.u32[1];
                    uint64x2_t v310 = v300;
                    v300.i64[0] = v307.u32[0];
                    v300.i64[1] = v307.u32[1];
                    uint64x2_t v311 = v300;
                    v300.i64[0] = v309.u32[2];
                    v300.i64[1] = v309.u32[3];
                    int8x16_t v292 = vorrq_s8((int8x16_t)vshlq_u64(v301, (uint64x2_t)vandq_s8((int8x16_t)v282, v284)), v292);
                    int8x16_t v294 = vorrq_s8((int8x16_t)vshlq_u64(v304, (uint64x2_t)vandq_s8((int8x16_t)v280, v284)), v294);
                    int8x16_t v293 = vorrq_s8((int8x16_t)vshlq_u64(v305, (uint64x2_t)vandq_s8((int8x16_t)v281, v284)), v293);
                    int8x16_t v291 = vorrq_s8((int8x16_t)vshlq_u64(v306, (uint64x2_t)vandq_s8((int8x16_t)v283, v284)), v291);
                    int8x16_t v288 = vorrq_s8((int8x16_t)vshlq_u64(v308, (uint64x2_t)vandq_s8((int8x16_t)v286, v284)), v288);
                    int8x16_t v295 = vorrq_s8((int8x16_t)vshlq_u64(v310, (uint64x2_t)vandq_s8((int8x16_t)v279, v284)), v295);
                    int8x16_t v287 = vorrq_s8((int8x16_t)vshlq_u64(v311, (uint64x2_t)vandq_s8((int8x16_t)v289, v284)), v287);
                    int8x16_t v296 = vorrq_s8((int8x16_t)vshlq_u64(v300, (uint64x2_t)vandq_s8((int8x16_t)v278, v284)), v296);
                    int64x2_t v283 = vaddq_s64(v283, v285);
                    int64x2_t v286 = vaddq_s64(v286, v285);
                    int64x2_t v289 = vaddq_s64(v289, v285);
                    int64x2_t v282 = vaddq_s64(v282, v285);
                    int64x2_t v281 = vaddq_s64(v281, v285);
                    int64x2_t v280 = vaddq_s64(v280, v285);
                    int64x2_t v279 = vaddq_s64(v279, v285);
                    int64x2_t v278 = vaddq_s64(v278, v285);
                    v290 -= 16LL;
                  }

                  while (v290);
                  int8x16_t v312 = vorrq_s8( vorrq_s8(vorrq_s8(v287, v293), vorrq_s8(v291, v295)),  vorrq_s8(vorrq_s8(v288, v294), vorrq_s8(v292, v296)));
                  int8x8_t v252 = vorr_s8(*(int8x8_t *)v312.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v312, v312, 8uLL));
                  if (v208 != v251)
                  {
                    if ((v208 & 8) == 0) {
                      goto LABEL_296;
                    }
                    goto LABEL_288;
                  }
                }

                else
                {
                  int8x8_t v252 = 0LL;
                  unint64_t v253 = 0LL;
                  unint64_t v251 = 0LL;
LABEL_288:
                  unint64_t v254 = v251;
                  unint64_t v251 = v208 & 0xFFFFFFFFFFFFFFF8LL;
                  int64x2_t v255 = vdupq_n_s64(v253);
                  unint64_t v253 = 8 * (v208 & 0xFFFFFFFFFFFFFFF8LL);
                  int8x16_t v256 = (int8x16_t)(unint64_t)v252;
                  int8x16_t v257 = 0uLL;
                  int64x2_t v258 = vaddq_s64(v255, (int64x2_t)xmmword_1817FFCC0);
                  int64x2_t v259 = vaddq_s64(v255, (int64x2_t)xmmword_1817FFCE0);
                  int64x2_t v260 = vaddq_s64(v255, (int64x2_t)xmmword_1817FFCB0);
                  int64x2_t v261 = vaddq_s64(v255, (int64x2_t)xmmword_1817FFCD0);
                  char v262 = (uint8x8_t *)(v254 + v16 + 8);
                  int8x16_t v263 = (int8x16_t)vdupq_n_s64(0x38uLL);
                  unint64_t v264 = v254 - (v208 & 0xFFFFFFFFFFFFFFF8LL);
                  int64x2_t v265 = vdupq_n_s64(0x40uLL);
                  int8x16_t v266 = 0uLL;
                  int8x16_t v267 = 0uLL;
                  do
                  {
                    uint8x8_t v268 = *v262++;
                    uint16x8_t v269 = vmovl_u8(v268);
                    uint32x4_t v270 = vmovl_high_u16(v269);
                    v271.i64[0] = v270.u32[2];
                    v271.i64[1] = v270.u32[3];
                    uint64x2_t v272 = v271;
                    v271.i64[0] = v270.u32[0];
                    v271.i64[1] = v270.u32[1];
                    uint64x2_t v273 = v271;
                    uint32x4_t v274 = vmovl_u16(*(uint16x4_t *)v269.i8);
                    v271.i64[0] = v274.u32[2];
                    v271.i64[1] = v274.u32[3];
                    uint64x2_t v275 = v271;
                    v271.i64[0] = v274.u32[0];
                    v271.i64[1] = v274.u32[1];
                    int8x16_t v267 = vorrq_s8((int8x16_t)vshlq_u64(v272, (uint64x2_t)vandq_s8((int8x16_t)v258, v263)), v267);
                    int8x16_t v266 = vorrq_s8((int8x16_t)vshlq_u64(v273, (uint64x2_t)vandq_s8((int8x16_t)v259, v263)), v266);
                    int8x16_t v257 = vorrq_s8((int8x16_t)vshlq_u64(v275, (uint64x2_t)vandq_s8((int8x16_t)v260, v263)), v257);
                    int8x16_t v256 = vorrq_s8((int8x16_t)vshlq_u64(v271, (uint64x2_t)vandq_s8((int8x16_t)v261, v263)), v256);
                    int64x2_t v259 = vaddq_s64(v259, v265);
                    int64x2_t v260 = vaddq_s64(v260, v265);
                    int64x2_t v261 = vaddq_s64(v261, v265);
                    int64x2_t v258 = vaddq_s64(v258, v265);
                    v264 += 8LL;
                  }

                  while (v264);
                  int8x16_t v276 = vorrq_s8(vorrq_s8(v256, v266), vorrq_s8(v257, v267));
                  int8x8_t v252 = vorr_s8(*(int8x8_t *)v276.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v276, v276, 8uLL));
                  if (v208 != v251)
                  {
LABEL_296:
                    uint64_t v313 = a1 - v251 - 8;
                    uint64_t v314 = (unsigned __int8 *)(v251 + v16 + 8);
                    do
                    {
                      unsigned int v315 = *v314++;
                      *(void *)&v252 |= (unint64_t)v315 << (v253 & 0x38);
                      v253 += 8LL;
                      --v313;
                    }

                    while (v313);
                  }
                }
              }

              unint64_t v316 = 0xA000000000000000LL;
              if (((*(void *)&v252 | v12) & 0x8080808080808080LL) == 0) {
                unint64_t v316 = 0xE000000000000000LL;
              }
              a1 = v316 | (a1 << 56) | *(void *)&v252;
              goto LABEL_90;
            }
          }

          goto LABEL_144;
        }

        swift_bridgeObjectRetain_n(0x80000001818B6F60LL | 0x8000000000000000LL, 5LL, v161, v162);
        int64_t v2 = 0xD00000000000009CLL;
        v330._Swift::UInt64 rawBits = 1LL;
        v331._Swift::UInt64 rawBits = (v16 << 16) | 1;
        v332._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v330,  v331,  0xD00000000000009CLL,  0x80000001818B6F60LL | 0x8000000000000000LL);
        if (v332._rawBits < 0x10000) {
          v332._rawBits |= 3;
        }
        Swift::Int v166 = specialized Collection.count.getter( v332,  v333,  0xD00000000000009CLL,  0x80000001818B6F60LL | 0x8000000000000000LL);
        swift_bridgeObjectRelease(0x80000001818B6F60LL | 0x8000000000000000LL);
        if ((a1 & 0x1000000000000000LL) != 0) {
          goto LABEL_324;
        }
LABEL_226:
        BOOL v22 = __OFADD__(v159, v166);
        int64_t v167 = v159 + v166;
        if (v22) {
          goto LABEL_326;
        }
LABEL_227:
        if ((v10 & ~a1 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(a1 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v168 = _StringGuts.nativeUnusedCapacity.getter(v10, a1);
          if ((v163 & 1) != 0) {
            goto LABEL_247;
          }
          uint64_t v169 = ((unint64_t)a1 >> 61) & 1;
          if (v168 < v166) {
            LODWORD(v169) = 1;
          }
          if (v167 <= 15 && (_DWORD)v169)
          {
LABEL_234:
            swift_bridgeObjectRetain(a1, v163, v164, v165);
            unint64_t v170 = _StringGuts._convertedToSmall()(v10, a1);
            unint64_t v172 = v171;
            swift_bridgeObjectRelease(a1);
            v173._Swift::UInt64 rawBits = (v16 << 16) | 1;
            v174._Swift::UInt64 rawBits = 1LL;
            v175._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v174,  v173,  0xD00000000000009CLL,  0x80000001818B6F60LL | 0x8000000000000000LL);
            if (v175._rawBits < 0x10000) {
              v175._rawBits |= 3;
            }
            unint64_t v177 = specialized String.init(_:)( v175,  v176,  0xD00000000000009CLL,  0x80000001818B6F60LL | 0x8000000000000000LL);
            unint64_t v179 = v178;
            swift_bridgeObjectRelease(0x80000001818B6F60LL | 0x8000000000000000LL);
            unint64_t v180 = _StringGuts._convertedToSmall()(v177, v179);
            unint64_t v182 = v181;
            swift_bridgeObjectRelease(v179);
            unint64_t v183 = specialized _SmallString.init(_:appending:)(v170, v172, v180, v182);
            if ((v185 & 1) == 0)
            {
              unint64_t v186 = (char *)v183;
              unint64_t v187 = v184;
              swift_bridgeObjectRelease(a1);
              swift_bridgeObjectRelease(0x80000001818B6F60LL | 0x8000000000000000LL);
              unint64_t v343 = (unint64_t)v186;
              unint64_t v344 = v187;
              goto LABEL_265;
            }

        int64_t result = 0LL;
        goto LABEL_261;
      }
    }

    else
    {
      uint64_t v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      uint64_t v8 = v161;
      if (v161 > 0) {
        goto LABEL_5;
      }
    }

LABEL_238:
            unint64_t v188 = 266LL;
LABEL_248:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v188,  0);
          }
        }

        else if (v167 <= 15)
        {
          goto LABEL_234;
        }

        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v167, v166);
        if ((0x80000001818B6F60LL & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)( 0xD00000000000009CLL,  0x80000001818B6F60LL | 0x8000000000000000LL,  0LL,  v16);
          unint64_t v191 = 0x80000001818B6F60LL | 0x8000000000000000LL;
LABEL_252:
          swift_bridgeObjectRelease_n(v191, 2LL);
LABEL_265:
          _assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)v343, v344, 0);
        }

        if ((0x80000001818B6F60LL & 0x2000000000000000LL) != 0) {
          a1 = ((0x80000001818B6F60LL | 0x8000000000000000LL) >> 62) & 1;
        }
        else {
          a1 = 1LL;
        }
        swift_bridgeObjectRelease_n(0x80000001818B6F60LL | 0x8000000000000000LL, 5LL);
        if ((0x80000001818B6F60LL & 0x2000000000000000LL) != 0)
        {
          uint64_t v12 = 0x80000001818B6F60LL | 0x8000000000000000LL;
          swift_bridgeObjectRelease(0x80000001818B6F60LL | 0x8000000000000000LL);
          unint64_t v341 = 0xD00000000000009CLL;
          unint64_t v342 = 0x80000001818B6F60LL & 0xFFFFFFFFFFFFFFLL;
          Swift::String::Index v206 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v16,  (uint64_t)&v341,  (0x80000001818B6F60LL >> 56) & 0xF);
          unint64_t v104 = &v343;
          _StringGuts.appendInPlace(_:isASCII:)(v206, v207, a1);
          if (!v9)
          {
            swift_bridgeObjectRelease(0x80000001818B6F60LL | 0x8000000000000000LL);
            goto LABEL_265;
          }

          goto LABEL_335;
        }

        uint64_t v12 = 0x80000001818B6F60LL;
        unint64_t v189 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v16,  (0x80000001818B6F60LL & 0xFFFFFFFFFFFFFFFLL) + 32,  156LL);
        unint64_t v104 = &v343;
        _StringGuts.appendInPlace(_:isASCII:)(v189, v190, a1);
        if (!v9)
        {
          unint64_t v191 = 0x80000001818B6F60LL | 0x8000000000000000LL;
          goto LABEL_252;
        }
      }

      uint64_t v339 = v12 & 0xFFFFFFFFFFFFLL;
      if (v1) {
        int64_t v2 = HIBYTE(a1) & 0xF;
      }
      else {
        int64_t v2 = v12 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain_n(a1, 2LL, v73, v74);
      uint64_t v340 = v2;
      if ((a1 & 0x1000000000000000LL) == 0)
      {
        swift_bridgeObjectRetain_n(a1, 4LL, v20, v21);
        if ((v10 & 0x1000000000000000LL) == 0) {
          continue;
        }
LABEL_314:
        Swift::Int v326 = String.UTF8View._foreignCount()();
        int64_t v3 = v326 + v2;
        if (!__OFADD__(v326, v2)) {
          goto LABEL_122;
        }
LABEL_316:
        __break(1u);
        goto LABEL_317;
      }

      break;
    }
  }

uint64_t specialized _NativeSet._unsafeInsertNew(_:at:)( uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  *(void *)(a4 + 8 * (a3 >> 6) + 56) |= 1LL << a3;
  unint64_t v4 = (void *)(*(void *)(a4 + 48) + 16 * a3);
  *unint64_t v4 = result;
  v4[1] = a2;
  uint64_t v5 = *(void *)(a4 + 16);
  BOOL v6 = __OFADD__(v5, 1LL);
  uint64_t v7 = v5 + 1;
  if (v6) {
    __break(1u);
  }
  else {
    *(void *)(a4 + 16) = v7;
  }
  return result;
}

uint64_t specialized _NativeSet._unsafeInsertNew(_:at:)(uint64_t result, unint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  uint64_t v3 = *(void *)(a3 + 48) + 40 * a2;
  __int128 v4 = *(_OWORD *)(result + 16);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)result;
  *(_OWORD *)(v3 + 16) = v4;
  *(void *)(v3 + 32) = *(void *)(result + 32);
  uint64_t v5 = *(void *)(a3 + 16);
  BOOL v6 = __OFADD__(v5, 1LL);
  uint64_t v7 = v5 + 1;
  if (v6) {
    __break(1u);
  }
  else {
    *(void *)(a3 + 16) = v7;
  }
  return result;
}

uint64_t _NativeSet._unsafeInsertNew(_:at:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 32LL))( *(void *)(a3 + 48) + *(void *)(*(void *)(a4 - 8) + 72LL) * a2,  a1,  a4);
  uint64_t v6 = *(void *)(a3 + 16);
  BOOL v7 = __OFADD__(v6, 1LL);
  uint64_t v8 = v6 + 1;
  if (v7) {
    __break(1u);
  }
  else {
    *(void *)(a3 + 16) = v8;
  }
  return result;
}

uint64_t specialized _NativeSet.insertNew(_:at:isUnique:)(uint64_t result, unint64_t a2, char a3)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 <= v6 || (a3 & 1) == 0)
  {
    uint64_t v8 = v6 + 1;
    if ((a3 & 1) != 0)
    {
      specialized _NativeSet.resize(capacity:)( v8,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>,  (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }

    else
    {
      if (v7 > v6)
      {
        uint64_t result = (uint64_t)specialized _NativeSet.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>);
        goto LABEL_12;
      }

      specialized _NativeSet.copyAndResize(capacity:)( v8,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>,  (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }

    uint64_t v9 = *v3;
    uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(*v3 + 40), v5);
    uint64_t v10 = -1LL << *(_BYTE *)(v9 + 32);
    a2 = result & ~v10;
    if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
    {
      uint64_t v11 = ~v10;
      while (*(void *)(*(void *)(v9 + 48) + 8 * a2) != v5)
      {
        a2 = (a2 + 1) & v11;
        if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
          goto LABEL_12;
        }
      }

{
  uint64_t *v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35[5];
  uint64_t v36[3];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39[3];
  uint64_t v40;
  uint64_t v41;
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0) {
    goto LABEL_15;
  }
  uint64_t v8 = v6 + 1;
  if ((a3 & 1) != 0)
  {
    specialized _NativeSet.resize(capacity:)(v8);
  }

  else
  {
    if (v7 > v6)
    {
      uint64_t result = (uint64_t)specialized _NativeSet.copy()();
      goto LABEL_15;
    }

    specialized _NativeSet.copyAndResize(capacity:)(v8);
  }

  uint64_t v9 = *v3;
  uint64_t v10 = *(void *)(*v3 + 40);
  uint64_t v11 = *(void *)(v5 + 24);
  uint64_t v12 = *(void *)(v5 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)v5, v11);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v12 + 8))(v39, v11, v12);
  uint64_t v13 = v40;
  BOOL v14 = v41;
  __swift_project_boxed_opaque_existential_0Tm(v39, v40);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 40))(v10, v13, v14);
  uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v39);
  uint64_t v16 = -1LL << *(_BYTE *)(v9 + 32);
  a2 = v15 & ~v16;
  char v34 = v9;
  uint64_t v17 = v9 + 56;
  if (((*(void *)(v17 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
  {
    uint64_t v18 = ~v16;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v34 + 48) + 40 * a2, (uint64_t)v39);
      uint64_t v19 = v40;
      uint64_t v20 = v41;
      __swift_project_boxed_opaque_existential_0Tm(v39, v40);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v36, v19, v20);
      uint64_t v21 = v37;
      BOOL v22 = v38;
      __swift_project_boxed_opaque_existential_0Tm(v36, v37);
      uint64_t v23 = *(void *)(v5 + 24);
      int64_t v24 = *(void *)(v5 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)v5, v23);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v24 + 8))(v35, v23, v24);
      int64_t v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v22 + 16))(v35, v21, v22);
      __swift_destroy_boxed_opaque_existential_1Tm(v35);
      if (v25 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v36);
        uint64_t result = (uint64_t)outlined destroy of AnyHashable(v39);
      }

      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v36);
        uint64_t result = (uint64_t)outlined destroy of AnyHashable(v39);
        if ((v25 & 1) != 0) {
          ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
        }
      }

      a2 = (a2 + 1) & v18;
    }

    while (((*(void *)(v17 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0);
  }

{
  uint64_t *v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 <= v6 || (a3 & 1) == 0)
  {
    uint64_t v8 = v6 + 1;
    if ((a3 & 1) != 0)
    {
      specialized _NativeSet.resize(capacity:)( v8,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<Int>,  (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }

    else
    {
      if (v7 > v6)
      {
        uint64_t result = (uint64_t)specialized _NativeSet.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<Int>);
        goto LABEL_12;
      }

      specialized _NativeSet.copyAndResize(capacity:)( v8,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _SetStorage<Int>,  (uint64_t (*)(void, void *))specialized _NativeSet._unsafeInsertNew(_:));
    }

    uint64_t v9 = *v3;
    uint64_t result = specialized static Hasher._hash(seed:_:)(*(void *)(*v3 + 40), v5);
    uint64_t v10 = -1LL << *(_BYTE *)(v9 + 32);
    a2 = result & ~v10;
    if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
    {
      uint64_t v11 = ~v10;
      while (*(void *)(*(void *)(v9 + 48) + 8 * a2) != v5)
      {
        a2 = (a2 + 1) & v11;
        if (((*(void *)(v9 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
          goto LABEL_12;
        }
      }

uint64_t specialized _NativeSet.insertNew(_:at:isUnique:)( uint64_t result, unint64_t a2, unint64_t a3, char a4)
{
  uint64_t v5 = v4;
  unint64_t v8 = result;
  unint64_t v9 = *(void *)(*v4 + 16);
  unint64_t v10 = *(void *)(*v4 + 24);
  if (v10 > v9 && (a4 & 1) != 0) {
    goto LABEL_25;
  }
  uint64_t v11 = v9 + 1;
  if ((a4 & 1) != 0)
  {
    specialized _NativeSet.resize(capacity:)(v11);
  }

  else
  {
    if (v10 > v9)
    {
      uint64_t result = (uint64_t)specialized _NativeSet.copy()();
      goto LABEL_25;
    }

    specialized _NativeSet.copyAndResize(capacity:)(v11);
  }

  uint64_t v12 = *v4;
  uint64_t v13 = _swift_stdlib_Hashing_parameters ^ *(void *)(*v4 + 40);
  v28[0] = 0LL;
  v28[1] = v13 ^ 0x736F6D6570736575LL;
  v28[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v28[3] = v13 ^ 0x6C7967656E657261LL;
  v28[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  String.hash(into:)(v28, v8, a2);
  uint64_t result = Hasher._finalize()();
  uint64_t v14 = -1LL << *(_BYTE *)(v12 + 32);
  a3 = result & ~v14;
  uint64_t v15 = v12 + 56;
  if (((*(void *)(v12 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a3) & 1) != 0)
  {
    uint64_t v16 = ~v14;
    uint64_t v17 = *(void *)(v12 + 48);
    do
    {
      uint64_t v18 = (uint64_t *)(v17 + 16 * a3);
      uint64_t result = *v18;
      unint64_t v19 = v18[1];
      BOOL v20 = *v18 == v8 && v19 == a2;
      if (v20
        || ((~v19 & 0x6000000000000000LL) == 0 ? (BOOL v21 = (a2 & 0x2000000000000000LL) == 0) : (BOOL v21 = 1),
            !v21 ? (BOOL v22 = (a2 & 0x4000000000000000LL) == 0) : (BOOL v22 = 1),
            v22 && (uint64_t result = _stringCompareInternal(_:_:expecting:)(result, v19, v8, a2, 0), (result & 1) != 0)))
      {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for String);
      }

      a3 = (a3 + 1) & v16;
    }

    while (((*(void *)(v15 + ((a3 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a3) & 1) != 0);
  }

void specialized _NativeSet.insertNew(_:at:isUnique:)(__int128 *a1, unint64_t a2, char a3)
{
  uint64_t v5 = *v3;
  unint64_t v6 = *(void *)(*v3 + 16);
  unint64_t v7 = *(void *)(*v3 + 24);
  if (v7 > v6 && (a3 & 1) != 0) {
    goto LABEL_90;
  }
  uint64_t v8 = v6 + 1;
  if ((a3 & 1) == 0)
  {
    if (v7 > v6)
    {
      uint64_t v26 = *(unsigned int *)(v5 + 36);
      uint64_t v27 = *(void **)(v5 + 40);
      char v28 = *(_BYTE *)(v5 + 32);
      LOBYTE(v93) = 0;
      __int128 v29 = specialized static _SetStorage.allocate(scale:age:seed:)(v28, v26, v27, 0);
      __int128 v30 = v29;
      if (!*(void *)(v5 + 16)) {
        goto LABEL_78;
      }
      char v31 = v29 + 7;
      uint64_t v32 = v5 + 56;
      unint64_t v33 = (unint64_t)((1LL << *((_BYTE *)v30 + 32)) + 63) >> 6;
      int64_t v35 = 0LL;
      _OWORD v30[2] = *(void *)(v5 + 16);
      uint64_t v36 = 1LL << *(_BYTE *)(v5 + 32);
      uint64_t v37 = -1LL;
      if (v36 < 64) {
        uint64_t v37 = ~(-1LL << v36);
      }
      unint64_t v38 = v37 & *(void *)(v5 + 56);
      int64_t v39 = (unint64_t)(v36 + 63) >> 6;
      while (1)
      {
        if (v38)
        {
          unint64_t v40 = __clz(__rbit64(v38));
          v38 &= v38 - 1;
          unint64_t v41 = v40 | (v35 << 6);
        }

        else
        {
          int64_t v46 = v35 + 1;
          if (__OFADD__(v35, 1LL))
          {
LABEL_93:
            __break(1u);
            goto LABEL_94;
          }

          if (v46 >= v39) {
            goto LABEL_78;
          }
          unint64_t v47 = *(void *)(v32 + 8 * v46);
          ++v35;
          if (!v47)
          {
            int64_t v35 = v46 + 1;
            if (v46 + 1 >= v39) {
              goto LABEL_78;
            }
            unint64_t v47 = *(void *)(v32 + 8 * v35);
            if (!v47)
            {
              int64_t v35 = v46 + 2;
              if (v46 + 2 >= v39) {
                goto LABEL_78;
              }
              unint64_t v47 = *(void *)(v32 + 8 * v35);
              if (!v47)
              {
                int64_t v48 = v46 + 3;
                if (v48 >= v39) {
                  goto LABEL_78;
                }
                unint64_t v47 = *(void *)(v32 + 8 * v48);
                if (!v47)
                {
                  while (1)
                  {
                    int64_t v35 = v48 + 1;
                    if (__OFADD__(v48, 1LL)) {
                      goto LABEL_97;
                    }
                    if (v35 >= v39) {
                      break;
                    }
                    unint64_t v47 = *(void *)(v32 + 8 * v35);
                    ++v48;
                    if (v47) {
                      goto LABEL_54;
                    }
                  }

LABEL_78:
                  swift_release(v5);
                  *uint64_t v3 = (uint64_t)v30;
LABEL_90:
                  uint64_t v80 = *v87;
                  *(void *)(*v87 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
                  uint64_t v81 = *(void *)(v80 + 48) + 40 * a2;
                  __int128 v82 = *a1;
                  __int128 v83 = a1[1];
                  *(void *)(v81 + 32) = *((void *)a1 + 4);
                  *(_OWORD *)uint64_t v81 = v82;
                  *(_OWORD *)(v81 + 16) = v83;
                  uint64_t v84 = *(void *)(v80 + 16);
                  BOOL v85 = __OFADD__(v84, 1LL);
                  uint64_t v86 = v84 + 1;
                  if (!v85)
                  {
                    *(void *)(v80 + 16) = v86;
                    return;
                  }

          swift_bridgeObjectRelease(v27);
          swift_bridgeObjectRetain(v32, v109, v110, v111);
          uint64_t v112 = _StringGuts._convertedToSmall()(v17, v32);
          uint64_t v114 = v113;
          swift_bridgeObjectRelease(v32);
          unsigned __int8 v115 = HIBYTE(v27) & 0xF;
          if ((v27 & 0x2000000000000000LL) == 0) {
            unsigned __int8 v115 = v25 & 0xFFFFFFFFFFFFLL;
          }
          if (v115 >= v8)
          {
            if ((a2 & 0xFFFFFFFFFFFF0000LL | 1) >= 0x10000) {
              v117._Swift::UInt64 rawBits = a2 & 0xFFFFFFFFFFFF0000LL | 1;
            }
            else {
              v117._Swift::UInt64 rawBits = a2 & 0xFFFFFFFFFFFF0000LL | 3;
            }
            v116._Swift::UInt64 rawBits = v34 & 0xFFFFFFFFFFFF0000LL | 1;
            unsigned int v118 = specialized String.init(_:)(v117, v116, v25, v27);
            uint64_t v120 = v119;
            swift_bridgeObjectRelease(v27);
            uint64_t v121 = _StringGuts._convertedToSmall()(v118, v120);
            uint64_t v123 = v122;
            swift_bridgeObjectRelease(v120);
            uint64_t v124 = HIBYTE(v114) & 0xF;
            uint64_t v125 = HIBYTE(v123) & 0xF;
            int64_t v126 = v125 + v124;
            if ((unint64_t)(v125 + v124) <= 0xF)
            {
              uint64_t v127 = (unint64_t *)v167;
              if (v125)
              {
                uint64_t v128 = 0LL;
                uint64_t v129 = 0LL;
                uint64_t v130 = 8 * v125;
                do
                {
                  uint64_t v131 = v124 + v129;
                  uint64_t v68 = v129++ >= 8;
                  if (v68) {
                    uint64_t v132 = v123;
                  }
                  else {
                    uint64_t v132 = v121;
                  }
                  unint64_t v133 = (8 * v124 + v128) & 0x38;
                  size_t v134 = (-255LL << v133) - 1;
                  uint64_t v135 = (unint64_t)(v132 >> (v128 & 0x38)) << v133;
                  uint64_t v136 = v135 | v134 & v114;
                  uint64_t v137 = v135 | v134 & v112;
                  if (v131 < 8) {
                    uint64_t v112 = v137;
                  }
                  else {
                    uint64_t v114 = v136;
                  }
                  v128 += 8LL;
                }

                while (v130 != v128);
              }

              swift_bridgeObjectRelease(v32);
              uint64_t v138 = 0xA000000000000000LL;
              if (!(v112 & 0x8080808080808080LL | v114 & 0x80808080808080LL)) {
                uint64_t v138 = 0xE000000000000000LL;
              }
              Swift::String::Index v173 = v112;
              Swift::String::Index v174 = v138 & 0xFF00000000000000LL | (v126 << 56) | v114 & 0xFFFFFFFFFFFFFFLL;
              goto LABEL_101;
            }

            goto LABEL_137;
          }

        if ((v59 & ~v60 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v60 & 0xFFFFFFFFFFFFFFFLL))
        {
          uint64_t v72 = (unint64_t)v315._object;
          uint64_t v73 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
          if ((v74 & 1) != 0) {
            goto LABEL_284;
          }
          if (v70 <= 15 && ((v72 & 0x2000000000000000LL) != 0 || v73 < v69)) {
            goto LABEL_88;
          }
LABEL_84:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v70, v69);
          swift_bridgeObjectRelease_n((uint64_t)v58._object, 4LL);
          if (((uint64_t)v58._object & 0x1000000000000000LL) == 0)
          {
            if (v63)
            {
              swift_bridgeObjectRelease_n((uint64_t)v58._object, 2LL);
              *(void *)&uint64_t v314 = v58._countAndFlagsBits;
              *((void *)&v314 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = (uint64_t)v58._object & 0xFFFFFFFFFFFFFFLL;
              uint64_t v75 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v58._object >> 56) & 0xF,  (uint64_t)&v314,  ((unint64_t)v58._object >> 56) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v75, v76, ((uint64_t)v58._object & 0x4000000000000000LL) != 0);
              uint64_t v77 = v58._object;
              goto LABEL_92;
            }

            if ((v58._countAndFlagsBits & 0x1000000000000000LL) == 0) {
              goto LABEL_279;
            }
            swift_bridgeObjectRelease((uint64_t)v58._object);
            int v116 = (id)(((uint64_t)v58._object & 0xFFFFFFFFFFFFFFFLL) + 32);
            unsigned int v117 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            goto LABEL_109;
          }

          swift_bridgeObjectRelease((uint64_t)v58._object);
          _StringGuts._foreignAppendInPlace(_:)(v58._countAndFlagsBits, (unint64_t)v58._object, 0LL, v66);
          swift_bridgeObjectRelease_n((uint64_t)v58._object, 2LL);
          a1 = v313;
        }

        else
        {
          if (v70 > 15) {
            goto LABEL_84;
          }
LABEL_88:
          swift_bridgeObjectRelease_n((uint64_t)v58._object, 5LL);
          uint64_t v78 = v315._countAndFlagsBits;
          char v79 = v315._object;
          swift_bridgeObjectRetain((unint64_t)v315._object, v80, v81, v82);
          __int128 v83 = _StringGuts._convertedToSmall()(v78, (unint64_t)v79);
          BOOL v85 = v84;
          swift_bridgeObjectRelease((uint64_t)v79);
          v86._Swift::UInt64 rawBits = (v66 << 16) | 1;
          v87._Swift::UInt64 rawBits = 1LL;
          v88._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v87,  v86,  v58._countAndFlagsBits,  (unint64_t)v58._object);
          if (v88._rawBits < 0x10000) {
            v88._rawBits |= 3;
          }
          Swift::String::Index v90 = specialized String.init(_:)(v88, v89, v58._countAndFlagsBits, (unint64_t)v58._object);
          uint64_t v92 = v91;
          swift_bridgeObjectRelease((uint64_t)v58._object);
          __int128 v93 = _StringGuts._convertedToSmall()(v90, v92);
          uint64_t v95 = v94;
          swift_bridgeObjectRelease(v92);
          unint64_t v96 = specialized _SmallString.init(_:appending:)(v83, v85, v93, v95);
          if ((v98 & 1) != 0) {
            goto LABEL_283;
          }
          unint64_t v99 = v96;
          unint64_t v100 = v97;
          swift_bridgeObjectRelease((uint64_t)v58._object);
          uint64_t v77 = v315._object;
          v315._uint64_t countAndFlagsBits = v99;
          v315._unint64_t object = v100;
LABEL_92:
          swift_bridgeObjectRelease((uint64_t)v77);
          a1 = v313;
        }
      }
    }

    else
    {
      unsigned int v315 = v58;
      swift_bridgeObjectRelease(v60);
    }
  }

  v315._uint64_t countAndFlagsBits = 46LL;
  v315._unint64_t object = (void *)0xE100000000000000LL;
  int8x16_t v239 = object;
LABEL_217:
  swift_bridgeObjectRelease(v239);
LABEL_218:
  int8x16_t v263 = _uint64ToString(_:radix:uppercase:)(a1, 10LL, 0);
  int64x2_t v265 = v315._countAndFlagsBits;
  unint64_t v264 = (unint64_t)v315._object;
  int8x16_t v266 = ((unint64_t)v315._object >> 56) & 0xF;
  int8x16_t v267 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v267 && (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000LL) == 0)
  {
    unsigned int v315 = v263;
    uint16x8_t v269 = v264;
    goto LABEL_228;
  }

  if (((uint64_t)v315._object & 0x2000000000000000LL) == 0)
  {
    if (((uint64_t)v263._object & 0x2000000000000000LL) != 0)
    {
      uint8x8_t v268 = ((unint64_t)v263._object >> 56) & 0xF;
      goto LABEL_227;
    }

    LOBYTE(EquatableBaseType) = 0;
    if ((v34 & 1) == 0) {
      return EquatableBaseType & 1;
    }
    __int128 v45 = v34 & 0xFFFFFFFFFFFFFFFELL;
    if (!v45) {
      return EquatableBaseType & 1;
    }
    EquatableBaseType = SwiftValueHeader::getEquatableBaseType((SwiftValueHeader *)&self[1]);
    if (!EquatableBaseType) {
      return EquatableBaseType & 1;
    }
    int64_t v46 = EquatableBaseType;
    if (EquatableBaseType == SwiftValueHeader::getEquatableBaseType((SwiftValueHeader *)((char *)a3 + 8)))
    {
      unint64_t v47 = (uint64_t)self[1].super.isa[-1].isa[10].isa & 0xF8;
      int64_t v48 = (char *)self + ((unsigned __int16)(v47 + 39) & (unsigned __int16)~v47 & 0x1F8);
      uint64_t v49 = *(_DWORD *)(*(void *)(*((void *)a3 + 1) - 8LL) + 80LL) & 0xF8;
      LOBYTE(EquatableBaseType) = _swift_stdlib_Equatable_isEqual_indirect( (uint64_t)v48,  (uint64_t)a3 + ((unsigned __int16)(v49 + 39) & (unsigned __int16)~(_WORD)v49 & 0x1F8),  v46,  v45);
      return EquatableBaseType & 1;
    }

    goto LABEL_82;
  }

  unint64_t v38 = (uint64_t)self[1].super.isa[-1].isa[10].isa & 0xF8;
  int64_t v39 = (char *)self + ((unsigned __int16)(v38 + 39) & (unsigned __int16)~v38 & 0x1F8);
  unint64_t v40 = *(_DWORD *)(*(void *)(*((void *)a3 + 1) - 8LL) + 80LL) & 0xF8;
  LOBYTE(EquatableBaseType) = _swift_stdlib_Hashable_isEqual_indirect( (uint64_t)v39,  (uint64_t)a3 + ((unsigned __int16)(v40 + 39) & (unsigned __int16)~(_WORD)v40 & 0x1F8),  v17,  v7);
  return EquatableBaseType & 1;
}

      uint64_t v54 = *(unsigned __int8 *)(v26 + 18);
      if (v54 == 5 && *(_DWORD *)(v26 + 8))
      {
        uint64_t v26 = *(void *)v26;
LABEL_82:
        uint64_t v55 = *(swift::Demangle::__runtime::Node **)v26;
      }

      else
      {
        uint64_t v55 = 0LL;
      }

      uint64_t v56 = a4 + 1;
      if (*(_DWORD *)a6) {
        return this;
      }
      unint64_t v57 = *a3;
      int64_t v58 = *(_DWORD *)(v13 + 12736);
      int64_t v59 = *(unsigned int *)(v13 + 12740);
      unint64_t v60 = *(char **)(v13 + 12728);
      unint64_t v61 = *(void **)(v13 + 12744);
      int64_t v62 = (char *)v61[1];
      if (&v60[v59] == v62)
      {
        uint64_t v71 = (unint64_t)&v60[v59 + 1];
        unint64_t v63 = v61[2];
        if (v71 <= v63)
        {
          v61[1] = v71;
          uint64_t v77 = 1;
          goto LABEL_124;
        }
      }

      else
      {
        unint64_t v63 = v61[2];
      }

      Swift::String::Index v102 = *a3;
      LODWORD(v72) = 2 * v59;
      else {
        uint64_t v72 = v72;
      }
      unint64_t v99 = v72;
      uint64_t v73 = v72 + v59;
      if (!v62 || (unint64_t)&v62[v73] > v63)
      {
        uint64_t v74 = 2LL * v61[4];
        if (v74 <= v73 + 1) {
          uint64_t v74 = v73 + 1;
        }
        v61[4] = v74;
        uint64_t v75 = v74 + 8;
        this = (unsigned int *)malloc(v74 + 8);
        uint64_t v76 = (char *)this + v75;
        *(void *)this = v61[3];
        int64_t v62 = (char *)(this + 2);
        v61[2] = v76;
        v61[3] = this;
      }

      v61[1] = &v62[v73];
      if ((_DWORD)v59)
      {
        this = (unsigned int *)memcpy(v62, *(const void **)(v13 + 12728), v59);
        LODWORD(v59) = *(_DWORD *)(v13 + 12740);
        int64_t v58 = *(_DWORD *)(v13 + 12736);
      }

      unint64_t v57 = v102;
      uint64_t v77 = v99;
      *(void *)(v13 + 12728) = v62;
      unint64_t v60 = v62;
LABEL_124:
      *(_DWORD *)(v13 + 1274_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 0) = v59 + v77;
LABEL_125:
      *(_DWORD *)(v13 + 127++*(_DWORD *)(v0 + 36) = v58 + 1;
      v60[v58] = v57;
      *a3 = 95;
      uint64_t v78 = *((unsigned __int8 *)v12 + 18);
      if (v78 == 2) {
        goto LABEL_129;
      }
      if (v78 == 5 && *((_DWORD *)v12 + 2) >= 2u)
      {
        uint64_t v12 = *(swift::Demangle::__runtime::Node **)v12;
LABEL_129:
        char v79 = *((void *)v12 + 1);
      }

      else
      {
        char v79 = 0LL;
      }

      uint64_t v80 = *(unsigned __int8 *)(v79 + 18);
      uint64_t v81 = (swift::Demangle::__runtime::Node **)v79;
      if (v80 == 5)
      {
        __int128 v82 = *(swift::Demangle::__runtime::Node **)v79;
        uint64_t v81 = *(swift::Demangle::__runtime::Node ***)v79;
LABEL_139:
        __int128 v83 = (swift::Demangle::__runtime::Node **)((char *)v82 + 8 * *(unsigned int *)(v79 + 8));
        goto LABEL_143;
      }

      uint64_t v81 = 0LL;
LABEL_135:
      switch(v80)
      {
        case 1:
          __int128 v83 = (swift::Demangle::__runtime::Node **)(v79 + 8);
          break;
        case 2:
          __int128 v83 = (swift::Demangle::__runtime::Node **)(v79 + 16);
          break;
        case 5:
          __int128 v82 = *(swift::Demangle::__runtime::Node **)v79;
          goto LABEL_139;
        default:
          __int128 v83 = 0LL;
          break;
      }

  *((_DWORD *)this + 3184) = v35 + 1;
  v37[v35] = v34;
  if (*(_DWORD *)a4) {
    return result;
  }
  char v31 = (swift::Demangle::__runtime::Node **)((char *)v9 + 8);
LABEL_80:
  uint64_t v51 = *((_DWORD *)this + 3184);
  uint64_t v52 = *((unsigned int *)this + 3185);
  char v53 = this[1591];
  uint64_t v54 = this[1593];
  uint64_t v55 = (char *)*((void *)v54 + 1);
  if (&v53[v52] != v55)
  {
    uint64_t v56 = *((void *)v54 + 2);
LABEL_84:
    else {
      int64_t v58 = (2 * v52);
    }
    int64_t v59 = v58 + v52;
    if (!v55 || (unint64_t)&v55[v59] > v56)
    {
      unint64_t v60 = 2LL * *((void *)v54 + 4);
      if (v60 <= v59 + 1) {
        unint64_t v60 = v59 + 1;
      }
      *((void *)v54 + 4) = v60;
      unint64_t v61 = v60 + 8;
      uint64_t result = (uint64_t)malloc(v60 + 8);
      int64_t v62 = result + v61;
      *(void *)uint64_t result = *((void *)v54 + 3);
      uint64_t v55 = (char *)(result + 8);
      *((void *)v54 + 2) = v62;
      *((void *)v54 + 3) = result;
    }

    *((void *)v54 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = &v55[v59];
    if ((_DWORD)v52)
    {
      uint64_t result = (uint64_t)memcpy(v55, this[1591], v52);
      LODWORD(v52) = *((_DWORD *)this + 3185);
      uint64_t v51 = *((_DWORD *)this + 3184);
    }

    char *v129 = v55;
    char v53 = v55;
    goto LABEL_95;
  }

  unint64_t v57 = (unint64_t)&v53[v52 + 1];
  uint64_t v56 = *((void *)v54 + 2);
  if (v57 > v56) {
    goto LABEL_84;
  }
  *((void *)v54 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v57;
  LODWORD(v58) = 1;
LABEL_95:
  *((_DWORD *)this + 3185) = v52 + v58;
LABEL_96:
  *((_DWORD *)this + 3184) = v51 + 1;
  v53[v51] = 95;
  unint64_t v63 = v11;
  if (v31 == v11) {
    goto LABEL_110;
  }
LABEL_97:
  int64_t v64 = *v31;
  uint64_t v65 = (swift::Demangle::__runtime::Node *)((char *)*v31 + 16);
  if (*(_WORD *)v65 != 118)
  {
    unint64_t v63 = v31;
LABEL_110:
    uint64_t v68 = *((_DWORD *)this + 3184);
    uint64_t v69 = *((unsigned int *)this + 3185);
    uint64_t v70 = this[1591];
    uint64_t v71 = this[1593];
    uint64_t v72 = (char *)*((void *)v71 + 1);
    if (&v70[v69] == v72)
    {
      uint64_t v74 = (unint64_t)&v70[v69 + 1];
      uint64_t v73 = *((void *)v71 + 2);
      if (v74 <= v73)
      {
        *((void *)v71 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v74;
        LODWORD(v75) = 1;
LABEL_128:
        *((_DWORD *)this + 3185) = v69 + v75;
LABEL_129:
        *((_DWORD *)this + 3184) = v68 + 1;
        for (v70[v68] = 95; v63 != v11; ++v63)
        {
          if (*(_DWORD *)a4) {
            return result;
          }
        }

        *(_DWORD *)a4 = 0;
        *(void *)(a4 + 8) = 0LL;
        *(_DWORD *)(a4 + 16) = 0;
        uint64_t v81 = *((_DWORD *)this + 3184);
        __int128 v82 = *((unsigned int *)this + 3185);
        __int128 v83 = this[1591];
        if (v81 < v82)
        {
LABEL_151:
          *((_DWORD *)this + 3184) = v81 + 1;
          v83[v81] = 95;
          *(_DWORD *)a4 = 0;
          *(void *)(a4 + 8) = 0LL;
          *(_DWORD *)(a4 + 16) = 0;
          return result;
        }

        uint64_t v84 = this[1593];
        BOOL v85 = (char *)*((void *)v84 + 1);
        if (&v83[v82] == v85)
        {
          unint64_t v87 = (unint64_t)&v83[v82 + 1];
          uint64_t v86 = *((void *)v84 + 2);
          if (v87 <= v86)
          {
            *((void *)v84 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v87;
            LODWORD(v88) = 1;
LABEL_150:
            *((_DWORD *)this + 3185) = v82 + v88;
            goto LABEL_151;
          }
        }

        else
        {
          uint64_t v86 = *((void *)v84 + 2);
        }

        else {
          unint64_t v88 = (2 * v82);
        }
        unint64_t v89 = v88 + v82;
        if (v85) {
          Swift::String::Index v90 = (unint64_t)&v85[v88 + v82] > v86;
        }
        else {
          Swift::String::Index v90 = 1;
        }
        __int128 v83 = (char *)*((void *)v84 + 1);
        if (v90)
        {
          uint64_t v91 = 2LL * *((void *)v84 + 4);
          if (v91 <= v89 + 1) {
            uint64_t v91 = v89 + 1;
          }
          *((void *)v84 + 4) = v91;
          uint64_t v92 = v91 + 8;
          uint64_t result = (uint64_t)malloc(v91 + 8);
          __int128 v93 = result + v92;
          *(void *)uint64_t result = *((void *)v84 + 3);
          __int128 v83 = (char *)(result + 8);
          *((void *)v84 + 2) = v93;
          *((void *)v84 + 3) = result;
        }

        *((void *)v84 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = &v83[v89];
        if ((_DWORD)v82)
        {
          uint64_t result = (uint64_t)memcpy(v83, this[1591], v82);
          LODWORD(v82) = *((_DWORD *)this + 3185);
          uint64_t v81 = *((_DWORD *)this + 3184);
        }

        char *v129 = v83;
        goto LABEL_150;
      }
    }

    else
    {
      uint64_t v73 = *((void *)v71 + 2);
    }

    else {
      uint64_t v75 = (2 * v69);
    }
    uint64_t v76 = v75 + v69;
    if (v72) {
      uint64_t v77 = (unint64_t)&v72[v75 + v69] > v73;
    }
    else {
      uint64_t v77 = 1;
    }
    uint64_t v70 = (char *)*((void *)v71 + 1);
    if (v77)
    {
      uint64_t v78 = 2LL * *((void *)v71 + 4);
      if (v78 <= v76 + 1) {
        uint64_t v78 = v76 + 1;
      }
      *((void *)v71 + 4) = v78;
      char v79 = v78 + 8;
      uint64_t result = (uint64_t)malloc(v78 + 8);
      uint64_t v80 = result + v79;
      *(void *)uint64_t result = *((void *)v71 + 3);
      uint64_t v70 = (char *)(result + 8);
      *((void *)v71 + 2) = v80;
      *((void *)v71 + 3) = result;
    }

    *((void *)v71 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = &v70[v76];
    if ((_DWORD)v69)
    {
      uint64_t result = (uint64_t)memcpy(v70, this[1591], v69);
      LODWORD(v69) = *((_DWORD *)this + 3185);
      uint64_t v68 = *((_DWORD *)this + 3184);
    }

    char *v129 = v70;
    goto LABEL_128;
  }

  uint64_t v66 = *((unsigned __int8 *)v64 + 18);
  if (v66 == 2) {
    goto LABEL_102;
  }
  if (v66 == 5 && *((_DWORD *)v64 + 2) == 2)
  {
    int64_t v64 = *(swift::Demangle::__runtime::Node **)v64;
    uint64_t v65 = (swift::Demangle::__runtime::Node *)((char *)v64 + 16);
LABEL_102:
    while (1)
    {
      if (*(_DWORD *)a4) {
        break;
      }
      int64_t v64 = (swift::Demangle::__runtime::Node *)((char *)v64 + 8);
      if (v64 == v65)
      {
        *(_DWORD *)a4 = 0;
        *(void *)(a4 + 8) = 0LL;
        *(_DWORD *)(a4 + 16) = 0;
        if (++v31 != v11) {
          goto LABEL_97;
        }
        unint64_t v63 = v11;
        goto LABEL_110;
      }
    }
  }

  else
  {
    *(_DWORD *)a4 = 1;
    *(void *)(a4 + 8) = v64;
    *(_DWORD *)(a4 + 16) = 1712;
  }

  return result;
}

uint64_t _NativeSet.insertNew(_:at:isUnique:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v32 = *(void *)(v7 - 8);
  uint64_t v33 = a1;
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v11 = *(void *)(*v4 + 16);
  unint64_t v12 = *(void *)(*v4 + 24);
  __int128 v30 = v4;
  if (v12 <= v11 || (v8 & 1) == 0)
  {
    Swift::Int v13 = v11 + 1;
    if ((v8 & 1) != 0)
    {
      _NativeSet.resize(capacity:)(v13);
    }

    else
    {
      if (v12 > v11)
      {
        _NativeSet.copy()();
        goto LABEL_12;
      }

      _NativeSet.copyAndResize(capacity:)(v13);
    }

    uint64_t v14 = *v4;
    uint64_t v15 = *(void *)(a4 + 24);
    uint64_t v16 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v15 + 32))(*(void *)(*v4 + 40), v7, v15);
    uint64_t v17 = -1LL << *(_BYTE *)(v14 + 32);
    a2 = v16 & ~v17;
    uint64_t v31 = v14;
    uint64_t v18 = v14 + 56;
    if (((*(void *)(v14 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
    {
      uint64_t v19 = ~v17;
      uint64_t v20 = *(void *)(v15 + 8);
      unint64_t v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v20 + 8);
      uint64_t v22 = *(void *)(v32 + 72);
      int64_t v23 = *(void (**)(char *, unint64_t, uint64_t))(v32 + 16);
      while (1)
      {
        v23(v10, *(void *)(v31 + 48) + v22 * a2, v7);
        char v24 = v21(v10, v33, v7, v20);
        (*(void (**)(char *, uint64_t))(v32 + 8))(v10, v7);
        if ((v24 & 1) != 0) {
          break;
        }
        a2 = (a2 + 1) & v19;
        if (((*(void *)(v18 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) == 0) {
          goto LABEL_12;
        }
      }

double specialized _NativeSet.update(with:isUnique:)@<D0>(__int128 *a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *v3;
  uint64_t v6 = *(void *)(*v3 + 40);
  uint64_t v7 = *((void *)a1 + 3);
  uint64_t v8 = *((void *)a1 + 4);
  __swift_project_boxed_opaque_existential_0Tm(a1, v7);
  (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v8 + 8))(&v123, v7, v8);
  uint64_t v9 = *((void *)&v124 + 1);
  uint64_t v10 = v125;
  __swift_project_boxed_opaque_existential_0Tm(&v123, *((uint64_t *)&v124 + 1));
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 40))(v6, v9, v10);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v123);
  uint64_t v12 = -1LL << *(_BYTE *)(v5 + 32);
  unint64_t v13 = v11 & ~v12;
  if (((*(void *)(v5 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) != 0)
  {
    char v114 = a2;
    uint64_t v14 = ~v12;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v13, (uint64_t)&v123);
      uint64_t v15 = *((void *)&v124 + 1);
      uint64_t v16 = v125;
      __swift_project_boxed_opaque_existential_0Tm(&v123, *((uint64_t *)&v124 + 1));
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v16 + 8))(v120, v15, v16);
      uint64_t v17 = v121;
      uint64_t v18 = v122;
      __swift_project_boxed_opaque_existential_0Tm(v120, v121);
      uint64_t v19 = *((void *)a1 + 3);
      uint64_t v20 = *((void *)a1 + 4);
      __swift_project_boxed_opaque_existential_0Tm(a1, v19);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v119, v19, v20);
      char v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v18 + 16))(v119, v17, v18);
      __swift_destroy_boxed_opaque_existential_1Tm(v119);
      if (v21 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v120);
        outlined destroy of AnyHashable((uint64_t *)&v123);
      }

      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v120);
        outlined destroy of AnyHashable((uint64_t *)&v123);
        if ((v21 & 1) != 0)
        {
          int v22 = 1;
          a2 = v114;
          goto LABEL_10;
        }
      }

      unint64_t v13 = (v13 + 1) & v14;
    }

    while (((*(void *)(v5 + 56 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v13) & 1) != 0);
    int v22 = 0;
    a2 = v114;
  }

  else
  {
    int v22 = 0;
  }

uint64_t _NativeSet.update(with:isUnique:)@<X0>( uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  LODWORD(v57) = a2;
  uint64_t v55 = a4;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)v53 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v56 = v4;
  uint64_t v9 = *v4;
  uint64_t v10 = *(void *)(*v4 + 40);
  v53[1] = v11;
  uint64_t v12 = *(void *)(v11 + 24);
  unint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 32);
  uint64_t v60 = v14;
  v53[0] = v13;
  uint64_t v15 = v13(v10, v5, v12);
  uint64_t v16 = -1LL << *(_BYTE *)(v9 + 32);
  unint64_t v17 = v15 & ~v16;
  uint64_t v59 = v9;
  uint64_t v18 = v9 + 56;
  uint64_t v19 = *(void *)(v9 + 56 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17;
  uint64_t v61 = v6;
  uint64_t v54 = v12;
  if ((v19 & 1) != 0)
  {
    uint64_t v58 = ~v16;
    uint64_t v20 = *(void *)(v12 + 8);
    char v21 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v20 + 8);
    uint64_t v22 = *(void *)(v6 + 72);
    uint64_t v23 = *(void (**)(char *, unint64_t, uint64_t))(v6 + 16);
    do
    {
      v23(v8, *(void *)(v59 + 48) + v22 * v17, v5);
      char v24 = v21(v8, v60, v5, v20);
      (*(void (**)(char *, uint64_t))(v61 + 8))(v8, v5);
      if ((v24 & 1) != 0) {
        break;
      }
      unint64_t v17 = (v17 + 1) & v58;
    }

    while (((*(void *)(v18 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) != 0);
  }

  else
  {
    char v24 = 0;
  }

  uint64_t v25 = v56;
  uint64_t v26 = *(void *)(*v56 + 16);
  BOOL v27 = (v24 & 1) == 0;
  Swift::Int v28 = v26 + v27;
  if (__OFADD__(v26, v27))
  {
    __break(1u);
    goto LABEL_30;
  }

  Swift::Int v29 = *(void *)(*v56 + 24);
  if (v29 >= v28 && (v57 & 1) != 0)
  {
    if ((v24 & 1) != 0)
    {
LABEL_11:
      unint64_t v30 = *(void *)(v61 + 72) * v17;
LABEL_27:
      uint64_t v49 = *v25;
      unint64_t v50 = *(void *)(*v25 + 48) + v30;
      uint64_t v43 = v61;
      uint64_t v51 = *(void (**)(uint64_t, unint64_t, uint64_t))(v61 + 32);
      uint64_t v48 = v55;
      v51(v55, v50, v5);
      v51(*(void *)(v49 + 48) + v30, v60, v5);
      uint64_t v47 = 0LL;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v43 + 56))(v48, v47, 1LL, v5);
    }

uint64_t _NativeSet._unsafeUpdate(with:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v28 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::Int v29 = v2;
  uint64_t v7 = *v2;
  uint64_t v8 = *(void *)(*v2 + 40);
  uint64_t v10 = *(void *)(v9 + 24);
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v10 + 32);
  uint64_t v33 = v12;
  uint64_t v13 = v11(v8, v3, v10);
  uint64_t v14 = -1LL << *(_BYTE *)(v7 + 32);
  unint64_t v15 = v13 & ~v14;
  uint64_t v30 = v7 + 56;
  uint64_t v31 = v7;
  uint64_t v16 = *(void *)(v7 + 56 + ((v15 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v15;
  uint64_t v32 = v4;
  if ((v16 & 1) != 0)
  {
    uint64_t v17 = ~v14;
    uint64_t v18 = *(void *)(v10 + 8);
    uint64_t v19 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v18 + 8);
    uint64_t v20 = *(void *)(v4 + 72);
    char v21 = *(void (**)(char *, unint64_t, uint64_t))(v4 + 16);
    while (1)
    {
      v21(v6, *(void *)(v31 + 48) + v20 * v15, v3);
      char v22 = v19(v6, v33, v3, v18);
      (*(void (**)(char *, uint64_t))(v32 + 8))(v6, v3);
      if ((v22 & 1) != 0) {
        return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v32 + 40))( *(void *)(*v29 + 48) + v20 * v15,  v33,  v3);
      }
      unint64_t v15 = (v15 + 1) & v17;
      if (((*(void *)(v30 + ((v15 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v15) & 1) == 0) {
        goto LABEL_5;
      }
    }
  }

  else
  {
LABEL_5:
    uint64_t v23 = *v29;
    if (*(void *)(*v29 + 16) >= *(void *)(*v29 + 24)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  0x1DFuLL,  0);
    }
    *(void *)(v23 + ((v15 >> 3) & 0xFFFFFFFFFFFFFF8LL) + 56) |= 1LL << v15;
    uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v32 + 32))( *(void *)(v23 + 48) + *(void *)(v32 + 72) * v15,  v33,  v3);
    uint64_t v25 = *(void *)(v23 + 16);
    BOOL v26 = __OFADD__(v25, 1LL);
    uint64_t v27 = v25 + 1;
    if (v26) {
      __break(1u);
    }
    else {
      *(void *)(v23 + 16) = v27;
    }
  }

  return result;
}

uint64_t _NativeSet.isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1;
  uint64_t v49 = *(void *)(a3 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v39 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v50 = (char *)&v39 - v12;
  uint64_t result = MEMORY[0x1895F8858](v11);
  unint64_t v15 = (char *)&v39 - v14;
  if (v16 == result) {
    return 1LL;
  }
  if (*(void *)(a2 + 16) != *(void *)(v7 + 16)) {
    return 0LL;
  }
  int64_t v17 = 0LL;
  uint64_t v18 = *(void *)(a2 + 56);
  uint64_t v40 = a2 + 56;
  uint64_t v19 = 1LL << *(_BYTE *)(a2 + 32);
  if (v19 < 64) {
    uint64_t v20 = ~(-1LL << v19);
  }
  else {
    uint64_t v20 = -1LL;
  }
  unint64_t v21 = v20 & v18;
  int64_t v22 = (unint64_t)(v19 + 63) >> 6;
  uint64_t v48 = v7 + 56;
  int64_t v41 = v22;
  uint64_t v42 = (char *)&v39 - v14;
  uint64_t v43 = a2;
  uint64_t v44 = a4;
  if (!v21) {
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v46 = (v21 - 1) & v21;
  for (unint64_t i = __clz(__rbit64(v21)) | (v17 << 6); ; unint64_t i = __clz(__rbit64(v25)) + (v17 << 6))
  {
    uint64_t v27 = *(void *)(a2 + 48);
    uint64_t v28 = v49;
    uint64_t v47 = *(void *)(v49 + 72);
    Swift::Int v29 = *(void (**)(char *, unint64_t, uint64_t))(v49 + 16);
    v29(v15, v27 + v47 * i, a3);
    (*(void (**)(char *, char *, uint64_t))(v28 + 32))(v50, v15, a3);
    uint64_t v30 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a4 + 32))(*(void *)(v7 + 40), a3, a4);
    uint64_t v31 = -1LL << *(_BYTE *)(v7 + 32);
    unint64_t v32 = v30 & ~v31;
    if (((*(void *)(v48 + ((v32 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v32) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t))(v49 + 8))(v50, a3);
      return 0LL;
    }

    int64_t v45 = v17;
    uint64_t v33 = v7;
    uint64_t v34 = ~v31;
    uint64_t v35 = *(void *)(a4 + 8);
    uint64_t v36 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v35 + 8);
    while (1)
    {
      v29(v10, *(void *)(v33 + 48) + v32 * v47, a3);
      char v37 = v36(v10, v50, a3, v35);
      uint64_t v38 = *(void (**)(char *, uint64_t))(v49 + 8);
      v38(v10, a3);
      if ((v37 & 1) != 0) {
        break;
      }
      unint64_t v32 = (v32 + 1) & v34;
      if (((*(void *)(v48 + ((v32 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v32) & 1) == 0)
      {
        v38(v50, a3);
        return 0LL;
      }
    }

    uint64_t result = ((uint64_t (*)(char *, uint64_t))v38)(v50, a3);
    a2 = v43;
    a4 = v44;
    uint64_t v7 = v33;
    int64_t v22 = v41;
    unint64_t v15 = v42;
    int64_t v17 = v45;
    unint64_t v21 = v46;
    if (v46) {
      goto LABEL_7;
    }
LABEL_9:
    if (__OFADD__(v17++, 1LL)) {
      break;
    }
    if (v17 >= v22) {
      return 1LL;
    }
    unint64_t v25 = *(void *)(v40 + 8 * v17);
    if (!v25)
    {
      int64_t v26 = v17 + 1;
      if (v17 + 1 >= v22) {
        return 1LL;
      }
      unint64_t v25 = *(void *)(v40 + 8 * v26);
      if (!v25)
      {
        while (1)
        {
          int64_t v17 = v26 + 1;
          if (__OFADD__(v26, 1LL)) {
            break;
          }
          if (v17 >= v22) {
            return 1LL;
          }
          unint64_t v25 = *(void *)(v40 + 8 * v17);
          ++v26;
          if (v25) {
            goto LABEL_18;
          }
        }

        __break(1u);
        break;
      }

      ++v17;
    }

uint64_t _NativeSet.makeIterator()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1LL;
  uint64_t v3 = -1LL << *(_BYTE *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t result = a1 + 56;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1LL << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0LL;
  a2[4] = v2 & v5;
  return result;
}

uint64_t _NativeSet.Iterator.next()@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (v4)
  {
    v2[4] = (v4 - 1) & v4;
    unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
    uint64_t v6 = *(void *)(*v2 + 48LL);
    uint64_t v7 = *(void *)(result + 16);
    uint64_t v8 = *(void *)(v7 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v8 + 16))(a2, v6 + *(void *)(v8 + 72) * v5, v7);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v10 = a2;
    uint64_t v11 = 0LL;
    uint64_t v12 = v7;
    return v9(v10, v11, 1LL, v12);
  }

  uint64_t v13 = v2[3];
  int64_t v14 = v13 + 1;
  if (!__OFADD__(v13, 1LL))
  {
    int64_t v15 = (unint64_t)(v2[2] + 64LL) >> 6;
    if (v14 < v15)
    {
      v2[3] = v14;
      uint64_t v16 = v2[1];
      unint64_t v17 = *(void *)(v16 + 8 * v14);
      v2[4] = v17;
      if (v17)
      {
LABEL_11:
        v2[4] = (v17 - 1) & v17;
        unint64_t v5 = __clz(__rbit64(v17)) + (v14 << 6);
        goto LABEL_3;
      }

      uint64_t v18 = v13 + 2;
      while (v15 != v18)
      {
        v2[3] = v18;
        unint64_t v17 = *(void *)(v16 + 8 * v18);
        v2[4] = v17;
        ++v18;
        if (v17)
        {
          int64_t v14 = v18 - 1;
          goto LABEL_11;
        }
      }
    }

    uint64_t v12 = *(void *)(result + 16);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56LL);
    uint64_t v10 = a2;
    uint64_t v11 = 1LL;
    return v9(v10, v11, 1LL, v12);
  }

  __break(1u);
  return result;
}

void _NativeSet.isEqual(to:)(void *a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v5 = a1;
  uint64_t v6 = *(a3 - 1);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (void *)MEMORY[0x1895F8858](v8);
  uint64_t v11 = (id *)((char *)&v33 - v10);
  id v13 = *(id *)(v12 + 16);
  if (v13 == objc_msgSend(v9, sel_count))
  {
    uint64_t v34 = (id *)((char *)&v33 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    uint64_t v35 = v7;
    int64_t v14 = 0LL;
    uint64_t v15 = a2 + 56;
    uint64_t v16 = 1LL << *(_BYTE *)(a2 + 32);
    uint64_t v17 = -1LL;
    if (v16 < 64) {
      uint64_t v17 = ~(-1LL << v16);
    }
    unint64_t v18 = v17 & *(void *)(a2 + 56);
    int64_t v19 = (unint64_t)(v16 + 63) >> 6;
    uint64_t v36 = a2;
    if (!v18) {
      goto LABEL_6;
    }
LABEL_5:
    unint64_t v20 = __clz(__rbit64(v18));
    v18 &= v18 - 1;
    for (unint64_t i = v20 | (v14 << 6); ; unint64_t i = __clz(__rbit64(v23)) + (v14 << 6))
    {
      (*(void (**)(id *, unint64_t, uint64_t *))(v6 + 16))( v11,  *(void *)(a2 + 48) + *(void *)(v6 + 72) * i,  a3);
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
      {
        if (v7 != 8) {
          goto LABEL_23;
        }
        uint64_t v27 = *v11;
        swift_unknownObjectRetain(*v11, v24, v25, v26);
        (*(void (**)(id *, uint64_t *))(v6 + 8))(v11, a3);
      }

      else
      {
        uint64_t v30 = v34;
        (*(void (**)(id *, id *, uint64_t *))(v6 + 32))(v34, v11, a3);
        uint64_t v27 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v30, a3, v31, v32);
      }

      uint64_t v28 = v5;
      id v29 = objc_msgSend(v5, sel_member_, v27);
      swift_unknownObjectRelease(v27);
      if (!v29) {
        break;
      }
      swift_unknownObjectRelease(v29);
      unint64_t v5 = v28;
      uint64_t v7 = v35;
      a2 = v36;
      if (v18) {
        goto LABEL_5;
      }
LABEL_6:
      int64_t v22 = v14 + 1;
      if (__OFADD__(v14, 1LL))
      {
        __break(1u);
        return;
      }

      if (v22 >= v19) {
        return;
      }
      unint64_t v23 = *(void *)(v15 + 8 * v22);
      ++v14;
      if (!v23)
      {
        while (1)
        {
          int64_t v14 = v22 + 1;
          if (__OFADD__(v22, 1LL)) {
            break;
          }
          if (v14 >= v19) {
            return;
          }
          unint64_t v23 = *(void *)(v15 + 8 * v14);
          ++v22;
          if (v23) {
            goto LABEL_12;
          }
        }

        __break(1u);
LABEL_23:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

BOOL __CocoaSet.contains(_:)(uint64_t a1, void *a2)
{
  return __CocoaDictionary.contains(_:)(a1, a2, (SEL *)&selRef_member_);
}

BOOL __CocoaDictionary.contains(_:)(uint64_t a1, id a2, SEL *a3)
{
  id v3 = objc_msgSend(a2, *a3, a1);
  id v4 = v3;
  if (v3) {
    swift_unknownObjectRelease(v3);
  }
  return v4 != 0LL;
}

Swift::Int __swiftcall _NativeSet.hashValue(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  uint64_t v7 = *(void *)(v2 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](at.offset);
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v7 + 16))(v10, *(void *)(v11 + 48) + *(void *)(v7 + 72) * v8);
  Swift::Int v12 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v4 + 32))(*(void *)(v6 + 40), v5, v4);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v5);
  return v12;
}

Swift::Void __swiftcall _NativeSet.moveEntry(from:to:)(Swift::_HashTable::Bucket from, Swift::_HashTable::Bucket to)
{
  uint64_t v5 = *(void *)(v2 + 48);
  uint64_t v6 = *(void *)(*(void *)(v3 - 8) + 72LL);
  Swift::Int v7 = v6 * to.offset;
  uint64_t v8 = (char *)(v5 + v6 * to.offset);
  Swift::Int v9 = v6 * from.offset;
  uint64_t v10 = (char *)(v5 + v9);
  unint64_t v11 = v5 + v9 + v6;
  if (v7 < v9 || (unint64_t)v8 >= v11)
  {
    swift_arrayInitWithTakeFrontToBack(v8, v10, 1LL, v3);
  }

  else if (v7 != v9)
  {
    swift_arrayInitWithTakeBackToFront(v8, v10, 1LL, v3);
  }

uint64_t protocol witness for _HashTableDelegate.hashValue(at:) in conformance _NativeSet<A>( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *v2;
  (*(void (**)(char *, uint64_t, uint64_t))(v5 + 16))(v8, *(void *)(v9 + 48) + *(void *)(v5 + 72) * v6, v4);
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a2 + 24) + 32LL))(*(void *)(v9 + 40), v4);
  (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v4);
  return v10;
}

char *protocol witness for _HashTableDelegate.moveEntry(from:to:) in conformance _NativeSet<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)v3 + 48LL);
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(*(void *)(v6 - 8) + 72LL);
  uint64_t v8 = v7 * a2;
  uint64_t result = (char *)(v5 + v7 * a2);
  uint64_t v10 = v7 * a1;
  unint64_t v11 = (char *)(v5 + v10);
  unint64_t v12 = v5 + v10 + v7;
  if (v8 != v10) {
    return swift_arrayInitWithTakeBackToFront(result, v11, 1LL, v6);
  }
  return result;
}

unint64_t specialized _NativeSet._delete(at:)( unint64_t result, uint64_t a2, uint64_t a3, char *a4)
{
  v5.Swift::Int offset = result;
  uint64_t v6 = (uint64_t)*v4;
  uint64_t v7 = (uint64_t)(*v4 + 7);
  uint64_t v8 = -1LL << *((_BYTE *)*v4 + 32);
  unint64_t v9 = (result + 1) & ~v8;
  if (((1LL << v9) & *(void *)(v7 + 8 * (v9 >> 6))) != 0)
  {
    uint64_t v10 = ~v8;
    swift_retain(*v4, a2, a3, a4);
    v11.Swift::Int offset = _HashTable.previousHole(before:)(v5).offset;
    if ((*(void *)(v7 + 8 * (v9 >> 6)) & (1LL << v9)) != 0)
    {
      unint64_t v15 = (v11.offset + 1) & v10;
      do
      {
        uint64_t v16 = (unint64_t *)(*(void *)(v6 + 48) + 16 * v9);
        unint64_t v17 = *v16;
        unint64_t v18 = v16[1];
        uint64_t v19 = _swift_stdlib_Hashing_parameters ^ *(void *)(v6 + 40);
        v27[0] = 0LL;
        v27[1] = v19 ^ 0x736F6D6570736575LL;
        v27[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
        v27[3] = v19 ^ 0x6C7967656E657261LL;
        id v27[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
        __int128 v28 = 0u;
        __int128 v29 = 0u;
        swift_bridgeObjectRetain(v18, v12.offset, v13.offset, (char *)v14.offset);
        String.hash(into:)(v27, v17, v18);
        swift_bridgeObjectRelease(v18);
        unint64_t v20 = Hasher._finalize()() & v10;
        if (v5.offset >= (uint64_t)v15)
        {
          if (v20 < v15) {
            goto LABEL_5;
          }
        }

        else if (v20 >= v15)
        {
          goto LABEL_11;
        }

        if (v5.offset >= (uint64_t)v20)
        {
LABEL_11:
          uint64_t v21 = *(void *)(v6 + 48);
          int64_t v22 = (_OWORD *)(v21 + 16 * v5.offset);
          unint64_t v23 = (_OWORD *)(v21 + 16 * v9);
          if (v5.offset != v9 || (v5.Swift::Int offset = v9, v22 >= v23 + 1))
          {
            *int64_t v22 = *v23;
            v5.Swift::Int offset = v9;
          }
        }

{
  unint64_t **v4;
  Swift::_HashTable::Bucket v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  Swift::_HashTable::Bucket v11;
  Swift::_HashTable::Bucket v12;
  Swift::_HashTable::Bucket v13;
  Swift::_HashTable::Bucket v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  _OWORD *v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  unint64_t v27[5];
  __int128 v28;
  __int128 v29;
  v5.Swift::Int offset = result;
  uint64_t v6 = (uint64_t)*v4;
  uint64_t v7 = (uint64_t)(*v4 + 7);
  uint64_t v8 = -1LL << *((_BYTE *)*v4 + 32);
  unint64_t v9 = (result + 1) & ~v8;
  if (((1LL << v9) & *(void *)(v7 + 8 * (v9 >> 6))) != 0)
  {
    uint64_t v10 = ~v8;
    swift_retain(*v4, a2, a3, a4);
    v11.Swift::Int offset = _HashTable.previousHole(before:)(v5).offset;
    if ((*(void *)(v7 + 8 * (v9 >> 6)) & (1LL << v9)) != 0)
    {
      unint64_t v15 = (v11.offset + 1) & v10;
      do
      {
        uint64_t v16 = (unint64_t *)(*(void *)(v6 + 48) + 16 * v9);
        unint64_t v17 = *v16;
        unint64_t v18 = v16[1];
        uint64_t v19 = _swift_stdlib_Hashing_parameters ^ *(void *)(v6 + 40);
        v27[0] = 0LL;
        v27[1] = v19 ^ 0x736F6D6570736575LL;
        v27[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
        v27[3] = v19 ^ 0x6C7967656E657261LL;
        id v27[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
        __int128 v28 = 0u;
        __int128 v29 = 0u;
        swift_bridgeObjectRetain(v18, v12.offset, v13.offset, (char *)v14.offset);
        String.hash(into:)(v27, v17, v18);
        swift_bridgeObjectRelease(v18);
        unint64_t v20 = Hasher._finalize()() & v10;
        if (v5.offset >= (uint64_t)v15)
        {
          if (v20 < v15) {
            goto LABEL_5;
          }
        }

        else if (v20 >= v15)
        {
          goto LABEL_11;
        }

        if (v5.offset >= (uint64_t)v20)
        {
LABEL_11:
          uint64_t v21 = *(void *)(v6 + 48);
          int64_t v22 = (_OWORD *)(v21 + 16 * v5.offset);
          unint64_t v23 = (_OWORD *)(v21 + 16 * v9);
          if (v5.offset != v9 || (v5.Swift::Int offset = v9, v22 >= v23 + 1))
          {
            *int64_t v22 = *v23;
            v5.Swift::Int offset = v9;
          }
        }

{
  unint64_t **v4;
  Swift::_HashTable::Bucket v5;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  Swift::_HashTable::Bucket v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  Swift::Int v20;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  unint64_t *v28;
  unint64_t v29;
  BOOL v30;
  unint64_t v31;
  unint64_t **v32;
  uint64_t v33[3];
  uint64_t v34;
  uint64_t v35;
  uint64_t v36[3];
  uint64_t v37;
  uint64_t v38;
  v5.Swift::Int offset = result;
  uint64_t v6 = *v4;
  uint64_t v7 = (uint64_t)(*v4 + 7);
  uint64_t v8 = -1LL << *((_BYTE *)*v4 + 32);
  unint64_t v9 = (result + 1) & ~v8;
  if (((1LL << v9) & *(void *)(v7 + 8 * (v9 >> 6))) != 0)
  {
    unint64_t v32 = v4;
    uint64_t v10 = ~v8;
    swift_retain(v6, a2, a3, a4);
    v11.Swift::Int offset = _HashTable.previousHole(before:)(v5).offset;
    if ((*(void *)(v7 + 8 * (v9 >> 6)) & (1LL << v9)) != 0)
    {
      Swift::_HashTable::Bucket v12 = (v11.offset + 1) & v10;
      do
      {
        Swift::_HashTable::Bucket v13 = v7;
        outlined init with copy of AnyHashable(v6[6] + 40 * v9, (uint64_t)v36);
        Swift::_HashTable::Bucket v14 = v6[5];
        unint64_t v15 = v37;
        uint64_t v16 = v38;
        __swift_project_boxed_opaque_existential_0Tm(v36, v37);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v16 + 8))(v33, v15, v16);
        unint64_t v17 = v34;
        unint64_t v18 = v35;
        __swift_project_boxed_opaque_existential_0Tm(v33, v34);
        uint64_t v19 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v18 + 40))(v14, v17, v18);
        __swift_destroy_boxed_opaque_existential_1Tm(v33);
        outlined destroy of AnyHashable(v36);
        unint64_t v20 = v19 & v10;
        if (v5.offset >= (uint64_t)v12)
        {
          if (v20 >= v12 && v5.offset >= v20)
          {
LABEL_17:
            unint64_t v23 = v6[6];
            uint64_t v24 = v23 + 40 * v5.offset;
            BOOL v25 = v23 + 40 * v9;
            uint64_t v7 = v13;
            if (v5.offset != v9 || (v5.Swift::Int offset = v9, v24 >= v25 + 40))
            {
              uint64_t v26 = *(_OWORD *)v25;
              uint64_t v27 = *(_OWORD *)(v25 + 16);
              *(void *)(v24 + 32) = *(void *)(v25 + 32);
              *(_OWORD *)uint64_t v24 = v26;
              *(_OWORD *)(v24 + 16) = v27;
              v5.Swift::Int offset = v9;
            }

            goto LABEL_5;
          }
        }

        else if (v20 >= v12 || v5.offset >= v20)
        {
          goto LABEL_17;
        }

        uint64_t v7 = v13;
LABEL_5:
        unint64_t v9 = (v9 + 1) & v10;
      }

      while (((*(void *)(v7 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) != 0);
    }

    *(void *)(v7 + (((unint64_t)v5.offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << SLOBYTE(v5.offset)) - 1;
    uint64_t result = swift_release((uint64_t)v6);
    uint64_t v4 = v32;
  }

  else
  {
    *(void *)(v7 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << result) - 1;
  }

  __int128 v28 = *v4;
  __int128 v29 = (*v4)[2];
  uint64_t v30 = __OFSUB__(v29, 1LL);
  uint64_t v31 = v29 - 1;
  if (v30)
  {
    __break(1u);
  }

  else
  {
    v28[2] = v31;
    ++*((_DWORD *)v28 + 9);
  }

  return result;
}

{
  unint64_t **v4;
  Swift::_HashTable::Bucket v5;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  Swift::_HashTable::Bucket v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  Swift::Int v20;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  unint64_t *v28;
  unint64_t v29;
  BOOL v30;
  unint64_t v31;
  unint64_t **v32;
  uint64_t v33[3];
  uint64_t v34;
  uint64_t v35;
  uint64_t v36[3];
  uint64_t v37;
  uint64_t v38;
  v5.Swift::Int offset = result;
  uint64_t v6 = *v4;
  uint64_t v7 = (uint64_t)(*v4 + 7);
  uint64_t v8 = -1LL << *((_BYTE *)*v4 + 32);
  unint64_t v9 = (result + 1) & ~v8;
  if (((1LL << v9) & *(void *)(v7 + 8 * (v9 >> 6))) != 0)
  {
    unint64_t v32 = v4;
    uint64_t v10 = ~v8;
    swift_retain(v6, a2, a3, a4);
    v11.Swift::Int offset = _HashTable.previousHole(before:)(v5).offset;
    if ((*(void *)(v7 + 8 * (v9 >> 6)) & (1LL << v9)) != 0)
    {
      Swift::_HashTable::Bucket v12 = (v11.offset + 1) & v10;
      do
      {
        Swift::_HashTable::Bucket v13 = v7;
        outlined init with copy of AnyHashable(v6[6] + 40 * v9, (uint64_t)v36);
        Swift::_HashTable::Bucket v14 = v6[5];
        unint64_t v15 = v37;
        uint64_t v16 = v38;
        __swift_project_boxed_opaque_existential_0Tm(v36, v37);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v16 + 8))(v33, v15, v16);
        unint64_t v17 = v34;
        unint64_t v18 = v35;
        __swift_project_boxed_opaque_existential_0Tm(v33, v34);
        uint64_t v19 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v18 + 40))(v14, v17, v18);
        __swift_destroy_boxed_opaque_existential_1Tm(v33);
        outlined destroy of AnyHashable(v36);
        unint64_t v20 = v19 & v10;
        if (v5.offset >= (uint64_t)v12)
        {
          if (v20 >= v12 && v5.offset >= v20)
          {
LABEL_17:
            unint64_t v23 = v6[6];
            uint64_t v24 = v23 + 40 * v5.offset;
            BOOL v25 = v23 + 40 * v9;
            uint64_t v7 = v13;
            if (v5.offset != v9 || (v5.Swift::Int offset = v9, v24 >= v25 + 40))
            {
              uint64_t v26 = *(_OWORD *)v25;
              uint64_t v27 = *(_OWORD *)(v25 + 16);
              *(void *)(v24 + 32) = *(void *)(v25 + 32);
              *(_OWORD *)uint64_t v24 = v26;
              *(_OWORD *)(v24 + 16) = v27;
              v5.Swift::Int offset = v9;
            }

            goto LABEL_5;
          }
        }

        else if (v20 >= v12 || v5.offset >= v20)
        {
          goto LABEL_17;
        }

        uint64_t v7 = v13;
LABEL_5:
        unint64_t v9 = (v9 + 1) & v10;
      }

      while (((*(void *)(v7 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) != 0);
    }

    *(void *)(v7 + (((unint64_t)v5.offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << SLOBYTE(v5.offset)) - 1;
    uint64_t result = swift_release((uint64_t)v6);
    uint64_t v4 = v32;
  }

  else
  {
    *(void *)(v7 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << result) - 1;
  }

  __int128 v28 = *v4;
  __int128 v29 = (*v4)[2];
  uint64_t v30 = __OFSUB__(v29, 1LL);
  uint64_t v31 = v29 - 1;
  if (v30)
  {
    __break(1u);
  }

  else
  {
    v28[2] = v31;
    ++*((_DWORD *)v28 + 9);
  }

  return result;
}

Swift::Void __swiftcall _NativeSet._delete(at:)(Swift::_HashTable::Bucket at)
{
  uint64_t v3 = v1;
  Swift::Int offset = at.offset;
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v39 = *(void *)(v5 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](at.offset);
  Swift::_HashTable::Bucket v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::_HashTable::Bucket v12 = *v2;
  uint64_t v13 = (uint64_t)(*v2 + 7);
  uint64_t v14 = -1LL << *((_BYTE *)*v2 + 32);
  unint64_t v15 = (v6 + 1) & ~v14;
  if (((1LL << v15) & *(void *)(v13 + 8 * (v15 >> 6))) != 0)
  {
    uint64_t v34 = v2;
    uint64_t v16 = ~v14;
    swift_retain(v12, v7, v8, v9);
    v17.Swift::Int offset = _HashTable.previousHole(before:)((Swift::_HashTable::Bucket)offset).offset;
    uint64_t v38 = v13;
    if ((*(void *)(v13 + 8 * (v15 >> 6)) & (1LL << v15)) != 0)
    {
      unint64_t v18 = (v17.offset + 1) & v16;
      uint64_t v37 = *(void *)(v3 + 24);
      uint64_t v19 = *(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v37 + 32);
      uint64_t v20 = *(void *)(v39 + 72);
      uint64_t v35 = *(void (**)(char *, unint64_t, uint64_t))(v39 + 16);
      uint64_t v36 = v19;
      do
      {
        int64_t v21 = v20 * v15;
        v35(v11, v12[6] + v20 * v15, v5);
        uint64_t v22 = v36(v12[5], v5, v37);
        (*(void (**)(char *, uint64_t))(v39 + 8))(v11, v5);
        Swift::Int v23 = v22 & v16;
        if (offset >= (uint64_t)v18)
        {
          if (v23 < v18 || offset < v23) {
            goto LABEL_6;
          }
        }

        else if (v23 < v18 && offset < v23)
        {
          goto LABEL_6;
        }

        unint64_t v26 = v12[6];
        Swift::Int v27 = v20 * offset;
        __int128 v28 = (char *)(v26 + v20 * offset);
        __int128 v29 = (char *)(v26 + v21);
        if (v20 * offset < v21 || v28 >= &v29[v20])
        {
          swift_arrayInitWithTakeFrontToBack(v28, v29, 1LL, v5);
        }

        else
        {
          Swift::Int offset = v15;
          if (v27 == v21) {
            goto LABEL_6;
          }
          swift_arrayInitWithTakeBackToFront(v28, v29, 1LL, v5);
        }

        Swift::Int offset = v15;
LABEL_6:
        unint64_t v15 = (v15 + 1) & v16;
      }

      while (((*(void *)(v38 + ((v15 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v15) & 1) != 0);
    }

    *(void *)(v38 + (((unint64_t)offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << offset) - 1;
    swift_release((uint64_t)v12);
    uint64_t v2 = v34;
  }

  else
  {
    *(void *)(v13 + (((unint64_t)offset >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << offset) - 1;
  }

  uint64_t v30 = *v2;
  unint64_t v31 = (*v2)[2];
  BOOL v32 = __OFSUB__(v31, 1LL);
  unint64_t v33 = v31 - 1;
  if (v32)
  {
    __break(1u);
  }

  else
  {
    _OWORD v30[2] = v33;
    ++*((_DWORD *)v30 + 9);
  }

void _NativeSet.uncheckedRemove(at:isUnique:)( Swift::_HashTable::Bucket a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if ((a2 & 1) == 0) {
    _NativeSet.copy()();
  }
  (*(void (**)(uint64_t, Swift::Int))(*(void *)(*(void *)(a3 + 16) - 8LL) + 32LL))( a4,  *(void *)(*(void *)v4 + 48LL) + *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 72LL) * a1.offset);
  _NativeSet._delete(at:)(a1);
}

Swift::Void __swiftcall _NativeSet.removeAll(isUnique:)(Swift::Bool isUnique)
{
  uint64_t v5 = v4;
  uint64_t v6 = v1;
  uint64_t v7 = *v4;
  char v8 = *(_BYTE *)(*v4 + 32LL);
  if (!isUnique)
  {
    type metadata accessor for _SetStorage(0LL, *(void *)(v1 + 16), *(void *)(v1 + 24), (uint64_t)v3);
    uint64_t v20 = static _SetStorage.allocate(scale:age:seed:)(v8, 0x100000000LL, 0LL, 1);
    swift_release(v7);
    *uint64_t v5 = v20;
    return;
  }

  uint64_t v9 = 1LL << v8;
  uint64_t v10 = (void *)(v7 + 56);
  uint64_t v11 = -1LL;
  if (v9 < 64) {
    uint64_t v11 = ~(-1LL << v9);
  }
  unint64_t v12 = v11 & *(void *)(v7 + 56);
  int64_t v13 = (unint64_t)(v9 + 63) >> 6;
  swift_retain((unint64_t *)v7, v1, v2, v3);
  int64_t v14 = 0LL;
  while (1)
  {
    if (v12)
    {
      unint64_t v15 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v16 = v15 | (v14 << 6);
      goto LABEL_6;
    }

    if (__OFADD__(v14++, 1LL)) {
      goto LABEL_24;
    }
    if (v14 >= v13) {
      break;
    }
    unint64_t v18 = v10[v14];
    if (!v18)
    {
      int64_t v19 = v14 + 1;
      if (v14 + 1 >= v13) {
        break;
      }
      unint64_t v18 = v10[v19];
      if (!v18)
      {
        while (1)
        {
          int64_t v14 = v19 + 1;
          if (__OFADD__(v19, 1LL)) {
            break;
          }
          if (v14 >= v13) {
            goto LABEL_19;
          }
          unint64_t v18 = v10[v14];
          ++v19;
          if (v18) {
            goto LABEL_17;
          }
        }

        __break(1u);
LABEL_24:
        __break(1u);
        return;
      }

      ++v14;
    }

void *specialized static _SetStorage.allocate(scale:age:seed:)(char a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v8 = a1;
  uint64_t v9 = 1LL << a1;
  unint64_t v10 = (unint64_t)((1LL << a1) + 63) >> 6;
  uint64_t v11 = canonical specialized generic type metadata accessor for _SetStorage<AnyHashable>();
  unint64_t v12 = swift_allocObject(v11, ((8 * v10 + 63) & 0x3FFFFFFFFFFFFFF8LL) + (40LL << v8), 7uLL);
  void v12[2] = 0LL;
  double v13 = (double)v9 * 0.75;
  if ((~*(void *)&v13 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v13 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v13 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  int64_t v14 = v12;
  unint64_t v15 = (int64x2_t *)(v12 + 7);
  uint64_t v16 = (uint64_t)&v12[v10 + 7];
  v12[3] = (uint64_t)v13;
  *((_BYTE *)v12 + 32) = a1;
  *((_BYTE *)v12 + 33) = 0;
  *((_WORD *)v12 + 17) = 0;
  if ((a2 & 0x100000000LL) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v12);
  }
  *((_DWORD *)v14 + 9) = a2;
  if ((_BYTE)qword_18C487060) {
    Swift::_HashTable::Bucket v17 = (void *)v8;
  }
  else {
    Swift::_HashTable::Bucket v17 = v14;
  }
  if ((a4 & 1) == 0) {
    Swift::_HashTable::Bucket v17 = a3;
  }
  Swift::UnsafeRawPointer_optional v14[5] = v17;
  v14[6] = v16;
  if (v9 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v10, v15);
  }
  else {
    v15->i64[0] = -1LL << v9;
  }
  return v14;
}

{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  double v13;
  void *v14;
  int64x2_t *v15;
  uint64_t v16;
  void *v17;
  uint64_t v8 = a1;
  uint64_t v9 = 1LL << a1;
  unint64_t v10 = (unint64_t)((1LL << a1) + 63) >> 6;
  uint64_t v11 = canonical specialized generic type metadata accessor for _SetStorage<String>();
  unint64_t v12 = swift_allocObject(v11, ((8 * v10 + 63) & 0x3FFFFFFFFFFFFFF8LL) + (16LL << v8), 7uLL);
  void v12[2] = 0LL;
  double v13 = (double)v9 * 0.75;
  if ((~*(void *)&v13 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v13 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v13 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  int64_t v14 = v12;
  unint64_t v15 = (int64x2_t *)(v12 + 7);
  uint64_t v16 = (uint64_t)&v12[v10 + 7];
  v12[3] = (uint64_t)v13;
  *((_BYTE *)v12 + 32) = a1;
  *((_BYTE *)v12 + 33) = 0;
  *((_WORD *)v12 + 17) = 0;
  if ((a2 & 0x100000000LL) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v12);
  }
  *((_DWORD *)v14 + 9) = a2;
  if ((_BYTE)qword_18C487060) {
    Swift::_HashTable::Bucket v17 = (void *)v8;
  }
  else {
    Swift::_HashTable::Bucket v17 = v14;
  }
  if ((a4 & 1) == 0) {
    Swift::_HashTable::Bucket v17 = a3;
  }
  Swift::UnsafeRawPointer_optional v14[5] = v17;
  v14[6] = v16;
  if (v9 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v10, v15);
  }
  else {
    v15->i64[0] = -1LL << v9;
  }
  return v14;
}

void *specialized static _SetStorage.allocate(scale:age:seed:)( char a1, uint64_t a2, void *a3, char a4, uint64_t (*a5)(void))
{
  uint64_t v9 = a1;
  uint64_t v10 = 1LL << a1;
  unint64_t v11 = (unint64_t)((1LL << a1) + 63) >> 6;
  uint64_t v12 = a5(0LL);
  double v13 = swift_allocObject(v12, ((8 * v11 + 63) & 0x3FFFFFFFFFFFFFF8LL) + (8LL << v9), 7uLL);
  _OWORD v13[2] = 0LL;
  double v14 = (double)v10 * 0.75;
  if ((~*(void *)&v14 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v14 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v14 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  unint64_t v15 = v13;
  uint64_t v16 = (int64x2_t *)(v13 + 7);
  uint64_t v17 = (uint64_t)&v13[v11 + 7];
  v13[3] = (uint64_t)v14;
  *((_BYTE *)v13 + 32) = a1;
  *((_BYTE *)v13 + 33) = 0;
  *((_WORD *)v13 + 17) = 0;
  if ((a2 & 0x100000000LL) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v13);
  }
  *((_DWORD *)v15 + 9) = a2;
  if ((_BYTE)qword_18C487060) {
    unint64_t v18 = (void *)v9;
  }
  else {
    unint64_t v18 = v15;
  }
  if ((a4 & 1) == 0) {
    unint64_t v18 = a3;
  }
  v15[5] = v18;
  v15[6] = v17;
  if (v10 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v11, v16);
  }
  else {
    v16->i64[0] = -1LL << v10;
  }
  return v15;
}

void *static _SetStorage.allocate(scale:age:seed:)(char a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v10 = a1;
  uint64_t v11 = 1LL << a1;
  unint64_t v12 = (unint64_t)((1LL << a1) + 63) >> 6;
  uint64_t v13 = *(void *)(*(void *)(v4 + 168) - 8LL);
  uint64_t v14 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v15 = v14 + 8 * v12;
  uint64_t v16 = swift_allocObject(v5, ((v15 + 56) & ~v14) + (*(void *)(v13 + 72) << a1), v14 | 7);
  void v16[2] = 0LL;
  double v17 = (double)v11 * 0.75;
  if ((~*(void *)&v17 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v17 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  if (v17 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be greater than Int.max",  88LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x373BuLL,  0);
  }
  unint64_t v18 = v16;
  unint64_t v24 = v12;
  int64_t v19 = a3;
  uint64_t v20 = (int64x2_t *)(v16 + 7);
  v16[3] = (uint64_t)v17;
  uint64_t v21 = ((unint64_t)v16 + v15 + 56) & ~v14;
  *((_BYTE *)v16 + 32) = a1;
  *((_BYTE *)v16 + 33) = 0;
  *((_WORD *)v16 + 17) = 0;
  if ((a2 & 0x100000000LL) != 0) {
    LODWORD(a2) = specialized static Hasher._hash(seed:_:)(0LL, (uint64_t)v16);
  }
  *((_DWORD *)v18 + 9) = a2;
  if ((_BYTE)qword_18C487060) {
    uint64_t v22 = (void *)v10;
  }
  else {
    uint64_t v22 = v18;
  }
  if ((a4 & 1) == 0) {
    uint64_t v22 = v19;
  }
  v18[5] = v22;
  v18[6] = v21;
  if (v11 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v24, v20);
  }
  else {
    v20->i64[0] = -1LL << v11;
  }
  return v18;
}

unint64_t *_NativeSet.Iterator.base.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_retain(*v4, a2, a3, a4);
}

uint64_t _NativeSet.Iterator.iterator.getter()
{
  return *(void *)(v0 + 8);
}

uint64_t _NativeSet.Iterator.iterator.setter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[1] = result;
  void v4[2] = a2;
  v4[3] = a3;
  v4[4] = a4;
  return result;
}

uint64_t (*_NativeSet.Iterator.iterator.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _NativeSet.Iterator.init(_:)@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = -1LL;
  uint64_t v3 = -1LL << *(_BYTE *)(a1 + 32);
  *a2 = a1;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t result = a1 + 56;
  uint64_t v5 = v6;
  if (-v3 < 64) {
    uint64_t v2 = ~(-1LL << -(char)v3);
  }
  a2[1] = result;
  a2[2] = ~v3;
  a2[3] = 0LL;
  a2[4] = v2 & v5;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance _NativeSet<A>(void *a1@<X8>)
{
  uint64_t v2 = *v1;
  uint64_t v3 = -1LL;
  uint64_t v4 = -1LL << *(_BYTE *)(*v1 + 32);
  *a1 = *v1;
  uint64_t v7 = *(void *)(v2 + 56);
  uint64_t v5 = v2 + 56;
  uint64_t v6 = v7;
  if (-v4 < 64) {
    uint64_t v3 = ~(-1LL << -(char)v4);
  }
  a1[1] = v5;
  a1[2] = ~v4;
  a1[3] = 0LL;
  a1[4] = v3 & v6;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _NativeSet<A>( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = specialized Sequence._copyToContiguousArray()(v2, a1, a2);
  swift_release(*v2);
  return v3;
}

uint64_t protocol witness for IteratorProtocol.next() in conformance _NativeSet<A>.Iterator@<X0>( uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = v2[4];
  if (v4)
  {
    v2[4] = (v4 - 1) & v4;
    unint64_t v5 = __clz(__rbit64(v4)) | (v2[3] << 6);
LABEL_3:
    uint64_t v6 = *(void *)(*v2 + 48LL);
    uint64_t v7 = *(void *)(result + 16);
    uint64_t v8 = *(void *)(v7 - 8);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v8 + 16))(a2, v6 + *(void *)(v8 + 72) * v5, v7);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56);
    uint64_t v10 = a2;
    uint64_t v11 = 0LL;
    uint64_t v12 = v7;
    return v9(v10, v11, 1LL, v12);
  }

  uint64_t v13 = v2[3];
  int64_t v14 = v13 + 1;
  if (!__OFADD__(v13, 1LL))
  {
    int64_t v15 = (unint64_t)(v2[2] + 64LL) >> 6;
    if (v14 < v15)
    {
      v2[3] = v14;
      uint64_t v16 = v2[1];
      unint64_t v17 = *(void *)(v16 + 8 * v14);
      v2[4] = v17;
      if (v17)
      {
LABEL_11:
        v2[4] = (v17 - 1) & v17;
        unint64_t v5 = __clz(__rbit64(v17)) + (v14 << 6);
        goto LABEL_3;
      }

      uint64_t v18 = v13 + 2;
      while (v15 != v18)
      {
        v2[3] = v18;
        unint64_t v17 = *(void *)(v16 + 8 * v18);
        v2[4] = v17;
        ++v18;
        if (v17)
        {
          int64_t v14 = v18 - 1;
          goto LABEL_11;
        }
      }
    }

    uint64_t v12 = *(void *)(result + 16);
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56LL);
    uint64_t v10 = a2;
    uint64_t v11 = 1LL;
    return v9(v10, v11, 1LL, v12);
  }

  __break(1u);
  return result;
}

uint64_t closure #1 in _NativeSet.isSubset<A>(of:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, char *a8@<X8>)
{
  uint64_t v55 = a8;
  uint64_t v68 = a2;
  uint64_t v69 = (void *)a7;
  uint64_t v57 = a1;
  uint64_t v13 = *(void **)(a4 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](a1);
  int64_t v66 = (char *)&v54 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  unint64_t v17 = (char *)&v54 - v16;
  uint64_t v21 = type metadata accessor for Optional(0LL, v20, v18, v19);
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  __int128 v64 = (char *)&v54 - v23;
  uint64_t v24 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](v22);
  unint64_t v26 = (char *)&v54 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::Int v27 = (const char *)a7;
  uint64_t v28 = a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v27,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v54 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v30 = (char *)&v54 - v29;
  unint64_t v31 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
  BOOL v32 = v64;
  v31(v26, v68, v28);
  ((void (*)(uint64_t))v69[4])(v28);
  uint64_t v33 = v28;
  unint64_t v34 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v69,  v33,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v36 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v62 = AssociatedConformanceWitness;
  uint64_t v63 = v30;
  uint64_t v61 = v36;
  ((void (*)(unint64_t))v36)(v34);
  uint64_t v60 = (unsigned int (*)(char *, uint64_t, uint64_t))v13[6];
  if (v60(v32, 1LL, a4) != 1)
  {
    uint64_t v56 = 0LL;
    uint64_t v58 = (void (*)(char *, char *, uint64_t))v13[4];
    uint64_t v59 = a6;
    uint64_t v68 = a3 + 56;
    uint64_t v69 = v13;
    uint64_t v70 = a3;
    uint64_t v71 = v17;
    v58(v17, v32, a4);
    while (1)
    {
      uint64_t v41 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(a3 + 40), a4, a6);
      uint64_t v42 = -1LL << *(_BYTE *)(a3 + 32);
      unint64_t v43 = v41 & ~v42;
      if (((*(void *)(v68 + ((v43 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v43) & 1) != 0)
      {
        uint64_t v67 = ~v42;
        uint64_t v44 = *(void *)(a6 + 8);
        int64_t v45 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v44 + 8);
        uint64_t v46 = v13[9];
        uint64_t v47 = (void (*)(char *, unint64_t, uint64_t))v13[2];
        while (1)
        {
          uint64_t v48 = v66;
          v47(v66, *(void *)(v70 + 48) + v46 * v43, a4);
          char v49 = v45(v48, v71, a4, v44);
          uint64_t v37 = (void (*)(char *, uint64_t))v69[1];
          v37(v48, a4);
          if ((v49 & 1) != 0) {
            break;
          }
          unint64_t v43 = (v43 + 1) & v67;
          if (((*(void *)(v68 + ((v43 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v43) & 1) == 0) {
            goto LABEL_4;
          }
        }

        uint64_t v38 = v71;
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v37)(v71, a4);
        uint64_t v51 = (v43 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
        uint64_t v52 = *(void *)(v57 + v51);
        *(void *)(v57 + v5_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v52 | (1LL << v43);
        if ((v52 & (1LL << v43)) != 0)
        {
          a6 = v59;
          uint64_t v13 = v69;
          a3 = v70;
          uint64_t v39 = v64;
        }

        else
        {
          a6 = v59;
          uint64_t v13 = v69;
          a3 = v70;
          uint64_t v39 = v64;
          if (__OFADD__(v56, 1LL))
          {
            __break(1u);
            return result;
          }

          if (v56 + 1 == *(void *)(v70 + 16))
          {
            char v53 = 1;
            goto LABEL_18;
          }

          ++v56;
        }

        v61(AssociatedTypeWitness, v62);
        if (v60(v39, 1LL, a4) == 1) {
          break;
        }
      }

      else
      {
        uint64_t v37 = (void (*)(char *, uint64_t))v13[1];
LABEL_4:
        uint64_t v38 = v71;
        v37(v71, a4);
        uint64_t v39 = v64;
        v61(AssociatedTypeWitness, v62);
        unsigned int v40 = v60(v39, 1LL, a4);
        a6 = v59;
        uint64_t v13 = v69;
        a3 = v70;
        if (v40 == 1) {
          break;
        }
      }

      v58(v38, v39, a4);
    }
  }

  char v53 = 0;
LABEL_18:
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v54 + 8))(v63, AssociatedTypeWitness);
  *uint64_t v55 = v53;
  return result;
}

uint64_t _NativeSet.isSubset<A>(of:)( uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void (*a7)(unsigned __int8 *__return_ptr, int64x2_t *, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v13 = isStackAllocationSafe;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  char v14 = *(_BYTE *)(a2 + 32);
  unint64_t v15 = (unint64_t)((1LL << v14) + 63) >> 6;
  size_t v16 = 8 * v15;
  if ((v14 & 0x3Fu) <= 0xD
    || (isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1895F8858](isStackAllocationSafe);
    unint64_t v17 = (int64x2_t *)((char *)&v20 - ((v16 + 15) & 0x3FFFFFFFFFFFFFF0LL));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v15, v17);
    a7(&v21, v17, v15, v13, a2, a3, a4, a5, a6);
    return v21;
  }

  else
  {
    uint64_t v19 = (int64x2_t *)swift_slowAlloc(v16, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v15, v19);
    a7(&v21, v19, v15, v13, a2, a3, a4, a5, a6);
    swift_slowDealloc(v19);
    return v21;
  }

uint64_t closure #1 in _NativeSet.isStrictSubset<A>(of:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, const char *a7@<X7>, char *a8@<X8>)
{
  uint64_t v58 = a1;
  uint64_t v68 = (uint64_t)a7;
  uint64_t v70 = a2;
  uint64_t v71 = a5;
  uint64_t v11 = a4;
  uint64_t v57 = a8;
  uint64_t v13 = *(void **)(a4 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](a1);
  uint64_t v69 = (char *)&v55 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v75 = (char *)&v55 - v16;
  uint64_t v20 = type metadata accessor for Optional(0LL, v19, v17, v18);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v55 - v22;
  uint64_t v24 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](v21);
  unint64_t v26 = (char *)&v55 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a7,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v56 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v29 = (char *)&v55 - v28;
  uint64_t v30 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
  uint64_t v31 = v71;
  v30(v26, v70, v71);
  uint64_t v32 = v31;
  uint64_t v33 = v68;
  (*(void (**)(uint64_t))(v68 + 32))(v32);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v33,  v71,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v35 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  int64_t v66 = v29;
  unint64_t v67 = AssociatedTypeWitness;
  __int128 v64 = v35;
  unint64_t v65 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v35)(AssociatedTypeWitness);
  uint64_t v63 = (unsigned int (*)(char *, uint64_t, uint64_t))v13[6];
  if (v63(v23, 1LL, v11) != 1)
  {
    uint64_t v59 = 0LL;
    uint64_t v60 = v23;
    LODWORD(v68) = 0;
    uint64_t v39 = (void (*)(char *, char *, uint64_t))v13[4];
    uint64_t v61 = a6;
    unint64_t v62 = v39;
    uint64_t v71 = a3 + 56;
    uint64_t v72 = v13;
    uint64_t v73 = a3;
    uint64_t v74 = v11;
    v39(v75, v23, v11);
    while (1)
    {
      uint64_t v42 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(a3 + 40), v11, a6);
      uint64_t v43 = -1LL << *(_BYTE *)(a3 + 32);
      unint64_t v44 = v42 & ~v43;
      if (((*(void *)(v71 + ((v44 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v44) & 1) != 0)
      {
        uint64_t v70 = ~v43;
        uint64_t v45 = *(void *)(a6 + 8);
        uint64_t v46 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v45 + 8);
        uint64_t v47 = v13[9];
        uint64_t v48 = (void (*)(char *, unint64_t, uint64_t))v13[2];
        while (1)
        {
          uint64_t v49 = v74;
          unint64_t v50 = v69;
          v48(v69, *(void *)(v73 + 48) + v47 * v44, v74);
          char v51 = v46(v50, v75, v49, v45);
          uint64_t v52 = (void (*)(char *, uint64_t))v72[1];
          v52(v50, v49);
          if ((v51 & 1) != 0) {
            break;
          }
          unint64_t v44 = (v44 + 1) & v70;
          if (((*(void *)(v71 + ((v44 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v44) & 1) == 0) {
            goto LABEL_11;
          }
        }

        uint64_t v11 = v74;
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v52)(v75, v74);
        uint64_t v53 = (v44 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
        uint64_t v54 = *(void *)(v58 + v53);
        *(void *)(v58 + v53) = v54 | (1LL << v44);
        if ((v54 & (1LL << v44)) != 0)
        {
          a6 = v61;
          a3 = v73;
        }

        else
        {
          if (__OFADD__(v59, 1LL))
          {
            __break(1u);
            return result;
          }

          a3 = v73;
          ++v59;
          a6 = v61;
        }

        uint64_t v13 = v72;
        unsigned int v40 = v60;
        v64(v67, v65);
        if (v63(v40, 1LL, v11) == 1) {
          break;
        }
      }

      else
      {
        uint64_t v52 = (void (*)(char *, uint64_t))v13[1];
LABEL_11:
        uint64_t v11 = v74;
        v52(v75, v74);
        a3 = v73;
        if ((v68 & 1) == 0 && v59 == *(void *)(v73 + 16))
        {
LABEL_22:
          char v36 = 1;
          goto LABEL_3;
        }

        unsigned int v40 = v60;
        v64(v67, v65);
        LODWORD(v68) = 1;
        unsigned int v41 = v63(v40, 1LL, v11);
        a6 = v61;
        uint64_t v13 = v72;
        if (v41 == 1) {
          break;
        }
      }

      v62(v75, v40, v11);
    }
  }

  char v36 = 0;
LABEL_3:
  uint64_t v37 = v57;
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v56 + 8))(v66, v67);
  *uint64_t v37 = v36;
  return result;
}

uint64_t closure #1 in _NativeSet.isStrictSuperset<A>(of:)@<X0>( uint64_t a1@<X0>, void *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, char *a8@<X8>)
{
  uint64_t v63 = a1;
  uint64_t v64 = a6;
  uint64_t v10 = a4;
  uint64_t v73 = a2;
  uint64_t v74 = a3;
  uint64_t v68 = a8;
  uint64_t v11 = *(void **)(a4 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v71 = (char *)&v56 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v75 = (char *)&v56 - v14;
  uint64_t v18 = type metadata accessor for Optional(0LL, v17, v15, v16);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  uint64_t v21 = (char *)&v56 - v20;
  uint64_t v22 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v24 = (char *)&v56 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a7,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v65 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  Swift::Int v27 = (char *)&v56 - v26;
  (*(void (**)(char *, void *, uint64_t))(v22 + 16))(v24, v73, a5);
  (*(void (**)(uint64_t, uint64_t))(a7 + 32))(a5, a7);
  uint64_t v28 = a7;
  uint64_t v29 = v21;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v28,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v31 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  int64_t v66 = v27;
  unint64_t v67 = AssociatedTypeWitness;
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v33 = v68;
  uint64_t v61 = v31;
  unint64_t v62 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v31)(v32);
  uint64_t v73 = v11;
  unint64_t v34 = (uint64_t (*)(char *, uint64_t, uint64_t))v11[6];
  uint64_t v35 = v74;
  char v36 = 1;
  if (v34(v21, 1LL, v10) != 1)
  {
    uint64_t v37 = (void (*)(void, void, void))v73[4];
    uint64_t v38 = v35 + 56;
    uint64_t v59 = v34;
    uint64_t v60 = v29;
    uint64_t v57 = 0LL;
    uint64_t v58 = v37;
    uint64_t v72 = v10;
    while (1)
    {
      v37(v75, v29, v10);
      uint64_t v39 = v64;
      uint64_t v40 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v64 + 32))(*(void *)(v35 + 40), v10, v64);
      uint64_t v41 = -1LL << *(_BYTE *)(v35 + 32);
      unint64_t v42 = v40 & ~v41;
      if (((*(void *)(v38 + ((v42 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v42) & 1) == 0) {
        break;
      }
      uint64_t v69 = ~v41;
      uint64_t v43 = *(void *)(v39 + 8);
      uint64_t v70 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v43 + 8);
      uint64_t v44 = v73[9];
      uint64_t v45 = (void (*)(char *, unint64_t, uint64_t))v73[2];
      while (1)
      {
        uint64_t v47 = v71;
        uint64_t v46 = v72;
        v45(v71, *(void *)(v74 + 48) + v44 * v42, v72);
        char v48 = v70(v47, v75, v46, v43);
        uint64_t v49 = (void (*)(char *, uint64_t))v73[1];
        v49(v47, v46);
        if ((v48 & 1) != 0) {
          break;
        }
        unint64_t v42 = (v42 + 1) & v69;
        if (((*(void *)(v38 + ((v42 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v42) & 1) == 0) {
          goto LABEL_16;
        }
      }

      uint64_t result = ((uint64_t (*)(char *, uint64_t))v49)(v75, v72);
      uint64_t v51 = (v42 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
      uint64_t v52 = *(void *)(v63 + v51);
      *(void *)(v63 + v5_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v52 | (1LL << v42);
      if ((v52 & (1LL << v42)) != 0)
      {
        uint64_t v33 = v68;
        uint64_t v35 = v74;
        uint64_t v53 = v59;
        uint64_t v29 = v60;
        unint64_t v54 = v62;
      }

      else
      {
        uint64_t v33 = v68;
        uint64_t v35 = v74;
        uint64_t v53 = v59;
        uint64_t v29 = v60;
        unint64_t v54 = v62;
        if (__OFADD__(v57, 1LL))
        {
          __break(1u);
          return result;
        }

        if (v57 + 1 == *(void *)(v74 + 16))
        {
          char v36 = 0;
          goto LABEL_17;
        }

        ++v57;
      }

      v61(v67, v54);
      char v36 = 1;
      uint64_t v10 = v72;
      int v55 = v53(v29, 1LL, v72);
      uint64_t v37 = v58;
      if (v55 == 1) {
        goto LABEL_17;
      }
    }

    uint64_t v49 = (void (*)(char *, uint64_t))v73[1];
LABEL_16:
    v49(v75, v72);
    char v36 = 0;
    uint64_t v33 = v68;
  }

__objc2_class **_NativeSet.extractSubset(using:count:)( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v26 = a6;
  uint64_t v11 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v25 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (!v15)
  {
    swift_release(a4);
    return &_swiftEmptySetSingleton;
  }

  if (*(void *)(a4 + 16) == a3) {
    return (__objc2_class **)a4;
  }
  type metadata accessor for _SetStorage(0LL, a5, v26, v12);
  uint64_t result = (__objc2_class **)static _SetStorage.allocate(capacity:)(a3);
  uint64_t v16 = (uint64_t)result;
  if (a2 < 1) {
    unint64_t v18 = 0LL;
  }
  else {
    unint64_t v18 = *a1;
  }
  uint64_t v19 = 0LL;
  while (1)
  {
    if (v18)
    {
      unint64_t v20 = __clz(__rbit64(v18));
      v18 &= v18 - 1;
      unint64_t v21 = v20 | (v19 << 6);
      goto LABEL_21;
    }

    BOOL v22 = __OFADD__(v19++, 1LL);
    if (v22) {
      goto LABEL_27;
    }
    if (v19 >= a2)
    {
LABEL_23:
      swift_release(a4);
      return (__objc2_class **)v16;
    }

    unint64_t v23 = a1[v19];
    if (!v23) {
      break;
    }
LABEL_20:
    unint64_t v18 = (v23 - 1) & v23;
    unint64_t v21 = __clz(__rbit64(v23)) + (v19 << 6);
LABEL_21:
    (*(void (**)(char *, unint64_t, uint64_t))(v11 + 16))( v14,  *(void *)(a4 + 48) + *(void *)(v11 + 72) * v21,  a5);
    uint64_t result = (__objc2_class **)_NativeSet._unsafeInsertNew(_:)((uint64_t)v14, v16, a5, v26);
    BOOL v22 = __OFSUB__(a3--, 1LL);
    if (v22)
    {
      __break(1u);
      goto LABEL_26;
    }

    if (!a3) {
      goto LABEL_23;
    }
  }

  uint64_t v24 = v19 + 1;
  if (v19 + 1 >= a2) {
    goto LABEL_23;
  }
  unint64_t v23 = a1[v24];
  if (v23)
  {
    ++v19;
    goto LABEL_20;
  }

  while (1)
  {
    uint64_t v19 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v19 >= a2) {
      goto LABEL_23;
    }
    unint64_t v23 = a1[v19];
    ++v24;
    if (v23) {
      goto LABEL_20;
    }
  }

__objc2_class **_NativeSet.subtracting<A>(_:)( uint64_t a1, __objc2_class **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v68 = a5;
  v73[1] = *(__objc2_class ***)MEMORY[0x1895F89C0];
  uint64_t v11 = type metadata accessor for Optional(0LL, a3, a3, a4);
  uint64_t v65 = *(void *)(v11 - 8);
  uint64_t v66 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  unint64_t v67 = (char *)&v55 - v13;
  uint64_t v71 = *(void **)(a3 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v55 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v72 = (char *)&v55 - v18;
  uint64_t v19 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](v17);
  unint64_t v21 = (char *)&v55 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a6,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v25 = (char *)&v55 - v24;
  if (a2[2])
  {
    uint64_t v61 = v23;
    (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))(v21, a1, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 32))(a4, a6);
    uint64_t v56 = (const char *)a6;
    uint64_t v57 = a4;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    Swift::Int v27 = v67;
    uint64_t v63 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
    unint64_t v64 = AssociatedConformanceWitness;
    v63(AssociatedTypeWitness);
    uint64_t v28 = v71;
    unint64_t v62 = (uint64_t (*)(char *, uint64_t, uint64_t))v71[6];
    int v29 = v62(v27, 1LL, a3);
    uint64_t v30 = v68;
    if (v29 == 1)
    {
LABEL_3:
      (*(void (**)(char *, uint64_t))(v65 + 8))(v27, v66);
      (*(void (**)(char *, unint64_t))(v61 + 8))(v25, AssociatedTypeWitness);
    }

    else
    {
      uint64_t v58 = (void (*)(char *, char *, uint64_t))v28[4];
      uint64_t v59 = v25;
      uint64_t v69 = a2;
      uint64_t v70 = (char *)(a2 + 7);
      unint64_t v60 = AssociatedTypeWitness;
      while (1)
      {
        v58(v72, v27, a3);
        uint64_t v31 = (*(uint64_t (**)(__objc2_class *, uint64_t, uint64_t))(v30 + 32))(a2[5], a3, v30);
        uint64_t v32 = -1LL << *((_BYTE *)a2 + 32);
        unint64_t v33 = v31 & ~v32;
        if (((*(void *)&v70[(v33 >> 3) & 0xFFFFFFFFFFFFF8LL] >> v33) & 1) != 0) {
          break;
        }
        uint64_t v41 = (void (*)(char *, uint64_t))v28[1];
LABEL_12:
        v41(v72, a3);
        Swift::Int v27 = v67;
        uint64_t v25 = v59;
        unint64_t AssociatedTypeWitness = v60;
        ((void (*)(unint64_t, unint64_t))v63)(v60, v64);
        int v42 = v62(v27, 1LL, a3);
        uint64_t v30 = v68;
        a2 = v69;
        uint64_t v28 = v71;
        if (v42 == 1) {
          goto LABEL_3;
        }
      }

      uint64_t v34 = ~v32;
      uint64_t v35 = *(void *)(v30 + 8);
      char v36 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v35 + 8);
      uint64_t v37 = v28;
      uint64_t v38 = v28[9];
      uint64_t v39 = (void (*)(char *, char *, uint64_t))v37[2];
      while (1)
      {
        v39(v16, (char *)v69[6] + v38 * v33, a3);
        char v40 = v36(v16, v72, a3, v35);
        uint64_t v41 = (void (*)(char *, uint64_t))v71[1];
        v41(v16, a3);
        if ((v40 & 1) != 0) {
          break;
        }
        unint64_t v33 = (v33 + 1) & v34;
        if (((*(void *)&v70[(v33 >> 3) & 0xFFFFFFFFFFFFF8LL] >> v33) & 1) == 0) {
          goto LABEL_12;
        }
      }

      uint64_t isStackAllocationSafe = ((uint64_t (*)(char *, uint64_t))v41)(v72, a3);
      uint64_t v44 = (uint64_t)v69;
      char v45 = *((_BYTE *)v69 + 32);
      unint64_t v46 = (unint64_t)((1LL << v45) + 63) >> 6;
      size_t v47 = 8 * v46;
      if ((v45 & 0x3Fu) < 0xE
        || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (_DWORD)isStackAllocationSafe))
      {
        MEMORY[0x1895F8858](isStackAllocationSafe);
        char v48 = (char *)&v55 - ((v47 + 15) & 0x3FFFFFFFFFFFFFF0LL);
        specialized UnsafeMutablePointer.initialize(from:count:)(v70, v46, v48);
        unint64_t v49 = v33;
        uint64_t v50 = (uint64_t)v59;
        closure #1 in _NativeSet.subtracting<A>(_:)( (unint64_t *)v48,  v46,  v44,  v49,  (uint64_t)v59,  a3,  v57,  v68,  v73,  v56);
        swift_release(v44);
        unint64_t v51 = v60;
        a2 = v73[0];
      }

      else
      {
        uint64_t v52 = (char *)swift_slowAlloc(v47, 0xFFFFFFFFFFFFFFFFLL);
        specialized UnsafeMutablePointer.initialize(from:count:)(v70, v46, v52);
        unint64_t v53 = v33;
        uint64_t v50 = (uint64_t)v59;
        closure #1 in _NativeSet.subtracting<A>(_:)( (unint64_t *)v52,  v46,  v44,  v53,  (uint64_t)v59,  a3,  v57,  v68,  v73,  v56);
        swift_release(v44);
        unint64_t v51 = v60;
        swift_slowDealloc(v52);
        a2 = v73[0];
      }

      (*(void (**)(uint64_t, unint64_t))(v61 + 8))(v50, v51);
    }
  }

  else
  {
    swift_release((uint64_t)a2);
    return &_swiftEmptySetSingleton;
  }

  return a2;
}

__objc2_class **closure #1 in _NativeSet.subtracting<A>(_:)@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, __objc2_class ***a9@<X8>, const char *a10)
{
  uint64_t v55 = a9;
  uint64_t v65 = a5;
  uint64_t v14 = a3;
  uint64_t v54 = a2;
  uint64_t v16 = type metadata accessor for Optional(0LL, a6, a3, a4);
  uint64_t v52 = *(void *)(v16 - 8);
  uint64_t v53 = v16;
  uint64_t v17 = MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v51 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v66 = (char *)&v51 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v20);
  uint64_t v71 = (char *)&v51 - v22;
  uint64_t v23 = *(void *)(v14 + 16);
  uint64_t v24 = (a4 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  uint64_t v25 = *(unint64_t *)((char *)a1 + v24) & ((-1LL << a4) - 1);
  uint64_t v56 = a1;
  *(unint64_t *)((char *)a1 + v24) = v25;
  Swift::Int v27 = v26;
  uint64_t v57 = v23 - 1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a10,  a7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a10,  a7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v30 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v64 = AssociatedTypeWitness;
  uint64_t v31 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  unint64_t v62 = v30;
  unint64_t v63 = AssociatedConformanceWitness;
  v30(v31, AssociatedConformanceWitness);
  uint64_t v61 = (unsigned int (*)(char *, uint64_t, uint64_t))v27[6];
  if (v61(v19, 1LL, a6) != 1)
  {
    char v36 = (void (*)(char *, char *, uint64_t))v27[4];
    uint64_t v59 = a8;
    unint64_t v60 = v36;
    uint64_t v68 = v14 + 56;
    uint64_t v69 = v27;
    uint64_t v70 = v14;
    uint64_t v58 = v19;
    uint64_t v37 = v66;
    v36(v71, v19, a6);
    while (1)
    {
      uint64_t v40 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a8 + 32))(*(void *)(v14 + 40), a6, a8);
      uint64_t v41 = -1LL << *(_BYTE *)(v14 + 32);
      unint64_t v42 = v40 & ~v41;
      if (((*(void *)(v68 + ((v42 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v42) & 1) == 0) {
        break;
      }
      uint64_t v67 = ~v41;
      uint64_t v43 = *(void *)(a8 + 8);
      uint64_t v44 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v43 + 8);
      uint64_t v45 = v27[9];
      unint64_t v46 = (void (*)(char *, unint64_t, uint64_t))v27[2];
      while (1)
      {
        v46(v37, *(void *)(v70 + 48) + v45 * v42, a6);
        char v47 = v44(v37, v71, a6, v43);
        uint64_t v38 = (void (*)(char *, uint64_t))v69[1];
        v38(v37, a6);
        if ((v47 & 1) != 0) {
          break;
        }
        unint64_t v42 = (v42 + 1) & v67;
        if (((*(void *)(v68 + ((v42 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v42) & 1) == 0) {
          goto LABEL_6;
        }
      }

      uint64_t result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v38)(v71, a6);
      uint64_t v48 = (v42 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
      uint64_t v49 = *(unint64_t *)((char *)v56 + v48);
      *(unint64_t *)((char *)v56 + v48) = v49 & ~(1LL << v42);
      if ((v49 & (1LL << v42)) == 0) {
        goto LABEL_7;
      }
      uint64_t v19 = v58;
      uint64_t v50 = v57 - 1;
      a8 = v59;
      Swift::Int v27 = v69;
      uint64_t v14 = v70;
      if (__OFSUB__(v57, 1LL))
      {
        __break(1u);
        return result;
      }

      --v57;
      if (!v50)
      {
        uint64_t result = &_swiftEmptySetSingleton;
        goto LABEL_3;
      }

void _NativeSet.filter(_:)(uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t (*)(char *))isStackAllocationSafe;
  v17[1] = *(__objc2_class ***)MEMORY[0x1895F89C0];
  char v10 = *(_BYTE *)(a3 + 32);
  unint64_t v11 = (unint64_t)((1LL << v10) + 63) >> 6;
  size_t v12 = 8 * v11;
  if ((v10 & 0x3Fu) <= 0xD
    || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1895F8858](isStackAllocationSafe);
    uint64_t v13 = (int64x2_t *)((char *)&v15 - ((v12 + 15) & 0x3FFFFFFFFFFFFFF0LL));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v11, v13);
    closure #1 in _NativeSet.filter(_:)((unint64_t *)v13, v11, v9, a4, a5, &v16);
    swift_release(a3);
    if (v5) {
      swift_willThrow();
    }
  }

  else
  {
    uint64_t v14 = (int64x2_t *)swift_slowAlloc(v12, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v11, v14);
    closure #1 in _NativeSet.filter(_:)((unint64_t *)v14, v11, v9, a4, a5, v17);
    swift_release(a3);
    swift_slowDealloc(v14);
  }

__objc2_class **closure #1 in _NativeSet.filter(_:)@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(char *)@<X3>, uint64_t a4@<X5>, uint64_t a5@<X6>, __objc2_class ***a6@<X8>)
{
  uint64_t v32 = a5;
  uint64_t v33 = a2;
  uint64_t v38 = a3;
  uint64_t v34 = a1;
  uint64_t v31 = a6;
  uint64_t v8 = *(void *)(a4 - 8);
  uint64_t result = (__objc2_class **)MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v31 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int64_t v14 = 0LL;
  uint64_t v39 = v15;
  unint64_t v18 = v15[7];
  uint64_t v16 = (uint64_t)(v15 + 7);
  unint64_t v17 = v18;
  uint64_t v35 = 0LL;
  uint64_t v36 = v16;
  uint64_t v19 = 1LL << *(_BYTE *)(v16 - 24);
  uint64_t v20 = -1LL;
  if (v19 < 64) {
    uint64_t v20 = ~(-1LL << v19);
  }
  unint64_t v21 = v20 & v17;
  int64_t v37 = (unint64_t)(v19 + 63) >> 6;
  while (v21)
  {
    unint64_t v22 = __clz(__rbit64(v21));
    v21 &= v21 - 1;
    unint64_t v23 = v22 | (v14 << 6);
LABEL_16:
    (*(void (**)(char *, unint64_t, uint64_t))(v8 + 16))(v13, v39[6] + *(void *)(v8 + 72) * v23, a4);
    char v27 = v38(v13);
    uint64_t result = (__objc2_class **)(*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v13, a4);
    if (v6) {
      return result;
    }
    if ((v27 & 1) != 0)
    {
      *(unint64_t *)((char *)v34 + ((v23 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v23;
      BOOL v24 = __OFADD__(v35++, 1LL);
      if (v24)
      {
        __break(1u);
LABEL_21:
        uint64_t v28 = v31;
        uint64_t v29 = v32;
        uint64_t v30 = v39;
        swift_retain(v39, v10, v16, v11);
        uint64_t result = _NativeSet.extractSubset(using:count:)(v34, v33, v35, (uint64_t)v30, a4, v29);
        void *v28 = result;
        return result;
      }
    }
  }

  BOOL v24 = __OFADD__(v14++, 1LL);
  if (v24) {
    goto LABEL_24;
  }
  if (v14 >= v37) {
    goto LABEL_21;
  }
  unint64_t v25 = *(void *)(v36 + 8 * v14);
  if (v25)
  {
LABEL_15:
    unint64_t v21 = (v25 - 1) & v25;
    unint64_t v23 = __clz(__rbit64(v25)) + (v14 << 6);
    goto LABEL_16;
  }

  int64_t v26 = v14 + 1;
  if (v14 + 1 >= v37) {
    goto LABEL_21;
  }
  unint64_t v25 = *(void *)(v36 + 8 * v26);
  if (v25)
  {
    ++v14;
    goto LABEL_15;
  }

  while (1)
  {
    int64_t v14 = v26 + 1;
    if (__OFADD__(v26, 1LL)) {
      break;
    }
    if (v14 >= v37) {
      goto LABEL_21;
    }
    unint64_t v25 = *(void *)(v36 + 8 * v14);
    ++v26;
    if (v25) {
      goto LABEL_15;
    }
  }

  __break(1u);
LABEL_24:
  __break(1u);
  return result;
}

__objc2_class **_NativeSet.intersection(_:)( uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = isStackAllocationSafe;
  v15[1] = *(__objc2_class ***)MEMORY[0x1895F89C0];
  char v8 = *(_BYTE *)(a2 + 32);
  unint64_t v9 = (unint64_t)((1LL << v8) + 63) >> 6;
  size_t v10 = 8 * v9;
  if ((v8 & 0x3Fu) <= 0xD
    || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1895F8858](isStackAllocationSafe);
    unint64_t v11 = (int64x2_t *)((char *)v15 - ((v10 + 15) & 0x3FFFFFFFFFFFFFF0LL));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v9, v11);
    closure #1 in _NativeSet.intersection(_:)((unint64_t *)v11, v9, a2, v7, a3, a4, v15);
    swift_release(a2);
    return v15[0];
  }

  else
  {
    uint64_t v13 = (int64x2_t *)swift_slowAlloc(v10, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v9, v13);
    closure #1 in _NativeSet.intersection(_:)((unint64_t *)v13, v9, a2, v7, a3, a4, v15);
    swift_release(a2);
    swift_slowDealloc(v13);
    return v15[0];
  }

__objc2_class **closure #1 in _NativeSet.intersection(_:)@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, __objc2_class ***a7@<X8>)
{
  uint64_t v75 = a1;
  uint64_t v73 = a2;
  uint64_t v74 = a7;
  uint64_t v11 = *(void *)(a5 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  int64_t v14 = (char *)&v73 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unint64_t v17 = (char *)&v73 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v73 - v19;
  uint64_t result = (__objc2_class **)MEMORY[0x1895F8858](v18);
  int64_t v26 = (char *)&v73 - v25;
  unint64_t v27 = *(void *)(v23 + 16);
  unint64_t v28 = *(void *)(v24 + 16);
  uint64_t v82 = v29;
  uint64_t v86 = v24;
  uint64_t v87 = v23;
  uint64_t v88 = v11;
  if (v28 < v27)
  {
    int64_t v30 = 0LL;
    uint64_t v31 = *(void *)(a4 + 56);
    unint64_t v76 = (unint64_t)v26;
    uint64_t v77 = a4 + 56;
    uint64_t v32 = 1LL << *(_BYTE *)(a4 + 32);
    if (v32 < 64) {
      uint64_t v33 = ~(-1LL << v32);
    }
    else {
      uint64_t v33 = -1LL;
    }
    unint64_t v34 = v33 & v31;
    int64_t v78 = (unint64_t)(v32 + 63) >> 6;
    uint64_t v79 = 0LL;
    uint64_t v83 = a3 + 56;
    uint64_t v85 = v20;
    if (v34) {
      goto LABEL_9;
    }
LABEL_10:
    BOOL v35 = __OFADD__(v30, 1LL);
    int64_t v37 = v30 + 1;
    if (v35) {
      goto LABEL_57;
    }
    if (v37 < v78)
    {
      unint64_t v38 = *(void *)(v77 + 8 * v37);
      if (v38)
      {
LABEL_19:
        uint64_t v80 = (v38 - 1) & v38;
        int64_t v81 = v37;
        for (unint64_t i = __clz(__rbit64(v38)) + (v37 << 6); ; unint64_t i = __clz(__rbit64(v34)) | (v30 << 6))
        {
          uint64_t v40 = *(void *)(a4 + 48);
          int64_t v84 = *(void (**)(char *, unint64_t, uint64_t))(v11 + 72);
          uint64_t v41 = *(void (**)(char *, unint64_t, uint64_t))(v11 + 16);
          v41(v26, v40 + (void)v84 * i, a5);
          (*(void (**)(char *, char *, uint64_t))(v11 + 32))(v20, v26, a5);
          uint64_t v42 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(a3 + 40), a5, a6);
          uint64_t v43 = -1LL << *(_BYTE *)(a3 + 32);
          unint64_t v44 = v42 & ~v43;
          if (((*(void *)(v83 + ((v44 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v44) & 1) != 0)
          {
            uint64_t v45 = ~v43;
            uint64_t v46 = *(void *)(a6 + 8);
            char v47 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v46 + 8);
            while (1)
            {
              v41(v17, *(void *)(v87 + 48) + v44 * (void)v84, a5);
              char v48 = v47(v17, v85, a5, v46);
              uint64_t v49 = *(void (**)(char *, uint64_t))(v88 + 8);
              v49(v17, a5);
              if ((v48 & 1) != 0) {
                break;
              }
              unint64_t v44 = (v44 + 1) & v45;
              if (((*(void *)(v83 + ((v44 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v44) & 1) == 0) {
                goto LABEL_26;
              }
            }

            uint64_t v20 = v85;
            uint64_t result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v49)(v85, a5);
            int64_t v26 = (char *)v76;
            *(unint64_t *)((char *)v75 + ((v44 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v44;
            unint64_t v34 = v80;
            BOOL v35 = __OFADD__(v79++, 1LL);
            int64_t v30 = v81;
            a6 = v82;
            a4 = v86;
            a3 = v87;
            uint64_t v11 = v88;
            if (v35) {
              goto LABEL_59;
            }
            if (!v80) {
              goto LABEL_10;
            }
          }

          else
          {
            uint64_t v49 = *(void (**)(char *, uint64_t))(v11 + 8);
LABEL_26:
            uint64_t v20 = v85;
            uint64_t result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v49)(v85, a5);
            int64_t v30 = v81;
            a6 = v82;
            a4 = v86;
            a3 = v87;
            uint64_t v11 = v88;
            int64_t v26 = (char *)v76;
            unint64_t v34 = v80;
            if (!v80) {
              goto LABEL_10;
            }
          }

__objc2_class **_NativeSet.genericIntersection<A>(_:)( uint64_t isStackAllocationSafe, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = (unint64_t *)isStackAllocationSafe;
  v19[1] = *(__objc2_class ***)MEMORY[0x1895F89C0];
  char v12 = *(_BYTE *)(a2 + 32);
  unint64_t v13 = (unint64_t)((1LL << v12) + 63) >> 6;
  size_t v14 = 8 * v13;
  if ((v12 & 0x3Fu) <= 0xD
    || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    MEMORY[0x1895F8858](isStackAllocationSafe);
    uint64_t v15 = (int64x2_t *)((char *)v19 - ((v14 + 15) & 0x3FFFFFFFFFFFFFF0LL));
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v13, v15);
    closure #1 in _NativeSet.genericIntersection<A>(_:)( (unint64_t *)v15,  v13,  v11,  (unint64_t *)a2,  a3,  a4,  a5,  a6,  v19);
    swift_release(a2);
    return v19[0];
  }

  else
  {
    unint64_t v17 = (int64x2_t *)swift_slowAlloc(v14, 0xFFFFFFFFFFFFFFFFLL);
    specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, v13, v17);
    closure #1 in _NativeSet.genericIntersection<A>(_:)( (unint64_t *)v17,  v13,  v11,  (unint64_t *)a2,  a3,  a4,  a5,  a6,  v19);
    swift_release(a2);
    swift_slowDealloc(v17);
    return v19[0];
  }

__objc2_class **closure #1 in _NativeSet.genericIntersection<A>(_:)@<X0>( unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, unint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, __objc2_class ***a9@<X8>)
{
  unint64_t v54 = a9;
  uint64_t v67 = a3;
  char v68 = a4;
  uint64_t v53 = a2;
  int64_t v56 = a1;
  uint64_t v69 = *(void **)(a5 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](a1);
  uint64_t v65 = (char *)&v51 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v70 = (char *)&v51 - v15;
  uint64_t v19 = type metadata accessor for Optional(0LL, v18, v16, v17);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v51 - v21;
  uint64_t v23 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v51 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a8,  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v52 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v28 = (char *)&v51 - v27;
  (*(void (**)(char *, unint64_t *, uint64_t))(v23 + 16))(v25, v67, a6);
  (*(void (**)(uint64_t, uint64_t))(a8 + 32))(a6, a8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a8,  a6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int64_t v30 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v63 = v28;
  unint64_t v64 = AssociatedTypeWitness;
  uint64_t v61 = v30;
  unint64_t v62 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v30)(AssociatedTypeWitness);
  unint64_t v60 = (uint64_t (*)(char *, uint64_t, uint64_t))v69[6];
  int v31 = v60(v22, 1LL, a5);
  uint64_t v55 = 0LL;
  if (v31 == 1)
  {
LABEL_2:
    (*(void (**)(char *, unint64_t))(v52 + 8))(v63, v64);
    uint64_t v32 = v68;
    swift_retain(v68, v33, v34, v35);
    uint64_t result = _NativeSet.extractSubset(using:count:)(v56, v53, v55, (uint64_t)v32, a5, a7);
    *unint64_t v54 = result;
    return result;
  }

  uint64_t v55 = 0LL;
  unint64_t v57 = (void (*)(char *, char *, uint64_t))v69[4];
  int64_t v58 = v22;
  uint64_t v67 = v68 + 7;
  uint64_t v59 = a7;
  v57(v70, v22, a5);
  while (1)
  {
    int64_t v39 = v68;
    uint64_t v40 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(a7 + 32))(v68[5], a5, a7);
    uint64_t v41 = -1LL << *((_BYTE *)v39 + 32);
    unint64_t v42 = v40 & ~v41;
    int64_t v37 = (void (*)(char *, uint64_t))v69[1];
LABEL_5:
    v37(v70, a5);
    unint64_t v38 = v58;
    a7 = v59;
LABEL_6:
    v61(v64, v62);
    v57(v70, v38, a5);
  }

  uint64_t v66 = ~v41;
  uint64_t v43 = *(void *)(a7 + 8);
  unint64_t v44 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v43 + 8);
  uint64_t v45 = v69[9];
  uint64_t v46 = (void (*)(char *, unint64_t, uint64_t))v69[2];
  while (1)
  {
    char v47 = v65;
    v46(v65, v68[6] + v45 * v42, a5);
    char v48 = v44(v47, v70, a5, v43);
    int64_t v37 = (void (*)(char *, uint64_t))v69[1];
    v37(v47, a5);
    if ((v48 & 1) != 0) {
      break;
    }
    unint64_t v42 = (v42 + 1) & v66;
  }

  uint64_t result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v37)(v70, a5);
  uint64_t v49 = (v42 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  uint64_t v50 = *(unint64_t *)((char *)v56 + v49);
  *(unint64_t *)((char *)v56 + v49) = v50 | (1LL << v42);
  unint64_t v38 = v58;
  if ((v50 & (1LL << v42)) != 0)
  {
    a7 = v59;
    goto LABEL_6;
  }

  a7 = v59;
  if (!__OFADD__(v55, 1LL))
  {
    ++v55;
    goto LABEL_6;
  }

  __break(1u);
  return result;
}

uint64_t _SwiftNewtypeWrapper<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a1,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  size_t v10 = (char *)&v13 - v9;
  (*(void (**)(uint64_t, uint64_t))(v6 + 24))(a1, v6);
  uint64_t v11 = (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 16))(AssociatedTypeWitness, a4);
  (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
  return v11;
}

uint64_t _SwiftNewtypeWrapper<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v12 = (char *)&v14 - v11;
  (*(void (**)(uint64_t, uint64_t))(v8 + 24))(a2, v8);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(a5 + 24))(a1, AssociatedTypeWitness, a5);
  return (*(uint64_t (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
}

uint64_t _SwiftNewtypeWrapper<>._rawHashValue(seed:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v12 = (char *)&v15 - v11;
  (*(void (**)(uint64_t, uint64_t))(v8 + 24))(a2, v8);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(a5 + 32))(a1, AssociatedTypeWitness, a5);
  (*(void (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
  return v13;
}

double _SwiftNewtypeWrapper._toCustomAnyHashable()@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0LL;
  double result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return result;
}

uint64_t _SwiftNewtypeWrapper<>._toCustomAnyHashable()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  v10[0] = a1;
  v10[1] = a2;
  v10[2] = a3;
  v10[3] = a4;
  a5[3] = type metadata accessor for _NewtypeWrapperAnyHashableBox(0LL, (uint64_t)v10);
  a5[4] = &protocol witness table for _NewtypeWrapperAnyHashableBox<A>;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(a5);
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)(a1 - 8) + 32LL))( boxed_opaque_existential_0Tm,  v5,  a1);
}

uint64_t _NewtypeWrapperAnyHashableBox._canonicalBox.getter(void *a1)
{
  uint64_t v2 = *(void *)(a1[4] + 8LL);
  uint64_t v3 = a1[2];
  unint64_t AssociatedTypeWitness = (uint64_t (***)())swift_getAssociatedTypeWitness( 0LL,  (const char *)v2,  v3,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v6 = (char *)&v11[-1] - v5;
  (*(void (**)(uint64_t, uint64_t))(v2 + 24))(v3, v2);
  AnyHashable.init<A>(_:)((uint64_t)v6, AssociatedTypeWitness, a1[5], (uint64_t)v11);
  uint64_t v7 = v12;
  uint64_t v8 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  (*(void (**)(uint64_t, uint64_t))(v8 + 8))(v7, v8);
  return __swift_destroy_boxed_opaque_existential_1Tm(v11);
}

uint64_t _ConcreteHashableBox._base.getter@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  a2[3] = v3;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(a2);
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)(v3 - 8) + 16LL))( boxed_opaque_existential_0Tm,  v2,  v3);
}

uint64_t _NewtypeWrapperAnyHashableBox._unbox<A>()@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = v3;
  unint64_t v44 = a3;
  uint64_t v7 = *(swift **)(a1 + 16);
  uint64_t v40 = *(const char **)(*(void *)(a1 + 32) + 8LL);
  unint64_t AssociatedTypeWitness = (swift *)swift_getAssociatedTypeWitness( 0LL,  v40,  (uint64_t)v7,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64_t v39 = (uint64_t *)((char *)&v35 - v9);
  uint64_t v10 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v8);
  unint64_t v42 = (char *)&v35 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = type metadata accessor for Optional(0LL, (uint64_t)a2, v12, v13);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v35 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v35 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (uint64_t *)((char *)&v35 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *, uint64_t, swift *))(v24 + 16))(v23, v4, v7);
  uint64_t v36 = v7;
  int v25 = swift_dynamicCast(v21, v23, v7, a2, 6uLL);
  uint64_t v26 = *((void *)a2 - 1);
  uint64_t v43 = *(void (**)(char *, void, uint64_t, const char *))(v26 + 56);
  v43(v21, v25 ^ 1u, 1LL, a2);
  uint64_t v27 = v10;
  unint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  uint64_t v29 = v42;
  v28(v42, v4, a1);
  uint64_t v37 = v15;
  uint64_t v38 = v14;
  (*(void (**)(char *, char *, uint64_t))(v15 + 32))(v18, v21, v14);
  if ((*(unsigned int (**)(char *, uint64_t, const char *))(v26 + 48))(v18, 1LL, a2) == 1)
  {
    int64_t v30 = v39;
    (*((void (**)(swift *))v40 + 3))(v36);
    (*(void (**)(char *, uint64_t))(v27 + 8))(v29, a1);
    int v31 = v44;
    int v32 = swift_dynamicCast(v44, v30, AssociatedTypeWitness, a2, 6uLL);
    v43(v31, v32 ^ 1u, 1LL, a2);
    return (*(uint64_t (**)(char *, uint64_t))(v37 + 8))(v18, v38);
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v27 + 8))(v29, a1);
    uint64_t v34 = v44;
    (*(void (**)(char *, char *, const char *))(v26 + 32))(v44, v18, a2);
    return ((uint64_t (*)(char *, void, uint64_t, const char *))v43)(v34, 0LL, 1LL, a2);
  }

uint64_t _NewtypeWrapperAnyHashableBox._downCastConditional<A>(into:)(char *a1, uint64_t a2, const char *a3)
{
  uint64_t v41 = a1;
  uint64_t v5 = *(swift **)(a2 + 16);
  uint64_t v40 = *(const char **)(*(void *)(a2 + 32) + 8LL);
  unint64_t AssociatedTypeWitness = (swift *)swift_getAssociatedTypeWitness( 0LL,  v40,  (uint64_t)v5,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v7 = (uint64_t *)((char *)&v36 - v6);
  uint64_t v39 = type metadata accessor for Optional(0LL, (uint64_t)a3, v8, v9);
  uint64_t v10 = *(void *)(v39 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v39);
  uint64_t v13 = (char *)&v36 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v36 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (uint64_t *)((char *)&v36 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v20 = *((void *)a3 - 1);
  uint64_t v21 = MEMORY[0x1895F8858](v17);
  uint64_t v37 = (char *)&v36 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v21);
  uint64_t v24 = (char *)&v36 - v23;
  (*(void (**)(uint64_t *, uint64_t, swift *))(v25 + 16))(v19, v3, v5);
  int v26 = swift_dynamicCast(v16, v19, v5, a3, 6uLL);
  uint64_t v27 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v20 + 56);
  if (v26)
  {
    uint64_t v28 = 1LL;
    v27(v16, 0LL, 1LL, a3);
    uint64_t v29 = *(void (**)(char *, char *, const char *))(v20 + 32);
    v29(v24, v16, a3);
    v29(v41, v24, a3);
  }

  else
  {
    v27(v16, 1LL, 1LL, a3);
    int64_t v30 = *(void (**)(char *, uint64_t))(v10 + 8);
    int v31 = v16;
    uint64_t v32 = v39;
    v30(v31, v39);
    (*((void (**)(swift *))v40 + 3))(v5);
    if (swift_dynamicCast(v13, v7, AssociatedTypeWitness, a3, 6uLL))
    {
      uint64_t v28 = 1LL;
      v27(v13, 0LL, 1LL, a3);
      uint64_t v33 = *(void (**)(char *, char *, const char *))(v20 + 32);
      uint64_t v34 = v37;
      v33(v37, v13, a3);
      v33(v41, v34, a3);
    }

    else
    {
      v27(v13, 1LL, 1LL, a3);
      v30(v13, v32);
      return 0LL;
    }
  }

  return v28;
}

void protocol witness for _AnyHashableBox._isEqual(to:) in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

void protocol witness for _AnyHashableBox._hashValue.getter in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

void protocol witness for _AnyHashableBox._hash(into:) in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

void protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _NewtypeWrapperAnyHashableBox<A>()
{
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _NewtypeWrapperAnyHashableBox<A>@<X0>( const char *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return _NewtypeWrapperAnyHashableBox._unbox<A>()(a2, a1, a3);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _NewtypeWrapperAnyHashableBox<A>( char *a1, const char *a2, uint64_t a3)
{
  return _NewtypeWrapperAnyHashableBox._downCastConditional<A>(into:)(a1, a3, a2);
}

uint64_t _SwiftNewtypeWrapper<>._bridgeToObjectiveC()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v12 - v8;
  (*(void (**)(uint64_t, uint64_t))(v5 + 24))(a1, v5);
  uint64_t v10 = (*(uint64_t (**)(unint64_t, uint64_t))(a3 + 16))(AssociatedTypeWitness, a3);
  (*(void (**)(char *, unint64_t))(v7 + 8))(v9, AssociatedTypeWitness);
  return v10;
}

uint64_t static _SwiftNewtypeWrapper<>._forceBridgeFromObjectiveC(_:result:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v30 = a1;
  uint64_t v31 = a5;
  uint64_t v29 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v29,  a3,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v28 = (char *)&v27 - v9;
  uint64_t v12 = type metadata accessor for Optional(0LL, a3, v10, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v32 = (char *)&v27 - v14;
  uint64_t v17 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v15, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v27 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v27 - v22;
  uint64_t v33 = v13;
  uint64_t v34 = a2;
  (*(void (**)(uint64_t, uint64_t))(v13 + 8))(a2, v12);
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t))(v8 + 56))(v23, 1LL, 1LL, AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, unint64_t))(v31 + 24))(v30, v23, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v18 + 32))(v21, v23, v17);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48))(v21, 1LL, AssociatedTypeWitness) == 1)
  {
    uint64_t v24 = v32;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL))(v32, 1LL, 1LL, a3);
  }

  else
  {
    uint64_t v25 = v28;
    (*(void (**)(char *, char *, unint64_t))(v8 + 32))(v28, v21, AssociatedTypeWitness);
    uint64_t v24 = v32;
    (*((void (**)(char *, uint64_t))v29 + 2))(v25, a3);
  }

  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v33 + 32))(v34, v24, v12);
}

uint64_t static _SwiftNewtypeWrapper<>._conditionallyBridgeFromObjectiveC(_:result:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v31 = a1;
  uint64_t v32 = a5;
  uint64_t v30 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v30,  a3,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v29 = (char *)&v28 - v9;
  uint64_t v12 = type metadata accessor for Optional(0LL, a3, v10, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v33 = (char *)&v28 - v14;
  uint64_t v17 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v15, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v28 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v28 - v22;
  uint64_t v34 = v13;
  uint64_t v35 = a2;
  (*(void (**)(uint64_t, uint64_t))(v13 + 8))(a2, v12);
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t))(v8 + 56))(v23, 1LL, 1LL, AssociatedTypeWitness);
  char v24 = (*(uint64_t (**)(uint64_t, char *, unint64_t))(v32 + 32))(v31, v23, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v18 + 32))(v21, v23, v17);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48))(v21, 1LL, AssociatedTypeWitness) == 1)
  {
    uint64_t v25 = v33;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL))(v33, 1LL, 1LL, a3);
  }

  else
  {
    int v26 = v29;
    (*(void (**)(char *, char *, unint64_t))(v8 + 32))(v29, v21, AssociatedTypeWitness);
    uint64_t v25 = v33;
    (*((void (**)(char *, uint64_t))v30 + 2))(v26, a3);
  }

  (*(void (**)(uint64_t, char *, uint64_t))(v34 + 32))(v35, v25, v12);
  return v24 & 1;
}

uint64_t static _SwiftNewtypeWrapper<>._unconditionallyBridgeFromObjectiveC(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v20 - v11;
  uint64_t v15 = type metadata accessor for Optional(0LL, a2, v13, v14);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v20 - v16;
  (*(void (**)(uint64_t, unint64_t, uint64_t))(a4 + 40))(a1, AssociatedTypeWitness, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, v9);
  uint64_t v18 = *(void *)(a2 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v18 + 48))(v17, 1LL, a2) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/NewtypeWrapper.swift",  26LL,  2,  0x8DuLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v18 + 32))(a5, v17, a2);
}

uint64_t _SwiftNewtypeWrapper<>._bridgeToObjectiveC()(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)(a2 + 8) + 24LL))(&v3);
  return v3;
}

uint64_t static _SwiftNewtypeWrapper<>._forceBridgeFromObjectiveC(_:result:)( void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, a3, a3, a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8LL))(a2, v8);
  uint64_t v15 = a1;
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v10 = *(uint64_t (**)(void **, uint64_t, uint64_t))(v9 + 16);
  swift_unknownObjectRetain(a1, v11, v12, v13);
  return v10(&v15, a3, v9);
}

BOOL static _SwiftNewtypeWrapper<>._conditionallyBridgeFromObjectiveC(_:result:)( void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, a3, a3, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v20 - v10;
  uint64_t v12 = *(void (**)(uint64_t, uint64_t))(v9 + 8);
  v12(a2, v8);
  uint64_t v21 = a1;
  uint64_t v13 = *(void *)(a4 + 8);
  uint64_t v14 = *(void (**)(void **, uint64_t, uint64_t))(v13 + 16);
  swift_unknownObjectRetain(a1, v15, v16, v17);
  v14(&v21, a3, v13);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, a2, v8);
  BOOL v18 = (*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 48LL))(v11, 1LL, a3) != 1;
  v12((uint64_t)v11, v8);
  return v18;
}

uint64_t static _SwiftNewtypeWrapper<>._unconditionallyBridgeFromObjectiveC(_:)@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = type metadata accessor for Optional(0LL, a2, a3, a4);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v19 - v13;
  if (!a1
    || (uint64_t v20 = a1,
        uint64_t v15 = *(void *)(a3 + 8),
        uint64_t v16 = *(void (**)(void **, uint64_t, uint64_t))(v15 + 16),
        swift_unknownObjectRetain(a1, v10, v11, v12),
        v16(&v20, a2, v15),
        uint64_t v17 = *(void *)(a2 - 8),
        (*(unsigned int (**)(char *, uint64_t, uint64_t))(v17 + 48))(v14, 1LL, a2) == 1))
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/NewtypeWrapper.swift",  26LL,  2,  0xADuLL,  0);
  }

  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v17 + 32))(a5, v14, a2);
}

uint64_t static UInt32.% infix(_:_:)(unsigned int a1, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x1AB6uLL,  0);
  }
  return a1 % a2;
}

unint64_t specialized Unicode._InternalNFC.Iterator.next()()
{
  uint64_t v1 = *(__objc2_class ***)v0;
  if (*(void *)(*(void *)v0 + 16LL))
  {
    if ((*(_BYTE *)(v0 + 8) & 1) == 0)
    {
      specialized MutableCollection<>.reverse()();
      *(_BYTE *)(v0 + 8) = 1;
    }

    int v2 = specialized RangeReplaceableCollection<>.removeLast()();
    LOBYTE(v3) = 0;
    LODWORD(v4) = v2;
    return v4 | ((unint64_t)v3 << 32);
  }

  *(_BYTE *)(v0 + 8) = 0;
  unint64_t v5 = specialized Unicode._InternalNFD.Iterator.next()();
  if ((v5 & 0x1000000000000LL) != 0)
  {
LABEL_34:
    LODWORD(v4) = *(_DWORD *)(v0 + 12);
    LOBYTE(v3) = *(_BYTE *)(v0 + 16);
    *(_DWORD *)(v0 + 12) = 0;
    *(_BYTE *)(v0 + 16) = 1;
    return v4 | ((unint64_t)v3 << 32);
  }

  unint64_t v4 = v5;
  while (1)
  {
    while ((*(_BYTE *)(v0 + 16) & 1) != 0)
    {
      if ((v4 & 0x7F800000000LL) != 0)
      {
        LOBYTE(v3) = 0;
        return v4 | ((unint64_t)v3 << 32);
      }

      LODWORD(v6) = v4;
LABEL_10:
      *(_DWORD *)(v0 + 12) = v6;
      *(_BYTE *)(v0 + 16) = 0;
      unint64_t v4 = specialized Unicode._InternalNFD.Iterator.next()();
      if ((v4 & 0x1000000000000LL) != 0) {
        goto LABEL_34;
      }
    }

    unsigned int v7 = *(_DWORD *)(v0 + 12);
    uint64_t v8 = v1[2];
    if (!v8) {
      break;
    }
    unsigned int v3 = (v4 >> 35);
    if (v3 > (WORD2(v1[(void)v8 + 3]) >> 3))
    {
      if (v4 >= 0x300 && (v4 & 0x600000000LL) != 0)
      {
        unint64_t v6 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v0 + 12), v4);
        if ((v6 & 0x100000000LL) == 0) {
          goto LABEL_10;
        }
        LODWORD(v6) = _swift_stdlib_getComposition(v7, v4);
        if ((_DWORD)v6 != -1) {
          goto LABEL_10;
        }
      }

      goto LABEL_24;
    }

    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v1);
    *(void *)uint64_t v0 = v1;
    if (!isUniquelyReferenced_nonNull_native)
    {
      int64_t v14 = (int64_t)&v8->isa + 1;
      goto LABEL_33;
    }

Swift::Unicode::Scalar_optional __swiftcall Unicode._InternalNFC.Iterator.next()()
{
  unsigned int v3 = *(__objc2_class ***)v2;
  if (*(void *)(*(void *)v2 + 16LL))
  {
    if ((*(_BYTE *)(v2 + 8) & 1) == 0)
    {
      specialized MutableCollection<>.reverse()();
      *(_BYTE *)(v2 + 8) = 1;
    }

    unsigned int v4 = specialized RangeReplaceableCollection<>.removeLast()();
    LOBYTE(v5) = 0;
    return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
  }

  *(_BYTE *)(v2 + 8) = 0;
  type metadata accessor for Unicode._InternalNFD.Iterator(0LL, *(void *)(v0 + 16), *(void *)(v0 + 24), v1);
  Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional v20 = Unicode._InternalNFD.Iterator.next()();
  if ((*(void *)&v20.value.scalar._value & 0x1000000000000LL) != 0)
  {
LABEL_35:
    unsigned int v4 = *(_DWORD *)(v2 + 12);
    LOBYTE(v5) = *(_BYTE *)(v2 + 16);
    *(_DWORD *)(v2 + 12) = 0;
    *(_BYTE *)(v2 + 16) = 1;
    return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
  }

  unint64_t v6 = *(void *)&v20.value.scalar._value;
  for (unint64_t i = (char *)v3 + 36; ; unint64_t i = (char *)v3 + 36)
  {
    while ((*(_BYTE *)(v2 + 16) & 1) != 0)
    {
      if ((v6 & 0x7F800000000LL) != 0)
      {
        LOBYTE(v5) = 0;
        unsigned int v4 = v6;
        return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
      }

      LODWORD(v8) = v6;
LABEL_10:
      *(_DWORD *)(v2 + 12) = v8;
      *(_BYTE *)(v2 + 16) = 0;
      *(Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional *)&__int128 v9 = Unicode._InternalNFD.Iterator.next()();
      unint64_t v6 = v9;
      if ((v9 & 0x1000000000000LL) != 0) {
        goto LABEL_35;
      }
    }

    unsigned int v4 = *(_DWORD *)(v2 + 12);
    unint64_t v10 = v3[2];
    if (!v10) {
      break;
    }
    unsigned int v5 = (v6 >> 35);
    if (v5 > (*(unsigned __int16 *)&i[8 * (void)v10 - 8] >> 3))
    {
      if ((v6 & 0x600000000LL) != 0 && v6 >= 0x300)
      {
        unint64_t v8 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v2 + 12), v6);
        if ((v8 & 0x100000000LL) == 0) {
          goto LABEL_10;
        }
        LODWORD(v8) = _swift_stdlib_getComposition(v4, v6);
        if ((_DWORD)v8 != -1) {
          goto LABEL_10;
        }
      }

      goto LABEL_22;
    }

    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v3);
    *(void *)uint64_t v2 = v3;
    if (!isUniquelyReferenced_nonNull_native)
    {
      int64_t v17 = (int64_t)&v10->isa + 1;
LABEL_31:
      unsigned int v3 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v17,  1,  (uint64_t)v3);
      *(void *)uint64_t v2 = v3;
    }

unint64_t specialized Unicode._InternalNFD.Iterator.next()()
{
  uint64_t v1 = *(void *)v0;
  if (*(void *)(*(void *)v0 + 16LL)) {
    goto LABEL_2;
  }
  *(_BYTE *)(v0 + 8) = 0;
  v6._Swift::UInt64 rawBits = *(void *)(v0 + 16);
  unint64_t v7 = *(void *)(v0 + 32);
  Swift::UInt64 v8 = v6._rawBits >> 14;
  if (v6._rawBits >> 14 >= v7 >> 14) {
    goto LABEL_82;
  }
  do
  {
    unint64_t v9 = *(void *)(v0 + 24);
    uint64_t v11 = *(void *)(v0 + 40);
    uint64_t v10 = *(void *)(v0 + 48);
    char v12 = (v10 & 0x1000000000000000LL) == 0 || (v11 & 0x800000000000000LL) != 0;
    uint64_t v13 = v6._rawBits & 0xC;
    uint64_t v14 = 4LL << v12;
    if ((v6._rawBits & 1) != 0 && v13 != v14)
    {
      if (v8 >= v7 >> 14 || v8 < v9 >> 14)
      {
        unint64_t v42 = 143LL;
        goto LABEL_81;
      }

Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional __swiftcall Unicode._InternalNFD.Iterator.next()()
{
  void (*v36)(void *__return_ptr, unint64_t, uint64_t);
  unint64_t *v37;
  void v38[4];
  unint64_t v39;
  Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional result;
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v5 = *(void *)(v0 + 16);
  uint64_t v4 = *(const char **)(v0 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v9 = (char *)&v33 - v8;
  if (!*(void *)(*(void *)v2 + 16LL))
  {
    *(_BYTE *)(v2 + 8) = 0;
    uint64_t v10 = *(int *)(v3 + 40);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UnicodeScalarView: BidirectionalCollection);
    unint64_t v12 = *(void *)(v2 + 16);
    unint64_t v37 = (unint64_t *)(v2 + 16);
    uint64_t v13 = v2 + v10;
    uint64_t v14 = *(void *)(AssociatedConformanceWitness + 8);
    uint64_t v36 = *(void (**)(void *__return_ptr, unint64_t, uint64_t))(v14 + 72);
    v36(v38, AssociatedTypeWitness, v14);
    if (v12 >> 14 < v38[0] >> 14)
    {
      uint64_t v15 = v7;
      Swift::UInt64 v16 = *(uint64_t (**)(void *, unint64_t *, unint64_t, uint64_t))(v14 + 80);
      uint64_t v34 = v7;
      uint64_t v35 = v16;
      while (1)
      {
        uint64_t v39 = v12;
        int64_t v17 = (void (*)(void *, void))v35(v38, &v39, AssociatedTypeWitness, v14);
        uint64_t v19 = *v18;
        v17(v38, 0LL);
        uint64_t v20 = 0LL;
        if (v19 >= 0xC0
          && (int NormData = _swift_stdlib_getNormData(v19),
              uint64_t v20 = NormData | ((v19 - 44032) >> 2 < 0xAE9),
              (NormData & 0x7F8) != 0))
        {
          int v21 = 0;
        }

        else
        {
          if (*(void *)(*(void *)v2 + 16LL)) {
            goto LABEL_22;
          }
          int v21 = 1;
        }

        (*(void (**)(char *, uint64_t, unint64_t))(v15 + 16))(v9, v13, AssociatedTypeWitness);
        (*(void (**)(unint64_t *, unint64_t, uint64_t))(v14 + 192))( v37,  AssociatedTypeWitness,  v14);
        (*(void (**)(char *, unint64_t))(v15 + 8))(v9, AssociatedTypeWitness);
        if ((v20 & 1) == 0) {
          break;
        }
        else {
          Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)( (Swift::Unicode::Scalar)v19,  (Swift::Unicode::_NormData)v20);
        }
LABEL_5:
        unint64_t v12 = *v37;
        v36(v38, AssociatedTypeWitness, v14);
        if (v12 >> 14 >= v38[0] >> 14) {
          goto LABEL_22;
        }
      }

      if (v21)
      {
        unsigned __int8 v31 = 0;
        uint64_t v32 = v19 | (v20 << 32);
        goto LABEL_26;
      }

uint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._InternalNFC<A>.Iterator@<X0>( uint64_t a1@<X8>)
{
  *(Swift::Unicode::Scalar_optional *)&uint64_t result = Unicode._InternalNFC.Iterator.next()();
  *(_DWORD *)a1 = result;
  *(_BYTE *)(a1 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t Unicode._InternalNFC.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  void (*v11)(uint64_t *__return_ptr, unint64_t *, uint64_t);
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = type metadata accessor for Unicode._InternalNFD(0LL, v4, v5, a2);
  MEMORY[0x1895F8858](v6);
  uint64_t v8 = (char *)&v19 - v7;
  (*(void (**)(uint64_t, uint64_t))(v5 + 136))(v4, v5);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  v4,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v10 = *(void *)(swift_getAssociatedConformanceWitness( v5,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UnicodeScalarView: BidirectionalCollection)
                  + 8);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, unint64_t *, uint64_t))(v10 + 64);
  unint64_t v12 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v11(&v20, v12, v10);
  uint64_t v13 = v20;
  uint64_t v15 = a3 + *(int *)(type metadata accessor for Unicode._InternalNFC.Iterator(0LL, v4, v5, v14) + 40);
  int64_t v17 = type metadata accessor for Unicode._InternalNFD.Iterator(0LL, v4, v5, v16);
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, unint64_t *))(*(v12 - 1) + 32))( v15 + *(int *)(v17 + 40),  v8,  v12);
  *(void *)uint64_t v15 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(v15 + 8) = 0;
  *(void *)(v15 + 16) = v13;
  *(void *)a3 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

uint64_t Unicode._InternalNFD.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void (*v8)(uint64_t *__return_ptr, unint64_t *, uint64_t);
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v7 = *(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for StringProtocol,  (uint64_t)&associated conformance descriptor for StringProtocol.StringProtocol.UnicodeScalarView: BidirectionalCollection)
                 + 8);
  uint64_t v8 = *(void (**)(uint64_t *__return_ptr, unint64_t *, uint64_t))(v7 + 64);
  unint64_t v9 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v8(&v14, v9, v7);
  uint64_t v10 = v14;
  unint64_t v12 = type metadata accessor for Unicode._InternalNFD.Iterator(0LL, v5, (uint64_t)v4, v11);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t *))(*(v9 - 1) + 16))( a2 + *(int *)(v12 + 40),  v2,  v9);
  *(void *)a2 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = v10;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>( a1,  a2,  (void (*)(void))Unicode._InternalNFC.makeIterator());
}

__objc2_class **specialized Unicode._InternalNFD.Iterator.decomposeHangul(_:)(int a1)
{
  unsigned int v2 = a1 - 44032;
  unsigned int v3 = (a1 - 44032) / 0x24Cu;
  uint64_t v4 = *v1;
  uint64_t result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = v4;
  if ((result & 1) == 0)
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v4 + 16) + 1LL,  1,  v4);
    uint64_t v4 = (uint64_t)result;
    *uint64_t v1 = (uint64_t)result;
  }

  unint64_t v7 = *(void *)(v4 + 16);
  unint64_t v6 = *(void *)(v4 + 24);
  unint64_t v8 = v7 + 1;
  if (v7 >= v6 >> 1)
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v6 > 1),  v7 + 1,  1,  v4);
    uint64_t v4 = (uint64_t)result;
  }

  *(void *)(v4 + 16) = v8;
  uint64_t v9 = v4 + 8 * v7;
  *(_DWORD *)(v9 + 32) = v3 + 4352;
  *(_WORD *)(v9 + ++*(_DWORD *)(v0 + 36) = 0;
  unsigned int v10 = (unsigned __int16)(v2 - 588 * v3) / 0x1Cu + 4449;
  *uint64_t v1 = v4;
  unint64_t v11 = *(void *)(v4 + 24);
  unint64_t v12 = v7 + 2;
  if ((uint64_t)(v7 + 2) > (uint64_t)(v11 >> 1))
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v11 > 1),  v7 + 2,  1,  v4);
    uint64_t v4 = (uint64_t)result;
  }

  *(void *)(v4 + 16) = v12;
  uint64_t v13 = v4 + 8 * v8;
  *(_DWORD *)(v13 + 32) = v10;
  *(_WORD *)(v13 + ++*(_DWORD *)(v0 + 36) = 4;
  *uint64_t v1 = v4;
  if (v2 % 0x1C)
  {
    unsigned int v14 = v2 % 0x1C + 4519;
    unint64_t v15 = *(void *)(v4 + 24);
    if ((uint64_t)(v7 + 3) > (uint64_t)(v15 >> 1))
    {
      uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v15 > 1),  v7 + 3,  1,  v4);
      uint64_t v4 = (uint64_t)result;
    }

    *(void *)(v4 + 16) = v7 + 3;
    uint64_t v16 = v4 + 8 * v12;
    *(_DWORD *)(v16 + 32) = v14;
    *(_WORD *)(v16 + ++*(_DWORD *)(v0 + 36) = 4;
    *uint64_t v1 = v4;
  }

  return result;
}

uint64_t specialized Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)(int a1, __int16 a2)
{
  uint64_t result = _swift_stdlib_getDecompositionEntry(a1);
  if ((result & 0x3FFFF) == a1)
  {
    uint64_t v6 = _swift_stdlib_nfd_decomp[(unint64_t)result >> 18];
    unint64_t v7 = (char *)(((unint64_t)result >> 18) + 0x181812291LL);
    uint64_t v8 = *v2;
    do
    {
      int v9 = *v7;
      if (*v7 < 0) {
        __asm { BR              X9 }
      }

      if (v6-- == 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }
      if (v6 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      uint64_t result = swift_isUniquelyReferenced_nonNull_native(v8);
      if ((result & 1) == 0)
      {
        uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v8 + 16) + 1LL,  1,  v8);
        uint64_t v8 = result;
      }

      unint64_t v12 = *(void *)(v8 + 16);
      unint64_t v11 = *(void *)(v8 + 24);
      if (v12 >= v11 >> 1)
      {
        uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v11 > 1),  v12 + 1,  1,  v8);
        uint64_t v8 = result;
      }

      ++v7;
      *(void *)(v8 + 16) = v12 + 1;
      uint64_t v13 = v8 + 8 * v12;
      *(_DWORD *)(v13 + 32) = v9;
      *(_WORD *)(v13 + ++*(_DWORD *)(v0 + 36) = 0;
    }

    while (v6 > 0);
  }

  else
  {
    uint64_t v8 = *v2;
    uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v2);
    *unsigned int v2 = v8;
    if ((result & 1) == 0)
    {
      uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v8 + 16) + 1LL,  1,  v8);
      uint64_t v8 = result;
      *unsigned int v2 = result;
    }

    unint64_t v15 = *(void *)(v8 + 16);
    unint64_t v14 = *(void *)(v8 + 24);
    if (v15 >= v14 >> 1)
    {
      uint64_t result = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v14 > 1),  v15 + 1,  1,  v8);
      uint64_t v8 = result;
    }

    *(void *)(v8 + 16) = v15 + 1;
    uint64_t v16 = v8 + 8 * v15;
    *(_DWORD *)(v16 + 32) = a1;
    *(_WORD *)(v16 + ++*(_DWORD *)(v0 + 36) = a2;
  }

  *unsigned int v2 = v8;
  return result;
}

Swift::Void __swiftcall Unicode._InternalNFD.Iterator.decomposeSlow(_:with:)( Swift::Unicode::Scalar _, Swift::Unicode::_NormData with)
{
  unsigned int DecompositionEntry = _swift_stdlib_getDecompositionEntry(_._value);
  if ((DecompositionEntry & 0x3FFFF) == _._value)
  {
    uint64_t v7 = _swift_stdlib_nfd_decomp[(unint64_t)DecompositionEntry >> 18];
    if (_swift_stdlib_nfd_decomp[(unint64_t)DecompositionEntry >> 18])
    {
      uint64_t v8 = ((unint64_t)DecompositionEntry >> 18) + 0x181812291LL;
      int v9 = (__objc2_class **)*v2;
      while (1)
      {
        unsigned int v10 = _decodeScalar(_:startingAt:)(v8, v6, 0LL);
        if (v7 < v11) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
        }
        if (v8) {
          v8 += v11;
        }
        else {
          uint64_t v8 = 0LL;
        }
        v7 -= v11;
        if (v7 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
        unsigned int v12 = v10;
        if (v7 && !v8) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
        }
        if (v10 >= 0x300)
        {
          __int16 v13 = _swift_stdlib_getNormData(v10) | ((v10 - 44032) >> 2 < 0xAE9);
          if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v9)) {
LABEL_18:
          }
            int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v9[2]->isa + 1,  1,  (uint64_t)v9);
        }

        else
        {
          __int16 v13 = 0;
        }

        unint64_t v15 = (unint64_t)v9[2];
        unint64_t v14 = (unint64_t)v9[3];
        if (v15 >= v14 >> 1) {
          int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v14 > 1),  v15 + 1,  1,  (uint64_t)v9);
        }
        void v9[2] = (__objc2_class *)(v15 + 1);
        uint64_t v16 = &v9[v15];
        *((_DWORD *)v16 + 8) = v12;
        *((_WORD *)v16 + 18) = v13;
        if (!v7) {
          goto LABEL_24;
        }
      }
    }
  }

  else
  {
    int v9 = (__objc2_class **)*v2;
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v2);
    *unsigned int v2 = (uint64_t)v9;
    if (!isUniquelyReferenced_nonNull_native)
    {
      int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v9[2]->isa + 1,  1,  (uint64_t)v9);
      *unsigned int v2 = (uint64_t)v9;
    }

    unint64_t v19 = (unint64_t)v9[2];
    unint64_t v18 = (unint64_t)v9[3];
    if (v19 >= v18 >> 1) {
      int v9 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v18 > 1),  v19 + 1,  1,  (uint64_t)v9);
    }
    void v9[2] = (__objc2_class *)(v19 + 1);
    uint64_t v20 = &v9[v19];
    *((Swift::Unicode::Scalar *)v20 + 8) = _;
    *((Swift::Unicode::_NormData *)v20 + 18) = with;
LABEL_24:
    *unsigned int v2 = (uint64_t)v9;
  }

uint64_t static UInt32./ infix(_:_:)(unsigned int a1, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x19E2uLL,  0);
  }
  return a1 / a2;
}

uint64_t _decodeScalar(_:startingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(char *)(a1 + a3);
  uint64_t result = *(unsigned __int8 *)(a1 + a3);
  if (v3 < 0) {
    return ((uint64_t (*)(void))((char *)&loc_18158811C
  }
                              + 4 * byte_18180011F[(__clz(result ^ 0xFF) - 24) - 1]))();
  return result;
}

uint64_t sub_181588150@<X0>(char a1@<W0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return *(_BYTE *)(a2 + a3 + 1) & 0x3F | ((a1 & 0x1F) << 6);
}

uint64_t sub_18158816C@<X0>(char a1@<W0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return ((a1 & 0xF) << 12) | ((*(_BYTE *)(a2 + a3 + 1) & 0x3F) << 6) | *(_BYTE *)(a2 + a3 + 2) & 0x3Fu;
}

uint64_t sub_181588190@<X0>(char a1@<W0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return ((a1 & 0xF) << 18) | ((*(_BYTE *)(a2 + a3 + 1) & 0x3F) << 12) | ((*(_BYTE *)(a2 + a3 + 2) & 0x3F) << 6) | *(_BYTE *)(a2 + a3 + 3) & 0x3Fu;
}

BOOL static String.Index.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 >> 14 < a2 >> 14;
}

Swift::Void __swiftcall Unicode._NormDataBuffer.sort()()
{
  uint64_t v1 = (__objc2_class **)*v0;
  unint64_t v2 = *(void *)(*v0 + 16);
  if (v2 >= 2)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
    uint64_t *v0 = (uint64_t)v1;
    if (!isUniquelyReferenced_nonNull_native) {
      uint64_t v1 = specialized _ArrayBuffer._consumeAndCreateNew()((uint64_t)v1);
    }
    uint64_t *v0 = (uint64_t)v1;
    uint64_t v4 = (_WORD *)v1 + 22;
    for (unint64_t i = 1LL; i != v2; ++i)
    {
      unint64_t v6 = (unint64_t)v1[2];
      if (i >= v6)
      {
LABEL_16:
        unint64_t v14 = 675LL;
        goto LABEL_17;
      }

      unint64_t v7 = i - 1;
      if ((WORD2(v1[i + 4]) >> 3) < (WORD2(v1[i + 3]) >> 3))
      {
        uint64_t v8 = v4;
        while (1)
        {
          if (v7 + 1 >= v6 || v7 >= v6) {
            goto LABEL_16;
          }
          int v9 = *((_DWORD *)v8 - 1);
          __int16 v10 = *v8;
          __int16 v11 = *(v8 - 4);
          *((_DWORD *)v8 - _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = *((_DWORD *)v8 - 3);
          *uint64_t v8 = v11;
          *((_DWORD *)v8 - 3) = v9;
          *(v8 - 4) = v10;
          if (!v7) {
            goto LABEL_5;
          }
          unint64_t v6 = (unint64_t)v1[2];
          if (v7 >= v6) {
            goto LABEL_16;
          }
          unsigned int v12 = (unsigned __int16)*(v8 - 4);
          unsigned int v13 = (unsigned __int16)*(v8 - 8);
          v8 -= 4;
          --v7;
        }

        unint64_t v14 = 688LL;
LABEL_17:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  v14,  0);
      }

uint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._InternalNFD<A>.Iterator@<X0>( uint64_t a1@<X8>)
{
  Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional v4 = Unicode._InternalNFD.Iterator.next()();
  *(_DWORD *)a1 = v4.value.scalar._value;
  *(_WORD *)(a1 + 4) = v4.value.normData.rawValue;
  *(_BYTE *)(a1 + 6) = v2 & 1;
  LODWORD(result) = v4.value.scalar._value;
  WORD2(result) = v4.value.normData.rawValue;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFD<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>( a1,  a2,  (void (*)(void))Unicode._InternalNFD.makeIterator());
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Unicode._InternalNFC<A>( uint64_t a1, uint64_t a2, void (*a3)(void))
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v3, a1);
}

uint64_t ObjectIdentifier.debugDescription.getter(unint64_t a1)
{
  uint64_t v3 = specialized static String._createEmpty(withInitialCapacity:)(20LL);
  uint64_t v7 = v3;
  uint64_t v8 = v4;
  uint64_t v203 = v3;
  unint64_t v204 = v4;
  uint64_t v9 = HIBYTE(v4) & 0xF;
  unint64_t i = v3 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000LL) != 0) {
    Swift::Int v11 = HIBYTE(v4) & 0xF;
  }
  else {
    Swift::Int v11 = v3 & 0xFFFFFFFFFFFFLL;
  }
  unsigned int v12 = "ObjectIdentifier(";
  if (!v11 && (v3 & ~v4 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v4);
    uint64_t v203 = 0xD000000000000011LL;
    unint64_t v204 = 0x80000001818B7020LL | 0x8000000000000000LL;
    goto LABEL_86;
  }

  if ((v4 & 0x2000000000000000LL) != 0 && (0x80000001818B7020LL & 0x2000000000000000LL) != 0)
  {
    unint64_t v13 = v9 + ((0x80000001818B7020LL >> 56) & 0xF);
    if (v13 <= 0xF)
    {
      unint64_t i = 0x80000001818B7020LL;
      unint64_t v37 = (0x80000001818B7020LL >> 56) & 0xF;
      if (v37)
      {
        char v61 = 0;
        uint64_t v62 = 0LL;
        unint64_t v38 = v4;
        do
        {
          uint64_t v63 = v9 + v62;
          uint64_t v64 = v62 + 1;
          unint64_t v65 = 0x80000001818B7020LL | 0x8000000000000000LL;
          if (v62 < 8) {
            unint64_t v65 = 0xD000000000000011LL;
          }
          unint64_t v66 = v65 >> (v61 & 0x38);
          char v67 = (8 * v9 + v61) & 0x38;
          uint64_t v68 = (-255LL << v67) - 1;
          unint64_t v69 = (unint64_t)v66 << v67;
          unint64_t v70 = v69 | v68 & v38;
          unint64_t v71 = v69 | v68 & v7;
          if (v63 < 8) {
            uint64_t v7 = v71;
          }
          else {
            unint64_t v38 = v70;
          }
          v61 += 8;
          uint64_t v62 = v64;
        }

        while (v37 != v64);
      }

      else
      {
        unint64_t v38 = v4;
      }

      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(0x80000001818B7020LL | 0x8000000000000000LL);
      unint64_t v72 = 0xA000000000000000LL;
      if (!(v7 & 0x8080808080808080LL | v38 & 0x80808080808080LL)) {
        unint64_t v72 = 0xE000000000000000LL;
      }
      unint64_t v60 = v72 & 0xFF00000000000000LL | (v13 << 56) | v38 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_85;
    }
  }

  uint64_t v14 = 0x80000001818B7020LL | 0x8000000000000000LL;
  if ((0x80000001818B7020LL & 0x2000000000000000LL) != 0) {
    uint64_t v15 = (0x80000001818B7020LL >> 56) & 0xF;
  }
  else {
    uint64_t v15 = 17LL;
  }
  swift_bridgeObjectRetain_n(0x80000001818B7020LL | 0x8000000000000000LL, 2LL, v5, v6);
  if ((0x80000001818B7020LL & 0x1000000000000000LL) != 0) {
    goto LABEL_227;
  }
  swift_bridgeObjectRetain_n(0x80000001818B7020LL | 0x8000000000000000LL, 4LL, v16, v17);
  Swift::Int v1 = v15;
  if ((v8 & 0x1000000000000000LL) != 0) {
    goto LABEL_230;
  }
LABEL_14:
  BOOL v18 = __OFADD__(v11, v1);
  v11 += v1;
  if (v18) {
    goto LABEL_232;
  }
LABEL_15:
  uint64_t v19 = v7 & ~v8;
  if ((v19 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v20 = _StringGuts.nativeUnusedCapacity.getter(v7, v8);
    if ((v21 & 1) != 0) {
      goto LABEL_255;
    }
    if (v11 > 15) {
      goto LABEL_23;
    }
    if ((v8 & 0x2000000000000000LL) == 0)
    {
      if (v20 < v1)
      {
LABEL_48:
        swift_bridgeObjectRelease_n((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL, 5LL);
        if ((v8 & 0x1000000000000000LL) == 0)
        {
          if ((v7 & 0x1000000000000000LL) != 0)
          {
            uint64_t v36 = (unsigned __int8 *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            uint64_t v36 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v8);
            unint64_t i = v33;
          }

          swift_bridgeObjectRetain(v8, v33, v34, v35);
          closure #1 in _StringGuts._convertedToSmall()(v36, i, &v202);
          swift_bridgeObjectRelease(v8);
          unint64_t i = *((void *)&v202 + 1);
          uint64_t v7 = v202;
          goto LABEL_57;
        }

        goto LABEL_250;
      }

LABEL_165:
  swift_bridgeObjectRelease_n(a1, 5LL);
  unint64_t i = v203;
  if (v105) {
    goto LABEL_236;
  }
  while (1)
  {
    v127._Swift::UInt64 rawBits = (v1 << 16) | 1;
    v128._Swift::UInt64 rawBits = 1LL;
    v129._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v128, v127, v7, a1);
    if (v129._rawBits < 0x10000) {
      v129._rawBits |= 3;
    }
    unint64_t v131 = specialized String.init(_:)(v129, v130, v7, a1);
    unint64_t v133 = v132;
    swift_bridgeObjectRelease(a1);
    if ((v133 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v133);
    }

    else if ((v133 & 0x1000000000000000LL) != 0)
    {
      unint64_t v131 = _StringGuts._foreignConvertedToSmall()(v131, v133);
      unint64_t v198 = v197;
      swift_bridgeObjectRelease(v133);
      unint64_t v133 = v198;
    }

    else
    {
      if ((v131 & 0x1000000000000000LL) != 0)
      {
        unint64_t v189 = (unsigned __int8 *)((v133 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v190 = v131 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v189 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v131, v133);
      }

      closure #1 in _StringGuts._convertedToSmall()(v189, v190, &v202);
      swift_bridgeObjectRelease(v133);
      unint64_t v133 = *((void *)&v202 + 1);
      unint64_t v131 = v202;
    }

    uint64_t v134 = HIBYTE(v11) & 0xF;
    uint64_t v135 = HIBYTE(v133) & 0xF;
    Swift::Int v1 = v135 + v134;
    if (v135)
    {
      char v136 = 0;
      unint64_t v137 = 0LL;
      do
      {
        unint64_t v138 = v134 + v137;
        unint64_t v139 = v137 + 1;
        if (v137 >= 8) {
          unint64_t v140 = v133;
        }
        else {
          unint64_t v140 = v131;
        }
        unint64_t v141 = v140 >> (v136 & 0x38);
        char v142 = (8 * v134 + v136) & 0x38;
        uint64_t v143 = (-255LL << v142) - 1;
        unint64_t v144 = (unint64_t)v141 << v142;
        Swift::Int v145 = v144 | v143 & v11;
        unint64_t v146 = v144 | v143 & i;
        if (v138 < 8) {
          unint64_t i = v146;
        }
        else {
          Swift::Int v11 = v145;
        }
        v136 += 8;
        unint64_t v137 = v139;
      }

      while (v135 != v139);
    }

    swift_bridgeObjectRelease(v8);
    swift_bridgeObjectRelease(a1);
    unint64_t v147 = 0xA000000000000000LL;
    if (!(i & 0x8080808080808080LL | v11 & 0x80808080808080LL)) {
      unint64_t v147 = 0xE000000000000000LL;
    }
    uint64_t v203 = i;
    unint64_t v204 = v147 & 0xFF00000000000000LL | (v1 << 56) | v11 & 0xFFFFFFFFFFFFFFLL;
LABEL_187:
    uint64_t v8 = v203;
    a1 = v204;
    unint64_t v149 = HIBYTE(v204) & 0xF;
    if ((v204 & 0x2000000000000000LL) != 0) {
      unint64_t v150 = HIBYTE(v204) & 0xF;
    }
    else {
      unint64_t v150 = v203 & 0xFFFFFFFFFFFFLL;
    }
    if (!v150 && (v203 & ~v204 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v204);
      return 41LL;
    }

    if ((v204 & 0x2000000000000000LL) != 0 && v149 != 15) {
      break;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v103, v104);
    if ((a1 & 0x1000000000000000LL) != 0)
    {
LABEL_233:
      Swift::Int v186 = String.UTF8View._foreignCount()();
      uint64_t v7 = v186 + 1;
      if (!__OFADD__(v186, 1LL))
      {
LABEL_199:
        if ((v8 & ~a1 & 0x2000000000000000LL) == 0
          || !swift_isUniquelyReferenced_nonNull_native(a1 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v7 <= 15) {
            goto LABEL_210;
          }
          goto LABEL_215;
        }

        int64_t v151 = _StringGuts.nativeUnusedCapacity.getter(v8, a1);
        if ((v152 & 1) == 0)
        {
          BOOL v154 = (a1 & 0x2000000000000000LL) == 0 && v151 > 0;
          if (v7 <= 15 && !v154)
          {
LABEL_210:
            swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
            swift_bridgeObjectRetain(a1, v155, v156, v157);
            unint64_t v158 = _StringGuts._convertedToSmall()(v8, a1);
            unint64_t v160 = v159;
            swift_bridgeObjectRelease(a1);
            v161._Swift::UInt64 rawBits = 1LL;
            v162._Swift::UInt64 rawBits = 65537LL;
            v163._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v161, v162, 0x29uLL, 0xE100000000000000LL);
            if (v163._rawBits < 0x10000) {
              v163._rawBits |= 3;
            }
            unint64_t v165 = specialized String.init(_:)(v163, v164, 0x29uLL, 0xE100000000000000LL);
            unint64_t v167 = v166;
            swift_bridgeObjectRelease(0xE100000000000000LL);
            unint64_t v168 = _StringGuts._convertedToSmall()(v165, v167);
            unint64_t v170 = v169;
            swift_bridgeObjectRelease(v167);
            unint64_t v171 = specialized _SmallString.init(_:appending:)(v158, v160, v168, v170);
            if ((v172 & 1) == 0)
            {
              uint64_t v8 = v171;
              swift_bridgeObjectRelease(a1);
              swift_bridgeObjectRelease(0xE100000000000000LL);
              return v8;
            }

      char v21 = 0;
      int64_t v22 = 0;
      char v23 = 15;
LABEL_166:
      BOOL v25 = 1;
      goto LABEL_208;
    }

      int8x16_t v239 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      goto LABEL_167;
    }

    if ((object & 0x2000000000000000LL) == 0) {
      goto LABEL_165;
    }
    int8x16_t v239 = HIBYTE(object) & 0xF;
    int8x8_t v240 = v237 + v239;
    if (v237 + v239 <= 0xF)
    {
      uint64_t v314 = v3;
      if (v239)
      {
        unsigned int v315 = 0;
        unint64_t v316 = 0LL;
        Swift::String::Index v317 = v357;
        do
        {
          Swift::String::Index v318 = v237 + v316;
          Swift::String::Index v319 = v316 + 1;
          if (v316 >= 8) {
            Swift::String::Index v320 = object;
          }
          else {
            Swift::String::Index v320 = countAndFlagsBits;
          }
          Swift::Int v321 = v320 >> (v315 & 0x38);
          Swift::String::Index v322 = (8 * v237 + v315) & 0x38;
          Swift::String::Index v323 = (-255LL << v322) - 1;
          Swift::String::Index v324 = (unint64_t)v321 << v322;
          Swift::String::Index v325 = v324 | v323 & v317;
          Swift::Int v326 = v324 | v323 & v236;
          if (v318 < 8) {
            int8x16_t v236 = v326;
          }
          else {
            Swift::String::Index v317 = v325;
          }
          v315 += 8;
          unint64_t v316 = v319;
        }

        while (v239 != v319);
      }

      else
      {
        Swift::String::Index v317 = v357;
      }

      swift_bridgeObjectRelease(v357);
      swift_bridgeObjectRelease(object);
      unint64_t v327 = 0xA000000000000000LL;
      if (!(v236 & 0x8080808080808080LL | v317 & 0x80808080808080LL)) {
        unint64_t v327 = 0xE000000000000000LL;
      }
      unint64_t object = v327 & 0xFF00000000000000LL | (v240 << 56) | v317 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v356 = v236;
      unint64_t v357 = object;
      uint64_t countAndFlagsBits = v236;
      uint64_t v3 = v314;
    }

    else
    {
LABEL_167:
      swift_bridgeObjectRetain(object, v81, v82, v83);
      _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v239);
      swift_bridgeObjectRelease_n(object, 2LL);
      uint64_t countAndFlagsBits = v356;
      unint64_t object = v357;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v357);
    uint64_t v356 = countAndFlagsBits;
    unint64_t v357 = object;
  }

  int8x16_t v244 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000LL) == 0) {
    int8x16_t v244 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v244 || (countAndFlagsBits & ~object & 0x2000000000000000LL) != 0)
  {
    if ((object & 0x2000000000000000LL) == 0
      || (int8x16_t v245 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x283EuLL, 0xE200000000000000LL),
          (v242 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v241, v242, v243);
      _StringGuts.append(_:)(10302LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      int8x16_t v246 = v245;
      int8x16_t v247 = v241;
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v356 = v246;
      unint64_t v357 = v247;
    }
  }

  else
  {
    swift_bridgeObjectRelease(object);
    uint64_t v356 = 10302LL;
    unint64_t v357 = 0xE200000000000000LL;
  }

  uint64_t v248 = *(const char **)(v1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v248,  (uint64_t)v2,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD2Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v248,  (uint64_t)v2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  unint64_t v251 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  int8x8_t v252 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  v251(0LL, v252, AssociatedConformanceWitness);
  v351 = (uint64_t *)v2;
  unint64_t v253 = __swift_allocate_boxed_opaque_existential_0Tm(&v350);
  memcpy(v253, v37, v3);
  unint64_t v254 = v351;
  int64x2_t v255 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
  DynamicType = (void *)swift_getDynamicType(v255, v254, 1);
  LODWORD(v254) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
  if ((_DWORD)v254)
  {
    int8x16_t v257 = v347;
    memcpy(v347, v37, v3);
    int64x2_t v258 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v350, v257, v2, v258, 7uLL);
    goto LABEL_178;
  }

  uint8x8_t v268 = v345;
  memcpy(v345, v37, v3);
  if ((swift_dynamicCast((char *)&v350, v268, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    uint16x8_t v269 = v350._object;
    String.append(_:)(v350);
    swift_bridgeObjectRelease((uint64_t)v269);
    goto LABEL_186;
  }

  uint16x8_t v298 = v343;
  memcpy(v343, v37, v3);
  uint32x4_t v299 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v353, v298, v2, v299, 6uLL))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
    uint64x2_t v300 = (uint64_t)v351;
    uint64x2_t v301 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v301 + 8))( &v356,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v300,  v301);
LABEL_183:
    __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
    goto LABEL_186;
  }

  v355 = 0LL;
  uint64_t v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v353,  &demangling cache variable for type metadata for TextOutputStreamable?);
  uint64x2_t v306 = v341;
  memcpy(v341, v37, v3);
  uint32x4_t v307 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v353, v306, v2, v307, 6uLL)
    || (v355 = 0LL,
        uint64_t v353 = 0u,
        v354 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v353,  &demangling cache variable for type metadata for CustomStringConvertible?),  uint64x2_t v308 = v339,  memcpy(v339, v37, v3),  v309 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v353, v308, v2, v309, 6uLL)))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
LABEL_178:
    int64x2_t v259 = (uint64_t)v351;
    int64x2_t v260 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    char v262 = (*(uint64_t (**)(uint64_t, uint64_t))(v260 + 8))(v259, v260);
    int8x16_t v263 = v261;
    unint64_t v264 = HIBYTE(v357) & 0xF;
    if ((v357 & 0x2000000000000000LL) == 0) {
      unint64_t v264 = v356 & 0xFFFFFFFFFFFFLL;
    }
    if (v264 || (v356 & ~v357 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v262, v261);
      swift_bridgeObjectRelease(v263);
    }

    else
    {
      swift_bridgeObjectRelease(v357);
      uint64_t v356 = v262;
      unint64_t v357 = v263;
    }

    goto LABEL_183;
  }

  v355 = 0LL;
  uint64_t v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v353,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v354 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v2;
  uint64_t v328 = __swift_allocate_boxed_opaque_existential_0Tm(&v353);
  memcpy(v328, v37, v3);
  Mirror.init(reflecting:)((uint64_t *)&v353, (uint64_t)&v350);
  uint64_t v329 = v350._object;
  Swift::String::Index v330 = v352;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v37,  &v350,  &v356,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  swift_release(v330);
  swift_release((uint64_t)v329);
LABEL_186:
  uint32x4_t v270 = v357;
  uint64x2_t v271 = HIBYTE(v357) & 0xF;
  if ((v357 & 0x2000000000000000LL) == 0) {
    uint64x2_t v271 = v356 & 0xFFFFFFFFFFFFLL;
  }
  if (v271 || (v356 & ~v357 & 0x2000000000000000LL) != 0)
  {
    if ((v357 & 0x2000000000000000LL) == 0
      || (uint64x2_t v272 = specialized _SmallString.init(_:appending:)(v356, v357, 0x202CuLL, 0xE200000000000000LL),
          (v266 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v265, v266, v267);
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      uint64x2_t v273 = v272;
      uint32x4_t v274 = v265;
      swift_bridgeObjectRelease(v270);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v356 = v273;
      unint64_t v357 = v274;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v357);
    uint64_t v356 = 8236LL;
    unint64_t v357 = 0xE200000000000000LL;
  }

  uint64x2_t v275 = v348;
  v251(1LL, v252, AssociatedConformanceWitness);
  v351 = (uint64_t *)v2;
  int8x16_t v276 = __swift_allocate_boxed_opaque_existential_0Tm(&v350);
  memcpy(v276, v275, v3);
  unint64_t v277 = v351;
  int64x2_t v278 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
  int64x2_t v279 = (void *)swift_getDynamicType(v278, v277, 1);
  LODWORD(v277) = swift_isOptionalType(v279);
  __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
  if ((_DWORD)v277)
  {
    int64x2_t v280 = v347;
    memcpy(v347, v275, v3);
    int64x2_t v281 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v350, v280, v2, v281, 7uLL);
    goto LABEL_196;
  }

  int8x16_t v291 = v346;
  memcpy(v346, v275, v3);
  if ((swift_dynamicCast((char *)&v350, v291, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    int8x16_t v292 = v350._object;
    String.append(_:)(v350);
    swift_bridgeObjectRelease((uint64_t)v292);
    goto LABEL_204;
  }

  uint16x8_t v302 = v344;
  memcpy(v344, v275, v3);
  uint32x4_t v303 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v353, v302, v2, v303, 6uLL))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
    uint64x2_t v304 = (uint64_t)v351;
    uint64x2_t v305 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v305 + 8))( &v356,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v304,  v305);
LABEL_201:
    __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
    goto LABEL_204;
  }

  v355 = 0LL;
  uint64_t v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v353,  &demangling cache variable for type metadata for TextOutputStreamable?);
  uint64x2_t v310 = v342;
  memcpy(v342, v275, v3);
  uint64x2_t v311 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v353, v310, v2, v311, 6uLL)
    || (v355 = 0LL,
        uint64_t v353 = 0u,
        v354 = 0u,
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v353,  &demangling cache variable for type metadata for CustomStringConvertible?),  int8x16_t v312 = v340,  memcpy(v340, v275, v3),  v313 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v353, v312, v2, v313, 6uLL)))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
LABEL_196:
    int64x2_t v282 = (uint64_t)v351;
    int64x2_t v283 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    int64x2_t v285 = (*(uint64_t (**)(uint64_t, uint64_t))(v283 + 8))(v282, v283);
    int64x2_t v286 = v284;
    int8x16_t v287 = HIBYTE(v357) & 0xF;
    if ((v357 & 0x2000000000000000LL) == 0) {
      int8x16_t v287 = v356 & 0xFFFFFFFFFFFFLL;
    }
    if (v287 || (v356 & ~v357 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v285, v284);
      swift_bridgeObjectRelease(v286);
    }

    else
    {
      swift_bridgeObjectRelease(v357);
      uint64_t v356 = v285;
      unint64_t v357 = v286;
    }

    goto LABEL_201;
  }

  v355 = 0LL;
  uint64_t v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?( (uint64_t)&v353,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v354 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v2;
  Swift::String::Index v331 = __swift_allocate_boxed_opaque_existential_0Tm(&v353);
  memcpy(v331, v275, v3);
  Mirror.init(reflecting:)((uint64_t *)&v353, (uint64_t)&v350);
  Swift::String::Index v332 = v350._object;
  Swift::String::Index v333 = v352;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v275,  &v350,  &v356,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
  swift_release(v333);
  swift_release((uint64_t)v332);
LABEL_204:
  int8x16_t v293 = v357;
  int8x16_t v294 = HIBYTE(v357) & 0xF;
  if ((v357 & 0x2000000000000000LL) == 0) {
    int8x16_t v294 = v356 & 0xFFFFFFFFFFFFLL;
  }
  if (v294 || (v356 & ~v357 & 0x2000000000000000LL) != 0)
  {
    if ((v357 & 0x2000000000000000LL) == 0
      || (int8x16_t v295 = specialized _SmallString.init(_:appending:)(v356, v357, 0x29uLL, 0xE100000000000000LL), (v289 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v288, v289, v290);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      return v356;
    }

    else
    {
      int8x16_t v296 = v295;
      swift_bridgeObjectRelease(v293);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v357);
    return 41LL;
  }

  return v296;
}

LABEL_254:
            unint64_t v195 = 266LL;
LABEL_256:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v195,  0);
          }

    int8x8_t v240 = 266LL;
    goto LABEL_256;
  }

  Swift::String::Index v177 = _StringGuts.nativeUnusedCapacity.getter(v82, v12);
  if ((v178 & 1) != 0) {
    goto LABEL_255;
  }
  Swift::String::Index v179 = (v12 >> 61) & 1;
  if (v177 < v4) {
    LODWORD(v179) = 1;
  }
  if (v7 <= 15 && (_DWORD)v179) {
    goto LABEL_197;
  }
LABEL_202:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v7, v4);
  swift_bridgeObjectRelease_n(v170, 4LL);
  if ((v170 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v170);
    _StringGuts._foreignAppendInPlace(_:)(v171, v170, 0LL, v46);
    swift_bridgeObjectRelease_n(v170, 2LL);
LABEL_224:
    char v2 = v247;
    int64_t v151 = v251;
    goto LABEL_225;
  }

  if (v13)
  {
    swift_bridgeObjectRelease_n(v170, 2LL);
    *(void *)&int8x8_t v252 = v171;
    *((void *)&v252 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v170 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v204 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v170) & 0xF,  (uint64_t)&v252,  HIBYTE(v170) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v204, v205, (v170 & 0x4000000000000000LL) != 0);
    swift_bridgeObjectRelease(v170);
    goto LABEL_224;
  }

  if ((v171 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v170);
    int64x2_t v218 = (id)((v170 & 0xFFFFFFFFFFFFFFFLL) + 32);
    int64x2_t v219 = v171 & 0xFFFFFFFFFFFFLL;
    goto LABEL_219;
  }

  int64x2_t v218 = _StringObject.sharedUTF8.getter(v171, v170);
  int64x2_t v219 = v239;
  swift_bridgeObjectRelease(v170);
  if (v219 < v84) {
LABEL_253:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
LABEL_219:
  int64_t v151 = v251;
  uint64_t v220 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v171 & 0xFFFFFFFFFFFFLL, (uint64_t)v218, v219);
  _StringGuts.appendInPlace(_:isASCII:)(v220, v221, v171 < 0);
  swift_bridgeObjectRelease_n(v170, 2LL);
  char v2 = v247;
LABEL_225:
  int64x2_t v223 = v254;
  int8x16_t v224 = HIBYTE(v254) & 0xF;
  if ((v254 & 0x2000000000000000LL) == 0) {
    int8x16_t v224 = v253 & 0xFFFFFFFFFFFFLL;
  }
  if (v224 || (v253 & ~v254 & 0x2000000000000000LL) != 0)
  {
    if ((v254 & 0x2000000000000000LL) == 0
      || (int8x16_t v225 = specialized _SmallString.init(_:appending:)(v253, v254, 0x29uLL, 0xE100000000000000LL), (v202 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000LL, v201, v202, v203);
      _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 2LL);
      uint8x8_t v226 = v253;
      uint16x8_t v227 = v254;
    }

    else
    {
      uint8x8_t v226 = v225;
      uint16x8_t v227 = v201;
      swift_bridgeObjectRelease(v223);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v254);
    uint16x8_t v227 = 0xE100000000000000LL;
    uint8x8_t v226 = 41LL;
  }

  uint32x4_t v228 = specialized static String.+ infix(_:_:)(v2, v151, v226, v227);
  swift_bridgeObjectRelease(v151);
  swift_bridgeObjectRelease(v227);
  return v228;
}

    int8x16_t v234 = 266LL;
LABEL_256:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v234,  0);
  }

  __int16 v10 = v249;
  a2 = v250;
  uint64_t v156 = _StringGuts.nativeUnusedCapacity.getter(v249, v250);
  if ((v157 & 1) != 0)
  {
LABEL_255:
    int8x16_t v234 = 258LL;
    goto LABEL_256;
  }

  if (v72 > 15) {
    goto LABEL_163;
  }
  if ((a2 & 0x2000000000000000LL) != 0) {
    goto LABEL_193;
  }
  if (v156 < v152) {
    goto LABEL_187;
  }
LABEL_163:
  unint64_t v158 = _StringGuts.nativeUnusedCapacity.getter(v10, a2);
  Swift::Int v11 = (v159 & 1) == 0 && v158 >= v152;
  if ((v10 & ~a2 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(a2 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v15 = v245;
    if ((v11 & 1) != 0)
    {
LABEL_180:
      _StringGuts.grow(_:)(v72);
      goto LABEL_181;
    }

    goto LABEL_174;
  }

  uint64_t v15 = v245;
  if ((v11 & 1) == 0)
  {
LABEL_174:
    Swift::String::Index v161 = _StringGuts.nativeCapacity.getter(v10, a2);
    if ((v162 & 1) != 0) {
      Swift::String::Index v163 = 0LL;
    }
    else {
      Swift::String::Index v163 = v161;
    }
    if (v163 + 0x4000000000000000LL >= 0)
    {
      Swift::String::Index v164 = 2 * v163;
      if (v164 > v72) {
        unint64_t v72 = v164;
      }
      goto LABEL_180;
    }

        uint64_t result = 0LL;
        goto LABEL_248;
      }
    }

    else
    {
      uint64_t v5 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      unint64_t v6 = v138;
      if (v138 > 0) {
        goto LABEL_5;
      }
    }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    goto LABEL_63;
  }

  if ((v86->i16[0] & 0x8080) == 0)
  {
    unint64_t v86 = (uint8x16_t *)((char *)v86 + 2);
    goto LABEL_59;
  }

        uint64_t v194 = 0LL;
LABEL_255:
        unint64_t v189 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  297,  v194,  v185,  a5);
        return (int8x16_t *)swift::Demangle::__runtime::Demangler::createType(this, v189, v190, v191, v192);
      case 'U':
        BOOL v18 = 245;
        goto LABEL_75;
      case 'X':
      case 'x':
        if (v11 == 88)
        {
          unint64_t v13 = *((_DWORD *)this + 24);
          if (!v13) {
            return 0LL;
          }
          uint64_t v14 = v13 - 1;
          uint64_t v15 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v14);
          if (*((_WORD *)v15 + 8) != 43) {
            return 0LL;
          }
          *((_DWORD *)this + 24) = v14;
          uint64_t v16 = swift::Demangle::__runtime::Demangler::popTypeList(this, a2, a3, a4, a5);
          if (!v16) {
            return 0LL;
          }
          int64_t v17 = (swift::Demangle::__runtime::Node *)v16;
        }

        else
        {
          int64_t v17 = 0LL;
          uint64_t v15 = 0LL;
        }

        unint64_t v114 = swift::Demangle::__runtime::Demangler::popTypeList(this, a2, a3, a4, a5);
        if (!v114) {
          return 0LL;
        }
        unsigned int v117 = v114;
        size_t v118 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v118 || v118 + 24 > *((void *)this + 2))
        {
          id v119 = 2LL * *((void *)this + 4);
          if (v119 <= 0x20) {
            id v119 = 32LL;
          }
          *((void *)this + 4) = v119;
          uint64_t v120 = v119 + 8;
          uint64_t v121 = malloc(v119 + 8);
          uint64_t v122 = (char *)v121 + v120;
          char *v121 = *((void *)this + 3);
          size_t v118 = ((unint64_t)v121 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = v122;
          *((void *)this + 3) = v121;
        }

        size_t v123 = v118 + 24;
        *((void *)this + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v118 + 24;
        *(_WORD *)(v118 + 16) = 212;
        *(_BYTE *)(v118 + 18) = 0;
        uint64_t v124 = v117[1].u8[2];
        switch((_DWORD)v124)
        {
          case 1:
            break;
          case 5:
            uint64_t v124 = v117->u32[2];
            if (!(_DWORD)v124) {
              goto LABEL_222;
            }
            break;
          case 2:
            uint64_t v124 = 2LL;
            break;
          default:
            goto LABEL_222;
        }

        unint64_t v195 = v17;
        for (unint64_t i = 0LL; i != v124; ++i)
        {
          unint64_t v157 = v117[1].u8[2];
          unint64_t v158 = v157 - 1;
          if ((_DWORD)v157 == 1) {
            goto LABEL_189;
          }
          if ((_DWORD)v157 != 5)
          {
            if ((_DWORD)v157 != 2) {
              goto LABEL_194;
            }
            unint64_t v157 = 2LL;
LABEL_189:
            if (v157 <= i) {
              goto LABEL_194;
            }
            goto LABEL_190;
          }

          if (v117->u32[2] <= i)
          {
LABEL_194:
            unint64_t v160 = 0LL;
            goto LABEL_195;
          }

LABEL_255:
        unint64_t v195 = 258LL;
        goto LABEL_256;
      }
    }

    else
    {
      BOOL v18 = __OFADD__(v150, 1LL);
      uint64_t v7 = v150 + 1;
      if (!v18) {
        goto LABEL_199;
      }
    }

    __break(1u);
LABEL_236:
    if ((v11 & 0x1000000000000000LL) != 0)
    {
      unint64_t i = _StringGuts._foreignConvertedToSmall()(i, v8);
      Swift::Int v11 = v196;
    }

    else
    {
      if ((i & 0x1000000000000000LL) != 0)
      {
        unint64_t v187 = (unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v188 = i & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        unint64_t v187 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(i, v8);
        uint64_t v188 = v124;
      }

      swift_bridgeObjectRetain(v8, v124, v125, v126);
      closure #1 in _StringGuts._convertedToSmall()(v187, v188, &v202);
      swift_bridgeObjectRelease(v8);
      Swift::Int v11 = *((void *)&v202 + 1);
      unint64_t i = v202;
    }
  }

  if (v149 < 8) {
    uint64_t v8 = (41LL << (8 * (HIBYTE(v204) & 7u))) | ((-255LL << (8 * (HIBYTE(v204) & 7u))) - 1) & v203;
  }
  swift_bridgeObjectRelease(v204);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v8;
}

            int8x8_t v240 = 258LL;
LABEL_256:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v240,  0);
          }

          if (v66 <= 15) {
            goto LABEL_73;
          }
LABEL_62:
          unint64_t v70 = _StringGuts.nativeUnusedCapacity.getter(v12, v46);
          Swift::String v73 = (v71 & 1) == 0 && v70 >= v4;
          if ((v67 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v46 & 0xFFFFFFFFFFFFFFFLL))
          {
            unint64_t v4 = v246;
            if (v73)
            {
LABEL_100:
              swift_bridgeObjectRelease_n(v13, 4LL);
              if ((v13 & 0x1000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v13);
                _StringGuts._foreignAppendInPlace(_:)(v5, v13, 0LL, v245);
                swift_bridgeObjectRelease_n(v13, 2LL);
                goto LABEL_104;
              }

              if (v3)
              {
                swift_bridgeObjectRelease_n(v13, 2LL);
                *(void *)&int8x8_t v252 = v5;
                *((void *)&v252 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v13 & 0xFFFFFFFFFFFFFFLL;
                char v106 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v13) & 0xF,  (uint64_t)&v252,  HIBYTE(v13) & 0xF);
                _StringGuts.appendInPlace(_:isASCII:)(v106, v107, (v13 & 0x4000000000000000LL) != 0);
                swift_bridgeObjectRelease(v13);
LABEL_104:
                uint64_t v7 = v247;
                uint64_t v3 = v251;
                goto LABEL_128;
              }

              if ((v5 & 0x1000000000000000LL) != 0)
              {
                swift_bridgeObjectRelease(v13);
                uint64_t v120 = (id)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
                uint64_t v121 = v244;
                uint64_t v122 = v244;
                uint64_t v7 = v247;
                uint64_t v3 = v251;
                goto LABEL_121;
              }

    int8x16_t v225 = v80 & 0xFFFFFFFFFFFFLL;
    goto LABEL_260;
  }

  if ((v106 & 0x2000000000000000LL) == 0) {
    goto LABEL_255;
  }
LABEL_259:
  int8x16_t v225 = HIBYTE(v106) & 0xF;
LABEL_260:
  swift_bridgeObjectRetain(v106, v221, v222, v223);
  _StringGuts.append(_:)(v80, v106, 0LL, v225);
  swift_bridgeObjectRelease_n(v106, 2LL);
  uint64_t v80 = v256;
  char v106 = v257;
LABEL_261:
  uint64x2_t v229 = HIBYTE(v106) & 0xF;
  if ((v106 & 0x2000000000000000LL) == 0) {
    uint64x2_t v229 = v80 & 0xFFFFFFFFFFFFLL;
  }
  if (v229 || (v80 & ~v106 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x29uLL, 0xE100000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    return v256;
  }

  else
  {
    swift_bridgeObjectRelease(v106);
    return 41LL;
  }

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance ObjectIdentifier()
{
  return ObjectIdentifier.debugDescription.getter(*v0);
}

BOOL static ObjectIdentifier.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 < a2;
}

BOOL static UInt.< infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance ObjectIdentifier( void *a1, void *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance ObjectIdentifier( void *a1, void *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance ObjectIdentifier( void *a1, void *a2)
{
  return *a2 < *a1;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance ObjectIdentifier()
{
  return specialized static Hasher._hash(seed:_:)(0LL, *v0);
}

void protocol witness for Hashable.hash(into:) in conformance ObjectIdentifier()
{
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance ObjectIdentifier(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(a1, *v1);
}

uint64_t Optional.init(nilLiteral:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 56LL))(a2, 1LL, 1LL);
}

uint64_t _sxSgs23ExpressibleByNilLiteralsRi_zrlsABP03nilD0xyt_tcfCTW@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 56LL))( a2,  1LL,  1LL);
}

uint64_t Optional.map<A>(_:)@<X0>( void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v19 = a1;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  Swift::Int v11 = (char *)&v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v14 + 16))(v13, v15);
  uint64_t v16 = 1LL;
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v13, 1LL, v7) != 1)
  {
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v11, v13, v7);
    v19(v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v7);
    if (v4) {
      return result;
    }
    uint64_t v16 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL))(a4, v16, 1LL, a3);
}

uint64_t Optional.flatMap<A>(_:)@<X0>( void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  Swift::Int v11 = (char *)v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unint64_t v13 = (char *)v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v14 + 16))(v13, v15);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v13, 1LL, v7) == 1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL))( a4,  1LL,  1LL,  a3);
  }
  (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v11, v13, v7);
  a1(v11);
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v7);
}

uint64_t Optional.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  uint64_t v5 = (char *)&v53[-2] - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v3);
  uint64_t v7 = (char *)&v53[-2] - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v8 + 16))(v7);
  uint64_t v10 = *(void (**)(char *, char *, uint64_t))(v2 + 32);
  v10(v5, v7, v1);
  Swift::String v54 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Optional(", 9uLL, 1);
  uint64_t v11 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  inited = swift_initStackObject(v11, v53);
  *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_1817FFC60;
  inited[7] = v1;
  boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  v10(boxed_opaque_existential_0Tm, v5, v1);
  specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v54._countAndFlagsBits);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  swift_setDeallocating((uint64_t)inited);
  swift_arrayDestroy((uint64_t)(inited + 4), 1LL, (uint64_t)byte_189B8D218);
  unint64_t object = (unint64_t)v54._object;
  uint64_t countAndFlagsBits = v54._countAndFlagsBits;
  size_t v19 = ((unint64_t)v54._object >> 56) & 0xF;
  uint64_t v20 = v54._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  else {
    int64_t v21 = v54._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v21 && (v54._countAndFlagsBits & ~(uint64_t)v54._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v54._object);
    return 41LL;
  }

  if (((uint64_t)v54._object & 0x2000000000000000LL) == 0 || v19 == 15)
  {
    swift_bridgeObjectRetain(0xE100000000000000LL, v14, v15, v16);
    if ((object & 0x1000000000000000LL) != 0)
    {
      Swift::Int v47 = String.UTF8View._foreignCount()();
      uint64_t v27 = v47 + 1;
      if (!__OFADD__(v47, 1LL)) {
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v27 = v21 + 1;
      if (!__OFADD__(v21, 1LL))
      {
LABEL_13:
        unint64_t v28 = countAndFlagsBits & ~object;
        if ((v28 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v29 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
          if ((v24 & 1) != 0)
          {
            unint64_t v50 = 258LL;
            goto LABEL_74;
          }

          if (v27 > 15 || (object & 0x2000000000000000LL) == 0 && v29 > 0) {
            goto LABEL_19;
          }
        }

        else if (v27 > 15)
        {
LABEL_19:
          int64_t v30 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
          BOOL v33 = (v31 & 1) == 0 && v30 > 0;
          if ((v28 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
          {
            if (v33) {
              goto LABEL_61;
            }
          }

          else if (v33)
          {
            goto LABEL_43;
          }

          uint64_t v36 = 2 * _StringGuts.nativeCapacity.getter(countAndFlagsBits, object);
          if ((v37 & 1) != 0) {
            uint64_t v36 = 0LL;
          }
          if (v36 > v27) {
            uint64_t v27 = v36;
          }
LABEL_43:
          uint64_t v38 = _StringGuts.uniqueNativeCapacity.getter();
          if ((v39 & 1) != 0)
          {
            if ((object & 0x1000000000000000LL) != 0) {
              int64_t v21 = String.UTF8View._foreignCount()();
            }
          }

          else
          {
            int64_t v21 = 2 * v38;
          }

          if (v21 <= v27) {
            int64_t v21 = v27;
          }
          if ((object & 0x1000000000000000LL) == 0)
          {
            if ((object & 0x2000000000000000LL) != 0)
            {
              *(void *)&__int128 __src = countAndFlagsBits;
              *((void *)&__src + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = object & 0xFFFFFFFFFFFFFFLL;
              unint64_t v41 = v19 | 0xC000000000000000LL;
              if ((object & 0x4000000000000000LL) == 0) {
                unint64_t v41 = HIBYTE(object) & 0xF;
              }
              uint64_t v42 = v41 | 0x3000000000000000LL;
              unint64_t object = _allocateStringStorage(codeUnitCapacity:)(v21);
              *(void *)(object + 16) = v43;
              *(void *)(object + 24) = v42;
              if (v43 < 0)
              {
                *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
                uint64_t v42 = *(void *)(object + 24);
              }

              *(_BYTE *)(object + 32 + (v42 & 0xFFFFFFFFFFFFLL)) = 0;
              specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v19, (char *)(object + 32));
            }

            else
            {
              if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
              {
                Swift::String::Index v40 = (char *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
              }

              else
              {
                Swift::String::Index v40 = (char *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
                uint64_t v20 = v49;
              }

              unint64_t object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v40,  v20,  v21,  countAndFlagsBits < 0);
            }

            swift_bridgeObjectRelease((uint64_t)v54._object);
            goto LABEL_61;
          }

          goto LABEL_66;
        }

        if ((object & 0x2000000000000000LL) != 0)
        {
          unint64_t v34 = object;
        }

        else if ((object & 0x1000000000000000LL) != 0)
        {
          uint64_t countAndFlagsBits = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, object);
          unint64_t v34 = v51;
        }

        else
        {
          if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
          {
            char v48 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            char v48 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
            uint64_t v20 = v24;
          }

          swift_bridgeObjectRetain(object, v24, v25, v26);
          closure #1 in _StringGuts._convertedToSmall()(v48, v20, &__src);
          swift_bridgeObjectRelease(object);
          unint64_t v34 = *((void *)&__src + 1);
          uint64_t countAndFlagsBits = __src;
        }

        swift_bridgeObjectRelease(0xE100000000000000LL);
        unint64_t v35 = HIBYTE(v34) & 0xF;
        if (v35 != 15)
        {
          uint64_t v22 = (41LL << (8 * (HIBYTE(v34) & 7u))) | ((-255LL << (8 * (HIBYTE(v34) & 7u))) - 1) & countAndFlagsBits;
          BOOL v23 = v35 >= 8;
          goto LABEL_34;
        }

        unint64_t v50 = 266LL;
LABEL_74:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v50,  0);
      }
    }

    __break(1u);
LABEL_66:
    _StringGuts._foreignGrow(_:)(v21);
    unint64_t object = (unint64_t)v54._object;
LABEL_61:
    swift_bridgeObjectRelease(0xE100000000000000LL);
    __int128 __src = xmmword_1817FFDA0;
    unint64_t v44 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&__src, 1LL);
    __StringStorage.appendInPlace(_:isASCII:)(v44, v45, 1);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    return *(void *)(object + 24);
  }

  uint64_t v22 = (41LL << (8 * (HIBYTE(v54._object) & 7u))) | ((-255LL << (8 * (HIBYTE(v54._object) & 7u))) - 1) & v54._countAndFlagsBits;
  BOOL v23 = v19 >= 8;
LABEL_34:
  if (v23) {
    uint64_t v9 = countAndFlagsBits;
  }
  else {
    uint64_t v9 = v22;
  }
  swift_bridgeObjectRelease(object);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v9;
}

uint64_t Optional.customMirror.getter@<X0>(swift *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *((void *)a1 + 2);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v47 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  Swift::Int v47 = (uint64_t *)((char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v47 - v14;
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  char v48 = (uint64_t *)((char *)&v47 - v17);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v47 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v47 - v21;
  uint64_t v49 = v23;
  uint64_t v24 = *(void (**)(char *, uint64_t, swift *))(v23 + 16);
  v24((char *)&v47 - v21, v3, a1);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v7 + 48))(v22, 1LL, v6) == 1)
  {
    v24(v15, v3, a1);
    uint64_t v50 = 0LL;
    uint64_t v51 = 0LL;
    uint64_t v25 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v15, (uint64_t)&v50, a1);
    uint64_t v27 = v26;
    uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
    int64_t v29 = swift_allocObject(v28, 0x48uLL, 7uLL);
    v29[6] = &_swiftEmptyArrayStorage;
    v29[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
    v29[8] = 0LL;
    uint64_t v30 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
    char v31 = swift_allocObject(v30, 0x18uLL, 7uLL);
    v31[2] = 0LL;
    size_t v32 = swift_allocObject(v30, 0x18uLL, 7uLL);
    void v32[2] = 0LL;
    v29[2] = v31;
    uint64_t v29[3] = &protocol witness table for _IndexBox<A>;
    v29[4] = v32;
    v29[5] = &protocol witness table for _IndexBox<A>;
    BOOL v33 = v47;
    (*(void (**)(uint64_t *, char *, swift *))(v49 + 32))(v47, v15, a1);
  }

  else
  {
    unint64_t v34 = *(void (**)(char *, char *, uint64_t))(v7 + 32);
    v34(v10, v22, v6);
    v24(v20, v3, a1);
    uint64_t v35 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
    uint64_t v36 = swift_allocObject(v35, 0x50uLL, 7uLL);
    *((_OWORD *)v36 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_1817FFC60;
    v36[4] = 1701670771LL;
    v36[5] = 0xE400000000000000LL;
    v36[9] = v6;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(v36 + 6);
    v34(boxed_opaque_existential_0Tm, v10, v6);
    uint64_t v50 = 0LL;
    uint64_t v51 = 0LL;
    uint64_t v25 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v20, (uint64_t)&v50, a1);
    uint64_t v27 = v38;
    uint64_t v39 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
    int64_t v29 = swift_allocObject(v39, 0x48uLL, 7uLL);
    v29[6] = v36;
    v29[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
    v29[8] = 0LL;
    uint64_t v40 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
    unint64_t v41 = swift_allocObject(v40, 0x18uLL, 7uLL);
    v41[2] = 0LL;
    uint64_t v42 = v36[2];
    uint64_t v43 = swift_allocObject(v40, 0x18uLL, 7uLL);
    v43[2] = v42;
    v29[2] = v41;
    uint64_t v29[3] = &protocol witness table for _IndexBox<A>;
    v29[4] = v43;
    v29[5] = &protocol witness table for _IndexBox<A>;
    BOOL v33 = v48;
    (*(void (**)(uint64_t *, char *, swift *))(v49 + 32))(v48, v20, a1);
  }

  unint64_t v44 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)&v50, v33, a1, v44, 6uLL);
  char v46 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(&v50);
  }
  *(void *)a2 = a1;
  *(void *)(a2 + 8) = v29;
  *(_BYTE *)(a2 + 16) = 4;
  *(void *)(a2 + 24) = v25;
  *(void *)(a2 + 32) = v27;
  *(_BYTE *)(a2 + 4_assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_rawHashValue(_seed:) called on non-canonical AnyHashable box",  61LL,  2,  "Swift/NewtypeWrapper.swift",  26LL,  2,  0x4FuLL, 0) = v46;
  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> A?( uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4 = a3;
  uint64_t v30 = a2;
  uint64_t v28 = *(void *)(a4 - 8);
  unint64_t v6 = a3[2];
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v27 = (char *)&v27 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v8);
  int64_t v29 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v13, v13, 0LL, 0LL);
  uint64_t v15 = *(TupleTypeMetadata2 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v18 = (char *)&v27 - v17;
  uint64_t v19 = (char *)&v27 + *(int *)(v16 + 48) - v17;
  uint64_t v20 = *(void (**)(char *, uint64_t, unint64_t *))(v11 + 16);
  v20((char *)&v27 - v17, a1, v4);
  v20(v19, v30, v4);
  uint64_t v21 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v7 + 48);
  if (v21(v18, 1LL, v6) == 1)
  {
    if (v21(v19, 1LL, v6) == 1)
    {
      char v22 = 1;
    }

    else
    {
      uint64_t v11 = v15;
      uint64_t v4 = TupleTypeMetadata2;
      char v22 = 0;
    }
  }

  else
  {
    uint64_t v30 = v15;
    uint64_t v23 = v29;
    v20(v29, (uint64_t)v18, v4);
    if (v21(v19, 1LL, v6) == 1)
    {
      (*(void (**)(char *, unint64_t))(v7 + 8))(v23, v6);
      char v22 = 0;
      uint64_t v11 = v30;
      uint64_t v4 = TupleTypeMetadata2;
    }

    else
    {
      uint64_t v24 = v27;
      (*(void (**)(char *, char *, unint64_t))(v7 + 32))(v27, v19, v6);
      char v22 = (*(uint64_t (**)(char *, char *, unint64_t))(v28 + 8))(v23, v24, v6);
      uint64_t v25 = *(void (**)(char *, unint64_t))(v7 + 8);
      v25(v24, v6);
      v25(v23, v6);
    }
  }

  (*(void (**)(char *, unint64_t *))(v11 + 8))(v18, v4);
  return v22 & 1;
}

void Optional<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v12 + 16))(v11, v13);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v6 + 48))(v11, 1LL, v5) == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v6 + 32))(v9, v11, v5);
    Hasher._combine(_:)(1u);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v5, a3);
    (*(void (**)(char *, uint64_t))(v6 + 8))(v9, v5);
  }

Swift::Int Optional<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v14[-1] - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v5);
  uint64_t v9 = (char *)&v14[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v14[0] = 0LL;
  v14[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  void v14[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v14[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v14[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  (*(void (**)(char *, uint64_t))(v10 + 16))(v9, v11);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v4 + 48))(v9, 1LL, v3) == 1)
  {
    Hasher._combine(_:)(0);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t))(v4 + 32))(v7, v9, v3);
    Hasher._combine(_:)(1u);
    (*(void (**)(void *, uint64_t, uint64_t))(a2 + 24))(v14, v3, a2);
    (*(void (**)(char *, uint64_t))(v4 + 8))(v7, v3);
  }

  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> A?(uint64_t a1, uint64_t a2)
{
  return Optional<A>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> A?(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> A?( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))Optional<A>.hash(into:));
}

BOOL static Optional.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 48LL))(a1, 1LL, a2) == 1;
}

BOOL static Optional.!= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 48LL))(a1, 1LL, a2) != 1;
}

uint64_t ?? infix<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t (*a2)(void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9 = type metadata accessor for Optional(0LL, a4, a3, a4);
  MEMORY[0x1895F8858](v9);
  uint64_t v11 = (char *)v15 - v10;
  (*(void (**)(char *, uint64_t))(v12 + 16))((char *)v15 - v10, a1);
  uint64_t v13 = *(void *)(a4 - 8);
  else {
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v13 + 32))(a5, v11, a4);
  }
}

{
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  void v15[2];
  uint64_t v9 = type metadata accessor for Optional(0LL, a4, a3, a4);
  MEMORY[0x1895F8858](v9);
  uint64_t v11 = (char *)v15 - v10;
  (*(void (**)(char *, uint64_t))(v12 + 16))((char *)v15 - v10, a1);
  uint64_t v13 = *(void *)(a4 - 8);
  (*(void (**)(uint64_t, char *, uint64_t))(v13 + 32))(a5, v11, a4);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v13 + 56))(a5, 0LL, 1LL, a4);
}

__SwiftNull *Optional._bridgeToObjectiveC()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 8);
  uint64_t v3 = MEMORY[0x1895F8858](a1);
  uint64_t v5 = (char *)&v15 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(uint64_t **)(v3 + 16);
  uint64_t v7 = *(v6 - 1);
  MEMORY[0x1895F8858](v3);
  uint64_t v9 = (id *)((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(char *))(v2 + 16))(v5);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v7 + 48))(v5, 1LL, v6) == 1)
  {
    (*(void (**)(char *, uint64_t))(v2 + 8))(v5, a1);
    return _swift_Foundation_getOptionalNilSentinelObject(v6, v10, v11, v12);
  }

  else
  {
    (*(void (**)(id *, char *, uint64_t *))(v7 + 32))(v9, v5, v6);
    uint64_t v13 = _bridgeAnythingToObjectiveC<A>(_:)(v9, v6);
    (*(void (**)(id *, uint64_t *))(v7 + 8))(v9, v6);
  }

  return (__SwiftNull *)v13;
}

uint64_t static Optional._forceBridgeFromObjectiveC(_:result:)(__SwiftNull *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(a3 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v23 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = type metadata accessor for Optional((const char *)0xFF, v9, v9, v10);
  uint64_t v14 = type metadata accessor for Optional(0LL, v11, v12, v13);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v14 - 8) + 8LL))(a2, v14);
  OptionalNilSentinelObject = _swift_Foundation_getOptionalNilSentinelObject(a3, v15, v16, v17);
  swift_unknownObjectRelease(OptionalNilSentinelObject);
  if (OptionalNilSentinelObject == a1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v6 + 56))(a2, 1LL, 1LL, a3);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56LL))( a2,  0LL,  1LL,  v11);
  }

  else
  {
    uint64_t v24 = a1;
    swift_unknownObjectRetain(a1, v19, v20, v21);
    swift_dynamicCast(v8, (uint64_t *)&v24, (swift *)&unk_189B8D230, (const char *)a3, 7uLL);
    (*(void (**)(uint64_t, char *, uint64_t *))(v6 + 16))(a2, v8, a3);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t *))(v6 + 56))(a2, 0LL, 1LL, a3);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v11 - 8) + 56LL))(a2, 0LL, 1LL, v11);
    return (*(uint64_t (**)(char *, uint64_t *))(v6 + 8))(v8, a3);
  }

uint64_t static Optional._conditionallyBridgeFromObjectiveC(_:result:)( __SwiftNull *a1, char *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for Optional(0LL, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v30 - v10;
  uint64_t v12 = *(a3 - 1);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = type metadata accessor for Optional(0LL, v7, v15, v16);
  (*(void (**)(char *, uint64_t))(*(void *)(v17 - 8) + 8LL))(a2, v17);
  OptionalNilSentinelObject = _swift_Foundation_getOptionalNilSentinelObject(a3, v18, v19, v20);
  swift_unknownObjectRelease(OptionalNilSentinelObject);
  if (OptionalNilSentinelObject == a1)
  {
    uint64_t v27 = 1LL;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v12 + 56))(a2, 1LL, 1LL, a3);
  }

  else
  {
    char v31 = a1;
    swift_unknownObjectRetain(a1, v22, v23, v24);
    int v25 = swift_dynamicCast(v11, (uint64_t *)&v31, (swift *)&unk_189B8D230, (const char *)a3, 6uLL);
    uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v12 + 56);
    if (!v25)
    {
      v26(v11, 1LL, 1LL, a3);
      (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 56))(a2, 1LL, 1LL, v7);
      return 0LL;
    }

    uint64_t v27 = 1LL;
    v26(v11, 0LL, 1LL, a3);
    uint64_t v28 = *(void (**)(char *, char *, uint64_t *))(v12 + 32);
    v28(v14, v11, a3);
    v28(a2, v14, a3);
    v26(a2, 0LL, 1LL, a3);
  }

  (*(void (**)(char *, void, uint64_t, uint64_t))(v8 + 56))(a2, 0LL, 1LL, v7);
  return v27;
}

uint64_t static Optional._unconditionallyBridgeFromObjectiveC(_:)@<X0>( __SwiftNull *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  if (a1)
  {
    swift_unknownObjectRetain(a1, (uint64_t)a2, a3, a4);
    OptionalNilSentinelObject = _swift_Foundation_getOptionalNilSentinelObject(a2, v8, v9, v10);
    swift_unknownObjectRelease(OptionalNilSentinelObject);
    if (OptionalNilSentinelObject != a1)
    {
      uint64_t v13 = a1;
      swift_dynamicCast(a5, (uint64_t *)&v13, (swift *)&unk_189B8D230, (const char *)a2, 7uLL);
      return (*(uint64_t (**)(char *, void, uint64_t, uint64_t *))(*(a2 - 1) + 56))(a5, 0LL, 1LL, a2);
    }

    swift_unknownObjectRelease(a1);
  }

  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t *))(*(a2 - 1) + 56))(a5, 1LL, 1LL, a2);
}

uint64_t protocol witness for static _ObjectiveCBridgeable._forceBridgeFromObjectiveC(_:result:) in conformance A?( __SwiftNull *a1, uint64_t a2, uint64_t a3)
{
  return static Optional._forceBridgeFromObjectiveC(_:result:)(a1, a2, *(uint64_t **)(a3 + 16));
}

uint64_t protocol witness for static _ObjectiveCBridgeable._conditionallyBridgeFromObjectiveC(_:result:) in conformance A?( __SwiftNull *a1, char *a2, uint64_t a3, uint64_t a4)
{
  return static Optional._conditionallyBridgeFromObjectiveC(_:result:)(a1, a2, *(uint64_t **)(a3 + 16), a4);
}

uint64_t protocol witness for static _ObjectiveCBridgeable._unconditionallyBridgeFromObjectiveC(_:) in conformance A?@<X0>( __SwiftNull *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X8>)
{
  return static Optional._unconditionallyBridgeFromObjectiveC(_:)(a1, *(uint64_t **)(a2 + 16), a3, a4, a5);
}

uint64_t OptionSet.union(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v9 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v15 - v12;
  (*(void (**)(uint64_t, uint64_t))(v10 + 24))(a2, v10);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 24))(v13, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  return (*(uint64_t (**)(char *, uint64_t))(*(void *)(a3 + 16) + 96LL))(v8, a2);
}

uint64_t OptionSet.intersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(uint64_t, uint64_t))(v6 + 24))(a2, v6);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 24))(v9, a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a3 + 16) + 104LL))(a1, a2);
}

uint64_t OptionSet.symmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v9 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v15 - v12;
  (*(void (**)(uint64_t, uint64_t))(v10 + 24))(a2, v10);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 24))(v13, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  return (*(uint64_t (**)(char *, uint64_t))(*(void *)(a3 + 16) + 112LL))(v8, a2);
}

uint64_t OptionSet<>.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)(a3 + 16) + 144LL))();
}

uint64_t OptionSet<>.insert(_:)(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v35 = a1;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  (uint64_t)&type metadata for Bool,  a3,  "inserted memberAfterInsert ",  0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  BOOL v33 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v30 - v13;
  uint64_t v15 = *(void *)(a3 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v12);
  uint64_t v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v30 - v19;
  uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v15 + 16);
  uint64_t v32 = v5;
  v21(v18, v5, a3);
  uint64_t v22 = *(void *)(a4 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v22 + 56))(a2, a3, v22);
  uint64_t v23 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(v22 + 8) + 8LL);
  uint64_t v31 = a2;
  char v24 = v23(v20, a2, a3) ^ 1;
  unint64_t v34 = TupleTypeMetadata2;
  int v25 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  *uint64_t v14 = v24 & 1;
  if ((v24 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v15 + 8))(v20, a3);
    uint64_t v27 = v31;
    v21(v25, v31, a3);
    v21(v18, v27, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v22 + 96))(v18, a3, v22);
    uint64_t v26 = *(void (**)(char *, char *, uint64_t))(v15 + 32);
  }

  else
  {
    uint64_t v26 = *(void (**)(char *, char *, uint64_t))(v15 + 32);
    v26(v25, v20, a3);
  }

  uint64_t v28 = &v33[*((int *)v34 + 12)];
  v26(v28, v25, a3);
  v26(v35, v28, a3);
  return v24 & 1;
}

uint64_t OptionSet<>.remove(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v13, v5, a2);
  uint64_t v16 = *(void *)(a3 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 56))(a1, a2, v16);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v16 + 152))(a2, v16) & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, a2);
    uint64_t v17 = 1LL;
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 168))(a1, a2, v16);
    (*(void (**)(uint64_t, char *, uint64_t))(v10 + 32))(a4, v15, a2);
    uint64_t v17 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a4, v17, 1LL, a2);
}

uint64_t OptionSet<>.update(with:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v20 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v20 - v14;
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v16(v13, v5, a2);
  uint64_t v17 = *(void *)(a3 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v17 + 56))(a1, a2, v17);
  v16(v13, a1, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 96))(v13, a2, v17);
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v17 + 152))(a2, v17) & 1) != 0)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, a2);
    uint64_t v18 = 1LL;
  }

  else
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v10 + 32))(a4, v15, a2);
    uint64_t v18 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56))(a4, v18, 1LL, a2);
}

uint64_t OptionSet<>.init()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v15 - v7;
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a3 + 8) + 24LL) + 16LL);
  unint64_t v10 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v10);
  uint64_t v12 = (char *)&v15 - v11;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  AssociatedTypeWitness,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v10,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t, uint64_t))(v9 + 24))(v12, AssociatedTypeWitness, v9);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(a2 + 24))(v8, a1, a2);
}

uint64_t OptionSet<>.formUnion(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  v20[1] = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)v20 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)v20 - v15;
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v6 + 24);
  v17(a2, v6);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(v4, a2);
  v17(a2, v6);
  (*(void (**)(char *, char *, unint64_t))(*(void *)(v21 + 8) + 208LL))( v14,  v11,  AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, unint64_t))(v8 + 8);
  v18(v11, AssociatedTypeWitness);
  v18(v14, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v22 + 24))(v16, a2);
}

uint64_t OptionSet<>.formIntersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  v20[1] = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)v20 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)v20 - v15;
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v6 + 24);
  v17(a2, v6);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(v4, a2);
  v17(a2, v6);
  (*(void (**)(char *, char *, unint64_t))(*(void *)(v21 + 8) + 192LL))( v14,  v11,  AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, unint64_t))(v8 + 8);
  v18(v11, AssociatedTypeWitness);
  v18(v14, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v22 + 24))(v16, a2);
}

uint64_t OptionSet<>.formSymmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = a4;
  uint64_t v22 = a3;
  v20[1] = a1;
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for RawRepresentable,  associated type descriptor for RawRepresentable.RawValue);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)v20 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)v20 - v15;
  uint64_t v17 = *(void (**)(uint64_t, uint64_t))(v6 + 24);
  v17(a2, v6);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(v4, a2);
  v17(a2, v6);
  (*(void (**)(char *, char *, unint64_t))(*(void *)(v21 + 8) + 224LL))( v14,  v11,  AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, unint64_t))(v8 + 8);
  v18(v11, AssociatedTypeWitness);
  v18(v14, AssociatedTypeWitness);
  return (*(uint64_t (**)(char *, uint64_t))(v22 + 24))(v16, a2);
}

void specialized TextOutputStream._writeASCII(_:)(uint8x16_t *a1, uint64_t a2)
{
  unint64_t v2 = specialized static String._uncheckedFromASCII(_:)(a1, a2);
  unint64_t v6 = v3;
  uint64_t v7 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (!v7) {
    goto LABEL_9;
  }
  uint64_t v8 = v2;
  swift_bridgeObjectRetain(v3, v3, v4, v5);
  if ((v6 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = specialized static String._copying(_:)(v8, v6);
    unint64_t v9 = v12;
    swift_bridgeObjectRelease(v6);
    if ((v9 & 0x2000000000000000LL) == 0) {
      goto LABEL_6;
    }
  }

  else
  {
    unint64_t v9 = v6;
    if ((v6 & 0x2000000000000000LL) == 0)
    {
LABEL_6:
      if ((v8 & 0x1000000000000000LL) != 0)
      {
        id v10 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        size_t v11 = v8 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        id v10 = _StringObject.sharedUTF8.getter(v8, v9);
        if (!v10) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/OutputStream.swift",  24LL,  2,  0x239uLL,  0);
        }
        size_t v11 = v13;
      }

      _swift_stdlib_fwrite_stdout(v10, 1uLL, v11);
      swift_bridgeObjectRelease(v9);
LABEL_9:
      swift_bridgeObjectRelease(v6);
      return;
    }
  }

  v14[0] = v8;
  v14[1] = v9 & 0xFFFFFFFFFFFFFFLL;
  _swift_stdlib_fwrite_stdout(v14, 1uLL, HIBYTE(v9) & 0xF);
  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRelease(v6);
}

void TextOutputStream._writeASCII(_:)(uint8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = specialized static String._uncheckedFromASCII(_:)(a1, a2);
  uint64_t v7 = v6;
  (*(void (**)(unint64_t))(a4 + 24))(v5);
  swift_bridgeObjectRelease(v7);
}

uint64_t _fallbackEnumRawValue<A>(_:)(char *a1, uint64_t a2)
{
  uint64_t result = 0LL;
  switch(*(void *)(*(void *)(a2 - 8) + 64LL))
  {
    case 1LL:
      uint64_t result = *a1;
      break;
    case 2LL:
      uint64_t result = *(__int16 *)a1;
      break;
    case 4LL:
      uint64_t result = *(int *)a1;
      break;
    case 8LL:
      uint64_t result = *(void *)a1;
      break;
    default:
      return result;
  }

  return result;
}

void printTypeName #1 <A, B>(_:) in _adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:)( unint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  TypeName = (uint8x16_t *)swift_getTypeName(a1, a3);
  if (v9 < 0) {
LABEL_188:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  uint64_t v10 = v9;
  if (!v9)
  {
    int8x8_t v15 = 0LL;
    int64_t v16 = 0xE000000000000000LL;
    goto LABEL_185;
  }

  size_t v11 = TypeName;
  unint64_t v12 = TypeName;
  if ((v9 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080LL) != 0) {
      goto LABEL_23;
    }
    unint64_t v12 = TypeName + 1;
    while (v12 < (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFF0LL])
    {
      uint64_t v13 = v12->i64[0];
      uint64_t v14 = v12->i64[1];
      ++v12;
      if (((v14 | v13) & 0x8080808080808080LL) != 0) {
        goto LABEL_23;
      }
    }
  }

  if (v12 < (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFF8LL])
  {
    if ((v12->i64[0] & 0x8080808080808080LL) != 0) {
      goto LABEL_23;
    }
    unint64_t v12 = (uint8x16_t *)((char *)v12 + 8);
  }

  if (v12 < (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v12->i32[0] & 0x80808080) != 0) {
      goto LABEL_23;
    }
    unint64_t v12 = (uint8x16_t *)((char *)v12 + 4);
  }

  if (v12 >= (uint8x16_t *)&TypeName->i8[v9 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_19:
    if (v12 >= (uint8x16_t *)&TypeName->i8[v9] || (v12->i8[0] & 0x80000000) == 0)
    {
      if (v9 <= 15) {
        goto LABEL_74;
      }
      char v17 = 1;
      goto LABEL_64;
    }

    goto LABEL_23;
  }

  if ((v12->i16[0] & 0x8080) == 0)
  {
    unint64_t v12 = (uint8x16_t *)((char *)v12 + 2);
    goto LABEL_19;
  }

uint64_t String.subscript.getter(Swift::String::Index a1, uint64_t a2, unint64_t a3)
{
  v5._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(a1)._rawBits;
  uint64_t v6 = (v5._rawBits >> 8) & 0x3F;
  int64_t v7 = v5._rawBits >> 16;
  if (v6) {
    goto LABEL_24;
  }
  uint64_t v8 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000LL) != 0) {
    uint64_t v9 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v9 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v5._rawBits >> 14 != 4 * v9)
  {
    if ((a3 & 0x1000000000000000LL) != 0) {
      goto LABEL_37;
    }
    if ((a3 & 0x2000000000000000LL) != 0)
    {
      uint64_t v21 = a2;
      uint64_t v22 = a3 & 0xFFFFFFFFFFFFFFLL;
      if (v7 + 1 != (HIBYTE(a3) & 0xF))
      {
        int v13 = *(unsigned __int16 *)((char *)&v21 + v7);
        if (v13 == 2573 || (v13 & 0x80808080) != 0) {
          goto LABEL_37;
        }
      }
    }

    else
    {
      if ((a2 & 0x1000000000000000LL) != 0) {
        size_t v11 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        size_t v11 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      if (v7 + 1 != v8)
      {
        if (!v11) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
        }
        int v12 = *(unsigned __int16 *)&v11[v7];
        if (v12 == 2573 || (v12 & 0x80808080) != 0)
        {
LABEL_37:
          uint64_t v6 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v7);
          int64_t v10 = v6 + v7;
          if ((a3 & 0x1000000000000000LL) == 0) {
            goto LABEL_25;
          }
          return _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v7, v10)._countAndFlagsBits;
        }
      }
    }

    uint64_t v6 = 1LL;
LABEL_24:
    int64_t v10 = v6 + v7;
    if ((a3 & 0x1000000000000000LL) == 0) {
      goto LABEL_25;
    }
    return _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v7, v10)._countAndFlagsBits;
  }

  uint64_t v6 = 0LL;
  int64_t v10 = v5._rawBits >> 16;
  if ((a3 & 0x1000000000000000LL) != 0) {
    return _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v7, v10)._countAndFlagsBits;
  }
LABEL_25:
  if (v10 < v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if ((a3 & 0x2000000000000000LL) == 0)
  {
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      id v15 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v16 = a2 & 0xFFFFFFFFFFFFLL;
      if ((a2 & 0xFFFFFFFFFFFFLL) >= v10)
      {
LABEL_29:
        char v17 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v7, v10, (uint64_t)v15, v16);
        return specialized static String._uncheckedFromUTF8(_:)(v17, v18);
      }
    }

    else
    {
      id v15 = _StringObject.sharedUTF8.getter(a2, a3);
      uint64_t v16 = v20;
      if (v20 >= v10) {
        goto LABEL_29;
      }
    }

void specialized String.write<A>(to:)( unint64_t *a1, unint64_t a2, unint64_t a3, char *a4)
{
  unint64_t v7 = a1[1];
  uint64_t v8 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = *a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 || (*a1 & ~v7 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(a2, a3);
  }

  else
  {
    swift_bridgeObjectRetain(a3, a2, a3, a4);
    swift_bridgeObjectRelease(v7);
    *a1 = a2;
    a1[1] = a3;
  }

void protocol witness for TextOutputStream.write(_:) in conformance _Stdout( unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v4)
  {
    unint64_t v5 = a1;
    unint64_t v6 = a2;
    swift_bridgeObjectRetain(a2, a2, a3, a4);
    specialized String.withUTF8<A>(_:)(&v5);
    swift_bridgeObjectRelease(v6);
  }

Swift::Void __swiftcall String.write(_:)(Swift::String a1)
{
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  unint64_t v6 = v3[1];
  uint64_t v7 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = *v3 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 || (*v3 & ~v6 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(a1._countAndFlagsBits, (unint64_t)a1._object);
  }

  else
  {
    swift_bridgeObjectRetain((unint64_t)a1._object, (uint64_t)a1._object, v1, v2);
    swift_bridgeObjectRelease(v6);
    *unint64_t v3 = countAndFlagsBits;
    v3[1] = (uint64_t)object;
  }

uint64_t _StringGuts.init(_:isASCII:)(uint64_t a1, unint64_t a2, char a3)
{
  unint64_t v3 = a2 | 0xC000000000000000LL;
  if ((a3 & 1) == 0) {
    unint64_t v3 = a2;
  }
  return v3 | 0x1000000000000000LL;
}

void _StringGuts.append(_:)(unint64_t a1, unint64_t a2)
{
  uint64_t v5 = v2[1];
  if ((v5 & 0x2000000000000000LL) != 0)
  {
    if ((a2 & 0x2000000000000000LL) != 0)
    {
      unint64_t v7 = specialized _SmallString.init(_:appending:)(*v2, v2[1], a1, a2);
      if ((v9 & 1) == 0)
      {
        unint64_t v10 = v7;
        unint64_t v11 = v8;
        swift_bridgeObjectRelease(v5);
        *unint64_t v2 = v10;
        v2[1] = v11;
        return;
      }

      goto LABEL_8;
    }
  }

  else if ((a2 & 0x2000000000000000LL) != 0)
  {
LABEL_8:
    uint64_t v6 = HIBYTE(a2) & 0xF;
    goto LABEL_9;
  }

  uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
LABEL_9:
  _StringGuts.append(_:)(a1, a2, 0LL, v6);
}

uint64_t Character.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 24))(a2, a3, a4, a5);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Character( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Character.write<A>(to:)(a1, *v3, v3[1], a2, a3);
}

void Unicode.Scalar.write<A>(to:)(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2);
  uint64_t v7 = v6;
  (*(void (**)(uint64_t))(a4 + 24))(v5);
  swift_bridgeObjectRelease(v7);
}

void protocol witness for TextOutputStreamable.write<A>(to:) in conformance Unicode.Scalar( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void *_playgroundPrintHook.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = _playgroundPrintHook;
  outlined copy of (@escaping @callee_guaranteed (@guaranteed String) -> ())?( (unint64_t *)_playgroundPrintHook,  (unint64_t *)qword_18C565C68,  a3,  a4);
  return v4;
}

uint64_t _playgroundPrintHook.setter(void *a1, uint64_t a2)
{
  unint64_t v2 = _playgroundPrintHook;
  uint64_t v3 = qword_18C565C68;
  _playgroundPrintHook = a1;
  qword_18C565C68 = a2;
  return outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v2, v3);
}

uint64_t (*_playgroundPrintHook.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Void __swiftcall _TeeStream.write(_:)(Swift::String a1)
{
  uint64_t v2 = v1;
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  (*(void (**)(uint64_t, void *, void))(*(void *)(v1 + 32) + 24LL))( a1._countAndFlagsBits,  a1._object,  *(void *)(v1 + 16));
  (*(void (**)(uint64_t, void *, void))(*(void *)(v2 + 40) + 24LL))( countAndFlagsBits,  object,  *(void *)(v2 + 24));
}

Swift::Void __swiftcall _TeeStream._lock()()
{
  uint64_t v1 = v0;
  (*(void (**)(void))(*(void *)(v0 + 32) + 8LL))(*(void *)(v0 + 16));
  (*(void (**)(void))(*(void *)(v1 + 40) + 8LL))(*(void *)(v1 + 24));
}

Swift::Void __swiftcall _TeeStream._unlock()()
{
  uint64_t v1 = v0;
  (*(void (**)(void))(*(void *)(v0 + 40) + 16LL))(*(void *)(v0 + 24));
  (*(void (**)(void))(*(void *)(v1 + 32) + 16LL))(*(void *)(v1 + 16));
}

uint64_t _Pointer.successor()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(a2 + 48))();
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for _Pointer,  associated type descriptor for _Pointer.Pointee);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 56))( v4 + *(void *)(*(void *)(AssociatedTypeWitness - 8) + 72LL),  a1,  a2);
}

uint64_t _Pointer.predecessor()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(a2 + 48))();
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for _Pointer,  associated type descriptor for _Pointer.Pointee);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 56))( v4 - *(void *)(*(void *)(AssociatedTypeWitness - 8) + 72LL),  a1,  a2);
}

void *static Strideable<>.-= infix(_:_:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 32);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  int v12 = (char *)&v16 - v11;
  size_t v13 = *(void *)(*(void *)(a3 - 8) + 64LL);
  MEMORY[0x1895F8858](v10);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric);
  (*(void (**)(uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( a2,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 48))(v12, a3, v7);
  (*(void (**)(char *, unint64_t))(v9 + 8))(v12, AssociatedTypeWitness);
  return memcpy(a1, (char *)&v16 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL), v13);
}

void *_convertConstArrayToPointerArgument<A, B>(_:)( uint64_t a1, uint64_t a2, uint64_t *a3, char *a4, uint64_t a5)
{
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    || (a2 & 0x8000000000000000LL) == 0 && (a2 & 0x4000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(a2);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
    {
      uint64_t v9 = *(unsigned __int8 *)(*(a3 - 1) + 80);
      uint64_t v10 = (a2 & 0xFFFFFFFFFFFFFF8LL) + ((v9 + 32) & ~v9);
    }

    else
    {
      uint64_t v11 = *(unsigned __int8 *)(*(a3 - 1) + 80);
      uint64_t v10 = a2 + ((v11 + 32) & ~v11);
    }

void *_convertMutableArrayToPointerArgument<A, B>(_:)( uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = type metadata accessor for Array(0LL, (uint64_t)a3, (uint64_t)a3, a4);
  Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(0LL, 0);
  unint64_t v10 = *a2;
  if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    && ((v10 & 0x8000000000000000LL) != 0 || (v10 & 0x4000000000000000LL) != 0))
  {
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v9, v11);
    if ((Collection.isEmpty.getter(v9, WitnessTable) & 1) == 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Pointer.swift",  19LL,  2,  0x1E3uLL,  0);
    }
  }

  else
  {
    _swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
  }

  uint64_t v15 = *a2;
  swift_bridgeObjectRetain(*a2, v12, v13, v14);
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a3, a3)
    || (v15 & 0x8000000000000000LL) == 0 && (v15 & 0x4000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v15);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
    {
      uint64_t v16 = *(unsigned __int8 *)(*(a3 - 1) + 80);
      uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFF8LL) + ((v16 + 32) & ~v16);
    }

    else
    {
      uint64_t v18 = *(unsigned __int8 *)(*(a3 - 1) + 80);
      uint64_t v17 = v15 + ((v18 + 32) & ~v18);
    }

__objc2_class **_convertConstStringToUTF8PointerArgument<A>(_:)( uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v7 = String.utf8CString.getter(a2, a3, a3, a4);
  (*(void (**)(__objc2_class **, char *, uint64_t))(a5 + 56))(v7 + 4, a4, a5);
  return v7;
}

__objc2_class **String.utf8CString.getter(unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  if ((a2 & 0x1000000000000000LL) != 0) {
    return String._slowUTF8CString()(a1, a2, a3, a4);
  }
  if ((a2 & 0x2000000000000000LL) != 0)
  {
    v12[0] = a1;
    v12[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    int64_t v6 = HIBYTE(a2) & 0xF;
    uint64_t v5 = (char *)v12;
  }

  else if ((a1 & 0x1000000000000000LL) != 0)
  {
    uint64_t v5 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    int64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v5 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
    if (!v5)
    {
      uint64_t v7 = &_swiftEmptyArrayStorage;
      goto LABEL_7;
    }
  }

  uint64_t v7 = specialized _copyCollectionToContiguousArray<A>(_:)(v5, v6);
LABEL_7:
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v7);
  v12[0] = v7;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v7[2]->isa + 1,  1);
    uint64_t v7 = (__objc2_class **)v12[0];
  }

  unint64_t v10 = v7[2];
  unint64_t v9 = (unint64_t)v7[3];
  if ((unint64_t)v10 >= v9 >> 1)
  {
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v9 > 1),  (int64_t)&v10->isa + 1,  1);
    uint64_t v7 = (__objc2_class **)v12[0];
  }

  v7[2] = (__objc2_class *)((char *)&v10->isa + 1);
  *((_BYTE *)&v10->info + (void)v7) = 0;
  return v7;
}

uint64_t protocol witness for Error._domain.getter in conformance Never(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError( a1,  a2,  &demangling cache variable for type metadata for Never.Type);
}

uint64_t protocol witness for Error._domain.getter in conformance _MergeError( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = a1;
  v5[0] = 0LL;
  v5[1] = 0xE000000000000000LL;
  uint64_t v3 = (swift *)__swift_instantiateConcreteTypeFromMangledName(a3);
  _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)&v6,  (uint64_t)v5,  v3,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  return v5[0];
}

uint64_t Never.init(from:)(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v2);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8))(v2, v3);
  swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
  *(void *)uint64_t v5 = &type metadata for Never;
  *(void *)(v5 + 8) = v4;
  *(void *)(v5 + 16) = 0xD000000000000026LL;
  *(void *)(v5 + 24) = 0x80000001818B70E0LL;
  *(void *)(v5 + 32) = 0LL;
  *(_BYTE *)(v5 + 72) = 0;
  swift_willThrow();
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Never(uint64_t *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v4);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 8))(v4, v5);
  swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
  *(void *)uint64_t v7 = v2;
  *(void *)(v7 + 8) = v6;
  *(void *)(v7 + 16) = 0xD000000000000026LL;
  *(void *)(v7 + 24) = 0x80000001818B70E0LL;
  *(void *)(v7 + 32) = 0LL;
  *(_BYTE *)(v7 + 72) = 0;
  swift_willThrow();
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t (*LazyPrefixWhileSequence._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyPrefixWhileSequence.init(_base:predicate:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return LazyDropWhileSequence.init(_base:predicate:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyPrefixWhileSequence,  a6);
}

uint64_t LazyDropWhileSequence.init(_base:predicate:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t (*a6)(void, uint64_t, uint64_t)@<X5>, uint64_t a7@<X8>)
{
  uint64_t result = a6(0LL, a4, a5);
  uint64_t v14 = (void *)(a7 + *(int *)(result + 36));
  *uint64_t v14 = a2;
  v14[1] = a3;
  return result;
}

uint64_t LazyPrefixWhileSequence.Iterator._predicateHasFailed.getter()
{
  return *v0;
}

uint64_t (*LazyPrefixWhileSequence.Iterator._predicateHasFailed.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyPrefixWhileSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IndexingIterator._position.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t LazyPrefixWhileSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return IndexingIterator._position.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*LazyPrefixWhileSequence.Iterator._base.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence.Iterator._predicate.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = (uint64_t *)(v4 + *(int *)(a1 + 40));
  uint64_t v6 = *v5;
  swift_retain((unint64_t *)v5[1], a2, a3, a4);
  return v6;
}

uint64_t LazyPrefixWhileSequence.Iterator.init(_base:predicate:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, _BYTE *a6@<X8>)
{
  return LazyDropWhileSequence.Iterator.init(_base:predicate:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(void, uint64_t, const char *))type metadata accessor for LazyPrefixWhileSequence.Iterator,  a6);
}

uint64_t LazyDropWhileSequence.Iterator.init(_base:predicate:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t (*a6)(void, uint64_t, const char *)@<X5>, _BYTE *a7@<X8>)
{
  *a7 = 0;
  uint64_t v13 = a6(0LL, a4, a5);
  uint64_t v14 = &a7[*(int *)(v13 + 36)];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t result = (*(uint64_t (**)(_BYTE *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( v14,  a1,  AssociatedTypeWitness);
  uint64_t v17 = &a7[*(int *)(v13 + 40)];
  *uint64_t v17 = a2;
  v17[1] = a3;
  return result;
}

uint64_t LazyPrefixWhileSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v27 - v12;
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v11);
  uint64_t v18 = (char *)&v27 - v17;
  uint64_t v30 = v2;
  if ((*v2 & 1) == 0)
  {
    uint64_t v27 = v16;
    uint64_t v28 = v15;
    uint64_t v29 = a2;
    unint64_t v20 = swift_getAssociatedTypeWitness( 255LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  v6,  v20,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v22 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v23 = swift_checkMetadataState(0LL, v20);
    v22(v23, AssociatedConformanceWitness);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v14 + 48))(v13, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v27 + 8))(v13, v28);
      uint64_t v19 = 1LL;
    }

    else
    {
      int v24 = *(void (**)(char *, char *, unint64_t))(v14 + 32);
      v24(v18, v13, AssociatedTypeWitness);
      if (((*(uint64_t (**)(char *))&v30[*(int *)(a1 + 40)])(v18) & 1) != 0)
      {
        uint64_t v25 = v29;
        v24(v29, v18, AssociatedTypeWitness);
        a2 = v25;
        uint64_t v19 = 0LL;
        return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v14 + 56))( a2,  v19,  1LL,  AssociatedTypeWitness);
      }

      (*(void (**)(char *, unint64_t))(v14 + 8))(v18, AssociatedTypeWitness);
      uint64_t v19 = 1LL;
      *uint64_t v30 = 1;
    }

    a2 = v29;
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v14 + 56))( a2,  v19,  1LL,  AssociatedTypeWitness);
  }

  uint64_t v19 = 1LL;
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, unint64_t))(v14 + 56))( a2,  v19,  1LL,  AssociatedTypeWitness);
}

double LazyPrefixWhileSequence.makeIterator()@<D0>(uint64_t a1@<X0>, _BYTE *a2@<X8>)
{
  *(void *)&double result = LazyDropWhileSequence.makeIterator()( a1,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for LazyPrefixWhileSequence.Iterator,  a2).n128_u64[0];
  return result;
}

__n128 LazyDropWhileSequence.makeIterator()@<Q0>( uint64_t a1@<X0>, uint64_t (*a2)(void, uint64_t, uint64_t)@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v7 = *(void *)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 32))( (char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v3,  v7);
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t))(v10 + 32);
  uint64_t v12 = a2(0LL, v7, v10);
  v11(v7, v10);
  uint64_t v13 = *(int *)(a1 + 36);
  *a3 = 0;
  __n128 result = *(__n128 *)(v3 + v13);
  *(__n128 *)&a3[*(int *)(v12 + 40)] = result;
  return result;
}

unint64_t *LazySequenceProtocol.prefix(while:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return LazySequenceProtocol.drop(while:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, unint64_t, unint64_t))type metadata accessor for LazyPrefixWhileSequence,  a5);
}

unint64_t *LazySequenceProtocol.drop(while:)@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void, unint64_t, unint64_t)@<X4>, uint64_t a6@<X8>)
{
  uint64_t v23 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  associated type descriptor for LazySequenceProtocol.Elements);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v22 - v14;
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 8LL))(v6, a3);
  (*(void (**)(uint64_t, char *, unint64_t))(v13 + 32))(a6, v15, AssociatedTypeWitness);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol,  (uint64_t)&associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
  uint64_t v17 = (void *)(a6 + *(int *)(a5(0LL, AssociatedTypeWitness, AssociatedConformanceWitness) + 36));
  *uint64_t v17 = v23;
  v17[1] = a2;
  return swift_retain(a2, v18, v19, v20);
}

uint64_t LazyPrefixWhileSequence<>.Index._value.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v5 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation( 0LL,  *(void *)(a1 + 16),  *(void *)(a1 + 24),  a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a3, v3, v5);
}

uint64_t LazyPrefixWhileSequence<>.Index.init(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v7 + 32))(a4, a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v7 + 56))( a4,  0LL,  1LL,  AssociatedTypeWitness);
}

uint64_t LazyPrefixWhileSequence<>.Index.init(endOf:)@<X0>( uint64_t a1@<X1>, const char *a2@<X2>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8)
                                                                                + 56LL))( a3,  1LL,  1LL,  AssociatedTypeWitness);
}

uint64_t static LazyPrefixWhileSequence<>.Index.== infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v33 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v32 = (char *)&v30 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v31 = (char *)&v30 - v11;
  uint64_t v13 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(255LL, a3, (uint64_t)a4, v12);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v13, v13, 0LL, 0LL);
  uint64_t v15 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v17 = (char *)&v30 - v16;
  uint64_t v18 = (char *)&v30 + *(int *)(v15 + 48) - v16;
  uint64_t v19 = *(void *)(v13 - 8);
  unint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v20((char *)&v30 - v16, a1, v13);
  v20(v18, v33, v13);
  uint64_t v21 = (uint64_t (*)(char *, uint64_t, unint64_t))v8[6];
  LODWORD(v2_assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_rawHashValue(_seed:) called on non-canonical AnyHashable box",  61LL,  2,  "Swift/NewtypeWrapper.swift",  26LL,  2,  0x4FuLL, 0) = v21(v17, 1LL, AssociatedTypeWitness);
  int v22 = v21(v18, 1LL, AssociatedTypeWitness);
  if ((_DWORD)v20 != 1)
  {
    if (v22 != 1)
    {
      int v24 = (void (*)(char *, char *, unint64_t))v8[4];
      uint64_t v25 = v31;
      v24(v31, v17, AssociatedTypeWitness);
      unsigned int v26 = v32;
      v24(v32, v18, AssociatedTypeWitness);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
      char v23 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                        + 8LL))( v25,  v26,  AssociatedTypeWitness);
      uint64_t v28 = (void (*)(char *, unint64_t))v8[1];
      v28(v26, AssociatedTypeWitness);
      v28(v25, AssociatedTypeWitness);
      return v23 & 1;
    }

    ((void (*)(char *, unint64_t))v8[1])(v17, AssociatedTypeWitness);
    goto LABEL_7;
  }

  if (v22 != 1)
  {
    (*(void (**)(char *, uint64_t))(v19 + 8))(v18, v13);
LABEL_7:
    char v23 = 0;
    return v23 & 1;
  }

  char v23 = 1;
  return v23 & 1;
}

uint64_t static LazyPrefixWhileSequence<>.Index.< infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v32 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v31 = (char *)&v29 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v30 = (char *)&v29 - v11;
  uint64_t v13 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(255LL, a3, (uint64_t)a4, v12);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v13, v13, 0LL, 0LL);
  uint64_t v15 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v17 = (char *)&v29 - v16;
  uint64_t v18 = (char *)&v29 + *(int *)(v15 + 48) - v16;
  uint64_t v19 = *(void *)(v13 - 8);
  unint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v20((char *)&v29 - v16, a1, v13);
  v20(v18, v32, v13);
  uint64_t v21 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48);
  if (v21(v17, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v19 + 8))(v18, v13);
    char v22 = 0;
  }

  else if (v21(v18, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, unint64_t))(v8 + 8))(v17, AssociatedTypeWitness);
    char v22 = 1;
  }

  else
  {
    char v23 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
    int v24 = v30;
    v23(v30, v17, AssociatedTypeWitness);
    uint64_t v25 = v31;
    v23(v31, v18, AssociatedTypeWitness);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    char v22 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 16))( v24,  v25,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v27 = *(void (**)(char *, unint64_t))(v8 + 8);
    v27(v25, AssociatedTypeWitness);
    v27(v24, AssociatedTypeWitness);
  }

  return v22 & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance LazyPrefixWhileSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static LazyPrefixWhileSequence<>.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(const char **)(a3 + 24));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance LazyPrefixWhileSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static LazyPrefixWhileSequence<>.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(const char **)(a3 + 24));
}

void LazyPrefixWhileSequence<>.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v7 = *(const char **)(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v18 - v11;
  uint64_t v14 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0LL, v8, (uint64_t)v7, v13);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = (char *)&v18 - v15;
  (*(void (**)(char *, uint64_t))(v17 + 16))((char *)&v18 - v15, v4);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v10 + 48))(v16, 1LL, AssociatedTypeWitness) == 1)
  {
    Hasher._combine(_:)(0x7FFFFFFFFFFFFFFFuLL);
  }

  else
  {
    (*(void (**)(char *, char *, unint64_t))(v10 + 32))(v12, v16, AssociatedTypeWitness);
    (*(void (**)(uint64_t, unint64_t, uint64_t))(a3 + 24))(a1, AssociatedTypeWitness, a3);
    (*(void (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
  }

Swift::Int LazyPrefixWhileSequence<>.Index<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18[-1] - v9;
  uint64_t v12 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0LL, v6, (uint64_t)v5, v11);
  MEMORY[0x1895F8858](v12);
  uint64_t v14 = (char *)&v18[-1] - v13;
  v18[0] = 0LL;
  v18[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v18[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v18[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v18[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  (*(void (**)(char *, uint64_t))(v15 + 16))((char *)&v18[-1] - v13, v3);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48))(v14, 1LL, AssociatedTypeWitness) == 1)
  {
    Hasher._combine(_:)(0x7FFFFFFFFFFFFFFFuLL);
  }

  else
  {
    (*(void (**)(char *, char *, unint64_t))(v8 + 32))(v10, v14, AssociatedTypeWitness);
    (*(void (**)(void *, unint64_t, uint64_t))(a2 + 24))(v18, AssociatedTypeWitness, a2);
    (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
  }

  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> LazyPrefixWhileSequence<A><>.Index( uint64_t a1, uint64_t a2)
{
  return LazyPrefixWhileSequence<>.Index<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <> LazyPrefixWhileSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> LazyPrefixWhileSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))LazyPrefixWhileSequence<>.Index<>.hash(into:));
}

uint64_t LazyPrefixWhileSequence<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(a2 + 64))(v5);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8)
                                                                               + 56LL))( a3,  0LL,  1LL,  AssociatedTypeWitness);
}

uint64_t LazyPrefixWhileSequence<>.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v22 = a1;
  uint64_t v23 = a3;
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a2 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v22 - v12;
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v22 - v15;
  Collection.first.getter(v5, a2, (uint64_t)v13);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v14 + 48))(v13, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, v9);
  }

  else
  {
    (*(void (**)(char *, char *, unint64_t))(v14 + 32))(v16, v13, AssociatedTypeWitness);
    char v17 = (*(uint64_t (**)(char *))(v3 + *(int *)(v22 + 36)))(v16);
    (*(void (**)(char *, unint64_t))(v14 + 8))(v16, AssociatedTypeWitness);
    if ((v17 & 1) != 0)
    {
      unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v18 - 8) + 56LL))( v23,  1LL,  1LL,  v18);
    }
  }

  uint64_t v20 = v23;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(v5, a2);
  unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(*(void *)(v21 - 8) + 56LL))( v20,  0LL,  1LL,  v21);
}

uint64_t LazyPrefixWhileSequence<>.index(after:)@<X0>( void (*a1)(char *, char *, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  int8x16_t v107 = a1;
  int8x16_t v91 = a5;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v109 = a2;
  uint64_t v8 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0LL, v6, a3, a4);
  uint64_t v98 = *(void *)(v8 - 8);
  uint64_t v99 = v8;
  MEMORY[0x1895F8858](v8);
  int8x16_t v100 = (char *)&v85 - v9;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v108 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64x2_t v96 = (char *)&v85 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64x2_t v95 = (char *)&v85 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  int8x16_t v105 = (char *)&v85 - v15;
  MEMORY[0x1895F8858](v14);
  uint16x8_t v93 = (char *)&v85 - v16;
  unint64_t v17 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a3 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v90 = type metadata accessor for Optional(0LL, v17, v18, v19);
  uint64_t v89 = *(void *)(v90 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v90);
  uint64_t v22 = (char *)&v85 - v21;
  uint64_t v23 = *(void *)(v17 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v20);
  unint64_t v86 = (char *)&v85 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v85 - v27;
  uint64_t v29 = *(void *)(a2 - 8);
  uint64_t v30 = MEMORY[0x1895F8858](v26);
  uint32x4_t v94 = (char *)&v85 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v30);
  uint64_t v33 = (char *)&v85 - v32;
  uint64_t v35 = type metadata accessor for LazyPrefixWhileSequence<>.Index(0LL, v6, a3, v34);
  uint64_t v36 = MEMORY[0x1895F8858](v35);
  char v38 = (char *)&v85 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v36);
  unint64_t v40 = (char *)&v85 - v39;
  uint64_t v102 = v42;
  uint16x8_t v103 = v41;
  (*(void (**)(char *, void (*)(char *, char *, uint64_t)))(v42 + 16))((char *)&v85 - v39, v107);
  uint64_t v97 = v29;
  unint64_t v43 = *(void (**)(char *, uint64_t, uint64_t))(v29 + 16);
  uint64_t v44 = v109;
  uint8x8_t v92 = v43;
  ((void (*)(char *, uint64_t))v43)(v33, v106);
  int8x16_t v104 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v6;
  Collection.first.getter(v6, a3, (uint64_t)v22);
  int v45 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v23 + 48))(v22, 1LL, v17);
  unint64_t v88 = v17;
  uint64_t v87 = v23;
  if (v45 == 1)
  {
    (*(void (**)(char *, uint64_t))(v89 + 8))(v22, v90);
  }

  else
  {
    (*(void (**)(char *, char *, unint64_t))(v23 + 32))(v28, v22, v17);
    char v46 = (*(uint64_t (**)(char *))&v33[*(int *)(v44 + 36)])(v28);
    (*(void (**)(char *, unint64_t))(v23 + 8))(v28, v17);
    if ((v46 & 1) != 0)
    {
      uint64_t v47 = *(void (**)(char *, uint64_t, uint64_t, unint64_t))(v108 + 56);
      uint64_t v48 = AssociatedTypeWitness;
      v47(v38, 1LL, 1LL, AssociatedTypeWitness);
      uint64_t v49 = (uint64_t)v104;
      goto LABEL_6;
    }
  }

  uint64_t v49 = (uint64_t)v104;
  (*(void (**)(uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t))(a3 + 64))(v104, a3);
  uint64_t v47 = *(void (**)(char *, uint64_t, uint64_t, unint64_t))(v108 + 56);
  uint64_t v48 = AssociatedTypeWitness;
  v47(v38, 0LL, 1LL, AssociatedTypeWitness);
LABEL_6:
  uint64_t v50 = v102;
  int64_t v51 = v103;
  char v52 = static LazyPrefixWhileSequence<>.Index.== infix(_:_:)((uint64_t)v40, (uint64_t)v38, v49, (const char *)a3);
  uint64_t v53 = *(void (**)(char *, void))(v50 + 8);
  v53(v38, v51);
  if ((v52 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't advance past endIndex",  27LL,  2,  "Swift/PrefixWhile.swift",  23LL,  2,  0xEDuLL,  0);
  }
  uint64_t v54 = v109;
  uint16x8_t v103 = *(void (**)(void, void))(v97 + 8);
  int8x16_t v104 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v47;
  v103(v33, v109);
  v53(v40, v51);
  uint64_t v56 = v98;
  uint64_t v55 = v99;
  uint64_t v57 = v100;
  (*(void (**)(char *, void, uint64_t))(v98 + 16))(v100, v107, v99);
  uint64_t v58 = v108;
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v108 + 48))(v57, 1LL, v48) == 1)
  {
    (*(void (**)(char *, uint64_t))(v56 + 8))(v57, v55);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid index passed to index(after:)",  37LL,  2,  "Swift/PrefixWhile.swift",  23LL,  2,  0xEFuLL,  0);
  }

  uint64_t v59 = v93;
  int8x16_t v107 = *(void (**)(char *, char *, uint64_t))(v58 + 32);
  v107(v93, v57, v48);
  uint64_t v60 = v105;
  uint64_t v61 = v106;
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 184))(v59, v49, a3);
  unint64_t v62 = *(void (**)(char *, uint64_t))(v58 + 8);
  v62(v59, v48);
  uint64_t v63 = v95;
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v49, a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  v49,  v48,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v65 = v58;
  char v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v60,  v63,  v48);
  v62(v63, v48);
  char v67 = v94;
  v92(v94, v61, v54);
  uint64_t v68 = *(void (**)(char *, char *, uint64_t))(v65 + 16);
  uint64_t v69 = v96;
  v68(v96, v60, v48);
  if ((v66 & 1) != 0)
  {
    v62(v69, v48);
    v103(v67, v54);
    unsigned int v73 = v91;
LABEL_12:
    v62(v105, v48);
    uint64_t v83 = 1LL;
    return v104((uint64_t)v73, v83, 1LL, v48);
  }

  uint64_t v74 = &v67[*(int *)(v54 + 36)];
  unsigned int v75 = (unint64_t *)*((void *)v74 + 1);
  uint64_t v108 = *(void *)v74;
  uint64_t v76 = v54;
  unsigned int v77 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a3 + 80);
  swift_retain(v75, v70, v71, v72);
  unint64_t v78 = v69;
  uint64_t v79 = v77(v110, v69, v49, a3);
  uint64_t v80 = v87;
  int8x16_t v81 = v86;
  unint64_t v82 = v88;
  (*(void (**)(char *))(v87 + 16))(v86);
  ((void (*)(_BYTE *, void))v79)(v110, 0LL);
  v62(v78, v48);
  v103(v67, v76);
  LOBYTE(v79) = ((uint64_t (*)(char *))v108)(v81);
  swift_release((uint64_t)v75);
  (*(void (**)(char *, unint64_t))(v80 + 8))(v81, v82);
  unsigned int v73 = v91;
  if ((v79 & 1) == 0) {
    goto LABEL_12;
  }
  v107(v91, v105, v48);
  uint64_t v83 = 0LL;
  return v104((uint64_t)v73, v83, 1LL, v48);
}

uint64_t LazyPrefixWhileSequence<>.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = &v22[-v10];
  uint64_t v13 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0LL, v7, a3, v12);
  MEMORY[0x1895F8858](v13);
  uint64_t v15 = &v22[-v14];
  (*(void (**)(_BYTE *, uint64_t))(v16 + 16))(&v22[-v14], a1);
  if ((*(unsigned int (**)(_BYTE *, uint64_t, unint64_t))(v9 + 48))(v15, 1LL, AssociatedTypeWitness) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/PrefixWhile.swift",  23LL,  2,  0xFEuLL,  0);
  }
  (*(void (**)(_BYTE *, _BYTE *, unint64_t))(v9 + 32))(v11, v15, AssociatedTypeWitness);
  unint64_t v17 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t, uint64_t))(a3 + 80))( v22,  v11,  v7,  a3);
  uint64_t v19 = v18;
  unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v20 - 8) + 16LL))(a4, v19, v20);
  v17(v22, 0LL);
  return (*(uint64_t (**)(_BYTE *, unint64_t))(v9 + 8))(v11, AssociatedTypeWitness);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance <> LazyPrefixWhileSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyPrefixWhileSequence<>.startIndex.getter(a1, *(void *)(a2 - 8), a3);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance <> LazyPrefixWhileSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return LazyPrefixWhileSequence<>.endIndex.getter(a1, *(void *)(a2 - 8), a3);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> LazyPrefixWhileSequence<A>( unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v8 = (unint64_t *)malloc(0x28uLL);
  *a1 = v8;
  v8[4] = (unint64_t)LazyPrefixWhileSequence<>.subscript.read(v8, a2, a3, *(void *)(a4 - 8));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*LazyPrefixWhileSequence<>.subscript.read( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4))()
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  *(void *)(a3 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  *a1 = AssociatedTypeWitness;
  unint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  a1[1] = v9;
  uint64_t v10 = malloc(*(void *)(v9 + 64));
  a1[2] = (unint64_t)v10;
  LazyPrefixWhileSequence<>.subscript.getter(a2, a3, a4, (uint64_t)v10);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> LazyPrefixWhileSequence<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = type metadata accessor for LazyPrefixWhileSequence<>.Index(255LL, *(void *)(a1 + 16), *(void *)(a2 - 8), a3);
  uint64_t v8 = type metadata accessor for Optional(0LL, v5, v6, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 56LL))(a4, 1LL, 1LL, v8);
}

uint64_t protocol witness for Collection.index(after:) in conformance <> LazyPrefixWhileSequence<A>@<X0>( void (*a1)(char *, char *, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  return LazyPrefixWhileSequence<>.index(after:)(a1, a2, *(void *)(a3 - 8), a4, a5);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> LazyPrefixWhileSequence<A>( void (*a1)(char *, char *, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = type metadata accessor for LazyPrefixWhileSequence<>.Index(0LL, *(void *)(a2 + 16), v6, a4);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v13 - v9;
  LazyPrefixWhileSequence<>.index(after:)(a1, a2, v6, v11, (char *)&v13 - v9);
  (*(void (**)(void (*)(char *, char *, uint64_t), uint64_t))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(void, char *, uint64_t))(v8 + 32))(a1, v10, v7);
}

uint64_t LazyPrefixWhileSequence<>.index(before:)@<X0>( void (*a1)(char *, unint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = a2;
  int8x16_t v104 = a1;
  uint64_t v85 = a4;
  uint64_t v91 = a3;
  uint64_t v5 = *(void *)(a3 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v5 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v95 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v96 = AssociatedTypeWitness;
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint32x4_t v94 = (char *)&v84 - v9;
  uint64_t v10 = *(void *)(v4 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v98 = (char *)&v84 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint8x8_t v92 = (char *)&v84 - v13;
  unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v15 = *(void *)(v14 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v97 = (char *)&v84 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  unint64_t v20 = (char *)&v84 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v84 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v84 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v102 = (uint64_t (*)(char *))((char *)&v84 - v28);
  MEMORY[0x1895F8858](v27);
  uint64_t v30 = (char *)&v84 - v29;
  uint64_t v103 = v6;
  uint64_t v32 = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(0LL, v6, v5, v31);
  MEMORY[0x1895F8858](v32);
  uint64_t v34 = (char *)&v84 - v33;
  (*(void (**)(char *, void))(v35 + 16))((char *)&v84 - v33, v104);
  int v36 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v15 + 48))(v34, 1LL, v14);
  uint64_t v99 = v26;
  unint64_t v100 = v14;
  if (v36 == 1)
  {
    uint64_t v37 = v103;
    (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v103, v5);
    char v38 = *(char **)(v5 + 184);
    uint64_t v91 = *(void *)(v5 + 72);
    uint8x8_t v92 = v38;
    uint64_t v90 = *(void *)(swift_getAssociatedConformanceWitness( v5,  v37,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    uint64_t v39 = *(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v90 + 8);
    uint64_t v88 = v15;
    uint64_t v89 = v39;
    uint64_t v86 = v5;
    uint64_t v87 = v20;
    uint16x8_t v93 = v23;
    while (1)
    {
      unint64_t v40 = v23;
      uint64_t v41 = v101;
      uint64_t v42 = v103;
      ((void (*)(char *, uint64_t, uint64_t))v92)(v40, v103, v5);
      ((void (*)(uint64_t, uint64_t))v91)(v42, v5);
      char v43 = v89(v20, v26, v14, v90);
      int8x16_t v104 = *(void (**)(char *, unint64_t))(v15 + 8);
      v104(v26, v14);
      uint64_t v44 = v98;
      (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v98, v41, v4);
      int v45 = v97;
      (*(void (**)(char *, char *, unint64_t))(v15 + 16))(v97, v20, v14);
      if ((v43 & 1) != 0) {
        break;
      }
      uint64_t v49 = &v44[*(int *)(v4 + 36)];
      uint64_t v50 = v10;
      uint64_t v102 = *(uint64_t (**)(char *))v49;
      int64_t v51 = v44;
      char v52 = (unint64_t *)*((void *)v49 + 1);
      uint64_t v53 = v103;
      uint64_t v54 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v5 + 80);
      swift_retain(v52, v46, v47, v48);
      uint64_t v55 = v54(v105, v45, v53, v5);
      uint64_t v56 = v4;
      unint64_t v57 = v100;
      uint64_t v58 = (void (*)(_BYTE *, void))v55;
      uint64_t v59 = v95;
      unint64_t v60 = v96;
      uint64_t v61 = v45;
      unint64_t v62 = v94;
      (*(void (**)(char *))(v95 + 16))(v94);
      v58(v105, 0LL);
      v104(v61, v57);
      uint64_t v10 = v50;
      uint64_t v63 = *(void (**)(char *, uint64_t))(v50 + 8);
      uint64_t v64 = v51;
      unint64_t v20 = v87;
      uint64_t v65 = v56;
      v63(v64, v56);
      char v66 = v102(v62);
      uint64_t v15 = v88;
      LOBYTE(v58) = v66;
      swift_release((uint64_t)v52);
      char v67 = *(void (**)(char *, unint64_t))(v59 + 8);
      unint64_t v14 = v57;
      v67(v62, v60);
      uint64_t v23 = v93;
      v104(v93, v57);
      (*(void (**)(char *, char *, unint64_t))(v15 + 32))(v23, v20, v57);
      uint64_t v5 = v86;
      uint64_t v4 = v65;
      uint64_t v26 = v99;
    }

    v104(v45, v14);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v44, v4);
LABEL_9:
    v104(v20, v14);
    unint64_t v82 = v14;
    uint64_t v83 = v85;
    (*(void (**)(uint64_t, char *, unint64_t))(v15 + 32))(v85, v93, v82);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v15 + 56))(v83, 0LL, 1LL, v82);
  }

  else
  {
    uint64_t v68 = v4;
    int8x16_t v104 = *(void (**)(char *, unint64_t))(v15 + 32);
    ((void (*)(char *, char *, unint64_t))v104)(v30, v34, v14);
    uint64_t v69 = v102;
    (*(void (**)(uint64_t (*)(char *), char *, unint64_t))(v15 + 16))(v102, v30, v14);
    uint64_t v70 = v92;
    (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v92, v101, v68);
    uint64_t v71 = v103;
    (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v103, v5);
    uint64_t v72 = v71;
    unsigned int v73 = v99;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  v72,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    char v75 = (*(uint64_t (**)(uint64_t (*)(char *), char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                                              + 8LL))( v69,  v73,  v14);
    unint64_t v76 = v14;
    char v77 = v75;
    unint64_t v78 = *(void (**)(char *, unint64_t))(v15 + 8);
    v78(v73, v76);
    if ((v77 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't move before startIndex",  28LL,  2,  "Swift/PrefixWhile.swift",  23LL,  2,  0x10BuLL,  0);
    }
    (*(void (**)(char *, uint64_t))(v10 + 8))(v70, v68);
    unint64_t v79 = v100;
    v78((char *)v102, v100);
    (*(void (**)(char *, uint64_t))(v91 + 32))(v30, v103);
    v78(v30, v79);
    uint64_t v80 = v85;
    ((void (*)(uint64_t, char *, unint64_t))v104)(v85, v73, v79);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v15 + 56))(v80, 0LL, 1LL, v79);
  }

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> LazyPrefixWhileSequence<A>@<X0>( void (*a1)(char *, unint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return LazyPrefixWhileSequence<>.index(before:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> LazyPrefixWhileSequence<A>( void (*a1)(char *, unint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a3 - 8);
  uint64_t v7 = type metadata accessor for LazyPrefixWhileSequence<>.Index(0LL, *(void *)(a2 + 16), *(void *)(v6 + 8), a4);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v12 - v9;
  LazyPrefixWhileSequence<>.index(before:)(a1, a2, v6, (uint64_t)&v12 - v9);
  (*(void (**)(void, uint64_t))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(void (*)(char *, unint64_t), char *, uint64_t))(v8 + 32))( a1,  v10,  v7);
}

Swift::Void __swiftcall _prespecialize()()
{
}

void Dictionary._Variant.__specialize_setValue(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void Array.__specialize_append(_:)(uint64_t a1, uint64_t a2)
{
}

void Set._Variant.__specialize_insert(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t specialized Set._Variant.insert(_:)(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = specialized static Hasher._hash(seed:_:)(*(void *)(v6 + 40), a2);
  uint64_t v8 = -1LL << *(_BYTE *)(v6 + 32);
  unint64_t v9 = v7 & ~v8;
  if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) != 0)
  {
    uint64_t v10 = ~v8;
    while (*(void *)(*(void *)(v6 + 48) + 8 * v9) != a2)
    {
      unint64_t v9 = (v9 + 1) & v10;
      if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0) {
        goto LABEL_5;
      }
    }

    uint64_t result = 0LL;
  }

  else
  {
LABEL_5:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    specialized _NativeSet.insertNew(_:at:isUnique:)(a2, v9, isUniquelyReferenced_nonNull_native);
    uint64_t v12 = *v3;
    *uint64_t v3 = v14;
    swift_bridgeObjectRelease(v12);
    uint64_t result = 1LL;
  }

  *a1 = a2;
  return result;
}

{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = specialized static Hasher._hash(seed:_:)(*(void *)(v6 + 40), a2);
  uint64_t v8 = -1LL << *(_BYTE *)(v6 + 32);
  unint64_t v9 = v7 & ~v8;
  if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) != 0)
  {
    uint64_t v10 = ~v8;
    while (*(void *)(*(void *)(v6 + 48) + 8 * v9) != a2)
    {
      unint64_t v9 = (v9 + 1) & v10;
      if (((*(void *)(v6 + 56 + ((v9 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v9) & 1) == 0) {
        goto LABEL_5;
      }
    }

    uint64_t result = 0LL;
  }

  else
  {
LABEL_5:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v14 = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    specialized _NativeSet.insertNew(_:at:isUnique:)(a2, v9, isUniquelyReferenced_nonNull_native);
    uint64_t v12 = *v3;
    *uint64_t v3 = v14;
    swift_bridgeObjectRelease(v12);
    uint64_t result = 1LL;
  }

  *a1 = a2;
  return result;
}

uint64_t specialized Set._Variant.insert(_:)( unint64_t *a1, unint64_t a2, unint64_t a3, char *a4)
{
  unint64_t v8 = *v4;
  uint64_t v9 = _swift_stdlib_Hashing_parameters ^ *(void *)(*v4 + 40);
  v31[0] = 0LL;
  v31[1] = v9 ^ 0x736F6D6570736575LL;
  v31[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v31[3] = v9 ^ 0x6C7967656E657261LL;
  v31[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  swift_bridgeObjectRetain(v8, a2, a3, a4);
  String.hash(into:)(v31, a2, a3);
  Swift::Int v10 = Hasher._finalize()();
  uint64_t v11 = -1LL << *(_BYTE *)(v8 + 32);
  unint64_t v12 = v10 & ~v11;
  if (((*(void *)(v8 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v12) & 1) != 0)
  {
    uint64_t v13 = ~v11;
    uint64_t v14 = *(void *)(v8 + 48);
    while (1)
    {
      uint64_t v15 = (uint64_t *)(v14 + 16 * v12);
      unint64_t v16 = v15[1];
      if (*v15 == a2 && v16 == a3) {
        break;
      }
      BOOL v18 = (~v16 & 0x6000000000000000LL) != 0 || (a3 & 0x2000000000000000LL) == 0;
      BOOL v19 = v18 || (a3 & 0x4000000000000000LL) == 0;
      if (v19 && (_stringCompareInternal(_:_:expecting:)(*v15, v16, a2, a3, 0) & 1) != 0) {
        break;
      }
      unint64_t v12 = (v12 + 1) & v13;
      if (((*(void *)(v8 + 56 + ((v12 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v12) & 1) == 0) {
        goto LABEL_18;
      }
    }

    swift_bridgeObjectRelease(a3);
    swift_bridgeObjectRelease(v8);
    unint64_t v20 = (unint64_t *)(*(void *)(*v4 + 48) + 16 * v12);
    unint64_t v21 = v20[1];
    *a1 = *v20;
    a1[1] = v21;
    swift_bridgeObjectRetain(v21, v22, v23, v24);
    return 0LL;
  }

  else
  {
LABEL_18:
    swift_bridgeObjectRelease(v8);
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
    v31[0] = *v4;
    *uint64_t v4 = 0x8000000000000000LL;
    swift_bridgeObjectRetain(a3, v27, v28, v29);
    specialized _NativeSet.insertNew(_:at:isUnique:)(a2, a3, v12, isUniquelyReferenced_nonNull_native);
    uint64_t v30 = *v4;
    *uint64_t v4 = v31[0];
    swift_bridgeObjectRelease(v30);
    *a1 = a2;
    a1[1] = a3;
    return 1LL;
  }

uint64_t specialized Set._Variant.insert(_:)(uint64_t a1, uint64_t a2)
{
  void (*v9)(uint64_t *__return_ptr, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v29;
  __int128 v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34[5];
  uint64_t v35[3];
  uint64_t v36;
  uint64_t v37;
  uint64_t v38[3];
  uint64_t v39;
  uint64_t v40;
  unint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 40);
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a2, v7);
  uint64_t v9 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8);
  swift_bridgeObjectRetain(v5, v10, v11, v12);
  v9(v38, v7, v8);
  uint64_t v13 = v39;
  uint64_t v14 = v40;
  __swift_project_boxed_opaque_existential_0Tm(v38, v39);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 40))(v6, v13, v14);
  __swift_destroy_boxed_opaque_existential_1Tm(v38);
  unint64_t v16 = -1LL << *(_BYTE *)(v5 + 32);
  uint64_t v17 = v15 & ~v16;
  __int128 v32 = a1;
  __int128 v33 = v5;
  BOOL v18 = v5 + 56;
  if (((*(void *)(v18 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) != 0)
  {
    BOOL v19 = ~v16;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v33 + 48) + 40 * v17, (uint64_t)v38);
      unint64_t v20 = v39;
      unint64_t v21 = v40;
      __swift_project_boxed_opaque_existential_0Tm(v38, v39);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v21 + 8))(v35, v20, v21);
      uint64_t v22 = v36;
      uint64_t v23 = v37;
      __swift_project_boxed_opaque_existential_0Tm(v35, v36);
      uint64_t v25 = *(void *)(a2 + 24);
      uint64_t v24 = *(void *)(a2 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)a2, v25);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v24 + 8))(v34, v25, v24);
      uint64_t v26 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v23 + 16))(v34, v22, v23);
      __swift_destroy_boxed_opaque_existential_1Tm(v34);
      if (v26 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v35);
        outlined destroy of AnyHashable(v38);
      }

      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v35);
        outlined destroy of AnyHashable(v38);
        if ((v26 & 1) != 0)
        {
          swift_bridgeObjectRelease(v33);
          outlined destroy of AnyHashable((uint64_t *)a2);
          outlined init with copy of AnyHashable(*(void *)(*v31 + 48) + 40 * v17, v32);
          return 0LL;
        }
      }

      uint64_t v17 = (v17 + 1) & v19;
    }

    while (((*(void *)(v18 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) != 0);
  }

  swift_bridgeObjectRelease(v33);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v31);
  outlined init with copy of AnyHashable(a2, (uint64_t)v38);
  v35[0] = *v31;
  *uint64_t v31 = 0x8000000000000000LL;
  specialized _NativeSet.insertNew(_:at:isUnique:)((uint64_t)v38, v17, isUniquelyReferenced_nonNull_native);
  uint64_t v29 = *v31;
  *uint64_t v31 = v35[0];
  swift_bridgeObjectRelease(v29);
  uint64_t v30 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)__int128 v32 = *(_OWORD *)a2;
  *(_OWORD *)(v32 + 16) = v30;
  *(void *)(v32 + 32) = *(void *)(a2 + 32);
  return 1LL;
}

{
  unint64_t *v2;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(__int128 *__return_ptr, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char isUniquelyReferenced_nonNull_native;
  uint64_t v29;
  __int128 v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34[5];
  uint64_t v35[3];
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v5 = *v2;
  uint64_t v6 = *(void *)(*v2 + 40);
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 32);
  __swift_project_boxed_opaque_existential_0Tm((void *)a2, v7);
  uint64_t v9 = *(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v8 + 8);
  swift_bridgeObjectRetain(v5, v10, v11, v12);
  v9(&v38, v7, v8);
  uint64_t v13 = v39;
  uint64_t v14 = v40;
  __swift_project_boxed_opaque_existential_0Tm(&v38, v39);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 40))(v6, v13, v14);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v38);
  unint64_t v16 = -1LL << *(_BYTE *)(v5 + 32);
  uint64_t v17 = v15 & ~v16;
  __int128 v32 = a1;
  __int128 v33 = v5;
  BOOL v18 = v5 + 56;
  if (((*(void *)(v18 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) != 0)
  {
    BOOL v19 = ~v16;
    do
    {
      outlined init with copy of AnyHashable(*(void *)(v33 + 48) + 40 * v17, (uint64_t)&v38);
      unint64_t v20 = v39;
      unint64_t v21 = v40;
      __swift_project_boxed_opaque_existential_0Tm(&v38, v39);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v21 + 8))(v35, v20, v21);
      uint64_t v22 = v36;
      uint64_t v23 = v37;
      __swift_project_boxed_opaque_existential_0Tm(v35, v36);
      uint64_t v25 = *(void *)(a2 + 24);
      uint64_t v24 = *(void *)(a2 + 32);
      __swift_project_boxed_opaque_existential_0Tm((void *)a2, v25);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v24 + 8))(v34, v25, v24);
      uint64_t v26 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v23 + 16))(v34, v22, v23);
      __swift_destroy_boxed_opaque_existential_1Tm(v34);
      if (v26 == 2)
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v35);
        outlined destroy of AnyHashable((uint64_t *)&v38);
      }

      else
      {
        __swift_destroy_boxed_opaque_existential_1Tm(v35);
        outlined destroy of AnyHashable((uint64_t *)&v38);
        if ((v26 & 1) != 0)
        {
          swift_bridgeObjectRelease(v33);
          outlined destroy of AnyHashable((uint64_t *)a2);
          outlined init with copy of AnyHashable(*(void *)(*v31 + 48) + 40 * v17, v32);
          return 0LL;
        }
      }

      uint64_t v17 = (v17 + 1) & v19;
    }

    while (((*(void *)(v18 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) != 0);
  }

  swift_bridgeObjectRelease(v33);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v31);
  outlined init with copy of AnyHashable(a2, (uint64_t)&v38);
  v35[0] = *v31;
  *uint64_t v31 = 0x8000000000000000LL;
  specialized _NativeSet.insertNew(_:at:isUnique:)(&v38, v17, isUniquelyReferenced_nonNull_native);
  uint64_t v29 = *v31;
  *uint64_t v31 = v35[0];
  swift_bridgeObjectRelease(v29);
  uint64_t v30 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)__int128 v32 = *(_OWORD *)a2;
  *(_OWORD *)(v32 + 16) = v30;
  *(void *)(v32 + 32) = *(void *)(a2 + 32);
  return 1LL;
}

uint64_t Set._Variant.insert(_:)(char *a1, id *a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v7 = a1;
  uint64_t v8 = *(uint64_t **)(a3 + 16);
  uint64_t v9 = *(v8 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  unint64_t v12 = (char *)&v55 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v17 = (char *)&v55 - v16;
  uint64_t v18 = *v4;
  if ((*v4 & 0xC000000000000001LL) != 0)
  {
    uint64_t v58 = v7;
    uint64_t v19 = v9;
    uint64_t v23 = _bridgeAnythingToObjectiveC<A>(_:)(a2, v8);
    uint64_t v24 = *v4;
    if ((*v4 & 0x8000000000000000LL) != 0LL) {
      uint64_t v25 = (void *)*v4;
    }
    else {
      uint64_t v25 = (void *)(*v4 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(*v4, v20, v21, v22);
    id v26 = objc_msgSend(v25, sel_member_, v23);
    swift_unknownObjectRelease(v23);
    if (v26)
    {
      (*(void (**)(id *, uint64_t *))(v19 + 8))(a2, v8);
      swift_bridgeObjectRelease(v24);
      _forceBridgeFromObjectiveC<A>(_:_:)(v26, (char *)v8, v27, v58);
      swift_unknownObjectRelease(v26);
      return 0LL;
    }

    uint64_t result = (uint64_t)objc_msgSend(v25, sel_count);
    if (__OFADD__(result, 1LL))
    {
      __break(1u);
      return result;
    }

    uint64_t v44 = *(void *)(a3 + 24);
    int v45 = _NativeSet.init(_:capacity:)(v25, result + 1, (char *)v8, v44);
    uint64_t v64 = v45;
    (*(void (**)(char *, id *, uint64_t *))(v19 + 16))(v12, a2, v8);
    uint64_t v47 = v45[2];
    if (v45[3] <= v47)
    {
      Swift::Int v48 = (Swift::Int)&v47->isa + 1;
      type metadata accessor for _NativeSet(0LL, (uint64_t)v8, v44, v46);
      _NativeSet.resize(capacity:)(v48);
      int v45 = v64;
    }

    _NativeSet._unsafeInsertNew(_:)((uint64_t)v12, (uint64_t)v45, (uint64_t)v8, v44);
    uint64_t v49 = *v4;
    *uint64_t v4 = (unint64_t)v45;
    swift_bridgeObjectRelease(v49);
    (*(void (**)(char *, id *, uint64_t *))(v19 + 32))(v58, a2, v8);
    return 1LL;
  }

  unint64_t v57 = (uint64_t *)v4;
  uint64_t v29 = *(void *)(v18 + 40);
  uint64_t v30 = *(void *)(a3 + 24);
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(v30 + 32);
  swift_bridgeObjectRetain(v18, v13, v14, v15);
  uint64_t v32 = v31(v29, v8, v30);
  uint64_t v33 = -1LL << *(_BYTE *)(v18 + 32);
  unint64_t v34 = v32 & ~v33;
  uint64_t v62 = v18 + 56;
  if (((*(void *)(v18 + 56 + ((v34 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v34) & 1) == 0)
  {
    swift_bridgeObjectRelease(v18);
    char v38 = *(void (**)(char *, id *, uint64_t *))(v9 + 16);
LABEL_17:
    uint64_t v50 = v57;
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v57);
    v38(v17, a2, v8);
    uint64_t v64 = (__objc2_class **)*v50;
    uint64_t *v50 = 0x8000000000000000LL;
    uint64_t v53 = type metadata accessor for _NativeSet(0LL, (uint64_t)v8, v30, v52);
    _NativeSet.insertNew(_:at:isUnique:)((uint64_t)v17, v34, isUniquelyReferenced_nonNull_native, v53);
    uint64_t v54 = *v50;
    uint64_t *v50 = (uint64_t)v64;
    swift_bridgeObjectRelease(v54);
    (*(void (**)(char *, id *, uint64_t *))(v9 + 32))(v7, a2, v8);
    return 1LL;
  }

  uint64_t v58 = v7;
  uint64_t v59 = ~v33;
  uint64_t v35 = v9;
  uint64_t v56 = v30;
  uint64_t v36 = *(void *)(v30 + 8);
  uint64_t v37 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v36 + 8);
  uint64_t v60 = *(void *)(v35 + 72);
  uint64_t v61 = v37;
  uint64_t v63 = v35;
  char v38 = *(void (**)(char *, id *, uint64_t *))(v35 + 16);
  while (1)
  {
    unint64_t v39 = v60 * v34;
    unint64_t v40 = v38;
    v38(v17, (id *)(*(void *)(v18 + 48) + v60 * v34), v8);
    uint64_t v41 = a2;
    char v42 = v61(v17, a2, v8, v36);
    char v43 = *(void (**)(char *, uint64_t *))(v63 + 8);
    v43(v17, v8);
    if ((v42 & 1) != 0) {
      break;
    }
    unint64_t v34 = (v34 + 1) & v59;
    a2 = v41;
    char v38 = v40;
    if (((*(void *)(v62 + ((v34 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v34) & 1) == 0)
    {
      swift_bridgeObjectRelease(v18);
      uint64_t v7 = v58;
      uint64_t v9 = v63;
      uint64_t v30 = v56;
      goto LABEL_17;
    }
  }

  swift_bridgeObjectRelease(v18);
  v43((char *)v41, v8);
  v40(v58, (id *)(*(void *)(*v57 + 48) + v39), v8);
  return 0LL;
}

uint64_t specialized Set._Variant.remove(_:)(unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v7 = *v4;
  uint64_t v8 = _swift_stdlib_Hashing_parameters ^ *(void *)(*v4 + 40);
  v27[0] = 0LL;
  v27[1] = v8 ^ 0x736F6D6570736575LL;
  v27[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v27[3] = v8 ^ 0x6C7967656E657261LL;
  id v27[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  swift_bridgeObjectRetain(v7, a2, a3, a4);
  String.hash(into:)(v27, a1, a2);
  Swift::Int v9 = Hasher._finalize()();
  uint64_t v10 = -1LL << *(_BYTE *)(v7 + 32);
  unint64_t v11 = v9 & ~v10;
  if (((*(void *)(v7 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) != 0)
  {
    uint64_t v12 = ~v10;
    uint64_t v13 = *(void *)(v7 + 48);
    while (1)
    {
      uint64_t v14 = (uint64_t *)(v13 + 16 * v11);
      unint64_t v15 = v14[1];
      if (*v14 == a1 && v15 == a2) {
        break;
      }
      BOOL v17 = (~v15 & 0x6000000000000000LL) != 0 || (a2 & 0x2000000000000000LL) == 0;
      BOOL v18 = v17 || (a2 & 0x4000000000000000LL) == 0;
      if (v18 && (_stringCompareInternal(_:_:expecting:)(*v14, v15, a1, a2, 0) & 1) != 0) {
        break;
      }
      unint64_t v11 = (v11 + 1) & v12;
      if (((*(void *)(v7 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v11) & 1) == 0) {
        goto LABEL_20;
      }
    }

    swift_bridgeObjectRelease(v7);
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v4);
    unint64_t v23 = *v4;
    v27[0] = *v4;
    *uint64_t v4 = 0x8000000000000000LL;
    if (!isUniquelyReferenced_nonNull_native)
    {
      specialized _NativeSet.copy()();
      unint64_t v23 = v27[0];
    }

    uint64_t v24 = *(void *)(*(void *)(v23 + 48) + 16 * v11);
    specialized _NativeSet._delete(at:)(v11, v20, v21, v22);
    uint64_t v25 = *v4;
    *uint64_t v4 = v27[0];
    swift_bridgeObjectRelease(v25);
  }

  else
  {
LABEL_20:
    swift_bridgeObjectRelease(v7);
    return 0LL;
  }

  return v24;
}

double specialized Set._Variant.remove(_:)@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  void (*v8)(uint64_t *__return_ptr, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  BOOL isUniquelyReferenced_nonNull_native;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  double result;
  uint64_t *v35;
  uint64_t v37;
  uint64_t v38[5];
  uint64_t v39[3];
  uint64_t v40;
  uint64_t v41;
  uint64_t v42[3];
  uint64_t v43;
  uint64_t v44;
  unint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 40);
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  uint64_t v8 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 8);
  swift_bridgeObjectRetain(v4, v9, v10, v11);
  v8(v42, v6, v7);
  uint64_t v12 = v43;
  uint64_t v13 = v44;
  __swift_project_boxed_opaque_existential_0Tm(v42, v43);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 40))(v5, v12, v13);
  __swift_destroy_boxed_opaque_existential_1Tm(v42);
  unint64_t v15 = -1LL << *(_BYTE *)(v4 + 32);
  uint64_t v16 = v14 & ~v15;
  BOOL v17 = v4;
  BOOL v18 = v4 + 56;
  if (((*(void *)(v18 + ((v16 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v16) & 1) == 0)
  {
LABEL_10:
    swift_bridgeObjectRelease(v17);
    *(void *)(a2 + 32) = 0LL;
    uint64_t result = 0.0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    return result;
  }

  uint64_t v37 = ~v15;
  while (1)
  {
    outlined init with copy of AnyHashable(*(void *)(v17 + 48) + 40 * v16, (uint64_t)v42);
    uint64_t v19 = v43;
    uint64_t v20 = v44;
    __swift_project_boxed_opaque_existential_0Tm(v42, v43);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v39, v19, v20);
    uint64_t v21 = v40;
    uint64_t v22 = v41;
    __swift_project_boxed_opaque_existential_0Tm(v39, v40);
    uint64_t v24 = a1[3];
    unint64_t v23 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v24);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v23 + 8))(v38, v24, v23);
    uint64_t v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v22 + 16))(v38, v21, v22);
    __swift_destroy_boxed_opaque_existential_1Tm(v38);
    if (v25 != 2) {
      break;
    }
    __swift_destroy_boxed_opaque_existential_1Tm(v39);
    outlined destroy of AnyHashable(v42);
LABEL_4:
    uint64_t v16 = (v16 + 1) & v37;
    if (((*(void *)(v18 + ((v16 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v16) & 1) == 0) {
      goto LABEL_10;
    }
  }

  __swift_destroy_boxed_opaque_existential_1Tm(v39);
  outlined destroy of AnyHashable(v42);
  if ((v25 & 1) == 0) {
    goto LABEL_4;
  }
  swift_bridgeObjectRelease(v17);
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v35);
  uint64_t v30 = *v35;
  v42[0] = *v35;
  *uint64_t v35 = 0x8000000000000000LL;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized _NativeSet.copy()();
    uint64_t v30 = v42[0];
  }

  uint64_t v31 = *(void *)(v30 + 48) + 40 * v16;
  uint64_t v32 = *(_OWORD *)(v31 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v31;
  *(_OWORD *)(a2 + 16) = v32;
  *(void *)(a2 + 32) = *(void *)(v31 + 32);
  specialized _NativeSet._delete(at:)(v16, v27, v28, v29);
  uint64_t v33 = *v35;
  *uint64_t v35 = v42[0];
  swift_bridgeObjectRelease(v33);
  return result;
}

void specialized Set._Variant.remove(_:)(void *a1@<X0>, uint64_t a2@<X8>)
{
  void (*v8)(__int128 *__return_ptr, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t *v26;
  BOOL isUniquelyReferenced_nonNull_native;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  char v38;
  void *v39;
  void *v40;
  uint64_t v41;
  unint64_t v42;
  int64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  int64_t v54;
  unint64_t v55;
  int64_t v56;
  uint64_t *v57;
  uint64_t v59;
  uint64_t v60[5];
  uint64_t v61[3];
  uint64_t v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  unint64_t v4 = *v2;
  uint64_t v5 = *(void *)(*v2 + 40);
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  uint64_t v8 = *(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v7 + 8);
  swift_bridgeObjectRetain(v4, v9, v10, v11);
  v8(&v64, v6, v7);
  uint64_t v12 = *((void *)&v65 + 1);
  uint64_t v13 = v66;
  __swift_project_boxed_opaque_existential_0Tm(&v64, *((uint64_t *)&v65 + 1));
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v13 + 40))(v5, v12, v13);
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v64);
  unint64_t v15 = -1LL << *(_BYTE *)(v4 + 32);
  uint64_t v16 = v14 & ~v15;
  BOOL v17 = v4;
  BOOL v18 = v4 + 56;
  if (((*(void *)(v18 + ((v16 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v16) & 1) == 0)
  {
LABEL_10:
    swift_bridgeObjectRelease(v17);
    *(void *)(a2 + 32) = 0LL;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    return;
  }

  uint64_t v59 = ~v15;
  while (1)
  {
    outlined init with copy of AnyHashable(*(void *)(v17 + 48) + 40 * v16, (uint64_t)&v64);
    uint64_t v19 = *((void *)&v65 + 1);
    uint64_t v20 = v66;
    __swift_project_boxed_opaque_existential_0Tm(&v64, *((uint64_t *)&v65 + 1));
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v20 + 8))(v61, v19, v20);
    uint64_t v21 = v62;
    uint64_t v22 = v63;
    __swift_project_boxed_opaque_existential_0Tm(v61, v62);
    uint64_t v24 = a1[3];
    unint64_t v23 = a1[4];
    __swift_project_boxed_opaque_existential_0Tm(a1, v24);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v23 + 8))(v60, v24, v23);
    uint64_t v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v22 + 16))(v60, v21, v22);
    __swift_destroy_boxed_opaque_existential_1Tm(v60);
    if (v25 != 2) {
      break;
    }
    __swift_destroy_boxed_opaque_existential_1Tm(v61);
    outlined destroy of AnyHashable((uint64_t *)&v64);
LABEL_4:
    uint64_t v16 = (v16 + 1) & v59;
    if (((*(void *)(v18 + ((v16 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v16) & 1) == 0) {
      goto LABEL_10;
    }
  }

  __swift_destroy_boxed_opaque_existential_1Tm(v61);
  outlined destroy of AnyHashable((uint64_t *)&v64);
  if ((v25 & 1) == 0) {
    goto LABEL_4;
  }
  swift_bridgeObjectRelease(v17);
  id v26 = v57;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v57);
  uint64_t v31 = *v57;
  v61[0] = *v57;
  *unint64_t v57 = 0x8000000000000000LL;
  if (isUniquelyReferenced_nonNull_native)
  {
    uint64_t v32 = v31;
LABEL_9:
    uint64_t v33 = *(void *)(v32 + 48) + 40 * v16;
    unint64_t v34 = *(_OWORD *)(v33 + 16);
    *(_OWORD *)a2 = *(_OWORD *)v33;
    *(_OWORD *)(a2 + 16) = v34;
    *(void *)(a2 + 32) = *(void *)(v33 + 32);
    specialized _NativeSet._delete(at:)(v16, v28, v29, v30);
    uint64_t v35 = *v26;
    *id v26 = v61[0];
    swift_bridgeObjectRelease(v35);
    return;
  }

  uint64_t v36 = *(unsigned int *)(v31 + 36);
  uint64_t v37 = *(void **)(v31 + 40);
  char v38 = *(_BYTE *)(v31 + 32);
  LOBYTE(v64) = 0;
  unint64_t v39 = specialized static _SetStorage.allocate(scale:age:seed:)(v38, v36, v37, 0);
  uint64_t v32 = (uint64_t)v39;
  if (!*(void *)(v31 + 16))
  {
LABEL_36:
    swift_bridgeObjectRelease(v31);
    v61[0] = v32;
    id v26 = v57;
    goto LABEL_9;
  }

  unint64_t v40 = v39 + 7;
  uint64_t v41 = v31 + 56;
  char v42 = (unint64_t)((1LL << *(_BYTE *)(v32 + 32)) + 63) >> 6;
  char v43 = 0LL;
  *(void *)(v32 + 16) = *(void *)(v31 + 16);
  uint64_t v44 = 1LL << *(_BYTE *)(v31 + 32);
  int v45 = -1LL;
  if (v44 < 64) {
    int v45 = ~(-1LL << v44);
  }
  uint64_t v46 = v45 & *(void *)(v31 + 56);
  uint64_t v47 = (unint64_t)(v44 + 63) >> 6;
  while (2)
  {
    if (v46)
    {
      Swift::Int v48 = __clz(__rbit64(v46));
      v46 &= v46 - 1;
      uint64_t v49 = v48 | (v43 << 6);
LABEL_20:
      uint64_t v50 = 40 * v49;
      outlined init with copy of AnyHashable(*(void *)(v31 + 48) + 40 * v49, (uint64_t)&v64);
      int64_t v51 = *(void *)(v32 + 48) + v50;
      uint64_t v52 = v64;
      uint64_t v53 = v65;
      *(void *)(v51 + 32) = v66;
      *(_OWORD *)int64_t v51 = v52;
      *(_OWORD *)(v51 + 16) = v53;
      continue;
    }

    break;
  }

  uint64_t v54 = v43 + 1;
  if (__OFADD__(v43, 1LL))
  {
    __break(1u);
    goto LABEL_38;
  }

  if (v54 >= v47) {
    goto LABEL_36;
  }
  uint64_t v55 = *(void *)(v41 + 8 * v54);
  ++v43;
  if (v55) {
    goto LABEL_35;
  }
  char v43 = v54 + 1;
  if (v54 + 1 >= v47) {
    goto LABEL_36;
  }
  uint64_t v55 = *(void *)(v41 + 8 * v43);
  if (v55) {
    goto LABEL_35;
  }
  char v43 = v54 + 2;
  if (v54 + 2 >= v47) {
    goto LABEL_36;
  }
  uint64_t v55 = *(void *)(v41 + 8 * v43);
  if (v55)
  {
LABEL_35:
    uint64_t v46 = (v55 - 1) & v55;
    uint64_t v49 = __clz(__rbit64(v55)) + (v43 << 6);
    goto LABEL_20;
  }

  uint64_t v56 = v54 + 3;
  if (v56 >= v47) {
    goto LABEL_36;
  }
  uint64_t v55 = *(void *)(v41 + 8 * v56);
  if (v55)
  {
    char v43 = v56;
    goto LABEL_35;
  }

  while (1)
  {
    char v43 = v56 + 1;
    if (__OFADD__(v56, 1LL)) {
      break;
    }
    if (v43 >= v47) {
      goto LABEL_36;
    }
    uint64_t v55 = *(void *)(v41 + 8 * v43);
    ++v56;
    if (v55) {
      goto LABEL_35;
    }
  }

void Set._Variant.remove(_:)(id *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = v3;
  uint64_t v8 = *(uint64_t **)(a2 + 16);
  uint64_t v44 = *(v8 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v38 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *v4;
  if ((*v4 & 0xC000000000000001LL) != 0)
  {
    if (v14 < 0) {
      unint64_t v15 = (void *)*v4;
    }
    else {
      unint64_t v15 = (void *)(v14 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_bridgeObjectRetain(*v4, v9, v10, v11);
    uint64_t v16 = _bridgeAnythingToObjectiveC<A>(_:)(a1, v8);
    id v17 = objc_msgSend(v15, sel_member_, v16);
    swift_unknownObjectRelease(v16);
    if (v17)
    {
      swift_unknownObjectRelease(v17);
      Set._Variant._migrateToNative(_:removing:)(v15, (char *)a1, a2, a3);
      swift_bridgeObjectRelease(v14);
      (*(void (**)(uint64_t, void, uint64_t, uint64_t *))(v44 + 56))(a3, 0LL, 1LL, v8);
    }

    else
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v44 + 56))(a3, 1LL, 1LL, v8);
      swift_bridgeObjectRelease(v14);
    }
  }

  else
  {
    uint64_t v18 = *(void *)(v14 + 40);
    uint64_t v19 = *(void *)(a2 + 24);
    uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(v19 + 32);
    swift_bridgeObjectRetain(*v4, v9, v10, v11);
    uint64_t v21 = v20(v18, v8, v19);
    uint64_t v22 = -1LL << *(_BYTE *)(v14 + 32);
    unint64_t v23 = v21 & ~v22;
    uint64_t v43 = v14 + 56;
    if (((*(void *)(v14 + 56 + ((v23 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v23) & 1) != 0)
    {
      char v38 = (uint64_t *)v4;
      uint64_t v39 = v19;
      uint64_t v40 = a3;
      uint64_t v41 = ~v22;
      char v42 = a1;
      uint64_t v24 = *(void *)(v19 + 8);
      uint64_t v25 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v24 + 8);
      uint64_t v26 = *(void *)(v44 + 72);
      uint64_t v27 = *(void (**)(char *, unint64_t, uint64_t *))(v44 + 16);
      while (1)
      {
        v27(v13, *(void *)(v14 + 48) + v26 * v23, v8);
        char v28 = v25(v13, v42, v8, v24);
        (*(void (**)(char *, uint64_t *))(v44 + 8))(v13, v8);
        if ((v28 & 1) != 0) {
          break;
        }
        unint64_t v23 = (v23 + 1) & v41;
        if (((*(void *)(v43 + ((v23 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v23) & 1) == 0)
        {
          swift_bridgeObjectRelease(v14);
          a3 = v40;
          goto LABEL_14;
        }
      }

      swift_bridgeObjectRelease(v14);
      __int128 v29 = v38;
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v38);
      uint64_t v32 = *v29;
      uint64_t v45 = *v29;
      *__int128 v29 = 0x8000000000000000LL;
      if (!isUniquelyReferenced_nonNull_native)
      {
        type metadata accessor for _NativeSet(0LL, (uint64_t)v8, v39, v31);
        _NativeSet.copy()();
        uint64_t v32 = v45;
      }

      unint64_t v33 = *(void *)(v32 + 48) + v26 * v23;
      uint64_t v34 = v44;
      uint64_t v35 = v40;
      (*(void (**)(uint64_t, unint64_t, uint64_t *))(v44 + 32))(v40, v33, v8);
      type metadata accessor for _NativeSet(0LL, (uint64_t)v8, v39, v36);
      _NativeSet._delete(at:)((Swift::_HashTable::Bucket)v23);
      uint64_t v37 = *v29;
      *__int128 v29 = v32;
      swift_bridgeObjectRelease(v37);
      (*(void (**)(uint64_t, void, uint64_t, uint64_t *))(v34 + 56))(v35, 0LL, 1LL, v8);
    }

    else
    {
      swift_bridgeObjectRelease(v14);
LABEL_14:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v44 + 56))(a3, 1LL, 1LL, v8);
    }
  }

void _NativeSet.__specialize_insertNew(_:at:isUnique:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void _NativeSet.__specialize__unsafeInsertNew(_:at:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void print(_:separator:terminator:)( uint64_t a1, uint64_t a2, unint64_t a3, char *a4, unint64_t a5)
{
}

void specialized _print<A>(_:separator:terminator:to:)( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, void *a5, unint64_t *a6)
{
  uint64_t v7 = a5;
  uint64_t v8 = a4;
  uint64_t v9 = *(void *)(a1 + 16);
  if (!v9)
  {
    a3 = 0xE000000000000000LL;
    goto LABEL_13;
  }

  outlined init with copy of Any(a1 + 32, (uint64_t)v42);
  outlined init with take of Any(v42, v41);
  unint64_t v13 = *a6;
  unint64_t v14 = a6[1];
  uint64_t v15 = HIBYTE(v14) & 0xF;
  if ((v14 & 0x2000000000000000LL) == 0) {
    uint64_t v15 = *a6 & 0xFFFFFFFFFFFFLL;
  }
  if (v15 || (v13 & ~v14 & 0x2000000000000000LL) != 0)
  {
    if ((v14 & 0x2000000000000000LL) == 0
      || (unint64_t v16 = specialized _SmallString.init(_:appending:)(v13, a6[1], 0LL, 0xE000000000000000LL), (v18 & 1) != 0))
    {
      _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
      swift_bridgeObjectRelease(0xE000000000000000LL);
    }

    else
    {
      unint64_t v19 = v16;
      unint64_t v20 = v17;
      swift_bridgeObjectRelease(v14);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      *a6 = v19;
      a6[1] = v20;
    }
  }

  else
  {
    swift_bridgeObjectRelease(a6[1]);
    *a6 = 0LL;
    a6[1] = 0xE000000000000000LL;
  }

  _print_unlocked<A, B>(_:_:)( (uint64_t)v41,  (uint64_t)a6,  (swift *)byte_189B8D218,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
  __swift_destroy_boxed_opaque_existential_1Tm(v41);
  swift_bridgeObjectRetain(a3, v21, v22, v23);
  uint64_t v24 = v9 - 1;
  if (v9 != 1)
  {
    uint64_t v26 = a1 + 64;
    while (1)
    {
      outlined init with copy of Any(v26, (uint64_t)v42);
      outlined init with take of Any(v42, v41);
      unint64_t v31 = *a6;
      unint64_t v32 = a6[1];
      uint64_t v33 = HIBYTE(v32) & 0xF;
      if ((v32 & 0x2000000000000000LL) == 0) {
        uint64_t v33 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v33 && (v31 & ~v32 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(a6[1]);
        *a6 = a2;
        a6[1] = a3;
        goto LABEL_17;
      }

      if ((v32 & 0x2000000000000000LL) == 0) {
        break;
      }
      if ((a3 & 0x2000000000000000LL) == 0) {
        goto LABEL_15;
      }
      unint64_t v34 = specialized _SmallString.init(_:appending:)(v31, a6[1], a2, a3);
      uint64_t v27 = HIBYTE(a3) & 0xF;
      if ((v36 & 1) == 0)
      {
        unint64_t v37 = v34;
        unint64_t v38 = v35;
        swift_bridgeObjectRelease(v32);
        swift_bridgeObjectRelease(a3);
        *a6 = v37;
        a6[1] = v38;
        goto LABEL_17;
      }

void specialized _print<A>(_:separator:terminator:to:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11)
  {
    uint64_t v51 = a4;
    unint64_t v52 = a5;
    uint64_t v12 = 0LL;
    uint64_t v13 = a1 + 32;
    unint64_t v14 = 0xE000000000000000LL;
    unint64_t v53 = a3;
    while (1)
    {
      outlined init with copy of Any(v13, (uint64_t)v57);
      outlined init with take of Any(v57, v56);
      unint64_t v23 = *a6;
      unint64_t v24 = a6[1];
      uint64_t v25 = HIBYTE(v24) & 0xF;
      if ((v24 & 0x2000000000000000LL) == 0) {
        uint64_t v25 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v25 && (v23 & ~v24 & 0x2000000000000000LL) == 0) {
        break;
      }
      uint64_t v26 = v14 & 0x2000000000000000LL;
      if ((v24 & 0x2000000000000000LL) == 0
        || !v26
        || (unint64_t v27 = specialized _SmallString.init(_:appending:)(v23, a6[1], v12, v14), (v29 & 1) != 0))
      {
        if (v26) {
          uint64_t v36 = HIBYTE(v14) & 0xF;
        }
        else {
          uint64_t v36 = v12 & 0xFFFFFFFFFFFFLL;
        }
        _StringGuts.append(_:)(v12, v14, 0LL, v36);
        unint64_t v35 = v14;
        a3 = v53;
LABEL_19:
        uint64_t v37 = HIBYTE(v35) & 0xF;
        if (!v26) {
          uint64_t v37 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (!v37) {
          goto LABEL_5;
        }
        goto LABEL_22;
      }

      unint64_t v30 = v27;
      unint64_t v31 = v28;
      swift_bridgeObjectRelease(v24);
      *a6 = v30;
      a6[1] = v31;
      unint64_t v35 = v14;
      a3 = v53;
      if ((v14 & 0xF00000000000000LL) == 0) {
        goto LABEL_5;
      }
LABEL_22:
      swift_bridgeObjectRetain(v14, v32, v33, v34);
      if ((v35 & 0x1000000000000000LL) != 0)
      {
        uint64_t v12 = specialized static String._copying(_:)(v12, v14);
        unint64_t v35 = v39;
        swift_bridgeObjectRelease(v14);
        uint64_t v38 = v35;
        if ((v35 & 0x2000000000000000LL) == 0)
        {
LABEL_24:
          if ((v12 & 0x1000000000000000LL) != 0)
          {
            unint64_t v16 = (void *)((v35 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v15 = v12 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            unint64_t v16 = _StringObject.sharedUTF8.getter(v12, v38);
            if (!v16) {
              goto LABEL_46;
            }
            size_t v15 = v40;
          }

          goto LABEL_4;
        }
      }

      else
      {
        uint64_t v38 = v14;
        if ((v35 & 0x2000000000000000LL) == 0) {
          goto LABEL_24;
        }
      }

      size_t v15 = HIBYTE(v35) & 0xF;
      v55[0] = v12;
      v55[1] = v35 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v16 = v55;
LABEL_4:
      _swift_stdlib_fwrite_stdout(v16, 1uLL, v15);
      swift_bridgeObjectRelease(v38);
LABEL_5:
      swift_bridgeObjectRelease(v14);
      _print_unlocked<A, B>(_:_:)( (uint64_t)v56,  (uint64_t)a6,  (swift *)byte_189B8D218,  (uint64_t)&unk_189B89E20,  (uint64_t)&protocol witness table for _TeeStream<A, B>);
      __swift_destroy_boxed_opaque_existential_1Tm(v56);
      swift_bridgeObjectRetain(a3, v17, v18, v19);
      v13 += 32LL;
      unint64_t v14 = a3;
      uint64_t v12 = a2;
      if (!--v11)
      {
        a4 = v51;
        a5 = v52;
        goto LABEL_33;
      }
    }

    swift_bridgeObjectRetain(v14, v20, v21, v22);
    swift_bridgeObjectRelease(v24);
    *a6 = v12;
    a6[1] = v14;
    uint64_t v26 = v14 & 0x2000000000000000LL;
    unint64_t v35 = v14;
    goto LABEL_19;
  }

  a3 = 0xE000000000000000LL;
LABEL_33:
  swift_bridgeObjectRelease(a3);
  v41._uint64_t countAndFlagsBits = a4;
  v41._unint64_t object = (void *)a5;
  String.write(_:)(v41);
  uint64_t v45 = HIBYTE(a5) & 0xF;
  if ((a5 & 0x2000000000000000LL) == 0) {
    uint64_t v45 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v45)
  {
    swift_bridgeObjectRetain(a5, v42, v43, v44);
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      a4 = specialized static String._copying(_:)(a4, a5);
      unint64_t v49 = v48;
      swift_bridgeObjectRelease(a5);
      a5 = v49;
      if ((v49 & 0x2000000000000000LL) == 0)
      {
LABEL_38:
        if ((a4 & 0x1000000000000000LL) != 0)
        {
          uint64_t v46 = (_OWORD *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v47 = a4 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          uint64_t v46 = _StringObject.sharedUTF8.getter(a4, a5);
          if (!v46) {
LABEL_46:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/OutputStream.swift",  24LL,  2,  0x239uLL,  0);
          size_t v47 = v50;
        }

        goto LABEL_42;
      }
    }

    else if ((a5 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_38;
    }

    size_t v47 = HIBYTE(a5) & 0xF;
    *(void *)&v57[0] = a4;
    *((void *)&v57[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = a5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v46 = v57;
LABEL_42:
    _swift_stdlib_fwrite_stdout(v46, 1uLL, v47);
    swift_bridgeObjectRelease(a5);
  }

  _swift_stdlib_funlockfile_stdout();
}

void debugPrint(_:separator:terminator:)( uint64_t a1, uint64_t a2, unint64_t a3, char *a4, unint64_t a5)
{
}

void print(_:separator:terminator:)( uint64_t a1, uint64_t a2, unint64_t a3, char *a4, unint64_t a5, void (*a6)(uint64_t, uint64_t, unint64_t, char *, unint64_t, uint64_t *), void (*a7)(uint64_t *, uint64_t, char *, ValueMetadata *, _UNKNOWN **))
{
  uint64_t v12 = (void (*)(uint64_t, unint64_t))_playgroundPrintHook;
  if (_playgroundPrintHook)
  {
    uint64_t v14 = qword_18C565C68;
    uint64_t v16 = 0LL;
    unint64_t v17 = 0xE000000000000000LL;
    swift_retain((unint64_t *)qword_18C565C68, a2, a3, a4);
    a6(a1, a2, a3, a4, a5, &v16);
    uint64_t v15 = v17;
    v12(v16, v17);
    swift_bridgeObjectRelease(v15);
    outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v12, v14);
  }

  else
  {
    specialized _print<A>(_:separator:terminator:to:)(a1, a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7);
  }

void specialized _debugPrint<A>(_:separator:terminator:to:)( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t *a6)
{
  unint64_t v7 = a5;
  unint64_t v8 = a4;
  uint64_t v131 = *(void *)(a1 + 16);
  if (v131)
  {
    unint64_t v9 = a3;
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
    uint64_t v130 = a1 + 32;
    unint64_t v12 = 0xE000000000000000LL;
    while (1)
    {
      outlined init with copy of Any(v130 + 32 * v10, (uint64_t)v137);
      outlined init with take of Any(v137, v136);
      uint64_t v20 = *a6;
      unint64_t v19 = a6[1];
      uint64_t v21 = HIBYTE(v19) & 0xF;
      if ((v19 & 0x2000000000000000LL) != 0) {
        uint64_t v22 = HIBYTE(v19) & 0xF;
      }
      else {
        uint64_t v22 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v22 && (v20 & ~v19 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(a6[1]);
        *a6 = v11;
        a6[1] = v12;
        goto LABEL_4;
      }

      uint64_t v23 = HIBYTE(v12) & 0xF;
      if ((v19 & 0x2000000000000000LL) != 0)
      {
        if ((v12 & 0x2000000000000000LL) != 0)
        {
          uint64_t v25 = v21 + v23;
          if ((unint64_t)(v21 + v23) <= 0xF)
          {
            if (v23)
            {
              char v89 = 0;
              unint64_t v90 = 0LL;
              uint64_t v91 = a6[1];
              do
              {
                unint64_t v92 = v21 + v90;
                unint64_t v93 = v90 + 1;
                if (v90 >= 8) {
                  unint64_t v94 = v12;
                }
                else {
                  unint64_t v94 = v11;
                }
                unint64_t v95 = v94 >> (v89 & 0x38);
                char v96 = (8 * v21 + v89) & 0x38;
                uint64_t v97 = (-255LL << v96) - 1;
                unint64_t v98 = (unint64_t)v95 << v96;
                unint64_t v99 = v98 | v97 & v91;
                unint64_t v100 = v98 | v97 & v20;
                if (v92 < 8) {
                  uint64_t v20 = v100;
                }
                else {
                  uint64_t v91 = v99;
                }
                v89 += 8;
                unint64_t v90 = v93;
              }

              while (v23 != v93);
            }

            else
            {
              uint64_t v91 = a6[1];
            }

            swift_bridgeObjectRelease(a6[1]);
            swift_bridgeObjectRelease(v12);
            unint64_t v105 = 0xE000000000000000LL;
            if (v20 & 0x8080808080808080LL | v91 & 0x80808080808080LL) {
              unint64_t v105 = 0xA000000000000000LL;
            }
            unint64_t v55 = v105 & 0xFF00000000000000LL | (v25 << 56) | v91 & 0xFFFFFFFFFFFFFFLL;
LABEL_122:
            *a6 = v20;
            a6[1] = v55;
            goto LABEL_4;
          }

          uint64_t v24 = 1LL;
        }

        else
        {
          uint64_t v24 = 0LL;
        }
      }

      else
      {
        uint64_t v24 = v12 & 0x2000000000000000LL;
      }

      uint64_t v26 = v11 & 0xFFFFFFFFFFFFLL;
      uint64_t v133 = v24;
      if (v24) {
        uint64_t v27 = HIBYTE(v12) & 0xF;
      }
      else {
        uint64_t v27 = v11 & 0xFFFFFFFFFFFFLL;
      }
      uint64_t v129 = v27;
      if ((v12 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v12, 2LL, v17, v18);
        v106._Swift::UInt64 rawBits = 1LL;
        v107._Swift::UInt64 rawBits = (v27 << 16) | 1;
        v108._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v106, v107, v11, v12);
        if (v108._rawBits < 0x10000) {
          v108._rawBits |= 3;
        }
        uint64_t v27 = specialized Collection.count.getter(v108, v109, v11, v12);
        swift_bridgeObjectRelease(v12);
        if ((v19 & 0x1000000000000000LL) == 0)
        {
LABEL_21:
          BOOL v28 = __OFADD__(v22, v27);
          uint64_t v29 = v22 + v27;
          if (v28) {
            goto LABEL_159;
          }
          goto LABEL_22;
        }
      }

      else
      {
        swift_bridgeObjectRetain(v12, v16, v17, v18);
        if ((v19 & 0x1000000000000000LL) == 0) {
          goto LABEL_21;
        }
      }

      Swift::Int v110 = String.UTF8View._foreignCount()();
      uint64_t v29 = v110 + v27;
      if (__OFADD__(v110, v27))
      {
LABEL_159:
        __break(1u);
LABEL_160:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
      }

void specialized _debugPrint<A>(_:separator:terminator:to:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11)
  {
    uint64_t v51 = a4;
    unint64_t v52 = a5;
    uint64_t v12 = 0LL;
    uint64_t v13 = a1 + 32;
    unint64_t v14 = 0xE000000000000000LL;
    unint64_t v53 = a3;
    while (1)
    {
      outlined init with copy of Any(v13, (uint64_t)v57);
      outlined init with take of Any(v57, v56);
      unint64_t v23 = *a6;
      unint64_t v24 = a6[1];
      uint64_t v25 = HIBYTE(v24) & 0xF;
      if ((v24 & 0x2000000000000000LL) == 0) {
        uint64_t v25 = *a6 & 0xFFFFFFFFFFFFLL;
      }
      if (!v25 && (v23 & ~v24 & 0x2000000000000000LL) == 0) {
        break;
      }
      uint64_t v26 = v14 & 0x2000000000000000LL;
      if ((v24 & 0x2000000000000000LL) == 0
        || !v26
        || (unint64_t v27 = specialized _SmallString.init(_:appending:)(v23, a6[1], v12, v14), (v29 & 1) != 0))
      {
        if (v26) {
          uint64_t v36 = HIBYTE(v14) & 0xF;
        }
        else {
          uint64_t v36 = v12 & 0xFFFFFFFFFFFFLL;
        }
        _StringGuts.append(_:)(v12, v14, 0LL, v36);
        unint64_t v35 = v14;
        a3 = v53;
LABEL_19:
        uint64_t v37 = HIBYTE(v35) & 0xF;
        if (!v26) {
          uint64_t v37 = v12 & 0xFFFFFFFFFFFFLL;
        }
        if (!v37) {
          goto LABEL_5;
        }
        goto LABEL_22;
      }

      unint64_t v30 = v27;
      unint64_t v31 = v28;
      swift_bridgeObjectRelease(v24);
      *a6 = v30;
      a6[1] = v31;
      unint64_t v35 = v14;
      a3 = v53;
      if ((v14 & 0xF00000000000000LL) == 0) {
        goto LABEL_5;
      }
LABEL_22:
      swift_bridgeObjectRetain(v14, v32, v33, v34);
      if ((v35 & 0x1000000000000000LL) != 0)
      {
        uint64_t v12 = specialized static String._copying(_:)(v12, v14);
        unint64_t v35 = v39;
        swift_bridgeObjectRelease(v14);
        uint64_t v38 = v35;
        if ((v35 & 0x2000000000000000LL) == 0)
        {
LABEL_24:
          if ((v12 & 0x1000000000000000LL) != 0)
          {
            uint64_t v16 = (void *)((v35 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v15 = v12 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v16 = _StringObject.sharedUTF8.getter(v12, v38);
            if (!v16) {
              goto LABEL_46;
            }
            size_t v15 = v40;
          }

          goto LABEL_4;
        }
      }

      else
      {
        uint64_t v38 = v14;
        if ((v35 & 0x2000000000000000LL) == 0) {
          goto LABEL_24;
        }
      }

      size_t v15 = HIBYTE(v35) & 0xF;
      v55[0] = v12;
      v55[1] = v35 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v16 = v55;
LABEL_4:
      _swift_stdlib_fwrite_stdout(v16, 1uLL, v15);
      swift_bridgeObjectRelease(v38);
LABEL_5:
      swift_bridgeObjectRelease(v14);
      _debugPrint_unlocked<A, B>(_:_:)( (uint64_t)v56,  (uint64_t)a6,  (swift *)byte_189B8D218,  (uint64_t)&unk_189B89E20,  (uint64_t)&protocol witness table for _TeeStream<A, B>);
      __swift_destroy_boxed_opaque_existential_1Tm(v56);
      swift_bridgeObjectRetain(a3, v17, v18, v19);
      v13 += 32LL;
      unint64_t v14 = a3;
      uint64_t v12 = a2;
      if (!--v11)
      {
        a4 = v51;
        a5 = v52;
        goto LABEL_33;
      }
    }

    swift_bridgeObjectRetain(v14, v20, v21, v22);
    swift_bridgeObjectRelease(v24);
    *a6 = v12;
    a6[1] = v14;
    uint64_t v26 = v14 & 0x2000000000000000LL;
    unint64_t v35 = v14;
    goto LABEL_19;
  }

  a3 = 0xE000000000000000LL;
LABEL_33:
  swift_bridgeObjectRelease(a3);
  v41._uint64_t countAndFlagsBits = a4;
  v41._unint64_t object = (void *)a5;
  String.write(_:)(v41);
  uint64_t v45 = HIBYTE(a5) & 0xF;
  if ((a5 & 0x2000000000000000LL) == 0) {
    uint64_t v45 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v45)
  {
    swift_bridgeObjectRetain(a5, v42, v43, v44);
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      a4 = specialized static String._copying(_:)(a4, a5);
      unint64_t v49 = v48;
      swift_bridgeObjectRelease(a5);
      a5 = v49;
      if ((v49 & 0x2000000000000000LL) == 0)
      {
LABEL_38:
        if ((a4 & 0x1000000000000000LL) != 0)
        {
          unint64_t v46 = (_OWORD *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v47 = a4 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          unint64_t v46 = _StringObject.sharedUTF8.getter(a4, a5);
          if (!v46) {
LABEL_46:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/OutputStream.swift",  24LL,  2,  0x239uLL,  0);
          size_t v47 = v50;
        }

        goto LABEL_42;
      }
    }

    else if ((a5 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_38;
    }

    size_t v47 = HIBYTE(a5) & 0xF;
    *(void *)&v57[0] = a4;
    *((void *)&v57[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = a5 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v46 = v57;
LABEL_42:
    _swift_stdlib_fwrite_stdout(v46, 1uLL, v47);
    swift_bridgeObjectRelease(a5);
  }

  _swift_stdlib_funlockfile_stdout();
}

void specialized _print<A>(_:separator:terminator:to:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, void (*a7)(uint64_t *, uint64_t, char *, ValueMetadata *, _UNKNOWN **))
{
  uint64_t v14 = *(void *)(a1 + 16);
  if (v14)
  {
    uint64_t v39 = a4;
    unint64_t v40 = a5;
    uint64_t v15 = 0LL;
    uint64_t v16 = a1 + 32;
    unint64_t v17 = 0xE000000000000000LL;
    while (1)
    {
      outlined init with copy of Any(v16, (uint64_t)v43);
      outlined init with take of Any(v43, v42);
      uint64_t v26 = HIBYTE(v17) & 0xF;
      if ((v17 & 0x2000000000000000LL) == 0) {
        uint64_t v26 = v15 & 0xFFFFFFFFFFFFLL;
      }
      if (!v26) {
        goto LABEL_5;
      }
      swift_bridgeObjectRetain(v17, v23, v24, v25);
      if ((v17 & 0x1000000000000000LL) != 0)
      {
        uint64_t v15 = specialized static String._copying(_:)(v15, v17);
        unint64_t v27 = v28;
        swift_bridgeObjectRelease(v17);
        if ((v27 & 0x2000000000000000LL) == 0)
        {
LABEL_11:
          if ((v15 & 0x1000000000000000LL) != 0)
          {
            unint64_t v19 = (void *)((v27 & 0xFFFFFFFFFFFFFFFLL) + 32);
            size_t v18 = v15 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            unint64_t v19 = _StringObject.sharedUTF8.getter(v15, v27);
            if (!v19) {
              goto LABEL_32;
            }
            size_t v18 = v29;
          }

          goto LABEL_4;
        }
      }

      else
      {
        unint64_t v27 = v17;
        if ((v17 & 0x2000000000000000LL) == 0) {
          goto LABEL_11;
        }
      }

      size_t v18 = HIBYTE(v27) & 0xF;
      v41[0] = v15;
      v41[1] = v27 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v19 = v41;
LABEL_4:
      _swift_stdlib_fwrite_stdout(v19, 1uLL, v18);
      swift_bridgeObjectRelease(v27);
LABEL_5:
      swift_bridgeObjectRelease(v17);
      a7(v42, a6, byte_189B8D218, &type metadata for _Stdout, &protocol witness table for _Stdout);
      __swift_destroy_boxed_opaque_existential_1Tm(v42);
      swift_bridgeObjectRetain(a3, v20, v21, v22);
      v16 += 32LL;
      unint64_t v17 = a3;
      uint64_t v15 = a2;
      if (!--v14)
      {
        a4 = v39;
        a5 = v40;
        goto LABEL_19;
      }
    }
  }

  a3 = 0xE000000000000000LL;
LABEL_19:
  swift_bridgeObjectRelease(a3);
  uint64_t v33 = HIBYTE(a5) & 0xF;
  if ((a5 & 0x2000000000000000LL) == 0) {
    uint64_t v33 = a4 & 0xFFFFFFFFFFFFLL;
  }
  if (v33)
  {
    swift_bridgeObjectRetain(a5, v30, v31, v32);
    if ((a5 & 0x1000000000000000LL) != 0)
    {
      a4 = specialized static String._copying(_:)(a4, a5);
      unint64_t v37 = v36;
      swift_bridgeObjectRelease(a5);
      a5 = v37;
      if ((v37 & 0x2000000000000000LL) == 0)
      {
LABEL_24:
        if ((a4 & 0x1000000000000000LL) != 0)
        {
          char v34 = (_OWORD *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
          size_t v35 = a4 & 0xFFFFFFFFFFFFLL;
        }

        else
        {
          char v34 = _StringObject.sharedUTF8.getter(a4, a5);
          if (!v34) {
LABEL_32:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/OutputStream.swift",  24LL,  2,  0x239uLL,  0);
          size_t v35 = v38;
        }

        goto LABEL_28;
      }
    }

    else if ((a5 & 0x2000000000000000LL) == 0)
    {
      goto LABEL_24;
    }

    size_t v35 = HIBYTE(a5) & 0xF;
    *(void *)&v43[0] = a4;
    *((void *)&v43[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = a5 & 0xFFFFFFFFFFFFFFLL;
    char v34 = v43;
LABEL_28:
    _swift_stdlib_fwrite_stdout(v34, 1uLL, v35);
    swift_bridgeObjectRelease(a5);
  }

  _swift_stdlib_funlockfile_stdout();
}

uint64_t _print<A>(_:separator:terminator:to:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void (*a9)(uint64_t *, uint64_t, void *, uint64_t, uint64_t))
{
  uint64_t v17 = *(void *)(a1 + 16);
  if (v17)
  {
    uint64_t v28 = a5;
    outlined init with copy of Any(a1 + 32, (uint64_t)v29);
    size_t v18 = *(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a8 + 24);
    v18(0LL, 0xE000000000000000LL, a7, a8);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    a9(v29, a6, &unk_189B8D218, a7, a8);
    __swift_destroy_boxed_opaque_existential_1Tm(v29);
    swift_bridgeObjectRetain(a3, v19, v20, v21);
    uint64_t v22 = v17 - 1;
    if (v22)
    {
      uint64_t v23 = a1 + 64;
      do
      {
        outlined init with copy of Any(v23, (uint64_t)v29);
        v18(a2, a3, a7, a8);
        swift_bridgeObjectRelease(a3);
        a9(v29, a6, &unk_189B8D218, a7, a8);
        __swift_destroy_boxed_opaque_existential_1Tm(v29);
        swift_bridgeObjectRetain(a3, v24, v25, v26);
        v23 += 32LL;
        --v22;
      }

      while (v22);
    }

    a5 = v28;
  }

  else
  {
    a3 = 0xE000000000000000LL;
  }

  swift_bridgeObjectRelease(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a8 + 24))(a4, a5, a7, a8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a8 + 16))(a7, a8);
}

Swift::UInt64 __swiftcall SystemRandomNumberGenerator.next()()
{
  Swift::UInt64 __buf = 0LL;
  swift_stdlib_random(&__buf, 8uLL);
  return __buf;
}

uint64_t protocol witness for RandomNumberGenerator.next() in conformance SystemRandomNumberGenerator()
{
  uint64_t __buf = 0LL;
  swift_stdlib_random(&__buf, 8uLL);
  return __buf;
}

uint64_t RandomAccessCollection.index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return BidirectionalCollection.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 + 8), a5);
}

uint64_t RandomAccessCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return BidirectionalCollection.distance(from:to:)(a1, a2, a3, *(void *)(a4 + 8));
}

uint64_t Range.init(uncheckedBounds:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v48 = a1;
  unint64_t v49 = (char *)a4;
  uint64_t v47 = a5;
  uint64_t v7 = type metadata accessor for Range(0LL, a3, a4, a4);
  uint64_t v45 = *(void *)(v7 - 8);
  uint64_t v46 = v7;
  MEMORY[0x1895F8858](v7);
  unint64_t v44 = (char *)&v41 - v8;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, a3, "lower upper ", 0LL);
  uint64_t v42 = *(TupleTypeMetadata2 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v12 = (char *)&v41 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v43 = (char *)&v41 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  size_t v50 = (char *)&v41 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v41 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v41 - v21;
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v41 - v24;
  uint64_t v26 = (char *)&v41 + *(int *)(v23 + 48) - v24;
  uint64_t v27 = *(void *)(a3 - 8);
  uint64_t v28 = *(void (**)(void))(v27 + 32);
  ((void (*)(char *, uint64_t, uint64_t))v28)((char *)&v41 - v24, v48, a3);
  ((void (*)(char *, uint64_t, uint64_t))v28)(v26, a2, a3);
  size_t v29 = &v22[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v48 = v27;
  uint64_t v30 = *(void (**)(char *, char *, uint64_t))(v27 + 16);
  v30(v22, v25, a3);
  v30(v29, v26, a3);
  if (((*((uint64_t (**)(char *, char *, uint64_t))v49 + 3))(v22, v29, a3) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  (*(void (**)(char *, unint64_t *))(v42 + 8))(v22, TupleTypeMetadata2);
  unint64_t v49 = &v19[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v31 = v49;
  v30(v19, v25, a3);
  v30(v31, v26, a3);
  uint64_t v32 = &v50[*((int *)TupleTypeMetadata2 + 12)];
  v28();
  ((void (*)(char *, char *, uint64_t))v28)(v32, v26, a3);
  uint64_t v33 = v43;
  char v34 = &v43[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, uint64_t))v28)(v43, v19, a3);
  ((void (*)(char *, char *, uint64_t))v28)(v34, v32, a3);
  size_t v35 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  v30(v12, v33, a3);
  v30(v35, v34, a3);
  unint64_t v36 = v44;
  ((void (*)(char *, char *, uint64_t))v28)(v44, v12, a3);
  unint64_t v37 = *(void (**)(char *, uint64_t))(v48 + 8);
  v37(v35, a3);
  size_t v38 = &v12[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, char *, uint64_t))v28)(v12, v33, a3);
  ((void (*)(char *, char *, uint64_t))v28)(v38, v34, a3);
  uint64_t v39 = v46;
  ((void (*)(char *, char *, uint64_t))v28)(&v36[*(int *)(v46 + 36)], v38, a3);
  v37(v12, a3);
  (*(void (**)(uint64_t, char *, uint64_t))(v45 + 32))(v47, v36, v39);
  v37(v50, a3);
  return ((uint64_t (*)(char *, uint64_t))v37)(v49, a3);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance <> Range<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  unint64_t v9 = &v17.i8[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v10 = *(void *)(v7 - 8);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 16);
  int8x16_t v17 = *(int8x16_t *)(v12 - 16);
  v11(a2, v2, a1);
  Range<>.startIndex.getter(a1, (uint64_t)v9);
  (*(void (**)(uint64_t, uint64_t))(v10 + 8))(v2, a1);
  int8x16_t v18 = vextq_s8(v17, v17, 8uLL);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a1, &v18);
  uint64_t v15 = type metadata accessor for IndexingIterator(0LL, a1, WitnessTable, v14);
  return (*(uint64_t (**)(uint64_t, __int8 *, uint64_t))(v6 + 32))(a2 + *(int *)(v15 + 36), v9, v5);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance <> Range<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>( a1,  a2,  (uint64_t)&protocol conformance descriptor for <> Range<A>,  Collection.underestimatedCount.getter);
}

uint64_t protocol witness for Sequence._customContainsEquatableElement(_:) in conformance <> Range<A>( uint64_t a1, uint64_t a2)
{
  return Range<>._customContainsEquatableElement(_:)(a1, a2);
}

uint64_t Range<>._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  unint64_t v9 = (char *)&v20 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v14 = (char *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = *(void *)(v15 + 8);
  char v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 24))(v3, a1, v11, v16);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, a1, v11);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v9, v3, a2);
  if ((v17 & 1) != 0) {
    char v18 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v16 + 16))( v14,  &v9[*(int *)(a2 + 36)],  v11,  v16);
  }
  else {
    char v18 = 0;
  }
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
  return v18 & 1;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance <> Range<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance <> ClosedRange<A>( a1,  a2,  (uint64_t)&protocol conformance descriptor for <> Range<A>,  Collection._copyToContiguousArray());
}

uint64_t Range<>.startIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))(a2, v2);
}

uint64_t Range<>.endIndex.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))( a2,  v2 + *(int *)(a1 + 36));
}

uint64_t Range<>.index(after:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  uint64_t v70 = a4;
  uint64_t v76 = a5;
  uint64_t v77 = a1;
  uint64_t v9 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v9,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v74 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  size_t v73 = (char *)&v59 - v11;
  uint64_t v71 = *(const char **)(*(void *)(swift_getAssociatedConformanceWitness( a3,  v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                                   + 8)
                       + 16LL);
  unint64_t v75 = AssociatedTypeWitness;
  unint64_t v69 = swift_getAssociatedTypeWitness( 0LL,  v71,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v69);
  int64_t v68 = (char *)&v59 - v12;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v9, "lower upper ", 0LL);
  uint64_t v13 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v15 = (char *)&v59 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  unint64_t v63 = (char *)&v59 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v59 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v59 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v59 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  size_t v29 = (char *)&v59 - v28;
  uint64_t v67 = *(void *)(a2 - 8);
  uint64_t v30 = MEMORY[0x1895F8858](v27);
  uint64_t v64 = (char *)&v59 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v30);
  uint64_t v65 = (char *)&v59 - v32;
  uint64_t v62 = v33;
  char v34 = *(void (**)(char *, uint64_t, uint64_t))(v33 + 16);
  v34(v29, v6, v9);
  uint64_t v72 = a2;
  v34(v26, v6 + *(int *)(a2 + 36), v9);
  v34(v23, (uint64_t)v29, v9);
  v34(v20, (uint64_t)v26, v9);
  uint64_t v35 = a3;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3 + 8) + 24LL))(v23, v20, v9) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v36 = v15;
  uint64_t v37 = v62;
  size_t v38 = *(void (**)(char *, uint64_t))(v62 + 8);
  Swift::Int v60 = v38;
  uint64_t v61 = v35;
  v38(v20, v9);
  v38(v23, v9);
  uint64_t v39 = TupleTypeMetadata2;
  unint64_t v40 = v63;
  uint64_t v41 = &v63[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v42 = *(void (**)(char *, char *, uint64_t))(v37 + 32);
  v42(v63, v29, v9);
  v42(v41, v26, v9);
  uint64_t v43 = &v36[*((int *)v39 + 12)];
  v34(v36, (uint64_t)v40, v9);
  v34(v43, (uint64_t)v41, v9);
  unint64_t v44 = v64;
  v42(v64, v36, v9);
  uint64_t v45 = v60;
  v60(v43, v9);
  uint64_t v46 = &v36[*((int *)v39 + 12)];
  v42(v36, v40, v9);
  v42(v46, v41, v9);
  uint64_t v47 = v72;
  v42(&v44[*(int *)(v72 + 36)], v46, v9);
  v45(v36, v9);
  uint64_t v48 = v67;
  uint64_t v49 = (uint64_t)v65;
  (*(void (**)(char *, char *, uint64_t))(v67 + 32))(v65, v44, v47);
  uint64_t v50 = v61;
  v78[0] = v61;
  v78[1] = v70;
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, v47, v78);
  specialized Collection._failEarlyRangeCheck(_:bounds:)(v77, v49, v47, WitnessTable);
  (*(void (**)(uint64_t, uint64_t))(v48 + 8))(v49, v47);
  unint64_t v52 = v71;
  uint64_t v53 = v75;
  unint64_t v54 = v69;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v71,  v75,  v69,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v56 = v68;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  v54,  AssociatedConformanceWitness);
  char v57 = v73;
  (*((void (**)(char *, uint64_t, const char *))v52 + 3))(v56, v53, v52);
  (*(void (**)(char *, uint64_t, uint64_t))(v50 + 48))(v57, v9, v50);
  return (*(uint64_t (**)(char *, uint64_t))(v74 + 8))(v57, v53);
}

uint64_t Range<>.index(before:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v43 = a4;
  uint64_t v7 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v41 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v40 = (char *)&v37 - v9;
  uint64_t v39 = *(const char **)(*(void *)(swift_getAssociatedConformanceWitness( a3,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                                   + 8)
                       + 16LL);
  unint64_t v42 = AssociatedTypeWitness;
  unint64_t v38 = swift_getAssociatedTypeWitness( 0LL,  v39,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1895F8858](v38);
  uint64_t v37 = (char *)&v37 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v46 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v37 - v16;
  uint64_t v18 = *(void *)(v7 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v15);
  uint64_t v21 = (char *)&v37 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v37 - v22;
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 16);
  uint64_t v47 = a1;
  uint64_t v45 = v24;
  v24((char *)&v37 - v22, a1, v7);
  uint64_t v25 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v25(v17, v48, a2);
  uint64_t v44 = a3;
  uint64_t v26 = *(void *)(a3 + 8);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v26 + 40))(v23, v17, v7, v26) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Range.swift",  17LL,  2,  0xF1uLL,  0);
  }
  uint64_t v27 = *(void (**)(char *, uint64_t))(v12 + 8);
  v27(v17, a2);
  uint64_t v28 = *(void (**)(char *, uint64_t))(v18 + 8);
  v28(v23, v7);
  v45(v21, v47, v7);
  size_t v29 = v46;
  v25(v46, v48, a2);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v26 + 24))(v21, &v29[*(int *)(a2 + 36)], v7, v26) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Range.swift",  17LL,  2,  0xF2uLL,  0);
  }
  v27(v29, a2);
  v28(v21, v7);
  unint64_t v30 = v38;
  uint64_t v31 = v39;
  uint64_t v32 = v42;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v39,  v42,  v38,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v34 = v37;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE78,  257LL,  v30,  AssociatedConformanceWitness);
  uint64_t v35 = v40;
  (*((void (**)(char *, uint64_t, const char *))v31 + 3))(v34, v32, v31);
  (*(void (**)(char *, uint64_t))(v44 + 48))(v35, v7);
  return (*(uint64_t (**)(char *, uint64_t))(v41 + 8))(v35, v32);
}

uint64_t Range<>.index(_:offsetBy:)@<X0>( void (*a1)(char *, uint64_t, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v53 = a6;
  uint64_t v48 = a4;
  uint64_t v49 = a1;
  uint64_t v8 = *(void *)(a3 - 8);
  uint64_t v50 = a3;
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v47 = (char *)&v45 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v45 - v12;
  uint64_t v15 = *(void *)(v14 + 16);
  uint64_t v51 = *(void *)(v15 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v11);
  uint64_t v46 = (char *)&v45 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v45 - v18;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v20,  v15,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v22 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v23 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v25 = (char *)&v45 - v24;
  uint64_t v54 = a2;
  uint64_t v26 = *(void *)(a5 + 8);
  uint64_t v27 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v26 + 88);
  unint64_t v30 = lazy protocol witness table accessor for type Int and conformance Int(v23, v28, v29);
  v27(&v54, &type metadata for Int, v30, AssociatedTypeWitness, v26);
  uint64_t v31 = v48;
  uint64_t v32 = v53;
  (*(void (**)(char *, uint64_t, uint64_t))(v48 + 48))(v25, v15, v48);
  (*(void (**)(char *, unint64_t))(v22 + 8))(v25, AssociatedTypeWitness);
  uint64_t v49 = *(void (**)(char *, uint64_t, uint64_t))(v51 + 16);
  v49(v19, v32, v15);
  uint64_t v33 = v8;
  char v34 = *(void (**)(char *, uint64_t))(v8 + 16);
  uint64_t v35 = v50;
  v34(v13, v52);
  uint64_t v36 = *(void *)(v31 + 8);
  uint64_t v37 = v13;
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v36 + 32))(v19, v13, v15, v36) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Range.swift",  17LL,  2,  0xFAuLL,  0);
  }
  unint64_t v38 = *(void (**)(char *, uint64_t))(v33 + 8);
  uint64_t v39 = v37;
  uint64_t v40 = v35;
  v38(v39, v35);
  uint64_t v41 = *(void (**)(char *, uint64_t))(v51 + 8);
  v41(v19, v15);
  unint64_t v42 = v46;
  v49(v46, v53, v15);
  uint64_t v43 = v47;
  ((void (*)(char *, uint64_t, uint64_t))v34)(v47, v52, v40);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v36 + 24))( v42,  &v43[*(int *)(v40 + 36)],  v15,  v36) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Range.swift",  17LL,  2,  0xFBuLL,  0);
  }
  v38(v43, v40);
  return ((uint64_t (*)(char *, uint64_t))v41)(v42, v15);
}

uint64_t Range<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return specialized Range<>.distance(from:to:)(a1, a2, *(void *)(a3 + 16), a4, a5);
}

uint64_t Range<>.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a3, a1);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  void (*v16)(char *, uint64_t, uint64_t);
  uint64_t v18;
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v14, v15, a2);
  uint64_t v16 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 16);
  v16(v10, a1, v6);
  if ((Range.contains(_:)((uint64_t)v10, a2) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v6);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, a2);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v16)(a3, a1, v6);
}

uint64_t Range<>.indices.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a2, v2);
}

uint64_t Range<>._customIndexOfEquatableElement(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v32 = a3;
  uint64_t v7 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v29 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v15 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *(void *)(v16 + 8);
  char v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v17 + 24))(v4, a1, v12, v17);
  uint64_t v29 = a1;
  uint64_t v30 = v13;
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v19(v15, a1, v12);
  uint64_t v31 = v7;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, v4, a2);
  if ((v18 & 1) != 0)
  {
    uint64_t v20 = v29;
    char v21 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v17 + 16))( v15,  &v10[*(int *)(a2 + 36)],  v12,  v17);
    (*(void (**)(char *, uint64_t))(v31 + 8))(v10, a2);
    uint64_t v22 = v30;
    (*(void (**)(char *, uint64_t))(v30 + 8))(v15, v12);
    uint64_t v23 = v32;
    if ((v21 & 1) != 0)
    {
      v19(v32, v20, v12);
      uint64_t v24 = 0LL;
    }

    else
    {
      uint64_t v24 = 1LL;
    }
  }

  else
  {
    (*(void (**)(char *, uint64_t))(v31 + 8))(v10, a2);
    uint64_t v22 = v30;
    (*(void (**)(char *, uint64_t))(v30 + 8))(v15, v12);
    uint64_t v24 = 1LL;
    uint64_t v23 = v32;
  }

  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 56))(v23, v24, 1LL, v12);
  uint64_t v27 = type metadata accessor for Optional(0LL, v12, v25, v26);
  return (*(uint64_t (**)(char *, void, uint64_t, uint64_t))(*(void *)(v27 - 8) + 56LL))(v23, 0LL, 1LL, v27);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance <> Range<A>( void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = Range<>.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*Range<>.subscript.read(void *a1, uint64_t a2, uint64_t a3))(void ***a1)
{
  uint64_t v4 = v3;
  uint64_t v8 = malloc(0x28uLL);
  *a1 = v8;
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t v10 = malloc(*(void *)(v9 + 64));
  uint64_t v11 = *(void *)(a3 + 16);
  *uint64_t v8 = v10;
  v8[1] = v11;
  uint64_t v12 = *(void **)(v11 - 8);
  size_t v13 = v12[8];
  uint64_t v14 = malloc(v13);
  v8[2] = v14;
  uint64_t v15 = malloc(v13);
  uint64_t v8[3] = v15;
  (*(void (**)(void *, uint64_t, uint64_t))(v9 + 16))(v10, v4, a3);
  uint64_t v16 = (void (*)(void *, uint64_t, uint64_t))v12[2];
  v16(v14, a2, v11);
  if ((Range.contains(_:)((uint64_t)v14, a3) & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
  }
  uint64_t v17 = (void (*)(void *, uint64_t))v12[1];
  v8[4] = v17;
  v17(v14, v11);
  (*(void (**)(void *, uint64_t))(v9 + 8))(v10, a3);
  v16(v15, a2, v11);
  return Range<>.subscript.read;
}

void Range<>.subscript.read(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (*a1)[3];
  uint64_t v3 = (*a1)[2];
  uint64_t v4 = **a1;
  ((void (*)(void *, void *))(*a1)[4])(v2, (*a1)[1]);
  free(v2);
  free(v3);
  free(v4);
  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance <> Range<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return Range<>.subscript.getter(a1, a2, a3);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance <> Range<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  return Range<>._customIndexOfEquatableElement(_:)(a1, a2, a3);
}

uint64_t protocol witness for Collection._customLastIndexOfEquatableElement(_:) in conformance <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Range<>._customLastIndexOfEquatableElement(_:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> Range<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> ClosedRange<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t)&protocol conformance descriptor for <> Range<A>,  a6);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return specialized Range<>.distance(from:to:)(a1, a2, *(void *)(a3 + 16), *(void *)(a4 - 8), *(void *)(a4 - 16));
}

uint64_t protocol witness for Collection.index(after:) in conformance <> Range<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v70 = a1;
  uint64_t v68 = a4;
  uint64_t v63 = a3;
  uint64_t v5 = *(void *)(a3 - 8);
  uint64_t v6 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  v6,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v66 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v65 = (char *)&v53 - v8;
  uint64_t v62 = *(const char **)(*(void *)(swift_getAssociatedConformanceWitness( v5,  v6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                                   + 8)
                       + 16LL);
  unint64_t v67 = AssociatedTypeWitness;
  unint64_t v61 = swift_getAssociatedTypeWitness( 0LL,  v62,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v61);
  Swift::Int v60 = (char *)&v53 - v9;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v6, v6, "lower upper ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v58 = (char *)&v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  char v57 = (char *)&v53 - v13;
  uint64_t v14 = *(void *)(v6 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v53 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v53 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v53 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v53 - v25;
  uint64_t v27 = *(void *)(a2 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v24);
  unint64_t v55 = (char *)&v53 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v28);
  uint64_t v56 = (char *)&v53 - v30;
  Range<>.startIndex.getter(a2, (uint64_t)v26);
  uint64_t v64 = a2;
  Range<>.endIndex.getter(a2, (uint64_t)v23);
  uint64_t v31 = v14;
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v14 + 16);
  v32(v20, v26, v6);
  v32(v17, v23, v6);
  uint64_t v69 = v5;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v5 + 8) + 24LL))(v20, v17, v6) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v33 = v31;
  char v34 = *(void (**)(char *, uint64_t))(v31 + 8);
  v34(v17, v6);
  v34(v20, v6);
  uint64_t v54 = v27;
  uint64_t v35 = TupleTypeMetadata2;
  uint64_t v36 = v57;
  uint64_t v37 = &v57[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v38 = *(void (**)(char *, char *, uint64_t))(v33 + 32);
  v38(v57, v26, v6);
  v38(v37, v23, v6);
  uint64_t v39 = v58;
  uint64_t v40 = &v58[*((int *)v35 + 12)];
  v32(v58, v36, v6);
  v32(v40, v37, v6);
  uint64_t v41 = v55;
  v38(v55, v39, v6);
  v34(v40, v6);
  unint64_t v42 = &v39[*((int *)v35 + 12)];
  v38(v39, v36, v6);
  v38(v42, v37, v6);
  uint64_t v43 = v64;
  v38(&v41[*(int *)(v64 + 36)], v42, v6);
  v34(v39, v6);
  uint64_t v44 = v54;
  uint64_t v45 = v56;
  (*(void (**)(char *, char *, uint64_t))(v54 + 32))(v56, v41, v43);
  Collection._failEarlyRangeCheck(_:bounds:)(v70, v45, v43, v63);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v45, v43);
  unint64_t v46 = v61;
  uint64_t v47 = v62;
  uint64_t v48 = v67;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v62,  v67,  v61,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v50 = v60;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  v46,  AssociatedConformanceWitness);
  uint64_t v51 = v65;
  (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v50, v48, v47);
  (*(void (**)(char *, uint64_t))(v69 + 48))(v51, v6);
  return (*(uint64_t (**)(char *, uint64_t))(v66 + 8))(v51, v48);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v72 = a1;
  uint64_t v66 = a3;
  uint64_t v4 = *(void *)(a3 - 8);
  uint64_t v5 = *(void *)(a2 + 16);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v4,  v5,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v69 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v68 = (char *)&v55 - v7;
  uint64_t v65 = *(const char **)(*(void *)(swift_getAssociatedConformanceWitness( v4,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                                   + 8)
                       + 16LL);
  unint64_t v70 = AssociatedTypeWitness;
  unint64_t v64 = swift_getAssociatedTypeWitness( 0LL,  v65,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](v64);
  uint64_t v63 = (char *)&v55 - v8;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v5, v5, "lower upper ", 0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v57 = (char *)&v55 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v56 = (char *)&v55 - v12;
  uint64_t v61 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v59 = (char *)&v55 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  Swift::Int v60 = (char *)&v55 - v16;
  uint64_t v17 = *(void **)(v5 - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v55 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v55 - v22;
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v55 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v29 = (char *)&v55 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v62 = (char *)&v55 - v30;
  Range<>.startIndex.getter(a2, (uint64_t)v29);
  uint64_t v67 = a2;
  Range<>.endIndex.getter(a2, (uint64_t)v26);
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v17[2];
  v31(v23, v29, v5);
  v31(v20, v26, v5);
  uint64_t v71 = v4;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v4 + 8) + 24LL))(v23, v20, v5) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v32 = (void (*)(char *, uint64_t))v17[1];
  unint64_t v55 = v32;
  v32(v20, v5);
  v32(v23, v5);
  uint64_t v33 = TupleTypeMetadata2;
  char v34 = v56;
  uint64_t v35 = &v56[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v36 = (void (*)(char *, char *, uint64_t))v17[4];
  v36(v56, v29, v5);
  v36(v35, v26, v5);
  uint64_t v37 = v57;
  unint64_t v38 = &v57[*((int *)v33 + 12)];
  v31(v57, v34, v5);
  v31(v38, v35, v5);
  uint64_t v39 = v59;
  v36(v59, v37, v5);
  uint64_t v40 = v55;
  v55(v38, v5);
  uint64_t v41 = &v37[*((int *)v33 + 12)];
  v36(v37, v34, v5);
  v36(v41, v35, v5);
  uint64_t v42 = v67;
  v36(&v39[*(int *)(v67 + 36)], v41, v5);
  v40(v37, v5);
  uint64_t v43 = (void (*)(uint64_t, uint64_t))v40;
  uint64_t v45 = v60;
  uint64_t v44 = v61;
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v60, v39, v42);
  uint64_t v46 = v72;
  Collection._failEarlyRangeCheck(_:bounds:)(v72, v45, v42, v66);
  (*(void (**)(char *, uint64_t))(v44 + 8))(v45, v42);
  unint64_t v47 = v64;
  uint64_t v48 = v65;
  uint64_t v49 = v70;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v65,  v70,  v64,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v51 = v63;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  v47,  AssociatedConformanceWitness);
  uint64_t v52 = v68;
  (*((void (**)(char *, uint64_t, const char *))v48 + 3))(v51, v49, v48);
  uint64_t v53 = v62;
  (*(void (**)(char *, uint64_t))(v71 + 48))(v52, v5);
  v43(v46, v5);
  (*(void (**)(char *, uint64_t))(v69 + 8))(v52, v49);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v46, v53, v5);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance <> Range<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.index(before:)(a1, a2, *(void *)(a3 - 8), a4);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance <> Range<A>( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v11 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Range<>.index(before:)(v5, v8, v9, (uint64_t)v7);
  (*(void (**)(uint64_t, uint64_t))(v4 + 8))(a1, v3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v4 + 32))(a1, v7, v3);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance <> Range<A>@<X0>( void (*a1)(char *, uint64_t, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return Range<>.index(_:offsetBy:)(a1, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16), a5);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance <> ClosedRange<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  int8x16_t v14 = vextq_s8(*(int8x16_t *)(a5 - 16), *(int8x16_t *)(a5 - 16), 8uLL);
  uint64_t WitnessTable = swift_getWitnessTable(a6, a4, &v14);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a7);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Range<>.distance(from:to:)(a1, a2, a3, *(void *)(a4 - 8), *(void *)(a4 - 16));
}

uint64_t Range<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, char *a4@<X8>)
{
  uint64_t v49 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a2, a2, "lower upper ", 0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v48 = (char *)v42 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v46 = (char *)v42 - v9;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  a2,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)v42 - v11;
  uint64_t v13 = a3;
  uint64_t v43 = a3;
  uint64_t v14 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( (uint64_t)a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v14,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)v42 - v17;
  uint64_t v50 = *(void *)(a2 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)v42 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)v42 - v22;
  uint64_t v45 = *((void *)v13 + 1);
  uint64_t v25 = type metadata accessor for ClosedRange(0LL, a2, v45, v24);
  v42[1] = a1 + *(int *)(v25 + 36);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v14,  AssociatedTypeWitness,  v15,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  v15,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t, uint64_t))(v14 + 24))(v18, AssociatedTypeWitness, v14);
  (*((void (**)(char *, uint64_t))v43 + 6))(v12, a2);
  (*(void (**)(char *, unint64_t))(v44 + 8))(v12, AssociatedTypeWitness);
  uint64_t v27 = v50;
  uint64_t v28 = *(void (**)(char *, uint64_t, uint64_t))(v50 + 16);
  v28(v21, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v25 - 8) + 8LL))(a1, v25);
  uint64_t v30 = v46;
  uint64_t v29 = TupleTypeMetadata2;
  uint64_t v31 = &v46[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v27 + 32);
  v32(v46, v21, a2);
  v32(v31, v23, a2);
  uint64_t v33 = v29;
  char v34 = v48;
  uint64_t v35 = &v48[*((int *)v29 + 12)];
  v28(v48, (uint64_t)v30, a2);
  v28(v35, (uint64_t)v31, a2);
  uint64_t v36 = v49;
  v32(v49, v34, a2);
  uint64_t v37 = *(void (**)(char *, uint64_t))(v50 + 8);
  v37(v35, a2);
  unint64_t v38 = &v34[*((int *)v33 + 12)];
  v32(v34, v30, a2);
  v32(v38, v31, a2);
  uint64_t v40 = type metadata accessor for Range(0LL, a2, v45, v39);
  v32(&v36[*(int *)(v40 + 36)], v38, a2);
  return ((uint64_t (*)(char *, uint64_t))v37)(v34, a2);
}

uint64_t Range.relative<A>(to:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))(a2, v2, a1);
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance Range<A>@<X0>( uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return Range.relative<A>(to:)(a1, a2);
}

uint64_t ClosedRange.clamped(to:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v5 = a2;
  uint64_t v44 = a3;
  uint64_t v7 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v10 = (char *)&v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v40 - v12;
  uint64_t v14 = *(void *)(v7 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v11);
  uint64_t v41 = (char *)&v40 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v40 - v17;
  uint64_t v19 = *(void *)(v5 + 24);
  uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 40);
  char v20 = v40(a1, v4, v7, v19);
  uint64_t v45 = v5;
  uint64_t v42 = v14;
  if ((v20 & 1) != 0)
  {
    uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
    v21(v18, a1, v7);
    uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 16);
  }

  else
  {
    uint64_t v23 = a1 + *(int *)(v5 + 36);
    uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 16);
    char v24 = v22(v23, v4, v7, v19);
    uint64_t v21 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
    if ((v24 & 1) != 0)
    {
      uint64_t v25 = v18;
      uint64_t v26 = v23;
    }

    else
    {
      uint64_t v25 = v18;
      uint64_t v26 = v4;
    }

    v21(v25, v26, v7);
    uint64_t v5 = v45;
  }

  uint64_t v27 = *(int *)(v5 + 36);
  uint64_t v28 = a1 + v27;
  uint64_t v29 = v4 + v27;
  if ((v22(a1 + v27, v29, v7, v19) & 1) == 0)
  {
    if ((v40(a1, v29, v7, v19) & 1) != 0) {
      uint64_t v28 = a1;
    }
    else {
      uint64_t v28 = v29;
    }
  }

  uint64_t v30 = v41;
  v21(v41, v28, v7);
  uint64_t v31 = v42;
  uint64_t v32 = TupleTypeMetadata2;
  uint64_t v33 = &v13[*((int *)TupleTypeMetadata2 + 12)];
  char v34 = *(void (**)(char *, char *, uint64_t))(v42 + 32);
  v34(v13, v18, v7);
  v34(v33, v30, v7);
  uint64_t v35 = &v10[*((int *)v32 + 12)];
  v21(v10, (uint64_t)v13, v7);
  v21(v35, (uint64_t)v33, v7);
  uint64_t v36 = v44;
  v34(v44, v10, v7);
  uint64_t v37 = *(void (**)(char *, uint64_t))(v31 + 8);
  v37(v35, v7);
  unint64_t v38 = &v10[*((int *)v32 + 12)];
  v34(v10, v13, v7);
  v34(v38, v33, v7);
  v34(&v36[*(int *)(v45 + 36)], v38, v7);
  return ((uint64_t (*)(char *, uint64_t))v37)(v10, v7);
}

unint64_t Range.description.getter(uint64_t a1)
{
  uint64_t v2 = v1;
  unint64_t v14 = specialized static String._createEmpty(withInitialCapacity:)(7LL);
  unint64_t v15 = v4;
  uint64_t v5 = *(swift **)(a1 + 16);
  _print_unlocked<A, B>(_:_:)( v1,  (uint64_t)&v14,  v5,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  uint64_t v6 = v15;
  unint64_t v7 = HIBYTE(v15) & 0xF;
  if ((v15 & 0x2000000000000000LL) == 0) {
    unint64_t v7 = v14 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 || (v14 & ~v15 & 0x2000000000000000LL) != 0)
  {
    if ((v15 & 0x2000000000000000LL) == 0
      || (unint64_t v8 = specialized _SmallString.init(_:appending:)(v14, v15, 0x3C2E2EuLL, 0xE300000000000000LL), (v10 & 1) != 0))
    {
      _StringGuts.append(_:)(3943982LL, 0xE300000000000000LL, 0LL, 3LL);
    }

    else
    {
      unint64_t v11 = v8;
      unint64_t v12 = v9;
      swift_bridgeObjectRelease(v6);
      unint64_t v14 = v11;
      unint64_t v15 = v12;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v15);
    unint64_t v14 = 3943982LL;
    unint64_t v15 = 0xE300000000000000LL;
  }

  _print_unlocked<A, B>(_:_:)( v2 + *(int *)(a1 + 36),  (uint64_t)&v14,  v5,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  return v14;
}

unint64_t Range.debugDescription.getter(uint64_t a1)
{
  uint64_t v3 = v1;
  uint64_t v250 = a1;
  int64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (uint64_t)&v244 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = specialized static String._createEmpty(withInitialCapacity:)(8LL);
  unint64_t v12 = v8;
  unint64_t v13 = v9;
  unint64_t v253 = v8;
  unint64_t v254 = v9;
  unint64_t v14 = HIBYTE(v9) & 0xF;
  if ((v9 & 0x2000000000000000LL) != 0) {
    uint64_t v15 = HIBYTE(v9) & 0xF;
  }
  else {
    uint64_t v15 = v8 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v251 = v3;
  if (!v15 && (v8 & ~v9 & 0x2000000000000000LL) == 0)
  {
    unint64_t v12 = 0x2865676E6152LL;
    swift_bridgeObjectRelease(v9);
    unint64_t v46 = 0xE600000000000000LL;
    goto LABEL_40;
  }

  if ((v9 & 0x2000000000000000LL) == 0 || v14 > 9)
  {
    swift_bridgeObjectRetain_n(0xE600000000000000LL, 6LL, v10, v11);
    if ((v13 & 0x1000000000000000LL) != 0) {
      goto LABEL_159;
    }
    BOOL v21 = __OFADD__(v15, 6LL);
    int64_t v22 = v15 + 6;
    if (!v21) {
      goto LABEL_13;
    }
LABEL_161:
    __break(1u);
    goto LABEL_162;
  }

  uint64_t v16 = 8 * HIBYTE(v9);
  uint64_t v17 = (-255LL << (v16 & 0x38)) - 1;
  uint64_t v18 = 82LL << (v16 & 0x38);
  char v19 = v14 + 1;
  if (v14 >= 8)
  {
    unint64_t v20 = v18 | v17 & v9;
    goto LABEL_31;
  }

  unint64_t v12 = v18 | v17 & v8;
  if (v14 == 7)
  {
    char v19 = 8;
    unint64_t v20 = v9;
LABEL_31:
    uint64_t v49 = (97LL << (8 * (v19 & 7u))) | ((-255LL << (8 * (v19 & 7u))) - 1) & v20;
    char v50 = v14 + 2;
LABEL_32:
    uint64_t v51 = (110LL << (8 * (v50 & 7u))) | ((-255LL << (8 * (v50 & 7u))) - 1) & v49;
    char v52 = v14 + 3;
LABEL_33:
    uint64_t v53 = (103LL << (8 * (v52 & 7u))) | ((-255LL << (8 * (v52 & 7u))) - 1) & v51;
    char v54 = v14 + 4;
LABEL_34:
    uint64_t v55 = (101LL << (8 * (v54 & 7u))) | ((-255LL << (8 * (v54 & 7u))) - 1) & v53;
    char v56 = v14 + 5;
    goto LABEL_35;
  }

  unint64_t v12 = (97LL << (8 * (v19 & 7u))) | ((-255LL << (8 * (v19 & 7u))) - 1) & v12;
  if (v14 >= 6)
  {
    char v50 = 8;
    uint64_t v49 = v9;
    goto LABEL_32;
  }

  unint64_t v12 = (110LL << ((v16 + 16) & 0x38)) | ((-255LL << ((v16 + 16) & 0x38)) - 1) & v12;
  if (v14 == 5)
  {
    char v52 = 8;
    uint64_t v51 = v9;
    goto LABEL_33;
  }

  unint64_t v12 = (103LL << ((v16 + 24) & 0x38)) | ((-255LL << ((v16 + 24) & 0x38)) - 1) & v12;
  if (v14 >= 4)
  {
    char v54 = 8;
    uint64_t v53 = v9;
    goto LABEL_34;
  }

  unint64_t v12 = (101LL << ((v16 + 32) & 0x38)) | ((-255LL << ((v16 + 32) & 0x38)) - 1) & v12;
  if (v14 != 3)
  {
    unint64_t v12 = (40LL << ((v16 + 40) & 0x38)) | ((-255LL << ((v16 + 40) & 0x38)) - 1) & v12;
    uint64_t v57 = v9;
    goto LABEL_36;
  }

  char v56 = 8;
  uint64_t v55 = v9;
LABEL_35:
  uint64_t v57 = (40LL << (8 * (v56 & 7u))) | ((-255LL << (8 * (v56 & 7u))) - 1) & v55;
LABEL_36:
  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRelease(0xE600000000000000LL);
  unint64_t v58 = 0xA000000000000000LL;
  if (!(v12 & 0x8080808080808080LL | v57 & 0x80808080808080LL)) {
    unint64_t v58 = 0xE000000000000000LL;
  }
  unint64_t v46 = (v58 & 0xFF00000000000000LL | (v14 << 56) | v57 & 0xFFFFFFFFFFFFFFLL) + 0x600000000000000LL;
LABEL_40:
  unint64_t v253 = v12;
  unint64_t v254 = v46;
  while (1)
  {
    unint64_t v249 = *(void (**)(uint64_t, uint64_t, int64_t))(v5 + 16);
    v249(v7, v3, v4);
    *(void *)&__int128 v252 = 0LL;
    *((void *)&v252 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 0xE000000000000000LL;
    _debugPrint_unlocked<A, B>(_:_:)( v7,  (uint64_t)&v252,  (swift *)v4,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
    uint64_t v248 = *(void (**)(uint64_t, int64_t))(v5 + 8);
    v248(v7, v4);
    unint64_t v13 = *((void *)&v252 + 1);
    uint64_t v5 = v252;
    uint64_t v61 = HIBYTE(v46) & 0xF;
    uint64_t v2 = v12 & 0xFFFFFFFFFFFFLL;
    if ((v46 & 0x2000000000000000LL) != 0) {
      uint64_t v62 = HIBYTE(v46) & 0xF;
    }
    else {
      uint64_t v62 = v12 & 0xFFFFFFFFFFFFLL;
    }
    if (!v62 && (v12 & ~v46 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v46);
      unint64_t v253 = v5;
      unint64_t v254 = v13;
      goto LABEL_128;
    }

    uint64_t v247 = v7;
    uint64_t v3 = *((void *)&v252 + 1) & 0x2000000000000000LL;
    uint64_t v7 = HIBYTE(*((void *)&v252 + 1)) & 0xFLL;
    if ((v46 & 0x2000000000000000LL) != 0)
    {
      if (v3) {
        break;
      }
    }

uint64_t ClosedRange.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  unint64_t v32 = (uint64_t *)((char *)&v33[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v33[-1] - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))((char *)&v33[-1] - v9, v3, a1);
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  unint64_t v12 = swift_allocObject(v11, 0x80uLL, 7uLL);
  *((_OWORD *)v12 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_1817FFCF0;
  v12[4] = 0x756F427265776F6CLL;
  v12[5] = 0xEA0000000000646ELL;
  uint64_t v13 = *(void *)(a1 + 16);
  v12[9] = v13;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v12 + 6);
  uint64_t v15 = *(void (**)(void *, uint64_t, uint64_t))(*(void *)(v13 - 8) + 16LL);
  v15(boxed_opaque_existential_0Tm, v3, v13);
  v12[10] = 0x756F427265707075LL;
  v12[11] = 0xEA0000000000646ELL;
  uint64_t v16 = v3 + *(int *)(a1 + 36);
  v12[15] = v13;
  uint64_t v17 = __swift_allocate_boxed_opaque_existential_0Tm(v12 + 12);
  v15(v17, v16, v13);
  v33[0] = 0LL;
  v33[1] = 0LL;
  uint64_t v18 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v10, (uint64_t)v33, (swift *)a1);
  uint64_t v20 = v19;
  uint64_t v21 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  int64_t v22 = swift_allocObject(v21, 0x48uLL, 7uLL);
  v22[6] = v12;
  v22[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v22[8] = 0LL;
  uint64_t v23 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  char v24 = swift_allocObject(v23, 0x18uLL, 7uLL);
  v24[2] = 0LL;
  uint64_t v25 = v12[2];
  BOOL v26 = swift_allocObject(v23, 0x18uLL, 7uLL);
  void v26[2] = v25;
  _OWORD v22[2] = v24;
  v22[3] = &protocol witness table for _IndexBox<A>;
  v22[4] = v26;
  unint64_t v22[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v27 = *(void (**)(uint64_t *, char *, uint64_t))(v6 + 32);
  uint64_t v28 = v32;
  v27(v32, v10, a1);
  uint64_t v29 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v33, v28, (swift *)a1, v29, 6uLL);
  char v31 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v33);
  }
  *(void *)a2 = a1;
  *(void *)(a2 + 8) = v22;
  *(_BYTE *)(a2 + 16) = 8;
  *(void *)(a2 + 24) = v18;
  *(void *)(a2 + 32) = v20;
  *(_BYTE *)(a2 + 4_assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_rawHashValue(_seed:) called on non-canonical AnyHashable box",  61LL,  2,  "Swift/NewtypeWrapper.swift",  26LL,  2,  0x4FuLL, 0) = v31;
  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance Range<A>( char *a1, char *a2, uint64_t a3)
{
  return static Range.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t ClosedRange<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void (**)(uint64_t, uint64_t))(a3 + 24);
  uint64_t v6 = *(void *)(a2 + 16);
  v5(a1, v6);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v5)(a1, v6, a3);
}

Swift::Int ClosedRange<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  uint64_t v3 = *(void (**)(void *, uint64_t, uint64_t))(a2 + 24);
  uint64_t v4 = *(void *)(a1 + 16);
  v3(v6, v4, a2);
  v3(v6, v4, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> Range<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))Range<>.hash(into:));
}

uint64_t Range<>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  return ClosedRange<>.init(from:)( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for Range,  a5);
}

uint64_t ClosedRange<>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t (*a5)(void, uint64_t, uint64_t)@<X4>, uint64_t a6@<X8>)
{
  unint64_t v117 = a4;
  uint64_t v113 = a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a2, a2, "lower upper ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v112 = (char *)&v107 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  unint64_t v110 = (char *)&v107 - v12;
  uint64_t v114 = a3;
  unint64_t v116 = a5(0LL, a2, a3);
  uint64_t v111 = *(void *)(v116 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v116);
  uint64_t v15 = (char *)&v107 - v14;
  uint64_t v16 = *(void *)(a2 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v13);
  uint64_t v19 = (char *)&v107 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v107 - v20;
  uint64_t v22 = a1[3];
  uint64_t v23 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v22);
  char v24 = v123;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v23 + 32))(v120, v22, v23);
  if (v24)
  {
LABEL_63:
    char v45 = a1;
    return __swift_destroy_boxed_opaque_existential_1Tm(v45);
  }

  size_t v107 = v15;
  uint64_t v108 = v16;
  unint64_t v109 = v19;
  unint64_t v123 = a1;
  uint64_t v26 = v121;
  uint64_t v25 = v122;
  __swift_mutable_project_boxed_opaque_existential_1(v120, v121);
  uint64_t v27 = v117;
  (*(void (**)(uint64_t, uint64_t, void *, uint64_t, uint64_t))(v25 + 176))(a2, a2, v117, v26, v25);
  uint64_t v28 = v21;
  uint64_t v30 = v121;
  uint64_t v29 = v122;
  __swift_mutable_project_boxed_opaque_existential_1(v120, v121);
  uint64_t v31 = (uint64_t)v109;
  (*(void (**)(uint64_t, uint64_t, void *, uint64_t, uint64_t))(v29 + 176))(a2, a2, v27, v30, v29);
  if (((*(uint64_t (**)(char *, uint64_t, uint64_t))(v114 + 24))(v28, v31, a2) & 1) == 0)
  {
    uint64_t v46 = (uint64_t)v28;
    unint64_t v47 = (swift *)a2;
    unint64_t v117 = swift_allocError( (uint64_t)&type metadata for DecodingError,  (uint64_t)&protocol witness table for DecodingError,  0LL,  0);
    uint64_t v49 = v48;
    uint64_t v50 = v123[3];
    uint64_t v51 = v123[4];
    __swift_project_boxed_opaque_existential_0Tm(v123, v50);
    TupleTypeMetadata2 = (unint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(v51 + 8))(v50, v51);
    unint64_t v52 = specialized static String._createEmpty(withInitialCapacity:)(72LL);
    uint64_t v54 = v53;
    unint64_t v118 = v52;
    unint64_t v119 = v53;
    uint64_t v55 = HIBYTE(v53) & 0xF;
    if ((v53 & 0x2000000000000000LL) == 0) {
      uint64_t v55 = v52 & 0xFFFFFFFFFFFFLL;
    }
    if (v55 || (v52 & ~v53 & 0x2000000000000000LL) != 0)
    {
      uint64_t v56 = v108;
      if ((v53 & 0x2000000000000000LL) != 0
        && (0x80000001818B5860LL & 0x2000000000000000LL) != 0
        && (unint64_t v57 = specialized _SmallString.init(_:appending:)( v52,  v53,  0xD000000000000012LL,  0x80000001818B5860LL | 0x8000000000000000LL),  (v59 & 1) == 0))
      {
        unint64_t v60 = v57;
        unint64_t v61 = v58;
        swift_bridgeObjectRelease(v54);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
        unint64_t v118 = v60;
        unint64_t v119 = v61;
      }

      else
      {
        if ((0x80000001818B5860LL & 0x2000000000000000LL) != 0) {
          unint64_t v62 = (0x80000001818B5860LL >> 56) & 0xF;
        }
        else {
          unint64_t v62 = 18LL;
        }
        _StringGuts.append(_:)(0xD000000000000012LL, 0x80000001818B5860LL | 0x8000000000000000LL, 0LL, v62);
        swift_bridgeObjectRelease(0x80000001818B5860LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v53);
      unint64_t v118 = 0xD000000000000012LL;
      unint64_t v119 = 0x80000001818B5860LL | 0x8000000000000000LL;
      uint64_t v56 = v108;
    }

    TypeName = (uint64_t *)swift_getTypeName(v116, 0);
    if (v64 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    uint64_t v65 = (uint8x16_t *)TypeName;
    int64_t v66 = v64;
    int64_t v67 = validateUTF8(_:)(TypeName, v64);
    if ((v69 & 1) != 0) {
      unint64_t v70 = repairUTF8(_:firstKnownBrokenRange:)(v65->i8, v66, v67, v68);
    }
    else {
      unint64_t v70 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v65, v66, v67 & 1);
    }
    unint64_t v72 = v70;
    unint64_t v73 = v71;
    uint64_t v74 = v119;
    unint64_t v75 = HIBYTE(v119) & 0xF;
    if ((v119 & 0x2000000000000000LL) == 0) {
      unint64_t v75 = v118 & 0xFFFFFFFFFFFFLL;
    }
    if (!v75 && (v118 & ~v119 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v119);
      unint64_t v118 = v72;
      unint64_t v119 = v73;
      goto LABEL_30;
    }

    if ((v119 & 0x2000000000000000LL) != 0)
    {
      if ((v71 & 0x2000000000000000LL) != 0)
      {
        unint64_t v102 = specialized _SmallString.init(_:appending:)(v118, v119, v70, v71);
        if ((v104 & 1) == 0)
        {
          unint64_t v105 = v102;
          unint64_t v106 = v103;
          swift_bridgeObjectRelease(v74);
          swift_bridgeObjectRelease(v73);
          unint64_t v118 = v105;
          unint64_t v119 = v106;
          unint64_t v73 = v106;
          unint64_t v72 = v105;
          uint64_t v56 = v108;
          goto LABEL_30;
        }

        uint64_t v76 = HIBYTE(v73) & 0xF;
        uint64_t v56 = v108;
LABEL_29:
        _StringGuts.append(_:)(v72, v73, 0LL, v76);
        swift_bridgeObjectRelease(v73);
        unint64_t v72 = v118;
        unint64_t v73 = v119;
LABEL_30:
        uint64_t v77 = HIBYTE(v73) & 0xF;
        if ((v73 & 0x2000000000000000LL) == 0) {
          uint64_t v77 = v72 & 0xFFFFFFFFFFFFLL;
        }
        if (v77 || (v72 & ~v73 & 0x2000000000000000LL) != 0)
        {
          if ((v73 & 0x2000000000000000LL) != 0
            && (0x80000001818B5D90LL & 0x2000000000000000LL) != 0
            && (unint64_t v78 = specialized _SmallString.init(_:appending:)( v72,  v73,  0xD000000000000014LL,  0x80000001818B5D90LL | 0x8000000000000000LL),  (v80 & 1) == 0))
          {
            unint64_t v81 = v78;
            unint64_t v82 = v79;
            swift_bridgeObjectRelease(v73);
            swift_bridgeObjectRelease(0x80000001818B5D90LL | 0x8000000000000000LL);
            unint64_t v118 = v81;
            unint64_t v119 = v82;
          }

          else
          {
            if ((0x80000001818B5D90LL & 0x2000000000000000LL) != 0) {
              unint64_t v83 = (0x80000001818B5D90LL >> 56) & 0xF;
            }
            else {
              unint64_t v83 = 20LL;
            }
            _StringGuts.append(_:)(0xD000000000000014LL, 0x80000001818B5D90LL | 0x8000000000000000LL, 0LL, v83);
            swift_bridgeObjectRelease(0x80000001818B5D90LL | 0x8000000000000000LL);
          }
        }

        else
        {
          swift_bridgeObjectRelease(v73);
          unint64_t v118 = 0xD000000000000014LL;
          unint64_t v119 = 0x80000001818B5D90LL | 0x8000000000000000LL;
        }

        _print_unlocked<A, B>(_:_:)( v46,  (uint64_t)&v118,  v47,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
        uint64_t v84 = *(void (**)(uint64_t, swift *))(v56 + 8);
        v84(v46, v47);
        uint64_t v85 = v119;
        unint64_t v86 = HIBYTE(v119) & 0xF;
        if ((v119 & 0x2000000000000000LL) == 0) {
          unint64_t v86 = v118 & 0xFFFFFFFFFFFFLL;
        }
        if (v86 || (v118 & ~v119 & 0x2000000000000000LL) != 0)
        {
          if ((v119 & 0x2000000000000000LL) != 0
            && (0x80000001818B5DB0LL & 0x2000000000000000LL) != 0
            && (unint64_t v87 = specialized _SmallString.init(_:appending:)( v118,  v119,  0xD00000000000001BLL,  0x80000001818B5DB0LL | 0x8000000000000000LL),  (v89 & 1) == 0))
          {
            unint64_t v90 = v87;
            unint64_t v91 = v88;
            swift_bridgeObjectRelease(v85);
            swift_bridgeObjectRelease(0x80000001818B5DB0LL | 0x8000000000000000LL);
            unint64_t v118 = v90;
            unint64_t v119 = v91;
          }

          else
          {
            if ((0x80000001818B5DB0LL & 0x2000000000000000LL) != 0) {
              unint64_t v92 = (0x80000001818B5DB0LL >> 56) & 0xF;
            }
            else {
              unint64_t v92 = 27LL;
            }
            _StringGuts.append(_:)(0xD00000000000001BLL, 0x80000001818B5DB0LL | 0x8000000000000000LL, 0LL, v92);
            swift_bridgeObjectRelease(0x80000001818B5DB0LL | 0x8000000000000000LL);
          }
        }

        else
        {
          swift_bridgeObjectRelease(v119);
          unint64_t v118 = 0xD00000000000001BLL;
          unint64_t v119 = 0x80000001818B5DB0LL | 0x8000000000000000LL;
        }

        uint64_t v93 = (uint64_t)v109;
        _print_unlocked<A, B>(_:_:)( (uint64_t)v109,  (uint64_t)&v118,  v47,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
        v84(v93, v47);
        uint64_t v94 = v119;
        unint64_t v95 = HIBYTE(v119) & 0xF;
        if ((v119 & 0x2000000000000000LL) == 0) {
          unint64_t v95 = v118 & 0xFFFFFFFFFFFFLL;
        }
        if (v95 || (v118 & ~v119 & 0x2000000000000000LL) != 0)
        {
          if ((v119 & 0x2000000000000000LL) == 0
            || (unint64_t v96 = specialized _SmallString.init(_:appending:)(v118, v119, 0x29uLL, 0xE100000000000000LL),
                (v98 & 1) != 0))
          {
            _StringGuts.append(_:)(41LL, 0xE100000000000000LL, 0LL, 1LL);
            swift_bridgeObjectRelease(0xE100000000000000LL);
            unint64_t v99 = v118;
            unint64_t v100 = v119;
          }

          else
          {
            unint64_t v99 = v96;
            unint64_t v100 = v97;
            swift_bridgeObjectRelease(v94);
            swift_bridgeObjectRelease(0xE100000000000000LL);
          }
        }

        else
        {
          swift_bridgeObjectRelease(v119);
          unint64_t v100 = 0xE100000000000000LL;
          unint64_t v99 = 41LL;
        }

        *(void *)uint64_t v49 = TupleTypeMetadata2;
        *(void *)(v49 + 8) = v99;
        *(void *)(v49 + 16) = v100;
        *(void *)(v49 + 24) = 0LL;
        *(_BYTE *)(v49 + 72) = 3;
        swift_willThrow();
        __swift_destroy_boxed_opaque_existential_1Tm(v120);
        a1 = v123;
        goto LABEL_63;
      }
    }

    else if ((v71 & 0x2000000000000000LL) != 0)
    {
      uint64_t v76 = HIBYTE(v71) & 0xF;
      goto LABEL_29;
    }

    uint64_t v76 = v70 & 0xFFFFFFFFFFFFLL;
    goto LABEL_29;
  }

  unint64_t v32 = TupleTypeMetadata2;
  Swift::String::Index v33 = v110;
  Swift::String::Index v34 = &v110[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v117 = 0LL;
  uint64_t v35 = v108;
  Swift::String::Index v36 = *(void (**)(char *, char *, uint64_t))(v108 + 32);
  v36(v110, v28, a2);
  unint64_t v37 = v34;
  v36(v34, (char *)v31, a2);
  unint64_t v38 = v112;
  unint64_t v39 = &v112[*((int *)v32 + 12)];
  unint64_t v40 = *(void (**)(char *, char *, uint64_t))(v35 + 16);
  v40(v112, v33, a2);
  v40(v39, v37, a2);
  unint64_t v41 = v107;
  v36(v107, v38, a2);
  unint64_t v42 = *(void (**)(char *, uint64_t))(v35 + 8);
  v42(v39, a2);
  unint64_t v43 = &v38[*((int *)TupleTypeMetadata2 + 12)];
  v36(v38, v33, a2);
  v36(v43, v37, a2);
  unint64_t v44 = v116;
  v36(&v41[*(int *)(v116 + 36)], v43, a2);
  v42(v38, a2);
  (*(void (**)(uint64_t, char *, unint64_t))(v111 + 32))(v113, v41, v44);
  __swift_destroy_boxed_opaque_existential_1Tm(v120);
  char v45 = v123;
  return __swift_destroy_boxed_opaque_existential_1Tm(v45);
}

uint64_t protocol witness for Decodable.init(from:) in conformance <> Range<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a2 + 24), *(void **)(a3 - 8), a4);
}

uint64_t Range<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return ClosedRange<>.encode(to:)(a1, a2, a3);
}

uint64_t PartialRangeUpTo.relative<A>(to:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  unint64_t v42 = a4;
  uint64_t v7 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v40 = (char *)&v38 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v39 = (char *)&v38 - v11;
  uint64_t v12 = *(void **)(v7 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v38 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v38 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v38 - v22;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  char v24 = (void (*)(char *, uint64_t, uint64_t))v12[2];
  v24(v21, v43, v7);
  v24(v18, (uint64_t)v23, v7);
  v24(v15, (uint64_t)v21, v7);
  uint64_t v25 = *(void *)(a1 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v7, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v43 = v25;
  uint64_t v26 = (void (*)(char *, uint64_t))v12[1];
  v26(v15, v7);
  v26(v18, v7);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = v39;
  uint64_t v29 = &v39[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v30 = (void (*)(char *, char *, uint64_t))v12[4];
  v30(v39, v23, v7);
  v30(v29, v21, v7);
  uint64_t v31 = v40;
  unint64_t v32 = &v40[*((int *)v27 + 12)];
  v24(v40, (uint64_t)v28, v7);
  v24(v32, (uint64_t)v29, v7);
  Swift::String::Index v33 = v42;
  v30(v42, v31, v7);
  v26(v32, v7);
  Swift::String::Index v34 = &v31[*((int *)v27 + 12)];
  v30(v31, v28, v7);
  v30(v34, v29, v7);
  uint64_t v36 = type metadata accessor for Range(0LL, v7, v43, v35);
  v30(&v33[*(int *)(v36 + 36)], v34, v7);
  return ((uint64_t (*)(char *, uint64_t))v26)(v31, v7);
}

uint64_t PartialRangeUpTo.contains(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 16LL))(a1, v2) & 1;
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance PartialRangeUpTo<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v43 = a4;
  uint64_t v7 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v41 = (char *)&v39 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v40 = (char *)&v39 - v11;
  uint64_t v12 = *(void **)(v7 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v39 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v39 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v39 - v22;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  char v24 = (void (*)(char *, uint64_t, uint64_t))v12[2];
  v24(v21, v44, v7);
  v24(v18, (uint64_t)v23, v7);
  v24(v15, (uint64_t)v21, v7);
  uint64_t v25 = *(void *)(a3 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v7, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v26 = (void (*)(char *, uint64_t))v12[1];
  v26(v15, v7);
  v26(v18, v7);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = *((int *)TupleTypeMetadata2 + 12);
  uint64_t v44 = v25;
  uint64_t v29 = v40;
  uint64_t v30 = &v40[v28];
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v12[4];
  v31(v40, v23, v7);
  v31(v30, v21, v7);
  unint64_t v32 = v41;
  Swift::String::Index v33 = &v41[*((int *)v27 + 12)];
  v24(v41, (uint64_t)v29, v7);
  v24(v33, (uint64_t)v30, v7);
  Swift::String::Index v34 = v43;
  v31(v43, v32, v7);
  v26(v33, v7);
  uint64_t v35 = &v32[*((int *)v27 + 12)];
  v31(v32, v29, v7);
  v31(v35, v30, v7);
  uint64_t v37 = type metadata accessor for Range(0LL, v7, v44, v36);
  v31(&v34[*(int *)(v37 + 36)], v35, v7);
  return ((uint64_t (*)(char *, uint64_t))v26)(v32, v7);
}

uint64_t protocol witness for RangeExpression.contains(_:) in conformance PartialRangeUpTo<A>( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 16LL))(a1, v2) & 1;
}

uint64_t PartialRangeUpTo<>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return PartialRangeUpTo<>.init(from:)(a1, a2, a3, a4);
}

{
  uint64_t v4;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v18[3];
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v21 = a3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = (void *)MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v18[-1] - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = v9[3];
  uint64_t v13 = v9[4];
  __swift_project_boxed_opaque_existential_0Tm(v9, v12);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v13 + 32))(v18, v12, v13);
  if (!v4)
  {
    uint64_t v14 = v19;
    uint64_t v15 = v20;
    __swift_mutable_project_boxed_opaque_existential_1(v18, v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v15 + 176))(a2, a2, v21, v14, v15);
    (*(void (**)(uint64_t, char *, uint64_t))(v8 + 32))(a4, v11, a2);
    __swift_destroy_boxed_opaque_existential_1Tm(v18);
  }

  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t PartialRangeUpTo<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeUpTo<>.encode(to:)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11[3];
  uint64_t v12;
  uint64_t v13;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 32))(v11, v6, v7);
  uint64_t v8 = v12;
  uint64_t v9 = v13;
  __swift_mutable_project_boxed_opaque_existential_1(v11, v12);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t))(v9 + 160))(v3, *(void *)(a2 + 16), a3, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v11);
}

uint64_t PartialRangeThrough.relative<A>(to:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v43 = a4;
  uint64_t v7 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v41 = (char *)&v39 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v40 = (char *)&v39 - v11;
  uint64_t v12 = *(void **)(v7 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v39 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v39 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v39 - v22;
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 184))(v44, a2, a3);
  char v24 = (void (*)(char *, char *, uint64_t))v12[2];
  v24(v18, v23, v7);
  v24(v15, v21, v7);
  uint64_t v25 = *(void *)(a1 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v7, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v26 = (void (*)(char *, uint64_t))v12[1];
  v26(v15, v7);
  v26(v18, v7);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = *((int *)TupleTypeMetadata2 + 12);
  uint64_t v44 = v25;
  uint64_t v29 = v40;
  uint64_t v30 = &v40[v28];
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v12[4];
  v31(v40, v23, v7);
  v31(v30, v21, v7);
  unint64_t v32 = v41;
  Swift::String::Index v33 = &v41[*((int *)v27 + 12)];
  v24(v41, v29, v7);
  v24(v33, v30, v7);
  Swift::String::Index v34 = v43;
  v31(v43, v32, v7);
  v26(v33, v7);
  uint64_t v35 = &v32[*((int *)v27 + 12)];
  v31(v32, v29, v7);
  v31(v35, v30, v7);
  uint64_t v37 = type metadata accessor for Range(0LL, v7, v44, v36);
  v31(&v34[*(int *)(v37 + 36)], v35, v7);
  return ((uint64_t (*)(char *, uint64_t))v26)(v32, v7);
}

uint64_t PartialRangeThrough.contains(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 24LL))(a1, v2) & 1;
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance PartialRangeThrough<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v43 = a4;
  uint64_t v7 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v41 = (char *)&v39 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v40 = (char *)&v39 - v11;
  uint64_t v12 = *(void **)(v7 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v39 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v39 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v39 - v22;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 184))(v44, a1, a2);
  char v24 = (void (*)(char *, char *, uint64_t))v12[2];
  v24(v18, v23, v7);
  v24(v15, v21, v7);
  uint64_t v25 = *(void *)(a3 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v18, v15, v7, v25) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v26 = (void (*)(char *, uint64_t))v12[1];
  v26(v15, v7);
  v26(v18, v7);
  uint64_t v27 = TupleTypeMetadata2;
  uint64_t v28 = *((int *)TupleTypeMetadata2 + 12);
  uint64_t v44 = v25;
  uint64_t v29 = v40;
  uint64_t v30 = &v40[v28];
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v12[4];
  v31(v40, v23, v7);
  v31(v30, v21, v7);
  unint64_t v32 = v41;
  Swift::String::Index v33 = &v41[*((int *)v27 + 12)];
  v24(v41, v29, v7);
  v24(v33, v30, v7);
  Swift::String::Index v34 = v43;
  v31(v43, v32, v7);
  v26(v33, v7);
  uint64_t v35 = &v32[*((int *)v27 + 12)];
  v31(v32, v29, v7);
  v31(v35, v30, v7);
  uint64_t v37 = type metadata accessor for Range(0LL, v7, v44, v36);
  v31(&v34[*(int *)(v37 + 36)], v35, v7);
  return ((uint64_t (*)(char *, uint64_t))v26)(v32, v7);
}

uint64_t protocol witness for RangeExpression.contains(_:) in conformance PartialRangeThrough<A>( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 24LL))(a1, v2) & 1;
}

uint64_t PartialRangeThrough<>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return PartialRangeUpTo<>.init(from:)(a1, a2, a3, a4);
}

uint64_t PartialRangeThrough<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeUpTo<>.encode(to:)(a1, a2, a3);
}

uint64_t PartialRangeFrom.relative<A>(to:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v43 = a1;
  uint64_t v44 = a3;
  unint64_t v40 = a5;
  uint64_t v8 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v8, v8, "lower upper ", 0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v41 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v39 = (char *)&v39 - v12;
  uint64_t v13 = *(void **)(v8 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v39 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v39 - v21;
  MEMORY[0x1895F8858](v20);
  char v24 = (char *)&v39 - v23;
  uint64_t v25 = (void (*)(char *, uint64_t, uint64_t))v13[2];
  v25((char *)&v39 - v23, v5, v8);
  (*(void (**)(uint64_t, uint64_t))(a4 + 72))(v44, a4);
  v25(v19, (uint64_t)v24, v8);
  v25(v16, (uint64_t)v22, v8);
  uint64_t v26 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a2 + 24) + 24LL);
  uint64_t v44 = *(void *)(a2 + 24);
  if ((v26(v19, v16, v8) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v27 = (void (*)(char *, uint64_t))v13[1];
  v27(v16, v8);
  v27(v19, v8);
  uint64_t v28 = TupleTypeMetadata2;
  uint64_t v29 = v39;
  uint64_t v30 = &v39[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v13[4];
  v31(v39, v24, v8);
  v31(v30, v22, v8);
  unint64_t v32 = v41;
  Swift::String::Index v33 = &v41[*((int *)v28 + 12)];
  v25(v41, (uint64_t)v29, v8);
  v25(v33, (uint64_t)v30, v8);
  Swift::String::Index v34 = v40;
  v31(v40, v32, v8);
  v27(v33, v8);
  uint64_t v35 = &v32[*((int *)v28 + 12)];
  v31(v32, v29, v8);
  v31(v35, v30, v8);
  uint64_t v37 = type metadata accessor for Range(0LL, v8, v44, v36);
  v31(&v34[*(int *)(v37 + 36)], v35, v8);
  return ((uint64_t (*)(char *, uint64_t))v27)(v32, v8);
}

uint64_t PartialRangeFrom.contains(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 + 24) + 24LL))(v2, a1) & 1;
}

uint64_t protocol witness for RangeExpression.relative<A>(to:) in conformance PartialRangeFrom<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  uint64_t v43 = a1;
  uint64_t v44 = a2;
  unint64_t v40 = a5;
  uint64_t v8 = *(void *)(a4 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v8, v8, "lower upper ", 0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v41 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v39 = (char *)&v39 - v12;
  uint64_t v13 = *(void **)(v8 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v39 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v22 = (char *)&v39 - v21;
  MEMORY[0x1895F8858](v20);
  char v24 = (char *)&v39 - v23;
  uint64_t v25 = (void (*)(char *, uint64_t, uint64_t))v13[2];
  v25((char *)&v39 - v23, v5, v8);
  (*(void (**)(uint64_t, uint64_t))(a3 + 72))(v44, a3);
  v25(v19, (uint64_t)v24, v8);
  v25(v16, (uint64_t)v22, v8);
  uint64_t v26 = *(void *)(a4 + 24);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v26 + 24))(v19, v16, v8, v26) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v44 = v26;
  uint64_t v27 = (void (*)(char *, uint64_t))v13[1];
  v27(v16, v8);
  v27(v19, v8);
  uint64_t v28 = TupleTypeMetadata2;
  uint64_t v29 = v39;
  uint64_t v30 = &v39[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v31 = (void (*)(char *, char *, uint64_t))v13[4];
  v31(v39, v24, v8);
  v31(v30, v22, v8);
  unint64_t v32 = v41;
  Swift::String::Index v33 = &v41[*((int *)v28 + 12)];
  v25(v41, (uint64_t)v29, v8);
  v25(v33, (uint64_t)v30, v8);
  Swift::String::Index v34 = v40;
  v31(v40, v32, v8);
  v27(v33, v8);
  uint64_t v35 = &v32[*((int *)v28 + 12)];
  v31(v32, v29, v8);
  v31(v35, v30, v8);
  uint64_t v37 = type metadata accessor for Range(0LL, v8, v44, v36);
  v31(&v34[*(int *)(v37 + 36)], v35, v8);
  return ((uint64_t (*)(char *, uint64_t))v27)(v32, v8);
}

uint64_t (*PartialRangeFrom<>.Iterator._current.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t PartialRangeFrom<>.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v20 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v20,  v4,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v21 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v19 = (char *)&v18 - v6;
  uint64_t v7 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( (uint64_t)v20,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                             + 8)
                 + 16LL);
  unint64_t v8 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v18 - v10;
  uint64_t v12 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a2, v2, v4);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v12 + 56))(a2, 0LL, 1LL, v4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  AssociatedTypeWitness,  v8,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE70,  512LL,  v8,  AssociatedConformanceWitness);
  uint64_t v16 = v19;
  (*(void (**)(char *, unint64_t, uint64_t))(v7 + 24))(v11, AssociatedTypeWitness, v7);
  (*((void (**)(char *, uint64_t))v20 + 6))(v16, v4);
  (*(void (**)(char *, unint64_t))(v21 + 8))(v16, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v12 + 40))(v2, v14, v4);
}

uint64_t PartialRangeFrom<>.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 32LL))(a2, v2);
}

uint64_t PartialRangeFrom<>.init(from:)@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return PartialRangeUpTo<>.init(from:)(a1, a2, a3, a4);
}

uint64_t protocol witness for Decodable.init(from:) in conformance <> PartialRangeFrom<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return PartialRangeFrom<>.init(from:)(a1, *(void *)(a2 + 16), *(void *)(a3 - 8), a4);
}

uint64_t PartialRangeFrom<>.encode(to:)(void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeUpTo<>.encode(to:)(a1, a2, a3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> PartialRangeFrom<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return PartialRangeFrom<>.encode(to:)(a1, a2, *(void *)(a3 - 8));
}

uint64_t static Comparable...< prefix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return static Comparable.... postfix(_:)(a1, a2, a3, "Range cannot have an unordered upper bound.", 0x311uLL, a4);
}

uint64_t static Comparable.... prefix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return static Comparable.... postfix(_:)(a1, a2, a3, "Range cannot have an unordered upper bound.", 0x330uLL, a4);
}

uint64_t static Comparable.... postfix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, unint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v17 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v15(v14, a1, a2);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3 + 8) + 8LL))(v14, v14, a2) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a4,  43LL,  2,  "Swift/Range.swift",  17LL,  2,  a5,  0);
  }
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, a2);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v15)(a6, a1, a2);
}

uint64_t Collection.subscript.getter@<X0>(uint64_t a1@<X2>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v65 = a3;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v64 = (char *)&v55 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  char v59 = (char *)&v55 - v9;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v62 = *(void *)(v12 - 8);
  uint64_t v63 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v58 = (char *)&v55 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v60 = (char *)&v55 - v16;
  uint64_t v17 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  int64_t v68 = (char *)&v55 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  int64_t v66 = (char *)&v55 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  char v69 = (char *)&v55 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  int64_t v67 = (char *)&v55 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v55 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v55 - v29;
  uint64_t v32 = type metadata accessor for PartialRangeFrom(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v31);
  uint64_t v57 = *(void *)(v32 - 8);
  MEMORY[0x1895F8858](v32);
  Swift::String::Index v34 = (char *)&v55 - v33;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(a2 + 64);
  uint64_t v70 = a1;
  uint64_t v71 = v3;
  uint64_t v72 = a2;
  v35(a1, a2);
  uint64_t v36 = (void (*)(char *, char *, unint64_t))v17[2];
  v36(v28, v30, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v28,  v28,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range cannot have an unordered lower bound.",  43LL,  2,  "Swift/Range.swift",  17LL,  2,  0x34FuLL,  0);
  }
  uint64_t v56 = v32;
  uint64_t v37 = (void (*)(char *, unint64_t))v17[1];
  v37(v28, AssociatedTypeWitness);
  uint64_t v38 = (void (*)(char *, char *, unint64_t))v17[4];
  v38(v34, v30, AssociatedTypeWitness);
  uint64_t v39 = v67;
  v36(v67, v34, AssociatedTypeWitness);
  unint64_t v40 = v69;
  (*(void (**)(uint64_t))(v72 + 72))(v70);
  unint64_t v41 = AssociatedConformanceWitness;
  unint64_t v42 = v66;
  v36(v66, v39, AssociatedTypeWitness);
  uint64_t v43 = v68;
  v36(v68, v40, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v41 + 24))( v42,  v43,  AssociatedTypeWitness,  v41) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v37(v68, AssociatedTypeWitness);
  v37(v66, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v57 + 8))(v34, v56);
  uint64_t v44 = TupleTypeMetadata2;
  char v45 = v59;
  uint64_t v46 = &v59[*((int *)TupleTypeMetadata2 + 12)];
  v38(v59, v67, AssociatedTypeWitness);
  v38(v46, v69, AssociatedTypeWitness);
  unint64_t v47 = v64;
  uint64_t v48 = &v64[*((int *)v44 + 12)];
  v36(v64, v45, AssociatedTypeWitness);
  v36(v48, v46, AssociatedTypeWitness);
  uint64_t v49 = v58;
  v38(v58, v47, AssociatedTypeWitness);
  v37(v48, AssociatedTypeWitness);
  uint64_t v50 = &v47[*((int *)v44 + 12)];
  v38(v47, v45, AssociatedTypeWitness);
  v38(v50, v46, AssociatedTypeWitness);
  uint64_t v51 = v63;
  v38(&v49[*(int *)(v63 + 36)], v50, AssociatedTypeWitness);
  v37(v47, AssociatedTypeWitness);
  uint64_t v52 = v62;
  unint64_t v53 = v60;
  (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v60, v49, v51);
  (*(void (**)(char *, uint64_t))(v72 + 88))(v53, v70);
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v53, v51);
}

uint64_t specialized MutableCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 8);
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(v5 + 72))(v8, a2, v5);
  uint64_t v6 = v8[0];
  if (v8[0] < a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v8[0] = a1;
  v8[1] = v6;
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(v5 + 88))(v8, a2, v5);
}

uint64_t MutableCollection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RangeExpression,  (uint64_t)&associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v18 - v15;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 24))(v5, a2, v9, a3, a5);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 88))(v16, a2, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, v13);
}

uint64_t key path getter for MutableCollection.subscript<A>(_:) : <A><A1>AAA1( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MutableCollection.subscript.getter( a2,  *(void *)(a3 + a2 - 32),  *(void *)(a3 + a2 - 24),  *(void *)(a3 + a2 - 16),  *(void *)(a3 + a2 - 8));
}

uint64_t key path setter for MutableCollection.subscript<A>(_:) : <A><A1>AAA1( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a4 + a3 - 32);
  uint64_t v7 = *(void *)(a4 + a3 - 24);
  uint64_t v8 = *(void *)(a4 + a3 - 16);
  uint64_t v9 = *(void *)(a4 + a3 - 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  (*(void (**)(char *, uint64_t))(v13 + 16))((char *)&v15 - v11, a1);
  return specialized MutableCollection.subscript.setter((uint64_t)v12, a3, v6, v7, v8, v9);
}

uint64_t MutableCollection.subscript.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a4 - 8) + 8LL))(a2, a4);
}

void (*MutableCollection.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6))(uint64_t a1, char a2)
{
  uint64_t v12 = malloc(0x78uLL);
  *a1 = v12;
  void v12[2] = a5;
  v12[3] = a6;
  *uint64_t v12 = a3;
  v12[1] = a4;
  uint64_t v13 = *(void *)(a5 + 8);
  v12[4] = v6;
  v12[5] = v13;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v13,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a6,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RangeExpression,  (uint64_t)&associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v27 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v17 = *(void *)(v27 - 8);
  uint64_t v18 = malloc(*(void *)(v17 + 64));
  v12[6] = v18;
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v13,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  v12[7] = v19;
  uint64_t v20 = *(void *)(v19 - 8);
  v12[8] = v20;
  size_t v21 = *(void *)(v20 + 64);
  v12[9] = malloc(v21);
  uint64_t v22 = malloc(v21);
  uint64_t v23 = *(void *)(a4 - 8);
  v12[10] = v22;
  v12[11] = v23;
  size_t v24 = *(void *)(v23 + 64);
  v12[12] = malloc(v24);
  v12[13] = malloc(v24);
  (*(void (**)(void))(v23 + 16))();
  uint64_t v25 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 24);
  v12[14] = v25;
  v25(v28, a3, v13, a4, a6);
  (*(void (**)(void *, uint64_t, uint64_t))(v13 + 88))(v18, a3, v13);
  (*(void (**)(void *, uint64_t))(v17 + 8))(v18, v27);
  return MutableCollection.subscript.modify;
}

void MutableCollection.subscript.modify(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 88LL);
  uint64_t v22 = *(void **)(*(void *)a1 + 96LL);
  uint64_t v23 = *(void **)(*(void *)a1 + 104LL);
  uint64_t v5 = *(void **)(*(void *)a1 + 72LL);
  uint64_t v4 = *(void **)(*(void *)a1 + 80LL);
  if ((a2 & 1) != 0)
  {
    uint64_t v20 = v2[7];
    uint64_t v21 = v2[8];
    uint64_t v6 = (void *)v2[6];
    uint64_t v7 = v2[4];
    uint64_t v17 = v2[5];
    uint64_t v8 = v2[1];
    uint64_t v18 = v2[3];
    uint64_t v19 = v2[2];
    uint64_t v9 = *v2;
    uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 112LL);
    (*(void (**)(void *, void *))(v21 + 16))(v5, v4);
    uint64_t v11 = *(void (**)(void *, void *, uint64_t))(v3 + 32);
    uint64_t v12 = v3;
    uint64_t v13 = v22;
    v11(v22, v23, v8);
    v10(v7, v9, v17, v8, v18);
    (*(void (**)(void *, uint64_t))(v12 + 8))(v22, v8);
    (*(void (**)(void *, void *, uint64_t))(v19 + 40))(v5, v6, v9);
    (*(void (**)(void *, uint64_t))(v21 + 8))(v4, v20);
  }

  else
  {
    uint64_t v6 = (void *)v2[6];
    uint64_t v15 = v2[1];
    uint64_t v14 = v2[2];
    uint64_t v16 = *v2;
    (*(void (**)(void, void, void, uint64_t, void))(*(void *)a1 + 112LL))( v2[4],  *v2,  v2[5],  v15,  v2[3]);
    (*(void (**)(void *, uint64_t))(v3 + 8))(v23, v15);
    (*(void (**)(void *, void *, uint64_t, uint64_t))(v14 + 40))(v4, v6, v16, v14);
    uint64_t v13 = v22;
  }

  free(v23);
  free(v13);
  free(v4);
  free(v5);
  free(v6);
  free(v2);
}

uint64_t MutableCollection.subscript.getter@<X0>(uint64_t a1@<X2>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v63 = a3;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v62 = (char *)&v54 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v57 = (char *)&v54 - v9;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v60 = *(void *)(v12 - 8);
  uint64_t v61 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v56 = (char *)&v54 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  unint64_t v58 = (char *)&v54 - v16;
  uint64_t v17 = *(void **)(AssociatedTypeWitness - 8);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  int64_t v66 = (char *)&v54 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v54 - v21;
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v64 = (char *)&v54 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v65 = (char *)&v54 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v29 = (char *)&v54 - v28;
  MEMORY[0x1895F8858](v27);
  uint64_t v31 = (char *)&v54 - v30;
  uint64_t v33 = type metadata accessor for PartialRangeFrom(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v32);
  uint64_t v54 = *(void *)(v33 - 8);
  uint64_t v55 = v33;
  MEMORY[0x1895F8858](v33);
  uint64_t v35 = (char *)&v54 - v34;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v68 = a1;
  uint64_t v69 = v3;
  uint64_t v67 = v5;
  v36(a1, v5);
  uint64_t v37 = (void (*)(char *, char *, unint64_t))v17[2];
  v37(v29, v31, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v29,  v29,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range cannot have an unordered lower bound.",  43LL,  2,  "Swift/Range.swift",  17LL,  2,  0x34FuLL,  0);
  }
  uint64_t v38 = (void (*)(char *, unint64_t))v17[1];
  v38(v29, AssociatedTypeWitness);
  uint64_t v39 = (void (*)(char *, char *, unint64_t))v17[4];
  v39(v35, v31, AssociatedTypeWitness);
  unint64_t v40 = v65;
  v37(v65, v35, AssociatedTypeWitness);
  unint64_t v41 = v64;
  (*(void (**)(uint64_t))(v67 + 72))(v68);
  v37(v22, v40, AssociatedTypeWitness);
  unint64_t v42 = v66;
  v37(v66, v41, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v22,  v42,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v38(v66, AssociatedTypeWitness);
  v38(v22, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v54 + 8))(v35, v55);
  uint64_t v43 = TupleTypeMetadata2;
  uint64_t v44 = v57;
  char v45 = &v57[*((int *)TupleTypeMetadata2 + 12)];
  v39(v57, v65, AssociatedTypeWitness);
  v39(v45, v41, AssociatedTypeWitness);
  uint64_t v46 = v62;
  unint64_t v47 = &v62[*((int *)v43 + 12)];
  v37(v62, v44, AssociatedTypeWitness);
  v37(v47, v45, AssociatedTypeWitness);
  uint64_t v48 = v56;
  v39(v56, v46, AssociatedTypeWitness);
  v38(v47, AssociatedTypeWitness);
  uint64_t v49 = &v46[*((int *)v43 + 12)];
  v39(v46, v44, AssociatedTypeWitness);
  v39(v49, v45, AssociatedTypeWitness);
  uint64_t v50 = v61;
  v39(&v48[*(int *)(v61 + 36)], v49, AssociatedTypeWitness);
  v38(v46, AssociatedTypeWitness);
  uint64_t v51 = v60;
  uint64_t v52 = v58;
  (*(void (**)(char *, char *, uint64_t))(v60 + 32))(v58, v48, v50);
  (*(void (**)(char *, uint64_t))(v67 + 88))(v52, v68);
  return (*(uint64_t (**)(char *, uint64_t))(v51 + 8))(v52, v50);
}

uint64_t MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return specialized MutableCollection.subscript.setter(a1, a4, a5);
}

void (*MutableCollection.subscript.modify( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t **a1, char a2)
{
  uint64_t v9 = malloc(0x38uLL);
  *a1 = v9;
  v9[1] = a5;
  void v9[2] = v5;
  *uint64_t v9 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a5 + 8),  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  uint64_t v9[3] = AssociatedTypeWitness;
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  v9[4] = v11;
  size_t v12 = *(void *)(v11 + 64);
  v9[5] = malloc(v12);
  uint64_t v13 = malloc(v12);
  v9[6] = v13;
  MutableCollection.subscript.getter(a4, a5, (uint64_t)v13);
  return MutableCollection.subscript.modify;
}

void MutableCollection.subscript.modify(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)(*a1)[5];
  uint64_t v4 = (void *)(*a1)[6];
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = v2[3];
    uint64_t v6 = v2[4];
    uint64_t v7 = v2[1];
    uint64_t v8 = *v2;
    (*(void (**)(uint64_t, void *, uint64_t))(v6 + 16))((*a1)[5], v4, v5);
    specialized MutableCollection.subscript.setter((uint64_t)v3, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v4, v5);
  }

  else
  {
    specialized MutableCollection.subscript.setter((*a1)[6], *v2, v2[1]);
  }

  free(v4);
  free(v3);
  free(v2);
}

uint64_t Range.overlaps(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v37 = (char *)&v32 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v34 = (char *)&v32 - v10;
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v32 - v12;
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v32 - v15;
  uint64_t v18 = *(void *)(v17 + 16);
  uint64_t v19 = *(void *)(v17 + 24);
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 24);
  char v21 = v20(v14 + *(int *)(v17 + 36), v3, v18, v19);
  uint64_t v33 = v6;
  uint64_t v22 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 16);
  uint64_t v35 = v3;
  v22(v16, v3, a2);
  uint64_t v36 = a1;
  v22(v13, a1, a2);
  if ((v21 & 1) != 0) {
    char v23 = 1;
  }
  else {
    char v23 = v20((uint64_t)&v16[*(int *)(a2 + 36)], (uint64_t)v13, v18, v19);
  }
  uint64_t v24 = *(void (**)(char *, uint64_t))(v33 + 8);
  v24(v13, a2);
  v24(v16, a2);
  uint64_t v25 = v34;
  v22(v34, v35, a2);
  if ((v23 & 1) != 0)
  {
    v24(v25, a2);
    uint64_t v26 = v37;
    v22(v37, v36, a2);
    char v27 = 0;
  }

  else
  {
    uint64_t v28 = *(void *)(v19 + 8);
    uint64_t v29 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v28 + 8);
    char v30 = v29(v25, &v25[*(int *)(a2 + 36)], v18, v28);
    v24(v25, a2);
    uint64_t v26 = v37;
    v22(v37, v36, a2);
    if ((v30 & 1) != 0) {
      char v27 = 0;
    }
    else {
      char v27 = v29(v26, &v26[*(int *)(a2 + 36)], v18, v28) ^ 1;
    }
  }

  v24(v26, a2);
  return v27 & 1;
}

unint64_t String.Index._encodedOffset.getter(unint64_t a1)
{
  return a1 >> 16;
}

Swift::Void __swiftcall RangeReplaceableCollection.reserveCapacity(_:)(Swift::Int a1)
{
}

{
  EnumeratedSequence._base.modify();
}

uint64_t RangeReplaceableCollection.init(repeating:count:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v26 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a4[1] + 8LL),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v12 = type metadata accessor for Repeated(0LL, AssociatedTypeWitness, v10, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v25 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = (char *)&v25 - v17;
  uint64_t v19 = (void (*)(uint64_t, void *))a4[3];
  uint64_t v25 = a5;
  v19(a3, a4);
  if (!a2) {
    return (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 8LL))( v26,  AssociatedTypeWitness);
  }
  uint64_t v20 = v26;
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Repetition count should be non-negative",  39LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x28uLL,  0);
  }
  *(void *)uint64_t v16 = a2;
  (*(void (**)(char *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( &v16[*(int *)(v12 + 28)],  v20,  AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v13 + 32))(v18, v16, v12);
  char v21 = (uint64_t (*)(char *, uint64_t, uint64_t, uint64_t, void *))a4[9];
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, v12, v22);
  return v21(v18, v12, WitnessTable, a3, a4);
}

uint64_t RangeReplaceableCollection.append(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v12 - v9;
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(a2, v6);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a3 + 80))(a1, v10, a2, a3);
  return (*(uint64_t (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
}

uint64_t RangeReplaceableCollection.append<A>(contentsOf:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return RangeReplaceableCollection.append<A>(contentsOf:)(a1, a4, a2, a5, a3);
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  char *v21;
  unint64_t v22;
  unsigned int (*v23)(char *, uint64_t, unint64_t);
  void (*v24)(char *, char *, unint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v27 = a4;
  uint64_t v28 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a4 + 8) + 8LL),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v26 - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  MEMORY[0x1895F8858](v13);
  uint64_t v15 = (char *)&v26 - v14;
  uint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v26 = *(void *)(v16 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v18 = (char *)&v26 - v17;
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  v16,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  char v21 = v18;
  uint64_t v22 = v16;
  v20(v16, AssociatedConformanceWitness);
  char v23 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48);
  if (v23(v15, 1LL, AssociatedTypeWitness) != 1)
  {
    uint64_t v24 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
    do
    {
      v24(v10, v15, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t))(v27 + 64))(v10, v28);
      v20(v22, AssociatedConformanceWitness);
    }

    while (v23(v15, 1LL, AssociatedTypeWitness) != 1);
  }

  return (*(uint64_t (**)(char *, unint64_t))(v26 + 8))(v21, v22);
}

uint64_t specialized RangeReplaceableCollection.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v11)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v13;
  uint64_t v14;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v13 - v8;
  (*(void (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v11(&v14, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v14 & 0x100) == 0)
  {
    do
    {
      if (HIBYTE(*v3)) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
      }
      *v3 |= (v14 + 1) << (-(__clz(*v3) & 0x18) & 0x18);
      v11(&v14, AssociatedTypeWitness, AssociatedConformanceWitness);
    }

    while (BYTE1(v14) != 1);
  }

  return (*(uint64_t (**)(char *, unint64_t))(v7 + 8))(v9, AssociatedTypeWitness);
}

{
  uint64_t v3;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t *__return_ptr, unint64_t, unint64_t);
  Swift::String::Index v12;
  Swift::String::Index v13;
  uint64_t v15;
  uint64_t v16;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v15 - v8;
  (*(void (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v16 & 0x100000000LL) == 0)
  {
    do
    {
      v12._Swift::UInt64 rawBits = *(void *)(v3 + 8);
      v13._Swift::UInt64 rawBits = v12._rawBits;
      specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v12, v13);
      v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
    }

    while (BYTE4(v16) != 1);
  }

  return (*(uint64_t (**)(char *, unint64_t))(v7 + 8))(v9, AssociatedTypeWitness);
}

uint64_t specialized RangeReplaceableCollection.insert(_:at:)(uint64_t result, unsigned int a2)
{
  unsigned int v3 = *v2;
  if (a2)
  {
    if (!v3) {
LABEL_6:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC1uLL,  0);
    unsigned int v4 = *v2;
    while (v4 != a2)
    {
      BOOL v5 = v4 >= 0x100;
      v4 >>= 8;
      if (!v5) {
        goto LABEL_6;
      }
    }

    while (v3 != a2)
    {
      BOOL v5 = v3 >= 0x100;
      v3 >>= 8;
      if (!v5) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC2uLL,  0);
      }
    }

    unsigned int v3 = *v2;
    if (*v2 < a2) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  if (v3 == a2)
  {
    unsigned int v6 = 0;
  }

  else
  {
    unsigned int v6 = 0;
    unsigned int v9 = v3;
    do
    {
      if (v3 < v9 || v9 <= a2) {
        goto LABEL_27;
      }
      if (HIBYTE(v6)) {
        goto LABEL_26;
      }
      v6 |= v9 << (-(__clz(v6) & 0x18) & 0x18);
      v9 >>= 8;
    }

    while (v9 != a2);
    if (HIBYTE(v6)) {
LABEL_26:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
  }

  if (v3 < a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  unsigned int v7 = ((result + 1) << (-(__clz(v6) & 0x18) & 0x18)) | v6;
  if (a2)
  {
    unsigned int v8 = a2;
    while (v8 <= a2)
    {
      if (HIBYTE(v7)) {
        goto LABEL_26;
      }
      v7 |= v8 << (-(__clz(v7) & 0x18) & 0x18);
      BOOL v5 = v8 >= 0x100;
      v8 >>= 8;
      if (!v5) {
        goto LABEL_19;
      }
    }

uint64_t RangeReplaceableCollection.insert(_:at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v61 = a4;
  uint64_t v62 = a2;
  uint64_t v59 = a1;
  uint64_t v5 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v5 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v58 = type metadata accessor for CollectionOfOne(0LL, AssociatedTypeWitness, v6, v7);
  MEMORY[0x1895F8858](v58);
  uint64_t v56 = (char *)&v50 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v9, v9, "lower upper ", 0LL);
  uint64_t v10 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v12 = (char *)&v50 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v50 - v14;
  uint64_t v16 = *(void *)(v9 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v13);
  uint64_t v19 = (char *)&v50 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  char v21 = (char *)&v50 - v20;
  uint64_t v60 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a3,  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v24 = type metadata accessor for Range(0LL, v9, AssociatedConformanceWitness, v23);
  uint64_t v54 = *(void *)(v24 - 8);
  uint64_t v55 = v24;
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  char v27 = (char *)&v50 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v29 = (char *)&v50 - v28;
  uint64_t v52 = v16;
  char v30 = *(void (**)(char *, uint64_t, unint64_t))(v16 + 16);
  uint64_t v31 = v62;
  v30(v21, v62, v9);
  v30(v19, v31, v9);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v21,  v19,  v9,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v32 = v52;
  uint64_t v33 = *(void (**)(char *, unint64_t))(v52 + 8);
  v33(v19, v9);
  v33(v21, v9);
  uint64_t v51 = v29;
  uint64_t v34 = TupleTypeMetadata2;
  uint64_t v35 = &v15[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v36 = v62;
  v30(v15, v62, v9);
  v30(v35, v36, v9);
  uint64_t v37 = &v12[*((int *)v34 + 12)];
  v30(v12, (uint64_t)v15, v9);
  v30(v37, (uint64_t)v35, v9);
  uint64_t v38 = *(void (**)(char *, char *, unint64_t))(v32 + 32);
  v38(v27, v12, v9);
  v33(v37, v9);
  uint64_t v39 = &v12[*((int *)v34 + 12)];
  v38(v12, v15, v9);
  v38(v39, v35, v9);
  uint64_t v40 = v55;
  v38(&v27[*(int *)(v55 + 36)], v39, v9);
  v33(v12, v9);
  uint64_t v41 = v54;
  unint64_t v42 = v51;
  (*(void (**)(char *, char *, uint64_t))(v54 + 32))(v51, v27, v40);
  uint64_t v43 = v56;
  (*(void (**)(char *, uint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))(v56, v59);
  uint64_t v44 = v61;
  char v45 = *(void (**)(char *, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v61 + 32);
  uint64_t v46 = v58;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v58, v47);
  v45(v42, v43, v46, WitnessTable, v60, v44);
  return (*(uint64_t (**)(char *, uint64_t))(v41 + 8))(v42, v40);
}

uint64_t specialized RangeReplaceableCollection.remove(at:)(Swift::UInt64 a1)
{
  uint64_t v3 = *v1;
  unint64_t v2 = v1[1];
  uint64_t v4 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000LL) == 0) {
    uint64_t v4 = *v1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove from an empty collection",  37LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x222uLL,  0);
  }
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1)._rawBits;
  if ((v2 & 0x1000000000000000LL) != 0)
  {
    uint64_t v9 = *(_OWORD *)&_StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v6._rawBits & 0xFFFFFFFFFFFF0000LL));
  }

  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((v2 & 0x2000000000000000LL) != 0)
    {
      uint64_t v23 = v3;
      uint64_t v24 = v2 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v9 = *((unsigned __int8 *)&v23 + v7);
      if (*((char *)&v23 + v7) < 0) {
        __asm { BR              X10 }
      }
    }

    else
    {
      if ((v3 & 0x1000000000000000LL) != 0) {
        uint64_t v8 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v2);
      }
      uint64_t v9 = v8[v7];
      if ((char)v8[v7] < 0) {
        __asm { BR              X10 }
      }
    }
  }

  uint64_t v11 = *v1;
  uint64_t v10 = v1[1];
  v12._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1)._rawBits;
  if ((v10 & 0x1000000000000000LL) != 0)
  {
    v18._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v12)._rawBits;
  }

  else
  {
    Swift::UInt64 v13 = v12._rawBits >> 16;
    if ((v10 & 0x2000000000000000LL) != 0)
    {
      uint64_t v23 = v11;
      uint64_t v24 = v10 & 0xFFFFFFFFFFFFFFLL;
      int v15 = *((unsigned __int8 *)&v23 + v13);
    }

    else
    {
      if ((v11 & 0x1000000000000000LL) != 0) {
        uint64_t v14 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v10);
      }
      int v15 = v14[v13];
    }

    int v16 = (char)v15;
    unsigned int v17 = __clz(v15 ^ 0xFF) - 24;
    if (v16 >= 0) {
      LOBYTE(v17) = 1;
    }
    v18._Swift::UInt64 rawBits = ((v13 + v17) << 16) | 5;
  }

  if (v18._rawBits >> 14 < a1 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v19._Swift::UInt64 rawBits = a1;
  Swift::UInt64 v20 = _StringGuts.validateScalarRange_5_7(_:)(v19, v18, *v1, v1[1]);
  specialized _StringGuts.replaceSubrange<A>(_:with:)(v20, v21);
  return v9;
}

{
  uint64_t v1;
  uint64_t v3;
  Swift::String::Index v4;
  Swift::String::Index v5;
  Swift::String::Index v6;
  if (!((*(void *)(v1 + 8) ^ *(void *)v1) >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove from an empty collection",  37LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x222uLL,  0);
  }
  uint64_t v3 = Substring.subscript.getter(a1, *(void *)v1, *(void *)(v1 + 8), *(void *)(v1 + 16), *(void *)(v1 + 24));
  v4._Swift::UInt64 rawBits = Substring.index(after:)((Swift::String::Index)a1)._rawBits;
  if (v4._rawBits >> 14 < a1 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v5._Swift::UInt64 rawBits = v4._rawBits;
  v6._Swift::UInt64 rawBits = a1;
  specialized Substring._replaceSubrange<A>(_:with:)(v6, v5);
  return v3;
}

uint64_t specialized RangeReplaceableCollection.remove(at:)(unsigned int a1)
{
  unsigned int v2 = *v1;
  if (!*v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove from an empty collection",  37LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x222uLL,  0);
  }
  if (!a1) {
    goto LABEL_29;
  }
  unsigned int v3 = a1 >> 8;
  for (unsigned int i = *v1; i != a1; i >>= 8)
  {
    BOOL v5 = i >= 0x100;
    if (!v5) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC1uLL,  0);
    }
  }

  if (a1 >= 0x100)
  {
    while (v2)
    {
      if (v2 == v3) {
        goto LABEL_8;
      }
      BOOL v5 = v2 >= 0x100;
      v2 >>= 8;
      if (!v5) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC2uLL,  0);
      }
    }

{
  unsigned int *v1;
  unint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v2 = *((unsigned __int8 *)v1 + 4);
  if (!*((_BYTE *)v1 + 4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove from an empty collection",  37LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x222uLL,  0);
  }
  if (a1 >= 0xF0u) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unsigned int v3 = *v1;
  uint64_t v4 = a1 + 16;
  BOOL v5 = (a1 + 16);
  if (v5 != v4) {
LABEL_9:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xD4uLL,  0);
  unsigned int v6 = -((int)((a1 + 16)
             - a1
             + ((((a1 + 16) - a1) & 0xF000u) >> 12)) >> 4);
  if ((uint64_t)(v6 + (v2 >> 4)) >= 3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xDDuLL,  0);
  }
  *uint64_t v1 = (v3 >> ((v4 >> 1) & 0x18) >> ((v4 >> 1) & 0x18) << ((16 * v6 + v4) & 0x10)) | v3 & ((1 << ((a1 >> 1) & 0x18) << ((a1 >> 1) & 0x18))
                                                                                          - 1);
  *((_BYTE *)v1 + 4) = v2 + 16 * v6;
  return v3 >> a1;
}

{
  unsigned int *v1;
  unint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v2 = *((unsigned __int8 *)v1 + 4);
  if (!*((_BYTE *)v1 + 4)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove from an empty collection",  37LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x222uLL,  0);
  }
  if (a1 >= 0xF8u) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unsigned int v3 = *v1;
  uint64_t v4 = a1 + 8;
  BOOL v5 = (a1 + 8);
  if (v5 != v4) {
LABEL_9:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xD4uLL,  0);
  unsigned int v6 = -((int)((a1 + 8)
             - a1
             + ((((a1 + 8) - a1) & 0xE000u) >> 13)) >> 3);
  if ((uint64_t)(v6 + (v2 >> 3)) >= 5) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xDDuLL,  0);
  }
  *uint64_t v1 = (v3 >> ((v4 >> 1) & 0x1C) >> ((v4 >> 1) & 0x1C) << ((8 * v6 + v4) & 0x18)) | v3 & ((1 << ((a1 >> 1) & 0x1C) << ((a1 >> 1) & 0x1C))
                                                                                         - 1);
  *((_BYTE *)v1 + 4) = v2 + 8 * v6;
  return v3 >> a1;
}

uint64_t specialized RangeReplaceableCollection.remove(at:)(Swift::String::Index a1)
{
  Swift::UInt64 v2 = *v1 >> 14;
  Swift::UInt64 v3 = v1[1] >> 14;
  if (v2 == v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove from an empty collection",  37LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x222uLL,  0);
  }
  v4._Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = v1[2];
  uint64_t v5 = v1[3];
  char v7 = (v5 & 0x1000000000000000LL) == 0 || (v6 & 0x800000000000000LL) != 0;
  uint64_t v8 = a1._rawBits & 0xC;
  uint64_t v9 = 4LL << v7;
  if ((a1._rawBits & 1) != 0 && v8 != v9)
  {
    if (a1._rawBits >> 14 >= v2 && a1._rawBits >> 14 < v3)
    {
LABEL_23:
      if ((v5 & 0x1000000000000000LL) == 0) {
        goto LABEL_24;
      }
LABEL_46:
      uint64_t v15 = *(_OWORD *)&_StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(a1._rawBits & 0xFFFFFFFFFFFF0000LL));
      goto LABEL_31;
    }

    unint64_t v11 = 143LL;
LABEL_21:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v11,  0);
  }

  if (v8 == v9) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if (a1._rawBits >> 14 < v2 || a1._rawBits >> 14 >= v3)
  {
    unint64_t v11 = 43LL;
    goto LABEL_21;
  }

  if ((a1._rawBits & 1) != 0) {
    goto LABEL_23;
  }
  a1._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(a1)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
  if ((v5 & 0x1000000000000000LL) != 0) {
    goto LABEL_46;
  }
LABEL_24:
  Swift::UInt64 v13 = a1._rawBits >> 16;
  if ((v5 & 0x2000000000000000LL) != 0)
  {
    uint64_t v27 = v6;
    uint64_t v28 = v5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v15 = *((unsigned __int8 *)&v27 + v13);
    if (*((char *)&v27 + v13) < 0) {
      __asm { BR              X10 }
    }
  }

  else
  {
    if ((v6 & 0x1000000000000000LL) != 0) {
      uint64_t v14 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else {
      uint64_t v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v6, v5);
    }
    uint64_t v15 = v14[v13];
    if ((char)v14[v13] < 0) {
      __asm { BR              X10 }
    }
  }

uint64_t RangeReplaceableCollection.remove(at:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v70 = a4;
  uint64_t v68 = a3;
  uint64_t v7 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v11 = (char *)&v62 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  int64_t v66 = (char *)&v62 - v13;
  uint64_t v69 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v62 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v72 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v71 = (char *)&v62 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v73 = (char *)&v62 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v74 = (char *)&v62 - v21;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v24 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v23);
  uint64_t v65 = *(void *)(v24 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v24);
  uint64_t v63 = (char *)&v62 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v25);
  uint64_t v64 = (char *)&v62 - v27;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 104);
  uint64_t v75 = a2;
  uint64_t v76 = v4;
  if ((v28(a2, v7) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove from an empty collection",  37LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x222uLL,  0);
  }
  uint64_t v62 = v24;
  uint64_t v30 = v75;
  uint64_t v29 = v76;
  uint64_t v31 = a1;
  uint64_t v32 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v7 + 80))( v77,  a1,  v75,  v7);
  uint64_t v34 = v33;
  unint64_t v35 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v30,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v36 = *(void (**)(uint64_t, uint64_t))(*(void *)(v35 - 8) + 16LL);
  uint64_t v37 = v70;
  uint64_t v70 = v35;
  v36(v37, v34);
  v32(v77, 0LL);
  uint64_t v38 = v31;
  uint64_t v39 = v69;
  (*(void (**)(char *, uint64_t, uint64_t))(v69 + 16))(v16, v29, v30);
  uint64_t v40 = v74;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 184))(v38, v30, v7);
  (*(void (**)(char *, uint64_t))(v39 + 8))(v16, v30);
  uint64_t v42 = v72;
  uint64_t v41 = v73;
  uint64_t v43 = *(void (**)(char *, uint64_t, unint64_t))(v72 + 16);
  v43(v73, v38, AssociatedTypeWitness);
  uint64_t v44 = v71;
  v43(v71, (uint64_t)v40, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v41,  v44,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  char v45 = *(void (**)(char *, unint64_t))(v42 + 8);
  v45(v44, AssociatedTypeWitness);
  v45(v73, AssociatedTypeWitness);
  uint64_t v47 = v66;
  uint64_t v46 = TupleTypeMetadata2;
  uint64_t v48 = &v66[*((int *)TupleTypeMetadata2 + 12)];
  v43(v66, v38, AssociatedTypeWitness);
  uint64_t v49 = *(void (**)(char *, char *, unint64_t))(v42 + 32);
  v49(v48, v74, AssociatedTypeWitness);
  uint64_t v50 = &v11[*((int *)v46 + 12)];
  v43(v11, (uint64_t)v47, AssociatedTypeWitness);
  v43(v50, (uint64_t)v48, AssociatedTypeWitness);
  uint64_t v51 = v63;
  v49(v63, v11, AssociatedTypeWitness);
  v45(v50, AssociatedTypeWitness);
  uint64_t v52 = &v11[*((int *)v46 + 12)];
  v49(v11, v47, AssociatedTypeWitness);
  v49(v52, v48, AssociatedTypeWitness);
  uint64_t v53 = v62;
  v49(&v51[*(int *)(v62 + 36)], v52, AssociatedTypeWitness);
  v45(v11, AssociatedTypeWitness);
  uint64_t v55 = v64;
  uint64_t v54 = v65;
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v64, v51, v53);
  uint64_t v56 = *(void (**)(char *))(v68 + 32);
  uint64_t v59 = type metadata accessor for EmptyCollection(0LL, v70, v57, v58);
  swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v59, v60);
  v56(v55);
  return (*(uint64_t (**)(char *, uint64_t))(v54 + 8))(v55, v53);
}

uint64_t RangeReplaceableCollection._customRemoveLast()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return RangeReplaceableCollection._customRemoveLast()(a1, a2, a3);
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a2 + 8) + 8LL),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8)
                                                                                + 56LL))( a3,  1LL,  1LL,  AssociatedTypeWitness);
}

void specialized RangeReplaceableCollection.removeAll(keepingCapacity:)(char a1)
{
  if ((a1 & 1) != 0)
  {
    unint64_t v2 = *v1;
    unint64_t v3 = v1[1];
    uint64_t v4 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000LL) == 0) {
      uint64_t v4 = *v1;
    }
    uint64_t v5 = 7LL;
    if (((v3 >> 60) & ((v2 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v5 = 11LL;
    }
    v6._Swift::UInt64 rawBits = v5 | (v4 << 16);
    v7._Swift::UInt64 rawBits = 15LL;
    Swift::UInt64 v8 = _StringGuts.validateScalarRange_5_7(_:)(v7, v6, v2, v3);
    specialized _StringGuts.replaceSubrange<A>(_:with:)(v8, v9);
  }

  else
  {
    swift_bridgeObjectRelease(v1[1]);
    *uint64_t v1 = 0LL;
    v1[1] = 0xE000000000000000LL;
  }

double specialized RangeReplaceableCollection.removeAll(keepingCapacity:)(char a1)
{
  if ((a1 & 1) != 0)
  {
    v3._Swift::UInt64 rawBits = v1[1];
    if (v3._rawBits >> 14 < *v1 >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    v2._Swift::UInt64 rawBits = *v1;
    specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v2, v3);
  }

  else
  {
    swift_bridgeObjectRelease(v1[3]);
    *(void *)&double result = 15LL;
    *(_OWORD *)uint64_t v1 = xmmword_1817FFCA0;
    v1[2] = 0LL;
    void v1[3] = 0xE000000000000000LL;
  }

  return result;
}

{
  Swift::UInt64 *v1;
  Swift::String::Index v2;
  Swift::String::Index v3;
  double result;
  if ((a1 & 1) != 0)
  {
    v3._Swift::UInt64 rawBits = v1[1];
    if (v3._rawBits >> 14 < *v1 >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    v2._Swift::UInt64 rawBits = *v1;
    specialized Substring._replaceSubrange<A>(_:with:)(v2, v3);
  }

  else
  {
    swift_bridgeObjectRelease(v1[3]);
    *(void *)&double result = 15LL;
    *(_OWORD *)uint64_t v1 = xmmword_1817FFCA0;
    v1[2] = 0LL;
    void v1[3] = 0xE000000000000000LL;
  }

  return result;
}

void specialized RangeReplaceableCollection.removeAll(keepingCapacity:)()
{
  _DWORD *v0 = 0;
}

Swift::Void __swiftcall RangeReplaceableCollection.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  Swift::String::Index v6 = *(const char **)(v2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v61 = (char *)&v54 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v59 = (char *)&v54 - v11;
  uint64_t v62 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v54 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v54 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v54 - v19;
  MEMORY[0x1895F8858](v18);
  int v22 = (char *)&v54 - v21;
  uint64_t v63 = v6;
  uint64_t v64 = v4;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v25 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v24);
  uint64_t v26 = MEMORY[0x1895F8858](v25);
  uint64_t v27 = MEMORY[0x1895F8858](v26);
  if (keepingCapacity)
  {
    uint64_t v55 = v30;
    uint64_t v56 = (char *)&v54 - v28;
    uint64_t v57 = v29;
    uint64_t v58 = v27;
    uint64_t v54 = v3;
    uint64_t v31 = v63;
    uint64_t v32 = v64;
    (*((void (**)(uint64_t, const char *))v63 + 8))(v64, v63);
    (*((void (**)(uint64_t, const char *))v31 + 9))(v32, v31);
    uint64_t v33 = *(void (**)(char *, char *, unint64_t))(v62 + 16);
    v33(v17, v22, AssociatedTypeWitness);
    v33(v14, v20, AssociatedTypeWitness);
    if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                        + 24))( v17,  v14,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0)
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    uint64_t v34 = v62;
    unint64_t v35 = *(void (**)(char *, unint64_t))(v62 + 8);
    v35(v14, AssociatedTypeWitness);
    v35(v17, AssociatedTypeWitness);
    uint64_t v36 = v59;
    uint64_t v37 = TupleTypeMetadata2;
    uint64_t v38 = &v59[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v39 = *(void (**)(char *, char *, unint64_t))(v34 + 32);
    v39(v59, v22, AssociatedTypeWitness);
    v39(v38, v20, AssociatedTypeWitness);
    uint64_t v40 = v61;
    uint64_t v41 = &v61[*((int *)v37 + 12)];
    v33(v61, v36, AssociatedTypeWitness);
    v33(v41, v38, AssociatedTypeWitness);
    uint64_t v42 = v55;
    v39(v55, v40, AssociatedTypeWitness);
    v35(v41, AssociatedTypeWitness);
    uint64_t v43 = &v40[*((int *)v37 + 12)];
    v39(v40, v36, AssociatedTypeWitness);
    v39(v43, v38, AssociatedTypeWitness);
    uint64_t v44 = v58;
    v39(&v42[*(int *)(v58 + 36)], v43, AssociatedTypeWitness);
    v35(v40, AssociatedTypeWitness);
    uint64_t v46 = v56;
    uint64_t v45 = v57;
    (*(void (**)(char *, char *, uint64_t))(v57 + 32))(v56, v42, v44);
    uint64_t v47 = *(void (**)(char *))(v54 + 32);
    unint64_t v48 = swift_getAssociatedTypeWitness( 255LL,  *((const char **)v63 + 1),  v64,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v51 = type metadata accessor for EmptyCollection(0LL, v48, v49, v50);
    swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v51, v52);
    v47(v46);
    (*(void (**)(char *, uint64_t))(v45 + 8))(v46, v44);
  }

  else
  {
    uint64_t v53 = v64;
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v64 - 8) + 8LL))(v65, v64);
    (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v53, v3);
  }

uint64_t RangeReplaceableCollection.removeAll(where:)( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeReplaceableCollection.removeAll(where:)(a1, a2, a3, a4);
}

{
  uint64_t v4;
  const char *v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t);
  const char *v27;
  unint64_t AssociatedConformanceWitness;
  void (*v29)(const char *, unint64_t);
  uint64_t v30;
  unsigned int (*v31)(char *, uint64_t, unint64_t);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v36)(char *, char *, unint64_t);
  char *v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(const char *, unint64_t);
  uint64_t (*v49)(char *);
  char *v50;
  const char *v51;
  uint64_t v45 = a4;
  uint64_t v39 = a2;
  uint64_t v49 = a1;
  uint64_t v51 = *(const char **)(*(void *)(a4 + 8) + 8LL);
  Swift::String::Index v6 = v51;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v51,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v47 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v43 = (char *)&v39 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v39 - v10;
  uint64_t v14 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v12, v13);
  MEMORY[0x1895F8858](v14);
  uint64_t v16 = (char *)&v39 - v15;
  uint64_t v17 = (const char *)swift_getAssociatedTypeWitness( 0LL,  v6,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v41 = *((void *)v17 - 1);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v39 - v19;
  uint64_t v21 = MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v39 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v21);
  uint64_t v40 = v24;
  (*(void (**)(char *, uint64_t, uint64_t))(v24 + 16))((char *)&v39 - v25, v42, a3);
  uint64_t v26 = *(void (**)(uint64_t))(v45 + 24);
  uint64_t v44 = v23;
  v26(a3);
  uint64_t v27 = v51;
  (*((void (**)(uint64_t))v51 + 4))(a3);
  uint64_t v46 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v27,  a3,  (uint64_t)v17,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v29 = *(void (**)(const char *, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v50 = v20;
  uint64_t v51 = v17;
  v29(v17, AssociatedConformanceWitness);
  uint64_t v30 = v47;
  uint64_t v31 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v47 + 48);
  if (v31(v16, 1LL, AssociatedTypeWitness) == 1)
  {
LABEL_2:
    uint64_t v32 = v40;
    uint64_t v33 = v42;
    uint64_t v34 = v46;
    (*(void (**)(uint64_t, uint64_t))(v40 + 8))(v42, v46);
    (*(void (**)(char *, const char *))(v41 + 8))(v50, v51);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v32 + 32))(v33, v44, v34);
  }

  else
  {
    unint64_t v48 = v29;
    uint64_t v36 = *(void (**)(char *, char *, unint64_t))(v30 + 32);
    v36(v11, v16, AssociatedTypeWitness);
    while (1)
    {
      uint64_t v38 = v49(v11);
      if (v4) {
        break;
      }
      if ((v38 & 1) != 0)
      {
        (*(void (**)(char *, unint64_t))(v47 + 8))(v11, AssociatedTypeWitness);
      }

      else
      {
        uint64_t v37 = v43;
        v36(v43, v11, AssociatedTypeWitness);
        (*(void (**)(char *, uint64_t))(v45 + 64))(v37, v46);
      }

      v48(v51, AssociatedConformanceWitness);
      if (v31(v16, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_2;
      }
      v36(v11, v16, AssociatedTypeWitness);
    }

    (*(void (**)(char *, unint64_t))(v47 + 8))(v11, AssociatedTypeWitness);
    (*(void (**)(char *, const char *))(v41 + 8))(v50, v51);
    return (*(uint64_t (**)(char *, uint64_t))(v40 + 8))(v44, v46);
  }

void specialized RangeReplaceableCollection.removeAll(where:)( uint64_t (*a1)(void *), uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v7 = v4[1];
  unint64_t v8 = 0xE000000000000000LL;
  uint64_t v9 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) == 0) {
    uint64_t v9 = *v4 & 0xFFFFFFFFFFFFLL;
  }
  v25[2] = *v4;
  v25[3] = v7;
  v25[4] = 0LL;
  uint64_t v25[5] = v9;
  unint64_t v26 = 0LL;
  unint64_t v28 = v7;
  swift_bridgeObjectRetain(v7, a2, a3, a4);
  Swift::String_optional v10 = String.Iterator.next()();
  if (v10.value._object)
  {
    uint64_t countAndFlagsBits = v10.value._countAndFlagsBits;
    unint64_t object = (unint64_t)v10.value._object;
    while (1)
    {
      v25[0] = countAndFlagsBits;
      v25[1] = object;
      char v15 = a1(v25);
      if (v5)
      {
        swift_bridgeObjectRelease(v28);
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease(v27);
        return;
      }

      if ((v15 & 1) == 0)
      {
        uint64_t v16 = v27;
        unint64_t v17 = HIBYTE(v27) & 0xF;
        if ((v27 & 0x2000000000000000LL) == 0) {
          unint64_t v17 = v26 & 0xFFFFFFFFFFFFLL;
        }
        if (!v17 && (v26 & ~v27 & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(v27);
          unint64_t v26 = countAndFlagsBits;
          unint64_t v27 = object;
          goto LABEL_10;
        }

        if ((object & 0x2000000000000000LL & v27) != 0)
        {
          unint64_t v18 = specialized _SmallString.init(_:appending:)(v26, v27, countAndFlagsBits, object);
          if ((v20 & 1) == 0)
          {
            unint64_t v21 = v18;
            unint64_t v22 = v19;
            swift_bridgeObjectRelease(object);
            swift_bridgeObjectRelease(v16);
            unint64_t v26 = v21;
            unint64_t v27 = v22;
            goto LABEL_10;
          }
        }

        if ((object & 0x2000000000000000LL) != 0) {
          uint64_t v13 = HIBYTE(object) & 0xF;
        }
        else {
          uint64_t v13 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        }
        _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v13);
      }

      swift_bridgeObjectRelease(object);
LABEL_10:
      Swift::String_optional v14 = String.Iterator.next()();
      uint64_t countAndFlagsBits = v14.value._countAndFlagsBits;
      unint64_t object = (unint64_t)v14.value._object;
      if (!v14.value._object)
      {
        unint64_t v23 = v26;
        unint64_t v8 = v27;
        goto LABEL_23;
      }
    }
  }

  unint64_t v23 = 0LL;
LABEL_23:
  swift_bridgeObjectRelease_n(v28, 2LL);
  *uint64_t v24 = v23;
  v24[1] = v8;
}

{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  void *v13;
  unsigned int value;
  Swift::Int scalarLength;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v16;
  unsigned int v17;
  Swift::Int v18;
  char v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  void v33[2];
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v36 = a2;
  unint64_t v7 = *v4;
  Swift::String::Index v6 = v4[1];
  unint64_t v8 = 0xE000000000000000LL;
  uint64_t v34 = 0LL;
  unint64_t v35 = 0xE000000000000000LL;
  if ((v6 & 0x2000000000000000LL) != 0) {
    uint64_t v9 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v9 = v7 & 0xFFFFFFFFFFFFLL;
  }
  if (!v9)
  {
    uint64_t v30 = 0LL;
    goto LABEL_27;
  }

  swift_bridgeObjectRetain(v6, a2, a3, a4);
  for (unsigned int i = 0LL; i < v9; i += v18)
  {
    if ((v6 & 0x1000000000000000LL) != 0)
    {
      uint64_t v16 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(i << 16));
      Swift::Int scalarLength = v16.scalarLength;
      Swift::UInt32 value = v16._0._value;
    }

    else
    {
      if ((v6 & 0x2000000000000000LL) != 0)
      {
        v33[0] = v7;
        v33[1] = v6 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v13 = v33;
      }

      else
      {
        uint64_t v13 = (void *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v7 & 0x1000000000000000LL) == 0) {
          uint64_t v13 = _StringObject.sharedUTF8.getter(v7, v6);
        }
      }

      Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)v13, v10, i);
    }

    unint64_t v17 = value;
    unint64_t v18 = scalarLength;
    LODWORD(v33[0]) = value;
    unint64_t v19 = a1(v33);
    if (v5)
    {
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(v35);
      return;
    }

    if ((v19 & 1) == 0)
    {
      unint64_t v21 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v17);
      unint64_t v22 = v20;
      unint64_t v23 = v35;
      if ((v35 & 0x2000000000000000LL) == 0)
      {
        if ((v20 & 0x2000000000000000LL) != 0) {
LABEL_24:
        }
          uint64_t v12 = HIBYTE(v22) & 0xF;
        else {
LABEL_6:
        }
          uint64_t v12 = v21 & 0xFFFFFFFFFFFFLL;
        _StringGuts.append(_:)(v21, v22, 0LL, v12);
        swift_bridgeObjectRelease(v22);
        continue;
      }

      if ((v20 & 0x2000000000000000LL) == 0) {
        goto LABEL_6;
      }
      uint64_t v24 = specialized _SmallString.init(_:appending:)(v34, v35, v21, v20);
      if ((v26 & 1) != 0) {
        goto LABEL_24;
      }
      unint64_t v27 = v24;
      unint64_t v28 = v22;
      uint64_t v29 = v25;
      swift_bridgeObjectRelease(v28);
      swift_bridgeObjectRelease(v23);
      uint64_t v34 = v27;
      unint64_t v35 = v29;
    }
  }

  swift_bridgeObjectRelease(v6);
  uint64_t v4 = (uint64_t *)v31;
  Swift::String::Index v6 = *(void *)(v31 + 8);
  uint64_t v30 = v34;
  unint64_t v8 = v35;
LABEL_27:
  swift_bridgeObjectRelease(v6);
  *uint64_t v4 = v30;
  v4[1] = v8;
}

void specialized RangeReplaceableCollection.removeAll(where:)( uint64_t (*a1)(uint64_t *), uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v8 = *v4;
  unint64_t v9 = v4[1];
  uint64_t v11 = v4[2];
  unint64_t v10 = v4[3];
  *(_OWORD *)&v41[0]._Swift::UInt64 rawBits = xmmword_1817FFCA0;
  unint64_t v12 = 0xE000000000000000LL;
  Swift::UInt64 v42 = 0LL;
  unint64_t v43 = 0xE000000000000000LL;
  swift_bridgeObjectRetain(v10, a2, a3, a4);
  if ((v8 ^ v9) >= 0x4000)
  {
    uint64_t v38 = a1;
    uint64_t v44 = a2;
    v18._Swift::UInt64 rawBits = v8;
    do
    {
      v19._Swift::UInt64 rawBits = v18._rawBits;
      v20._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:in:)(v19, v8, v9, v11, v10)._rawBits;
      if ((v10 & 0x1000000000000000LL) != 0)
      {
        int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v20._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
        v35._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v18)._rawBits;
        v18._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v35)._rawBits;
      }

      else
      {
        Swift::UInt64 v22 = v20._rawBits >> 16;
        if ((v10 & 0x2000000000000000LL) != 0)
        {
          uint64_t v39 = v11;
          uint64_t v40 = v10 & 0xFFFFFFFFFFFFFFLL;
          int value = _decodeScalar(_:startingAt:)((uint64_t)&v39, v21._rawBits, v22);
          Swift::UInt64 v27 = _StringGuts.validateScalarIndex(_:)(v18)._rawBits >> 16;
          uint64_t v39 = v11;
          uint64_t v40 = v10 & 0xFFFFFFFFFFFFFFLL;
          int v28 = *((unsigned __int8 *)&v39 + v27);
        }

        else
        {
          id v23 = (id)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v11 & 0x1000000000000000LL) == 0) {
            id v23 = _StringObject.sharedUTF8.getter(v11, v10);
          }
          int v24 = _decodeScalar(_:startingAt:)((uint64_t)v23, v21._rawBits, v22);
          v25._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v18)._rawBits;
          unint64_t v26 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((v11 & 0x1000000000000000LL) == 0) {
            unint64_t v26 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v10);
          }
          Swift::UInt64 v27 = v25._rawBits >> 16;
          int v28 = v26[v25._rawBits >> 16];
          int value = v24;
        }

        int v30 = (char)v28;
        unsigned int v31 = __clz(v28 ^ 0xFF) - 24;
        if (v30 >= 0) {
          LOBYTE(v3_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 1;
        }
        v18._Swift::UInt64 rawBits = ((v27 + v31) << 16) | 5;
      }

      LODWORD(v39) = value;
      char v32 = v38(&v39);
      if (v5)
      {
        uint64_t v36 = v43;
        swift_bridgeObjectRelease(v10);
        swift_bridgeObjectRelease(v36);
        return;
      }

      if ((v32 & 1) == 0)
      {
        v33._Swift::UInt64 rawBits = v41[1]._rawBits;
        v34._Swift::UInt64 rawBits = v41[1]._rawBits;
        specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v33, v34);
      }
    }

    while ((v18._rawBits ^ v9) >= 0x4000);
    unint64_t v17 = v37;
    uint64_t v16 = v37[3];
    Swift::UInt64 rawBits = v41[0]._rawBits;
    Swift::UInt64 v15 = v41[1]._rawBits;
    Swift::UInt64 v13 = v42;
    unint64_t v12 = v43;
  }

  else
  {
    Swift::UInt64 v13 = 0LL;
    Swift::UInt64 rawBits = 15LL;
    Swift::UInt64 v15 = 7LL;
    uint64_t v16 = v10;
    unint64_t v17 = v37;
  }

  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease(v16);
  *unint64_t v17 = rawBits;
  v17[1] = v15;
  void v17[2] = v13;
  v17[3] = v12;
}

void specialized RangeReplaceableCollection.removeAll(where:)( uint64_t (*a1)(void *), uint64_t a2)
{
  uint64_t v24 = a2;
  unint64_t v4 = *v2;
  unint64_t v5 = v2[1];
  uint64_t v7 = v2[2];
  unint64_t v6 = v2[3];
  *(_OWORD *)&v21[0]._Swift::UInt64 rawBits = xmmword_1817FFCA0;
  unint64_t v8 = 0xE000000000000000LL;
  unint64_t v22 = 0LL;
  uint64_t v23 = 0xE000000000000000LL;
  if ((v4 ^ v5) >= 0x4000)
  {
    v12._Swift::UInt64 rawBits = v4;
    while (1)
    {
      unint64_t v13 = Substring.subscript.getter(v12._rawBits, v4, v5, v7, v6);
      Swift::UInt64 v15 = v14;
      v12._Swift::UInt64 rawBits = Substring.index(after:)(v12)._rawBits;
      v20[0] = v13;
      v20[1] = v15;
      char v16 = a1(v20);
      if (v3) {
        break;
      }
      if ((v16 & 1) == 0)
      {
        v17._Swift::UInt64 rawBits = v21[1]._rawBits;
        v18._Swift::UInt64 rawBits = v21[1]._rawBits;
        specialized Substring._replaceSubrange<A>(_:with:)(v17, v18, v13, v15);
      }

      swift_bridgeObjectRelease(v15);
      if ((v12._rawBits ^ v5) < 0x4000)
      {
        Swift::UInt64 rawBits = v21[0]._rawBits;
        Swift::UInt64 v11 = v21[1]._rawBits;
        unint64_t v9 = v22;
        unint64_t v8 = v23;
        goto LABEL_9;
      }
    }

    swift_bridgeObjectRelease(v15);
    swift_bridgeObjectRelease(v23);
  }

  else
  {
    unint64_t v9 = 0LL;
    Swift::UInt64 rawBits = 15LL;
    Swift::UInt64 v11 = 7LL;
LABEL_9:
    swift_bridgeObjectRelease(v6);
    *uint64_t v2 = rawBits;
    v2[1] = v11;
    v2[2] = v9;
    v2[3] = v8;
  }

uint64_t specialized RangeReplaceableCollection.removeAll(where:)(uint64_t result)
{
  unsigned int v3 = *v1;
  if (*v1)
  {
    unint64_t v4 = (uint64_t (*)(char *))result;
    unsigned int v5 = 0;
    while (1)
    {
      char v7 = v3 - 1;
      double result = v4(&v7);
      if (v2) {
        break;
      }
      if ((result & 1) == 0)
      {
        if (HIBYTE(v5)) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
        }
        v5 |= v3 << (-(__clz(v5) & 0x18) & 0x18);
      }

      BOOL v6 = v3 >= 0x100;
      v3 >>= 8;
      if (!v6) {
        goto LABEL_10;
      }
    }
  }

  else
  {
    unsigned int v5 = 0;
LABEL_10:
    *uint64_t v1 = v5;
  }

  return result;
}

uint64_t Repeated.init(_repeating:count:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Repetition count should be non-negative",  39LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x28uLL,  0);
  }
  *a5 = a2;
  char v7 = (char *)a5 + *(int *)(type metadata accessor for Repeated(0LL, a3, a3, a4) + 28);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a3 - 8) + 32LL))(v7, a1, a3);
}

uint64_t RangeReplaceableCollection.replaceSubrange<A, B>(_:with:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a4;
  uint64_t v25 = a7;
  uint64_t v23 = a2;
  unint64_t v13 = *(const char **)(a6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v13,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a8,  a5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RangeExpression,  (uint64_t)&associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v17 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v16);
  uint64_t v18 = *(void *)(v17 - 8);
  MEMORY[0x1895F8858](v17);
  Swift::String::Index v20 = (char *)&v22 - v19;
  (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(a8 + 24))(v8, a3, v13, a5, a8);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 32))(v20, v23, v24, v25, a3, a6);
  return (*(uint64_t (**)(char *, uint64_t))(v18 + 8))(v20, v17);
}

uint64_t RangeReplaceableCollection.removeSubrange<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v10,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for RangeExpression,  (uint64_t)&associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  uint64_t v14 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v15 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v17 = (char *)&v19 - v16;
  (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(a5 + 24))(v5, a2, v10, a3, a5);
  (*(void (**)(char *, uint64_t, uint64_t))(a4 + 104))(v17, a2, a4);
  return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v17, v14);
}

uint64_t specialized RangeReplaceableCollection<>._customRemoveLast()()
{
  unint64_t rawBits = v0->_rawBits;
  unint64_t v2 = v0[1]._rawBits;
  Swift::UInt64 v3 = v0->_rawBits >> 14;
  if (v3 == v2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x331uLL,  0);
  }
  unint64_t v5 = v0[2]._rawBits;
  unint64_t v4 = v0[3]._rawBits;
  v6._unint64_t rawBits = Substring.index(before:)(v0[1])._rawBits;
  uint64_t v7 = Substring.subscript.getter(v6._rawBits, rawBits, v2, v5, v4);
  uint64_t v9 = v8;
  v10._unint64_t rawBits = Substring.index(before:)((Swift::String::Index)v2)._rawBits;
  if (v3 > v10._rawBits >> 14)
  {
    swift_bridgeObjectRelease(v9);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  v11._unint64_t rawBits = v10._rawBits;
  v12._unint64_t rawBits = rawBits;
  Swift::UInt64 v13 = specialized Substring.subscript.getter(v12, v11, rawBits, v2, v5, v4);
  Swift::UInt64 v15 = v14;
  Swift::UInt64 v17 = v16;
  uint64_t v19 = v18;
  swift_bridgeObjectRetain((unint64_t)v18, v14, v16, v18);
  swift_bridgeObjectRelease(v4);
  v0->_unint64_t rawBits = v13;
  v0[1]._unint64_t rawBits = v15;
  v0[2]._unint64_t rawBits = v17;
  v0[3]._unint64_t rawBits = (Swift::UInt64)v19;
  return v7;
}

{
  unint64_t *v0;
  Swift::UInt64 v1;
  Swift::UInt64 v2;
  unint64_t v3;
  unint64_t v4;
  Swift::String::Index v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  Swift::String::Index v11;
  Swift::UInt64 rawBits;
  char *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  int v23;
  Swift::UInt64 v24;
  Swift::String::Index v25;
  Swift::String::Index v26;
  Swift::UInt64 v27;
  unint64_t v28;
  unint64_t v29;
  void v31[2];
  unint64_t v2 = *v0;
  uint64_t v1 = v0[1];
  Swift::UInt64 v3 = v0[2];
  unint64_t v4 = v0[3];
  v5._unint64_t rawBits = v1;
  Swift::String::Index v6 = specialized BidirectionalCollection.last.getter(*v0, v5, v3, v4);
  if ((v6 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x331uLL,  0);
  }
  Swift::String::Index v10 = v6;
  swift_bridgeObjectRetain(v4, v7, v8, v9);
  v11._unint64_t rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)v1)._rawBits;
  if (!(v11._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  unint64_t rawBits = v11._rawBits;
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    uint64_t v24 = String.UnicodeScalarView._foreignIndex(before:)(v11)._rawBits;
    swift_bridgeObjectRelease(v4);
  }

  else
  {
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      v31[0] = v3;
      v31[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      swift_bridgeObjectRelease(v4);
      Swift::String::Index v20 = (char *)v31 + (rawBits >> 16);
      if ((*(v20 - 1) & 0xC0) == 0x80)
      {
        Swift::String::Index v21 = 0LL;
        uint64_t v22 = v20 - 2;
        do
          uint64_t v23 = v22[v21--] & 0xC0;
        while (v23 == 128);
        uint64_t v19 = 1 - v21;
      }

      else
      {
        uint64_t v19 = 1LL;
      }
    }

    else
    {
      if ((v3 & 0x1000000000000000LL) != 0) {
        Swift::UInt64 v13 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        Swift::UInt64 v13 = (char *)_StringObject.sharedUTF8.getter(v3, v4);
      }
      uint64_t v14 = 0LL;
      do
        Swift::UInt64 v15 = v13[(rawBits >> 16) - 1 + v14--] & 0xC0;
      while (v15 == 128);
      swift_bridgeObjectRelease(v4);
      uint64_t v19 = -v14;
    }

    uint64_t v24 = (rawBits - (v19 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
  }

  if (v24 >> 14 < v2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  swift_bridgeObjectRetain(v4, v16, v17, v18);
  v25._unint64_t rawBits = v2;
  v26._unint64_t rawBits = v24;
  Swift::UInt64 v27 = _StringGuts.validateScalarRange(_:in:)(v25, v26, v2, v1, v3, v4);
  uint64_t v29 = v28;
  swift_bridgeObjectRelease(v4);
  Swift::String::Index *v0 = v27;
  v0[1] = v29;
  v0[2] = v3;
  v0[3] = v4;
  LOBYTE(v31[0]) = 0;
  return v10;
}

uint64_t RangeReplaceableCollection<>._customRemoveLast()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v90 = (void (**)(char *, uint64_t))a2;
  uint64_t v78 = a3;
  uint64_t v4 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v4,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v6 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v72 = (char *)&v69 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v71 = (char *)&v69 - v9;
  uint64_t v88 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unint64_t v82 = (char *)&v69 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  unint64_t v81 = (char *)&v69 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unint64_t v79 = (char *)&v69 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v86 = (char *)&v69 - v17;
  MEMORY[0x1895F8858](v16);
  uint64_t v84 = (char *)&v69 - v18;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v4,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v20 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v19);
  uint64_t v75 = *(void *)(v20 - 8);
  uint64_t v76 = v20;
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  unint64_t v73 = (char *)&v69 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  uint64_t v74 = (char *)&v69 - v24;
  uint64_t v25 = *(void *)(a1 - 8);
  uint64_t v26 = MEMORY[0x1895F8858](v23);
  int v28 = (char *)&v69 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  unint64_t v87 = (char *)&v69 - v29;
  uint64_t v83 = v4;
  unint64_t v30 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v4 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v33 = type metadata accessor for Optional(0LL, v30, v31, v32);
  uint64_t v34 = MEMORY[0x1895F8858](v33);
  uint64_t v36 = (char *)&v69 - v35;
  uint64_t v37 = *(void *)(v30 - 8);
  MEMORY[0x1895F8858](v34);
  uint64_t v39 = (char *)&v69 - v38;
  BidirectionalCollection.last.getter(a1, (uint64_t)v90, (uint64_t)v36);
  uint64_t v85 = v37;
  uint64_t v40 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v37 + 48);
  unint64_t v89 = v30;
  if (v40(v36, 1LL, v30) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x331uLL,  0);
  }
  uint64_t v41 = *(void (**)(uint64_t, char *, unint64_t))(v85 + 32);
  uint64_t v70 = v39;
  uint64_t v69 = v41;
  v41((uint64_t)v39, v36, v89);
  Swift::UInt64 v42 = *(void (**)(char *, uint64_t, uint64_t))(v25 + 16);
  uint64_t v43 = v91;
  v42(v87, v91, a1);
  uint64_t v44 = v83;
  uint64_t v45 = v84;
  (*(void (**)(uint64_t, uint64_t))(v83 + 64))(a1, v83);
  v42(v28, v43, a1);
  uint64_t v46 = v79;
  (*(void (**)(uint64_t, uint64_t))(v44 + 72))(a1, v44);
  uint64_t v47 = *(void (***)(char *, uint64_t))(v25 + 8);
  ((void (*)(uint64_t, uint64_t))v47)(v43, a1);
  unint64_t v48 = v86;
  v90[4](v46, a1);
  uint64_t v49 = v88;
  uint64_t v50 = *(void (**)(char *, unint64_t))(v88 + 8);
  v50(v46, AssociatedTypeWitness);
  unint64_t v90 = v47;
  ((void (*)(char *, uint64_t))v47)(v28, a1);
  uint64_t v51 = *(void (**)(char *, char *, unint64_t))(v49 + 16);
  uint64_t v52 = v81;
  v51(v81, v45, AssociatedTypeWitness);
  uint64_t v53 = v82;
  v51(v82, v48, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v52,  v53,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v50(v53, AssociatedTypeWitness);
  v50(v52, AssociatedTypeWitness);
  uint64_t v54 = v71;
  uint64_t v55 = v72;
  uint64_t v56 = TupleTypeMetadata2;
  uint64_t v57 = &v71[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v58 = *(void (**)(char *, char *, unint64_t))(v88 + 32);
  v58(v71, v84, AssociatedTypeWitness);
  v58(v57, v86, AssociatedTypeWitness);
  uint64_t v59 = &v55[*((int *)v56 + 12)];
  v51(v55, v54, AssociatedTypeWitness);
  v51(v59, v57, AssociatedTypeWitness);
  uint64_t v60 = v73;
  v58(v73, v55, AssociatedTypeWitness);
  v50(v59, AssociatedTypeWitness);
  uint64_t v61 = &v55[*((int *)v56 + 12)];
  v58(v55, v54, AssociatedTypeWitness);
  v58(v61, v57, AssociatedTypeWitness);
  uint64_t v62 = v76;
  v58(&v60[*(int *)(v76 + 36)], v61, AssociatedTypeWitness);
  v50(v55, AssociatedTypeWitness);
  uint64_t v64 = v74;
  uint64_t v63 = v75;
  (*(void (**)(char *, char *, uint64_t))(v75 + 32))(v74, v60, v62);
  uint64_t v65 = v87;
  (*(void (**)(char *, uint64_t))(v83 + 88))(v64, a1);
  (*(void (**)(char *, uint64_t))(v63 + 8))(v64, v62);
  ((void (*)(char *, uint64_t))v90)(v65, a1);
  uint64_t v66 = v78;
  unint64_t v67 = v89;
  v69(v78, v70, v89);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v85 + 56))(v66, 0LL, 1LL, v67);
}

uint64_t RangeReplaceableCollection<>.removeLast(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeReplaceableCollection<>.removeLast(_:)(a1, a2, a3, a4, 0x37CuLL, 0x383uLL);
}

{
  return RangeReplaceableCollection<>.removeLast(_:)(a1, a2, a3, a4, 0x3C6uLL, 0x3CDuLL);
}

uint64_t RangeReplaceableCollection<>.popLast()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v32 = a3;
  uint64_t v33 = a4;
  uint64_t v30 = a2;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v28 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v29 = (char *)&v28 - v9;
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v5 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v13 = type metadata accessor for Optional(0LL, v10, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v28 - v16;
  uint64_t v18 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v28 - v19;
  (*(void (**)(uint64_t))(v32 + 112))(a1);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48))(v17, 1LL, v10) == 1)
  {
    (*(void (**)(char *, uint64_t))(v14 + 8))(v17, v13);
    (*(void (**)(uint64_t, uint64_t))(v5 + 72))(a1, v5);
    uint64_t v22 = v29;
    (*(void (**)(char *, uint64_t))(v30 + 32))(v8, a1);
    uint64_t v23 = *(void (**)(char *, unint64_t))(v28 + 8);
    unint64_t v24 = AssociatedTypeWitness;
    v23(v8, AssociatedTypeWitness);
    uint64_t v25 = v33;
    (*(void (**)(char *, uint64_t))(v32 + 96))(v22, a1);
    v23(v22, v24);
    return (*(uint64_t (**)(char *, void, uint64_t, unint64_t))(v18 + 56))(v25, 0LL, 1LL, v10);
  }

  else
  {
    uint64_t v26 = *(void (**)(char *, char *, unint64_t))(v18 + 32);
    v26(v20, v17, v10);
    uint64_t v27 = v33;
    v26(v33, v20, v10);
    return (*(uint64_t (**)(char *, void, uint64_t, unint64_t))(v18 + 56))(v27, 0LL, 1LL, v10);
  }

uint64_t RangeReplaceableCollection<>.removeLast()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v26 = a4;
  uint64_t v30 = a5;
  uint64_t v28 = a2;
  uint64_t v7 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v27 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v10 = (char *)&v25 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v25 - v11;
  unint64_t v13 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v7 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v16 = type metadata accessor for Optional(0LL, v13, v14, v15);
  uint64_t v17 = *(void *)(v16 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v25 - v18;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v7 + 104))(a1, v7) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove last element from an empty collection",  50LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  v26,  0);
  }
  uint64_t v20 = *(void (**)(uint64_t, unint64_t))(a3 + 112);
  unint64_t v26 = a3;
  v20(a1, a3);
  uint64_t v21 = *(void *)(v13 - 8);
  (*(void (**)(char *, uint64_t))(v17 + 8))(v19, v16);
  (*(void (**)(uint64_t, uint64_t))(v7 + 72))(a1, v7);
  (*(void (**)(char *, uint64_t))(v28 + 32))(v10, a1);
  uint64_t v22 = *(void (**)(char *, unint64_t))(v27 + 8);
  unint64_t v23 = AssociatedTypeWitness;
  v22(v10, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v26 + 96))(v12, a1);
  return ((uint64_t (*)(char *, unint64_t))v22)(v12, v23);
}

uint64_t RangeReplaceableCollection<>.removeLast(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  unint64_t v57 = a6;
  uint64_t v69 = a4;
  unint64_t v70 = a5;
  uint64_t v68 = a3;
  uint64_t v9 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v9,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v11 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v64 = (char *)&v55 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v59 = (char *)&v55 - v13;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v9,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v62 = *(void *)(v15 - 8);
  uint64_t v63 = v15;
  uint64_t v16 = MEMORY[0x1895F8858](v15);
  uint64_t v58 = (char *)&v55 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  uint64_t v60 = (char *)&v55 - v18;
  uint64_t v21 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v19, v20);
  uint64_t v55 = *(void *)(v21 - 8);
  uint64_t v56 = v21;
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  unint64_t v24 = (char *)&v55 - v23;
  uint64_t v25 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v26 = MEMORY[0x1895F8858](v22);
  uint64_t v66 = (char *)&v55 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v65 = (char *)&v55 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v32 = (char *)&v55 - v31;
  uint64_t v33 = MEMORY[0x1895F8858](v30);
  uint64_t v35 = (char *)&v55 - v34;
  uint64_t result = MEMORY[0x1895F8858](v33);
  uint64_t v38 = (char *)&v55 - v37;
  if (a1)
  {
    if (a1 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  v70,  0);
    }
    uint64_t v39 = *(uint64_t (**)(uint64_t, uint64_t))(v69 + 120);
    unint64_t v70 = v6;
    uint64_t result = v39(a1, a2);
    if ((result & 1) == 0)
    {
      (*(void (**)(uint64_t, uint64_t))(v9 + 72))(a2, v9);
      (*(void (**)(uint64_t, uint64_t))(v9 + 64))(a2, v9);
      (*(void (**)(char *, uint64_t, char *, uint64_t))(v68 + 56))(v38, -a1, v32, a2);
      uint64_t v40 = *(void (**)(char *, unint64_t))(v25 + 8);
      v40(v32, AssociatedTypeWitness);
      if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v25 + 48))( v24,  1LL,  AssociatedTypeWitness) == 1)
      {
        (*(void (**)(char *, uint64_t))(v55 + 8))(v24, v56);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  v57,  0);
      }

      uint64_t v41 = *(void (**)(char *, char *, unint64_t))(v25 + 32);
      v41(v35, v24, AssociatedTypeWitness);
      Swift::UInt64 v42 = *(void (**)(char *, char *, unint64_t))(v25 + 16);
      uint64_t v43 = v65;
      v42(v65, v35, AssociatedTypeWitness);
      uint64_t v44 = v66;
      v42(v66, v38, AssociatedTypeWitness);
      if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v43,  v44,  AssociatedTypeWitness) & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }
      v40(v44, AssociatedTypeWitness);
      v40(v43, AssociatedTypeWitness);
      uint64_t v68 = a2;
      uint64_t v45 = TupleTypeMetadata2;
      uint64_t v46 = v59;
      uint64_t v47 = &v59[*((int *)TupleTypeMetadata2 + 12)];
      v41(v59, v35, AssociatedTypeWitness);
      v41(v47, v38, AssociatedTypeWitness);
      unint64_t v48 = v64;
      uint64_t v49 = &v64[*((int *)v45 + 12)];
      v42(v64, v46, AssociatedTypeWitness);
      v42(v49, v47, AssociatedTypeWitness);
      uint64_t v50 = v58;
      v41(v58, v48, AssociatedTypeWitness);
      v40(v49, AssociatedTypeWitness);
      uint64_t v51 = &v48[*((int *)v45 + 12)];
      v41(v48, v46, AssociatedTypeWitness);
      v41(v51, v47, AssociatedTypeWitness);
      uint64_t v52 = v63;
      v41(&v50[*(int *)(v63 + 36)], v51, AssociatedTypeWitness);
      v40(v48, AssociatedTypeWitness);
      uint64_t v53 = v62;
      uint64_t v54 = v60;
      (*(void (**)(char *, char *, uint64_t))(v62 + 32))(v60, v50, v52);
      (*(void (**)(char *, uint64_t))(v69 + 104))(v54, v68);
      return (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v54, v52);
    }
  }

  return result;
}

uint64_t static RangeReplaceableCollection.+ infix<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v13 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(*(void *)(v16 - 8) + 16LL))(a7);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a2, a4);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 72))(v15, a4, a6, a3, a5);
}

{
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v13 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(*(void *)(v16 - 8) + 16LL))(a7);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a2, a4);
  return (*(uint64_t (**)(char *, uint64_t, void, uint64_t, uint64_t))(a5 + 72))( v15,  a4,  *(void *)(*(void *)(a6 + 8) + 8LL),  a3,  a5);
}

uint64_t static RangeReplaceableCollection.+ infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v32 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v33 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t, uint64_t))(v17 + 24))(v18, v17);
  uint64_t v19 = *(void *)(a5 + 8);
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t))(v19 + 112);
  uint64_t v34 = a2;
  uint64_t v21 = v20(a3, v19);
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 40);
  uint64_t v31 = a1;
  uint64_t v23 = a6;
  uint64_t v24 = v22(a4, a6);
  BOOL v25 = __OFADD__(v21, v24);
  uint64_t result = v21 + v24;
  if (v25)
  {
    __break(1u);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a5 + 40))(result, a3, a5);
    (*(void (**)(char *, uint64_t, uint64_t))(v30 + 16))(v16, v31, a4);
    uint64_t v27 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 72);
    v27(v16, a4, v23, a3, a5);
    uint64_t v28 = v33;
    (*(void (**)(char *, uint64_t, uint64_t))(v32 + 16))(v33, v34, a3);
    return ((uint64_t (*)(char *, uint64_t, void, uint64_t, uint64_t))v27)( v28,  a3,  *(void *)(v19 + 8),  a3,  a5);
  }

  return result;
}

uint64_t static RangeReplaceableCollection.+= infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = (char *)&v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v12 + 16))(v11);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 72))(v11, a4, a6, a3, a5);
}

uint64_t RangeReplaceableCollection.filter(_:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v42 = a4;
  uint64_t v46 = a2;
  uint64_t v37 = a1;
  uint64_t v8 = *(void *)(*(void *)(a4 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v43 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v40 = (char *)&v36 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v36 - v12;
  uint64_t v16 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v14, v15);
  MEMORY[0x1895F8858](v16);
  uint64_t v18 = (char *)&v36 - v17;
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v38 = *(void *)(v19 - 8);
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (char *)&v36 - v20;
  uint64_t v22 = *(void (**)(uint64_t))(v42 + 24);
  uint64_t v47 = a5;
  v22(a3);
  (*(void (**)(uint64_t, uint64_t))(v8 + 32))(a3, v8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a3,  v19,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v24 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v48 = v21;
  unint64_t v41 = v19;
  unint64_t v25 = v19;
  uint64_t v26 = v24;
  v24(v25, AssociatedConformanceWitness);
  uint64_t v27 = v43;
  uint64_t v28 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v43 + 48);
  if (v28(v18, 1LL, AssociatedTypeWitness) == 1)
  {
    unint64_t v29 = v41;
    return (*(uint64_t (**)(char *, unint64_t))(v38 + 8))(v48, v29);
  }

  else
  {
    uint64_t v44 = v28;
    uint64_t v45 = v26;
    uint64_t v31 = v37;
    uint64_t v39 = a3;
    uint64_t v32 = *(void (**)(char *, char *, unint64_t))(v27 + 32);
    unint64_t v29 = v41;
    v32(v13, v18, AssociatedTypeWitness);
    while (1)
    {
      char v33 = v31(v13);
      if (v5) {
        break;
      }
      if ((v33 & 1) != 0)
      {
        uint64_t v34 = v40;
        v32(v40, v13, AssociatedTypeWitness);
        uint64_t v35 = v34;
        unint64_t v29 = v41;
        (*(void (**)(char *, uint64_t))(v42 + 64))(v35, v39);
      }

      else
      {
        (*(void (**)(char *, unint64_t))(v43 + 8))(v13, AssociatedTypeWitness);
      }

      v45(v29, AssociatedConformanceWitness);
      if (v44(v18, 1LL, AssociatedTypeWitness) == 1) {
        return (*(uint64_t (**)(char *, unint64_t))(v38 + 8))(v48, v29);
      }
      v32(v13, v18, AssociatedTypeWitness);
    }

    (*(void (**)(char *, unint64_t))(v43 + 8))(v13, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v38 + 8))(v48, v29);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v39 - 8) + 8LL))(v47, v39);
  }

uint64_t RangeReplaceableCollection.removeSubranges(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.SubSequence);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v41 = (char *)&v35 - v7;
  unint64_t v8 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  v8,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v11 = type metadata accessor for Range(0LL, v8, AssociatedConformanceWitness, v10);
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v40 = (char *)&v35 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v35 - v16;
  uint64_t result = MEMORY[0x1895F8858](v15);
  uint64_t v22 = (char *)&v35 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (*(void *)(*(void *)a1 + 16LL))
  {
    uint64_t v38 = v20;
    uint64_t v23 = type metadata accessor for RangeSet(0LL, v8, AssociatedConformanceWitness, v19);
    RangeSet._inverted<A>(within:)(v23, a2, v6, &v44);
    (*(void (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
    uint64_t v24 = v44;
    unint64_t v25 = *(void *)(v44 + 16);
    uint64_t v39 = a3;
    if (v25)
    {
      unint64_t v26 = 0LL;
      uint64_t v27 = v41;
      do
      {
        if (v26 >= v25) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }
        uint64_t v28 = v40;
        (*(void (**)(char *, unint64_t, uint64_t))(v12 + 16))( v40,  v24 + ((*(unsigned __int8 *)(v12 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80))
        + *(void *)(v12 + 72) * v26,
          v11);
        (*(void (**)(char *, char *, uint64_t))(v12 + 32))(v17, v28, v11);
        ++v26;
        (*(void (**)(char *, uint64_t, uint64_t))(v6 + 88))(v17, a2, v6);
        (*(void (**)(char *, uint64_t))(v12 + 8))(v17, v11);
        uint64_t v37 = v11;
        uint64_t v29 = v39;
        uint64_t v36 = *(void (**)(char *, unint64_t, void, uint64_t, uint64_t))(v39 + 72);
        unint64_t v30 = AssociatedTypeWitness;
        unint64_t v31 = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
        uint64_t v32 = v29;
        uint64_t v11 = v37;
        v36(v27, v30, *(void *)(v31 + 8), a2, v32);
        unint64_t v25 = *(void *)(v24 + 16);
      }

      while (v26 != v25);
    }

    uint64_t v33 = v38;
    uint64_t v34 = v43;
    (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v43, a2);
    swift_release(v24);
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v33 + 32))(v34, v22, a2);
  }

  return result;
}

uint64_t MutableCollection<>.removeSubranges(_:)(unint64_t *a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v116 = a4;
  unint64_t v135 = a1;
  unint64_t v136 = a3;
  uint64_t v7 = (const char *)*((void *)a3 + 1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v115 = (char *)&v110 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v113 = (char *)&v110 - v12;
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  unint64_t v119 = (char *)&v110 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v118 = (char *)&v110 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  id v120 = (char *)&v110 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v121 = (char *)&v110 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v117 = (char *)&v110 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  unint64_t v137 = (char *)&v110 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v28 = (char *)&v110 - v27;
  MEMORY[0x1895F8858](v26);
  unint64_t v128 = (char *)&v110 - v29;
  int8x16_t v134 = v7;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v32 = type metadata accessor for Range((const char *)0xFF, AssociatedTypeWitness, AssociatedConformanceWitness, v31);
  uint64_t v35 = type metadata accessor for Optional(0LL, v32, v33, v34);
  char v130 = *(unint64_t ***)(v35 - 8);
  uint64_t v131 = (void (*)(char *, char *, unint64_t))v35;
  uint64_t v36 = MEMORY[0x1895F8858](v35);
  uint64_t v38 = (char *)&v110 - v37;
  uint64_t v129 = *(void *)(v32 - 8);
  uint64_t v39 = MEMORY[0x1895F8858](v36);
  uint64_t v111 = (char *)&v110 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  unint64_t v112 = (char *)&v110 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  uint64_t v132 = (char *)&v110 - v44;
  uint64_t v45 = MEMORY[0x1895F8858](v43);
  unint64_t v126 = (char *)&v110 - v46;
  MEMORY[0x1895F8858](v45);
  unint64_t v48 = (char *)&v110 - v47;
  unint64_t v135 = (unint64_t *)*v135;
  Swift::String::Index v141 = v135;
  unint64_t v127 = AssociatedConformanceWitness;
  uint64_t v50 = type metadata accessor for RangeSet.Ranges(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v49);
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v50, v51);
  Collection.first.getter(v50, (uint64_t)WitnessTable, (uint64_t)v38);
  uint64_t v52 = v129;
  unint64_t v123 = *(void (**)(char *, char *, uint64_t))(v52 + 32);
  v123(v48, v38, v32);
  uint64_t v54 = *(void (**)(char *, char *, unint64_t))(v13 + 16);
  uint64_t v55 = v128;
  v54(v128, v48, AssociatedTypeWitness);
  uint64_t v56 = *(int *)(v32 + 36);
  unint64_t v110 = v48;
  uint64_t v131 = v54;
  v54(v28, &v48[v56], AssociatedTypeWitness);
  Swift::String::Index v141 = v135;
  swift_retain(v135, v57, v58, v59);
  uint64_t v122 = v50;
  Collection.dropFirst(_:)(1LL, v50, (uint64_t)WitnessTable, (uint64_t)&v138);
  uint64_t v61 = v138;
  uint64_t v60 = v139;
  uint64_t v62 = v140;
  Swift::String::Index v141 = v138;
  unint64_t v142 = v139;
  uint64_t v143 = v140;
  unint64_t v144 = v138;
  uint64_t v124 = v13;
  uint64_t v125 = v32;
  if (v138 != v139)
  {
    char v130 = &v144;
    uint64_t v63 = v129;
    do
    {
      Swift::String::Index v138 = v141;
      Swift::String::Index v139 = v60;
      uint64_t v66 = v122;
      specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v130, (uint64_t)&v138, v122, WitnessTable);
      if (((unint64_t)v61 & 0x8000000000000000LL) != 0
        || (uint64_t v67 = v143, (unint64_t)v61 >= *(void *)(v143 + 16)))
      {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }

      unint64_t v68 = v143
      uint64_t v69 = *(void (**)(char *, unint64_t, uint64_t))(v63 + 16);
      unint64_t v70 = v126;
      v69(v126, v68, v32);
      uint64_t v71 = *(unint64_t **)(v67 + 16);
      Swift::String::Index v138 = 0LL;
      Swift::String::Index v139 = v71;
      specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v130, (uint64_t)&v138, v66, WitnessTable);
      unint64_t v144 = (unint64_t *)((char *)v61 + 1);
      uint64_t v72 = v132;
      v123(v132, v70, v32);
      unint64_t v73 = v137;
      v131(v137, v72, AssociatedTypeWitness);
      uint64_t v74 = *(uint64_t (**)(char *, char *, unint64_t))(*(void *)(v127 + 8) + 8LL);
      unint64_t v135 = *(unint64_t **)(v127 + 8);
      char v75 = v74(v28, v73, AssociatedTypeWitness);
      uint64_t v76 = v134;
      if ((v75 & 1) == 0)
      {
        uint64_t v77 = (void (*)(char *, char *, uint64_t, char *))*((void *)v136 + 8);
        uint64_t v78 = (void (*)(char *, uint64_t, const char *))*((void *)v134 + 24);
        do
        {
          v77(v55, v28, a2, v136);
          v78(v55, a2, v76);
          v78(v28, a2, v76);
        }

        while ((((uint64_t (*)(char *, char *, unint64_t, unint64_t *))v74)( v28,  v137,  AssociatedTypeWitness,  v135) & 1) == 0);
      }

      uint64_t v13 = v124;
      uint64_t v64 = *(void (**)(char *, unint64_t))(v124 + 8);
      v64(v137, AssociatedTypeWitness);
      v64(v28, AssociatedTypeWitness);
      uint64_t v32 = v125;
      uint64_t v65 = v132;
      v131(v28, &v132[*(int *)(v125 + 36)], AssociatedTypeWitness);
      uint64_t v63 = v129;
      (*(void (**)(char *, uint64_t))(v129 + 8))(v65, v32);
      uint64_t v61 = v144;
      uint64_t v60 = v142;
    }

    while (v144 != v142);
    uint64_t v62 = v143;
  }

  swift_release(v62);
  unint64_t v79 = v134;
  char v80 = (char *)*((void *)v134 + 9);
  uint64_t v81 = *(void *)(v127 + 8);
  unint64_t v135 = *(unint64_t **)(v81 + 8);
  unint64_t v82 = v5;
  uint64_t v83 = v117;
  unint64_t v137 = v80;
  ((void (*)(uint64_t, const char *))v80)(a2, v134);
  uint64_t WitnessTable = (const char *)v81;
  char v84 = ((uint64_t (*)(char *, char *, unint64_t, uint64_t))v135)(v28, v83, AssociatedTypeWitness, v81);
  uint64_t v85 = *(void (**)(char *, unint64_t))(v13 + 8);
  v85(v83, AssociatedTypeWitness);
  if ((v84 & 1) == 0)
  {
    uint64_t v132 = (char *)*((void *)v136 + 8);
    unint64_t v86 = v128;
    do
    {
      ((void (*)(char *, char *, uint64_t, char *))v132)(v86, v28, a2, v136);
      unint64_t v87 = (void (*)(char *, uint64_t, const char *))*((void *)v134 + 24);
      v87(v86, a2, v134);
      v87(v28, a2, v134);
      unint64_t v79 = v134;
      ((void (*)(uint64_t, const char *))v137)(a2, v134);
      char v88 = ((uint64_t (*)(char *, char *, unint64_t, const char *))v135)( v28,  v83,  AssociatedTypeWitness,  WitnessTable);
      v85(v83, AssociatedTypeWitness);
    }

    while ((v88 & 1) == 0);
  }

  unint64_t v89 = v85;
  unint64_t v136 = v28;
  unint64_t v90 = v121;
  uint64_t v91 = v131;
  v131(v121, v128, AssociatedTypeWitness);
  unint64_t v92 = v79;
  uint64_t v93 = v120;
  ((void (*)(uint64_t, const char *))v137)(a2, v92);
  uint64_t v94 = v118;
  v91(v118, v90, AssociatedTypeWitness);
  unint64_t v95 = v119;
  v91(v119, v93, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(v127 + 24))(v94, v95, AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v96 = v82;
  v89(v95, AssociatedTypeWitness);
  v89(v94, AssociatedTypeWitness);
  v89(v136, AssociatedTypeWitness);
  v89(v128, AssociatedTypeWitness);
  unint64_t v97 = AssociatedTypeWitness;
  unint64_t v137 = *(char **)(v129 + 8);
  ((void (*)(char *, uint64_t))v137)(v110, v32);
  unint64_t v136 = v96;
  char v98 = TupleTypeMetadata2;
  unint64_t v99 = v113;
  unint64_t v100 = &v113[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v101 = v91;
  unint64_t v102 = v93;
  unint64_t v103 = *(void (**)(char *, char *, unint64_t))(v124 + 32);
  v103(v113, v121, v97);
  v103(v100, v102, v97);
  char v104 = v115;
  unint64_t v105 = &v115[*((int *)v98 + 12)];
  v101(v115, v99, v97);
  v101(v105, v100, v97);
  unint64_t v106 = v111;
  v103(v111, v104, v97);
  v89(v105, v97);
  size_t v107 = &v104[*((int *)v98 + 12)];
  v103(v104, v99, v97);
  v103(v107, v100, v97);
  uint64_t v108 = v125;
  v103(&v106[*(int *)(v125 + 36)], v107, v97);
  v89(v104, v97);
  unint64_t v109 = v112;
  v123(v112, v106, v108);
  (*(void (**)(char *, uint64_t))(v116 + 104))(v109, a2);
  return ((uint64_t (*)(char *, uint64_t))v137)(v109, v108);
}

uint64_t RangeSet._ranges.setter(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t result = swift_release(*v1);
  *uint64_t v1 = v2;
  return result;
}

uint64_t (*RangeSet._ranges.modify())()
{
  return EnumeratedSequence._base.modify;
}

void RangeSet.init()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, __objc2_class ***a4@<X8>)
{
  uint64_t v5 = (uint64_t *)type metadata accessor for Range(0LL, a1, a2, a3);
  _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
  uint64_t v6 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v5);
  if (v6)
  {
    uint64_t v9 = (__objc2_class **)v6;
  }

  else
  {
    uint64_t v13 = &_swiftEmptyArrayStorage;
    uint64_t v10 = type metadata accessor for Array(0LL, (uint64_t)v5, v7, v8);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v10, v11);
    uint64_t v9 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v13, v10, WitnessTable);
  }

  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  *a4 = v9;
}

void RangeSet.Ranges.init()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, __objc2_class ***a4@<X8>)
{
  uint64_t v5 = (uint64_t *)type metadata accessor for Range(0LL, a1, a2, a3);
  _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
  uint64_t v6 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v5);
  if (v6)
  {
    uint64_t v9 = (__objc2_class **)v6;
  }

  else
  {
    uint64_t v13 = &_swiftEmptyArrayStorage;
    uint64_t v10 = type metadata accessor for Array(0LL, (uint64_t)v5, v7, v8);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v10, v11);
    uint64_t v9 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v13, v10, WitnessTable);
  }

  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  *a4 = v9;
}

void RangeSet.Ranges.init(_range:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v7 = (uint64_t *)type metadata accessor for Range((const char *)0xFF, a2, a3, a4);
  uint64_t v10 = type metadata accessor for _ContiguousArrayStorage(0LL, (uint64_t)v7, v8, v9);
  uint64_t v11 = *(v7 - 1);
  uint64_t v12 = swift_allocObject( v10,  ((*(unsigned __int8 *)(v11 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))
        + *(void *)(v11 + 72),
          *(unsigned __int8 *)(v11 + 80) | 7LL);
  uint64_t v13 = *(uint64_t **)(*v12 + 144LL);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v13, v13);
  void v12[2] = 1LL;
  v12[3] = isClassOrObjCExistentialType | 2LL;
  uint64_t v15 = *(unsigned __int8 *)(*(v13 - 1) + 80);
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(v11 + 32))((uint64_t)v12 + ((v15 + 32) & ~v15), a1, v7);
  uint64_t v16 = _ArrayBuffer.requestNativeBuffer()((unint64_t)v12, v7);
  if (!v16)
  {
    uint64_t v23 = v12;
    uint64_t v19 = type metadata accessor for Array(0LL, (uint64_t)v7, v17, v18);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v19, v20);
    uint64_t v16 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v23, v19, WitnessTable);
  }

  uint64_t v22 = v16;
  swift_bridgeObjectRelease((uint64_t)v12);
  *a5 = v22;
}

void *RangeSet.init<A>(_:)@<X0>( unint64_t **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t **a6@<X8>)
{
  uint64_t v12 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (type metadata accessor for RangeSet.Ranges(0LL, v15, v16, v16) == a3)
  {
    uint64_t v22 = *a1;
    uint64_t v23 = *(uint64_t (**)(unint64_t **, uint64_t))(v12 + 8);
    swift_retain(*a1, v17, v18, v19);
    uint64_t result = (void *)v23(a1, a3);
  }

  else
  {
    (*(void (**)(char *, unint64_t **, uint64_t))(v12 + 32))(v14, a1, a3);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 56))(a3, a5);
    uint64_t result = RangeSet.Ranges.init(_unorderedRanges:)(v20, a2, a4, (uint64_t *)&v25);
    uint64_t v22 = v25;
  }

  *a6 = v22;
  return result;
}

void *RangeSet.init(_ranges:)@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void *RangeSet.Ranges.init(_unorderedRanges:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v5 = a2;
  unint64_t v92 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a2, a2, "lower upper ", 0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v98 = (char *)&v92 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  unint64_t v97 = (char *)&v92 - v10;
  uint64_t v11 = *(void *)(v5 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  unint64_t v103 = (char *)&v92 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  unint64_t v102 = (char *)&v92 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v101 = (char *)&v92 - v17;
  MEMORY[0x1895F8858](v16);
  unint64_t v100 = (char *)&v92 - v18;
  uint64_t v20 = type metadata accessor for Range(0LL, v5, a3, v19);
  uint64_t v21 = *(void *)(v20 - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v112 = (char *)&v92 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v108 = (char *)&v92 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v111 = (char *)&v92 - v27;
  MEMORY[0x1895F8858](v26);
  uint64_t v29 = (char *)&v92 - v28;
  uint64_t v30 = _ArrayBuffer.requestNativeBuffer()(a1, (uint64_t *)v20);
  if (!v30)
  {
    uint64_t v115 = a1;
    uint64_t v33 = type metadata accessor for Array(0LL, v20, v31, v32);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v33, v34);
    uint64_t v30 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)&v115, v33, WitnessTable);
  }

  uint64_t v36 = v30;
  swift_bridgeObjectRelease(a1);
  uint64_t v114 = &v92;
  uint64_t v115 = v36;
  MEMORY[0x1895F8858](v37);
  uint64_t v90 = v5;
  uint64_t v91 = a3;
  uint64_t v40 = type metadata accessor for ContiguousArray(0LL, v20, v38, v39);
  uint64_t v42 = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v40, v41);
  uint64_t v44 = (void *)swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v40, v43);
  uint64_t v109 = v40;
  uint64_t result = MutableCollection<>.sort(by:)( partial apply for closure #1 in RangeSet.Ranges.init(_unorderedRanges:),  (uint64_t)v89,  v40,  v42,  v44);
  uint64_t v46 = v115;
  unint64_t v47 = *(void *)(v115 + 16);
  if (v47)
  {
    unint64_t v48 = 0LL;
    uint64_t v95 = a3;
    uint64_t v96 = v11;
    uint64_t v94 = v29;
    uint64_t v107 = v20;
    uint64_t v93 = v21;
    do
    {
      if (v48 >= v47) {
LABEL_23:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      unint64_t v113 = (*(unsigned __int8 *)(v21 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v21 + 80);
      unint64_t v49 = v46 + v113;
      uint64_t v50 = v21;
      uint64_t v51 = *(void *)(v21 + 72);
      uint64_t v52 = *(void (**)(char *, unint64_t, uint64_t))(v50 + 16);
      v52(v29, v46 + v113 + v51 * v48, v20);
      uint64_t v114 = (void **)v48;
      if (v48)
      {
        unint64_t v110 = (unint64_t)v114 - 1;
        uint64_t v53 = v51 * ((void)v114 - 1);
        uint64_t v54 = v5;
        uint64_t v55 = v29;
        uint64_t v56 = v111;
        v52(v111, v49 + v53, v20);
        uint64_t v57 = &v56[*(int *)(v20 + 36)];
        uint64_t v58 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a3 + 32);
        if ((v58(v57, v55, v54, a3) & 1) != 0)
        {
          uint64_t v106 = v53;
          uint64_t v59 = &v55[*(int *)(v20 + 36)];
          char v60 = v58(v59, v57, v54, a3);
          uint64_t v61 = v96;
          uint64_t v62 = *(void (**)(char *, char *, uint64_t))(v96 + 16);
          if ((v60 & 1) != 0) {
            uint64_t v63 = v59;
          }
          else {
            uint64_t v63 = v57;
          }
          uint64_t v64 = v100;
          v62(v100, v63, v54);
          uint64_t v65 = v101;
          v62(v101, v56, v54);
          uint64_t v66 = v102;
          v62(v102, v65, v54);
          uint64_t v67 = v103;
          v62(v103, v64, v54);
          if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a3 + 24))(v66, v67, v54, a3) & 1) == 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
          }
          unint64_t v68 = *(void (**)(char *, uint64_t))(v61 + 8);
          char v104 = v68;
          v68(v67, v54);
          v68(v66, v54);
          uint64_t v69 = *(void (**)(char *, uint64_t))(v50 + 8);
          uint64_t v70 = v107;
          v69(v111, v107);
          unint64_t v105 = (uint64_t (*)(uint64_t, uint64_t))v69;
          v69(v55, v70);
          uint64_t v71 = TupleTypeMetadata2;
          uint64_t v72 = v97;
          unint64_t v73 = &v97[*((int *)TupleTypeMetadata2 + 12)];
          uint64_t v74 = *(void (**)(char *, char *, uint64_t))(v61 + 32);
          v74(v97, v65, v54);
          v74(v73, v64, v54);
          char v75 = v98;
          uint64_t v76 = &v98[*((int *)v71 + 12)];
          v62(v98, v72, v54);
          v62(v76, v73, v54);
          uint64_t v77 = (uint64_t)v112;
          v74(v112, v75, v54);
          uint64_t v78 = v104;
          v104(v76, v54);
          unint64_t v79 = &v75[*((int *)v71 + 12)];
          v74(v75, v72, v54);
          v74(v79, v73, v54);
          uint64_t v20 = v107;
          v74((char *)(v77 + *(int *)(v107 + 36)), v79, v54);
          char v80 = v75;
          uint64_t v21 = v93;
          v78(v80, v54);
          (*(void (**)(char *, uint64_t, uint64_t))(v21 + 32))(v108, v77, v20);
          uint64_t v81 = (__objc2_class **)v115;
          BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v115);
          uint64_t v115 = (uint64_t)v81;
          uint64_t v5 = v54;
          uint64_t v83 = v109;
          if (!isUniquelyReferenced_nonNull_native)
          {
            uint64_t v81 = _ContiguousArrayBuffer._consumeAndCreateNew()((uint64_t)v81, *(uint64_t **)(v109 + 16));
            uint64_t v115 = (uint64_t)v81;
          }

          unint64_t v48 = (unint64_t)v114;
          specialized Array._checkSubscript_mutating(_:)(v110, (uint64_t)v81);
          (*(void (**)(char *, char *, uint64_t))(v21 + 40))((char *)v81 + v113 + v106, v108, v20);
          uint64_t v88 = (uint64_t)v112;
          ContiguousArray.remove(at:)(v48, v83, (uint64_t)v112);
          uint64_t result = (void *)v105(v88, v20);
          a3 = v95;
          uint64_t v29 = v94;
          goto LABEL_6;
        }

        (*(void (**)(char *, uint64_t))(v50 + 8))(v56, v20);
        uint64_t v29 = v55;
        uint64_t v5 = v54;
      }

      char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a3 + 8) + 8LL))( v29,  &v29[*(int *)(v20 + 36)],  v5);
      uint64_t v85 = *(uint64_t (**)(char *, uint64_t))(v50 + 8);
      uint64_t result = (void *)v85(v29, v20);
      uint64_t v21 = v50;
      if ((v84 & 1) != 0)
      {
        uint64_t v86 = (uint64_t)v112;
        uint64_t v87 = (uint64_t)v114;
        ContiguousArray.remove(at:)((uint64_t)v114, v109, (uint64_t)v112);
        uint64_t result = (void *)v85((char *)v86, v20);
        unint64_t v48 = v87;
      }

      else
      {
        unint64_t v48 = (unint64_t)v114 + 1;
      }

uint64_t RangeSet.Ranges.init(_ranges:)@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t RangeSet.Ranges._contains(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = *(void *)(v8 + 24);
  uint64_t v11 = type metadata accessor for Range(0LL, v4, v9, v10);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v26 - v13;
  uint64_t v32 = (unint64_t *)*v2;
  uint64_t v15 = v32;
  uint64_t v29 = v4;
  uint64_t v30 = v9;
  uint64_t v27 = a1;
  uint64_t v31 = a1;
  uint64_t v18 = type metadata accessor for ContiguousArray(0LL, v11, v16, v17);
  swift_retain(v15, v19, v20, v21);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v18, v22);
  Collection._partitioningIndex(where:)( (uint64_t (*)(char *))partial apply for closure #1 in RangeSet.Ranges._contains(_:),  (uint64_t)v28,  v18,  WitnessTable,  (char *)&v33);
  swift_release((uint64_t)v32);
  if (v33 == v15[2])
  {
    char v24 = 0;
  }

  else
  {
    ContiguousArray.subscript.getter(v33, (uint64_t)v15, v11, (uint64_t)v14);
    (*(void (**)(char *, char *, uint64_t))(v5 + 16))(v7, v14, v4);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v11);
    char v24 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 24))(v7, v27, v4, v9);
    (*(void (**)(char *, uint64_t))(v5 + 8))(v7, v4);
  }

  return v24 & 1;
}

uint64_t RangeSet.insert(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = type metadata accessor for Range(0LL, v5, v6, a4);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 8LL))( a1,  a1 + *(int *)(v7 + 36),  v5);
  if ((result & 1) == 0)
  {
    uint64_t v10 = type metadata accessor for RangeSet.Ranges(0LL, v5, v6, v9);
    return RangeSet.Ranges._insert(contentsOf:)(a1, v10);
  }

  return result;
}

uint64_t RangeSet.Ranges._insert(contentsOf:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v5, v5, "lower upper ", 0LL);
  uint64_t v6 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v127 = (char *)&v117 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v125 = (char *)&v117 - v9;
  uint64_t v132 = *(void *)(v5 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  char v130 = (char *)&v117 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v10);
  int8x16_t v134 = (char *)&v117 - v13;
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v133 = (char *)&v117 - v15;
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v129 = (char *)&v117 - v17;
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v131 = (char *)&v117 - v19;
  MEMORY[0x1895F8858](v18);
  Swift::String::Index v139 = (char *)&v117 - v20;
  uint64_t v21 = *(char **)(a2 + 24);
  uint64_t v23 = type metadata accessor for Range((const char *)0xFF, v5, (uint64_t)v21, v22);
  uint64_t v138 = type metadata accessor for CollectionOfOne(0LL, v23, v24, v25);
  uint64_t v26 = MEMORY[0x1895F8858](v138);
  unint64_t v137 = (char *)&v117 - v27;
  uint64_t v141 = *(void *)(v23 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v121 = (char *)&v117 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v122 = (char *)&v117 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v120 = (uint64_t)&v117 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v124 = (char *)&v117 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  unint64_t v136 = (char *)&v117 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  uint64_t v128 = (uint64_t)&v117 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  uint64_t v42 = (char *)&v117 - v41;
  MEMORY[0x1895F8858](v40);
  uint64_t v44 = (char *)&v117 - v43;
  uint64_t v45 = *v2;
  swift_retain(*v2, v46, v47, v48);
  uint64_t v49 = a1;
  uint64_t v50 = specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(a1, v45, 1, v5, (uint64_t)v21);
  uint64_t v52 = v51;
  swift_release((uint64_t)v45);
  uint64_t v140 = v52;
  if (v50 != v52)
  {
    uint64_t v66 = v23;
    unint64_t v118 = v44;
    unint64_t v135 = (uint64_t *)v2;
    unint64_t v119 = v50;
    ContiguousArray.subscript.getter(v50, (uint64_t)v45, v23, (uint64_t)v42);
    uint64_t v67 = v131;
    uint64_t v68 = v132;
    uint64_t v69 = *(void (**)(char *, char *, uint64_t))(v132 + 16);
    v69(v131, v42, v5);
    uint64_t v70 = *(void (**)(char *, uint64_t))(v141 + 8);
    uint64_t v123 = v66;
    v70(v42, v66);
    uint64_t v71 = v49;
    if (((*((uint64_t (**)(uint64_t, char *, uint64_t, char *))v21 + 2))(v49, v67, v5, v21) & 1) != 0)
    {
      (*(void (**)(char *, uint64_t))(v68 + 8))(v67, v5);
      v69(v139, (char *)v49, v5);
    }

    else
    {
      (*(void (**)(char *, char *, uint64_t))(v68 + 32))(v139, v67, v5);
    }

    unint64_t v73 = v133;
    uint64_t v72 = v134;
    if (__OFSUB__(v140, 1LL))
    {
      __break(1u);
    }

    else
    {
      uint64_t v74 = v128;
      char v75 = (void (*)(char *, uint64_t, uint64_t))v69;
      uint64_t v76 = v123;
      ContiguousArray.subscript.getter(v140 - 1, *v135, v123, v128);
      v75(v73, v74 + *(int *)(v76 + 36), v5);
      v70((char *)v74, v76);
      uint64_t v77 = v71 + *(int *)(v76 + 36);
      if (((*((uint64_t (**)(uint64_t, char *, uint64_t, char *))v21 + 4))(v77, v73, v5, v21) & 1) != 0)
      {
        (*(void (**)(char *, uint64_t))(v68 + 8))(v73, v5);
        uint64_t v78 = v129;
        v75(v129, v77, v5);
      }

      else
      {
        uint64_t v78 = v129;
        (*(void (**)(char *, char *, uint64_t))(v68 + 32))(v129, v73, v5);
      }

      unint64_t v79 = (void (*)(char *, char *, uint64_t))v75;
      char v80 = v139;
      v79(v72, v139, v5);
      uint64_t v81 = v130;
      v79(v130, v78, v5);
      if (((*((uint64_t (**)(char *, char *, uint64_t, char *))v21 + 3))(v72, v81, v5, v21) & 1) != 0)
      {
        uint64_t v133 = v21;
        int8x16_t v134 = (char *)v70;
        unint64_t v82 = v72;
        uint64_t v83 = *(void (**)(char *, uint64_t))(v68 + 8);
        v83(v81, v5);
        v83(v82, v5);
        char v84 = TupleTypeMetadata2;
        uint64_t v85 = v68;
        uint64_t v86 = v125;
        uint64_t v87 = &v125[*((int *)TupleTypeMetadata2 + 12)];
        uint64_t v88 = *(void (**)(char *, char *, uint64_t))(v85 + 32);
        v88(v125, v80, v5);
        v88(v87, v78, v5);
        unint64_t v89 = v127;
        uint64_t v90 = &v127[*((int *)v84 + 12)];
        v79(v127, v86, v5);
        v79(v90, v87, v5);
        uint64_t v91 = v118;
        v88(v118, v89, v5);
        v83(v90, v5);
        unint64_t v92 = &v89[*((int *)v84 + 12)];
        uint64_t v93 = v86;
        uint64_t v94 = v141;
        v88(v89, v93, v5);
        v88(v92, v87, v5);
        uint64_t v95 = v123;
        v88(&v91[*(int *)(v123 + 36)], v92, v5);
        v83(v89, v5);
        uint64_t v96 = *(uint64_t (**)(char *, char *, uint64_t))(v94 + 32);
        unint64_t v97 = v136;
        char v98 = v91;
        uint64_t v99 = v95;
        uint64_t result = v96(v136, v98, v95);
        unint64_t v101 = v119;
        unint64_t v102 = v140 - v119;
        if (__OFSUB__(v140, v119))
        {
          __break(1u);
          return result;
        }

        unint64_t v103 = v124;
        (*(void (**)(char *, char *, uint64_t))(v94 + 16))(v124, v97, v99);
        if (v102 == 1)
        {
          uint64_t v104 = v120;
          ContiguousArray.subscript.getter(v101, *v135, v99, v120);
          uint64_t v105 = *((void *)v133 + 1);
          uint64_t v106 = v103;
          uint64_t v141 = *(void *)(v105 + 8);
          char v107 = ((uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v141)(v103, v104, v5, v105);
          unint64_t v103 = v122;
          v96(v122, v106, v99);
          uint64_t v108 = v121;
          v96(v121, (char *)v104, v99);
          if ((v107 & 1) != 0)
          {
            char v109 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v141)( &v103[*(int *)(v99 + 36)],  &v108[*(int *)(v99 + 36)],  v5,  v105);
            unint64_t v110 = (void (*)(char *, uint64_t))v134;
            ((void (*)(char *, uint64_t))v134)(v108, v99);
            v110(v103, v99);
            unint64_t v112 = v137;
            uint64_t v111 = v138;
            unint64_t v97 = v136;
            if ((v109 & 1) != 0)
            {
              v110(v136, v99);
              return 0LL;
            }

            goto LABEL_19;
          }

          ((void (*)(char *, uint64_t))v134)(v108, v99);
          unint64_t v97 = v136;
          unint64_t v112 = v137;
        }

        else
        {
          unint64_t v112 = v137;
        }

        ((void (*)(char *, uint64_t))v134)(v103, v99);
        uint64_t v111 = v138;
LABEL_19:
        v96(v112, v97, v99);
        uint64_t v115 = type metadata accessor for ContiguousArray(0LL, v99, v113, v114);
        uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v111, v116);
        uint64_t v61 = v101;
        uint64_t v62 = v140;
        uint64_t v63 = (uint64_t)v112;
        uint64_t v64 = v115;
        uint64_t v65 = v111;
        goto LABEL_20;
      }
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v53 = v141;
  (*(void (**)(char *, uint64_t, uint64_t))(v141 + 16))(v44, v49, v23);
  ContiguousArray._checkIndex(_:)(v50);
  uint64_t v54 = v137;
  (*(void (**)(char *, char *, uint64_t))(v53 + 32))(v137, v44, v23);
  uint64_t v57 = type metadata accessor for ContiguousArray(0LL, v23, v55, v56);
  uint64_t v58 = v138;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v138, v59);
  uint64_t v61 = v50;
  uint64_t v62 = v50;
  uint64_t v63 = (uint64_t)v54;
  uint64_t v64 = v57;
  uint64_t v65 = v58;
LABEL_20:
  ContiguousArray.replaceSubrange<A>(_:with:)(v61, v62, v63, v64, v65, WitnessTable);
  return 1LL;
}

void RangeSet.remove(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = type metadata accessor for Range(0LL, v5, v6, a4);
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 + 8) + 8LL))( a1,  a1 + *(int *)(v7 + 36),  v5) & 1) == 0)
  {
    uint64_t v9 = type metadata accessor for RangeSet.Ranges(0LL, v5, v6, v8);
    RangeSet.Ranges._remove(contentsOf:)(a1, v9, v10, v11);
  }

void RangeSet.Ranges._remove(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(a2 + 24);
  uint64_t v9 = type metadata accessor for Range((const char *)0xFF, v7, v8, a4);
  uint64_t v202 = type metadata accessor for _Pair(0LL, v9, v10, v11);
  MEMORY[0x1895F8858](v202);
  uint64_t v201 = (char *)&v193 - v12;
  uint64_t v227 = type metadata accessor for CollectionOfOne(0LL, v9, v13, v14);
  MEMORY[0x1895F8858](v227);
  uint64_t v226 = (char *)&v193 - v15;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v16 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  Swift::String::Index v230 = (char *)&v193 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  Swift::String::Index v233 = (char *)&v193 - v19;
  uint64_t v234 = *(void *)(v9 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v209 = (uint64_t)&v193 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  unint64_t v200 = (char *)&v193 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v223 = (uint64_t)&v193 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v225 = (char *)&v193 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v222 = (uint64_t)&v193 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  unint64_t v204 = (char *)&v193 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v221 = (uint64_t)&v193 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v203 = (char *)&v193 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  uint64_t v38 = (char *)&v193 - v37;
  uint64_t v39 = *(void *)(v7 - 8);
  uint64_t v40 = MEMORY[0x1895F8858](v36);
  unint64_t v207 = (char *)&v193 - ((v41 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  char v206 = (char *)&v193 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  unint64_t v208 = (char *)&v193 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  size_t v205 = (char *)&v193 - v47;
  uint64_t v48 = MEMORY[0x1895F8858](v46);
  uint64_t v219 = (char *)&v193 - v49;
  uint64_t v50 = MEMORY[0x1895F8858](v48);
  id v218 = (char *)&v193 - v51;
  uint64_t v52 = MEMORY[0x1895F8858](v50);
  uint64_t v220 = (char *)&v193 - v53;
  uint64_t v54 = MEMORY[0x1895F8858](v52);
  unint64_t v217 = (char *)&v193 - v55;
  uint64_t v56 = MEMORY[0x1895F8858](v54);
  unint64_t v215 = (char *)&v193 - v57;
  uint64_t v58 = MEMORY[0x1895F8858](v56);
  uint64_t v214 = (char *)&v193 - v59;
  uint64_t v60 = MEMORY[0x1895F8858](v58);
  unint64_t v216 = (char *)&v193 - v61;
  uint64_t v62 = MEMORY[0x1895F8858](v60);
  char v213 = (char *)&v193 - v63;
  uint64_t v64 = MEMORY[0x1895F8858](v62);
  unint64_t v211 = (char *)&v193 - v65;
  uint64_t v66 = MEMORY[0x1895F8858](v64);
  unint64_t v210 = (char *)&v193 - v67;
  uint64_t v68 = MEMORY[0x1895F8858](v66);
  unint64_t v212 = (char *)&v193 - v69;
  uint64_t v70 = MEMORY[0x1895F8858](v68);
  unint64_t v228 = (char *)&v193 - v71;
  uint64_t v72 = MEMORY[0x1895F8858](v70);
  uint16x8_t v237 = (char *)&v193 - v73;
  MEMORY[0x1895F8858](v72);
  char v75 = (char *)&v193 - v74;
  uint16x8_t v235 = (uint64_t *)v5;
  uint64_t v76 = *v5;
  swift_retain(v76, v77, v78, v79);
  char v80 = (char *)a1;
  uint64_t v236 = v8;
  unint64_t v81 = specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(a1, v76, 0, v7, v8);
  uint64_t v83 = v82;
  swift_release((uint64_t)v76);
  if (v81 != v83)
  {
    char v84 = *(void (**)(void))(v39 + 16);
    uint64_t v232 = v83;
    uint64x2_t v229 = v80;
    ((void (*)(char *, char *, uint64_t))v84)(v75, v80, v7);
    ContiguousArray.subscript.getter(v81, (uint64_t)v76, v9, (uint64_t)v38);
    uint64_t v85 = v237;
    ((void (*)(char *, char *, uint64_t))v84)(v237, v38, v7);
    unint64_t v199 = *(void (**)(char *, uint64_t))(v234 + 8);
    v199(v38, v9);
    uint64_t v86 = v236;
    int v197 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v236 + 40))(v75, v85, v7, v236);
    uint64_t v195 = v39;
    uint64_t v87 = *(void (**)(char *, uint64_t))(v39 + 8);
    v87(v85, v7);
    v87(v75, v7);
    uint64_t v88 = &v229[*(int *)(v9 + 36)];
    char v198 = v84;
    ((void (*)(char *, char *, uint64_t))v84)(v75, v88, v7);
    if (__OFSUB__(v232, 1LL))
    {
      __break(1u);
      goto LABEL_19;
    }

    unint64_t v193 = v88;
    unint64_t v224 = v81;
    unint64_t v89 = v235;
    uint64_t v90 = *v235;
    unint64_t v194 = v232 - 1;
    ContiguousArray.subscript.getter(v232 - 1, v90, v9, (uint64_t)v38);
    uint64_t v91 = v237;
    unint64_t v92 = v198;
    ((void (*)(char *, char *, uint64_t))v198)(v237, &v38[*(int *)(v9 + 36)], v7);
    unint64_t v196 = v38;
    uint64_t v93 = v9;
    uint64_t v94 = v9;
    uint64_t v95 = (void (*)(uint64_t, uint64_t))v199;
    v199(v38, v94);
    uint64_t v96 = v89;
    char v97 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v86 + 16))(v75, v91, v7, v86);
    v87(v91, v7);
    v87(v75, v7);
    unint64_t v100 = v87;
    if ((v197 & 1) != 0)
    {
      uint64_t v101 = *v96;
      unint64_t v102 = v233;
      if ((v97 & 1) != 0)
      {
        uint64_t v103 = v223;
        ContiguousArray.subscript.getter(v224, v101, v93, v223);
        uint64_t v104 = v217;
        v92();
        uint16x8_t v237 = (char *)v93;
        v95(v103, v93);
        uint64_t v105 = v220;
        ((void (*)(char *, char *, uint64_t))v92)(v220, v229, v7);
        uint64_t v106 = v218;
        ((void (*)(char *, char *, uint64_t))v92)(v218, v104, v7);
        char v107 = v219;
        ((void (*)(char *, char *, uint64_t))v92)(v219, v105, v7);
        uint64x2_t v229 = *(char **)(v236 + 24);
        char v108 = ((uint64_t (*)(char *, char *, uint64_t))v229)(v106, v107, v7);
        uint64_t v109 = v195;
        if ((v108 & 1) != 0)
        {
          v100(v107, v7);
          v100(v106, v7);
          unint64_t v110 = TupleTypeMetadata2;
          uint64_t v111 = v233;
          unint64_t v112 = &v233[*((int *)TupleTypeMetadata2 + 12)];
          uint64_t v113 = *(void (**)(char *, char *, uint64_t))(v109 + 32);
          v113(v233, v104, v7);
          v113(v112, v105, v7);
          uint64_t v114 = v230;
          uint64_t v115 = &v230[*((int *)v110 + 12)];
          ((void (*)(char *, char *, uint64_t))v92)(v230, v111, v7);
          ((void (*)(char *, char *, uint64_t))v92)(v115, v112, v7);
          uint64_t v116 = v196;
          v113(v196, v114, v7);
          v100(v115, v7);
          uint64_t v117 = &v114[*((int *)v110 + 12)];
          v113(v114, v111, v7);
          v113(v117, v112, v7);
          uint64_t v118 = (uint64_t)v237;
          v113(&v116[*((int *)v237 + 9)], v117, v7);
          v100(v114, v7);
          uint64_t v234 = *(void *)(v234 + 32);
          ((void (*)(char *, char *, uint64_t))v234)(v225, v116, v118);
          unint64_t v119 = v205;
          ((void (*)(char *, char *, uint64_t))v92)(v205, v193, v7);
          uint64_t v120 = v209;
          ContiguousArray.subscript.getter(v194, *v235, v118, v209);
          uint64_t v121 = v208;
          ((void (*)(char *, uint64_t, uint64_t))v92)(v208, v120 + *(int *)(v118 + 36), v7);
          v199((char *)v120, v118);
          uint64_t v122 = v206;
          ((void (*)(char *, char *, uint64_t))v92)(v206, v119, v7);
          uint64_t v123 = v207;
          ((void (*)(char *, char *, uint64_t))v92)(v207, v121, v7);
          if ((((uint64_t (*)(char *, char *, uint64_t, uint64_t))v229)(v122, v123, v7, v236) & 1) != 0)
          {
            v100(v123, v7);
            v100(v122, v7);
            uint64_t v124 = TupleTypeMetadata2;
            uint64_t v125 = v233;
            unint64_t v126 = &v233[*((int *)TupleTypeMetadata2 + 12)];
            v113(v233, v119, v7);
            v113(v126, v121, v7);
            unint64_t v127 = &v114[*((int *)v124 + 12)];
            ((void (*)(char *, char *, uint64_t))v92)(v114, v125, v7);
            ((void (*)(char *, char *, uint64_t))v92)(v127, v126, v7);
            uint64_t v128 = v196;
            v113(v196, v114, v7);
            v100(v127, v7);
            uint64_t v129 = &v114[*((int *)v124 + 12)];
            v113(v114, v125, v7);
            v113(v129, v126, v7);
            uint64_t v130 = (uint64_t)v237;
            v113(&v128[*((int *)v237 + 9)], v129, v7);
            v100(v114, v7);
            uint64_t v131 = v200;
            uint64_t v132 = (void (*)(char *, char *, uint64_t))v234;
            ((void (*)(char *, char *, uint64_t))v234)(v200, v128, v130);
            uint64_t v133 = v201;
            v132(v201, v225, v130);
            int8x16_t v134 = swift_getTupleTypeMetadata2(0LL, v130, v130, "first second ", 0LL);
            v132(&v133[*((int *)v134 + 12)], v131, v130);
            uint64_t v138 = type metadata accessor for ContiguousArray(0LL, v130, v135, v136);
            Swift::String::Index v139 = &protocol conformance descriptor for _Pair<A>;
            uint64_t v140 = v202;
LABEL_14:
            uint64_t WitnessTable = swift_getWitnessTable(v139, v140, v137);
            uint64_t v183 = v224;
            uint64_t v184 = v232;
            uint64_t v185 = (uint64_t)v133;
            uint64_t v186 = v138;
            uint64_t v187 = v140;
LABEL_16:
            ContiguousArray.replaceSubrange<A>(_:with:)(v183, v184, v185, v186, v187, WitnessTable);
            return;
          }
        }

uint64_t static RangeSet.== infix(_:_:)(unint64_t **a1, unint64_t **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v8 = type metadata accessor for Range(0LL, a3, a4, a4);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v10 = MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v49 - v11;
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v22 = *a1;
  uint64_t v23 = *a2;
  unint64_t v24 = v22[2];
  if (v24 != (*a2)[2]) {
    return 0LL;
  }
  uint64_t v61 = (char *)&v49 - v18;
  if (!v24 || v22 == v23) {
    return 1LL;
  }
  uint64_t v25 = v14;
  uint64_t v53 = a3;
  uint64_t v54 = v21;
  uint64_t v59 = v20;
  unint64_t v26 = (*(unsigned __int8 *)(v20 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v20 + 80);
  uint64_t v57 = v19;
  uint64_t v58 = (char *)v22 + v26;
  uint64_t v52 = (char *)v23 + v26;
  swift_retain(v22, v15, v16, v17);
  swift_retain(v23, v27, v28, v29);
  unint64_t v30 = 0LL;
  unint64_t v50 = v24;
  uint64_t v51 = v4;
  uint64_t v55 = v22;
  uint64_t v56 = v23;
  do
  {
    BOOL v60 = v24 == v30;
    if (v24 == v30) {
      break;
    }
    if (v30 >= v22[2]
      || (uint64_t v31 = v59,
          unint64_t v32 = *(void *)(v59 + 72) * v30,
          uint64_t v33 = *(void (**)(char *, char *, uint64_t))(v59 + 16),
          uint64_t v34 = v61,
          v33(v61, &v58[v32], v25),
          v30 >= v23[2]))
    {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }

    uint64_t v35 = v54;
    v33(v54, &v52[v32], v25);
    uint64_t v36 = *(void *)(v4 + 8);
    uint64_t v37 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v36 + 8);
    uint64_t v38 = v34;
    uint64_t v39 = v34;
    uint64_t v40 = v53;
    int v62 = v37(v38, (uint64_t)v35, v53, v36);
    uint64_t v41 = *(void (**)(char *, char *, uint64_t))(v31 + 32);
    v41(v12, v39, v25);
    uint64_t v42 = v31;
    uint64_t v43 = v12;
    uint64_t v44 = v57;
    v41(v57, v35, v25);
    if ((v62 & 1) == 0)
    {
      uint64_t v48 = *(void (**)(uint64_t, uint64_t))(v42 + 8);
      v48((uint64_t)v44, v25);
      v48((uint64_t)v43, v25);
      uint64_t v22 = v55;
      uint64_t v23 = v56;
      break;
    }

    char v45 = v37(&v43[*(int *)(v25 + 36)], (uint64_t)&v44[*(int *)(v25 + 36)], v40, v36);
    uint64_t v46 = *(void (**)(uint64_t, uint64_t))(v42 + 8);
    v46((uint64_t)v44, v25);
    v46((uint64_t)v43, v25);
    ++v30;
    unint64_t v24 = v50;
    uint64_t v4 = v51;
    uint64_t v12 = v43;
    uint64_t v22 = v55;
    uint64_t v23 = v56;
  }

  while ((v45 & 1) != 0);
  swift_release((uint64_t)v22);
  swift_release((uint64_t)v23);
  return v60;
}

BOOL static RangeSet.Ranges.== infix(_:_:)(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v8 = type metadata accessor for Range(0LL, a3, a4, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v39 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v39 - v16;
  uint64_t v20 = *a1;
  uint64_t v21 = *a2;
  uint64_t v22 = *(void *)(*a1 + 16);
  if (v22 == *(void *)(v21 + 16))
  {
    if (!v22 || v20 == v21)
    {
      return 1;
    }

    else
    {
      uint64_t v46 = v18;
      uint64_t v47 = v17;
      unint64_t v23 = 0LL;
      unint64_t v24 = (*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80);
      uint64_t v48 = a3;
      uint64_t v49 = v20 + v24;
      uint64_t v44 = v4;
      uint64_t v45 = v21 + v24;
      uint64_t v25 = v15;
      uint64_t v42 = v20;
      uint64_t v43 = (char *)&v39 - v16;
      uint64_t v40 = v22;
      uint64_t v41 = v21;
      do
      {
        BOOL v50 = v22 == v23;
        if (v22 == v23) {
          break;
        }
        if (v23 >= *(void *)(v20 + 16)
          || (uint64_t v26 = *(void *)(v9 + 72) * v23,
              uint64_t v27 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16),
              v27(v19, v49 + v26, v25),
              v23 >= *(void *)(v21 + 16)))
        {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }

        uint64_t v28 = v46;
        v27(v46, v45 + v26, v25);
        uint64_t v29 = *(void *)(v4 + 8);
        unint64_t v30 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 8);
        uint64_t v31 = v48;
        int v51 = v30(v19, (uint64_t)v28, v48, v29);
        unint64_t v32 = *(void (**)(uint64_t, char *, uint64_t))(v9 + 32);
        uint64_t v33 = v19;
        uint64_t v34 = v47;
        v32((uint64_t)v47, v33, v25);
        v32((uint64_t)v12, v28, v25);
        if ((v51 & 1) == 0)
        {
          uint64_t v38 = *(void (**)(char *, uint64_t))(v9 + 8);
          v38(v12, v25);
          v38(v34, v25);
          return 0;
        }

        char v35 = v30(&v34[*(int *)(v25 + 36)], (uint64_t)&v12[*(int *)(v25 + 36)], v31, v29);
        uint64_t v36 = *(void (**)(char *, uint64_t))(v9 + 8);
        v36(v12, v25);
        v36(v34, v25);
        ++v23;
        uint64_t v19 = v43;
        uint64_t v4 = v44;
        uint64_t v21 = v41;
        uint64_t v20 = v42;
        uint64_t v22 = v40;
      }

      while ((v35 & 1) != 0);
    }
  }

  else
  {
    return 0;
  }

  return v50;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance RangeSet<A>( unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return static RangeSet.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t RangeSet<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = type metadata accessor for Range(0LL, v7, *(void *)(a2 + 24), a4);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v21 - v10;
  uint64_t v12 = *v4;
  Swift::UInt v13 = (*v4)[2];
  Hasher._combine(_:)(v13);
  swift_retain(v12, v14, v15, v16);
  Swift::UInt v22 = v13;
  if (v13)
  {
    unint64_t v17 = 0LL;
    do
    {
      if (v17 >= v12[2]) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      unint64_t v18 = v17 + 1;
      (*(void (**)(char *, unint64_t, uint64_t))(v9 + 16))( v11,  (unint64_t)v12 + ((*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
      + *(void *)(v9 + 72) * v17,
        v8);
      uint64_t v19 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24);
      v19(a1, v7, a3);
      v19(a1, v7, a3);
      (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
      unint64_t v17 = v18;
    }

    while (v22 != v18);
  }

  return swift_release((uint64_t)v12);
}

Swift::Int RangeSet<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *v4;
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  RangeSet<>.hash(into:)((uint64_t)v6, a1, a2, a4);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> RangeSet<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeSet<>.hashValue.getter(a1, *(void *)(a2 - 8), a3, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> RangeSet<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeSet<>.hash(into:)(a1, a2, *(void *)(a3 - 8), a4);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> RangeSet<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))RangeSet<>.hash(into:));
}

uint64_t RangeSet.init<A, B>(_:within:)@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, const char *a6@<X5>, uint64_t a7@<X6>, __objc2_class ***a8@<X8>)
{
  uint64_t v91 = a2;
  unint64_t v82 = a1;
  char v75 = a8;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a3, a3, "lower upper ", 0LL);
  uint64_t v13 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v86 = (char *)&v74 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v87 = (char *)&v74 - v15;
  uint64_t v89 = a7;
  uint64_t v92 = a5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  a5,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v18 = (uint64_t *)type metadata accessor for Range(0LL, a3, AssociatedConformanceWitness, v17);
  uint64_t v85 = *(v18 - 1);
  uint64_t v19 = MEMORY[0x1895F8858](v18);
  char v84 = (char *)&v74 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v83 = (char *)&v74 - v22;
  unint64_t v23 = *(void **)(a3 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v21);
  uint64_t v26 = (char *)&v74 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  uint64_t v96 = (char *)&v74 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v31 = (char *)&v74 - v30;
  MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v74 - v32;
  uint64_t v36 = type metadata accessor for Optional(0LL, a3, v34, v35);
  MEMORY[0x1895F8858](v36);
  uint64_t v38 = (char *)&v74 - v37;
  uint64_t v95 = (uint64_t)a6;
  uint64_t v39 = a6;
  uint64_t v40 = a4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v39,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v74 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v94 = (char *)&v74 - v41;
  _swift_isClassOrObjCExistentialType((uint64_t)v18, v18);
  uint64_t v90 = v18;
  uint64_t v42 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v18);
  if (v42)
  {
    uint64_t v45 = (__objc2_class **)v42;
  }

  else
  {
    uint64_t v98 = &_swiftEmptyArrayStorage;
    uint64_t v46 = type metadata accessor for Array(0LL, (uint64_t)v90, v43, v44);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v46, v47);
    uint64_t v45 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v98, v46, WitnessTable);
  }

  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v98 = v45;
  uint64_t v49 = v95;
  (*(void (**)(uint64_t, uint64_t))(v95 + 32))(v40, v95);
  uint64_t v50 = v40;
  unint64_t v51 = AssociatedTypeWitness;
  unint64_t v52 = swift_getAssociatedConformanceWitness( v49,  v50,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v81 = *(void (**)(unint64_t))(v52 + 16);
  unint64_t v82 = v52;
  v81(v51);
  char v80 = (unsigned int (*)(char *, uint64_t, uint64_t))v23[6];
  if (v80(v38, 1LL, a3) != 1)
  {
    uint64_t v95 = v23[4];
    uint64_t v78 = v23;
    unint64_t v79 = AssociatedConformanceWitness;
    uint64_t v77 = v26;
    char v97 = v33;
    uint64_t v76 = v38;
    uint64_t v53 = (void (*)(char *, char *, uint64_t))v95;
    do
    {
      ((void (*)(char *, char *, uint64_t))v95)(v33, v38, a3);
      (*(void (**)(char *, uint64_t))(v89 + 184))(v33, v92);
      uint64_t v54 = (void (*)(char *, char *, uint64_t))v23[2];
      uint64_t v55 = v96;
      v54(v96, v33, a3);
      v54(v26, v31, a3);
      if (((*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v55,  v26,  a3,  AssociatedConformanceWitness) & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }
      uint64_t v56 = (void (*)(char *, uint64_t))v23[1];
      v56(v26, a3);
      v56(v96, a3);
      uint64_t v58 = v87;
      uint64_t v57 = TupleTypeMetadata2;
      uint64_t v59 = &v87[*((int *)TupleTypeMetadata2 + 12)];
      v54(v87, v97, a3);
      v53(v59, v31, a3);
      BOOL v60 = v86;
      uint64_t v61 = &v86[*((int *)v57 + 12)];
      v54(v86, v58, a3);
      v54(v61, v59, a3);
      int v62 = v84;
      v53(v84, v60, a3);
      v56(v61, a3);
      uint64_t v63 = *((int *)v57 + 12);
      uint64_t v64 = (uint64_t)v90;
      uint64_t v65 = &v60[v63];
      v53(v60, v58, a3);
      v53(v65, v59, a3);
      uint64_t v66 = v65;
      unint64_t AssociatedConformanceWitness = v79;
      v53(&v62[*(int *)(v64 + 36)], v66, a3);
      v56(v60, a3);
      uint64_t v67 = v85;
      uint64_t v68 = (uint64_t)v83;
      (*(void (**)(char *, char *, uint64_t))(v85 + 32))(v83, v62, v64);
      uint64_t v70 = type metadata accessor for RangeSet.Ranges(0LL, a3, AssociatedConformanceWitness, v69);
      RangeSet.Ranges._insert(contentsOf:)(v68, v70);
      uint64_t v71 = *(void (**)(uint64_t, uint64_t))(v67 + 8);
      unint64_t v23 = v78;
      uint64_t v72 = v68;
      uint64_t v26 = v77;
      v71(v72, v64);
      v56(v97, a3);
      uint64_t v33 = v97;
      uint64_t v38 = v76;
      ((void (*)(unint64_t, unint64_t))v81)(AssociatedTypeWitness, v82);
    }

    while (v80(v38, 1LL, a3) != 1);
  }

  (*(void (**)(uint64_t))(*(void *)(v92 - 8) + 8LL))(v91);
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v74 + 8))(v94, AssociatedTypeWitness);
  *char v75 = v98;
  return result;
}

uint64_t RangeSet.insert<A>(_:within:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v54 = a2;
  uint64_t v55 = a4;
  uint64_t v8 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v8, v8, "lower upper ", 0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v47 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v50 = (char *)&v47 - v13;
  uint64_t v14 = *(void *)(v8 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v47 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v47 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v47 - v21;
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v25 = type metadata accessor for Range(0LL, v8, v23, v24);
  uint64_t v52 = *(void *)(v25 - 8);
  uint64_t v26 = MEMORY[0x1895F8858](v25);
  uint64_t v49 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  unint64_t v51 = (char *)&v47 - v28;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a5 + 184))(a1, v55, a5);
  uint64_t v48 = v14;
  uint64_t v29 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  uint64_t v54 = a1;
  v29(v20, a1, v8);
  v29(v17, (uint64_t)v22, v8);
  uint64_t v30 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v23 + 24);
  uint64_t v55 = v23;
  if ((v30(v20, v17, v8, v23) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v47 = v25;
  uint64_t v31 = v22;
  uint64_t v32 = v48;
  uint64_t v33 = *(void (**)(char *, uint64_t))(v48 + 8);
  v33(v17, v8);
  v33(v20, v8);
  uint64_t v34 = TupleTypeMetadata2;
  uint64_t v35 = v50;
  uint64_t v36 = &v50[*((int *)TupleTypeMetadata2 + 12)];
  v29(v50, v54, v8);
  uint64_t v37 = *(void (**)(char *, char *, uint64_t))(v32 + 32);
  v37(v36, v31, v8);
  uint64_t v38 = &v11[*((int *)v34 + 12)];
  v29(v11, (uint64_t)v35, v8);
  v29(v38, (uint64_t)v36, v8);
  uint64_t v39 = v49;
  v37(v49, v11, v8);
  v33(v38, v8);
  uint64_t v40 = &v11[*((int *)v34 + 12)];
  v37(v11, v35, v8);
  v37(v40, v36, v8);
  uint64_t v41 = v47;
  v37(&v39[*(int *)(v47 + 36)], v40, v8);
  v33(v11, v8);
  uint64_t v42 = (uint64_t)v51;
  uint64_t v43 = v52;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v39, v41);
  uint64_t v45 = type metadata accessor for RangeSet.Ranges(0LL, v8, v55, v44);
  LOBYTE(v33) = RangeSet.Ranges._insert(contentsOf:)(v42, v45);
  (*(void (**)(uint64_t, uint64_t))(v43 + 8))(v42, v41);
  return v33 & 1;
}

uint64_t RangeSet.remove<A>(_:within:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v55 = a2;
  uint64_t v56 = a4;
  uint64_t v8 = *(void *)(a3 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v8, v8, "lower upper ", 0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v48 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v50 = (char *)&v48 - v13;
  uint64_t v14 = *(void **)(v8 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)&v48 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v48 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v48 - v21;
  uint64_t v23 = *(void *)(a3 + 24);
  uint64_t v25 = type metadata accessor for Range(0LL, v8, v23, v24);
  uint64_t v52 = *(void *)(v25 - 8);
  uint64_t v53 = v25;
  uint64_t v26 = MEMORY[0x1895F8858](v25);
  uint64_t v49 = (char *)&v48 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v26);
  unint64_t v51 = (char *)&v48 - v28;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a5 + 184))(a1, v56, a5);
  uint64_t v29 = (void (*)(char *, uint64_t, uint64_t))v14[2];
  uint64_t v55 = a1;
  v29(v20, a1, v8);
  v29(v17, (uint64_t)v22, v8);
  uint64_t v30 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v23 + 24);
  uint64_t v56 = v23;
  if ((v30(v20, v17, v8, v23) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v31 = (void (*)(char *, uint64_t))v14[1];
  v31(v17, v8);
  v31(v20, v8);
  uint64_t v32 = TupleTypeMetadata2;
  uint64_t v33 = v50;
  uint64_t v34 = &v50[*((int *)TupleTypeMetadata2 + 12)];
  v29(v50, v55, v8);
  uint64_t v35 = (void (*)(char *, char *, uint64_t))v14[4];
  v35(v34, v22, v8);
  uint64_t v36 = &v11[*((int *)v32 + 12)];
  v29(v11, (uint64_t)v33, v8);
  v29(v36, (uint64_t)v34, v8);
  uint64_t v37 = v49;
  v35(v49, v11, v8);
  v31(v36, v8);
  uint64_t v38 = &v11[*((int *)v32 + 12)];
  v35(v11, v33, v8);
  v35(v38, v34, v8);
  uint64_t v39 = v53;
  v35(&v37[*(int *)(v53 + 36)], v38, v8);
  v31(v11, v8);
  uint64_t v41 = (uint64_t)v51;
  uint64_t v40 = v52;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v37, v39);
  uint64_t v42 = v56;
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v56 + 8) + 8LL))( v41,  v41 + *(int *)(v39 + 36),  v8) & 1) == 0)
  {
    uint64_t v44 = type metadata accessor for RangeSet.Ranges(0LL, v8, v42, v43);
    RangeSet.Ranges._remove(contentsOf:)(v41, v44, v45, v46);
  }

  return (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 8))(v41, v39);
}

void RangeSet.Ranges._gaps(boundedBy:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v162 = a3;
  uint64_t v6 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v6, v6, "lower upper ", 0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unint64_t v161 = (char *)&v136 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  int8x16_t v159 = (char *)&v136 - v9;
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v12 = (uint64_t *)type metadata accessor for Range(0LL, v6, v10, v11);
  uint64_t v13 = *(v12 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v136 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v136 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  Swift::Int v158 = (char *)&v136 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  Swift::String::Index v153 = (char *)&v136 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v163 = (char *)&v136 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  Swift::Int v157 = (char *)&v136 - v27;
  uint64_t v28 = *(void *)(v6 - 8);
  uint64_t v29 = MEMORY[0x1895F8858](v26);
  char v150 = (char *)&v136 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  unint64_t v149 = (char *)&v136 - v32;
  uint64_t v33 = MEMORY[0x1895F8858](v31);
  unint64_t v151 = (char *)&v136 - v34;
  uint64_t v35 = MEMORY[0x1895F8858](v33);
  Swift::String::Index v154 = (char *)&v136 - v36;
  uint64_t v37 = MEMORY[0x1895F8858](v35);
  Swift::String::Index v156 = (char *)&v136 - v38;
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  Swift::String::Index v155 = (char *)&v136 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  uint64_t v166 = (char *)&v136 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  uint64_t v165 = (char *)&v136 - v44;
  MEMORY[0x1895F8858](v43);
  uint64_t v46 = (char *)&v136 - v45;
  uint64_t v47 = *v3;
  uint64_t v168 = a1;
  uint64_t v164 = v10;
  uint64_t v48 = specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(a1, v47, 1, v6, v10);
  if (v48 == v49)
  {
    uint64_t v50 = v162;
    (*(void (**)(char *, uint64_t, uint64_t *))(v13 + 16))(v16, v168, v12);
    uint64_t v53 = type metadata accessor for _ContiguousArrayStorage(0LL, (uint64_t)v12, v51, v52);
    uint64_t v54 = (__objc2_class **)swift_allocObject( v53,  ((*(unsigned __int8 *)(v13 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80))
                            + *(void *)(v13 + 72),
                              *(unsigned __int8 *)(v13 + 80) | 7LL);
    vtable = (uint64_t *)(*v54)[3].vtable;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)vtable, vtable);
    v54[2] = (__objc2_class *)1;
    v54[3] = (__objc2_class *)(isClassOrObjCExistentialType | 2LL);
    uint64_t v57 = *(unsigned __int8 *)(*(vtable - 1) + 80);
    (*(void (**)(uint64_t, char *, uint64_t *))(v13 + 32))((uint64_t)v54 + ((v57 + 32) & ~v57), v16, v12);
    uint64_t v58 = _ArrayBuffer.requestNativeBuffer()((unint64_t)v54, v12);
    if (v58)
    {
LABEL_5:
      uint64_t v65 = v58;
      goto LABEL_6;
    }

    unint64_t v170 = v54;
    uint64_t v61 = type metadata accessor for Array(0LL, (uint64_t)v12, v59, v60);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v61, v62);
    uint64_t v64 = &v170;
LABEL_4:
    uint64_t v58 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)v64, v61, WitnessTable);
    goto LABEL_5;
  }

  Swift::Int v66 = v48;
  uint64_t v141 = v19;
  Swift::Int v167 = v49;
  _swift_isClassOrObjCExistentialType((uint64_t)v12, v12);
  uint64_t v67 = *(unsigned __int8 *)(v13 + 80);
  unint64_t v170 = &_swiftEmptyArrayStorage;
  uint64_t v68 = *(void (**)(char *, uint64_t, uint64_t))(v28 + 16);
  v68(v46, v168, v6);
  ContiguousArray._checkIndex(_:)(v66);
  ContiguousArray._checkIndex(_:)(v167);
  Swift::Int v69 = v167;
  if (v167 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  unint64_t v152 = v46;
  uint64_t v70 = (uint64_t)v12;
  uint64_t v148 = v28;
  uint64_t v71 = (char *)v47 + ((v67 + 32) & ~v67);
  uint64_t v72 = v165;
  uint64_t v73 = v166;
  do
  {
    if (v66 >= v69) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
    }
    uint64_t v74 = *(void *)(v13 + 72);
    uint64_t v145 = v71;
    char v75 = v157;
    (*(void (**)(char *, char *, uint64_t))(v13 + 16))(v157, &v71[v74 * v66], v70);
    uint64_t v76 = *(void (**)(char *, char *, uint64_t))(v13 + 32);
    uint64_t v77 = v163;
    uint64_t v146 = v70;
    unint64_t v147 = v76;
    v76(v163, v75, v70);
    uint64_t v78 = v152;
    v68(v72, (uint64_t)v152, v6);
    v68(v73, (uint64_t)v77, v6);
    unint64_t v79 = v72;
    char v80 = v155;
    v68(v155, (uint64_t)v79, v6);
    unint64_t v81 = v156;
    v68(v156, (uint64_t)v73, v6);
    uint64_t v140 = *(uint64_t (**)(char *, char *, uint64_t))(v164 + 24);
    if ((v140(v80, v81, v6) & 1) == 0) {
      goto LABEL_23;
    }
    Swift::Int v142 = v66;
    uint64_t v144 = v13;
    uint64_t v82 = v148;
    uint64_t v83 = *(void (**)(char *, uint64_t))(v148 + 8);
    v83(v81, v6);
    v83(v80, v6);
    v83(v78, v6);
    char v84 = v159;
    uint64_t v85 = TupleTypeMetadata2;
    uint64_t v86 = &v159[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v87 = *(void (**)(char *, char *, uint64_t))(v82 + 32);
    v87(v159, v79, v6);
    uint64_t v88 = v86;
    v87(v86, v73, v6);
    uint64_t v89 = *((int *)v85 + 12);
    uint64_t v90 = v85;
    uint64_t v91 = (void (*)(char *, char *, uint64_t))v68;
    uint64_t v92 = v161;
    uint64_t v93 = &v161[v89];
    v91(v161, v84, v6);
    uint64_t v143 = v91;
    v91(v93, v88, v6);
    uint64_t v94 = v146;
    uint64_t v95 = v158;
    v87(v158, v92, v6);
    v83(v93, v6);
    uint64_t v96 = &v92[*((int *)v90 + 12)];
    v87(v92, v84, v6);
    v87(v96, v88, v6);
    char v97 = &v95[*(int *)(v94 + 36)];
    uint64_t v138 = v87;
    v87(v97, v96, v6);
    Swift::String::Index v139 = v83;
    v83(v92, v6);
    uint64_t v98 = (uint64_t)v153;
    v147(v153, v95, v94);
    uint64_t v99 = v98 + *(int *)(v94 + 36);
    unint64_t v100 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v164 + 8) + 8LL);
    uint64_t v137 = *(void *)(v164 + 8);
    uint64_t v136 = v100;
    if ((((uint64_t (*)(uint64_t, uint64_t, uint64_t))v100)(v98, v99, v6) & 1) != 0)
    {
      uint64_t v13 = v144;
      (*(void (**)(uint64_t, uint64_t))(v144 + 8))(v98, v94);
    }

    else
    {
      uint64_t v103 = type metadata accessor for Array(0LL, v94, v101, v102);
      Array.append(_:)(v98, v103);
      uint64_t v13 = v144;
    }

    uint64_t v104 = v154;
    Swift::Int v66 = v142 + 1;
    uint64_t v105 = v163;
    uint64_t v106 = (void (*)(char *, uint64_t, uint64_t))v143;
    v143(v152, &v163[*(int *)(v94 + 36)], v6);
    char v107 = *(void (**)(char *, uint64_t))(v13 + 8);
    char v108 = v105;
    uint64_t v68 = v106;
    uint64_t v70 = v94;
    v107(v108, v94);
    uint64_t v73 = v166;
    Swift::Int v69 = v167;
    uint64_t v72 = v165;
    uint64_t v71 = v145;
  }

  while (v167 != v66);
  uint64_t v109 = v152;
  v68(v104, (uint64_t)v152, v6);
  uint64_t v110 = v168 + *(int *)(v94 + 36);
  uint64_t v111 = v151;
  v68(v151, v110, v6);
  unint64_t v112 = (void (*)(char *, char *, uint64_t))v68;
  uint64_t v113 = v149;
  v68(v149, (uint64_t)v104, v6);
  uint64_t v114 = v150;
  v68(v150, (uint64_t)v111, v6);
  if ((((uint64_t (*)(char *, char *, uint64_t, uint64_t))v140)(v113, v114, v6, v164) & 1) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v115 = v139;
  v139(v114, v6);
  v115(v113, v6);
  v115(v109, v6);
  uint64_t v116 = v159;
  uint64_t v117 = TupleTypeMetadata2;
  uint64_t v118 = &v159[*((int *)TupleTypeMetadata2 + 12)];
  unint64_t v119 = v138;
  v138(v159, v104, v6);
  v119(v118, v111, v6);
  uint64_t v120 = v161;
  uint64_t v121 = &v161[*((int *)v117 + 12)];
  v112(v161, v116, v6);
  v112(v121, v118, v6);
  uint64_t v122 = v158;
  v119(v158, v120, v6);
  v115(v121, v6);
  uint64_t v123 = &v120[*((int *)v117 + 12)];
  v119(v120, v116, v6);
  v119(v123, v118, v6);
  uint64_t v124 = v146;
  v119(&v122[*(int *)(v146 + 36)], v123, v6);
  v115(v120, v6);
  uint64_t v125 = (uint64_t)v141;
  v147(v141, v122, v124);
  if ((v136(v125, v125 + *(int *)(v124 + 36), v6, v137) & 1) != 0)
  {
    v107((char *)v125, v124);
  }

  else
  {
    uint64_t v131 = type metadata accessor for Array(0LL, v124, v126, v127);
    Array.append(_:)(v125, v131);
  }

  uint64_t v50 = v162;
  uint64_t v54 = v170;
  unint64_t v132 = swift_bridgeObjectRetain((unint64_t)v170, v128, v129, v130);
  uint64_t v65 = _ArrayBuffer.requestNativeBuffer()(v132, (uint64_t *)v124);
  swift_bridgeObjectRelease((uint64_t)v54);
  if (!v65)
  {
    int8x16_t v169 = v54;
    uint64_t v61 = type metadata accessor for Array(0LL, v124, v133, v134);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v61, v135);
    uint64_t v64 = &v169;
    goto LABEL_4;
  }

uint64_t RangeSet.formUnion(_:)(unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *v4;
  v9[0] = *a1;
  uint64_t v5 = v9[0];
  v9[1] = v6;
  uint64_t v7 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._union(_:)(v9, v7, &v10);
  swift_release((uint64_t)v6);
  uint64_t result = swift_release((uint64_t)v5);
  *uint64_t v4 = v10;
  return result;
}

uint64_t RangeSet.union(_:)@<X0>( unint64_t **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v7 = *v4;
  v10[0] = *a1;
  uint64_t v6 = v10[0];
  v10[1] = v7;
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  RangeSet.Ranges._union(_:)(v10, v8, &v11);
  swift_release((uint64_t)v7);
  uint64_t result = swift_release((uint64_t)v6);
  *a4 = v11;
  return result;
}

uint64_t RangeSet.formIntersection(_:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *v4;
  v8[0] = *a1;
  v8[1] = v5;
  uint64_t v6 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._intersection(_:)(v8, v6, &v9);
  uint64_t result = swift_release(v5);
  *uint64_t v4 = v9;
  return result;
}

uint64_t RangeSet.formSymmetricDifference(_:)(unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *v4;
  uint64_t v14 = *a1;
  uint64_t v6 = v14;
  uint64_t v15 = v7;
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._union(_:)(&v14, v8, &v16);
  uint64_t v9 = v16;
  uint64_t v14 = v6;
  uint64_t v15 = v7;
  RangeSet.Ranges._intersection(_:)((uint64_t *)&v14, v8, (uint64_t *)&v16);
  swift_release((uint64_t)v6);
  swift_release((uint64_t)v7);
  uint64_t v10 = v16;
  uint64_t v15 = v16;
  uint64_t v16 = v9;
  RangeSet.subtract(_:)(&v15, a2, v11, v12);
  uint64_t result = swift_release((uint64_t)v10);
  *uint64_t v4 = v16;
  return result;
}

uint64_t RangeSet.symmetricDifference(_:)@<X0>( unint64_t **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, unint64_t **a4@<X8>)
{
  uint64_t v8 = *v4;
  uint64_t v15 = *a1;
  uint64_t v7 = v15;
  uint64_t v16 = v8;
  uint64_t v9 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a3);
  RangeSet.Ranges._union(_:)(&v15, v9, &v17);
  uint64_t v10 = v17;
  uint64_t v15 = v7;
  uint64_t v16 = v8;
  RangeSet.Ranges._intersection(_:)((uint64_t *)&v15, v9, (uint64_t *)&v17);
  swift_release((uint64_t)v7);
  swift_release(v8);
  uint64_t v11 = v17;
  *a4 = v10;
  uint64_t v17 = v11;
  RangeSet.subtract(_:)(&v17, a2, v12, v13);
  return swift_release((uint64_t)v11);
}

uint64_t RangeSet.subtract(_:)(unint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v33 = *(void *)(a2 + 24);
  uint64_t v34 = v6;
  uint64_t v7 = type metadata accessor for Range(0LL, v6, v33, a4);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)v32 - v12;
  uint64_t v16 = type metadata accessor for Optional(0LL, v7, v14, v15);
  MEMORY[0x1895F8858](v16);
  uint64_t v18 = (char *)v32 - v17;
  uint64_t v19 = (uint64_t)*a1;
  unint64_t v20 = (*a1)[2];
  swift_retain(*a1, v21, v22, v23);
  if (v20)
  {
    v32[1] = v4;
    for (unint64_t i = 0LL; i != v20; ++i)
    {
      if (i >= v20) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      (*(void (**)(char *, unint64_t, uint64_t))(v8 + 16))( v13,  v19 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80))
      + *(void *)(v8 + 72) * i,
        v7);
      uint64_t v25 = *(void (**)(char *, char *, uint64_t))(v8 + 32);
      v25(v18, v13, v7);
      uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 56);
      v26(v18, 0LL, 1LL, v7);
      v25(v11, v18, v7);
      if (((*(uint64_t (**)(char *, char *))(*(void *)(v33 + 8) + 8LL))(v11, &v11[*(int *)(v7 + 36)]) & 1) == 0)
      {
        uint64_t v28 = type metadata accessor for RangeSet.Ranges(0LL, v34, v33, v27);
        RangeSet.Ranges._remove(contentsOf:)((uint64_t)v11, v28, v29, v30);
      }

      (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
      unint64_t v20 = *(void *)(v19 + 16);
    }
  }

  else
  {
    uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 56);
  }

  v26(v18, 1LL, 1LL, v7);
  return swift_release(v19);
}

void RangeSet.Ranges._union(_:)(unint64_t **a1@<X0>, uint64_t a2@<X1>, unint64_t **a3@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v7, v7, "lower upper ", 0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v146 = (char *)&v140 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v145 = (char *)&v140 - v10;
  uint64_t v168 = *(void *)(a2 + 24);
  uint64_t v12 = (uint64_t *)type metadata accessor for Range(0LL, v7, v168, v11);
  uint64_t v158 = *(v12 - 1);
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  unint64_t v152 = (char *)&v140 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v144 = (char *)&v140 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v163 = (char *)&v140 - v18;
  Swift::String::Index v153 = *(void **)(v7 - 8);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v149 = (char *)&v140 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v148 = (char *)&v140 - v22;
  uint64_t v23 = MEMORY[0x1895F8858](v21);
  Swift::String::Index v154 = (char *)&v140 - v24;
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  char v150 = (char *)&v140 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v151 = (char *)&v140 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v165 = (char *)&v140 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v166 = (char *)&v140 - v32;
  MEMORY[0x1895F8858](v31);
  uint64_t v143 = (char *)&v140 - v36;
  uint64_t v37 = *a1;
  uint64_t v162 = *v3;
  if (!v37[2])
  {
    uint64_t v106 = v162;
    *a3 = v162;
LABEL_42:
    swift_retain(v106, v33, v34, v35);
    return;
  }

  if (!v162[2])
  {
    *a3 = v37;
    uint64_t v106 = v37;
    goto LABEL_42;
  }

  uint64_t v38 = v162;
  swift_retain(v162, v33, v34, v35);
  swift_retain(v37, v39, v40, v41);
  _swift_isClassOrObjCExistentialType((uint64_t)v12, v12);
  uint64_t v42 = *(unsigned __int8 *)(v158 + 80);
  uint64_t v172 = &_swiftEmptyArrayStorage;
  uint64_t v43 = v38[2];
  unint64_t v161 = v12;
  uint64_t v141 = a3;
  if (v43)
  {
    unint64_t v44 = v37[2];
    if (v44)
    {
      unint64_t v169 = 0LL;
      unint64_t v45 = 0LL;
      uint64_t v46 = (v42 + 32) & ~v42;
      Swift::Int v142 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v168 + 16);
      uint64_t v47 = v151;
      uint64_t v157 = v46;
      do
      {
        if (v169 >= v44) {
          goto LABEL_53;
        }
        uint64_t v48 = *(void *)(v158 + 72);
        Swift::Int v49 = (void (*)(char *, char *, uint64_t))v153[2];
        v49(v143, (char *)v37 + v46 + v48 * v169, v7);
        if ((v45 & 0x8000000000000000LL) != 0 || v45 >= v162[2]) {
          goto LABEL_53;
        }
        uint64_t v50 = v162;
        uint64_t v51 = v166;
        int64_t v159 = v45;
        size_t v160 = (void (*)(char *, uint64_t, uint64_t))v49;
        v49(v166, (char *)v162 + v46 + v48 * v45, v7);
        uint64_t v52 = v48;
        uint64_t v53 = v143;
        char v54 = v142(v143, v51, v7, v168);
        uint64_t v55 = (void (*)(char *, uint64_t))v153[1];
        v55(v51, v7);
        Swift::Int v167 = v55;
        v55(v53, v7);
        BOOL v56 = (v54 & 1) == 0;
        if ((v54 & 1) != 0) {
          unint64_t v57 = v159;
        }
        else {
          unint64_t v57 = v169;
        }
        if (v56) {
          unint64_t v58 = v159;
        }
        else {
          unint64_t v58 = v169;
        }
        if (v56) {
          uint64_t v59 = v37;
        }
        else {
          uint64_t v59 = v50;
        }
        if (!v56) {
          uint64_t v50 = v37;
        }
        uint64_t v162 = v50;
        if (v58 >= v50[2]) {
LABEL_53:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        uint64_t v60 = (char *)v162 + v46 + v58 * v52;
        uint64_t v61 = (uint64_t)v161;
        (*(void (**)(char *, char *, uint64_t *))(v158 + 16))(v163, v60, v161);
        int64_t v62 = v58 + 1;
        BOOL v63 = v57 >= v59[2];
        uint64_t v156 = v52;
        uint64_t v64 = v59;
        int64_t v159 = v62;
        if (v63)
        {
          unint64_t v169 = v57;
          uint64_t v37 = v59;
          uint64_t v46 = v157;
        }

        else
        {
          uint64_t v65 = &v163[*(int *)(v61 + 36)];
          unint64_t v169 = v57;
          uint64_t v46 = v157;
          Swift::Int v66 = v160;
          Swift::String::Index v155 = v65;
          v160(v165, (uint64_t)v65, v7);
          while (1)
          {
            if ((v169 & 0x8000000000000000LL) != 0 || v169 >= v64[2]) {
              goto LABEL_53;
            }
            uint64_t v67 = v7;
            uint64_t v68 = v47;
            unint64_t v69 = v169;
            uint64_t v70 = (uint64_t)v64 + v46 + v169 * v156;
            uint64_t v71 = v166;
            v66(v166, v70, v67);
            uint64_t v72 = *(uint64_t (**)(char *, char *, uint64_t))(v168 + 32);
            uint64_t v73 = v165;
            LODWORD(v164) = v72(v165, v71, v67);
            uint64_t v74 = v71;
            char v75 = v167;
            v167(v74, v67);
            v75(v73, v67);
            uint64_t v47 = v68;
            v66(v68, (uint64_t)v65, v67);
            if (v69 >= v64[2]) {
              goto LABEL_53;
            }
            uint64_t v76 = v64;
            uint64_t v7 = v67;
            uint64_t v77 = v70 + *((int *)v161 + 9);
            uint64_t v78 = v166;
            v66(v166, v77, v67);
            char v79 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v72)(v47, v78, v67, v168);
            char v80 = v167;
            v167(v78, v7);
            v80(v47, v7);
            if ((v79 & 1) != 0)
            {
              ++v169;
              uint64_t v64 = v76;
              uint64_t v37 = v76;
            }

            else
            {
              unint64_t v81 = v150;
              v66(v150, (uint64_t)v163, v7);
              if (v169 >= v76[2]) {
                goto LABEL_53;
              }
              uint64_t v82 = v154;
              v66(v154, v77, v7);
              uint64_t v83 = v148;
              v66(v148, (uint64_t)v81, v7);
              char v84 = v149;
              v66(v149, (uint64_t)v82, v7);
              uint64_t v85 = v81;
              if (((*(uint64_t (**)(char *, char *, uint64_t))(v168 + 24))(v83, v84, v7) & 1) == 0) {
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
              }
              uint64_t v86 = v167;
              v167(v84, v7);
              v86(v83, v7);
              uint64_t v87 = *(void (**)(char *, uint64_t *))(v158 + 8);
              uint64_t v164 = v76;
              uint64_t v88 = (uint64_t)v161;
              v87(v163, v161);
              uint64_t v89 = TupleTypeMetadata2;
              uint64_t v90 = v145;
              uint64_t v91 = &v145[*((int *)TupleTypeMetadata2 + 12)];
              uint64_t v92 = (void (*)(char *, char *, uint64_t))v153[4];
              v92(v145, v85, v7);
              v92(v91, v154, v7);
              uint64_t v93 = v146;
              uint64_t v94 = &v146[*((int *)v89 + 12)];
              v160(v146, (uint64_t)v90, v7);
              v160(v94, (uint64_t)v91, v7);
              uint64_t v95 = v152;
              v92(v152, v93, v7);
              v86(v94, v7);
              uint64_t v96 = &v93[*((int *)v89 + 12)];
              v92(v93, v90, v7);
              v92(v96, v91, v7);
              v92(&v95[*(int *)(v88 + 36)], v96, v7);
              v86(v93, v7);
              Swift::Int v66 = v160;
              char v97 = *(void (**)(char *, char *, uint64_t))(v158 + 32);
              uint64_t v98 = v144;
              v97(v144, v95, v88);
              v97(v163, v98, v88);
              int64_t v99 = v169 + 1;
              unint64_t v169 = v159;
              int64_t v159 = v99;
              uint64_t v37 = v162;
              uint64_t v162 = v164;
              uint64_t v64 = v37;
              uint64_t v47 = v151;
            }

            uint64_t v46 = v157;
            uint64_t v65 = v155;
            v66(v165, (uint64_t)v155, v7);
          }

          uint64_t v37 = v64;
          uint64_t v46 = v157;
          uint64_t v47 = v68;
          uint64_t v7 = v67;
        }

void RangeSet.Ranges._intersection(_:)(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v111 = a3;
  uint64_t v6 = *(void *)(a2 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v6, v6, "lower upper ", 0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v124 = (char *)&v110 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v123 = (char *)&v110 - v10;
  uint64_t v132 = *(void *)(v6 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v110 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v120 = (char *)&v110 - v15;
  MEMORY[0x1895F8858](v14);
  uint64_t v131 = (char *)&v110 - v16;
  uint64_t v127 = *(void *)(a2 + 24);
  uint64_t v18 = type metadata accessor for Range(0LL, v6, v127, v17);
  uint64_t v19 = *(void *)(v18 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v122 = (char *)&v110 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)&v110 - v23;
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v121 = (char *)&v110 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  uint64_t v126 = (char *)&v110 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v31 = (char *)&v110 - v30;
  uint64_t v32 = (uint64_t *)MEMORY[0x1895F8858](v29);
  uint64_t v34 = (char *)&v110 - v33;
  uint64_t v35 = *a1;
  uint64_t v36 = *v3;
  _swift_isClassOrObjCExistentialType((uint64_t)v32, v32);
  uint64_t v40 = *(unsigned __int8 *)(v19 + 80);
  uint64_t v41 = &_swiftEmptyArrayStorage;
  uint64_t v144 = &_swiftEmptyArrayStorage;
  uint64_t v115 = *(void *)(v36 + 16);
  if (v115)
  {
    unint64_t v42 = 0LL;
    unint64_t v43 = 0LL;
    uint64_t v44 = (v40 + 32) & ~v40;
    uint64_t v114 = v36;
    uint64_t v113 = v36 + v44;
    uint64_t v45 = v35;
    uint64_t v112 = v35 + v44;
    uint64_t v119 = v13;
    uint64_t v46 = v127;
    uint64_t v118 = v19;
    uint64_t v117 = v24;
    uint64_t v47 = v126;
    uint64_t v134 = v34;
    uint64_t v139 = v45;
    uint64_t v128 = v31;
    while (1)
    {
      if (v42 >= *(void *)(v114 + 16)) {
LABEL_46:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      uint64_t v50 = *(void *)(v19 + 72);
      unint64_t v116 = v42;
      uint64_t v51 = *(void (**)(char *, unint64_t, uint64_t))(v19 + 16);
      uint64_t v140 = v43;
      v51(v34, v113 + v50 * v42, v18);
      uint64_t v137 = *(void *)(v45 + 16);
      uint64_t v129 = v51;
      v51(v31, (unint64_t)v34, v18);
      unint64_t v52 = v140;
      uint64_t v135 = v50;
      if (v140 >= v137)
      {
        unint64_t v58 = *(void (**)(char *, uint64_t))(v19 + 8);
        char v54 = (void (*)(char *, char *, uint64_t))v129;
LABEL_15:
        uint64_t v138 = v58;
        v58(v31, v18);
      }

      else
      {
        uint64_t v53 = v112 + v140 * v50;
        char v54 = (void (*)(char *, char *, uint64_t))v129;
        while (1)
        {
          if (v52 >= *(void *)(v45 + 16)) {
            goto LABEL_46;
          }
          uint64_t v140 = v52;
          char v55 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(v46 + 24))( v53 + *(int *)(v18 + 36),  v31,  v6,  v46);
          uint64_t v138 = *(void (**)(char *, uint64_t))(v19 + 8);
          v138(v31, v18);
          if ((v55 & 1) == 0) {
            break;
          }
          unint64_t v56 = v140 + 1;
          v54(v31, v134, v18);
          unint64_t v52 = v56;
          v53 += v135;
          BOOL v57 = v137 == v56;
          uint64_t v45 = v139;
          if (v57)
          {
            uint64_t v140 = v137;
            uint64_t v34 = v134;
            unint64_t v58 = v138;
            goto LABEL_15;
          }
        }

        uint64_t v34 = v134;
        uint64_t v45 = v139;
      }

      v54(v47, v34, v18);
      uint64_t v59 = v140;
      if (v140 < v137) {
        break;
      }
LABEL_3:
      uint64_t v48 = v138;
      v138(v47, v18);
      unint64_t v142 = v140;
      v48(v34, v18);
LABEL_4:
      unint64_t v49 = v116;
LABEL_5:
      unint64_t v42 = v49 + 1;
      unint64_t v43 = v142;
      if (v42 == v115)
      {
        uint64_t v41 = v144;
        goto LABEL_43;
      }
    }

    uint64_t v60 = v19;
    uint64_t v61 = (char *)(v112 + v140 * v135);
    unint64_t v142 = v140;
    while (1)
    {
      if (v59 < 0 || v142 >= *(void *)(v45 + 16)) {
        goto LABEL_46;
      }
      int64_t v62 = &v47[*(int *)(v18 + 36)];
      BOOL v63 = *(uint64_t (**)(void))(v46 + 16);
      uint64_t v136 = v61;
      char v64 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v63)(v61, v62, v6, v46);
      v138(v47, v18);
      if ((v64 & 1) == 0)
      {
        uint64_t v31 = v128;
        uint64_t v45 = v139;
        uint64_t v19 = v60;
        v138(v34, v18);
        goto LABEL_4;
      }

      if (v142 >= *(void *)(v139 + 16)) {
        goto LABEL_46;
      }
      uint64_t v65 = v117;
      v54(v117, v136, v18);
      Swift::Int v66 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v46 + 40);
      if ((v66(v34, v65, v6, v46) & 1) != 0)
      {
        uint64_t v141 = *(void (**)(char *, char *, uint64_t))(v132 + 16);
        v141(v131, v34, v6);
      }

      else
      {
        uint64_t v67 = &v34[*(int *)(v18 + 36)];
        char v68 = ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v63)(v67, v65, v6, v46);
        unint64_t v69 = *(void (**)(char *, char *, uint64_t))(v132 + 16);
        uint64_t v141 = v69;
        if ((v68 & 1) != 0)
        {
          uint64_t v70 = v131;
          uint64_t v71 = v67;
        }

        else
        {
          uint64_t v70 = v131;
          uint64_t v71 = v65;
        }

        v69(v70, v71, v6);
      }

      uint64_t v72 = v138;
      uint64_t v73 = *(int *)(v18 + 36);
      uint64_t v74 = &v65[v73];
      unint64_t v133 = &v34[v73];
      char v75 = v63();
      uint64_t v130 = (uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v66;
      if ((v75 & 1) != 0) {
        break;
      }
      if ((v66(v34, v74, v6, v46) & 1) != 0)
      {
        v72(v65, v18);
        uint64_t v76 = v120;
        uint64_t v77 = v120;
        uint64_t v78 = v34;
        goto LABEL_33;
      }

      uint64_t v76 = v120;
      v141(v120, v74, v6);
      v72(v65, v18);
LABEL_35:
      uint64_t v79 = v18;
      char v80 = TupleTypeMetadata2;
      unint64_t v81 = v123;
      uint64_t v82 = &v123[*((int *)TupleTypeMetadata2 + 12)];
      uint64_t v83 = v132;
      char v84 = *(void (**)(char *, char *, uint64_t))(v132 + 32);
      v84(v123, v131, v6);
      v84(v82, v76, v6);
      uint64_t v85 = v124;
      uint64_t v86 = &v124[*((int *)v80 + 12)];
      uint64_t v87 = v141;
      v141(v124, v81, v6);
      v87(v86, v82, v6);
      uint64_t v88 = (uint64_t)v122;
      v84(v122, v85, v6);
      uint64_t v89 = *(void (**)(char *, uint64_t))(v83 + 8);
      v89(v86, v6);
      uint64_t v90 = &v85[*((int *)v80 + 12)];
      v84(v85, v81, v6);
      v84(v90, v82, v6);
      v84((char *)(v88 + *(int *)(v79 + 36)), v90, v6);
      v89(v85, v6);
      uint64_t v91 = v118;
      uint64_t v92 = *(void (**)(char *, uint64_t, uint64_t))(v118 + 32);
      uint64_t v93 = v121;
      v92(v121, v88, v79);
      v92((char *)v88, (uint64_t)v93, v79);
      uint64_t v96 = type metadata accessor for Array(0LL, v79, v94, v95);
      Array.append(_:)(v88, v96);
      char v97 = v119;
      v141(v119, v133, v6);
      if (v142 >= *(void *)(v139 + 16)) {
        goto LABEL_46;
      }
      uint64_t v18 = v79;
      uint64_t v60 = v91;
      uint64_t v98 = v136;
      int64_t v99 = &v136[*(int *)(v79 + 36)];
      uint64_t v46 = v127;
      char v100 = v130(v97, (uint64_t)v99, v6, v127);
      v89(v97, v6);
      if ((v100 & 1) == 0)
      {
        uint64_t v34 = v134;
        v138(v134, v18);
        uint64_t v47 = v126;
        uint64_t v31 = v128;
        uint64_t v45 = v139;
        unint64_t v49 = v116;
        uint64_t v19 = v91;
        goto LABEL_5;
      }

      unint64_t v101 = v142 + 1;
      uint64_t v47 = v126;
      uint64_t v34 = v134;
      char v54 = (void (*)(char *, char *, uint64_t))v129;
      v129(v126, (unint64_t)v134, v18);
      uint64_t v61 = &v98[v135];
      unint64_t v142 = v101;
      BOOL v57 = v137 == v101;
      uint64_t v31 = v128;
      uint64_t v45 = v139;
      uint64_t v59 = v140;
      if (v57)
      {
        uint64_t v140 = v137;
        uint64_t v19 = v60;
        goto LABEL_3;
      }
    }

    v72(v65, v18);
    uint64_t v76 = v120;
    uint64_t v77 = v120;
    uint64_t v78 = v133;
LABEL_33:
    v141(v77, v78, v6);
    goto LABEL_35;
  }

uint64_t RangeSet.subtracting(_:)@<X0>( unint64_t **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v6 = *a1;
  *a5 = *v5;
  uint64_t v8 = v6;
  return RangeSet.subtract(_:)(&v8, a2, a3, a4);
}

uint64_t RangeSet.isSubset(of:)(unint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v70 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v69 = (char *)&v64 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *(void *)(v6 + 24);
  uint64_t v9 = type metadata accessor for Range(0LL, v4, v7, v8);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v68 = (uint64_t)&v64 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v74 = (char *)&v64 - v14;
  MEMORY[0x1895F8858](v13);
  uint64_t v71 = (uint64_t)&v64 - v15;
  uint64_t v16 = *a1;
  uint64_t v17 = *v2;
  *(void *)&__int128 v80 = v16;
  uint64_t v19 = type metadata accessor for RangeSet.Ranges(0LL, v4, v7, v18);
  swift_retain(v16, v20, v21, v22);
  uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v19, v23);
  uint64_t v73 = v19;
  Collection.subscript.getter(v19, (uint64_t)WitnessTable, (uint64_t)&v86);
  char v64 = v16;
  swift_release((uint64_t)v16);
  char v84 = v17;
  unint64_t v85 = 0LL;
  uint64_t v25 = (uint64_t *)(v17 + 2);
  unint64_t v24 = v17[2];
  swift_retain(v17, v26, v27, v28);
  if (v24)
  {
    uint64_t v65 = v4;
    uint64_t v30 = v10;
    uint64_t v66 = v7;
    unint64_t v31 = 0LL;
    uint64_t v76 = 0LL;
    uint64_t v67 = (char *)&v85;
    uint64_t v32 = WitnessTable;
    uint64_t v33 = v73;
    uint64_t v34 = v74;
    uint64_t v75 = v30;
    while (1)
    {
      uint64_t v35 = v71;
      RangeSet.Ranges.subscript.getter(v31, v33, v29, v71);
      uint64_t v36 = *v25;
      *(void *)&__int128 v80 = 0LL;
      *((void *)&v80 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v36;
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v67, (uint64_t)&v80, v33, v32);
      if (__OFADD__(v31, 1LL))
      {
        __break(1u);
LABEL_16:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }

      unint64_t v85 = v31 + 1;
      uint64_t v37 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v30 + 32))(v34, v35, v9);
      uint64_t v38 = v87;
      __int128 v80 = v86;
      unint64_t v81 = v87;
      MEMORY[0x1895F8858](v37);
      uint64_t v39 = v34;
      uint64_t v40 = v65;
      uint64_t v41 = v66;
      uint64_t v61 = v65;
      uint64_t v62 = v66;
      BOOL v63 = v39;
      uint64_t v43 = type metadata accessor for Slice(0LL, v33, (uint64_t)v32, v42);
      swift_retain(v38, v44, v45, v46);
      uint64_t v48 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v43, v47);
      uint64_t v49 = v76;
      Collection.firstIndex(where:)( (uint64_t (*)(char *))partial apply for closure #1 in RangeSet.isSubset(of:),  (uint64_t)(&v64 - 6),  v43,  v48,  (uint64_t)&v82);
      swift_release((uint64_t)v81);
      uint64_t v50 = (uint64_t)v87;
      if ((v83 & 1) != 0)
      {
        swift_release((uint64_t)v87);
        swift_release((uint64_t)v84);
        (*(void (**)(char *, uint64_t))(v75 + 8))(v74, v9);
        return 0LL;
      }

      uint64_t v51 = v82;
      __int128 v78 = v86;
      uint64_t v79 = (uint64_t)v87;
      uint64_t v76 = v49;
      uint64_t v77 = v82;
      uint64_t v52 = v68;
      Slice.subscript.getter((uint64_t)&v77, v43, v68);
      swift_release(v50);
      uint64_t v53 = v70;
      char v54 = v69;
      (*(void (**)(char *, uint64_t, uint64_t))(v70 + 16))(v69, v52 + *(int *)(v9 + 36), v40);
      char v55 = *(void (**)(uint64_t, uint64_t))(v75 + 8);
      v55(v52, v9);
      unint64_t v56 = v74;
      char v57 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 16))( v54,  &v74[*(int *)(v9 + 36)],  v40,  v41);
      (*(void (**)(char *, uint64_t))(v53 + 8))(v54, v40);
      if ((v57 & 1) != 0) {
        break;
      }
      uint64_t v82 = v64;
      int64_t v58 = v64[2];
      *(void *)&__int128 v78 = v51;
      *((void *)&v78 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v58;
      uint64_t v32 = WitnessTable;
      uint64_t v33 = v73;
      Collection<>.subscript.getter((uint64_t)&v78, v73, (uint64_t)WitnessTable, (char *)&v80);
      uint64_t v34 = v56;
      v55((uint64_t)v56, v9);
      uint64_t v59 = (uint64_t)v81;
      __int128 v86 = v80;
      uint64_t v87 = v81;
      uint64_t v17 = v84;
      unint64_t v31 = v85;
      uint64_t v25 = (uint64_t *)(v84 + 2);
      uint64_t v30 = v75;
      if (v85 == v84[2]) {
        goto LABEL_10;
      }
    }

    swift_release((uint64_t)v84);
    v55((uint64_t)v56, v9);
    return 0LL;
  }

  else
  {
    uint64_t v59 = (uint64_t)v87;
LABEL_10:
    swift_release((uint64_t)v17);
    swift_release(v59);
    return 1LL;
  }

uint64_t closure #1 in RangeSet.isSubset(of:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = type metadata accessor for Range(0LL, a3, a4, a4);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v19 - v11;
  uint64_t v13 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  char v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 24))(a1, a2, a3, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a1, v8);
  if ((v16 & 1) != 0) {
    char v17 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a4 + 16))(v15, &v12[*(int *)(v8 + 36)], a3, a4);
  }
  else {
    char v17 = 0;
  }
  (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  (*(void (**)(char *, uint64_t))(v13 + 8))(v15, a3);
  return v17 & 1;
}

uint64_t RangeSet.isSuperset(of:)(unint64_t **a1, uint64_t a2)
{
  Swift::UInt64 v3 = *a1;
  v5[0] = *v2;
  v5[1] = v3;
  return RangeSet.isSubset(of:)(v5, a2) & 1;
}

uint64_t RangeSet.isStrictSubset(of:)(unint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *v2;
  uint64_t v8 = *a1;
  uint64_t v9 = v5;
  if ((static RangeSet.== infix(_:_:)(&v9, &v8, *(void *)(a2 + 16), *(void *)(a2 + 24)) & 1) != 0)
  {
    char v6 = 0;
  }

  else
  {
    uint64_t v8 = v4;
    uint64_t v9 = v5;
    char v6 = RangeSet.isSubset(of:)(&v8, a2);
  }

  return v6 & 1;
}

uint64_t RangeSet.isStrictSuperset(of:)(unint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *v2;
  uint64_t v8 = v5;
  uint64_t v9 = v4;
  if ((static RangeSet.== infix(_:_:)(&v9, &v8, *(void *)(a2 + 16), *(void *)(a2 + 24)) & 1) != 0)
  {
    char v6 = 0;
  }

  else
  {
    uint64_t v8 = v5;
    uint64_t v9 = v4;
    char v6 = RangeSet.isSubset(of:)(&v8, a2);
  }

  return v6 & 1;
}

BOOL RangeSet.isDisjoint(_:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *v4;
  v9[0] = *a1;
  v9[1] = v5;
  uint64_t v6 = type metadata accessor for RangeSet.Ranges(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), a4);
  RangeSet.Ranges._intersection(_:)(v9, v6, &v10);
  uint64_t v7 = *(void *)(v10 + 16);
  swift_release(v10);
  return v7 == 0;
}

uint64_t RangeSet.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v129 = *(void *)(a1 + 24);
  uint64_t v130 = v5;
  uint64_t v6 = type metadata accessor for Range(0LL, v5, v129, a4);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v131 = (char *)&v124 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v124 - v11;
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v124 - v13;
  uint64_t v15 = *v4;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v16 = 91LL;
  unint64_t v17 = 0xE100000000000000LL;
  uint64_t v135 = 91LL;
  unint64_t v136 = 0xE100000000000000LL;
  __int128 v134 = (unint64_t)v15;
  unint64_t v18 = v15[2];
  swift_retain(v15, v19, v20, v21);
  if (!v18) {
    goto LABEL_47;
  }
  unint64_t v22 = 0LL;
  uint64_t v128 = (char *)&v134 + 8;
  char v23 = 1;
  __int128 v127 = xmmword_1817FFC60;
  __int128 v126 = xmmword_1817FFC70;
  Swift::UInt64 v125 = 131073LL;
  do
  {
    if (v22 >= v18) {
      goto LABEL_46;
    }
    (*(void (**)(char *, unint64_t, uint64_t))(v7 + 16))( v12,  (unint64_t)v15 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
    + *(void *)(v7 + 72) * v22,
      v6);
    unint64_t v24 = *(void (**)(char *, char *, uint64_t))(v7 + 32);
    v24(v14, v12, v6);
    *(void *)&__int128 v133 = 0LL;
    *((void *)&v133 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v18;
    uint64_t v26 = type metadata accessor for RangeSet.Ranges(0LL, v130, v129, v25);
    uint64_t WitnessTable = (const char *)swift_getWitnessTable( &protocol conformance descriptor for RangeSet<A>.Ranges,  v26,  v27);
    specialized Collection._failEarlyRangeCheck(_:bounds:)(v128, (uint64_t)&v133, v26, WitnessTable);
    *((void *)&v134 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v22 + 1;
    v24(v131, v14, v6);
    if ((v23 & 1) == 0)
    {
      uint64_t v32 = v135;
      uint64_t v31 = v136;
      unint64_t v33 = HIBYTE(v136) & 0xF;
      if ((v136 & 0x2000000000000000LL) != 0) {
        unint64_t v34 = HIBYTE(v136) & 0xF;
      }
      else {
        unint64_t v34 = v135 & 0xFFFFFFFFFFFFLL;
      }
      if (!v34 && (v135 & ~v136 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v136);
        uint64_t v135 = 8236LL;
        unint64_t v136 = 0xE200000000000000LL;
        goto LABEL_41;
      }

      if ((v136 & 0x2000000000000000LL) != 0 && v33 <= 0xD)
      {
        unint64_t v35 = 8 * (HIBYTE(v136) & 7);
        uint64_t v36 = (-255LL << v35) - 1;
        uint64_t v37 = 44LL << v35;
        char v38 = v33 + 1;
        if (v33 >= 8)
        {
          uint64_t v39 = v37 | v36 & v136;
LABEL_35:
          uint64_t v68 = (32LL << (8 * (v38 & 7u))) | ((-255LL << (8 * (v38 & 7u))) - 1) & v39;
        }

        else
        {
          uint64_t v32 = v37 | v36 & v135;
          if (v33 == 7)
          {
            char v38 = 8;
            uint64_t v39 = v136;
            goto LABEL_35;
          }

          uint64_t v32 = (32LL << (8 * (v38 & 7u))) | ((-255LL << (8 * (v38 & 7u))) - 1) & v32;
          uint64_t v68 = v136;
        }

        swift_bridgeObjectRelease(v136);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v69 = 0xA000000000000000LL;
        if (!(v32 & 0x8080808080808080LL | v68 & 0x80808080808080LL)) {
          unint64_t v69 = 0xE000000000000000LL;
        }
        uint64_t v135 = v32;
        unint64_t v136 = (v69 & 0xFF00000000000000LL | (v33 << 56) | v68 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
        goto LABEL_41;
      }

      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v29, v30);
      if ((v31 & 0x1000000000000000LL) != 0)
      {
        Swift::Int v73 = String.UTF8View._foreignCount()();
        int64_t v41 = v73 + 2;
        if (__OFADD__(v73, 2LL))
        {
LABEL_45:
          __break(1u);
LABEL_46:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }
      }

      else
      {
        BOOL v40 = __OFADD__(v34, 2LL);
        int64_t v41 = v34 + 2;
        if (v40) {
          goto LABEL_45;
        }
      }

      if ((v32 & ~v31 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v31 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v42 = _StringGuts.nativeUnusedCapacity.getter(v32, v31);
        if ((v43 & 1) != 0) {
          goto LABEL_118;
        }
        BOOL v45 = (v31 & 0x2000000000000000LL) == 0 && v42 > 1;
        if (v41 > 15 || v45)
        {
LABEL_33:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v41, 2LL);
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
          __int128 v133 = v126;
          uint64_t v66 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v133, 2LL);
          _StringGuts.appendInPlace(_:isASCII:)(v66, v67, 1);
          swift_bridgeObjectRelease(0xE200000000000000LL);
          goto LABEL_41;
        }
      }

      else if (v41 > 15)
      {
        goto LABEL_33;
      }

      swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
      swift_bridgeObjectRetain(v31, v46, v47, v48);
      unint64_t v49 = _StringGuts._convertedToSmall()(v32, v31);
      unint64_t v51 = v50;
      swift_bridgeObjectRelease(v31);
      v52._unint64_t rawBits = 1LL;
      v53._unint64_t rawBits = v125;
      v54._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v52, v53, 0x202CuLL, 0xE200000000000000LL);
      if (v54._rawBits < 0x10000) {
        v54._rawBits |= 3;
      }
      unint64_t v56 = specialized String.init(_:)(v54, v55, 0x202CuLL, 0xE200000000000000LL);
      unint64_t v58 = v57;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v59 = _StringGuts._convertedToSmall()(v56, v58);
      unint64_t v124 = v60;
      swift_bridgeObjectRelease(v58);
      unint64_t v61 = specialized _SmallString.init(_:appending:)(v49, v51, v59, v124);
      if ((v63 & 1) != 0) {
        goto LABEL_117;
      }
      uint64_t v64 = v61;
      unint64_t v65 = v62;
      swift_bridgeObjectRelease(v31);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v135 = v64;
      unint64_t v136 = v65;
    }

LABEL_108:
  uint64_t v116 = v16;
  if ((v79 & 0x1000000000000000LL) != 0)
  {
    unint64_t v76 = _StringGuts._foreignConvertedToSmall()(v76, v79);
    uint64_t v122 = v121;
    swift_bridgeObjectRelease(v79);
    uint64_t v79 = v122;
    uint64_t v16 = v116;
  }

  else
  {
    if ((v76 & 0x1000000000000000LL) != 0)
    {
      uint64_t v117 = (unsigned __int8 *)((v79 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v118 = v76 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v117 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v76, v79);
    }

    closure #1 in _StringGuts._convertedToSmall()(v117, v118, &v134);
    swift_bridgeObjectRelease(v79);
    uint64_t v79 = *((void *)&v134 + 1);
    unint64_t v76 = v134;
  }

  if ((v76 & 0x1000000000000000LL) != 0)
  {
    Swift::Int v73 = _StringGuts._foreignConvertedToSmall()(v73, v76);
    uint64_t v118 = v117;
    swift_bridgeObjectRelease(v76);
    unint64_t v76 = v118;
  }

  else
  {
    if ((v73 & 0x1000000000000000LL) != 0)
    {
      size_t v113 = (unsigned __int8 *)((v76 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v114 = v73 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      size_t v113 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v73, v76);
    }

    closure #1 in _StringGuts._convertedToSmall()(v113, v114, &v130);
    swift_bridgeObjectRelease(v76);
    unint64_t v76 = *((void *)&v130 + 1);
    Swift::Int v73 = v130;
  }

    uint64_t v68 = 0;
    uint64_t v19 = 0;
    LODWORD(v62) = v16;
    uint64_t v16 = v61;
    if ((v83 & 1) != 0) {
      goto LABEL_122;
    }
LABEL_109:
    if ((v68 & 1) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v87);
      swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
      swift_bridgeObjectRelease(a2);
      swift_bridgeObjectRelease((uint64_t)v89);
      swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
      swift_bridgeObjectRelease(a7);
      goto LABEL_125;
    }

    uint64_t v15 = v85;
    unint64_t v18 = v86;
    if (v48 != (_DWORD)v62)
    {
      swift_bridgeObjectRelease((uint64_t)v87);
      swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
      swift_bridgeObjectRelease(a2);
      swift_bridgeObjectRelease((uint64_t)v89);
      swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
      swift_bridgeObjectRelease(a7);
      uint64_t v72 = v48 < v62;
      return v72 & a5;
    }
  }

  if ((v61 & 0x7F800000000LL) == 0)
  {
    unint64_t v62 = v61;
    goto LABEL_78;
  }

  uint64_t v68 = 0;
  uint64_t v19 = 1;
  LODWORD(v62) = v61;
  if ((v83 & 1) == 0) {
    goto LABEL_109;
  }
LABEL_122:
  swift_bridgeObjectRelease((uint64_t)v87);
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  swift_bridgeObjectRelease(a2);
  swift_bridgeObjectRelease((uint64_t)v89);
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  swift_bridgeObjectRelease(a7);
  if ((v68 & 1) != 0) {
    return (a5 & 1) == 0;
  }
LABEL_125:
  uint64_t v72 = a9 < a4;
  return v72 & a5;
}

        v19[1] = v52;
        LODWORD(v53) = 1;
        goto LABEL_94;
      }

      goto LABEL_95;
    }

    uint64_t v8 = 1LL;
  }

uint64_t RangeSet.Ranges.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = type metadata accessor for Range(0LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  __int128 v127 = (char *)&v120 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v120 - v11;
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v120 - v13;
  uint64_t v15 = *v4;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v16 = 91LL;
  unint64_t v17 = 0xE100000000000000LL;
  uint64_t v131 = 91LL;
  unint64_t v132 = 0xE100000000000000LL;
  __int128 v130 = (unint64_t)v15;
  unint64_t v18 = v15[2];
  swift_retain(v15, v19, v20, v21);
  if (!v18) {
    goto LABEL_47;
  }
  unint64_t v22 = 0LL;
  __int128 v126 = (char *)&v130 + 8;
  char v23 = 1;
  __int128 v125 = xmmword_1817FFC60;
  __int128 v124 = xmmword_1817FFC70;
  Swift::UInt64 v123 = 131073LL;
  do
  {
    if (v22 >= v18) {
      goto LABEL_46;
    }
    (*(void (**)(char *, unint64_t, uint64_t))(v7 + 16))( v12,  (unint64_t)v15 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
    + *(void *)(v7 + 72) * v22,
      v6);
    unint64_t v24 = *(void (**)(char *, char *, uint64_t))(v7 + 32);
    v24(v14, v12, v6);
    *(void *)&__int128 v129 = 0LL;
    *((void *)&v129 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v18;
    uint64_t WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a1, v25);
    specialized Collection._failEarlyRangeCheck(_:bounds:)(v126, (uint64_t)&v129, a1, WitnessTable);
    *((void *)&v130 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v22 + 1;
    v24(v127, v14, v6);
    if ((v23 & 1) == 0)
    {
      uint64_t v30 = v131;
      uint64_t v29 = v132;
      unint64_t v31 = HIBYTE(v132) & 0xF;
      if ((v132 & 0x2000000000000000LL) != 0) {
        unint64_t v32 = HIBYTE(v132) & 0xF;
      }
      else {
        unint64_t v32 = v131 & 0xFFFFFFFFFFFFLL;
      }
      if (!v32 && (v131 & ~v132 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v132);
        uint64_t v131 = 8236LL;
        unint64_t v132 = 0xE200000000000000LL;
        goto LABEL_41;
      }

      if ((v132 & 0x2000000000000000LL) != 0 && v31 <= 0xD)
      {
        unint64_t v33 = 8 * (HIBYTE(v132) & 7);
        uint64_t v34 = (-255LL << v33) - 1;
        uint64_t v35 = 44LL << v33;
        char v36 = v31 + 1;
        if (v31 >= 8)
        {
          uint64_t v37 = v35 | v34 & v132;
LABEL_35:
          uint64_t v65 = (32LL << (8 * (v36 & 7u))) | ((-255LL << (8 * (v36 & 7u))) - 1) & v37;
        }

        else
        {
          uint64_t v30 = v35 | v34 & v131;
          if (v31 == 7)
          {
            char v36 = 8;
            uint64_t v37 = v132;
            goto LABEL_35;
          }

          uint64_t v30 = (32LL << (8 * (v36 & 7u))) | ((-255LL << (8 * (v36 & 7u))) - 1) & v30;
          uint64_t v65 = v132;
        }

        swift_bridgeObjectRelease(v132);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v66 = 0xE000000000000000LL;
        if (v30 & 0x8080808080808080LL | v65 & 0x80808080808080LL) {
          unint64_t v66 = 0xA000000000000000LL;
        }
        uint64_t v131 = v30;
        unint64_t v132 = (v66 & 0xFF00000000000000LL | (v31 << 56) | v65 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
        goto LABEL_41;
      }

      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v27, v28);
      if ((v29 & 0x1000000000000000LL) != 0)
      {
        Swift::Int v70 = String.UTF8View._foreignCount()();
        int64_t v39 = v70 + 2;
        if (__OFADD__(v70, 2LL))
        {
LABEL_45:
          __break(1u);
LABEL_46:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
        }
      }

      else
      {
        BOOL v38 = __OFADD__(v32, 2LL);
        int64_t v39 = v32 + 2;
        if (v38) {
          goto LABEL_45;
        }
      }

      if ((v30 & ~v29 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v29 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v40 = _StringGuts.nativeUnusedCapacity.getter(v30, v29);
        if ((v41 & 1) != 0) {
          goto LABEL_118;
        }
        BOOL v43 = (v29 & 0x2000000000000000LL) == 0 && v40 > 1;
        if (v39 > 15 || v43)
        {
LABEL_33:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v39, 2LL);
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
          __int128 v129 = v124;
          char v63 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v129, 2LL);
          _StringGuts.appendInPlace(_:isASCII:)(v63, v64, 1);
          swift_bridgeObjectRelease(0xE200000000000000LL);
          goto LABEL_41;
        }
      }

      else if (v39 > 15)
      {
        goto LABEL_33;
      }

      swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
      swift_bridgeObjectRetain(v29, v44, v45, v46);
      unint64_t v47 = _StringGuts._convertedToSmall()(v30, v29);
      unint64_t v122 = v48;
      swift_bridgeObjectRelease(v29);
      v49._unint64_t rawBits = 1LL;
      v50._unint64_t rawBits = v123;
      v51._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v49, v50, 0x202CuLL, 0xE200000000000000LL);
      if (v51._rawBits < 0x10000) {
        v51._rawBits |= 3;
      }
      unint64_t v53 = specialized String.init(_:)(v51, v52, 0x202CuLL, 0xE200000000000000LL);
      unint64_t v55 = v54;
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v121 = _StringGuts._convertedToSmall()(v53, v55);
      unint64_t v57 = v56;
      swift_bridgeObjectRelease(v55);
      unint64_t v58 = specialized _SmallString.init(_:appending:)(v47, v122, v121, v57);
      if ((v60 & 1) != 0) {
        goto LABEL_117;
      }
      uint64_t v61 = v58;
      unint64_t v62 = v59;
      swift_bridgeObjectRelease(v29);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v131 = v61;
      unint64_t v132 = v62;
    }

void *MutableCollection<>.sort(by:)(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  Swift::Int v112 = a5;
  uint64_t v114 = a2;
  uint64_t v8 = *(void *)(a4 + 8);
  uint64_t v111 = *(void *)(v8 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v111,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v96 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v92 = *(void *)(v96 + 64);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v95 = (char *)&v88 - v9;
  unint64_t v10 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0LL, v10, v11, v12);
  uint64_t v107 = *(void *)(v13 - 8);
  uint64_t v108 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  char v106 = (char *)&v88 - v15;
  uint64_t v105 = *(void *)(v10 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v104 = (char *)&v88 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v16);
  unint64_t v103 = (char *)&v88 - v18;
  unint64_t v109 = v10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v10, (uint64_t)&type metadata for Int, 0LL, 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v93 = (char *)&v88 - v19;
  unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Indices);
  unint64_t v99 = *(void *)(v20 - 8);
  MEMORY[0x1895F8858](v20);
  char v100 = (char *)&v88 - v21;
  uint64_t v102 = v8;
  uint64_t v22 = *(void *)(swift_getAssociatedConformanceWitness( v8,  a3,  v20,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Indices: Collection)
                  + 8);
  uint64_t v24 = lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>( &lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>,  (uint64_t)&protocol conformance descriptor for <> Range<A>,  v23);
  uint64_t v122 = v20;
  Swift::UInt64 v123 = &unk_189B86D40;
  uint64_t v124 = v22;
  uint64_t v125 = v24;
  uint64_t v98 = type metadata accessor for Zip2Sequence(0LL, (uint64_t)&v122);
  MEMORY[0x1895F8858](v98);
  unint64_t v97 = (char *)&v88 - v25;
  uint64_t v122 = v20;
  Swift::UInt64 v123 = &unk_189B86D40;
  uint64_t v101 = v22;
  uint64_t v124 = v22;
  uint64_t v125 = v24;
  uint64_t v26 = type metadata accessor for Zip2Sequence.Iterator(0LL, (uint64_t)&v122);
  uint64_t v27 = *(void *)(v26 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v88 - v29;
  uint64_t v31 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v28);
  unint64_t v33 = (char *)&v88 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v117 = a3;
  uint64_t v118 = a4;
  uint64_t v34 = v113;
  unint64_t v119 = v112;
  uint64_t v120 = a1;
  Swift::Int v112 = a1;
  uint64_t v121 = v114;
  uint64_t v35 = a4;
  uint64_t result = (*(void *(**)(uint64_t *__return_ptr, void (*)(uint64_t), char *, void *, uint64_t))(a4 + 80))( &v122,  partial apply for closure #1 in MutableCollection<>.sort(by:),  v116,  &unk_189B8D178,  a3);
  if (!v34)
  {
    uint64_t v37 = v111;
    Swift::String::Index v90 = (uint64_t (*)(char *, uint64_t, unint64_t))v20;
    uint64_t v91 = v30;
    uint64_t v89 = v27;
    uint64_t v113 = v26;
    uint64_t v88 = v35;
    if (v122 == 1)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v33, v115, a3);
      uint64_t v122 = (*(uint64_t (**)(uint64_t, uint64_t))(v37 + 56))(a3, v37);
      uint64_t v38 = AssociatedTypeWitness;
      uint64_t v41 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v39, v40);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v41, v42);
      uint64_t v45 = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v41, v44);
      MutableCollection<>.sort(by:)(v112, v114, v41, WitnessTable, v45);
      uint64_t v46 = (const char *)v122;
      uint64_t v114 = 0LL;
      unint64_t v47 = v97;
      (*(void (**)(uint64_t))(v102 + 96))(a3);
      uint64_t v111 = (uint64_t)v46;
      __int128 v126 = v46;
      uint64_t v50 = type metadata accessor for Array(0LL, v38, v48, v49);
      uint64_t v52 = swift_getWitnessTable(&protocol conformance descriptor for [A], v50, v51);
      RandomAccessCollection<>.indices.getter(v50, v52, (uint64_t)&protocol witness table for Int, (char *)&v122);
      int64_t v54 = v122;
      uint64_t v53 = (uint64_t)v123;
      Swift::Int v112 = v123;
      unint64_t v55 = (uint64_t *)&v47[*(int *)(v98 + 52)];
      *unint64_t v55 = v122;
      v55[1] = v53;
      uint64_t v56 = (uint64_t)v90;
      (*(void (**)(char *, char *, uint64_t (*)(char *, uint64_t, unint64_t)))(v99 + 32))( v100,  v47,  v90);
      unint64_t v57 = (const char *)v101;
      unint64_t v58 = v91;
      (*(void (**)(uint64_t, uint64_t))(v101 + 32))(v56, v101);
      uint64_t v59 = v113;
      char v60 = (int64_t *)&v58[*(int *)(v113 + 52)];
      *char v60 = v54;
      v60[1] = v53;
      char v100 = (char *)v60;
      v60[2] = v54;
      uint64_t v102 = *(int *)(v59 + 56);
      v58[v102] = 0;
      unint64_t v61 = swift_getAssociatedTypeWitness( 255LL,  v57,  v56,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v57,  v56,  v61,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      char v63 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
      uint64_t v101 = v61;
      size_t v64 = swift_checkMetadataState(0LL, v61);
      uint64_t v65 = v106;
      unint64_t v99 = AssociatedConformanceWitness;
      uint64_t v98 = (uint64_t)v63;
      v63(v64, AssociatedConformanceWitness);
      uint64_t v66 = v105;
      uint64_t v67 = *(uint64_t (**)(char *, uint64_t, unint64_t))(v105 + 48);
      unint64_t v68 = v109;
      int v69 = v67(v65, 1LL, v109);
      uint64_t v70 = v107;
      uint64_t v71 = v104;
      if (v69 == 1)
      {
LABEL_4:
        (*(void (**)(char *))(v70 + 8))(v65);
      }

      else
      {
        unint64_t v74 = *(void (**)(char *, char *, unint64_t))(v66 + 32);
        unint64_t v97 = (char *)(v111 & 0xC000000000000001LL);
        while (1)
        {
          uint64_t v75 = v74;
          v74(v103, v65, v68);
          if (v54 >= (uint64_t)v112) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
          }
          Swift::String::Index v90 = v67;
          BOOL v76 = v97 == 0LL;
          *((void *)v100 + 2) = v54 + 1;
          unint64_t v77 = v71;
          uint64_t v78 = *((int *)TupleTypeMetadata2 + 12);
          char v79 = v93;
          v75(v93, v103, v68);
          *(void *)&v79[v78] = v54;
          int64_t v80 = (uint64_t *)AssociatedTypeWitness;
          v75(v77, v79, v68);
          char v81 = v76 | ~_swift_isClassOrObjCExistentialType((uint64_t)v80, v80);
          char v82 = (const char *)v111;
          Array._checkSubscript(_:wasNativeTypeChecked:)(v54, v81 & 1);
          if ((v81 & 1) != 0)
          {
            BOOL v83 = v95;
            (*(void (**)(char *, const char *, uint64_t *))(v96 + 16))( v95,  &v82[((*(unsigned __int8 *)(v96 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v96 + 80))
                 + *(void *)(v96 + 72) * v54],
              v80);
          }

          else
          {
            id v86 = _ArrayBuffer._getElementSlowPath(_:)(v54, (uint64_t)v82, v80);
            Swift::String::Index v87 = v86;
            if (v92 != 8)
            {
              swift_unknownObjectRelease(v86);
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
            }

            uint64_t v122 = (uint64_t)v86;
            BOOL v83 = v95;
            (*(void (**)(char *, uint64_t *, unint64_t))(v96 + 16))(v95, &v122, AssociatedTypeWitness);
            swift_unknownObjectRelease(v87);
          }

          unint64_t v58 = v91;
          uint64_t v67 = v90;
          uint64_t v71 = v104;
          (*(void (**)(char *, char *, uint64_t))(v88 + 24))(v83, v104, a3);
          uint64_t v84 = swift_checkMetadataState(0LL, v101);
          uint64_t v65 = v106;
          ((void (*)(unint64_t *, unint64_t))v98)(v84, v99);
          unint64_t v68 = v109;
          int v85 = v67(v65, 1LL, v109);
          ++v54;
          uint64_t v70 = v107;
          uint64_t v66 = v105;
          unint64_t v74 = v75;
          if (v85 == 1) {
            goto LABEL_4;
          }
        }

        (*(void (**)(char *))(v66 + 8))(v103);
      }

      uint64_t v72 = v113;
      uint64_t v73 = v89;
      v58[v102] = 1;
      (*(void (**)(char *, uint64_t))(v73 + 8))(v58, v72);
      return (void *)swift_release(v111);
    }
  }

  return result;
}

uint64_t RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, void *a2, char a3, uint64_t a4)
{
  return specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)( a1,  a2,  a3,  *(void *)(a4 + 16),  *(void *)(a4 + 24));
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t RangeSet.Ranges.startIndex.getter()
{
  return 0LL;
}

uint64_t RangeSet.Ranges.count.getter()
{
  return *(void *)(*(void *)v0 + 16LL);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance RangeSet<A>.Ranges@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = RangeSet.Ranges.count.getter();
  *a1 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance RangeSet<A>.Ranges( uint64_t **a1, unint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = (uint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (uint64_t)RangeSet.Ranges.subscript.read(v6, *a2, a3, v7);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*RangeSet.Ranges.subscript.read( uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v7 = type metadata accessor for Range(0LL, *(void *)(a3 + 16), *(void *)(a3 + 24), a4);
  *a1 = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  a1[1] = v8;
  a1[2] = (uint64_t)malloc(*(void *)(v8 + 64));
  if ((a2 & 0x8000000000000000LL) != 0 || *(void *)(*(void *)v4 + 16LL) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
  (*(void (**)(void))(v8 + 16))();
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.indices.getter in conformance RangeSet<A>.Ranges@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance RangeSet<A>.Ranges@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance RangeSet<A>.Ranges@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance RangeSet<A>.Ranges( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

void *protocol witness for Collection.formIndex(after:) in conformance RangeSet<A>.Ranges( void *a1, uint64_t a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  uint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance RangeSet<A>.Ranges@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance RangeSet<A>.Ranges@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance RangeSet<A>.Ranges( uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return static RangeSet.Ranges.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

void RangeSet.Ranges<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = type metadata accessor for Range(0LL, v7, *(void *)(a2 + 24), a4);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = (char *)&v17 - v10;
  uint64_t v12 = *v4;
  Swift::UInt v13 = *(void *)(*v4 + 16);
  Hasher._combine(_:)(v13);
  Swift::UInt v18 = v13;
  if (v13)
  {
    unint64_t v14 = 0LL;
    do
    {
      if (v14 >= *(void *)(v12 + 16)) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
      }
      unint64_t v15 = v14 + 1;
      (*(void (**)(char *, unint64_t, uint64_t))(v9 + 16))( v11,  v12 + ((*(unsigned __int8 *)(v9 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
      + *(void *)(v9 + 72) * v14,
        v8);
      uint64_t v16 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24);
      v16(a1, v7, a3);
      v16(a1, v7, a3);
      (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v8);
      unint64_t v14 = v15;
    }

    while (v18 != v15);
  }

Swift::Int RangeSet.Ranges<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *v4;
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  RangeSet.Ranges<>.hash(into:)((uint64_t)v6, a1, a2, a4);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RangeSet.Ranges<>.hashValue.getter(a1, *(void *)(a2 - 8), a3, a4);
}

void protocol witness for Hashable.hash(into:) in conformance <> RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> RangeSet<A>.Ranges( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))RangeSet.Ranges<>.hash(into:));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _Pair<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _Pair<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _Pair<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _Pair<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

void protocol witness for Collection.endIndex.getter in conformance _Pair<A>(void *a1@<X8>)
{
  *a1 = 2LL;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _Pair<A>( uint64_t **a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = (uint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (uint64_t)_Pair.subscript.read(v6, *a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*_Pair.subscript.read(uint64_t *a1, uint64_t a2, uint64_t a3))(uint64_t a1)
{
  uint64_t v6 = *(void *)(a3 + 16);
  *a1 = v6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v6, v6, "first second ", 0LL);
  __int128 v8 = (char *)malloc(*(void *)(*(TupleTypeMetadata2 - 1) + 64));
  a1[1] = (uint64_t)v8;
  uint64_t v9 = *(void *)(v6 - 8);
  uint64_t v10 = malloc(*(void *)(v9 + 64));
  a1[2] = (uint64_t)v10;
  if (a2 == 1)
  {
    uint64_t v11 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v12 = &v8[v11];
    Swift::UInt v13 = &v8[v11];
    Swift::UInt v18 = v8;
  }

  else
  {
    if (a2) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index is out of range",  21LL,  2,  "Swift/RangeSetRanges.swift",  26LL,  2,  0x19EuLL,  0);
    }
    uint64_t v11 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v12 = &v8[v11];
    Swift::UInt v13 = v8;
    Swift::UInt v18 = &v8[v11];
  }

  uint64_t v14 = v3 + v11;
  unint64_t v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15(v8, v3, v6);
  v15(v12, v14, v6);
  (*(void (**)(void *, char *, uint64_t))(v9 + 32))(v10, v13, v6);
  uint64_t v16 = *(void (**)(char *, uint64_t))(v9 + 8);
  a1[3] = (uint64_t)v16;
  v16(v18, v6);
  return _Pair.subscript.read;
}

void _Pair.subscript.read(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  uint64_t v2 = *(void **)(a1 + 8);
  (*(void (**)(void *, void))(a1 + 24))(v1, *(void *)a1);
  free(v1);
  free(v2);
}

uint64_t protocol witness for Collection.indices.getter in conformance _Pair<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance _Pair<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance _Pair<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _Pair<A>( void *a1, uint64_t a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a2, a3);
  uint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _Pair<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>( a1,  (uint64_t)&protocol conformance descriptor for _Pair<A>,  a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance _FixedArray16<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = v3;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 32LL))(a3, v6, a1);
  uint64_t WitnessTable = swift_getWitnessTable(a2, a1, v8);
  uint64_t result = type metadata accessor for IndexingIterator(0LL, a1, WitnessTable, v10);
  *(void *)(a3 + *(int *)(result + 36)) = 0LL;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _Pair<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _Pair<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _Pair<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>( swift::SwiftError **a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (!a2)
  {
    uint64_t v8 = v215;
    uint64_t v9 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(v214, (uint64_t)v215);
    DynamicType = (unint64_t *)swift_getDynamicType(v9, v8, 1);
    a2 = swift_reflectionMirror_normalizedType(v214, DynamicType, (uint64_t *)&unk_189B8D218);
  }

  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v214);
  uint64_t v11 = swift_reflectionMirror_count(a1, (objc_class *)a2, (uint64_t *)&unk_189B8D218);
  if (v11 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v12 = v11;
  outlined init with copy of Any((uint64_t)a1, (uint64_t)v213);
  Swift::UInt v13 = swift_allocObject((uint64_t)&unk_189B89618, 0x38uLL, 7uLL);
  outlined init with take of Any(v213, (_OWORD *)v13 + 1);
  v13[6] = a2;
  uint64_t v14 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<Range<Int>, (label: String?, value: Any)>>);
  unint64_t v15 = swift_allocObject(v14, 0x50uLL, 7uLL);
  v15[6] = 0LL;
  v15[7] = v12;
  v15[8] = partial apply for closure #1 in Mirror.init(internalReflecting:subjectType:customAncestor:);
  v15[9] = v13;
  uint64_t v16 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v17 = swift_allocObject(v16, 0x18uLL, 7uLL);
  void v17[2] = 0LL;
  Swift::UInt v18 = swift_allocObject(v16, 0x18uLL, 7uLL);
  v18[2] = v12;
  void v15[2] = v17;
  v15[3] = &protocol witness table for _IndexBox<A>;
  v15[4] = v18;
  v15[5] = &protocol witness table for _IndexBox<A>;
  outlined init with copy of Any((uint64_t)a1, (uint64_t)v213);
  uint64_t v19 = swift_allocObject((uint64_t)&unk_189B89640, 0x68uLL, 7uLL);
  v19[2] = a2;
  outlined init with take of Mirror?((uint64_t)v216, (uint64_t)(v19 + 3));
  outlined init with take of Any(v213, v19 + 9);
  char v20 = swift_reflectionMirror_displayStyle(a1, (void **)&unk_189B8D218);
  if (v20 < 0)
  {
LABEL_13:
    *((void *)&v211 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v20;
    uint64_t v23 = specialized static String._createEmpty(withInitialCapacity:)(30LL);
    unint64_t v27 = v23;
    unint64_t v28 = v24;
    *(void *)&v213[0] = v23;
    *((void *)&v213[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v24;
    uint64_t v29 = HIBYTE(v24) & 0xF;
    if ((v24 & 0x2000000000000000LL) != 0) {
      unint64_t v30 = HIBYTE(v24) & 0xF;
    }
    else {
      unint64_t v30 = v23 & 0xFFFFFFFFFFFFLL;
    }
    if (!v30 && (v23 & ~v24 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v24);
      unint64_t v31 = 0x80000001818BB2F0LL | 0x8000000000000000LL;
      for (*(void *)&v213[0] = 0xD00000000000001BLL; ; *(void *)&v213[0] = v30)
      {
LABEL_97:
        *((void *)&v213[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v31;
LABEL_98:
        *(void *)&__int128 v211 = _int64ToString(_:radix:uppercase:)( *((uint64_t *)&v211 + 1),  10LL,  0,  (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
        *((void *)&v211 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v92;
        unint64_t v28 = *((void *)&v213[0] + 1);
        unint64_t v27 = *(void *)&v213[0];
        uint64_t v95 = HIBYTE(*((void *)&v213[0] + 1)) & 0xFLL;
        if ((*((void *)&v213[0] + 1) & 0x2000000000000000LL) != 0) {
          uint64_t v40 = HIBYTE(*((void *)&v213[0] + 1)) & 0xFLL;
        }
        else {
          uint64_t v40 = *(void *)&v213[0] & 0xFFFFFFFFFFFFLL;
        }
        if (!v40 && (*(void *)&v213[0] & ~*((void *)&v213[0] + 1) & 0x2000000000000000LL) == 0)
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v213[0] + 1));
          v213[0] = v211;
          goto LABEL_167;
        }

        uint64_t v4 = v92 & 0x2000000000000000LL;
        unint64_t v30 = HIBYTE(v92) & 0xF;
        if ((*((void *)&v213[0] + 1) & 0x2000000000000000LL) != 0 && v4)
        {
          unint64_t v98 = v95 + v30;
          if (v95 + v30 <= 0xF)
          {
            if (v30)
            {
              uint64_t v143 = 0LL;
              unint64_t v144 = 0LL;
              unint64_t v125 = *((void *)&v213[0] + 1);
              uint64_t v126 = v92;
              do
              {
                unint64_t v145 = v95 + v144;
                unint64_t v146 = v144 + 1;
                if (v144 >= 8) {
                  unint64_t v147 = v92;
                }
                else {
                  unint64_t v147 = v211;
                }
                unint64_t v148 = v147 >> (v143 & 0x38);
                char v149 = (8 * v95 + v143) & 0x38;
                uint64_t v150 = (-255LL << v149) - 1;
                unint64_t v151 = (unint64_t)v148 << v149;
                unint64_t v152 = v150 & v125 | v151;
                unint64_t v153 = v150 & v27 | v151;
                if (v145 < 8) {
                  unint64_t v27 = v153;
                }
                else {
                  unint64_t v125 = v152;
                }
                v143 += 8LL;
                unint64_t v144 = v146;
              }

              while (v30 != v146);
            }

            else
            {
              unint64_t v125 = *((void *)&v213[0] + 1);
              uint64_t v126 = v92;
            }

            swift_bridgeObjectRelease(v126);
            swift_bridgeObjectRelease(v28);
            unint64_t v154 = 0xA000000000000000LL;
            if (!(v27 & 0x8080808080808080LL | v125 & 0x80808080808080LL)) {
              unint64_t v154 = 0xE000000000000000LL;
            }
            *(void *)&v213[0] = v27;
            for (*((void *)&v213[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v154 & 0xFF00000000000000LL | (v98 << 56) | v125 & 0xFFFFFFFFFFFFFFLL;
                  ;
                  *((void *)&v213[0] + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v142 & 0xFF00000000000000LL | (v123 << 56) | v111 & 0xFFFFFFFFFFFFFFLL)
            {
LABEL_167:
              unint64_t v104 = *((void *)&v213[0] + 1);
              unint64_t v111 = *(void *)&v213[0];
              unint64_t v118 = HIBYTE(*((void *)&v213[0] + 1)) & 0xFLL;
              if ((*((void *)&v213[0] + 1) & 0x2000000000000000LL) != 0) {
                uint64_t v155 = HIBYTE(*((void *)&v213[0] + 1)) & 0xFLL;
              }
              else {
                uint64_t v155 = *(void *)&v213[0] & 0xFFFFFFFFFFFFLL;
              }
              if (!v155 && (*(void *)&v213[0] & ~*((void *)&v213[0] + 1) & 0x2000000000000000LL) == 0)
              {
                swift_bridgeObjectRelease(*((uint64_t *)&v213[0] + 1));
                unint64_t v156 = 0xE100000000000000LL;
                unint64_t v111 = 39LL;
                goto LABEL_199;
              }

              if ((*((void *)&v213[0] + 1) & 0x2000000000000000LL) != 0 && v118 != 15)
              {
                uint64_t v157 = HIBYTE(*((void *)&v213[0] + 1));
                swift_bridgeObjectRelease(0xE100000000000000LL);
                swift_bridgeObjectRelease(v104);
                char v158 = 8 * (v157 & 7);
                uint64_t v159 = (-255LL << v158) - 1;
                uint64_t v160 = 39LL << v158;
                unint64_t v161 = v159 & v104 | v160;
                unint64_t v162 = v159 & v111 | v160;
                if (v118 >= 8) {
                  unint64_t v163 = v161;
                }
                else {
                  unint64_t v163 = v104;
                }
                if (v118 < 8) {
                  unint64_t v111 = v162;
                }
                unint64_t v164 = 0xA000000000000000LL;
                if (!(v163 & 0x80808080808080LL | v111 & 0x8080808080808080LL)) {
                  unint64_t v164 = 0xE000000000000000LL;
                }
                unint64_t v156 = (v164 & 0xFF00000000000000LL | (v118 << 56) | v163 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL;
                goto LABEL_199;
              }

              swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v96, v97);
              if ((v104 & 0x1000000000000000LL) != 0)
              {
                Swift::Int v200 = String.UTF8View._foreignCount()();
                uint64_t v120 = v200 + 1;
                if (!__OFADD__(v200, 1LL))
                {
LABEL_185:
                  if ((v111 & ~v104 & 0x2000000000000000LL) == 0
                    || !swift_isUniquelyReferenced_nonNull_native(v104 & 0xFFFFFFFFFFFFFFFLL))
                  {
                    if (v120 <= 15) {
                      goto LABEL_192;
                    }
                    goto LABEL_198;
                  }

                  int64_t v168 = _StringGuts.nativeUnusedCapacity.getter(v111, v104);
                  if ((v165 & 1) == 0)
                  {
                    uint64_t v169 = (v104 >> 61) & 1;
                    if (v168 < 1) {
                      LOBYTE(v169) = 1;
                    }
                    if (v120 <= 15 && (v169 & 1) != 0)
                    {
LABEL_192:
                      swift_bridgeObjectRetain(v104, v165, v166, v167);
                      unint64_t v170 = _StringGuts._convertedToSmall()(v111, v104);
                      unint64_t v172 = v171;
                      swift_bridgeObjectRelease(v104);
                      v173._unint64_t rawBits = 1LL;
                      v174._unint64_t rawBits = 65537LL;
                      v175._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v173, v174, 0x27uLL, 0xE100000000000000LL);
                      if (v175._rawBits < 0x10000) {
                        v175._rawBits |= 3;
                      }
                      unint64_t v177 = specialized String.init(_:)(v175, v176, 0x27uLL, 0xE100000000000000LL);
                      unint64_t v179 = v178;
                      swift_bridgeObjectRelease(0xE100000000000000LL);
                      unint64_t v180 = _StringGuts._convertedToSmall()(v177, v179);
                      unint64_t v182 = v181;
                      swift_bridgeObjectRelease(v179);
                      unint64_t v183 = specialized _SmallString.init(_:appending:)(v170, v172, v180, v182);
                      if ((v185 & 1) == 0)
                      {
                        unint64_t v111 = v183;
                        unint64_t v156 = v184;
                        swift_bridgeObjectRelease(0xE100000000000000LL);
                        swift_bridgeObjectRelease(v104);
                        goto LABEL_199;
                      }

LABEL_200:
                  unint64_t v186 = 258LL;
                  goto LABEL_201;
                }
              }

              else
              {
                BOOL v102 = __OFADD__(v155, 1LL);
                uint64_t v120 = v155 + 1;
                if (!v102) {
                  goto LABEL_185;
                }
              }

              __break(1u);
LABEL_223:
              if ((v120 & 0x1000000000000000LL) != 0)
              {
                unint64_t v118 = _StringGuts._foreignConvertedToSmall()(v118, v120);
                uint64_t v209 = v208;
                swift_bridgeObjectRelease(v120);
                uint64_t v120 = v209;
              }

              else
              {
                if ((v118 & 0x1000000000000000LL) != 0)
                {
                  uint64_t v201 = (unsigned __int8 *)((v120 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v202 = v118 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  uint64_t v201 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v118, v120);
                }

                closure #1 in _StringGuts._convertedToSmall()(v201, v202, &v212);
                swift_bridgeObjectRelease(v120);
                uint64_t v120 = *((void *)&v212 + 1);
                unint64_t v118 = v212;
              }

                  uint64_t v209 = 266LL;
LABEL_202:
                  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v209,  0);
                }

LABEL_136:
              uint64_t v121 = HIBYTE(v111) & 0xF;
              uint64_t v122 = HIBYTE(v120) & 0xF;
              uint64_t v123 = v122 + v121;
              if (v122)
              {
                char v131 = 0;
                unint64_t v132 = 0LL;
                unint64_t v124 = v210;
                do
                {
                  unint64_t v133 = v121 + v132;
                  unint64_t v134 = v132 + 1;
                  if (v132 >= 8) {
                    unint64_t v135 = v120;
                  }
                  else {
                    unint64_t v135 = v118;
                  }
                  unint64_t v136 = v135 >> (v131 & 0x38);
                  char v137 = (8 * v121 + v131) & 0x38;
                  uint64_t v138 = (-255LL << v137) - 1;
                  unint64_t v139 = (unint64_t)v136 << v137;
                  unint64_t v140 = v138 & v111 | v139;
                  unint64_t v141 = v138 & v124 | v139;
                  if (v133 < 8) {
                    unint64_t v124 = v141;
                  }
                  else {
                    unint64_t v111 = v140;
                  }
                  v131 += 8;
                  unint64_t v132 = v134;
                }

                while (v122 != v134);
              }

              else
              {
                unint64_t v124 = v210;
              }

              swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
              swift_bridgeObjectRelease(v104);
              unint64_t v142 = 0xA000000000000000LL;
              if (!(v124 & 0x8080808080808080LL | v111 & 0x80808080808080LL)) {
                unint64_t v142 = 0xE000000000000000LL;
              }
              *(void *)&v213[0] = v124;
            }
          }

          uint64_t v4 = 1LL;
        }

        uint64_t v41 = v211 & 0xFFFFFFFFFFFFLL;
        if (v4) {
          unint64_t v34 = HIBYTE(v92) & 0xF;
        }
        else {
          unint64_t v34 = v211 & 0xFFFFFFFFFFFFLL;
        }
        swift_bridgeObjectRetain_n(v92, 2LL, v93, v94);
        if ((*((void *)&v211 + 1) & 0x1000000000000000LL) != 0)
        {
LABEL_210:
          swift_bridgeObjectRetain_n(*((uint64_t *)&v211 + 1), 5LL, v38, v39);
          v193._unint64_t rawBits = 1LL;
          v194._unint64_t rawBits = (v34 << 16) | 1;
          v195._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v193, v194, v211, *((unint64_t *)&v211 + 1));
          if (v195._rawBits < 0x10000) {
            v195._rawBits |= 3;
          }
          uint64_t v32 = (const char *)specialized Collection.count.getter(v195, v196, v211, *((unint64_t *)&v211 + 1));
          swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
          if ((v28 & 0x1000000000000000LL) == 0)
          {
LABEL_113:
            BOOL v102 = __OFADD__(v40, v32);
            int64_t v103 = (int64_t)&v32[v40];
            if (!v102) {
              goto LABEL_114;
            }
            goto LABEL_215;
          }
        }

        else
        {
          swift_bridgeObjectRetain_n(*((uint64_t *)&v211 + 1), 4LL, v38, v39);
          uint64_t v32 = (const char *)v34;
          if ((v28 & 0x1000000000000000LL) == 0) {
            goto LABEL_113;
          }
        }

        Swift::Int v197 = String.UTF8View._foreignCount()();
        int64_t v103 = (int64_t)&v32[v197];
        if (!__OFADD__(v197, v32))
        {
LABEL_114:
          if ((v27 & ~v28 & 0x2000000000000000LL) != 0
            && swift_isUniquelyReferenced_nonNull_native(v28 & 0xFFFFFFFFFFFFFFFLL))
          {
            unint64_t v104 = *((void *)&v213[0] + 1);
            unint64_t v210 = *(void *)&v213[0];
            int64_t v105 = _StringGuts.nativeUnusedCapacity.getter(*(uint64_t *)&v213[0], *((uint64_t *)&v213[0] + 1));
            if ((v99 & 1) != 0) {
              goto LABEL_200;
            }
            if (v103 > 15) {
              goto LABEL_122;
            }
            if ((v104 & 0x2000000000000000LL) == 0)
            {
LABEL_122:
              _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v103, (int64_t)v32);
              if ((*((void *)&v211 + 1) & 0x1000000000000000LL) != 0)
              {
                _StringGuts._foreignAppendInPlace(_:)(v211, *((unint64_t *)&v211 + 1), 0LL, v34);
                uint64_t v110 = *((void *)&v211 + 1);
              }

              else
              {
                swift_bridgeObjectRelease_n(*((uint64_t *)&v211 + 1), 4LL);
                if (v4)
                {
                  swift_bridgeObjectRelease_n(*((uint64_t *)&v211 + 1), 2LL);
                  *(void *)&__int128 v212 = v211;
                  *((void *)&v212 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = *((void *)&v211 + 1) & 0xFFFFFFFFFFFFFFLL;
                  __int128 v129 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v30, (uint64_t)&v212, v30);
                  _StringGuts.appendInPlace(_:isASCII:)( v129,  v130,  (*((void *)&v211 + 1) & 0x4000000000000000LL) != 0);
                  swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
                  goto LABEL_167;
                }

                if ((v211 & 0x1000000000000000LL) != 0)
                {
                  swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
                  id v106 = (id)((*((void *)&v211 + 1) & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v107 = v41;
                }

                else
                {
                  id v106 = _StringObject.sharedUTF8.getter(v211, *((uint64_t *)&v211 + 1));
                  uint64_t v107 = v205;
                  swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
                  if (v107 < v41) {
                    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
                  }
                }

                uint64_t v108 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v41, (uint64_t)v106, v107);
                _StringGuts.appendInPlace(_:isASCII:)(v108, v109, (uint64_t)v211 < 0);
                uint64_t v110 = *((void *)&v211 + 1);
              }

              swift_bridgeObjectRelease_n(v110, 2LL);
              goto LABEL_167;
            }

            unint64_t v111 = v104;
          }

          else
          {
            if (v103 > 15) {
              goto LABEL_122;
            }
            unint64_t v104 = *((void *)&v213[0] + 1);
            unint64_t v111 = *((void *)&v213[0] + 1);
            unint64_t v210 = *(void *)&v213[0];
            if ((*((void *)&v213[0] + 1) & 0x2000000000000000LL) == 0)
            {
LABEL_128:
              if ((v104 & 0x1000000000000000LL) != 0)
              {
                unint64_t v210 = _StringGuts._foreignConvertedToSmall()(v210, v104);
                unint64_t v111 = v204;
              }

              else
              {
                if ((v210 & 0x1000000000000000LL) != 0)
                {
                  Swift::Int v112 = (unsigned __int8 *)((v104 & 0xFFFFFFFFFFFFFFFLL) + 32);
                  uint64_t v113 = v210 & 0xFFFFFFFFFFFFLL;
                }

                else
                {
                  Swift::Int v112 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v210, v104);
                  uint64_t v113 = v99;
                }

                swift_bridgeObjectRetain(v104, v99, v100, v101);
                closure #1 in _StringGuts._convertedToSmall()(v112, v113, &v212);
                swift_bridgeObjectRelease(v104);
                unint64_t v111 = *((void *)&v212 + 1);
                unint64_t v210 = v212;
              }
            }
          }

          v114._unint64_t rawBits = (v34 << 16) | 1;
          v115._unint64_t rawBits = 1LL;
          v116._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v115, v114, v211, *((unint64_t *)&v211 + 1));
          if (v116._rawBits < 0x10000) {
            v116._rawBits |= 3;
          }
          unint64_t v118 = specialized String.init(_:)(v116, v117, v211, *((unint64_t *)&v211 + 1));
          uint64_t v120 = v119;
          swift_bridgeObjectRelease(*((uint64_t *)&v211 + 1));
          if ((v120 & 0x2000000000000000LL) == 0) {
            goto LABEL_223;
          }
          swift_bridgeObjectRelease(v120);
          goto LABEL_136;
        }

  uint64_t result = 0LL;
  uint64_t v8 = 0;
LABEL_248:
  unint64_t v140 = v8;
LABEL_249:
  LOBYTE(v139[0]) = (a2 & 0x1000000000000000LL) != 0;
  return result;
}

  uint64_t v236 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000LL) == 0) {
    uint64_t v236 = v407 & 0xFFFFFFFFFFFFLL;
  }
  if (v236 || (v407 & ~v408 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v408);
    uint64_t v407 = 8236LL;
    v408 = 0xE200000000000000LL;
  }

  v145(6LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v237);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v145(7LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v238);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v145(8LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v239);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v145(9LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v240);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v145(10LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v241);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v145(11LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v242);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v145(12LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v243);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v145(13LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v101,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v244);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v245 = (uint64_t)v384;
  v145(14LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v245,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000LL, v246);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64_t v247 = (uint64_t)v385;
  v145(15LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v247,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v248._uint64_t countAndFlagsBits = 8236LL;
  v248._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v248);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  unint64_t v249 = (uint64_t)v386;
  v145(16LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v249,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v250._uint64_t countAndFlagsBits = 8236LL;
  v250._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v250);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  unint64_t v251 = (uint64_t)v387;
  v145(17LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v251,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v252._uint64_t countAndFlagsBits = 8236LL;
  v252._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v252);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  unint64_t v253 = (uint64_t)v388;
  v145(18LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v253,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v254._uint64_t countAndFlagsBits = 8236LL;
  v254._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v254);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int64x2_t v255 = (uint64_t)v389;
  v145(19LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v255,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v256._uint64_t countAndFlagsBits = 8236LL;
  v256._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v256);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int8x16_t v257 = (uint64_t)v390;
  v145(20LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v257,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v258._uint64_t countAndFlagsBits = 8236LL;
  v258._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v258);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int64x2_t v259 = (uint64_t)v391;
  v145(21LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v259,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v260._uint64_t countAndFlagsBits = 8236LL;
  v260._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v260);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int64x2_t v261 = (uint64_t)v392;
  v145(22LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v261,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v262._uint64_t countAndFlagsBits = 8236LL;
  v262._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v262);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int8x16_t v263 = (uint64_t)v393;
  v145(23LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v263,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v264._uint64_t countAndFlagsBits = 8236LL;
  v264._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v264);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int64x2_t v265 = (uint64_t)v394;
  v145(24LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v265,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v266._uint64_t countAndFlagsBits = 8236LL;
  v266._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v266);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int8x16_t v267 = (uint64_t)v395;
  v145(25LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v267,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v268._uint64_t countAndFlagsBits = 8236LL;
  v268._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v268);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint16x8_t v269 = (uint64_t)v396;
  v145(26LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v269,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v270._uint64_t countAndFlagsBits = 8236LL;
  v270._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v270);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64x2_t v271 = (uint64_t)v397;
  v145(27LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v271,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v272._uint64_t countAndFlagsBits = 8236LL;
  v272._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v272);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64x2_t v273 = (uint64_t)v398;
  v145(28LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v273,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v274._uint64_t countAndFlagsBits = 8236LL;
  v274._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v274);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  uint64x2_t v275 = (uint64_t)v399;
  v145(29LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v275,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v276._uint64_t countAndFlagsBits = 8236LL;
  v276._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v276);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  unint64_t v277 = (uint64_t)v400;
  v145(30LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v277,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v278._uint64_t countAndFlagsBits = 8236LL;
  v278._unint64_t object = (void *)0xE200000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v278);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  int64x2_t v279 = (uint64_t)v378;
  v145(31LL, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( v279,  (uint64_t)&v407,  v2,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v280._uint64_t countAndFlagsBits = 41LL;
  v280._unint64_t object = (void *)0xE100000000000000LL;
  DefaultStringInterpolation.appendLiteral(_:)(v280);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v407;
}

LABEL_228:
      unint64_t v30 = _StringGuts._foreignConvertedToSmall()(v30, v27);
      unint64_t v28 = v203;
      goto LABEL_52;
    }

            __break(1u);
            goto LABEL_229;
          }
        }

        __break(1u);
        goto LABEL_228;
      }

  v390 = v557;
  v391 = v567;
  v392 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000LL) == 0) {
    v392 = v566 & 0xFFFFFFFFFFFFLL;
  }
  if (v392 || (v566 & ~v567 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    v391 = 0xE200000000000000LL;
  }

  else
  {
    uint64_t v566 = 8236LL;
    v567 = 0xE200000000000000LL;
  }

  swift_bridgeObjectRelease(v391);
  v146(9LL, v162, AssociatedConformanceWitness);
  uint64_t v561 = (uint64_t *)v1;
  uint64_t v393 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v393, v390, v2);
  uint64_t v394 = v561;
  v395 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v396 = (void *)swift_getDynamicType(v395, v394, 1);
  LODWORD(v394) = swift_isOptionalType(v396);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v394)
  {
    memcpy(v151, v390, v2);
    v397 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v397, 7uLL);
  }

  else
  {
    v405 = v548;
    memcpy(v548, v390, v2);
    if (swift_dynamicCast((char *)&v560, v405, v1, (const char *)&type metadata for String, 6uLL))
    {
      v406 = v560._object;
      String.append(_:)(v560);
      swift_bridgeObjectRelease((uint64_t)v406);
      goto LABEL_239;
    }

    uint64_t v442 = v539;
    memcpy(v539, v390, v2);
    v443 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v442, v1, v443, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v444 = (uint64_t)v561;
      char v445 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v445 + 8))( &v566,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v444,  v445);
      goto LABEL_236;
    }

    uint64_t v565 = 0LL;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v480 = v521;
    memcpy(v521, v390, v2);
    v481 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (!swift_dynamicCast((char *)&v563, v480, v1, v481, 6uLL))
    {
      uint64_t v565 = 0LL;
      v563 = 0u;
      v564 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomStringConvertible?);
      v482 = v511;
      memcpy(v511, v390, v2);
      v483 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
      if (!swift_dynamicCast((char *)&v563, v482, v1, v483, 6uLL))
      {
        uint64_t v565 = 0LL;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v563,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((void *)&v564 + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = v1;
        v508 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
        memcpy(v508, v390, v2);
        Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
        v509 = v560._object;
        v510 = v562;
        ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v390,  &v560,  &v566,  0LL,  v1,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
        swift_release(v510);
        swift_release((uint64_t)v509);
        goto LABEL_239;
      }
    }

    outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
  }

  v398 = (uint64_t)v561;
  uint64_t v399 = v562;
  __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  uint64_t v400 = (*(uint64_t (**)(uint64_t, uint64_t))(v399 + 8))(v398, v399);
  v402 = v401;
  specialized String.write<A>(to:)(&v566, v400, v401, v403);
  swift_bridgeObjectRelease(v402);
LABEL_236:
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
LABEL_239:
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000LL, v404);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v146(10LL, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v151,  (uint64_t)&v566,  v1,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000LL, v407);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v146(11LL, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v151,  (uint64_t)&v566,  v1,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000LL, v408);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v146(12LL, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v151,  (uint64_t)&v566,  v1,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000LL, v409);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v146(13LL, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v151,  (uint64_t)&v566,  v1,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000LL, v410);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v146(14LL, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v151,  (uint64_t)&v566,  v1,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000LL, v411);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  v146(15LL, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)( (uint64_t)v151,  (uint64_t)&v566,  v1,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x29uLL, 0xE100000000000000LL, v412);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v566;
}

      unint64_t v146 = 0LL;
LABEL_229:
      if (v11 == 122) {
        unint64_t v147 = 162;
      }
      else {
        unint64_t v147 = 163;
      }
      unint64_t v148 = swift::Demangle::__runtime::Demangler::createWithChildren(v7, v147, v146, v29, v25);
      Node = v148;
      if (v20 && v148)
      {
LABEL_234:
        unint64_t v139 = (unsigned int *)Node;
        uint64_t v138 = v20;
LABEL_235:
        swift::Demangle::__runtime::Node::addChild(v139, v138, v7, a4, a5);
      }

      return (int8x16_t *)Node;
    case 'a':
      char v58 = 171;
      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    case 'b':
      char v94 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::popProtocol(this, a2, a3, a4, a5);
      uint64_t v95 = *((_DWORD *)v7 + 24);
      if (v95
        && (v96 = v95 - 1, unint64_t v97 = *(unsigned int **)(*((void *)v7 + 11) + 8LL * v96), *((_WORD *)v97 + 8) == 232))
      {
        *((_DWORD *)v7 + 24) = v96;
      }

      else
      {
        unint64_t v97 = 0LL;
      }

      unint64_t v142 = v7;
      uint64_t v143 = 269;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::createWithChildren( v142,  v143,  (swift::Demangle::__runtime::Node *)v97,  v94,  a5);
    case 'c':
      unint64_t v98 = *((_DWORD *)this + 24);
      if (v98
        && ((uint64_t v99 = v98 - 1,
             unint64_t v78 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * (v98 - 1)),
             uint64_t v100 = *((unsigned __int16 *)v78 + 8),
             v100 == 232)
         || swift::Demangle::__runtime::isContext(v100)))
      {
        *((_DWORD *)v7 + 24) = v99;
      }

      else
      {
        unint64_t v78 = 0LL;
      }

      this = v7;
      uint64_t v65 = 263;
      goto LABEL_223;
    case 'd':
      char v58 = 56;
      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    case 'e':
      swift::Demangle::__runtime::Demangler::demangleBridgedMethodParams(this, &__p);
      uint64_t v101 = __p.__r_.__value_.__s.__size_;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        BOOL v102 = __p.__r_.__value_.__s.__size_;
      }
      else {
        BOOL v102 = __p.__r_.__value_.__l.__size_;
      }
      if (v102)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        Node = swift::Demangle::__runtime::NodeFactory::createNode(v7, 277, p_p, v102);
        uint64_t v101 = __p.__r_.__value_.__s.__size_;
      }

      else
      {
        Node = 0LL;
      }

      if ((v101 & 0x80) == 0) {
        return (int8x16_t *)Node;
      }
      char v149 = (unint64_t *)__p.__r_.__value_.__r.__words[0];
      goto LABEL_277;
    case 'f':
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::demangleFunctionSpecialization(this, a2, a3, a4, a5);
    case 'g':
      unint64_t v59 = 91;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::demangleGenericSpecialization(this, v59, a3, a4, a5);
    case 'i':
      unint64_t v59 = 96;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::demangleGenericSpecialization(this, v59, a3, a4, a5);
    case 'j':
      unint64_t v104 = *((_DWORD *)this + 24);
      if (v104
        && ((int64_t v105 = v104 - 1,
             unint64_t v78 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * (v104 - 1)),
             id v106 = *((unsigned __int16 *)v78 + 8),
             v106 == 232)
         || swift::Demangle::__runtime::isContext(v106)))
      {
        *((_DWORD *)v7 + 24) = v105;
      }

      else
      {
        unint64_t v78 = 0LL;
      }

      this = v7;
      uint64_t v65 = 264;
      goto LABEL_223;
    case 'l':
      uint64_t v107 = swift::Demangle::__runtime::Demangler::popAssocTypeName(this, a2, a3, a4, a5);
      if (!v107) {
        return 0LL;
      }
      unint64_t v62 = (swift::Demangle::__runtime::Node *)v107;
      this = v7;
      uint64_t v65 = 270;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::createWithChild(this, v65, v62, a4, a5);
    case 'm':
      char v58 = 144;
      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    case 'n':
      unint64_t v66 = (char *)swift::Demangle::__runtime::Demangler::popProtocol(this, a2, a3, a4, a5);
      char v71 = swift::Demangle::__runtime::Demangler::popAssocTypePath(v7, v108, v109, v110, v111);
      Swift::Int v112 = *((_DWORD *)v7 + 24);
      if (v112
        && (uint64_t v113 = v112 - 1,
            char v74 = *(swift::Demangle::__runtime::Node **)(*((void *)v7 + 11) + 8LL * v113),
            *((_WORD *)v74 + 8) == 232))
      {
        *((_DWORD *)v7 + 24) = v113;
      }

      else
      {
        char v74 = 0LL;
      }

      unint64_t v140 = v7;
      unint64_t v141 = 267;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::createWithChildren( v140,  v141,  v74,  (swift::Demangle::__runtime::Node *)v71,  v66);
    case 'o':
      char v58 = 164;
      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    case 'p':
      uint64_t v75 = 86;
LABEL_151:
      Swift::String::Index v116 = (unsigned int *)swift::Demangle::__runtime::Demangler::demangleSpecAttributes(this, v75, a3, a4, a5);
      Swift::String::Index v117 = *((_DWORD *)v7 + 24);
      if (v117
        && (unint64_t v118 = v117 - 1,
            uint64_t v119 = *(swift::Demangle::__runtime::Node **)(*((void *)v7 + 11) + 8LL * v118),
            *((_WORD *)v119 + 8) == 232))
      {
        *((_DWORD *)v7 + 24) = v118;
      }

      else
      {
        uint64_t v119 = 0LL;
      }

      uint64_t v120 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::createWithChild( v7,  94,  v119,  v114,  v115);
      Node = 0LL;
      if (v116 && v120)
      {
        swift::Demangle::__runtime::Node::addChild(v116, v120, v7, v121, v122);
        return (int8x16_t *)v116;
      }

      return (int8x16_t *)Node;
    case 'q':
      uint64_t v123 = *((_DWORD *)this + 24);
      if (v123
        && ((unint64_t v124 = v123 - 1,
             unint64_t v78 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * (v123 - 1)),
             unint64_t v125 = *((unsigned __int16 *)v78 + 8),
             v125 == 232)
         || swift::Demangle::__runtime::isContext(v125)))
      {
        *((_DWORD *)v7 + 24) = v124;
      }

      else
      {
        unint64_t v78 = 0LL;
      }

      this = v7;
      uint64_t v65 = 265;
LABEL_223:
      unint64_t v62 = v78;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::createWithChild(this, v65, v62, a4, a5);
    case 's':
      unint64_t v59 = 95;
      return (int8x16_t *)swift::Demangle::__runtime::Demangler::demangleGenericSpecialization(this, v59, a3, a4, a5);
    case 'u':
      char v58 = 319;
      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    case 'v':
      uint64_t v126 = swift::Demangle::__runtime::Demangler::demangleIndex(this);
      if ((v126 & 0x80000000) != 0) {
        return 0LL;
      }
      __int128 v127 = *((void *)v7 + 9);
      if (v127 < *((void *)v7 + 8) && (*((void *)v7 + 9) = v127 + 1, *(_BYTE *)(*((void *)v7 + 7) + v127) == 114)) {
        return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(v7, 288, v126);
      }
      else {
        return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(v7, 287, v126);
      }
    case 'w':
      if (v9 >= v6) {
        return 0LL;
      }
      *((void *)this + 9) = v5 + 2;
      size_t v128 = *(char *)(v10 + v9);
      switch(v128)
      {
        case 'B':
          char v58 = 333;
          break;
        case 'S':
          char v58 = 340;
          break;
        case 'b':
          char v58 = 332;
          break;
        default:
          return 0LL;
      }

      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    case 'x':
      char v58 = 59;
      return (int8x16_t *)swift::Demangle::__runtime::NodeFactory::createNode(this, v58);
    default:
      return (int8x16_t *)Node;
  }

  do
  {
    if (v37 < v36)
    {
      *v37++ = Node;
      uint64_t v39 = v35;
      goto LABEL_64;
    }

    uint64_t v40 = v37 - v38;
    uint64_t v41 = v40 + 1;
    if ((unint64_t)(v40 + 1) >> 61) {
LABEL_302:
    }
      abort();
    else {
      uint64_t v42 = v41;
    }
    if (v42)
    {
      if (v42 >> 61) {
LABEL_303:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      int64_t v43 = (char *)operator new(8 * v42);
    }

    else
    {
      int64_t v43 = 0LL;
    }

    int64_t v44 = (unint64_t *)&v43[8 * v40];
    char *v44 = Node;
    char v45 = v44 + 1;
    if (v37 != v38)
    {
      uint64_t v46 = (char *)v37 - (char *)v38 - 8;
      if (v46 >= 0x168)
      {
        Swift::String::Index v51 = ((char *)(v37 - 1) - (char *)v38) & 0xFFFFFFFFFFFFFFF8LL;
        if (&v43[(char *)v37 - (char *)v38 - 8 - v51] > &v43[(char *)v37 - (char *)v38 - 8])
        {
          BOOL v47 = v37;
        }

        else if ((unint64_t *)((char *)v37 - v51 - 8) > v37 - 1)
        {
          BOOL v47 = v37;
        }

        else if ((unint64_t)((char *)v38 - v43) >= 0x20)
        {
          Swift::String::Index v52 = (v46 >> 3) + 1;
          Swift::String::Index v53 = 8 * (v52 & 0x3FFFFFFFFFFFFFFCLL);
          BOOL v47 = &v37[v53 / 0xFFFFFFFFFFFFFFF8LL];
          int64_t v44 = (unint64_t *)((char *)v44 - v53);
          unint64_t v54 = &v43[8 * v40 - 16];
          uint64_t v55 = v37 - 2;
          uint64_t v56 = v52 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            uint64_t v57 = *(_OWORD *)v55;
            *((_OWORD *)v54 - _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = *((_OWORD *)v55 - 1);
            *(_OWORD *)unint64_t v54 = v57;
            v54 -= 32;
            v55 -= 4;
            v56 -= 4LL;
          }

          while (v56);
          if (v52 == (v52 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_59;
          }
        }

        else
        {
          BOOL v47 = v37;
        }
      }

      else
      {
        BOOL v47 = v37;
      }

      do
      {
        uint64_t v48 = *--v47;
        *--int64_t v44 = v48;
      }

      while (v47 != v38);
LABEL_59:
      uint64_t v37 = v38;
    }

    uint64_t v38 = v44;
    char v36 = (unint64_t *)&v43[8 * v42];
    if (v37)
    {
      operator delete(v37);
      uint64_t v39 = *((_DWORD *)v7 + 24);
    }

    else
    {
      uint64_t v39 = v35;
    }

    uint64_t v37 = v45;
LABEL_64:
    if (!v39) {
      goto LABEL_282;
    }
    uint64_t v35 = v39 - 1;
    uint64_t v49 = *((void *)v7 + 11);
    Node = *(void *)(v49 + 8LL * (v39 - 1));
    *((_DWORD *)v7 + 24) = v39 - 1;
    if (!Node) {
      goto LABEL_300;
    }
    Swift::String::Index v50 = *(unsigned __int16 *)(Node + 16);
  }

  while (v50 == 232);
  if (v50 == 43)
  {
    if (v39 == 1
      || (unint64_t v178 = v39 - 2,
          unint64_t v179 = *(swift::Demangle::__runtime::Node **)(v49 + 8LL * v178),
          *((_DWORD *)v7 + 24) = v178,
          !v179))
    {
LABEL_282:
      Node = 0LL;
      goto LABEL_300;
    }

    unint64_t v180 = swift::Demangle::__runtime::Demangler::createWithChildren( v7,  v16,  v179,  (swift::Demangle::__runtime::Node *)Node,  a5);
  }

  else
  {
    unint64_t v180 = swift::Demangle::__runtime::Demangler::createWithChild( v7,  v16,  (swift::Demangle::__runtime::Node *)Node,  a4,  a5);
  }

  Node = v180;
  while (v37 != v38)
  {
    unint64_t v186 = (swift::Demangle::__runtime::Node *)*--v37;
    swift::Demangle::__runtime::Node::addChild((unsigned int *)Node, v186, v7, v181, v182);
  }

  if ((v192 & 1) != 0)
  {
    uint64_t v187 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v7, 217);
    swift::Demangle::__runtime::Node::addChild((unsigned int *)Node, v187, v7, v188, v189);
  }

LABEL_209:
    __break(1u);
    goto LABEL_210;
  }

  char v21 = 1;
  switch(v20)
  {
    case 'c':
      goto LABEL_11;
    case 'd':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
      goto LABEL_13;
    case 'e':
      char v21 = 2;
      goto LABEL_11;
    case 's':
      char v21 = 0;
      goto LABEL_11;
    case 't':
      char v21 = 3;
      goto LABEL_11;
    default:
      if (v20) {
        goto LABEL_13;
      }
      char v21 = 8;
LABEL_11:
      uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
      *(void *)a4 = a2;
      *(void *)(a4 + 8) = v15;
      *(_BYTE *)(a4 + 16) = v21;
      *(void *)(a4 + 24) = partial apply for closure #2 in Mirror.init(internalReflecting:subjectType:customAncestor:);
      *(void *)(a4 + 32) = v19;
      *(_BYTE *)(a4 + 4_assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_rawHashValue(_seed:) called on non-canonical AnyHashable box",  61LL,  2,  "Swift/NewtypeWrapper.swift",  26LL,  2,  0x4FuLL, 0) = 0;
      return result;
  }

    unint64_t v79 = v371;
    goto LABEL_210;
  }

uint64_t _EachFieldOptions.rawValue.getter()
{
  return *v0;
}

uint64_t _EachFieldOptions.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_EachFieldOptions.rawValue.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::_EachFieldOptions __swiftcall _EachFieldOptions.init(rawValue:)(Swift::_EachFieldOptions rawValue)
{
  v1->uint64_t rawValue = rawValue.rawValue;
  return rawValue;
}

void static _EachFieldOptions.classType.getter(_DWORD *a1@<X8>)
{
  *a1 = static _EachFieldOptions.classType;
}

int *static _EachFieldOptions.classType.setter(int *result)
{
  static _EachFieldOptions.classType = *result;
  return result;
}

uint64_t (*static _EachFieldOptions.classType.modify())()
{
  return EnumeratedSequence._base.modify;
}

void static _EachFieldOptions.ignoreUnknown.getter(_DWORD *a1@<X8>)
{
  *a1 = static _EachFieldOptions.ignoreUnknown;
}

int *static _EachFieldOptions.ignoreUnknown.setter(int *result)
{
  static _EachFieldOptions.ignoreUnknown = *result;
  return result;
}

uint64_t (*static _EachFieldOptions.ignoreUnknown.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for SetAlgebra.init() in conformance _EachFieldOptions(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

_DWORD *protocol witness for SetAlgebra.union(_:) in conformance _EachFieldOptions@<X0>( _DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 | *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.intersection(_:) in conformance _EachFieldOptions@<X0>( _DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.symmetricDifference(_:) in conformance _EachFieldOptions@<X0>( _DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 ^ *result;
  return result;
}

BOOL protocol witness for SetAlgebra.insert(_:) in conformance _EachFieldOptions(_DWORD *a1, int *a2)
{
  int v3 = *a2;
  int v4 = *v2 & *a2;
  if (v4 != *a2) {
    *v2 |= v3;
  }
  *a1 = v3;
  return v4 != v3;
}

_DWORD *protocol witness for SetAlgebra.remove(_:) in conformance _EachFieldOptions@<X0>( _DWORD *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *v2 & *result;
  if (v3) {
    *v2 &= ~*result;
  }
  *(_DWORD *)a2 = v3;
  *(_BYTE *)(a2 + 4) = v3 == 0;
  return result;
}

int *protocol witness for SetAlgebra.update(with:) in conformance _EachFieldOptions@<X0>( int *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  *v2 |= *result;
  int v5 = v4 & v3;
  *(_DWORD *)a2 = v5;
  *(_BYTE *)(a2 + 4) = v5 == 0;
  return result;
}

_DWORD *protocol witness for SetAlgebra.formUnion(_:) in conformance _EachFieldOptions(_DWORD *result)
{
  *v1 |= *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.formIntersection(_:) in conformance _EachFieldOptions( _DWORD *result)
{
  *v1 &= *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.formSymmetricDifference(_:) in conformance _EachFieldOptions( _DWORD *result)
{
  *v1 ^= *result;
  return result;
}

_DWORD *protocol witness for SetAlgebra.subtracting(_:) in conformance _EachFieldOptions@<X0>( _DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = *v2 & ~*result;
  return result;
}

uint64_t SetAlgebra.subtracting(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v21[1] = a4;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)v21 - v13;
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v17 = (char *)v21 - v16;
  MEMORY[0x1895F8858](v15);
  Swift::UInt v18 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v18((char *)v21 - v19, v4, a2);
  v18(v14, v4, a2);
  v18(v11, a1, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 64))(v11, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 56))(v17, a2, a3);
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v17, a2);
}

{
  uint64_t v4;
  SetAlgebra.subtracting(_:)(a1, a2, a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(v4, a2);
}

BOOL protocol witness for SetAlgebra.isSubset(of:) in conformance _EachFieldOptions(_DWORD *a1)
{
  return (*v1 & ~*a1) == 0;
}

uint64_t SetAlgebra.isSubset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v15 - v12;
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v11, v4, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))(a1, a2, a3);
  LOBYTE(v4) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(a3 + 8) + 8LL))(v13, v4, a2);
  (*(void (**)(char *, uint64_t))(v8 + 8))(v13, a2);
  return v4 & 1;
}

BOOL protocol witness for SetAlgebra.isDisjoint(with:) in conformance _EachFieldOptions(_DWORD *a1)
{
  return (*v1 & *a1) == 0;
}

uint64_t SetAlgebra.isDisjoint(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = (char *)&v14 - v11;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, v3, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 56))(a1, a2, a3);
  LOBYTE(a3) = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 152))(a2, a3);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v12, a2);
  return a3 & 1;
}

BOOL protocol witness for SetAlgebra.isSuperset(of:) in conformance _EachFieldOptions(_DWORD *a1)
{
  return (*a1 & ~*v1) == 0;
}

uint64_t SetAlgebra.isSuperset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(a3 + 128))(v3) & 1;
}

BOOL protocol witness for SetAlgebra.isEmpty.getter in conformance _EachFieldOptions()
{
  return *v0 == 0;
}

uint64_t SetAlgebra.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v12 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(uint64_t))(v10 + 32))(v7);
  LOBYTE(v3) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(a2 + 8) + 8LL))(v3, v9, a1);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a1);
  return v3 & 1;
}

uint64_t specialized SetAlgebra.init<A>(_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _DWORD *a3@<X8>)
{
  void (*v11)(uint64_t *__return_ptr, unint64_t, unint64_t);
  int v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v15 - v8;
  (*(void (**)(uint64_t, uint64_t))(a2 + 32))(a1, a2);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v11 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v16 & 0x100000000LL) != 0)
  {
    uint64_t v12 = 0;
  }

  else
  {
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = v16;
      v12 |= v13;
      v11(&v16, AssociatedTypeWitness, AssociatedConformanceWitness);
    }

    while (BYTE4(v16) != 1);
  }

  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v7 + 8))(v9, AssociatedTypeWitness);
  *a3 = v12;
  return result;
}

uint64_t SetAlgebra.init<A>(_:)@<X0>( char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v42 = a1;
  uint64_t v35 = (uint64_t)a5;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a2,  (uint64_t)&protocol requirements base descriptor for SetAlgebra,  associated type descriptor for SetAlgebra.Element);
  uint64_t v36 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v35 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v35 - v15;
  uint64_t v19 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v17, v18);
  MEMORY[0x1895F8858](v19);
  char v21 = (char *)&v35 - v20;
  uint64_t v22 = a5;
  uint64_t v23 = a3;
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  v22,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v37 = *(void *)(v24 - 8);
  MEMORY[0x1895F8858](v24);
  uint64_t v26 = (char *)&v35 - v25;
  unint64_t v27 = *(void (**)(uint64_t, uint64_t))(a4 + 32);
  uint64_t v39 = a6;
  uint64_t v40 = a2;
  uint64_t v38 = a4;
  v27(a2, a4);
  uint64_t v28 = v35;
  (*(void (**)(uint64_t, uint64_t))(v35 + 32))(v23, v35);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v28,  v23,  v24,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  unint64_t v30 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  unint64_t v41 = v24;
  uint64_t v42 = v26;
  v30(v24, AssociatedConformanceWitness);
  uint64_t v31 = v36;
  uint64_t v32 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v36 + 48);
  if (v32(v21, 1LL, AssociatedTypeWitness) != 1)
  {
    unint64_t v33 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
    do
    {
      v33(v14, v21, AssociatedTypeWitness);
      (*(void (**)(char *, char *, uint64_t))(v38 + 72))(v16, v14, v40);
      (*(void (**)(char *, unint64_t))(v31 + 8))(v16, AssociatedTypeWitness);
      v30(v41, AssociatedConformanceWitness);
    }

    while (v32(v21, 1LL, AssociatedTypeWitness) != 1);
  }

  return (*(uint64_t (**)(char *, unint64_t))(v37 + 8))(v42, v41);
}

_DWORD *protocol witness for SetAlgebra.subtract(_:) in conformance _EachFieldOptions(_DWORD *result)
{
  *v1 &= ~*result;
  return result;
}

uint64_t SetAlgebra.subtract(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v19 - v13;
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v19 - v15;
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v17(v14, v4, a2);
  v17(v11, a1, a2);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 64))(v11, a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(a3 + 104))(v16, a2, a3);
  return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v16, a2);
}

_DWORD *protocol witness for RawRepresentable.init(rawValue:) in conformance _EachFieldOptions@<X0>( _DWORD *result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *result;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance _EachFieldOptions(_DWORD *a1@<X8>)
{
  *a1 = *v1;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _EachFieldOptions( _DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

void specialized SetAlgebra<>.init(arrayLiteral:)(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    int v4 = 0;
    int v5 = (int *)(a1 + 32);
    do
    {
      int v7 = *v5++;
      int v6 = v7;
      if ((v7 & ~v4) == 0) {
        int v6 = 0;
      }
      v4 |= v6;
      --v3;
    }

    while (v3);
  }

  else
  {
    int v4 = 0;
  }

  swift_bridgeObjectRelease(a1);
  *a2 = v4;
}

uint64_t SetAlgebra<>.init(arrayLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a1;
  int v5 = *(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 160);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a3 + 16),  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByArrayLiteral,  associated type descriptor for ExpressibleByArrayLiteral.ArrayLiteralElement);
  uint64_t v9 = type metadata accessor for Array(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v9, v10);
  return v5(&v13, v9, WitnessTable, a2, a3);
}

Swift::_MetadataKind_optional __swiftcall _MetadataKind.init(rawValue:)(Swift::UInt rawValue)
{
  if ((uint64_t)rawValue > 1023)
  {
    if ((uint64_t)rawValue > 1280)
    {
      if (rawValue == 1281)
      {
        *uint64_t v1 = 14;
        return (Swift::_MetadataKind_optional)rawValue;
      }

      if (rawValue == 0xFFFF)
      {
        *uint64_t v1 = 15;
        return (Swift::_MetadataKind_optional)rawValue;
      }
    }

    else
    {
      if (rawValue == 1024)
      {
        *uint64_t v1 = 12;
        return (Swift::_MetadataKind_optional)rawValue;
      }

      if (rawValue == 1280)
      {
        *uint64_t v1 = 13;
        return (Swift::_MetadataKind_optional)rawValue;
      }
    }

uint64_t _MetadataKind.rawValue.getter()
{
  return qword_18180BDC0[*v0];
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _MetadataKind(char *a1, char *a2)
{
  return qword_18180BDC0[*a1] == qword_18180BDC0[*a2];
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance _MetadataKind()
{
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance _MetadataKind()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance _MetadataKind()
{
  return Hasher._finalize()();
}

Swift::_MetadataKind_optional protocol witness for RawRepresentable.init(rawValue:) in conformance _MetadataKind( Swift::UInt *a1)
{
  return _MetadataKind.init(rawValue:)(*a1);
}

void protocol witness for RawRepresentable.rawValue.getter in conformance _MetadataKind(void *a1@<X8>)
{
  *a1 = qword_18180BDC0[*v1];
}

uint64_t _forEachField(of:options:body:)( uint64_t *a1, int *a2, uint64_t (*a3)(char *, uint64_t, void *, char *))
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  int v5 = *a2;
  if (swift_isClassType(a1) == ((static _EachFieldOptions.classType & ~v5) != 0)) {
    return 0LL;
  }
  uint64_t v6 = swift_reflectionMirror_recursiveCount((unint64_t *)a1);
  if (v6 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v7 = (const char *)v6;
  if (!v6) {
    return 1LL;
  }
  uint64_t v8 = 0LL;
  while (1)
  {
    uint64_t v9 = swift_reflectionMirror_recursiveChildOffset((uint64_t)a1, (unint64_t)v8);
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    __int16 v20 = 0;
    uint64_t v10 = (void *)swift_reflectionMirror_recursiveChildMetadata(a1, v8, &v18);
    Swift::UInt MetadataKind = swift_getMetadataKind(v10);
    _MetadataKind.init(rawValue:)(MetadataKind);
    char v12 = v17 == 16 ? 15 : v17;
    uint64_t v13 = v18;
    if (!v18) {
      break;
    }
    char v17 = v12;
    if ((a3(v18, v9, v10, &v17) & 1) == 0)
    {
      uint64_t v15 = v19;
      if (!v19) {
        return 0LL;
      }
      uint64_t v16 = v13;
      goto LABEL_20;
    }

uint64_t _forEachFieldWithKeyPath<A>(of:options:body:)( uint64_t *a1, int *a2, uint64_t (*a3)(char *, void *), uint64_t a4, uint64_t a5)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  int v8 = *a2;
  if (swift_isClassType(a1) || (static _EachFieldOptions.classType & ~v8) == 0) {
    return 0LL;
  }
  int v10 = static _EachFieldOptions.ignoreUnknown;
  uint64_t v11 = swift_reflectionMirror_recursiveCount((unint64_t *)a1);
  if (v11 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  char v12 = (const char *)v11;
  if (!v11) {
    return 1LL;
  }
  uint64_t v13 = 0LL;
  int v27 = v10 & v8;
  while (1)
  {
    if (v12 == v13) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
    }
    unint64_t v14 = swift_reflectionMirror_recursiveChildOffset((uint64_t)a1, (unint64_t)v13);
    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    __int16 v30 = 0;
    uint64_t v15 = (void *)swift_reflectionMirror_recursiveChildMetadata(a1, v13, &v28);
    Swift::UInt MetadataKind = swift_getMetadataKind(v15);
    _MetadataKind.init(rawValue:)(MetadataKind);
    BOOL v18 = LOBYTE(into._position.value._rawValue) > 0xBu || ((1 << SLOBYTE(into._position.value._rawValue)) & 0x94F) == 0;
    if (!v18 && (v30 & 1) != 0) {
      break;
    }
    __int16 v20 = v29;
    if (v27 != v10)
    {
      if (!v29) {
        return 0LL;
      }
      uint64_t v26 = v28;
      goto LABEL_37;
    }

    if (v29) {
      v29(v28);
    }
LABEL_27:
    ++v13;
    uint64_t result = 1LL;
    if (v12 == v13) {
      return result;
    }
  }

  if (HIBYTE(v30) == 1) {
    uint64_t v19 = type metadata accessor for WritableKeyPath(0LL, a5, (uint64_t)v15, v17);
  }
  else {
    uint64_t v19 = type metadata accessor for KeyPath(0LL, a5, (uint64_t)v15, v17);
  }
  uint64_t v21 = swift_allocObject( v19,  ((*(unsigned int *)(v19 + 48) + 3LL) & 0x1FFFFFFFCLL) + 12,  *(unsigned __int16 *)(v19 + 52) | 3LL);
  void v21[2] = 0LL;
  into._position.value._uint64_t rawValue = v21 + 3;
  into._end.value._uint64_t rawValue = (char *)v21 + 36;
  Swift::UnsafeMutableRawBufferPointer v22 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes( 2147483652LL,  0LL,  (uint64_t)v22._position.value._rawValue,  (uint64_t)v22._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4LL, 4LL);
  if ((v14 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  if (HIDWORD(v14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, 0);
  uint64_t v23 = v28;
  if (v28)
  {
    char v24 = a3(v28, v21);
    swift_release((uint64_t)v21);
    if ((v24 & 1) == 0)
    {
      __int16 v20 = v29;
      if (!v29) {
        return 0LL;
      }
      uint64_t v26 = v23;
      goto LABEL_37;
    }

    goto LABEL_25;
  }

  char v25 = a3("", v21);
  swift_release((uint64_t)v21);
  if ((v25 & 1) != 0)
  {
LABEL_25:
    if (v29) {
      v29(v23);
    }
    goto LABEL_27;
  }

  __int16 v20 = v29;
  if (!v29) {
    return 0LL;
  }
  uint64_t v26 = 0LL;
LABEL_37:
  v20(v26);
  return 0LL;
}

uint64_t Repeated.count.getter()
{
  return *(void *)v0;
}

uint64_t Repeated.repeatedValue.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 16LL))( a2,  v2 + *(int *)(a1 + 28));
}

uint64_t Repeated.startIndex.getter()
{
  return 0LL;
}

uint64_t Repeated.endIndex.getter()
{
  return *(void *)v0;
}

uint64_t Repeated.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v18 - v12;
  unint64_t v14 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v14((char *)&v18 - v12, v4, a2);
  v14(v11, (uint64_t)v13, a2);
  if (a1 < 0)
  {
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, a2);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x51uLL,  0);
  }

  uint64_t v15 = *(void *)v11;
  uint64_t v16 = *(void (**)(char *, uint64_t))(v8 + 8);
  v16(v11, a2);
  if (v15 <= a1) {
    goto LABEL_5;
  }
  v16(v13, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8LL) + 16LL))( a3,  v4 + *(int *)(a2 + 28));
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance Repeated<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Repeated<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance Repeated<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Repeated<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

uint64_t protocol witness for Collection.endIndex.getter in conformance Repeated<A>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = Repeated.endIndex.getter();
  *a1 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Repeated<A>( void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = Repeated.subscript.read(v6, *a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*Repeated.subscript.read(void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  *a1 = v6;
  a1[1] = v7;
  uint64_t v8 = malloc(*(void *)(v7 + 64));
  a1[2] = v8;
  Repeated.subscript.getter(a2, a3, (uint64_t)v8);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.indices.getter in conformance Repeated<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.index(after:) in conformance Repeated<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

void *protocol witness for Collection.formIndex(after:) in conformance Repeated<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>( a1,  a2,  a3,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance Repeated<A>( void *a1, uint64_t a2, uint64_t a3, void *(*a4)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  uint64_t result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance Repeated<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 32LL))(a2, v4, a1);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a1, v6);
  uint64_t result = type metadata accessor for IndexingIterator(0LL, a1, WitnessTable, v8);
  *(void *)(a2 + *(int *)(result + 36)) = 0LL;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance Repeated<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Repeated<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t repeatElement<A>(_:count:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v7 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v14 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v7 + 16))(v9);
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Repetition count should be non-negative",  39LL,  2,  "Swift/Repeat.swift",  18LL,  2,  0x28uLL,  0);
  }
  *(void *)a4 = a2;
  uint64_t v12 = type metadata accessor for Repeated(0LL, a3, v10, v11);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v7 + 32))(&a4[*(int *)(v12 + 28)], v9, a3);
}

Swift::Void __swiftcall _replPrintLiteralString(_:)(Swift::String a1)
{
  unint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  uint64_t v3 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  inited = swift_initStackObject(v3, v16);
  *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_1817FFC60;
  inited[7] = &type metadata for String;
  inited[4] = countAndFlagsBits;
  inited[5] = object;
  uint64_t v8 = (unint64_t *)_playgroundPrintHook;
  if (_playgroundPrintHook)
  {
    uint64_t v9 = (unint64_t *)qword_18C565C68;
    unint64_t v14 = 0LL;
    unint64_t v15 = 0xE000000000000000LL;
    swift_bridgeObjectRetain((unint64_t)object, v4, v5, v6);
    outlined copy of (@escaping @callee_guaranteed (@guaranteed String) -> ())?(v8, v9, v10, v11);
    specialized _print<A>(_:separator:terminator:to:)( (uint64_t)inited,  32LL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v14);
    swift_bridgeObjectRelease((uint64_t)inited);
    uint64_t v12 = v15;
    ((void (*)(unint64_t, unint64_t))v8)(v14, v15);
    swift_bridgeObjectRelease(v12);
    outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v8, (uint64_t)v9);
  }

  else
  {
    swift_bridgeObjectRetain((unint64_t)object, v4, v5, v6);
    specialized _print<A>(_:separator:terminator:to:)( (uint64_t)inited,  32LL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  v13,  (void (*)(uint64_t *, uint64_t, char *, ValueMetadata *, _UNKNOWN **))_print_unlocked<A, B>(_:_:));
    swift_bridgeObjectRelease((uint64_t)inited);
  }

void _replDebugPrintln<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
  inited = swift_initStackObject(v4, v16);
  *((_OWORD *)inited + _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = xmmword_1817FFC60;
  inited[7] = a2;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))( boxed_opaque_existential_0Tm,  a1,  a2);
  uint64_t v11 = (void (*)(unint64_t, unint64_t))_playgroundPrintHook;
  if (_playgroundPrintHook)
  {
    uint64_t v12 = qword_18C565C68;
    unint64_t v14 = 0LL;
    unint64_t v15 = 0xE000000000000000LL;
    swift_retain((unint64_t *)qword_18C565C68, v7, v8, v9);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  32LL,  0xE100000000000000LL,  10LL,  0xE100000000000000LL,  &v14);
    swift_bridgeObjectRelease((uint64_t)inited);
    uint64_t v13 = v15;
    v11(v14, v15);
    swift_bridgeObjectRelease(v13);
    outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?((uint64_t)v11, v12);
  }

  else
  {
    specialized _print<A>(_:separator:terminator:to:)( (uint64_t)inited,  32LL,  0xE100000000000000LL,  10LL,  0xE100000000000000LL,  v10,  (void (*)(uint64_t *, uint64_t, char *, ValueMetadata *, _UNKNOWN **))_debugPrint_unlocked<A, B>(_:_:));
    swift_bridgeObjectRelease((uint64_t)inited);
  }

uint64_t static Result<>.== infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v39 = a5;
  uint64_t v40 = a6;
  uint64_t v44 = a1;
  uint64_t v45 = a2;
  uint64_t v43 = *(void *)(a4 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v38 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v42 = *(void *)(v10 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v37 = (char *)&v36 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = type metadata accessor for Result(0LL, v12, v13, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v36 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v36 - v20;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v15, v15, 0LL, 0LL);
  uint64_t v41 = *(TupleTypeMetadata2 - 1);
  uint64_t v23 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  char v25 = (unsigned __int8 *)&v36 - v24;
  uint64_t v26 = (unsigned __int8 *)&v36 + *(int *)(v23 + 48) - v24;
  int v27 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  v27((char *)&v36 - v24, v44, v15);
  v27((char *)v26, v45, v15);
  if (swift_getEnumCaseMultiPayload(v25, v15) != 1)
  {
    v27(v21, (uint64_t)v25, v15);
    if (swift_getEnumCaseMultiPayload(v26, v15) != 1)
    {
      uint64_t v32 = v42;
      unint64_t v33 = v37;
      (*(void (**)(char *, unsigned __int8 *, uint64_t))(v42 + 32))(v37, v26, a3);
      char v30 = (*(uint64_t (**)(char *, char *, uint64_t))(v39 + 8))(v21, v33, a3);
      unint64_t v34 = *(void (**)(char *, uint64_t))(v32 + 8);
      v34(v33, a3);
      v34(v21, a3);
      goto LABEL_9;
    }

    (*(void (**)(char *, uint64_t))(v42 + 8))(v21, a3);
    goto LABEL_7;
  }

  v27(v19, (uint64_t)v25, v15);
  if (swift_getEnumCaseMultiPayload(v26, v15) != 1)
  {
    (*(void (**)(char *, uint64_t))(v43 + 8))(v19, a4);
LABEL_7:
    char v30 = 0;
    uint64_t v16 = v41;
    uint64_t v15 = (uint64_t)TupleTypeMetadata2;
    goto LABEL_9;
  }

  uint64_t v28 = v43;
  uint64_t v29 = v38;
  (*(void (**)(char *, unsigned __int8 *, uint64_t))(v43 + 32))(v38, v26, a4);
  char v30 = (*(uint64_t (**)(char *, char *, uint64_t))(v40 + 8))(v19, v29, a4);
  uint64_t v31 = *(void (**)(char *, uint64_t))(v28 + 8);
  v31(v29, a4);
  v31(v19, a4);
LABEL_9:
  (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 8))(v25, v15);
  return v30 & 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <> Result<A, B>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return static Result<>.== infix(_:_:)( a1,  a2,  *(void *)(a3 + 16),  *(void *)(a3 + 24),  *(void *)(a4 - 8),  *(void *)(a4 - 16));
}

uint64_t Result<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = a4;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v23 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v9);
  uint64_t v17 = (char *)&v23 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v19 = (unsigned __int8 *)&v23 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(v20 + 16))(v19, v21, a2);
  if (swift_getEnumCaseMultiPayload(v19, a2) == 1)
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v8 + 32))(v11, v19, v7);
    Hasher._combine(_:)(1uLL);
    (*(void (**)(uint64_t, uint64_t))(v24 + 24))(a1, v7);
    return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v7);
  }

  else
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v14 + 32))(v17, v19, v13);
    Hasher._combine(_:)(0LL);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v13, a3);
    return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v17, v13);
  }

Swift::Int Result<>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  void v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  Result<>.hash(into:)((uint64_t)v4, a1, a2, a3);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> Result<A, B>( uint64_t a1, uint64_t a2)
{
  return Result<>.hashValue.getter(a1, *(void *)(a2 - 8), *(void *)(a2 - 16));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> Result<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Result<>.hash(into:)(a1, a2, *(void *)(a3 - 8), *(void *)(a3 - 16));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> Result<A, B>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t, uint64_t))Result<>.hash(into:));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> FlattenSequence<A><>.Index( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v5 = *(void *)(a3 - 16);
  uint64_t v6 = *(void *)(a3 - 8);
  v8[0] = 0LL;
  v8[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  uint64_t v8[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v8[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v8[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  a4(v8, a2, v6, v5);
  return Hasher._finalize()();
}

void Result.map<A>(_:)(void (*a1)(char *)@<X0>, void *a2@<X2>, uint64_t a3@<X3>, _BYTE *a4@<X8>)
{
  uint64_t v8 = a2[2];
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v20 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (unsigned __int8 *)&v20 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *, uint64_t))(v15 + 16))(v14, v16);
  if (swift_getEnumCaseMultiPayload(v14, (uint64_t)a2) == 1)
  {
    uint64_t v17 = a2[3];
    (*(void (**)(_BYTE *, unsigned __int8 *, uint64_t))(*(void *)(v17 - 8) + 32LL))(a4, v14, v17);
    unsigned int v18 = 1;
  }

  else
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v9 + 32))(v12, v14, v8);
    a1(v12);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
    unsigned int v18 = 0;
    uint64_t v17 = a2[3];
  }

  size_t v19 = type metadata accessor for Result(0LL, a3, v17, a2[4]);
  swift_storeEnumTagMultiPayload(a4, v19, v18);
}

void Result.mapError<A>(_:)( void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, _BYTE *a5@<X8>)
{
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (unsigned __int8 *)&v22 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *, uint64_t))(v17 + 16))(v16, v18);
  if (swift_getEnumCaseMultiPayload(v16, a2) == 1)
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v11 + 32))(v14, v16, v10);
    a1(v14);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    uint64_t v19 = *(void *)(a2 + 16);
    unsigned int v20 = 1;
  }

  else
  {
    uint64_t v19 = *(void *)(a2 + 16);
    (*(void (**)(_BYTE *, unsigned __int8 *, uint64_t))(*(void *)(v19 - 8) + 32LL))(a5, v16, v19);
    unsigned int v20 = 0;
  }

  size_t v21 = type metadata accessor for Result(0LL, v19, a3, a4);
  swift_storeEnumTagMultiPayload(a5, v21, v20);
}

void Result.flatMap<A>(_:)( void (*a1)(char *)@<X0>, void *a2@<X2>, uint64_t a3@<X3>, _BYTE *a4@<X8>)
{
  uint64_t v8 = a2[2];
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v19 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (unsigned __int8 *)&v19 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *, uint64_t))(v15 + 16))(v14, v16);
  if (swift_getEnumCaseMultiPayload(v14, (uint64_t)a2) == 1)
  {
    uint64_t v17 = a2[3];
    (*(void (**)(_BYTE *, unsigned __int8 *, uint64_t))(*(void *)(v17 - 8) + 32LL))(a4, v14, v17);
    size_t v18 = type metadata accessor for Result(0LL, a3, v17, a2[4]);
    swift_storeEnumTagMultiPayload(a4, v18, 1u);
  }

  else
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v9 + 32))(v12, v14, v8);
    a1(v12);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  }

void Result.flatMapError<A>(_:)( void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, _BYTE *a5@<X8>)
{
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v21 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (unsigned __int8 *)&v21 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *, uint64_t))(v17 + 16))(v16, v18);
  if (swift_getEnumCaseMultiPayload(v16, a2) == 1)
  {
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v11 + 32))(v14, v16, v10);
    a1(v14);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
  }

  else
  {
    uint64_t v19 = *(void *)(a2 + 16);
    (*(void (**)(_BYTE *, unsigned __int8 *, uint64_t))(*(void *)(v19 - 8) + 32LL))(a5, v16, v19);
    size_t v20 = type metadata accessor for Result(0LL, v19, a3, a4);
    swift_storeEnumTagMultiPayload(a5, v20, 0);
  }

uint64_t Result.get()@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v10 = (unsigned __int8 *)v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(unsigned __int8 *))(v11 + 16))(v10);
  uint64_t v12 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v5 + 32);
  v12(v8, v10, v4);
  swift_allocError(v4, a1[4], 0LL, 0);
  v12(v13, (unsigned __int8 *)v8, v4);
  return swift_willThrow();
}

uint64_t Result<>.init(catching:)@<X0>(void (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for Error);
  size_t v7 = type metadata accessor for Result(0LL, a2, v6, (uint64_t)&protocol self-conformance witness table for Error);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v13 - v10;
  a1(v9);
  swift_storeEnumTagMultiPayload(v11, v7, 0);
  return (*(uint64_t (**)(uint64_t, _BYTE *, size_t))(v8 + 32))(a3, v11, v7);
}

uint64_t ReversedCollection.Iterator._position.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a1 + 24) + 8LL),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a2,  v4,  AssociatedTypeWitness);
}

uint64_t ReversedCollection.Iterator._position.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a2 + 24) + 8LL),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 40LL))( v4,  a1,  AssociatedTypeWitness);
}

uint64_t (*ReversedCollection.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t ReversedCollection.Iterator.init(_base:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v17 - v11;
  uint64_t v13 = *(void *)(a2 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16))(a4, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v8 + 72))(a2, v8);
  (*(void (**)(uint64_t, uint64_t))(v13 + 8))(a1, a2);
  uint64_t v15 = type metadata accessor for ReversedCollection.Iterator(0LL, a2, a3, v14);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v10 + 32))( a4 + *(int *)(v15 + 36),  v12,  AssociatedTypeWitness);
}

uint64_t ReversedCollection.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v4 = a1;
  uint64_t v27 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(void *)(v6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v26 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  uint64_t v14 = (char *)&v26 - v13;
  uint64_t v15 = v3 + *(int *)(v4 + 36);
  (*(void (**)(char *, uint64_t, unint64_t))(v9 + 16))((char *)&v26 - v13, v15, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v7 + 64))(v5, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v4) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                           + 8LL))( v14,  v12,  AssociatedTypeWitness);
  uint64_t v17 = *(void (**)(char *, unint64_t))(v9 + 8);
  v17(v12, AssociatedTypeWitness);
  v17(v14, AssociatedTypeWitness);
  if ((v4 & 1) != 0)
  {
    unint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v25 - 8) + 56LL))( v27,  1LL,  1LL,  v25);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 40))(v15, v5, v6);
    uint64_t v18 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v7 + 80))( v28,  v15,  v5,  v7);
    uint64_t v20 = v19;
    unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v22 = *(void *)(v21 - 8);
    uint64_t v23 = v27;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v22 + 16))(v27, v20, v21);
    v18(v28, 0LL);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v22 + 56))(v23, 0LL, 1LL, v21);
  }

uint64_t protocol witness for IteratorProtocol.next() in conformance ReversedCollection<A>.Iterator@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v27 = a2;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v26 - v12;
  uint64_t v14 = v2 + *(int *)(a1 + 36);
  (*(void (**)(char *, uint64_t, unint64_t))(v8 + 16))((char *)&v26 - v12, v14, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v4, v6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v16 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v13,  v11,  AssociatedTypeWitness);
  uint64_t v17 = *(void (**)(char *, unint64_t))(v8 + 8);
  v17(v11, AssociatedTypeWitness);
  v17(v13, AssociatedTypeWitness);
  if ((v16 & 1) != 0)
  {
    unint64_t v25 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v6 + 8),  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v25 - 8) + 56LL))( v27,  1LL,  1LL,  v25);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 40))(v14, v4, v5);
    uint64_t v18 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v6 + 80))( v28,  v14,  v4,  v6);
    uint64_t v20 = v19;
    unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v6 + 8),  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v22 = *(void *)(v21 - 8);
    uint64_t v23 = v27;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v22 + 16))(v27, v20, v21);
    v18(v28, 0LL);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v22 + 56))(v23, 0LL, 1LL, v21);
  }

uint64_t ReversedCollection.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v18 - v10;
  uint64_t v12 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 32))(v14, v2, v5);
  (*(void (**)(uint64_t, char *, uint64_t))(v12 + 16))(a2, v14, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v5);
  uint64_t v16 = type metadata accessor for ReversedCollection.Iterator(0LL, v5, v4, v15);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v8 + 32))( a2 + *(int *)(v16 + 36),  v11,  AssociatedTypeWitness);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance ReversedCollection<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(v4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v18 - v10;
  uint64_t v12 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 32))(v14, v2, v5);
  (*(void (**)(uint64_t, char *, uint64_t))(v12 + 16))(a2, v14, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v14, v5);
  uint64_t v16 = type metadata accessor for ReversedCollection.Iterator(0LL, v5, v4, v15);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v8 + 32))( a2 + *(int *)(v16 + 36),  v11,  AssociatedTypeWitness);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t ReversedCollection.Index.base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a1 + 24) + 8LL),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a2,  v2,  AssociatedTypeWitness);
}

uint64_t ReversedCollection.Index.init(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a4,  a1,  AssociatedTypeWitness);
}

uint64_t static ReversedCollection.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                       + 8LL))( a1,  a2,  AssociatedTypeWitness) & 1;
}

uint64_t static ReversedCollection.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v7,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 40))( a1,  a2,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1;
}

uint64_t protocol witness for static Comparable.< infix(_:_:) in conformance ReversedCollection<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static ReversedCollection.Index.< infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance ReversedCollection<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static ReversedCollection.Index.== infix(_:_:)(a1, a2, *(void *)(a3 + 16), *(void *)(a3 + 24));
}

uint64_t ReversedCollection.Index<>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a2 + 24) + 8LL),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return v7(a1, AssociatedTypeWitness, a3);
}

Swift::Int ReversedCollection.Index<>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  uint64_t v3 = *(void (**)(void *, unint64_t, uint64_t))(a2 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a1 + 24) + 8LL),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  v3(v6, AssociatedTypeWitness, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <> ReversedCollection<A>.Index( uint64_t a1, uint64_t a2)
{
  return ReversedCollection.Index<>.hashValue.getter(a1, *(void *)(a2 - 8));
}

uint64_t protocol witness for Hashable.hash(into:) in conformance <> ReversedCollection<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ReversedCollection.Index<>.hash(into:)(a1, a2, *(void *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <> ReversedCollection<A>.Index( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t))ReversedCollection.Index<>.hash(into:));
}

uint64_t ReversedCollection.startIndex.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 8LL) + 72LL))(*(void *)(a1 + 16));
}

uint64_t ReversedCollection.endIndex.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 8LL) + 64LL))(*(void *)(a1 + 16));
}

uint64_t ReversedCollection.index(after:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 24) + 32LL))(a1, *(void *)(a2 + 16));
}

uint64_t ReversedCollection.index(before:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)(a2 + 24) + 8LL) + 184LL))( a1,  *(void *)(a2 + 16));
}

uint64_t ReversedCollection.index(_:offsetBy:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  BOOL v3 = __OFSUB__(0LL, a2);
  uint64_t v4 = -a2;
  if (!v3) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 48LL))( result,  v4,  *(void *)(a3 + 16));
  }
  __break(1u);
  return result;
}

uint64_t ReversedCollection.index(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v29 = a5;
  uint64_t v9 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(a4 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v8 + 8),  v9,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = *(void *)(v13 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v28 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t result = MEMORY[0x1895F8858](v15);
  uint64_t v20 = (char *)&v28 - v19;
  if (__OFSUB__(0LL, a2))
  {
    __break(1u);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56))(a1, -a2, a3, v9, v8);
    (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v17, v20, v13);
    uint64_t v21 = *(void *)(AssociatedTypeWitness - 8);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v21 + 48))(v17, 1LL, AssociatedTypeWitness) == 1)
    {
      uint64_t v23 = type metadata accessor for ReversedCollection.Index(0LL, v9, v8, v22);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v23 - 8) + 56LL))( v29,  1LL,  1LL,  v23);
    }

    else
    {
      uint64_t v24 = *(void (**)(uint64_t, char *, unint64_t))(v21 + 32);
      uint64_t v25 = v29;
      v24(v29, v17, AssociatedTypeWitness);
      uint64_t v27 = type metadata accessor for ReversedCollection.Index(0LL, v9, v8, v26);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v27 - 8) + 56LL))( v25,  0LL,  1LL,  v27);
    }
  }

  return result;
}

uint64_t ReversedCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a3 + 24) + 64LL))( a2,  a1,  *(void *)(a3 + 16));
}

uint64_t ReversedCollection.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(v5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  v6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = &v17[-v10];
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 32))(a1, v6, v5);
  uint64_t v12 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t, uint64_t))(v7 + 80))( v17,  v11,  v6,  v7);
  uint64_t v14 = v13;
  unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v15 - 8) + 16LL))(a3, v14, v15);
  v12(v17, 0LL);
  return (*(uint64_t (**)(_BYTE *, unint64_t))(v9 + 8))(v11, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t))ReversedCollection.index(before:));
}

uint64_t (*protocol witness for Collection.subscript.read in conformance ReversedCollection<A>( void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = ReversedCollection.subscript.read(v6, a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*ReversedCollection.subscript.read(void *a1, uint64_t a2, uint64_t a3))()
{
  uint64_t v5 = malloc(0x40uLL);
  *a1 = v5;
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t v8 = *(void *)(v6 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v7,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v10 = malloc(*(void *)(v9 + 64));
  uint64_t v5[4] = v10;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  v5[5] = v11;
  uint64_t v12 = *(void *)(v11 - 8);
  v5[6] = v12;
  uint64_t v13 = malloc(*(void *)(v12 + 64));
  v5[7] = v13;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32))(a2, v7, v6);
  uint64_t v14 = (void (*)(void *, void))(*(uint64_t (**)(void *, void *, uint64_t, uint64_t))(v8 + 80))( v5,  v10,  v7,  v8);
  (*(void (**)(void *))(v12 + 16))(v13);
  v14(v5, 0LL);
  (*(void (**)(void *, unint64_t))(v9 + 8))(v10, AssociatedTypeWitness);
  return LazyMapSequence<>.subscript.read;
}

void LazyMapSequence<>.subscript.read(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void **)(*(void *)a1 + 56LL);
  BOOL v3 = *(void **)(*(void *)a1 + 32LL);
  (*(void (**)(void *, void))(*(void *)(*(void *)a1 + 48LL) + 8LL))( v2,  *(void *)(*(void *)a1 + 40LL));
  free(v2);
  free(v3);
  free(v1);
}

uint64_t protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance ReversedCollection<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v4 = type metadata accessor for ReversedCollection.Index(255LL, *(void *)(a1 + 16), *(void *)(a1 + 24), a2);
  uint64_t v7 = type metadata accessor for Optional(0LL, v4, v5, v6);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56LL))(a3, 1LL, 1LL, v7);
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>( a1,  a2,  a3,  (void (*)(uint64_t, uint64_t))ReversedCollection.index(after:));
}

uint64_t protocol witness for BidirectionalCollection.formIndex(before:) in conformance ReversedCollection<A>( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t))
{
  uint64_t v7 = type metadata accessor for ReversedCollection.Index(0LL, *(void *)(a2 + 16), *(void *)(a2 + 24), (uint64_t)a4);
  uint64_t v8 = *(void *)(v7 - 8);
  MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v12 - v9;
  a4(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v8 + 8))(a1, v7);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v8 + 32))(a1, v10, v7);
}

uint64_t ReversedCollection.reversed()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 16) - 8LL) + 32LL))(a2, v2);
}

uint64_t BidirectionalCollection.reversed()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 32LL))(a2, v2);
}

uint64_t _stdlib_atomicCompareExchangeStrongPtr(object:expected:desired:)( unint64_t *a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3 = *a2;
  while (1)
  {
    unint64_t v4 = __ldaxr(a1);
    if (v4 != v3) {
      break;
    }
    if (!__stlxr(a3, a1))
    {
      uint64_t result = 1LL;
      *a2 = v4;
      return result;
    }
  }

  uint64_t result = 0LL;
  __clrex();
  *a2 = v4;
  return result;
}

uint64_t _stdlib_atomicCompareExchangeStrongPtr<A>(object:expected:desired:)( unint64_t *a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3 = *a2;
  while (1)
  {
    unint64_t v4 = __ldaxr(a1);
    if (v4 != v3) {
      break;
    }
    if (!__stlxr(a3, a1))
    {
      uint64_t result = 1LL;
      *a2 = v4;
      return result;
    }
  }

  uint64_t result = 0LL;
  __clrex();
  *a2 = v4;
  return result;
}

{
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  unint64_t v3 = *a2;
  while (1)
  {
    unint64_t v4 = __ldaxr(a1);
    if (v4 != v3) {
      break;
    }
    if (!__stlxr(a3, a1))
    {
      uint64_t result = 1LL;
      *a2 = v4;
      return result;
    }
  }

  uint64_t result = 0LL;
  __clrex();
  *a2 = v4;
  return result;
}

BOOL static Int64.>= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 >= a2;
}

Swift::Int String.UTF16View.count.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignCount()();
  }
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1;
  }
  return String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v2 << 16) | 7));
}

void *__SwiftNativeNSArray.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t __SwiftNativeNSArray.init()()
{
  return v0;
}

uint64_t __SwiftNativeNSArray.deinit()
{
  return v0;
}

void *_SwiftNativeNSMutableArray.__allocating_init()()
{
  return swift_allocObject(v0, 0x10uLL, 7uLL);
}

uint64_t _SwiftNativeNSMutableArray.init()()
{
  return v0;
}

uint64_t _SwiftNativeNSMutableArray.deinit()
{
  return v0;
}

void *__SwiftNativeNSSet.__allocating_init(coder:)(void *a1)
{
  return swift_allocObject(v1, 0x10uLL, 7uLL);
}

uint64_t __SwiftNativeNSSet.init(coder:)(void *a1)
{
  return v1;
}

uint64_t __SwiftNativeNSSet.deinit()
{
  return v0;
}

uint64_t static UInt64.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t DropFirstSequence.init(_:dropping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return DropFirstSequence.init(_:dropping:)( a1,  a2,  a3,  a4,  "Can't drop a negative number of elements from a sequence",  56LL,  0x1E3uLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for DropFirstSequence,  a5);
}

uint64_t DropFirstSequence.makeIterator()(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v4,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v6, v7);
  uint64_t v27 = *(void *)(v8 - 8);
  uint64_t v28 = v8;
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  unint64_t v11 = (char *)&v25 - v10;
  MEMORY[0x1895F8858](v9);
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))( (char *)&v25 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v1,  v3);
  (*(void (**)(uint64_t, uint64_t))(v4 + 32))(v3, v4);
  uint64_t v26 = a1;
  uint64_t v14 = *(int *)(a1 + 36);
  uint64_t v15 = v1;
  if (*(uint64_t *)(v1 + v14) >= 1)
  {
    unint64_t v16 = swift_getAssociatedTypeWitness( 255LL,  (const char *)v4,  v3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    uint64_t v17 = v4;
    uint64_t v18 = v16;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v17,  v3,  v16,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v20 = 0LL;
    uint64_t v21 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
    do
    {
      uint64_t v22 = swift_checkMetadataState(0LL, v18);
      v21(v22, AssociatedConformanceWitness);
      int v23 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 48LL))( v11,  1LL,  AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t))(v27 + 8))(v11, v28);
      if (v23 == 1) {
        break;
      }
      ++v20;
    }

    while (v20 < *(void *)(v15 + v14));
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)(v26 - 8) + 8LL))(v15);
}

uint64_t DropFirstSequence.dropFirst(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v4, v8);
  uint64_t v12 = *(void *)(v4 + *(int *)(a2 + 36));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8LL))(v4, a2);
  uint64_t v13 = v12 + a1;
  if (__OFADD__(v12, a1))
  {
    __break(1u);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a sequence",  56LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x1E3uLL,  0);
  }

  if (v13 < 0) {
    goto LABEL_5;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 32))(a3, v11, v8);
  *(void *)(a3 + *(int *)(a2 + 36)) = v13;
  return result;
}

uint64_t (*PrefixSequence._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t PrefixSequence._maxLength.getter(uint64_t a1)
{
  return *(void *)(v1 + *(int *)(a1 + 36));
}

uint64_t PrefixSequence.init(_:maxLength:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return DropFirstSequence.init(_:dropping:)( a1,  a2,  a3,  a4,  "Can't take a prefix of negative length",  38LL,  0x211uLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for PrefixSequence,  a5);
}

uint64_t DropFirstSequence.init(_:dropping:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t (*a8)(void, uint64_t, uint64_t)@<X7>, uint64_t a9@<X8>)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  a5,  a6,  2,  "Swift/Sequence.swift",  20LL,  2,  a7,  0);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a3 - 8) + 32LL))(a9, a1);
  uint64_t result = a8(0LL, a3, a4);
  *(void *)(a9 + *(int *)(result + 36)) = a2;
  return result;
}

uint64_t PrefixSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t PrefixSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*PrefixSequence.Iterator._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t PrefixSequence.Iterator._remaining.setter(uint64_t result, uint64_t a2)
{
  *(void *)(v2 + *(int *)(a2 + 36)) = result;
  return result;
}

uint64_t (*PrefixSequence.Iterator._remaining.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t PrefixSequence.Iterator.init(_:maxLength:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a5,  a1,  AssociatedTypeWitness);
  uint64_t result = type metadata accessor for PrefixSequence.Iterator(0LL, a3, (uint64_t)a4, v11);
  *(void *)(a5 + *(int *)(result + 36)) = a2;
  return result;
}

uint64_t PrefixSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(int *)(a1 + 36);
  uint64_t v5 = *(void *)(v2 + v4);
  if (v5)
  {
    *(void *)(v2 + v4) = v5 - 1;
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = *(const char **)(a1 + 24);
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  v7,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  v7,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v13 = *(uint64_t (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v10 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
    return v13(v10, AssociatedConformanceWitness);
  }

  else
  {
    unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v12 - 8) + 56LL))( a2,  1LL,  1LL,  v12);
  }

uint64_t PrefixSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v19 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(v8 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  v6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v19 - v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v10, v3, v6);
  (*(void (**)(uint64_t, uint64_t))(v11 + 32))(v6, v11);
  uint64_t v16 = *(void *)(v3 + *(int *)(a1 + 36));
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v3, a1);
  (*(void (**)(uint64_t, char *, unint64_t))(v13 + 32))(a2, v15, AssociatedTypeWitness);
  uint64_t result = type metadata accessor for PrefixSequence.Iterator(0LL, v6, v11, v17);
  *(void *)(a2 + *(int *)(result + 36)) = v16;
  return result;
}

uint64_t PrefixSequence.prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  else {
    uint64_t v12 = *(void *)(v8 + *(int *)(v7 + 36));
  }
  uint64_t v13 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 32);
  v13(v11, v8, v5);
  if (v12 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a prefix of negative length",  38LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x211uLL,  0);
  }
  uint64_t result = ((uint64_t (*)(uint64_t, char *, uint64_t))v13)(a3, v11, v5);
  *(void *)(a3 + *(int *)(a2 + 36)) = v12;
  return result;
}

uint64_t DropWhileSequence._iterator.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t DropWhileSequence._iterator.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*DropWhileSequence._iterator.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*DropWhileSequence._nextElement.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t DropWhileSequence.init(iterator:predicate:)@<X0>( uint64_t a1@<X0>, uint64_t (*a2)(char *)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v45 = a2;
  uint64_t v46 = a3;
  uint64_t v44 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v47 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v35 - v11;
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v36 = v15;
  uint64_t v37 = v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v35 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v35 - v20;
  uint64_t v43 = (uint64_t)a5;
  uint64_t v35 = type metadata accessor for DropWhileSequence(0LL, a4, (uint64_t)a5, v22);
  uint64_t v23 = a6 + *(int *)(v35 + 36);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v47 + 56))(v23, 1LL, 1LL, AssociatedTypeWitness);
  unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v24 - 8) + 32LL))(a6, v44, v24);
  uint64_t v25 = a4;
  uint64_t v26 = v36;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v43,  v25,  v24,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v28 = *(void (**)(unint64_t, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v43 = AssociatedConformanceWitness;
  uint64_t v44 = a6;
  uint64_t v42 = v28;
  ((void (*)(unint64_t))v28)(v24);
  uint64_t v29 = v37;
  uint64_t v41 = *(void (**)(uint64_t, char *, uint64_t))(v37 + 40);
  v41(v23, v21, v26);
  uint64_t v30 = v29;
  uint64_t v31 = v47;
  uint64_t v40 = *(void (**)(char *, uint64_t, uint64_t))(v30 + 16);
  v40(v19, v23, v26);
  uint64_t v39 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v31 + 48);
  if (v39(v19, 1LL, AssociatedTypeWitness) == 1) {
    return (*(uint64_t (**)(char *, uint64_t))(v37 + 8))(v19, v26);
  }
  uint64_t v38 = *(void (**)(char *, char *, unint64_t))(v31 + 32);
  while (1)
  {
    v38(v12, v19, AssociatedTypeWitness);
    char v32 = v45(v12);
    if (v6) {
      break;
    }
    char v33 = v32;
    uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v47 + 8))(v12, AssociatedTypeWitness);
    if ((v33 & 1) == 0) {
      return result;
    }
    v42(v24, v43);
    v41(v23, v21, v26);
    v40(v19, v23, v26);
    if (v39(v19, 1LL, AssociatedTypeWitness) == 1) {
      return (*(uint64_t (**)(char *, uint64_t))(v37 + 8))(v19, v26);
    }
  }

  (*(void (**)(char *, unint64_t))(v47 + 8))(v12, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v35 - 8) + 8LL))(v44, v35);
}

uint64_t DropWhileSequence.init(_:predicate:)@<X0>( uint64_t (*a1)(char *)@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v27 = a1;
  uint64_t v28 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v25 - v9;
  uint64_t v12 = type metadata accessor for DropWhileSequence(0LL, a3, a4, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v25 - v15;
  uint64_t v17 = *(int *)(v14 + 36);
  uint64_t v26 = a5;
  uint64_t v18 = a5 + v17;
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v19 - 8) + 56LL))( v18,  1LL,  1LL,  v19);
  (*(void (**)(uint64_t, uint64_t))(a4 + 32))(a3, a4);
  uint64_t v20 = v29;
  DropWhileSequence.init(iterator:predicate:)((uint64_t)v10, v27, v28, a3, (const char *)a4, (uint64_t)v16);
  uint64_t v23 = type metadata accessor for Optional(0LL, v19, v21, v22);
  if (v20) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v23 - 8) + 8LL))(v18, v23);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v23 - 8) + 8LL))(v18, v23);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v13 + 32))(v26, v16, v12);
}

uint64_t DropWhileSequence.Iterator._iterator.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t DropWhileSequence.Iterator._iterator.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*DropWhileSequence.Iterator._iterator.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t DropWhileSequence._nextElement.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = v2 + *(int *)(a1 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a1 + 24),  *(void *)(a1 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v6, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16LL))(a2, v4, v8);
}

uint64_t DropWhileSequence._nextElement.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2 + *(int *)(a2 + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(a2 + 24),  *(void *)(a2 + 16),  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v6, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 40LL))(v4, a1, v8);
}

uint64_t (*DropWhileSequence.Iterator._nextElement.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t DropWhileSequence.Iterator.init(_:nextElement:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = a5 + *(int *)(type metadata accessor for DropWhileSequence.Iterator(0LL, a3, (uint64_t)a4, (uint64_t)a4) + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56LL))( v10,  1LL,  1LL,  AssociatedTypeWitness);
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(v12 - 8) + 32LL))(a5, a1, v12);
  uint64_t v15 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v13, v14);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v15 - 8) + 40LL))(v10, a2, v15);
}

uint64_t DropWhileSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v26 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v9 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v10 = *(void *)(v9 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v25 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v25 - v14;
  uint64_t v16 = *(int *)(a1 + 36);
  uint64_t v25 = v2;
  uint64_t v17 = v2 + v16;
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))((char *)&v25 - v14, v2 + v16, v9);
  uint64_t v18 = *(void *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48))(v15, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, v9);
    uint64_t v19 = 1LL;
  }

  else
  {
    (*(void (**)(uint64_t, char *, unint64_t))(v18 + 32))(v26, v15, AssociatedTypeWitness);
    unint64_t v20 = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v4,  v5,  v20,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    uint64_t v22 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
    uint64_t v23 = swift_checkMetadataState(0LL, v20);
    v22(v23, AssociatedConformanceWitness);
    (*(void (**)(uint64_t, char *, uint64_t))(v10 + 40))(v17, v13, v9);
    uint64_t v19 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v18 + 56))( v26,  v19,  1LL,  AssociatedTypeWitness);
}

uint64_t DropWhileSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(const char **)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v23 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v9 = *(void *)(v23 - 8);
  MEMORY[0x1895F8858](v23);
  uint64_t v11 = (char *)&v23 - v10;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  v4,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v13 = *(void *)(v12 - 8);
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (char *)&v23 - v14;
  (*(void (**)(char *, uint64_t, unint64_t))(v13 + 16))((char *)&v23 - v14, v2, v12);
  uint64_t v16 = v2 + *(int *)(a1 + 36);
  uint64_t v17 = v23;
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, v16, v23);
  uint64_t v19 = type metadata accessor for DropWhileSequence.Iterator(0LL, v5, (uint64_t)v4, v18);
  uint64_t v20 = v24;
  uint64_t v21 = v24 + *(int *)(v19 + 36);
  (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 56LL))( v21,  1LL,  1LL,  AssociatedTypeWitness);
  (*(void (**)(uint64_t, char *, unint64_t))(v13 + 32))(v20, v15, v12);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 40))(v21, v11, v17);
}

uint64_t DropWhileSequence.drop(while:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v35 = a1;
  uint64_t v36 = a2;
  uint64_t v37 = a4;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(const char **)(a3 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v6,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v32 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v33 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v34 = (char *)&v30 - v8;
  unint64_t v9 = swift_getAssociatedTypeWitness( 255LL,  v6,  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v12 = type metadata accessor for Optional(0LL, v9, v10, v11);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v30 - v15;
  uint64_t v17 = *(void *)(v9 - 8);
  MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v30 - v18;
  uint64_t v38 = a3;
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v16, v40 + *(int *)(a3 + 36), v12);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v17 + 48))(v16, 1LL, v9) == 1)
  {
    (*(void (**)(char *, uint64_t))(v13 + 8))(v16, v12);
    uint64_t v20 = v38;
    uint64_t v21 = v40;
    uint64_t v22 = v37;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v20 - 8) + 32LL))(v22, v21, v20);
  }

  uint64_t v31 = v6;
  (*(void (**)(char *, char *, unint64_t))(v17 + 32))(v19, v16, v9);
  uint64_t v25 = v35;
  uint64_t v24 = v36;
  uint64_t v26 = v39;
  char v27 = v35(v19);
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)(v38 - 8) + 8LL))(v40);
    return (*(uint64_t (**)(char *, unint64_t))(v17 + 8))(v19, v9);
  }

  else
  {
    char v28 = v27;
    (*(void (**)(char *, unint64_t))(v17 + 8))(v19, v9);
    uint64_t v21 = v40;
    uint64_t v22 = v37;
    uint64_t v20 = v38;
    if ((v28 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v20 - 8) + 32LL))(v22, v21, v20);
    }
    uint64_t v29 = (uint64_t)v34;
    (*(void (**)(char *, uint64_t, unint64_t))(v32 + 16))(v34, v40, v33);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v20 - 8) + 8LL))(v21, v20);
    return DropWhileSequence.init(iterator:predicate:)(v29, v25, v24, v5, v31, v22);
  }

uint64_t protocol witness for Sequence.makeIterator() in conformance DropWhileSequence<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v2, a1);
}

uint64_t Sequence.map<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return Collection.map<A>(_:)( a1,  a2,  a3,  a4,  a5,  (uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error),  (uint64_t (*)(uint64_t, void *))_sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSTRzsAE_pRsd_0_r_0_lIetMgnozo_Tpq5Tm);
}

uint64_t Collection.map<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t (*a7)(uint64_t, void *))
{
  uint64_t v8[2] = a3;
  uint64_t v8[3] = a4;
  v8[4] = a5;
  void v8[5] = a1;
  v8[6] = a2;
  return a7(a6, v8);
}

uint64_t Sequence<>.split(separator:maxSplits:omittingEmptySubsequences:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)( a1,  a2,  a3,  a4,  a5,  a6,  (uint64_t)partial apply for closure #1 in Sequence<>.contains(_:),  (uint64_t (*)(uint64_t, uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))Sequence.split(maxSplits:omittingEmptySubsequences:whereSeparator:));
}

uint64_t Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, _BYTE *, uint64_t, uint64_t))
{
  uint64_t v23 = a8;
  uint64_t v10 = v8;
  uint64_t v17 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))( (char *)&v22 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL),  v10,  v19);
  uint64_t v25 = a4;
  uint64_t v26 = a5;
  uint64_t v27 = a6;
  uint64_t v28 = a1;
  uint64_t v20 = v23(a2, a3, a7, v24, a4, a5);
  (*(void (**)(uint64_t, uint64_t))(v17 + 8))(v10, a4);
  return v20;
}

void (*Sequence.split(maxSplits:omittingEmptySubsequences:whereSeparator:)( uint64_t a1, char a2, uint64_t (*a3)(char *), uint64_t a4, uint64_t a5, uint64_t a6))(char *, unint64_t)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Must take zero or more splits",  29LL,  2,  "Swift/Sequence.swift",  20LL,  2,  0x3CBuLL,  0);
  }
  (*(void (**)(uint64_t, uint64_t))(a6 + 56))(a5, a6);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a6,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v15 = type metadata accessor for Array(0LL, AssociatedTypeWitness, v13, v14);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v15, v16);
  return Collection.split(maxSplits:omittingEmptySubsequences:whereSeparator:)(a1, a2 & 1, a3, a4, v15, WitnessTable);
}

uint64_t specialized Sequence._copySequenceContents(initializing:)( Swift::String::Index *a1, uint64_t a2, uint64_t a3, Swift::String::Index position, Swift::UInt64 a5, unint64_t a6, unint64_t a7)
{
  if (a2)
  {
    if (a3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
    if (a3)
    {
      uint64_t v9 = 0LL;
      Swift::UInt64 v10 = a5 >> 14;
      uint64_t v11 = (a6 >> 59) & 1;
      if ((a7 & 0x1000000000000000LL) == 0) {
        LOBYTE(v1_NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(capacity, 1) = 1;
      }
      uint64_t v12 = 4LL << v11;
      Swift::UInt64 v13 = position._rawBits >> 14;
      uint64_t v14 = a7 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v15 = (a7 & 0xFFFFFFFFFFFFFFFLL) + 32;
      unint64_t v16 = a6 & 0xFFFFFFFFFFFFLL;
      if ((a7 & 0x2000000000000000LL) != 0) {
        unint64_t v16 = HIBYTE(a7) & 0xF;
      }
      Swift::UInt64 rawBits = position._rawBits;
      while (1)
      {
        Swift::UInt64 v18 = rawBits >> 14;
        if (rawBits >> 14 == v10) {
          goto LABEL_31;
        }
        Swift::UInt64 v19 = rawBits & 0xC;
        Swift::UInt64 v20 = rawBits;
        if (v19 == v12)
        {
          uint64_t v54 = a2;
          uint64_t v58 = a3;
          Swift::UInt64 v63 = a5;
          uint64_t v68 = v15;
          Swift::UInt64 v24 = v10;
          unint64_t v25 = a6;
          Swift::UInt64 v73 = v13;
          uint64_t v78 = v9;
          Swift::UInt64 v26 = position._rawBits;
          uint64_t v27 = v14;
          unint64_t v28 = v16;
          Swift::UInt64 v20 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          unint64_t v16 = v28;
          uint64_t v15 = v68;
          Swift::UInt64 v13 = v73;
          uint64_t v14 = v27;
          uint64_t v9 = v78;
          position._Swift::UInt64 rawBits = v26;
          a6 = v25;
          a2 = v54;
          a3 = v58;
          Swift::UInt64 v10 = v24;
          a5 = v63;
          Swift::UInt64 v18 = v20 >> 14;
          if (v20 >> 14 < v73) {
LABEL_32:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/Substring.swift",  21LL,  2,  0x29BuLL,  0);
        }

        else if (v18 < v13)
        {
          goto LABEL_32;
        }

        if (v18 >= v10) {
          goto LABEL_32;
        }
        if ((a7 & 0x1000000000000000LL) != 0)
        {
          uint64_t v55 = a2;
          uint64_t v59 = a3;
          Swift::UInt64 v64 = a5;
          unint64_t v69 = v16;
          Swift::UInt64 v29 = v10;
          unint64_t v30 = a6;
          Swift::UInt64 v31 = position._rawBits;
          uint64_t v74 = v14;
          uint64_t v79 = v9;
          uint64_t v32 = v15;
          Swift::UInt8 v23 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)v20);
          unint64_t v16 = v69;
          uint64_t v14 = v74;
          uint64_t v15 = v32;
          uint64_t v9 = v79;
          position._Swift::UInt64 rawBits = v31;
          a6 = v30;
          a2 = v55;
          a3 = v59;
          Swift::UInt64 v10 = v29;
          a5 = v64;
          if (v19 != v12) {
            goto LABEL_20;
          }
        }

        else
        {
          Swift::UInt64 v21 = v20 >> 16;
          if ((a7 & 0x2000000000000000LL) != 0)
          {
            v82[0] = a6;
            v82[1] = v14;
            Swift::UInt8 v23 = *((_BYTE *)v82 + v21);
            if (v19 != v12) {
              goto LABEL_20;
            }
          }

          else
          {
            uint64_t v22 = (_BYTE *)v15;
            if ((a6 & 0x1000000000000000LL) == 0)
            {
              unint64_t v53 = a6;
              uint64_t v57 = a2;
              Swift::UInt64 v62 = position._rawBits;
              Swift::UInt64 v67 = a5;
              uint64_t v77 = v14;
              Swift::UInt64 v81 = v10;
              uint64_t v49 = a3;
              uint64_t v50 = v9;
              uint64_t v51 = v15;
              unint64_t v72 = v16;
              uint64_t v22 = _StringObject.sharedUTF8.getter(a6, a7);
              unint64_t v16 = v72;
              uint64_t v14 = v77;
              uint64_t v15 = v51;
              uint64_t v9 = v50;
              a2 = v57;
              position._Swift::UInt64 rawBits = v62;
              a6 = v53;
              a3 = v49;
              Swift::UInt64 v10 = v81;
              a5 = v67;
            }

            Swift::UInt8 v23 = v22[v21];
            if (v19 != v12)
            {
LABEL_20:
              if ((a7 & 0x1000000000000000LL) != 0) {
                goto LABEL_26;
              }
              goto LABEL_21;
            }
          }
        }

        Swift::UInt8 v65 = v23;
        v33._Swift::UInt64 rawBits = rawBits;
        uint64_t v56 = a2;
        uint64_t v60 = a3;
        Swift::UInt64 v34 = a5;
        Swift::UInt64 v35 = v10;
        unint64_t v36 = a6;
        Swift::UInt64 v37 = position._rawBits;
        uint64_t v38 = v9;
        unint64_t v70 = v16;
        uint64_t v75 = v14;
        uint64_t v39 = v15;
        v40._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v33)._rawBits;
        unint64_t v16 = v70;
        uint64_t v14 = v75;
        uint64_t v15 = v39;
        uint64_t v9 = v38;
        position._Swift::UInt64 rawBits = v37;
        a6 = v36;
        a2 = v56;
        a3 = v60;
        Swift::UInt64 v10 = v35;
        a5 = v34;
        Swift::UInt64 rawBits = v40._rawBits;
        Swift::UInt8 v23 = v65;
        if ((a7 & 0x1000000000000000LL) != 0)
        {
LABEL_26:
          Swift::UInt8 v66 = v23;
          uint64_t v71 = v15;
          uint64_t v76 = v14;
          uint64_t v80 = v9;
          Swift::UInt64 v61 = position._rawBits;
          if (v16 <= rawBits >> 16) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
          }
          uint64_t v41 = a3;
          uint64_t v42 = a2;
          Swift::UInt64 v43 = v10;
          Swift::UInt64 v44 = a5;
          unint64_t v45 = v16;
          v46._Swift::UInt64 rawBits = rawBits;
          unint64_t v47 = a6;
          v48._Swift::UInt64 rawBits = String.UTF8View._foreignIndex(after:)(v46)._rawBits;
          a6 = v47;
          Swift::UInt64 rawBits = v48._rawBits;
          a5 = v44;
          Swift::UInt64 v10 = v43;
          a2 = v42;
          a3 = v41;
          position._Swift::UInt64 rawBits = v61;
          uint64_t v14 = v76;
          uint64_t v9 = v80;
          uint64_t v15 = v71;
          unint64_t v16 = v45;
          Swift::UInt8 v23 = v66;
          goto LABEL_28;
        }