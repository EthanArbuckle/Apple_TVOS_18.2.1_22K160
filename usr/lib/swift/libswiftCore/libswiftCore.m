uint64_t min<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  else {
    v9 = a1;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, v9, a3);
}

Swift::Int min<A>(_:_:_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, char *a7@<X8>)
{
  uint64_t v48 = a2;
  uint64_t v49 = a4;
  v46 = a3;
  uint64_t v11 = *(a5 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  v14 = (char *)&v43 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  v17 = (char *)&v43 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  v20 = (char *)&v43 - v19;
  uint64_t v44 = v21;
  MEMORY[0x1895F8858](v18);
  v23 = (char *)&v43 - v22;
  v25 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v24 + 16);
  if ((v25(v26, a1, v27, v24) & 1) != 0) {
    uint64_t v28 = v48;
  }
  else {
    uint64_t v28 = a1;
  }
  v29 = *(void (**)(char *, uint64_t, uint64_t *))(v11 + 16);
  v29(v23, v28, a5);
  v47 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t))v25;
  uint64_t v48 = a6;
  if ((v25((uint64_t)v46, (uint64_t)v23, (uint64_t)a5, a6) & 1) != 0)
  {
    (*(void (**)(char *, uint64_t *))(v11 + 8))(v23, a5);
    v29(a7, (uint64_t)v46, a5);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t *))(v11 + 32))(a7, v23, a5);
  }

  v30 = v29;
  uint64_t v31 = v49;
  Swift::Int result = Array._getCount()();
  v46 = (void *)result;
  if (result)
  {
    unint64_t v33 = 0LL;
    unint64_t v45 = v31 & 0xC000000000000001LL;
    do
    {
      BOOL v34 = v45 == 0;
      char v35 = v34 | ~_swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v33, v35 & 1);
      if ((v35 & 1) != 0)
      {
        unint64_t v36 = v31
        v37 = v30;
        v30(v17, v36, a5);
      }

      else
      {
        id v42 = _ArrayBuffer._getElementSlowPath(_:)(v33, v31, a5);
        v39 = v42;
        if (v44 != 8) {
          goto LABEL_20;
        }
        id v50 = v42;
        v37 = v30;
        v30(v17, (uint64_t)&v50, a5);
        swift_unknownObjectRelease(v39);
      }

      v38 = *(void (**)(char *, char *, uint64_t *))(v11 + 32);
      v38(v20, v17, a5);
      v39 = (void *)(v33 + 1);
      if (__OFADD__(v33, 1LL))
      {
        __break(1u);
LABEL_20:
        swift_unknownObjectRelease(v39);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

      v38(v14, v20, a5);
      char v40 = v47(v14, (uint64_t)a7, a5, v48);
      v41 = *(void (**)(uint64_t, uint64_t *))(v11 + 8);
      if ((v40 & 1) != 0)
      {
        v41((uint64_t)a7, a5);
        Swift::Int result = ((uint64_t (*)(char *, char *, uint64_t *))v38)(a7, v14, a5);
      }

      else
      {
        Swift::Int result = ((uint64_t (*)(char *, uint64_t *))v41)(v14, a5);
      }

      v30 = v37;
      ++v33;
      uint64_t v31 = v49;
    }

    while (v39 != v46);
  }

  return result;
}

uint64_t Collection<>.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v10 = (char *)&v15 - v9;
  uint64_t v11 = *(void *)(a1 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 16))(a3, v3, a1);
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v11 + 8))(v3, a1);
  uint64_t v13 = type metadata accessor for IndexingIterator(0LL, a1, a2, v12);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v8 + 32))( a3 + *(int *)(v13 + 36),  v10,  AssociatedTypeWitness);
}

uint64_t IndexingIterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v4 = a1;
  uint64_t v32 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v31 = *(void *)(v5 - 8);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  v30 = (char *)&v29 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *(void *)(v6 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v29 - v14;
  uint64_t v16 = v3 + *(int *)(v4 + 36);
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v29 - v14, v16, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v8 + 72))(v5, v8);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(v4) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                           + 8LL))( v15,  v13,  AssociatedTypeWitness);
  uint64_t v18 = *(void (**)(char *, unint64_t))(v10 + 8);
  v18(v13, AssociatedTypeWitness);
  v18(v15, AssociatedTypeWitness);
  if ((v4 & 1) != 0)
  {
    unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v19 - 8) + 56LL))( v32,  1LL,  1LL,  v19);
  }

  else
  {
    uint64_t v21 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v8 + 80))( v33,  v16,  v5,  v8);
    uint64_t v23 = v22;
    unint64_t v24 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v8 + 8),  v5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v25 = *(void *)(v24 - 8);
    uint64_t v26 = v32;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v25 + 16))(v32, v23, v24);
    v21(v33, 0LL);
    uint64_t v28 = v30;
    uint64_t v27 = v31;
    (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v30, v3, v5);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 192))(v16, v5, v8);
    (*(void (**)(char *, uint64_t))(v27 + 8))(v28, v5);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v25 + 56))(v26, 0LL, 1LL, v24);
  }
}

uint64_t max<A>(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  else {
    uint64_t v9 = a1;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))(a5, v9, a3);
}

Swift::Int max<A>(_:_:_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, char *a7@<X8>)
{
  uint64_t v48 = a2;
  uint64_t v49 = a4;
  v46 = a3;
  uint64_t v11 = *(a5 - 1);
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v14 = (char *)&v43 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  v17 = (char *)&v43 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  v20 = (char *)&v43 - v19;
  uint64_t v44 = v21;
  MEMORY[0x1895F8858](v18);
  uint64_t v23 = (char *)&v43 - v22;
  uint64_t v25 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v24 + 32);
  if ((v25(v26, a1, v27, v24) & 1) != 0) {
    uint64_t v28 = v48;
  }
  else {
    uint64_t v28 = a1;
  }
  uint64_t v29 = *(void (**)(char *, uint64_t, uint64_t *))(v11 + 16);
  v29(v23, v28, a5);
  v47 = (uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t))v25;
  uint64_t v48 = a6;
  if ((v25((uint64_t)v46, (uint64_t)v23, (uint64_t)a5, a6) & 1) != 0)
  {
    (*(void (**)(char *, uint64_t *))(v11 + 8))(v23, a5);
    v29(a7, (uint64_t)v46, a5);
  }

  else
  {
    (*(void (**)(char *, char *, uint64_t *))(v11 + 32))(a7, v23, a5);
  }

  v30 = v29;
  uint64_t v31 = v49;
  Swift::Int result = Array._getCount()();
  v46 = (void *)result;
  if (result)
  {
    unint64_t v33 = 0LL;
    unint64_t v45 = v31 & 0xC000000000000001LL;
    do
    {
      BOOL v34 = v45 == 0;
      char v35 = v34 | ~_swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v33, v35 & 1);
      if ((v35 & 1) != 0)
      {
        unint64_t v36 = v31
        v37 = v30;
        v30(v17, v36, a5);
      }

      else
      {
        id v42 = _ArrayBuffer._getElementSlowPath(_:)(v33, v31, a5);
        v39 = v42;
        if (v44 != 8) {
          goto LABEL_20;
        }
        id v50 = v42;
        v37 = v30;
        v30(v17, (uint64_t)&v50, a5);
        swift_unknownObjectRelease(v39);
      }

      v38 = *(void (**)(char *, char *, uint64_t *))(v11 + 32);
      v38(v20, v17, a5);
      v39 = (void *)(v33 + 1);
      if (__OFADD__(v33, 1LL))
      {
        __break(1u);
LABEL_20:
        swift_unknownObjectRelease(v39);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

      v38(v14, v20, a5);
      char v40 = v47(v14, (uint64_t)a7, a5, v48);
      v41 = *(void (**)(uint64_t, uint64_t *))(v11 + 8);
      if ((v40 & 1) != 0)
      {
        v41((uint64_t)a7, a5);
        Swift::Int result = ((uint64_t (*)(char *, char *, uint64_t *))v38)(a7, v14, a5);
      }

      else
      {
        Swift::Int result = ((uint64_t (*)(char *, uint64_t *))v41)(v14, a5);
      }

      v30 = v37;
      ++v33;
      uint64_t v31 = v49;
    }

    while (v39 != v46);
  }

  return result;
}

uint64_t (*EnumeratedSequence._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t EnumeratedSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter( a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator,  a2);
}

uint64_t EnumeratedSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter( a1,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
}

uint64_t (*EnumeratedSequence.Iterator._base.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t (*EnumeratedSequence.Iterator._count.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t EnumeratedSequence.Iterator.init(_base:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( a4,  a1,  AssociatedTypeWitness);
  uint64_t result = type metadata accessor for EnumeratedSequence.Iterator(0LL, a2, (uint64_t)a3, v9);
  *(void *)(a4 + *(int *)(result + 36)) = 0LL;
  return result;
}

uint64_t Int.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 8 <= 0x40) {
    return *(void *)a1;
  }
  else {
    return 0LL;
  }
}

uint64_t EnumeratedSequence.Iterator.next()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v32 = a2;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v3 = *(const char **)(a1 + 24);
  uint64_t v30 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  (uint64_t)&type metadata for Int,  AssociatedTypeWitness,  "offset element ",  0LL);
  uint64_t v31 = *(TupleTypeMetadata2 - 1);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v29 = (char *)&v28 - v6;
  uint64_t v28 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v7, v8);
  uint64_t v9 = *(void *)(v28 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v28);
  uint64_t v12 = (char *)&v28 - v11;
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v28 - v14;
  unint64_t v16 = swift_getAssociatedTypeWitness( 255LL,  v3,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v3,  v4,  v16,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v18 = *(void (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v19 = swift_checkMetadataState(0LL, v16);
  v18(v19, AssociatedConformanceWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v13 + 48))(v12, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v28);
    return (*(uint64_t (**)(void *, uint64_t, uint64_t, unint64_t *))(v31 + 56))( v32,  1LL,  1LL,  TupleTypeMetadata2);
  }

  else
  {
    uint64_t v21 = v32;
    uint64_t v22 = *(void (**)(char *, char *, unint64_t))(v13 + 32);
    v22(v15, v12, AssociatedTypeWitness);
    uint64_t v23 = TupleTypeMetadata2;
    uint64_t v24 = &v29[*((int *)TupleTypeMetadata2 + 12)];
    uint64_t v25 = *(int *)(v30 + 36);
    uint64_t v26 = *(void *)(v2 + v25);
    uint64_t result = ((uint64_t (*)(char *, char *, unint64_t))v22)(v24, v15, AssociatedTypeWitness);
    if (__OFADD__(v26, 1LL))
    {
      __break(1u);
    }

    else
    {
      *(void *)(v2 + v25) = v26 + 1;
      uint64_t v27 = (char *)v21 + *((int *)v23 + 12);
      *uint64_t v21 = v26;
      v22(v27, v24, AssociatedTypeWitness);
      return (*(uint64_t (**)(void *, void, uint64_t, unint64_t *))(v31 + 56))(v21, 0LL, 1LL, v23);
    }
  }

  return result;
}

void *static Int.+= infix(_:_:)(void *result, uint64_t a2)
{
  if (__OFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

uint64_t Sequence<>.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 32LL))(a2, v2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator()
{
  return 0LL;
}

uint64_t Sequence.underestimatedCount.getter()
{
  return 0LL;
}

uint64_t protocol witness for Sequence._customContainsEquatableElement(_:) in conformance EnumeratedSequence<A>.Iterator()
{
  return 2LL;
}

uint64_t Sequence._customContainsEquatableElement(_:)()
{
  return 2LL;
}

uint64_t Sequence._copyToContiguousArray()(uint64_t a1, uint64_t a2)
{
  return Sequence._copyToContiguousArray()(a1, a2, specialized Sequence._copyToContiguousArray());
}

{
  uint64_t v2;
  uint64_t v4;
  uint64_t v4 = specialized Sequence._copyToContiguousArray()(v2, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v2, a1);
  return v4;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance EnumeratedSequence<A>.Iterator@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return Sequence.withContiguousStorageIfAvailable<A>(_:)(a1, a2);
}

uint64_t _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5@<X0>( uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 56LL))(a2, 1LL, 1LL);
}

uint64_t _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySuqd__Isgyrzo_s7UInt128V5WordsVABsAG_pAKRszr__lIetMgyrzo_Tpq5@<X0>( uint64_t a1@<X4>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 56LL))(a2, 1LL, 1LL, a1);
}

uint64_t _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys7UnicodeO6ScalarVqd__Isgyrzo_Ss0hI4ViewVABsAG_pAMRszr__lIetMggrzo_Tpq5Tm@<X0>( uint64_t a1@<X6>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 56LL))(a2, 1LL, 1LL, a1);
}

uint64_t Sequence.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 56LL))(a2, 1LL, 1LL);
}

uint64_t EnumeratedSequence.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 16);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(char *))(v6 + 32))((char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v7 = *(void *)(a1 + 24);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v4, v7);
  uint64_t result = type metadata accessor for EnumeratedSequence.Iterator(0LL, v4, v7, v8);
  *(void *)(a2 + *(int *)(result + 36)) = 0LL;
  return result;
}

uint64_t _ArrayBody._storage.setter(uint64_t result, uint64_t a2)
{
  *uint64_t v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t (*_ArrayBody._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Bool __swiftcall Bool.init(_builtinBooleanLiteral:)(Builtin::Int1 _builtinBooleanLiteral)
{
  return _builtinBooleanLiteral;
}

Swift::_ArrayBody __swiftcall _ArrayBody.init(count:capacity:elementTypeIsBridgedVerbatim:)( Swift::Int count, Swift::Int capacity, Swift::Bool elementTypeIsBridgedVerbatim)
{
  Swift::UInt v3 = elementTypeIsBridgedVerbatim | (unint64_t)(2 * capacity);
  result._storage._capacityAndFlags = v3;
  result._storage.count = count;
  return result;
}

BOOL static Int.>= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 >= a2;
}

  ;
}

uint64_t UInt.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 9 <= 0x20 && (a2 & 1) == 0) {
    return *(void *)a1;
  }
  else {
    return 0LL;
  }
}

uint64_t FixedWidthInteger.init<A>(truncatingIfNeeded:)@<X0>( uint64_t (*a1)(char *, char *, uint64_t, uint64_t)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a2, a4) <= 64)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 120))(a3, a5);
    (*(void (**)(uint64_t (*)(char *, char *, uint64_t, uint64_t), uint64_t))(*(void *)(a3 - 8) + 8LL))( a1,  a3);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 136))(v13, a2, a4);
  }

  else
  {
    static FixedWidthInteger._truncatingInit<A>(_:)(a1, a2, a3, a4, a5, a6);
    return (*(uint64_t (**)(uint64_t (*)(char *, char *, uint64_t, uint64_t), uint64_t))(*(void *)(a3 - 8) + 8LL))( a1,  a3);
  }

uint64_t static UInt.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

Swift::_ArrayBody __swiftcall _ArrayBody.init()()
{
  Swift::Int v0 = 0LL;
  Swift::UInt v1 = 0LL;
  result._storage._capacityAndFlags = v1;
  result._storage.count = v0;
  return result;
}

void *key path getter for _ArrayBody.count : _ArrayBody@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void *key path setter for _ArrayBody.count : _ArrayBody(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t _ArrayBody.count.setter(uint64_t result)
{
  *Swift::UInt v1 = result;
  return result;
}

uint64_t (*_ArrayBody.count.modify(void *a1))(uint64_t result)
{
  *a1 = *v1;
  a1[1] = v1;
  return _ArrayBody.count.modify;
}

uint64_t _ArrayBody.count.modify(uint64_t result)
{
  **(void **)(result + 8) = *(void *)result;
  return result;
}

unint64_t _ArrayBody.capacity.getter(uint64_t a1, unint64_t a2)
{
  return a2 >> 1;
}

uint64_t _ArrayBody._capacityAndFlags.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

unint64_t static UInt.&>> infix(_:_:)(unint64_t a1, char a2)
{
  return a1 >> a2;
}

uint64_t SignedInteger<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v7 = v6;
  uint64_t v9 = a4;
  uint64_t v185 = a6;
  uint64_t v192 = *(void *)(a4 + 8);
  v178 = *(const char **)(*(void *)(v192 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v178,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v176 = (char *)&v164 - v13;
  v175 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t v174 = swift_getAssociatedTypeWitness( 0LL,  v175,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v14 = MEMORY[0x1895F8858](v174);
  v173 = (char *)&v164 - v15;
  uint64_t v182 = *(void *)(a2 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  v172 = (char *)&v164 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  v171 = (char *)&v164 - v19;
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  v190 = (char *)&v164 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v168 = (char *)&v164 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v164 - v25;
  uint64_t v27 = MEMORY[0x1895F8858](v24);
  v181 = (char *)&v164 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  v179 = (char *)&v164 - v30;
  uint64_t v31 = *(void *)(a3 - 8);
  uint64_t v32 = MEMORY[0x1895F8858](v29);
  v169 = (char *)&v164 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  v170 = (char *)&v164 - v35;
  uint64_t v36 = MEMORY[0x1895F8858](v34);
  v183 = (char *)&v164 - v37;
  uint64_t v38 = MEMORY[0x1895F8858](v36);
  v187 = (char *)&v164 - v39;
  uint64_t v40 = MEMORY[0x1895F8858](v38);
  v167 = (char *)&v164 - v41;
  uint64_t v42 = MEMORY[0x1895F8858](v40);
  v166 = (char *)&v164 - v43;
  uint64_t v44 = MEMORY[0x1895F8858](v42);
  v184 = (char *)&v164 - v45;
  uint64_t v46 = MEMORY[0x1895F8858](v44);
  v180 = (char *)&v164 - v47;
  MEMORY[0x1895F8858](v46);
  uint64_t v49 = (char *)&v164 - v48;
  v189 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  char v50 = v189(a3, a5);
  v193 = *(void (**)(char *, uint64_t, uint64_t))(v31 + 16);
  uint64_t v194 = a1;
  v193(v49, a1, a3);
  uint64_t v186 = v7;
  if ((v50 & 1) == 0)
  {
    v191 = *(void (**)(char *, uint64_t))(v31 + 8);
    v191(v49, a3);
    v51 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    goto LABEL_8;
  }

  v51 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
  uint64_t v52 = v51(a3, a5);
  v53 = *(void (**)(char *, uint64_t))(v31 + 8);
  v53(v49, a3);
  uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 56))(a2, v9);
  v191 = v53;
  if (v54 >= v52)
  {
LABEL_8:
    uint64_t v70 = v194;
    goto LABEL_23;
  }

  v164 = v26;
  v55 = v180;
  v193(v180, v194, a3);
  v56 = *(void (**)(uint64_t, uint64_t))(v9 + 72);
  v57 = v179;
  uint64_t v165 = v9;
  v56(a2, v9);
  v58 = v189;
  int v59 = v189(a3, a5);
  uint64_t v60 = v192;
  int v61 = (*(uint64_t (**)(uint64_t, uint64_t))(v192 + 64))(a2, v192);
  v188 = v51;
  if (((v59 ^ v61) & 1) == 0)
  {
    uint64_t v71 = v51(a3, a5);
    if (v71 >= (*(uint64_t (**)(uint64_t, uint64_t))(v60 + 128))(a2, v60))
    {
      v81 = v184;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v57, a2, v60, a3, a5);
      char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v55,  v81,  a3);
      v69 = v191;
      v191(v81, a3);
    }

    else
    {
      v72 = v184;
      v193(v184, (uint64_t)v55, a3);
      v73 = v181;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v60 + 96))(v72, a3, a5, a2, v60);
      char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v60 + 32) + 8LL) + 16LL))( v73,  v57,  a2);
      v75 = *(void (**)(char *, uint64_t))(v182 + 8);
      v75(v73, a2);
      v75(v57, a2);
      v55 = v180;
      v69 = v191;
    }

    uint64_t v70 = v194;
    v51 = v188;
    uint64_t v9 = v165;
    if ((v74 & 1) == 0) {
      goto LABEL_22;
    }
    goto LABEL_54;
  }

  char v62 = v58(a3, a5);
  uint64_t v63 = v51(a3, a5);
  uint64_t v64 = v60;
  uint64_t v65 = v63;
  uint64_t v66 = (*(uint64_t (**)(uint64_t))(v64 + 128))(a2);
  if ((v62 & 1) != 0)
  {
    uint64_t v9 = v165;
    if (v66 >= v65)
    {
      unint64_t v82 = v174;
      v83 = v175;
      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v175,  a3,  v174,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v85 = v173;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v82,  AssociatedConformanceWitness);
      v86 = v184;
      (*((void (**)(char *, uint64_t, const char *))v83 + 3))(v85, a3, v83);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v55,  v86,  a3);
      v191(v86, a3);
      v87 = v166;
      v193(v166, (uint64_t)v55, a3);
      uint64_t v88 = v182;
      v89 = v164;
      (*(void (**)(char *, char *, uint64_t))(v182 + 32))(v164, v179, a2);
      if ((v82 & 1) != 0)
      {
        (*(void (**)(char *, uint64_t))(v88 + 8))(v89, a2);
        v191(v87, a3);
      }

      else
      {
        v90 = v181;
        v91 = v87;
        uint64_t v92 = v192;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v192 + 96))(v91, a3, a5, a2, v192);
        char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v92 + 32) + 8LL) + 16LL))( v90,  v89,  a2);
        v94 = *(void (**)(char *, uint64_t))(v88 + 8);
        v94(v90, a2);
        v94(v89, a2);
        uint64_t v70 = v194;
        v69 = v191;
        v51 = v188;
        v55 = v180;
        if ((v93 & 1) == 0)
        {
LABEL_22:
          v69(v55, a3);
          goto LABEL_23;
        }
      }

LABEL_54:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
    }

    v67 = v184;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v179, a2, v192, a3, a5);
    char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v55,  v67,  a3);
    v69 = v191;
    v191(v67, a3);
    uint64_t v70 = v194;
LABEL_21:
    v51 = v188;
    if ((v68 & 1) == 0) {
      goto LABEL_22;
    }
    goto LABEL_54;
  }

  uint64_t v70 = v194;
  uint64_t v9 = v165;
  if (v65 < v66)
  {
    v76 = v184;
    v193(v184, (uint64_t)v55, a3);
    uint64_t v77 = v192;
    v78 = v181;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v192 + 96))(v76, a3, a5, a2, v192);
    v79 = v179;
    char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v77 + 32) + 8LL) + 16LL))( v78,  v179,  a2);
    v80 = *(void (**)(char *, uint64_t))(v182 + 8);
    v80(v78, a2);
    v80(v79, a2);
    v55 = v180;
    v69 = v191;
    goto LABEL_21;
  }

  unint64_t v95 = AssociatedTypeWitness;
  v96 = v178;
  unint64_t v97 = swift_getAssociatedConformanceWitness( (uint64_t)v178,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v98 = v176;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v97 + 8))( &unk_18180BE68,  256LL,  v95,  v97);
  v99 = v181;
  (*((void (**)(char *, uint64_t, const char *))v96 + 3))(v98, a2, v96);
  v100 = v179;
  LODWORD(v166) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v192 + 32) + 8LL) + 40LL))( v179,  v99,  a2);
  uint64_t v101 = v182;
  v102 = *(void (**)(char *, uint64_t))(v182 + 8);
  v103 = v180;
  v102(v99, a2);
  v104 = v167;
  v193(v167, (uint64_t)v103, a3);
  v105 = *(void (**)(char *, char *, uint64_t))(v101 + 32);
  v106 = v168;
  v105(v168, v100, a2);
  if ((v166 & 1) != 0)
  {
    v107 = v104;
    v108 = v184;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v106, a2, v192, a3, a5);
    char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v107,  v108,  a3);
    v55 = v180;
    v69 = v191;
    v191(v108, a3);
    v69(v107, a3);
    goto LABEL_21;
  }

  v102(v106, a2);
  v163 = v191;
  v191(v104, a3);
  v51 = v188;
  v163(v103, a3);
LABEL_23:
  v109 = v51;
  uint64_t v110 = v51(a3, a5);
  v111 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
  uint64_t v112 = a5;
  uint64_t v113 = v9;
  uint64_t v114 = v111(a2, v9);
  v115 = v187;
  v193(v187, v70, a3);
  v188 = v109;
  if (v114 < v110)
  {
    v191(v115, a3);
    v116 = v190;
    goto LABEL_25;
  }

  uint64_t v132 = v109(a3, v112);
  v191(v115, a3);
  BOOL v133 = v132 == v111(a2, v113);
  v116 = v190;
  if (v133 && (v189(a3, v112) & 1) == 0)
  {
LABEL_25:
    v117 = v183;
    v193(v183, v194, a3);
    (*(void (**)(uint64_t, uint64_t))(v113 + 64))(a2, v113);
    uint64_t v118 = v192;
    v119 = *(uint64_t (**)(uint64_t, uint64_t))(v192 + 64);
    int v120 = v119(a2, v192);
    uint64_t v121 = v112;
    if (((v120 ^ v189(a3, v112)) & 1) != 0)
    {
      char v122 = v119(a2, v118);
      uint64_t v123 = (*(uint64_t (**)(uint64_t, uint64_t))(v118 + 128))(a2, v118);
      uint64_t v124 = v188(a3, v112);
      if ((v122 & 1) != 0)
      {
        v125 = v191;
        if (v124 < v123)
        {
          v126 = v184;
          v193(v184, (uint64_t)v117, a3);
          v127 = v181;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v118 + 96))(v126, a3, v121, a2, v118);
          v128 = v190;
          char v129 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v118 + 32) + 8LL) + 16LL))( v190,  v127,  a2);
          v130 = *(void (**)(char *, uint64_t))(v182 + 8);
          v130(v127, a2);
          v131 = v128;
          goto LABEL_46;
        }

        unint64_t v142 = AssociatedTypeWitness;
        v143 = v178;
        unint64_t v144 = swift_getAssociatedConformanceWitness( (uint64_t)v178,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v145 = v176;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v144 + 8))( &unk_18180BE68,  256LL,  v142,  v144);
        v146 = v181;
        (*((void (**)(char *, uint64_t, const char *))v143 + 3))(v145, a2, v143);
        v147 = v190;
        LOBYTE(v142) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v118 + 32) + 8LL)
                                                                          + 16LL))( v190,  v146,  a2);
        uint64_t v148 = v182;
        v189 = *(uint64_t (**)(uint64_t, uint64_t))(v182 + 8);
        v189((uint64_t)v146, a2);
        v149 = v171;
        (*(void (**)(char *, char *, uint64_t))(v148 + 32))(v171, v147, a2);
        v150 = v170;
        v193(v170, (uint64_t)v117, a3);
        if ((v142 & 1) != 0)
        {
          v125(v150, a3);
          v189((uint64_t)v149, a2);
          goto LABEL_47;
        }

        v151 = v184;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v121 + 96))(v149, a2, v118, a3, v121);
        char v136 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v121 + 32) + 8LL) + 16LL))( v151,  v150,  a3);
        v125(v151, a3);
        v138 = v150;
      }

      else
      {
        v125 = v191;
        if (v123 >= v124)
        {
          unint64_t v152 = v174;
          v153 = v175;
          unint64_t v154 = swift_getAssociatedConformanceWitness( (uint64_t)v175,  a3,  v174,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v155 = v173;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v154 + 8))( &unk_18180BE68,  256LL,  v152,  v154);
          v156 = v184;
          (*((void (**)(char *, uint64_t, const char *))v153 + 3))(v155, a3, v153);
          LOBYTE(v152) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v121 + 32) + 8LL)
                                                                            + 40LL))( v117,  v156,  a3);
          v125(v156, a3);
          uint64_t v157 = v182;
          v158 = v172;
          (*(void (**)(char *, char *, uint64_t))(v182 + 32))(v172, v190, a2);
          v159 = v169;
          v193(v169, (uint64_t)v117, a3);
          if ((v152 & 1) != 0)
          {
            v160 = v159;
            v161 = v181;
            (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v118 + 96))(v160, a3, v121, a2, v118);
            char v129 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v118 + 32) + 8LL) + 16LL))( v158,  v161,  a2);
            v130 = *(void (**)(char *, uint64_t))(v157 + 8);
            v130(v161, a2);
            v131 = v158;
LABEL_46:
            v130(v131, a2);
            if ((v129 & 1) != 0) {
              goto LABEL_47;
            }
            goto LABEL_49;
          }

          v125(v159, a3);
          (*(void (**)(char *, uint64_t))(v157 + 8))(v158, a2);
          goto LABEL_49;
        }

        v137 = v184;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v121 + 96))(v190, a2, v118, a3, v121);
        char v136 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v121 + 32) + 8LL) + 16LL))( v137,  v117,  a3);
        v138 = v137;
      }

      v125(v138, a3);
    }

    else
    {
      uint64_t v134 = (*(uint64_t (**)(uint64_t, uint64_t))(v118 + 128))(a2, v118);
      if (v134 >= v188(a3, v112))
      {
        v139 = v184;
        v193(v184, (uint64_t)v117, a3);
        v140 = v181;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v118 + 96))(v139, a3, v112, a2, v118);
        LOBYTE(v139) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v118 + 32) + 8LL)
                                                                          + 16LL))( v116,  v140,  a2);
        v141 = *(void (**)(char *, uint64_t))(v182 + 8);
        v141(v140, a2);
        v141(v116, a2);
        v125 = v191;
        goto LABEL_49;
      }

      v135 = v184;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v112 + 96))(v116, a2, v118, a3, v112);
      char v136 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v112 + 32) + 8LL) + 16LL))( v135,  v117,  a3);
      v125 = v191;
      v191(v135, a3);
    }

    if ((v136 & 1) != 0) {
LABEL_47:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
LABEL_49:
    v125(v117, a3);
    uint64_t v112 = v121;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v192 + 96))(v194, a3, v112, a2);
}

  __break(1u);
  return result;
}

          uint64_t v38 = (v47 - 1) & v47;
          uint64_t v41 = __clz(__rbit64(v47)) + (v35 << 6);
        }

        uint64_t v42 = 40 * v41;
        outlined init with copy of AnyHashable(*(void *)(v5 + 48) + 40 * v41, (uint64_t)&v93);
        uint64_t v43 = v30[6] + v42;
        uint64_t v44 = v93;
        uint64_t v45 = v94;
        *(void *)(v43 + 32) = v95;
        *(_OWORD *)uint64_t v43 = v44;
        *(_OWORD *)(v43 + 16) = v45;
      }
    }

    char v50 = specialized static _HashTable.scale(forCapacity:)(v8);
    LOBYTE(v93) = 1;
    uint64_t v13 = specialized static _SetStorage.allocate(scale:age:seed:)(v50, 0x100000000LL, 0LL, 1);
    if (*(void *)(v5 + 16))
    {
      uint64_t v54 = 1LL << *(_BYTE *)(v5 + 32);
      v55 = v5 + 56;
      v56 = -1LL;
      if (v54 < 64) {
        v56 = ~(-1LL << v54);
      }
      v57 = v56 & *(void *)(v5 + 56);
      v58 = (unint64_t)(v54 + 63) >> 6;
      swift_retain((unint64_t *)v5, v51, v52, v53);
      int v59 = 0LL;
      while (1)
      {
        if (v57)
        {
          uint64_t v60 = __clz(__rbit64(v57));
          v57 &= v57 - 1;
          int v61 = v60 | (v59 << 6);
        }

        else
        {
          char v62 = v59 + 1;
          if (__OFADD__(v59, 1LL))
          {
LABEL_94:
            __break(1u);
            goto LABEL_95;
          }

          if (v62 >= v58) {
            goto LABEL_82;
          }
          uint64_t v63 = *(void *)(v55 + 8 * v62);
          ++v59;
          if (!v63)
          {
            int v59 = v62 + 1;
            if (v62 + 1 >= v58) {
              goto LABEL_82;
            }
            uint64_t v63 = *(void *)(v55 + 8 * v59);
            if (!v63)
            {
              int v59 = v62 + 2;
              if (v62 + 2 >= v58) {
                goto LABEL_82;
              }
              uint64_t v63 = *(void *)(v55 + 8 * v59);
              if (!v63)
              {
                uint64_t v64 = v62 + 3;
                if (v64 >= v58) {
                  goto LABEL_82;
                }
                uint64_t v63 = *(void *)(v55 + 8 * v64);
                if (!v63)
                {
                  while (1)
                  {
                    int v59 = v64 + 1;
                    if (__OFADD__(v64, 1LL)) {
                      goto LABEL_98;
                    }
                    if (v59 >= v58) {
                      break;
                    }
                    uint64_t v63 = *(void *)(v55 + 8 * v59);
                    ++v64;
                    if (v63) {
                      goto LABEL_77;
                    }
                  }

    uint64_t v70 = v74;
    uint64_t v71 = v73;
    v72 = v79;
    swift_retain((unint64_t *)a3, v22, v23, (char *)v24);
    Swift::_ArrayBody result = _NativeSet.extractSubset(using:count:)(v75, v71, v72, a3, a5, a6);
    *uint64_t v70 = result;
    return result;
  }

  char v50 = 0LL;
  v51 = *(void *)(a3 + 56);
  uint64_t v77 = a3 + 56;
  uint64_t v52 = 1LL << *(_BYTE *)(a3 + 32);
  if (v52 < 64) {
    v53 = ~(-1LL << v52);
  }
  else {
    v53 = -1LL;
  }
  uint64_t v54 = v53 & v51;
  v78 = (unint64_t)(v52 + 63) >> 6;
  v79 = 0LL;
  v83 = a4 + 56;
  if (v54) {
    goto LABEL_35;
  }
LABEL_36:
  uint64_t v35 = __OFADD__(v50, 1LL);
  v56 = v50 + 1;
  if (v35) {
    goto LABEL_58;
  }
  if (v56 >= v78) {
    goto LABEL_54;
  }
  v57 = *(void *)(v77 + 8 * v56);
  if (v57)
  {
LABEL_45:
    v80 = (v57 - 1) & v57;
    v81 = v56;
    for (j = __clz(__rbit64(v57)) + (v56 << 6); ; j = __clz(__rbit64(v54)) | (v50 << 6))
    {
      int v59 = *(char **)(v11 + 72);
      uint64_t v60 = *(void *)(a3 + 48) + (void)v59 * j;
      v84 = *(void (**)(char *, unint64_t, uint64_t))(v11 + 16);
      v85 = v59;
      v84(v14, v60, a5);
      int v61 = v14;
      char v62 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a6 + 32))(*(void *)(a4 + 40), a5, a6);
      uint64_t v63 = -1LL << *(_BYTE *)(a4 + 32);
      uint64_t v64 = v62 & ~v63;
      if (((*(void *)(v83 + ((v64 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v64) & 1) != 0)
      {
        v76 = j;
        uint64_t v65 = ~v63;
        uint64_t v66 = *(void *)(a6 + 8);
        v67 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v66 + 8);
        while (1)
        {
          v84(v17, *(void *)(v86 + 48) + v64 * (void)v85, a5);
          char v68 = v67(v17, v14, a5, v66);
          v69 = *(void (**)(char *, uint64_t))(v88 + 8);
          v69(v17, a5);
          if ((v68 & 1) != 0) {
            break;
          }
          uint64_t v64 = (v64 + 1) & v65;
          uint64_t v14 = v61;
          if (((*(void *)(v83 + ((v64 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v64) & 1) == 0) {
            goto LABEL_52;
          }
        }

        uint64_t v14 = v61;
        Swift::_ArrayBody result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v69)(v61, a5);
        *(unint64_t *)((char *)v75 + ((v76 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v76;
        uint64_t v54 = v80;
        uint64_t v35 = __OFADD__(v79++, 1LL);
        char v50 = v81;
        a6 = v82;
        a4 = v86;
        a3 = v87;
        uint64_t v11 = v88;
        if (v35) {
          goto LABEL_60;
        }
        if (!v80) {
          goto LABEL_36;
        }
      }

      else
      {
        v69 = *(void (**)(char *, uint64_t))(v11 + 8);
LABEL_52:
        Swift::_ArrayBody result = (__objc2_class **)((uint64_t (*)(char *, uint64_t))v69)(v14, a5);
        char v50 = v81;
        a6 = v82;
        a4 = v86;
        a3 = v87;
        uint64_t v11 = v88;
        uint64_t v54 = v80;
        if (!v80) {
          goto LABEL_36;
        }
      }

        if ((v20 & 0x7F800000000LL) == 0) {
          goto LABEL_74;
        }
LABEL_55:
        if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v13))
        {
          uint64_t v43 = (int64_t)&v13[2]->isa + 1;
          goto LABEL_64;
        }

        goto LABEL_56;
      }

      uint64_t v39 = (v20 >> 35);
      if (v39 > (*(unsigned __int16 *)&v34[8 * (void)v38 - 8] >> 3))
      {
        if ((v20 & 0x600000000LL) != 0 && v20 >= 0x300)
        {
          uint64_t v35 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v52, v20);
          if ((v35 & 0x100000000LL) == 0) {
            goto LABEL_30;
          }
          LODWORD(v35) = _swift_stdlib_getComposition(v52, v20);
          if ((_DWORD)v35 != -1) {
            goto LABEL_30;
          }
        }

        goto LABEL_55;
      }

        uint64_t v45 = 1861LL;
        goto LABEL_53;
      }
    }

    int v59 = v20;
    char v62 = v16;
    uint64_t v39 = v19;
    uint64_t v23 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v13._rawBits >> 16);
    uint64_t v20 = v59;
    uint64_t v16 = v62;
    uint64_t v19 = v39;
    goto LABEL_31;
  }

        int v59 = 1860LL;
LABEL_55:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v59,  0);
      }

      v62[0] = a1;
      v62[1] = x1_0 & 0xFFFFFFFFFFFFFFLL;
      if (a3 < 0) {
        goto LABEL_54;
      }
      if ((uint64_t)(HIBYTE(x1_0) & 0xF) >= a4)
      {
        uint64_t v52 = a4 - a3;
        if (v52 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
        v53 = v5[1] & 0xFFFFFFFFFFFFFFFLL;
        specialized UnsafeMutablePointer.initialize(from:count:)( (char *)v62 + a3,  v52,  (char *)(v53 + (*(void *)(v53 + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
        uint64_t v54 = *(void *)(v53 + 24);
        if (!__OFADD__(v54 & 0xFFFFFFFFFFFFLL, v52))
        {
          __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( (v54 & 0xFFFFFFFFFFFFLL) + v52,  (x1_0 >> 62) & (v54 < 0));
          *uint64_t v5 = *(void *)(v53 + 24);
          return;
        }

        __break(1u);
        goto LABEL_58;
      }

    uint64_t v30 = v16 + result;
    if (__OFADD__(v16, result)) {
      break;
    }
    Swift::_ArrayBody result = v13.offset + v30;
    if (!__OFADD__(v13.offset, v30)) {
      return result;
    }
    __break(1u);
LABEL_58:
    rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
  }

  __break(1u);
  return result;
}

          (*(void (**)(char *, uint64_t))(v130 + 8))(v131, v41);
          (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
          swift_bridgeObjectRelease((uint64_t)v133);
          swift_bridgeObjectRelease((uint64_t)v134);
          v56(v54, v40);
LABEL_55:
          swift_bridgeObjectRelease((uint64_t)v128);
          uint64_t v110 = v123;
          goto LABEL_56;
        }
      }
    }

  Swift::_ArrayBody result = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v24);
  if (result <= 63) {
    goto LABEL_47;
  }
LABEL_48:
  uint64_t v28 = (a2 & 0x800000000000000LL) != 0 || v22 == 0;
  uint64_t v29 = 7LL;
  if (!v28) {
    uint64_t v29 = 11LL;
  }
  a1->_rawBits = v20 | v29;
  return result;
}

  while (2)
  {
    uint64_t v23 = (const char *)*v21;
    uint64_t v24 = *(unsigned __int16 *)(*v21 + 16);
    switch(v24)
    {
      case 276:
        v36 |= 0x80u;
        *a5 = 1;
LABEL_52:
        ++v21;
LABEL_53:
        if (v21 == v19) {
          goto LABEL_35;
        }
        continue;
      case 232:
        uint64_t v25 = *((unsigned __int8 *)v23 + 18);
        if ((v25 - 1) >= 2)
        {
          if (v25 != 5 || !*((_DWORD *)v23 + 2))
          {
            uint64_t v26 = 0LL;
LABEL_65:
            if (v31)
            {
              uint64_t v27 = v29;
              uint64_t v28 = (void (*)(uint64_t, int))v30;
              goto LABEL_68;
            }

            goto LABEL_52;
          }

          uint64_t v23 = *(const char **)v23;
        }

        uint64_t v26 = *(const char **)v23;
        goto LABEL_65;
      case 225:
        uint64_t v34 = *(_OWORD *)v23;
        if (++v21 == v19) {
          goto LABEL_35;
        }
        continue;
    }
  }

  uint64_t v27 = operator new(8uLL);
  *uint64_t v27 = "unknown node";
  uint64_t v28 = _ZZN5swift15TypeLookupErrorC1IZNS_L19TypeLookupErrorImplIJEEES0_PKcDpT_EUlvE_EERKT_ENUlPvNS0_7CommandESB_E_8__invokeESB_SC_SB_;
LABEL_68:
  *(void *)(a6 + 8) = v28;
  *(void *)a6 = ((uint64_t (*)(void *, uint64_t, void))v28)(v27, 2LL, 0LL);
  *(_BYTE *)(a6 + 16) = 1;
  return (void *)((uint64_t (*)(void *, uint64_t, void))v28)(v27, 3LL, 0LL);
}

  std::string::append((std::string *)this, ">", 1uLL);
  if (*((_WORD *)v7 + 8) != 44) {
    goto LABEL_85;
  }
LABEL_58:
  uint64_t v26 = *((unsigned __int8 *)v7 + 18);
  if (v26 != 2)
  {
    if (v26 != 5 || *((_DWORD *)v7 + 2) < 2u)
    {
      uint64_t v27 = 0LL;
      goto LABEL_64;
    }

    uint64_t v7 = *(swift::Demangle::__runtime::Node **)v7;
  }

  uint64_t v27 = (swift::Demangle::__runtime::Node *)*((void *)v7 + 1);
LABEL_64:
  uint64_t v28 = v27;
  while (1)
  {
    uint64_t v29 = v28;
    uint64_t v30 = *((unsigned __int16 *)v28 + 8);
    if (v30 != 232) {
      break;
    }
    uint64_t v31 = *((unsigned __int8 *)v29 + 18);
    if ((v31 - 1) < 2)
    {
LABEL_67:
      uint64_t v28 = *(swift::Demangle::__runtime::Node **)v29;
    }

    else
    {
      uint64_t v28 = 0LL;
      if (v31 == 5)
      {
        uint64_t v28 = 0LL;
        if (*((_DWORD *)v29 + 2))
        {
          uint64_t v29 = *(swift::Demangle::__runtime::Node **)v29;
          goto LABEL_67;
        }
      }
    }
  }

  uint64_t v32 = (v30 - 44) > 0x26 || ((1LL << (v30 - 44)) & 0x4000200001LL) == 0;
  if (v32 && v30 != 245) {
    std::string::push_back((std::string *)this, 32);
  }
  uint64_t v33 = *((unsigned __int8 *)v27 + 18);
  if ((v33 - 1) < 2)
  {
LABEL_83:
    uint64_t v7 = *(swift::Demangle::__runtime::Node **)v27;
  }

  else
  {
    if (v33 == 5 && *((_DWORD *)v27 + 2))
    {
      uint64_t v27 = *(swift::Demangle::__runtime::Node **)v27;
      goto LABEL_83;
    }

    uint64_t v7 = 0LL;
  }

  if (v25 == v27) {
    goto LABEL_58;
  }
  uint64_t v28 = a3 + 2;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v25 == v27) {
      goto LABEL_58;
    }
  }

  uint64_t v30 = *(_DWORD *)(v7 + 12736);
  uint64_t v31 = *(unsigned int *)(v7 + 12740);
  uint64_t v32 = *(char **)(v7 + 12728);
  if (v30 >= v31)
  {
    uint64_t v33 = *(void **)(v7 + 12744);
    uint64_t v34 = (char *)v33[1];
    if (&v32[v31] != v34)
    {
      uint64_t v35 = v33[2];
      goto LABEL_76;
    }

    uint64_t v44 = (unint64_t)&v32[v31 + 1];
    uint64_t v35 = v33[2];
    if (v44 <= v35)
    {
      v33[1] = v44;
      LODWORD(v45) = 1;
    }

    else
    {
LABEL_76:
      else {
        uint64_t v45 = (2 * v31);
      }
      uint64_t v46 = v45 + v31;
      if (!v34 || (unint64_t)&v34[v46] > v35)
      {
        uint64_t v47 = 2LL * v33[4];
        if (v47 <= v46 + 1) {
          uint64_t v47 = v46 + 1;
        }
        v33[4] = v47;
        uint64_t v48 = v47 + 8;
        this = (char *)malloc(v47 + 8);
        uint64_t v49 = &this[v48];
        *(void *)this = v33[3];
        uint64_t v34 = this + 8;
        v33[2] = v49;
        v33[3] = this;
      }

      v33[1] = &v34[v46];
      if ((_DWORD)v31)
      {
        this = (char *)memcpy(v34, *(const void **)(v7 + 12728), v31);
        LODWORD(v31) = *(_DWORD *)(v7 + 12740);
        uint64_t v30 = *(_DWORD *)(v7 + 12736);
      }

      *uint64_t v9 = v34;
      uint64_t v32 = v34;
    }

    *(_DWORD *)(v7 + 12740) = v31 + v45;
  }

  uint64_t v14 = 0;
  uint64_t v4 = 0LL;
  uint64_t v13 = 0;
  *(_DWORD *)(v7 + 12736) = v30 + 1;
  v32[v30] = 95;
LABEL_49:
  *(_DWORD *)a4 = v14;
  *(void *)(a4 + 8) = v4;
  *(_DWORD *)(a4 + 16) = v13;
  return this;
}

uint64_t _ArrayBody.elementTypeIsBridgedVerbatim.getter(uint64_t a1, char a2)
{
  return a2 & 1;
}

uint64_t key path getter for _ArrayBody.elementTypeIsBridgedVerbatim : _ArrayBody@<X0>( uint64_t result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = *(_BYTE *)(result + 8) & 1;
  return result;
}

unsigned __int8 *key path setter for _ArrayBody.elementTypeIsBridgedVerbatim : _ArrayBody( unsigned __int8 *result, uint64_t a2)
{
  *(void *)(a2 + 8) = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFFELL | *result;
  return result;
}

uint64_t _ArrayBody.elementTypeIsBridgedVerbatim.setter(uint64_t result)
{
  *(void *)(v1 + 8) = *(void *)(v1 + 8) & 0xFFFFFFFFFFFFFFFELL | result & 1;
  return result;
}

uint64_t static UInt.& infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 & a1;
}

uint64_t static FixedWidthInteger.~ prefix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v25 = a1;
  uint64_t v26 = a4;
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a3 + 8) + 24LL) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v21 - v9;
  uint64_t v24 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v21 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v11);
  uint64_t v15 = (char *)&v21 - v14;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v23 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  v23(&unk_18180BE68, 256LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v22 = *(void (**)(char *, uint64_t, uint64_t))(v6 + 24);
  v22(v10, a2, v6);
  uint64_t v17 = a3;
  uint64_t v21 = a3;
  uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(a3 + 88);
  v18(v15, v25, a2, v17);
  uint64_t v19 = *(void (**)(char *, uint64_t))(v24 + 8);
  v19(v13, a2);
  v23(&qword_18180BE70, 512LL, AssociatedTypeWitness, AssociatedConformanceWitness);
  v22(v10, a2, v6);
  v18(v26, (uint64_t)v13, a2, v21);
  v19(v13, a2);
  return ((uint64_t (*)(char *, uint64_t))v19)(v15, a2);
}

uint64_t _ArrayBody._capacityAndFlags.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

unsigned __int8 *(*_ArrayBody.elementTypeIsBridgedVerbatim.modify( uint64_t a1))(unsigned __int8 *result)
{
  *(void *)a1 = v1;
  *(_BYTE *)(a1 + 8) = *(_BYTE *)(v1 + 8) & 1;
  return _ArrayBody.elementTypeIsBridgedVerbatim.modify;
}

unsigned __int8 *_ArrayBody.elementTypeIsBridgedVerbatim.modify(unsigned __int8 *result)
{
  *(void *)(*(void *)result + 8LL) = *(void *)(*(void *)result + 8LL) & 0xFFFFFFFFFFFFFFFELL | result[8];
  return result;
}

uint64_t key path getter for _ArrayBody._capacityAndFlags : _ArrayBody@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(result + 8);
  return result;
}

void *key path setter for _ArrayBody._capacityAndFlags : _ArrayBody(void *result, uint64_t a2)
{
  *(void *)(a2 + 8) = *result;
  return result;
}

void *(*_ArrayBody._capacityAndFlags.modify(void *a1))(void *result)
{
  *a1 = *(void *)(v1 + 8);
  a1[1] = v1;
  return _ArrayBody._capacityAndFlags.modify;
}

void *_ArrayBody._capacityAndFlags.modify(void *result)
{
  *(void *)(result[1] + 8LL) = *result;
  return result;
}

uint64_t (*_ArrayBuffer._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

__objc2_class **_emptyArrayStorage.getter()
{
  return &_swiftEmptyArrayStorage;
}

uint64_t _ArrayBuffer.init(nsArray:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t _BridgeStorage.init(objC:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t _ArrayBuffer.cast<A>(toBufferOf:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _ArrayBuffer.downcast<A>(toBufferWithDeferredTypeCheckOf:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
  uint64_t v5 = a2 & 0xFFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v5 = a2;
  }
  return v5 | 1;
}

uint64_t _ArrayBuffer._native.getter(unint64_t a1, uint64_t *a2)
{
  else {
    uint64_t v6 = a1;
  }
  swift_bridgeObjectRetain(a1, v3, v4, v5);
  return v6;
}

unint64_t _BridgeStorage.init(native:isFlagged:)(unint64_t a1, char a2)
{
  return a2 & 1 | a1;
}

BOOL _ArrayBuffer.needsElementTypeCheck.getter(uint64_t a1, uint64_t *a2)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  BOOL result = 0LL;
  if (isClassOrObjCExistentialType && (a1 & 0xC000000000000001LL) != 0) {
    return swift_dynamicCastMetatype((uint64_t *)&unk_189B8D230, a2) == 0LL;
  }
  return result;
}

uint64_t _ArrayBuffer._isNativeTypeChecked.getter(uint64_t a1, uint64_t *a2)
{
  return ((a1 & 0xC000000000000001LL) == 0) | !_swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
}

BOOL static Bool.! prefix(_:)(char a1)
{
  return (a1 & 1) == 0;
}

uint64_t static Bool.&& infix(_:_:)(char a1, uint64_t (*a2)(void))
{
  if ((a1 & 1) != 0) {
    return a2() & 1;
  }
  else {
    return 0LL;
  }
}

void protocol witness for _ArrayBufferProtocol.init() in conformance _ArrayBuffer<A>(void *a1@<X8>)
{
  *a1 = &_swiftEmptyArrayStorage;
}

uint64_t protocol witness for _ArrayBufferProtocol.init(_buffer:shiftedToStartIndex:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t *a3@<X8>)
{
  uint64_t result = EnumeratedSequence._base.modify(a1, *(void *)(a2 + 16));
  *a3 = result;
  return result;
}

uint64_t _ArrayBuffer.init(_buffer:shiftedToStartIndex:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return EnumeratedSequence._base.modify(a1, a3);
}

uint64_t protocol witness for _ArrayBufferProtocol.init(copying:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return _ArrayBufferProtocol.init(copying:)(a1, a2, a3, a4);
}

uint64_t _ArrayBufferProtocol.init(copying:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v37 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v36 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = *(void *)(*(void *)(v10 + 8) + 8LL);
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t))(v11 + 112);
  uint64_t v14 = v12(v13, v11);
  uint64_t v15 = v12(a2, v11);
  if (v15 <= v14) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = v15;
  }
  if (v16)
  {
    uint64_t v36 = a4;
    unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v18 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
    uint64_t v19 = *(AssociatedTypeWitness - 1);
    uint64_t v20 = *(void *)(v19 + 72);
    uint64_t v21 = *(unsigned __int8 *)(v19 + 80);
    uint64_t v22 = (__objc2_class **)swift_allocObject( v18,  ((v21 + *(unsigned int *)(v18 + 48)) & ~v21) + v20 * v16,  v21 | *(unsigned __int16 *)(v18 + 52));
    size_t v23 = _swift_stdlib_malloc_size(v22);
    if (!v20) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }
    int64_t v27 = v23 - ((v21 + 32) & ~v21);
    if (v27 == 0x8000000000000000LL && v20 == -1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
    }
    uint64_t v29 = v27 / v20;
    swift_retain((unint64_t *)v22, v24, v25, v26);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( (uint64_t)AssociatedTypeWitness,  AssociatedTypeWitness);
    v22[2] = (__objc2_class *)v14;
    v22[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v29));
    swift_release((uint64_t)v22);
  }

  else
  {
    uint64_t v22 = &_swiftEmptyArrayStorage;
  }

  uint64_t v31 = v37;
  (*(void (**)(char *, uint64_t, uint64_t))(v37 + 16))(v9, a1, a2);
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(v11 + 96))(v38, a2, v11);
  uint64_t v32 = v38[0];
  uint64_t v33 = v38[1];
  uint64_t v34 = *(unsigned __int8 *)(*(void *)(swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v11 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element)
                                       - 8)
                           + 80LL);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 48))( v32,  v33,  (uint64_t)v22 + ((v34 + 32) & ~v34),  a2,  a3);
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(v11 + 64))(v38, a2, v11);
  (*(void (**)(uint64_t, uint64_t))(v31 + 8))(a1, a2);
  return (*(uint64_t (**)(__objc2_class **, void, uint64_t, uint64_t))(a3 + 32))(v22, v38[0], a2, a3);
}

void **protocol witness for _ArrayBufferProtocol._copyContents(subRange:initializing:) in conformance _ArrayBuffer<A>( Swift::Int a1, Swift::Int a2, char *a3, uint64_t a4)
{
  return _ArrayBuffer._copyContents(subRange:initializing:)(a1, a2, a3, *v4, *(uint64_t **)(a4 + 16));
}

void **specialized _ArrayBuffer._copyContents(subRange:initializing:)( void **result, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if ((unint64_t)a4 >> 62)
  {
    if (a4 >= 0) {
      a4 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    uint64_t v7 = specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)(result, a2, a3, (id)a4);
    swift_bridgeObjectRelease(v4);
    return v7;
  }

  else
  {
    uint64_t v6 = a2 - (void)result;
    if (__OFSUB__(a2, result))
    {
      __break(1u);
    }

    else
    {
      specialized UnsafeMutablePointer.initialize(from:count:)( (char *)((a4 & 0xFFFFFFFFFFFFFF8LL) + 8LL * (void)result + 32),  v6,  (char *)a3);
      swift_bridgeObjectRelease(v4);
      return &a3[v6];
    }
  }

  return result;
}

void **_ArrayBuffer._copyContents(subRange:initializing:)( Swift::Int a1, Swift::Int a2, char *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v8 = a2;
  _ArrayBuffer._typeCheck(_:)(a1, a2, a4, a5);
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a5, a5)
    || (a4 & 0x8000000000000000LL) == 0 && (a4 & 0x4000000000000000LL) == 0)
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
    BOOL v14 = __OFSUB__(v8, a1);
    v8 -= a1;
    if (!v14)
    {
      uint64_t v15 = a4 & 0xFFFFFFFFFFFFFF8LL;
      if (!isClassOrObjCExistentialType) {
        uint64_t v15 = a4;
      }
      uint64_t v16 = *(a5 - 1);
      uint64_t v17 = *(void *)(v16 + 72);
      UnsafeMutablePointer.initialize(from:count:)( (char *)(v15 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80))
               + v17 * a1),
        v8,
        a3,
        (uint64_t)a5);
      swift_bridgeObjectRelease(a4);
      return (void **)&a3[v17 * v8];
    }

    __break(1u);
  }

  if (a4 < 0) {
    uint64_t v19 = (void *)a4;
  }
  else {
    uint64_t v19 = (void *)(a4 & 0xFFFFFFFFFFFFFF8LL);
  }
  swift_unknownObjectRetain(v19, v10, v11, v12);
  swift_bridgeObjectRelease(a4);
  uint64_t v20 = specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)((void **)a1, v8, (void **)a3, v19);
  swift_unknownObjectRelease(v19);
  return v20;
}

uint64_t _ArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)(a2 + 16);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v4, v4);
  uint64_t v6 = *v2;
  if (isClassOrObjCExistentialType)
  {
    uint64_t v7 = 0LL;
    if (v6 < 0 || (v6 & 0x4000000000000000LL) != 0) {
      return v7;
    }
    if ((swift_isUniquelyReferenced_nonNull_bridgeObject(v6) & 1) == 0) {
      return 0LL;
    }
  }

  else if (!swift_isUniquelyReferenced_nonNull_native(v6))
  {
    return 0LL;
  }

  unint64_t v8 = *v2;
  else {
    uint64_t v7 = v8;
  }
  if (a1 > *(void *)(v7 + 24) >> 1) {
    return 0LL;
  }
  swift_bridgeObjectRetain(v8, v9, v10, v11);
  return v7;
}

BOOL specialized _ArrayBuffer.isMutableAndUniquelyReferenced()()
{
  return swift_isUniquelyReferenced_nonNull_native(*v0);
}

Swift::Bool __swiftcall _ArrayBuffer.isMutableAndUniquelyReferenced()()
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType(*(void *)(v0 + 16), *(uint64_t **)(v0 + 16));
  uint64_t v3 = *v1;
  if (!isClassOrObjCExistentialType) {
    return swift_isUniquelyReferenced_nonNull_native(*v1);
  }
  Swift::Bool result = 0;
  if ((v3 & 0x8000000000000000LL) == 0 && (v3 & 0x4000000000000000LL) == 0) {
    return swift_isUniquelyReferenced_nonNull_bridgeObject(*v1);
  }
  return result;
}

uint64_t protocol witness for _ArrayBufferProtocol.requestNativeBuffer() in conformance _ArrayBuffer<A>( uint64_t a1)
{
  return _ArrayBuffer.requestNativeBuffer()(*v1, *(uint64_t **)(a1 + 16));
}

uint64_t _ArrayBuffer.requestNativeBuffer()(unint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    uint64_t v7 = 0LL;
    if ((a1 & 0x8000000000000000LL) == 0 && (a1 & 0x4000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain(a1, v4, v5, v6);
      else {
        return a1;
      }
    }
  }

  else
  {
    else {
      uint64_t v7 = a1;
    }
    swift_bridgeObjectRetain(a1, v8, v9, v10);
  }

  return v7;
}

void protocol witness for _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:) in conformance _ArrayBuffer<A>( uint64_t a1, uint64_t a2, void (*a3)(void, void, void), uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8)
{
}

void _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( uint64_t a1, uint64_t a2, void (*a3)(void, void, void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const char *a8)
{
  uint64_t v9 = v8;
  uint64_t v65 = a4;
  uint64_t v68 = (uint64_t)a3;
  uint64_t v16 = *(void *)(*(void *)(a7 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v16 + 8),  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v66 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v67 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v60 = (char *)&v57 - v18;
  uint64_t v64 = a8;
  unint64_t v19 = swift_getAssociatedTypeWitness( 0LL,  a8,  a6,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v62 = *(void *)(v19 - 8);
  unint64_t v63 = v19;
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  int v61 = (char *)&v57 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  int v59 = (char *)&v57 - v23;
  uint64_t v24 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v57 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v24 + 16))(v26, v9, a5);
  int64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 144);
  uint64_t v69 = a7;
  uint64_t v70 = v27(a5, a7);
  (*(void (**)(char *, uint64_t))(v24 + 8))(v26, a5);
  uint64_t v28 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_19:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
  }

  if (v28 < 0) {
    goto LABEL_19;
  }
  uint64_t v29 = a2;
  uint64_t v30 = *(void *)(v66 + 72);
  unint64_t v31 = v70 + v30 * a1;
  swift_arrayDestroy(v31, v28, v67);
  uint64_t v33 = v68;
  uint64_t v34 = v68 - v28;
  if (__OFSUB__(v68, v28))
  {
    __break(1u);
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }

  uint64_t v58 = v30 * v68;
  if (!v34) {
    goto LABEL_8;
  }
  uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v16 + 112))(a5, v16);
  if (__OFSUB__(v35, v29)) {
    goto LABEL_21;
  }
  UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v70 + v30 * v29), v35 - v29, (char *)(v31 + v30 * v33), v67);
  uint64_t v36 = (uint64_t (*)(void *, void))(*(uint64_t (**)(void *, uint64_t))(v69 + 120))(v71, a5);
  if (__OFADD__(*v37, v34))
  {
LABEL_22:
    __break(1u);
    return;
  }

  *v37 += v34;
  uint64_t v32 = v36(v71, 0LL);
LABEL_8:
  if (v33 < 1)
  {
    v51 = *(void (**)(uint64_t, uint64_t))(*(void *)(a6 - 8) + 8LL);
    uint64_t v52 = v65;
LABEL_16:
    v51(v52, a6);
    return;
  }

  unint64_t v57 = v31 + v30 * v33;
  MEMORY[0x1895F8858](v32);
  *(&v57 - 6) = a5;
  *(&v57 - 5) = a6;
  uint64_t v38 = (uint64_t)v64;
  uint64_t v39 = v65;
  uint64_t v53 = v69;
  uint64_t v54 = v64;
  uint64_t v55 = v33;
  unint64_t v56 = v31;
  (*(void (**)(void *__return_ptr, char *(*)(char *, uint64_t)))(*((void *)v64 + 1) + 72LL))( v71,  partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:));
  if ((v71[0] & 1) == 0)
  {
    v51 = *(void (**)(uint64_t, uint64_t))(*(void *)(a6 - 8) + 8LL);
    uint64_t v52 = v39;
    goto LABEL_16;
  }

  uint64_t v40 = v59;
  (*(void (**)(uint64_t, uint64_t))(v38 + 64))(a6, v38);
  unint64_t v41 = v57;
  uint64_t v70 = v30;
  uint64_t v42 = v60;
  uint64_t v43 = a6;
  uint64_t v44 = v66;
  uint64_t v45 = v67;
  if (v58 >= 1)
  {
    uint64_t v46 = *(void *)(v38 + 80);
    uint64_t v68 = *(void *)(v38 + 192);
    uint64_t v69 = v46;
    do
    {
      uint64_t v47 = (void (*)(void *, void))((uint64_t (*)(void *, char *, uint64_t, uint64_t))v69)( v71,  v40,  v43,  v38);
      (*(void (**)(char *))(v44 + 16))(v42);
      v47(v71, 0LL);
      (*(void (**)(unint64_t, char *, uint64_t))(v44 + 32))(v31, v42, v45);
      v31 += v70;
      ((void (*)(char *, uint64_t, uint64_t))v68)(v40, v43, v38);
    }

    while (v31 < v41);
  }

  uint64_t v49 = (uint64_t)v61;
  uint64_t v48 = v62;
  unint64_t v50 = v63;
  (*(void (**)(char *, char *, unint64_t))(v62 + 32))(v61, v40, v63);
  _expectEnd<A>(of:is:)(v39, v49, v43, v38);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v43 - 8) + 8LL))(v39, v43);
  (*(void (**)(uint64_t, unint64_t))(v48 + 8))(v49, v50);
}

uint64_t protocol witness for _ArrayBufferProtocol.subscript.getter in conformance _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _ArrayBuffer.subscript.getter(a1, a2, *v3, *(uint64_t **)(a3 + 16));
}

uint64_t _ArrayBuffer.subscript.getter(uint64_t a1, uint64_t a2, int64_t a3, uint64_t *a4)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4)
    && _swift_isClassOrObjCExistentialType((uint64_t)a4, a4)
    && (a3 & 0xC000000000000001LL) != 0
    && !swift_dynamicCastMetatype((uint64_t *)&unk_189B8D230, a4))
  {
    if (a2 < a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    if (a1 != a2)
    {
      Swift::Int v17 = a1;
      do
      {
        if (a2 == v17) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        Swift::Int v18 = v17 + 1;
        _ArrayBuffer._typeCheckSlowPath(_:)(v17);
        Swift::Int v17 = v18;
      }

      while (a2 != v18);
    }
  }

  if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
  {
    if (a3 >= 0) {
      a3 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    swift_unknownObjectRetain((id)a3, v8, v9, v10);
    uint64_t v15 = _CocoaArrayWrapper.subscript.getter(a1, a2, (void *)a3, v19);
    swift_unknownObjectRelease((id)a3);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
    if (a2 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    if (isClassOrObjCExistentialType) {
      uint64_t v15 = a3 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      uint64_t v15 = a3;
    }
    swift_bridgeObjectRetain(a3, v12, v13, v14);
  }

  return v15;
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:) in conformance _ArrayBuffer<A>( uint64_t (*a1)(uint64_t, unint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _ArrayBuffer.withUnsafeBufferPointer<A>(_:)(a1, a2, *v4, *(uint64_t **)(a4 + 16));
}

void *_ss12_ArrayBufferV010withUnsafeB7Pointeryqd__qd__SRyxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxSSSgIsgyrzo_AByxGAFsAE_pAFRsd__r__lIetMggozo_Tp5( void *(*a1)(uint64_t *__return_ptr, uint64_t, unint64_t), uint64_t a2, int64_t a3, uint64_t *a4)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
  {
    uint64_t v17 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a4, v9, v10);
    swift_bridgeObjectRetain(a3, v18, v19, v20);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v17, v21);
    uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v17, WitnessTable);
    uint64_t v15 = _ss15ContiguousArrayV23withUnsafeBufferPointeryqd__qd__SRyxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxSSSgIsgyrzo_AByxGAFsAE_pAFRsd__r__lIetMggozo_Tp5( a1,  a2,  v23,  (uint64_t)a4);
    swift_release(v23);
  }

  else
  {
    else {
      uint64_t v11 = a3;
    }
    uint64_t v12 = *(unsigned __int8 *)(*(a4 - 1) + 80);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
    {
      if (a3 < 0) {
        uint64_t v24 = (void *)a3;
      }
      else {
        uint64_t v24 = (void *)(a3 & 0xFFFFFFFFFFFFFF8LL);
      }
      unint64_t v25 = (unint64_t)objc_msgSend(v24, sel_count);
      if ((v25 & 0x8000000000000000LL) != 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      unint64_t v14 = v25;
    }

    else
    {
      else {
        uint64_t v13 = a3;
      }
      unint64_t v14 = *(void *)(v13 + 16);
    }

    uint64_t v15 = (void *)a2;
    a1(&v26, v11 + ((v12 + 32) & ~v12), v14);
    if (!v4) {
      return (void *)v26;
    }
  }

  return v15;
}

uint64_t _ArrayBuffer.withUnsafeBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t, unint64_t), uint64_t a2, int64_t a3, uint64_t *a4)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
  {
    uint64_t v14 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a4, v7, v8);
    swift_bridgeObjectRetain(a3, v15, v16, v17);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v14, v18);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v14, WitnessTable);
    uint64_t v21 = *(unsigned __int8 *)(*(a4 - 1) + 80);
    a1(v20 + ((v21 + 32) & ~v21), *(void *)(v20 + 16));
    return swift_release(v20);
  }

  else
  {
    else {
      uint64_t v9 = a3;
    }
    uint64_t v10 = *(unsigned __int8 *)(*(a4 - 1) + 80);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
    {
      if (a3 < 0) {
        uint64_t v22 = (void *)a3;
      }
      else {
        uint64_t v22 = (void *)(a3 & 0xFFFFFFFFFFFFFF8LL);
      }
      unint64_t v23 = (unint64_t)objc_msgSend(v22, sel_count);
      if ((v23 & 0x8000000000000000LL) != 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      unint64_t v12 = v23;
    }

    else
    {
      else {
        uint64_t v11 = a3;
      }
      unint64_t v12 = *(void *)(v11 + 16);
    }

    return a1(v9 + ((v10 + 32) & ~v10), v12);
  }

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:) in conformance _ArrayBuffer<A>( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _ArrayBuffer.withUnsafeMutableBufferPointer<A>(_:)(a1, a2, a4);
}

uint64_t _ArrayBuffer.withUnsafeMutableBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *v3;
  uint64_t v6 = *(uint64_t **)(a3 + 16);
  uint64_t v7 = _ArrayBuffer.firstElementAddressIfContiguous.getter(*v3, v6);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v6, v6) && (v5 < 0 || (v5 & 0x4000000000000000LL) != 0))
  {
    if (v5 < 0) {
      uint64_t v13 = (void *)v5;
    }
    else {
      uint64_t v13 = (void *)(v5 & 0xFFFFFFFFFFFFFF8LL);
    }
    unint64_t v14 = (unint64_t)objc_msgSend(v13, sel_count);
    if ((v14 & 0x8000000000000000LL) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
    unint64_t v10 = v14;
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
    uint64_t v9 = v5 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v9 = v5;
    }
    unint64_t v10 = *(void *)(v9 + 16);
  }

  if (v10) {
    BOOL v11 = v7 == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
  }
  return a1(v7);
}

BOOL _ArrayBuffer.count.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *v2;
  BOOL result = _swift_isClassOrObjCExistentialType(*(void *)(a2 + 16), *(uint64_t **)(a2 + 16));
  uint64_t v6 = v4 & 0xFFFFFFFFFFFFF8LL;
  if (!result) {
    uint64_t v6 = v4;
  }
  *(void *)(v6 + 16) = a1;
  return result;
}

BOOL (*protocol witness for _ArrayBufferProtocol.count.modify in conformance _ArrayBuffer<A>( void *a1, uint64_t a2))(uint64_t *a1)
{
  uint64_t v4 = *v2;
  uint64_t v5 = *(uint64_t **)(a2 + 16);
  a1[1] = v2;
  a1[2] = v5;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v5, v5) && (v4 < 0 || (v4 & 0x4000000000000000LL) != 0))
  {
    id v10 = _ArrayBuffer._nonNative.getter(v4);
    id v8 = objc_msgSend(v10, sel_count);
    swift_unknownObjectRelease(v10);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
    uint64_t v7 = v4 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v7 = v4;
    }
    id v8 = *(id *)(v7 + 16);
  }

  *a1 = v8;
  return protocol witness for _ArrayBufferProtocol.count.modify in conformance _ArrayBuffer<A>;
}

BOOL protocol witness for _ArrayBufferProtocol.count.modify in conformance _ArrayBuffer<A>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)a1[1];
  BOOL result = _swift_isClassOrObjCExistentialType(a1[2], (uint64_t *)a1[2]);
  uint64_t v4 = v2 & 0xFFFFFFFFFFFFF8LL;
  if (!result) {
    uint64_t v4 = v2;
  }
  *(void *)(v4 + 16) = v1;
  return result;
}

BOOL (*_ArrayBuffer.count.modify(void *a1, uint64_t a2))(uint64_t *a1)
{
  uint64_t v4 = *v2;
  uint64_t v5 = *(uint64_t **)(a2 + 16);
  a1[1] = v2;
  a1[2] = v5;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v5, v5) && (v4 < 0 || (v4 & 0x4000000000000000LL) != 0))
  {
    if (v4 < 0) {
      id v10 = (void *)v4;
    }
    else {
      id v10 = (void *)(v4 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v8 = objc_msgSend(v10, sel_count);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
    uint64_t v7 = v4 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v7 = v4;
    }
    id v8 = *(id *)(v7 + 16);
  }

  *a1 = v8;
  return protocol witness for _ArrayBufferProtocol.count.modify in conformance _ArrayBuffer<A>;
}

id protocol witness for _ArrayBufferProtocol.capacity.getter in conformance _ArrayBuffer<A>(uint64_t a1)
{
  return _ArrayBuffer.capacity.getter(*v1, *(uint64_t **)(a1 + 16));
}

id _ArrayBuffer.capacity.getter(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      uint64_t v7 = (void *)a1;
    }
    else {
      uint64_t v7 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    return objc_msgSend(v7, sel_count);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v5 = a1;
    }
    return (id)(*(void *)(v5 + 24) >> 1);
  }

id protocol witness for _ArrayBufferProtocol.owner.getter in conformance _ArrayBuffer<A>(uint64_t a1)
{
  uint64_t v2 = (void *)specialized _ArrayBuffer.owner.getter(*v1, *(uint64_t **)(a1 + 16));
  return swift_unknownObjectRetain(v2, v3, v4, v5);
}

id _ArrayBuffer.owner.getter(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (void *)specialized _ArrayBuffer.owner.getter(a1, a2);
  return swift_unknownObjectRetain(v2, v3, v4, v5);
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddress.getter in conformance _ArrayBuffer<A>( uint64_t a1)
{
  return _ArrayBuffer.firstElementAddress.getter(*v1, *(uint64_t **)(a1 + 16));
}

uint64_t specialized _ArrayBuffer.firstElementAddress.getter(uint64_t a1)
{
  return a1 + 32;
}

uint64_t _ArrayBuffer.firstElementAddress.getter(uint64_t a1, uint64_t *a2)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  uint64_t v5 = a1 & 0xFFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v5 = a1;
  }
  uint64_t v6 = *(unsigned __int8 *)(*(a2 - 1) + 80);
  return v5 + ((v6 + 32) & ~v6);
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddressIfContiguous.getter in conformance _ArrayBuffer<A>( uint64_t a1)
{
  return _ArrayBuffer.firstElementAddressIfContiguous.getter(*v1, *(uint64_t **)(a1 + 16));
}

uint64_t _ArrayBuffer.firstElementAddressIfContiguous.getter(uint64_t a1, uint64_t *a2)
{
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a2, a2)
    || (uint64_t result = 0LL, (a1 & 0x8000000000000000LL) == 0) && (a1 & 0x4000000000000000LL) == 0)
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v6 = a1;
    }
    uint64_t v7 = *(unsigned __int8 *)(*(a2 - 1) + 80);
    return v6 + ((v7 + 32) & ~v7);
  }

  return result;
}

uint64_t _ArrayBufferProtocol.subscriptBaseAddress.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t protocol witness for _ArrayBufferProtocol.identity.getter in conformance _ArrayBuffer<A>(uint64_t a1)
{
  return _ArrayBuffer.identity.getter(*v1, *(uint64_t **)(a1 + 16));
}

uint64_t _ArrayBuffer.identity.getter(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (unint64_t)a1 >> 62)
  {
    if (a1 < 0) {
      return a1;
    }
    else {
      return a1 & 0xFFFFFFFFFFFFFF8LL;
    }
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v6 = a1;
    }
    uint64_t v7 = *(unsigned __int8 *)(*(a2 - 1) + 80);
    return v6 + ((v7 + 32) & ~v7);
  }

void protocol witness for MutableCollection.subscript.setter in conformance _ArrayBuffer<A>( uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void _ArrayBuffer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = type metadata accessor for CollectionOfOne(0LL, (uint64_t)a4, a3, (uint64_t)a4);
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  BOOL v11 = (char *)&v27 - v10;
  uint64_t v12 = *(a4 - 1);
  MEMORY[0x1895F8858](v9);
  unint64_t v14 = (char *)&v27 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
  {
    uint64_t v28 = a3;
    if (__OFADD__(a2, 1LL))
    {
      __break(1u);
    }

    else if (a2 + 1 >= a2)
    {
      (*(void (**)(char *, uint64_t, uint64_t *))(v12 + 32))(v11, a1, a4);
      uint64_t v19 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a4, v17, v18);
      swift_bridgeObjectRetain(a3, v20, v21, v22);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v19, v23);
      uint64_t v26 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v8, v25);
      _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( a2,  a2 + 1,  (void (*)(void, void, void))1,  (uint64_t)v11,  v19,  v8,  WitnessTable,  v26);
      swift_bridgeObjectRelease(v28);
      return;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  else {
    uint64_t v15 = a3;
  }
  (*(void (**)(char *, uint64_t, uint64_t *))(v12 + 32))(v14, a1, a4);
  unint64_t v16 = v15
  (*(void (**)(uint64_t, unint64_t, uint64_t *))(v12 + 16))(a1, v16, a4);
  (*(void (**)(uint64_t, uint64_t *))(v12 + 8))(a1, a4);
  (*(void (**)(unint64_t, char *, uint64_t *))(v12 + 40))(v16, v14, a4);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>( void *a1, unint64_t *a2, uint64_t a3))(uint64_t ***a1, char a2)
{
  uint64_t v7 = malloc(0x30uLL);
  *a1 = v7;
  uint64_t v8 = *(uint64_t **)(a3 + 16);
  *uint64_t v7 = v8;
  uint64_t v9 = *(v8 - 1);
  v7[1] = v9;
  size_t v10 = *(void *)(v9 + 64);
  v7[2] = malloc(v10);
  BOOL v11 = malloc(v10);
  unint64_t v12 = *a2;
  v7[3] = v11;
  v7[4] = v12;
  uint64_t v13 = *v3;
  v7[5] = *v3;
  _ArrayBuffer.subscript.getter(v12, v13, v8, (uint64_t)v11);
  return protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>( uint64_t ***a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = (uint64_t)(*a1)[4];
  uint64_t v3 = (uint64_t)(*a1)[5];
  uint64_t v5 = (*a1)[2];
  uint64_t v6 = (*a1)[3];
  if ((a2 & 1) != 0)
  {
    uint64_t v7 = *v2;
    uint64_t v8 = v2[1];
    ((void (*)(uint64_t *, uint64_t *, uint64_t *))v8[2])((*a1)[2], v6, *v2);
    _ArrayBuffer.subscript.setter((uint64_t)v5, v4, v3, v7);
    ((void (*)(uint64_t *, uint64_t *))v8[1])(v6, v7);
  }

  else
  {
    _ArrayBuffer.subscript.setter((uint64_t)(*a1)[3], v4, v3, *v2);
  }

  free(v6);
  free(v5);
  free(v2);
}

void (*_ArrayBuffer.subscript.modify( void *a1, unint64_t a2, uint64_t a3, uint64_t *a4))(uint64_t *a1, char a2)
{
  uint64_t v8 = malloc(0x30uLL);
  *a1 = v8;
  *uint64_t v8 = a2;
  v8[1] = a3;
  uint64_t v9 = *(a4 - 1);
  v8[2] = a4;
  v8[3] = v9;
  size_t v10 = *(void *)(v9 + 64);
  v8[4] = malloc(v10);
  BOOL v11 = malloc(v10);
  v8[5] = v11;
  _ArrayBuffer.subscript.getter(a2, a3, a4, (uint64_t)v11);
  return _ArrayBuffer.subscript.modify;
}

void _ArrayBuffer.subscript.modify(uint64_t *a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void **)(*a1 + 32);
  uint64_t v4 = *(void **)(*a1 + 40);
  if ((a2 & 1) != 0)
  {
    uint64_t v5 = *(uint64_t **)(v2 + 16);
    uint64_t v6 = *(void *)(v2 + 24);
    uint64_t v8 = *(void *)v2;
    uint64_t v7 = *(void *)(v2 + 8);
    (*(void (**)(void, void *, uint64_t *))(v6 + 16))(*(void *)(*a1 + 32), v4, v5);
    _ArrayBuffer.subscript.setter((uint64_t)v3, v8, v7, v5);
    (*(void (**)(void *, uint64_t *))(v6 + 8))(v4, v5);
  }

  else
  {
    _ArrayBuffer.subscript.setter(*(void *)(*a1 + 40), *(void *)v2, *(void *)(v2 + 8), *(uint64_t **)(v2 + 16));
  }

  free(v4);
  free(v3);
  free((void *)v2);
}

void protocol witness for MutableCollection.subscript.setter in conformance _ArrayBuffer<A>()
{
}

void _ArrayBuffer.subscript.setter()
{
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>( uint64_t *a1, uint64_t *a2, uint64_t a3))(id *a1, char a2)
{
  *a1 = _ArrayBuffer.subscript.getter(*a2, a2[1], *v3, *(uint64_t **)(a3 + 16));
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>( id *a1, char a2)
{
}

void (*_ArrayBuffer.subscript.modify( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4))(id *a1, char a2)
{
  *a1 = _ArrayBuffer.subscript.getter(a2, a3, *v4, *(uint64_t **)(a4 + 16));
  a1[1] = v6;
  a1[2] = v7;
  a1[3] = v8;
  return _ArrayBuffer.subscript.modify;
}

void _ArrayBuffer.subscript.modify(id *a1, char a2)
{
}

void *protocol witness for MutableCollection.partition(by:) in conformance _ArrayBuffer<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void *MutableCollection<>.partition(by:)@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v22 = a6;
  uint64_t v19 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v19,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v14 = (char *)&v18 - v13;
  uint64_t v25 = a3;
  uint64_t v26 = a4;
  uint64_t v27 = a5;
  uint64_t v28 = a1;
  uint64_t v20 = a1;
  uint64_t v21 = a2;
  uint64_t v29 = a2;
  uint64_t v15 = v23;
  uint64_t result = (*(void *(**)(uint64_t *__return_ptr, uint64_t (*)@<X0>(void *@<X8>), _BYTE *, ValueMetadata *, uint64_t, uint64_t))(a5 + 80))( &v30,  partial apply for closure #1 in MutableCollection<>.partition(by:),  v24,  &type metadata for Int,  a3,  a5);
  if (!v15)
  {
    if ((v31 & 1) != 0)
    {
      return (void *)MutableCollection<>._partitionImpl(by:)(v20, v21, a3, a4, a5, v22);
    }

    else
    {
      uint64_t v17 = v30;
      (*((void (**)(uint64_t, const char *))v19 + 8))(a3, v19);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(a4 + 48))(v14, v17, a3, a4);
      return (void *)(*(uint64_t (**)(char *, unint64_t))(v12 + 8))(v14, AssociatedTypeWitness);
    }
  }

  return result;
}

uint64_t specialized MutableCollection.swapAt(_:_:)(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    unint64_t v3 = *v2;
    unint64_t v4 = v2[1];
    char v5 = 8 * (result & 7);
    if (result >= 8) {
      unint64_t v6 = v2[1];
    }
    else {
      unint64_t v6 = *v2;
    }
    unint64_t v7 = v6 >> v5;
    if (a2 >= 8) {
      unint64_t v8 = v2[1];
    }
    else {
      unint64_t v8 = *v2;
    }
    char v9 = 8 * (a2 & 7);
    unint64_t v10 = v8 >> v9;
    uint64_t v11 = (-255LL << v5) - 1;
    unint64_t v12 = (unint64_t)v10 << v5;
    if (result > 7)
    {
      unint64_t v4 = v12 | v4 & v11;
      v2[1] = v4;
    }

    else
    {
      unint64_t v3 = v12 | v3 & v11;
      *uint64_t v2 = v3;
    }

    unint64_t v13 = (unint64_t)v7 << v9;
    if (a2 >= 8) {
      unint64_t v3 = v4;
    }
    v2[a2 > 7] = v3 & ((-255LL << v9) - 1) | v13;
  }

  return result;
}

uint64_t MutableCollection.swapAt(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v33 = a4;
  uint64_t v7 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v31 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v10 = (char *)&v27 - v9;
  unint64_t v11 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v7 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v12 = *(void *)(v11 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v30 = (char *)&v27 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v32 = (char *)&v27 - v15;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                         + 8LL))( a1,  a2,  AssociatedTypeWitness);
  if ((result & 1) == 0)
  {
    uint64_t v27 = v10;
    uint64_t v28 = a2;
    uint64_t v29 = *(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v7 + 80);
    uint64_t v18 = (void (*)(_BYTE *, void))v29(v34, a1, a3, v7);
    uint64_t v19 = *(void (**)(char *))(v12 + 16);
    uint64_t v20 = v32;
    v19(v32);
    v18(v34, 0LL);
    uint64_t v31 = *(void *)(v31 + 16);
    uint64_t v21 = v27;
    ((void (*)(char *, uint64_t, unint64_t))v31)(v27, a1, AssociatedTypeWitness);
    uint64_t v22 = v28;
    uint64_t v23 = (void (*)(_BYTE *, void))v29(v34, v28, a3, v7);
    uint64_t v24 = v30;
    v19(v30);
    v23(v34, 0LL);
    uint64_t v25 = v33;
    uint64_t v26 = *(void (**)(char *, char *, uint64_t, uint64_t))(v33 + 24);
    v26(v24, v21, a3, v33);
    ((void (*)(char *, uint64_t, unint64_t))v31)(v21, v22, AssociatedTypeWitness);
    return ((uint64_t (*)(char *, char *, uint64_t, uint64_t))v26)(v20, v21, a3, v25);
  }

  return result;
}

uint64_t protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a2);
}

uint64_t MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:)@<X0>( uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5( a1,  a2);
}

uint64_t _sSMsE39withContiguousMutableStorageIfAvailableyqd__Sgqd__Sry7ElementQzGzKXEKlFSryxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lys5UInt8Vqd__Isglrzo_s12_SmallStringVABsAG_pAKRszr__lIetMglrzo_Tpq5@<X0>( uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 - 8) + 56LL))(a2, 1LL, 1LL, a1);
}

uint64_t MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>( uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5( a1,  a2);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, a3, a4, (uint64_t)&protocol witness table for Int, a5);
}

unint64_t specialized RandomAccessCollection<>.index(_:offsetBy:)( uint64_t a1, uint64_t a2, unsigned int a3)
{
  BOOL v3 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v3)
  {
    __break(1u);
    return result;
  }

  if (a3 >= 0x10000)
  {
    if (result <= 2) {
      return result;
    }
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  if (result >= 2) {
    goto LABEL_6;
  }
  return result;
}

{
  BOOL v3;
  unint64_t result;
  unint64_t v5;
  BOOL v3 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v3)
  {
    __break(1u);
    return result;
  }

  if (a3 >= 0x80)
  {
    if (a3 >= 0x800)
    {
      if (HIWORD(a3))
      {
        if (result <= 4) {
          return result;
        }
      }

      else if (result <= 3)
      {
        return result;
      }

LABEL_7:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
    }

    char v5 = 2LL;
  }

  else
  {
    char v5 = 1LL;
  }

  if (result > v5) {
    goto LABEL_7;
  }
  return result;
}

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
    }

    unint64_t v4 = 2LL;
  }

  else
  {
    unint64_t v4 = 1LL;
  }

  if (result >= v4) {
    goto LABEL_7;
  }
  return result;
}

  uint64_t v12 = specialized UnsafeRawBufferPointer.init<A>(_:)((uint64_t)v8, v9);
  a1(v12);
  swift_bridgeObjectRelease(v6);
}

    outlined destroy of _HasContiguousBytes?( (uint64_t)v23,  &demangling cache variable for type metadata for (AnyHashable?, AnyHashable?));
    return 0LL;
  }

  outlined init with copy of AnyHashable?((uint64_t)v23, (uint64_t)&v20);
  if (!*((void *)&v25 + 1))
  {
    outlined destroy of AnyHashable((uint64_t *)&v20);
    goto LABEL_7;
  }

  v18[0] = v20;
  v18[1] = v21;
  BOOL v3 = v22;
  uint64_t v19 = v22;
  uint64_t v15 = v24;
  unint64_t v16 = v25;
  uint64_t v17 = v26;
  unint64_t v4 = *((void *)&v21 + 1);
  __swift_project_boxed_opaque_existential_0Tm(v18, *((uint64_t *)&v21 + 1));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v3 + 8))(v12, v4, v3);
  char v5 = v13;
  unint64_t v6 = v14;
  __swift_project_boxed_opaque_existential_0Tm(v12, v13);
  uint64_t v7 = *((void *)&v16 + 1);
  unint64_t v8 = v17;
  __swift_project_boxed_opaque_existential_0Tm(&v15, *((uint64_t *)&v16 + 1));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v11, v7, v8);
  LOBYTE(v5) = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v6 + 16))(v11, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  uint64_t v9 = v5 & 1;
  __swift_destroy_boxed_opaque_existential_1Tm(v12);
  outlined destroy of AnyHashable((uint64_t *)&v15);
  outlined destroy of AnyHashable((uint64_t *)v18);
  outlined destroy of AnyHashable?(v23);
  return v9;
}

      uint64_t v54 = v22;
      uint64_t v55 = v21;
      unint64_t v56 = v19;
      uint64_t v52 = v9;
      uint64_t v25 = a2;
      int v59 = v16;
      uint64_t v26 = swift_retain((unint64_t *)v16, v11, v12, v13);
      uint64_t v27 = (char *)_SwiftDeferredNSDictionary.bridgeKeys()((uint64_t)v26);
      uint64_t v31 = v64;
      if (v64 < 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
      }
      uint64_t v32 = (uint64_t)v27;
      if (v64)
      {
        uint64_t v53 = v5;
        uint64_t v33 = 0LL;
        uint64_t v34 = v27 + 40;
        uint64_t v60 = (unint64_t)(63 - v18) >> 6;
        unint64_t v50 = v59 + 88;
        v51 = v60 - 3;
        while (1)
        {
          if (v23 == v24)
          {
            uint64_t v23 = v24;
            uint64_t v31 = v33;
            char v5 = v53;
            break;
          }

          if (v32)
          {
            uint64_t v35 = *(void **)&v34[8 * v23];
            swift_unknownObjectRetain(v35, v28, v29, v30);
          }

          else
          {
            (*(void (**)(id *, unint64_t, uint64_t *))(v63 + 16))( v15,  *(void *)(v62[4] + 48LL) + *(void *)(v63 + 72) * v23,  v6);
            if (_swift_isClassOrObjCExistentialType((uint64_t)v6, v6))
            {
              if (v61 != 8) {
                goto LABEL_39;
              }
              uint64_t v35 = *v15;
              swift_unknownObjectRetain(*v15, v36, v37, v38);
              (*(void (**)(id *, uint64_t *))(v63 + 8))(v15, v6);
            }

            else
            {
              uint64_t v42 = v52;
              (*(void (**)(id *, id *, uint64_t *))(v63 + 32))(v52, v15, v6);
              uint64_t v35 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v42, v6, v43, v44);
            }
          }

          if (v33 == 0x1000000000000000LL)
          {
            __break(1u);
LABEL_39:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
          }

          *(void *)(v25 + 8 * v33) = v35;
          swift_unknownObjectRelease(v35);
          uint64_t v39 = v23 >> 6;
          if ((*(void *)(v17 + 8 * (v23 >> 6)) & (-2LL << v23)) != 0)
          {
            uint64_t v23 = __clz(__rbit64(*(void *)(v17 + 8 * (v23 >> 6)) & (-2LL << v23))) | v23 & 0xFFFFFFFFFFFFFFC0LL;
          }

          else
          {
            uint64_t v40 = v39 + 1;
            uint64_t v23 = v24;
            if (v39 + 1 < v60)
            {
              unint64_t v41 = *(void *)(v17 + 8 * v40);
              if (!v41)
              {
                uint64_t v40 = v39 + 2;
                uint64_t v23 = v24;
                if (v39 + 2 >= v60) {
                  goto LABEL_11;
                }
                unint64_t v41 = *(void *)(v17 + 8 * v40);
                if (!v41)
                {
                  while (v51 != v39)
                  {
                    unint64_t v41 = *(void *)(v50 + 8 * v39++);
                    if (v41)
                    {
                      uint64_t v40 = v39 + 2;
                      goto LABEL_22;
                    }
                  }

                  uint64_t v23 = v24;
                  goto LABEL_11;
                }
              }

  uint64_t v24 = *v6;
  if ((v22 & 1) != 0)
  {
LABEL_8:
    uint64_t v25 = *(void *)(a4 + 24);
    uint64_t v26 = *(void *)(v25 - 8);
    uint64_t v27 = *(void *)(v26 + 72) * v18;
    uint64_t v28 = *(void (**)(uint64_t, unint64_t, uint64_t))(v26 + 32);
    uint64_t v29 = v37;
    v28(v37, v24[7] + v27, v25);
    v28(v24[7] + v27, v36, v25);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v26 + 56))(v29, 0LL, 1LL, v25);
  }

  uint64_t v18 = *v5;
  if ((v16 & 1) != 0)
  {
LABEL_8:
    uint64_t v19 = (uint64_t *)(v18[7] + 32 * v12);
    __swift_destroy_boxed_opaque_existential_1Tm(v19);
    return outlined init with take of Any(a1, v19);
  }

  unint64_t v16 = *v4;
  if ((v14 & 1) != 0)
  {
LABEL_8:
    uint64_t v17 = (uint64_t *)(v16[7] + 32 * v10);
    __swift_destroy_boxed_opaque_existential_1Tm(v17);
    return outlined init with take of Any(a1, v17);
  }

    v340 = 0LL;
    v72 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v73 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    char v74 = v338;
    v72(&v340, &type metadata for Int, v73, a3, a4);
    v75 = v74;
    v76 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v66,  v74,  a3);
    uint64_t v69 = *(void (**)(char *, uint64_t))(v40 + 8);
    v69(v75, a3);
    uint64_t v70 = v339;
    if ((v76 & 1) != 0) {
      goto LABEL_17;
    }
    goto LABEL_21;
  }

  uint64_t v71 = v61(a3, a4);
  v323 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  unint64_t v63 = v323(a3, a4);
  uint64_t v66 = a2;
  if ((v71 & 1) == 0)
  {
    uint64_t v70 = v339;
    if (v63 < 64)
    {
      uint64_t v77 = v338;
      (*(void (**)(char *, uint64_t, uint64_t))(v40 + 16))(v338, v66, a3);
      v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v69 = *(void (**)(char *, uint64_t))(v40 + 8);
      v69(v77, a3);
      if (!v78) {
        goto LABEL_17;
      }
    }

    else
    {
      v340 = 0LL;
      v91 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      char v93 = v338;
      v91(&v340, &type metadata for Int, v92, a3, a4);
      v94 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL))( v66,  v93,  a3);
      unint64_t v95 = v93;
      uint64_t v69 = *(void (**)(char *, uint64_t))(v40 + 8);
      v69(v95, a3);
      if ((v94 & 1) != 0) {
        goto LABEL_17;
      }
    }

    goto LABEL_21;
  }

  if (v63 > 64) {
    goto LABEL_7;
  }
  v79 = v336;
  v80 = *(void (**)(uint64_t *, uint64_t))(swift_getAssociatedConformanceWitness( (uint64_t)v336,  a3,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral)
                                                  + 8);
  v81 = v10;
  unint64_t v82 = v40;
  v83 = v335;
  v306 = v81;
  v80(&qword_18180BE68, 256LL);
  v84 = (void (*)(char *, uint64_t, const char *))*((void *)v79 + 3);
  v85 = v338;
  v86 = v83;
  uint64_t v40 = v82;
  v87 = v79;
  uint64_t v66 = a2;
  v84(v86, a3, v87);
  uint64_t v88 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 32LL))( a2,  v85,  a3);
  v89 = v85;
  uint64_t v69 = *(void (**)(char *, uint64_t))(v82 + 8);
  v69(v89, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v82 + 16))(v43, a2, a3);
  if ((v88 & 1) == 0)
  {
    v69(v43, a3);
    unint64_t v10 = v306;
    uint64_t v70 = v339;
    goto LABEL_21;
  }

  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v69(v43, a3);
  unint64_t v10 = v306;
  uint64_t v70 = v339;
  if (!v90) {
    goto LABEL_17;
  }
LABEL_21:
  (*(void (**)(uint64_t, uint64_t))(v7 + 56))(a3, v7);
  v98 = (uint64_t)v334;
  v99 = swift_getAssociatedConformanceWitness( a4,  a3,  (uint64_t)v334,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  v100 = *(uint64_t (**)(uint64_t))(v99 + 136);
  v305 = v99;
  uint64_t v101 = v100(v98);
  if (v101 > 15)
  {
    (*((void (**)(char *, uint64_t))v333 + 1))(v70, v98);
    v102 = v331;
    v103 = v331(a3, a4);
    v104 = v66;
    v105 = v103;
    v106 = v325;
    (*(void (**)(char *, uint64_t, uint64_t))(v40 + 16))(v325, v104, a3);
    if ((v105 & 1) != 0)
    {
      if ((v102(a3, a4) & 1) != 0)
      {
        v107 = v323(a3, a4);
        if (v107 >= 64)
        {
          v340 = 0LL;
          uint64_t v110 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v111 = lazy protocol witness table accessor for type Int and conformance Int(v107, v108, v109);
          uint64_t v112 = v338;
          v110(&v340, &type metadata for Int, v111, a3, a4);
          uint64_t v113 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v106,  v112,  a3);
          v69(v112, a3);
          uint64_t v114 = v106;
          goto LABEL_115;
        }

        goto LABEL_51;
      }

      uint64_t v186 = v40;
      v187 = v102(a3, a4);
      v188 = v323(a3, a4);
      if ((v187 & 1) != 0)
      {
        if (v188 <= 64)
        {
          v219 = (void (**)(char *, uint64_t, const char *))v336;
          v220 = swift_getAssociatedConformanceWitness( (uint64_t)v336,  a3,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v221 = v335;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v220 + 8))( &qword_18180BE68,  256LL,  v10,  v220);
          v222 = v338;
          v219[3](v221, a3, (const char *)v219);
          v223 = v325;
          LOBYTE(v219) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                            + 16LL))( v325,  v222,  a3);
          v69(v222, a3);
          (*(void (**)(char *, char *, uint64_t))(v186 + 32))(v310, v223, a3);
          if ((v219 & 1) != 0)
          {
            v69(v310, a3);
LABEL_116:
            v96 = 0;
            v203 = -1024;
            goto LABEL_117;
          }

          v249 = v310;
          v201 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v202 = v249;
          goto LABEL_52;
        }

        v340 = 0LL;
        v191 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v192 = lazy protocol witness table accessor for type Int and conformance Int(v188, v189, v190);
        v193 = v338;
        v191(&v340, &type metadata for Int, v192, a3, a4);
        uint64_t v194 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
        v195 = v325;
        uint64_t v113 = v194(v325, v193, a3);
        v196 = v193;
        v197 = a3;
LABEL_114:
        v69(v196, v197);
        uint64_t v114 = v195;
LABEL_115:
        v69(v114, a3);
        if ((v113 & 1) != 0) {
          goto LABEL_116;
        }
LABEL_55:
        v96 = 0;
        v203 = 31744;
LABEL_117:
        *v337 = v203;
        return v96 & 1;
      }

      v106 = v325;
      if (v188 < 64)
      {
LABEL_51:
        v201 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v202 = v106;
LABEL_52:
        v69(v202, a3);
        if (v201 < 0) {
          goto LABEL_116;
        }
        goto LABEL_55;
      }
    }

    v69(v106, a3);
    goto LABEL_55;
  }

  v303 = v40;
  v306 = v10;
  v302 = v66;
  v304 = v101;
  if (v101 <= 10)
  {
    unint64_t v154 = (uint64_t)v334;
    v155 = v322;
    (*((void (**)(char *, char *, unint64_t *))v333 + 4))(v322, v339, v334);
    v156 = v305;
    v339 = *(char **)(v305 + 64);
    if ((((uint64_t (*)(uint64_t, unint64_t))v339)(v154, v305) & 1) != 0)
    {
      uint64_t v157 = v155;
      v158 = v314;
      (*((void (**)(char *, char *, uint64_t))v333 + 2))(v314, v157, v154);
      v159 = (void (**)(char *, uint64_t, const char *))v329;
      v160 = v326;
      v161 = swift_getAssociatedConformanceWitness( (uint64_t)v329,  v154,  v326,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v162 = v327;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v161 + 8))( &qword_18180BE68,  256LL,  v160,  v161);
      v163 = v332;
      v159[3](v162, v154, (const char *)v159);
      v164 = swift_getAssociatedConformanceWitness( v7,  a3,  v154,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v159) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v164 + 32))( v158,  v163,  v154,  v164);
      uint64_t v165 = (void (*)(char *, uint64_t))*((void *)v333 + 1);
      v165(v163, v154);
      v165(v158, v154);
      unint64_t v10 = v306;
      v156 = v305;
      v155 = v322;
    }

    v166 = *(uint64_t (**)(uint64_t, unint64_t))(v156 + 128);
    if (v166(v154, v156) < 16)
    {
LABEL_80:
      v230 = (*(uint64_t (**)(uint64_t, unint64_t))(v156 + 120))(v154, v156);
      (*((void (**)(char *, uint64_t))v333 + 1))(v155, v154);
      v231 = v331;
      v232 = v331(a3, a4);
      v233 = v320;
      (*(void (**)(char *, uint64_t, uint64_t))(v303 + 16))(v320, v302, a3);
      if ((v232 & 1) != 0)
      {
        v234 = v10;
        if ((v231(a3, a4) & 1) != 0)
        {
          v235 = v323(a3, a4);
          if (v235 < 64)
          {
LABEL_83:
            v238 = v320;
            v239 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v69(v238, a3);
            v240 = v239 >> 63;
            goto LABEL_121;
          }

          goto LABEL_88;
        }

        v242 = v231(a3, a4);
        v235 = v323(a3, a4);
        if ((v242 & 1) != 0)
        {
          if (v235 <= 64)
          {
            v250 = v336;
            v251 = v234;
            v252 = swift_getAssociatedConformanceWitness( (uint64_t)v336,  a3,  v234,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v253 = v335;
            (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v252 + 8))( &qword_18180BE68,  256LL,  v251,  v252);
            v254 = v338;
            (*((void (**)(char *, uint64_t, const char *))v250 + 3))(v253, a3, v250);
            v255 = v320;
            LOBYTE(v251) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                              + 16LL))( v320,  v254,  a3);
            v69(v254, a3);
            (*(void (**)(char *, char *, uint64_t))(v303 + 32))(v309, v255, a3);
            if ((v251 & 1) != 0) {
              LOBYTE(v240) = 1;
            }
            else {
              v240 = (unint64_t)(*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4) >> 63;
            }
            v248 = v309;
            goto LABEL_120;
          }

  uint64_t v12 = ((uint64_t (*)(void *, uint64_t, uint64_t))a4)(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12 & 0x1FF;
}

  uint64_t v12 = ((uint64_t (*)(void *, uint64_t, uint64_t))a4)(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12 & 0x1FFFF;
}

  uint64_t v12 = ((uint64_t (*)(void *, uint64_t, uint64_t))a4)(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12 | ((HIDWORD(v12) & 1) << 32);
}

  uint64_t v12 = ((uint64_t (*)(void *, uint64_t, uint64_t))a4)(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12;
}

  uint64_t v12 = ((uint64_t (*)(void *, uint64_t, uint64_t))a4)(v8, v9, a3);
  swift_bridgeObjectRelease(v6);
  return v12;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unicode.Scalar.UTF8View index is out of bounds",  46LL,  2,  "Swift/UnicodeScalar.swift",  25LL,  2,  0x1E9uLL,  0);
  }

  if (a1) {
    goto LABEL_7;
  }
  return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(a2, a1);
}

  uint64_t v23 = v38;
  uint64_t v24 = v14;
  uint64_t v25 = v37;
  if ((v20 & 1) == 0) {
    goto LABEL_11;
  }
LABEL_8:
  uint64_t v26 = *(void *)(v9 - 8);
  uint64_t v27 = v16;
  (*(void (**)(char *, unint64_t, uint64_t))(v26 + 32))( v11,  (*v5)[7] + *(void *)(v26 + 72) * v16,  v9);
  uint64_t v28 = 0LL;
LABEL_12:
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v26 + 56))(v11, v28, 1LL, v9);
  uint64_t v32 = *(void (**)(char *, uint64_t))(v39 + 8);
  v32(v11, v25);
  uint64_t v33 = v5;
  uint64_t v34 = v36;
  $defer #1 <A, B>() in _NativeDictionary.subscript.modify(v23, v20 & 1, v33, v27, v36, v13, v9, v24);
  (*(void (**)(uint64_t, unint64_t))(*(void *)(v13 - 8) + 8LL))(v34, v13);
  return ((uint64_t (*)(uint64_t, uint64_t))v32)(v23, v25);
}

    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3) && (a2 < 0 || (a2 & 0x4000000000000000LL) != 0))
    {
      if (a2 < 0) {
        uint64_t v18 = (void *)a2;
      }
      else {
        uint64_t v18 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_unknownObjectRetain(v18, v12, v13, v14);
      if (v10) {
        goto LABEL_14;
      }
    }

    else
    {
      else {
        uint64_t v18 = (void *)a2;
      }
      swift_bridgeObjectRetain(a2, v15, v16, v17);
      if (v10) {
        goto LABEL_14;
      }
    }

    (*(void (**)(unint64_t, char *, uint64_t))(a5 + 56))( ~*(_BYTE *)(*(a3 - 1) + 80) | 0xFFFFFFFFFFFFFF00LL,  a4,  a5);
    return v18;
  }

  if (!Array._getCount()())
  {
    swift_bridgeObjectRelease(a2);
    unint64_t v10 = 0LL;
    goto LABEL_7;
  }

  uint64_t v22 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a3, v19, v20);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v22, v23);
  uint64_t v18 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v22, WitnessTable);
  uint64_t v25 = *(unsigned __int8 *)(*(a3 - 1) + 80);
  unint64_t v10 = (uint64_t)v18 + ((v25 + 32) & ~v25);
LABEL_14:
  (*(void (**)(uint64_t, char *, uint64_t))(a5 + 56))(v10, a4, a5);
  return v18;
}

            uint64_t v32 = 0LL;
            uint64_t v33 = 0;
            uint64_t v13 = 0LL;
            uint64_t v14 = 18;
            uint64_t v15 = 1;
            break;
          case 13:
            if (v23 > 0xF) {
              goto LABEL_258;
            }
            uint64_t v28 = 1 << v23;
            if ((v28 & 0x20A1) != 0)
            {
LABEL_248:
              uint64_t v14 = 18;
              goto LABEL_8;
            }

            if ((v28 & 0x8C00) == 0) {
              goto LABEL_258;
            }
            uint64_t v15 = 0;
            uint64_t v14 = 18;
            uint64_t v29 = 1LL;
            goto LABEL_255;
          case 14:
            if (((v25 | v31) & 1) != 0) {
              goto LABEL_258;
            }
            uint64_t v14 = 18;
            uint64_t v31 = 1;
            goto LABEL_8;
          default:
            goto LABEL_258;
        }

        goto LABEL_8;
      }

  uint64_t v40 = *(void (**)(uint64_t, uint64_t))(a3 + 120);
  v40(a2, a3);
  v39(v33, a2);
  unint64_t v41 = ((uint64_t (*)(uint64_t, uint64_t))v40)(a2, a3);
LABEL_18:
  v39(v34, a2);
  return v41;
}

  uint64_t v38 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
  unint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
  uint64_t v40 = 0;
LABEL_18:
  *uint64_t v31 = v38;
  v31[1] = v40;
  return result;
}

  uint64_t v38 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
  unint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
  uint64_t v40 = 0;
LABEL_18:
  *(_WORD *)uint64_t v31 = v38;
  *(_BYTE *)(v31 + 2) = v40;
  return result;
}

  uint64_t v38 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
  unint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
  uint64_t v40 = 0;
LABEL_18:
  *(_DWORD *)uint64_t v31 = v38;
  *(_BYTE *)(v31 + 4) = v40;
  return result;
}

  *a2 = v3;
  return result;
}

  v102 = -64LL;
  (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
  uint64_t v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
  unint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
  uint64_t v35 = a1;
  if ((v38 & 1) != 0) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v46 = v100(a3, a4);
  uint64_t v47 = v96;
  uint64_t v48 = v96(a3, a4);
  if ((v46 & 1) != 0)
  {
    if (v48 > 64) {
      goto LABEL_19;
    }
  }

  else if (v48 >= 64)
  {
LABEL_19:
    v102 = 64LL;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
    uint64_t v49 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
    unint64_t v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    unint64_t result = v50(v30, a3);
    if ((v49 & 1) == 0) {
      goto LABEL_20;
    }
LABEL_27:
    uint64_t v45 = 0LL;
    goto LABEL_60;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
  uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  unint64_t result = v50(v30, a3);
  if (v60 > 64) {
    goto LABEL_27;
  }
LABEL_20:
  v51 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v52 = v97;
  v51(v97, a2, a3);
  uint64_t v53 = v100(a3, a4);
  uint64_t v54 = v95;
  v87 = (void (*)(char *, char *, uint64_t))v51;
  v51(v95, (uint64_t)v52, a3);
  if ((v53 & 1) == 0)
  {
    v50(v54, a3);
    unint64_t v56 = v97;
    unint64_t v57 = v100;
    goto LABEL_44;
  }

  uint64_t v55 = v47(a3, a4);
  v50(v54, a3);
  unint64_t v56 = v97;
  unint64_t v57 = v100;
  if (v55 <= 64) {
    goto LABEL_44;
  }
  uint64_t v58 = v89;
  v87(v89, v97, a3);
  v102 = 0x8000000000000000LL;
  if ((v57(a3, a4) & 1) != 0)
  {
    if (v47(a3, a4) < 64)
    {
      int v59 = v30;
      goto LABEL_38;
    }

    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
    unint64_t v63 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v58,  v30,  a3);
    goto LABEL_33;
  }

  int v61 = v57(a3, a4);
  uint64_t v62 = v47(a3, a4);
  if ((v61 & 1) != 0)
  {
    if (v62 <= 64)
    {
      uint64_t v66 = v35;
      uint64_t v68 = AssociatedTypeWitness;
      unint64_t v67 = (void (**)(char *, uint64_t, const char *))v92;
      uint64_t v69 = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v70 = v90;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v69 + 8))( &qword_18180BE68,  256LL,  v68,  v69);
      v67[3](v70, a3, (const char *)v67);
      uint64_t v71 = v89;
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v89,  v30,  a3);
      v50(v30, a3);
      v72 = v88;
      v87(v88, v71, a3);
      if ((v67 & 1) != 0)
      {
        v50(v72, a3);
        goto LABEL_65;
      }

      v73 = v102;
      char v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v50(v72, a3);
      v75 = v74 < v73;
      uint64_t v35 = v66;
      uint64_t v47 = v96;
      unint64_t v56 = v97;
      uint64_t v58 = v89;
      if (v75) {
        goto LABEL_65;
      }
LABEL_42:
      v86 = v58;
      goto LABEL_43;
    }

    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
    uint64_t v58 = v89;
    unint64_t v63 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v89,  v30,  a3);
LABEL_33:
    uint64_t v64 = v63;
    v50(v30, a3);
    if ((v64 & 1) != 0) {
      goto LABEL_65;
    }
    goto LABEL_42;
  }

  if (v62 < 64)
  {
    int v59 = v30;
    uint64_t v58 = v89;
LABEL_38:
    v87(v59, v58, a3);
    uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v50(v30, a3);
    if (v65 < v102) {
LABEL_65:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
    goto LABEL_42;
  }

  v86 = v89;
LABEL_43:
  v50(v86, a3);
LABEL_44:
  v76 = v47(a3, a4);
  uint64_t v77 = v94;
  v87(v94, v56, a3);
  if (v76 >= 65)
  {
    v50(v77, a3);
    goto LABEL_46;
  }

  unint64_t v82 = v47(a3, a4);
  v50(v77, a3);
  if (v82 == 64 && (v57(a3, a4) & 1) == 0)
  {
LABEL_46:
    v78 = v93;
    v87(v93, v56, a3);
    v102 = 0x7FFFFFFFFFFFFFFFLL;
    v79 = v57(a3, a4);
    v80 = v78;
    LOBYTE(v78) = v79;
    v81 = v47(a3, a4);
    if ((v78 & 1) != 0)
    {
      if (v81 > 64)
      {
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))( &v102,  v98,  v99,  a3,  a4);
        goto LABEL_55;
      }
    }

    else if (v81 >= 64)
    {
      uint64_t v101 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v98, v99, a3, a4);
LABEL_55:
      v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v80,  a3);
      v50(v30, a3);
      if ((v83 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_56;
    }

    v87(v30, v80, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v50(v30, a3);
LABEL_56:
    v50(v80, a3);
  }

  v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t result = v50(v56, a3);
  v85 = *v35;
  if ((v84 & 0x8000000000000000LL) != 0)
  {
    if (v84 <= 0xFFFFFFFFFFFFFFC0LL) {
      uint64_t v45 = v85 >> 63;
    }
    else {
      uint64_t v45 = v85 >> -(char)v84;
    }
  }

  else
  {
    uint64_t v45 = v85 << v84;
    if (v84 >= 0x40) {
      uint64_t v45 = 0LL;
    }
  }

  uint64_t v12 = v9 == 1;
  *a1 = *(void *)a2;
  uint64_t v13 = ((unint64_t)a1 + v5 + 8) & v6;
  uint64_t v14 = (unint64_t)&a2[v5 + 8] & v6;
  (*(void (**)(uint64_t, uint64_t))(v4 + 16))(v13, v14);
  uint64_t v15 = (v7 + v14) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v16 = *(_BYTE *)(v15 + 8);
  uint64_t v17 = (v7 + v13) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)uint64_t v17 = *(void *)v15;
  *(_BYTE *)(v17 + 8) = v16;
  *((_BYTE *)a1 + v8) = v12;
  return a1;
}

  uint64_t v12 = v9 == 1;
  *a1 = *(void *)a2;
  uint64_t v13 = ((unint64_t)a1 + v5 + 8) & v6;
  uint64_t v14 = (unint64_t)&a2[v5 + 8] & v6;
  (*(void (**)(uint64_t, uint64_t))(v4 + 32))(v13, v14);
  uint64_t v15 = (v7 + v14) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v16 = *(_BYTE *)(v15 + 8);
  uint64_t v17 = (v7 + v13) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)uint64_t v17 = *(void *)v15;
  *(_BYTE *)(v17 + 8) = v16;
  *((_BYTE *)a1 + v8) = v12;
  return a1;
}

    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }

  if (v6 < 0xFFFFFFFF)
  {
    swift_release(a1[1]);
    goto LABEL_7;
  }

  uint64_t v7 = (unint64_t *)a2[1];
  unint64_t v8 = a1[1];
  *a1 = v6;
  a1[1] = (unint64_t)v7;
  swift_retain(v7, (uint64_t)a2, a3, a4);
  swift_release(v8);
  return a1;
}

    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }

  if (v4 < 0xFFFFFFFF)
  {
    swift_release(a1[1]);
    goto LABEL_7;
  }

  char v5 = a2[1];
  unint64_t v6 = a1[1];
  *a1 = v4;
  a1[1] = v5;
  swift_release(v6);
  return a1;
}

      if (v15 == a8)
      {
        v246 = v245;
        (*(void (**)(void *, void *))(*a8 + 24LL))(a8, v245);
      }

      else
      {
        v246 = (void *)(*(uint64_t (**)(void *))(*v15 + 16LL))(v15);
      }

      goto LABEL_21;
    }

    if (!v14)
    {
      v252 = 0LL;
      unint64_t v16 = (void *)a8[3];
      if (!v16) {
        goto LABEL_17;
      }
LABEL_12:
      if (v16 == a8)
      {
        v250 = v249;
        (*(void (**)(void *, void *))(*a8 + 24LL))(a8, v249);
      }

      else
      {
        v250 = (void *)(*(uint64_t (**)(void *))(*v16 + 16LL))(v16);
      }

      goto LABEL_36;
    }

    if (v14 == a6)
    {
      v252 = v251;
      (*(void (**)(void *, void *))(*a6 + 24LL))(a6, v251);
      unint64_t v16 = (void *)a8[3];
      if (!v16) {
        goto LABEL_17;
      }
      goto LABEL_12;
    }

    v252 = (void *)(*(uint64_t (**)(void *))(*v14 + 16LL))(v14);
    unint64_t v16 = (void *)a8[3];
    if (v16) {
      goto LABEL_12;
    }
LABEL_17:
    v250 = 0LL;
LABEL_36:
    if ((*(_DWORD *)v13 & 0x1Fu) >= 6 && (*(_DWORD *)v13 & 0x1F) != 31)
    {
      *(void *)a9 = "unknown kind";
      *(void *)(a9 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
      *(_BYTE *)(a9 + 16) = 1;
      goto LABEL_383;
    }

    uint64_t v25 = (int *)(v13 + 4);
    uint64_t v26 = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)(*(int *)(v13 + 4) + v13 + 4), a2);
    uint64_t v28 = v27;
    if (v252)
    {
      if (v252 != v251)
      {
        v274 = (void *)(*(uint64_t (**)(void))(*v252 + 16LL))();
        uint64_t v29 = v250;
        if (v250) {
          goto LABEL_44;
        }
LABEL_47:
        v272 = 0LL;
        goto LABEL_75;
      }

      v274 = v273;
      (*(void (**)(void *, void *))(v251[0] + 24LL))(v251, v273);
      uint64_t v29 = v250;
      if (!v250) {
        goto LABEL_47;
      }
    }

    else
    {
      v274 = 0LL;
      uint64_t v29 = v250;
      if (!v250) {
        goto LABEL_47;
      }
    }

    unint64_t v4 = (void *)getSuperclassForMaybeIncompleteMetadata((uint64_t)v4, v7, v6, v167);
    uint64_t v7 = v10;
    unint64_t v6 = 1LL;
    if (!v4)
    {
      uint64_t WitnessTable = 0LL;
      uint64_t v9 = 0LL;
      unint64_t v6 = 1LL;
      goto LABEL_75;
    }
  }

  if (qword_18C486EB0 <= v11 && unk_18C486EB8 > v11)
  {
    if (v13)
    {
      foreign_type_protocol_conformance = _dyld_find_foreign_type_protocol_conformance();
    }

    else
    {
      if ((qword_18C486EB0 > (unint64_t)ObjCClassFromMetadataConditional
         || unk_18C486EB8 <= (unint64_t)ObjCClassFromMetadataConditional)
        && (qword_18C486EB0 > (unint64_t)v12 || unk_18C486EB8 <= (unint64_t)v12))
      {
        if (MEMORY[0x1895F8BD0]) {
          uint64_t v26 = MEMORY[0x1895F8BB8] == 0LL;
        }
        else {
          uint64_t v26 = 1;
        }
        if (!v26) {
          goto LABEL_63;
        }
        goto LABEL_58;
      }

      foreign_type_protocol_conformance = _dyld_find_protocol_conformance();
    }

    uint64_t v9 = v20;
    if (foreign_type_protocol_conformance != 2) {
      goto LABEL_59;
    }
  }

  if (MEMORY[0x1895F8BD0]) {
    uint64_t v27 = MEMORY[0x1895F8BB8] == 0LL;
  }
  else {
    uint64_t v27 = 1;
  }
  if (v27)
  {
LABEL_58:
    uint64_t v9 = 0LL;
    foreign_type_protocol_conformance = 2LL;
    goto LABEL_59;
  }

  if (v13)
  {
    foreign_type_protocol_conformance = _dyld_find_foreign_type_protocol_conformance_on_disk();
    goto LABEL_64;
  }

  *(_DWORD *)a1 = (v8 & 0xFFFFFFFE | v11) + 2;
  if (*a2 != -4096LL) {
    --*(_DWORD *)(a1 + 4);
  }
  *a2 = *a3;
  a2[1] = *a4;
  return a2;
}

  swift::Demangle::__runtime::nodeToString(__p, v12, a4);
  uint64_t v15 = (void *)HIBYTE(v24);
  unint64_t v16 = HIBYTE(v24);
  if (v24 < 0) {
    uint64_t v15 = __p[1];
  }
  if (v15)
  {
    *(_OWORD *)a5 = *(_OWORD *)__p;
    a5[2] = v24;
    return;
  }

  if (a2)
  {
    if (a3 > 0x7FFFFFFFFFFFFFF7LL) {
      goto LABEL_38;
    }
    if (a3 >= 0x17)
    {
      uint64_t v20 = (a3 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((a3 | 7) != 0x17) {
        uint64_t v20 = a3 | 7;
      }
      uint64_t v21 = v20 + 1;
      uint64_t v22 = operator new(v20 + 1);
      a5[1] = a3;
      a5[2] = v21 | 0x8000000000000000LL;
      *a5 = v22;
      a5 = v22;
    }

    else
    {
      *((_BYTE *)a5 + 23) = a3;
      if (!a3)
      {
LABEL_35:
        *((_BYTE *)a5 + a3) = 0;
        if ((v24 & 0x8000000000000000LL) == 0) {
          return;
        }
        goto LABEL_36;
      }
    }

    memmove(a5, a2, a3);
    goto LABEL_35;
  }

  *a5 = 0LL;
  a5[1] = 0LL;
  a5[2] = 0LL;
  if ((v16 & 0x80) == 0) {
    return;
  }
LABEL_36:
  operator delete(__p[0]);
}

    v7[v6++] = v10;
  }

  while (v5 != v6);
  uint64_t v21 = v6;
LABEL_29:
  uint64_t v22 = *((void *)this + 9);
  if (v22 >= *((void *)this + 8)) {
    return 0LL;
  }
  *((void *)this + 9) = v22 + 1;
  uint64_t v23 = *(char *)(*((void *)this + 7) + v22);
  if (v23 == 80)
  {
    uint64_t v24 = (void *)((char *)this + 8);
    unint64_t result = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    if (result && result + 24 <= *((void *)this + 2))
    {
      uint64_t v32 = 173;
      goto LABEL_50;
    }

    uint64_t v33 = 2LL * *((void *)this + 4);
    if (v33 <= 0x20) {
      uint64_t v33 = 32LL;
    }
    *((void *)this + 4) = v33;
    uint64_t v34 = v33 + 8;
    uint64_t v35 = malloc(v33 + 8);
    uint64_t v36 = *((void *)this + 3);
    *((void *)this + 3) = v35;
    uint64_t v30 = (char *)v35 + v34;
    *uint64_t v35 = v36;
    uint64_t v31 = v35 + 1;
    uint64_t v32 = 173;
    goto LABEL_49;
  }

  if (v23 == 112)
  {
    uint64_t v24 = (void *)((char *)this + 8);
    unint64_t result = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    if (result && result + 24 <= *((void *)this + 2))
    {
      uint64_t v32 = 175;
      goto LABEL_50;
    }

    uint64_t v37 = 2LL * *((void *)this + 4);
    if (v37 <= 0x20) {
      uint64_t v37 = 32LL;
    }
    *((void *)this + 4) = v37;
    uint64_t v38 = v37 + 8;
    uint64_t v39 = malloc(v37 + 8);
    uint64_t v40 = *((void *)this + 3);
    *((void *)this + 3) = v39;
    uint64_t v30 = (char *)v39 + v38;
    void *v39 = v40;
    uint64_t v31 = v39 + 1;
    uint64_t v32 = 175;
LABEL_49:
    unint64_t result = ((unint64_t)v31 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = v30;
    goto LABEL_50;
  }

  if (v23 != 105) {
    return 0LL;
  }
  uint64_t v24 = (void *)((char *)this + 8);
  unint64_t result = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!result || result + 24 > *((void *)this + 2))
  {
    uint64_t v26 = 2LL * *((void *)this + 4);
    if (v26 <= 0x20) {
      uint64_t v26 = 32LL;
    }
    *((void *)this + 4) = v26;
    uint64_t v27 = v26 + 8;
    uint64_t v28 = malloc(v26 + 8);
    uint64_t v29 = *((void *)this + 3);
    *((void *)this + 3) = v28;
    uint64_t v30 = (char *)v28 + v27;
    *uint64_t v28 = v29;
    uint64_t v31 = v28 + 1;
    uint64_t v32 = 124;
    goto LABEL_49;
  }

  uint64_t v32 = 124;
LABEL_50:
  *uint64_t v24 = result + 24;
  *(_WORD *)(result + 16) = v32;
  *(_BYTE *)(result + 18) = 3;
  *(void *)unint64_t result = v7;
  *(void *)(result + 8) = v21;
  return result;
}

  unint64_t v10 = swift::Demangle::__runtime::Demangler::popProtocol(this, a2, a3, a4, a5);
  uint64_t v13 = 0LL;
  if (v8)
  {
    uint64_t v14 = (swift::Demangle::__runtime::Node *)v10;
    if (v10)
    {
      uint64_t v13 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v13 || v13 + 24 > *((void *)this + 2))
      {
        uint64_t v15 = 2LL * *((void *)this + 4);
        if (v15 <= 0x20) {
          uint64_t v15 = 32LL;
        }
        *((void *)this + 4) = v15;
        unint64_t v16 = v15 + 8;
        uint64_t v17 = malloc(v15 + 8);
        uint64_t v18 = (char *)v17 + v16;
        char *v17 = *((void *)this + 3);
        uint64_t v13 = ((unint64_t)v17 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)this + 2) = v18;
        *((void *)this + 3) = v17;
      }

      *((void *)this + 1) = v13 + 24;
      *(_WORD *)(v13 + 16) = 185;
      *(_BYTE *)(v13 + 18) = 0;
      swift::Demangle::__runtime::Node::addChild((unsigned int *)v13, v14, this, v11, v12);
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v13,  (swift::Demangle::__runtime::Node *)v8,  this,  v19,  v20);
    }
  }

  return v13;
}

  unint64_t v8 = *a2;
  uint64_t v9 = *((unsigned __int16 *)*a2 + 8);
  if (v9 != 65 && v9 != 245 && v9 != 82) {
  if (v9 == 65 || v9 == 82)
  }
    unint64_t v11 = 70;
  else {
    unint64_t v11 = 102;
  }
  uint64_t v12 = *(_DWORD *)(v6 + 12736);
  uint64_t v13 = *(unsigned int *)(v6 + 12740);
  uint64_t v14 = *(char **)(v6 + 12728);
  if (v12 >= v13)
  {
    uint64_t v15 = *(void **)(v6 + 12744);
    unint64_t v16 = (char *)v15[1];
    if (&v14[v13] == v16)
    {
      uint64_t v18 = (unint64_t)&v14[v13 + 1];
      uint64_t v17 = v15[2];
      if (v18 <= v17)
      {
        v15[1] = v18;
        LODWORD(v19) = 1;
LABEL_31:
        *(_DWORD *)(v6 + 12740) = v13 + v19;
        goto LABEL_32;
      }
    }

    else
    {
      uint64_t v17 = v15[2];
    }

    else {
      uint64_t v19 = (2 * v13);
    }
    uint64_t v20 = v19 + v13;
    if (!v16 || (unint64_t)&v16[v20] > v17)
    {
      uint64_t v21 = 2LL * v15[4];
      if (v21 <= v20 + 1) {
        uint64_t v21 = v20 + 1;
      }
      v15[4] = v21;
      uint64_t v22 = v21 + 8;
      uint64_t v33 = v19;
      uint64_t v23 = v11;
      this = malloc(v21 + 8);
      unint64_t v11 = v23;
      LODWORD(v19) = v33;
      uint64_t v24 = (char *)this + v22;
      *this = v15[3];
      unint64_t v16 = (char *)(this + 1);
      v15[2] = v24;
      v15[3] = this;
    }

    v15[1] = &v16[v20];
    if ((_DWORD)v13)
    {
      uint64_t v25 = v13;
      uint64_t v26 = v11;
      this = memcpy(v16, *(const void **)(v6 + 12728), v25);
      unint64_t v11 = v26;
      LODWORD(v13) = *(_DWORD *)(v6 + 12740);
      uint64_t v12 = *(_DWORD *)(v6 + 12736);
    }

    *(void *)(v6 + 12728) = v16;
    uint64_t v14 = v16;
    goto LABEL_31;
  }

  *(_DWORD *)a5 = 0;
  *(void *)(a5 + 8) = 0LL;
  *(_DWORD *)(a5 + 16) = 0;
  return result;
}

uint64_t specialized RandomAccessCollection<>.index(_:offsetBy:)(uint64_t a1, uint64_t a2, id a3)
{
  uint64_t v3 = a1 + a2;
  if (__OFADD__(a1, a2))
  {
    __break(1u);
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ClosedRange requires lowerBound <= upperBound",  45LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x59uLL,  0);
  }

  uint64_t v4 = (uint64_t)objc_msgSend(a3, sel_count);
  if (v4 < 0) {
    goto LABEL_8;
  }
  if (v3 < 0 || v4 < v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }
  return v3;
}

unint64_t specialized RandomAccessCollection<>.index(_:offsetBy:)( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v4)
  {
    __break(1u);
  }

  else if (result > (HIBYTE(a4) & 0xF))
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  return result;
}

uint64_t specialized RandomAccessCollection<>.index(_:offsetBy:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v4)
  {
    __break(1u);
    return result;
  }

  if (!a3)
  {
    if (!result) {
      return result;
    }
LABEL_7:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  if (result < 0 || a4 - a3 < result) {
    goto LABEL_7;
  }
  return result;
}

uint64_t RandomAccessCollection<>.index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v26 = a1;
  uint64_t v10 = *(void *)(*(void *)(a4 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v23 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  unint64_t v16 = (char *)&v23 - v15;
  uint64_t v17 = *(void *)(a5 + 8);
  uint64_t v19 = type metadata accessor for ClosedRange(0LL, AssociatedTypeWitness, v17, v18);
  uint64_t v24 = *(void *)(v19 - 8);
  uint64_t v25 = v19;
  MEMORY[0x1895F8858](v19);
  uint64_t v21 = (char *)&v23 - v20;
  uint64_t v27 = a2;
  (*(void (**)(uint64_t *, unint64_t, uint64_t))(a5 + 48))(&v27, AssociatedTypeWitness, a5);
  (*(void (**)(uint64_t, uint64_t))(v10 + 64))(a3, v10);
  (*(void (**)(uint64_t, uint64_t))(v10 + 72))(a3, v10);
  ClosedRange.init(uncheckedBounds:)((uint64_t)v16, (uint64_t)v14, AssociatedTypeWitness, v17, (uint64_t)v21);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v10 + 168))(a6, v21, a3, v10);
  return (*(uint64_t (**)(char *, uint64_t))(v24 + 8))(v21, v25);
}

unint64_t specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)( unsigned int a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a1)
  {
    if (!a4) {
LABEL_6:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x82uLL,  0);
    unsigned int v4 = a4;
    while (v4 != a1)
    {
      BOOL v5 = v4 >= 0x100;
      v4 >>= 8;
      if (!v5) {
        goto LABEL_6;
      }
    }
  }

  if (a3)
  {
    if (!a4) {
      goto LABEL_25;
    }
    unsigned int v6 = a4;
    while (v6 != a3)
    {
      BOOL v5 = v6 >= 0x100;
      v6 >>= 8;
      if (!v5) {
        goto LABEL_25;
      }
    }
  }

  uint64_t v7 = __clz(a1);
  uint64_t v8 = v7 - __clz(a3);
  uint64_t v9 = v8 >> 3;
  if (a2 >= 1)
  {
    if (v8 < 0 || v9 >= a2) {
      goto LABEL_20;
    }
LABEL_19:
    uint64_t v10 = 0LL;
    unsigned __int8 v11 = 1;
    return v10 | ((unint64_t)v11 << 32);
  }

  if (v8 <= 7 && v9 > a2) {
    goto LABEL_19;
  }
LABEL_20:
  if (!a4)
  {
    if (!a1) {
      goto LABEL_28;
    }
LABEL_25:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x83uLL,  0);
  }

  if (a1)
  {
    unsigned int v12 = a4;
    while (v12 != a1)
    {
      BOOL v5 = v12 >= 0x100;
      v12 >>= 8;
      if (!v5) {
        goto LABEL_25;
      }
    }
  }

LABEL_28:
  unint64_t v13 = __clz(a4);
  BOOL v14 = __OFADD__(a2, (uint64_t)(v13 - v7) >> 3);
  unint64_t v15 = a2 + ((uint64_t)(v13 - v7) >> 3);
  if (v14)
  {
    __break(1u);
LABEL_34:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x8EuLL,  0);
  }

  if ((v15 & 0x8000000000000000LL) != 0) {
    goto LABEL_34;
  }
  if (4 - (v13 >> 3) < v15) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0x8FuLL,  0);
  }
  unsigned __int8 v11 = 0;
  uint64_t v10 = a4 >> (4 * (v15 & 7)) >> (4 * (v15 & 7));
  return v10 | ((unint64_t)v11 << 32);
}

  __break(1u);
  return result;
}

    v164 = v174;
    uint64_t v165 = v101;
    v166 = v199;
    ((void (*)(char *, char *, unint64_t))v96)(v174, v165, v199);
    v167 = (void (*)(char *, void))(*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 80))( v214,  v70,  v213,  v7);
    v168 = v76;
    v169 = v206;
    v170 = v207;
    v171 = v205;
    (*(void (**)(char *))(v207 + 16))(v205);
    v167(v214, 0LL);
    v102 = (*((uint64_t (**)(char *, char *, char *))v209 + 19))(v97, v164, v169);
    (*(void (**)(char *, char *))(v170 + 8))(v171, v169);
    v172 = *(void (**)(char *, unint64_t))(v168 + 8);
    v172(v164, v166);
    v172(v97, v166);
    return v102;
  }

  v183 = (char *)v51;
  v78 = static FlattenSequence<>.Index.< infix(_:_:)(v50, v70, v213, v7, v6);
  v79 = *(void (**)(char *, uint64_t, uint64_t))(v210 + 16);
  v211 = (char *)v7;
  v80 = v195;
  if ((v78 & 1) != 0)
  {
    v81 = (uint64_t)v178;
    v79(v178, v50, v195);
    unint64_t v82 = (uint64_t)v179;
    v79(v179, v70, v80);
    if ((static FlattenSequence<>.Index.< infix(_:_:)(v82, v81, v213, v7, v6) & 1) != 0) {
      goto LABEL_31;
    }
    v83 = v210;
    v84 = *(void (**)(uint64_t, uint64_t))(v210 + 8);
    v84(v82, v80);
    v84(v81, v80);
    v85 = TupleTypeMetadata2;
    v86 = v185;
    v87 = &v185[*((int *)TupleTypeMetadata2 + 12)];
    v79(v185, v194, v80);
    v79(v87, v70, v80);
    uint64_t v88 = v83;
    v89 = v202;
    v90 = &v202[*((int *)v85 + 12)];
    v79(v202, (uint64_t)v86, v80);
    v79(v90, (uint64_t)v87, v80);
    v91 = *(void (**)(char *, char *, uint64_t))(v88 + 32);
    uint64_t v70 = (uint64_t)v186;
    v91(v186, v89, v80);
    v210 = (uint64_t)v84;
    v84((uint64_t)v90, v80);
    uint64_t v92 = &v89[*((int *)v85 + 12)];
    char v93 = v89;
    v94 = v86;
  }

  else
  {
    v103 = (uint64_t)v177;
    v79(v177, v70, v195);
    v104 = (uint64_t)v201;
    v79(v201, v50, v80);
    if ((static FlattenSequence<>.Index.< infix(_:_:)(v104, v103, v213, v7, v6) & 1) != 0) {
      goto LABEL_31;
    }
    v105 = *(void (**)(char *, uint64_t))(v210 + 8);
    v105(v201, v80);
    v105((char *)v103, v80);
    v106 = TupleTypeMetadata2;
    v107 = v185;
    v87 = &v185[*((int *)TupleTypeMetadata2 + 12)];
    v79(v185, v70, v80);
    v79(v87, v50, v80);
    v108 = v202;
    v109 = &v202[*((int *)v106 + 12)];
    v79(v202, (uint64_t)v107, v80);
    v79(v109, (uint64_t)v87, v80);
    v91 = *(void (**)(char *, char *, uint64_t))(v210 + 32);
    uint64_t v70 = (uint64_t)v186;
    v91(v186, v108, v80);
    v210 = (uint64_t)v105;
    v105(v109, v80);
    uint64_t v92 = &v108[*((int *)v106 + 12)];
    char v93 = v108;
    v94 = v107;
  }

  v91(v93, v94, v80);
  v91(v92, v87, v80);
  uint64_t v110 = v189;
  v91((char *)(v70 + *(int *)(v189 + 36)), v92, v80);
  ((void (*)(char *, uint64_t))v210)(v202, v80);
  v111 = v192;
  (*(void (**)(char *, uint64_t, uint64_t))(v188 + 32))(v192, v70, v110);
  uint64_t v101 = *(char **)(v198 + 16);
  ((void (*)(char *, char *, char *))v101)(v54, v111, v183);
  uint64_t v112 = &v111[*(int *)(v80 + 44)];
  uint64_t v113 = v191;
  uint64_t v114 = v184;
  v115 = v197;
  uint64_t v186 = *(char **)(v191 + 16);
  ((void (*)(char *, char *, uint64_t))v186)(v184, v112, v197);
  v116 = v193;
  TupleTypeMetadata2 = *(unint64_t **)(v193 + 48);
  v117 = ((uint64_t (*)(char *, uint64_t, unint64_t))TupleTypeMetadata2)(v114, 1LL, v199);
  v202 = v101;
  if (v117 == 1)
  {
    (*(void (**)(char *, uint64_t))(v113 + 8))(v114, v115);
    v210 = 0LL;
    uint64_t v118 = v190;
    unint64_t v97 = v203;
  }

  else
  {
    v119 = v175;
    (*(void (**)(char *, char *, unint64_t))(v116 + 32))(v175, v114, v199);
    int v120 = v208;
    v201 = *(char **)(v208 + 16);
    uint64_t v121 = v203;
    ((void (*)(char *, uint64_t, uint64_t))v201)(v203, v212, v213);
    char v122 = v211;
    uint64_t v123 = (void (*)(char *, void))(*((uint64_t (**)(char *, char *, uint64_t, char *))v211 + 10))( v214,  v54,  v213,  v211);
    uint64_t v124 = v206;
    uint64_t v70 = v207;
    v125 = *(void (**)(char *))(v207 + 16);
    v200 = v54;
    v126 = v205;
    v125(v205);
    v123(v214, 0LL);
    uint64_t v185 = *(char **)(v120 + 8);
    ((void (*)(char *, uint64_t))v185)(v121, v213);
    v127 = v209;
    v128 = v182;
    (*((void (**)(char *, const char *))v209 + 9))(v124, v209);
    v210 = (*((uint64_t (**)(char *, char *, char *, const char *))v127 + 19))(v119, v128, v124, v127);
    char v129 = *(void (**)(char *, unint64_t))(v116 + 8);
    v129(v128, v199);
    v130 = v126;
    uint64_t v54 = v200;
    v131 = v124;
    unint64_t v97 = v121;
    (*(void (**)(char *, char *))(v70 + 8))(v130, v131);
    uint64_t v132 = v119;
    uint64_t v101 = v202;
    v129(v132, v199);
    BOOL v133 = v121;
    uint64_t v110 = v189;
    ((void (*)(char *, uint64_t, uint64_t))v201)(v133, v212, v213);
    (*((void (**)(char *, uint64_t, char *))v122 + 24))(v54, v213, v122);
    ((void (*)(char *, uint64_t))v185)(v97, v213);
    uint64_t v118 = v190;
  }

  uint64_t v134 = &v192[*(int *)(v110 + 36)];
  v135 = AssociatedConformanceWitness;
  char v136 = *(char **)(AssociatedConformanceWitness + 16);
  v137 = v183;
  ((void (*)(char *, char *, char *))v101)(v118, v54, v183);
  v203 = v134;
  v201 = v136;
  LOBYTE(v134) = ((uint64_t (*)(char *, char *, char *, unint64_t))v136)(v118, v134, v137, v135);
  v138 = *(void (**)(char *, char *))(v198 + 8);
  v138(v118, v137);
  if ((v134 & 1) != 0)
  {
    v139 = *(char **)(v208 + 16);
    v200 = v139;
    while (1)
    {
      v140 = v213;
      ((void (*)(char *, uint64_t, uint64_t))v139)(v97, v212, v213);
      ((void (*)(char *, char *, char *))v101)(v118, v54, v137);
      v141 = (void (*)(char *, void))(*((uint64_t (**)(char *, char *, uint64_t))v211 + 10))( v214,  v118,  v140);
      v143 = v206;
      unint64_t v142 = v207;
      unint64_t v144 = v205;
      (*(void (**)(char *))(v207 + 16))(v205);
      v141(v214, 0LL);
      v138(v118, v137);
      uint64_t v70 = *(void *)(v208 + 8);
      ((void (*)(char *, uint64_t))v70)(v97, v140);
      v145 = v138;
      v146 = (*((uint64_t (**)(char *))v209 + 14))(v143);
      (*(void (**)(char *, char *))(v142 + 8))(v144, v143);
      if (__OFADD__(v210, v146)) {
        break;
      }
      v210 += v146;
      v147 = v213;
      v139 = v200;
      ((void (*)(char *, uint64_t, uint64_t))v200)(v97, v212, v213);
      (*((void (**)(char *, uint64_t))v211 + 24))(v54, v147);
      ((void (*)(char *, uint64_t))v70)(v97, v147);
      uint64_t v148 = v202;
      ((void (*)(char *, char *, char *))v202)(v118, v54, v137);
      v149 = ((uint64_t (*)(char *, char *, char *, unint64_t))v201)( v118,  v203,  v137,  AssociatedConformanceWitness);
      v145(v118, v137);
      uint64_t v101 = v148;
      v138 = v145;
      if ((v149 & 1) == 0) {
        goto LABEL_21;
      }
    }

    __break(1u);
LABEL_31:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

      uint64_t v68 = *(void (**)(uint64_t, uint64_t))(v6 + 56);
      uint64_t v69 = v108;
      v68(a2, v6);
      uint64_t v70 = v107;
      v68(a2, v6);
      uint64_t v71 = swift_getAssociatedConformanceWitness( a3,  a2,  (uint64_t)v10,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
      v72 = v109;
      (*(void (**)(_BYTE *, _BYTE *, unint64_t *, unint64_t))(v71 + 168))(v69, v70, v10, v71);
      v73 = *(void (**)(_BYTE *, unint64_t *))(v110 + 8);
      v73(v70, v10);
      v73(v69, v10);
      char v74 = *(uint64_t (**)(unint64_t *, unint64_t))(v71 + 64);
      if ((v74(v10, v71) & 1) != 0)
      {
        v75 = (*(uint64_t (**)(unint64_t *, unint64_t))(v71 + 128))(v10, v71);
        if (v75 < 64) {
          goto LABEL_36;
        }
      }

      else
      {
        v78 = v74(v10, v71);
        v75 = (*(uint64_t (**)(unint64_t *, unint64_t))(v71 + 128))(v10, v71);
        if ((v78 & 1) == 0)
        {
          if (v75 < 64)
          {
LABEL_36:
            v83 = (*(uint64_t (**)(unint64_t *, unint64_t))(v71 + 120))(v10, v71);
            v73(v72, v10);
            unint64_t v63 = v83 == 0;
            return v63 & 1;
          }

          uint64_t v113 = 0LL;
          v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v71 + 96);
          uint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
          v91(&v113, &type metadata for Int, v92, v10, v71);
          char v93 = swift_getAssociatedConformanceWitness( v6,  a2,  (uint64_t)v10,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
          unint64_t v63 = (*(uint64_t (**)(_BYTE *, _BYTE *, unint64_t *))(*(void *)(v93 + 8) + 8LL))( v72,  v69,  v10);
          v73(v72, v10);
          unint64_t v82 = v69;
LABEL_41:
          v73(v82, v10);
          return v63 & 1;
        }

        if (v75 <= 64)
        {
          v84 = v99;
          v85 = (uint64_t)v100;
          v86 = swift_getAssociatedConformanceWitness( (uint64_t)v100,  (uint64_t)v10,  v99,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v87 = v98;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v86 + 8))( &unk_18180BE68,  256LL,  v84,  v86);
          (*(void (**)(_BYTE *, unint64_t *, uint64_t))(v85 + 24))(v87, v10, v85);
          uint64_t v88 = swift_getAssociatedConformanceWitness( v6,  a2,  (uint64_t)v10,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
          v89 = (*(uint64_t (**)(_BYTE *, _BYTE *, unint64_t *, unint64_t))(v88 + 32))( v72,  v69,  v10,  v88);
          v73(v69, v10);
          v90 = v101;
          (*(void (**)(_BYTE *, _BYTE *, unint64_t *))(v110 + 32))(v101, v72, v10);
          unint64_t v63 = (v89 & 1) != 0
             && (*(uint64_t (**)(unint64_t *, unint64_t))(v71 + 120))(v10, v71) == 0;
          unint64_t v82 = v90;
          goto LABEL_41;
        }
      }

      uint64_t v113 = 0LL;
      v79 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v71 + 96);
      v80 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
      v79(&v113, &type metadata for Int, v80, v10, v71);
      v81 = swift_getAssociatedConformanceWitness( v6,  a2,  (uint64_t)v10,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      unint64_t v63 = (*(uint64_t (**)(_BYTE *, _BYTE *, unint64_t *))(*(void *)(v81 + 8) + 8LL))( v72,  v69,  v10);
      v73(v69, v10);
      unint64_t v82 = v72;
      goto LABEL_41;
    }

    goto LABEL_14;
  }

  if (v35 >= 64)
  {
LABEL_14:
    uint64_t v113 = 0LL;
    unint64_t v50 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v51 = lazy protocol witness table accessor for type Int and conformance Int(v35, v36, v37);
    v50(&v113, &type metadata for Int, v51, a2, a3);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(*(void *)(*(void *)(a3 + 16) + 8LL) + 8LL))( v102,  v26,  a2);
LABEL_15:
    uint64_t v52 = v48;
    uint64_t v44 = *(void (**)(_BYTE *, uint64_t))(v112 + 8);
    v44(v26, a2);
    if ((v52 & 1) != 0) {
      goto LABEL_16;
    }
    goto LABEL_28;
  }

  uint64_t v32 = v112;
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v112 + 16))(v26, v102, a2);
LABEL_12:
  uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v44 = *(void (**)(_BYTE *, uint64_t))(v32 + 8);
  v44(v26, a2);
  if (v49) {
    goto LABEL_28;
  }
LABEL_16:
  if ((v27(a2, a3) & 1) == 0)
  {
    unint64_t v57 = v27(a2, a3);
    uint64_t v53 = v111;
    uint64_t v54 = v106(a2, a3);
    if ((v57 & 1) != 0)
    {
      if (v54 <= 64)
      {
        uint64_t v58 = v104;
        int v59 = v105;
        uint64_t v60 = swift_getAssociatedConformanceWitness( (uint64_t)v105,  a2,  v104,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        int v61 = v103;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v60 + 8))( &unk_18180BE68,  256LL,  v58,  v60);
        (*((void (**)(_BYTE *, uint64_t, const char *))v59 + 3))(v61, a2, v59);
        LOBYTE(v58) = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL)
                                                                           + 32LL))( v53,  v26,  a2);
        v44(v26, a2);
        uint64_t v62 = v97;
        (*(void (**)(_BYTE *, uint64_t, uint64_t))(v112 + 16))(v97, v53, a2);
        unint64_t v63 = (v58 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3) == 0;
        unint64_t v67 = v62;
        goto LABEL_26;
      }
    }

    else if (v54 < 64)
    {
      goto LABEL_24;
    }

  uint64_t result = swift_release((uint64_t)v4);
  *uint64_t v2 = v8;
  return result;
}

  uint64_t result = swift_release((uint64_t)v4);
  *uint64_t v2 = v8;
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  after._rawBits += v10 << 16;
  BOOL v14 = 5;
  return (Swift::String::Index)(after._rawBits & 0xFFFFFFFFFFFF0000LL | v14);
}

  __break(1u);
  return offsetBy;
}

  after._rawBits += v10 << 16;
  BOOL v14 = 5;
  return (Swift::String::Index)(after._rawBits & 0xFFFFFFFFFFFF0000LL | v14);
}

    v127 = *(uint64_t (**)(uint64_t, uint64_t))(v16 + 120);
    v128 = v127(v85, v16);
    char v129 = (void (*)(char *, uint64_t))v277;
    v277(v45, v85);
    *(_DWORD *)v90 &= ~(v128 << *(_BYTE *)(v90 + 4));
    v130 = *(void (**)(char *, char *, uint64_t))(v98 + 16);
    v131 = v270;
    v130(v270, v278, v85);
    if ((((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16) & 1) != 0)
    {
      uint64_t v132 = v250;
      v130(v250, v131, v85);
      BOOL v133 = v263;
      uint64_t v134 = v262;
      v135 = swift_getAssociatedConformanceWitness( (uint64_t)v263,  v85,  v262,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v136 = v261;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v135 + 8))( &unk_18180BE68,  256LL,  v134,  v135);
      v137 = (void (*)(char *, uint64_t, const char *))*((void *)v133 + 3);
      v138 = v136;
      v86 = v274;
      v139 = v133;
      v140 = v132;
      char v129 = (void (*)(char *, uint64_t))v277;
      v137(v138, v85, v139);
      LOBYTE(v134) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v16 + 32) + 8LL) + 32LL))( v140,  v86,  v85);
      v129(v86, v85);
      if ((v134 & 1) == 0) {
LABEL_57:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
      v129(v140, v85);
      v131 = v270;
    }

    if (v107(v85, v16) >= 32)
    {
      v141 = v249;
      v130(v249, v131, v85);
      v279 = -1;
      unint64_t v142 = ((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16);
      v143 = v107(v85, v16);
      if ((v142 & 1) != 0)
      {
        if (v143 <= 32)
        {
          v146 = v263;
          v147 = v262;
          uint64_t v148 = swift_getAssociatedConformanceWitness( (uint64_t)v263,  v85,  v262,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v149 = v261;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v148 + 8))( &unk_18180BE68,  256LL,  v147,  v148);
          (*((void (**)(char *, uint64_t, const char *))v146 + 3))(v149, v85, v146);
          LOBYTE(v147) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v16 + 32) + 8LL)
                                                                            + 40LL))( v141,  v86,  v85);
          v150 = v86;
          v151 = (void (*)(char *, uint64_t))v277;
          v277(v150, v85);
          unint64_t v152 = v279;
          v153 = v243;
          v130(v243, v141, v85);
          if ((v147 & 1) != 0)
          {
            unint64_t v154 = v127(v85, v16);
            v151(v153, v85);
            v155 = v152 >= v154;
LABEL_40:
            v131 = v270;
            if (!v155) {
LABEL_58:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
          }

          else
          {
            v151(v153, v85);
            v131 = v270;
          }

      __break(1u);
LABEL_29:
      __break(1u);
      return result;
    }

        v83[0] = v34;
        uint64_t v60 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
        int v61 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v38, v39, v40);
        uint64_t v52 = &type metadata for UInt64;
        uint64_t v62 = v80;
        v60(v83, &type metadata for UInt64, v61, &type metadata for UInt64, v5);
        uint64_t v54 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( v24,  v62,  &type metadata for UInt64);
        uint64_t v55 = (void (*)(char *, ValueMetadata *))v35[1];
        v55(v62, &type metadata for UInt64);
        unint64_t v56 = v24;
        goto LABEL_33;
      }

      if (v38 >= 64) {
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v38 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for UInt64, v5);
      if (v38 >= 64) {
        goto LABEL_28;
      }
    }

    uint64_t v47 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for UInt64, v5);
    ((void (*)(char *, ValueMetadata *))v35[1])(v24, &type metadata for UInt64);
    goto LABEL_19;
  }

  if (v4 != &type metadata for Int64) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "self isn't canonical",  20LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3CF6uLL,  0);
  }
  outlined init with copy of MirrorPath(a1, (uint64_t)v83);
  uint64_t v25 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  uint64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  uint64_t v27 = v82;
  Description[2](v17, v2, &type metadata for Int64);
  uint64_t v28 = *(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 64);
  if ((v28(&type metadata for Int64, v5) & 1) != 0)
  {
    uint64_t v29 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for Int64, v5);
    if (v29 < 64) {
      goto LABEL_22;
    }
    goto LABEL_16;
  }

  uint64_t v49 = v28(&type metadata for Int64, v5);
  uint64_t v29 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for Int64, v5);
  if ((v49 & 1) == 0)
  {
    if (v29 < 64)
    {
LABEL_22:
      uint64_t v58 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for Int64, v5);
      ((void (*)(char *, ValueMetadata *))Description[1])(v17, &type metadata for Int64);
      unint64_t v57 = v58 == v27;
      goto LABEL_23;
    }

    uint64_t v71 = Description;
    v72 = ((uint64_t (*)(char *, char *, ValueMetadata *))Description[4])(v11, v17, &type metadata for Int64);
    if ((v27 & 0x8000000000000000LL) == 0)
    {
      v83[0] = v27;
      v75 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
      v76 = lazy protocol witness table accessor for type Int64 and conformance Int64(v72, v73, v74);
      uint64_t v52 = &type metadata for Int64;
      uint64_t v77 = v80;
      v75(v83, &type metadata for Int64, v76, &type metadata for Int64, v5);
      uint64_t v54 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( v11,  v77,  &type metadata for Int64);
      uint64_t v55 = (void (*)(char *, ValueMetadata *))v71[1];
      v55(v77, &type metadata for Int64);
      unint64_t v56 = v11;
      goto LABEL_33;
    }

    ((void (*)(char *, ValueMetadata *))v71[1])(v11, &type metadata for Int64);
    return 0LL;
  }

  if (v29 > 64)
  {
LABEL_16:
    v83[0] = v27;
    unint64_t v50 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
    v51 = lazy protocol witness table accessor for type Int64 and conformance Int64(v29, v30, v31);
    uint64_t v52 = &type metadata for Int64;
    uint64_t v53 = v80;
    v50(v83, &type metadata for Int64, v51, &type metadata for Int64, v5);
    uint64_t v54 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( v17,  v53,  &type metadata for Int64);
    uint64_t v55 = (void (*)(char *, ValueMetadata *))Description[1];
    v55(v53, &type metadata for Int64);
    unint64_t v56 = v17;
LABEL_33:
    v55(v56, v52);
    return v54 & 1;
  }

  unint64_t v63 = v79;
  uint64_t v64 = swift_getAssociatedConformanceWitness( (uint64_t)v79,  (uint64_t)&type metadata for Int64,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v65 = v78;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v64 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v64);
  uint64_t v66 = v80;
  (*((void (**)(char *, ValueMetadata *, const char *))v63 + 3))(v65, &type metadata for Int64, v63);
  unint64_t v67 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 32) + 8LL) + 32LL))( v17,  v66,  &type metadata for Int64);
  uint64_t v68 = Description;
  uint64_t v69 = (void (*)(char *, ValueMetadata *))Description[1];
  v69(v66, &type metadata for Int64);
  ((void (**)(char *, char *, ValueMetadata *))v68)[4](v14, v17, &type metadata for Int64);
  uint64_t v70 = (v67 & 1) != 0
     && (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for Int64, v5) == v27;
  v69(v14, &type metadata for Int64);
  return v70;
}

  if (v25 < v13 || v21 < v13)
  {
    uint64_t v31 = (unint64_t *)((char *)v17 + v15);
    if (v25 < v13)
    {
      if (v21 >= v13)
      {
        uint64_t v42 = v10;
        if (v15 >= 1)
        {
          do
          {
            uint64_t v37 = *v17++;
            uint64_t v36 = v37;
            unint64_t v41 = v17;
            v42 += v37 & 0xFFFFFFFFFFFFFFLL;
            if (HIBYTE(v37))
            {
              (*(void (**)(void *, unint64_t **, size_t *, uint64_t))((char *)destroyTable
                                                                                     + ((v36 >> 53) & 0x7F8)))( v9,  &v41,  &v42,  a4);
              uint64_t v17 = v41;
            }
          }

          while (v17 < v31);
        }

        uint64_t v31 = v17;
      }

      uint64_t result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v16);
      v10 += v16;
      uint64_t v17 = v31;
    }

    else if (v15 >= 1)
    {
      do
      {
        uint64_t v33 = *v17++;
        uint64_t v32 = v33;
        unint64_t v41 = v17;
        uint64_t v34 = v40;
        uint64_t v35 = v33 & 0xFFFFFFFFFFFFFFLL;
        if ((v33 & 0xFFFFFFFFFFFFFFLL) != 0)
        {
          uint64_t v38 = v40;
          uint64_t v39 = v17;
          uint64_t result = memcpy((void *)(a4 + v40), (const void *)(a5 + v40), v35);
          uint64_t v34 = v38;
          uint64_t v17 = v39;
        }

        uint64_t v40 = v34 + v35;
        if (HIBYTE(v32))
        {
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v32 >> 53) & 0x7F8)))( v9,  &v41,  &v40,  a4,  a5);
          uint64_t v17 = v41;
        }
      }

      while (v17 < v31);
      uint64_t v10 = v40;
    }
  }

  *a2 = v17;
  *a3 = v10;
  return result;
}

  operator delete(v41.__r_.__value_.__l.__data_);
LABEL_18:
LABEL_30:
  operator delete(v42.__r_.__value_.__l.__data_);
LABEL_19:
  uint64_t v34 = (char)v39.__r_.__value_.__s.__size_;
  uint64_t v35 = (void *)v39.__r_.__value_.__r.__words[0];
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v36 = &v39;
  }
  else {
    uint64_t v36 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  uint64_t v37 = strdup((const char *)v36);
  if (v34 < 0) {
    operator delete(v35);
  }
  return v37;
}

  operator delete(v41.__r_.__value_.__l.__data_);
LABEL_18:
LABEL_30:
  operator delete(v42.__r_.__value_.__l.__data_);
LABEL_19:
  uint64_t v34 = (char)v39.__r_.__value_.__s.__size_;
  uint64_t v35 = (void *)v39.__r_.__value_.__r.__words[0];
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v36 = &v39;
  }
  else {
    uint64_t v36 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  uint64_t v37 = strdup((const char *)v36);
  if (v34 < 0) {
    operator delete(v35);
  }
  return v37;
}

  operator delete(v41.__r_.__value_.__l.__data_);
LABEL_18:
LABEL_30:
  operator delete(v42.__r_.__value_.__l.__data_);
LABEL_19:
  uint64_t v34 = (char)v39.__r_.__value_.__s.__size_;
  uint64_t v35 = (void *)v39.__r_.__value_.__r.__words[0];
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v36 = &v39;
  }
  else {
    uint64_t v36 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  uint64_t v37 = strdup((const char *)v36);
  if (v34 < 0) {
    operator delete(v35);
  }
  return v37;
}

    abort();
  }

  unsigned int v6 = *v2;
  uint64_t v7 = (char *)v2 + v6;
  if ((_DWORD)v6) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t result = (uint64_t (***)())objc_lookUpClass(v8);
  if (result) {
    return (uint64_t (***)())swift_getObjCClassMetadata((unint64_t)result);
  }
  return result;
}

    unint64_t v13 = (uint64_t *)(a2 + 8);
LABEL_29:
    unsigned int v12 = *v13;
    goto LABEL_30;
  }

  if ((_DWORD)v7 == 515 || (_DWORD)v7 == 516) {
    goto LABEL_28;
  }
LABEL_30:
  uint64_t v33 = v12;
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a2, a2, a3, a4);
  uint64_t v35 = v37;
  uint64_t v36 = 0x800000000LL;
  v37[32] = 0LL;
  BOOL v14 = *(unsigned int *)(a1 + 12);
  v28[0] = off_189B8E1C8;
  v28[1] = &v32;
  uint64_t v29 = v28;
  v26[0] = off_189B8E210;
  v26[1] = &v32;
  uint64_t v27 = v26;
  v24[0] = off_189B8E258;
  v24[1] = &v32;
  uint64_t v25 = v24;
  swift::_checkGenericRequirements(v30, v6, v8, a1 + 4 * ((v14 >> 6) & 1) + 16, BYTE1(v14), v38, v28, v26, v24);
  unint64_t v15 = v25;
  if (v25 == v24)
  {
    unint64_t v16 = 4LL;
    unint64_t v15 = v24;
  }

  else
  {
    if (!v25) {
      goto LABEL_35;
    }
    unint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_35:
  uint64_t v17 = v27;
  if (v27 == v26)
  {
    uint64_t v18 = 4LL;
    uint64_t v17 = v26;
  }

  else
  {
    if (!v27) {
      goto LABEL_40;
    }
    uint64_t v18 = 5LL;
  }

  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_40:
  uint64_t v19 = v29;
  if (v29 == v28)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = v28;
    goto LABEL_44;
  }

  if (v29)
  {
    uint64_t v20 = 5LL;
LABEL_44:
    (*(void (**)(void))(*v19 + 8 * v20))();
  }

  uint64_t v21 = v31;
  if (v31) {
    ((void (*)(void, uint64_t, void))v30[1])(v30[0], 3LL, 0LL);
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v21)
  {
    uint64_t WitnessTable = 0LL;
    goto LABEL_53;
  }

  a3 = (const char *)v38[0];
LABEL_52:
  uint64_t WitnessTable = swift::_getWitnessTable((int *)a1, (uint64_t *)a2, (uint64_t)a3, a4);
LABEL_53:
  if (v38[0] != v39) {
    free(v38[0]);
  }
  return WitnessTable;
}

  unint64_t v16 = 0LL;
LABEL_29:
  if (*((_WORD *)v15 + 8) != 153 || v15[1] != 5) {
  uint64_t v17 = (int *)*v15;
  }
  uint64_t v18 = *v17;
  uint64_t v19 = *((unsigned __int8 *)v17 + 4);
  uint64_t v20 = v18 == 1718187859 && v19 == 116;
  if (!v20 || *(_WORD *)(v16 + 16) != 101 || *(void *)(v16 + 8) != 8LL || **(void **)v16 != 0x6C616E6F6974704FLL) {
  v23[0] = 0LL;
  }
  v23[1] = 0LL;
  uint64_t v24 = 0;
  if ((this & 1) != 0) {
    goto LABEL_49;
  }
  uint64_t v21 = *((unsigned __int8 *)v5 + 18);
  if (v21 == 2) {
    goto LABEL_45;
  }
  if (v21 == 5 && *((_DWORD *)v5 + 2) >= 2u)
  {
    BOOL v5 = *(swift::Demangle::__runtime::Node **)v5;
LABEL_45:
    uint64_t v22 = (swift::Demangle::__runtime::Node *)*((void *)v5 + 1);
    goto LABEL_47;
  }

  uint64_t v22 = 0LL;
LABEL_47:
  if (!*(_DWORD *)a4)
  {
    swift::Demangle::__runtime::CharVector::append((char **)(v6 + 12728), "Sg", 2uLL, *(void **)(v6 + 12744));
    this = (uint64_t)swift::Demangle::__runtime::RemanglerBase::addSubstitution( (char *)v6,  (const swift::Demangle::__runtime::SubstitutionEntry *)v23);
LABEL_49:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
  }

  return this;
}

  *(_DWORD *)(v5 + 12736) = v8 + 1;
  v10[v8] = 121;
LABEL_29:
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

  uint64_t v38 = (unsigned __int8 *)*((void *)this + 3);
  uint64_t v39 = *v38;
  if (v39 == 104)
  {
    *((void *)this + 3) = v38 + 1;
    *((void *)this + 4) = v21 - 1;
    uint64_t v40 = (void *)*((void *)this + 5);
    unint64_t v41 = v40[1];
    if (!v41 || (unint64_t)(v41 + 9) > v40[2])
    {
      uint64_t v42 = 2LL * v40[4];
      if (v42 <= 0xA) {
        uint64_t v42 = 10LL;
      }
      v40[4] = v42;
      uint64_t v43 = v42 + 8;
      uint64_t v44 = malloc(v42 + 8);
      *uint64_t v44 = v40[3];
      unint64_t v41 = (uint64_t)(v44 + 1);
      v40[2] = (char *)v44 + v43;
      v40[3] = v44;
    }

    v40[1] = v41 + 9;
    *(void *)unint64_t v41 = *(void *)"@Sendable";
    *(_BYTE *)(v41 + 8) = 101;
    uint64_t v45 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v40,  112,  v41,  9LL);
    swift::Demangle::__runtime::Node::addChild( Node,  v45,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v46,  v47);
    uint64_t v21 = *((void *)this + 4);
    if (!v21) {
      return 0LL;
    }
    uint64_t v38 = (unsigned __int8 *)*((void *)this + 3);
    uint64_t v39 = *v38;
  }

  if (v39 == 72)
  {
    *((void *)this + 3) = v38 + 1;
    *((void *)this + 4) = v21 - 1;
    uint64_t v48 = (void *)*((void *)this + 5);
    uint64_t v49 = v48[1];
    if (!v49 || (unint64_t)(v49 + 6) > v48[2])
    {
      unint64_t v50 = 2LL * v48[4];
      if (v50 <= 7) {
        unint64_t v50 = 7LL;
      }
      v48[4] = v50;
      v51 = v50 + 8;
      uint64_t v52 = malloc(v50 + 8);
      *uint64_t v52 = v48[3];
      uint64_t v49 = (uint64_t)(v52 + 1);
      v48[2] = (char *)v52 + v51;
      v48[3] = v52;
    }

    v48[1] = v49 + 6;
    *(_WORD *)(v49 + 4) = 25454;
    *(_DWORD *)uint64_t v49 = 2037604672;
    uint64_t v53 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v48,  112,  v49,  6LL);
    swift::Demangle::__runtime::Node::addChild( Node,  v53,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v54,  v55);
    uint64_t v21 = *((void *)this + 4);
    if (!v21) {
      return 0LL;
    }
    uint64_t v38 = (unsigned __int8 *)*((void *)this + 3);
    uint64_t v39 = *v38;
  }

  if ((v39 | 0x20) == 0x67)
  {
    *((void *)this + 3) = v38 + 1;
    *((void *)this + 4) = v21 - 1;
    if (!result) {
      return result;
    }
    swift::Demangle::__runtime::Node::addChild( Node,  result,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v56,  v57);
    uint64_t v21 = *((void *)this + 4);
    if (!v21) {
      return 0LL;
    }
    uint64_t v38 = (unsigned __int8 *)*((void *)this + 3);
    uint64_t v39 = *v38;
  }

  if (v39 != 95) {
    return 0LL;
  }
  uint64_t v58 = v21 - 1;
  *((void *)this + 3) = v38 + 1;
  *((void *)this + 4) = v58;
  int v59 = a2 + 2;
  if (!v58) {
    goto LABEL_51;
  }
LABEL_50:
  uint64_t v60 = (_BYTE *)*((void *)this + 3);
  if (*v60 == 95)
  {
    unint64_t v63 = v58 - 1;
    *((void *)this + 3) = v60 + 1;
    *((void *)this + 4) = v63;
    if (!v63) {
      goto LABEL_58;
    }
LABEL_57:
    uint64_t v64 = (_BYTE *)*((void *)this + 3);
    if (*v64 == 95)
    {
      *((void *)this + 3) = v64 + 1;
      *((void *)this + 4) = v63 - 1;
      return (swift::Demangle::__runtime::Node *)Node;
    }

    else
    {
LABEL_58:
      while (1)
      {
        if (!result) {
          break;
        }
        swift::Demangle::__runtime::Node::addChild( Node,  result,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v65,  v66);
        unint64_t v63 = *((void *)this + 4);
        if (v63) {
          goto LABEL_57;
        }
      }
    }
  }

  else
  {
LABEL_51:
    while (1)
    {
      if (!result) {
        break;
      }
      swift::Demangle::__runtime::Node::addChild( Node,  result,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v61,  v62);
      uint64_t v58 = *((void *)this + 4);
      if (v58) {
        goto LABEL_50;
      }
    }
  }

  return result;
}

      unint64_t v15 = a3 + 1;
      while (1)
      {
        if (*(_DWORD *)a4) {
          return this;
        }
        if (++v12 == v14) {
          goto LABEL_31;
        }
      }
    }

    unint64_t v13 = *(swift::Demangle::__runtime::Node **)v5;
LABEL_21:
    BOOL v14 = (swift::Demangle::__runtime::Node **)((char *)v13 + 8 * *((unsigned int *)v5 + 2));
    if (v12 == v14) {
      goto LABEL_31;
    }
    goto LABEL_28;
  }

  if (v9 != 1) {
    goto LABEL_14;
  }
LABEL_6:
  this = (char **)swift::Demangle::__runtime::CharVector::append(this + 1591, "PM", 2uLL, this[1593]);
  uint64_t v10 = *((unsigned __int8 *)v5 + 18);
  if (v10 == 1) {
  if (v10 == 5 && *((_DWORD *)v5 + 2) == 1)
  }
  {
    BOOL v5 = *(swift::Demangle::__runtime::Node **)v5;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = v5;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  *(_DWORD *)(v5 + 12736) = v8 + 1;
  v10[v8] = 121;
LABEL_29:
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

uint64_t RandomAccessCollection.index(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 48))(a1, a3, a4, a5);
  if (a2 < 1)
  {
    if (v11 <= 0 && v11 > a2) {
      goto LABEL_4;
    }
LABEL_10:
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 32))(a1, a2, a4, a5);
    unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a5 + 8) + 8LL),  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
    uint64_t v14 = a6;
    uint64_t v15 = 0LL;
    return v13(v14, v15, 1LL, AssociatedTypeWitness);
  }

LABEL_4:
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(a5 + 8) + 8LL),  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v14 = a6;
  uint64_t v15 = 1LL;
  return v13(v14, v15, 1LL, AssociatedTypeWitness);
}

  uint64_t result = 0LL;
  uint64_t v11 = 1;
LABEL_11:
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v11;
  return result;
}

    uint64_t v40 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v40, v164);
    *((_OWORD *)inited + 1) = v144;
    inited[7] = AssociatedTypeWitness;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v51(boxed_opaque_existential_0Tm, (uint64_t)v39, AssociatedTypeWitness);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v165);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v36 = 0;
    v152(v15, v32, v10);
  }

  (*(void (**)(unint64_t, uint64_t))(v140 + 8))(v27, v139);
  uint64_t v48 = v165;
  uint64_t v54 = v166;
  uint64_t v64 = HIBYTE(v166) & 0xF;
  uint64_t v27 = v165 & 0xFFFFFFFFFFFFLL;
  if ((v166 & 0x2000000000000000LL) != 0) {
    v94 = HIBYTE(v166) & 0xF;
  }
  else {
    v94 = v165 & 0xFFFFFFFFFFFFLL;
  }
  if (!v94 && (v165 & ~v166 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v166);
    return 93LL;
  }

  if ((v166 & 0x2000000000000000LL) == 0 || v64 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v92, v93);
    if ((v54 & 0x1000000000000000LL) != 0) {
      goto LABEL_105;
    }
    unint64_t v63 = __OFADD__(v94, 1LL);
    unint64_t v95 = v94 + 1;
    if (v63) {
      goto LABEL_107;
    }
LABEL_58:
    v96 = v48 & ~v54;
    if ((v96 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v54 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v97 = _StringGuts.nativeUnusedCapacity.getter(v48, v54);
      if ((v98 & 1) != 0)
      {
LABEL_118:
        v135 = 258LL;
LABEL_119:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v135,  0);
      }

      if (v95 > 15) {
        goto LABEL_64;
      }
      if ((v54 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        goto LABEL_76;
      }

      if (v97 > 0)
      {
LABEL_64:
        v99 = _StringGuts.nativeUnusedCapacity.getter(v48, v54);
        v102 = (v100 & 1) == 0 && v99 > 0;
        if ((v96 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v54 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v102) {
            goto LABEL_100;
          }
        }

        else if (v102)
        {
LABEL_99:
          _StringGuts.grow(_:)(v95);
LABEL_100:
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
          v163 = xmmword_1817FFC80;
          v128 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v163, 1LL);
          _StringGuts.appendInPlace(_:isASCII:)(v128, v129, 1);
          swift_bridgeObjectRelease(0xE100000000000000LL);
          return v165;
        }

        uint64_t v124 = _StringGuts.nativeCapacity.getter(v48, v54);
        if ((v125 & 1) != 0) {
          v126 = 0LL;
        }
        else {
          v126 = v124;
        }
        if (v126 + 0x4000000000000000LL >= 0)
        {
          v127 = 2 * v126;
          if (v127 > v95) {
            unint64_t v95 = v127;
          }
          goto LABEL_99;
        }

        __break(1u);
        goto LABEL_117;
      }
    }

    else if (v95 > 15)
    {
      goto LABEL_64;
    }

    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    if ((v54 & 0x2000000000000000LL) == 0)
    {
      if ((v54 & 0x1000000000000000LL) != 0)
      {
        uint64_t v48 = _StringGuts._foreignConvertedToSmall()(v48, v54);
        uint64_t v27 = v138;
      }

      else
      {
        if ((v48 & 0x1000000000000000LL) != 0)
        {
          uint64_t v134 = (unsigned __int8 *)((v54 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          uint64_t v134 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v48, v54);
          uint64_t v27 = v103;
        }

        swift_bridgeObjectRetain(v54, v103, v104, v105);
        closure #1 in _StringGuts._convertedToSmall()(v134, v27, &v163);
        swift_bridgeObjectRelease(v54);
        uint64_t v27 = *((void *)&v163 + 1);
        uint64_t v48 = v163;
      }

      goto LABEL_77;
    }

  uint64_t result = 0LL;
  uint64_t v14 = 1;
LABEL_11:
  *(void *)a6 = result;
  *(_BYTE *)(a6 + 8) = v14;
  return result;
}

  uint64_t result = 0LL;
  unsigned int v12 = 1;
LABEL_11:
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v12;
  return result;
}

  uint64_t result = 0LL;
  unsigned int v12 = 1;
LABEL_11:
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v12;
  return result;
}

  ++*(_DWORD *)(a1 + 8);
  if (v10 != -2) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)a2 = *a3;
  *(_OWORD *)(a2 + 8) = *a4;
  return a2;
}

  swift::BuilderError::BuilderError( (swift::BuilderError *)__p,  "Unable to compute extra data size of descriptor with kind %u",  v10);
  if (SHIBYTE(v15) < 0)
  {
    std::string::__init_copy_ctor_external( (std::string *)a4,  (const std::string::value_type *)__p[0],  (std::string::size_type)__p[1]);
    unint64_t v13 = SHIBYTE(v15);
    *(_DWORD *)(a4 + 24) = 1;
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    *(_OWORD *)a4 = *(_OWORD *)__p;
    *(void *)(a4 + 16) = v15;
    *(_DWORD *)(a4 + 24) = 1;
  }

  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  a2[1] = 0LL;
  return a2;
}

            a2 = *(swift::Demangle::__runtime::Node **)a2;
          }

uint64_t protocol witness for RandomAccessCollection.distance(from:to:) in conformance _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, a4, (uint64_t)&protocol witness table for Int);
}

unint64_t specialized RandomAccessCollection<>.distance(from:to:)( unint64_t a1, unint64_t a2, unsigned int a3)
{
  if (a3 < 0x80)
  {
    if (a1 <= 1 && a2 <= 1) {
      return a2 - a1;
    }
LABEL_15:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  if (a3 >= 0x800)
  {
    if (a3 >= 0x10000)
    {
      if (a1 >= 5 || a2 > 4) {
        goto LABEL_15;
      }
    }

    else if (a1 > 3 || a2 > 3)
    {
      goto LABEL_15;
    }
  }

  else if (a1 > 2 || a2 >= 3)
  {
    goto LABEL_15;
  }

  return a2 - a1;
}

unint64_t specialized RandomAccessCollection<>.distance(from:to:)( uint64_t a1, unint64_t a2, unsigned int a3)
{
  uint64_t v3 = 1LL;
  if (HIWORD(a3)) {
    uint64_t v3 = 2LL;
  }
  if (a1 < 0 || v3 < a1) {
    goto LABEL_9;
  }
  if (!HIWORD(a3))
  {
    if (a2 <= 1) {
      return a2 - a1;
    }
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  if (a2 >= 3) {
    goto LABEL_9;
  }
  return a2 - a1;
}

uint64_t specialized RandomAccessCollection<>.distance(from:to:)(uint64_t a1, uint64_t a2, id a3)
{
  uint64_t v6 = (uint64_t)objc_msgSend(a3, sel_count);
  if (v6 < 0) {
    goto LABEL_9;
  }
  if (a1 < 0 || v6 < a1) {
LABEL_8:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  uint64_t v7 = (uint64_t)objc_msgSend(a3, sel_count);
  if (v7 < 0) {
LABEL_9:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ClosedRange requires lowerBound <= upperBound",  45LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x59uLL,  0);
  if (a2 < 0 || v7 < a2) {
    goto LABEL_8;
  }
  return a2 - a1;
}

unint64_t specialized RandomAccessCollection<>.distance(from:to:)( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = HIBYTE(a4) & 0xF;
  if (v4 < a1 || v4 < a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }
  return a2 - a1;
}

uint64_t specialized RandomAccessCollection<>.distance(from:to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3) {
    uint64_t v4 = a4 - a3;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a1 < 0 || v4 < a1) {
    goto LABEL_11;
  }
  if (!a3)
  {
    if (!a2) {
      return a2 - a1;
    }
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  if (a2 < 0 || a4 - a3 < a2) {
    goto LABEL_11;
  }
  return a2 - a1;
}

uint64_t RandomAccessCollection<>.distance(from:to:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v31 = a5;
  uint64_t v32 = a2;
  uint64_t v33 = a1;
  uint64_t v7 = *(void *)(*(void *)(a4 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v27 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unint64_t v13 = (char *)&v27 - v12;
  uint64_t v14 = *(void *)(a5 + 8);
  unint64_t v27 = AssociatedTypeWitness;
  uint64_t v28 = v14;
  uint64_t v30 = type metadata accessor for ClosedRange(0LL, AssociatedTypeWitness, v14, v15);
  uint64_t v16 = *(void *)(v30 - 8);
  MEMORY[0x1895F8858](v30);
  uint64_t v18 = (char *)&v27 - v17;
  uint64_t v29 = *(void (**)(uint64_t, uint64_t))(v7 + 64);
  v29(a3, v7);
  uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v7 + 72);
  v19(a3, v7);
  ClosedRange.init(uncheckedBounds:)((uint64_t)v13, (uint64_t)v11, AssociatedTypeWitness, v14, (uint64_t)v18);
  uint64_t v20 = *(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 168);
  v20(v33, v18, a3, v7);
  uint64_t v21 = *(void (**)(char *, uint64_t))(v16 + 8);
  uint64_t v22 = v30;
  v21(v18, v30);
  v29(a3, v7);
  v19(a3, v7);
  uint64_t v23 = (uint64_t)v11;
  uint64_t v24 = v27;
  ClosedRange.init(uncheckedBounds:)((uint64_t)v13, v23, v27, v28, (uint64_t)v18);
  uint64_t v25 = v32;
  v20(v32, v18, a3, v7);
  v21(v18, v22);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v31 + 40))(&v34, v25, v24);
  return v34;
}

void protocol witness for Collection.startIndex.getter in conformance _ArrayBuffer<A>(void *a1@<X8>)
{
  *a1 = 0LL;
}

uint64_t _ArrayBuffer.startIndex.getter()
{
  return 0LL;
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance _ArrayBuffer<A>@<X0>( Swift::Int *a1@<X8>)
{
  Swift::Int result = Array._getCount()();
  *a1 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>( uint64_t ***a1, unint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = (uint64_t **)malloc(0x28uLL);
  *a1 = v7;
  v7[4] = (uint64_t *)_ArrayBuffer.subscript.read(v7, *a2, *v3, *(uint64_t **)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*specialized _ArrayBuffer.subscript.read( void *a1, unint64_t a2, uint64_t a3, char *a4))(id *a1)
{
  if ((a3 & 0xC000000000000001LL) != 0) {
    id v5 = specialized _ArrayBuffer._getElementSlowPath(_:)(a2, a3, a3, a4);
  }
  else {
    id v5 = swift_unknownObjectRetain(*(id *)(a3 + 8 * a2 + 32), a2, a3, a4);
  }
  *a1 = v5;
  return _ArrayBuffer.subscript.readspecialized ;
}

void _ArrayBuffer.subscript.readspecialized (id *a1)
{
}

uint64_t (*_ArrayBuffer.subscript.read( uint64_t **a1, unint64_t a2, uint64_t a3, uint64_t *a4))()
{
  uint64_t v8 = *(a4 - 1);
  *a1 = a4;
  a1[1] = (uint64_t *)v8;
  uint64_t v9 = (uint64_t *)malloc(*(void *)(v8 + 64));
  a1[2] = v9;
  _ArrayBuffer.subscript.getter(a2, a3, a4, (uint64_t)v9);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance _ArrayBuffer<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = _ArrayBuffer.subscript.getter(*a1, a1[1], *v3, *(uint64_t **)(a2 + 16));
  *a3 = result;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t specialized RandomAccessCollection<>.indices.getter()
{
  return 0LL;
}

uint64_t RandomAccessCollection<>.indices.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v43 = a4;
  uint64_t v44 = a3;
  uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v40 = (char *)&v39 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v39 - v10;
  uint64_t v12 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v9);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v18 = (char *)&v39 - v17;
  uint64_t v19 = MEMORY[0x1895F8858](v16);
  uint64_t v21 = (char *)&v39 - v20;
  MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v39 - v22;
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(a1, v5);
  (*(void (**)(uint64_t, uint64_t))(v5 + 72))(a1, v5);
  uint64_t v24 = v12;
  uint64_t v25 = *(void (**)(char *, char *, unint64_t))(v12 + 16);
  v25(v18, v23, AssociatedTypeWitness);
  unint64_t v41 = v21;
  v25(v15, v21, AssociatedTypeWitness);
  uint64_t v26 = *(void *)(v44 + 8);
  if (((*(uint64_t (**)(char *, char *, unint64_t, uint64_t))(v26 + 24))( v18,  v15,  AssociatedTypeWitness,  v26) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v27 = v24;
  uint64_t v28 = *(void (**)(char *, unint64_t))(v24 + 8);
  v28(v15, AssociatedTypeWitness);
  v28(v18, AssociatedTypeWitness);
  uint64_t v29 = v40;
  uint64_t v44 = v26;
  uint64_t v30 = TupleTypeMetadata2;
  uint64_t v31 = &v11[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v32 = *(void (**)(char *, char *, unint64_t))(v27 + 32);
  v32(v11, v23, AssociatedTypeWitness);
  v32(v31, v41, AssociatedTypeWitness);
  uint64_t v33 = &v29[*((int *)v30 + 12)];
  v25(v29, v11, AssociatedTypeWitness);
  v25(v33, v31, AssociatedTypeWitness);
  uint64_t v34 = v43;
  v32(v43, v29, AssociatedTypeWitness);
  v28(v33, AssociatedTypeWitness);
  uint64_t v35 = &v29[*((int *)v30 + 12)];
  v32(v29, v11, AssociatedTypeWitness);
  v32(v35, v31, AssociatedTypeWitness);
  uint64_t v37 = type metadata accessor for Range(0LL, AssociatedTypeWitness, v44, v36);
  v32(&v34[*(int *)(v37 + 36)], v35, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, unint64_t))v28)(v29, AssociatedTypeWitness);
}

BOOL specialized Collection.isEmpty.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  return v2 == 0;
}

uint64_t Collection.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v5 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v15 - v9;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(a2 + 72))(a1, a2);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v12 = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v10,  v8,  AssociatedTypeWitness);
  uint64_t v13 = *(void (**)(char *, unint64_t))(v5 + 8);
  v13(v8, AssociatedTypeWitness);
  v13(v10, AssociatedTypeWitness);
  return v12 & 1;
}

id protocol witness for Collection.count.getter in conformance _ArrayBuffer<A>(uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(uint64_t **)(a1 + 16);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3) && (v2 < 0 || (v2 & 0x4000000000000000LL) != 0))
  {
    id v7 = _ArrayBuffer._nonNative.getter(v2);
    id v8 = objc_msgSend(v7, sel_count);
    swift_unknownObjectRelease(v7);
    return v8;
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v3, v3);
    uint64_t v5 = v2 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v5 = v2;
    }
    return *(id *)(v5 + 16);
  }

id _ArrayBuffer.count.getter(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      id v7 = (void *)a1;
    }
    else {
      id v7 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    return objc_msgSend(v7, sel_count);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v5 = a1;
    }
    return *(id *)(v5 + 16);
  }

uint64_t Collection._customIndexOfEquatableElement(_:)@<X0>( uint64_t a1@<X1>, const char *a2@<X2>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v5, v6);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56LL))(a3, 1LL, 1LL, v7);
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v5, v6);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 56LL))(a3, 1LL, 1LL, v7);
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance _ArrayBuffer<A>()
{
  return Collection._failEarlyRangeCheck(_:bounds:)();
}

{
  return Collection._failEarlyRangeCheck(_:bounds:)();
}

{
  return Collection._failEarlyRangeCheck(_:bounds:)();
}

uint64_t protocol witness for Collection.index(after:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

unint64_t specialized RandomAccessCollection<>.index(after:)(unint64_t a1, unsigned int a2)
{
  if (a2 >= 0x80)
  {
    if (a2 >= 0x800)
    {
      if (HIWORD(a2))
      {
        if (a1 < 4) {
          goto LABEL_11;
        }
      }

      else if (a1 < 3)
      {
        goto LABEL_11;
      }

{
  if (a2 < 0x10000)
  {
    if (a1) {
LABEL_3:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  else if (a1 >= 2)
  {
    goto LABEL_3;
  }

  return a1 + 1;
}

LABEL_6:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
    }

    unint64_t v2 = 2LL;
  }

  else
  {
    unint64_t v2 = 1LL;
  }

  if (v2 <= a1) {
    goto LABEL_6;
  }
LABEL_11:
  BOOL v3 = __OFADD__(a1, 1LL);
  unint64_t result = a1 + 1;
  if (v3) {
    __break(1u);
  }
  return result;
}

  uint64_t v23 = v31;
  uint64_t v22 = v32;
  (*(void (**)(uint64_t, char *, unint64_t))(v31 + 32))(v32, v17, AssociatedTypeWitness);
LABEL_11:
  uint64_t v28 = 0LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v23 + 56))( v22,  v28,  1LL,  AssociatedTypeWitness);
}

  uint64_t v23 = v31;
  uint64_t v22 = v32;
  (*(void (**)(uint64_t, char *, unint64_t))(v31 + 32))(v32, v17, AssociatedTypeWitness);
LABEL_11:
  uint64_t v28 = 0LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v23 + 56))( v22,  v28,  1LL,  AssociatedTypeWitness);
}

    uint64_t v5 = specialized LazyMapSequence.Iterator.next()();
    uint64_t v1 = v6;
    if (!v6) {
      break;
    }
    uint64_t v7 = v5;
    swift_bridgeObjectRelease(v0[7]);
    v0[6] = v7;
    v0[7] = v1;
    v0[8] = 15LL;
  }

  id v8 = 1;
  return v1 | (v8 << 8);
}

    uint64_t v5 = specialized LazyMapSequence.Iterator.next()();
    uint64_t v1 = v6;
    if (!v6) {
      break;
    }
    uint64_t v7 = v5;
    swift_bridgeObjectRelease(v0[8]);
    v0[7] = v7;
    v0[8] = v1;
    v0[9] = 15LL;
  }

  id v8 = 1;
  return v1 | (v8 << 8);
}

  while (1)
  {
    uint64_t v6 = *v1;
    uint64_t v7 = v1[1];
    *uint64_t v1 = 0LL;
    v1[1] = 0LL;
    if (!v7) {
      break;
    }
    id v8 = (void (*)(void *__return_ptr, unint64_t *))v1[2];
    uint64_t v24 = v6;
    uint64_t v25 = v7;
    v8(v23, &v24);
    swift_bridgeObjectRelease(v7);
    uint64_t v9 = v23[0];
    unint64_t v2 = v23[1];
    swift_bridgeObjectRelease(v1[5]);
    v1[4] = v9;
    v1[5] = v2;
    v1[6] = 15LL;
    if (v2) {
      goto LABEL_2;
    }
  }

  uint64_t v10 = 0;
  uint64_t v11 = 1;
  return v10 | (v11 << 8);
}

      uint64_t v46 = v115;
      uint64_t v47 = *(void *)(v115 + 16);
    }

    while (v48 < v47);
  }

  *uint64_t v92 = v46;
  return result;
}

  swift_bridgeObjectRelease((uint64_t)v54);
  *unint64_t v50 = v65;
}

    uint64_t v30 = *(void (**)(char *, uint64_t))(*(void *)(a3 - 8) + 8LL);
    v30(v25, a3);
    uint64_t v31 = v38;
    v23(v38, v39, v7);
    uint64_t v32 = *(void *)v31;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a3,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    v30(&v31[*((int *)TupleTypeMetadata3 + 12)], a3);
    uint64_t v34 = v42;
    v23(v42, v43, v7);
    uint64_t v35 = *(void *)v34;
    uint64_t v36 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a3,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    v30(&v34[*((int *)v36 + 12)], a3);
    uint64_t v27 = v32 < v35;
    id v8 = v40;
    uint64_t v7 = v41;
    goto LABEL_7;
  }

  v23(v17, (uint64_t)v21, v7);
  uint64_t v24 = *((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a3,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
        + 12);
  uint64_t v25 = &v17[v24];
  uint64_t v26 = *(void (**)(unsigned __int8 *, uint64_t))(*(void *)(a3 - 8) + 8LL);
  v26(&v22[v24], a3);
  v26((unsigned __int8 *)v25, a3);
  uint64_t v27 = 1LL;
LABEL_7:
  (*(void (**)(unsigned __int8 *, uint64_t))(v8 + 8))(v21, v7);
  return v27;
}

  uint64_t v14 = v66;
  uint64_t v42 = v60;
  return (unint64_t *)((uint64_t (*)(char *, unint64_t))v14[1])(v42, AssociatedTypeWitness);
}

    v117 = -128LL;
    uint64_t v32 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v28, v29, v30);
    v32(&v117, &type metadata for Int, v33, a3, a4);
    LOBYTE(v32) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v26,  a3);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
    goto LABEL_10;
  }

  uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v28 = v114(a3, a4);
  if (v28 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
  if (v34 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  uint64_t v35 = v27(a3, a4);
  uint64_t v36 = v114(a3, a4);
  if ((v35 & 1) != 0)
  {
    if (v36 > 64) {
      goto LABEL_12;
    }
  }

  else if (v36 >= 64)
  {
LABEL_12:
    v117 = 128LL;
    uint64_t v39 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
    v39(&v117, &type metadata for Int, v40, a3, a4);
    LOBYTE(v39) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v26,  a2,  a3);
    unint64_t v41 = *(void (**)(char *, uint64_t))(v9 + 8);
    v41(v26, a3);
    goto LABEL_16;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v41 = *(void (**)(char *, uint64_t))(v9 + 8);
  v41(v26, a3);
  if (v42 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v43 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  uint64_t v44 = v113;
  v43(v113, a2, a3);
  uint64_t v45 = v27(a3, a4);
  uint64_t v46 = v111;
  uint64_t v47 = (void (*)(char *, char *, uint64_t))v43;
  v43(v111, (uint64_t)v44, a3);
  if ((v45 & 1) != 0)
  {
    uint64_t v48 = v114(a3, a4);
    v41(v46, a3);
    if (v48 <= 64) {
      goto LABEL_41;
    }
    uint64_t v49 = v106;
    v47(v106, v113, a3);
    v117 = 0x8000000000000000LL;
    if ((v27(a3, a4) & 1) != 0)
    {
      unint64_t v50 = v114(a3, a4);
      if (v50 < 64)
      {
        uint64_t v53 = v26;
        goto LABEL_35;
      }

      uint64_t v70 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
      v70(&v117, &type metadata for Int, v71, a3, a4);
      uint64_t v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v49,  v26,  a3);
      goto LABEL_30;
    }

    unint64_t v63 = v27(a3, a4);
    uint64_t v64 = v114(a3, a4);
    if ((v63 & 1) != 0)
    {
      if (v64 <= 64)
      {
        v75 = AssociatedTypeWitness;
        char v74 = (void (**)(char *, uint64_t, const char *))v109;
        v76 = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v77 = v107;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))( &qword_18180BE68,  256LL,  v75,  v76);
        v74[3](v77, a3, (const char *)v74);
        v78 = v106;
        LOBYTE(v74) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v106,  v26,  a3);
        v41(v26, a3);
        v79 = v105;
        v47(v105, v78, a3);
        if ((v74 & 1) != 0)
        {
          v41(v79, a3);
          goto LABEL_61;
        }

        v80 = v117;
        v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v41(v79, a3);
        unint64_t v82 = v81 < v80;
        uint64_t v49 = v106;
        if (v82) {
          goto LABEL_61;
        }
LABEL_39:
        uint64_t v54 = v49;
        goto LABEL_40;
      }

      unint64_t v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
      v67(&v117, &type metadata for Int, v68, a3, a4);
      uint64_t v49 = v106;
      uint64_t v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v106,  v26,  a3);
LABEL_30:
      v72 = v69;
      v41(v26, a3);
      if ((v72 & 1) != 0) {
        goto LABEL_61;
      }
      goto LABEL_39;
    }

    if (v64 < 64)
    {
      uint64_t v53 = v26;
      uint64_t v49 = v106;
LABEL_35:
      v47(v53, v49, a3);
      v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v41(v26, a3);
      if (v73 < v117) {
LABEL_61:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      goto LABEL_39;
    }

    uint64_t v54 = v106;
  }

  else
  {
    uint64_t v54 = v46;
  }

    v117 = -128LL;
    uint64_t v32 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v33 = lazy protocol witness table accessor for type Int and conformance Int(v28, v29, v30);
    v32(&v117, &type metadata for Int, v33, a3, a4);
    LOBYTE(v32) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v26,  a3);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
    goto LABEL_10;
  }

  uint64_t v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v28 = v114(a3, a4);
  if (v28 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
  if (v34 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  uint64_t v35 = v27(a3, a4);
  uint64_t v36 = v114(a3, a4);
  if ((v35 & 1) != 0)
  {
    if (v36 > 64) {
      goto LABEL_12;
    }
  }

  else if (v36 >= 64)
  {
LABEL_12:
    v117 = 128LL;
    uint64_t v39 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
    v39(&v117, &type metadata for Int, v40, a3, a4);
    LOBYTE(v39) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v26,  a2,  a3);
    unint64_t v41 = *(void (**)(char *, uint64_t))(v9 + 8);
    v41(v26, a3);
    goto LABEL_16;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v41 = *(void (**)(char *, uint64_t))(v9 + 8);
  v41(v26, a3);
  if (v42 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v43 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  uint64_t v44 = v113;
  v43(v113, a2, a3);
  uint64_t v45 = v27(a3, a4);
  uint64_t v46 = v111;
  uint64_t v47 = (void (*)(char *, char *, uint64_t))v43;
  v43(v111, (uint64_t)v44, a3);
  if ((v45 & 1) != 0)
  {
    uint64_t v48 = v114(a3, a4);
    v41(v46, a3);
    if (v48 <= 64) {
      goto LABEL_41;
    }
    uint64_t v49 = v106;
    v47(v106, v113, a3);
    v117 = 0x8000000000000000LL;
    if ((v27(a3, a4) & 1) != 0)
    {
      unint64_t v50 = v114(a3, a4);
      if (v50 < 64)
      {
        uint64_t v53 = v26;
        goto LABEL_35;
      }

      uint64_t v70 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
      v70(&v117, &type metadata for Int, v71, a3, a4);
      uint64_t v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v49,  v26,  a3);
      goto LABEL_30;
    }

    unint64_t v63 = v27(a3, a4);
    uint64_t v64 = v114(a3, a4);
    if ((v63 & 1) != 0)
    {
      if (v64 <= 64)
      {
        v75 = AssociatedTypeWitness;
        char v74 = (void (**)(char *, uint64_t, const char *))v109;
        v76 = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v77 = v107;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))( &qword_18180BE68,  256LL,  v75,  v76);
        v74[3](v77, a3, (const char *)v74);
        v78 = v106;
        LOBYTE(v74) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v106,  v26,  a3);
        v41(v26, a3);
        v79 = v105;
        v47(v105, v78, a3);
        if ((v74 & 1) != 0)
        {
          v41(v79, a3);
          goto LABEL_61;
        }

        v80 = v117;
        v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v41(v79, a3);
        unint64_t v82 = v81 < v80;
        uint64_t v49 = v106;
        if (v82) {
          goto LABEL_61;
        }
LABEL_39:
        uint64_t v54 = v49;
        goto LABEL_40;
      }

      unint64_t v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
      v67(&v117, &type metadata for Int, v68, a3, a4);
      uint64_t v49 = v106;
      uint64_t v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v106,  v26,  a3);
LABEL_30:
      v72 = v69;
      v41(v26, a3);
      if ((v72 & 1) != 0) {
        goto LABEL_61;
      }
      goto LABEL_39;
    }

    if (v64 < 64)
    {
      uint64_t v53 = v26;
      uint64_t v49 = v106;
LABEL_35:
      v47(v53, v49, a3);
      v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v41(v26, a3);
      if (v73 < v117) {
LABEL_61:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      goto LABEL_39;
    }

    uint64_t v54 = v106;
  }

  else
  {
    uint64_t v54 = v46;
  }

  *a2 = v10;
}

  *a2 = v13;
}

    a2 = v7;
  }

  uint64_t v9 = (unsigned __int128 *)(8 * a2 + 16);
  do
  {
    uint64_t v11 = __ldxp(v9);
    uint64_t v10 = v11;
  }

  while (__stxp(v11, v9));
  char v12 = DWORD2(v11);
  uint64_t v13 = HIDWORD(*((void *)&v11 + 1));
  if ((_DWORD)a3 == 1)
  {
    uint64_t v4 = 0;
    goto LABEL_30;
  }

  uint64_t v14 = v11;
  if ((v11 & 0x8000000000000000LL) == 0 || v11 != 0xFFFFFFFFLL)
  {
    if (a3 >= 2 && (v11 & 0x8000000000000000LL) != 0)
    {
      uint64_t v23 = HIDWORD(*((void *)&v11 + 1));
    }

    else
    {
LABEL_30:
      while (v10 - v5 >= 0)
      {
        uint64_t v15 = v12;
        uint64_t v16 = v12 | (unint64_t)(v13 << 32);
        do
        {
          while (1)
          {
            uint64_t v18 = __ldxp(v9);
            char v12 = DWORD2(v18);
            uint64_t v17 = v18;
            uint64_t v19 = (void)v18 != v10;
            if (*((void *)&v18 + 1) != v16) {
              ++v19;
            }
            if (!v19) {
              break;
            }
            if (!__stlxp(v18, v9)) {
              goto LABEL_38;
            }
          }
        }

        while (__stlxp(__PAIR128__(v15, v10 - v5), v9));
LABEL_38:
        if ((void)v18 == v10 && *((void *)&v18 + 1) == v16) {
          return 0LL;
        }
        uint64_t v21 = HIDWORD(*((void *)&v18 + 1));
        uint64_t v22 = (v18 & 0x8000000000000000LL) != 0LL && v4;
        uint64_t v10 = v18;
        uint64_t v13 = HIDWORD(*((void *)&v18 + 1));
        if (v22) {
          goto LABEL_51;
        }
      }

      uint64_t v21 = v13;
      uint64_t v17 = v10;
LABEL_51:
      uint64_t v14 = v17;
      uint64_t v23 = v21;
      uint64_t v10 = v17;
    }

    if (v14 != 0xFFFFFFFFLL && ((_DWORD)a3 == 1 || (v10 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL))
    {
      while (1)
      {
        uint64_t v25 = v10 - v5;
        uint64_t v27 = a3 >= 2 && v10 < 0 || v25 < 0;
        uint64_t v28 = !v27;
        if (v27)
        {
          if ((_DWORD)v10 == -1) {
            return 0LL;
          }
          uint64_t v25 = v10 & 0x80000000FFFFFFFFLL | 0x100000000LL;
        }

        uint64_t v29 = v12;
        uint64_t v30 = v12 | (unint64_t)(v23 << 32);
        do
        {
          while (1)
          {
            uint64_t v31 = __ldxp(v9);
            char v12 = DWORD2(v31);
            uint64_t v32 = (void)v31 != v10;
            if (*((void *)&v31 + 1) != v30) {
              ++v32;
            }
            if (!v32) {
              break;
            }
            if (!__stlxp(v31, v9)) {
              goto LABEL_56;
            }
          }
        }

        while (__stlxp(__PAIR128__(v29, v25), v9));
LABEL_56:
        if ((void)v31 == v10 && *((void *)&v31 + 1) == v30) {
          break;
        }
        uint64_t v23 = HIDWORD(*((void *)&v31 + 1));
        uint64_t v10 = v31;
      }

      if ((v28 & 1) == 0)
      {
        __dmb(9u);
        id v8 = *(unint64_t **)(8 * a2);
        goto LABEL_22;
      }
    }
  }

  return 0LL;
}

  uint64_t v10 = v14[0];
  v14[0] = 0LL;
  if (v10) {
    operator delete(v10);
  }
  if (v19 != (void *)v21) {
    free(v19);
  }
  return v7;
}

    LOBYTE(v6) = 0;
  }

  return v6 & 1;
}

    if (!v12) {
      goto LABEL_13;
    }
    goto LABEL_7;
  }

  uint64_t v14 = 4LL;
  uint64_t v13 = __p;
LABEL_12:
  (*((void (**)(void))*v13 + v14))();
  if (!v12)
  {
LABEL_13:
    if (!a2)
    {
      *a5 = 0LL;
      a5[1] = 0LL;
      a5[2] = 0LL;
      return;
    }

    if (a3 <= 0x7FFFFFFFFFFFFFF7LL)
    {
      if (a3 >= 0x17)
      {
        uint64_t v17 = (a3 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((a3 | 7) != 0x17) {
          uint64_t v17 = a3 | 7;
        }
        uint64_t v18 = v17 + 1;
        uint64_t v19 = operator new(v17 + 1);
        a5[1] = a3;
        a5[2] = v18 | 0x8000000000000000LL;
        *a5 = v19;
        a5 = v19;
      }

      else
      {
        *((_BYTE *)a5 + 23) = a3;
        if (!a3) {
          goto LABEL_28;
        }
      }

      memmove(a5, a2, a3);
LABEL_28:
      *((_BYTE *)a5 + a3) = 0;
      return;
    }

uint64_t specialized RandomAccessCollection<>.index(after:)(uint64_t a1, id a2)
{
  uint64_t v3 = (uint64_t)objc_msgSend(a2, sel_count);
  if (v3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }
  if (a1 < 0 || v3 <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return a1 + 1;
}

unint64_t specialized RandomAccessCollection<>.index(after:)( unint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((HIBYTE(a3) & 0xF) <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return a1 + 1;
}

uint64_t specialized RandomAccessCollection<>.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || a1 < 0 || a3 - a2 <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return a1 + 1;
}

uint64_t specialized RandomAccessCollection<>.index(after:)(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)a2 >> 62)
  {
    if (a2 < 0) {
      uint64_t v5 = (void *)a2;
    }
    else {
      uint64_t v5 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v3 = (uint64_t)objc_msgSend(v5, sel_count);
    if (v3 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
    }
  }

  else
  {
    uint64_t v3 = *(void *)((a2 & 0xFFFFFFFFFFFFF8LL) + 0x10);
  }

  if (a1 < 0 || v3 <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return a1 + 1;
}

uint64_t RandomAccessCollection<>.index(after:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v21 = a4;
  uint64_t v22 = a1;
  uint64_t v23 = a5;
  uint64_t v7 = *(void *)(*(void *)(a3 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v21 - v12;
  uint64_t v14 = *(void *)(a4 + 8);
  uint64_t v16 = type metadata accessor for Range(0LL, AssociatedTypeWitness, v14, v15);
  uint64_t v17 = *(void *)(v16 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v19 = (char *)&v21 - v18;
  (*(void (**)(uint64_t, uint64_t))(v7 + 64))(a2, v7);
  (*(void (**)(uint64_t, uint64_t))(v7 + 72))(a2, v7);
  Range.init(uncheckedBounds:)((uint64_t)v13, (uint64_t)v11, AssociatedTypeWitness, v14, (uint64_t)v19);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 160))(v22, v19, a2, v7);
  (*(void (**)(char *, uint64_t))(v17 + 8))(v19, v16);
  uint64_t v24 = 1LL;
  return (*(uint64_t (**)(uint64_t *, unint64_t))(v21 + 48))(&v24, AssociatedTypeWitness);
}

void *protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for _ArrayBuffer<A>,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

uint64_t Collection.formIndex(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 184))(a1, a2, a3);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v7 + 32))(a1, v9, AssociatedTypeWitness);
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 184))(a1, a2, a3);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v7 + 32))(a1, v9, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

unint64_t specialized RandomAccessCollection<>.index(before:)(uint64_t a1, unsigned int a2)
{
  BOOL v2 = __OFSUB__(a1, 1LL);
  unint64_t result = a1 - 1;
  if (v2)
  {
    __break(1u);
  }

  else if (a2 < 0x10000)
  {
    if (result) {
LABEL_4:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  else if (result >= 2)
  {
    goto LABEL_4;
  }

  return result;
}

{
  BOOL v2;
  unint64_t result;
  unint64_t v4;
  BOOL v2 = __OFSUB__(a1, 1LL);
  unint64_t result = a1 - 1;
  if (v2)
  {
    __break(1u);
    return result;
  }

  if (a2 >= 0x80)
  {
    if (a2 >= 0x800)
    {
      if (HIWORD(a2))
      {
        if (result < 4) {
          return result;
        }
      }

      else if (result < 3)
      {
        return result;
      }

uint64_t specialized RandomAccessCollection<>.index(before:)(uint64_t a1, id a2)
{
  uint64_t v2 = a1 - 1;
  if (__OFSUB__(a1, 1LL))
  {
    __break(1u);
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0xB2uLL,  0);
  }

  uint64_t v3 = (uint64_t)objc_msgSend(a2, sel_count);
  if (v3 < 0) {
    goto LABEL_8;
  }
  if (v2 < 0 || v2 >= v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }
  return v2;
}

unint64_t specialized RandomAccessCollection<>.index(before:)( uint64_t a1, uint64_t a2, unint64_t a3)
{
  BOOL v3 = __OFSUB__(a1, 1LL);
  unint64_t result = a1 - 1;
  if (v3)
  {
    __break(1u);
  }

  else if (result >= (HIBYTE(a3) & 0xF))
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  return result;
}

uint64_t specialized RandomAccessCollection<>.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3 = __OFSUB__(a1, 1LL);
  uint64_t result = a1 - 1;
  if (v3)
  {
    __break(1u);
  }

  else if (!a2 || result < 0 || result >= a3 - a2)
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  return result;
}

uint64_t RandomAccessCollection<>.index(before:)@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = *(void *)(*(void *)(a2 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v20 - v12;
  uint64_t v14 = *(void *)(a3 + 8);
  uint64_t v16 = type metadata accessor for Range(0LL, AssociatedTypeWitness, v14, v15);
  uint64_t v20 = *(void *)(v16 - 8);
  uint64_t v21 = v16;
  MEMORY[0x1895F8858](v16);
  uint64_t v18 = (char *)&v20 - v17;
  uint64_t v22 = -1LL;
  (*(void (**)(uint64_t *, unint64_t, uint64_t))(a3 + 48))(&v22, AssociatedTypeWitness, a3);
  (*(void (**)(uint64_t, uint64_t))(v7 + 64))(a1, v7);
  (*(void (**)(uint64_t, uint64_t))(v7 + 72))(a1, v7);
  Range.init(uncheckedBounds:)((uint64_t)v13, (uint64_t)v11, AssociatedTypeWitness, v14, (uint64_t)v18);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v7 + 160))(a4, v18, a1, v7);
  return (*(uint64_t (**)(char *, uint64_t))(v20 + 8))(v18, v21);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _ArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  (uint64_t)&protocol conformance descriptor for _ArrayBuffer<A>,  (void *(*)(uint64_t *__return_ptr, void *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t BidirectionalCollection.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 32))(a1, a2, a3);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v7 + 32))(a1, v9, AssociatedTypeWitness);
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v11;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a3 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v11 - v8;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 32))(a1, a2, a3);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v7 + 32))(a1, v9, AssociatedTypeWitness);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)( a1,  a2,  a3,  WitnessTable,  (uint64_t)&protocol witness table for Int,  a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _ArrayBuffer<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

void protocol witness for Sequence.makeIterator() in conformance _ArrayBuffer<A>(void *a1@<X8>)
{
  *a1 = *v1;
  a1[1] = 0LL;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

Swift::Int specialized Collection.underestimatedCount.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000LL) != 0) {
    return String.UTF16View._foreignCount()();
  }
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1;
  }
  return String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v2 << 16) | 7));
}

uint64_t Collection.underestimatedCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _ArrayBuffer<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t Collection._copyToContiguousArray()(uint64_t a1, uint64_t a2)
{
  return Sequence._copyToContiguousArray()( a1,  a2,  (uint64_t (*)(uint64_t, uint64_t, uint64_t))specialized Collection._copyToContiguousArray());
}

uint64_t Sequence._copyToContiguousArray()( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v5 = a3(v3, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 - 8) + 8LL))(v3, a1);
  return v5;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _ArrayBuffer<A>( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, void, void))_ArrayBuffer._copyContents(initializing:));
}

uint64_t specialized _ArrayBuffer._copyContents(initializing:)(void **a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a2;
  if ((unint64_t)a3 >> 62)
  {
    if (a2 >= 1)
    {
      if (!a1) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
      }
      if (a3 < 0) {
        uint64_t v8 = (void *)a3;
      }
      else {
        uint64_t v8 = (void *)(a3 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_bridgeObjectRetain(a3, a2, a3, a4);
      id v9 = _CocoaArrayWrapper._copyContents(initializing:)(a1, v5, v8);
      swift_unknownObjectRelease(v9);
    }
  }

  else if (a2 >= 1)
  {
    if (!a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2ECuLL,  0);
    }
    if (*(void *)((a3 & 0xFFFFFFFFFFFFFF8LL) + 0x10) < a2) {
      uint64_t v5 = *(void *)((a3 & 0xFFFFFFFFFFFFFF8LL) + 0x10);
    }
    uint64_t v7 = (char *)((a3 & 0xFFFFFFFFFFFFFF8LL) + 32);
    swift_bridgeObjectRetain(a3, a2, a3, a4);
    specialized UnsafeMutablePointer.initialize(from:count:)(v7, v5, (char *)a1);
    swift_bridgeObjectRelease(a3);
  }

  return a3;
}

uint64_t _ArrayBuffer._copyContents(initializing:)(void **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
  {
    if (a2 >= 1)
    {
      if (!a1) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
      }
      if (a3 < 0) {
        uint64_t v18 = (void *)a3;
      }
      else {
        uint64_t v18 = (void *)(a3 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_unknownObjectRetain(v18, v8, v9, v10);
      id v19 = _CocoaArrayWrapper._copyContents(initializing:)(a1, a2, v18);
      swift_unknownObjectRelease(v19);
    }
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
    uint64_t v15 = a3 & 0xFFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v15 = a3;
    }
    if (a2 > 0)
    {
      if (!a1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2ECuLL,  0);
      }
      if (*(void *)(v15 + 16) < a2) {
        a2 = *(void *)(v15 + 16);
      }
      uint64_t v16 = *(unsigned __int8 *)(*(a4 - 1) + 80);
      uint64_t v17 = (char *)(v15 + ((v16 + 32) & ~v16));
      swift_bridgeObjectRetain(a3, v12, v13, v14);
      UnsafeMutablePointer.initialize(from:count:)(v17, a2, (char *)a1, (uint64_t)a4);
      swift_bridgeObjectRelease(a3);
    }
  }

  return a3;
}

BOOL static Int.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t _ArrayBuffer.arrayPropertyIsNativeTypeChecked.getter(uint64_t a1, uint64_t *a2)
{
  return ((a1 & 0xC000000000000001LL) == 0) | !_swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
}

Swift::Bool __swiftcall _ArrayBuffer.isUniquelyReferenced()()
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType(*(void *)(v0 + 16), *(uint64_t **)(v0 + 16));
  uint64_t v3 = *v1;
  if (!isClassOrObjCExistentialType) {
    return swift_isUniquelyReferenced_nonNull_native(*v1);
  }
  Swift::Bool result = 0;
  if ((v3 & 0x8000000000000000LL) == 0 && (v3 & 0x4000000000000000LL) == 0) {
    return swift_isUniquelyReferenced_nonNull_bridgeObject(*v1);
  }
  return result;
}

Swift::Bool __swiftcall _BridgeStorage.isUniquelyReferencedUnflaggedNative()()
{
  return swift_isUniquelyReferenced_nonNull_native(*v0);
}

Swift::Bool __swiftcall _BridgeStorage.isUniquelyReferencedNative()()
{
  Swift::Bool result = 0;
  if ((*v0 & 0x8000000000000000LL) == 0 && (*v0 & 0x4000000000000000LL) == 0) {
    return swift_isUniquelyReferenced_nonNull_bridgeObject(*v0);
  }
  return result;
}

BOOL specialized _ArrayBuffer.beginCOWMutation()()
{
  uint64_t v1 = *v0;
  BOOL result = swift_isUniquelyReferenced_nonNull_native(*v0);
  *uint64_t v0 = v1;
  return result;
}

Swift::Bool __swiftcall _ArrayBuffer.beginCOWMutation()()
{
  uint64_t v2 = *(uint64_t **)(v0 + 16);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v2, v2);
  uint64_t v4 = *v1;
  if (isClassOrObjCExistentialType)
  {
    int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(*v1);
    *uint64_t v1 = v4;
    if (isUniquelyReferenced_nonNull_bridgeObject)
    {
      BOOL v6 = _swift_isClassOrObjCExistentialType((uint64_t)v2, v2);
      BOOL v8 = (v4 & 0x4000000000000000LL) == 0 && v4 >= 0;
      LOBYTE(isUniquelyReferenced_nonNull_bridgeObject) = !v6 || v8;
    }
  }

  else
  {
    LOBYTE(isUniquelyReferenced_nonNull_bridgeObject) = swift_isUniquelyReferenced_nonNull_native(*v1);
    *uint64_t v1 = v4;
  }

  return isUniquelyReferenced_nonNull_bridgeObject;
}

uint64_t _ArrayBuffer._isNative.getter(uint64_t a1, uint64_t *a2)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  BOOL v5 = (a1 & 0x4000000000000000LL) == 0 && a1 >= 0;
  return !isClassOrObjCExistentialType || v5;
}

__objc2_class **_ArrayBuffer._asCocoaArray()(int64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      uint64_t v13 = (void *)a1;
    }
    else {
      uint64_t v13 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    return (__objc2_class **)swift_unknownObjectRetain(v13, v4, v5, v6);
  }

  else
  {
    else {
      uint64_t v10 = (unint64_t *)a1;
    }
    swift_bridgeObjectRetain(a1, v7, v8, v9);
    return _ContiguousArrayBuffer._asCocoaArray()(v10, a2, v11);
  }

Swift::Bool __swiftcall _fastPath(_:)(Swift::Bool a1)
{
  return a1;
}

__objc2_class **_ContiguousArrayBuffer._asCocoaArray()(unint64_t *a1, uint64_t *a2, void *a3)
{
  if (one-time initialization token for _bridgeInitializedSuccessfully != -1) {
    swift_once( &one-time initialization token for _bridgeInitializedSuccessfully,  (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully,  a3);
  }
  if (!_bridgeInitializedSuccessfully) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0x82uLL,  0);
  }
  _orphanedFoundationSubclassesReparented = 1;
  if (a1[2])
  {
    if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
    {
      uint64_t v7 = type metadata accessor for _ContiguousArrayStorage(0LL, (uint64_t)a2, v5, v6);
      swift_retain(a1, v8, v9, v10);
      _swift_setClassMetadata(v7, a1);
      swift_release((uint64_t)a1);
    }

    else
    {
      uint64_t v11 = type metadata accessor for __StaticArrayStorage();
      else {
        uint64_t v14 = type metadata accessor for __SwiftDeferredNSArray();
      }
      uint64_t v15 = swift_allocObject(v14, 0x20uLL, 7uLL);
      v15[2] = 0LL;
      v15[3] = a1;
      return (__objc2_class **)v15;
    }
  }

  else
  {
    swift_release((uint64_t)a1);
    return &_swiftEmptyArrayStorage;
  }

  return (__objc2_class **)a1;
}

id _ArrayBuffer._nonNative.getter(uint64_t a1)
{
  uint64_t v1 = (void *)specialized _ArrayBuffer._nonNative.getter(a1);
  return swift_unknownObjectRetain(v1, v2, v3, v4);
}

__objc2_class **specialized _ArrayBuffer._consumeAndCreateNew()(uint64_t a1)
{
  return specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(a1 + 16),  0,  a1);
}

{
  return specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(a1 + 16),  0,  a1);
}

{
  return specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(a1 + 16),  0,  a1);
}

{
  return specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(a1 + 16),  0,  a1);
}

uint64_t specialized _ArrayBuffer._consumeAndCreateNew()(uint64_t a1)
{
  uint64_t v1 = a1;
  if ((unint64_t)a1 >> 62)
  {
    if (a1 >= 0) {
      a1 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    id v2 = objc_msgSend((id)a1, sel_count);
  }

  else
  {
    id v2 = *(id *)((a1 & 0xFFFFFFFFFFFFF8LL) + 0x10);
  }

  return specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0,  (uint64_t)v2,  0,  v1);
}

uint64_t _ArrayBuffer._consumeAndCreateNew()(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      uint64_t v8 = (void *)a1;
    }
    else {
      uint64_t v8 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v6 = objc_msgSend(v8, sel_count);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v5 = a1;
    }
    id v6 = *(id *)(v5 + 16);
  }

  return _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (uint64_t)v6, 0, a1, a2);
}

__objc2_class **specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **result, int64_t a2, char a3, uint64_t a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  size_t v8 = *(void *)(a4 + 16);
  uint64_t v9 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v8, v7);
  uint64_t v10 = (char *)(v9 + 4);
  if ((v5 & 1) != 0)
  {
    specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(a4 + 32),  v8,  v10,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v10, a4);
  }

  swift_bridgeObjectRelease(a4);
  return v9;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __objc2_class **v9;
  char *v10;
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  size_t v8 = *(void *)(a4 + 16);
  uint64_t v9 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v8, v7);
  uint64_t v10 = (char *)(v9 + 4);
  if ((v5 & 1) != 0)
  {
    specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v8, v10);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v10, a4);
  }

  swift_bridgeObjectRelease(a4);
  return v9;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = *(void *)(a4 + 24);
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    size_t v8 = *(void *)(a4 + 16);
    if (v7 <= v8) {
      uint64_t v9 = *(void *)(a4 + 16);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String.Index>();
      uint64_t v11 = (__objc2_class **)swift_allocObject(v10, 8 * v9 + 32, 7uLL);
      uint64_t v12 = _swift_stdlib_malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 25;
      }
      v11[2] = (__objc2_class *)v8;
      v11[3] = (__objc2_class *)(2 * (v13 >> 3));
      uint64_t v14 = (char *)(v11 + 4);
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = &_swiftEmptyArrayStorage;
      uint64_t v14 = (char *)&_swiftEmptySetSingleton;
      if ((result & 1) != 0)
      {
LABEL_15:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v8, v14);
        *(void *)(a4 + 16) = 0LL;
LABEL_18:
        swift_bridgeObjectRelease(a4);
        return v11;
      }
    }

    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v14, a4);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  size_t v12;
  char *v13;
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = *(void *)(a4 + 24);
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    size_t v8 = *(void *)(a4 + 16);
    if (v7 <= v8) {
      uint64_t v9 = *(void *)(a4 + 16);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Bool>();
      uint64_t v11 = (__objc2_class **)swift_allocObject(v10, v9 + 32, 7uLL);
      uint64_t v12 = _swift_stdlib_malloc_size(v11);
      v11[2] = (__objc2_class *)v8;
      v11[3] = (__objc2_class *)(2 * v12 - 64);
      uint64_t v13 = (char *)(v11 + 4);
      if ((v5 & 1) != 0)
      {
LABEL_13:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v8, v13);
        *(void *)(a4 + 16) = 0LL;
LABEL_16:
        swift_bridgeObjectRelease(a4);
        return v11;
      }
    }

    else
    {
      uint64_t v11 = &_swiftEmptyArrayStorage;
      uint64_t v13 = (char *)&_swiftEmptySetSingleton;
    }

    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v13, a4);
    goto LABEL_16;
  }

  __break(1u);
  return result;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  size_t v8 = *(void *)(a4 + 16);
  if (v7 <= v8) {
    uint64_t v9 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>();
    uint64_t v11 = (__objc2_class **)swift_allocObject(v10, 16 * v9 + 32, 7uLL);
    uint64_t v12 = _swift_stdlib_malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    v11[2] = (__objc2_class *)v8;
    v11[3] = (__objc2_class *)(2 * (v13 >> 4));
  }

  else
  {
    uint64_t v11 = &_swiftEmptyArrayStorage;
  }

  uint64_t v14 = (char *)(v11 + 4);
  uint64_t v15 = (char *)(a4 + 32);
  if ((v5 & 1) != 0)
  {
    specialized UnsafeMutablePointer.moveInitialize(from:count:)(v15, v8, v14);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    specialized UnsafeMutablePointer.initialize(from:count:)(v15, v8, v14);
  }

  swift_bridgeObjectRelease(a4);
  return v11;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = *(void *)(a4 + 24);
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    size_t v8 = *(void *)(a4 + 16);
    if (v7 <= v8) {
      uint64_t v9 = *(void *)(a4 + 16);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
      uint64_t v11 = (__objc2_class **)swift_allocObject(v10, 32 * v9 + 32, 7uLL);
      uint64_t v12 = _swift_stdlib_malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 1;
      }
      v11[2] = (__objc2_class *)v8;
      v11[3] = (__objc2_class *)(2 * (v13 >> 5));
      uint64_t v14 = (char *)(v11 + 4);
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = &_swiftEmptyArrayStorage;
      uint64_t v14 = (char *)&_swiftEmptySetSingleton;
      if ((result & 1) != 0)
      {
LABEL_15:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v8, v14);
        *(void *)(a4 + 16) = 0LL;
LABEL_18:
        swift_bridgeObjectRelease(a4);
        return v11;
      }
    }

    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v14, a4);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = *(void *)(a4 + 24);
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    size_t v8 = *(void *)(a4 + 16);
    if (v7 <= v8) {
      uint64_t v9 = *(void *)(a4 + 16);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Range<Int>>();
      uint64_t v11 = (__objc2_class **)swift_allocObject(v10, 16 * v9 + 32, 7uLL);
      uint64_t v12 = _swift_stdlib_malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 17;
      }
      v11[2] = (__objc2_class *)v8;
      v11[3] = (__objc2_class *)(2 * (v13 >> 4));
      uint64_t v14 = (char *)(v11 + 4);
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = &_swiftEmptyArrayStorage;
      uint64_t v14 = (char *)&_swiftEmptySetSingleton;
      if ((result & 1) != 0)
      {
LABEL_15:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v8, v14);
        *(void *)(a4 + 16) = 0LL;
LABEL_18:
        swift_bridgeObjectRelease(a4);
        return v11;
      }
    }

    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v14, a4);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

{
  char v5;
  unint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  size_t v12;
  char *v13;
  char *v14;
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    uint64_t v7 = a2;
  }

  size_t v8 = *(void *)(a4 + 16);
  if (v7 <= v8) {
    uint64_t v9 = *(void *)(a4 + 16);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
    uint64_t v11 = (__objc2_class **)swift_allocObject(v10, v9 + 32, 7uLL);
    uint64_t v12 = _swift_stdlib_malloc_size(v11);
    v11[2] = (__objc2_class *)v8;
    v11[3] = (__objc2_class *)(2 * v12 - 64);
  }

  else
  {
    uint64_t v11 = &_swiftEmptyArrayStorage;
  }

  uint64_t v13 = (char *)(v11 + 4);
  uint64_t v14 = (char *)(a4 + 32);
  if ((v5 & 1) != 0)
  {
    specialized UnsafeMutablePointer.moveInitialize(from:count:)( v14,  v8,  v13,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  0x416uLL);
    *(void *)(a4 + 16) = 0LL;
  }

  else
  {
    specialized UnsafeMutablePointer.initialize(from:count:)(v14, v8, v13);
  }

  swift_bridgeObjectRelease(a4);
  return v11;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = *(void *)(a4 + 24);
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    size_t v8 = *(void *)(a4 + 16);
    if (v7 <= v8) {
      uint64_t v9 = *(void *)(a4 + 16);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>();
      uint64_t v11 = (__objc2_class **)swift_allocObject(v10, 8 * v9 + 32, 7uLL);
      uint64_t v12 = _swift_stdlib_malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 25;
      }
      v11[2] = (__objc2_class *)v8;
      v11[3] = (__objc2_class *)(2 * (v13 >> 3));
      uint64_t v14 = (char *)(v11 + 4);
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = &_swiftEmptyArrayStorage;
      uint64_t v14 = (char *)&_swiftEmptySetSingleton;
      if ((result & 1) != 0)
      {
LABEL_15:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v8, v14);
        *(void *)(a4 + 16) = 0LL;
LABEL_18:
        swift_bridgeObjectRelease(a4);
        return v11;
      }
    }

    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v14, a4);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

{
  char v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __objc2_class **v11;
  int64_t v12;
  uint64_t v13;
  char *v14;
  char v5 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = a2;
    goto LABEL_8;
  }

  unint64_t v6 = *(void *)(a4 + 24);
  uint64_t v7 = v6 >> 1;
  if (v7 + 0x4000000000000000LL >= 0)
  {
    uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    size_t v8 = *(void *)(a4 + 16);
    if (v7 <= v8) {
      uint64_t v9 = *(void *)(a4 + 16);
    }
    else {
      uint64_t v9 = v7;
    }
    if (v9)
    {
      uint64_t v10 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_V>();
      uint64_t v11 = (__objc2_class **)swift_allocObject(v10, 8 * v9 + 32, 7uLL);
      uint64_t v12 = _swift_stdlib_malloc_size(v11);
      uint64_t v13 = v12 - 32;
      if (v12 < 32) {
        uint64_t v13 = v12 - 25;
      }
      v11[2] = (__objc2_class *)v8;
      v11[3] = (__objc2_class *)(2 * (v13 >> 3));
      uint64_t v14 = (char *)(v11 + 4);
      if ((v5 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
      uint64_t v11 = &_swiftEmptyArrayStorage;
      uint64_t v14 = (char *)&_swiftEmptySetSingleton;
      if ((result & 1) != 0)
      {
LABEL_15:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v8, v14);
        *(void *)(a4 + 16) = 0LL;
LABEL_18:
        swift_bridgeObjectRelease(a4);
        return v11;
      }
    }

    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v8, v14, a4);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

uint64_t specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( char a1, uint64_t a2, char a3, uint64_t a4)
{
  unint64_t v8 = (unint64_t)a4 >> 62;
  if ((unint64_t)a4 >> 62)
  {
    if (a4 < 0) {
      uint64_t v18 = (void *)a4;
    }
    else {
      uint64_t v18 = (void *)(a4 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t result = (uint64_t)objc_msgSend(v18, sel_count);
    if ((a3 & 1) == 0) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t result = *(void *)((a4 & 0xFFFFFFFFFFFFF8LL) + 0x18) >> 1;
    if ((a3 & 1) == 0) {
      goto LABEL_9;
    }
  }

  if (result >= a2)
  {
    a2 = result;
    goto LABEL_9;
  }

  if (result + 0x4000000000000000LL >= 0)
  {
    if (2 * result > a2) {
      a2 = 2 * result;
    }
LABEL_9:
    if (v8)
    {
      if (a4 < 0) {
        uint64_t v11 = (void *)a4;
      }
      else {
        uint64_t v11 = (void *)(a4 & 0xFFFFFFFFFFFFFF8LL);
      }
      uint64_t v10 = (uint64_t)objc_msgSend(v11, sel_count);
    }

    else
    {
      uint64_t v10 = *(void *)((a4 & 0xFFFFFFFFFFFFF8LL) + 0x10);
    }

    if (a2 <= v10) {
      a2 = v10;
    }
    if (a2)
    {
      uint64_t v12 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
      uint64_t v13 = (__objc2_class **)swift_allocObject(v12, 8 * a2 + 32, 7uLL);
      int64_t v14 = _swift_stdlib_malloc_size(v13);
      uint64_t v15 = v14 - 32;
      if (v14 < 32) {
        uint64_t v15 = v14 - 25;
      }
      v13[2] = (__objc2_class *)v10;
      v13[3] = (__objc2_class *)((2 * (v15 >> 3)) | 1);
      if ((a1 & 1) != 0) {
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v13 = &_swiftEmptyArrayStorage;
      if ((a1 & 1) != 0)
      {
LABEL_21:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)((a4 & 0xFFFFFFFFFFFFFF8LL) + 32),  v10,  (char *)v13 + 32);
        *(void *)((a4 & 0xFFFFFFFFFFFFFF8LL) + 0x10) = 0LL;
LABEL_30:
        swift_bridgeObjectRelease(a4);
        return (uint64_t)v13;
      }
    }

    if (v10 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    uint64_t v16 = (void **)(v13 + 4);
    if (v8)
    {
      if (a4 < 0) {
        uint64_t v17 = (void *)a4;
      }
      else {
        uint64_t v17 = (void *)(a4 & 0xFFFFFFFFFFFFFF8LL);
      }
      specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)(0LL, v10, v16, v17);
    }

    else
    {
      specialized UnsafeMutablePointer.initialize(from:count:)( (char *)((a4 & 0xFFFFFFFFFFFFFF8LL) + 32),  v10,  (char *)v16);
    }

    goto LABEL_30;
  }

  __break(1u);
  return result;
}

__objc2_class **specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **result, int64_t a2, char a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  char v8 = (char)result;
  if ((a3 & 1) == 0)
  {
    uint64_t v10 = a2;
    goto LABEL_8;
  }

  unint64_t v9 = *(void *)(a4 + 24);
  uint64_t v10 = v9 >> 1;
  if (v10 + 0x4000000000000000LL >= 0)
  {
    uint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
LABEL_8:
    uint64_t v11 = *(void *)(a4 + 16);
    if (v10 <= v11) {
      uint64_t v12 = *(void *)(a4 + 16);
    }
    else {
      uint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(a5);
      int64_t v14 = (__objc2_class **)swift_allocObject(v13, 40 * v12 + 32, 7uLL);
      size_t v15 = _swift_stdlib_malloc_size(v14);
      v14[2] = (__objc2_class *)v11;
      v14[3] = (__objc2_class *)(2 * ((uint64_t)(v15 - 32) / 40));
      uint64_t v16 = (char *)(v14 + 4);
      if ((v8 & 1) != 0)
      {
LABEL_13:
        specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(a4 + 32), v11, v16);
        *(void *)(a4 + 16) = 0LL;
LABEL_16:
        swift_bridgeObjectRelease(a4);
        return v14;
      }
    }

    else
    {
      int64_t v14 = &_swiftEmptyArrayStorage;
      uint64_t v16 = (char *)&_swiftEmptySetSingleton;
    }

    specialized _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v11, v16, a4, a6);
    goto LABEL_16;
  }

  __break(1u);
  return result;
}

uint64_t _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( char a1, uint64_t a2, char a3, uint64_t a4, uint64_t *a5)
{
  uint64_t result = (uint64_t)_ArrayBuffer.capacity.getter(a4, a5);
  if ((a3 & 1) == 0)
  {
    uint64_t v11 = a2;
    goto LABEL_8;
  }

  uint64_t v11 = result;
  if (result >= a2)
  {
LABEL_8:
    if (_swift_isClassOrObjCExistentialType((uint64_t)a5, a5) && (a4 < 0 || (a4 & 0x4000000000000000LL) != 0))
    {
      if (a4 < 0) {
        uint64_t v33 = (void *)a4;
      }
      else {
        uint64_t v33 = (void *)(a4 & 0xFFFFFFFFFFFFFF8LL);
      }
      uint64_t v14 = (uint64_t)objc_msgSend(v33, sel_count);
    }

    else
    {
      BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
      uint64_t v13 = a4 & 0xFFFFFFFFFFFFF8LL;
      if (!isClassOrObjCExistentialType) {
        uint64_t v13 = a4;
      }
      uint64_t v14 = *(void *)(v13 + 16);
    }

    if (v11 <= v14) {
      uint64_t v11 = v14;
    }
    if (v11)
    {
      uint64_t v15 = getContiguousArrayStorageType<A>(for:)((uint64_t)a5, a5);
      uint64_t v16 = *(a5 - 1);
      uint64_t v17 = *(void *)(v16 + 72);
      uint64_t v18 = *(unsigned __int8 *)(v16 + 80);
      id v19 = (__objc2_class **)swift_allocObject( v15,  ((v18 + *(unsigned int *)(v15 + 48)) & ~v18) + v17 * v11,  v18 | *(unsigned __int16 *)(v15 + 52));
      size_t v20 = _swift_stdlib_malloc_size(v19);
      if (!v17) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
      }
      int64_t v24 = v20 - ((v18 + 32) & ~v18);
      if (v24 == 0x8000000000000000LL && v17 == -1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
      }
      uint64_t v26 = v24 / v17;
      swift_retain((unint64_t *)v19, v21, v22, v23);
      BOOL v27 = _swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
      v19[2] = (__objc2_class *)v14;
      v19[3] = (__objc2_class *)(v27 | (unint64_t)(2 * v26));
      swift_release((uint64_t)v19);
      if ((a1 & 1) != 0) {
        goto LABEL_23;
      }
    }

    else
    {
      id v19 = &_swiftEmptyArrayStorage;
      if ((a1 & 1) != 0)
      {
LABEL_23:
        uint64_t v28 = *(unsigned __int8 *)(*(a5 - 1) + 80);
        uint64_t v29 = (v28 + 32) & ~v28;
        else {
          uint64_t v30 = a4;
        }
        UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v30 + v29), v14, (char *)v19 + v29, (uint64_t)a5);
        else {
          uint64_t v31 = a4;
        }
        *(void *)(v31 + 16) = 0LL;
        swift_bridgeObjectRelease(a4);
        return (uint64_t)v19;
      }
    }

    if (v14 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    uint64_t v32 = *(unsigned __int8 *)(*(a5 - 1) + 80);
    _ArrayBuffer._copyContents(subRange:initializing:)(0LL, v14, (char *)v19 + ((v32 + 32) & ~v32), a4, a5);
    return (uint64_t)v19;
  }

  if (result + 0x4000000000000000LL >= 0)
  {
    if (2 * result <= a2) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = 2 * result;
    }
    goto LABEL_8;
  }

  __break(1u);
  return result;
}

__objc2_class **specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( uint64_t a1, uint64_t a2)
{
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(scalar: Unicode.Scalar, normData: Unicode._NormData)>);
  char v5 = swift_allocObject(v4, 8 * v2 + 32, 7uLL);
  int64_t v6 = _swift_stdlib_malloc_size(v5);
  uint64_t v7 = v6 - 32;
  if (v6 < 32) {
    uint64_t v7 = v6 - 25;
  }
  v5[2] = a1;
  v5[3] = 2 * (v7 >> 3);
  return (__objc2_class **)v5;
}

{
  uint64_t v2;
  uint64_t v4;
  void *v5;
  size_t v6;
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
  char v5 = swift_allocObject(v4, v2 + 32, 7uLL);
  int64_t v6 = _swift_stdlib_malloc_size(v5);
  v5[2] = a1;
  v5[3] = 2 * v6 - 64;
  return (__objc2_class **)v5;
}

{
  uint64_t v2;
  uint64_t v4;
  void *v5;
  int64_t v6;
  int64_t v7;
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt16>();
  char v5 = swift_allocObject(v4, 2 * v2 + 32, 7uLL);
  int64_t v6 = _swift_stdlib_malloc_size(v5);
  uint64_t v7 = v6 - 32;
  if (v6 < 32) {
    uint64_t v7 = v6 - 31;
  }
  v5[2] = a1;
  v5[3] = v7 & 0xFFFFFFFFFFFFFFFELL;
  return (__objc2_class **)v5;
}

{
  uint64_t v2;
  uint64_t v4;
  void *v5;
  int64_t v6;
  uint64_t v7;
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>();
  char v5 = swift_allocObject(v4, 8 * v2 + 32, 7uLL);
  int64_t v6 = _swift_stdlib_malloc_size(v5);
  uint64_t v7 = v6 - 32;
  if (v6 < 32) {
    uint64_t v7 = v6 - 25;
  }
  v5[2] = a1;
  v5[3] = 2 * (v7 >> 3);
  return (__objc2_class **)v5;
}

{
  uint64_t v2;
  uint64_t v4;
  void *v5;
  int64_t v6;
  uint64_t v7;
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
  char v5 = swift_allocObject(v4, 8 * v2 + 32, 7uLL);
  int64_t v6 = _swift_stdlib_malloc_size(v5);
  uint64_t v7 = v6 - 32;
  if (v6 < 32) {
    uint64_t v7 = v6 - 25;
  }
  v5[2] = a1;
  v5[3] = (2 * (v7 >> 3)) | 1;
  return (__objc2_class **)v5;
}

__objc2_class **specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  if (a2 <= a1) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a2;
  }
  if (!v3) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v5 = a3(0LL);
  int64_t v6 = swift_allocObject(v5, 16 * v3 + 32, 7uLL);
  int64_t v7 = _swift_stdlib_malloc_size(v6);
  uint64_t v8 = v7 - 32;
  if (v7 < 32) {
    uint64_t v8 = v7 - 17;
  }
  v6[2] = a1;
  v6[3] = 2 * (v8 >> 4);
  return (__objc2_class **)v6;
}

{
  uint64_t v3;
  uint64_t v5;
  void *v6;
  int64_t v7;
  uint64_t v8;
  if (a2 <= a1) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a2;
  }
  if (!v3) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v5 = a3(0LL);
  int64_t v6 = swift_allocObject(v5, 4 * v3 + 32, 7uLL);
  int64_t v7 = _swift_stdlib_malloc_size(v6);
  uint64_t v8 = v7 - 32;
  if (v7 < 32) {
    uint64_t v8 = v7 - 29;
  }
  v6[2] = a1;
  v6[3] = 2 * (v8 >> 2);
  return (__objc2_class **)v6;
}

__objc2_class **_ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a2 <= a1) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a2;
  }
  if (!v3) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v6 = getContiguousArrayStorageType<A>(for:)((uint64_t)a3, a3);
  uint64_t v7 = *(a3 - 1);
  uint64_t v8 = *(void *)(v7 + 72);
  uint64_t v9 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v10 = swift_allocObject(v6, ((v9 + *(unsigned int *)(v6 + 48)) & ~v9) + v8 * v3, v9 | *(unsigned __int16 *)(v6 + 52));
  size_t v11 = _swift_stdlib_malloc_size(v10);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  int64_t v15 = v11 - ((v9 + 32) & ~v9);
  if (v15 == 0x8000000000000000LL && v8 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  uint64_t v17 = v15 / v8;
  swift_retain(v10, v12, v13, v14);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
  v10[2] = a1;
  v10[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v17);
  swift_release((uint64_t)v10);
  return (__objc2_class **)v10;
}

uint64_t _ContiguousArrayBuffer.firstElementAddress.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80LL);
  return a1 + ((v2 + 32) & ~v2);
}

char *specialized UnsafeMutablePointer.moveInitialize(from:count:)(char *__src, uint64_t a2, char *__dst)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  if (__dst != __src || &__src[16 * a2] <= __dst) {
    return (char *)memmove(__dst, __src, 16 * a2);
  }
  return __src;
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  if (__dst != __src || &__src[4 * a2] <= __dst) {
    return (char *)memmove(__dst, __src, 4 * a2);
  }
  return __src;
}

{
  size_t v3;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  uint64_t v3 = 8 * a2;
  if (__dst != __src || &__src[v3] <= __dst) {
    return (char *)memmove(__dst, __src, v3);
  }
  return __src;
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  if (__dst != __src || &__src[8 * a2] <= __dst) {
    return (char *)memmove(__dst, __src, 8 * a2);
  }
  return __src;
}

{
  size_t v3;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  uint64_t v3 = 32 * a2;
  if (__dst != __src || &__src[v3] <= __dst) {
    return (char *)memmove(__dst, __src, v3);
  }
  return __src;
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  if (__dst != __src || &__src[32 * a2] <= __dst) {
    return (char *)memmove(__dst, __src, 32 * a2);
  }
  return __src;
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  if (__dst != __src || &__src[40 * a2] <= __dst) {
    return (char *)memmove(__dst, __src, 40 * a2);
  }
  return __src;
}

char *specialized UnsafeMutablePointer.moveInitialize(from:count:)(char *__src, size_t __len, char *__dst)
{
  if ((__len & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  if (__dst != __src || &__src[__len] <= __dst) {
    return (char *)memmove(__dst, __src, __len);
  }
  return __src;
}

char *UnsafeMutablePointer.moveInitialize(from:count:)(char *__src, uint64_t a2, char *__dst, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.moveInitialize with negative count",  55LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x416uLL,  0);
  }
  if (__dst < __src || &__src[*(void *)(*(void *)(a4 - 8) + 72LL) * a2] <= __dst) {
    return swift_arrayInitWithTakeFrontToBack(__dst, __src, a2, a4);
  }
  if (__dst != __src) {
    return swift_arrayInitWithTakeBackToFront(__dst, __src, a2, a4);
  }
  return __src;
}

uint64_t static Comparable...< infix(_:_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return static Comparable...< infix(_:_:)( a1,  a2,  a3,  a4,  "Swift/Range.swift",  17LL,  0x2F2uLL,  (uint64_t (*)(void, uint64_t, uint64_t))type metadata accessor for Range,  a5);
}

BOOL _BridgeStorage.isNative.getter(uint64_t a1)
{
  return (a1 & 0x4000000000000000LL) == 0 && a1 >= 0;
}

Swift::Void __swiftcall _ArrayBuffer._typeCheckSlowPath(_:)(Swift::Int a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v6 = *((void *)v2 - 1);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v109 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  size_t v11 = (char *)&v109 - v10;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v12, v12) && (v4 < 0 || (v4 & 0x4000000000000000LL) != 0))
  {
    if (v4 < 0) {
      uint64_t v16 = (void *)v4;
    }
    else {
      uint64_t v16 = (void *)(v4 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v17 = objc_msgSend(v16, sel_objectAtIndex_, a1);
    v109._uint64_t countAndFlagsBits = (uint64_t)v17;
    swift_unknownObjectRetain(v17, v18, v19, v20);
    if (swift_dynamicCast(v9, &v109._countAndFlagsBits, (swift *)&unk_189B8D230, v3, 6uLL))
    {
      swift_unknownObjectRelease(v17);
      (*(void (**)(char *, const char *))(v6 + 8))(v9, v3);
      return;
    }

    v109._uint64_t countAndFlagsBits = specialized static String._createEmpty(withInitialCapacity:)(85LL);
    v109._uint64_t object = v84;
    v85._uint64_t countAndFlagsBits = 0xD000000000000046LL;
    v85._uint64_t object = (void *)(0x80000001818B4920LL | 0x8000000000000000LL);
    String.append(_:)(v85);
    swift_bridgeObjectRelease(0x80000001818B4920LL | 0x8000000000000000LL);
    TypeName = (uint64_t *)swift_getTypeName((unint64_t)v3, 0);
    if ((v87 & 0x8000000000000000LL) == 0)
    {
      uint64_t v88 = (uint8x16_t *)TypeName;
      int64_t v89 = v87;
      int64_t v90 = validateUTF8(_:)(TypeName, v87);
      uint64_t v93 = (v92 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v88->i8, v89, v90, v91)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v88, v89, v90 & 1);
      uint64_t v95 = v94;
      String.append(_:)(*(Swift::String *)&v93);
      swift_bridgeObjectRelease(v95);
      Swift::String v96 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" but found ", 0xBuLL, 1);
      uint64_t object = (uint64_t)v96._object;
      String.append(_:)(v96);
      swift_bridgeObjectRelease(object);
      unint64_t ObjectType = swift_getObjectType((unint64_t)v17);
      v99 = (uint64_t *)swift_getTypeName(ObjectType, 0);
      if ((v100 & 0x8000000000000000LL) == 0)
      {
        uint64_t v101 = (uint8x16_t *)v99;
        int64_t v102 = v100;
        int64_t v103 = validateUTF8(_:)(v99, v100);
        if ((v105 & 1) != 0) {
          uint64_t v106 = repairUTF8(_:firstKnownBrokenRange:)(v101->i8, v102, v103, v104);
        }
        else {
          uint64_t v106 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v101, v102, v103 & 1);
        }
        uint64_t v108 = v107;
        String.append(_:)(*(Swift::String *)&v106);
        swift_bridgeObjectRelease(v108);
        _assertionFailure(_:_:flags:)( "Fatal error",  11LL,  2LL,  (char *)v109._countAndFlagsBits,  (unint64_t)v109._object,  0);
      }
    }

    goto LABEL_92;
  }

  int64_t v15 = *(void **)((v4 & 0xFFFFFFFFFFFFF8LL) + 8 * a1 + 0x20);
  v109._uint64_t countAndFlagsBits = (uint64_t)v15;
  swift_unknownObjectRetain_n((uint64_t)v15, 2LL, v13, v14);
  if (!swift_dynamicCast(v11, &v109._countAndFlagsBits, (swift *)&unk_189B8D230, v3, 6uLL))
  {
    uint64_t v21 = specialized static String._createEmpty(withInitialCapacity:)(82LL);
    uint64_t v23 = v22;
    v109._uint64_t countAndFlagsBits = v21;
    v109._uint64_t object = (void *)v22;
    uint64_t v24 = HIBYTE(v22) & 0xF;
    if ((v22 & 0x2000000000000000LL) == 0) {
      uint64_t v24 = v21 & 0xFFFFFFFFFFFFLL;
    }
    if (v24 || (v21 & ~v22 & 0x2000000000000000LL) != 0)
    {
      if ((v22 & 0x2000000000000000LL) != 0
        && (0x80000001818B48D0LL & 0x2000000000000000LL) != 0
        && (unint64_t v25 = specialized _SmallString.init(_:appending:)( v21,  v22,  0xD000000000000043LL,  0x80000001818B48D0LL | 0x8000000000000000LL),  (v27 & 1) == 0))
      {
        uint64_t v28 = v25;
        uint64_t v29 = v26;
        swift_bridgeObjectRelease(v23);
        swift_bridgeObjectRelease(0x80000001818B48D0LL | 0x8000000000000000LL);
        v109._uint64_t countAndFlagsBits = v28;
        v109._uint64_t object = v29;
      }

      else
      {
        if ((0x80000001818B48D0LL & 0x2000000000000000LL) != 0) {
          unint64_t v30 = (0x80000001818B48D0LL >> 56) & 0xF;
        }
        else {
          unint64_t v30 = 67LL;
        }
        _StringGuts.append(_:)(0xD000000000000043LL, 0x80000001818B48D0LL | 0x8000000000000000LL, 0LL, v30);
        swift_bridgeObjectRelease(0x80000001818B48D0LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v22);
      v109._uint64_t countAndFlagsBits = 0xD000000000000043LL;
      v109._uint64_t object = (void *)(0x80000001818B48D0LL | 0x8000000000000000LL);
    }

    uint64_t v31 = (uint64_t *)swift_getTypeName((unint64_t)v3, 0);
    if (v32 < 0) {
      goto LABEL_92;
    }
    uint64_t v33 = (uint8x16_t *)v31;
    int64_t v34 = v32;
    int64_t v35 = validateUTF8(_:)(v31, v32);
    if ((v37 & 1) != 0) {
      unint64_t v38 = repairUTF8(_:firstKnownBrokenRange:)(v33->i8, v34, v35, v36);
    }
    else {
      unint64_t v38 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v33, v34, v35 & 1);
    }
    uint64_t countAndFlagsBits = v38;
    unint64_t v41 = v39;
    uint64_t v42 = v109._object;
    unint64_t v43 = ((unint64_t)v109._object >> 56) & 0xF;
    if (!v43 && (v109._countAndFlagsBits & ~(uint64_t)v109._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v109._object);
      v109._uint64_t countAndFlagsBits = countAndFlagsBits;
      v109._uint64_t object = (void *)v41;
      goto LABEL_43;
    }

    if (((uint64_t)v109._object & 0x2000000000000000LL) != 0)
    {
      if ((v39 & 0x2000000000000000LL) != 0)
      {
        unint64_t v45 = specialized _SmallString.init(_:appending:)( v109._countAndFlagsBits,  (unint64_t)v109._object,  v38,  v39);
        if ((v47 & 1) == 0)
        {
          uint64_t v48 = v45;
          uint64_t v49 = v46;
          swift_bridgeObjectRelease((uint64_t)v42);
          swift_bridgeObjectRelease(v41);
          v109._uint64_t countAndFlagsBits = v48;
          v109._uint64_t object = v49;
          unint64_t v41 = (unint64_t)v49;
          uint64_t countAndFlagsBits = v48;
          goto LABEL_43;
        }

        goto LABEL_41;
      }
    }

    else if ((v39 & 0x2000000000000000LL) != 0)
    {
LABEL_41:
      uint64_t v44 = HIBYTE(v41) & 0xF;
      goto LABEL_42;
    }

    uint64_t v44 = v38 & 0xFFFFFFFFFFFFLL;
LABEL_42:
    _StringGuts.append(_:)(countAndFlagsBits, v41, 0LL, v44);
    swift_bridgeObjectRelease(v41);
    uint64_t countAndFlagsBits = v109._countAndFlagsBits;
    unint64_t v41 = (unint64_t)v109._object;
LABEL_43:
    Swift::String v50 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" but found ", 0xBuLL, 1);
    uint64_t v51 = HIBYTE(v41) & 0xF;
    if ((v41 & 0x2000000000000000LL) == 0) {
      uint64_t v51 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v51 && (countAndFlagsBits & ~v41 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v41);
      Swift::String v109 = v50;
      goto LABEL_57;
    }

    if ((v41 & 0x2000000000000000LL) != 0)
    {
      if (((uint64_t)v50._object & 0x2000000000000000LL) != 0)
      {
        unint64_t v53 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v41,  v50._countAndFlagsBits,  (unint64_t)v50._object);
        if ((v55 & 1) == 0)
        {
          uint64_t v56 = v53;
          unint64_t v57 = v54;
          swift_bridgeObjectRelease(v41);
          swift_bridgeObjectRelease((uint64_t)v50._object);
          v109._uint64_t countAndFlagsBits = v56;
          v109._uint64_t object = v57;
          goto LABEL_57;
        }

        goto LABEL_55;
      }
    }

    else if (((uint64_t)v50._object & 0x2000000000000000LL) != 0)
    {
LABEL_55:
      uint64_t v52 = ((unint64_t)v50._object >> 56) & 0xF;
      goto LABEL_56;
    }

    uint64_t v52 = v50._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_56:
    _StringGuts.append(_:)(v50._countAndFlagsBits, (unint64_t)v50._object, 0LL, v52);
    swift_bridgeObjectRelease((uint64_t)v50._object);
LABEL_57:
    unint64_t v58 = swift_getObjectType((unint64_t)v15);
    int v59 = (uint64_t *)swift_getTypeName(v58, 0);
    if ((v60 & 0x8000000000000000LL) == 0)
    {
      int v61 = (uint8x16_t *)v59;
      int64_t v62 = v60;
      int64_t v63 = validateUTF8(_:)(v59, v60);
      if ((v65 & 1) != 0) {
        unint64_t v66 = repairUTF8(_:firstKnownBrokenRange:)(v61->i8, v62, v63, v64);
      }
      else {
        unint64_t v66 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v61, v62, v63 & 1);
      }
      uint64_t v68 = v66;
      unint64_t v69 = v67;
      uint64_t v70 = v109._object;
      unint64_t v71 = ((unint64_t)v109._object >> 56) & 0xF;
      if (!v71 && (v109._countAndFlagsBits & ~(uint64_t)v109._object & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease((uint64_t)v109._object);
        v109._uint64_t countAndFlagsBits = v68;
        v109._uint64_t object = (void *)v69;
        goto LABEL_75;
      }

      if (((uint64_t)v109._object & 0x2000000000000000LL) != 0)
      {
        if ((v67 & 0x2000000000000000LL) != 0)
        {
          unint64_t v73 = specialized _SmallString.init(_:appending:)( v109._countAndFlagsBits,  (unint64_t)v109._object,  v66,  v67);
          if ((v75 & 1) == 0)
          {
            uint64_t v76 = v73;
            uint64_t v77 = v74;
            swift_bridgeObjectRelease((uint64_t)v70);
            swift_bridgeObjectRelease(v69);
            v109._uint64_t countAndFlagsBits = v76;
            v109._uint64_t object = v77;
            unint64_t v69 = (unint64_t)v77;
            uint64_t v68 = v76;
            goto LABEL_75;
          }

          goto LABEL_73;
        }
      }

      else if ((v67 & 0x2000000000000000LL) != 0)
      {
LABEL_73:
        uint64_t v72 = HIBYTE(v69) & 0xF;
        goto LABEL_74;
      }

      uint64_t v72 = v66 & 0xFFFFFFFFFFFFLL;
LABEL_74:
      _StringGuts.append(_:)(v68, v69, 0LL, v72);
      swift_bridgeObjectRelease(v69);
      uint64_t v68 = v109._countAndFlagsBits;
      unint64_t v69 = (unint64_t)v109._object;
LABEL_75:
      uint64_t v78 = HIBYTE(v69) & 0xF;
      if ((v69 & 0x2000000000000000LL) == 0) {
        uint64_t v78 = v68 & 0xFFFFFFFFFFFFLL;
      }
      if (v78 || (v68 & ~v69 & 0x2000000000000000LL) != 0)
      {
        if ((v69 & 0x2000000000000000LL) == 0
          || (unint64_t v81 = specialized _SmallString.init(_:appending:)(v68, v69, 0LL, 0xE000000000000000LL), (v83 & 1) != 0))
        {
          _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
          swift_bridgeObjectRelease(0xE000000000000000LL);
          v79 = (char *)v109._countAndFlagsBits;
          v80 = v109._object;
        }

        else
        {
          v79 = (char *)v81;
          v80 = v82;
          swift_bridgeObjectRelease(v69);
          swift_bridgeObjectRelease(0xE000000000000000LL);
        }
      }

      else
      {
        swift_bridgeObjectRelease(v69);
        v79 = 0LL;
        v80 = (void *)0xE000000000000000LL;
      }

      _assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, v79, (unint64_t)v80, 0);
    }

LABEL_92:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  swift_unknownObjectRelease(v15);
  (*(void (**)(char *, const char *))(v6 + 8))(v11, v3);
}

    swift_release(v23);
    char *v117 = (uint64_t)v35;
    Swift::String v85 = v35[5];
    v86 = *((void *)a1 + 3);
    uint64_t v87 = *((void *)a1 + 4);
    __swift_project_boxed_opaque_existential_0Tm(a1, v86);
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v87 + 8))(&v123, v86, v87);
    uint64_t v88 = *((void *)&v124 + 1);
    int64_t v89 = v125;
    __swift_project_boxed_opaque_existential_0Tm(&v123, *((uint64_t *)&v124 + 1));
    int64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v89 + 40))(v85, v88, v89);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v123);
    int64_t v91 = -1LL << *((_BYTE *)v35 + 32);
    uint64_t v13 = v90 & ~v91;
    char v92 = v35 + 7;
    uint64_t v29 = v13 >> 6;
    unint64_t v30 = 1LL << v13;
    if (((1LL << v13) & v35[(v13 >> 6) + 7]) != 0)
    {
      uint64_t v93 = ~v91;
      do
      {
        uint64_t v94 = v35;
        outlined init with copy of AnyHashable(v35[6] + 40 * v13, (uint64_t)&v123);
        uint64_t v95 = *((void *)&v124 + 1);
        Swift::String v96 = v125;
        __swift_project_boxed_opaque_existential_0Tm(&v123, *((uint64_t *)&v124 + 1));
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v96 + 8))(v120, v95, v96);
        unint64_t v97 = v121;
        v98 = v122;
        __swift_project_boxed_opaque_existential_0Tm(v120, v121);
        v99 = *((void *)a1 + 3);
        uint64_t v100 = *((void *)a1 + 4);
        __swift_project_boxed_opaque_existential_0Tm(a1, v99);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v100 + 8))(v119, v99, v100);
        uint64_t v101 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v98 + 16))(v119, v97, v98);
        __swift_destroy_boxed_opaque_existential_1Tm(v119);
        if (v101 == 2)
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v120);
          outlined destroy of AnyHashable((uint64_t *)&v123);
        }

        else
        {
          __swift_destroy_boxed_opaque_existential_1Tm(v120);
          outlined destroy of AnyHashable((uint64_t *)&v123);
          if ((v101 & 1) != 0)
          {
            if (v115)
            {
              uint64_t v28 = (void *)*v117;
              goto LABEL_100;
            }

  swift_bridgeObjectRelease(v10);
  unint64_t v73 = 0xA000000000000000LL;
  if (!(v9 & 0x8080808080808080LL | rawBits & 0x80808080808080LL)) {
    unint64_t v73 = 0xE000000000000000LL;
  }
  a2 = v73 & 0xFF00000000000000LL | (v20 << 56) | rawBits & 0xFFFFFFFFFFFFFFLL;
  a1 = v9;
LABEL_108:
  int64_t v91 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    int64_t v91 = a1;
  }
  char v92 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    char v92 = 11LL;
  }
  *uint64_t v4 = 15LL;
  v4[1] = v92 | (v91 << 16);
  v4[2] = a1;
  v4[3] = a2;
}

  uint64_t v121 = v274;
  char v122 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000LL) == 0) {
    char v122 = v273 & 0xFFFFFFFFFFFFLL;
  }
  if (v122 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
  {
    if ((v274 & 0x2000000000000000LL) == 0
      || (uint64_t v123 = specialized _SmallString.init(_:appending:)(v273, v274, 0x202CuLL, 0xE200000000000000LL),
          (v117 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v116, v117, v118);
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      uint64_t v124 = v123;
      v125 = v116;
      swift_bridgeObjectRelease(v121);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      v273 = v124;
      v274 = v125;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = 8236LL;
    v274 = 0xE200000000000000LL;
  }

  v102(1LL, v103, AssociatedConformanceWitness);
  v268 = (uint64_t *)v2;
  v126 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v126, v33, v3);
  v127 = v268;
  v128 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  char v129 = (void *)swift_getDynamicType(v128, v127, 1);
  LODWORD(v127) = swift_isOptionalType(v129);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if (!(_DWORD)v127)
  {
    unint64_t v142 = v261;
    memcpy(v261, v33, v3);
    if ((swift_dynamicCast((char *)&v267, v142, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
    {
      v143 = v267._object;
      String.append(_:)(v267);
      swift_bridgeObjectRelease((uint64_t)v143);
    }

    else
    {
      v147 = v257;
      memcpy(v257, v33, v3);
      uint64_t v148 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
      if (swift_dynamicCast((char *)&v270, v147, v2, v148, 6uLL))
      {
        outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
        v149 = (uint64_t)v268;
        v150 = v269;
        __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
        (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v150 + 8))( &v273,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v149,  v150);
        __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      }

      else
      {
        v272 = 0LL;
        v270 = 0u;
        v271 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for TextOutputStreamable?);
        v222 = v254;
        memcpy(v254, v33, v3);
        v223 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
        if (swift_dynamicCast((char *)&v270, v222, v2, v223, 6uLL)
          || (v272 = 0LL,
              v270 = 0u,
              v271 = 0u,
              outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomStringConvertible?),  v224 = v250,  memcpy(v250, v33, v3),  v225 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v270, v224, v2, v225, 6uLL)))
        {
          outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
          goto LABEL_102;
        }

        v272 = 0LL;
        v270 = 0u;
        v271 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((void *)&v271 + 1) = v2;
        v237 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
        memcpy(v237, v33, v3);
        Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
        v238 = v267._object;
        v239 = v269;
        ((void (*)(char *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v33,  &v267,  &v273,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
        swift_release(v239);
        swift_release((uint64_t)v238);
      }
    }

    v138 = v264;
    goto LABEL_115;
  }

  v130 = v266;
  memcpy(v266, v33, v3);
  v131 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  swift_dynamicCast((char *)&v267, v130, v2, v131, 7uLL);
LABEL_102:
  uint64_t v132 = (uint64_t)v268;
  BOOL v133 = v269;
  __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  v135 = (*(uint64_t (**)(uint64_t, uint64_t))(v133 + 8))(v132, v133);
  char v136 = v134;
  v137 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000LL) == 0) {
    v137 = v273 & 0xFFFFFFFFFFFFLL;
  }
  if (v137 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(v135, v134);
    swift_bridgeObjectRelease(v136);
  }

  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = v135;
    v274 = v136;
  }

  v138 = v264;
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
LABEL_115:
  v151 = v274;
  unint64_t v152 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000LL) == 0) {
    unint64_t v152 = v273 & 0xFFFFFFFFFFFFLL;
  }
  if (v152 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
  {
    if ((v274 & 0x2000000000000000LL) == 0
      || (v153 = specialized _SmallString.init(_:appending:)(v273, v274, 0x202CuLL, 0xE200000000000000LL),
          (v140 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v139, v140, v141);
      _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      unint64_t v154 = v153;
      v155 = v139;
      swift_bridgeObjectRelease(v151);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      v273 = v154;
      v274 = v155;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = 8236LL;
    v274 = 0xE200000000000000LL;
  }

  v156 = v265;
  v102(2LL, v103, AssociatedConformanceWitness);
  v268 = (uint64_t *)v2;
  uint64_t v157 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v157, v156, v3);
  v158 = v268;
  v159 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  v160 = (void *)swift_getDynamicType(v159, v158, 1);
  LODWORD(v158) = swift_isOptionalType(v160);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if ((_DWORD)v158)
  {
    v161 = v266;
    memcpy(v266, v156, v3);
    v162 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v267, v161, v2, v162, 7uLL);
LABEL_125:
    v163 = (uint64_t)v268;
    v164 = v269;
    __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
    v166 = (*(uint64_t (**)(uint64_t, uint64_t))(v164 + 8))(v163, v164);
    v167 = v165;
    v168 = HIBYTE(v274) & 0xF;
    if ((v274 & 0x2000000000000000LL) == 0) {
      v168 = v273 & 0xFFFFFFFFFFFFLL;
    }
    if (v168 || (v273 & ~v274 & 0x2000000000000000LL) != 0)
    {
      _StringGuts.append(_:)(v166, v165);
      swift_bridgeObjectRelease(v167);
    }

    else
    {
      swift_bridgeObjectRelease(v274);
      v273 = v166;
      v274 = v167;
    }

    goto LABEL_130;
  }

  v172 = v262;
  memcpy(v262, v156, v3);
  if ((swift_dynamicCast((char *)&v267, v172, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v173 = v267._object;
    String.append(_:)(v267);
    swift_bridgeObjectRelease((uint64_t)v173);
  }

  else
  {
    v201 = v258;
    memcpy(v258, v156, v3);
    v202 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v270, v201, v2, v202, 6uLL))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      v203 = (uint64_t)v268;
      v204 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v204 + 8))( &v273,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v203,  v204);
LABEL_130:
      __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      goto LABEL_133;
    }

    v272 = 0LL;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v226 = v255;
    memcpy(v255, v156, v3);
    v227 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v270, v226, v2, v227, 6uLL)
      || (v272 = 0LL,
          v270 = 0u,
          v271 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomStringConvertible?),  v228 = v251,  memcpy(v251, v156, v3),  v229 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v270, v228, v2, v229, 6uLL)))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      goto LABEL_125;
    }

    v272 = 0LL;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v270,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v271 + 1) = v2;
    v240 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
    memcpy(v240, v156, v3);
    Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
    v241 = v267._object;
    v242 = v156;
    v243 = v269;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v242,  &v267,  &v273,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v243);
    swift_release((uint64_t)v241);
  }

  v176 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000LL) == 0) {
    v176 = v407 & 0xFFFFFFFFFFFFLL;
  }
  v177 = v381;
  if (v176 || (v407 & ~v408 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000LL);
    swift_bridgeObjectRelease(0xE200000000000000LL);
  }

  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236LL;
    v408 = 0xE200000000000000LL;
  }

  v145(2LL, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v178 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v178, v177, v3);
  v179 = v402;
  v180 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  v181 = (void *)swift_getDynamicType(v180, v179, 1);
  LODWORD(v179) = swift_isOptionalType(v181);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v179)
  {
    memcpy(v101, v177, v3);
    uint64_t v182 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v182, 7uLL);
LABEL_99:
    v183 = (uint64_t)v402;
    v184 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    uint64_t v185 = (*(uint64_t (**)(uint64_t, uint64_t))(v184 + 8))(v183, v184);
    v187 = v186;
    specialized String.write<A>(to:)(&v407, v185, v186, v188);
    swift_bridgeObjectRelease(v187);
LABEL_100:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_103;
  }

  v189 = v373;
  memcpy(v373, v177, v3);
  if ((swift_dynamicCast((char *)&v401, v189, v2, (const char *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v190 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v190);
  }

  else
  {
    v290 = v367;
    memcpy(v367, v177, v3);
    v291 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v290, v2, v291, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v292 = (uint64_t)v402;
      v293 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v293 + 8))( &v407,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  v292,  v293);
      goto LABEL_100;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for TextOutputStreamable?);
    v314 = v361;
    memcpy(v361, v177, v3);
    v315 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v314, v2, v315, 6uLL)
      || (v406 = 0LL,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomStringConvertible?),  v316 = v355,  memcpy(v355, v177, v3),  v317 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible),  swift_dynamicCast((char *)&v404, v316, v2, v317, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_99;
    }

    v406 = 0LL;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v404,  &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v405 + 1) = v2;
    v337 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v337, v177, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v338 = v401._object;
    v339 = v177;
    v340 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, swift *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))( v339,  &v401,  &v407,  0LL,  v2,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation);
    swift_release(v340);
    swift_release((uint64_t)v338);
  }

      *((void *)a1 + 1) = v17 + 24;
      *(_WORD *)(v17 + 16) = 80;
      *(_BYTE *)(v17 + 18) = 4;
      *(void *)id v17 = v23;
      break;
    case 'p':
      if (v14 >= v12) {
        return 0LL;
      }
      uint64_t result = 0LL;
      uint64_t v32 = v13 + 2;
      *((void *)a1 + 9) = v13 + 2;
      switch(*(_BYTE *)(v15 + v14))
      {
        case 'd':
          uint64_t v33 = a1;
          int64_t v34 = (swift::Demangle::__runtime::Node *)v7;
          int64_t v35 = 3;
          return swift::Demangle::__runtime::Demangler::addFuncSpecParamNumber(v33, v34, v35, a4, a5);
        case 'f':
          uint64_t v48 = a1;
          uint64_t v49 = 0LL;
          goto LABEL_106;
        case 'g':
          uint64_t v48 = a1;
          uint64_t v49 = 1LL;
          goto LABEL_106;
        case 'i':
          uint64_t v33 = a1;
          int64_t v34 = (swift::Demangle::__runtime::Node *)v7;
          int64_t v35 = 2;
          return swift::Demangle::__runtime::Demangler::addFuncSpecParamNumber(v33, v34, v35, a4, a5);
        case 'k':
          uint64_t v48 = a1;
          uint64_t v49 = 9LL;
LABEL_106:
          uint64_t result = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v48, 80, v49);
          if (result) {
            goto LABEL_107;
          }
          return result;
        case 's':
          if (v32 >= v12) {
            return 0LL;
          }
          *((void *)a1 + 9) = v13 + 3;
          Swift::String v50 = *(char *)(v15 + v32);
          switch(v50)
          {
            case 'b':
              uint64_t v51 = "u8";
              break;
            case 'c':
              uint64_t v51 = "objc";
              break;
            case 'w':
              uint64_t v51 = "u16";
              break;
            default:
              return 0LL;
          }

          Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a1, 80, 4LL);
          if (Node) {
            swift::Demangle::__runtime::Node::addChild((unsigned int *)v7, Node, a1, v53, v54);
          }
          uint64_t result = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a1, 81, v51);
          if (!result) {
            return result;
          }
LABEL_107:
          id v17 = (unint64_t)result;
          break;
        default:
          return result;
      }

      break;
    case 'r':
      id v17 = (v7 + 31) & 0xFFFFFFFFFFFFFFF8LL;
      if (v17) {
        int64_t v36 = v17 + 24 > v8;
      }
      else {
        int64_t v36 = 1;
      }
      if (v36)
      {
        char v37 = 2LL * *((void *)a1 + 4);
        if (v37 <= 0x20) {
          char v37 = 32LL;
        }
        *((void *)a1 + 4) = v37;
        unint64_t v38 = v37 + 8;
        unint64_t v39 = malloc(v37 + 8);
        void *v39 = *((void *)a1 + 3);
        id v17 = ((unint64_t)v39 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)a1 + 2) = (char *)v39 + v38;
        *((void *)a1 + 3) = v39;
      }

      *((void *)a1 + 1) = v17 + 24;
      *(_WORD *)(v17 + 16) = 80;
      *(_BYTE *)(v17 + 18) = 4;
      *(void *)id v17 = 8LL;
      break;
    case 's':
      id v17 = (v7 + 31) & 0xFFFFFFFFFFFFFFF8LL;
      if (v17) {
        uint64_t v40 = v17 + 24 > v8;
      }
      else {
        uint64_t v40 = 1;
      }
      if (v40)
      {
        unint64_t v41 = 2LL * *((void *)a1 + 4);
        if (v41 <= 0x20) {
          unint64_t v41 = 32LL;
        }
        *((void *)a1 + 4) = v41;
        uint64_t v42 = v41 + 8;
        unint64_t v43 = malloc(v41 + 8);
        *unint64_t v43 = *((void *)a1 + 3);
        id v17 = ((unint64_t)v43 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)a1 + 2) = (char *)v43 + v42;
        *((void *)a1 + 3) = v43;
      }

      *((void *)a1 + 1) = v17 + 24;
      *(_WORD *)(v17 + 16) = 80;
      *(_BYTE *)(v17 + 18) = 4;
      *(void *)id v17 = 7LL;
      break;
    case 'x':
      id v17 = (v7 + 31) & 0xFFFFFFFFFFFFFFF8LL;
      if (v17) {
        uint64_t v28 = v17 + 24 > v8;
      }
      else {
        uint64_t v28 = 1;
      }
      if (v28)
      {
        uint64_t v29 = 2LL * *((void *)a1 + 4);
        if (v29 <= 0x20) {
          uint64_t v29 = 32LL;
        }
        *((void *)a1 + 4) = v29;
        unint64_t v30 = v29 + 8;
        uint64_t v31 = malloc(v29 + 8);
        *uint64_t v31 = *((void *)a1 + 3);
        id v17 = ((unint64_t)v31 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)a1 + 2) = (char *)v31 + v30;
        *((void *)a1 + 3) = v31;
      }

      *((void *)a1 + 1) = v17 + 24;
      *(_WORD *)(v17 + 16) = 80;
      *(_BYTE *)(v17 + 18) = 4;
      *(void *)id v17 = 256LL;
      break;
    default:
      return 0LL;
  }

  swift::Demangle::__runtime::Node::addChild((unsigned int *)v7, (swift::Demangle::__runtime::Node *)v17, a1, a4, a5);
  return (swift::Demangle::__runtime::Node *)v7;
}

uint64_t _ContiguousArrayBuffer.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + ((*(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(a3 - 8) + 80LL))
         + *(void *)(*(void *)(a3 - 8) + 72LL) * a1);
}

Swift::DefaultStringInterpolation __swiftcall DefaultStringInterpolation.init(literalCapacity:interpolationCount:)( Swift::Int literalCapacity, Swift::Int interpolationCount)
{
  if (interpolationCount + 0x4000000000000000LL < 0)
  {
    __break(1u);
    goto LABEL_5;
  }

  BOOL v2 = __OFADD__(literalCapacity, 2 * interpolationCount);
  literalCapacity += 2 * interpolationCount;
  if (v2)
  {
LABEL_5:
    __break(1u);
    goto _$ss26DefaultStringInterpolationV15literalCapacity18interpolationCountABSi_SitcfC;
  }

  literalCapacity = static String._createEmpty(withInitialCapacity:)(literalCapacity);
_$ss26DefaultStringInterpolationV15literalCapacity18interpolationCountABSi_SitcfC:
  result._storage._uint64_t object = (void *)interpolationCount;
  result._storage._uint64_t countAndFlagsBits = literalCapacity;
  return result;
}

Swift::String __swiftcall String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)( Builtin::RawPointer _builtinStringLiteral, Builtin::Word utf8CodeUnitCount, Builtin::Int1 isASCII)
{
  if ((utf8CodeUnitCount & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (utf8CodeUnitCount)
  {
    if (utf8CodeUnitCount <= 0xF)
    {
      int64_t v7 = utf8CodeUnitCount - 8;
      Builtin::Word v8 = 8LL;
      uint64_t v5 = *(unsigned __int8 *)_builtinStringLiteral;
      if (v8 != 1)
      {
        v5 |= (unint64_t)*((unsigned __int8 *)_builtinStringLiteral + 1) << 8;
        if (v8 != 2)
        {
          v5 |= (unint64_t)*((unsigned __int8 *)_builtinStringLiteral + 2) << 16;
          if (v8 != 3)
          {
            v5 |= (unint64_t)*((unsigned __int8 *)_builtinStringLiteral + 3) << 24;
            if (v8 != 4)
            {
              v5 |= (unint64_t)*((unsigned __int8 *)_builtinStringLiteral + 4) << 32;
              if (v8 != 5)
              {
                v5 |= (unint64_t)*((unsigned __int8 *)_builtinStringLiteral + 5) << 40;
                if (v8 != 6)
                {
                  v5 |= (unint64_t)*((unsigned __int8 *)_builtinStringLiteral + 6) << 48;
                  if (v8 != 7) {
                    v5 |= (unint64_t)*((unsigned __int8 *)_builtinStringLiteral + 7) << 56;
                  }
                }
              }
            }
          }
        }
      }

      uint64_t v9 = 0LL;
      if (utf8CodeUnitCount >= 9)
      {
        uint64_t v10 = 0LL;
        size_t v11 = (unsigned __int8 *)_builtinStringLiteral + 8;
        unint64_t v12 = v7 & ~(v7 >> 63);
        do
        {
          if (v12 <= utf8CodeUnitCount - 9) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
          }
          unsigned int v13 = *v11++;
          v9 |= (unint64_t)v13 << v10;
          v10 += 8LL;
          --v7;
        }

        while (v7);
      }

      unint64_t v14 = 0xA000000000000000LL;
      if (((v9 | v5) & 0x8080808080808080LL) == 0) {
        unint64_t v14 = 0xE000000000000000LL;
      }
      uint64_t v6 = (void *)(v14 | (utf8CodeUnitCount << 56) | v9);
    }

    else
    {
      Builtin::Word v4 = utf8CodeUnitCount | 0xC000000000000000LL;
      if (!isASCII) {
        Builtin::Word v4 = utf8CodeUnitCount;
      }
      uint64_t v5 = v4 | 0x1000000000000000LL;
      uint64_t v6 = (void *)(((unint64_t)_builtinStringLiteral + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    }
  }

  else
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = (void *)0xE000000000000000LL;
  }

  result._uint64_t object = v6;
  result._uint64_t countAndFlagsBits = v5;
  return result;
}

Swift::Void __swiftcall DefaultStringInterpolation.appendLiteral(_:)(Swift::String a1)
{
  uint64_t object = a1._object;
  uint64_t countAndFlagsBits = a1._countAndFlagsBits;
  unint64_t v6 = v3[1];
  uint64_t v7 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000LL) == 0) {
    uint64_t v7 = *v3 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 || (*v3 & ~v6 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(a1._countAndFlagsBits, (unint64_t)a1._object);
  }

  else
  {
    swift_bridgeObjectRetain((unint64_t)a1._object, (uint64_t)a1._object, v1, v2);
    swift_bridgeObjectRelease(v6);
    *uint64_t v3 = countAndFlagsBits;
    v3[1] = (uint64_t)object;
  }

void DefaultStringInterpolation.appendInterpolation(_:)(unint64_t a1)
{
  TypeName = (uint64_t *)swift_getTypeName(a1, 0);
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v3 = (uint8x16_t *)TypeName;
  int64_t v4 = v2;
  int64_t v5 = validateUTF8(_:)(TypeName, v2);
  if ((v7 & 1) != 0) {
    uint64_t v8 = repairUTF8(_:firstKnownBrokenRange:)(v3->i8, v4, v5, v6);
  }
  else {
    uint64_t v8 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v3, v4, v5 & 1);
  }
  uint64_t v10 = v9;
  String.append(_:)(*(Swift::String *)&v8);
  swift_bridgeObjectRelease(v10);
}

Swift::UInt32 __swiftcall _fatalErrorFlags()()
{
  return 0;
}

void _assertionFailure(_:_:flags:)( const char *a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5, int a6)
{
  if ((a3 & 1) != 0)
  {
    if ((unint64_t)a1 >> 32) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    }
    _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n( a1,  (uint64_t (*)(uint64_t *))partial apply for closure #1 in _assertionFailure(_:_:flags:));
    __break(1u);
  }

  else if (!a1)
  {
    unint64_t v7 = 136LL;
    goto LABEL_15;
  }

  uint64_t v8 = a2;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  int v9 = a6;
  unint64_t v10 = a5;
  uint64_t v11 = (uint64_t)a4;
  swift_bridgeObjectRetain(a5, a2, a3, a4);
  if ((v10 & 0x1000000000000000LL) != 0)
  {
    uint64_t v11 = specialized static String._copying(_:)(v11, v10);
    unint64_t v15 = v14;
    swift_bridgeObjectRelease(v10);
    unint64_t v10 = v15;
    if ((v15 & 0x2000000000000000LL) == 0)
    {
LABEL_11:
      if ((v11 & 0x1000000000000000LL) != 0)
      {
        unint64_t v12 = (const char *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v13 = v11 & 0xFFFFFFFFFFFFLL;
LABEL_13:
        closure #1 in closure #1 in _assertionFailure(_:_:flags:)(v12, v13, a1, v8, v9);
        swift_bridgeObjectRelease(v10);
        __break(1u);
LABEL_14:
        unint64_t v7 = 148LL;
LABEL_15:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v7,  0);
      }

LABEL_20:
      unint64_t v12 = (const char *)_StringObject.sharedUTF8.getter(v11, v10);
      goto LABEL_13;
    }
  }

  else if ((v10 & 0x2000000000000000LL) == 0)
  {
    goto LABEL_11;
  }

  v16[0] = v11;
  v16[1] = v10 & 0xFFFFFFFFFFFFFFLL;
  closure #1 in closure #1 in _assertionFailure(_:_:flags:)((const char *)v16, HIBYTE(v10) & 0xF, a1, v8, v9);
  swift_bridgeObjectRelease(v10);
  __break(1u);
  goto LABEL_20;
}

      uint64_t v19 = (const char *)_StringObject.sharedUTF8.getter(v18, v17);
      goto LABEL_13;
    }
  }

  else if ((v17 & 0x2000000000000000LL) == 0)
  {
    goto LABEL_11;
  }

  v23[0] = v18;
  v23[1] = v17 & 0xFFFFFFFFFFFFFFLL;
  closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)( (const char *)v23,  HIBYTE(v17) & 0xF,  v16,  v15,  v14,  a1,  v13,  a9,  v11);
  swift_bridgeObjectRelease(v17);
  __break(1u);
  goto LABEL_20;
}

    __break(1u);
    goto LABEL_21;
  }

  if (v8 < 0) {
    uint64_t v11 = (void *)*v2;
  }
  else {
    uint64_t v11 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
  }
  unint64_t v12 = objc_msgSend(v11, sel_count);
  if (__OFADD__(v12, 1LL))
  {
    __break(1u);
    goto LABEL_19;
  }

  int64_t v4 = a2[4];
  uint64_t v13 = _NativeDictionary.init(_:capacity:)(v11, (uint64_t)v12 + 1, v9, v10, v4);
  int64_t v34 = (uint64_t)v13;
  unint64_t v14 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
  uint64_t v16 = v13[2];
  id v17 = (v15 & 1) == 0;
  uint64_t v18 = (Swift::Int)v16 + v17;
  if (__OFADD__(v16, v17))
  {
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }

  uint64_t v3 = v14;
  uint64_t v19 = v15;
  if ((uint64_t)v13[3] < v18)
  {
    type metadata accessor for _NativeDictionary(0LL, (uint64_t)v9, (uint64_t)v10, v4);
    _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v18, 1);
    size_t v20 = __RawDictionaryStorage.find<A>(_:)(a1, (uint64_t)v9, v4);
    if ((v19 & 1) == (v21 & 1))
    {
      uint64_t v3 = v20;
      goto LABEL_10;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different dictionaries",  45LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x75CuLL,  0);
  }

  if ((a6 & 1) == 0) {
    goto LABEL_20;
  }
  if (a1 >= 0) {
    unint64_t v10 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    unint64_t v10 = a1;
  }
  uint64_t v11 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v10, v11)) {
    goto LABEL_21;
  }
  if (v7 >= 0) {
    v7 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(v7, v11)) {
LABEL_21:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v10 + 16) != *(void *)(v7 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different dictionaries",  45LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x2A2uLL,  0);
  }
  return a2 == a5;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different dictionaries",  45LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x770uLL,  0);
  }

  if ((a6 & 1) == 0) {
    goto LABEL_20;
  }
  if (a1 >= 0) {
    unint64_t v10 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    unint64_t v10 = a1;
  }
  uint64_t v11 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v10, v11)) {
    goto LABEL_21;
  }
  if (v7 >= 0) {
    v7 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(v7, v11)) {
LABEL_21:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v10 + 16) != *(void *)(v7 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different dictionaries",  45LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x2AFuLL,  0);
  }
  return a2 < a5;
}

        size_t v20 = 303LL;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v20,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if (a3 < 0
    || 1LL << *(_BYTE *)(a6 + 32) <= a3
    || ((*(void *)(a6 + (((unint64_t)a3 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> a3) & 1) == 0
    || *(_DWORD *)(a6 + 36) != (_DWORD)a4)
  {
    size_t v20 = 281LL;
    goto LABEL_7;
  }

        uint64_t v18 = 303LL;
LABEL_7:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v18,  0);
      }
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  if (a1 < 0
    || 1LL << *(_BYTE *)(a3 + 32) <= a1
    || ((*(void *)(a3 + (((unint64_t)a1 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> a1) & 1) == 0
    || *(_DWORD *)(a3 + 36) != (_DWORD)a2)
  {
    uint64_t v18 = 281LL;
    goto LABEL_7;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL))( v14,  *(void *)(a3 + 56) + *(void *)(*(void *)(a5 - 8) + 72LL) * a1,  a5);
}

    unint64_t v12 = (v21 - 1) & v21;
    uint64_t v19 = __clz(__rbit64(v21)) + (v14 << 6);
LABEL_21:
    uint64_t v23 = (unint64_t *)(v4[3].i64[0] + 16 * v19);
    uint64_t v24 = *v23;
    unint64_t v25 = v23[1];
    uint64_t v26 = v4[3].i64[1] + 40 * v19;
    if ((a2 & 1) != 0)
    {
      char v27 = *(_OWORD *)v26;
      uint64_t v28 = *(_OWORD *)(v26 + 16);
      uint64_t v31 = *(void *)(v26 + 32);
      v30[0] = v27;
      v30[1] = v28;
    }

    else
    {
      outlined init with copy of AnyHashable(v26, (uint64_t)v30);
      swift_bridgeObjectRetain(v25, v15, v16, v17);
    }

    specialized _NativeDictionary._unsafeInsertNew(key:value:)(v24, v25, (uint64_t)v30, v8);
  }

    unint64_t v12 = (v22 - 1) & v22;
    size_t v20 = __clz(__rbit64(v22)) + (v15 << 6);
LABEL_21:
    uint64_t v24 = (unint64_t *)(v4[3].i64[0] + 16 * v20);
    unint64_t v25 = *v24;
    uint64_t v26 = v24[1];
    char v27 = (_OWORD *)(v4[3].i64[1] + 32 * v20);
    if ((a2 & 1) != 0)
    {
      outlined init with take of Any(v27, v29);
    }

    else
    {
      outlined init with copy of Any((uint64_t)v27, (uint64_t)v29);
      swift_bridgeObjectRetain(v26, v16, v17, v18);
    }

    Swift::String result = (uint64_t)specialized _NativeDictionary._unsafeInsertNew(key:value:)(v25, v26, v29, v8);
  }

    unint64_t v12 = (v19 - 1) & v19;
    id v17 = __clz(__rbit64(v19)) + (v15 << 6);
LABEL_21:
    uint64_t v21 = v4[3].i64[0] + 40 * v17;
    if ((a2 & 1) != 0)
    {
      unint64_t v22 = *(_OWORD *)v21;
      uint64_t v23 = *(_OWORD *)(v21 + 16);
      char v27 = *(void *)(v21 + 32);
      v26[0] = v22;
      v26[1] = v23;
      outlined init with take of Any((_OWORD *)(v4[3].i64[1] + 32 * v17), v25);
    }

    else
    {
      outlined init with copy of AnyHashable(v21, (uint64_t)v26);
      outlined init with copy of Any(v4[3].i64[1] + 32 * v17, (uint64_t)v25);
    }

    Swift::String result = (uint64_t)specialized _NativeDictionary._unsafeInsertNew(key:value:)(v26, v25, v8);
  }

    unint64_t v12 = (v24 - 1) & v24;
    unint64_t v22 = __clz(__rbit64(v24)) + (v14 << 6);
LABEL_21:
    uint64_t v26 = v4[3].i64[0] + 40 * v22;
    if ((a2 & 1) != 0)
    {
      char v27 = *(_OWORD *)v26;
      uint64_t v28 = *(_OWORD *)(v26 + 16);
      uint64_t v32 = *(void *)(v26 + 32);
      v31[0] = v27;
      v31[1] = v28;
      uint64_t v29 = (uint64_t *)(v4[3].i64[1] + 16 * v22);
      uint64_t v16 = *v29;
      id v17 = v29[1];
    }

    else
    {
      outlined init with copy of AnyHashable(v26, (uint64_t)v31);
      unint64_t v15 = (uint64_t *)(v4[3].i64[1] + 16 * v22);
      uint64_t v16 = *v15;
      id v17 = v15[1];
      swift_bridgeObjectRetain(v17, v18, v19, v20);
    }

    specialized _NativeDictionary._unsafeInsertNew(key:value:)((uint64_t)v31, v16, v17, v8);
  }

  swift_release(v16);
  if (v48)
  {
    unint64_t v45 = 1LL << *(_BYTE *)(v16 + 32);
    uint64_t v3 = v47;
    uint64_t v21 = (uint64_t)v60;
    if (v45 > 63) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v45 + 63) >> 6, v35);
    }
    else {
      v35->i64[0] = -1LL << v45;
    }
    *(void *)(v16 + 16) = 0LL;
LABEL_26:
    swift_release(v16);
    goto LABEL_27;
  }

  swift_release(v16);
  uint64_t v3 = v47;
  uint64_t v21 = (uint64_t)v60;
LABEL_27:
  *uint64_t v3 = v21;
}

        unint64_t v22 = (v28 - 1) & v28;
        uint64_t v26 = __clz(__rbit64(v28)) + (v24 << 6);
      }

      (*(void (**)(char *, unint64_t, uint64_t))(v5 + 32))( v10,  *(void *)(v11 + 48) + *(void *)(v5 + 72) * v26,  v4);
      _NativeSet._unsafeInsertNew(_:)((uint64_t)v10, (uint64_t)v18, v4, v13);
    }
  }

  swift_release(v11);
  *uint64_t v3 = v18;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different sets",  37LL,  2,  "Swift/Set.swift",  15LL,  2,  0x589uLL,  0);
  }

  if ((a6 & 1) == 0) {
    goto LABEL_20;
  }
  if (a1 >= 0) {
    unint64_t v10 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    unint64_t v10 = a1;
  }
  uint64_t v11 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v10, v11)) {
    goto LABEL_21;
  }
  if (v7 >= 0) {
    v7 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(v7, v11)) {
LABEL_21:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v10 + 16) != *(void *)(v7 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different sets",  37LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1F5uLL,  0);
  }
  return a2 == a5;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different sets",  37LL,  2,  "Swift/Set.swift",  15LL,  2,  0x59DuLL,  0);
  }

  if ((a6 & 1) == 0) {
    goto LABEL_20;
  }
  if (a1 >= 0) {
    unint64_t v10 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    unint64_t v10 = a1;
  }
  uint64_t v11 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v10, v11)) {
    goto LABEL_21;
  }
  if (v7 >= 0) {
    v7 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(v7, v11)) {
LABEL_21:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  if (*(void *)(v10 + 16) != *(void *)(v7 + 16)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different sets",  37LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1FFuLL,  0);
  }
  return a2 < a5;
}

    char v27 = (v33 - 1) & v33;
    uint64_t v31 = __clz(__rbit64(v33)) + (v29 << 6);
LABEL_21:
    (*(void (**)(id *, unint64_t, uint64_t *))(v4 + 16))( v9,  *(void *)(v1[3] + 48) + *(void *)(v4 + 72) * v31,  v3);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3))
    {
      if (v59 != 8) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
      unint64_t v38 = *v9;
      swift_unknownObjectRetain(*v9, v35, v36, v37);
      (*(void (**)(id *, uint64_t *))(v4 + 8))(v9, v3);
      *(void *)(v60 + 8 * v31) = v38;
    }

    else
    {
      unint64_t v39 = v54;
      (*(void (**)(id *, id *, uint64_t *))(v4 + 32))(v54, v9, v3);
      uint64_t v42 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v39, v3, v40, v41);
      *(void *)(v60 + 8 * v31) = v42;
    }
  }

    unint64_t v14 = 1860LL;
LABEL_21:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v14,  0);
  }

  v16[0] = result;
  v16[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (a3 < 0) {
    goto LABEL_20;
  }
  if ((uint64_t)(HIBYTE(a2) & 0xF) < a4)
  {
LABEL_18:
    unint64_t v14 = 1861LL;
    goto LABEL_21;
  }

  if (a4 - a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (a4 != a3)
  {
    do
    {
      Swift::String result = a5(*((unsigned __int8 *)v16 + v8));
      if (v5) {
        break;
      }
      ++v8;
    }

    while (a4 != v8);
  }

  return result;
}

      if ((v10 & ~v9 & 0x2000000000000000LL) != 0
        && (isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL),
            unint64_t v10 = *v4,
            int v9 = v4[1],
            isUniquelyReferenced_nonNull_native))
      {
        uint64_t v21 = _StringGuts.nativeUnusedCapacity.getter(*v4, v4[1]);
        if ((v22 & 1) != 0)
        {
          uint64_t v93 = 258LL;
LABEL_97:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v93,  0);
        }

        if (v19 <= 15 && ((v9 & 0x2000000000000000LL) != 0 || v21 < v17))
        {
LABEL_38:
          uint64_t v32 = _StringGuts._convertedToSmall()(v10, v9);
          int64_t v34 = v33;
          v35._rawBits = (v16 << 16) | 1;
          v36._rawBits = 3LL;
          char v37 = specialized String.init(_:)(v36, v35, v8, v7);
          unint64_t v39 = v38;
          swift_bridgeObjectRelease(v7);
          uint64_t v40 = _StringGuts._convertedToSmall()(v37, v39);
          uint64_t v42 = v41;
          swift_bridgeObjectRelease(v39);
          unint64_t v43 = HIBYTE(v34) & 0xF;
          uint64_t v44 = HIBYTE(v42) & 0xF;
          unint64_t v45 = v44 + v43;
          if ((unint64_t)(v44 + v43) > 0xF)
          {
            uint64_t v93 = 266LL;
            goto LABEL_97;
          }

          int64_t v5 = v97;
          if (v44)
          {
            uint64_t v46 = 0;
            char v47 = 0LL;
            do
            {
              uint64_t v48 = v43 + v47;
              uint64_t v49 = v47 + 1;
              if (v47 >= 8) {
                Swift::String v50 = v42;
              }
              else {
                Swift::String v50 = v40;
              }
              uint64_t v51 = v50 >> (v46 & 0x38);
              uint64_t v52 = (8 * v43 + v46) & 0x38;
              unint64_t v53 = (-255LL << v52) - 1;
              uint64_t v54 = (unint64_t)v51 << v52;
              char v55 = v54 | v53 & v34;
              uint64_t v56 = v54 | v53 & v32;
              if (v48 < 8) {
                uint64_t v32 = v56;
              }
              else {
                int64_t v34 = v55;
              }
              v46 += 8;
              char v47 = v49;
            }

            while (v44 != v49);
          }

          swift_bridgeObjectRelease(v9);
          swift_bridgeObjectRelease(v7);
          unint64_t v57 = 0xA000000000000000LL;
          if (!(v32 & 0x8080808080808080LL | v34 & 0x80808080808080LL)) {
            unint64_t v57 = 0xE000000000000000LL;
          }
          unint64_t v58 = v57 & 0xFF00000000000000LL | (v45 << 56) | v34 & 0xFFFFFFFFFFFFFFLL;
          *int64_t v4 = v32;
          goto LABEL_79;
        }
      }

      else if (v19 <= 15)
      {
        goto LABEL_38;
      }

      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v19, v17);
      if ((v7 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignAppendInPlace(_:)(v8, v7, 0LL, v16);
        swift_bridgeObjectRelease_n(v7, 2LL);
        int64_t v5 = v97;
        goto LABEL_4;
      }

      swift_bridgeObjectRelease(v7);
      int64_t v5 = v97;
      if (v13)
      {
        __src[0] = v8;
        __src[1] = v7 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v23 = v4[1];
        uint64_t v24 = v23 & 0xFFFFFFFFFFFFFFFLL;
        unint64_t v25 = (v23 & 0xFFFFFFFFFFFFFFFLL) + 32;
        uint64_t v26 = (char *)(v25 + (*(void *)(v23 + 24) & 0xFFFFFFFFFFFFLL));
        memcpy(v26, __src, HIBYTE(v7) & 0xF);
        char v27 = *(void *)(v24 + 24);
        uint64_t v28 = (v27 & 0xFFFFFFFFFFFFLL) + v14;
        uint64_t v29 = v27 > -1 || (v7 & 0x4000000000000000LL) == 0;
        unint64_t v30 = v28 | 0xC000000000000000LL;
        if (v29) {
          unint64_t v30 = v28;
        }
        *(void *)(v24 + 24) = v30 | 0x3000000000000000LL;
        *(_BYTE *)(v25 + (v30 & 0xFFFFFFFFFFFFLL)) = 0;
        uint64_t v31 = *(void *)(v24 + 16);
        if (v31 < 0)
        {
          char v83 = (uint64_t *)((v25 + (v31 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
          v84 = *v83;
          const char *v83 = 0LL;
          swift_bridgeObjectRelease(v7);
          swift_release(v84);
        }

        else
        {
          swift_bridgeObjectRelease(v7);
        }

        *int64_t v4 = *(void *)(v24 + 24);
        goto LABEL_4;
      }

      if ((v8 & 0x1000000000000000LL) != 0)
      {
        unint64_t v71 = (char *)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        int64_t v91 = (char *)_StringObject.sharedUTF8.getter(v8, v7);
        if (v92 < __n) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
        }
        unint64_t v71 = v91;
        if (__n)
        {
          int64_t v5 = v97;
          uint64_t v72 = v8 & 0xFFFFFFFFFFFFLL;
          if (!v91) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
          }
          goto LABEL_65;
        }

        int64_t v5 = v97;
      }

      uint64_t v72 = v8 & 0xFFFFFFFFFFFFLL;
LABEL_65:
      unint64_t v73 = v4[1];
      char v74 = v73 & 0xFFFFFFFFFFFFFFFLL;
      char v75 = (v73 & 0xFFFFFFFFFFFFFFFLL) + 32;
      uint64_t v76 = (char *)(v75 + (*(void *)(v73 + 24) & 0xFFFFFFFFFFFFLL));
      if (&v76[v72] > v71 && v76 < &v71[v72]) {
        goto LABEL_93;
      }
      memcpy(v76, v71, v72);
      uint64_t v77 = *(void *)(v74 + 24);
      uint64_t v78 = (v77 & 0xFFFFFFFFFFFFLL) + v72;
      if (((v77 & v8 & 0x8000000000000000LL) != 0LL) != v18) {
        v78 |= 0xC000000000000000LL;
      }
      v79 = v78 | 0x3000000000000000LL;
      *(void *)(v74 + 24) = v78 | 0x3000000000000000LL;
      *(_BYTE *)(v75 + (v78 & 0xFFFFFFFFFFFFLL)) = 0;
      v80 = *(void *)(v74 + 16);
      if (v80 < 0)
      {
        unint64_t v81 = (uint64_t *)((v75 + (v80 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
        unint64_t v82 = *v81;
        char *v81 = 0LL;
        swift_release(v82);
        v79 = *(void *)(v74 + 24);
      }

      *int64_t v4 = v79;
      swift_bridgeObjectRelease(v7);
LABEL_4:
      ++v5;
    }

    while (v5 != v96);
  }

  uint64_t v18 = v10 + v11;
  if (v12 < v10 + v11) {
    uint64_t v18 = v7 >> 16;
  }
  uint64_t v19 = v18 << 16;
  size_t v20 = v18 & 0xFFFFFFFFFFFFLL;
  uint64_t v21 = v5 & 0x1000000000000000LL;
  if ((v18 & 0xFFFFFFFFFFFFLL) == v12)
  {
    unint64_t v22 = 0LL;
LABEL_39:
    v19 |= v22 << 8;
    goto LABEL_40;
  }

  if (!v21)
  {
    if ((v5 & 0x2000000000000000LL) != 0)
    {
      unint64_t v30 = v6;
      uint64_t v31 = v5 & 0xFFFFFFFFFFFFFFLL;
      if (v20 + 1 == (HIBYTE(v5) & 0xF)) {
        goto LABEL_38;
      }
      unint64_t v25 = *(unsigned __int16 *)((char *)&v30 + v20);
LABEL_33:
      if (v25 == 2573 || (v25 & 0x8080) != 0) {
        goto LABEL_46;
      }
LABEL_38:
      uint64_t v21 = 0LL;
      unint64_t v22 = 1LL;
      goto LABEL_39;
    }

    if ((v6 & 0x1000000000000000LL) != 0)
    {
      uint64_t v23 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v24 = v6 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v23 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
    }

    if (v20 + 1 == v24) {
      goto LABEL_38;
    }
    if (v23)
    {
      unint64_t v25 = *(unsigned __int16 *)&v23[v20];
      goto LABEL_33;
    }

  id v17 = v9 + v10;
  uint64_t v18 = v17 << 16;
  uint64_t v19 = v17 & 0xFFFFFFFFFFFFLL;
  size_t v20 = v5 & 0x1000000000000000LL;
  if ((v17 & 0xFFFFFFFFFFFFLL) == v11)
  {
    uint64_t v21 = 0LL;
LABEL_39:
    v18 |= v21 << 8;
    goto LABEL_40;
  }

  if (!v20)
  {
    if ((v5 & 0x2000000000000000LL) != 0)
    {
      uint64_t v29 = v6;
      unint64_t v30 = v5 & 0xFFFFFFFFFFFFFFLL;
      if (v19 + 1 == (HIBYTE(v5) & 0xF)) {
        goto LABEL_38;
      }
      uint64_t v24 = *(unsigned __int16 *)((char *)&v29 + v19);
LABEL_33:
      if (v24 == 2573 || (v24 & 0x8080) != 0) {
        goto LABEL_46;
      }
LABEL_38:
      size_t v20 = 0LL;
      uint64_t v21 = 1LL;
      goto LABEL_39;
    }

    if ((v6 & 0x1000000000000000LL) != 0)
    {
      unint64_t v22 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v23 = v6 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      unint64_t v22 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
    }

    if (v19 + 1 == v23) {
      goto LABEL_38;
    }
    if (v22)
    {
      uint64_t v24 = *(unsigned __int16 *)&v22[v19];
      goto LABEL_33;
    }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
    }

  *char v27 = v18;
  return result;
}

  v125 = v32;
  unint64_t v57 = v30(a3, a4);
  unint64_t v58 = v32(a3, a4);
  if ((v57 & 1) != 0)
  {
    if (v58 > 64) {
      goto LABEL_22;
    }
  }

  else if (v58 > 63)
  {
LABEL_22:
    v127 = 128LL;
    int v61 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    int64_t v62 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
    v61(&v127, &type metadata for Int, v62, a3, a4);
    LOBYTE(v61) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    Swift::String result = v63(v29, a3);
LABEL_31:
    char v55 = 0LL;
    uint64_t v56 = 0LL;
    uint64_t v54 = v123;
    goto LABEL_51;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  Swift::String result = v63(v29, a3);
  if (v78 > 128) {
    goto LABEL_31;
  }
LABEL_23:
  int64_t v64 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  char v65 = v121;
  v64(v121, a2, a3);
  unint64_t v66 = v124(a3, a4);
  unint64_t v67 = (void (*)(char *, char *, uint64_t))v64;
  v64(v25, (uint64_t)v65, a3);
  if ((v66 & 1) == 0)
  {
    uint64_t v77 = v25;
    unint64_t v69 = v120;
    uint64_t v70 = v121;
    goto LABEL_33;
  }

  uint64_t v68 = v125(a3, a4);
  v63(v25, a3);
  unint64_t v69 = v120;
  uint64_t v70 = v121;
  if (v68 < 65) {
    goto LABEL_34;
  }
  unint64_t v71 = v114;
  v67(v114, v121, a3);
  v127 = 0x8000000000000000LL;
  uint64_t v72 = v124;
  if ((v124(a3, a4) & 1) == 0)
  {
    char v92 = v72(a3, a4);
    uint64_t v93 = v125(a3, a4);
    if ((v92 & 1) != 0)
    {
      if (v93 > 64)
      {
        Swift::String v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
        v96(&v127, &type metadata for Int, v97, a3, a4);
        unint64_t v71 = v114;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v114,  v29,  a3);
        goto LABEL_56;
      }

      char v105 = AssociatedTypeWitness;
      int64_t v104 = (void (**)(char *, uint64_t, const char *))v117;
      uint64_t v106 = swift_getAssociatedConformanceWitness( (uint64_t)v117,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v107 = v115;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v106 + 8))( &unk_18180BE68,  256LL,  v105,  v106);
      v104[3](v107, a3, (const char *)v104);
      uint64_t v108 = v114;
      LOBYTE(v104) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v114,  v29,  a3);
      v63(v29, a3);
      Swift::String v109 = v113;
      v67(v113, v108, a3);
      if ((v104 & 1) != 0)
      {
        v63(v109, a3);
        goto LABEL_68;
      }

      uint64_t v110 = v127;
      v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v63(v109, a3);
      char v47 = v111 < v110;
      uint64_t v70 = v121;
      uint64_t v77 = v114;
      if (!v47) {
        goto LABEL_33;
      }
    }

    else
    {
      if (v93 >= 64)
      {
        uint64_t v77 = v114;
        goto LABEL_33;
      }

      int64_t v102 = v114;
      v67(v29, v114, a3);
      int64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v63(v29, a3);
      uint64_t v77 = v102;
      if (v103 >= v127) {
        goto LABEL_33;
      }
    }

  uint64_t v121 = v32;
  char v55 = v30(a3, a4);
  uint64_t v56 = v32(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64) {
      goto LABEL_22;
    }
LABEL_25:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    int64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    int v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    Swift::String result = v61(v29, a3);
    if (v62 <= 8) {
      goto LABEL_27;
    }
LABEL_26:
    LOBYTE(v54) = 0;
    goto LABEL_51;
  }

  if (v56 <= 63) {
    goto LABEL_25;
  }
LABEL_22:
  uint64_t v123 = 8LL;
  int v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  uint64_t v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v123, &type metadata for Int, v60, a3, a4);
  LOBYTE(v59) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
  int v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  Swift::String result = v61(v29, a3);
LABEL_27:
  int64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  int64_t v64 = v117;
  v63(v117, a2, a3);
  char v65 = v120(a3, a4);
  unint64_t v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    uint64_t v76 = v25;
    uint64_t v68 = v116;
    unint64_t v69 = v117;
    goto LABEL_34;
  }

  unint64_t v67 = v121(a3, a4);
  v61(v25, a3);
  uint64_t v68 = v116;
  unint64_t v69 = v117;
  if (v67 < 65) {
    goto LABEL_35;
  }
  uint64_t v70 = v111;
  v66(v111, v117, a3);
  uint64_t v123 = 0x8000000000000000LL;
  unint64_t v71 = v120;
  if ((v120(a3, a4) & 1) == 0)
  {
    int64_t v90 = v71(a3, a4);
    int64_t v91 = v121(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 > 64)
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v94(&v123, &type metadata for Int, v95, a3, a4);
        uint64_t v70 = v111;
        Swift::String v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v29,  a3);
        goto LABEL_56;
      }

      int64_t v103 = AssociatedTypeWitness;
      int64_t v102 = (void (**)(char *, uint64_t, const char *))v114;
      int64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v105 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
      v102[3](v105, a3, (const char *)v102);
      uint64_t v106 = v111;
      LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v29,  a3);
      v61(v29, a3);
      uint64_t v107 = v110;
      v66(v110, v106, a3);
      if ((v102 & 1) != 0)
      {
        v61(v107, a3);
        goto LABEL_70;
      }

      uint64_t v108 = v123;
      Swift::String v109 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v107, a3);
      char v47 = v109 < v108;
      unint64_t v69 = v117;
      uint64_t v76 = v111;
      if (!v47) {
        goto LABEL_34;
      }
    }

    else
    {
      if (v91 > 64)
      {
        uint64_t v76 = v111;
        goto LABEL_34;
      }

      uint64_t v100 = v111;
      v66(v29, v111, a3);
      uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      uint64_t v76 = v100;
      if (v101 >= v123) {
        goto LABEL_34;
      }
    }

  uint64_t v121 = v32;
  char v55 = v30(a3, a4);
  uint64_t v56 = v32(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64) {
      goto LABEL_22;
    }
LABEL_25:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    int64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    int v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    Swift::String result = v61(v29, a3);
    if (v62 <= 16) {
      goto LABEL_27;
    }
LABEL_26:
    LOWORD(v54) = 0;
    goto LABEL_51;
  }

  if (v56 <= 63) {
    goto LABEL_25;
  }
LABEL_22:
  uint64_t v123 = 16LL;
  int v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  uint64_t v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v123, &type metadata for Int, v60, a3, a4);
  LOBYTE(v59) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
  int v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  Swift::String result = v61(v29, a3);
LABEL_27:
  int64_t v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  int64_t v64 = v117;
  v63(v117, a2, a3);
  char v65 = v120(a3, a4);
  unint64_t v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    uint64_t v76 = v25;
    uint64_t v68 = v116;
    unint64_t v69 = v117;
    goto LABEL_34;
  }

  unint64_t v67 = v121(a3, a4);
  v61(v25, a3);
  uint64_t v68 = v116;
  unint64_t v69 = v117;
  if (v67 < 65) {
    goto LABEL_35;
  }
  uint64_t v70 = v111;
  v66(v111, v117, a3);
  uint64_t v123 = 0x8000000000000000LL;
  unint64_t v71 = v120;
  if ((v120(a3, a4) & 1) == 0)
  {
    int64_t v90 = v71(a3, a4);
    int64_t v91 = v121(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 > 64)
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v94(&v123, &type metadata for Int, v95, a3, a4);
        uint64_t v70 = v111;
        Swift::String v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v29,  a3);
        goto LABEL_56;
      }

      int64_t v103 = AssociatedTypeWitness;
      int64_t v102 = (void (**)(char *, uint64_t, const char *))v114;
      int64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v105 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
      v102[3](v105, a3, (const char *)v102);
      uint64_t v106 = v111;
      LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v29,  a3);
      v61(v29, a3);
      uint64_t v107 = v110;
      v66(v110, v106, a3);
      if ((v102 & 1) != 0)
      {
        v61(v107, a3);
        goto LABEL_70;
      }

      uint64_t v108 = v123;
      Swift::String v109 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v107, a3);
      char v47 = v109 < v108;
      unint64_t v69 = v117;
      uint64_t v76 = v111;
      if (!v47) {
        goto LABEL_34;
      }
    }

    else
    {
      if (v91 > 64)
      {
        uint64_t v76 = v111;
        goto LABEL_34;
      }

      uint64_t v100 = v111;
      v66(v29, v111, a3);
      uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      uint64_t v76 = v100;
      if (v101 >= v123) {
        goto LABEL_34;
      }
    }

  char v129 = 64LL;
  uint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  int v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
  v60(&v129, &type metadata for Int, v61, a3, a4);
  int64_t v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
  int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  Swift::String result = v63(v30, a3);
  if ((v62 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  char v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  unint64_t v66 = v124;
  v65(v124, a2, a3);
  unint64_t v67 = v127(a3, a4);
  v65(v26, (uint64_t)v66, a3);
  if ((v67 & 1) == 0)
  {
    v63(v26, a3);
    unint64_t v71 = v123;
    uint64_t v70 = v124;
    uint64_t v68 = v125;
    v79 = v125(a3, a4);
    goto LABEL_47;
  }

  uint64_t v68 = v125;
  unint64_t v69 = v125(a3, a4);
  v63(v26, a3);
  unint64_t v71 = v123;
  uint64_t v70 = v124;
  if (v69 > 64)
  {
    v115 = v63;
    uint64_t v72 = v117;
    v65(v117, (uint64_t)v124, a3);
    char v129 = 0x8000000000000000LL;
    unint64_t v73 = v127;
    if ((v127(a3, a4) & 1) != 0)
    {
      char v74 = v68(a3, a4);
      if (v74 < 64)
      {
        v65(v30, (uint64_t)v72, a3);
        uint64_t v77 = v72;
        uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        int64_t v63 = v115;
        v115(v30, a3);
LABEL_40:
        if (v78 < v129) {
LABEL_69:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
        goto LABEL_44;
      }

      uint64_t v77 = v72;
      uint64_t v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      v87(&v129, &type metadata for Int, v88, a3, a4);
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v77,  v30,  a3);
    }

    else
    {
      v80 = v73(a3, a4);
      unint64_t v81 = v68(a3, a4);
      if ((v80 & 1) == 0)
      {
        int64_t v63 = v115;
        if (v81 >= 64)
        {
          uint64_t v113 = v117;
LABEL_45:
          v63(v113, a3);
          goto LABEL_46;
        }

        uint64_t v77 = v117;
        v65(v30, (uint64_t)v117, a3);
        uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v63(v30, a3);
        goto LABEL_40;
      }

      if (v81 <= 64)
      {
        int64_t v91 = AssociatedTypeWitness;
        int64_t v90 = (void (**)(char *, uint64_t, const char *))v120;
        char v92 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v93 = v118;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v92 + 8))( &qword_18180BE68,  256LL,  v91,  v92);
        v90[3](v93, a3, (const char *)v90);
        uint64_t v94 = v117;
        LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
        v115(v30, a3);
        uint64_t v95 = v116;
        v65(v116, (uint64_t)v94, a3);
        if ((v90 & 1) != 0)
        {
          v115(v95, a3);
          goto LABEL_69;
        }

        Swift::String v96 = v129;
        unint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        int64_t v63 = v115;
        v115(v95, a3);
        v98 = v97 < v96;
        uint64_t v70 = v124;
        uint64_t v77 = v117;
        if (v98) {
          goto LABEL_69;
        }
LABEL_44:
        uint64_t v113 = v77;
        goto LABEL_45;
      }

      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v84(&v129, &type metadata for Int, v85, a3, a4);
      uint64_t v77 = v117;
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
    }

    int64_t v89 = v86;
    int64_t v63 = v115;
    v115(v30, a3);
    if ((v89 & 1) != 0) {
      goto LABEL_69;
    }
    goto LABEL_44;
  }

  char v129 = 64LL;
  int v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  uint64_t v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v129, &type metadata for Int, v60, a3, a4);
  int v61 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
  int64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  Swift::String result = v62(v30, a3);
  if ((v61 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  char v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  unint64_t v66 = v124;
  v65(v124, a2, a3);
  unint64_t v67 = v127(a3, a4);
  v65(v26, (uint64_t)v66, a3);
  if ((v67 & 1) == 0)
  {
    v62(v26, a3);
    unint64_t v71 = v123;
    uint64_t v70 = v124;
    uint64_t v68 = v125;
    v79 = v125(a3, a4);
    goto LABEL_47;
  }

  uint64_t v68 = v125;
  unint64_t v69 = v125(a3, a4);
  v62(v26, a3);
  unint64_t v71 = v123;
  uint64_t v70 = v124;
  if (v69 > 64)
  {
    v115 = v62;
    uint64_t v72 = v117;
    v65(v117, (uint64_t)v124, a3);
    char v129 = 0x8000000000000000LL;
    unint64_t v73 = v127;
    if ((v127(a3, a4) & 1) != 0)
    {
      char v74 = v68(a3, a4);
      if (v74 < 64)
      {
        v65(v30, (uint64_t)v72, a3);
        uint64_t v77 = v72;
        uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        int64_t v62 = v115;
        v115(v30, a3);
LABEL_40:
        if (v78 < v129) {
LABEL_69:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
        goto LABEL_44;
      }

      uint64_t v77 = v72;
      uint64_t v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      v87(&v129, &type metadata for Int, v88, a3, a4);
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v77,  v30,  a3);
    }

    else
    {
      v80 = v73(a3, a4);
      unint64_t v81 = v68(a3, a4);
      if ((v80 & 1) == 0)
      {
        int64_t v62 = v115;
        if (v81 >= 64)
        {
          uint64_t v113 = v117;
LABEL_45:
          v62(v113, a3);
          goto LABEL_46;
        }

        uint64_t v77 = v117;
        v65(v30, (uint64_t)v117, a3);
        uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v62(v30, a3);
        goto LABEL_40;
      }

      if (v81 <= 64)
      {
        int64_t v91 = AssociatedTypeWitness;
        int64_t v90 = (void (**)(char *, uint64_t, const char *))v120;
        char v92 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v93 = v118;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v92 + 8))( &qword_18180BE68,  256LL,  v91,  v92);
        v90[3](v93, a3, (const char *)v90);
        uint64_t v94 = v117;
        LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
        v115(v30, a3);
        uint64_t v95 = v116;
        v65(v116, (uint64_t)v94, a3);
        if ((v90 & 1) != 0)
        {
          v115(v95, a3);
          goto LABEL_69;
        }

        Swift::String v96 = v129;
        unint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        int64_t v62 = v115;
        v115(v95, a3);
        v98 = v97 < v96;
        uint64_t v70 = v124;
        uint64_t v77 = v117;
        if (v98) {
          goto LABEL_69;
        }
LABEL_44:
        uint64_t v113 = v77;
        goto LABEL_45;
      }

      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v84(&v129, &type metadata for Int, v85, a3, a4);
      uint64_t v77 = v117;
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
    }

    int64_t v89 = v86;
    int64_t v62 = v115;
    v115(v30, a3);
    if ((v89 & 1) != 0) {
      goto LABEL_69;
    }
    goto LABEL_44;
  }

  unint64_t v144 = 64LL;
  unint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
  uint64_t v68 = v142;
  v66(&v144, &type metadata for Int, v67, a3, a4);
  unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
  uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  Swift::String result = v70(v68, a3);
  if ((v69 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  unint64_t v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  char v74 = v140;
  v73(v140, a2, a3);
  char v75 = v141(a3, a4);
  uint64_t v76 = v139;
  uint64_t v77 = v74;
  uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  uint64_t v132 = (unint64_t *)v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_42;
  }

  v79 = v32(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64) {
    goto LABEL_42;
  }
  unint64_t v81 = v135;
  v78(v135, v140, a3);
  unint64_t v144 = 0x8000000000000000LL;
  unint64_t v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    char v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      uint64_t v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v88,  a3);
      int64_t v89 = v88;
      unint64_t v81 = v135;
      v70(v89, a3);
      goto LABEL_41;
    }
  }

  else
  {
    int64_t v90 = v82(a3, a4);
    int64_t v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        int64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
        int64_t v103 = v133;
        int64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        unint64_t v81 = v107;
        v70(v108, a3);
        Swift::String v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_64;
        }

        uint64_t v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        v80 = v140;
        if (v112) {
          goto LABEL_64;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        Swift::String v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        unint64_t v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        v99 = v96;
        unint64_t v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_64;
        }
      }

      goto LABEL_41;
    }

    if (v91 >= 64) {
      goto LABEL_41;
    }
  }

  uint64_t v100 = v142;
  v78(v142, v81, a3);
  uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_64:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
  v70(v81, a3);
LABEL_42:
  uint64_t v113 = v132;
  uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }

  uint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v78(v40, v80, a3);
    unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    uint64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        uint64_t v123 = &v144;
        goto LABEL_54;
      }
    }

    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
      v70(v127, a3);
      if ((v128 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    v126 = v142;
    v78(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }

  char v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  Swift::String result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) != 0)
  {
    if (v129 >= 0xFFFFFFFFFFFFFFC1LL)
    {
      int v61 = v130 << -(char)v129;
      goto LABEL_59;
    }

    goto LABEL_24;
  }

  int v61 = v130 >> v129;
  if (v129 >= 0x40) {
    int v61 = 0LL;
  }
LABEL_59:
  void *v39 = v61;
  return result;
}

  unint64_t v144 = 64LL;
  unint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
  uint64_t v68 = v142;
  v66(&v144, &type metadata for Int, v67, a3, a4);
  unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
  uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  Swift::String result = v70(v68, a3);
  if ((v69 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  unint64_t v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  char v74 = v140;
  v73(v140, a2, a3);
  char v75 = v141(a3, a4);
  uint64_t v76 = v139;
  uint64_t v77 = v74;
  uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  uint64_t v132 = (unint64_t *)v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_42;
  }

  v79 = v32(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64) {
    goto LABEL_42;
  }
  unint64_t v81 = v135;
  v78(v135, v140, a3);
  unint64_t v144 = 0x8000000000000000LL;
  unint64_t v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    char v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      uint64_t v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v88,  a3);
      int64_t v89 = v88;
      unint64_t v81 = v135;
      v70(v89, a3);
      goto LABEL_41;
    }
  }

  else
  {
    int64_t v90 = v82(a3, a4);
    int64_t v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        int64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
        int64_t v103 = v133;
        int64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        unint64_t v81 = v107;
        v70(v108, a3);
        Swift::String v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_64;
        }

        uint64_t v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        v80 = v140;
        if (v112) {
          goto LABEL_64;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        Swift::String v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        unint64_t v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        v99 = v96;
        unint64_t v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_64;
        }
      }

      goto LABEL_41;
    }

    if (v91 >= 64) {
      goto LABEL_41;
    }
  }

  uint64_t v100 = v142;
  v78(v142, v81, a3);
  uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_64:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
  v70(v81, a3);
LABEL_42:
  uint64_t v113 = v132;
  uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }

  uint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v78(v40, v80, a3);
    unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    uint64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        uint64_t v123 = &v144;
        goto LABEL_54;
      }
    }

    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
      v70(v127, a3);
      if ((v128 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    v126 = v142;
    v78(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }

  char v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  Swift::String result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFC0LL)
    {
      int v61 = v130 >> -(char)v129;
      goto LABEL_59;
    }

    goto LABEL_24;
  }

  int v61 = v130 << v129;
  if (v129 >= 0x40) {
    int v61 = 0LL;
  }
LABEL_59:
  void *v39 = v61;
  return result;
}

    uint64_t v40 = *(char **)&v66[8 * v29];
    swift_unknownObjectRetain(v40, v31, v32, v33);
LABEL_25:
    v15[2](v15, v30, v40, &v73);
    if (v73)
    {
      swift_release_n(v61, 2LL);
      _Block_release(v15);
      swift_unknownObjectRelease(v30);
      swift_unknownObjectRelease(v40);
      swift_release((uint64_t)v19);
      return swift_release(v71);
    }

    swift_unknownObjectRelease(v30);
    swift_unknownObjectRelease(v40);
    uint64_t v24 = v72;
    if (v72) {
      goto LABEL_4;
    }
LABEL_7:
    if (__OFADD__(v28++, 1LL)) {
      __break(1u);
    }
    if (v28 >= v65) {
      break;
    }
    int64_t v35 = *(void *)(v22 + 8 * v28);
    if (!v35)
    {
      int64_t v36 = v28 + 1;
      if (v28 + 1 >= v65) {
        break;
      }
      int64_t v35 = *(void *)(v22 + 8 * v36);
      if (!v35)
      {
        while (1)
        {
          uint64_t v28 = v36 + 1;
          if (__OFADD__(v36, 1LL)) {
            break;
          }
          if (v28 >= v65) {
            goto LABEL_29;
          }
          int64_t v35 = *(void *)(v22 + 8 * v28);
          ++v36;
          if (v35) {
            goto LABEL_16;
          }
        }

        __break(1u);
        goto LABEL_33;
      }

      ++v28;
    }

    *(_DWORD *)(a7 + 24) = 0;
    return;
  }

  swift::BuilderError::BuilderError( (swift::BuilderError *)__p,  "Not enough generic arguments, %zu provided, %d required",  a6,  v17);
  if (SHIBYTE(v30) < 0)
  {
    std::string::__init_copy_ctor_external( (std::string *)a7,  (const std::string::value_type *)__p[0],  (std::string::size_type)__p[1]);
    uint64_t v24 = SHIBYTE(v30);
    *(_DWORD *)(a7 + 24) = 1;
    if (v24 < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    *(_OWORD *)a7 = *(_OWORD *)__p;
    *(void *)(a7 + 16) = v30;
    *(_DWORD *)(a7 + 24) = 1;
  }

  swift_deallocClassInstance(v5);
}

  id v17 = (char *)(a1 + 8LL * (int)v10);
  if ((v8[5] & 1) == 0) {
    return memcpy(v17, __src, 8LL * v8[4]);
  }
  uint64_t v18 = (_WORD *)((((unint64_t)v8 + *(unsigned __int16 *)v9 + 15) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v8[3]);
  uint64_t v19 = (unsigned __int16)*v18;
  size_t v20 = v8[4];
  if (*v18) {
    uint64_t v21 = &v18[2 * (v8[5] & 1)];
  }
  else {
    uint64_t v21 = 0LL;
  }
  Swift::String result = memcpy(v17, __src, 8 * v20);
  if ((_DWORD)v19)
  {
    uint64_t v23 = v21 + 2;
    do
    {
      unint64_t v25 = *(v23 - 1);
      uint64_t v26 = *(void *)&v17[8 * *v23];
      if (*(v23 - 2) == 1)
      {
        uint64_t v24 = 8 * v25;
        Swift::String result = (void *)swift_allocateWitnessTablePack(*(void *)&v17[8 * v25], v26);
      }

      else
      {
        if (*(v23 - 2)) {
          goto LABEL_28;
        }
        uint64_t v24 = 8 * v25;
        Swift::String result = (void *)swift_allocateMetadataPack(*(void *)&v17[8 * v25], v26);
      }

      *(void *)&v17[v24] = result;
LABEL_28:
      v23 += 4;
      --v19;
    }

    while (v19);
  }

  return result;
}

    uint64_t v21 = v13 | 0xA00000000000000LL;
LABEL_23:
    *(void *)(*result + result[1]) = v21;
LABEL_24:
    v17[1] += 8LL;
    *a5 = 0LL;
LABEL_25:
    int v9 = (void *)(*(a3 - 1) + 64);
    goto LABEL_26;
  }

  *a5 = v13;
  if (a3[1])
  {
    uint64_t v18 = 0LL;
    do
      Swift::String result = (uint64_t *)_swift_addRefCountStringForMetatype(v17, a2, a3[2 * v18++ + 3], a4, a5);
    while (v18 < a3[1]);
  }

  return result;
}

  char v65 = v16;
  unint64_t v66 = a4;
  unint64_t v67 = v9;
  uint64_t v68 = a2 + 4;
  uint64_t v29 = a2[3];
  if (BYTE1(v29))
  {
    unint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = &v68[(v29 >> 6) & 1];
    uint64_t v33 = &v32[3 * BYTE1(v29)];
    int64_t v34 = 12LL * BYTE1(v29);
    do
    {
      if ((*v32 & 0x80) != 0)
      {
        WitnessTablePack = *(void *)&a3[8 * v30];
        if ((*v32 & 0x20) != 0) {
          WitnessTablePack = swift_allocateWitnessTablePack(WitnessTablePack, GenericArgs[LOWORD(v33[2 * v31++ + 1])]);
        }
        *(void *)&v17[8 * ~v30++] = WitnessTablePack;
      }

      v32 += 3;
      v34 -= 12LL;
    }

    while (v34);
  }

  int64_t v36 = *a2;
  char v37 = (char *)a2 + (v36 & 0xFFFFFFFFFFFFFFFELL);
  if ((v36 & 1) != 0) {
    char v37 = *(char **)v37;
  }
  unint64_t v38 = *((_DWORD *)v37 + 3);
  unint64_t v39 = (unint64_t)&v37[12 * v38 + 24];
  uint64_t v40 = *((unsigned int *)v37 + 4);
  unint64_t v41 = a2[3];
  if ((v41 & 0x10000) != 0)
  {
    uint64_t v42 = (unsigned int *)(((unint64_t)&v68[3 * BYTE1(a2[3])
                                                 + 2 * HIBYTE(a2[3])
                                                 + (((unint64_t)a2[3] >> 6) & 1)]
                          + 3) & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v43 = *v42;
    if ((_DWORD)v43)
    {
      uint64_t v44 = 8 * v43;
      unint64_t v45 = &v42[HIWORD(v41) & 1];
      uint64_t v46 = (int *)(v45 + 1);
      do
      {
        char v47 = *(v46 - 1);
        if ((_DWORD)v47)
        {
          uint64_t v48 = (void *)((char *)v45 + (v47 & 0xFFFFFFFFFFFFFFFELL));
          if ((v47 & 1) != 0) {
            uint64_t v48 = (void *)*v48;
          }
          if (v48)
          {
            if ((unint64_t)v48 < v39 || (unint64_t)v48 >= v39 + 8 * v40) {
              swift::fatalError( 0LL,  "generic witness table at %p contains out-of-bounds requirement descriptor %p\n",  v12,  v13,  v67,  v48);
            }
            Swift::String v50 = (((unint64_t)v48 - v39) >> 3) + 1;
            uint64_t v51 = *v46;
            if ((_DWORD)v51) {
              uint64_t v52 = (uint64_t)v45 + v51 + 4;
            }
            else {
              uint64_t v52 = 0LL;
            }
            *(void *)&v17[8 * v50] = v52;
          }
        }

        v45 += 2;
        v46 += 2;
        v44 -= 8LL;
      }

      while (v44);
    }
  }

  if ((_DWORD)v40)
  {
    unint64_t v53 = (uint64_t)&v37[12 * v38 + 28];
    uint64_t v54 = &v66[8 * v65 + 8];
    do
    {
      char v55 = *(void *)v54;
      if (!*(void *)v54)
      {
        uint64_t v56 = *(int *)(v39 + 4);
        if ((_DWORD)v56) {
          char v55 = v53 + v56;
        }
        else {
          char v55 = 0LL;
        }
        *(void *)uint64_t v54 = v55;
      }

      if ((*(_BYTE *)v39 & 0xF) == 0 && v55 != 0) {
        swift_getAssociatedConformanceWitnessSlow( (uint64_t)v17,  (uint64_t)a1,  (uint64_t)a1,  (uint64_t)&v37[12 * *((unsigned int *)v37 + 3) + 16],  v39);
      }
      v53 += 8LL;
      v54 += 8;
      v39 += 8LL;
      --v40;
    }

    while (v40);
  }

  unint64_t v58 = (int)v67[1];
  if ((_DWORD)v58) {
    ((void (*)(char *, uint64_t *, const char *))((char *)v67 + v58 + 4))(v17, a1, a3);
  }
  return v17;
}

        if (++v8 == v10) {
          return result;
        }
      }

      char v27 = *((unsigned __int8 *)v20 + 18);
      if (v27 != 2)
      {
        if (v27 != 5 || *((_DWORD *)v20 + 2) < 2u)
        {
          uint64_t v23 = 0LL;
          goto LABEL_51;
        }

        size_t v20 = (uint64_t *)*v20;
      }

      uint64_t v23 = v20[1];
LABEL_51:
      char v47 = a4;
      uint64_t v29 = 0LL;
      goto LABEL_52;
    default:
      unint64_t v10 = 0LL;
      if (v8) {
        goto LABEL_21;
      }
      break;
  }

  return result;
}

    *(_DWORD *)(a3 + 24) = v8;
    int v9 = *((unsigned __int8 *)a2 + 18);
    if (v9 == 5 && *((_DWORD *)a2 + 2))
    {
      a2 = *(const char **)a2;
LABEL_4:
      a2 = *(const char **)a2;
      goto LABEL_5;
    }

    a2 = 0LL;
LABEL_5:
    **(_BYTE **)a1 = 1;
  }

  if (*((unsigned __int16 *)a2 + 8) > 0x7Eu)
  {
    if (v7 == 127)
    {
      uint64_t v8 = *(_DWORD *)(a3 + 24) | 0x400;
    }

    else
    {
      if (v7 != 128) {
        goto LABEL_31;
      }
      uint64_t v8 = *(_DWORD *)(a3 + 24) | 0x800;
    }

    goto LABEL_20;
  }

  if (v7 == 123)
  {
    uint64_t v8 = *(_DWORD *)(a3 + 24) & 0xFFFFFF80 | 1;
    goto LABEL_20;
  }

  if (v7 == 11 || v7 == 64)
  {
    *(_DWORD *)(a3 + 24) |= 0x100u;
    **(_BYTE **)a1 = 1;
    unint64_t v10 = *(void *)(a1 + 16);
    uint64_t v11 = **(_DWORD **)(a1 + 8);
    goto LABEL_26;
  }

  Swift::String result = memcpy(&v9[v8], a2, a3);
  *((_DWORD *)a1 + 2) += a3;
  return result;
}

    unint64_t v12 = 0;
    if (v7 >= v2) {
      goto LABEL_19;
    }
    goto LABEL_21;
  }

  return 0LL;
}

    uint64_t v13 = a2;
    if (v7 >= 2) {
      uint64_t v13 = *(swift::Demangle::__runtime::Node **)a2;
    }
    unint64_t v14 = (uint64_t *)*((void *)v13 + v10);
LABEL_25:
    unint64_t v15 = *((unsigned __int16 *)v14 + 8);
    if (v15 == 232)
    {
      unint64_t v15 = *(unsigned __int16 *)(*v14 + 16);
    }

    if (v15 != 42) {
      goto LABEL_32;
    }
    ++v10;
  }

  while (v8 != (_DWORD)v10);
  LODWORD(v10) = v8;
LABEL_32:
  if (!(_DWORD)v9)
  {
LABEL_92:
    if ((_DWORD)v10 == v48) {
      goto LABEL_106;
    }
    if (!this[1].__r_.__value_.__s.__data_[7]) {
      goto LABEL_106;
    }
    std::string::append(this, " where ", 7uLL);
    char v37 = *((unsigned __int8 *)a2 + 18);
    unint64_t v38 = v37 - 1;
    switch((_DWORD)v37)
    {
      case 1:
        goto LABEL_99;
      case 2:
        break;
      case 5:
        char v37 = *((unsigned int *)a2 + 2);
LABEL_99:
        if (v37 > v10)
        {
LABEL_100:
          unint64_t v39 = a2;
          if (v38 >= 2) {
            unint64_t v39 = *(swift::Demangle::__runtime::Node **)a2;
          }
          uint64_t v40 = (swift::Demangle::__runtime::Node *)*((void *)v39 + v10);
LABEL_105:
          unint64_t v41 = v10 + 1LL;
          if (v48 == (_DWORD)v10 + 1)
          {
LABEL_106:
            std::string::push_back(this, 62);
            return;
          }

          uint64_t v42 = ~(_DWORD)v10 + v48;
          while (2)
          {
            uint64_t v44 = *((unsigned __int8 *)a2 + 18);
            if ((_DWORD)v44 == 2)
            {
              if (v44 <= v41) {
                goto LABEL_108;
              }
            }

            else if ((_DWORD)v44 != 5 || *((unsigned int *)a2 + 2) <= v41)
            {
LABEL_108:
              unint64_t v43 = 0LL;
              goto LABEL_109;
            }

            unint64_t v45 = v44 - 1;
            uint64_t v46 = a2;
            if (v45 >= 2) {
              uint64_t v46 = *(swift::Demangle::__runtime::Node **)a2;
            }
            unint64_t v43 = (swift::Demangle::__runtime::Node *)*((void *)v46 + v41);
LABEL_109:
            ++v41;
            if (!--v42) {
              goto LABEL_106;
            }
            continue;
          }
        }

        break;
    }

    uint64_t v40 = 0LL;
    goto LABEL_105;
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

      Swift::String result = (uint64_t)swift::Demangle::__runtime::CharVector::append(this + 1591, v10, 1uLL, this[1593]);
      unint64_t v12 = 0;
      uint64_t v3 = 0LL;
      uint64_t v11 = 0;
      goto LABEL_21;
  }

  uint64_t v11 = 1678;
  unint64_t v12 = 17;
LABEL_21:
  *(_DWORD *)a3 = v12;
  *(void *)(a3 + 8) = v3;
  *(_DWORD *)(a3 + 16) = v11;
  return result;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 109;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  unint64_t v22 = a2;
  if (v21 != 1)
  {
    if (v21 != 5 || *((_DWORD *)a2 + 2) != 1) {
      goto LABEL_30;
    }
    unint64_t v22 = *(swift::Demangle::__runtime::Node **)a2;
  }

  if (*(_WORD *)(*(void *)v22 + 16LL) != 232)
  {
LABEL_30:
    *(_DWORD *)a4 = 1;
    *(void *)(a4 + 8) = a2;
    uint64_t v24 = 2760;
    goto LABEL_31;
  }

  if ((v21 - 1) < 2)
  {
LABEL_29:
    uint64_t v23 = *(swift::Demangle::__runtime::Node **)a2;
    goto LABEL_34;
  }

  if (v21 == 5 && *((_DWORD *)a2 + 2))
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
    goto LABEL_29;
  }

  uint64_t v23 = 0LL;
LABEL_34:
  unint64_t v25 = *((unsigned __int8 *)v23 + 18);
  if (v25 != 1)
  {
    if (v25 == 5 && *((_DWORD *)v23 + 2) == 1)
    {
      uint64_t v23 = *(swift::Demangle::__runtime::Node **)v23;
    }

    *(_DWORD *)a4 = 10;
    *(void *)(a4 + 8) = v23;
    uint64_t v24 = 114;
LABEL_31:
    *(_DWORD *)(a4 + 16) = v24;
    return this;
  }
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 105;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  unint64_t v22 = a2;
  if (v21 != 1)
  {
    if (v21 != 5 || *((_DWORD *)a2 + 2) != 1) {
      goto LABEL_30;
    }
    unint64_t v22 = *(swift::Demangle::__runtime::Node **)a2;
  }

  if (*(_WORD *)(*(void *)v22 + 16LL) != 232)
  {
LABEL_30:
    *(_DWORD *)a4 = 1;
    *(void *)(a4 + 8) = a2;
    uint64_t v24 = 2769;
    goto LABEL_31;
  }

  if ((v21 - 1) < 2)
  {
LABEL_29:
    uint64_t v23 = *(swift::Demangle::__runtime::Node **)a2;
    goto LABEL_34;
  }

  if (v21 == 5 && *((_DWORD *)a2 + 2))
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
    goto LABEL_29;
  }

  uint64_t v23 = 0LL;
LABEL_34:
  unint64_t v25 = *((unsigned __int8 *)v23 + 18);
  if (v25 != 1)
  {
    if (v25 == 5 && *((_DWORD *)v23 + 2) == 1)
    {
      uint64_t v23 = *(swift::Demangle::__runtime::Node **)v23;
    }

    *(_DWORD *)a4 = 10;
    *(void *)(a4 + 8) = v23;
    uint64_t v24 = 114;
LABEL_31:
    *(_DWORD *)(a4 + 16) = v24;
    return this;
  }
}

  *(_DWORD *)(a1 + 12736) = v14 + 1;
  v16[v14] = 70;
  uint64_t v28 = *((unsigned __int8 *)a2 + 18);
  uint64_t v29 = a2;
  if ((v28 - 1) < 2)
  {
LABEL_24:
    unint64_t v30 = *v29;
    goto LABEL_26;
  }

  if (v28 == 5 && *((_DWORD *)a2 + 2))
  {
    uint64_t v29 = (uint64_t *)*a2;
    goto LABEL_24;
  }

  unint64_t v30 = 0LL;
LABEL_26:
  uint64_t v31 = (a6 + 1);
  if (*(_DWORD *)a7) {
    return result;
  }
  Swift::String result = swift::Demangle::__runtime::CharVector::append(v13, a3, v9, *(void **)(a1 + 12744));
  uint64_t v33 = *((unsigned __int16 *)a2 + 8);
  if (v33 != 220)
  {
    if (v33 == 254)
    {
      int64_t v34 = *((unsigned __int8 *)a2 + 18);
      int64_t v35 = a2;
      if (v34 == 2) {
        goto LABEL_33;
      }
      if (v34 == 5 && *((_DWORD *)a2 + 2) >= 2u)
      {
        int64_t v35 = (uint64_t *)*a2;
LABEL_33:
        if (*(_DWORD *)a7) {
          return result;
        }
        if (*((_BYTE *)a2 + 18) == 5)
        {
          if (*((_DWORD *)a2 + 2) < 3u) {
            int64_t v36 = 0LL;
          }
          else {
            int64_t v36 = *(swift::Demangle::__runtime::Node **)(*a2 + 16);
          }
          uint64_t v48 = *((_DWORD *)a2 + 2);
          if (*((_WORD *)v36 + 8) == 290)
          {
            if (v48 >= 4)
            {
              uint64_t v46 = *(swift::Demangle::__runtime::Node **)(*a2 + 24);
              goto LABEL_73;
            }

            goto LABEL_72;
          }

          if (v48 >= 3)
          {
            char v47 = *(unsigned int **)(*a2 + 16);
            goto LABEL_77;
          }
        }

id _CocoaArrayWrapper.subscript.getter(uint64_t a1, id a2)
{
  return objc_msgSend(a2, sel_objectAtIndex_, a1);
}

void _ArrayBuffer._typeCheck(_:)(Swift::Int a1, Swift::Int a2, uint64_t a3, uint64_t *a4)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4)
    && _swift_isClassOrObjCExistentialType((uint64_t)a4, a4)
    && (a3 & 0xC000000000000001LL) != 0
    && !swift_dynamicCastMetatype((uint64_t *)&unk_189B8D230, a4))
  {
    if (a2 < a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    for (; a2 != a1; ++a1)
    {
      if (a2 == a1) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
      }
      _ArrayBuffer._typeCheckSlowPath(_:)(a1);
    }
  }

Swift::Bool __swiftcall _slowPath(_:)(Swift::Bool a1)
{
  return a1;
}

char *_ContiguousArrayBuffer._copyContents(subRange:initializing:)( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5)
{
  int64_t v6 = specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)(a1, a2, a3, a4, a5);
  swift_release(a4);
  return v6;
}

uint64_t UnsafeMutableRawPointer.assumingMemoryBound<A>(to:)(uint64_t a1, uint64_t a2)
{
  return a2;
}

void **_CocoaArrayWrapper._copyContents(subRange:initializing:)(void **a1, uint64_t a2, void **a3, void *a4)
{
  int64_t v5 = specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)(a1, a2, a3, a4);
  swift_unknownObjectRelease(a4);
  return v5;
}

unint64_t *_ContiguousArrayBuffer._copyContents(initializing:)( char *a1, uint64_t a2, unint64_t *a3, char *a4)
{
  if (a2 >= 1)
  {
    else {
      uint64_t v6 = a3[2];
    }
    if (!a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2ECuLL,  0);
    }
    uint64_t v8 = *((void *)a4 - 1);
    int v9 = (char *)a3 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80));
    uint64_t v10 = *(void *)(v8 + 72) * v6;
    uint64_t v11 = &a1[v10];
    unint64_t v12 = &v9[v10];
    swift_retain(a3, a2, (uint64_t)a3, a4);
    if (v9 < v11 && v12 > a1) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
    }
    swift_arrayInitWithCopy(a1, v9, v6, (uint64_t)a4);
    swift_release((uint64_t)a3);
  }

  return a3;
}

uint64_t IndexingIterator.init(_elements:_position:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = a5 + *(int *)(type metadata accessor for IndexingIterator(0LL, a3, (uint64_t)a4, v9) + 36);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( v10,  a2,  AssociatedTypeWitness);
}

BOOL static Int.> infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 < a1;
}

uint64_t UnsafeMutableBufferPointer.init(start:count:)(uint64_t result, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  if (a2)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer has a nil start and nonzero count",  60LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x49uLL,  0);
    }
  }

  return result;
}

id _CocoaArrayWrapper._copyContents(initializing:)(void **a1, uint64_t a2, id a3)
{
  if (a2 >= 1)
  {
    if (!a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CocoaArray.swift",  22LL,  2,  0x9DuLL,  0);
    }
    uint64_t v5 = a2;
    uint64_t v6 = specialized RandomAccessCollection<>.distance(from:to:)(0, (uint64_t)objc_msgSend(a3, sel_count), a3);
    if (v6 < v5) {
      uint64_t v5 = v6;
    }
    if (v5 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    swift_unknownObjectRetain(a3, v7, v8, v9);
    specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)(0LL, v5, a1, a3);
    swift_unknownObjectRelease(a3);
  }

  return a3;
}

uint64_t key path getter for _ArrayBuffer.subscript(_:) : <A>_ArrayBuffer<A>A@<X0>( int64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = _ArrayBuffer.subscript.getter(*a2, a2[1], *a1, *(uint64_t **)((char *)a2 + a3 - 8));
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

uint64_t key path setter for _ArrayBuffer.subscript(_:) : <A>_ArrayBuffer<A>A( void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for _ArrayBuffer.subscript(_:) : <A>_ArrayBuffer<A>A( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void))type metadata accessor for _ArrayBuffer,  (uint64_t (*)(uint64_t))specialized _ArrayBuffer.subscript.setter);
}

id _ContiguousArrayBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _ContiguousArrayBuffer.subscript.getter( a1,  a2,  a3,  a4,  (uint64_t (*)(void))specialized _ContiguousArrayBuffer.subscript.getter);
}

uint64_t _CocoaArrayWrapper.subscript.getter(uint64_t a1, uint64_t a2, void *a3, char *a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1)) {
    goto LABEL_16;
  }
  if (!v4)
  {
    uint64_t v9 = &_swiftEmptyArrayStorage;
    return specialized _SliceBuffer.init(_buffer:shiftedToStartIndex:)((uint64_t)v9, a1);
  }

  uint64_t v6 = a3;
  uint64_t v8 = (uint64_t)objc_msgSend(swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4), sel_count);
  if (v8 < 0) {
    goto LABEL_17;
  }
  if (_CocoaArrayWrapper.contiguousStorage(_:)(0LL, v8, v6))
  {
    if (a2 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    return (uint64_t)v6;
  }

  swift_unknownObjectRelease(v6);
  uint64_t v10 = (unint64_t *)specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v4, 0LL);
  if (v4 < 0) {
LABEL_17:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v14 = (uint64_t)v10;
  swift_retain(v10, v11, v12, v13);
  for (uint64_t i = 0LL; i != v4; ++i)
  {
    if (__OFADD__(i, a1))
    {
      __break(1u);
LABEL_16:
      __break(1u);
      goto LABEL_17;
    }

    *(void *)(v14 + 8 * i + 32) = objc_msgSend(v6, sel_objectAtIndex_, i + a1);
  }

  swift_release(v14);
  uint64_t v9 = (__objc2_class **)v14;
  return specialized _SliceBuffer.init(_buffer:shiftedToStartIndex:)((uint64_t)v9, a1);
}

id _SliceBuffer.unsafeCastElements<A>(to:)(uint64_t a1, void *a2, uint64_t a3, char *a4)
{
  return swift_unknownObjectRetain(a2, (uint64_t)a2, a3, a4);
}

void fatalError(_:file:line:)( uint64_t (*a1)(void), uint64_t a2, const char *a3, uint64_t a4, char a5, unint64_t a6)
{
  uint64_t v10 = (char *)a1();
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11LL, 2LL, v10, v11, a3, a4, a5, a6, 0);
}

void key path getter for _ArrayBuffer.count : <A>_ArrayBuffer<A>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *(uint64_t **)(a3 + a2 - 8);
  uint64_t v6 = *a1;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v5, v5) && (v6 < 0 || (v6 & 0x4000000000000000LL) != 0))
  {
    id v10 = _ArrayBuffer._nonNative.getter(v6);
    id v9 = objc_msgSend(v10, sel_count);
    swift_unknownObjectRelease(v10);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
    uint64_t v8 = v6 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v8 = v6;
    }
    id v9 = *(id *)(v8 + 16);
  }

  *a4 = v9;
}

BOOL key path setter for _ArrayBuffer.count : <A>_ArrayBuffer<A>( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = type metadata accessor for _ArrayBuffer(0LL, *(void *)(a4 + a3 - 8), a3, a4);
  return _ArrayBuffer.count.setter(v4, v5);
}

uint64_t _ContiguousArrayBuffer.count.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

id _CocoaArrayWrapper.endIndex.getter(void *a1)
{
  return objc_msgSend(a1, sel_count);
}

uint64_t _ContiguousArrayBuffer.count.setter(uint64_t result, uint64_t a2)
{
  *(void *)(a2 + 16) = result;
  return result;
}

uint64_t specialized _ArrayBuffer.immutableCount.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t _ArrayBuffer.mutableCount.getter(uint64_t a1, uint64_t *a2)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  uint64_t v4 = a1 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v4 = a1;
  }
  return *(void *)(v4 + 16);
}

BOOL key path getter for _ArrayBuffer.mutableCount : <A>_ArrayBuffer<A>@<W0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *a1;
  BOOL result = _swift_isClassOrObjCExistentialType(*(void *)(a3 + a2 - 8), *(uint64_t **)(a3 + a2 - 8));
  uint64_t v7 = v5 & 0xFFFFFFFFFFFFF8LL;
  if (!result) {
    uint64_t v7 = v5;
  }
  *a4 = *(void *)(v7 + 16);
  return result;
}

BOOL key path setter for _ArrayBuffer.mutableCount : <A>_ArrayBuffer<A>( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *a2;
  BOOL result = _swift_isClassOrObjCExistentialType(*(void *)(a4 + a3 - 8), *(uint64_t **)(a4 + a3 - 8));
  uint64_t v7 = v5 & 0xFFFFFFFFFFFFF8LL;
  if (!result) {
    uint64_t v7 = v5;
  }
  *(void *)(v7 + 16) = v4;
  return result;
}

uint64_t _ContiguousArrayBuffer.mutableCount.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

Swift::Void __swiftcall _ArrayBuffer._checkInoutAndNativeBounds(_:wasNative:)(Swift::Int _, Swift::Bool wasNative)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3))
  {
    BOOL v9 = (v5 & 0x4000000000000000LL) == 0 && v5 >= 0;
    if (v9 == wasNative)
    {
      if (!wasNative) {
        return;
      }
      goto LABEL_12;
    }

LABEL_17:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "inout rules were violated: the array was overwritten",  52LL,  2,  "Swift/ArrayBuffer.swift",  23LL,  2,  0x1AEuLL,  0);
  }

  if (!wasNative) {
    goto LABEL_17;
  }
LABEL_12:
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v4, v4);
  if (_ < 0) {
    goto LABEL_18;
  }
  uint64_t v11 = v5 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v11 = v5;
  }
  if (*(void *)(v11 + 16) <= (unint64_t)_) {
LABEL_18:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v30, a3);
  BOOL result = (*(uint64_t (**)(char *, unint64_t))(v13 + 8))(v15, AssociatedTypeWitness);
  if (*v29 < a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  if (a2)
  {
    unint64_t v25 = a2;
    while (v25 <= a2)
    {
      if (HIBYTE(v20)) {
        goto LABEL_31;
      }
      v20 |= v25 << (-(__clz(v20) & 0x18) & 0x18);
      uint64_t v18 = v25 >= 0x100;
      v25 >>= 8;
      if (!v18) {
        goto LABEL_23;
      }
    }

    goto LABEL_30;
  }

    __break(1u);
    goto LABEL_18;
  }

  return (__objc2_class **)v9;
}

    (*(void (**)(char *, uint64_t))(v56 + 8))(v54, a3);
    a5 = v114;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t, uint64_t))(v45 + 96))(a1, a3, a5, v9, v45);
}

    swift_bridgeObjectRelease((uint64_t)object);
    return 0;
  }

  if ((_stringCompareInternal(_:_:expecting:)( a1._countAndFlagsBits,  (unint64_t)a1._object,  1702195828LL,  0xE400000000000000LL,  0) & 1) != 0)
  {
LABEL_10:
    swift_bridgeObjectRelease((uint64_t)object);
    return (Swift::Bool_optional)1;
  }

  uint64_t v5 = _stringCompareInternal(_:_:expecting:)( countAndFlagsBits,  (unint64_t)object,  0x65736C6166LL,  0xE500000000000000LL,  0);
  swift_bridgeObjectRelease((uint64_t)object);
  result.value = 0;
  if ((v5 & 1) == 0) {
    return (Swift::Bool_optional)2;
  }
  return result;
}

    swift_bridgeObjectRelease(a1);
LABEL_18:
    *uint64_t v1 = v3;
    return;
  }

  __break(1u);
}

  uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  (*(void (**)(char *, uint64_t))(v52 + 8))(v21, a2);
  return v46;
}

  uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  (*(void (**)(char *, uint64_t))(v52 + 8))(v21, a2);
  return v46;
}

  unint64_t v15 = specialized static String.+ infix(_:_:)(0x7830uLL, 0xE200000000000000LL, countAndFlagsBits, object);
  swift_bridgeObjectRelease(0xE200000000000000LL);
  swift_bridgeObjectRelease(object);
  return v15;
}

  unint64_t v15 = specialized static String.+ infix(_:_:)(0x7830uLL, 0xE200000000000000LL, countAndFlagsBits, object);
  id v17 = v16;
  swift_bridgeObjectRelease(0xE200000000000000LL);
  swift_bridgeObjectRelease(object);
  uint64_t v18 = v15;
  uint64_t v19 = v17;
  result._uint64_t object = v19;
  result._uint64_t countAndFlagsBits = v18;
  return result;
}

  (*(void (**)(uint64_t, uint64_t, char *))(v16 + 16))( a1,  *(void *)(a6 + 48) + *(void *)(v16 + 72) * a3,  a7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a8 - 8) + 16LL))( a2,  *(void *)(a6 + 56) + *(void *)(*(void *)(a8 - 8) + 72LL) * a3,  a8);
}

    uint64_t v12 = (v18 - 1) & v18;
    uint64_t v16 = __clz(__rbit64(v18)) + (v14 << 6);
LABEL_6:
    swift_arrayDestroy(v7[3].i64[0] + *(void *)(*(void *)(v6[2] - 8) + 72LL) * v16, 1LL, v6[2]);
    swift_arrayDestroy(v7[3].i64[1] + *(void *)(*(void *)(v6[3] - 8) + 72LL) * v16, 1LL, v6[3]);
  }

  if (v7 != 127)
  {
    if (v7 <= -128) {
      uint64_t v14 = -128LL;
    }
    else {
      uint64_t v14 = v7;
    }
    if ((v14 & 0x8000000000000000LL) != 0)
    {
      if (v7 < -127)
      {
        unint64_t v15 = 0LL;
        uint64_t v16 = 0LL;
LABEL_43:
        size_t v20 = v16 | v5;
        uint64_t v21 = v15 | v10;
        if (a2 >= 0.0)
        {
          if ((v21 & 0x8000000000000000LL) == 0)
          {
LABEL_49:
            *(void *)a1 = v20;
            *(void *)(a1 + 8) = v21;
LABEL_50:
            *(_BYTE *)(a1 + 16) = 0;
            return result;
          }
        }

        else if ((v21 & 0x8000000000000000LL) == 0)
        {
          unint64_t v22 = v20 == 0;
          size_t v20 = -(uint64_t)v20;
          if (v22) {
            uint64_t v21 = -(uint64_t)v21;
          }
          else {
            uint64_t v21 = ~v21;
          }
          goto LABEL_49;
        }

        _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000028LL,  0x80000001818B7CB0LL | 0x8000000000000000LL,  "Swift/LegacyInt128.swift",  24LL,  2,  0x27CuLL,  0);
      }

      unint64_t v15 = 0LL;
      uint64_t v16 = 0LL;
      uint64_t v19 = -(uint64_t)v14;
      if ((v19 & 0x7F) != 0)
      {
        unint64_t v15 = 0LL;
        uint64_t v16 = 1uLL >> v19;
        goto LABEL_43;
      }
    }

    else
    {
      if (v14 > 0x3F)
      {
        uint64_t v16 = 0LL;
        unint64_t v15 = 1LL << v14;
        goto LABEL_43;
      }

      if (v14)
      {
        unint64_t v15 = 1uLL >> -(char)v14;
        uint64_t v16 = 1LL << v14;
        goto LABEL_43;
      }
    }

    unint64_t v15 = 0LL;
    uint64_t v16 = 1LL;
    goto LABEL_43;
  }

          __break(1u);
          return result;
        }

  if (v6 < v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if ((v11 & 0x2000000000000000LL) != 0)
  {
    uint64_t v24 = v10;
    unint64_t v25 = v11 & 0xFFFFFFFFFFFFFFLL;
    if ((v1 & 0x8000000000000000LL) == 0)
    {
      if ((uint64_t)(HIBYTE(v11) & 0xF) >= v6)
      {
        if (v9 < 0) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
        }
        uint64_t v14 = (uint8x16_t *)((char *)&v24 + v1);
        goto LABEL_27;
      }

      goto LABEL_34;
    }

    goto LABEL_37;
  }

  if ((v10 & 0x1000000000000000LL) != 0)
  {
    uint64_t v12 = (id)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v13 = v10 & 0xFFFFFFFFFFFFLL;
    if ((v1 & 0x8000000000000000LL) == 0) {
      goto LABEL_21;
    }
LABEL_37:
    uint64_t v21 = 1860LL;
LABEL_38:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v21,  0);
  }

  uint64_t v12 = _StringObject.sharedUTF8.getter(v10, v11);
  uint64_t v13 = v22;
  if (v1 < 0) {
    goto LABEL_37;
  }
LABEL_21:
  if (v13 < v6)
  {
LABEL_34:
    uint64_t v21 = 1861LL;
    goto LABEL_38;
  }

  uint64_t v14 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v1, v6, (uint64_t)v12, v13);
LABEL_27:
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v14, v9);
LABEL_28:
  id v17 = (uint64_t)object;
  v0[2] = v6;
  uint64_t v18 = (void (*)(uint64_t *__return_ptr, void *))v0[4];
  v23[0] = countAndFlagsBits;
  v23[1] = object;
  v18(&v24, v23);
  swift_bridgeObjectRelease(v17);
  return v24;
}

      uint64_t v14 = (v19 - 1) & v19;
    }

      uint64_t v14 = (v19 - 1) & v19;
    }

    uint64_t v12 = (v18 - 1) & v18;
    uint64_t v16 = __clz(__rbit64(v18)) + (v14 << 6);
LABEL_6:
    swift_arrayDestroy( *(void *)(v7 + 48) + *(void *)(*(void *)(*(void *)(v6 + 16) - 8LL) + 72LL) * v16,  1LL,  *(void *)(v6 + 16));
  }

  BOOL result = (*(uint64_t (**)(char *, unint64_t))(v65 + 8))(v66, v67);
  *uint64_t v33 = v36;
  return result;
}

    uint64_t v16 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v11 << 16));
    scalarLength = v16.scalarLength;
  }

  __break(1u);
LABEL_33:
  swift_bridgeObjectRelease(a4);
  uint64_t v13 = 0;
  return v13 & 1;
}

          uint64_t v14 = __clz(__rbit64(v22)) + (v21 << 6);
        }
      }

    if (v6 < v1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    if ((v11 & 0x2000000000000000LL) != 0)
    {
      uint64_t v21 = v10;
      unint64_t v22 = v11 & 0xFFFFFFFFFFFFFFLL;
      if ((v1 & 0x8000000000000000LL) == 0)
      {
        if ((uint64_t)(HIBYTE(v11) & 0xF) >= v6)
        {
          if (v9 < 0) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
          }
          uint64_t v14 = (uint8x16_t *)((char *)&v21 + v1);
          goto LABEL_27;
        }

        goto LABEL_34;
      }
    }

    else if ((v10 & 0x1000000000000000LL) != 0)
    {
      uint64_t v12 = (id)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v13 = v10 & 0xFFFFFFFFFFFFLL;
      if ((v1 & 0x8000000000000000LL) == 0) {
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v12 = _StringObject.sharedUTF8.getter(v10, v11);
      uint64_t v13 = v19;
      if ((v1 & 0x8000000000000000LL) == 0)
      {
LABEL_21:
        if (v13 >= v6)
        {
          uint64_t v14 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v1, v6, (uint64_t)v12, v13);
LABEL_27:
          uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)(v14, v9);
LABEL_28:
          v0[2] = v6;
          goto LABEL_41;
        }

    uint64_t v3 = v23;
    if ((*(void *)(v5 + 16) & 0x8000000000000000LL) != 0) {
LABEL_18:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  uint64_t v6 = v5 + 24;
  return v3(v6);
}

    __break(1u);
    goto LABEL_18;
  }

  id v10 = __OFSUB__(__PAIR128__(v4, v3), __PAIR128__(v5, v6));
  BOOL v9 = v3 - v6;
  uint64_t v7 = (__PAIR128__(v4, v3) - __PAIR128__(v5, v6)) >> 64;
  uint64_t v8 = v3 - v6;
  uint64_t v11 = v10;
  if ((v11 & 1) != 0)
  {
    __break(1u);
    goto LABEL_17;
  }

  if (__CFADD__(v9, 0x8000000000000000LL) + v7) {
LABEL_18:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Distance is not representable in Int",  36LL,  2,  "Swift/Integers.swift",  20LL,  2,  0x64AuLL,  0);
LABEL_15:
  *a2 = v8;
  return result;
}

  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  BOOL result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *uint64_t v49 = v42;
  return result;
}

  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  BOOL result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *uint64_t v49 = v42;
  return result;
}

  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  BOOL result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *uint64_t v49 = v42;
  return result;
}

  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  BOOL result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *uint64_t v49 = v42;
  return result;
}

        uint64_t v33 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
        v39(v15, v40, v3);
        goto LABEL_18;
      }

      v26(v32, v3);
      goto LABEL_14;
    }
  }

  unint64_t v43 = 0LL;
  uint64_t v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
  unint64_t v25 = lazy protocol witness table accessor for type Int and conformance Int(v20, v21, v22);
  v24(&v43, &type metadata for Int, v25, v3, v4);
  LOBYTE(v24) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8LL) + 16LL))( v17,  v15,  v3);
  uint64_t v26 = *(void (**)(char *, uint64_t))(v42 + 8);
  v26(v15, v3);
  v26(v17, v3);
LABEL_14:
  uint64_t v33 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  int64_t v34 = v41;
LABEL_15:
  v39(v15, v40, v3);
LABEL_18:
  int64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
  v26(v15, v3);
  BOOL result = __swift_instantiateConcreteTypeFromMangledName(v33);
  v34[3] = result;
  v34[4] = (uint64_t)&protocol witness table for _IntegerAnyHashableBox<A>;
  *int64_t v34 = v35;
  return result;
}

  uint64_t v19 = 1;
LABEL_20:
  result.partialValue.high = v12;
  result.partialValue.low = v10;
  result.overflow = v19;
  return result;
}

          Swift::String v50 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
          uint64_t v51 = v105;
          v50(v105, a2, a3);
          uint64_t v52 = v31(a3, a4);
          v50(v25, (uint64_t)v51, a3);
          if ((v52 & 1) != 0)
          {
            unint64_t v53 = v109(a3, a4);
            v48(v25, a3);
            if (v53 < 65) {
              goto LABEL_36;
            }
            unint64_t v25 = v99;
            v50(v99, (uint64_t)v51, a3);
            v111 = 0x8000000000000000LL;
            if ((v31(a3, a4) & 1) != 0)
            {
              uint64_t v54 = v109(a3, a4);
              if (v54 < 64)
              {
LABEL_31:
                v50(v29, (uint64_t)v25, a3);
                unint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v48(v29, a3);
                if (v66 < v111) {
LABEL_58:
                }
                  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
                goto LABEL_35;
              }

              goto LABEL_28;
            }

            int64_t v63 = v31(a3, a4);
            uint64_t v54 = v109(a3, a4);
            if ((v63 & 1) != 0)
            {
              if (v54 > 64)
              {
LABEL_28:
                int64_t v64 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                char v65 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
                v64(&v111, &type metadata for Int, v65, a3, a4);
                LOBYTE(v64) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                 + 16LL))( v25,  v29,  a3);
                v48(v29, a3);
                goto LABEL_35;
              }

              uint64_t v68 = AssociatedTypeWitness;
              unint64_t v67 = (void (**)(char *, uint64_t, const char *))v102;
              unint64_t v69 = swift_getAssociatedConformanceWitness( (uint64_t)v102,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v70 = v100;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v69 + 8))( &qword_18180BE68,  256LL,  v68,  v69);
              v67[3](v70, a3, (const char *)v67);
              LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                               + 16LL))( v25,  v29,  a3);
              v48(v29, a3);
              unint64_t v71 = v98;
              v50(v98, (uint64_t)v25, a3);
              if ((v67 & 1) != 0)
              {
                v48(v71, a3);
                goto LABEL_58;
              }

              uint64_t v72 = v111;
              unint64_t v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v48(v71, a3);
              char v74 = v73 < v72;
              uint64_t v51 = v105;
              if (v74) {
                goto LABEL_58;
              }
            }

            else if (v54 < 64)
            {
              goto LABEL_31;
            }
          }

          uint64_t v49 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
          Swift::String v50 = v111;
          v49(v111, a2, a3);
          uint64_t v51 = v29(a3, a4);
          v49(v24, (uint64_t)v50, a3);
          if ((v51 & 1) == 0)
          {
            v47(v24, a3);
            unint64_t v53 = v112;
            goto LABEL_38;
          }

          uint64_t v52 = v114(a3, a4);
          v47(v24, a3);
          unint64_t v53 = v112;
          if (v52 <= 64) {
            goto LABEL_38;
          }
          uint64_t v54 = v106;
          v49(v106, (uint64_t)v50, a3);
          v116 = 0x8000000000000000LL;
          if ((v29(a3, a4) & 1) != 0)
          {
            char v55 = v114(a3, a4);
            if (v55 >= 64)
            {
              unint64_t v58 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              int v59 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
              v58(&v116, &type metadata for Int, v59, a3, a4);
              unint64_t v53 = v112;
              uint64_t v60 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v54,  v28,  a3);
              v47(v28, a3);
              if ((v60 & 1) != 0) {
                goto LABEL_60;
              }
              goto LABEL_37;
            }
          }

          else
          {
            unint64_t v67 = v29(a3, a4);
            uint64_t v68 = v114(a3, a4);
            if ((v67 & 1) != 0)
            {
              if (v68 <= 64)
              {
                char v75 = AssociatedTypeWitness;
                uint64_t v76 = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                uint64_t v77 = v107;
                (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))( &qword_18180BE68,  256LL,  v75,  v76);
                (*((void (**)(char *, uint64_t))v109 + 3))(v77, a3);
                LOBYTE(v77) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                 + 16LL))( v54,  v28,  a3);
                v47(v28, a3);
                uint64_t v78 = v105;
                v49(v105, (uint64_t)v54, a3);
                if ((v77 & 1) != 0)
                {
                  v47(v78, a3);
                  goto LABEL_60;
                }

                Swift::String v109 = (const char *)v116;
                v79 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v47(v78, a3);
                v80 = v79 < (uint64_t)v109;
                unint64_t v53 = v112;
                if (v80) {
                  goto LABEL_60;
                }
              }

              else
              {
                unint64_t v71 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                uint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
                v71(&v116, &type metadata for Int, v72, a3, a4);
                unint64_t v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v54,  v28,  a3);
                v47(v28, a3);
                unint64_t v53 = v112;
                if ((v73 & 1) != 0) {
                  goto LABEL_60;
                }
              }

              goto LABEL_37;
            }

            unint64_t v53 = v112;
            if (v68 >= 64) {
              goto LABEL_37;
            }
          }

          v49(v28, (uint64_t)v54, a3);
          char v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
          if (v74 < v116) {
LABEL_60:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_37:
          v47(v54, a3);
LABEL_38:
          unint64_t v81 = v114;
          unint64_t v82 = v114(a3, a4);
          v49(v53, (uint64_t)v50, a3);
          if (v82 < 65)
          {
            char v83 = v81(a3, a4);
            v47(v53, a3);
            if (v83 != 64 || (v29(a3, a4) & 1) != 0) {
              goto LABEL_50;
            }
          }

          else
          {
            v47(v53, a3);
          }

          v84 = v110;
          v49(v110, (uint64_t)v50, a3);
          v116 = 0x7FFFFFFFFFFFFFFFLL;
          Swift::String v85 = v29(a3, a4);
          v86 = v114(a3, a4);
          if ((v85 & 1) != 0)
          {
            if (v86 > 64)
            {
              int64_t v89 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              int64_t v90 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
              int64_t v91 = &v116;
              goto LABEL_48;
            }
          }

          else if (v86 >= 64)
          {
            v115 = 0x7FFFFFFFFFFFFFFFLL;
            int64_t v89 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            int64_t v90 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
            int64_t v91 = &v115;
LABEL_48:
            v89(v91, &type metadata for Int, v90, a3, a4);
            char v92 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v28,  v84,  a3);
            v47(v28, a3);
            if ((v92 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_49;
          }

          v49(v28, (uint64_t)v84, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
LABEL_49:
          v47(v84, a3);
LABEL_50:
          uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v94 = v50;
          int64_t v35 = v93;
          v47(v94, a3);
          goto LABEL_51;
        }
      }

          Swift::String v50 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
          uint64_t v51 = v105;
          v50(v105, a2, a3);
          uint64_t v52 = v31(a3, a4);
          v50(v25, (uint64_t)v51, a3);
          if ((v52 & 1) != 0)
          {
            unint64_t v53 = v109(a3, a4);
            v48(v25, a3);
            if (v53 < 65) {
              goto LABEL_36;
            }
            unint64_t v25 = v99;
            v50(v99, (uint64_t)v51, a3);
            v111 = 0x8000000000000000LL;
            if ((v31(a3, a4) & 1) != 0)
            {
              uint64_t v54 = v109(a3, a4);
              if (v54 < 64)
              {
LABEL_31:
                v50(v29, (uint64_t)v25, a3);
                unint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v48(v29, a3);
                if (v66 < v111) {
LABEL_60:
                }
                  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
                goto LABEL_35;
              }

              goto LABEL_28;
            }

            int64_t v63 = v31(a3, a4);
            uint64_t v54 = v109(a3, a4);
            if ((v63 & 1) != 0)
            {
              if (v54 > 64)
              {
LABEL_28:
                int64_t v64 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                char v65 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
                v64(&v111, &type metadata for Int, v65, a3, a4);
                LOBYTE(v64) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                 + 16LL))( v25,  v29,  a3);
                v48(v29, a3);
                goto LABEL_35;
              }

              uint64_t v68 = AssociatedTypeWitness;
              unint64_t v67 = (void (**)(char *, uint64_t, const char *))v102;
              unint64_t v69 = swift_getAssociatedConformanceWitness( (uint64_t)v102,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v70 = v100;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v69 + 8))( &qword_18180BE68,  256LL,  v68,  v69);
              v67[3](v70, a3, (const char *)v67);
              LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                               + 16LL))( v25,  v29,  a3);
              v48(v29, a3);
              unint64_t v71 = v98;
              v50(v98, (uint64_t)v25, a3);
              if ((v67 & 1) != 0)
              {
                v48(v71, a3);
                goto LABEL_60;
              }

              uint64_t v72 = v111;
              unint64_t v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v48(v71, a3);
              char v74 = v73 < v72;
              uint64_t v51 = v105;
              if (v74) {
                goto LABEL_60;
              }
            }

            else if (v54 < 64)
            {
              goto LABEL_31;
            }
          }

          uint64_t v49 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
          Swift::String v50 = v111;
          v49(v111, a2, a3);
          uint64_t v51 = v29(a3, a4);
          v49(v24, (uint64_t)v50, a3);
          if ((v51 & 1) == 0)
          {
            v47(v24, a3);
            unint64_t v53 = v112;
            goto LABEL_38;
          }

          uint64_t v52 = v114(a3, a4);
          v47(v24, a3);
          unint64_t v53 = v112;
          if (v52 <= 64) {
            goto LABEL_38;
          }
          uint64_t v54 = v106;
          v49(v106, (uint64_t)v50, a3);
          v116 = 0x8000000000000000LL;
          if ((v29(a3, a4) & 1) != 0)
          {
            char v55 = v114(a3, a4);
            if (v55 >= 64)
            {
              unint64_t v58 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              int v59 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
              v58(&v116, &type metadata for Int, v59, a3, a4);
              unint64_t v53 = v112;
              uint64_t v60 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v54,  v28,  a3);
              v47(v28, a3);
              if ((v60 & 1) != 0) {
                goto LABEL_62;
              }
              goto LABEL_37;
            }
          }

          else
          {
            unint64_t v67 = v29(a3, a4);
            uint64_t v68 = v114(a3, a4);
            if ((v67 & 1) != 0)
            {
              if (v68 <= 64)
              {
                char v75 = AssociatedTypeWitness;
                uint64_t v76 = swift_getAssociatedConformanceWitness( (uint64_t)v109,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                uint64_t v77 = v107;
                (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))( &qword_18180BE68,  256LL,  v75,  v76);
                (*((void (**)(char *, uint64_t))v109 + 3))(v77, a3);
                LOBYTE(v77) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                 + 16LL))( v54,  v28,  a3);
                v47(v28, a3);
                uint64_t v78 = v105;
                v49(v105, (uint64_t)v54, a3);
                if ((v77 & 1) != 0)
                {
                  v47(v78, a3);
                  goto LABEL_62;
                }

                Swift::String v109 = (const char *)v116;
                v79 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v47(v78, a3);
                v80 = v79 < (uint64_t)v109;
                unint64_t v53 = v112;
                if (v80) {
                  goto LABEL_62;
                }
              }

              else
              {
                unint64_t v71 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                uint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
                v71(&v116, &type metadata for Int, v72, a3, a4);
                unint64_t v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v54,  v28,  a3);
                v47(v28, a3);
                unint64_t v53 = v112;
                if ((v73 & 1) != 0) {
                  goto LABEL_62;
                }
              }

              goto LABEL_37;
            }

            unint64_t v53 = v112;
            if (v68 >= 64) {
              goto LABEL_37;
            }
          }

          v49(v28, (uint64_t)v54, a3);
          char v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
          if (v74 < v116) {
LABEL_62:
          }
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_37:
          v47(v54, a3);
LABEL_38:
          unint64_t v81 = v114;
          unint64_t v82 = v114(a3, a4);
          v49(v53, (uint64_t)v50, a3);
          if (v82 < 65)
          {
            int64_t v91 = v81(a3, a4);
            v47(v53, a3);
            if (v91 != 64 || (v29(a3, a4) & 1) != 0) {
              goto LABEL_51;
            }
          }

          else
          {
            v47(v53, a3);
          }

          char v83 = v110;
          v49(v110, (uint64_t)v50, a3);
          v116 = 0x7FFFFFFFFFFFFFFFLL;
          v84 = v29(a3, a4);
          Swift::String v85 = v114(a3, a4);
          if ((v84 & 1) != 0)
          {
            if (v85 > 64)
            {
              uint64_t v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              int64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
              int64_t v90 = &v116;
              goto LABEL_49;
            }
          }

          else if (v85 >= 64)
          {
            v115 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            int64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
            int64_t v90 = &v115;
LABEL_49:
            v88(v90, &type metadata for Int, v89, a3, a4);
            char v92 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v28,  v83,  a3);
            v47(v28, a3);
            if ((v92 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_50;
          }

          v49(v28, (uint64_t)v83, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
LABEL_50:
          v47(v83, a3);
LABEL_51:
          uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v94 = v50;
          int64_t v35 = v93;
          v47(v94, a3);
          goto LABEL_52;
        }
      }

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 0xA;
  uint64_t v8 = v6 - 10;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 6;
  uint64_t v8 = v6 - 6;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 0x10;
  uint64_t v8 = v6 - 16;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 0x1E;
  uint64_t v8 = v6 - 30;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 8;
  uint64_t v8 = v6 - 8;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 2;
  uint64_t v8 = v6 - 2;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 4;
  uint64_t v8 = v6 - 4;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 2;
  uint64_t v8 = (v6 + 2147483646) & 0x7FFFFFFF;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

  uint64_t v6 = *a1;
  uint64_t v7 = v6 >= 3;
  uint64_t v8 = v6 - 3;
  if (!v7) {
    uint64_t v8 = -1;
  }
  return (v8 + 1);
}

      uint64_t v14 = ~(_DWORD)a6 + a2;
      if (a5 > 3)
      {
        uint64_t v16 = 1;
        goto LABEL_21;
      }

  unint64_t v15 = *a2 & 0x7FFFFFFFFFFFFFFELL;
  if (v15)
  {
    uint64_t v16 = (unsigned __int128 *)(v15 + 16);
    do
      id v17 = __ldxp(v16);
    while (__stxp(v17, v16));
    if ((v17 & 0x100000000LL) != 0)
    {
      unint64_t v15 = 0LL;
    }

    else
    {
      do
      {
        uint64_t v19 = __ldxp(v16);
        uint64_t v18 = v19;
      }

      while (__stxp(v19, v16));
      if (DWORD2(v19) == -1) {
LABEL_36:
      }
        swift::swift_abortWeakRetainOverflow((swift *)v7, (uint64_t)a2, a3, a4);
      size_t v20 = DWORD2(v19);
      uint64_t v21 = HIDWORD(*((void *)&v19 + 1));
      while (1)
      {
        unint64_t v22 = v20 + 1;
        uint64_t v23 = v20 | (unint64_t)(v21 << 32);
        uint64_t v24 = (unsigned __int128 *)(v15 + 16);
        do
        {
          while (1)
          {
            unint64_t v25 = __ldxp(v24);
            size_t v20 = DWORD2(v25);
            uint64_t v26 = (void)v25 != v18;
            if (*((void *)&v25 + 1) != v23) {
              ++v26;
            }
            if (!v26) {
              break;
            }
            if (!__stxp(v25, v24)) {
              goto LABEL_31;
            }
          }
        }

        while (__stxp(__PAIR128__(v22, v18), v24));
LABEL_31:
        if ((void)v25 == v18 && *((void *)&v25 + 1) == v23) {
          break;
        }
        uint64_t v21 = HIDWORD(*((void *)&v25 + 1));
        uint64_t v18 = v25;
        if (DWORD2(v25) == -1) {
          goto LABEL_36;
        }
      }
    }
  }

  if (v15) {
    uint64_t v33 = v15 | 1;
  }
  else {
    uint64_t v33 = 0LL;
  }
  *a1 = v33;
}

    uint64_t v13 = *a2;
    *a2 = 0LL;
    *a1 = v13;
  }

  return a1;
}

  ((void (*)(const char *, unsigned __int8 *, unint64_t, uint64_t, _BYTE *, _BYTE *, void *(*)@<X0>(const char *@<X0>, unsigned __int8 *@<X1>, unint64_t@<X2>, uint64_t@<X3>, void *@<X4>, void *@<X5>, uint64_t@<X8>)))v14)( a1,  a2,  a3,  a4,  v30,  v28,  swift_getTypeByMangledNameImpl);
  uint64_t v18 = v29;
  if (v29 == v28)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = v28;
  }

  else
  {
    if (!v29) {
      goto LABEL_22;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_22:
  BOOL result = v31;
  if (v31 == v30)
  {
    uint64_t v21 = 4LL;
    BOOL result = v30;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v21))();
  }

  ((void (*)(const char *, uint64_t, swift::Demangle::__runtime::Node *, uint64_t, _BYTE *, _BYTE *, void (*)(const char *@<X0>, uint64_t@<X1>, swift::Demangle::__runtime::Node *@<X2>, uint64_t@<X3>, void *@<X4>, void *@<X5>, uint64_t@<X8>)))v14)( a1,  a2,  a3,  a4,  v30,  v28,  swift_getTypeByMangledNodeImpl);
  uint64_t v18 = v29;
  if (v29 == v28)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = v28;
  }

  else
  {
    if (!v29) {
      goto LABEL_22;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_22:
  BOOL result = v31;
  if (v31 == v30)
  {
    uint64_t v21 = 4LL;
    BOOL result = v30;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v21))();
  }

  if (qword_18C486EF0 != -1) {
    dispatch_once_f( &qword_18C486EF0,  &Conformances,  (dispatch_function_t)swift::Lazy<ConformanceState>::defaultInitCallback);
  }
  do
    uint64_t v8 = __ldaxr(&qword_18C486E88);
  while (__stxr(v8 + 1, &qword_18C486E88));
  if (!qword_18C486E90 || (BOOL v9 = atomic_load((unint64_t *)qword_18C486E90)) == 0)
  {
    do
LABEL_34:
      size_t v20 = __ldxr(&qword_18C486E88);
    while (__stlxr(v20 - 1, &qword_18C486E88));
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v21 = (os_log_s *)swift::runtime::trace::ScanLog;
      if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
      {
        *(_DWORD *)unint64_t v25 = 134217984;
        *(void *)&v25[4] = 0LL;
        _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v21,  OS_SIGNPOST_INTERVAL_END,  v3,  "section_scan",  "result=%p",  v25,  0xCu);
      }
    }

    return 0LL;
  }

  id v10 = (int **)(qword_18C486E90 + 8);
  uint64_t v11 = qword_18C486E90 + 8 + 16 * v9;
  while (1)
  {
    uint64_t v12 = *v10;
    uint64_t v13 = v10[1];
    if (*v10 != v13) {
      break;
    }
LABEL_23:
    v10 += 2;
  }

  uint64_t v14 = *v10;
  while (1)
  {
    uint64_t v16 = (uint64_t)v12 + *v14;
    id v17 = (int *)(v16 + 4);
    uint64_t v18 = (*(_DWORD *)(v16 + 12) >> 3) & 7;
    if (v18 != 1) {
      break;
    }
    unint64_t v15 = *(const char **)((char *)v17 + *v17);
    if (v15) {
      goto LABEL_27;
    }
LABEL_28:
    ++v14;
    ++v12;
    if (v14 == v13) {
      goto LABEL_23;
    }
  }

  if (v18) {
    goto LABEL_28;
  }
  uint64_t v19 = *v17;
  if (!(_DWORD)v19) {
    goto LABEL_28;
  }
  unint64_t v15 = (char *)v17 + v19;
LABEL_27:
  if (v3 - 1 < 0xFFFFFFFFFFFFFFFELL)
  {
    unint64_t v22 = (os_log_s *)swift::runtime::trace::ScanLog;
    if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
    {
      *(_DWORD *)unint64_t v25 = 134217984;
      *(void *)&v25[4] = v15;
      _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v22,  OS_SIGNPOST_INTERVAL_END,  v3,  "section_scan",  "result=%p",  v25,  0xCu);
    }
  }

  do
    uint64_t v23 = __ldxr(&qword_18C486E88);
  while (__stlxr(v23 - 1, &qword_18C486E88));
  return v15;
}

            *(_DWORD *)a4 = 0;
            *(void *)(a4 + 8) = 0LL;
            *(_DWORD *)(a4 + 16) = 0;
LABEL_18:
            if (--v11 == -1) {
              goto LABEL_29;
            }
          }

        case 5:
          uint64_t v7 = *((unsigned int *)a2 + 2);
          if ((_DWORD)v7) {
            goto LABEL_16;
          }
          break;
        case 2:
          uint64_t v7 = 2LL;
          goto LABEL_16;
      }

      BOOL v9 = (swift::Demangle::__runtime::Node *)((char *)v9 + 8);
      if (v9 == v11) {
        goto LABEL_87;
      }
    }

    unint64_t v15 = (_DWORD **)*v13;
LABEL_23:
    switch(**v15)
    {
      case 0:
      case 1:
        if (v14 == 2) {
          goto LABEL_28;
        }
        if (v14 == 5 && *((_DWORD *)v13 + 2) >= 2u)
        {
          uint64_t v13 = (_DWORD **)*v13;
LABEL_28:
          NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)v13[1];
        }

        else
        {
          NodeWithAllocatedText = 0LL;
        }

  size_t v20 = 2316;
  uint64_t v21 = 20;
LABEL_67:
  *(_DWORD *)a3 = v21;
  *(void *)(a3 + 8) = v3;
  *(_DWORD *)(a3 + 16) = v20;
  return result;
}

            *(_DWORD *)a4 = 0;
            *(void *)(a4 + 8) = 0LL;
            *(_DWORD *)(a4 + 16) = 0;
LABEL_18:
            if (--v11 == -1) {
              goto LABEL_29;
            }
          }

        case 5:
          uint64_t v7 = *((unsigned int *)a2 + 2);
          if ((_DWORD)v7) {
            goto LABEL_16;
          }
          break;
        case 2:
          uint64_t v7 = 2LL;
          goto LABEL_16;
      }

  size_t v20 = 1867;
  uint64_t v21 = 20;
LABEL_67:
  *(_DWORD *)a3 = v21;
  *(void *)(a3 + 8) = v3;
  *(_DWORD *)(a3 + 16) = v20;
  return result;
}

BOOL static Bool.== infix(_:_:)(int a1, int a2)
{
  return ((a1 ^ a2) & 1) == 0;
}

uint64_t _precondition(_:_:file:line:)( uint64_t (*a1)(void), uint64_t a2, const char *a3, uint64_t a4, char a5, const char *a6, uint64_t a7, char a8, unint64_t a9)
{
  uint64_t result = a1();
  if ((result & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11LL, 2, a3, a4, a5, a6, a7, a8, a9, 0);
  }
  return result;
}

Swift::Void __swiftcall _ContiguousArrayBuffer._checkValidSubscript(_:)(Swift::Int a1)
{
  if (a1 < 0 || *(void *)(v1 + 16) <= (unint64_t)a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
}

Swift::Void __swiftcall _ArrayBuffer._checkInoutAndNativeTypeCheckedBounds(_:wasNativeTypeChecked:)( Swift::Int _, Swift::Bool wasNativeTypeChecked)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  BOOL v6 = wasNativeTypeChecked;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3))
  {
    if (((((v5 & 0xC000000000000001LL) != 0) ^ v6) & 1) != 0)
    {
      if (!v6) {
        return;
      }
      goto LABEL_6;
    }

LABEL_11:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "inout rules were violated: the array was overwritten",  52LL,  2,  "Swift/ArrayBuffer.swift",  23LL,  2,  0x1C4uLL,  0);
  }

  if (!v6) {
    goto LABEL_11;
  }
LABEL_6:
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v4, v4);
  if (_ < 0) {
    goto LABEL_12;
  }
  uint64_t v9 = v5 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v9 = v5;
  }
  if (*(void *)(v9 + 16) <= (unint64_t)_) {
LABEL_12:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
}

          if (++v33 == v64)
          {
            uint64_t v5 = v53;
            uint64_t v31 = v64;
            break;
          }
        }
      }

      swift_release(v32);
      swift_release(v59);
      if ((v23 & 0x8000000000000000LL) == 0)
      {
        uint64_t v46 = v54;
        *(void *)uint64_t v5 = v56;
        *(void *)(v5 + 8) = v46;
        *(void *)(v5 + 16) = v55;
        *(void *)(v5 + 24) = v23;
        char v47 = v57;
        *(_OWORD *)(v5 + 32) = v58;
        *(_OWORD *)(v5 + 48) = v47;
        return v31;
      }

    ++v21;
  }

  while (v21 != v22);
  size_t v20 = v19;
  uint64_t v21 = v22;
LABEL_34:
  id v17 = v41;
  unint64_t v15 = v42;
  uint64_t v18 = v40;
  if (v20 < 0) {
    goto LABEL_39;
  }
LABEL_35:
  int64_t v34 = v44;
  *uint64_t v44 = v15;
  v34[1] = v18;
  v34[2] = (uint64_t)v17;
  v34[3] = v19;
  int64_t v35 = v45;
  *((_OWORD *)v34 + 2) = v46;
  *((_OWORD *)v34 + 3) = v35;
  return v21;
}

          uint64_t v54 = *(TupleTypeMetadata2 - 1);
          (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v54 + 56))( v37,  v53,  1LL,  TupleTypeMetadata2);
          (*(void (**)(char *, char *, uint64_t))(v136 + 32))(v43, v37, v137);
          if ((*(unsigned int (**)(char *, uint64_t, unint64_t *))(v54 + 48))( v43,  1LL,  TupleTypeMetadata2) == 1) {
            goto LABEL_90;
          }
          char v55 = &v43[*((int *)TupleTypeMetadata2 + 12)];
          uint64_t v56 = *(void (**)(id *, char *, uint64_t *))(v138 + 32);
          v56(v134, v43, v13);
          unint64_t v57 = *(void (**)(id *, char *, uint64_t *))(v139 + 32);
          v57(v135, v55, v3);
          if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3))
          {
            if (v130 != 8) {
              goto LABEL_94;
            }
            int v61 = v135;
            int64_t v62 = *v135;
            swift_unknownObjectRetain(*v135, v58, v59, v60);
            (*(void (**)(id *, uint64_t *))(v139 + 8))(v61, v3);
          }

          else
          {
            unint64_t v71 = v123;
            v57(v123, (char *)v135, v3);
            int64_t v62 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v71, v3, v72, v73);
          }

          if (v49 == 0x1000000000000000LL)
          {
            __break(1u);
LABEL_96:
            __break(1u);
LABEL_97:
            __break(1u);
LABEL_98:
            __break(1u);
LABEL_99:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Invalid count",  13LL,  2,  "Swift/DictionaryStorage.swift",  29LL,  2,  0x188uLL,  0);
          }

          *(void *)(v132 + 8 * v49) = v62;
          swift_unknownObjectRelease(v62);
          if (_swift_isClassOrObjCExistentialType((uint64_t)v13, v13))
          {
            unint64_t v66 = v134;
            unint64_t v67 = *v134;
            swift_unknownObjectRetain(*v134, v63, v64, v65);
            (*(void (**)(id *, uint64_t *))(v138 + 8))(v66, v13);
          }

          else
          {
            char v74 = v124;
            v56(v124, (char *)v134, v13);
            unint64_t v67 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v74, v13, v75, v76);
          }

          *(void *)(v131 + 8 * v49) = v67;
          swift_unknownObjectRelease(v67);
        }

        Swift::String v50 = __clz(__rbit64(v47));
        v47 &= v47 - 1;
        uint64_t v51 = v50 | ((void)v128 << 6);
        goto LABEL_10;
      }

      uint64_t v134 = (id *)(v48 - 1);
      v135 = (id *)(v41 - 1);
      swift_retain((unint64_t *)v2, v38, v39, v40);
      uint64_t v101 = 0LL;
      int64_t v102 = 0LL;
      int64_t v103 = v133;
      if (!v47) {
        goto LABEL_75;
      }
LABEL_66:
      int64_t v104 = __clz(__rbit64(v47));
      v47 &= v47 - 1;
      char v105 = v104 | (v102 << 6);
LABEL_67:
      uint64_t v106 = v127;
      (*(void (**)(char *, unint64_t, uint64_t *))(v138 + 16))( v127,  *(void *)(v103 + 48) + *(void *)(v138 + 72) * v105,  v13);
      (*(void (**)(char *, unint64_t, uint64_t *))(v139 + 16))( &v106[*((int *)TupleTypeMetadata2 + 12)],  *(void *)(v103 + 56) + *(void *)(v139 + 72) * v105,  v3);
      uint64_t v107 = 0LL;
      while (1)
      {
        uint64_t v108 = *(TupleTypeMetadata2 - 1);
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v108 + 56))( v106,  v107,  1LL,  TupleTypeMetadata2);
        (*(void (**)(char *, char *, uint64_t))(v136 + 32))(v34, v106, v137);
        if ((*(unsigned int (**)(char *, uint64_t, unint64_t *))(v108 + 48))( v34,  1LL,  TupleTypeMetadata2) == 1) {
          break;
        }
        Swift::String v109 = *(void (**)(id *, char *, uint64_t *))(v138 + 32);
        v109(v128, v34, v13);
        if (_swift_isClassOrObjCExistentialType((uint64_t)v13, v13))
        {
          uint64_t v113 = v128;
          uint64_t v114 = *v128;
          swift_unknownObjectRetain(*v128, v110, v111, v112);
          (*(void (**)(id *, uint64_t *))(v138 + 8))(v113, v13);
        }

        else
        {
          v119 = v124;
          v109(v124, (char *)v128, v13);
          uint64_t v114 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v119, v13, v120, v121);
        }

        if (v101 == (id *)0x1000000000000000LL) {
          goto LABEL_97;
        }
        v115 = &v34[*((int *)TupleTypeMetadata2 + 12)];
        *(void *)(v131 + 8LL * (void)v101) = v114;
        swift_unknownObjectRelease(v114);
        if (v101 == v135)
        {
          swift_release(v133);
          (*(void (**)(char *, uint64_t *))(v139 + 8))(v115, v3);
          return;
        }

        uint64_t v101 = (id *)((char *)v101 + 1);
        (*(void (**)(char *, uint64_t *))(v139 + 8))(v115, v3);
        if (v47) {
          goto LABEL_66;
        }
LABEL_75:
        v116 = v102 + 1;
        if (__OFADD__(v102, 1LL)) {
          goto LABEL_101;
        }
        if (v116 >= (uint64_t)v126)
        {
          char v47 = 0LL;
          uint64_t v107 = 1LL;
          uint64_t v106 = v127;
        }

        else
        {
          v117 = *(void *)(v125 + 8 * v116);
          uint64_t v106 = v127;
          if (v117) {
            goto LABEL_78;
          }
          uint64_t v118 = (char *)(v102 + 2);
          if (v102 + 2 >= (uint64_t)v126)
          {
            char v47 = 0LL;
            uint64_t v107 = 1LL;
            ++v102;
          }

          else
          {
            v117 = *(void *)(v125 + 8LL * (void)v118);
            if (v117)
            {
              v116 = v102 + 2;
LABEL_78:
              char v47 = (v117 - 1) & v117;
              char v105 = __clz(__rbit64(v117)) + (v116 << 6);
              int64_t v102 = v116;
              goto LABEL_67;
            }

            while (1)
            {
              v116 = (uint64_t)(v118 + 1);
              if (__OFADD__(v118, 1LL)) {
                goto LABEL_104;
              }
              v117 = *(void *)(v125 + 8 * v116);
              ++v118;
              if (v117) {
                goto LABEL_78;
              }
            }

            char v47 = 0LL;
            uint64_t v107 = 1LL;
            int64_t v102 = (uint64_t)v134;
          }
        }
      }

  (*(void (**)(char *, uint64_t, unint64_t))(v35 + 16))(v12, a2, v10);
  uint64_t v33 = *(void *)(a4 + 24);
  _NativeDictionary._insert(at:key:value:)(v18, (uint64_t)v12, v36, v24, v10, v33);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v33 - 8) + 56LL))( v37,  1LL,  1LL,  v33);
}

  specialized _NativeDictionary._insert(at:key:value:)(v12, a2, a3, a1, v18);
  return (_OWORD *)swift_bridgeObjectRetain(a3, v23, v24, v25);
}

  outlined init with copy of AnyHashable((uint64_t)a2, (uint64_t)v21);
  return specialized _NativeDictionary._insert(at:key:value:)(v10, (uint64_t)v21, a1, v16);
}

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }

    uint64_t v42 = v50;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 72))(v45, v4);
    *uint64_t v42 = v39;
  }

  return result;
}

  v220 = v77;
  unint64_t v81 = v221;
  unint64_t v82 = v58(v64, v222);
  char v83 = v219;
  v84 = *(uint64_t (**)(uint64_t, uint64_t))(v219 + 56);
  Swift::String v85 = v58;
  v86 = v84(v61, v219);
  uint64_t v87 = v211;
  uint64_t v88 = v81;
  int64_t v89 = v215;
  v215(v211, (uint64_t)v88, v64);
  if (v86 < v82)
  {
    v213 = v85;
    v220(v87, v64);
    v89(v218, (uint64_t)v221, v64);
    int64_t v90 = (unsigned int (*)(uint64_t, uint64_t))v212;
    goto LABEL_13;
  }

  int64_t v102 = v221;
  int64_t v103 = v222;
  int64_t v104 = v85(v64, v222);
  v220(v87, v64);
  if (v104 != v84(v61, v83))
  {
    uint64_t v106 = v218;
    v215(v218, (uint64_t)v102, v64);
    v79 = v217;
LABEL_23:
    v220(v106, v64);
LABEL_24:
    v80 = v214;
LABEL_34:
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v79 + 96))(v221, v64, v222, v61, v79);
    uint64_t v121 = 0LL;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v216 + 56))(v80, v121, 1LL, v61);
  }

  v213 = v85;
  int64_t v90 = (unsigned int (*)(uint64_t, uint64_t))v212;
  char v105 = v212(v64, v103);
  uint64_t v106 = v218;
  v215(v218, (uint64_t)v102, v64);
  v79 = v217;
  if ((v105 & 1) != 0) {
    goto LABEL_23;
  }
LABEL_13:
  int64_t v91 = v209;
  (*(void (**)(uint64_t))(v219 + 64))(v61);
  char v92 = *(uint64_t (**)(uint64_t, uint64_t))(v79 + 64);
  uint64_t v93 = v92(v61, v79);
  if (((v93 ^ v90(v64, v222)) & 1) == 0)
  {
    uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(v79 + 128))(v61, v79);
    uint64_t v108 = v218;
    Swift::String v109 = v91;
    if (v107 >= v213(v64, v222))
    {
      v119 = v210;
      (*(void (**)(char *, char *, uint64_t))(v207 + 32))(v210, v108, v64);
      int v120 = v208;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v79 + 96))(v119, v64, v222, v61, v79);
      v99 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v79 + 32) + 8LL) + 16LL))( v91,  v120,  v61);
      uint64_t v100 = *(void (**)(char *, uint64_t))(v216 + 8);
      v100(v120, v61);
      uint64_t v101 = v91;
      goto LABEL_30;
    }

    uint64_t v110 = v222;
    v111 = v210;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v222 + 96))(v109, v61, v79, v64, v222);
    v99 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v110 + 32) + 8LL) + 16LL))( v111,  v108,  v64);
    uint64_t v112 = v111;
    uint64_t v113 = v64;
    uint64_t v114 = v108;
    goto LABEL_27;
  }

  uint64_t v94 = v92(v61, v79);
  uint64_t v95 = (*(uint64_t (**)(uint64_t, uint64_t))(v79 + 128))(v61, v79);
  Swift::String v96 = v213(v64, v222);
  if ((v94 & 1) != 0)
  {
    if (v96 < v95)
    {
      unint64_t v97 = v210;
      (*(void (**)(char *, char *, uint64_t))(v207 + 32))(v210, v218, v64);
      v98 = v208;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v79 + 96))(v97, v64, v222, v61, v79);
      v99 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v79 + 32) + 8LL) + 16LL))( v91,  v98,  v61);
      uint64_t v100 = *(void (**)(char *, uint64_t))(v216 + 8);
      v100(v98, v61);
      uint64_t v101 = v91;
LABEL_30:
      v100(v101, v61);
      uint64_t v77 = v220;
      goto LABEL_31;
    }

    v128 = AssociatedTypeWitness;
    char v129 = v205;
    v130 = swift_getAssociatedConformanceWitness( (uint64_t)v205,  v61,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v131 = v203;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v130 + 8))( &unk_18180BE68,  256LL,  v128,  v130);
    uint64_t v132 = v208;
    (*((void (**)(char *, uint64_t, const char *))v129 + 3))(v131, v61, v129);
    LOBYTE(v128) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v79 + 32) + 8LL) + 16LL))( v91,  v132,  v61);
    BOOL v133 = v216;
    uint64_t v134 = *(void (**)(char *, uint64_t))(v216 + 8);
    v134(v132, v61);
    v135 = *(void (**)(char *, char *, uint64_t))(v133 + 32);
    char v136 = v198;
    v135(v198, v91, v61);
    v137 = v197;
    (*(void (**)(char *, char *, uint64_t))(v207 + 32))(v197, v218, v64);
    if ((v128 & 1) != 0)
    {
      v138 = (void (*)(uint64_t, uint64_t))v220;
      v220(v137, v64);
      v134(v136, v61);
      v80 = v214;
      v138((uint64_t)v221, v64);
      goto LABEL_33;
    }

    uint64_t v157 = v222;
    v158 = v136;
    v159 = v210;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v222 + 96))(v158, v61, v79, v64, v222);
    v99 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v157 + 32) + 8LL) + 16LL))( v159,  v137,  v64);
    uint64_t v77 = v220;
    v220(v159, v64);
    uint64_t v118 = v137;
LABEL_28:
    v77(v118, v64);
    goto LABEL_31;
  }

  if (v95 < v96)
  {
    v115 = v222;
    v116 = v210;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v222 + 96))(v91, v61, v79, v64, v222);
    v117 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v115 + 32) + 8LL) + 16LL);
    uint64_t v114 = v218;
    v99 = v117(v116, v218, v64);
    uint64_t v112 = v116;
    uint64_t v113 = v64;
LABEL_27:
    uint64_t v77 = v220;
    v220(v112, v113);
    uint64_t v118 = v114;
    goto LABEL_28;
  }

  v139 = v202;
  v140 = v201;
  v141 = swift_getAssociatedConformanceWitness( (uint64_t)v202,  v64,  v201,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v142 = v200;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v141 + 8))( &unk_18180BE68,  256LL,  v140,  v141);
  v143 = v210;
  (*((void (**)(char *, uint64_t, const char *))v139 + 3))(v142, v64, v139);
  unint64_t v144 = v218;
  LOBYTE(v140) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v222 + 32) + 8LL) + 40LL))( v218,  v143,  v64);
  v145 = v143;
  uint64_t v77 = v220;
  v220(v145, v64);
  v146 = v216;
  v147 = v199;
  (*(void (**)(char *, char *, uint64_t))(v216 + 32))(v199, v91, v61);
  uint64_t v148 = v196;
  (*(void (**)(char *, char *, uint64_t))(v207 + 32))(v196, v144, v64);
  if ((v140 & 1) == 0)
  {
    v77(v148, v64);
    (*(void (**)(char *, uint64_t))(v146 + 8))(v147, v61);
    goto LABEL_24;
  }

  v149 = v146;
  v150 = v208;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v79 + 96))(v148, v64, v222, v61, v79);
  v99 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v79 + 32) + 8LL) + 16LL))( v147,  v150,  v61);
  v151 = *(void (**)(char *, uint64_t))(v149 + 8);
  v151(v150, v61);
  v151(v147, v61);
LABEL_31:
  v80 = v214;
  if ((v99 & 1) == 0) {
    goto LABEL_34;
  }
LABEL_32:
  v77(v221, v64);
LABEL_33:
  uint64_t v121 = 1LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v216 + 56))(v80, v121, 1LL, v61);
}

  if (__OFSUB__(v11 - rawValue, v14))
  {
LABEL_41:
    __break(1u);
LABEL_42:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if (v11 - rawValue - v14 < 0) {
    goto LABEL_42;
  }
  into->_position.value._rawValue = &rawValue[v14];
  into->_end.value._rawValue = v11;
}

    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3) && (v15 < 0 || (v15 & 0x4000000000000000LL) != 0))
    {
      if (v15 < 0) {
        unint64_t v25 = (void *)v15;
      }
      else {
        unint64_t v25 = (void *)(v15 & 0xFFFFFFFFFFFFFF8LL);
      }
      swift_unknownObjectRetain(v25, v19, v20, v21);
      if (v17) {
        goto LABEL_18;
      }
    }

    else
    {
      else {
        unint64_t v25 = (void *)v15;
      }
      swift_bridgeObjectRetain(v15, v22, v23, v24);
      if (v17) {
        goto LABEL_18;
      }
    }

    (*(void (**)(unint64_t, uint64_t, uint64_t))(a5 + 56))( ~*(_BYTE *)(*(a3 - 1) + 80) | 0xFFFFFFFFFFFFFF00LL,  a4,  a5);
    return v25;
  }

  if (!Array._getCount()())
  {
    swift_bridgeObjectRelease(v15);
    id v17 = 0LL;
    goto LABEL_11;
  }

  unint64_t v30 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a3, v27, v28);
  uint64_t v32 = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v30, v31);
  unint64_t v25 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v32 + 56))(v30, v32);
  uint64_t v33 = *(unsigned __int8 *)(*(a3 - 1) + 80);
  id v17 = (uint64_t)v25 + ((v33 + 32) & ~v33);
LABEL_18:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a5 + 56))(v17, a4, a5);
  return v25;
}

  uint64_t v8 = a4;
  uint64_t v7 = a5;
LABEL_13:
  swift_bridgeObjectRelease(a3);
  v25._uint64_t countAndFlagsBits = v8;
  v25._uint64_t object = v7;
  String.write(_:)(v25);
}

  if (v6 < v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  if (a1 >= 0x100)
  {
    id v10 = a1 >> 8;
    while (v3 >= v10)
    {
      if (HIBYTE(v7)) {
        goto LABEL_32;
      }
      v7 |= v10 << (-(__clz(v7) & 0x18) & 0x18);
      uint64_t v5 = v10 >= 0x100;
      v10 >>= 8;
      if (!v5) {
        goto LABEL_13;
      }
    }

    goto LABEL_28;
  }

      ++v18;
    }

    while (v18 != v5);
  }

  swift_release((uint64_t)v17);
  swift_release(v8);
  if ((v14 & 0x8000000000000000LL) != 0) {
    goto LABEL_32;
  }
  *(void *)a1 = v11;
  *(void *)(a1 + 8) = v25;
  *(void *)(a1 + 16) = v26;
  *(void *)(a1 + 24) = v14;
  *(_OWORD *)(a1 + 32) = v28;
  *(_OWORD *)(a1 + 48) = v27;
  return v5;
}

    ++v21;
  }

  while (v21 != v22);
  size_t v20 = v19;
  uint64_t v21 = v22;
LABEL_34:
  id v17 = v41;
  unint64_t v15 = v42;
  uint64_t v18 = v40;
  if (v20 < 0) {
    goto LABEL_39;
  }
LABEL_35:
  int64_t v34 = v44;
  *uint64_t v44 = v15;
  v34[1] = v18;
  v34[2] = (uint64_t)v17;
  v34[3] = v19;
  int64_t v35 = v45;
  *((_OWORD *)v34 + 2) = v46;
  *((_OWORD *)v34 + 3) = v35;
  return v21;
}

  *a1 = v8;
  a1[1] = v11;
  return v12;
}

    Unicode.UTF8.ForwardParser._invalidLength()();
    uint64_t v1 = 0;
    goto LABEL_12;
  }

  if ((v0 & 0x1E) == 0) {
    goto LABEL_11;
  }
LABEL_3:
  uint64_t v1 = 1;
LABEL_12:
  result.bitCount = v2;
  result.isValid = v1;
  return result;
}

  uint64_t v21 = v37;
  unint64_t v22 = v36;
  (*(void (**)(char *, uint64_t, uint64_t))(v38 + 16))(v35, v36, v37);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v21, v7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  v21,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v24 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v24(&v39, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v39 & 0x100) == 0)
  {
    unint64_t v25 = v39;
    while (!HIBYTE(v18))
    {
      v18 |= (v25 + 1) << (-(__clz(v18) & 0x18) & 0x18);
      v24(&v39, AssociatedTypeWitness, AssociatedConformanceWitness);
      unint64_t v25 = v39;
      if (BYTE1(v39) == 1) {
        goto LABEL_15;
      }
    }

    goto LABEL_21;
  }

        _S0 = floorf(_S0);
      }

      else
      {
        __asm { FCVT            S0, H0 }

        _S0 = ceilf(_S0);
      }

        _S0 = floorf(_S0);
      }

      else
      {
        __asm { FCVT            S0, H0 }

        _S0 = ceilf(_S0);
      }

  if (!v5) {
    return 0LL;
  }
  id v10 = *(void *)(a3 + (((unint64_t)*(unsigned int *)(*(void *)(a3 + 8) + 20LL) >> 21) & 0x7F8));
  uint64_t v11 = v4 - v10;
  uint64_t v12 = 0;
  switch(v11)
  {
    case 0LL:
      break;
    case 1LL:
      uint64_t v12 = a1[v10];
      break;
    case 2LL:
      uint64_t v12 = *(unsigned __int16 *)&a1[v10];
      break;
    case 3LL:
      uint64_t v12 = *(unsigned __int16 *)&a1[v10] | (a1[v10 + 2] << 16);
      break;
    default:
      uint64_t v12 = *(_DWORD *)&a1[v10];
      break;
  }

  if (v11 == 4) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = -1 << (8 * v11);
  }
  unint64_t v15 = v12 | v14;
  if (__CFADD__(v15, v5)) {
    return -v15;
  }
  else {
    return 0LL;
  }
}

  memset(&v26, 0, sizeof(v26));
  if (a4)
  {
    uint64_t v13 = 0LL;
    while (1)
    {
      uint64_t v14 = a3 + 16LL * v13;
      unint64_t v15 = *(void *)(v14 + 8);
      size = v26.__r_.__value_.__s.__size_;
      if ((v26.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        size = v26.__r_.__value_.__l.__size_;
      }
      if (v15)
      {
        id v17 = *(const std::string::value_type **)v14;
        if (!size) {
          std::string::append(&v26, v13, 32);
        }
        std::string::append(&v26, v17, v15);
      }

      else if (!size)
      {
        goto LABEL_15;
      }

      std::string::push_back(&v26, 32);
LABEL_15:
      if (a4 == ++v13)
      {
        uint64_t v18 = v26.__r_.__value_.__s.__size_;
        uint64_t v19 = v26.__r_.__value_.__l.__size_;
        goto LABEL_25;
      }
    }
  }

  uint64_t v19 = 0LL;
  uint64_t v18 = 0;
LABEL_25:
  if ((v18 & 0x80u) == 0) {
    uint64_t v21 = v18;
  }
  else {
    uint64_t v21 = v19;
  }
  if (v21) {
    unint64_t v22 = v7 | 0x10000;
  }
  else {
    unint64_t v22 = v7;
  }
  if ((v18 & 0x80) != 0)
  {
    if (v19) {
      uint64_t v23 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    else {
      uint64_t v23 = 0LL;
    }
  }

  else if (v18)
  {
    uint64_t v23 = &v26;
  }

  else
  {
    uint64_t v23 = 0LL;
  }

  TupleTypeMetadata = swift_getTupleTypeMetadata((const char *)0xFF, v22, (uint64_t)a1, (const char *)v23, 0LL);
  *(_WORD *)(a5 + 16) = 0;
  *(void *)a5 = TupleTypeMetadata;
  if (TupleTypeMetadata)
  {
  }

  else
  {
    *(void *)a5 = "unknown error";
    *(void *)(a5 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
    *(_WORD *)(a5 + 16) = 1;
  }

  operator delete(v26.__r_.__value_.__l.__data_);
}

    uint64_t v9 = *(unsigned __int16 **)(a2 + 8);
    if (!v9)
    {
LABEL_18:
      BOOL v6 = 0LL;
      uint64_t v8 = 0LL;
      goto LABEL_19;
    }

  if (a2[v3 - 1] == 95)
  {
    uint64_t v8 = v3 - 1;
    if (v3 < v3 - 1) {
      uint64_t v8 = v3;
    }
    if (v8)
    {
      while (a2[v8 - 1] - 48 <= 9)
      {
        if (v8 >= v8 - 1) {
          --v8;
        }
        if (!v8) {
          goto LABEL_39;
        }
      }

      if (v8 >= 2 && (*(_WORD *)&a2[v8 - 2] == 20820 || *(_WORD *)&a2[v8 - 2] == 22868))
      {
        if (v8 >= v8 - 2) {
          uint64_t v3 = v8 - 2;
        }
        else {
          uint64_t v3 = v8;
        }
      }
    }
  }

  uint64_t v13 = 0;
  return swift::Demangle::__runtime::Demangler::getDependentGenericParamType(this, v13, v9, a4, a5);
}

        *(_DWORD *)a4 = 1;
        *(void *)(a4 + 8) = a2;
        *(_DWORD *)(a4 + 16) = 2116;
        return;
      }

      break;
  }

  uint64_t v8 = *((_DWORD *)this + 3184);
  uint64_t v9 = *((unsigned int *)this + 3185);
  id v10 = (char *)this[1591];
  if (v8 >= v9)
  {
    uint64_t v11 = this[1593];
    uint64_t v12 = (char *)v11[1];
    if (&v10[v9] == v12)
    {
      uint64_t v14 = (unint64_t)&v10[v9 + 1];
      uint64_t v13 = v11[2];
      if (v14 <= v13)
      {
        v11[1] = v14;
        LODWORD(v15) = 1;
LABEL_28:
        *((_DWORD *)this + 3185) = v9 + v15;
        goto LABEL_29;
      }
    }

    else
    {
      uint64_t v13 = v11[2];
    }

    else {
      unint64_t v15 = (2 * v9);
    }
    uint64_t v16 = v15 + v9;
    if (v12) {
      id v17 = (unint64_t)&v12[v15 + v9] > v13;
    }
    else {
      id v17 = 1;
    }
    id v10 = (char *)v11[1];
    if (v17)
    {
      uint64_t v18 = 2LL * v11[4];
      if (v18 <= v16 + 1) {
        uint64_t v18 = v16 + 1;
      }
      v11[4] = v18;
      uint64_t v19 = v18 + 8;
      size_t v20 = malloc(v18 + 8);
      uint64_t v21 = (char *)v20 + v19;
      char *v20 = v11[3];
      id v10 = (char *)(v20 + 1);
      v11[2] = v21;
      v11[3] = v20;
    }

    v11[1] = &v10[v16];
    if ((_DWORD)v9)
    {
      memcpy(v10, this[1591], v9);
      LODWORD(v9) = *((_DWORD *)this + 3185);
      uint64_t v8 = *((_DWORD *)this + 3184);
    }

    this[1591] = v10;
    goto LABEL_28;
  }

uint64_t _ContiguousArrayBuffer.capacity.getter(uint64_t a1)
{
  return *(void *)(a1 + 24) >> 1;
}

Swift::String::Index specialized Collection.count.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v4 = a1;
  }
  uint64_t v5 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v5 = 11LL;
  }
  v6._rawBits = v5 | (v4 << 16);
  v7._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)15LL)._rawBits;
  result._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v6)._rawBits;
  Swift::UInt64 v9 = result._rawBits >> 14;
  if (v7._rawBits >> 14 < result._rawBits >> 14)
  {
    for (uint64_t i = 0LL; ; ++i)
    {
      uint64_t v11 = i + 1;
      if (__OFADD__(i, 1LL)) {
        break;
      }
      if ((a2 & 0x1000000000000000LL) != 0)
      {
        result._rawBits = String.UnicodeScalarView._foreignIndex(after:)(v7)._rawBits;
        v7._rawBits = result._rawBits;
      }

      else
      {
        Swift::UInt64 v12 = v7._rawBits >> 16;
        if ((a2 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = a1;
          uint64_t v23 = a2 & 0xFFFFFFFFFFFFFFLL;
          int v13 = *((unsigned __int8 *)&v22 + v12);
        }

        else
        {
          result._rawBits = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((a1 & 0x1000000000000000LL) == 0) {
            result._rawBits = (Swift::UInt64)_StringObject.sharedUTF8.getter(a1, a2);
          }
          int v13 = *(unsigned __int8 *)(result._rawBits + v12);
        }

        int v14 = (char)v13;
        unsigned int v15 = __clz(v13 ^ 0xFF) - 24;
        if (v14 >= 0) {
          LOBYTE(v15) = 1;
        }
        v7._rawBits = ((v12 + v15) << 16) | 5;
      }

      if (v9 <= v7._rawBits >> 14) {
        return (Swift::String::Index)v11;
      }
    }

    __break(1u);
LABEL_40:
    __break(1u);
    return result;
  }

  if (v9 < v7._rawBits >> 14)
  {
    uint64_t v11 = 0LL;
    while (!__OFSUB__(v11--, 1LL))
    {
      if ((a2 & 0x1000000000000000LL) != 0)
      {
        result._rawBits = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
        v7._rawBits = result._rawBits;
      }

      else
      {
        if ((a2 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = a1;
          uint64_t v23 = a2 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v22 + (v7._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v20 = 0LL;
            do
              int v21 = *((_BYTE *)&v22 + (v7._rawBits >> 16) + v20-- - 2) & 0xC0;
            while (v21 == 128);
            uint64_t v19 = 1 - v20;
          }

          else
          {
            uint64_t v19 = 1LL;
          }
        }

        else
        {
          result._rawBits = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((a1 & 0x1000000000000000LL) == 0) {
            result._rawBits = (Swift::UInt64)_StringObject.sharedUTF8.getter(a1, a2);
          }
          uint64_t v17 = 0LL;
          do
            int v18 = *(_BYTE *)(result._rawBits + (v7._rawBits >> 16) - 1 + v17--) & 0xC0;
          while (v18 == 128);
          uint64_t v19 = -v17;
        }

        v7._rawBits = (v7._rawBits - (v19 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (v9 >= v7._rawBits >> 14) {
        return (Swift::String::Index)v11;
      }
    }

    goto LABEL_40;
  }

  return 0LL;
}

Swift::String::Index specialized Collection.count.getter( Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, uint64_t a4)
{
  v7._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(a1)._rawBits;
  result._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(a2)._rawBits;
  Swift::UInt64 v9 = result._rawBits >> 14;
  if (v7._rawBits >> 14 < result._rawBits >> 14)
  {
    for (uint64_t i = 0LL; ; ++i)
    {
      uint64_t v11 = i + 1;
      if (__OFADD__(i, 1LL)) {
        break;
      }
      if ((a4 & 0x1000000000000000LL) != 0)
      {
        result._rawBits = String.UnicodeScalarView._foreignIndex(after:)(v7)._rawBits;
        v7._rawBits = result._rawBits;
      }

      else
      {
        Swift::UInt64 v12 = v7._rawBits >> 16;
        if ((a4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = a3;
          uint64_t v23 = a4 & 0xFFFFFFFFFFFFFFLL;
          int v13 = *((unsigned __int8 *)&v22 + v12);
        }

        else
        {
          result._rawBits = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((a3 & 0x1000000000000000LL) == 0) {
            result._rawBits = (Swift::UInt64)_StringObject.sharedUTF8.getter(a3, a4);
          }
          int v13 = *(unsigned __int8 *)(result._rawBits + v12);
        }

        int v14 = (char)v13;
        unsigned int v15 = __clz(v13 ^ 0xFF) - 24;
        if (v14 >= 0) {
          LOBYTE(v15) = 1;
        }
        v7._rawBits = ((v12 + v15) << 16) | 5;
      }

      if (v9 <= v7._rawBits >> 14) {
        return (Swift::String::Index)v11;
      }
    }

    __break(1u);
LABEL_36:
    __break(1u);
    return result;
  }

  if (v9 < v7._rawBits >> 14)
  {
    uint64_t v11 = 0LL;
    while (!__OFSUB__(v11--, 1LL))
    {
      if ((a4 & 0x1000000000000000LL) != 0)
      {
        result._rawBits = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
        v7._rawBits = result._rawBits;
      }

      else
      {
        if ((a4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v22 = a3;
          uint64_t v23 = a4 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v22 + (v7._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            uint64_t v20 = 0LL;
            do
              int v21 = *((_BYTE *)&v22 + (v7._rawBits >> 16) + v20-- - 2) & 0xC0;
            while (v21 == 128);
            uint64_t v19 = 1 - v20;
          }

          else
          {
            uint64_t v19 = 1LL;
          }
        }

        else
        {
          result._rawBits = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
          if ((a3 & 0x1000000000000000LL) == 0) {
            result._rawBits = (Swift::UInt64)_StringObject.sharedUTF8.getter(a3, a4);
          }
          uint64_t v17 = 0LL;
          do
            int v18 = *(_BYTE *)(result._rawBits + (v7._rawBits >> 16) - 1 + v17--) & 0xC0;
          while (v18 == 128);
          uint64_t v19 = -v17;
        }

        v7._rawBits = (v7._rawBits - (v19 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
      }

      if (v9 >= v7._rawBits >> 14) {
        return (Swift::String::Index)v11;
      }
    }

    goto LABEL_36;
  }

  return 0LL;
}

Swift::Int specialized Collection.count.getter( Swift::String::Index from, Swift::String::Index to, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = from._rawBits;
  uint64_t v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = 4LL << v8;
  if ((from._rawBits & 0xC) == 4LL << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(from)._rawBits;
  }
  if ((to._rawBits & 0xC) == v9)
  {
    to._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
    if ((a4 & 0x1000000000000000LL) == 0) {
      return (to._rawBits >> 16) - (rawBits >> 16);
    }
  }

  else if ((a4 & 0x1000000000000000LL) == 0)
  {
    return (to._rawBits >> 16) - (rawBits >> 16);
  }

  unint64_t v11 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    unint64_t v11 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v11 < rawBits >> 16 || v11 < to._rawBits >> 16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
  }
  return String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)rawBits, to);
}

Swift::UInt64 specialized Collection.count.getter( uint64_t a1, unint64_t a2, void (*a3)(unint64_t *__return_ptr, uint64_t *), char *a4)
{
  v13[0] = a1;
  v13[1] = a2;
  swift_bridgeObjectRetain(a2, a2, (uint64_t)a3, a4);
  a3((unint64_t *)&v14, v13);
  swift_bridgeObjectRelease(a2);
  uint64_t v9 = v14;
  unint64_t v8 = v15;
  swift_bridgeObjectRelease(v15);
  uint64_t v10 = HIBYTE(v8) & 0xF;
  if ((v8 & 0x2000000000000000LL) == 0) {
    uint64_t v10 = v9 & 0xFFFFFFFFFFFFLL;
  }
  if (v10) {
    unint64_t v11 = 15LL;
  }
  else {
    unint64_t v11 = 0LL;
  }
  return specialized FlattenSequence<>.distance(from:to:)( v10 == 0,  v11,  v10 == 0,  1LL,  0LL,  1,  a1,  a2,  a3,  (unint64_t *)a4);
}

uint64_t Collection.count.getter(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v5 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v6 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v14 - v9;
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(a2 + 72))(a1, a2);
  uint64_t v11 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a2 + 152))(v10, v8, a1, a2);
  Swift::UInt64 v12 = *(void (**)(char *, unint64_t))(v5 + 8);
  v12(v8, AssociatedTypeWitness);
  v12(v10, AssociatedTypeWitness);
  return v11;
}

void _ArrayBuffer.getElement(_:wasNativeTypeChecked:)( unint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(a4 - 1) + 16))( a5,  a3 + ((*(unsigned __int8 *)(*(a4 - 1) + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(a4 - 1) + 80))
    + *(void *)(*(a4 - 1) + 72) * a1,
      a4);
  }

  else
  {
    id v7 = _ArrayBuffer._getElementSlowPath(_:)(a1, a3, a4);
    unint64_t v8 = v7;
    uint64_t v9 = *(a4 - 1);
    if (*(void *)(v9 + 64) != 8LL)
    {
      swift_unknownObjectRelease(v7);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    id v10 = v7;
    (*(void (**)(uint64_t, id *, uint64_t *))(v9 + 16))(a5, &v10, a4);
    swift_unknownObjectRelease(v8);
  }

id specialized _ArrayBuffer._getElementSlowPath(_:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if ((unint64_t)a2 >> 62)
  {
    if (a2 < 0) {
      uint64_t v6 = (void *)a2;
    }
    else {
      uint64_t v6 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
    }
    return objc_msgSend(v6, sel_objectAtIndex_, a1);
  }

  else
  {
    if ((a1 & 0x8000000000000000LL) != 0 || *(void *)((a2 & 0xFFFFFFFFFFFFFF8LL) + 0x10) <= a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }
    return swift_unknownObjectRetain(*(id *)((a2 & 0xFFFFFFFFFFFFFF8LL) + 8 * a1 + 0x20), a2, a1, a4);
  }

id _ArrayBuffer._getElementSlowPath(_:)(unint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(a3 - 1);
  uint64_t v7 = MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v129 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v11 = (char *)&v129 - v10;
  if (!_swift_isClassOrObjCExistentialType((uint64_t)v12, v12) || !((unint64_t)a2 >> 62))
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
    if ((a1 & 0x8000000000000000LL) != 0
      || (!isClassOrObjCExistentialType ? (uint64_t v21 = a2) : (uint64_t v21 = a2 & 0xFFFFFFFFFFFFFF8LL), *(void *)(v21 + 16) <= a1))
    {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }

    id v14 = *(id *)((a2 & 0xFFFFFFFFFFFFFF8LL) + 8 * a1 + 0x20);
    v129._uint64_t countAndFlagsBits = (uint64_t)v14;
    swift_unknownObjectRetain_n((uint64_t)v14, 2LL, v19, v20);
    if (swift_dynamicCast(v11, &v129._countAndFlagsBits, (swift *)&unk_189B8D230, (const char *)a3, 6uLL))
    {
      (*(void (**)(char *, uint64_t *))(v6 + 8))(v11, a3);
      return v14;
    }

    uint64_t v27 = specialized static String._createEmpty(withInitialCapacity:)(82LL);
    uint64_t v29 = v28;
    v129._uint64_t countAndFlagsBits = v27;
    v129._uint64_t object = (void *)v28;
    uint64_t v30 = HIBYTE(v28) & 0xF;
    if ((v28 & 0x2000000000000000LL) == 0) {
      uint64_t v30 = v27 & 0xFFFFFFFFFFFFLL;
    }
    if (v30 || (v27 & ~v28 & 0x2000000000000000LL) != 0)
    {
      if ((v28 & 0x2000000000000000LL) != 0
        && ((unint64_t)"ize with negative count" & 0x2000000000000000LL) != 0
        && (unint64_t v36 = specialized _SmallString.init(_:appending:)(v27, v28, 0xD000000000000043LL, 0x80000001818B48D0LL),
            (v38 & 1) == 0))
      {
        uint64_t v39 = v36;
        uint64_t v40 = v37;
        swift_bridgeObjectRelease(v29);
        v129._uint64_t countAndFlagsBits = v39;
        v129._uint64_t object = v40;
      }

      else
      {
        else {
          unint64_t v51 = 67LL;
        }
        _StringGuts.append(_:)(0xD000000000000043LL, 0x80000001818B48D0LL, 0LL, v51);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v28);
      v129._uint64_t countAndFlagsBits = 0xD000000000000043LL;
      v129._uint64_t object = (void *)0x80000001818B48D0LL;
    }

    TypeName = (uint64_t *)swift_getTypeName((unint64_t)a3, 0);
    if (v53 < 0) {
      goto LABEL_135;
    }
    uint64_t v54 = (uint8x16_t *)TypeName;
    int64_t v55 = v53;
    int64_t v56 = validateUTF8(_:)(TypeName, v53);
    if ((v58 & 1) != 0) {
      unint64_t v59 = repairUTF8(_:firstKnownBrokenRange:)(v54->i8, v55, v56, v57);
    }
    else {
      unint64_t v59 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v54, v55, v56 & 1);
    }
    uint64_t countAndFlagsBits = v59;
    unint64_t v66 = v60;
    uint64_t object = v129._object;
    unint64_t v68 = ((unint64_t)v129._object >> 56) & 0xF;
    if (!v68 && (v129._countAndFlagsBits & ~(uint64_t)v129._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v129._object);
      v129._uint64_t countAndFlagsBits = countAndFlagsBits;
      v129._uint64_t object = (void *)v66;
      goto LABEL_102;
    }

    if (((uint64_t)v129._object & 0x2000000000000000LL) != 0)
    {
      if ((v60 & 0x2000000000000000LL) != 0)
      {
        unint64_t v99 = specialized _SmallString.init(_:appending:)( v129._countAndFlagsBits,  (unint64_t)v129._object,  v59,  v60);
        if ((v101 & 1) == 0)
        {
          uint64_t v102 = v99;
          int64_t v103 = v100;
          swift_bridgeObjectRelease(v66);
          swift_bridgeObjectRelease((uint64_t)object);
          v129._uint64_t countAndFlagsBits = v102;
          v129._uint64_t object = v103;
          unint64_t v66 = (unint64_t)v103;
          uint64_t countAndFlagsBits = v102;
          goto LABEL_102;
        }

        goto LABEL_100;
      }
    }

    else if ((v60 & 0x2000000000000000LL) != 0)
    {
LABEL_100:
      uint64_t v70 = HIBYTE(v66) & 0xF;
      goto LABEL_101;
    }

    uint64_t v70 = v59 & 0xFFFFFFFFFFFFLL;
LABEL_101:
    _StringGuts.append(_:)(countAndFlagsBits, v66, 0LL, v70);
    swift_bridgeObjectRelease(v66);
    uint64_t countAndFlagsBits = v129._countAndFlagsBits;
    unint64_t v66 = (unint64_t)v129._object;
LABEL_102:
    Swift::String v104 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" but found ", 0xBuLL, 1);
    uint64_t v105 = HIBYTE(v66) & 0xF;
    if ((v66 & 0x2000000000000000LL) == 0) {
      uint64_t v105 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v105 && (countAndFlagsBits & ~v66 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v66);
      Swift::String v129 = v104;
      goto LABEL_116;
    }

    if ((v66 & 0x2000000000000000LL) != 0)
    {
      if (((uint64_t)v104._object & 0x2000000000000000LL) != 0)
      {
        unint64_t v107 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  v66,  v104._countAndFlagsBits,  (unint64_t)v104._object);
        if ((v109 & 1) == 0)
        {
          uint64_t v110 = v107;
          v111 = v108;
          swift_bridgeObjectRelease((uint64_t)v104._object);
          swift_bridgeObjectRelease(v66);
          v129._uint64_t countAndFlagsBits = v110;
          v129._uint64_t object = v111;
          goto LABEL_116;
        }

        goto LABEL_114;
      }
    }

    else if (((uint64_t)v104._object & 0x2000000000000000LL) != 0)
    {
LABEL_114:
      uint64_t v106 = ((unint64_t)v104._object >> 56) & 0xF;
      goto LABEL_115;
    }

    uint64_t v106 = v104._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_115:
    _StringGuts.append(_:)(v104._countAndFlagsBits, (unint64_t)v104._object, 0LL, v106);
    swift_bridgeObjectRelease((uint64_t)v104._object);
LABEL_116:
    unint64_t ObjectType = swift_getObjectType((unint64_t)v14);
    swift_unknownObjectRelease(v14);
    uint64_t v113 = (uint64_t *)swift_getTypeName(ObjectType, 0);
    if ((v114 & 0x8000000000000000LL) == 0)
    {
      v115 = (uint8x16_t *)v113;
      int64_t v116 = v114;
      int64_t v117 = validateUTF8(_:)(v113, v114);
      if ((v119 & 1) != 0) {
        uint64_t v120 = repairUTF8(_:firstKnownBrokenRange:)(v115->i8, v116, v117, v118);
      }
      else {
        uint64_t v120 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v115, v116, v117 & 1);
      }
      uint64_t v94 = v120;
      unint64_t v95 = v121;
      unint64_t v96 = v129._countAndFlagsBits;
      unint64_t v97 = (unint64_t)v129._object;
      unint64_t v122 = ((unint64_t)v129._object >> 56) & 0xF;
      if (v122 || (v129._countAndFlagsBits & ~(uint64_t)v129._object & 0x2000000000000000LL) != 0)
      {
LABEL_125:
        if ((v97 & 0x2000000000000000LL) != 0)
        {
          if ((v95 & 0x2000000000000000LL) != 0)
          {
            unint64_t v124 = specialized _SmallString.init(_:appending:)(v96, v97, v94, v95);
            if ((v126 & 1) == 0)
            {
              unint64_t v127 = v124;
              unint64_t v128 = v125;
              swift_bridgeObjectRelease(v95);
              swift_bridgeObjectRelease(v97);
              unint64_t v95 = v128;
              uint64_t v94 = v127;
              goto LABEL_134;
            }

            uint64_t v123 = HIBYTE(v95) & 0xF;
LABEL_133:
            _StringGuts.append(_:)(v94, v95, 0LL, v123);
            swift_bridgeObjectRelease(v95);
            uint64_t v94 = v129._countAndFlagsBits;
            unint64_t v95 = (unint64_t)v129._object;
LABEL_134:
            _assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)v94, v95, 0);
          }
        }

        else if ((v95 & 0x2000000000000000LL) != 0)
        {
          uint64_t v123 = HIBYTE(v95) & 0xF;
          goto LABEL_133;
        }

        uint64_t v123 = v94 & 0xFFFFFFFFFFFFLL;
        goto LABEL_133;
      }

LABEL_124:
      swift_bridgeObjectRelease(v97);
      goto LABEL_134;
    }

    uint64_t v102 = HIBYTE(v2) & 0xF;
    int64_t v103 = HIBYTE(v5) & 0xF;
    Swift::String v104 = v103 + v102;
    if (v103)
    {
      uint64_t v105 = 0;
      uint64_t v106 = 0LL;
      do
      {
        unint64_t v107 = v102 + v106;
        uint64_t v108 = v106 + 1;
        if (v106 >= 8) {
          char v109 = v5;
        }
        else {
          char v109 = v12;
        }
        uint64_t v110 = v109 >> (v105 & 0x38);
        v111 = (8 * v102 + v105) & 0x38;
        uint64_t v112 = (-255LL << v111) - 1;
        uint64_t v113 = (unint64_t)v110 << v111;
        uint64_t v114 = v113 | v112 & v2;
        v115 = v113 | v112 & v7;
        if (v107 < 8) {
          uint64_t v7 = v115;
        }
        else {
          uint64_t v2 = v114;
        }
        v105 += 8;
        uint64_t v106 = v108;
      }

      while (v103 != v108);
    }

    swift_bridgeObjectRelease(v13);
    swift_bridgeObjectRelease(v4);
    int64_t v118 = 0xA000000000000000LL;
    if (!(v7 & 0x8080808080808080LL | v2 & 0x80808080808080LL)) {
      int64_t v118 = 0xE000000000000000LL;
    }
    char v119 = v118 & 0xFF00000000000000LL | (v104 << 56) | v2 & 0xFFFFFFFFFFFFFFLL;
LABEL_170:
    v199 = v7;
    v200 = v119;
  }

  swift_bridgeObjectRelease(v200);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v13;
}

                        ++v65;
                        continue;
                      }

                      if (*(_BYTE *)(**(void **)v71 + 18LL) == 3) {
                        goto LABEL_124;
                      }
                    }

                    if (v73 == 3)
                    {
                      v439 = *(_DWORD *)(v71 + 8);
                      v440 = *(const char **)v71;
                    }

                    else
                    {
                      v439 = 0;
                      v440 = "";
                    }

                    goto LABEL_1075;
                  }
                }

                else if (v73 == 3)
                {
                  v423 = *(_DWORD *)(v71 + 8);
                  v440 = *(const char **)v71;
LABEL_1023:
                  v424 = operator new(0x28uLL);
                  v255 = v424;
                  *v424 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
                  v424[1] = 0x7100000422LL;
                  *((_DWORD *)v424 + 4) = v423;
                  v425 = "expected grandchildren";
                  goto LABEL_1076;
                }

                v423 = 0;
                v440 = "";
                goto LABEL_1023;
              case 'v':
                  goto LABEL_124;
                v412 = *(unsigned __int16 *)(v71 + 16);
                if (*(_BYTE *)(v71 + 18) == 3)
                {
                  v413 = *(_DWORD *)(v71 + 8);
                  v414 = *(const char **)v71;
                }

                else
                {
                  v413 = 0;
                  v414 = "";
                }

                v424 = operator new(0x28uLL);
                v255 = v424;
                *v424 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
                v438 = 1103;
                goto LABEL_1074;
              case 'x':
                  goto LABEL_124;
                v412 = *(unsigned __int16 *)(v71 + 16);
                if (*(_BYTE *)(v71 + 18) == 3)
                {
                  v413 = *(_DWORD *)(v71 + 8);
                  v414 = *(const char **)v71;
                }

                else
                {
                  v413 = 0;
                  v414 = "";
                }

                v424 = operator new(0x28uLL);
                v255 = v424;
                *v424 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
                v438 = 1107;
LABEL_1074:
                *((_DWORD *)v424 + 2) = v438;
                *((_DWORD *)v424 + 3) = v412;
                *((_DWORD *)v424 + 4) = v413;
                v425 = "failed to decode function parameter";
                v424[3] = v414;
                goto LABEL_1077;
              case 'z':
                  goto LABEL_124;
                v404 = *(unsigned __int16 *)(v71 + 16);
                if (*(_BYTE *)(v71 + 18) == 3)
                {
                  v405 = *(_DWORD *)(v71 + 8);
                  v406 = *(const char **)v71;
                }

                else
                {
                  v405 = 0;
                  v406 = "";
                }

                v424 = operator new(0x28uLL);
                v255 = v424;
                *v424 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
                *((_DWORD *)v424 + 2) = 1111;
                *((_DWORD *)v424 + 3) = v404;
                *((_DWORD *)v424 + 4) = v405;
                v425 = "failed to decode function part";
                v424[3] = v406;
                goto LABEL_1077;
              default:
                if (*(_BYTE *)(v71 + 18) == 3)
                {
                  v402 = *(_DWORD *)(v71 + 8);
                  v403 = *(const char **)v71;
                }

                else
                {
                  v402 = 0;
                  v403 = "";
                }

                v424 = operator new(0x28uLL);
                v255 = v424;
                *v424 = "TypeDecoder.h:%u: Node kind %u %.*s - %s";
                *((_DWORD *)v424 + 2) = 1113;
                *((_DWORD *)v424 + 3) = v72;
                *((_DWORD *)v424 + 4) = v402;
                v425 = "unexpected kind";
                v424[3] = v403;
                goto LABEL_1077;
            }
          }

          break;
        }

    int64_t v45 = -1000LL;
    goto LABEL_125;
  }

  int64_t v45 = -1000LL;
  if ((v103 & 0x80000000) == 0 && v9 < v5 && v104 == 95)
  {
    *((void *)this + 9) = v9 + 1;
    int64_t v45 = (v103 + 1);
  }

            unint64_t v67 = 0LL;
LABEL_125:
            uint64_t v7 = (v7 + 2);
            std::string::append(this, ", Argument Types : [", 0x14uLL);
            unint64_t v68 = *((unsigned __int8 *)a2 + 18);
            switch(v68)
            {
              case 1u:
                goto LABEL_128;
              case 5u:
                unint64_t v68 = *((_DWORD *)a2 + 2);
                if (v7 < v68)
                {
                  while (1)
                  {
LABEL_155:
                    v80 = a2;
                    char v81 = (swift::Demangle::__runtime::Node *)*((void *)v80 + v7);
                    if (*((_WORD *)v81 + 8) != 232) {
                      break;
                    }
                    uint64_t v82 = (v7 + 1);
                    if (v82 < v68)
                    {
                      char v83 = a2;
                      if (*(_BYTE *)(*((void *)v83 + v82) + 18LL) == 3) {
                        std::string::append(this, ", ", 2uLL);
                      }
                    }

                    if (v68 == (_DWORD)++v7)
                    {
                      LODWORD(v7) = v68;
                      goto LABEL_9;
                    }
                  }
                }

                break;
              case 2u:
LABEL_128:
                break;
            }

LABEL_135:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  if (a2 < 0) {
    int v13 = (void *)a2;
  }
  else {
    int v13 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  id v14 = objc_msgSend(v13, sel_objectAtIndex_, a1);
  v129._uint64_t countAndFlagsBits = (uint64_t)v14;
  swift_unknownObjectRetain(v14, v15, v16, v17);
  if (!swift_dynamicCast(v9, &v129._countAndFlagsBits, (swift *)&unk_189B8D230, (const char *)a3, 6uLL))
  {
    uint64_t v23 = specialized static String._createEmpty(withInitialCapacity:)(85LL);
    uint64_t v25 = v24;
    v129._uint64_t countAndFlagsBits = v23;
    v129._uint64_t object = (void *)v24;
    uint64_t v26 = HIBYTE(v24) & 0xF;
    if ((v24 & 0x2000000000000000LL) == 0) {
      uint64_t v26 = v23 & 0xFFFFFFFFFFFFLL;
    }
    if (v26 || (v23 & ~v24 & 0x2000000000000000LL) != 0)
    {
      if ((v24 & 0x2000000000000000LL) != 0
        && (0x80000001818B4920LL & 0x2000000000000000LL) != 0
        && (unint64_t v31 = specialized _SmallString.init(_:appending:)( v23,  v24,  0xD000000000000046LL,  0x80000001818B4920LL | 0x8000000000000000LL),  (v33 & 1) == 0))
      {
        uint64_t v34 = v31;
        int64_t v35 = v32;
        swift_bridgeObjectRelease(0x80000001818B4920LL | 0x8000000000000000LL);
        swift_bridgeObjectRelease(v25);
        v129._uint64_t countAndFlagsBits = v34;
        v129._uint64_t object = v35;
      }

      else
      {
        if ((0x80000001818B4920LL & 0x2000000000000000LL) != 0) {
          unint64_t v41 = (0x80000001818B4920LL >> 56) & 0xF;
        }
        else {
          unint64_t v41 = 70LL;
        }
        _StringGuts.append(_:)(0xD000000000000046LL, 0x80000001818B4920LL | 0x8000000000000000LL, 0LL, v41);
        swift_bridgeObjectRelease(0x80000001818B4920LL | 0x8000000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v24);
      v129._uint64_t countAndFlagsBits = 0xD000000000000046LL;
      v129._uint64_t object = (void *)(0x80000001818B4920LL | 0x8000000000000000LL);
    }

    uint64_t v42 = (uint64_t *)swift_getTypeName((unint64_t)a3, 0);
    if (v43 < 0) {
      goto LABEL_135;
    }
    uint64_t v44 = (uint8x16_t *)v42;
    int64_t v45 = v43;
    int64_t v46 = validateUTF8(_:)(v42, v43);
    if ((v48 & 1) != 0) {
      unint64_t v49 = repairUTF8(_:firstKnownBrokenRange:)(v44->i8, v45, v46, v47);
    }
    else {
      unint64_t v49 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v44, v45, v46 & 1);
    }
    uint64_t v61 = v49;
    unint64_t v62 = v50;
    int64_t v63 = v129._object;
    unint64_t v64 = ((unint64_t)v129._object >> 56) & 0xF;
    if (!v64 && (v129._countAndFlagsBits & ~(uint64_t)v129._object & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v129._object);
      v129._uint64_t countAndFlagsBits = v61;
      v129._uint64_t object = (void *)v62;
      goto LABEL_75;
    }

    if (((uint64_t)v129._object & 0x2000000000000000LL) != 0)
    {
      if ((v50 & 0x2000000000000000LL) != 0)
      {
        unint64_t v71 = specialized _SmallString.init(_:appending:)( v129._countAndFlagsBits,  (unint64_t)v129._object,  v49,  v50);
        if ((v73 & 1) == 0)
        {
          uint64_t v74 = v71;
          char v75 = v72;
          swift_bridgeObjectRelease(v62);
          swift_bridgeObjectRelease((uint64_t)v63);
          v129._uint64_t countAndFlagsBits = v74;
          v129._uint64_t object = v75;
          unint64_t v62 = (unint64_t)v75;
          uint64_t v61 = v74;
          goto LABEL_75;
        }

        goto LABEL_73;
      }
    }

    else if ((v50 & 0x2000000000000000LL) != 0)
    {
LABEL_73:
      uint64_t v69 = HIBYTE(v62) & 0xF;
      goto LABEL_74;
    }

    uint64_t v69 = v49 & 0xFFFFFFFFFFFFLL;
LABEL_74:
    _StringGuts.append(_:)(v61, v62, 0LL, v69);
    swift_bridgeObjectRelease(v62);
    uint64_t v61 = v129._countAndFlagsBits;
    unint64_t v62 = (unint64_t)v129._object;
LABEL_75:
    Swift::String v76 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" but found ", 0xBuLL, 1);
    uint64_t v77 = HIBYTE(v62) & 0xF;
    if ((v62 & 0x2000000000000000LL) == 0) {
      uint64_t v77 = v61 & 0xFFFFFFFFFFFFLL;
    }
    if (!v77 && (v61 & ~v62 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v62);
      Swift::String v129 = v76;
      goto LABEL_89;
    }

    if ((v62 & 0x2000000000000000LL) != 0)
    {
      if (((uint64_t)v76._object & 0x2000000000000000LL) != 0)
      {
        unint64_t v79 = specialized _SmallString.init(_:appending:)( v61,  v62,  v76._countAndFlagsBits,  (unint64_t)v76._object);
        if ((v81 & 1) == 0)
        {
          uint64_t v82 = v79;
          char v83 = v80;
          swift_bridgeObjectRelease((uint64_t)v76._object);
          swift_bridgeObjectRelease(v62);
          v129._uint64_t countAndFlagsBits = v82;
          v129._uint64_t object = v83;
          goto LABEL_89;
        }

        goto LABEL_87;
      }
    }

    else if (((uint64_t)v76._object & 0x2000000000000000LL) != 0)
    {
LABEL_87:
      uint64_t v78 = ((unint64_t)v76._object >> 56) & 0xF;
      goto LABEL_88;
    }

    uint64_t v78 = v76._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_88:
    _StringGuts.append(_:)(v76._countAndFlagsBits, (unint64_t)v76._object, 0LL, v78);
    swift_bridgeObjectRelease((uint64_t)v76._object);
LABEL_89:
    unint64_t v84 = swift_getObjectType((unint64_t)v14);
    swift_unknownObjectRelease(v14);
    Swift::String v85 = (uint64_t *)swift_getTypeName(v84, 0);
    if ((v86 & 0x8000000000000000LL) == 0)
    {
      uint64_t v87 = (uint8x16_t *)v85;
      int64_t v88 = v86;
      int64_t v89 = validateUTF8(_:)(v85, v86);
      if ((v91 & 1) != 0) {
        uint64_t v92 = repairUTF8(_:firstKnownBrokenRange:)(v87->i8, v88, v89, v90);
      }
      else {
        uint64_t v92 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v87, v88, v89 & 1);
      }
      uint64_t v94 = v92;
      unint64_t v95 = v93;
      unint64_t v96 = v129._countAndFlagsBits;
      unint64_t v97 = (unint64_t)v129._object;
      unint64_t v98 = ((unint64_t)v129._object >> 56) & 0xF;
      goto LABEL_124;
    }

    goto LABEL_135;
  }

  (*(void (**)(char *, uint64_t *))(v6 + 8))(v9, a3);
  return v14;
}

          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
        }

        if (v235 < 64) {
          goto LABEL_83;
        }
        v241 = v320;
      }

      else
      {
        v241 = v233;
      }

      v69(v241, a3);
      LOBYTE(v240) = 0;
      goto LABEL_121;
    }

    v301 = v69;
    v167 = (void (*)(char *, char *, uint64_t))*((void *)v333 + 2);
    v167(v321, v155, v154);
    LOWORD(v340) = -1;
    v168 = ((uint64_t (*)(uint64_t, unint64_t))v339)(v154, v156);
    v169 = v156;
    v170 = v168;
    v171 = v166(v154, v169);
    if ((v170 & 1) != 0)
    {
      if (v171 <= 16)
      {
        unint64_t v174 = (void (**)(char *, uint64_t, const char *))v329;
        v175 = (uint64_t)v334;
        v176 = v326;
        v177 = swift_getAssociatedConformanceWitness( (uint64_t)v329,  (uint64_t)v334,  v326,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v178 = v327;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v177 + 8))( &qword_18180BE68,  256LL,  v176,  v177);
        v179 = v332;
        v174[3](v178, v175, (const char *)v174);
        v180 = swift_getAssociatedConformanceWitness( v7,  a3,  v175,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        v181 = v321;
        LOBYTE(v174) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v180 + 40))( v321,  v179,  v175,  v180);
        uint64_t v182 = (void (*)(char *, uint64_t))*((void *)v333 + 1);
        v182(v179, v175);
        v183 = (unsigned __int16)v340;
        v167(v311, v181, v175);
        if ((v174 & 1) != 0)
        {
          v184 = v311;
          unint64_t v154 = (uint64_t)v334;
          uint64_t v185 = (*(uint64_t (**)(unint64_t *))(v305 + 120))(v334);
          v182(v184, v154);
          if (v183 < v185) {
            goto LABEL_72;
          }
        }

        else
        {
          unint64_t v154 = (uint64_t)v334;
          v182(v311, (uint64_t)v334);
        }

        goto LABEL_79;
      }
    }

    else if (v171 <= 16)
    {
      v224 = v332;
      unint64_t v154 = (uint64_t)v334;
      v167(v332, v321, (uint64_t)v334);
      v225 = (*(uint64_t (**)(uint64_t))(v305 + 120))(v154);
      uint64_t v182 = (void (*)(char *, uint64_t))*((void *)v333 + 1);
      v182(v224, v154);
LABEL_79:
      v182(v321, v154);
      uint64_t v69 = v301;
      uint64_t v10 = v306;
      v156 = v305;
      v155 = v322;
      goto LABEL_80;
    }

    v204 = v305;
    v205 = *(void (**)(char **, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v305 + 96);
    v206 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v171, v172, v173);
    v207 = v332;
    unint64_t v154 = (uint64_t)v334;
    v205(&v340, &type metadata for UInt16, v206, v334, v204);
    v208 = swift_getAssociatedConformanceWitness( v7,  a3,  v154,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    LOBYTE(v205) = (*(uint64_t (**)(char *, char *, uint64_t, unint64_t))(v208 + 16))( v207,  v321,  v154,  v208);
    uint64_t v182 = (void (*)(char *, uint64_t))*((void *)v333 + 1);
    v182(v207, v154);
    if ((v205 & 1) != 0) {
LABEL_72:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    goto LABEL_79;
  }

  v115 = v101;
  int64_t v116 = v329;
  int64_t v117 = (uint64_t)v334;
  int64_t v118 = v326;
  v311 = (char *)(v101 - 10);
  char v119 = swift_getAssociatedConformanceWitness( (uint64_t)v329,  (uint64_t)v334,  v326,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v322 = *(char **)(v119 + 8);
  v325 = (char *)v119;
  uint64_t v120 = v327;
  ((void (*)(uint64_t *, uint64_t, unint64_t, unint64_t))v322)( &qword_18180BE70,  512LL,  v118,  v119);
  unint64_t v121 = v116;
  v321 = (char *)*((void *)v116 + 3);
  unint64_t v122 = v332;
  uint64_t v123 = ((uint64_t (*)(char *, uint64_t, const char *))v321)(v120, v117, v121);
  v340 = (char *)(v115 - 11);
  unint64_t v124 = v305;
  unint64_t v125 = *(void (**)(char *, char **, ValueMetadata *, char *, uint64_t, unint64_t))(v305 + 256);
  v314 = (char *)lazy protocol witness table accessor for type Int and conformance Int(v123, v126, v127);
  v125(v122, &v340, &type metadata for Int, v314, v117, v124);
  v320 = (char *)*((void *)v333 + 1);
  ((void (*)(char *, uint64_t))v320)(v122, v117);
  unint64_t v128 = v327;
  ((void (*)(void *, uint64_t, unint64_t, char *))v322)(&unk_18180BE80, 768LL, v118, v325);
  Swift::String v129 = v315;
  v130 = v128;
  ((void (*)(char *, uint64_t, char *))v321)(v128, v117, v329);
  v131 = AssociatedConformanceWitness;
  (*(void (**)(char *, char *, uint64_t, unint64_t))(AssociatedConformanceWitness + 64))( v129,  v328,  v117,  AssociatedConformanceWitness);
  uint64_t v132 = v320;
  ((void (*)(char *, uint64_t))v320)(v129, v117);
  ((void (*)(uint64_t *, uint64_t))v322)(&qword_18180BE70, 512LL);
  ((void (*)(char *, uint64_t, char *))v321)(v130, v117, v329);
  BOOL v133 = *(void (**)(char *, char *, uint64_t))(*(void *)(v131 + 8) + 40LL);
  uint64_t v134 = v316;
  v135 = v332;
  v133(v332, v129, v117);
  ((void (*)(char *, uint64_t))v132)(v129, v117);
  ((void (*)(char *, uint64_t))v132)(v135, v117);
  char v136 = v132;
  v137 = v305;
  v138 = v339;
  (*(void (**)(char *, char *, uint64_t, unint64_t))(v305 + 192))(v339, v134, v117, v305);
  ((void (*)(char *, uint64_t))v136)(v134, v117);
  v340 = v311;
  v139 = v117;
  v140 = v332;
  (*(void (**)(char *, char **, ValueMetadata *, char *, uint64_t, unint64_t))(v137 + 240))( v138,  &v340,  &type metadata for Int,  v314,  v139,  v137);
  ((void (*)(char *, uint64_t))v136)(v138, v139);
  v141 = *(char **)(v137 + 120);
  unint64_t v142 = v137;
  v143 = v136;
  v315 = v141;
  unint64_t v144 = ((uint64_t (*)(uint64_t, unint64_t))v141)(v139, v142);
  ((void (*)(char *, uint64_t))v136)(v140, v139);
  v316 = (char *)v144;
  LODWORD(v339) = v144 & 0x3FF;
  v145 = swift_getAssociatedConformanceWitness( v7,  a3,  v139,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  v146 = *(uint64_t (**)(char *, char *, uint64_t))(v145 + 40);
  v147 = v330;
  uint64_t v148 = v328;
  unint64_t AssociatedConformanceWitness = v145;
  v149 = v146(v330, v328, v139);
  v150 = v333;
  v151 = v319;
  (*((void (**)(char *, char *, uint64_t))v333 + 2))(v319, v147, v139);
  unint64_t v152 = (void (*)(void, void, void))v150[4];
  v153 = v318;
  v333 = v152;
  v152(v318, v148, v139);
  v301 = v69;
  if ((v149 & 1) != 0)
  {
    ((void (*)(char *, uint64_t))v143)(v153, v139);
    ((void (*)(char *, uint64_t))v143)(v151, v139);
  }

  else
  {
    v198 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(AssociatedConformanceWitness + 8) + 8LL))( v151,  v153,  v139);
    ((void (*)(char *, uint64_t))v143)(v153, v139);
    ((void (*)(char *, uint64_t))v143)(v151, v139);
  }

  if ((_DWORD)v339 == 1023)
  {
    if (v304 >= 0xF)
    {
      ((void (*)(char *, unint64_t *))v320)(v330, v334);
      v199 = v331(a3, a4);
      (*(void (**)(char *, uint64_t, uint64_t))(v303 + 16))(v313, v302, a3);
      if ((v199 & 1) != 0)
      {
        if ((v331(a3, a4) & 1) != 0)
        {
          if (v323(a3, a4) < 64) {
            goto LABEL_128;
          }
LABEL_113:
          v340 = 0LL;
          v287 = v338;
          (*(void (**)(char **, ValueMetadata *, char *, uint64_t, uint64_t))(a4 + 96))( &v340,  &type metadata for Int,  v314,  a3,  a4);
          v288 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
          v195 = v313;
          uint64_t v113 = v288(v313, v287, a3);
          v196 = v287;
          v197 = a3;
          uint64_t v69 = v301;
          goto LABEL_114;
        }

        v285 = v331(a3, a4);
        v286 = v323(a3, a4);
        if ((v285 & 1) != 0)
        {
          if (v286 <= 64)
          {
            v294 = (void (**)(char *, uint64_t, const char *))v336;
            v295 = v306;
            v296 = swift_getAssociatedConformanceWitness( (uint64_t)v336,  a3,  v306,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v297 = v335;
            (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v296 + 8))( &qword_18180BE68,  256LL,  v295,  v296);
            v298 = v338;
            v294[3](v297, a3, (const char *)v294);
            v299 = v313;
            LOBYTE(v294) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                              + 16LL))( v313,  v298,  a3);
            v301(v298, a3);
            (*(void (**)(char *, char *, uint64_t))(v303 + 32))(v307, v299, a3);
            if ((v294 & 1) != 0)
            {
              v301(v307, a3);
              goto LABEL_116;
            }

            v290 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 120);
            v291 = &v339;
            goto LABEL_129;
          }

          goto LABEL_113;
        }

        if (v286 < 64)
        {
LABEL_128:
          v290 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 120);
          v291 = (char **)&v341;
LABEL_129:
          v292 = *(v291 - 32);
          v293 = v290(a3, a4);
          v301(v292, a3);
          if (v293 < 0) {
            goto LABEL_116;
          }
          goto LABEL_55;
        }
      }

      v301(v313, a3);
      goto LABEL_55;
    }

    ++v304;
    v200 = 1024;
  }

  else
  {
    v200 = (_DWORD)v339 + 1;
  }

  LODWORD(v339) = v200;
LABEL_61:
  v209 = v331;
  v210 = v331(a3, a4);
  (*(void (**)(char *, uint64_t, uint64_t))(v303 + 16))(v324, v302, a3);
  if ((v210 & 1) == 0) {
    goto LABEL_77;
  }
  if ((v209(a3, a4) & 1) != 0)
  {
    if (v323(a3, a4) < 64) {
      goto LABEL_74;
    }
LABEL_67:
    v340 = 0LL;
    v213 = v338;
    (*(void (**)(char **, ValueMetadata *, char *, uint64_t, uint64_t))(a4 + 96))( &v340,  &type metadata for Int,  v314,  a3,  a4);
    v214 = v324;
    v215 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v324,  v213,  a3);
    v216 = v301;
    v301(v213, a3);
    v216(v214, a3);
    v217 = v304;
    v218 = (unsigned __int16)v339 & 0x3FF;
    if ((v215 & 1) == 0) {
      goto LABEL_76;
    }
LABEL_97:
    v229 = 0x8000;
    goto LABEL_98;
  }

  v211 = v209(a3, a4);
  v212 = v323(a3, a4);
  if ((v211 & 1) == 0)
  {
    if (v212 < 64)
    {
LABEL_74:
      v226 = v324;
      v227 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      goto LABEL_75;
    }

              _StringGuts._foreignGrow(_:)(v40);
              goto LABEL_109;
            }
          }

          __break(1u);
          goto LABEL_133;
        }
      }

      else
      {
        unint64_t v95 = _StringObject.sharedUTF8.getter(v198, v199);
        unint64_t v96 = v181;
        if (v181 >= v94) {
          goto LABEL_32;
        }
      }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    unint64_t v31 = *v190;
    uint64_t v32 = v190[1];
  }

  v196 = 0LL;
  v197 = 0xE000000000000000LL;
  int64_t v46 = _StringGuts.nativeCapacity.getter(v31, v32);
  if ((v47 & 1) == 0) {
    String.reserveCapacity(_:)(v46);
  }
  v48._Swift::UInt64 rawBits = v188;
  unint64_t v49 = specialized Collection.subscript.getter(v48, v31, v32);
  unint64_t v51 = v50;
  uint64_t v53 = v52;
  int64_t v55 = (unint64_t)v54;
  swift_bridgeObjectRetain((unint64_t)v54, v50, v52, v54);
  v56._Swift::UInt64 rawBits = v49;
  v57._Swift::UInt64 rawBits = v51;
  char v58 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v56,  v57,  v53,  v55);
  unint64_t v59 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v58, 1LL);
  uint64_t v61 = v60;
  swift_bridgeObjectRelease((uint64_t)v58);
  if (!v61) {
    goto LABEL_144;
  }
  unint64_t v62 = v197;
  int64_t v63 = specialized static String.+ infix(_:_:)(v196, v197, v59, v61);
  char v65 = v64;
  swift_bridgeObjectRelease(v55);
  swift_bridgeObjectRelease(v62);
  swift_bridgeObjectRelease(v61);
  v196 = v63;
  v197 = v65;
  char v37 = (v65 & 0x2000000000000000LL) != 0 ? HIBYTE(v65) & 0xF : v63 & 0xFFFFFFFFFFFFLL;
  unint64_t v66 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5( (void (*)(uint64_t *__return_ptr, char *))protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar,  0LL,  (uint64_t)v6,  v7);
  unint64_t v67 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v66, 1LL);
  uint64_t v69 = v68;
  swift_bridgeObjectRelease((uint64_t)v66);
  if (!v69) {
    goto LABEL_144;
  }
  uint64_t v70 = specialized static String.+ infix(_:_:)(v63, v65, v67, v69);
  uint64_t v72 = v71;
  swift_bridgeObjectRelease(v65);
  swift_bridgeObjectRelease(v69);
  v196 = v70;
  v197 = v72;
  v73._Swift::UInt64 rawBits = v187;
  uint64_t v74 = specialized Collection.subscript.getter(v73, v31, v32);
  Swift::String v76 = v75;
  uint64_t v78 = v77;
  v80 = (unint64_t)v79;
  swift_bridgeObjectRetain((unint64_t)v79, v75, v77, v79);
  v81._Swift::UInt64 rawBits = v74;
  v82._Swift::UInt64 rawBits = v76;
  char v83 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSs17UnicodeScalarViewV_s6UInt32Vs5NeverOTg506_sSS17def38V6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6G8VAHXEfU_Tf1cn_n( v81,  v82,  v78,  v80);
  unint64_t v84 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v83, 1LL);
  uint64_t v86 = v85;
  swift_bridgeObjectRelease((uint64_t)v83);
  uint64_t v87 = (unint64_t *)v190;
  if (!v86) {
LABEL_144:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/String.swift",  18LL,  2,  0x1C9uLL,  0);
  int64_t v88 = specialized static String.+ infix(_:_:)(v70, v72, v84, v86);
  int64_t v90 = v89;
  swift_bridgeObjectRelease(v32);
  swift_bridgeObjectRelease(v80);
  swift_bridgeObjectRelease(v72);
  swift_bridgeObjectRelease(v86);
  uint8x16_t *v87 = v88;
  v87[1] = v90;
  return v37;
}

      v81[0] = v22;
      uint64_t v82 = 0LL;
      uint64_t v78 = (os_unfair_lock_s *)&unk_18C476AB0;
      goto LABEL_143;
    }

    checkMetadataDependency(swift::MetadataDependency)::CheckDependencyResult::forForeignMetadata( v88,  v10[1],  (uint64_t)v81);
LABEL_144:
    if (!v82) {
      goto LABEL_4;
    }
    swift::blockOnMetadataDependency(swift::MetadataDependency,swift::MetadataDependency)::$_0::operator()( (uint64_t **)&p_p,  v82,  (uint64_t)v83);
    uint64_t v10 = (void *)*((void *)v86 - 2);
    uint64_t v9 = *((void *)v86 - 1);
    v88[0] = v9;
  }

  int v18 = (unsigned int **)(v10 + 1);
LABEL_29:
  uint64_t v23 = *v18;
  unint64_t v24 = **v18;
  if ((v24 & 0x80) != 0)
  {
    if ((v24 & 0x1F) - 17 >= 2)
    {
      if ((v24 & 0x1F) != 0x10) {
        goto LABEL_159;
      }
      if ((v24 & 0x20000000) != 0)
      {
        uint64_t v70 = (int)v23[6];
        if ((_DWORD)v70) {
          unint64_t v71 = (unint64_t *)((char *)v23 + v70 + 24);
        }
        else {
          unint64_t v71 = 0LL;
        }
        uint64_t v72 = *v71;
        if (!*v71)
        {
          computeMetadataBoundsFromSuperclass(v23, (uint64_t)v71, v11, v12);
          uint64_t v72 = v73;
        }

        uint64_t v26 = v72 >> 3;
      }

      else
      {
        if ((v24 & 0x10000000) != 0)
        {
          unint64_t v68 = 0;
          uint64_t v69 = v23 + 6;
        }

        else
        {
          unint64_t v68 = v23[7];
          uint64_t v69 = v23 + 8;
        }

        LODWORD(v26) = v68 - *v69;
      }
    }

    else
    {
      LODWORD(v26) = 2;
    }

    uint64_t v27 = (uint64_t)&v10[(int)v26];
    Cache = getCache(v23);
    uint64_t v29 = Cache;
    uint64_t v30 = *((unsigned __int16 *)Cache + 28);
    unint64_t v31 = *((_WORD *)Cache + 29);
    uint64_t v32 = *((unsigned __int16 *)Cache + 30);
    char v33 = *((unsigned __int16 *)Cache + 31);
    uint64_t v34 = Cache[8];
    int64_t v35 = (1455063249 * v30);
    if (*((_WORD *)Cache + 28))
    {
      unint64_t v36 = 0LL;
      char v37 = *((unsigned __int16 *)Cache + 31);
      do
      {
        if (v36 >= v32 || *(_WORD *)(v34 + 8 * v36) || (char v38 = v34 + 8 * v36, v37 != *(unsigned __int16 *)(v38 + 2)))
        {
          int64_t v35 = __ROR8__(v35, 10) ^ (*(void *)(v27 + 8 * v37) >> 19) ^ *(void *)(v27 + 8 * v37);
        }

        else
        {
          uint64_t v39 = *(void *)(v27 + 8LL * *(unsigned __int16 *)(v38 + 4));
          ++v36;
          if (v39)
          {
            uint64_t v40 = 0LL;
            do
            {
              unint64_t v41 = *(void *)((*(void *)(v27 + 8 * v37) & 0xFFFFFFFFFFFFFFFELL) + 8 * v40);
              int64_t v35 = __ROR8__(v35, 10) ^ (v41 >> 19) ^ v41;
              ++v40;
            }

            while (v39 > v40);
          }
        }

        ++v37;
      }

      while (v37 != v33 + v30);
    }

    v88[1] = v27;
    int64_t v89 = v30;
    int64_t v90 = v31;
    char v91 = v32;
    uint64_t v92 = v33;
    unint64_t v93 = v34;
    uint64_t v94 = (668265261 * v35) >> 10;
    do
      uint64_t v42 = __ldaxr((unsigned int *)v29);
    while (__stxr(v42 + 1, (unsigned int *)v29));
    do
    {
      uint64_t v43 = atomic_load((unint64_t *)v29 + 1);
      uint64_t v44 = atomic_load((unint64_t *)v29 + 2);
      int64_t v45 = atomic_load((unsigned int *)v29 + 1);
      int64_t v46 = atomic_load((unint64_t *)v29 + 1);
    }

    while (v43 != v46);
    if (v43) {
      int64_t v47 = v43 + 8;
    }
    else {
      int64_t v47 = 0LL;
    }
    v95[0] = v29;
    v95[1] = v44;
    v95[2] = v47;
    v95[3] = v45;
    if (v48) {
      unint64_t v49 = *v48;
    }
    else {
      unint64_t v49 = 0LL;
    }
    do
      char v58 = __ldxr((unsigned int *)v29);
    while (__stlxr(v58 - 1, (unsigned int *)v29));
    unint64_t v59 = (os_unfair_lock_s *)(v29 + 6);
    unint64_t v60 = v88[0];
    uint64_t v61 = atomic_load(v49);
    unint64_t v62 = v61 & 7;
    if (v60 > 62)
    {
      if (v88[0] == 255)
      {
        if (!v62)
        {
          os_unfair_lock_lock(v59);
          unint64_t v64 = *v49;
          char v65 = *v49 & 7;
          if ((*(_DWORD *)v49 & 7) != 0) {
            goto LABEL_87;
          }
          goto LABEL_72;
        }
      }

      else
      {
        if (v88[0] != 63) {
          goto LABEL_159;
        }
        if (v62 <= 1)
        {
          os_unfair_lock_lock(v59);
          unint64_t v64 = *v49;
          char v65 = *v49 & 7;
          if (v65 > 1)
          {
LABEL_87:
            v81[0] = v65;
            uint64_t v82 = 0LL;
            goto LABEL_123;
          }

uint64_t unsafeBitCast<A, B>(_:to:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void *)(a3 - 8);
  if (*(void *)(*(void *)(a2 - 8) + 64LL) != *(void *)(v4 + 64)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v4 + 16))(a4, a1, a3);
}

void _ArrayBuffer.subscript.getter( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3) && (a2 & 0xC000000000000001LL) != 0)
  {
    id v8 = _ArrayBuffer._getElementSlowPath(_:)(a1, a2, a3);
    uint64_t v9 = v8;
    uint64_t v10 = *(a3 - 1);
    if (*(void *)(v10 + 64) != 8LL)
    {
      swift_unknownObjectRelease(v8);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    id v11 = v8;
    (*(void (**)(uint64_t, id *, uint64_t *))(v10 + 16))(a4, &v11, a3);
    swift_unknownObjectRelease(v9);
  }

  else
  {
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(a3 - 1) + 16))( a4,  a2 + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80))
    + *(void *)(*(a3 - 1) + 72) * a1,
      a3);
  }

void key path getter for _ArrayBuffer.subscript(_:) : <A>_ArrayBuffer<A>A( uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
}

void key path setter for _ArrayBuffer.subscript(_:) : <A>_ArrayBuffer<A>A( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(uint64_t **)(a4 + a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v11 - v6;
  uint64_t v9 = *v8;
  (*(void (**)(char *))(v10 + 16))((char *)&v11 - v6);
  _ArrayBuffer.subscript.setter((uint64_t)v7, v9, *a2, v5);
}

uint64_t _ContiguousArrayBuffer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 - 8);
  MEMORY[0x1895F8858]();
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 32))(v10, a1, v11);
  unint64_t v12 = a3
  (*(void (**)(uint64_t, unint64_t, uint64_t))(v8 + 16))(a1, v12, a4);
  (*(void (**)(uint64_t, uint64_t))(v8 + 8))(a1, a4);
  return (*(uint64_t (**)(unint64_t, char *, uint64_t))(v8 + 40))(v12, v10, a4);
}

uint64_t static Int.+ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t CollectionOfOne.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a3, a1);
}

uint64_t _convertPointerToPointerArgument<A, B>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 48))(a2, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 56))(v7, a3, a5);
}

uint64_t UnsafeBufferPointer.init(start:count:)(uint64_t result, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  if (a2)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
    }
  }

  return result;
}

void *_ss15ContiguousArrayV23withUnsafeBufferPointeryqd__qd__SRyxGKXEKlFADq_s5Error_pRi_zRi0_zRi__Ri0__r0_lyxSSSgIsgyrzo_AByxGAFsAE_pAFRsd__r__lIetMggozo_Tp5( void *(*a1)(uint64_t *__return_ptr, uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(unsigned __int8 *)(*(void *)(a4 - 8) + 80LL);
  uint64_t result = a1(&v7, a3 + ((v5 + 32) & ~v5), *(void *)(a3 + 16));
  if (!v4) {
    return (void *)v7;
  }
  return result;
}

uint64_t ContiguousArray.withUnsafeBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t, void), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned __int8 *)(*(void *)(a4 - 8) + 80LL);
  return a1(a3 + ((v4 + 32) & ~v4), *(void *)(a3 + 16));
}

uint64_t static Bool.|| infix(_:_:)(char a1, uint64_t (*a2)(void))
{
  if ((a1 & 1) != 0) {
    return 1LL;
  }
  else {
    return a2() & 1;
  }
}

uint64_t _ArrayBuffer.nativeOwner.getter(unint64_t a1, uint64_t *a2)
{
  else {
    uint64_t v6 = a1;
  }
  swift_bridgeObjectRetain(a1, v3, v4, v5);
  return v6;
}

BOOL _BridgeStorage.isUnflaggedNative.getter(uint64_t a1)
{
  return (a1 & 0xC000000000000001LL) == 0;
}

uint64_t _BridgeStorage.objCInstance.getter(int64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  if (a1 < 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = a1 & 0xFFFFFFFFFFFFFF8LL;
  }
  swift_bridgeObjectRetain(a1, a2, a3, a4);
  return v4;
}

uint64_t static Strideable<>.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a4 + 32) + 48LL))(a2, a3);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a4 + 32) + 48LL))(a1, a3);
}

Swift::UnsafeMutableRawPointer __swiftcall UnsafeMutablePointer.deinitialize(count:)(Swift::Int count)
{
  if (count < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
  }
  v3._rawValue = (Builtin::RawPointer)v1;
  swift_arrayDestroy(v1, count, v2);
  return v3;
}

uint64_t static Int.- infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __OFSUB__(a1, a2);
  uint64_t result = a1 - a2;
  if (v2) {
    __break(1u);
  }
  return result;
}

char *specialized closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( char *__src, uint64_t a2, uint64_t a3, char *__dst)
{
  if (a2 != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: count differed in successive traversals",  59LL,  2,  "Swift/ArrayBufferProtocol.swift",  31LL,  2,  0xAFuLL,  0);
  }
  if (!__src) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ArrayBufferProtocol.swift",  31LL,  2,  0xB3uLL,  0);
  }
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[8 * a2] > __src && &__src[8 * a2] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return swift_arrayInitWithCopy(__dst, __src, a2, (uint64_t)&unk_189B8D230);
}

char *closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( char *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a2 != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: count differed in successive traversals",  59LL,  2,  "Swift/ArrayBufferProtocol.swift",  31LL,  2,  0xAFuLL,  0);
  }
  if (!a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ArrayBufferProtocol.swift",  31LL,  2,  0xB3uLL,  0);
  }
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  uint64_t v11 = *(const char **)(*(void *)(*(void *)(a7 + 8) + 8LL) + 8LL);
  uint64_t v12 = *(void *)(*(void *)(swift_getAssociatedTypeWitness( 255LL,  v11,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element)
                              - 8)
                  + 72LL)
      * a2;
  int v13 = &a4[v12];
  uint64_t v14 = &a1[v12];
  if (v13 > a1 && v14 > a4) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v11,  a5,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  return swift_arrayInitWithCopy(a4, a1, a2, AssociatedTypeWitness);
}

Swift::Void __swiftcall _diagnoseUnexpectedNilOptional(_filenameStart:_filenameLength:_filenameIsASCII:_line:_isImplicitUnwrap:)( Builtin::RawPointer _filenameStart, Builtin::Word _filenameLength, Builtin::Int1 _filenameIsASCII, Builtin::Word _line, Builtin::Int1 _isImplicitUnwrap)
{
  if (_filenameIsASCII) {
    char v5 = 2;
  }
  else {
    char v5 = 0;
  }
  if (_isImplicitUnwrap) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while implicitly unwrapping an Optional value",  68LL,  2,  (const char *)_filenameStart,  _filenameLength,  v5,  _line,  0);
  }
  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  (const char *)_filenameStart,  _filenameLength,  v5,  _line,  0);
}

char *specialized UnsafeMutablePointer.initialize(from:count:)(char *__src, uint64_t a2, char *__dst)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[16 * a2] > __src && &__src[16 * a2] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return swift_arrayInitWithCopy(__dst, __src, a2, (uint64_t)&type metadata for String);
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[8 * a2] > __src && &__src[8 * a2] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return swift_arrayInitWithCopy(__dst, __src, a2, (uint64_t)&unk_189B8D230);
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[32 * a2] > __src && &__src[32 * a2] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return swift_arrayInitWithCopy(__dst, __src, a2, (uint64_t)&type metadata for _DictionaryCodingKey);
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[32 * a2] > __src && &__src[32 * a2] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return swift_arrayInitWithCopy(__dst, __src, a2, (uint64_t)&unk_189B8D218);
}

{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[16 * a2] > __src && &__src[16 * a2] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return swift_arrayInitWithCopy(__dst, __src, a2, (uint64_t)&type metadata for Character);
}

void *specialized UnsafeMutablePointer.initialize(from:count:)(char *__src, uint64_t a2, char *__dst)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[8 * a2] > __src && &__src[8 * a2] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return memcpy(__dst, __src, 8 * a2);
}

void *specialized UnsafeMutablePointer.initialize(from:count:)(char *__src, size_t __n, char *__dst)
{
  if ((__n & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&__dst[__n] > __src && &__src[__n] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return memcpy(__dst, __src, __n);
}

char *specialized UnsafeMutablePointer.initialize(from:count:)(char *a1, uint64_t a2, char *a3, uint64_t *a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  if (&a3[40 * a2] > a1 && &a1[40 * a2] > a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(a4);
  return swift_arrayInitWithCopy(a3, a1, a2, v8);
}

char *UnsafeMutablePointer.initialize(from:count:)(char *__src, uint64_t a2, char *__dst, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }
  uint64_t v4 = *(void *)(*(void *)(a4 - 8) + 72LL) * a2;
  char v5 = &__dst[v4];
  uint64_t v6 = &__src[v4];
  if (v5 > __src && v6 > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  return swift_arrayInitWithCopy(__dst, __src, a2, a4);
}

BOOL static _Pointer.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 48);
  unint64_t v7 = v6(a3, a4);
  return v7 < v6(a3, a4);
}

void *static Strideable<>.+= infix(_:_:)(void *a1, uint64_t a2, uint64_t a3)
{
  size_t v4 = *(void *)(*(void *)(a3 - 8) + 64LL);
  MEMORY[0x1895F8858](a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v5 + 32) + 48LL))(v6, v7);
  return memcpy(a1, (char *)&v9 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL), v4);
}

uint64_t _expectEnd<A>(of:is:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = a1;
  uint64_t v7 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v9 = (char *)&v22 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v11,  v10,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v16 = (char *)&v22 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  int v18 = (char *)&v22 - v17;
  (*(void (**)(char *, uint64_t, unint64_t))(v13 + 16))((char *)&v22 - v17, a2, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v9, v23, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 72))(a3, a4);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  LOBYTE(a2) = (*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                           + 8LL))( v18,  v16,  AssociatedTypeWitness);
  uint64_t v20 = *(void (**)(char *, unint64_t))(v13 + 8);
  v20(v16, AssociatedTypeWitness);
  if ((a2 & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: count differed in successive traversals",  59LL,  2,  "Swift/ArrayShared.swift",  23LL,  2,  0xAAuLL,  0);
  }
  (*(void (**)(char *, uint64_t))(v7 + 8))(v9, a3);
  return ((uint64_t (*)(char *, unint64_t))v20)(v18, AssociatedTypeWitness);
}

void _swift_arrayDownCastIndirect(unint64_t *a1, __objc2_class ***a2, uint64_t *a3, char *a4)
{
  uint64_t v6 = *a1;
  unint64_t v7 = swift_bridgeObjectRetain(*a1, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v8 = _arrayForceCast<A, B>(_:)(v7, a3);
  swift_bridgeObjectRelease(v6);
  *a2 = v8;
}

__objc2_class **specialized _arrayForceCast<A, B>(_:)(uint64_t a1)
{
  int64_t v1 = *(void *)(a1 + 16);
  BOOL v2 = &_swiftEmptyArrayStorage;
  if (v1)
  {
    int v18 = &_swiftEmptyArrayStorage;
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, v1, 0);
    uint64_t v4 = a1 + 32;
    do
    {
      outlined init with copy of MirrorPath(v4, (uint64_t)v15);
      outlined init with take of MirrorPath(v15, (uint64_t)v14);
      uint64_t v5 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CodingKey);
      swift_dynamicCast((char *)v16, v14, v5, (const char *)&type metadata for _DictionaryCodingKey, 7uLL);
      uint64_t v6 = (__objc2_class *)v16[0];
      unint64_t v7 = (__objc2_class *)v16[1];
      uint64_t v8 = (__objc2_class *)v16[2];
      char v9 = v17;
      BOOL v2 = v18;
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v18))
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v2[2]->isa + 1,  1);
        BOOL v2 = v18;
      }

      unint64_t v11 = (unint64_t)v2[2];
      unint64_t v10 = (unint64_t)v2[3];
      if (v11 >= v10 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v10 > 1),  v11 + 1,  1);
        BOOL v2 = v18;
      }

      v2[2] = (__objc2_class *)(v11 + 1);
      uint64_t v12 = &v2[4 * v11];
      v12[4] = v6;
      v12[5] = v7;
      v12[6] = v8;
      *((_BYTE *)v12 + 56) = v9;
      v4 += 40LL;
      --v1;
    }

    while (v1);
  }

  return v2;
}

__objc2_class **specialized _arrayForceCast<A, B>(_:)(uint64_t a1, char *a2)
{
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v15[-1] - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Swift::Int v9 = *(void *)(v4 + 16);
  if (v9)
  {
    char v17 = &_swiftEmptyArrayStorage;
    uint64_t v10 = type metadata accessor for ContiguousArray(0LL, (uint64_t)a2, v5, v6);
    ContiguousArray.reserveCapacity(_:)(v9);
    uint64_t v11 = a1 + 32;
    do
    {
      outlined init with copy of MirrorPath(v11, (uint64_t)v16);
      outlined init with take of MirrorPath(v16, (uint64_t)v15);
      uint64_t v12 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CodingKey);
      swift_dynamicCast(v8, v15, v12, a2, 7uLL);
      ContiguousArray.append(_:)((uint64_t)v8, v10);
      v11 += 40LL;
      --v9;
    }

    while (v9);
    return v17;
  }

  else
  {
    _swift_isClassOrObjCExistentialType((uint64_t)a2, (uint64_t *)a2);
    return &_swiftEmptyArrayStorage;
  }

__objc2_class **_arrayForceCast<A, B>(_:)(unint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a1;
  uint64_t v4 = *(a2 - 1);
  uint64_t v5 = *(void *)(v4 + 64);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v46 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v46 - v9;
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (char *)&v46 - v12;
  char v48 = v14;
  MEMORY[0x1895F8858](v11);
  uint64_t v16 = (char *)&v46 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v17, v17) && _swift_isClassOrObjCExistentialType((uint64_t)v48, v48))
  {
    unint64_t v21 = swift_bridgeObjectRetain(v3, v18, v19, v20);
    uint64_t v22 = (void *)_ArrayBuffer.requestNativeBuffer()(v21, a2);
    if (v22)
    {
      uint64_t v23 = (uint64_t)v22;
      char v24 = _ContiguousArrayBuffer.storesOnlyElementsOfType<A>(_:)((uint64_t)v22, v22, (uint64_t)a2, v48);
      swift_release(v23);
      if ((v24 & 1) == 0)
      {
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
        uint64_t v26 = v3 & 0xFFFFFFFFFFFFFF8LL;
        if (!isClassOrObjCExistentialType) {
          uint64_t v26 = v3;
        }
        return (__objc2_class **)(v26 | 1);
      }
    }

    else
    {
      swift_bridgeObjectRelease(v3);
      uint64_t v44 = _ArrayBuffer._asCocoaArray()(v3, a2);
      return (__objc2_class **)(~((unint64_t)v44 >> 1) & 0x4000000000000000LL | (unint64_t)v44);
    }
  }

  else
  {
    unint64_t v51 = v3;
    Swift::Int v27 = Array._getCount()();
    if (v27)
    {
      Swift::Int v30 = v27;
      unint64_t v50 = &_swiftEmptyArrayStorage;
      uint64_t v47 = type metadata accessor for ContiguousArray(0LL, (uint64_t)v48, v28, v29);
      ContiguousArray.reserveCapacity(_:)(v30);
      if (v30 < 0) {
        goto LABEL_22;
      }
      uint64_t v46 = v5;
      Swift::Int v33 = 0LL;
      while (v30 != v33)
      {
        unint64_t v34 = v51;
        char v35 = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
        char v36 = ((v34 & 0xC000000000000001LL) == 0) | ~v35;
        Array._checkSubscript(_:wasNativeTypeChecked:)(v33, (v34 & 0xC000000000000001LL) == 0 || (v35 & 1) == 0);
        if ((v36 & 1) != 0)
        {
          unint64_t v37 = v34
          char v38 = *(void (**)(char *, unint64_t, uint64_t *))(v4 + 16);
          v38(v13, v37, a2);
        }

        else
        {
          uint64_t v39 = (void *)_ArrayBuffer._getElementSlowPath(_:)(v33, v34, a2);
          uint64_t v40 = v39;
          if (v46 != 8)
          {
            swift_unknownObjectRelease(v39);
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
          }

          Swift::Int v49 = (Swift::Int)v39;
          char v38 = *(void (**)(char *, unint64_t, uint64_t *))(v4 + 16);
          v38(v13, (unint64_t)&v49, a2);
          swift_unknownObjectRelease(v40);
        }

        ++v33;
        (*(void (**)(char *, char *, uint64_t *))(v4 + 32))(v10, v13, a2);
        v38(v7, (unint64_t)v10, a2);
        swift_dynamicCast(v16, v7, a2, v48, 7LL);
        (*(void (**)(char *, uint64_t *))(v4 + 8))(v10, a2);
        ContiguousArray.append(_:)((uint64_t)v16, v47);
        if (v33 == 0x8000000000000000LL)
        {
          __break(1u);
LABEL_22:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
        }
      }

      Swift::Int v49 = v30;
      uint64_t v41 = type metadata accessor for Array(0LL, (uint64_t)a2, v31, v32);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v41, v42);
      _expectEnd<A>(of:is:)((uint64_t)&v51, (uint64_t)&v49, v41, WitnessTable);
      return v50;
    }

    else
    {
      _swift_isClassOrObjCExistentialType((uint64_t)v48, v48);
      return &_swiftEmptyArrayStorage;
    }
  }

  return (__objc2_class **)v3;
}

uint64_t _ContiguousArrayBuffer.storesOnlyElementsOfType<A>(_:)( uint64_t a1, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = *(a4 - 1);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = *(void *)(v11 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v14 = (char *)&v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = type metadata accessor for Optional(0LL, v15, v15, v16);
  uint64_t v18 = MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v31 - v19;
  unint64_t v21 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*a2 + 136LL))(v18);
  if (swift_dynamicCastMetatype(v21, a4)) {
    return 1LL;
  }
  unint64_t v34 = v10;
  unint64_t v24 = a2[2];
  if (v24)
  {
    uint64_t v33 = v7;
    unint64_t v25 = 0LL;
    uint64_t v26 = (char *)a2 + ((*(unsigned __int8 *)(v12 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80));
    uint64_t v32 = *(void *)(v12 + 72);
    Swift::Int v27 = *(void (**)(void, void, void))(v12 + 16);
    while (1)
    {
      uint64_t v28 = v27;
      v27(v20, v26, a3);
      if (v25 >= v24) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
      }
      uint64_t v31 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 56);
      v31(v20, 0LL, 1LL, a3);
      (*(void (**)(char *, char *, uint64_t))(v12 + 32))(v14, v20, a3);
      uint64_t v29 = v34;
      if ((swift_dynamicCast(v34, v14, a3, a4, 6LL) & 1) == 0) {
        return 0LL;
      }
      ++v25;
      (*(void (**)(char *, uint64_t *))(v33 + 8))(v29, a4);
      unint64_t v24 = a2[2];
      v26 += v32;
      Swift::Int v27 = v28;
      if (v25 == v24)
      {
        Swift::Int v30 = v31;
        goto LABEL_12;
      }
    }
  }

  else
  {
    Swift::Int v30 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 56);
LABEL_12:
    uint64_t v22 = 1LL;
    v30(v20, 1LL, 1LL, a3);
  }

  return v22;
}

uint64_t Array.init(_immutableCocoaArray:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000LL | a1;
}

uint64_t specialized closure #1 in _arrayForceCast<A, B>(_:)@<X0>( uint64_t a1@<X0>, swift *a2@<X1>, char *a3@<X8>)
{
  uint64_t v6 = (uint64_t *)((char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  (*(void (**)(uint64_t *))(v7 + 16))(v6);
  uint64_t v8 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CodingKey);
  return swift_dynamicCast(a3, v6, a2, v8, 7uLL);
}

__objc2_class **_sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg549_ss11CommandLineO10_argumentsSaySSGvpZfiSSSiXEfU_Tf1cn_n( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_22;
  }

  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = a1;
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, v2 & ~(v2 >> 63), 0);
  if (v2 < 0) {
LABEL_22:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  if (a2 <= v4) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = a2;
  }
  do
  {
    if (v6 == v4) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
    }
    if (one-time initialization token for _unsafeArgv != -1) {
      swift_once( &one-time initialization token for _unsafeArgv,  (dispatch_function_t)one-time initialization function for _unsafeArgv,  v5);
    }
    uint64_t v7 = *(uint8x16_t **)(static CommandLine._unsafeArgv + 8 * v4);
    if (!v7) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CommandLine.swift",  23LL,  2,  0x4EuLL,  0);
    }
    size_t v8 = _swift_stdlib_strlen(*(const char **)(static CommandLine._unsafeArgv + 8 * v4));
    if ((v8 & 0x8000000000000000LL) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    int64_t v9 = v8;
    int64_t v10 = validateUTF8(_:)(v7->i64, v8);
    uint64_t v20 = v6;
    if ((v12 & 1) != 0) {
      uint64_t v13 = repairUTF8(_:firstKnownBrokenRange:)(v7->i8, v9, v10, v11);
    }
    else {
      uint64_t v13 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v7, v9, v10 & 1);
    }
    uint64_t v15 = (__objc2_class *)v13;
    uint64_t v16 = v14;
    uint64_t v17 = qword_18C565BC8;
    if (qword_18C565BC8 >= (unint64_t)qword_18C565BD0 >> 1) {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (unint64_t)qword_18C565BD0 > 1,  qword_18C565BC8 + 1,  1);
    }
    qword_18C565BC8 = v17 + 1;
    uint64_t v18 = &_swiftEmptyArrayStorage + 2 * v17;
    v18[4] = v15;
    v18[5] = v16;
    ++v4;
    uint64_t v6 = v20;
  }

  while (a2 != v4);
  return &_swiftEmptyArrayStorage;
}

__objc2_class **_sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg5( void (*a1)(void *__return_ptr, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a4 - a3;
  if (__OFSUB__(a4, a3))
  {
    __break(1u);
    goto LABEL_17;
  }

  uint64_t v6 = v4;
  uint64_t v7 = &_swiftEmptyArrayStorage;
  if (!v5) {
    return v7;
  }
  uint64_t v9 = a3;
  uint64_t v23 = &_swiftEmptyArrayStorage;
  specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(0LL, v5 & ~(v5 >> 63), 0);
  if (v5 < 0) {
LABEL_17:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  uint64_t v7 = v23;
  if (a4 <= v9) {
    uint64_t v12 = v9;
  }
  else {
    uint64_t v12 = a4;
  }
  while (1)
  {
    if (v12 == v9) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
    }
    uint64_t v21 = v9;
    a1(v22, &v21);
    if (v6) {
      break;
    }
    uint64_t v6 = 0LL;
    uint64_t v19 = v12;
    uint64_t v20 = a2;
    uint64_t v13 = (__objc2_class *)v22[0];
    uint64_t v14 = (__objc2_class *)v22[1];
    uint64_t v23 = v7;
    unint64_t v16 = (unint64_t)v7[2];
    unint64_t v15 = (unint64_t)v7[3];
    if (v16 >= v15 >> 1)
    {
      specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v15 > 1, v16 + 1, 1);
      uint64_t v7 = v23;
    }

    v7[2] = (__objc2_class *)(v16 + 1);
    uint64_t v17 = &v7[2 * v16];
    v17[4] = v13;
    v17[5] = v14;
    ++v9;
    a2 = v20;
    uint64_t v12 = v19;
    if (a4 == v9) {
      return v7;
    }
  }

  swift_release((uint64_t)v7);
  return v7;
}

__objc2_class **_sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOqd__Isgnrzr_xAbGSlRzAGRsd_0_r_0_lIetMgnozo_Tpq5xq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyAdGs9CodingKey_pIsgnrzr_xSaysAH_pGAGSlRzsAH_pRsd__AGRsd_0_r_0_lIetMgnozo_Tp5( void (*a1)(__int128 *__return_ptr, char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  void (*v36)(__int128 *__return_ptr, char *);
  uint64_t v37;
  _BYTE v38[32];
  __int128 v39[2];
  __objc2_class **v40;
  uint64_t v6 = v5;
  char v36 = a1;
  unint64_t v37 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a4 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v35 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  int64_t v11 = (char *)&v29 - v10;
  unint64_t v12 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v30 = *(void *)(v12 - 8);
  unint64_t v31 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v29 = (char *)&v29 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  unint64_t v16 = (char *)&v29 - v15;
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 112))(a3, a4);
  uint64_t result = &_swiftEmptyArrayStorage;
  if (v17)
  {
    uint64_t v40 = &_swiftEmptyArrayStorage;
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v17 & ~(v17 >> 63),  0);
    (*(void (**)(uint64_t, uint64_t))(a4 + 64))(a3, a4);
    if (v17 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    uint64_t v19 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a4 + 80);
    uint64_t v33 = v4;
    unint64_t v34 = v19;
    unint64_t v32 = AssociatedTypeWitness;
    while (1)
    {
      uint64_t v20 = (void (*)(_BYTE *, void))v34(v38, v16, a3, a4);
      uint64_t v21 = v35;
      (*(void (**)(char *))(v35 + 16))(v11);
      v20(v38, 0LL);
      v36(v39, v11);
      if (v6) {
        break;
      }
      uint64_t v6 = 0LL;
      (*(void (**)(char *, unint64_t))(v21 + 8))(v11, AssociatedTypeWitness);
      uint64_t v22 = v40;
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v40))
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v22[2]->isa + 1,  1);
        uint64_t v22 = v40;
      }

      unint64_t v24 = (unint64_t)v22[2];
      unint64_t v23 = (unint64_t)v22[3];
      if (v24 >= v23 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v23 > 1),  v24 + 1,  1);
        uint64_t v22 = v40;
      }

      void v22[2] = (__objc2_class *)(v24 + 1);
      outlined init with take of MirrorPath(v39, (uint64_t)&v22[5 * v24 + 4]);
      uint64_t v25 = v33;
      (*(void (**)(char *, uint64_t, uint64_t))(a4 + 192))(v16, a3, a4);
      --v17;
      unint64_t AssociatedTypeWitness = v32;
      if (!v17)
      {
        uint64_t v27 = (uint64_t)v29;
        uint64_t v26 = v30;
        unint64_t v28 = v31;
        (*(void (**)(char *, char *, unint64_t))(v30 + 32))(v29, v16, v31);
        _expectEnd<A>(of:is:)(v25, v27, a3, a4);
        (*(void (**)(uint64_t, unint64_t))(v26 + 8))(v27, v28);
        return v40;
      }
    }

    (*(void (**)(char *, unint64_t))(v21 + 8))(v11, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v30 + 8))(v16, v31);
    return (__objc2_class **)swift_release((uint64_t)v40);
  }

  return result;
}

__objc2_class **_sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADsAE_pqd__Isgnrzr_xABsAE_pSlRzsAE_pRsd_0_r_0_lIetMgnozo_Tp5Tm( void (*a1)(char *, void *), uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v46 = a2;
  int64_t v45 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a5 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v42 = (char *)&v37 - v12;
  MEMORY[0x1895F8858](v11);
  uint64_t v41 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v40 = *(void *)(v14 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  uint64_t v39 = (char *)&v37 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v37 - v17;
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 112);
  uint64_t v48 = a5;
  uint64_t v20 = v19(a3, a5);
  if (v20)
  {
    Swift::Int v23 = v20;
    unint64_t v37 = v14;
    unint64_t v50 = &_swiftEmptyArrayStorage;
    uint64_t v43 = type metadata accessor for ContiguousArray(0LL, (uint64_t)a4, v21, v22);
    ContiguousArray.reserveCapacity(_:)(v23);
    unint64_t v24 = *(void (**)(void))(v48 + 64);
    char v38 = v18;
    uint64_t v25 = a3;
    uint64_t v26 = v5;
    uint64_t v27 = v25;
    v24();
    if (v23 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    uint64_t v44 = *(uint64_t (**)(void *, char *, uint64_t, uint64_t))(v48 + 80);
    uint64_t v29 = (uint64_t)v41;
    unint64_t v28 = v42;
    uint64_t v30 = v38;
    while (1)
    {
      unint64_t v31 = (void (*)(void *, void))v44(v49, v30, v27, v48);
      (*(void (**)(char *))(v10 + 16))(v28);
      v31(v49, 0LL);
      uint64_t v32 = v47;
      v45(v28, v49);
      if (v32) {
        break;
      }
      uint64_t v47 = 0LL;
      (*(void (**)(char *, unint64_t))(v10 + 8))(v28, AssociatedTypeWitness);
      ContiguousArray.append(_:)(v29, v43);
      (*(void (**)(char *, uint64_t))(v48 + 192))(v30, v27);
      if (!--v23)
      {
        uint64_t v33 = (uint64_t)v39;
        uint64_t v34 = v40;
        unint64_t v35 = v37;
        (*(void (**)(char *, char *, unint64_t))(v40 + 32))(v39, v30, v37);
        _expectEnd<A>(of:is:)(v26, v33, v27, v48);
        (*(void (**)(uint64_t, unint64_t))(v34 + 8))(v33, v35);
        return v50;
      }
    }

    (*(void (**)(char *, unint64_t))(v10 + 8))(v28, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v40 + 8))(v30, v37);
    return (__objc2_class **)swift_release((uint64_t)v50);
  }

  else
  {
    _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
    return &_swiftEmptyArrayStorage;
  }

__objc2_class **_sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOqd__Isgnrzr_xAbGSlRzAGRsd_0_r_0_lIetMgnozo_Tp5( void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v46 = a2;
  int64_t v45 = a1;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a5 + 8),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v42 = (char *)&v37 - v12;
  MEMORY[0x1895F8858](v11);
  uint64_t v41 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v40 = *(void *)(v14 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  uint64_t v39 = (char *)&v37 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v18 = (char *)&v37 - v17;
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 112);
  uint64_t v48 = a5;
  uint64_t v20 = v19(a3, a5);
  if (v20)
  {
    Swift::Int v23 = v20;
    unint64_t v37 = v14;
    unint64_t v50 = &_swiftEmptyArrayStorage;
    uint64_t v43 = type metadata accessor for ContiguousArray(0LL, (uint64_t)a4, v21, v22);
    ContiguousArray.reserveCapacity(_:)(v23);
    unint64_t v24 = *(void (**)(void))(v48 + 64);
    char v38 = v18;
    uint64_t v25 = a3;
    uint64_t v26 = v5;
    uint64_t v27 = v25;
    v24();
    if (v23 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    uint64_t v44 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(v48 + 80);
    uint64_t v29 = (uint64_t)v41;
    unint64_t v28 = v42;
    uint64_t v30 = v38;
    while (1)
    {
      unint64_t v31 = (void (*)(_BYTE *, void))v44(v49, v30, v27, v48);
      (*(void (**)(char *))(v10 + 16))(v28);
      v31(v49, 0LL);
      uint64_t v32 = v47;
      v45(v28);
      if (v32) {
        break;
      }
      uint64_t v47 = 0LL;
      (*(void (**)(char *, unint64_t))(v10 + 8))(v28, AssociatedTypeWitness);
      ContiguousArray.append(_:)(v29, v43);
      (*(void (**)(char *, uint64_t))(v48 + 192))(v30, v27);
      if (!--v23)
      {
        uint64_t v33 = (uint64_t)v39;
        uint64_t v34 = v40;
        unint64_t v35 = v37;
        (*(void (**)(char *, char *, unint64_t))(v40 + 32))(v39, v30, v37);
        _expectEnd<A>(of:is:)(v26, v33, v27, v48);
        (*(void (**)(uint64_t, unint64_t))(v34 + 8))(v33, v35);
        return v50;
      }
    }

    (*(void (**)(char *, unint64_t))(v10 + 8))(v28, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v40 + 8))(v30, v37);
    return (__objc2_class **)swift_release((uint64_t)v50);
  }

  else
  {
    _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
    return &_swiftEmptyArrayStorage;
  }

BOOL _swift_arrayDownCastConditionalIndirect( unint64_t *a1, __objc2_class ***a2, uint64_t *a3, char *a4)
{
  uint64_t v7 = *a1;
  unint64_t v8 = swift_bridgeObjectRetain(*a1, (uint64_t)a2, (uint64_t)a3, a4);
  uint64_t v10 = _arrayConditionalCast<A, B>(_:)(v8, a3, (uint64_t)a4, v9);
  swift_bridgeObjectRelease(v7);
  if (v10) {
    *a2 = v10;
  }
  return v10 != 0LL;
}

__objc2_class **_arrayConditionalCast<A, B>(_:)(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = type metadata accessor for Optional(0LL, a3, a3, a4);
  uint64_t v43 = *(void *)(v7 - 8);
  uint64_t v44 = v7;
  uint64_t v8 = MEMORY[0x1895F8858](v7);
  uint64_t v10 = (char *)&v42 - v9;
  uint64_t v52 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  unint64_t v50 = (char *)&v42 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  Swift::Int v49 = (char *)&v42 - v14;
  uint64_t v15 = *(a2 - 1);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  unint64_t v51 = (char *)&v42 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = MEMORY[0x1895F8858](v16);
  uint64_t v20 = (char *)&v42 - v19;
  uint64_t v42 = v21;
  MEMORY[0x1895F8858](v18);
  Swift::Int v23 = (char *)&v42 - v22;
  int64_t v55 = &_swiftEmptyArrayStorage;
  Swift::Int v24 = Array._getCount()();
  uint64_t v48 = type metadata accessor for ContiguousArray(0LL, a3, v25, v26);
  ContiguousArray.reserveCapacity(_:)(v24);
  Swift::Int v47 = Array._getCount()();
  if (!v47) {
    return v55;
  }
  Swift::Int v27 = 0LL;
  uint64_t v45 = a1;
  unint64_t v46 = a1 & 0xC000000000000001LL;
  while (1)
  {
    BOOL v28 = v46 == 0;
    char v29 = v28 | ~_swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v29 & 1);
    if ((v29 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t, uint64_t *))(v15 + 16))( v20,  a1 + ((*(unsigned __int8 *)(v15 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v15 + 80))
      + *(void *)(v15 + 72) * v27,
        a2);
    }

    else
    {
      uint64_t v40 = _ArrayBuffer._getElementSlowPath(_:)(v27, a1, a2);
      uint64_t v30 = (void *)v40;
      if (v42 != 8) {
        goto LABEL_15;
      }
      uint64_t v54 = v40;
      (*(void (**)(char *, uint64_t *, uint64_t *))(v15 + 16))(v20, &v54, a2);
      swift_unknownObjectRelease(v30);
    }

    uint64_t v30 = *(void **)(v15 + 32);
    ((void (*)(char *, char *, uint64_t *))v30)(v23, v20, a2);
    if (__OFADD__(v27, 1LL))
    {
      __break(1u);
LABEL_15:
      swift_unknownObjectRelease(v30);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    unint64_t v31 = v51;
    ((void (*)(char *, char *, uint64_t *))v30)(v51, v23, a2);
    char v32 = swift_dynamicCast(v10, v31, a2, a3, 6LL);
    uint64_t v33 = v52;
    uint64_t v34 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v52 + 56);
    if ((v32 & 1) == 0) {
      break;
    }
    v34(v10, 0LL, 1LL, a3);
    unint64_t v35 = *(void (**)(char *, char *, uint64_t))(v33 + 32);
    Swift::Int v53 = v27 + 1;
    char v36 = v20;
    unint64_t v37 = v49;
    v35(v49, v10, a3);
    uint64_t v38 = (uint64_t)v50;
    uint64_t v39 = v37;
    uint64_t v20 = v36;
    v35(v50, v39, a3);
    ContiguousArray.append(_:)(v38, v48);
    ++v27;
    a1 = v45;
    if (v53 == v47) {
      return v55;
    }
  }

  v34(v10, 1LL, 1LL, a3);
  swift_release((uint64_t)v55);
  (*(void (**)(char *, uint64_t))(v43 + 8))(v10, v44);
  return 0LL;
}

__objc2_class **specialized ContiguousArray.reserveCapacity(_:)(int64_t a1)
{
  uint64_t v3 = *v1;
  uint64_t result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(*v1);
  *int64_t v1 = v3;
  if (!(_DWORD)result || a1 > *(void *)(v3 + 24) >> 1)
  {
    if (*(void *)(v3 + 16) <= a1) {
      int64_t v5 = a1;
    }
    else {
      int64_t v5 = *(void *)(v3 + 16);
    }
    return specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(result, v5, 0);
  }

  return result;
}

Swift::Void __swiftcall ContiguousArray.reserveCapacity(_:)(Swift::Int a1)
{
  uint64_t v3 = *v1;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  *int64_t v1 = v3;
  if (!isUniquelyReferenced_nonNull_native || a1 > *(void *)(v3 + 24) >> 1)
  {
    if (*(void *)(v3 + 16) <= a1) {
      Swift::Int v5 = a1;
    }
    else {
      Swift::Int v5 = *(void *)(v3 + 16);
    }
    ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( isUniquelyReferenced_nonNull_native,  v5,  0);
  }

uint64_t specialized ContiguousArray.append(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v2);
  *uint64_t v2 = v5;
  if ((result & 1) == 0)
  {
    uint64_t result = specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v5 + 16) + 1LL,  1);
    uint64_t v5 = *v2;
  }

  unint64_t v8 = *(void *)(v5 + 16);
  unint64_t v7 = *(void *)(v5 + 24);
  if (v8 >= v7 >> 1)
  {
    uint64_t result = specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v7 > 1,  v8 + 1,  1);
    uint64_t v5 = *v2;
  }

  *(void *)(v5 + 16) = v8 + 1;
  uint64_t v9 = v5 + 16 * v8;
  *(void *)(v9 + 32) = a1;
  *(void *)(v9 + 40) = a2;
  *uint64_t v2 = v5;
  return result;
}

_OWORD *specialized ContiguousArray.append(_:)(_OWORD *a1)
{
  uint64_t v3 = *v1;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  *int64_t v1 = v3;
  if (!isUniquelyReferenced_nonNull_native)
  {
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v3 + 16) + 1LL,  1);
    uint64_t v3 = *v1;
  }

  unint64_t v6 = *(void *)(v3 + 16);
  unint64_t v5 = *(void *)(v3 + 24);
  if (v6 >= v5 >> 1)
  {
    specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v5 > 1),  v6 + 1,  1);
    uint64_t v3 = *v1;
  }

  *(void *)(v3 + 16) = v6 + 1;
  uint64_t result = outlined init with take of Any(a1, (_OWORD *)(v3 + 32 * v6 + 32));
  *int64_t v1 = v3;
  return result;
}

uint64_t ContiguousArray.append(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  unint64_t v7 = *(void *)(*v2 + 16);
  unint64_t v6 = *(void *)(*v2 + 24);
  if (v7 >= v6 >> 1)
  {
    ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)(v6 > 1, v7 + 1, 1);
    uint64_t v5 = *v2;
  }

  *(void *)(v5 + 16) = v7 + 1;
  uint64_t v8 = *(void *)(*(void *)(a2 + 16) - 8LL);
  return (*(uint64_t (**)(unint64_t, uint64_t))(v8 + 32))( v5 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80))
         + *(void *)(v8 + 72) * v7,
           a1);
}

uint64_t Array.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
}

uint64_t (*Array._buffer.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Bool __swiftcall Array._hoistableIsNativeTypeChecked()()
{
  return ((v0 & 0xC000000000000001LL) == 0) | !_swift_isClassOrObjCExistentialType((uint64_t)v1, v1);
}

id _ArrayBuffer.endIndex.getter(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      unint64_t v7 = (void *)a1;
    }
    else {
      unint64_t v7 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    return objc_msgSend(v7, sel_count);
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v5 = a1;
    }
    return *(id *)(v5 + 16);
  }

Swift::Int __swiftcall Array._getCapacity()()
{
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  if (_swift_isClassOrObjCExistentialType((uint64_t)v1, v1) && (v3 < 0 || (v3 & 0x4000000000000000LL) != 0))
  {
    if (v3 >= 0) {
      v3 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    id v10 = objc_msgSend(swift_unknownObjectRetain((id)v3, v4, v5, v6), sel_count);
    Swift::Int v11 = specialized RandomAccessCollection<>.distance(from:to:)(0LL, (uint64_t)v10, (id)v3);
    swift_unknownObjectRelease((id)v3);
    return v11;
  }

  else
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v2, v2);
    uint64_t v8 = v3 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v8 = v3;
    }
    return *(void *)(v8 + 24) >> 1;
  }

Swift::Void __swiftcall Array._makeMutableAndUnique()()
{
  uint64_t v2 = *(uint64_t **)(v0 + 16);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v2, v2);
  uint64_t v4 = *v1;
  if (isClassOrObjCExistentialType)
  {
    char isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(*v1);
    *int64_t v1 = v4;
    if ((isUniquelyReferenced_nonNull_bridgeObject & 1) == 0
      || _swift_isClassOrObjCExistentialType((uint64_t)v2, v2) && (v4 < 0 || (v4 & 0x4000000000000000LL) != 0))
    {
      goto LABEL_6;
    }
  }

  else
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
    *int64_t v1 = v4;
    if (!isUniquelyReferenced_nonNull_native) {
LABEL_6:
    }
      *int64_t v1 = _ArrayBuffer._consumeAndCreateNew()(v4, v2);
  }

Swift::Void __swiftcall Array._checkSubscript_native(_:)(Swift::Int a1)
{
}

unint64_t specialized Array._checkSubscript(_:wasNativeTypeChecked:)( unint64_t result, char a2, uint64_t a3)
{
  if ((a2 & 1) != 0 && ((result & 0x8000000000000000LL) != 0 || *(void *)(a3 + 16) <= result)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }
  return result;
}

{
  if ((a2 & 1) != 0
    && ((result & 0x8000000000000000LL) != 0 || *(void *)((a3 & 0xFFFFFFFFFFFFF8LL) + 0x10) <= result))
  {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }

  return result;
}

void __swiftcall Array._checkSubscript(_:wasNativeTypeChecked:)(Swift::Int _, Swift::Bool wasNativeTypeChecked)
{
  if (wasNativeTypeChecked)
  {
    uint64_t v4 = v2;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v3, v3);
    if (_ < 0) {
      goto LABEL_7;
    }
    uint64_t v7 = v4 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v7 = v4;
    }
    if (*(void *)(v7 + 16) <= (unint64_t)_) {
LABEL_7:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
  }

unint64_t specialized Array._checkSubscript_mutating(_:)(unint64_t result, uint64_t a2)
{
  if ((result & 0x8000000000000000LL) != 0 || *(void *)(a2 + 16) <= result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2B0uLL,  0);
  }
  return result;
}

{
  if ((result & 0x8000000000000000LL) != 0 || *(void *)((a2 & 0xFFFFFFFFFFFFF8LL) + 0x10) <= result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2B0uLL,  0);
  }
  return result;
}

Swift::Void __swiftcall Array._checkSubscript_mutating(_:)(Swift::Int a1)
{
  uint64_t v3 = v1;
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v2, v2);
  if (a1 < 0) {
    goto LABEL_5;
  }
  uint64_t v6 = v3 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v6 = v3;
  }
  if (*(void *)(v6 + 16) <= (unint64_t)a1) {
LABEL_5:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2B0uLL,  0);
}

id specialized Array._checkIndex(_:)(uint64_t a1, uint64_t a2)
{
  if (!((unint64_t)a2 >> 62))
  {
    id result = *(id *)((a2 & 0xFFFFFFFFFFFFF8LL) + 0x10);
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index is out of range",  27LL,  2,  "Swift/Array.swift",  17LL,  2,  0x1A3uLL,  0);
  }

  if (a2 < 0) {
    uint64_t v4 = (void *)a2;
  }
  else {
    uint64_t v4 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  id result = objc_msgSend(v4, sel_count);
LABEL_3:
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative Array index is out of range",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x1A4uLL,  0);
  }
  return result;
}

Swift::Void __swiftcall Array._checkIndex(_:)(Swift::Int a1)
{
  if (Array._getCount()() < a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index is out of range",  27LL,  2,  "Swift/Array.swift",  17LL,  2,  0x1A3uLL,  0);
  }
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative Array index is out of range",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x1A4uLL,  0);
  }
}

BOOL static Int.<= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 >= a1;
}

uint64_t Array.startIndex.getter()
{
  return 0LL;
}

void Array._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:)( unint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(a4 - 1) + 16))( a5,  a3 + ((*(unsigned __int8 *)(*(a4 - 1) + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(a4 - 1) + 80))
    + *(void *)(*(a4 - 1) + 72) * a1,
      a4);
  }

  else
  {
    id v7 = _ArrayBuffer._getElementSlowPath(_:)(a1, a3, a4);
    uint64_t v8 = v7;
    uint64_t v9 = *(a4 - 1);
    if (*(void *)(v9 + 64) != 8LL)
    {
      swift_unknownObjectRelease(v7);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    id v10 = v7;
    (*(void (**)(uint64_t, id *, uint64_t *))(v9 + 16))(a5, &v10, a4);
    swift_unknownObjectRelease(v8);
  }

unint64_t Array._getElementAddress(_:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
  uint64_t v7 = a2 & 0xFFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v7 = a2;
  }
  return v7
}

void *Array._owner.getter(int64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      id v10 = (void *)a1;
    }
    else {
      id v10 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_unknownObjectRetain(v10, v4, v5, v6);
  }

  else
  {
    else {
      id v10 = (void *)a1;
    }
    swift_bridgeObjectRetain(a1, v7, v8, v9);
  }

  return v10;
}

uint64_t Array._baseAddressIfContiguous.getter(uint64_t a1, uint64_t *a2)
{
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a2, a2)
    || (uint64_t result = 0LL, (a1 & 0x8000000000000000LL) == 0) && (a1 & 0x4000000000000000LL) == 0)
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v6 = a1;
    }
    uint64_t v7 = *(unsigned __int8 *)(*(a2 - 1) + 80);
    return v6 + ((v7 + 32) & ~v7);
  }

  return result;
}

Swift::Int protocol witness for _ArrayProtocol.capacity.getter in conformance [A]()
{
  return Array.capacity.getter();
}

id protocol witness for _ArrayProtocol._owner.getter in conformance [A](uint64_t a1)
{
  unint64_t v2 = *v1;
  uint64_t v3 = *(uint64_t **)(a1 + 16);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v3, v3)
    && ((v2 & 0x8000000000000000LL) != 0 || (v2 & 0x4000000000000000LL) != 0))
  {
    return _ArrayBuffer._nonNative.getter(v2);
  }

  else {
    uint64_t v7 = v2;
  }
  swift_bridgeObjectRetain(v2, v4, v5, v6);
  return (id)v7;
}

uint64_t protocol witness for _ArrayProtocol._baseAddressIfContiguous.getter in conformance [A](uint64_t a1)
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(uint64_t **)(a1 + 16);
  if (!_swift_isClassOrObjCExistentialType((uint64_t)v3, v3)
    || (uint64_t result = 0LL, (v2 & 0x8000000000000000LL) == 0) && (v2 & 0x4000000000000000LL) == 0)
  {
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v3, v3);
    uint64_t v6 = v2 & 0xFFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v6 = v2;
    }
    uint64_t v7 = *(unsigned __int8 *)(*(v3 - 1) + 80);
    return v6 + ((v7 + 32) & ~v7);
  }

  return result;
}

uint64_t protocol witness for _ArrayProtocol.init(_:) in conformance [A]@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v7 = type metadata accessor for _ArrayBuffer(0LL, *(void *)(a2 + 16), a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v7, v8);
  uint64_t result = Array.init<A>(_:)(a1, v10, v7, WitnessTable);
  *a5 = result;
  return result;
}

unint64_t protocol witness for _ArrayProtocol._buffer.getter in conformance [A]@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, unint64_t *a4@<X8>)
{
  unint64_t v5 = *v4;
  *a4 = *v4;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

Swift::Int __swiftcall Array.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1LL);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Array.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1LL);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

void *static Int.-= infix(_:_:)(void *result, uint64_t a2)
{
  if (__OFSUB__(*result, a2)) {
    __break(1u);
  }
  else {
    *result -= a2;
  }
  return result;
}

Swift::Int_optional __swiftcall Array.index(_:offsetBy:limitedBy:)( Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3 = specialized Array.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy);
  Swift::Bool v5 = v4 & 1;
  result.value = v3;
  result.is_nil = v5;
  return result;
}

BOOL static Int.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

void Array.subscript.getter(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
  char v9 = ((a2 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
  Array._checkSubscript(_:wasNativeTypeChecked:)( a1,  (a2 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
  if ((v9 & 1) != 0)
  {
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(a3 - 1) + 16))( a4,  a2 + ((*(unsigned __int8 *)(*(a3 - 1) + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(a3 - 1) + 80))
    + *(void *)(*(a3 - 1) + 72) * a1,
      a3);
  }

  else
  {
    id v10 = _ArrayBuffer._getElementSlowPath(_:)(a1, a2, a3);
    Swift::Int v11 = v10;
    uint64_t v12 = *(a3 - 1);
    if (*(void *)(v12 + 64) != 8LL)
    {
      swift_unknownObjectRelease(v10);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    id v13 = v10;
    (*(void (**)(uint64_t, id *, uint64_t *))(v12 + 16))(a4, &v13, a3);
    swift_unknownObjectRelease(v11);
  }

void key path getter for Array.subscript(_:) : <A>[A]A( uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
}

uint64_t key path setter for Array.subscript(_:) : <A>[A]A(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  return key path setter for Array.subscript(_:) : <A>[A]A( a1,  a2,  a3,  a4,  (uint64_t (*)(void, uint64_t))type metadata accessor for Array,  (uint64_t (*)(_BYTE *, uint64_t, uint64_t))Array.subscript.modify);
}

{
  return key path setter for Array.subscript(_:) : <A>[A]A( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void))type metadata accessor for Array,  (uint64_t (*)(id, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))Array.subscript.setter);
}

uint64_t (*Array.subscript.modify(uint64_t a1, Swift::Int a2, uint64_t a3))()
{
  Swift::Bool v5 = *(uint64_t **)(a3 + 16);
  Array._checkSubscript_mutating(_:)(a2);
  _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
  return EnumeratedSequence._base.modify;
}

uint64_t Array.subscript.setter(uint64_t a1, Swift::Int a2, uint64_t a3)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(uint64_t **)(a3 + 16);
  Array._checkSubscript_mutating(_:)(a2);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
  uint64_t v10 = v7 & 0xFFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v10 = v7;
  }
  return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t *))(*(v8 - 1) + 40))( v10 + ((*(unsigned __int8 *)(*(v8 - 1) + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(v8 - 1) + 80))
         + *(void *)(*(v8 - 1) + 72) * a2,
           a1,
           v8);
}

uint64_t Array.subscript.getter(Swift::Int a1, Swift::Int a2, int64_t a3, uint64_t *a4)
{
  return _ArrayBuffer.subscript.getter(a1, a2, a3, a4);
}

uint64_t key path getter for Array.subscript(_:) : <A>[A]A@<X0>( int64_t *a1@<X0>, Swift::Int *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = Array.subscript.getter(*a2, a2[1], *a1, *(uint64_t **)((char *)a2 + a3 - 8));
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

void Array.subscript.setter( void *a1, uint64_t a2, uint64_t a3, unint64_t a4, Swift::Int a5, Swift::Int a6, uint64_t a7)
{
  int64_t v14 = *v7;
  uint64_t v15 = *(uint64_t **)(a7 + 16);
  Array._checkIndex(_:)(a5);
  Array._checkIndex(_:)(a6);
  uint64_t v16 = (void *)_ArrayBuffer.subscript.getter(a5, a6, v14, v15);
  uint64_t v18 = v17;
  uint64_t v20 = v19;
  swift_unknownObjectRelease(v16);
  if (v18 + *(void *)(*(v15 - 1) + 72) * v20 != a2 + *(void *)(*(v15 - 1) + 72) * a3) {
    goto LABEL_2;
  }
  if ((uint64_t)(a4 >> 1) < a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a5 == a3 && a4 >> 1 == a6)
  {
    swift_unknownObjectRelease(a1);
  }

  else
  {
LABEL_2:
    v26[0] = a1;
    v26[1] = a2;
    v26[2] = a3;
    v26[3] = a4;
    uint64_t v23 = type metadata accessor for ArraySlice(0LL, (uint64_t)v15, v21, v22);
    swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v23, v24);
    Array.replaceSubrange<A>(_:with:)(a5, a6, (void (*)(void, void, void))v26, a7);
  }

BOOL static Equatable.!= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ((*(uint64_t (**)(void))(a4 + 8))() & 1) == 0;
}

uint64_t ArraySlice.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

unint64_t ArraySlice.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return a4 >> 1;
}

void specialized Array.replaceSubrange<A>(_:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array replace: subrange start is negative",  41LL,  2,  "Swift/Array.swift",  17LL,  2,  0x6D4uLL,  0);
  }
  uint64_t v9 = a1;
  uint64_t v10 = *v3;
  if (!((unint64_t)*v3 >> 62))
  {
    if (*(void *)((v10 & 0xFFFFFFFFFFFFF8LL) + 0x10) >= a2) {
      goto LABEL_4;
    }
LABEL_31:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array replace: subrange extends past the end",  44LL,  2,  "Swift/Array.swift",  17LL,  2,  0x6D7uLL,  0);
  }

  if (v10 < 0) {
    uint64_t v23 = (void *)*v3;
  }
  else {
    uint64_t v23 = (void *)(v10 & 0xFFFFFFFFFFFFFF8LL);
  }
LABEL_4:
  uint64_t v11 = a2 - v9;
  if (__OFSUB__(a2, v9))
  {
    __break(1u);
    goto LABEL_33;
  }

  uint64_t v6 = 1 - v11;
  if (__OFSUB__(1LL, v11))
  {
LABEL_33:
    __break(1u);
LABEL_34:
    if (v4 < 0) {
      uint64_t v24 = (void *)v4;
    }
    else {
      uint64_t v24 = (void *)(v4 & 0xFFFFFFFFFFFFFF8LL);
    }
    uint64_t v25 = (char *)objc_msgSend(v24, sel_count);
    p_ivar_lyt = (void **)&v25[v6];
    if (!__OFADD__(v25, v6)) {
      goto LABEL_8;
    }
LABEL_39:
    __break(1u);
LABEL_40:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
  }

  uint64_t v4 = *v3;
  unint64_t v5 = (unint64_t)*v3 >> 62;
  if (v5) {
    goto LABEL_34;
  }
  uint64_t v12 = *(void *)((v4 & 0xFFFFFFFFFFFFF8LL) + 0x10);
  p_ivar_lyt = (void **)(v12 + v6);
  if (__OFADD__(v12, v6)) {
    goto LABEL_39;
  }
LABEL_8:
  uint64_t v30 = a3;
  int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(v4);
  *Swift::Int v3 = v4;
  if (v5) {
    LODWORD(v15) = 0;
  }
  else {
    LODWORD(v15) = isUniquelyReferenced_nonNull_bridgeObject;
  }
  if ((_DWORD)v15 == 1)
  {
    uint64_t v16 = v4 & 0xFFFFFFFFFFFFFF8LL;
  }

  if (v5) {
    goto LABEL_50;
  }
  for (uint64_t i = *(void ***)((v4 & 0xFFFFFFFFFFFFF8) + 0x10); ; uint64_t i = (void **)objc_msgSend(v29, sel_count))
  {
    else {
      uint64_t v18 = (uint64_t)i;
    }
    uint64_t v4 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (char)v15,  v18,  1,  v4);
    *Swift::Int v3 = v4;
    uint64_t v16 = v4 & 0xFFFFFFFFFFFFFF8LL;
LABEL_19:
    if (v11 < 0) {
      goto LABEL_40;
    }
    p_ivar_lyt = (void **)(v16 + 32);
    uint64_t v9 = v16 + 32 + 8 * v9;
    swift_arrayDestroy(v9, v11, (uint64_t)&unk_189B8D230);
    if (!v6) {
      goto LABEL_25;
    }
    uint64_t v11 = v9 + 8;
    uint64_t v15 = (char *)&p_ivar_lyt[a2];
    uint64_t v19 = *(void *)(v16 + 16);
    if (__OFSUB__(v19, a2)) {
      goto LABEL_48;
    }
    specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)&p_ivar_lyt[a2], v19 - a2, (char *)(v9 + 8));
    uint64_t v20 = *(void *)(v16 + 16);
    BOOL v21 = __OFADD__(v20, v6);
    uint64_t v22 = (char *)(v20 + v6);
    if (!v21) {
      goto LABEL_24;
    }
LABEL_49:
    __break(1u);
LABEL_50:
    if (v4 < 0) {
      char v29 = (void *)v4;
    }
    else {
      char v29 = (void *)(v4 & 0xFFFFFFFFFFFFFF8LL);
    }
  }

  if (v4 >= 0) {
    uint64_t v26 = (void *)v16;
  }
  else {
    uint64_t v26 = (void *)v4;
  }
  p_ivar_lyt = &_SwiftValue__classData.ivar_lyt;
  id v27 = objc_msgSend(v26, sel_count);
  if (__OFSUB__(v27, a2))
  {
LABEL_48:
    __break(1u);
    goto LABEL_49;
  }

  specialized UnsafeMutablePointer.moveInitialize(from:count:)(v15, (uint64_t)v27 - a2, (char *)(v9 + 8));
  BOOL v28 = (char *)objc_msgSend(v26, sel_count);
  uint64_t v22 = &v28[v6];
  if (__OFADD__(v28, v6))
  {
    __break(1u);
    goto LABEL_48;
  }

LABEL_24:
  *(void *)(v16 + 16) = v22;
LABEL_25:
  *(void *)uint64_t v9 = v30;
  *Swift::Int v3 = v4;
}

  *(void *)(v19 + 16) = v25;
LABEL_25:
  if (v35 >= 1) {
    specialized closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(__src, v35, v35, (char *)v11);
  }
  *uint64_t v4 = v6;
}

  if (a4 < 0
    || 1LL << *(_BYTE *)(v51 + 32) <= a4
    || (int64_t v63 = *(void *)(v51 + (((unint64_t)a4 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64),
        swift_bridgeObjectRelease(v51),
        ((v63 >> a4) & 1) == 0)
    || (unint64_t v64 = *(_DWORD *)(v51 + 36), swift_bridgeObjectRelease(v51), v64 != (_DWORD)a5))
  {
LABEL_45:
    uint64_t v87 = 281LL;
    goto LABEL_46;
  }

      Swift::Int v49 = (v19 - 1) & v19;
      unint64_t v50 = v20;
      uint64_t v17 = __clz(__rbit64(v19)) + (v20 << 6);
    }

    uint64_t v22 = (unint64_t *)(*(void *)(a1 + 48) + 16 * v17);
    uint64_t v23 = *v22;
    uint64_t v24 = v22[1];
    outlined init with copy of AnyHashable(*(void *)(a1 + 56) + 40 * v17, (uint64_t)&v56);
    uint64_t v25 = v56;
    uint64_t v26 = v57;
    id v27 = v58;
    swift_retain((unint64_t *)a1, v28, v29, v30);
    swift_bridgeObjectRetain(v24, v31, v32, v33);
    outlined consume of [A : B].Iterator._Variant<A, B>(a1);
    if (!v24) {
      goto LABEL_31;
    }
    Swift::Int v53 = v23;
    uint64_t v54 = v24;
    v51[0] = v25;
    v51[1] = v26;
    uint64_t v52 = v27;
    swift_dynamicCast((char *)v55, (uint64_t *)v51, (swift *)&type metadata for AnyHashable, byte_189B8D218, 7uLL);
    uint64_t v34 = v53;
    unint64_t v35 = v54;
    outlined init with take of Any(v55, &v57);
    outlined init with take of Any(&v57, v59);
    outlined init with take of Any(v59, &v56);
    char v36 = specialized __RawDictionaryStorage.find<A>(_:)(v34, v35);
    unint64_t v37 = v36;
    if ((v38 & 1) != 0)
    {
      int64_t v14 = (unint64_t *)((char *)v46[6] + 16 * v36);
      uint64_t v15 = v14[1];
      __objc2_class *v14 = v34;
      v14[1] = v35;
      swift_bridgeObjectRelease(v15);
      uint64_t v16 = (uint64_t *)((char *)v46[7] + 32 * v37);
      __swift_destroy_boxed_opaque_existential_1Tm(v16);
      uint64_t result = (unint64_t)outlined init with take of Any(&v56, v16);
      goto LABEL_8;
    }

    if (v46[2] >= v46[3]) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  0x1FFuLL,  0);
    }
    *(__objc2_class **)((char *)v44 + ((v36 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) = (__objc2_class *)(*(unint64_t *)((char *)v44 + ((v36 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) | (1LL << v36));
    uint64_t v39 = (unint64_t *)((char *)v46[6] + 16 * v36);
    char *v39 = v34;
    v39[1] = v35;
    uint64_t result = (unint64_t)outlined init with take of Any(&v56, (_OWORD *)v46[7] + 2 * v36);
    uint64_t v40 = v46[2];
    uint64_t v41 = __OFADD__(v40, 1LL);
    uint64_t v42 = (__objc2_class *)((char *)&v40->isa + 1);
    if (v41) {
      break;
    }
    v46[2] = v42;
LABEL_8:
    uint64_t v8 = v49;
  }

  __break(1u);
LABEL_34:
  __break(1u);
LABEL_35:
  __break(1u);
  return result;
}

      unint64_t v96 = v60;
      unint64_t v98 = v61(a3);
      unint64_t v99 = v235(v8, v6);
      uint64_t v100 = v233(v8, v6);
      if ((v99 & 1) != 0)
      {
        if (v100 > 64)
        {
          v252[0] = v98;
          int64_t v103 = v96;
          Swift::String v104 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
          uint64_t v105 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
          uint64_t v106 = v244;
          v104(v252, &type metadata for Int, v105, v8, v6);
          unint64_t v96 = v103;
          unint64_t v107 = (*(uint64_t (**)(char *, void (*)(void), void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v106,  v250,  v8);
          v59(v106, v8);
          if ((v107 & 1) == 0)
          {
            uint64_t v108 = *(void (**)(void))(v242 + 16);
            goto LABEL_34;
          }

  uint64_t v17 = a2._rawBits & 0xC;
  if ((a2._rawBits & 2) == 0 || v17 == v12)
  {
    if (v17 == v12) {
      a2._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
    }
    if (a2._rawBits >> 14 < v7 >> 14 || v13 < a2._rawBits >> 14) {
      goto LABEL_16;
    }
    if ((a2._rawBits & 1) != 0)
    {
      if ((v7 & 2) != 0) {
        goto LABEL_35;
      }
    }

    else
    {
      a2._Swift::UInt64 rawBits = a2._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a2)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v7 & 2) != 0)
      {
LABEL_35:
        if ((a2._rawBits & 2) != 0) {
          goto LABEL_39;
        }
      }
    }

    if (a2._rawBits >> 14 != v7 >> 14 && a2._rawBits >> 14 != v13) {
      a2._Swift::UInt64 rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(a2._rawBits, v7, v6, v8, v9);
    }
    goto LABEL_39;
  }

  if (a2._rawBits >> 14 < v7 >> 14 || v13 < a2._rawBits >> 14) {
    goto LABEL_10;
  }
LABEL_39:
  id v13 = a2._rawBits >> 14;
  if (rawBits >> 14 < a2._rawBits >> 14)
  {
    uint64_t v7 = 0LL;
    a2._Swift::UInt64 rawBits = v6 >> 16;
    uint64_t v18 = HIBYTE(v9) & 0xF;
    uint64_t v19 = v9 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v20 = (v9 & 0xFFFFFFFFFFFFFFFLL) + 32;
    uint64_t v12 = v8 & 0xFFFFFFFFFFFFLL;
    if (((v9 >> 60) & ((v8 & 0x800000000000000LL) == 0)) != 0) {
      BOOL v21 = 8LL;
    }
    else {
      BOOL v21 = 4LL;
    }
    while (1)
    {
      uint64_t v6 = v7 + 1;
      if (__OFADD__(v7, 1LL))
      {
        __break(1u);
LABEL_97:
        __break(1u);
LABEL_98:
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
LABEL_12:
        if (rawBits >> 14 < v7 >> 14 || v13 < rawBits >> 14)
        {
LABEL_16:
          uint64_t v15 = 65LL;
LABEL_17:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v15,  0);
        }

        if ((rawBits & 1) != 0)
        {
          if ((v7 & 2) != 0) {
            goto LABEL_20;
          }
LABEL_21:
          if (rawBits >> 14 != v7 >> 14 && rawBits >> 14 != v13) {
            Swift::UInt64 rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(rawBits, v7, v6, v8, v9);
          }
        }

        else
        {
          Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
          if ((v7 & 2) == 0) {
            goto LABEL_21;
          }
LABEL_20:
          if ((rawBits & 2) == 0) {
            goto LABEL_21;
          }
        }

        goto LABEL_24;
      }

      uint64_t v22 = (rawBits >> 8) & 0x3F;
      uint64_t v23 = rawBits >> 16;
      if (!v22) {
        break;
      }
LABEL_59:
      id v27 = v22 + v23;
      BOOL v28 = v27 << 16;
      char v29 = v27 & 0xFFFFFFFFFFFFLL;
      if ((v27 & 0xFFFFFFFFFFFFLL) != a2._rawBits)
      {
        if ((v9 & 0x1000000000000000LL) != 0) {
          goto LABEL_81;
        }
        if ((v9 & 0x2000000000000000LL) != 0)
        {
          uint64_t v54 = v8;
          int64_t v55 = v19;
          if (v29 + 1 != v18)
          {
            uint64_t v33 = *(unsigned __int16 *)((char *)&v54 + v29);
LABEL_72:
            if (v33 == 2573 || (v33 & 0x8080) != 0)
            {
LABEL_81:
              unint64_t v46 = v20;
              unint64_t v50 = v18;
              unint64_t v35 = v29;
              char v36 = v19;
              uint64_t v30 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v35);
              uint64_t v20 = v46;
              uint64_t v18 = v50;
              uint64_t v19 = v36;
              if (v30 > 63) {
                goto LABEL_79;
              }
              goto LABEL_78;
            }
          }
        }

        else
        {
          unint64_t v31 = (char *)v20;
          char v32 = v8 & 0xFFFFFFFFFFFFLL;
          if ((v8 & 0x1000000000000000LL) == 0)
          {
            uint64_t v48 = v20;
            uint64_t v52 = v18;
            uint64_t v45 = v19;
            unint64_t v31 = (char *)_StringObject.sharedUTF8.getter(v8, v9);
            uint64_t v19 = v45;
            uint64_t v20 = v48;
            uint64_t v18 = v52;
          }

          if (v29 + 1 != v32)
          {
            if (!v31) {
LABEL_103:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            uint64_t v33 = *(unsigned __int16 *)&v31[v29];
            goto LABEL_72;
          }
        }

        uint64_t v30 = 1LL;
        goto LABEL_78;
      }

      uint64_t v30 = 0LL;
LABEL_78:
      v28 |= v30 << 8;
LABEL_79:
      Swift::UInt64 rawBits = v21 | v28 | 1;
      ++v7;
      if (v13 <= v28 >> 14) {
        return v6;
      }
    }

    if (v23 == a2._rawBits)
    {
      uint64_t v22 = 0LL;
      goto LABEL_59;
    }

    if ((v9 & 0x1000000000000000LL) == 0)
    {
      if ((v9 & 0x2000000000000000LL) == 0)
      {
        uint64_t v24 = (char *)v20;
        uint64_t v25 = v8 & 0xFFFFFFFFFFFFLL;
        if ((v8 & 0x1000000000000000LL) == 0)
        {
          Swift::Int v49 = v20;
          Swift::Int v53 = v18;
          uint64_t v38 = v19;
          uint64_t v24 = (char *)_StringObject.sharedUTF8.getter(v8, v9);
          uint64_t v20 = v49;
          uint64_t v18 = v53;
          uint64_t v19 = v38;
        }

        if (v23 + 1 == v25)
        {
LABEL_58:
          uint64_t v22 = 1LL;
          goto LABEL_59;
        }

        if (!v24) {
          goto LABEL_103;
        }
        uint64_t v26 = *(unsigned __int16 *)&v24[v23];
        if (v26 == 2573) {
          goto LABEL_83;
        }
        goto LABEL_57;
      }

      uint64_t v54 = v8;
      int64_t v55 = v19;
      if (v23 + 1 == v18) {
        goto LABEL_58;
      }
      uint64_t v26 = *(unsigned __int16 *)((char *)&v54 + v23);
      if (v26 != 2573)
      {
LABEL_57:
        if ((v26 & 0x80808080) == 0) {
          goto LABEL_58;
        }
      }
    }

            uint64_t v25 = _StringGuts.nativeUnusedCapacity.getter(v9, v10);
            BOOL v28 = (v26 & 1) == 0 && v25 >= v1;
            if ((v2 & 0x2000000000000000LL) != 0
              && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
            {
              if (v28)
              {
LABEL_47:
                if ((0x80000001818B6F40LL & 0x1000000000000000LL) != 0)
                {
                  _StringGuts._foreignAppendInPlace(_:)( 0xD00000000000001CLL,  0x80000001818B6F40LL | 0x8000000000000000LL,  0LL,  v16);
                  unint64_t v37 = 0x80000001818B6F40LL | 0x8000000000000000LL;
                }

                else
                {
                  uint64_t v34 = (0x80000001818B6F40LL & 0x2000000000000000LL) == 0
                     || (0x80000001818B6F40LL & 0x4000000000000000LL) != 0;
                  swift_bridgeObjectRelease_n(0x80000001818B6F40LL | 0x8000000000000000LL, 5LL);
                  if ((0x80000001818B6F40LL & 0x2000000000000000LL) != 0)
                  {
                    swift_bridgeObjectRelease(0x80000001818B6F40LL | 0x8000000000000000LL);
                    v341 = 0xD00000000000001CLL;
                    v342 = 0x80000001818B6F40LL & 0xFFFFFFFFFFFFFFLL;
                    unint64_t v142 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v16,  (uint64_t)&v341,  (0x80000001818B6F40LL >> 56) & 0xF);
                    _StringGuts.appendInPlace(_:isASCII:)(v142, v143, v34);
                    swift_bridgeObjectRelease(0x80000001818B6F40LL | 0x8000000000000000LL);
                    goto LABEL_87;
                  }

                  unint64_t v35 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v16,  (0x80000001818B6F40LL & 0xFFFFFFFFFFFFFFFLL) + 32,  28LL);
                  _StringGuts.appendInPlace(_:isASCII:)(v35, v36, v34);
                  unint64_t v37 = 0x80000001818B6F40LL | 0x8000000000000000LL;
                }

                swift_bridgeObjectRelease_n(v37, 2LL);
                goto LABEL_87;
              }
            }

            else if (v28)
            {
LABEL_46:
              _StringGuts.grow(_:)(v23);
              goto LABEL_47;
            }

            uint64_t v30 = _StringGuts.nativeCapacity.getter(v9, v10);
            if ((v31 & 1) != 0) {
              char v32 = 0LL;
            }
            else {
              char v32 = v30;
            }
            if (v32 + 0x4000000000000000LL < 0) {
              goto LABEL_327;
            }
            uint64_t v33 = 2 * v32;
            if (v33 > v23) {
              uint64_t v23 = v33;
            }
            goto LABEL_46;
          }
        }

        else
        {
          if (v23 > 15) {
            goto LABEL_24;
          }
          if ((v10 & 0x2000000000000000LL) == 0) {
            goto LABEL_35;
          }
        }

        uint64_t v12 = v10;
        goto LABEL_58;
      }

      goto LABEL_309;
    }
  }

  else
  {
    swift_bridgeObjectRetain_n(0x80000001818B6F40LL | 0x8000000000000000LL, 4LL, v17, v18);
    BOOL v1 = v16;
    if ((v10 & 0x1000000000000000LL) == 0) {
      goto LABEL_15;
    }
  }

  v321 = String.UTF8View._foreignCount()();
  uint64_t v23 = v321 + v1;
  if (!__OFADD__(v321, v1)) {
    goto LABEL_16;
  }
LABEL_309:
  __break(1u);
LABEL_310:
  __break(1u);
  while (1)
  {
    swift_bridgeObjectRetain_n(a1, 5LL, v20, v21);
    v322._Swift::UInt64 rawBits = 1LL;
    v323._Swift::UInt64 rawBits = (v2 << 16) | 1;
    v324._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v322, v323, v12, a1);
    if (v324._rawBits < 0x10000) {
      v324._rawBits |= 3;
    }
    uint64_t v2 = specialized Collection.count.getter(v324, v325, v12, a1);
    swift_bridgeObjectRelease(a1);
    if ((v10 & 0x1000000000000000LL) != 0) {
      goto LABEL_314;
    }
    while (2)
    {
      uint64_t v22 = __OFADD__(v3, v2);
      v3 += v2;
      if (v22) {
        goto LABEL_316;
      }
LABEL_122:
      if ((v16 & ~v10 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
      {
        Swift::String v85 = _StringGuts.nativeUnusedCapacity.getter(v16, v10);
        if ((v82 & 1) != 0) {
          goto LABEL_247;
        }
        uint64_t v86 = (v10 >> 61) & 1;
        if (v85 < v2) {
          LODWORD(v86) = 1;
        }
        if (v3 <= 15 && (_DWORD)v86)
        {
LABEL_129:
          swift_bridgeObjectRetain(v10, v82, v83, v84);
          uint64_t v87 = _StringGuts._convertedToSmall()(v16, v10);
          int64_t v89 = v88;
          swift_bridgeObjectRelease(v10);
          v90._Swift::UInt64 rawBits = (v340 << 16) | 1;
          v91._Swift::UInt64 rawBits = 1LL;
          v92._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v91, v90, v12, a1);
          if (v92._rawBits < 0x10000) {
            v92._rawBits |= 3;
          }
          uint64_t v94 = specialized String.init(_:)(v92, v93, v12, a1);
          unint64_t v96 = v95;
          swift_bridgeObjectRelease(a1);
          unint64_t v97 = _StringGuts._convertedToSmall()(v94, v96);
          uint64_t v2 = v98;
          swift_bridgeObjectRelease(v96);
          unint64_t v99 = specialized _SmallString.init(_:appending:)(v87, v89, v97, v2);
          if ((v101 & 1) == 0)
          {
            uint64_t v102 = (char *)v99;
            int64_t v103 = v100;
            swift_bridgeObjectRelease(v10);
            swift_bridgeObjectRelease(a1);
            v343 = (unint64_t)v102;
            v344 = v103;
            goto LABEL_212;
          }

          goto LABEL_238;
        }
      }

      else if (v3 <= 15)
      {
        goto LABEL_129;
      }

      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v3, v2);
      if ((a1 & 0x1000000000000000LL) != 0) {
        goto LABEL_194;
      }
      swift_bridgeObjectRelease_n(a1, 4LL);
      if (!v1)
      {
        if ((v12 & 0x1000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(a1);
          Swift::String v104 = (unint64_t *)((a1 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v105 = v339;
          uint64_t v16 = v339;
          goto LABEL_138;
        }

        Swift::String v104 = (unint64_t *)_StringObject.sharedUTF8.getter(v12, a1);
        uint64_t v16 = v336;
        swift_bridgeObjectRelease(a1);
        if (v16 < v339) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
        }
        goto LABEL_337;
      }

      swift_bridgeObjectRelease_n(a1, 2LL);
      uint64_t v16 = ((unint64_t)a1 >> 62) & 1;
      v341 = v12;
      v342 = a1 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v144 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v23, (uint64_t)&v341, v23);
      Swift::String v104 = &v343;
      _StringGuts.appendInPlace(_:isASCII:)(v144, v145, (a1 & 0x4000000000000000LL) != 0);
      if (!v9)
      {
        swift_bridgeObjectRelease(a1);
        goto LABEL_212;
      }

          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
        }
      }

      else
      {
        __break(1u);
      }

      __break(1u);
      goto LABEL_24;
    }

    swift_unknownObjectRelease(v12);
    return 0LL;
  }

  if (!*(void *)(a2 + 16)) {
    return 0LL;
  }
  char v36 = (*(uint64_t (**)(void, uint64_t *, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
  unint64_t v37 = -1LL << *(_BYTE *)(a2 + 32);
  char v32 = v36 & ~v37;
  Swift::Int v47 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v32 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v32) & 1) == 0) {
    return 0LL;
  }
  uint64_t v45 = ~v37;
  unint64_t v46 = a1;
  uint64_t v38 = *(void *)(a4 + 8);
  uint64_t v39 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v38 + 8);
  uint64_t v40 = *(void *)(v8 + 72);
  uint64_t v41 = *(void (**)(char *, unint64_t, uint64_t *))(v8 + 16);
  while (1)
  {
    v41(v10, *(void *)(a2 + 48) + v40 * v32, a3);
    uint64_t v42 = v39(v10, v46, a3, v38);
    (*(void (**)(char *, uint64_t *))(v8 + 8))(v10, a3);
    if ((v42 & 1) != 0) {
      break;
    }
    char v32 = (v32 + 1) & v45;
    if (((*(void *)(v47 + ((v32 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v32) & 1) == 0) {
      return 0LL;
    }
  }

  return v32;
}

          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
        }
      }

      else
      {
        __break(1u);
      }

      __break(1u);
      goto LABEL_24;
    }

    swift_unknownObjectRelease(v12);
    return 0LL;
  }

  if (!*(void *)(a2 + 16)) {
    return 0LL;
  }
  char v36 = (*(uint64_t (**)(void, uint64_t *, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
  unint64_t v37 = -1LL << *(_BYTE *)(a2 + 32);
  char v32 = v36 & ~v37;
  Swift::Int v47 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v32 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v32) & 1) == 0) {
    return 0LL;
  }
  uint64_t v45 = ~v37;
  unint64_t v46 = a1;
  uint64_t v38 = *(void *)(a4 + 8);
  uint64_t v39 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v38 + 8);
  uint64_t v40 = *(void *)(v8 + 72);
  uint64_t v41 = *(void (**)(char *, unint64_t, uint64_t *))(v8 + 16);
  while (1)
  {
    v41(v10, *(void *)(a2 + 48) + v40 * v32, a3);
    uint64_t v42 = v39(v10, v46, a3, v38);
    (*(void (**)(char *, uint64_t *))(v8 + 8))(v10, a3);
    if ((v42 & 1) != 0) {
      break;
    }
    char v32 = (v32 + 1) & v45;
    if (((*(void *)(v47 + ((v32 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v32) & 1) == 0) {
      return 0LL;
    }
  }

  return v32;
}

    uint64_t v19 = 0LL;
    uint64_t v30 = 0LL;
    BOOL v28 = 0u;
    char v29 = 0u;
  }

  uint64_t v23 = *(void *)(v7 + 8 * v24);
  if (v23)
  {
    BOOL v21 = v18 + 3;
    goto LABEL_12;
  }

  while (1)
  {
    BOOL v21 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v21 >= v11)
    {
      uint64_t v22 = v11 - 1;
      goto LABEL_24;
    }

    uint64_t v23 = *(void *)(v7 + 8 * v21);
    ++v24;
    if (v23) {
      goto LABEL_12;
    }
  }

      uint64_t v17 = *a4;
      do
      {
        BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v17);
        *a4 = v17;
        if ((isUniquelyReferenced_nonNull_native & 1) == 0)
        {
          BOOL isUniquelyReferenced_nonNull_native = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v17 + 16) + 1LL,  1,  v17);
          uint64_t v17 = isUniquelyReferenced_nonNull_native;
          *a4 = isUniquelyReferenced_nonNull_native;
        }

        uint64_t v19 = *(void *)(v17 + 16);
        uint64_t v18 = *(void *)(v17 + 24);
        if (v19 >= v18 >> 1)
        {
          BOOL isUniquelyReferenced_nonNull_native = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v18 > 1),  v19 + 1,  1,  v17);
          uint64_t v17 = isUniquelyReferenced_nonNull_native;
        }

        *(void *)(v17 + 16) = v19 + 1;
        *(_BYTE *)(v17 + v19 + 32) = v16 - 1;
        *a4 = v17;
        uint64_t v20 = v16 >= 0x100;
        v16 >>= 8;
      }

      while (v20);
      goto LABEL_3;
    }

    if ((v7 & 0xF800) != 0xD800)
    {
      lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser( isUniquelyReferenced_nonNull_native,  a2,  a3);
      uint64_t v23 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      BOOL isUniquelyReferenced_nonNull_native = ((uint64_t (*)(_BYTE *, void))v23)(v39, 0LL);
      uint64_t v7 = (unsigned __int16)v7;
      uint64_t v15 = 1;
      goto LABEL_22;
    }

    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v10 = v6;
LABEL_9:
    uint64_t v11 = v8;
    if (v8 > 0x1Fu) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UIntBuffer.swift",  22LL,  2,  0xBEuLL,  0);
    }
    uint64_t v6 = v10 + 1;
    uint64_t v7 = (*v10 << v8) | ((-65535 << v8) - 1) & v7;
    v8 += 16;
    if (v11 <= 0xF && v6 != (unsigned __int16 *)a2)
    {
      uint64_t v6 = v10 + 2;
      uint64_t v7 = (v10[1] << v8) | ((0x10000 << v11) - 1) & v7;
      uint64_t v8 = v11 + 32;
    }

          unint64_t v51 = v29[1].u64[0];
          do
          {
            uint64_t v52 = v29[1].u64[1];
            if (v51 >= v52 >> 1) {
              char v29 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v52 > 1),  v51 + 1,  1,  (uint64_t)v29);
            }
            v29[1].i64[0] = v51 + 1;
            v29[2].i8[v51++] = v41 - 1;
            Swift::Int v53 = v41 >= 0x100;
            v41 >>= 8;
          }

          while (v53);
          goto LABEL_2;
        }

        ((void (*)(unsigned int *, ValueMetadata *))Description[1])(v14, AssociatedTypeWitness);
        uint64_t v41 = (v39 + 1);
        if (v41) {
          goto LABEL_24;
        }
      }

      else
      {
        if (v37 != &type metadata for Unicode.UTF8) {
          goto LABEL_31;
        }
        if (AssociatedTypeWitness != &type metadata for _ValidUTF8Buffer) {
LABEL_43:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
        uint64_t v41 = *v14;
        ((void (*)(unsigned int *))Description[1])(v14);
        if (v41) {
          goto LABEL_24;
        }
      }
    }

    if (EnumCaseMultiPayload == 2) {
      break;
    }
    uint64_t v43 = v29[1].u64[0];
    uint64_t v42 = v29[1].u64[1];
    uint64_t v44 = v42 >> 1;
    uint64_t v45 = v43 + 1;
    if (v42 >> 1 <= v43)
    {
      char v29 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v42 > 1),  v43 + 1,  1,  (uint64_t)v29);
      uint64_t v42 = v29[1].u64[1];
      uint64_t v44 = v42 >> 1;
    }

    v29[1].i64[0] = v45;
    v29[2].i8[v43] = -17;
    unint64_t v46 = v43 + 2;
    if (v44 <= v45)
    {
      char v29 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v42 > 1),  v43 + 2,  1,  (uint64_t)v29);
      uint64_t v42 = v29[1].u64[1];
      uint64_t v44 = v42 >> 1;
    }

    v29[1].i64[0] = v46;
    v29[2].i8[v45] = -65;
    Swift::Int v47 = v43 + 3;
    if (v44 <= v46) {
      char v29 = (uint8x16_t *)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v42 > 1),  v47,  1,  (uint64_t)v29);
    }
    v29[1].i64[0] = v47;
    v29[2].i8[v46] = -67;
    LODWORD(v74) = 1;
  }

  (*(void (**)(_BYTE *, unint64_t))(v71 + 8))(v80, v81);
  unint64_t v60 = *(void (**)(_BYTE *, unint64_t))(v73 + 8);
  uint64_t v61 = v79;
  v60(v78, v79);
  v60(v70, v61);
  if ((v74 & 1) == 0 || (v69 & 1) != 0)
  {
    unint64_t v66 = v29[1].i64[0];
    swift_bridgeObjectRetain((unint64_t)v29, v62, v63, v64);
    char v65 = specialized static String._uncheckedFromUTF8(_:)(v29 + 2, v66);
    swift_bridgeObjectRelease_n((uint64_t)v29, 2LL);
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v29);
    return 0LL;
  }

  return v65;
}

      if (v14 <= v17 >> 16)
      {
        uint64_t v25 = 144LL;
LABEL_34:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v25,  0);
      }

      uint64_t v17 = String.UTF8View._foreignIndex(after:)((Swift::String::Index)v17)._rawBits;
LABEL_26:
      if (v18 == v13) {
        return 0LL;
      }
      *(_BYTE *)(a1 + v13++) = v23;
    }

    while (4 * v14 != v17 >> 14);
  }

  return v13;
}

  __break(1u);
}

              uint64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
              uint64_t v26 = (v24 & 1) == 0 && v23 >= v15;
              if ((v20 & 0x2000000000000000LL) != 0
                && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
              {
                id v27 = a1;
                if (v26)
                {
LABEL_42:
                  swift_bridgeObjectRelease_n((uint64_t)v8._object, 4LL);
                  if (((uint64_t)v8._object & 0x1000000000000000LL) != 0)
                  {
                    swift_bridgeObjectRelease((uint64_t)v8._object);
                    _StringGuts._foreignAppendInPlace(_:)( v8._countAndFlagsBits,  (unint64_t)v8._object,  0LL,  v254);
                    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
                    x1_0 = v251;
                  }

                  else if (v12)
                  {
                    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
                    *(void *)&v260 = v8._countAndFlagsBits;
                    *((void *)&v260 + 1) = (uint64_t)v8._object & 0xFFFFFFFFFFFFFFLL;
                    char v32 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v8._object >> 56) & 0xF,  (uint64_t)&v260,  ((unint64_t)v8._object >> 56) & 0xF);
                    _StringGuts.appendInPlace(_:isASCII:)(v32, v33, ((uint64_t)v8._object & 0x4000000000000000LL) != 0);
                    swift_bridgeObjectRelease((uint64_t)v8._object);
                    x1_0 = v251;
                  }

                  else
                  {
                    if ((v8._countAndFlagsBits & 0x1000000000000000LL) != 0)
                    {
                      swift_bridgeObjectRelease((uint64_t)v8._object);
                      uint64_t v78 = (id)(((uint64_t)v8._object & 0xFFFFFFFFFFFFFFFLL) + 32);
                      unint64_t v79 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
                      v80 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
                      x1_0 = v251;
                    }

                    else
                    {
                      uint64_t v78 = _StringObject.sharedUTF8.getter(v8._countAndFlagsBits, (uint64_t)v8._object);
                      v80 = v245;
                      swift_bridgeObjectRelease((uint64_t)v8._object);
                      if (v80 < (v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
LABEL_192:
                      }
                        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
                      x1_0 = v251;
                      id v27 = a1;
                      unint64_t v79 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
                    }

                    char v81 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v79, (uint64_t)v78, v80);
                    _StringGuts.appendInPlace(_:isASCII:)(v81, v82, v8._countAndFlagsBits < 0);
                    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
                  }

                  goto LABEL_89;
                }
              }

              else
              {
                id v27 = a1;
                if (v26)
                {
LABEL_41:
                  _StringGuts.grow(_:)(v19);
                  goto LABEL_42;
                }
              }

              BOOL v28 = _StringGuts.nativeCapacity.getter(v3, v5);
              if ((v29 & 1) != 0) {
                uint64_t v30 = 0LL;
              }
              else {
                uint64_t v30 = v28;
              }
              if (v30 + 0x4000000000000000LL < 0)
              {
                __break(1u);
LABEL_289:
                Swift::Int v3 = _StringGuts._foreignConvertedToSmall()(v3, v5);
                uint64_t v42 = v244;
                goto LABEL_52;
              }

              unint64_t v31 = 2 * v30;
              if (v31 > v19) {
                uint64_t v19 = v31;
              }
              goto LABEL_41;
            }
          }

          else
          {
            if (v19 > 15) {
              goto LABEL_24;
            }
            if ((v5 & 0x2000000000000000LL) == 0) {
              goto LABEL_46;
            }
          }

          swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
          uint64_t v42 = v5;
LABEL_52:
          x1_0 = v251;
          uint64_t v41 = v254;
LABEL_53:
          v43._Swift::UInt64 rawBits = (v41 << 16) | 1;
          v44._Swift::UInt64 rawBits = 1LL;
          v45._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v44,  v43,  v8._countAndFlagsBits,  (unint64_t)v8._object);
          if (v45._rawBits < 0x10000) {
            v45._rawBits |= 3;
          }
          Swift::Int v47 = specialized String.init(_:)(v45, v46, v8._countAndFlagsBits, (unint64_t)v8._object);
          Swift::Int v49 = v48;
          swift_bridgeObjectRelease((uint64_t)v8._object);
          if ((v49 & 0x2000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v49);
            id v27 = a1;
          }

          else
          {
            id v27 = a1;
            if ((v49 & 0x1000000000000000LL) != 0)
            {
              Swift::Int v47 = _StringGuts._foreignConvertedToSmall()(v47, v49);
              v247 = v246;
              swift_bridgeObjectRelease(v49);
              Swift::Int v49 = v247;
            }

            else
            {
              if ((v47 & 0x1000000000000000LL) != 0)
              {
                v241 = (unsigned __int8 *)((v49 & 0xFFFFFFFFFFFFFFFLL) + 32);
                v242 = v47 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                v241 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v47, v49);
              }

              closure #1 in _StringGuts._convertedToSmall()(v241, v242, &v260);
              swift_bridgeObjectRelease(v49);
              Swift::Int v47 = v260;
              Swift::Int v49 = *((void *)&v260 + 1);
            }
          }

          unint64_t v50 = HIBYTE(v42) & 0xF;
          unint64_t v51 = HIBYTE(v49) & 0xF;
          uint64_t v52 = v51 + v50;
          if ((unint64_t)(v51 + v50) <= 0xF)
          {
            if (v51)
            {
              Swift::Int v53 = 0;
              uint64_t v54 = 0LL;
              do
              {
                int64_t v55 = v50 + v54;
                int64_t v56 = v54 + 1;
                if (v54 >= 8) {
                  int64_t v57 = v49;
                }
                else {
                  int64_t v57 = v47;
                }
                char v58 = v57 >> (v53 & 0x38);
                unint64_t v59 = (8 * v50 + v53) & 0x38;
                unint64_t v60 = (-255LL << v59) - 1;
                uint64_t v61 = (unint64_t)v58 << v59;
                unint64_t v62 = v61 | v60 & v42;
                int64_t v63 = v61 | v60 & v3;
                if (v55 < 8) {
                  Swift::Int v3 = v63;
                }
                else {
                  uint64_t v42 = v62;
                }
                v53 += 8;
                uint64_t v54 = v56;
              }

              while (v51 != v56);
            }

            swift_bridgeObjectRelease(v5);
            swift_bridgeObjectRelease((uint64_t)v8._object);
            unint64_t v64 = 0xA000000000000000LL;
            if (!(v3 & 0x8080808080808080LL | v42 & 0x80808080808080LL)) {
              unint64_t v64 = 0xE000000000000000LL;
            }
            char v65 = (void *)(v64 & 0xFF00000000000000LL | (v52 << 56) | v42 & 0xFFFFFFFFFFFFFFLL);
LABEL_88:
            v261._uint64_t countAndFlagsBits = v3;
            v261._uint64_t object = v65;
            goto LABEL_89;
          }

              uint64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
              uint64_t v26 = (v24 & 1) == 0 && v23 >= v15;
              if ((v20 & 0x2000000000000000LL) != 0
                && swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
              {
                id v27 = a1;
                if (v26)
                {
LABEL_42:
                  swift_bridgeObjectRelease_n((uint64_t)v8._object, 4LL);
                  if (((uint64_t)v8._object & 0x1000000000000000LL) != 0)
                  {
                    swift_bridgeObjectRelease((uint64_t)v8._object);
                    _StringGuts._foreignAppendInPlace(_:)( v8._countAndFlagsBits,  (unint64_t)v8._object,  0LL,  v254);
                    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
                    x1_0 = v251;
                  }

                  else if (v12)
                  {
                    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
                    *(void *)&v260 = v8._countAndFlagsBits;
                    *((void *)&v260 + 1) = (uint64_t)v8._object & 0xFFFFFFFFFFFFFFLL;
                    char v32 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  ((unint64_t)v8._object >> 56) & 0xF,  (uint64_t)&v260,  ((unint64_t)v8._object >> 56) & 0xF);
                    _StringGuts.appendInPlace(_:isASCII:)(v32, v33, ((uint64_t)v8._object & 0x4000000000000000LL) != 0);
                    swift_bridgeObjectRelease((uint64_t)v8._object);
                    x1_0 = v251;
                  }

                  else
                  {
                    if ((v8._countAndFlagsBits & 0x1000000000000000LL) != 0)
                    {
                      swift_bridgeObjectRelease((uint64_t)v8._object);
                      uint64_t v78 = (id)(((uint64_t)v8._object & 0xFFFFFFFFFFFFFFFLL) + 32);
                      unint64_t v79 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
                      v80 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
                      x1_0 = v251;
                    }

                    else
                    {
                      uint64_t v78 = _StringObject.sharedUTF8.getter(v8._countAndFlagsBits, (uint64_t)v8._object);
                      v80 = v245;
                      swift_bridgeObjectRelease((uint64_t)v8._object);
                      if (v80 < (v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL)) {
LABEL_192:
                      }
                        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
                      x1_0 = v251;
                      id v27 = a1;
                      unint64_t v79 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
                    }

                    char v81 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v79, (uint64_t)v78, v80);
                    _StringGuts.appendInPlace(_:isASCII:)(v81, v82, v8._countAndFlagsBits < 0);
                    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2LL);
                  }

                  goto LABEL_89;
                }
              }

              else
              {
                id v27 = a1;
                if (v26)
                {
LABEL_41:
                  _StringGuts.grow(_:)(v19);
                  goto LABEL_42;
                }
              }

              BOOL v28 = _StringGuts.nativeCapacity.getter(v3, v5);
              if ((v29 & 1) != 0) {
                uint64_t v30 = 0LL;
              }
              else {
                uint64_t v30 = v28;
              }
              if (v30 + 0x4000000000000000LL < 0)
              {
                __break(1u);
LABEL_289:
                Swift::Int v3 = _StringGuts._foreignConvertedToSmall()(v3, v5);
                uint64_t v42 = v244;
                goto LABEL_52;
              }

              unint64_t v31 = 2 * v30;
              if (v31 > v19) {
                uint64_t v19 = v31;
              }
              goto LABEL_41;
            }
          }

          else
          {
            if (v19 > 15) {
              goto LABEL_24;
            }
            if ((v5 & 0x2000000000000000LL) == 0) {
              goto LABEL_46;
            }
          }

          swift_bridgeObjectRelease_n((uint64_t)v8._object, 5LL);
          uint64_t v42 = v5;
LABEL_52:
          x1_0 = v251;
          uint64_t v41 = v254;
LABEL_53:
          v43._Swift::UInt64 rawBits = (v41 << 16) | 1;
          v44._Swift::UInt64 rawBits = 1LL;
          v45._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v44,  v43,  v8._countAndFlagsBits,  (unint64_t)v8._object);
          if (v45._rawBits < 0x10000) {
            v45._rawBits |= 3;
          }
          Swift::Int v47 = specialized String.init(_:)(v45, v46, v8._countAndFlagsBits, (unint64_t)v8._object);
          Swift::Int v49 = v48;
          swift_bridgeObjectRelease((uint64_t)v8._object);
          if ((v49 & 0x2000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v49);
            id v27 = a1;
          }

          else
          {
            id v27 = a1;
            if ((v49 & 0x1000000000000000LL) != 0)
            {
              Swift::Int v47 = _StringGuts._foreignConvertedToSmall()(v47, v49);
              v247 = v246;
              swift_bridgeObjectRelease(v49);
              Swift::Int v49 = v247;
            }

            else
            {
              if ((v47 & 0x1000000000000000LL) != 0)
              {
                v241 = (unsigned __int8 *)((v49 & 0xFFFFFFFFFFFFFFFLL) + 32);
                v242 = v47 & 0xFFFFFFFFFFFFLL;
              }

              else
              {
                v241 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v47, v49);
              }

              closure #1 in _StringGuts._convertedToSmall()(v241, v242, &v260);
              swift_bridgeObjectRelease(v49);
              Swift::Int v47 = v260;
              Swift::Int v49 = *((void *)&v260 + 1);
            }
          }

          unint64_t v50 = HIBYTE(v42) & 0xF;
          unint64_t v51 = HIBYTE(v49) & 0xF;
          uint64_t v52 = v51 + v50;
          if ((unint64_t)(v51 + v50) <= 0xF)
          {
            if (v51)
            {
              Swift::Int v53 = 0;
              uint64_t v54 = 0LL;
              do
              {
                int64_t v55 = v50 + v54;
                int64_t v56 = v54 + 1;
                if (v54 >= 8) {
                  int64_t v57 = v49;
                }
                else {
                  int64_t v57 = v47;
                }
                char v58 = v57 >> (v53 & 0x38);
                unint64_t v59 = (8 * v50 + v53) & 0x38;
                unint64_t v60 = (-255LL << v59) - 1;
                uint64_t v61 = (unint64_t)v58 << v59;
                unint64_t v62 = v61 | v60 & v42;
                int64_t v63 = v61 | v60 & v3;
                if (v55 < 8) {
                  Swift::Int v3 = v63;
                }
                else {
                  uint64_t v42 = v62;
                }
                v53 += 8;
                uint64_t v54 = v56;
              }

              while (v51 != v56);
            }

            swift_bridgeObjectRelease(v5);
            swift_bridgeObjectRelease((uint64_t)v8._object);
            unint64_t v64 = 0xA000000000000000LL;
            if (!(v3 & 0x8080808080808080LL | v42 & 0x80808080808080LL)) {
              unint64_t v64 = 0xE000000000000000LL;
            }
            char v65 = (void *)(v64 & 0xFF00000000000000LL | (v52 << 56) | v42 & 0xFFFFFFFFFFFFFFLL);
LABEL_88:
            v261._uint64_t countAndFlagsBits = v3;
            v261._uint64_t object = v65;
            goto LABEL_89;
          }

  *uint64_t v4 = v23;
  return result;
}

  v33(v34, a4);
  uint64_t v41 = v36(a4, a6);
LABEL_25:
  unint64_t v67 = v41;
  v31(v21, (uint64_t)v30, a4);
  if (v67 >= 65)
  {
    v33(v21, a4);
    goto LABEL_27;
  }

  Swift::String v76 = v36(a4, a6);
  v33(v21, a4);
  if (v76 == 64 && (v35(a4, a6) & 1) == 0)
  {
LABEL_27:
    unint64_t v68 = v88;
    v31(v88, (uint64_t)v30, a4);
    unint64_t v96 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v69 = v35(a4, a6);
    uint64_t v70 = v36(a4, a6);
    if ((v69 & 1) != 0)
    {
      if (v70 > 64)
      {
        char v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        uint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
        char v75 = &v96;
        goto LABEL_36;
      }
    }

    else if (v70 > 63)
    {
      unint64_t v95 = 0x7FFFFFFFFFFFFFFFLL;
      char v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      uint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
      char v75 = &v95;
LABEL_36:
      uint64_t v78 = v89;
      v73(v75, &type metadata for Int, v74, a4, a6);
      unint64_t v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v78,  v68,  a4);
      v33(v78, a4);
      if ((v79 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_37;
    }

    uint64_t v77 = v89;
    v31(v89, (uint64_t)v68, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    v33(v77, a4);
LABEL_37:
    v33(v68, a4);
  }

  v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
  v33(v30, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v93 + 136))(v91, v80, v92);
}

  v34(v35, a5);
  uint64_t v42 = v37(a5, a7);
LABEL_25:
  unint64_t v68 = v42;
  v32(v22, (uint64_t)v31, a5);
  if (v68 >= 65)
  {
    v34(v22, a5);
    goto LABEL_27;
  }

  uint64_t v77 = v37(a5, a7);
  v34(v22, a5);
  if (v77 == 64 && (v36(a5, a7) & 1) == 0)
  {
LABEL_27:
    uint64_t v69 = v88;
    v32(v88, (uint64_t)v31, a5);
    unint64_t v97 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v70 = v36(a5, a7);
    unint64_t v71 = v37(a5, a7);
    if ((v70 & 1) != 0)
    {
      if (v71 > 64)
      {
        uint64_t v74 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
        char v75 = lazy protocol witness table accessor for type Int and conformance Int(v71, v72, v73);
        Swift::String v76 = &v97;
        goto LABEL_36;
      }
    }

    else if (v71 > 63)
    {
      unint64_t v96 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v74 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
      char v75 = lazy protocol witness table accessor for type Int and conformance Int(v71, v72, v73);
      Swift::String v76 = &v96;
LABEL_36:
      unint64_t v79 = v89;
      v74(v76, &type metadata for Int, v75, a5, a7);
      v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a7 + 32) + 8LL) + 16LL))( v79,  v69,  a5);
      v34(v79, a5);
      if ((v80 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_37;
    }

    uint64_t v78 = v89;
    v32(v89, (uint64_t)v69, a5);
    (*(void (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
    v34(v78, a5);
LABEL_37:
    v34(v69, a5);
  }

  char v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v34(v31, a5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v94 + 144))(v91, v81, v92, v93);
}

    uint64_t v61 = v86;
    partial apply for closure #1 in RangeReplaceableCollection.applying(_:)(v54);
    uint64_t v86 = v61;
    if (v61) {
      return (*(uint64_t (**)(uint64_t, uint64_t *))(v9 + 8))(v54, v8);
    }
    (*(void (**)(char *, uint64_t, uint64_t *))(v9 + 32))(v45, v54, v8);
    if (swift_getEnumCaseMultiPayload((unsigned __int8 *)v45, (uint64_t)v8) == 1)
    {
      char v29 = __OFADD__(v27++, 1LL);
      if (v29) {
        goto LABEL_45;
      }
    }

    else
    {
      char v29 = __OFADD__(v26++, 1LL);
      if (v29)
      {
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        __break(1u);
LABEL_48:
        unint64_t v62 = v45;
LABEL_49:
        swift_unknownObjectRelease(v62);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }
    }

    uint64_t v30 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v28,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    uint64_t v12 = v45;
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(*(void *)(v28 - 8) + 8LL))(&v45[*((int *)v30 + 12)], v28);
  }

        __break(1u);
        goto LABEL_25;
      }

    int64_t v56 = 0LL;
    int64_t v57 = 0LL;
    goto LABEL_60;
  }

  if (v108 <= 0xFFFFFFFFFFFFFF80LL) {
    goto LABEL_24;
  }
  else {
    int64_t v56 = v115 << -(char)v108;
  }
  int64_t v57 = (v119 << -(char)v108) | (v115 >> 1 >> (v108 - 1));
LABEL_60:
  *uint64_t v38 = v56;
  v38[1] = v57;
  return result;
}

    int64_t v56 = 0LL;
    int64_t v57 = 0LL;
    goto LABEL_64;
  }

  if (v108 <= 0xFFFFFFFFFFFFFF80LL) {
    goto LABEL_24;
  }
  else {
    int64_t v57 = v115 >> -(char)v108;
  }
  int64_t v56 = ((2 * v115) << (v108 - 1)) | (v119 >> -(char)v108);
LABEL_64:
  *uint64_t v38 = v56;
  v38[1] = v57;
  return result;
}

      LOBYTE(v55) = 0;
      goto LABEL_64;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    unint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v63(v30, a3);
    if (v64 <= 8) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  uint64_t v39 = v31(a3, a4);
  unint64_t v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      uint64_t v33 = v125;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }

  if (v40 > 64)
  {
    Swift::String v129 = -8LL;
    uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    uint64_t v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    uint64_t v33 = v125;
    if ((v45 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  unint64_t v50 = AssociatedTypeWitness;
  unint64_t v51 = v120;
  uint64_t v52 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  Swift::Int v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))( &qword_18180BE68,  256LL,  v50,  v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
  uint64_t v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    uint64_t v33 = v125;
    if (v49 < -8) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  LOBYTE(v55) = 0;
LABEL_64:
  char *v126 = v55;
  return result;
}

      LOBYTE(v61) = 0;
      goto LABEL_59;
    }

    unint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v71, a3);
    if (v72 <= 8) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      uint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_18;
    }

    Swift::Int v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }

  if (v42 > 64)
  {
    unint64_t v144 = -8LL;
    uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    Swift::Int v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if ((v48 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  int64_t v55 = v137;
  int64_t v56 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v56);
  char v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  unint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
  unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 < -8) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOBYTE(v61) = 0;
  uint64_t v39 = v132;
LABEL_59:
  *(_BYTE *)uint64_t v39 = v61;
  return result;
}

      LOBYTE(v61) = 0;
      goto LABEL_59;
    }

    unint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v71, a3);
    if (v72 <= 8) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      uint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_18;
    }

    Swift::Int v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }

  if (v42 > 64)
  {
    unint64_t v144 = -8LL;
    uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    Swift::Int v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if ((v48 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  int64_t v55 = v137;
  int64_t v56 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v56);
  char v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  unint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
  unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 < -8) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOBYTE(v61) = 0;
  uint64_t v39 = v132;
LABEL_59:
  *(_BYTE *)uint64_t v39 = v61;
  return result;
}

      LOWORD(v55) = 0;
      goto LABEL_64;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    unint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v63(v30, a3);
    if (v64 <= 16) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  uint64_t v39 = v31(a3, a4);
  unint64_t v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      uint64_t v33 = v125;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }

  if (v40 > 64)
  {
    Swift::String v129 = -16LL;
    uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    uint64_t v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    uint64_t v33 = v125;
    if ((v45 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  unint64_t v50 = AssociatedTypeWitness;
  unint64_t v51 = v120;
  uint64_t v52 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  Swift::Int v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))( &qword_18180BE68,  256LL,  v50,  v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
  uint64_t v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    uint64_t v33 = v125;
    if (v49 < -16) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  LOWORD(v55) = 0;
LABEL_64:
  char *v126 = v55;
  return result;
}

      LOWORD(v61) = 0;
      goto LABEL_59;
    }

    unint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v71, a3);
    if (v72 <= 16) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      uint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_18;
    }

    Swift::Int v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }

  if (v42 > 64)
  {
    unint64_t v144 = -16LL;
    uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    Swift::Int v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if ((v48 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  int64_t v55 = v137;
  int64_t v56 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v56);
  char v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  unint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
  unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 < -16) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOWORD(v61) = 0;
  uint64_t v39 = v132;
LABEL_59:
  *(_WORD *)uint64_t v39 = v61;
  return result;
}

      LOWORD(v61) = 0;
      goto LABEL_59;
    }

    unint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v71, a3);
    if (v72 <= 16) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      uint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_18;
    }

    Swift::Int v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }

  if (v42 > 64)
  {
    unint64_t v144 = -16LL;
    uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    Swift::Int v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if ((v48 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  int64_t v55 = v137;
  int64_t v56 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v56);
  char v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  unint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
  unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 < -16) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOWORD(v61) = 0;
  uint64_t v39 = v132;
LABEL_59:
  *(_WORD *)uint64_t v39 = v61;
  return result;
}

      int64_t v55 = 0;
      goto LABEL_64;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    unint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v63(v30, a3);
    if (v64 <= 32) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  uint64_t v39 = v31(a3, a4);
  unint64_t v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      uint64_t v33 = v125;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }

  if (v40 > 64)
  {
    Swift::String v129 = -32LL;
    uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    uint64_t v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    uint64_t v33 = v125;
    if ((v45 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  unint64_t v50 = AssociatedTypeWitness;
  unint64_t v51 = v120;
  uint64_t v52 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  Swift::Int v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))( &qword_18180BE68,  256LL,  v50,  v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
  uint64_t v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    uint64_t v33 = v125;
    if (v49 < -32) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  int64_t v55 = 0;
LABEL_64:
  char *v126 = v55;
  return result;
}

      uint64_t v61 = 0;
      goto LABEL_59;
    }

    unint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v71, a3);
    if (v72 <= 32) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  char v32 = *(unsigned int **)(a4 + 128);
  uint64_t v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      uint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_18;
    }

    Swift::Int v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }

  if (v42 > 64)
  {
    unint64_t v144 = -32LL;
    uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    Swift::Int v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if ((v48 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  int64_t v55 = v137;
  int64_t v56 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v56);
  char v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  unint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
  unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 < -32) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  uint64_t v61 = 0;
  uint64_t v39 = v132;
LABEL_59:
  char *v39 = v61;
  return result;
}

      int64_t v55 = 0;
      goto LABEL_64;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    unint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v63(v30, a3);
    if (v64 <= 32) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  uint64_t v39 = v31(a3, a4);
  unint64_t v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      uint64_t v33 = v125;
      goto LABEL_18;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }

  if (v40 > 64)
  {
    Swift::String v129 = -32LL;
    uint64_t v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    uint64_t v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    uint64_t v33 = v125;
    if ((v45 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  unint64_t v50 = AssociatedTypeWitness;
  unint64_t v51 = v120;
  uint64_t v52 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  Swift::Int v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))( &qword_18180BE68,  256LL,  v50,  v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
  uint64_t v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    Swift::Int v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    uint64_t v33 = v125;
    if (v49 < -32) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  int64_t v55 = 0;
LABEL_64:
  char *v126 = v55;
  return result;
}

      uint64_t v61 = 0;
      goto LABEL_59;
    }

    unint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    uint64_t result = v70(v71, a3);
    if (v72 <= 32) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  char v32 = *(unsigned int **)(a4 + 128);
  uint64_t v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      uint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_18;
    }

    Swift::Int v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }

  if (v42 > 64)
  {
    unint64_t v144 = -32LL;
    uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    Swift::Int v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if ((v48 & 1) != 0) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  int64_t v55 = v137;
  int64_t v56 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  v56);
  char v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  unint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
  unint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    uint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 < -32) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  uint64_t v61 = 0;
  uint64_t v39 = v132;
LABEL_59:
  char *v39 = v61;
  return result;
}

  unint64_t v97 = v246;
  unint64_t v98 = (*(uint64_t (**)(unint64_t *, unint64_t))(v91 + 120))(v9, v91);
  v89(v97, v9);
  unint64_t v99 = *(void (**)(uint64_t))(*(void *)(v74 + 8) + 16LL);
  uint64_t v100 = v250;
  v99(a2);
  char v101 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v96 + 32) + 8LL) + 16LL);
  uint64_t v102 = v251;
  LOBYTE(v97) = v101(v251, v100, a2);
  v95(v102, a2);
  v95(v100, a2);
  else {
    return v98;
  }
}

                uint64_t result = 0LL;
                int64_t v56 = 0LL;
                goto LABEL_64;
              }
            }

            else
            {
              v64(v100, a3);
              char v101 = v129;
            }

            v66(v71, (uint64_t)v67, a3);
            v131 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v102 = v101(a3, a4);
            int64_t v103 = v116(a3, a4);
            if ((v102 & 1) != 0)
            {
              if (v103 > 64)
              {
                uint64_t v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
                uint64_t v108 = &v131;
                goto LABEL_58;
              }
            }

            else if (v103 > 63)
            {
              v130 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              uint64_t v108 = &v130;
LABEL_58:
              v106(v108, &type metadata for Int, v107, a3, a4);
              v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v71,  a3);
              v64(v29, a3);
              if ((v111 & 1) != 0) {
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
              }
              goto LABEL_59;
            }

            v66(v29, (uint64_t)v71, a3);
            (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v64(v29, a3);
LABEL_59:
            v64(v71, a3);
            goto LABEL_60;
          }

          uint64_t v77 = v29;
          uint64_t v72 = v118;
          goto LABEL_40;
        }

        if (v79 <= 64)
        {
          int64_t v90 = AssociatedTypeWitness;
          int64_t v89 = (void (**)(char *, uint64_t, const char *))v121;
          char v91 = swift_getAssociatedConformanceWitness( (uint64_t)v121,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v92 = v119;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v91 + 8))( &qword_18180BE68,  256LL,  v90,  v91);
          v89[3](v92, a3, (const char *)v89);
          unint64_t v93 = v118;
          LOBYTE(v89) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                           + 16LL))( v118,  v29,  a3);
          v64(v29, a3);
          uint64_t v94 = v117;
          v66(v117, (uint64_t)v93, a3);
          if ((v89 & 1) != 0)
          {
            v64(v94, a3);
            goto LABEL_69;
          }

          unint64_t v95 = v131;
          unint64_t v96 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v94, a3);
          unint64_t v97 = v96 < v95;
          unint64_t v67 = v127;
          uint64_t v72 = v118;
          if (v97) {
            goto LABEL_69;
          }
LABEL_44:
          uint64_t v114 = v72;
          goto LABEL_45;
        }

        uint64_t v82 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        v82(&v131, &type metadata for Int, v83, a3, a4);
        uint64_t v72 = v118;
        unint64_t v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v118,  v29,  a3);
      }

      uint64_t v87 = v84;
      v64(v29, a3);
      if ((v87 & 1) != 0) {
        goto LABEL_69;
      }
      goto LABEL_44;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    char v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v64 = *(void (**)(char *, uint64_t))(v12 + 8);
    v64(v29, a3);
    if (v65 > 128) {
      goto LABEL_24;
    }
    goto LABEL_25;
  }

  v54(v15, a3);
  uint64_t result = 0LL;
  int64_t v56 = 0LL;
  a5 = v128;
LABEL_64:
  *a5 = v56;
  a5[1] = result;
  return result;
}

                uint64_t result = 0LL;
                int64_t v56 = 0LL;
                goto LABEL_64;
              }
            }

            else
            {
              v64(v100, a3);
              char v101 = v129;
            }

            v66(v71, (uint64_t)v67, a3);
            v131 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v102 = v101(a3, a4);
            int64_t v103 = v116(a3, a4);
            if ((v102 & 1) != 0)
            {
              if (v103 > 64)
              {
                uint64_t v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
                uint64_t v108 = &v131;
                goto LABEL_58;
              }
            }

            else if (v103 > 63)
            {
              v130 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              uint64_t v108 = &v130;
LABEL_58:
              v106(v108, &type metadata for Int, v107, a3, a4);
              v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v71,  a3);
              v64(v29, a3);
              if ((v111 & 1) != 0) {
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
              }
              goto LABEL_59;
            }

            v66(v29, (uint64_t)v71, a3);
            (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v64(v29, a3);
LABEL_59:
            v64(v71, a3);
            goto LABEL_60;
          }

          uint64_t v77 = v29;
          uint64_t v72 = v118;
          goto LABEL_40;
        }

        if (v79 <= 64)
        {
          int64_t v90 = AssociatedTypeWitness;
          int64_t v89 = (void (**)(char *, uint64_t, const char *))v121;
          char v91 = swift_getAssociatedConformanceWitness( (uint64_t)v121,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v92 = v119;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v91 + 8))( &qword_18180BE68,  256LL,  v90,  v91);
          v89[3](v92, a3, (const char *)v89);
          unint64_t v93 = v118;
          LOBYTE(v89) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                           + 16LL))( v118,  v29,  a3);
          v64(v29, a3);
          uint64_t v94 = v117;
          v66(v117, (uint64_t)v93, a3);
          if ((v89 & 1) != 0)
          {
            v64(v94, a3);
            goto LABEL_69;
          }

          unint64_t v95 = v131;
          unint64_t v96 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v94, a3);
          unint64_t v97 = v96 < v95;
          unint64_t v67 = v127;
          uint64_t v72 = v118;
          if (v97) {
            goto LABEL_69;
          }
LABEL_44:
          uint64_t v114 = v72;
          goto LABEL_45;
        }

        uint64_t v82 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        v82(&v131, &type metadata for Int, v83, a3, a4);
        uint64_t v72 = v118;
        unint64_t v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v118,  v29,  a3);
      }

      uint64_t v87 = v84;
      v64(v29, a3);
      if ((v87 & 1) != 0) {
        goto LABEL_69;
      }
      goto LABEL_44;
    }

    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    char v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v64 = *(void (**)(char *, uint64_t))(v12 + 8);
    v64(v29, a3);
    if (v65 > 128) {
      goto LABEL_24;
    }
    goto LABEL_25;
  }

  v54(v15, a3);
  uint64_t result = 0LL;
  int64_t v56 = 0LL;
  a5 = v128;
LABEL_64:
  *a5 = v56;
  a5[1] = result;
  return result;
}

              LOBYTE(v13) = 0;
              goto LABEL_25;
            }

            LOBYTE(v13) = 3;
          }
        }
      }
    }

              LOBYTE(v15) = 0;
              goto LABEL_25;
            }

            LOBYTE(v15) = 3;
          }
        }
      }
    }

  if (v5 < 2) {
    return 0LL;
  }
  int64_t v14 = (*(uint64_t (**)(void))(v4 + 48))();
  if (v14 >= 2) {
    return v14 - 1;
  }
  else {
    return 0LL;
  }
}

  if (v7 <= 7)
  {
LABEL_25:
    int64_t v14 = &a1[v5];
    switch((1 << ((v6 >> 62) - 1)))
    {
      case 1u:
        __objc2_class *v14 = v11;
        break;
      case 2u:
        *(_WORD *)int64_t v14 = v11;
        break;
      case 3u:
        *(_WORD *)int64_t v14 = v11;
        v14[2] = BYTE2(v11);
        break;
      case 4u:
        *(_DWORD *)int64_t v14 = v11;
        break;
      default:
        *(_DWORD *)int64_t v14 = v11;
        bzero(v14 + 4, (1 << ((v6 >> 62) - 1)) - 4LL);
        break;
    }
  }

    uint64_t v10 = 1;
    return v10 | (v10 << 8);
  }

  uint64_t v10 = 0;
  return v10 | (v10 << 8);
}

    uint64_t v11 = (int **)(a2 + 8);
LABEL_25:
    uint64_t v10 = *v11;
    goto LABEL_26;
  }

  if ((_DWORD)v6 == 515 || (_DWORD)v6 == 516) {
    goto LABEL_24;
  }
LABEL_26:
  if (v8 != v10)
  {
    validationLog(1, "Descriptors do not match");
    goto LABEL_30;
  }

  uint64_t v12 = *v8;
  if ((*v8 & 0x80) != 0)
  {
    uint64_t v18 = *(void *)(a1 - 8);
    uint64_t v19 = *(void *)(a2 - 8);
    if (*(void *)v18 == *(void *)v19
      && *(void *)(v18 + 8) == *(void *)(v19 + 8)
      && *(void *)(v18 + 16) == *(void *)(v19 + 16)
      && *(void *)(v18 + 24) == *(void *)(v19 + 24)
      && *(void *)(v18 + 32) == *(void *)(v19 + 32)
      && *(void *)(v18 + 40) == *(void *)(v19 + 40)
      && *(void *)(v18 + 48) == *(void *)(v19 + 48)
      && *(void *)(v18 + 56) == *(void *)(v19 + 56)
      && *(void *)(v18 + 64) == *(void *)(v19 + 64)
      && *(void *)(v18 + 72) == *(void *)(v19 + 72)
      && (uint64_t v20 = *(_DWORD *)(v18 + 80), v20 == *(_DWORD *)(v19 + 80))
      && *(_DWORD *)(v18 + 84) == *(_DWORD *)(v19 + 84)
      && ((v20 & 0x200000) == 0
       || *(void *)(v18 + 88) == *(void *)(v19 + 88)
       && *(void *)(v18 + 96) == *(void *)(v19 + 96)
       && *(void *)(v18 + 104) == *(void *)(v19 + 104)))
    {
      BOOL v21 = 1;
    }

    else
    {
      validationLog(1, "VWTs do not match");
      BOOL v21 = 0;
      uint64_t v12 = *v8;
    }

    uint64_t v22 = v12 & 0x1F;
    if (v22 == 16)
    {
      uint64_t v23 = v8 + 11;
      if ((v12 & 0x20000000) != 0)
      {
        ResilientImmediateMembersOffset = swift::getResilientImmediateMembersOffset((uint64_t)v8, a2, a3, a4);
      }

      else
      {
        if ((v12 & 0x10000000) != 0)
        {
          uint64_t v25 = 0;
          uint64_t v26 = v8 + 6;
        }

        else
        {
          uint64_t v25 = v8[7];
          uint64_t v26 = v8 + 8;
        }

        ResilientImmediateMembersOffset = v25 - *v26;
      }
    }

    else
    {
      if (v22 != 17 && v22 != 18) {
LABEL_130:
      }
        abort();
      uint64_t v23 = v8 + 7;
      ResilientImmediateMembersOffset = 2;
    }

    id v27 = *((unsigned __int16 *)v23 + 6);
    BOOL v28 = 8 * (v27 + ResilientImmediateMembersOffset);
    char v29 = *(void *)a1;
    if (*(void *)a1 > 0x7FFuLL) {
      LODWORD(v29) = 0;
    }
    if ((_DWORD)v29 == 513)
    {
      char v32 = 0LL;
      uint64_t v33 = *(void *)(a1 + 8);
      uint64_t v34 = *(int *)(v33 + 32);
      unint64_t v35 = v34 + v33 + 32;
      if (!(_DWORD)v34) {
        unint64_t v35 = 0LL;
      }
      if ((*(_BYTE *)(v35 + 8) & 2) != 0)
      {
        if (*(_BYTE *)(v33 + 23)) {
          char v36 = *(unsigned __int16 *)(v33 + 40) + 1LL;
        }
        else {
          char v36 = *(unsigned __int16 *)(v33 + 40);
        }
        char v32 = a1 + 8 * v36 + 16;
      }

      unint64_t v37 = 0LL;
      if (v32) {
        uint64_t v30 = v32 - a1 + 8;
      }
      else {
        uint64_t v30 = 8 * (v27 + ResilientImmediateMembersOffset);
      }
      uint64_t v38 = *(void *)(a2 + 8);
      uint64_t v39 = *(int *)(v38 + 32);
      uint64_t v40 = v39 + v38 + 32;
      if (!(_DWORD)v39) {
        uint64_t v40 = 0LL;
      }
      if ((*(_BYTE *)(v40 + 8) & 2) != 0)
      {
        uint64_t v41 = *(unsigned __int16 *)(v38 + 40);
        if (*(_BYTE *)(v38 + 23)) {
          ++v41;
        }
        unint64_t v37 = a2 + 8 * v41 + 16;
      }

      if (v37) {
        unint64_t v31 = v37 - a2 + 8;
      }
      else {
        unint64_t v31 = 8 * (v27 + ResilientImmediateMembersOffset);
      }
    }

    else if ((_DWORD)v29 == 512)
    {
      uint64_t v30 = swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_0::operator()( a1,  v28);
      unint64_t v31 = swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_0::operator()( a2,  v28);
    }

    else
    {
      if ((_DWORD)v29)
      {
        unint64_t v31 = 8 * (v27 + ResilientImmediateMembersOffset);
        goto LABEL_102;
      }

      uint64_t v30 = (*(_DWORD *)(a1 + 56) - *(_DWORD *)(a1 + 60)) >> 3;
      unint64_t v31 = (*(_DWORD *)(a2 + 56) - *(_DWORD *)(a2 + 60)) >> 3;
    }

    if (v30 != v31)
    {
      validationLog(1, "Sizes do not match");
      BOOL v21 = 0;
      LODWORD(v27) = *((unsigned __int16 *)v23 + 6);
      unint64_t v31 = v30;
    }

    id v27 = *(void *)(a1 + 16);
    if ((_DWORD)v5)
    {
      BOOL v28 = 0;
      char v29 = 0;
      uint64_t v30 = v4;
      do
      {
        if (v29 >= v14
          || *(_WORD *)(v27 + 8LL * v29)
          || (unint64_t v31 = v27 + 8LL * v29, v30 != *(unsigned __int16 *)(v31 + 2)))
        {
          if (v11[v30] != v12[v30]) {
            return 0LL;
          }
        }

        else
        {
          char v32 = v11[*(unsigned __int16 *)(v31 + 4)];
          if (v32)
          {
            uint64_t v33 = (void *)(v11[v30] & 0xFFFFFFFFFFFFFFFELL);
            uint64_t v34 = (void *)(v12[v30] & 0xFFFFFFFFFFFFFFFELL);
            if (*v33 != *v34) {
              return 0LL;
            }
            unint64_t v35 = 1LL;
            do
            {
              char v36 = v35;
              if (v32 == v35) {
                break;
              }
              unint64_t v37 = v33[v35];
              uint64_t v38 = v34[v35++];
            }

            while (v37 == v38);
            if (v36 < v32) {
              return 0LL;
            }
          }

          ++v29;
        }

        ++v30;
        ++v28;
      }

      while (v28 != (_DWORD)v5);
      LODWORD(v4) = v5 + v4;
    }

    else
    {
      char v29 = 0;
    }

    if ((_DWORD)v6)
    {
      uint64_t v39 = 0;
      uint64_t v40 = v29;
      Swift::Int v49 = *(void *)(a1 + 16);
      while (1)
      {
        if (v40 < *(unsigned __int16 *)(a1 + 12)
          && *(_WORD *)(v27 + 8LL * v40) == 1
          && (uint64_t v41 = v27 + 8LL * v40, (_DWORD)v4 == *(unsigned __int16 *)(v41 + 2)))
        {
          uint64_t v42 = v11[*(unsigned __int16 *)(v41 + 4)];
          if (v42)
          {
            uint64_t v43 = v4;
            uint64_t v44 = (uint64_t **)(v11[v43] & 0xFFFFFFFFFFFFFFFELL);
            uint64_t v45 = (uint64_t **)(v12[v43] & 0xFFFFFFFFFFFFFFFELL);
            uint64_t result = swift::MetadataCacheKey::areWitnessTablesEqual(*v44, *v45);
            if (!result) {
              return result;
            }
            unint64_t v46 = 1LL;
            do
            {
              Swift::Int v47 = v46;
              if (v42 == v46) {
                break;
              }
              uint64_t v48 = swift::MetadataCacheKey::areWitnessTablesEqual(v44[v46], v45[v46]);
              unint64_t v46 = v47 + 1;
            }

            while (v48);
            if (v47 < v42) {
              return 0LL;
            }
            ++v40;
            id v27 = v49;
          }

          else
          {
            ++v40;
          }
        }

        else
        {
          uint64_t result = swift::MetadataCacheKey::areWitnessTablesEqual( (uint64_t *)v11[v4],  (uint64_t *)v12[v4]);
          if (!result) {
            return result;
          }
        }

        LODWORD(v4) = v4 + 1;
        ++v39;
        uint64_t result = 1LL;
      }
    }

    return 1LL;
  }

  return result;
}

    *(_BYTE *)a3 = v21;
    uint64_t v22 = (uint64_t *)(v20 & 0xFFFFFFFFFFFFFFF0LL);
    if ((v20 & 8) != 0 && v22)
    {
      uint64_t v23 = *(void *)((v20 & 0xFFFFFFFFFFFFFFF0LL) + 0x18);
      uint64_t v19 = *(void *)((v20 & 0xFFFFFFFFFFFFFFF0LL) + 0x20);
    }

    else
    {
      uint64_t v23 = 0LL;
      if (v22)
      {
        if ((v20 & 8) == 0)
        {
          uint64_t v23 = *v22;
          uint64_t v19 = *(void *)((v20 & 0xFFFFFFFFFFFFFFF0LL) + 8);
        }
      }
    }

    *(void *)(a3 + 8) = v23;
    *(void *)(a3 + 16) = v19;
    goto LABEL_41;
  }

  if (!v16)
  {
    if (v18 > 3) {
      goto LABEL_36;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&unk_18C476AF0);
    uint64_t v20 = *v13;
    BOOL v21 = *v13 & 7;
    goto LABEL_24;
  }

  if (v16 != 1) {
    goto LABEL_44;
  }
  if (v18 > 2)
  {
LABEL_36:
    *(_BYTE *)a3 = v18;
    *(void *)(a3 + 8) = 0LL;
    return;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&unk_18C476AF0);
  uint64_t v20 = *v13;
  BOOL v21 = *v13 & 7;
LABEL_34:
  *(_BYTE *)a3 = v21;
  *(void *)(a3 + 8) = 0LL;
LABEL_41:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476AF0);
}

    uint64_t v8 = 0LL;
    goto LABEL_42;
  }

  uint64_t v8 = 0LL;
  if (v7 != 2) {
    goto LABEL_42;
  }
  uint64_t v9 = *(swift::Demangle::__runtime::Node **)(FunctionTypeFromMethod + 8);
  if (!v9) {
    goto LABEL_24;
  }
LABEL_11:
  uint64_t v34 = 1;
  unint64_t v35 = a3;
  char v36 = a4;
  unint64_t v37 = v39;
  uint64_t v38 = 0x800000000LL;
  v39[32] = 0LL;
  v24[0] = off_189B8DE60;
  v24[1] = &v34;
  v24[3] = v24;
  v23[0] = off_189B8DEA8;
  v23[1] = &v34;
  v23[3] = v23;
  uint64_t v25 = v40;
  v26[0] = off_189B8DE60;
  id v27 = v26;
  v28[0] = off_189B8DEA8;
  v26[1] = &v34;
  char v29 = v28;
  v28[1] = &v34;
  uint64_t v30 = 0;
  char v32 = 0LL;
  uint64_t v33 = 0LL;
  __p = 0LL;
  uint64_t v11 = *((unsigned __int8 *)v9 + 18);
  uint64_t v22 = (uint64_t *)&v25;
  if ((v11 - 1) < 2)
  {
LABEL_15:
    uint64_t v12 = *(swift::Demangle::__runtime::Node **)v9;
    goto LABEL_16;
  }

  uint64_t v12 = 0LL;
  if (v11 != 5) {
    goto LABEL_16;
  }
  if (*((_DWORD *)v9 + 2))
  {
    uint64_t v9 = *(swift::Demangle::__runtime::Node **)v9;
    goto LABEL_15;
  }

  uint64_t v12 = 0LL;
LABEL_16:
  if (v82 == 1)
  {
    int64_t v14 = v81(v80, 0LL, 0LL);
    v81(v80, 1LL, v14);
    uint64_t v8 = 0LL;
    if (v82 != 1) {
      goto LABEL_28;
    }
    v81(v80, 3LL, 0LL);
    goto LABEL_27;
  }

  if (v82)
  {
LABEL_27:
    uint64_t v8 = 0LL;
    goto LABEL_28;
  }

  if ((v80 & 1) != 0 || v80 == 0) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = v80;
  }
LABEL_28:
  if (__p)
  {
    char v32 = __p;
    operator delete(__p);
  }

  uint64_t v15 = v29;
  if (v29 == v28)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = v28;
  }

  else
  {
    if (!v29) {
      goto LABEL_35;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_35:
  uint64_t v17 = v27;
  if (v27 == v26)
  {
    uint64_t v18 = 4LL;
    uint64_t v17 = v26;
  }

  else
  {
    if (!v27) {
      goto LABEL_40;
    }
    uint64_t v18 = 5LL;
  }

  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_40:
  if (v37 != v39) {
    free(v37);
  }
LABEL_42:
  v40[0] = off_189B8E500;
  uint64_t v19 = v78;
  if (v78 == v77)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = v77;
  }

  else
  {
    if (!v78) {
      goto LABEL_47;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_47:
  v40[0] = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v41);
  if (v42) {
    *(_BYTE *)(v42 + 48) = 0;
  }
  return v8;
}

  v15[0] = off_189B8E500;
  uint64_t v10 = v53;
  if (v53 == v52)
  {
    uint64_t v11 = 4LL;
    uint64_t v10 = v52;
  }

  else
  {
    if (!v53) {
      goto LABEL_29;
    }
    uint64_t v11 = 5LL;
  }

  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_29:
  v15[0] = off_189B8E4D8;
  swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v16);
  if (v17) {
    *(_BYTE *)(v17 + 48) = 0;
  }
  return v7 | v6;
}

  uint64_t v26 = &a5[v6];
  id v27 = *(unsigned int *)(v6 + 4);
  if (!*(_DWORD *)(v6 + 4)) {
    goto LABEL_49;
  }
LABEL_26:
  BOOL v28 = (int *)(v6 + 8);
  char v29 = v6 + 8 + 8 * v27;
  uint64_t v30 = qword_18C486E30;
  while (2)
  {
    if (v30 != -1) {
    unint64_t v35 = *v28;
    }
    char v36 = (void *)((char *)v28 + (v35 & 0xFFFFFFFFFFFFFFFELL));
    if ((v35 & 1) != 0) {
      char v36 = (void *)*v36;
    }
    unint64_t v31 = v28[1];
    uint64_t v42 = v36;
    if (dword_18C486E28)
    {
      char v32 = (dword_18C486E28 - 1) & ((v36 >> 4) ^ (v36 >> 9));
      uint64_t v33 = (uint64_t *)(opaqueTypeMappings + 16LL * v32);
      uint64_t v34 = *v33;
      if ((void *)*v33 == v36)
      {
        uint64_t v30 = -1LL;
        goto LABEL_30;
      }

      uint64_t v38 = 0LL;
      uint64_t v39 = 1;
      while (v34 != -4096)
      {
        if (v38) {
          uint64_t v40 = 0;
        }
        else {
          uint64_t v40 = v34 == -8192;
        }
        if (v40) {
          uint64_t v38 = v33;
        }
        uint64_t v41 = v32 + v39++;
        char v32 = v41 & (dword_18C486E28 - 1);
        uint64_t v33 = (uint64_t *)(opaqueTypeMappings + 16LL * v32);
        uint64_t v34 = *v33;
        uint64_t v30 = -1LL;
        if ((void *)*v33 == v36) {
          goto LABEL_30;
        }
      }

      if (v38) {
        unint64_t v37 = v38;
      }
      else {
        unint64_t v37 = v33;
      }
    }

    else
    {
      unint64_t v37 = 0LL;
    }

    uint64_t v33 = __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*,swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::DenseMapInfo<swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*>,__swift::__runtime::llvm::detail::DenseMapPair<swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*,swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*>>,swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*,swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*,__swift::__runtime::llvm::DenseMapInfo<swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*>,__swift::__runtime::llvm::detail::DenseMapPair<swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*,swift::TargetOpaqueTypeDescriptor<swift::InProcess> const*>>::InsertIntoBucket<swift::TargetOpaqueTypeDescriptor<swift::InProcess> const* const&>( (uint64_t)&opaqueTypeMappings,  v37,  (uint64_t *)&v42);
    uint64_t v30 = qword_18C486E30;
LABEL_30:
    v33[1] = (uint64_t)v28 + v31 + 4;
    v28 += 2;
    break;
  }

  if (!v11)
  {
    if (v19) {
      uint64_t v38 = (char *)v48;
    }
    else {
      uint64_t v38 = 0LL;
    }
    goto LABEL_30;
  }

  if ((v11 & 1) == 0)
  {
    unint64_t v37 = v12 << 38;
    v12 |= 0x10000000uLL;
    uint64_t v38 = (char *)((unint64_t)v48 & (v37 >> 63));
LABEL_30:
    if ((a8 & 1) != 0) {
      swift::fatalError(0LL, "Expected metadata but got a metadata pack\n", (const char *)a3, v38);
    }
    ExtendedFunctionTypeMetadata = swift_getExtendedFunctionTypeMetadata( v12,  a6,  (unint64_t)v51,  (unint64_t)v38,  a3,  v11,  a5,  a8);
    *(_WORD *)(a9 + 16) = 0;
    *(void *)a9 = ExtendedFunctionTypeMetadata;
    if (!ExtendedFunctionTypeMetadata)
    {
      *(void *)a9 = "unknown error";
      *(void *)(a9 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
      *(_WORD *)(a9 + 16) = 1;
    }

    goto LABEL_34;
  }

  *(_WORD *)(a9 + 16) = 1;
  *(void *)(a9 + 8) = _ZZN5swift15TypeLookupErrorC1IZNS_L19TypeLookupErrorImplIJEEES0_PKcDpT_EUlvE_EERKT_ENUlPvNS0_7CommandESB_E_8__invokeESB_SC_SB_;
  uint64_t v40 = operator new(8uLL);
  *uint64_t v40 = "Tried to build a function type where the global actor type is a pack";
  *(void *)a9 = v40;
LABEL_34:
  if (v48 != v15) {
    free(v48);
  }
  if (v51 != v53) {
    free(v51);
  }
}

      *(_BYTE *)a3 = 0;
      *(_BYTE *)(a3 + 16) = 0;
      return;
    }
  }

  else if ((v6 - 512) >= 3)
  {
    if ((_DWORD)v6) {
      goto LABEL_18;
    }
    if ((*(_BYTE *)(a1 + 32) & 2) == 0) {
      goto LABEL_24;
    }
    uint64_t v7 = *(unsigned int **)(a1 + 64);
    if (!v7) {
      goto LABEL_18;
    }
    goto LABEL_12;
  }

  uint64_t v7 = *(unsigned int **)(a1 + 8);
  if (!v7) {
    goto LABEL_18;
  }
LABEL_12:
  if ((*(_BYTE *)v7 & 0x20) == 0) {
    goto LABEL_24;
  }
  InvertedProtocols = (unsigned __int16 *)swift::TargetContextDescriptor<swift::InProcess>::getInvertedProtocols(v7);
  if (!InvertedProtocols)
  {
    uint64_t v17 = operator new(8uLL);
    *(void *)uint64_t v17 = "unable to find suppressed protocols";
    uint64_t v18 = _ZZN5swift15TypeLookupErrorC1IZNS_L19TypeLookupErrorImplIJEEES0_PKcDpT_EUlvE_EERKT_ENUlPvNS0_7CommandESB_E_8__invokeESB_SC_SB__0;
LABEL_53:
    *(void *)a3 = v17;
    *(void *)(a3 + 8) = v18;
    *(_BYTE *)(a3 + 16) = 1;
    return;
  }

  uint64_t v12 = *InvertedProtocols & ~a2;
  if (!v12) {
    goto LABEL_24;
  }
  if ((*v7 & 0x80) == 0) {
    goto LABEL_51;
  }
  switch(*v7 & 0x1F)
  {
    case 1u:
      id v13 = (unsigned __int16 *)(v7 + 2);
      break;
    case 2u:
    case 4u:
      id v13 = (unsigned __int16 *)(v7 + 1);
      break;
    case 0x10u:
      id v13 = (unsigned __int16 *)(v7 + 12);
      break;
    case 0x11u:
    case 0x12u:
      id v13 = (unsigned __int16 *)(v7 + 8);
      break;
    default:
      goto LABEL_51;
  }

  uint64_t v34 = v13[5];
  if ((v34 & 2) == 0)
  {
LABEL_51:
    uint64_t v17 = operator new(0x10uLL);
    *(void *)uint64_t v17 = "type missing invertible conformances %x";
    v17[4] = v12;
LABEL_52:
    uint64_t v18 = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<unsigned short>(char const*,unsigned short)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<unsigned short>(char const*,unsigned short)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
    goto LABEL_53;
  }

  unint64_t v67 = v13 + 6;
  unint64_t v35 = (unsigned __int16 *)((((unint64_t)v13 + v13[2] + 15) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v13[3]);
  if ((v34 & 1) != 0) {
    char v36 = *v35;
  }
  else {
    char v36 = 0LL;
  }
  unint64_t v37 = v35[4 * v36 + 2 * (v34 & 1)] ^ 0xFFFF;
  uint64_t v38 = v12 & v37;
  if ((v12 & v37) != 0)
  {
    uint64_t v17 = operator new(0x10uLL);
    *(void *)uint64_t v17 = "type missing invertible conformances %x";
    v17[4] = v38;
    goto LABEL_52;
  }

  uint64_t v39 = 0;
  if ((v12 & 1) == 0)
  {
    do
      ++v39;
    while (((v12 >> v39) & 1) == 0);
  }

  if ((v34 & 2) != 0) {
    goto LABEL_63;
  }
LABEL_107:
  int64_t v56 = 0LL;
  int64_t v55 = 0LL;
  while (1)
  {
    Swift::String v76 = 0;
    int64_t v57 = *(void *)a1;
    if (*(void *)a1 > 0x7FFuLL) {
      LODWORD(v57) = 0;
    }
    char v58 = (uint64_t *)(a1 + 8);
    else {
      unint64_t v59 = 0LL;
    }
    uint64_t v77 = v59;
    GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a1, v9, v10, v11);
    unint64_t v79 = v81;
    v80 = 0x800000000LL;
    v81[32] = 0LL;
    v74[0] = &v75;
    v74[1] = (void *)0x100000000LL;
    unint64_t v60 = v13[2];
    v72[0] = off_189B8E0F0;
    v72[1] = &v76;
    char v73 = v72;
    v70[0] = off_189B8E138;
    v70[1] = &v76;
    unint64_t v71 = v70;
    v68[0] = off_189B8E180;
    v68[1] = &v76;
    uint64_t v69 = v68;
    swift::_checkGenericRequirements((void *)a3, v67, v60, v55, v56, v74, v72, v70, v68);
    uint64_t v61 = v69;
    if (v69 == v68)
    {
      uint64_t v61 = v68;
      unint64_t v62 = 4LL;
    }

    else
    {
      if (!v69) {
        goto LABEL_89;
      }
      unint64_t v62 = 5LL;
    }

    (*(void (**)(void))(*v61 + 8 * v62))();
LABEL_89:
    int64_t v63 = v71;
    if (v71 == v70)
    {
      int64_t v63 = v70;
      unint64_t v64 = 4LL;
    }

    else
    {
      if (!v71) {
        goto LABEL_94;
      }
      unint64_t v64 = 5LL;
    }

    (*(void (**)(void))(*v63 + 8 * v64))();
LABEL_94:
    char v65 = v73;
    if (v73 == v72)
    {
      char v65 = v72;
      unint64_t v66 = 4LL;
    }

    else
    {
      if (!v73) {
        goto LABEL_99;
      }
      unint64_t v66 = 5LL;
    }

    (*(void (**)(void))(*v65 + 8 * v66))();
LABEL_99:
    if (*(_BYTE *)(a3 + 16)) {
      break;
    }
    if (v74[0] != &v75) {
      free(v74[0]);
    }
    if (v79 != v81) {
      free(v79);
    }
    v12 &= ~(1 << v39);
    if (!v12) {
      goto LABEL_24;
    }
    do
      ++v39;
    while (((v12 >> v39) & 1) == 0);
    uint64_t v34 = v13[5];
    if ((v34 & 2) == 0) {
      goto LABEL_107;
    }
LABEL_63:
    uint64_t v40 = (unsigned __int16 *)((((unint64_t)v67 + v13[2] + 3) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v13[3]);
    if ((v34 & 1) != 0) {
      uint64_t v41 = *v40;
    }
    else {
      uint64_t v41 = 0LL;
    }
    uint64_t v42 = v34 & 1;
    uint64_t v43 = &v40[2 * (v34 & 1)];
    uint64_t v44 = v43[4 * v41];
    if (((v44 >> v39) & 1) == 0) {
      goto LABEL_107;
    }
    uint64_t v45 = 0;
    unint64_t v46 = v39;
    if (v39)
    {
      do
      {
        v45 += v44 & 1;
        v44 >>= 1;
        --v46;
      }

      while (v46);
    }

    Swift::Int v47 = (((unint64_t)v67 + v13[2] + 3) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v13[3];
    if ((v34 & 1) != 0) {
      Swift::Int v47 = (unint64_t)&v43[4 * *v40];
    }
    uint64_t v48 = (v34 >> 1) & 1;
    Swift::Int v49 = v47 + 2LL * v48;
    if (v45)
    {
      unint64_t v50 = *(unsigned __int16 *)(v49 + 2LL * (v45 - 1));
      if (!v42) {
        goto LABEL_73;
      }
    }

    else
    {
      unint64_t v50 = 0LL;
      if (!v42)
      {
LABEL_73:
        unint64_t v51 = 0LL;
        uint64_t v52 = 0LL;
        Swift::Int v53 = (((unint64_t)v67 + v13[2] + 3) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v13[3];
        goto LABEL_76;
      }
    }

    uint64_t v52 = *v40;
    Swift::Int v53 = (unint64_t)&v43[4 * v52];
    unint64_t v51 = 1LL;
LABEL_76:
    uint64_t v54 = (uint8x8_t)vcnt_s8((int8x8_t)v40[4 * v52 + 2 * v51]);
    v54.i16[0] = vaddlv_u8(v54);
    int64_t v55 = ((v53 + 2 * v48 + 2LL * v54.u32[0] + 3) & 0xFFFFFFFFFFFFFFFCLL) + 12LL * v50;
    int64_t v56 = *(unsigned __int16 *)(v49 + 2LL * v45) - v50;
  }

  if (v74[0] != &v75) {
    free(v74[0]);
  }
  if (v79 != v81) {
    free(v79);
  }
}

    if (*((_DWORD *)a2 + 2) != 1) {
      goto LABEL_26;
    }
  }

  uint64_t v15 = "Ll";
LABEL_27:
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(v14, v15, 2uLL, *((void **)this + 1593));
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

    uint64_t v15 = 321;
    int64_t v14 = 10;
    goto LABEL_25;
  }

      uint64_t result = 0LL;
      *a1 = v8 + 1;
      a1[1] = __n;
      a1[2] = 1LL;
      *((_BYTE *)a1 + 24) = v5;
      return result;
    }
  }

  if ((a5 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  *a1 = v8;
  a1[2] = 1LL;
  uint64_t v25 = v8 - 1;
  *(_DWORD *)(a2 + 12736) = v8 - 1;
  uint64_t v26 = v21[v22 - 1] + 32;
  id v27 = *(unsigned int *)(a2 + 12740);
  if ((int)v8 - 1 >= v27)
  {
    BOOL v28 = *(void **)(a2 + 12744);
    char v29 = (char *)v28[1];
    if (&v15[v27] == v29)
    {
      char v32 = (unint64_t)&v15[v27 + 1];
      uint64_t v30 = v28[2];
      if (v32 <= v30)
      {
        v28[1] = v32;
        uint64_t v41 = 1;
LABEL_43:
        *(_DWORD *)(a2 + 12740) = v27 + v41;
        goto LABEL_44;
      }
    }

    else
    {
      uint64_t v30 = v28[2];
    }

    uint64_t v44 = v26;
    LODWORD(v33) = 2 * v27;
    else {
      uint64_t v33 = v33;
    }
    uint64_t v42 = v33;
    uint64_t v34 = v33 + v27;
    if (!v29 || (unint64_t)&v29[v34] > v30)
    {
      unint64_t v35 = 2LL * v28[4];
      if (v35 <= v34 + 1) {
        unint64_t v35 = v34 + 1;
      }
      v28[4] = v35;
      char v36 = v35 + 8;
      unint64_t v37 = v14;
      uint64_t v38 = malloc(v35 + 8);
      int64_t v14 = v37;
      uint64_t v39 = (char *)v38 + v36;
      *uint64_t v38 = v28[3];
      char v29 = (char *)(v38 + 1);
      v28[2] = v39;
      v28[3] = v38;
    }

    v28[1] = &v29[v34];
    if ((_DWORD)v27)
    {
      uint64_t v40 = v14;
      memcpy(v29, *(const void **)(a2 + 12728), v27);
      int64_t v14 = v40;
      LODWORD(v27) = *(_DWORD *)(a2 + 12740);
      uint64_t v25 = *(_DWORD *)(a2 + 12736);
    }

    uint64_t v26 = v44;
    uint64_t v41 = v42;
    *(void *)int64_t v14 = v29;
    uint64_t v15 = v29;
    goto LABEL_43;
  }

void specialized Array.replaceSubrange<A>(_:with:)(char *a1, uint64_t a2, uint64_t a3)
{
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array replace: subrange start is negative",  41LL,  2,  "Swift/Array.swift",  17LL,  2,  0x6D4uLL,  0);
  }
  uint64_t v9 = a1;
  uint64_t v10 = *(void *)v4;
  if (!(*(void *)v4 >> 62))
  {
    if (*(void *)((v10 & 0xFFFFFFFFFFFFF8LL) + 0x10) >= a2) {
      goto LABEL_4;
    }
LABEL_36:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array replace: subrange extends past the end",  44LL,  2,  "Swift/Array.swift",  17LL,  2,  0x6D7uLL,  0);
  }

  if (v10 < 0) {
    uint64_t v26 = *(void **)v4;
  }
  else {
    uint64_t v26 = (void *)(v10 & 0xFFFFFFFFFFFFFF8LL);
  }
LABEL_4:
  uint64_t v11 = a2 - (void)v9;
  if (__OFSUB__(a2, v9))
  {
    __break(1u);
  }

  else
  {
    unint64_t v6 = (unint64_t)a3 >> 62;
    if (!((unint64_t)a3 >> 62))
    {
      uint64_t v12 = *(char **)((a3 & 0xFFFFFFFFFFFFF8LL) + 0x10);
      id v13 = &v12[-v11];
      if (!__OFSUB__(v12, v11)) {
        goto LABEL_7;
      }
LABEL_43:
      __break(1u);
LABEL_44:
      if (v5 < 0) {
        BOOL v28 = (void *)v5;
      }
      else {
        BOOL v28 = (void *)(v5 & 0xFFFFFFFFFFFFFF8LL);
      }
      id v29 = objc_msgSend(v28, sel_count);
      uint64_t v15 = &v13[(void)v29];
      if (!__OFADD__(v29, v13)) {
        goto LABEL_9;
      }
LABEL_49:
      __break(1u);
LABEL_50:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
    }
  }

  if (a3 < 0) {
    id v27 = (void *)a3;
  }
  else {
    id v27 = (void *)(a3 & 0xFFFFFFFFFFFFFF8LL);
  }
  uint64_t v12 = (char *)objc_msgSend(v27, sel_count);
  id v13 = &v12[-v11];
  if (__OFSUB__(v12, v11)) {
    goto LABEL_43;
  }
LABEL_7:
  uint64_t v5 = *(void *)v4;
  uint64_t v3 = *(void *)v4 >> 62;
  uint64_t v35 = (uint64_t)v12;
  if (v3) {
    goto LABEL_44;
  }
  uint64_t v14 = *(void *)((v5 & 0xFFFFFFFFFFFFF8LL) + 0x10);
  uint64_t v15 = &v13[v14];
  if (__OFADD__(v14, v13)) {
    goto LABEL_49;
  }
LABEL_9:
  unint64_t v33 = v6;
  uint64_t v34 = a3;
  int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(v5);
  *(void *)uint64_t v4 = v5;
  if (v3) {
    int v17 = 0;
  }
  else {
    int v17 = isUniquelyReferenced_nonNull_bridgeObject;
  }
  if (v17 == 1)
  {
    uint64_t v18 = v5 & 0xFFFFFFFFFFFFFF8LL;
  }

  if (v3) {
    goto LABEL_59;
  }
  for (uint64_t i = *(char **)((v5 & 0xFFFFFFFFFFFFF8) + 0x10); ; uint64_t i = (char *)objc_msgSend(v32, sel_count))
  {
    else {
      uint64_t v20 = (uint64_t)i;
    }
    uint64_t v5 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v17, v20, 1, v5);
    *(void *)uint64_t v4 = v5;
    uint64_t v18 = v5 & 0xFFFFFFFFFFFFFF8LL;
LABEL_20:
    uint64_t v15 = (char *)v35;
    if (v11 < 0) {
      goto LABEL_50;
    }
    uint64_t v4 = (char *)(v18 + 32 + 8LL * (void)v9);
    swift_arrayDestroy((uint64_t)v4, v11, (uint64_t)&unk_189B8D230);
    if (!v13) {
      goto LABEL_26;
    }
    uint64_t v9 = &v4[8 * v35];
    uint64_t v11 = v18 + 32 + 8 * a2;
    uint64_t v21 = *(void *)(v18 + 16);
    if (__OFSUB__(v21, a2)) {
      goto LABEL_57;
    }
    specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v18 + 32 + 8 * a2), v21 - a2, &v4[8 * v35]);
    uint64_t v22 = *(void *)(v18 + 16);
    BOOL v23 = __OFADD__(v22, v13);
    uint64_t v24 = &v13[v22];
    if (!v23) {
      goto LABEL_25;
    }
LABEL_58:
    __break(1u);
LABEL_59:
    if (v5 < 0) {
      char v32 = (void *)v5;
    }
    else {
      char v32 = (void *)(v5 & 0xFFFFFFFFFFFFFF8LL);
    }
  }

  if (v5 >= 0) {
    uint64_t v5 = v18;
  }
  id v30 = objc_msgSend((id)v5, sel_count);
  if (__OFSUB__(v30, a2))
  {
LABEL_57:
    __break(1u);
    goto LABEL_58;
  }

  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v18 + 32 + 8 * a2),  (uint64_t)v30 - a2,  &v4[8 * v35]);
  id v31 = objc_msgSend((id)v5, sel_count);
  uint64_t v24 = &v13[(void)v31];
  if (__OFADD__(v31, v13))
  {
    __break(1u);
    goto LABEL_57;
  }

LABEL_25:
  *(void *)(v18 + 16) = v24;
LABEL_26:
  if (v35 >= 1)
  {
    if (v33)
    {
      uint64_t v25 = specialized _copyCollectionToContiguousArray<A>(_:)(v34);
      specialized closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( (char *)v25 + 32,  (uint64_t)v25[2],  v35,  v4);
      swift_release((uint64_t)v25);
    }

    else
    {
      specialized closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)( (char *)((v34 & 0xFFFFFFFFFFFFFF8LL) + 32),  *(void *)((v34 & 0xFFFFFFFFFFFFFF8LL) + 0x10),  v35,  v4);
    }
  }

  swift_bridgeObjectRelease(v34);
}

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
      }
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }

  int64_t v55 = (char *)a7;
  uint64_t v54 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v19 + 64);
  uint64_t result = ((void *(*)(uint64_t *__return_ptr, uint64_t, uint64_t))v54)(&v82, a6, v19);
  unint64_t v59 = v82;
  unint64_t v60 = v82 + a2;
  if (__OFADD__(v82, a2))
  {
    __break(1u);
  }

  else
  {
    int64_t v56 = v7;
    int64_t v57 = v81;
    uint64_t v61 = *(void (**)(char *, char *, uint64_t))(v81 + 16);
    v61(v69, v7, a6);
    if (v60 < v59) {
      goto LABEL_30;
    }
    unint64_t v62 = (uint64_t (*)(uint64_t, uint64_t, char *, uint64_t, char *))*((void *)v55 + 6);
    int64_t v63 = v62(v59, v60, v79, a6, v55);
    uint64_t result = (void *)((uint64_t (*)(uint64_t, uint64_t))v78)(v63, v76);
    uint64_t v24 = __OFADD__(v60, v80);
    unint64_t v64 = v60 + v80;
    if (!v24)
    {
      v80 = (uint64_t)v62;
      Swift::Int v53 = v74;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v74 + 72))(&v82, a6, v74);
      char v65 = v82;
      v61(v68, v56, a6);
      if (v65 >= v64)
      {
        ((void (*)(uint64_t, uint64_t, char *, uint64_t, char *))v80)(v64, v65, v75, a6, v55);
        goto LABEL_24;
      }

  if (v17 > 15)
  {
LABEL_26:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v17, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    v375 = 0LL;
    v376 = 0LL;
    uint64_t v44 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v375, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v44, v45, 1);
    uint64_t v43 = 0xE000000000000000LL;
    goto LABEL_27;
  }

        uint64_t v26 = (v46 - 1) & v46;
        uint64_t v38 = __clz(__rbit64(v46)) + (v35 << 6);
      }

      (*(void (**)(char *, unint64_t, char *))(v36 + 16))( v79,  *(void *)(v27 + 48) + *(void *)(v36 + 72) * v38,  a3);
      uint64_t v39 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v36 + 56);
      goto LABEL_13;
    }

    uint64_t v48 = (void *)v73;
    Swift::Int v49 = *(void *)(v73 + 216);
    uint64_t v44 = v79;
    if (v49 < 0) {
      goto LABEL_39;
    }
    if (v49 == *(void *)(v73 + 224)) {
      break;
    }
LABEL_30:
    unint64_t v51 = v48[3];
    if (!v51) {
      goto LABEL_46;
    }
    uint64_t v52 = (void **)(v51 + 8 * v49);
    Swift::Int v53 = *v52;
    v48[27] = v49 + 1;
    swift_unknownObjectRetain(v53, v32, v33, v34);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, (uint64_t *)a3))
    {
      unint64_t v84 = v53;
      swift_dynamicCast(v44, (uint64_t *)&v84, v72, a3, 7uLL);
      char v36 = v80;
      uint64_t v39 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v80 + 56);
    }

    else
    {
      uint64_t v54 = v80;
      uint64_t v39 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v80 + 56);
      int64_t v55 = v67;
      v39(v67, 1LL, 1LL, a3);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v53, (uint64_t)a3, v55);
      int64_t v56 = v53;
      char v36 = v54;
      swift_unknownObjectRelease(v56);
      int64_t v57 = v65;
      char v58 = v64;
      unint64_t v59 = v55;
      unint64_t v60 = v66;
      (*(void (**)(char *, uint64_t *, uint64_t))(v65 + 16))(v64, v59, v66);
      if ((*(unsigned int (**)(char *, uint64_t, char *))(v36 + 48))(v58, 1LL, a3) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v57 + 8))(v67, v60);
      (*(void (**)(char *, char *, char *))(v36 + 32))(v44, v58, a3);
      uint64_t v35 = v78;
    }

    uint64_t v26 = v43;
LABEL_13:
    v39((uint64_t *)v44, 0LL, 1LL, a3);
    uint64_t v40 = v76;
    (*(void (**)(char *, char *, char *))(v36 + 32))(v76, v44, a3);
    uint64_t v41 = v82;
    uint64_t v42 = v83;
    __swift_mutable_project_boxed_opaque_existential_1(v81, v82);
    (*(void (**)(char *, char *, uint64_t, uint64_t, uint64_t))(v42 + 160))(v40, a3, v77, v41, v42);
    char v36 = v80;
    (*(void (**)(char *, char *))(v80 + 8))(v40, a3);
    id v27 = v75;
    if (v4)
    {
      uint64_t v61 = v75;
      goto LABEL_40;
    }
  }

  unint64_t v50 = objc_msgSend(*(id *)(v73 + 208), sel_countByEnumeratingWithState_objects_count_, v70, v69, 16);
  v48[28] = v50;
  if (v50)
  {
    Swift::Int v49 = 0LL;
    v48[27] = 0LL;
    goto LABEL_30;
  }

  v48[27] = -1LL;
LABEL_39:
  (*(void (**)(char *, uint64_t, uint64_t, char *))(v36 + 56))(v44, 1LL, 1LL, a3);
  uint64_t v61 = v27;
LABEL_40:
  outlined consume of [A : B].Iterator._Variant<A, B>(v61);
  return __swift_destroy_boxed_opaque_existential_1Tm(v81);
}

    uint64_t v113 = 0LL;
    char v65 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v66 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v65(&v113, &type metadata for Int, v66, a2, a3);
    int64_t v63 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(*(void *)(*(void *)(a3 + 16) + 8LL) + 8LL))( v53,  v26,  a2);
    unint64_t v67 = v26;
LABEL_26:
    v44(v67, a2);
    return v63 & 1;
  }

  Swift::Int v53 = v111;
  uint64_t v54 = v106(a2, a3);
  if (v54 >= 64) {
    goto LABEL_25;
  }
LABEL_24:
  (*(void (**)(_BYTE *, uint64_t, uint64_t))(v112 + 16))(v26, v53, a2);
  unint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v44(v26, a2);
  int64_t v63 = v64 == 0;
  return v63 & 1;
}

    uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v11[2]->isa + 1,  1,  (uint64_t)v11);
LABEL_20:
    uint64_t v18 = v11[2];
    int v17 = (unint64_t)v11[3];
    if ((unint64_t)v18 >= v17 >> 1) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v17 > 1),  (int64_t)&v18->isa + 1,  1,  (uint64_t)v11);
    }
    v11[2] = (__objc2_class *)((char *)&v18->isa + 1);
    *((_BYTE *)&v18->info + (void)v11) = v16;
  }

  while (v7 | v8);
  uint64_t v41 = (unint64_t)v11;
  if (a4 < 0)
  {
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v11)) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v11[2]->isa + 1,  1,  (uint64_t)v11);
    }
    uint64_t v20 = v11[2];
    uint64_t v19 = (unint64_t)v11[3];
    if ((unint64_t)v20 >= v19 >> 1) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v19 > 1),  (int64_t)&v20->isa + 1,  1,  (uint64_t)v11);
    }
    v11[2] = (__objc2_class *)((char *)&v20->isa + 1);
    *((_BYTE *)&v20->info + (void)v11) = 45;
    uint64_t v41 = (unint64_t)v11;
  }

  specialized MutableCollection<>.reverse()();
  uint64_t v24 = *(void *)(v41 + 16);
  if (!v24)
  {
    id v31 = 0LL;
LABEL_53:
    swift_bridgeObjectRetain(v41, v21, v22, v23);
    goto LABEL_54;
  }

  if (v24 <= 0xF)
  {
    char v32 = 8LL;
    if (v24 < 8) {
      char v32 = *(void *)(v41 + 16);
    }
    id v31 = *(unsigned __int8 *)(v41 + 32);
    if (v32 != 1)
    {
      v31 |= (unint64_t)*(unsigned __int8 *)(v41 + 33) << 8;
      if (v32 != 2)
      {
        v31 |= (unint64_t)*(unsigned __int8 *)(v41 + 34) << 16;
        if (v32 != 3)
        {
          v31 |= (unint64_t)*(unsigned __int8 *)(v41 + 35) << 24;
          if (v32 != 4)
          {
            v31 |= (unint64_t)*(unsigned __int8 *)(v41 + 36) << 32;
            if (v32 != 5)
            {
              v31 |= (unint64_t)*(unsigned __int8 *)(v41 + 37) << 40;
              if (v32 != 6)
              {
                v31 |= (unint64_t)*(unsigned __int8 *)(v41 + 38) << 48;
                if (v32 != 7) {
                  v31 |= (unint64_t)*(unsigned __int8 *)(v41 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }

    unint64_t v33 = 0LL;
    if (v24 >= 9)
    {
      uint64_t v34 = 0LL;
      uint64_t v35 = (unsigned __int8 *)(v41 + 40);
      char v36 = v24 - 8;
      do
      {
        if (v24 - 8 <= v24 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        unint64_t v37 = *v35++;
        v33 |= (unint64_t)v37 << v34;
        v34 += 8LL;
        --v36;
      }

      while (v36);
    }

    goto LABEL_53;
  }

  uint64_t v25 = v24 | 0xF000000000000000LL;
  uint64_t v26 = _allocateStringStorage(codeUnitCapacity:)(*(void *)(v41 + 16));
  BOOL v28 = v27;
  *(void *)(v26 + 16) = v27;
  *(void *)(v26 + 24) = v24 | 0xF000000000000000LL;
  swift_bridgeObjectRetain(v41, v27, v29, v30);
  if (v28 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v25 = *(void *)(v26 + 24);
  }

  *(_BYTE *)(v26 + 32 + (v25 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v41 + 32), v24, (char *)(v26 + 32));
  id v31 = *(void *)(v26 + 24);
LABEL_54:
  swift_bridgeObjectRelease_n(v41, 2LL);
  return v31;
}

    uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v11[2]->isa + 1,  1,  (uint64_t)v11);
LABEL_20:
    uint64_t v18 = v11[2];
    int v17 = (unint64_t)v11[3];
    if ((unint64_t)v18 >= v17 >> 1) {
      uint64_t v11 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v17 > 1),  (int64_t)&v18->isa + 1,  1,  (uint64_t)v11);
    }
    v11[2] = (__objc2_class *)((char *)&v18->isa + 1);
    *((_BYTE *)&v18->info + (void)v11) = v16;
  }

  while (v5 | v4);
  uint64_t v39 = (unint64_t)v11;
  specialized MutableCollection<>.reverse()();
  uint64_t v22 = (size_t)v11[2];
  if (!v22)
  {
    id v30 = 0LL;
LABEL_47:
    swift_bridgeObjectRetain(v39, v19, v20, v21);
    goto LABEL_48;
  }

  BOOL v23 = (unsigned __int8 *)(v11 + 4);
  if (v22 <= 0xF)
  {
    id v31 = 8LL;
    if (v22 < 8) {
      id v31 = *(void *)(v39 + 16);
    }
    id v30 = *v23;
    if (v31 != 1)
    {
      v30 |= (unint64_t)*(unsigned __int8 *)(v39 + 33) << 8;
      if (v31 != 2)
      {
        v30 |= (unint64_t)*(unsigned __int8 *)(v39 + 34) << 16;
        if (v31 != 3)
        {
          v30 |= (unint64_t)*(unsigned __int8 *)(v39 + 35) << 24;
          if (v31 != 4)
          {
            v30 |= (unint64_t)*(unsigned __int8 *)(v39 + 36) << 32;
            if (v31 != 5)
            {
              v30 |= (unint64_t)*(unsigned __int8 *)(v39 + 37) << 40;
              if (v31 != 6)
              {
                v30 |= (unint64_t)*(unsigned __int8 *)(v39 + 38) << 48;
                if (v31 != 7) {
                  v30 |= (unint64_t)*(unsigned __int8 *)(v39 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }

    char v32 = 0LL;
    if (v22 >= 9)
    {
      unint64_t v33 = 0LL;
      uint64_t v34 = (unsigned __int8 *)(v39 + 40);
      uint64_t v35 = v22 - 8;
      do
      {
        if (v22 - 8 <= v22 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        char v36 = *v34++;
        v32 |= (unint64_t)v36 << v33;
        v33 += 8LL;
        --v35;
      }

      while (v35);
    }

    goto LABEL_47;
  }

  uint64_t v24 = v22 | 0xF000000000000000LL;
  uint64_t v25 = _allocateStringStorage(codeUnitCapacity:)(*(void *)(v39 + 16));
  id v27 = v26;
  *(void *)(v25 + 16) = v26;
  *(void *)(v25 + 24) = v22 | 0xF000000000000000LL;
  swift_bridgeObjectRetain(v39, v26, v28, v29);
  if (v27 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v24 = *(void *)(v25 + 24);
  }

  *(_BYTE *)(v25 + 32 + (v24 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v39 + 32), v22, (char *)(v25 + 32));
  id v30 = *(void *)(v25 + 24);
LABEL_48:
  swift_bridgeObjectRelease_n(v39, 2LL);
  return v30;
}

  uint64_t v20 = v17 + v18;
  if (v19 >= v20) {
    uint64_t v19 = v20;
  }
  if ((v8 & 0x1000000000000000LL) == 0)
  {
    if (v19 >= v18) {
      goto LABEL_29;
    }
    goto LABEL_73;
  }

  unint64_t v60 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v18, v19);
  uint64_t object = v60._object;
  uint64_t countAndFlagsBits = v60._countAndFlagsBits;
LABEL_37:
  id v27 = countAndFlagsBits;
  BOOL v28 = (uint64_t)object;
  id v29 = v0->_rawBits;
  id v30 = v0[1]._rawBits;
  id v31 = v0[2]._rawBits;
  char v32 = v0[3]._rawBits;
  unint64_t v33 = (v32 & 0x1000000000000000LL) == 0 || (v31 & 0x800000000000000LL) != 0;
  uint64_t v34 = 4LL << v33;
  uint64_t v35 = v30 >> 14;
  if ((rawBits & 2) == 0 || v10 == v34)
  {
    if (v10 == v34)
    {
      v62._Swift::UInt64 rawBits = rawBits;
      int64_t v63 = (uint64_t)object;
      unint64_t v64 = v27;
      v65._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v62)._rawBits;
      id v27 = v64;
      BOOL v28 = v63;
      Swift::UInt64 rawBits = v65._rawBits;
      uint64_t v3 = v65._rawBits >> 14;
    }

    if (v3 >= v29 >> 14 && v3 < v35)
    {
      if ((rawBits & 1) != 0)
      {
        if ((v29 & 2) != 0) {
          goto LABEL_52;
        }
      }

      else
      {
        uint64_t v77 = v28;
        uint64_t v69 = v27;
        v70._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
        id v27 = v69;
        BOOL v28 = v77;
        Swift::UInt64 rawBits = rawBits & 0xC | v70._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
        if ((v29 & 2) != 0)
        {
LABEL_52:
          if ((rawBits & 2) != 0) {
            goto LABEL_56;
          }
        }
      }

      if (rawBits >> 14 != v29 >> 14 && rawBits >> 14 != v35)
      {
        char v36 = rawBits;
        unint64_t v37 = v28;
        uint64_t v38 = v27;
        uint64_t v39 = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(v36, v29, v30, v31, v32);
        id v27 = v38;
        BOOL v28 = v37;
        Swift::UInt64 rawBits = v39;
      }

      goto LABEL_56;
    }

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

    uint64_t v14 = (v23 - 1) & v23;
    int v17 = __clz(__rbit64(v23)) + (v11 << 6);
LABEL_12:
    uint64_t v18 = 16 * v17;
    uint64_t v19 = (void *)(*(void *)(v1 + 48) + v18);
    uint64_t v20 = v19[1];
    uint64_t v21 = (void *)(v6[6] + v18);
    *uint64_t v21 = *v19;
    v21[1] = v20;
    uint64_t result = (void *)swift_bridgeObjectRetain(v20, v3, v4, v5);
  }

  uint64_t v24 = v22 + 2;
  if (v24 >= v15) {
    goto LABEL_26;
  }
  BOOL v23 = *(void *)(v8 + 8 * v24);
  if (v23)
  {
    uint64_t v11 = v24;
    goto LABEL_25;
  }

  while (1)
  {
    uint64_t v11 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v11 >= v15) {
      goto LABEL_26;
    }
    BOOL v23 = *(void *)(v8 + 8 * v11);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }

    uint64_t v14 = (v23 - 1) & v23;
    int v17 = __clz(__rbit64(v23)) + (v11 << 6);
LABEL_12:
    uint64_t v18 = 40 * v17;
    uint64_t result = (void *)outlined init with copy of AnyHashable(*(void *)(v1 + 48) + 40 * v17, (uint64_t)v25);
    uint64_t v19 = v6[6] + v18;
    uint64_t v20 = v25[0];
    uint64_t v21 = v25[1];
    *(void *)(v19 + 32) = v26;
    *(_OWORD *)uint64_t v19 = v20;
    *(_OWORD *)(v19 + 16) = v21;
  }

  uint64_t v24 = v22 + 2;
  if (v24 >= v15) {
    goto LABEL_26;
  }
  BOOL v23 = *(void *)(v8 + 8 * v24);
  if (v23)
  {
    uint64_t v11 = v24;
    goto LABEL_25;
  }

  while (1)
  {
    uint64_t v11 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v11 >= v15) {
      goto LABEL_26;
    }
    BOOL v23 = *(void *)(v8 + 8 * v11);
    ++v24;
    if (v23) {
      goto LABEL_25;
    }
  }

    uint64_t v19 = __clz(__rbit64(v17));
    uint64_t v12 = (v17 - 1) & v17;
    uint64_t v15 = v19 + (v9 << 6);
LABEL_12:
    *(void *)(v4[6] + 8 * v15) = *(void *)(*(void *)(v2 + 48) + 8 * v15);
  }

  uint64_t v18 = v16 + 2;
  if (v18 >= v13) {
    goto LABEL_26;
  }
  int v17 = *(void *)(v6 + 8 * v18);
  if (v17)
  {
    uint64_t v9 = v18;
    goto LABEL_25;
  }

  while (1)
  {
    uint64_t v9 = v18 + 1;
    if (__OFADD__(v18, 1LL)) {
      break;
    }
    if (v9 >= v13) {
      goto LABEL_26;
    }
    int v17 = *(void *)(v6 + 8 * v9);
    ++v18;
    if (v17) {
      goto LABEL_25;
    }
  }

  BOOL v23 = *v5;
  *(void *)(*v5 + 8 * (a3 >> 6) + 56) |= 1LL << a3;
  uint64_t v24 = (unint64_t *)(*(void *)(v23 + 48) + 16 * a3);
  *uint64_t v24 = v8;
  v24[1] = a2;
  uint64_t v25 = *(void *)(v23 + 16);
  uint64_t v26 = __OFADD__(v25, 1LL);
  id v27 = v25 + 1;
  if (v26) {
    __break(1u);
  }
  else {
    *(void *)(v23 + 16) = v27;
  }
  return result;
}

    uint64_t v11 = (unint64_t)v1[2];
    uint64_t v10 = (unint64_t)v1[3];
    if (v11 >= v10 >> 1) {
      BOOL v1 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v10 > 1),  v11 + 1,  1,  (uint64_t)v1);
    }
    v1[2] = (__objc2_class *)(v11 + 1);
    uint64_t v12 = &v1[v11];
    *((_DWORD *)v12 + 8) = v4;
    *((_WORD *)v12 + 18) = WORD2(v4);
    *(void *)uint64_t v0 = v1;
    uint64_t v4 = specialized Unicode._InternalNFD.Iterator.next()();
    if ((v4 & 0x1000000000000LL) != 0) {
      goto LABEL_34;
    }
  }

  if (v4 >= 0x300 && (v4 & 0x600000000LL) != 0)
  {
    unint64_t v6 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v0 + 12), v4);
    if ((v6 & 0x100000000LL) == 0) {
      goto LABEL_10;
    }
    LODWORD(v6) = _swift_stdlib_getComposition(v7, v4);
    if ((_DWORD)v6 != -1) {
      goto LABEL_10;
    }
  }

  if ((v4 & 0x7F800000000LL) != 0)
  {
LABEL_24:
    uint64_t v9 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v1);
    *(void *)uint64_t v0 = v1;
    if (v9) {
      goto LABEL_25;
    }
    uint64_t v14 = (int64_t)&v1[2]->isa + 1;
LABEL_33:
    BOOL v1 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v14,  1,  (uint64_t)v1);
    *(void *)uint64_t v0 = v1;
    goto LABEL_25;
  }

  LOBYTE(v3) = 0;
LABEL_38:
  *(_DWORD *)(v0 + 12) = v4;
  *(_BYTE *)(v0 + 16) = 0;
  LODWORD(v4) = v7;
  return v4 | ((unint64_t)v3 << 32);
}

  *a1 = a4;
  a1[1] = (unint64_t *)a5;
  a1[2] = (unint64_t *)v6;
  a1[3] = (unint64_t *)v5;
  return a3;
}

  swift_release_n(v57, 2LL);
  uint64_t v43 = v56;
  swift_retain(v56, v44, v45, v46);
  while (!__ldaxr(v2))
  {
  }

  __clrex();
  swift_release((uint64_t)v43);
LABEL_30:
  swift_release((uint64_t)v43);
  uint64_t v10 = (void *)atomic_load(v2);
  if (!v10) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0xCFuLL,  0);
  }
  unint64_t v51 = swift_unknownObjectRetain(v10, v48, v49, v50);
  return v10;
}

          __break(1u);
LABEL_26:
          __break(1u);
          goto LABEL_27;
        }

    Swift::Int v53 = v31 >> 63;
    uint64_t v54 = v31 >> 63;
    goto LABEL_67;
  }

  if (v110 <= 0xFFFFFFFFFFFFFF80LL)
  {
LABEL_18:
    Swift::Int v53 = 0LL;
    uint64_t v54 = 0LL;
    goto LABEL_67;
  }

  uint64_t v112 = v98 << -(char)v110;
  v111 = (-(uint64_t)v110 & 0x40) == 0;
  else {
    Swift::Int v53 = v98 << -(char)v110;
  }
  uint64_t v54 = (v31 << -(char)v110) | (v98 >> 1 >> (v110 - 1));
LABEL_65:
  if (!v111) {
    uint64_t v54 = v112;
  }
LABEL_67:
  uint64_t v113 = v124;
  *unint64_t v124 = v53;
  v113[1] = v54;
  return result;
}

        int64_t v55 = v123 >> 63;
        goto LABEL_65;
      }

      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      unint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      int64_t v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      uint64_t result = v63(v30, a3);
      if (v64 <= 64) {
        goto LABEL_26;
      }
      goto LABEL_25;
    }

  char v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v74 = v140;
  v73(v140, a2, a3);
  char v75 = v141(a3, a4);
  Swift::String v76 = v139;
  uint64_t v77 = v74;
  uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  uint64_t v132 = v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_42;
  }

  unint64_t v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64) {
    goto LABEL_42;
  }
  char v81 = v135;
  v78(v135, v140, a3);
  unint64_t v144 = 0x8000000000000000LL;
  uint64_t v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    char v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      uint64_t v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      int64_t v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v88,  a3);
      int64_t v89 = v88;
      char v81 = v135;
      v70(v89, a3);
      goto LABEL_41;
    }
  }

  else
  {
    int64_t v90 = v82(a3, a4);
    char v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
        int64_t v103 = v133;
        Swift::String v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        unint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        char v81 = v107;
        v70(v108, a3);
        char v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_64;
        }

        uint64_t v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        v80 = v140;
        if (v112) {
          goto LABEL_64;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        unint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        unint64_t v97 = v135;
        unint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        unint64_t v99 = v96;
        char v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_64;
        }
      }

      goto LABEL_41;
    }

    if (v91 >= 64) {
      goto LABEL_41;
    }
  }

  uint64_t v100 = v142;
  v78(v142, v81, a3);
  char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_64:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
  v70(v81, a3);
LABEL_42:
  uint64_t v113 = v132;
  uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    int64_t v116 = v141;
    goto LABEL_44;
  }

  unint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  unint64_t v125 = v124 == 64;
  int64_t v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v78(v40, v80, a3);
    unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v117 = v116(a3, a4);
    int64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        uint64_t v123 = &v144;
        goto LABEL_54;
      }
    }

    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v143;
LABEL_54:
      unint64_t v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
      v70(v127, a3);
      if ((v128 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    char v126 = v142;
    v78(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }

  Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) != 0)
  {
    if (v129 <= 0xFFFFFFFFFFFFFFC0LL) {
      uint64_t v61 = v130 >> 63;
    }
    else {
      uint64_t v61 = v130 >> -(char)v129;
    }
  }

  else
  {
    uint64_t v61 = v130 << v129;
    if (v129 >= 0x40) {
      uint64_t v61 = 0LL;
    }
  }

  uint64_t result = 0LL;
  unint64_t v62 = 0LL;
LABEL_58:
  uint64_t v102 = v115;
  uint8x16_t *v115 = v62;
  v102[1] = result;
  return result;
}

  uint64_t result = 0LL;
  unint64_t v62 = 0LL;
LABEL_58:
  uint64_t v102 = v115;
  uint8x16_t *v115 = v62;
  v102[1] = result;
  return result;
}

      char v36 = -128LL;
      goto LABEL_49;
    }
  }

  char v36 = -128LL;
  v111 = -128LL;
  unint64_t v37 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  uint64_t v38 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
  v37(&v111, &type metadata for Int, v38, a3, a4);
  uint64_t v39 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v39 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_49:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  int64_t v89 = v106;
  int64_t v88 = v107;
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v106, v107, v90);
  if ((v36 & 0x8000000000000000LL) != 0)
  {
    if (v36 <= 0xFFFFFFFFFFFFFF80LL)
    {
      uint64_t result = 0LL;
      unint64_t v93 = 0LL;
      goto LABEL_53;
    }

    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v111, v89, v88, v95);
  }

  else if (v36 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v89, v88, v92);
  }

  unint64_t v93 = v111;
LABEL_53:
  uint64_t v94 = v108;
  void *v108 = v93;
  v94[1] = result;
  return result;
}

      char v36 = -128LL;
      goto LABEL_50;
    }
  }

  char v36 = -128LL;
  v111 = -128LL;
  unint64_t v37 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  uint64_t v38 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
  v37(&v111, &type metadata for Int, v38, a3, a4);
  uint64_t v39 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v29,  a3);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v39 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_50:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  int64_t v89 = v106;
  int64_t v88 = v107;
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v106, v107, v90);
  if ((v36 & 0x8000000000000000LL) != 0)
  {
    if (v36 > 0xFFFFFFFFFFFFFF80LL)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v89, v88, v95);
    }
  }

  else
  {
    if (v36 >= 0x80)
    {
      uint64_t result = 0LL;
      unint64_t v93 = 0LL;
      goto LABEL_54;
    }

    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v111, v89, v88, v92);
  }

  unint64_t v93 = v111;
LABEL_54:
  uint64_t v94 = v108;
  void *v108 = v93;
  v94[1] = result;
  return result;
}

        isLinkingConsonant = _swift_stdlib_isLinkingConsonant(a2);
        if (v13 == 12)
        {
          if (!isLinkingConsonant) {
            goto LABEL_32;
          }
        }

        else if (v13 != 2 {
               || !isLinkingConsonant
        }
               || a1 < 0x300
               || !(_swift_stdlib_getNormData(a1) >> 3))
        {
          goto LABEL_32;
        }

        goto LABEL_37;
      }

      if (v14 != 8)
      {
LABEL_12:
        _swift_stdlib_isLinkingConsonant(a2);
        goto LABEL_32;
      }

      swift_bridgeObjectRetain(a5, v15, v16, v17);
      uint64_t v25 = specialized _StringGuts.countRIs(at:with:)(a3, (uint64_t)a4, a5);
      swift_bridgeObjectRelease_n(a5, 5LL);
      return v25 & 1;
  }

    if (_swift_stdlib_isLinkingConsonant(v12)) {
      break;
    }
    if (v13 == 2)
    {
      if (v12 < 0x300) {
        goto LABEL_39;
      }
      uint64_t v15 = _swift_stdlib_getNormData(v12) >> 3;
      if (!v15) {
        return v15 & 1;
      }
      HIDWORD(v17) = v12 - 2381;
      LODWORD(v17) = v12 - 2381;
      uint64_t v16 = v17 >> 7;
      uint64_t v18 = v16 > 8;
      uint64_t v19 = (0x15Bu >> v16) | v9;
      if (!v18) {
        uint64_t v9 = v19;
      }
    }

    else if (v13 != 12)
    {
      goto LABEL_39;
    }

    uint64_t v15 = 0;
    if (v3 <= 0) {
      return v15 & 1;
    }
  }

  uint64_t v15 = v9;
  return v15 & 1;
}

    if (_swift_stdlib_isLinkingConsonant(v14)) {
      break;
    }
    if (v15 == 2)
    {
      if (v14 < 0x300) {
        goto LABEL_40;
      }
      int v17 = _swift_stdlib_getNormData(v14) >> 3;
      if (!v17) {
        return v17 & 1;
      }
      HIDWORD(v19) = v14 - 2381;
      LODWORD(v19) = v14 - 2381;
      uint64_t v18 = v19 >> 7;
      uint64_t v20 = v18 > 8;
      uint64_t v21 = (0x15Bu >> v18) | v11;
      if (!v20) {
        uint64_t v11 = v21;
      }
    }

    else if (v15 != 12)
    {
      goto LABEL_40;
    }

    int v17 = 0;
    if (v5 <= a2) {
      return v17 & 1;
    }
  }

  int v17 = v11;
  return v17 & 1;
}

  if ((a8 & 1) != 0) {
    return result;
  }
  id v13 = __OFADD__(v16, 16LL);
  uint64_t v21 = v16 + 16;
  if (v13) {
    goto LABEL_46;
  }
  if ((unint64_t)(a7 - 0x1000000000000000LL) >> 61 != 7)
  {
LABEL_47:
    __break(1u);
    return result;
  }

  id v13 = __OFADD__(v21, 8 * a7);
  uint64_t v16 = v21 + 8 * a7;
  if (!v13) {
    goto LABEL_33;
  }
  __break(1u);
LABEL_31:
  if ((v16 & 1) != 0)
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }

  uint64_t result = a3(*(void *)(v8 + 40));
  uint64_t v16 = v9 + result;
  if (__OFADD__(v9, result))
  {
LABEL_45:
    __break(1u);
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }

  if ((_DWORD)v7 == v11)
  {
    uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v6 + 48);
    id v27 = a1;
    uint64_t v10 = v7;
    uint64_t v12 = v5;
    return v26(v27, v10, v12);
  }

  id v27 = (((v15 + a1) & ~v14) + v13 + v16) & ~v16;
  if ((_DWORD)v10 == v11)
  {
    uint64_t v26 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48);
    return v26(v27, v10, v12);
  }

  id v29 = *(unsigned __int8 *)(((v18 + v27) & ~v17) + v19);
  if (v29 < 2) {
    return 0LL;
  }
  id v30 = (v29 + 2147483646) & 0x7FFFFFFF;
  return (v30 + 1);
}

  if ((_DWORD)v8 == v12)
  {
    BOOL v23 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v7 + 48);
    uint64_t v24 = a1;
    uint64_t v11 = v8;
    id v13 = AssociatedTypeWitness;
    return v23(v24, v11, v13);
  }

  uint64_t v24 = (v15 + a1) & ~v14;
  if ((_DWORD)v11 == v12)
  {
    BOOL v23 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v10 + 48);
    return v23(v24, v11, v13);
  }

  uint64_t v26 = *(unsigned __int8 *)(v24 + v16);
  if (v26 < 2) {
    return 0LL;
  }
  id v27 = (v26 + 2147483646) & 0x7FFFFFFF;
  return (v27 + 1);
}

    if ((a3 & 0x100) != 0) {
      goto LABEL_38;
    }
    if (v11 < v21)
    {
      uint64_t v22 = *(os_unfair_lock_s **)a2;
      os_unfair_lock_lock(*(os_unfair_lock_t *)a2);
      BOOL v23 = *(void **)(a2 + 8);
      if (*v23 == 1LL)
      {
        uint64_t v24 = *(void *)(a2 + 8);
      }

      else
      {
        uint64_t v24 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
        *(_OWORD *)uint64_t v24 = 0u;
        *(_OWORD *)(v24 + 16) = 0u;
        *(_OWORD *)(v24 + 32) = 0u;
        *(void *)uint64_t v24 = 1LL;
        *(void *)(v24 + 16) = 0LL;
        *(void *)(v24 + 24) = 0LL;
        os_unfair_lock_lock((os_unfair_lock_t)(v24 + 8));
        uint64_t v25 = v23[2];
        v23[2] = 0LL;
        uint64_t v26 = *(void **)(v24 + 16);
        *(void *)(v24 + 16) = v25;
        if (v26) {
          operator delete(v26);
        }
      }

      *(void *)(v24 + 24) = v20;
      *(void *)(v24 + 32) = v3;
      atomic_store(*(unsigned __int8 *)(a2 + 17) | v24 | 8, (unint64_t *)a1);
      if ((void *)v24 != v23)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a2 + 8) + 8LL));
        id v27 = *(void **)(a2 + 8);
        if (*v27 == 1LL)
        {
          BOOL v28 = (void *)v27[2];
          v27[2] = 0LL;
          if (v28) {
            operator delete(v28);
          }
          swift_slowDealloc(v27);
        }

        else
        {
          --*v27;
        }

        *(void *)(a2 + 8) = v24;
      }

      os_unfair_lock_unlock(v22);
      uint64_t v8 = *(void *)(a2 + 8);
    }

    swift::blockOnMetadataDependency(*(void *)(a1 + 8), v40, v20, v3);
  }

  if (v9 == 63)
  {
    if (v21 > 1u) {
      goto LABEL_38;
    }
    goto LABEL_25;
  }

  if (v9 != 255) {
LABEL_52:
  }
    abort();
LABEL_38:
  if (!*(void *)(v8 + 16)
    && (unint64_t)v41 | *((void *)&v41 + 1) | (unint64_t)v42 | *((void *)&v42 + 1)
    && (char v36 = operator new(0x20uLL),
        unint64_t v37 = v42,
        *char v36 = v41,
        v36[1] = v37,
        uint64_t v38 = *(void **)(v8 + 16),
        *(void *)(v8 + 16) = v36,
        v38))
  {
    operator delete(v38);
    id v29 = *(_BYTE *)(a2 + 17);
  }

  else
  {
    id v29 = v21;
  }

    uint64_t v7 = *a1;
LABEL_26:
    swift::_swift_getClass((unint64_t)v7, a2);
    return 0LL;
  }

  if ((_DWORD)i == 773) {
    goto LABEL_25;
  }
  return result;
}

  if (dword_18C471464 == -1)
  {
LABEL_28:
    dword_18C471464 = 0;
  }

  else if (dword_18C471464)
  {
    swift::warning(0LL, "swift runtime: backtrace-on-crash is not supported on this platform.\n", v3, v4);
    goto LABEL_28;
  }

  if (v22)
  {
    BOOL v23 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    if (!v23 || v23 + 24 > *((void *)this + 2))
    {
      uint64_t v24 = 2LL * *((void *)this + 4);
      if (v24 <= 0x20) {
        uint64_t v24 = 32LL;
      }
      *((void *)this + 4) = v24;
      uint64_t v25 = v24 + 8;
      uint64_t v26 = malloc(v24 + 8);
      id v27 = (char *)v26 + v25;
      *uint64_t v26 = *((void *)this + 3);
      BOOL v23 = ((unint64_t)v26 + 15) & 0xFFFFFFFFFFFFFFF8LL;
      *((void *)this + 2) = v27;
      *((void *)this + 3) = v26;
    }

    *((void *)this + 1) = v23 + 24;
    *(_WORD *)(v23 + 16) = 44;
    *(_BYTE *)(v23 + 18) = 0;
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v23, v9, this, v13, v14);
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v23,  (swift::Demangle::__runtime::Node *)v22,  this,  v28,  v29);
    uint64_t v22 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    if (!v22 || v22 + 24 > *((void *)this + 2))
    {
      char v32 = 2LL * *((void *)this + 4);
      if (v32 <= 0x20) {
        char v32 = 32LL;
      }
      *((void *)this + 4) = v32;
      unint64_t v33 = v32 + 8;
      uint64_t v34 = malloc(v32 + 8);
      *uint64_t v34 = *((void *)this + 3);
      uint64_t v22 = ((unint64_t)v34 + 15) & 0xFFFFFFFFFFFFFFF8LL;
      *((void *)this + 2) = (char *)v34 + v33;
      *((void *)this + 3) = v34;
    }

    *((void *)this + 1) = v22 + 24;
    *(_WORD *)(v22 + 16) = 232;
    *(_BYTE *)(v22 + 18) = 0;
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v22,  (swift::Demangle::__runtime::Node *)v23,  this,  v30,  v31);
  }

  BOOL v23 = *((void *)this + 9);
  if (v23 >= *((void *)this + 8))
  {
    uint64_t v24 = 0;
  }

  else
  {
    *((void *)this + 9) = v23 + 1;
    uint64_t v24 = *(char *)(*((void *)this + 7) + v23);
  }

  HIDWORD(v26) = v24;
  LODWORD(v26) = v24 - 100;
  uint64_t v25 = v26 >> 1;
  if (v25 > 7 || ((0x93u >> v25) & 1) == 0) {
    return 0LL;
  }
  id v27 = qword_18180DDA0[v25];
  BOOL v28 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v28 || v28 + 24 > *((void *)this + 2))
  {
    id v29 = 2LL * *((void *)this + 4);
    if (v29 <= 0x20) {
      id v29 = 32LL;
    }
    *((void *)this + 4) = v29;
    id v30 = v29 + 8;
    id v31 = malloc(v29 + 8);
    *id v31 = *((void *)this + 3);
    BOOL v28 = ((unint64_t)v31 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = (char *)v31 + v30;
    *((void *)this + 3) = v31;
  }

  *((void *)this + 1) = v28 + 24;
  *(_WORD *)(v28 + 16) = 102;
  *(_BYTE *)(v28 + 18) = 4;
  *(void *)BOOL v28 = v27;
  if (v6) {
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v28,  this,  a4,  a5);
  }
  char v32 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleIndexSubset(this);
  uint64_t v35 = 0LL;
  if (v6 && v32)
  {
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v6, v32, this, v33, v34);
    uint64_t v35 = (unsigned int *)v6;
  }

  char v36 = *((void *)this + 9);
  if (v36 >= *((void *)this + 8) || *(_BYTE *)(*((void *)this + 7) + v36) != 112) {
    return 0LL;
  }
  *((void *)this + 9) = v36 + 1;
  unint64_t v37 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleIndexSubset(this);
  uint64_t v40 = 0LL;
  if (v35 && v37)
  {
    swift::Demangle::__runtime::Node::addChild(v35, v37, this, v38, v39);
    uint64_t v40 = v35;
  }

  uint64_t v41 = *((void *)this + 9);
  if (v41 >= *((void *)this + 8) || *(_BYTE *)(*((void *)this + 7) + v41) != 114) {
    return 0LL;
  }
  *((void *)this + 9) = v41 + 1;
  if (v12 && v40) {
    swift::Demangle::__runtime::Node::addChild(v40, v12, this, v38, v39);
  }
  return v40;
}

  begin = v17.__begin_;
  if (v17.__begin_)
  {
LABEL_26:
    v17.__end_ = begin;
    operator delete(begin);
  }

  return v15;
}

  *((_DWORD *)this + 3184) = v11 + 1;
  v13[v11] = 103;
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *(_DWORD *)(v6 + 12736) = v9 + 1;
  v11[v9] = 89;
  uint64_t v24 = *((unsigned __int8 *)v5 + 18);
  uint64_t v25 = (swift::Demangle::__runtime::Node **)v5;
  if ((v24 - 1) >= 2)
  {
    if (v24 == 5)
    {
      uint64_t v26 = *(swift::Demangle::__runtime::Node ***)v5;
      uint64_t v25 = *(swift::Demangle::__runtime::Node ***)v5;
      goto LABEL_33;
    }

    uint64_t v25 = 0LL;
  }

  switch(v24)
  {
    case 1:
      id v27 = (swift::Demangle::__runtime::Node **)((char *)v5 + 8);
      goto LABEL_42;
    case 2:
      id v27 = (swift::Demangle::__runtime::Node **)((char *)v5 + 16);
      goto LABEL_42;
    case 5:
      uint64_t v26 = *(swift::Demangle::__runtime::Node ***)v5;
LABEL_33:
      id v27 = &v26[*((unsigned int *)v5 + 2)];
      if (v25 != v27) {
        goto LABEL_40;
      }
      goto LABEL_42;
  }

  id v27 = 0LL;
  if (!v25)
  {
LABEL_42:
    uint64_t v16 = 0;
    uint64_t v5 = 0LL;
    uint64_t v15 = 0;
    goto LABEL_43;
  }

  *(_DWORD *)(v6 + 12736) = v9 + 1;
  v11[v9] = 122;
  uint64_t v24 = *((unsigned __int8 *)v5 + 18);
  uint64_t v25 = (swift::Demangle::__runtime::Node **)v5;
  if ((v24 - 1) >= 2)
  {
    if (v24 == 5)
    {
      uint64_t v26 = *(swift::Demangle::__runtime::Node ***)v5;
      uint64_t v25 = *(swift::Demangle::__runtime::Node ***)v5;
      goto LABEL_33;
    }

    uint64_t v25 = 0LL;
  }

  switch(v24)
  {
    case 1:
      id v27 = (swift::Demangle::__runtime::Node **)((char *)v5 + 8);
      goto LABEL_42;
    case 2:
      id v27 = (swift::Demangle::__runtime::Node **)((char *)v5 + 16);
      goto LABEL_42;
    case 5:
      uint64_t v26 = *(swift::Demangle::__runtime::Node ***)v5;
LABEL_33:
      id v27 = &v26[*((unsigned int *)v5 + 2)];
      if (v25 != v27) {
        goto LABEL_40;
      }
      goto LABEL_42;
  }

  id v27 = 0LL;
  if (!v25)
  {
LABEL_42:
    uint64_t v16 = 0;
    uint64_t v5 = 0LL;
    uint64_t v15 = 0;
    goto LABEL_43;
  }

  uint64_t v21 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    int v17 = (swift::Demangle::__runtime::Node *)((char *)v17 + 8);
    if (v17 == v20) {
      goto LABEL_28;
    }
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  *((_DWORD *)v8 + 3184) = v11 + 1;
  v13[v11] = 105;
  id v29 = v7;
  id v30 = (a4 + 1);
  if (!*(_DWORD *)a5)
  {
    id v31 = *((unsigned __int8 *)v7 + 18);
    if (v31 == 1)
    {
      char v32 = 0LL;
    }

    else
    {
      if (v31 == 5)
      {
        char v32 = *((unsigned int *)v7 + 2) - 1LL;
        unint64_t v33 = (uint64_t *)*v7;
        goto LABEL_34;
      }

      char v32 = 1LL;
    }

    unint64_t v33 = v7;
LABEL_34:
    if (*(_WORD *)(v33[v32] + 16) != 176)
    {
LABEL_46:
      if ((v31 - 1) >= 2
        && (v38 = *((_DWORD *)v7 + 2), uint64_t v7 = (uint64_t *)*v7, v38 >= 3)
        && (uint64_t v39 = (swift::Demangle::__runtime::Node *)v7[1], *((_WORD *)v39 + 8) == 290))
      {
        uint64_t v40 = applyParamLabels( v39,  (swift::Demangle::__runtime::Node *)v7[2],  (swift::Demangle::__runtime::NodeFactory *)*v8);
      }

      else
      {
        uint64_t v40 = (unsigned int *)v7[1];
      }

      int v17 = *(_DWORD *)a5;
      if (*(_DWORD *)a5) {
        return result;
      }
      uint64_t v18 = 0;
      uint64_t v7 = 0LL;
LABEL_8:
      *(_DWORD *)a5 = v18;
      *(void *)(a5 + 8) = v7;
      *(_DWORD *)(a5 + 16) = v17;
      return result;
    }

    if (v31 == 1)
    {
      uint64_t v35 = 0LL;
      char v36 = v7;
    }

    else if (v31 == 5)
    {
      unint64_t v37 = *((unsigned int *)v7 + 2);
      if (!(_DWORD)v37)
      {
        uint64_t v34 = 0LL;
        goto LABEL_44;
      }

      uint64_t v35 = v37 - 1;
      char v36 = (uint64_t *)*v7;
    }

    else
    {
      uint64_t v34 = 0LL;
      if (v31 != 2)
      {
LABEL_44:
        if (*(_DWORD *)a5) {
          return result;
        }
        id v31 = *((unsigned __int8 *)v7 + 18);
        goto LABEL_46;
      }

      uint64_t v35 = 1LL;
      char v36 = v7;
    }

    uint64_t v34 = (swift::Demangle::__runtime::Node *)v36[v35];
    goto LABEL_44;
  }

  return result;
}

  *((_DWORD *)v13 + 3184) = v16 + 1;
  v18[v16] = a3;
  if (!*(_DWORD *)a8)
  {
    uint64_t result = (char *)swift::Demangle::__runtime::CharVector::append(v38, v10, v9, *((void **)v13 + 1593));
    BOOL v23 = 0;
    uint64_t v12 = 0LL;
    uint64_t v22 = 0;
    goto LABEL_29;
  }

  return result;
}

void specialized Array.replaceSubrange<A>(_:with:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array replace: subrange start is negative",  41LL,  2,  "Swift/Array.swift",  17LL,  2,  0x6D4uLL,  0);
  }
  uint64_t v11 = a1;
  uint64_t v12 = *v4;
  if (!((unint64_t)*v4 >> 62))
  {
    if (*(void *)((v12 & 0xFFFFFFFFFFFFF8LL) + 0x10) >= a2) {
      goto LABEL_4;
    }
LABEL_33:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array replace: subrange extends past the end",  44LL,  2,  "Swift/Array.swift",  17LL,  2,  0x6D7uLL,  0);
  }

  if (v12 < 0) {
    uint64_t v26 = (void *)*v4;
  }
  else {
    uint64_t v26 = (void *)(v12 & 0xFFFFFFFFFFFFFF8LL);
  }
LABEL_4:
  uint64_t v13 = a2 - v11;
  if (__OFSUB__(a2, v11))
  {
    __break(1u);
    goto LABEL_35;
  }

  uint64_t v7 = a4 - v13;
  if (__OFSUB__(a4, v13))
  {
LABEL_35:
    __break(1u);
LABEL_36:
    if (v6 < 0) {
      id v27 = (void *)v6;
    }
    else {
      id v27 = (void *)(v6 & 0xFFFFFFFFFFFFFF8LL);
    }
    BOOL v28 = (char *)objc_msgSend(v27, sel_count);
    uint64_t v15 = &v28[v7];
    if (!__OFADD__(v28, v7)) {
      goto LABEL_8;
    }
LABEL_41:
    __break(1u);
LABEL_42:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
  }

  uint64_t v6 = *v4;
  unint64_t v5 = (unint64_t)*v4 >> 62;
  uint64_t v35 = a4;
  if (v5) {
    goto LABEL_36;
  }
  uint64_t v14 = *(void *)((v6 & 0xFFFFFFFFFFFFF8LL) + 0x10);
  uint64_t v15 = (char *)(v14 + v7);
  if (__OFADD__(v14, v7)) {
    goto LABEL_41;
  }
LABEL_8:
  uint64_t v16 = v7;
  __src = a3;
  int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(v6);
  *uint64_t v4 = v6;
  if (v5) {
    int v18 = 0;
  }
  else {
    int v18 = isUniquelyReferenced_nonNull_bridgeObject;
  }
  if (v18 == 1)
  {
    uint64_t v19 = v6 & 0xFFFFFFFFFFFFFF8LL;
  }

  if (v5) {
    goto LABEL_52;
  }
  for (uint64_t i = *(char **)((v6 & 0xFFFFFFFFFFFFF8) + 0x10); ; uint64_t i = (char *)objc_msgSend(v33, sel_count))
  {
    else {
      uint64_t v21 = (uint64_t)i;
    }
    uint64_t v6 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v18, v21, 1, v6);
    *uint64_t v4 = v6;
    uint64_t v19 = v6 & 0xFFFFFFFFFFFFFF8LL;
LABEL_19:
    uint64_t v15 = (char *)v35;
    if (v13 < 0) {
      goto LABEL_42;
    }
    uint64_t v11 = v19 + 32 + 8 * v11;
    swift_arrayDestroy(v11, v13, (uint64_t)&unk_189B8D230);
    if (!v16) {
      goto LABEL_25;
    }
    uint64_t v13 = v11 + 8 * v35;
    LOBYTE(v18) = v19 + 32 + 8 * a2;
    uint64_t v22 = *(void *)(v19 + 16);
    if (__OFSUB__(v22, a2)) {
      goto LABEL_50;
    }
    specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v19 + 32 + 8 * a2),  v22 - a2,  (char *)(v11 + 8 * v35));
    uint64_t v23 = *(void *)(v19 + 16);
    BOOL v24 = __OFADD__(v23, v16);
    uint64_t v25 = (char *)(v23 + v16);
    if (!v24) {
      goto LABEL_24;
    }
LABEL_51:
    __break(1u);
LABEL_52:
    if (v6 < 0) {
      unint64_t v33 = (void *)v6;
    }
    else {
      unint64_t v33 = (void *)(v6 & 0xFFFFFFFFFFFFFF8LL);
    }
  }

  if (v6 >= 0) {
    id v29 = (void *)v19;
  }
  else {
    id v29 = (void *)v6;
  }
  id v30 = v29;
  id v31 = objc_msgSend(v29, sel_count);
  if (__OFSUB__(v31, a2))
  {
LABEL_50:
    __break(1u);
    goto LABEL_51;
  }

  specialized UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(v19 + 32 + 8 * a2),  (uint64_t)v31 - a2,  (char *)(v11 + 8 * v35));
  char v32 = (char *)objc_msgSend(v30, sel_count);
  uint64_t v25 = &v32[v16];
  if (__OFADD__(v32, v16))
  {
    __break(1u);
    goto LABEL_50;
  }

uint64_t Array.replaceSubrange<A>(_:with:)( uint64_t a1, Swift::Int a2, void (*a3)(void, void, void), uint64_t a4)
{
  unint64_t v5 = v4;
  uint64_t v9 = *(uint64_t **)(a4 + 16);
  uint64_t v10 = *(v9 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v73 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v82 = v13;
  uint64_t v83 = v14;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v13,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  unint64_t v16 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v17 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v19 = (char *)&v73 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  uint64_t v86 = a1;
  if (a1 < 0)
  {
    LODWORD(v71) = 0;
    unint64_t v70 = 1748LL;
    LOBYTE(WitnessTable) = 2;
    int64_t v63 = "Array replace: subrange start is negative";
    uint64_t v64 = 41LL;
    goto LABEL_56;
  }

  uint64_t v77 = (char *)&v73 - v21;
  uint64_t v78 = v20;
  if (Array._getCount()() < a2)
  {
    LODWORD(v71) = 0;
    unint64_t v70 = 1751LL;
    LOBYTE(WitnessTable) = 2;
    int64_t v63 = "Array replace: subrange extends past the end";
    uint64_t v64 = 44LL;
LABEL_56:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  v63,  v64,  2,  "Swift/Array.swift",  17LL,  WitnessTable,  v70,  v71);
  }

  uint64_t v22 = a2 - v86;
  if (__OFSUB__(a2, v86))
  {
    __break(1u);
    goto LABEL_58;
  }

  Swift::Int v84 = a2;
  uint64_t v81 = v10;
  Swift::String v76 = v12;
  uint64_t v23 = a3;
  uint64_t v24 = (*((uint64_t (**)(uint64_t))v82 + 14))(v83);
  uint64_t v25 = (char *)(v24 - v22);
  if (__OFSUB__(v24, v22))
  {
LABEL_58:
    __break(1u);
    goto LABEL_59;
  }

  uint64_t v26 = v24;
  char v75 = v19;
  Swift::Int v27 = Array._getCount()();
  uint64_t v30 = (uint64_t)&v25[v27];
  if (__OFADD__(v27, v25))
  {
LABEL_59:
    __break(1u);
LABEL_60:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
  }

  Swift::String v85 = v25;
  unint64_t v74 = v16;
  uint64_t v79 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)v9, v28, v29);
  LOBYTE(v16) = _ArrayBuffer.beginCOWMutation()();
  if ((v16 & 1) != 0)
  {
    uint64_t v31 = *v5;
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
    uint64_t v33 = v31 & 0xFFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v33 = v31;
    }
    if (v30 <= *(void *)(v33 + 24) >> 1)
    {
      uint64_t v34 = v31 & 0xFFFFFFFFFFFFFF8LL;
      goto LABEL_21;
    }
  }

  uint64_t v31 = *v5;
  if (!_swift_isClassOrObjCExistentialType((uint64_t)v9, v9)
    || (v31 & 0x8000000000000000LL) == 0 && (v31 & 0x4000000000000000LL) == 0)
  {
    BOOL v35 = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
    uint64_t v36 = v31 & 0xFFFFFFFFFFFFF8LL;
    if (!v35) {
      uint64_t v36 = v31;
    }
    id v37 = *(id *)(v36 + 16);
    goto LABEL_17;
  }

  while (2)
  {
    if (v31 < 0) {
      unint64_t v68 = (void *)v31;
    }
    else {
      unint64_t v68 = (void *)(v31 & 0xFFFFFFFFFFFFFF8LL);
    }
    id v37 = objc_msgSend(v68, sel_count);
LABEL_17:
    else {
      uint64_t v38 = (uint64_t)v37;
    }
    uint64_t v31 = _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v16 & 1, v38, 1, v31, v9);
    *unint64_t v5 = v31;
    uint64_t v34 = v31 & 0xFFFFFFFFFFFFFF8LL;
LABEL_21:
    else {
      uint64_t v39 = v31;
    }
    uint64_t v40 = v83;
    if (v22 < 0) {
      goto LABEL_60;
    }
    uint64_t v41 = (void *)v34;
    unint64_t v5 = (uint64_t *)(v39 + ((*(unsigned __int8 *)(v81 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v81 + 80)));
    uint64_t v30 = *(void *)(v81 + 72);
    unint64_t v16 = (unint64_t)v5 + v30 * v86;
    uint64_t v42 = v22;
    uint64_t v22 = v26;
    uint64_t v73 = v30 * v26;
    v80 = (char *)(v16 + v30 * v26);
    swift_arrayDestroy(v16, v42, (uint64_t)v9);
    uint64_t v26 = (uint64_t)v23;
    if (!v85) {
      goto LABEL_45;
    }
    if (!_swift_isClassOrObjCExistentialType((uint64_t)v9, v9)
      || (v31 & 0x8000000000000000LL) == 0 && (v31 & 0x4000000000000000LL) == 0)
    {
      else {
        uint64_t v44 = v31;
      }
      uint64_t v45 = *(_BYTE **)(v44 + 16);
      goto LABEL_33;
    }

    while (1)
    {
      if (v31 < 0) {
        char v65 = (void *)v31;
      }
      else {
        char v65 = v41;
      }
      uint64_t v45 = objc_msgSend(v65, sel_count);
LABEL_33:
      uint64_t v23 = (void (*)(void, void, void))v84;
      if (__OFSUB__(v45, v84))
      {
        __break(1u);
        goto LABEL_62;
      }

      UnsafeMutablePointer.moveInitialize(from:count:)((char *)v5 + v30 * v84, (uint64_t)&v45[-v84], v80, (uint64_t)v9);
      else {
        uint64_t v46 = v31;
      }
      uint64_t v47 = *(void *)(v46 + 16);
      unint64_t v5 = (uint64_t *)&v85[v47];
      if (!__OFADD__(v47, v85)) {
        goto LABEL_41;
      }
LABEL_62:
      __break(1u);
    }

    if (v31 < 0) {
      unint64_t v66 = (void *)v31;
    }
    else {
      unint64_t v66 = v41;
    }
    id v67 = objc_msgSend(v66, sel_count);
    unint64_t v5 = (uint64_t *)&v85[(void)v67];
    if (__OFADD__(v67, v85))
    {
      __break(1u);
      continue;
    }

    break;
  }

LABEL_41:
  BOOL v43 = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
  if (v43) {
    uint64_t v48 = (uint64_t)v41;
  }
  else {
    uint64_t v48 = v31;
  }
  *(void *)(v48 + 16) = v5;
LABEL_45:
  if (v22 <= 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v40 - 8) + 8LL))(v26, v40);
  }
  uint64_t v86 = v30;
  uint64_t v49 = (uint64_t)v82;
  MEMORY[0x1895F8858](v43);
  uint64_t v50 = v79;
  *(&v73 - 6) = v79;
  *(&v73 - 5) = v40;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v50, v51);
  unint64_t v70 = v49;
  uint64_t v71 = v22;
  unint64_t v72 = v16;
  (*(void (**)(void *__return_ptr, char *(*)(char *, uint64_t), uint64_t *, void *, uint64_t))(*(void *)(v49 + 8) + 72LL))( v87,  partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:),  &v73 - 8,  &unk_189B8D178,  v40);
  if ((v87[0] & 1) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v40 - 8) + 8LL))(v26, v40);
  }
  uint64_t v52 = v77;
  (*(void (**)(uint64_t, uint64_t))(v49 + 64))(v40, v49);
  uint64_t v53 = v40;
  uint64_t v54 = v76;
  int64_t v56 = v80;
  uint64_t v55 = v81;
  if (v73 >= 1)
  {
    int64_t v57 = *(char **)(v49 + 80);
    Swift::Int v84 = *(void *)(v49 + 192);
    Swift::String v85 = v57;
    do
    {
      char v58 = (void (*)(void *, void))((uint64_t (*)(void *, char *, uint64_t, uint64_t))v85)( v87,  v52,  v53,  v49);
      (*(void (**)(char *))(v55 + 16))(v54);
      v58(v87, 0LL);
      (*(void (**)(unint64_t, char *, uint64_t *))(v55 + 32))(v16, v54, v9);
      v16 += v86;
      ((void (*)(char *, uint64_t, uint64_t))v84)(v52, v53, v49);
    }

    while (v16 < (unint64_t)v56);
  }

  unint64_t v60 = v74;
  uint64_t v59 = (uint64_t)v75;
  uint64_t v61 = v78;
  (*(void (**)(char *, char *, uint64_t))(v74 + 32))(v75, v52, v78);
  _expectEnd<A>(of:is:)(v26, v59, v53, v49);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v53 - 8) + 8LL))(v26, v53);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v60 + 8))(v59, v61);
}

    if ((v84 & 1) != 0)
    {
      uint64_t v71 = a5;
      uint64_t v73 = v86;
      unint64_t v72 = v38;
    }

    else
    {
      swift_bridgeObjectRetain(a8, v32, v33, v34);
      swift_retain(a10, v74, v75, v76);
      v77._Swift::UInt64 rawBits = rawBits;
      uint64_t v78 = specialized LazyMapSequence<>.subscript.getter(v77, a7, a8, a9);
      swift_release((uint64_t)a10);
      swift_bridgeObjectRelease(a8);
      uint64_t v79 = specialized RandomAccessCollection<>.distance(from:to:)(0LL, v83, v78);
      id v67 = __OFADD__(v28, v79);
      v28 += v79;
      uint64_t v71 = a5;
      unint64_t v72 = v38;
      if (v67)
      {
LABEL_50:
        __break(1u);
        goto LABEL_51;
      }

      uint64_t v73 = v86;
    }

    if ((specialized static Comparable.<= infix(_:_:)(v72, v85, v89, v73, v71, v90) & 1) != 0) {
      return v28;
    }
    id v67 = __OFSUB__(0LL, v28);
    uint64_t v28 = -(uint64_t)v28;
    if (!v67) {
      return v28;
    }
LABEL_51:
    __break(1u);
    goto LABEL_52;
  }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/CollectionOfOne.swift",  27LL,  2,  0x83uLL,  0);
    }

    unint64_t v70 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v70, v132);
    *((_OWORD *)inited + 1) = v127;
    inited[7] = v6;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v24(boxed_opaque_existential_0Tm, v131, v6);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v135);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v23 = 0;
    uint64_t v22 = *((void *)&v134 + 1);
    uint64_t v15 = (unint64_t *)v134;
    uint64_t v18 = *(void *)(v134 + 16);
  }

  while (*((void *)&v134 + 1) != v18);
  unint64_t v16 = v135;
  uint64_t v17 = v136;
LABEL_47:
  swift_release((uint64_t)v15);
  Swift::String v76 = HIBYTE(v17) & 0xF;
  uint64_t v77 = v16 & 0xFFFFFFFFFFFFLL;
  if ((v17 & 0x2000000000000000LL) != 0) {
    uint64_t v78 = HIBYTE(v17) & 0xF;
  }
  else {
    uint64_t v78 = v16 & 0xFFFFFFFFFFFFLL;
  }
  if (!v78 && (v16 & ~v17 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v17);
    return 93LL;
  }

  if ((v17 & 0x2000000000000000LL) != 0 && v76 != 15)
  {
    if (v76 < 8) {
      unint64_t v16 = (93LL << (8 * (HIBYTE(v17) & 7u))) | ((-255LL << (8 * (HIBYTE(v17) & 7u))) - 1) & v16;
    }
    goto LABEL_56;
  }

  swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v74, v75);
  if ((v17 & 0x1000000000000000LL) != 0)
  {
    v115 = String.UTF8View._foreignCount()();
    uint64_t v79 = v115 + 1;
    if (!__OFADD__(v115, 1LL)) {
      goto LABEL_59;
    }
    goto LABEL_107;
  }

  uint64_t v40 = __OFADD__(v78, 1LL);
  uint64_t v79 = v78 + 1;
  if (v40)
  {
LABEL_107:
    __break(1u);
    goto LABEL_108;
  }

    id v67 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v67, v128);
    *((_OWORD *)inited + 1) = v125;
    inited[7] = v6;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v24(boxed_opaque_existential_0Tm, v127, v6);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v131);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    uint64_t v23 = 0;
    uint64_t v22 = *((void *)&v130 + 1);
    uint64_t v15 = (unint64_t *)v130;
    uint64_t v18 = *(void *)(v130 + 16);
  }

  while (*((void *)&v130 + 1) != v18);
  unint64_t v16 = v131;
  uint64_t v17 = v132;
LABEL_47:
  swift_release((uint64_t)v15);
  uint64_t v73 = HIBYTE(v17) & 0xF;
  unint64_t v74 = v16 & 0xFFFFFFFFFFFFLL;
  if ((v17 & 0x2000000000000000LL) != 0) {
    char v75 = HIBYTE(v17) & 0xF;
  }
  else {
    char v75 = v16 & 0xFFFFFFFFFFFFLL;
  }
  if (!v75 && (v16 & ~v17 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v17);
    return 93LL;
  }

  if ((v17 & 0x2000000000000000LL) != 0 && v73 != 15)
  {
    if (v73 < 8) {
      unint64_t v16 = (93LL << (8 * (HIBYTE(v17) & 7u))) | ((-255LL << (8 * (HIBYTE(v17) & 7u))) - 1) & v16;
    }
    goto LABEL_56;
  }

  swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v71, v72);
  if ((v17 & 0x1000000000000000LL) != 0)
  {
    uint64_t v112 = String.UTF8View._foreignCount()();
    Swift::String v76 = v112 + 1;
    if (!__OFADD__(v112, 1LL)) {
      goto LABEL_59;
    }
    goto LABEL_107;
  }

  uint64_t v38 = __OFADD__(v75, 1LL);
  Swift::String v76 = v75 + 1;
  if (v38)
  {
LABEL_107:
    __break(1u);
    goto LABEL_108;
  }

      uint64_t v19 = 0LL;
      uint64_t v20 = 1LL;
      goto LABEL_42;
    }

    if ((v4 & 0x1000000000000000LL) != 0)
    {
      uint64_t v24 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v24 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
      uint64_t v9 = v29;
    }

    if (v21 + 1 == v9) {
      goto LABEL_41;
    }
    if (v24)
    {
      uint64_t v25 = *(unsigned __int16 *)&v24[v21];
      if (v25 == 2573 || (v25 & 0x80808080) != 0) {
        goto LABEL_33;
      }
      goto LABEL_41;
    }

      uint64_t v50 = _StringGuts.nativeUnusedCapacity.getter(v11, v12);
      uint64_t v53 = (v51 & 1) == 0 && v50 >= 0;
      if ((v17 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v53) {
          goto LABEL_59;
        }
      }

      else if (v53)
      {
LABEL_58:
        _StringGuts.grow(_:)(v16);
LABEL_59:
        swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
        v338 = 0uLL;
        char v58 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v338, 0LL);
        _StringGuts.appendInPlace(_:isASCII:)(v58, v59, 1);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        goto LABEL_60;
      }

      uint64_t v54 = _StringGuts.nativeCapacity.getter(v11, v12);
      if ((v55 & 1) != 0) {
        int64_t v56 = 0LL;
      }
      else {
        int64_t v56 = v54;
      }
      if (v56 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_280;
      }

      int64_t v57 = 2 * v56;
      if (v57 > v16) {
        unint64_t v16 = v57;
      }
      goto LABEL_58;
    }

        __break(1u);
        goto LABEL_42;
      }

  if ((_DWORD)a2) {
LABEL_42:
  }
    a7(a1, a2, a6, a4);
}

  if ((v7 & 0x20000) != 0) {
    uint64_t v19 = "false";
  }
  else {
    uint64_t v19 = "true";
  }
  InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  541,  "installCommonValueWitnesses",  "Uncommon layout case, flags.isInlineStorage=%s",  v19);
  if ((v7 & 0x20000) != 0)
  {
    unint64_t v16 = (void **)(a1 + 104);
    uint64_t v17 = *(_DWORD *)(a1 + 128);
    if (v17) {
      goto LABEL_13;
    }
  }

  else
  {
    unint64_t v16 = (void **)(a1 + 72);
    uint64_t v17 = *(_DWORD *)(a1 + 96);
    if (v17) {
      goto LABEL_13;
    }
  }

  *a3 = *v16;
  unint64_t v16 = (void **)(a1 + 40);
  uint64_t v17 = *(_DWORD *)(a1 + 64);
  if (v17)
  {
LABEL_13:
    if (v17 != 1) {
      unint64_t v16 = 0LL;
    }
    goto LABEL_16;
  }

  uint64_t v14 = (void **)(a1 + 8);
  uint64_t v20 = *(_DWORD *)(a1 + 32);
  if (v20)
  {
    uint64_t v18 = v20 == 1;
LABEL_35:
    if (v18) {
      unint64_t v16 = v14;
    }
    else {
      unint64_t v16 = 0LL;
    }
    if ((*((char *)v16 + 23) & 0x80000000) == 0)
    {
LABEL_39:
      *(_OWORD *)a4 = *(_OWORD *)v16;
      *(void *)(a4 + 16) = v16[2];
      goto LABEL_40;
    }

  operator delete(v66.__r_.__value_.__l.__data_);
  if (((char)v63.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_27:
LABEL_43:
    operator delete(v65.__r_.__value_.__l.__data_);
    goto LABEL_44;
  }

  uint64_t v29 = 0;
  if (*(unsigned __int16 *)(a2 + 16) > 0xD9u)
  {
    BOOL v43 = v10 - 218;
    if (v43 > 0x24 || ((1LL << v43) & 0x1000000005LL) == 0)
    {
LABEL_63:
      ++a4;
      uint64_t v29 = 1;
    }
  }

  else if (((v10 - 117) > 0x3E || ((1LL << (v10 - 117)) & 0x6000000000000101LL) == 0) {
         && v10 != 33
  }
         && v10 != 70)
  {
    goto LABEL_63;
  }

  uint64_t v44 = *(void *)(*(void *)a3 + 8 * v5);
  if (a4 < v7)
  {
    uint64_t v45 = *v28;
    if (*((_WORD *)*v28 + 8) != 71)
    {
      uint64_t v51 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleBoundGenericArgs( a1,  v45,  a3);
LABEL_84:
      if (v51)
      {
LABEL_85:
        uint64_t v59 = *(_WORD *)(v8 + 16);
        unint64_t v60 = (*((void *)a1 + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v60 || v60 + 24 > *((void *)a1 + 2))
        {
          uint64_t v61 = 2LL * *((void *)a1 + 4);
          if (v61 <= 0x20) {
            uint64_t v61 = 32LL;
          }
          *((void *)a1 + 4) = v61;
          unint64_t v62 = v61 + 8;
          int64_t v63 = malloc(v61 + 8);
          uint64_t v64 = (char *)v63 + v62;
          *int64_t v63 = *((void *)a1 + 3);
          unint64_t v60 = ((unint64_t)v63 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)a1 + 2) = v64;
          *((void *)a1 + 3) = v63;
        }

        *((void *)a1 + 1) = v60 + 24;
        *(_WORD *)(v60 + 16) = v59;
        *(_BYTE *)(v60 + 18) = 0;
        swift::Demangle::__runtime::Node::addChild((unsigned int *)v60, v51, a1, v49, v50);
        for (uint64_t i = 1; ; uint64_t i = v69 + 1)
        {
          id v67 = *(unsigned __int8 *)(v8 + 18);
          switch((_DWORD)v67)
          {
            case 1:
              unint64_t v68 = *(unsigned __int8 *)(v8 + 18);
              break;
            case 5:
              unint64_t v68 = *(unsigned int *)(v8 + 8);
              break;
            case 2:
              unint64_t v68 = 2LL;
              break;
            default:
              goto LABEL_111;
          }

          uint64_t v69 = i;
          if (v68 <= i)
          {
LABEL_111:
            uint64_t v8 = v60;
            goto LABEL_112;
          }

          unint64_t v70 = v67 - 1;
          if ((_DWORD)v67 != 1)
          {
            if ((_DWORD)v67 == 5)
            {
              goto LABEL_107;
            }

            id v67 = 2LL;
          }

          if (v67 <= v69) {
            continue;
          }
LABEL_107:
          uint64_t v71 = v8;
          if (v70 >= 2) {
            uint64_t v71 = *(void *)v8;
          }
          unint64_t v72 = *(swift::Demangle::__runtime::Node **)(v71 + 8 * v69);
          if (v72) {
            swift::Demangle::__runtime::Node::addChild((unsigned int *)v60, v72, a1, a4, a5);
          }
        }
      }

      return 0LL;
    }

    uint64_t v46 = *((unsigned __int8 *)v45 + 18);
    uint64_t v47 = *v28;
    if (v46 != 2)
    {
      if (v46 != 5 || *((_DWORD *)v45 + 2) < 2u)
      {
        uint64_t v48 = 0LL;
LABEL_73:
        uint64_t v52 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleBoundGenericArgs( a1,  v48,  a3);
        uint64_t v54 = *((unsigned __int8 *)v45 + 18);
        uint64_t v55 = (swift::Demangle::__runtime::Node **)v45;
        if ((v54 - 1) >= 2)
        {
          if (v54 != 5 || !*((_DWORD *)v45 + 2))
          {
            int64_t v56 = 0LL;
            goto LABEL_79;
          }

          uint64_t v55 = *(swift::Demangle::__runtime::Node ***)v45;
        }

        int64_t v56 = *v55;
LABEL_79:
        int64_t v57 = (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren(a1, 71, v56, v52, v53);
        uint64_t v51 = (swift::Demangle::__runtime::Node *)v57;
        if (*((_BYTE *)v45 + 18) == 5 && *((_DWORD *)v45 + 2) == 3)
        {
          if (v57)
          {
            char v58 = *(swift::Demangle::__runtime::Node **)(*(void *)v45 + 16LL);
            if (v58)
            {
              swift::Demangle::__runtime::Node::addChild(v57, v58, a1, v49, v50);
              goto LABEL_85;
            }
          }
        }

        goto LABEL_84;
      }

      uint64_t v47 = *(swift::Demangle::__runtime::Node **)v45;
    }

    uint64_t v48 = *((void *)v47 + 1);
    goto LABEL_73;
  }

  uint64_t v19 = v12;
  if ((v11 - 1) >= 2)
  {
    uint64_t v20 = 0;
    uint64_t v21 = *(swift::Demangle::__runtime::Node **)v5;
  }

  else
  {
    uint64_t v20 = 1;
    uint64_t v21 = v5;
  }

  if (*(_WORD *)(*((void *)v21 + v12) + 16LL) == 67)
  {
    if ((_DWORD)v11 == 1)
    {
      if (!v12) {
        goto LABEL_53;
      }
    }

    else
    {
      if ((_DWORD)v11 != 5)
      {
        if ((_DWORD)v11 != 2 || v12 >= 2uLL) {
          goto LABEL_51;
        }
LABEL_53:
        uint64_t v23 = v5;
        if ((v20 & 1) == 0) {
          uint64_t v23 = *(swift::Demangle::__runtime::Node **)v5;
        }
        uint64_t v22 = (swift::Demangle::__runtime::Node *)*((void *)v23 + v12);
        goto LABEL_56;
      }
    }

  if (v19 == v21) {
    goto LABEL_45;
  }
  uint64_t v22 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    if (++v19 == v21) {
      goto LABEL_45;
    }
  }

  if (v13)
  {
LABEL_42:
    BOOL v43 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( *((void **)this + 5),  68,  (char)v13);
    swift::Demangle::__runtime::Node::addChild( v32,  v43,  *((swift::Demangle::__runtime::NodeFactory **)this + 5),  v44,  v45);
  }

void (*Array.subscript.modify( void *a1, Swift::Int a2, Swift::Int a3, uint64_t a4))(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[6] = a4;
  v9[7] = v4;
  v9[4] = a2;
  v9[5] = a3;
  int64_t v10 = *v4;
  uint64_t v11 = *(uint64_t **)(a4 + 16);
  Array._checkIndex(_:)(a2);
  Array._checkIndex(_:)(a3);
  *uint64_t v9 = _ArrayBuffer.subscript.getter(a2, a3, v10, v11);
  v9[1] = v12;
  v9[2] = v13;
  v9[3] = v14;
  return Array.subscript.modify;
}

void Array.subscript.modify(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance [A]@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance [A]( a1,  a2,  a3,  specialized Array.index(_:offsetBy:limitedBy:),  a4);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance [A]( uint64_t a1, Swift::Int *a2, uint64_t a3)
{
  unint64_t v5 = Array.subscript.modify((uint64_t)v8, *a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8LL) + 40LL))(v6, a1);
  return ((uint64_t (*)(_BYTE *, void))v5)(v8, 0LL);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance [A]( void *a1, Swift::Int *a2, uint64_t a3))()
{
  uint64_t v6 = malloc(0x28uLL);
  *a1 = v6;
  v6[4] = Array.subscript.modify((uint64_t)v6, *a2, a3);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance [A]( void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for MutableCollection.subscript.setter in conformance [A]( a1,  a2,  a3,  a4,  (uint64_t (*)(void, void, void, void, void, void, uint64_t))Array.subscript.setter);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance [A]( void *a1, Swift::Int *a2, uint64_t a3))(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  v7[4] = v3;
  v7[5] = a3;
  Swift::Int v9 = *a2;
  Swift::Int v8 = a2[1];
  v7[6] = v9;
  v7[7] = v8;
  int64_t v10 = *v3;
  uint64_t v11 = *(uint64_t **)(a3 + 16);
  Array._checkIndex(_:)(v9);
  Array._checkIndex(_:)(v8);
  *uint64_t v7 = _ArrayBuffer.subscript.getter(v9, v8, v10, v11);
  v7[1] = v12;
  v7[2] = v13;
  v7[3] = v14;
  return protocol witness for MutableCollection.subscript.modify in conformance [A];
}

void protocol witness for MutableCollection.subscript.modify in conformance [A]( void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
}

void *protocol witness for MutableCollection.partition(by:) in conformance [A]@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void *protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance [A]@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return Array.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a3, a2, a4);
}

void *Array._withUnsafeMutableBufferPointerIfSupported<A>(_:)@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return Array._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3, a4);
}

{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  void v18[2];
  uint64_t v19;
  uint64_t v19 = a3;
  Array._makeMutableAndUnique()();
  Swift::Int v9 = *v4;
  int64_t v10 = *(uint64_t **)(a2 + 16);
  else {
    uint64_t v11 = v9;
  }
  uint64_t v12 = *(void *)(v11 + 16);
  else {
    uint64_t v13 = v9;
  }
  uint64_t v14 = *(unsigned __int8 *)(*(v10 - 1) + 80);
  uint64_t v15 = v13 + ((v14 + 32) & ~v14);
  v18[0] = v15;
  v18[1] = v12;
  a1(v18);
  if (v5) {
    return $defer #1 <A><A1>() in Array.withUnsafeMutableBufferPointer<A>(_:)(v18, v15, v12);
  }
  uint64_t v17 = v19;
  $defer #1 <A><A1>() in Array.withUnsafeMutableBufferPointer<A>(_:)(v18, v15, v12);
  return (void *)(*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v17 - 8) + 56LL))( a4,  0LL,  1LL,  v17);
}

void *Array.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return Array._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3, a4);
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance [A]@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if (__OFSUB__(*result, 1LL)) {
    __break(1u);
  }
  else {
    *a2 = *result - 1LL;
  }
  return result;
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance [A]@<X0>( void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t (*a4)(void, uint64_t, void)@<X5>, uint64_t a5@<X8>)
{
  uint64_t result = a4(*a1, a2, *a3);
  *(void *)a5 = result;
  *(_BYTE *)(a5 + 8) = v7 & 1;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance [A]( void *a1, void *a2)
{
  BOOL v2 = __OFSUB__(*a2, *a1);
  uint64_t result = *a2 - *a1;
  if (v2) {
    __break(1u);
  }
  return result;
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance [A]@<X0>(Swift::Int *a1@<X8>)
{
  Swift::Int result = Array.count.getter();
  *a1 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance [A]( void *a1, unint64_t *a2, uint64_t a3))()
{
  char v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = Array.subscript.read(v7, *a2, *v3, *(uint64_t **)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void (*Array.subscript.read( void *a1, unint64_t a2, uint64_t a3, uint64_t *a4))(void *a1)
{
  uint64_t v8 = *(a4 - 1);
  a1[1] = a4;
  a1[2] = v8;
  size_t v9 = *(void *)(v8 + 64);
  int64_t v10 = malloc(v9);
  a1[3] = v10;
  char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
  char v12 = ((a3 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
  Array._checkSubscript(_:wasNativeTypeChecked:)( a2,  (a3 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
  if ((v12 & 1) != 0)
  {
    (*(void (**)(void *, unint64_t, uint64_t *))(v8 + 16))( v10,  a3 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80))
    + *(void *)(v8 + 72) * a2,
      a4);
  }

  else
  {
    id v14 = _ArrayBuffer._getElementSlowPath(_:)(a2, a3, a4);
    uint64_t v15 = v14;
    if (v9 != 8)
    {
      swift_unknownObjectRelease(v14);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    *a1 = v14;
    (*(void (**)(void *, void *, uint64_t *))(v8 + 16))(v10, a1, a4);
    swift_unknownObjectRelease(v15);
  }

  return Array.subscript.read;
}

void Array.subscript.read(void *a1)
{
  BOOL v1 = (void *)a1[3];
  (*(void (**)(void *, void))(a1[2] + 8LL))(v1, a1[1]);
  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance [A]@<X0>( Swift::Int *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = Array.subscript.getter(*a1, a1[1], *v3, *(uint64_t **)(a2 + 16));
  *a3 = result;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance [A]@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

Swift::Int protocol witness for Collection.count.getter in conformance [A]()
{
  return Array.count.getter();
}

void protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance [A](uint64_t a1@<X8>)
{
  *(void *)a1 = 0LL;
  *(_WORD *)(a1 + 8) = 256;
}

void *protocol witness for Collection.index(after:) in conformance [A]@<X0>( void *result@<X0>, void *a2@<X8>)
{
  if (__OFADD__(*result, 1LL)) {
    __break(1u);
  }
  else {
    *a2 = *result + 1LL;
  }
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance [A](uint64_t a1)
{
  return Array._copyToContiguousArray()(*v1, *(uint64_t **)(a1 + 16));
}

uint64_t Array._copyToContiguousArray()(unint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    if ((a1 & 0x8000000000000000LL) != 0 || (a1 & 0x4000000000000000LL) != 0)
    {
      unint64_t v13 = a1;
      uint64_t v10 = type metadata accessor for Array(0LL, (uint64_t)a2, v5, (uint64_t)v6);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v10, v11);
      uint64_t v8 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v13, v10, WitnessTable);
      swift_bridgeObjectRelease(a1);
    }

    else
    {
      swift_bridgeObjectRetain(a1, v4, v5, v6);
      BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
      swift_bridgeObjectRelease(a1);
      if (isClassOrObjCExistentialType) {
        return a1 & 0xFFFFFFFFFFFFFF8LL;
      }
      else {
        return a1;
      }
    }
  }

  else if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    return a1 & 0xFFFFFFFFFFFFFF8LL;
  }

  else
  {
    return a1;
  }

  return (uint64_t)v8;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance [A]( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance _ArrayBuffer<A>( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(uint64_t, uint64_t, void, void))Array._copyContents(initializing:));
}

unint64_t Array._copyContents(initializing:)( char *a1, Swift::Int a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(a4 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (Array._getCount()())
  {
    if (v7)
    {
      if (Array._getCount()() > a2) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x694uLL,  0);
      }
      swift_bridgeObjectRetain(a3, v11, v12, v13);
      if (!_swift_isClassOrObjCExistentialType((uint64_t)a4, a4)
        || (a3 & 0x8000000000000000LL) == 0 && (a3 & 0x4000000000000000LL) == 0)
      {
        BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
        uint64_t v15 = a3 & 0xFFFFFFFFFFFFFF8LL;
        if (!isClassOrObjCExistentialType) {
          uint64_t v15 = a3;
        }
        unint64_t v16 = (char *)(v15 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80)));
        Swift::Int v17 = Array._getCount()();
        UnsafeMutablePointer.initialize(from:count:)(v16, v17, v7, (uint64_t)a4);
        if (!_swift_isClassOrObjCExistentialType((uint64_t)a4, a4)
          || (a3 & 0x8000000000000000LL) == 0 && (a3 & 0x4000000000000000LL) == 0)
        {
          _swift_isClassOrObjCExistentialType((uint64_t)a4, a4);
        }

        goto LABEL_13;
      }

      swift_bridgeObjectRelease(a3);
      v32[0] = 0LL;
      v32[1] = a3;
      swift_bridgeObjectRetain(a3, v22, v23, v24);
      if (!Array._getCount()())
      {
LABEL_13:
        swift_bridgeObjectRelease(a3);
        swift_bridgeObjectRetain(a3, v18, v19, v20);
        Array._getCount()();
        swift_bridgeObjectRelease(a3);
        return a3;
      }

      uint64_t v28 = type metadata accessor for Array(0LL, (uint64_t)a4, v25, v26);
      while (1)
      {
        swift_getWitnessTable(&protocol conformance descriptor for [A], v28, v27);
        uint64_t v29 = protocol witness for Collection.subscript.read in conformance [A](v31, v32, v28);
        (*(void (**)(char *))(v8 + 16))(v10);
        ((void (*)(void *, void))v29)(v31, 0LL);
        unint64_t v30 = v32[0] + 1;
        if (__OFADD__(v32[0], 1LL)) {
          break;
        }
        ++v32[0];
        (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v7, v10, a4);
        v7 += *(void *)(v8 + 72);
        if (v30 == Array._getCount()()) {
          goto LABEL_13;
        }
      }

      __break(1u);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to copy contents into nil buffer pointer",  48LL,  2,  "Swift/Array.swift",  17LL,  2,  0x693uLL,  0);
  }

  return a3;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance [A]@<X0>( uint64_t (*a1)(uint64_t, unint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return Array.withContiguousStorageIfAvailable<A>(_:)(a1, *v4, *(uint64_t **)(a3 + 16), a2, a4);
}

uint64_t Array.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t, unint64_t)@<X0>, int64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3) && (a2 < 0 || (a2 & 0x4000000000000000LL) != 0))
  {
    uint64_t v17 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a3, v10, v11);
    swift_bridgeObjectRetain(a2, v18, v19, v20);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v17, v21);
    uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v17, WitnessTable);
    uint64_t v24 = *(unsigned __int8 *)(*(a3 - 1) + 80);
    a1(v23 + ((v24 + 32) & ~v24), *(void *)(v23 + 16));
    uint64_t result = swift_release(v23);
    if (!v5) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(a4 - 8) + 56LL))(a5, 0LL, 1LL);
    }
  }

  else
  {
    else {
      uint64_t v12 = a2;
    }
    uint64_t v13 = *(unsigned __int8 *)(*(a3 - 1) + 80);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3) && (a2 < 0 || (a2 & 0x4000000000000000LL) != 0))
    {
      if (a2 < 0) {
        uint64_t v25 = (void *)a2;
      }
      else {
        uint64_t v25 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
      }
      unint64_t v26 = (unint64_t)objc_msgSend(v25, sel_count);
      if ((v26 & 0x8000000000000000LL) != 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      unint64_t v15 = v26;
    }

    else
    {
      else {
        uint64_t v14 = a2;
      }
      unint64_t v15 = *(void *)(v14 + 16);
    }

    uint64_t result = a1(v12 + ((v13 + 32) & ~v13), v15);
    if (!v5) {
      return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(a4 - 8) + 56LL))(a5, 0LL, 1LL);
    }
  }

  return result;
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance [A]@<X0>( uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  return result;
}

__objc2_class **Array.init()()
{
  return &_swiftEmptyArrayStorage;
}

__objc2_class **specialized Array.init(repeating:count:)(unint64_t a1, __objc2_class *a2)
{
  uint64_t result = specialized static Array._allocateUninitialized(_:)( a2,  (uint64_t (*)(__objc2_class *))specialized static Array._allocateBufferUninitialized(minimumCapacity:));
  if (((unint64_t)a2 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a2)
  {
    if ((unint64_t)a2 < 4)
    {
      unint64_t v6 = 0LL;
      uint64_t v7 = (unint64_t *)v5;
LABEL_8:
      uint64_t v11 = (char *)a2 - v6;
      do
      {
        *v7++ = a1;
        --v11;
      }

      while (v11);
      return result;
    }

    unint64_t v6 = (unint64_t)a2 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v7 = (unint64_t *)v5 + ((unint64_t)a2 & 0xFFFFFFFFFFFFFFFCLL);
    int64x2_t v8 = vdupq_n_s64(a1);
    uint64_t v9 = v5 + 1;
    unint64_t v10 = (unint64_t)a2 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v9[-1] = v8;
      *uint64_t v9 = v8;
      v9 += 2;
      v10 -= 4LL;
    }

    while (v10);
    if ((__objc2_class *)v6 != a2) {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t Array.init(repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Array.init(repeating:count:)( a1,  a2,  a3,  (uint64_t (*)(uint64_t, uint64_t))static Array._allocateUninitialized(_:));
}

__objc2_class **specialized static Array._allocateUninitialized(_:)(uint64_t a1)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct Array with count < 0",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x3A8uLL,  0);
  }
  if (!a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(a1);
  *(void *)(((unint64_t)result & 0xFFFFFFFFFFFFF8LL) + 0x10) = a1;
  return result;
}

__objc2_class **specialized static Array._allocateUninitialized(_:)( __objc2_class *a1, uint64_t (*a2)(__objc2_class *))
{
  if (((unint64_t)a1 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct Array with count < 0",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x3A8uLL,  0);
  }
  if (!a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t result = (__objc2_class **)a2(a1);
  result[2] = a1;
  return result;
}

uint64_t static Array._allocateUninitialized(_:)(uint64_t a1, uint64_t *a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct Array with count < 0",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x3A8uLL,  0);
  }
  if (a1)
  {
    uint64_t v4 = (uint64_t)static Array._allocateBufferUninitialized(minimumCapacity:)(a1, a2);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
    uint64_t v6 = v4 & 0xFFFFFFFFFFFFF8LL;
    if (!isClassOrObjCExistentialType) {
      uint64_t v6 = v4;
    }
    *(void *)(v6 + 16) = a1;
  }

  else
  {
    uint64_t v4 = (uint64_t)&_swiftEmptyArrayStorage;
  }

  _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  return v4;
}

__objc2_class **specialized static Array._allocateBufferUninitialized(minimumCapacity:)(uint64_t a1)
{
  if (a1 < 1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int8>();
  uint64_t v3 = swift_allocObject(v2, a1 + 32, 7uLL);
  size_t v4 = _swift_stdlib_malloc_size(v3);
  v3[2] = 0LL;
  v3[3] = 2 * v4 - 64;
  return (__objc2_class **)v3;
}

{
  uint64_t v2;
  void *v3;
  int64_t v4;
  uint64_t v5;
  if (a1 < 1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
  uint64_t v3 = swift_allocObject(v2, 8 * a1 + 32, 7uLL);
  size_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 0LL;
  v3[3] = (2 * (v5 >> 3)) | 1;
  return (__objc2_class **)v3;
}

{
  uint64_t v2;
  void *v3;
  int64_t v4;
  uint64_t v5;
  if (a1 < 1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>();
  uint64_t v3 = swift_allocObject(v2, 8 * a1 + 32, 7uLL);
  size_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 0LL;
  v3[3] = 2 * (v5 >> 3);
  return (__objc2_class **)v3;
}

__objc2_class **static Array._allocateBufferUninitialized(minimumCapacity:)(uint64_t a1, uint64_t *a2)
{
  return _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(0LL, a1, a2);
}

__objc2_class **Array.init(_uninitializedCount:)(uint64_t a1, uint64_t *a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct Array with count < 0",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x3A8uLL,  0);
  }
  if (!a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = (uint64_t)static Array._allocateBufferUninitialized(minimumCapacity:)(a1, a2);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  uint64_t v6 = v4 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v6 = v4;
  }
  *(void *)(v6 + 16) = a1;
  return (__objc2_class **)v4;
}

uint64_t specialized static Array._adoptStorage(_:count:)(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = 2 * a2;
  return result;
}

void *static Array._adoptStorage(_:count:)(void *a1, uint64_t a2)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( *(void *)(*a1 + 144LL),  *(uint64_t **)(*a1 + 144LL));
  a1[2] = a2;
  a1[3] = isClassOrObjCExistentialType | (unint64_t)(2 * a2);
  return a1;
}

void *_ContiguousArrayBuffer.init(count:storage:)(uint64_t a1, void *a2)
{
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( *(void *)(*a2 + 144LL),  *(uint64_t **)(*a2 + 144LL));
  a2[2] = a1;
  a2[3] = isClassOrObjCExistentialType | (unint64_t)(2 * a1);
  return a2;
}

Swift::Void __swiftcall Array._deallocateUninitialized()()
{
  uint64_t v2 = *v1;
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType(*(void *)(v0 + 16), *(uint64_t **)(v0 + 16));
  uint64_t v4 = v2 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v4 = v2;
  }
  *(void *)(v4 + 16) = 0LL;
}

Swift::Void __swiftcall Array.reserveCapacity(_:)(Swift::Int a1)
{
}

uint64_t specialized Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(uint64_t a1, uint64_t a2)
{
  return specialized Array._reserveCapacityImpl(minimumCapacity:growForAppend:)( a1,  a2,  (uint64_t (*)(void))specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:));
}

{
  return specialized Array._reserveCapacityImpl(minimumCapacity:growForAppend:)( a1,  a2,  (uint64_t (*)(void))specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:));
}

uint64_t specialized Array._reserveCapacityImpl(minimumCapacity:growForAppend:)( uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v6 = *v3;
  uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v3);
  *uint64_t v3 = v6;
  if (!(_DWORD)result || a1 > *(void *)(v6 + 24) >> 1)
  {
    uint64_t result = a3();
    *uint64_t v3 = result;
  }

  return result;
}

Swift::Void __swiftcall Array._reserveCapacityImpl(minimumCapacity:growForAppend:)( Swift::Int minimumCapacity, Swift::Bool growForAppend)
{
  uint64_t v6 = *(uint64_t **)(v2 + 16);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
  uint64_t v8 = *v3;
  if (!isClassOrObjCExistentialType)
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    *uint64_t v3 = v8;
    if (isUniquelyReferenced_nonNull_native) {
      goto LABEL_8;
    }
LABEL_12:
    char v10 = 0;
LABEL_13:
    if (_swift_isClassOrObjCExistentialType((uint64_t)v6, v6) && (v8 < 0 || (v8 & 0x4000000000000000LL) != 0))
    {
      if (v8 < 0) {
        uint64_t v18 = (void *)v8;
      }
      else {
        uint64_t v18 = (void *)(v8 & 0xFFFFFFFFFFFFFF8LL);
      }
      id v16 = objc_msgSend(v18, sel_count);
    }

    else
    {
      BOOL v14 = _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
      uint64_t v15 = v8 & 0xFFFFFFFFFFFFF8LL;
      if (!v14) {
        uint64_t v15 = v8;
      }
      id v16 = *(id *)(v15 + 16);
    }

    else {
      Swift::Int v17 = (Swift::Int)v16;
    }
    *uint64_t v3 = _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( v10,  v17,  growForAppend,  v8,  v6);
    return;
  }

  char isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(*v3);
  *uint64_t v3 = v8;
  if ((isUniquelyReferenced_nonNull_bridgeObject & 1) == 0) {
    goto LABEL_12;
  }
  if (_swift_isClassOrObjCExistentialType((uint64_t)v6, v6))
  {
    char v10 = 0;
    if (v8 < 0 || (v8 & 0x4000000000000000LL) != 0) {
      goto LABEL_13;
    }
  }

LABEL_8:
  BOOL v12 = _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
  uint64_t v13 = v8 & 0xFFFFFFFFFFFFF8LL;
  if (!v12) {
    uint64_t v13 = v8;
  }
  if (minimumCapacity > *(void *)(v13 + 24) >> 1)
  {
    char v10 = 1;
    goto LABEL_13;
  }

  uint64_t v94 = v17;
  unint64_t v96 = v14;
  uint64_t v33 = *v8;
  if ((*v8 & 0xC000000000000001LL) != 0)
  {
    if (v33 < 0) {
      uint64_t v34 = (void *)*v8;
    }
    else {
      uint64_t v34 = (void *)(v33 & 0xFFFFFFFFFFFFFF8LL);
    }
    BOOL v35 = v101 & 1;
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v35, v20);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v35, v36);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v35, v37);
    swift_bridgeObjectRetain(v33, v38, v39, v40);
    uint64_t v41 = objc_msgSend(v34, sel_count);
    uint64_t v42 = _NativeDictionary.init(_:capacity:)(v34, (uint64_t)v41, v99, v96, *(void *)(v100 + 32));
    BOOL v43 = *v8;
    *uint64_t v8 = (uint64_t)v42;
    swift_bridgeObjectRelease(v43);
  }

  else
  {
    uint64_t v44 = v101 & 1;
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v44, v20);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v44, v45);
    outlined copy of [A : B].Index._Variant<A, B>(a4, a5, v44, v46);
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v8);
  uint64_t v50 = isUniquelyReferenced_nonNull_native;
  uint64_t v51 = *v8;
  if ((a3 & 1) == 0)
  {
    if (v13 < 0
      || 1LL << *(_BYTE *)(v51 + 32) <= v13
      || ((*(void *)(v51 + (((unint64_t)v13 >> 3) & 0xFFFFFFFFFFFFF8LL) + 64) >> v13) & 1) == 0
      || *(_DWORD *)(v51 + 36) != (_DWORD)a2)
    {
      goto LABEL_45;
    }

    swift_bridgeObjectRetain_n(*v8, 2LL, v48, v49);
    if ((v101 & 1) == 0) {
      goto LABEL_24;
    }
    goto LABEL_34;
  }

  unint64_t v93 = isUniquelyReferenced_nonNull_native;
  swift_bridgeObjectRetain_n(v51, 2LL, v48, v49);
  outlined consume of [A : B].Index._Variant<A, B>(v13, a2, 1);
  outlined consume of [A : B].Index._Variant<A, B>(v13, a2, 1);
  if (v13 >= 0) {
    uint64_t v52 = v13 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v52 = v13;
  }
  uint64_t v53 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v52, v53)) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }
  if (!swift_dynamicCastClass(v52, v53)) {
    goto LABEL_50;
  }
  int64_t v57 = *(void *)(v52 + 24);
  if (*(void *)(v57 + 16) <= a2) {
    goto LABEL_48;
  }
  char v58 = *(void **)(v57 + 8 * a2 + 24);
  swift_unknownObjectRetain(v58, v54, v55, v56);
  outlined consume of [A : B].Index._Variant<A, B>(v13, a2, 1);
  uint64_t v59 = v99;
  _forceBridgeFromObjectiveC<A>(_:_:)(v58, v99, v60, v23);
  swift_unknownObjectRelease(v58);
  uint64_t v13 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v23, (uint64_t)v59, *(void *)(v100 + 32));
  unint64_t v62 = v61;
  (*(void (**)(char *, char *))(v98 + 8))(v23, v59);
  if ((v62 & 1) == 0) {
    goto LABEL_49;
  }
  uint64_t v50 = v93;
  if ((v101 & 1) != 0)
  {
LABEL_34:
    outlined consume of [A : B].Index._Variant<A, B>(a4, a5, 1);
    outlined consume of [A : B].Index._Variant<A, B>(a4, a5, 1);
    if (a4 >= 0) {
      char v65 = a4 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      char v65 = a4;
    }
    unint64_t v66 = type metadata accessor for __CocoaDictionary.Index.Storage();
    if (swift_dynamicCastClass(v65, v66))
    {
      id v67 = specialized static Hasher._hash(seed:_:)(0LL, *(void *)(v65 + 16));
      unint64_t v68 = *(_DWORD *)(v51 + 36);
      swift_bridgeObjectRelease(v51);
      if (v68 != v67) {
        goto LABEL_49;
      }
      if (swift_dynamicCastClass(v65, v66))
      {
        unint64_t v72 = *(void *)(v65 + 24);
        if (*(void *)(v72 + 16) > a5)
        {
          uint64_t v73 = *(void **)(v72 + 8 * a5 + 24);
          swift_unknownObjectRetain(v73, v69, v70, v71);
          outlined consume of [A : B].Index._Variant<A, B>(a4, a5, 1);
          unint64_t v74 = v95;
          char v75 = v99;
          _forceBridgeFromObjectiveC<A>(_:_:)(v73, v99, v76, v95);
          swift_unknownObjectRelease(v73);
          a4 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v74, (uint64_t)v75, *(void *)(v100 + 32));
          LOBYTE(v73) = v77;
          swift_bridgeObjectRelease(v51);
          (*(void (**)(char *, char *))(v98 + 8))(v74, v75);
LABEL_49:
          uint64_t v87 = 303LL;
LABEL_46:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Dictionary elements using an invalid index",  63LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  v87,  0);
        }

      uint64_t v39 = swift_checkMetadataState(0LL, v64);
      v62(v39, v63);
      if (v61(v19, 1LL, a6) == 1) {
        goto LABEL_2;
      }
      v60(v71, v19, a6);
    }

    uint64_t v38 = (void (*)(char *, uint64_t))v27[1];
LABEL_6:
    v38(v71, a6);
LABEL_7:
    uint64_t v19 = v58;
    a8 = v59;
    uint64_t v27 = v69;
    BOOL v14 = v70;
    goto LABEL_8;
  }

  uint64_t v6 = *v1;
  if (*v1 < a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v7 = 0;
  if (v6 != a1)
  {
    uint64_t v9 = *v1;
    while (v6 >= v9 && v9 > a1)
    {
      if (HIBYTE(v7)) {
LABEL_32:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
      v7 |= v9 << (-(__clz(v7) & 0x18) & 0x18);
      v9 >>= 8;
      if (v9 == a1) {
        goto LABEL_11;
      }
    }

      v5 += v12;
      uint64_t v8 = v9;
      if (v9 == v6) {
        return v7 & 1;
      }
    }
  }

  uint64_t v7 = 1;
  return v7 & 1;
}

  if ((v12 & ~v11 & 0x2000000000000000LL) != 0
    && (BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL),
        BOOL v12 = *v5,
        uint64_t v11 = v5[1],
        isUniquelyReferenced_nonNull_native))
  {
    id v16 = _StringGuts.nativeUnusedCapacity.getter(*v5, v5[1]);
    if ((v17 & 1) != 0)
    {
      uint64_t v61 = 258LL;
LABEL_60:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v61,  0);
    }

    if (v14 > 15 || (v11 & 0x2000000000000000LL) == 0 && v16 >= v10)
    {
LABEL_14:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v14, v10);
      if ((x1_0 & 0x1000000000000000LL) != 0)
      {
        _StringGuts._foreignAppendInPlace(_:)(a1, x1_0, a3, a4);
        return;
      }

      if ((x1_0 & 0x2000000000000000LL) == 0)
      {
        if ((a1 & 0x1000000000000000LL) != 0)
        {
          uint64_t v18 = (id)((x1_0 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v19 = a1 & 0xFFFFFFFFFFFFLL;
          if ((a3 & 0x8000000000000000LL) == 0) {
            goto LABEL_18;
          }
        }

        else
        {
          uint64_t v18 = _StringObject.sharedUTF8.getter(a1, x1_0);
          uint64_t v19 = v60;
          if ((a3 & 0x8000000000000000LL) == 0)
          {
LABEL_18:
            if (v19 >= a4)
            {
              uint64_t v20 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(a3, a4, (uint64_t)v18, v19);
              _StringGuts.appendInPlace(_:isASCII:)(v20, v21, a1 < 0);
              return;
            }

            goto LABEL_52;
          }
        }

  __break(1u);
}

              id v37 = 0LL;
              uint64_t v38 = 0;
              Swift::Int v17 = 0LL;
              uint64_t v18 = 18;
              uint64_t v19 = 1;
              break;
            case 13:
              if (v28 > 0xF) {
                goto LABEL_281;
              }
              uint64_t v33 = 1 << v28;
              if ((v33 & 0x20A1) != 0)
              {
LABEL_272:
                uint64_t v18 = 18;
                goto LABEL_9;
              }

              if ((v33 & 0x8C00) == 0) {
                goto LABEL_281;
              }
              uint64_t v19 = 0;
              uint64_t v18 = 18;
              uint64_t v34 = 1LL;
              goto LABEL_279;
            case 14:
              if (((v30 | v36) & 1) != 0) {
                goto LABEL_281;
              }
              uint64_t v18 = 18;
              uint64_t v36 = 1;
              goto LABEL_9;
            default:
              goto LABEL_281;
          }

          goto LABEL_9;
        }

    BOOL v14 = v11 == 1;
    *(void *)a1 = *(void *)a2;
    uint64_t v15 = (unint64_t)&a2[v7 + 8] & ~v7;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(v6 + 16))((unint64_t)&a1[v7 + 8] & ~v7, v15, v5);
    id v16 = (v8 + v15) & 0xFFFFFFFFFFFFFFF8LL;
    Swift::Int v17 = *(_BYTE *)(v16 + 8);
    uint64_t v18 = (v8 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)uint64_t v18 = *(void *)v16;
    *(_BYTE *)(v18 + 8) = v17;
    a1[v9] = v14;
  }

  return a1;
}

    BOOL v14 = v11 == 1;
    *(void *)a1 = *(void *)a2;
    uint64_t v15 = (unint64_t)&a2[v7 + 8] & ~v7;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(v6 + 32))((unint64_t)&a1[v7 + 8] & ~v7, v15, v5);
    id v16 = (v8 + v15) & 0xFFFFFFFFFFFFFFF8LL;
    Swift::Int v17 = *(_BYTE *)(v16 + 8);
    uint64_t v18 = (v8 + v10) & 0xFFFFFFFFFFFFFFF8LL;
    *(void *)uint64_t v18 = *(void *)v16;
    *(_BYTE *)(v18 + 8) = v17;
    a1[v9] = v14;
  }

  return a1;
}

      *(void *)(result + 8) = v3;
      return result;
    }

    if ((_DWORD)a2 == 1) {
      goto LABEL_7;
    }
    if ((~v2 & 0x80000000FFFFFFFFLL) == 0) {
      return result;
    }
    if (a2 < 2 || (v2 & 0x8000000000000000LL) == 0)
    {
LABEL_7:
      uint64_t v3 = v2 - (a2 << 33);
      if (v3 >= 0) {
        goto LABEL_8;
      }
    }

    if ((_DWORD)v2 != -1)
    {
      if (v2 < 0) {
        return swift::HeapObjectSideTableEntry::decrementNonAtomicStrong<(swift::PerformDeinit)1>( (void **)(8 * v2),  a2);
      }
      goto LABEL_14;
    }
  }

  return result;
}

  char v10 = (const char *)v3[2];
  uint64_t v11 = *(const char **)(v7 + 128);
  if (v10 != v11 && (!v10 || !v11 || strcmp(v10, v11))) {
    goto LABEL_14;
  }
  return v0 + 8 * v6;
}

  if (*((_WORD *)v4 + 8) == 233) {
    return *(const char **)v4;
  }
  uint64_t result = (const char *)descriptorFromStandardMangling((int **)v4);
  if (!result)
  {
    uint64_t v23 = 0LL;
    if (qword_18C486D78 != -1) {
      dispatch_once_f( &qword_18C486D78,  &TypeMetadataRecords,  (dispatch_function_t)swift::Lazy<TypeMetadataPrivateState>::defaultInitCallback);
    }
    if (*((_WORD *)v4 + 8) == 38) {
      return 0LL;
    }
    *(void *)&uint64_t v20 = a2;
    swift::Demangle::__runtime::mangleNode((uint64_t)a1);
    if (v21)
    {
      return 0LL;
    }

    else
    {
      uint64_t v20 = v22;
      do
        uint64_t v8 = __ldaxr(&TypeMetadataRecords);
      while (__stxr(v8 + 1, &TypeMetadataRecords));
      do
      {
        uint64_t v9 = atomic_load((unint64_t *)&dword_18C486D2C[1]);
        char v10 = atomic_load((unint64_t *)&dword_18C486D2C[3]);
        uint64_t v11 = atomic_load(dword_18C486D2C);
        BOOL v12 = atomic_load((unint64_t *)&dword_18C486D2C[1]);
      }

      while (v9 != v12);
      if (v9) {
        uint64_t v13 = v10 == 0;
      }
      else {
        uint64_t v13 = 1;
      }
      BOOL v14 = v13 || v11 == 0;
      if (v14
      {
        do
          Swift::Int v17 = __ldxr(&TypeMetadataRecords);
        while (__stlxr(v17 - 1, &TypeMetadataRecords));
        uint64_t v23 = _searchTypeMetadataRecords((uint64_t)&TypeMetadataRecords, (uint64_t)a1);
        if (v23 || (uint64_t result = swift::_searchConformancesByMangledTypeName(a1, v18), (v23 = result) != 0LL))
        {
          v19[0] = &v20;
          v19[1] = &v23;
          return v23;
        }
      }

      else
      {
        uint64_t result = *(const char **)(v15 + 16);
        do
          id v16 = __ldxr(&TypeMetadataRecords);
        while (__stlxr(v16 - 1, &TypeMetadataRecords));
      }
    }
  }

  return result;
}

  BOOL v12 = *((void *)this + 9);
  if (v12 < *((void *)this + 8) && *(_BYTE *)(*((void *)this + 7) + v12) == 110)
  {
    *((void *)this + 9) = v12 + 1;
    if (!v9) {
      return 0LL;
    }
  }

  else
  {
    BOOL v14 = swift::Demangle::__runtime::Demangler::demangleFuncSpecParam(this, 79, v6, v7, v8);
    uint64_t result = 0LL;
    if (!v9 || !v14) {
      return result;
    }
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v9, v14, this, v15, v16);
  }

  Swift::Int v17 = *(unsigned __int8 *)(v9 + 18);
  if ((_DWORD)v17 == 1) {
    goto LABEL_20;
  }
  if ((_DWORD)v17 == 5)
  {
    Swift::Int v17 = *(unsigned int *)(v9 + 8);
    if ((_DWORD)v17) {
      goto LABEL_20;
    }
    return v9;
  }

  if ((_DWORD)v17 != 2) {
    return v9;
  }
  Swift::Int v17 = 2LL;
LABEL_20:
  uint64_t v18 = 0LL;
  while (1)
  {
    uint64_t v19 = *(unsigned __int8 *)(v9 + 18);
    uint64_t v20 = v19 - 1;
    if ((_DWORD)v19 != 1)
    {
      if ((_DWORD)v19 == 5)
      {
        uint64_t v19 = *(unsigned int *)(v9 + 8);
      }

      else
      {
        if ((_DWORD)v19 != 2) {
          goto LABEL_31;
        }
        uint64_t v19 = 2LL;
      }
    }

    uint64_t v21 = v17 + ~v18;
    if (v19 <= v21)
    {
LABEL_31:
      uint64_t v23 = 0LL;
      goto LABEL_32;
    }

    uint64_t v22 = v9;
    if (v20 >= 2) {
      uint64_t v22 = *(void *)v9;
    }
    uint64_t v23 = *(int8x16_t **)(v22 + 8 * v21);
LABEL_32:
    if (v23[1].i16[0] != 78) {
      goto LABEL_21;
    }
    uint64_t v24 = v23[1].u8[2];
    uint64_t v25 = (unsigned int **)v23;
    if ((v24 - 1) >= 2)
    {
      if ((_DWORD)v24 != 5 || !v23->i32[2]) {
        goto LABEL_21;
      }
      uint64_t v25 = (unsigned int **)v23->i64[0];
    }

    unint64_t v26 = **v25;
    if (v26 > 9 || ((1 << v26) & 0x233) == 0) {
      goto LABEL_21;
    }
    if ((_DWORD)v24 == 1) {
      goto LABEL_47;
    }
    if ((_DWORD)v24 == 5) {
      break;
    }
    if ((_DWORD)v24 == 2)
    {
      uint64_t v24 = 2LL;
      uint64_t v28 = *((_DWORD *)this + 24);
      if (v28) {
        goto LABEL_52;
      }
      return 0LL;
    }

    uint64_t v24 = 0LL;
    uint64_t v28 = *((_DWORD *)this + 24);
    if (!v28) {
      return 0LL;
    }
LABEL_52:
    while (1)
    {
      uint64_t v29 = v28 - 1;
      unint64_t v30 = *(void *)(*((void *)this + 11) + 8LL * v29);
      uint64_t v31 = *(unsigned __int16 *)(v30 + 16);
      if (v31 != 232) {
        break;
      }
      *((_DWORD *)this + 24) = v29;
      if (v26 == 9 || v26 == 5)
      {
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v23,  (swift::Demangle::__runtime::Node *)v30,  this,  v7,  v8);
        uint64_t v28 = *((_DWORD *)this + 24);
        if (v28) {
          continue;
        }
      }

      return 0LL;
    }

    if (v31 != 101) {
      return 0LL;
    }
    *((_DWORD *)this + 24) = v29;
    uint64_t v33 = *(_BYTE **)v30;
    char v32 = *(void *)(v30 + 8);
    if (v26 == 4 && v32 && *v33 == 95)
    {
      --v32;
      ++v33;
    }

    uint64_t v34 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    if (!v34 || v34 + 24 > *((void *)this + 2))
    {
      BOOL v35 = 2LL * *((void *)this + 4);
      if (v35 <= 0x20) {
        BOOL v35 = 32LL;
      }
      *((void *)this + 4) = v35;
      uint64_t v36 = v35 + 8;
      id v37 = malloc(v35 + 8);
      *id v37 = *((void *)this + 3);
      uint64_t v34 = ((unint64_t)v37 + 15) & 0xFFFFFFFFFFFFFFF8LL;
      *((void *)this + 2) = (char *)v37 + v36;
      *((void *)this + 3) = v37;
    }

    *((void *)this + 1) = v34 + 24;
    *(_WORD *)(v34 + 16) = 81;
    *(_BYTE *)(v34 + 18) = 3;
    *(void *)uint64_t v34 = v33;
    *(void *)(v34 + 8) = v32;
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v23,  (swift::Demangle::__runtime::Node *)v34,  this,  v7,  v8);
    uint64_t v38 = v23[1].u8[2];
    if (v38 == 5)
    {
      uint64_t v39 = v23->u32[2];
      if (v24 != v39)
      {
        uint64_t v40 = (void *)(v23->i64[0] + 8 * v39 - 8);
        if ((unint64_t)v40 > v23->i64[0] + 8 * v24)
        {
          uint64_t v41 = v23->i64[0] + 8 * v24 + 8;
          do
          {
            uint64_t v42 = *(void *)(v41 - 8);
            *(void *)(v41 - 8) = *v40;
            *v40-- = v42;
            BOOL v43 = v41 >= (unint64_t)v40;
            v41 += 8LL;
          }

          while (!v43);
        }
      }
    }

    else if (v38 == 2 && !v24)
    {
      void *v23 = vextq_s8(*v23, *v23, 8uLL);
    }

  {
    if (*(_DWORD *)a4) {
      goto LABEL_12;
    }
    swift::Demangle::__runtime::RemanglerBase::addSubstitution( (char *)this,  (const swift::Demangle::__runtime::SubstitutionEntry *)v13);
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_12:
  if (SHIBYTE(v12) < 0) {
    operator delete(__p);
  }
}

  {
    if (*(_DWORD *)a8) {
      return;
    }
    swift::Demangle::__runtime::RemanglerBase::addSubstitution( a1,  (const swift::Demangle::__runtime::SubstitutionEntry *)v17);
  }

  *(_DWORD *)a8 = 0;
  *(void *)(a8 + 8) = 0LL;
  *(_DWORD *)(a8 + 16) = 0;
}

__objc2_class **specialized Array._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( __objc2_class **a1, int64_t a2, char a3)
{
  uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = (uint64_t)result;
  return result;
}

{
  uint64_t *v3;
  __objc2_class **result;
  uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = (uint64_t)result;
  return result;
}

uint64_t specialized Array._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( char a1, uint64_t a2, char a3)
{
  uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(a1, a2, a3, *v3);
  *uint64_t v3 = result;
  return result;
}

Swift::Void __swiftcall Array._copyToNewBuffer(oldCount:)(Swift::Int oldCount)
{
  uint64_t v6 = oldCount + 1;
  BOOL v14 = *v4;
  uint64_t v7 = type metadata accessor for _ArrayBuffer(0LL, *(void *)(v1 + 16), v2, v3);
  uint64_t WitnessTable = (uint64_t (**)(uint64_t, uint64_t, char *))swift_getWitnessTable( &protocol conformance descriptor for _ArrayBuffer<A>,  v7,  v8);
  char v10 = (unint64_t *)_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(countForNewBuffer:minNewCapacity:)( oldCount,  v6,  v7,  (uint64_t)WitnessTable);
  BOOL v14 = v10;
  uint64_t v11 = default argument 3 of _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)(v7, (uint64_t)WitnessTable);
  uint64_t v13 = v12;
  _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( &v14,  oldCount,  0LL,  (void (*)(char *, uint64_t))v11,  v12,  v7,  WitnessTable);
  swift_release(v13);
  swift_release((uint64_t)v10);
}

uint64_t static FixedWidthInteger.&+ infix(_:_:)@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 80))(a2);
}

__objc2_class **_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(countForNewBuffer:minNewCapacity:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v9 = v8(a3, a4);
  uint64_t v10 = v8(a3, a4);
  if (v9 < a2)
  {
    if (v10 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_21;
    }

    v10 *= 2LL;
  }

  if (v10 <= a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = v10;
  }
  if (v11 <= a1) {
    uint64_t v12 = a1;
  }
  else {
    uint64_t v12 = v11;
  }
  if (!v12) {
    return &_swiftEmptyArrayStorage;
  }
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(*(void *)(a4 + 8) + 8LL) + 8LL),  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v14 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
  uint64_t v15 = *(AssociatedTypeWitness - 1);
  uint64_t v16 = *(void *)(v15 + 72);
  uint64_t v17 = *(unsigned __int8 *)(v15 + 80);
  uint64_t v18 = swift_allocObject( v14,  ((v17 + *(unsigned int *)(v14 + 48)) & ~v17) + v16 * v12,  v17 | *(unsigned __int16 *)(v14 + 52));
  size_t v19 = _swift_stdlib_malloc_size(v18);
  if (!v16) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  int64_t v23 = v19 - ((v17 + 32) & ~v17);
  if (v23 == 0x8000000000000000LL && v16 == -1) {
LABEL_21:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  uint64_t v25 = v23 / v16;
  swift_retain(v18, v20, v21, v22);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( (uint64_t)AssociatedTypeWitness,  AssociatedTypeWitness);
  v18[2] = a1;
  v18[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v25);
  swift_release((uint64_t)v18);
  return (__objc2_class **)v18;
}

uint64_t (*default argument 3 of _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( uint64_t a1, uint64_t a2))()
{
  uint64_t v4 = swift_allocObject((uint64_t)&unk_189B896B8, 0x20uLL, 7uLL);
  v4[2] = a1;
  v4[3] = a2;
  return EnumeratedSequence._base.modify;
}

void *_ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( unint64_t **a1, uint64_t a2, uint64_t a3, void (*a4)(char *, uint64_t), uint64_t a5, uint64_t a6, uint64_t (**a7)(uint64_t, uint64_t, char *))
{
  void (*v54)(uint64_t *__return_ptr, uint64_t, uint64_t);
  char *v55;
  char *v56;
  uint64_t v57;
  void *result;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(char *, char *, uint64_t);
  uint64_t (*v62)(uint64_t, uint64_t, char *, uint64_t, char *);
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t *v66;
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t *v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  void (*v78)(char *, uint64_t);
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v81 = *(void *)(a6 - 8);
  uint64_t v15 = MEMORY[0x1895F8858](a1);
  unint64_t v68 = (char *)&v67 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v69 = (char *)&v67 - v17;
  uint64_t v19 = *(void *)(*(void *)(v18 + 8) + 8LL);
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(v19 + 112))(v20, v19);
  uint64_t v22 = *a1;
  unint64_t v23 = (*a1)[2];
  BOOL v24 = __OFSUB__(v23, a2);
  unint64_t v25 = v23 - a2;
  if (v24)
  {
    __break(1u);
    goto LABEL_27;
  }

  uint64_t v26 = v25 - a3;
  if (__OFSUB__(v25, a3))
  {
LABEL_27:
    __break(1u);
    goto LABEL_28;
  }

  uint64_t v27 = v21 - a2;
  if (__OFSUB__(v21, a2))
  {
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }

  v80 = v27 - v26;
  if (__OFSUB__(v27, v26))
  {
LABEL_29:
    __break(1u);
    goto LABEL_30;
  }

  uint64_t v71 = v26;
  uint64_t v77 = a5;
  uint64_t v78 = a4;
  uint64_t v28 = v21;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v19 + 8),  a6,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v30 = a3;
  uint64_t v31 = AssociatedTypeWitness;
  uint64_t v32 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v33 = (*(unsigned __int8 *)(v32 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v32 + 80);
  unint64_t v72 = v28;
  uint64_t v73 = v22;
  uint64_t v34 = (char *)v22 + v33;
  uint64_t v35 = *(void *)(v32 + 72);
  uint64_t v36 = v35 * a2;
  uint64_t v79 = v34;
  unint64_t v70 = &v34[v35 * a2];
  char v75 = &v70[v35 * v30];
  Swift::String v76 = v30;
  uint64_t v37 = a7[7](v28, a6, (char *)a7);
  unint64_t v74 = v19;
  if (v37)
  {
    uint64_t v38 = v37;
    uint64_t v39 = a7[18];
    unint64_t v68 = v7;
    uint64_t v69 = (char *)a7;
    uint64_t v40 = ((uint64_t (*)(uint64_t, uint64_t (**)(uint64_t, uint64_t, char *)))v39)(a6, a7);
    if (!v35) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }
    uint64_t v41 = (char *)v40;
    uint64_t v42 = v38 + v33;
    uint64_t v43 = v40 - v42;
    if (v40 - v42 != 0x8000000000000000LL || v35 != -1)
    {
      if (v43 / v35 < 0) {
        goto LABEL_25;
      }
      swift_arrayDestroy(v42, v43 / v35, v31);
      UnsafeMutablePointer.moveInitialize(from:count:)(v41, a2, v79, v31);
      uint64_t v45 = v80;
      if (v80 < 0) {
        goto LABEL_25;
      }
      uint64_t v46 = (uint64_t)&v41[v36];
      swift_arrayDestroy(v46, v80, v31);
      v78(v70, v76);
      UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v46 + v35 * v45), v71, v75, v31);
      uint64_t v47 = (uint64_t)&v41[v35 * v72];
      uint64_t v48 = v42 + *(void *)(v38 + 16) * v35 - v47;
      if (v48 != 0x8000000000000000LL || v35 != -1)
      {
        if (((v48 / v35) & 0x8000000000000000LL) == 0)
        {
          swift_arrayDestroy(v47, v48 / v35, v31);
          *(void *)(v38 + 16) = 0LL;
          swift_release(v38);
          uint64_t v53 = v74;
          uint64_t v54 = *(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v74 + 64);
          int64_t v56 = v68;
          uint64_t v55 = v69;
          int64_t v57 = v81;
LABEL_24:
          unint64_t v66 = v73;
          swift_retain(v73, v50, v51, v52);
          v54(&v82, a6, v53);
          (*(void (**)(char *, uint64_t))(v57 + 8))(v56, a6);
          return (void *)(*((uint64_t (**)(unint64_t *, uint64_t, uint64_t, char *))v55 + 4))( v66,  v82,  a6,  v55);
        }

LABEL_30:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  __break(1u);
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  uint64_t v20 = 0;
LABEL_13:
  uint64_t v29 = v3;
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, v30, a3);
  (*(void (**)(uint64_t, uint64_t))(v10 + 32))(a3, v10);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v10,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v22 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v22(&v31, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v31 & 0x100) == 0)
  {
    unint64_t v23 = v31;
    while (!HIBYTE(v20))
    {
      v20 |= (v23 + 1) << (-(__clz(v20) & 0x18) & 0x18);
      v22(&v31, AssociatedTypeWitness, AssociatedConformanceWitness);
      unint64_t v23 = v31;
      if ((v31 & 0x100) != 0) {
        goto LABEL_17;
      }
    }

    unint64_t v23 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v23[2]->isa + 1,  1,  (uint64_t)v23);
LABEL_25:
    uint64_t v29 = v23[2];
    uint64_t v28 = (unint64_t)v23[3];
    if ((unint64_t)v29 >= v28 >> 1) {
      unint64_t v23 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v28 > 1),  (int64_t)&v29->isa + 1,  1,  (uint64_t)v23);
    }
    v23[2] = (__objc2_class *)((char *)&v29->isa + 1);
    *((_BYTE *)&v29->info + (void)v23) = v27;
  }

  while (v4 | v5);
  uint64_t v40 = v23;
  specialized MutableCollection<>.reverse()();
  uint64_t v10 = (Swift::UInt64)v40;
  uint64_t v11 = (size_t)v40[2];
  if (!v11)
  {
    uint64_t v6 = 0LL;
LABEL_46:
    swift_bridgeObjectRetain((unint64_t)v40, v7, v8, v9);
    goto LABEL_47;
  }

  if (v11 <= 0xF)
  {
    uint64_t v30 = 8LL;
    if (v11 < 8) {
      uint64_t v30 = (uint64_t)v40[2];
    }
    uint64_t v6 = *((unsigned __int8 *)v40 + 32);
    if (v30 != 1)
    {
      v6 |= (unint64_t)*((unsigned __int8 *)v40 + 33) << 8;
      if (v30 != 2)
      {
        v6 |= (unint64_t)*((unsigned __int8 *)v40 + 34) << 16;
        if (v30 != 3)
        {
          v6 |= (unint64_t)*((unsigned __int8 *)v40 + 35) << 24;
          if (v30 != 4)
          {
            v6 |= (unint64_t)*((unsigned __int8 *)v40 + 36) << 32;
            if (v30 != 5)
            {
              v6 |= (unint64_t)*((unsigned __int8 *)v40 + 37) << 40;
              if (v30 != 6)
              {
                v6 |= (unint64_t)*((unsigned __int8 *)v40 + 38) << 48;
                if (v30 != 7) {
                  v6 |= (unint64_t)*((unsigned __int8 *)v40 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }

    uint64_t v31 = 0LL;
    if (v11 >= 9)
    {
      uint64_t v32 = 0LL;
      unint64_t v33 = (unsigned __int8 *)(v40 + 5);
      uint64_t v34 = v11 - 8;
      do
      {
        if (v11 - 8 <= v11 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        uint64_t v35 = *v33++;
        v31 |= (unint64_t)v35 << v32;
        v32 += 8LL;
        --v34;
      }

      while (v34);
    }

    goto LABEL_46;
  }

  uint64_t v12 = v11 | 0xF000000000000000LL;
  uint64_t v13 = _allocateStringStorage(codeUnitCapacity:)((int64_t)v40[2]);
  uint64_t v15 = v14;
  *(void *)(v13 + 16) = v14;
  *(void *)(v13 + 24) = v11 | 0xF000000000000000LL;
  swift_bridgeObjectRetain(v10, v14, v16, v17);
  if (v15 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v12 = *(void *)(v13 + 24);
  }

  *(_BYTE *)(v13 + 32 + (v12 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(v10 + 32), v11, (char *)(v13 + 32));
  uint64_t v6 = *(void *)(v13 + 24);
LABEL_47:
  swift_bridgeObjectRelease_n(v10, 2LL);
  return v6;
}

  v176 = 0LL;
  (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t, unint64_t))(v60 + 96))( &v176,  &type metadata for Int,  v163,  AssociatedTypeWitness,  v60);
  Swift::String v104 = *(uint64_t (**)(char *, char *, unint64_t))(*(void *)(swift_getAssociatedConformanceWitness( v157,  v154,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable)
                                                                                + 8)
                                                                    + 8LL);
  unint64_t v74 = v173;
  uint64_t v102 = v104(v173, v75, AssociatedTypeWitness);
LABEL_31:
  uint64_t v105 = v102;
  uint64_t v106 = v75;
  unint64_t v97 = (void (*)(char *, unint64_t))v175[1];
  v97(v106, AssociatedTypeWitness);
  v97(v74, AssociatedTypeWitness);
  int64_t v89 = v166;
  if ((v105 & 1) == 0) {
    goto LABEL_32;
  }
LABEL_47:
  v97(v77, AssociatedTypeWitness);
  v97(v65, AssociatedTypeWitness);
  if ((v151 & 1) != 0)
  {
    unint64_t v122 = v177;
    if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v177)) {
      unint64_t v122 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v122[2]->isa + 1,  1,  (uint64_t)v122);
    }
    unint64_t v124 = v122[2];
    uint64_t v123 = (unint64_t)v122[3];
    if ((unint64_t)v124 >= v123 >> 1) {
      unint64_t v122 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v123 > 1),  (int64_t)&v124->isa + 1,  1,  (uint64_t)v122);
    }
    v122[2] = (__objc2_class *)((char *)&v124->isa + 1);
    *((_BYTE *)&v124->info + (void)v122) = 45;
    v177 = v122;
  }

  specialized MutableCollection<>.reverse()();
  unint64_t v128 = v177;
  Swift::String v129 = (size_t)v177[2];
  if (!v129)
  {
    uint64_t v50 = 0LL;
    uint64_t v49 = 0xE000000000000000LL;
LABEL_76:
    swift_bridgeObjectRetain((unint64_t)v177, v125, v126, v127);
    goto LABEL_77;
  }

  if (v129 <= 0xF)
  {
    v135 = 8LL;
    if (v129 < 8) {
      v135 = (uint64_t)v177[2];
    }
    uint64_t v50 = *((unsigned __int8 *)v177 + 32);
    if (v135 != 1)
    {
      v50 |= (unint64_t)*((unsigned __int8 *)v177 + 33) << 8;
      if (v135 != 2)
      {
        v50 |= (unint64_t)*((unsigned __int8 *)v177 + 34) << 16;
        if (v135 != 3)
        {
          v50 |= (unint64_t)*((unsigned __int8 *)v177 + 35) << 24;
          if (v135 != 4)
          {
            v50 |= (unint64_t)*((unsigned __int8 *)v177 + 36) << 32;
            if (v135 != 5)
            {
              v50 |= (unint64_t)*((unsigned __int8 *)v177 + 37) << 40;
              if (v135 != 6)
              {
                v50 |= (unint64_t)*((unsigned __int8 *)v177 + 38) << 48;
                if (v135 != 7) {
                  v50 |= (unint64_t)*((unsigned __int8 *)v177 + 39) << 56;
                }
              }
            }
          }
        }
      }
    }

    char v136 = 0LL;
    if (v129 >= 9)
    {
      v137 = 0LL;
      v138 = (unsigned __int8 *)(v177 + 5);
      v139 = v129 - 8;
      do
      {
        if (v129 - 8 <= v129 - 9) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
        }
        v140 = *v138++;
        v136 |= (unint64_t)v140 << v137;
        v137 += 8LL;
        --v139;
      }

      while (v139);
    }

    v141 = 0xA000000000000000LL;
    if (((v136 | v50) & 0x8080808080808080LL) == 0) {
      v141 = 0xE000000000000000LL;
    }
    uint64_t v49 = v141 | (v129 << 56) | v136;
    goto LABEL_76;
  }

  v130 = v129 | 0xF000000000000000LL;
  uint64_t v49 = _allocateStringStorage(codeUnitCapacity:)((int64_t)v177[2]);
  uint64_t v132 = v131;
  *(void *)(v49 + 16) = v131;
  *(void *)(v49 + 24) = v129 | 0xF000000000000000LL;
  swift_bridgeObjectRetain((unint64_t)v128, v131, v133, v134);
  if (v132 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    v130 = *(void *)(v49 + 24);
  }

  *(_BYTE *)(v49 + 32 + (v130 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)v128 + 32, v129, (char *)(v49 + 32));
  uint64_t v50 = *(void *)(v49 + 24);
LABEL_77:
  swift_bridgeObjectRelease_n((uint64_t)v128, 2LL);
LABEL_78:
  unint64_t v142 = v50;
  v143 = (void *)v49;
  result._uint64_t object = v143;
  result._uint64_t countAndFlagsBits = v142;
  return result;
}

              __break(1u);
LABEL_31:
              KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v18);
            }

            unint64_t v23 = v17 + 3;
          }
        }

        if ((v23 & 0xC000) == 0x4000)
        {
          if (!HIWORD(v26)) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UTF16.swift",  17LL,  2,  0x5BuLL,  0);
          }
          LOWORD(v33) = v26 & 0x3FF | 0xDC00;
        }

        else if (HIWORD(v26))
        {
          LODWORD(v33) = ((v26 + 67043328) >> 10) - 10240;
        }

        else
        {
          LOWORD(v33) = v26;
        }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1E1uLL,  0);
    }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/SetBridging.swift",  23LL,  2,  0x1E1uLL,  0);
    }

  __break(1u);
}

    uint64_t v17 = 1LL;
    uint64_t v18 = v9 + 1;
    if (!__OFADD__(v9, 1LL)) {
      goto LABEL_31;
    }
LABEL_42:
    __break(1u);
  }

  if ((v4 & 0x1000000000000000LL) != 0)
  {
    uint64_t v12 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v13 = v4 & 0xFFFFFFFFFFFFLL;
    goto LABEL_19;
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

    uint64_t v51 = v70 >> 63;
    uint64_t v52 = v70 >> 63;
    goto LABEL_65;
  }

  if (v103 <= 0xFFFFFFFFFFFFFF80LL)
  {
LABEL_18:
    uint64_t v51 = 0LL;
    uint64_t v52 = 0LL;
    goto LABEL_65;
  }

  else {
    uint64_t v51 = v104 << -(char)v103;
  }
  uint64_t v52 = (v70 << -(char)v103) | (v104 >> 1 >> (v103 - 1));
LABEL_65:
  uint64_t v106 = v118;
  *int64_t v118 = v51;
  v106[1] = v52;
  return result;
}

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "no memory available to initialize from source",  45LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x2A9uLL,  0);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "buffer cannot contain every element from source.",  48LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v19,  0);
  }

  if ((a2 & 0x2000000000000000LL) == 0)
  {
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      uint64_t v7 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) <= a4) {
        goto LABEL_5;
      }
      goto LABEL_29;
    }

    uint64_t v7 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
    if (v7)
    {
      uint64_t v8 = v18;
      if (v18 <= a4)
      {
LABEL_5:
        if (__dst) {
          goto LABEL_10;
        }
        return v8;
      }

      goto LABEL_29;
    }

    return 0LL;
  }

  uint64_t v8 = HIBYTE(a2) & 0xF;
  __src[0] = a1;
  __src[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (v8 > a4)
  {
LABEL_29:
    uint64_t v19 = 918LL;
    goto LABEL_30;
  }

  if (__dst)
  {
    uint64_t v7 = (char *)__src;
LABEL_10:
    specialized UnsafeMutablePointer.moveInitialize(from:count:)( v7,  v8,  __dst,  "UnsafeMutablePointer.update with negative count",  47LL,  0x3DEuLL);
  }

  return v8;
}

    quotient = specialized _wideDivide32<A>(_:by:)(&v45, &v44, a3, v12, v9, v8);
    v47.low = v44;
    v47.high = v45;
    uint64_t v43 = specialized _wideDivide32<A>(_:by:)(&v45, &v44, v47, v11, v9, v8);
    uint64_t v39 = v44;
    uint64_t v38 = v45;
    *a1 = v43;
    uint64_t v40 = (v39 >> v17) | (v38 << -(char)v17);
    uint64_t v42 = v38 >> v17;
    uint64_t v41 = v17 == 0;
    goto LABEL_31;
  }

  if (!a8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x26BCuLL,  0);
  }
  if (a3.low % a8)
  {
    v26.low = a4;
    v26.high = a3.low % a8;
    remainder = UInt64.dividingFullWidth(_:)(v26).remainder;
    if (remainder) {
      goto LABEL_20;
    }
LABEL_35:
    quotient = v12 / a8;
    uint64_t v31 = v12 % a8;
    if (v12 % a8) {
      goto LABEL_21;
    }
LABEL_36:
    unint64_t v33 = v11 / a8;
    uint64_t v34 = v11 % a8;
    goto LABEL_37;
  }

  remainder = a4 % a8;
  if (!(a4 % a8)) {
    goto LABEL_35;
  }
LABEL_20:
  uint64_t v28 = v12;
  uint64_t v29 = UInt64.dividingFullWidth(_:)(*(Swift::tuple_high_UInt64_low_UInt64 *)&remainder);
  quotient = v29.quotient;
  uint64_t v31 = v29.remainder;
  if (!v29.remainder) {
    goto LABEL_36;
  }
LABEL_21:
  uint64_t v32 = v11;
  uint64_t v35 = UInt64.dividingFullWidth(_:)(*(Swift::tuple_high_UInt64_low_UInt64 *)&v31);
  uint64_t v34 = v35.remainder;
  unint64_t v33 = v35.quotient;
LABEL_37:
  *a1 = v33;
  *high = v34;
  *a2 = 0LL;
  return quotient;
}

  if (v24 < 0) {
    goto LABEL_35;
  }
  uint64_t v22 = -(uint64_t)v23;
  if (v23) {
    uint64_t v21 = ~v24;
  }
  else {
    uint64_t v21 = -v24;
  }
LABEL_36:
  result.remainder.high = v21;
  result.remainder.low = v22;
  result.quotient.high = v19;
  result.quotient.low = v20;
  return result;
}

    uint64_t v21 = v16;
    if (v20 >= 2) {
      uint64_t v21 = *(void *)v16;
    }
    uint64_t v22 = *(uint64_t **)(v21 + 8 * v18);
LABEL_35:
    if (*((_WORD *)v22 + 8) != 224) {
      goto LABEL_42;
    }
    unint64_t v23 = *((unsigned __int8 *)v22 + 18);
    if (v23 == 5 && *((_DWORD *)v22 + 2))
    {
      uint64_t v22 = (uint64_t *)*v22;
LABEL_40:
      uint64_t v22 = (uint64_t *)*v22;
      goto LABEL_42;
    }

    uint64_t v22 = 0LL;
LABEL_42:
    if (v92) {
      break;
    }
    if (!v90 || (v90 & 1) != 0) {
      goto LABEL_52;
    }
    *(void *)(a5 + 8 * v18++) = v90;
    if (v17 == v18) {
      goto LABEL_53;
    }
  }

  if (v92 == 1)
  {
    BOOL v24 = v91(v90, 0LL, 0LL);
    v91(v90, 1LL, v24);
    if (v92 == 1) {
      v91(v90, 3LL, 0LL);
    }
  }

  uint64_t v15 = *v12;
  if (*((_WORD *)v15 + 8) != 153
    || v15[1] != (unsigned __int16 *)3
    || ((uint64_t v16 = *v15, v17 = *v16, v18 = *((unsigned __int8 *)v16 + 2), v17 == 24415) ? (v19 = v18 == 67) : (v19 = 0), !v19))
  {
LABEL_48:
    uint64_t v13 = *a1;
    goto LABEL_49;
  }

  uint64_t v20 = a2;
  if (v9 == 2)
  {
LABEL_40:
    uint64_t v21 = v20[1];
  }

  else
  {
    if (*((_DWORD *)a2 + 2) >= 2u)
    {
      uint64_t v20 = (int **)*a2;
      goto LABEL_40;
    }

    uint64_t v21 = 0LL;
  }

  if (*((_WORD *)v21 + 8) != 101) {
    goto LABEL_48;
  }
  uint64_t v22 = *(const void **)v21;
  if (*(void *)v21)
  {
    unint64_t v23 = *((void *)v21 + 1);
    if (v23 > 0x7FFFFFFFFFFFFFF7LL) {
      goto LABEL_197;
    }
    if (v23 >= 0x17)
    {
      char v75 = (v23 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v23 | 7) != 0x17) {
        char v75 = v23 | 7;
      }
      Swift::String v76 = v75 + 1;
      BOOL v24 = operator new(v75 + 1);
      *(void *)&v102[8] = v23;
      *(void *)&v102[16] = v76 | 0x8000000000000000LL;
      *(void *)uint64_t v102 = v24;
    }

    else
    {
      v102[23] = *((void *)v21 + 1);
      BOOL v24 = v102;
      if (!v23) {
        goto LABEL_162;
      }
    }

    memmove(v24, v22, v23);
LABEL_162:
    *((_BYTE *)v24 + v23) = 0;
    if ((v102[23] & 0x80u) == 0) {
      unint64_t v74 = v102;
    }
    else {
      unint64_t v74 = *(uint8_t **)v102;
    }
  }

  else
  {
    memset(v102, 0, sizeof(v102));
    unint64_t v74 = v102;
  }

  uint64_t v3 = (const char *)((unint64_t)objc_getProtocol((const char *)v74) | 1);
  return (uint64_t)v3;
}

        if (v15 >= v6) {
          goto LABEL_38;
        }
        unint64_t v23 = *(unsigned __int8 *)(v8 + v15);
        if (v23 == 95)
        {
          uint64_t v9 = 0;
          *((void *)this + 9) = v15 + 1;
          return swift::Demangle::__runtime::Demangler::getDependentGenericParamType(this, v13, v9, a4, a5);
        }

        BOOL v24 = 0;
        while (1)
        {
          unint64_t v25 = *(unsigned __int8 *)(v8 + v15);
          uint64_t v26 = v25 + 10 * v24 - 48;
          if (v26 >= v24)
          {
            *((void *)this + 9) = ++v15;
            BOOL v24 = v26;
            if (v6 != v15) {
              continue;
            }
          }

              if (!v19)
              {
                uint64_t v21 = 0LL;
                uint64_t v12 = 1;
                goto LABEL_63;
              }

              uint64_t v22 = v19 - 1;
              uint64_t v21 = *(unsigned __int16 **)(*((void *)this + 11) + 8LL * (v19 - 1));
              unint64_t v23 = v21[8];
              BOOL v24 = (v23 - 173) > 0x3C
                 || ((1LL << (v23 + 83)) & 0x100000010000010DLL) == 0;
              if (v24
                && ((v23 - 101) <= 0x24
                  ? (unint64_t v25 = ((1LL << (v23 - 101)) & 0x1000800001LL) == 0)
                  : (unint64_t v25 = 1),
                    v25 && v23 != 347))
              {
                uint64_t v21 = 0LL;
                uint64_t v12 = 1;
              }

              else
              {
                *uint64_t v15 = v22;
                uint64_t v12 = 1;
                --v19;
                if (!v22) {
                  goto LABEL_63;
                }
              }

    uint64_t v14 = v9 + 8;
    goto LABEL_31;
  }

  return result;
}

      goto LABEL_169;
    case 0x10uLL:
      if (*v23 == 0x2E6E69746C697542LL && v23[1] == 0x726F747563657845LL)
      {
        unint64_t v25 = v6;
        uint64_t v26 = 101;
        goto LABEL_214;
      }

      if (*v23 == 0x2E6E69746C697542LL && v23[1] == 0x6E656B6F544C4953LL)
      {
        unint64_t v25 = v6;
        uint64_t v26 = 116;
        goto LABEL_214;
      }

      goto LABEL_154;
    case 0x11uLL:
      this = memcmp(*(const void **)v3, "Builtin.PackIndex", *((void *)v3 + 1));
      if (!(_DWORD)this)
      {
        unint64_t v25 = v6;
        uint64_t v26 = 80;
        goto LABEL_214;
      }

      goto LABEL_169;
    case 0x12uLL:
      if (*v23 != 0x2E6E69746C697542LL || v23[1] != 0x746E696F50776152LL || *((_WORD *)v23 + 8) != 29285)
      {
        if (*v23 == 0x2E6E69746C697542LL && v23[1] == 0x726574694C746E49LL && *((_WORD *)v23 + 8) == 27745)
        {
          unint64_t v25 = v6;
          uint64_t v26 = 73;
          goto LABEL_214;
        }

  if (!*(_DWORD *)a8)
  {
    uint64_t v36 = *(_WORD *)(v8[2] + 16) == 290
        ? (swift::Demangle::__runtime::Node **)applyParamLabels( (swift::Demangle::__runtime::Node *)v8[2],  (swift::Demangle::__runtime::Node *)v8[3],  *(swift::Demangle::__runtime::NodeFactory **)v14)
        : (swift::Demangle::__runtime::Node **)v8[2];
    uint64_t v21 = *(_DWORD *)a8;
    if (!*(_DWORD *)a8)
    {
      uint64_t v22 = 0;
      uint64_t v8 = 0LL;
      goto LABEL_8;
    }
  }

  return result;
}

__objc2_class **specialized Array._makeUniqueAndReserveCapacityIfNotUnique()()
{
  uint64_t v1 = *v0;
  uint64_t result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(*v0);
  *uint64_t v0 = v1;
  if ((result & 1) == 0)
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v1 + 16) + 1LL,  1,  v1);
    *uint64_t v0 = (uint64_t)result;
  }

  return result;
}

uint64_t specialized Array._makeUniqueAndReserveCapacityIfNotUnique()()
{
  return specialized Array._makeUniqueAndReserveCapacityIfNotUnique()((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:));
}

{
  return specialized Array._makeUniqueAndReserveCapacityIfNotUnique()((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:));
}

{
  uint64_t *v0;
  uint64_t v1;
  uint64_t result;
  id v3;
  void *v4;
  uint64_t v1 = *v0;
  uint64_t result = swift_isUniquelyReferenced_nonNull_bridgeObject(*v0);
  *uint64_t v0 = v1;
  if ((result & 1) == 0 || v1 < 0 || (v1 & 0x4000000000000000LL) != 0)
  {
    if ((unint64_t)v1 >> 62)
    {
      if (v1 < 0) {
        uint64_t v4 = (void *)v1;
      }
      else {
        uint64_t v4 = (void *)(v1 & 0xFFFFFFFFFFFFFF8LL);
      }
      uint64_t v3 = objc_msgSend(v4, sel_count);
    }

    else
    {
      uint64_t v3 = *(id *)((v1 & 0xFFFFFFFFFFFFF8LL) + 0x10);
    }

    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0,  (uint64_t)v3 + 1,  1,  v1);
    *uint64_t v0 = result;
  }

  return result;
}

uint64_t specialized Array._makeUniqueAndReserveCapacityIfNotUnique()( uint64_t (*a1)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v3 = *v1;
  uint64_t result = swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = v3;
  if (!(_DWORD)result)
  {
    uint64_t result = a1(result, *(void *)(v3 + 16) + 1LL, 1LL, v3);
    *uint64_t v1 = result;
  }

  return result;
}

Swift::Void __swiftcall Array._makeUniqueAndReserveCapacityIfNotUnique()()
{
  uint64_t v2 = *(uint64_t **)(v0 + 16);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v2, v2);
  uint64_t v4 = *v1;
  if (isClassOrObjCExistentialType)
  {
    char isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(*v1);
    *uint64_t v1 = v4;
    if ((isUniquelyReferenced_nonNull_bridgeObject & 1) == 0
      || _swift_isClassOrObjCExistentialType((uint64_t)v2, v2) && (v4 < 0 || (v4 & 0x4000000000000000LL) != 0))
    {
      goto LABEL_6;
    }
  }

  else
  {
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
    *uint64_t v1 = v4;
    if (!isUniquelyReferenced_nonNull_native)
    {
LABEL_6:
      Swift::Int v6 = Array._getCount()();
      *uint64_t v1 = _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v6 + 1, 1, v4, v2);
    }
  }

Swift::Void __swiftcall Array._reserveCapacityAssumingUniqueBuffer(oldCount:)(Swift::Int oldCount)
{
  uint64_t v4 = *v2;
  uint64_t v5 = *(uint64_t **)(v1 + 16);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v5, v5);
  uint64_t v7 = v4 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v7 = v4;
  }
  unint64_t v8 = *(void *)(v7 + 24);
  if (oldCount + 1 > (uint64_t)(v8 >> 1)) {
    *uint64_t v2 = _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( v8 > 1,  oldCount + 1,  1,  *v2,  v5);
  }
}

uint64_t specialized Array._appendElementAssumeUniqueAndCapacity(_:newElement:)( uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *v3;
  *(void *)(v4 + 16) = result + 1;
  uint64_t v5 = v4 + 16 * result;
  *(void *)(v5 + 32) = a2;
  *(void *)(v5 + 40) = a3;
  return result;
}

_OWORD *specialized Array._appendElementAssumeUniqueAndCapacity(_:newElement:)(uint64_t a1, _OWORD *a2)
{
  uint64_t v3 = *v2;
  *(void *)(v3 + 16) = a1 + 1;
  return outlined init with take of Any(a2, (_OWORD *)(v3 + 32 * a1 + 32));
}

uint64_t specialized Array._appendElementAssumeUniqueAndCapacity(_:newElement:)(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *v2 & 0xFFFFFFFFFFFFFF8LL;
  *(void *)(v3 + 16) = result + 1;
  *(void *)(v3 + 8 * result + 32) = a2;
  return result;
}

uint64_t Array._appendElementAssumeUniqueAndCapacity(_:newElement:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v7 = *v3;
  unint64_t v8 = *(uint64_t **)(a3 + 16);
  if (_swift_isClassOrObjCExistentialType((uint64_t)v8, v8))
  {
    uint64_t v9 = v7 & 0xFFFFFFFFFFFFFF8LL;
    *(void *)((v7 & 0xFFFFFFFFFFFFFF8LL) + 0x10) = v6;
  }

  else
  {
    *(void *)(v7 + 16) = v6;
    uint64_t v9 = v7 & 0xFFFFFFFFFFFFFF8LL;
  }

  else {
    uint64_t v10 = v7;
  }
  return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t *))(*(v8 - 1) + 32))( v10 + ((*(unsigned __int8 *)(*(v8 - 1) + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(*(v8 - 1) + 80))
         + *(void *)(*(v8 - 1) + 72) * a1,
           a2,
           v8);
}

__objc2_class **specialized Array.append(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  uint64_t result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(*v2);
  *uint64_t v2 = v5;
  if ((result & 1) == 0)
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v5 + 16) + 1LL,  1,  v5);
    uint64_t v5 = (uint64_t)result;
    *uint64_t v2 = (uint64_t)result;
  }

  unint64_t v8 = *(void *)(v5 + 16);
  unint64_t v7 = *(void *)(v5 + 24);
  if (v8 >= v7 >> 1)
  {
    uint64_t result = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v7 > 1),  v8 + 1,  1,  v5);
    uint64_t v5 = (uint64_t)result;
  }

  *(void *)(v5 + 16) = v8 + 1;
  uint64_t v9 = v5 + 16 * v8;
  *(void *)(v9 + 32) = a1;
  *(void *)(v9 + 40) = a2;
  *uint64_t v2 = v5;
  return result;
}

_OWORD *specialized Array.append(_:)(_OWORD *a1)
{
  uint64_t v3 = *v1;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = v3;
  if (!isUniquelyReferenced_nonNull_native)
  {
    uint64_t v3 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v3 + 16) + 1LL,  1,  v3);
    *uint64_t v1 = v3;
  }

  unint64_t v6 = *(void *)(v3 + 16);
  unint64_t v5 = *(void *)(v3 + 24);
  if (v6 >= v5 >> 1)
  {
    uint64_t v3 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v5 > 1),  v6 + 1,  1,  v3);
    *uint64_t v1 = v3;
  }

  *(void *)(v3 + 16) = v6 + 1;
  uint64_t result = outlined init with take of Any(a1, (_OWORD *)(v3 + 32 * v6 + 32));
  *uint64_t v1 = v3;
  return result;
}

uint64_t Array.append(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *v2;
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType(*(void *)(a2 + 16), *(uint64_t **)(a2 + 16));
  uint64_t v7 = v5 & 0xFFFFFFFFFFFFF8LL;
  if (!isClassOrObjCExistentialType) {
    uint64_t v7 = v5;
  }
  Swift::Int v8 = *(void *)(v7 + 16);
  Array._reserveCapacityAssumingUniqueBuffer(oldCount:)(v8);
  return Array._appendElementAssumeUniqueAndCapacity(_:newElement:)(v8, a1, a2);
}

int64_t specialized Array.append<A>(contentsOf:)(uint64_t a1)
{
  int64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (__objc2_class **)*v1;
  int64_t v5 = *(void *)(*v1 + 16);
  int64_t v6 = v5 + v3;
  if (__OFADD__(v5, v3))
  {
    __break(1u);
    goto LABEL_17;
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = (uint64_t)v4;
  if (!isUniquelyReferenced_nonNull_native || (int64_t v9 = (unint64_t)v4[3] >> 1, v9 < v6))
  {
    if (v5 <= v6) {
      int64_t v10 = v5 + v3;
    }
    else {
      int64_t v10 = v5;
    }
    uint64_t v4 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)isUniquelyReferenced_nonNull_native,  v10,  1,  (uint64_t)v4);
    *uint64_t v1 = (uint64_t)v4;
    int64_t v9 = (unint64_t)v4[3] >> 1;
  }

  uint64_t v11 = v4[2];
  uint64_t v12 = v9 - (void)v11;
  if (v9 - (uint64_t)v11 < 0) {
LABEL_17:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  int64_t result = specialized Sequence._copySequenceContents(initializing:)(v45, (uint64_t)&v4[2 * (void)v11 + 4], v12, a1);
  if (result < v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x4DEuLL,  0);
  }
  if (result)
  {
    uint64_t v17 = v4[2];
    BOOL v18 = __OFADD__(v17, result);
    uint64_t v19 = (__objc2_class *)((char *)v17 + result);
    if (v18)
    {
      __break(1u);
      goto LABEL_49;
    }

    v4[2] = v19;
  }

  if (result != v12)
  {
    uint64_t v20 = v45[0];
LABEL_15:
    int64_t result = outlined consume of [A : B].Iterator._Variant<A, B>(v20);
    *uint64_t v1 = (uint64_t)v4;
    return result;
  }

  uint64_t v2 = (uint64_t)v4[2];
  int64_t v3 = v45[0];
  uint64_t v44 = v45[1];
  uint64_t v15 = v46;
  int64_t v6 = v47;
  if (v48)
  {
    unint64_t v21 = (v48 - 1) & v48;
    unint64_t v22 = __clz(__rbit64(v48)) | (v47 << 6);
    int64_t v43 = (unint64_t)(v46 + 64) >> 6;
    goto LABEL_21;
  }

LABEL_49:
  int64_t v39 = v6 + 1;
  if (__OFADD__(v6, 1LL)) {
    goto LABEL_65;
  }
  int64_t v43 = (unint64_t)(v15 + 64) >> 6;
  if (v39 >= v43)
  {
    uint64_t v20 = v3;
    goto LABEL_15;
  }

  unint64_t v40 = *(void *)(v44 + 8 * v39);
  int64_t v41 = v6 + 1;
  if (v40) {
    goto LABEL_52;
  }
  int64_t v41 = v6 + 2;
  if (v6 + 2 >= v43) {
    goto LABEL_46;
  }
  unint64_t v40 = *(void *)(v44 + 8 * v41);
  if (!v40)
  {
    int64_t v41 = v6 + 3;
    if (v6 + 3 >= v43) {
      goto LABEL_46;
    }
    unint64_t v40 = *(void *)(v44 + 8 * v41);
    if (!v40)
    {
      int64_t v41 = v6 + 4;
      if (v6 + 4 < v43)
      {
        unint64_t v40 = *(void *)(v44 + 8 * v41);
        if (!v40)
        {
          int64_t v42 = v6 + 5;
          do
          {
            if (v43 == v42) {
              goto LABEL_46;
            }
            unint64_t v40 = *(void *)(v44 + 8 * v42++);
          }

          while (!v40);
          int64_t v41 = v42 - 1;
        }

        goto LABEL_52;
      }

    LODWORD(v305) = v115 ^ 1;
    v162 = v333;
    v161 = v334;
    (*(void (**)(uint64_t, unint64_t))(v333 + 120))(v334, v333);
    v163 = v161;
    v164 = v80;
    uint64_t v165 = v319;
    v166 = *(void *)(swift_getAssociatedConformanceWitness( v162,  v163,  v319,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger)
                     + 8);
    v167 = (*(uint64_t (**)(unint64_t, uint64_t))(v166 + 144))(v165, v166);
    v168 = v167 + v108;
    v344 = v168;
    v169 = *(void (**)(uint64_t *, ValueMetadata *))(v127 + 88);
    v333 = lazy protocol witness table accessor for type Int and conformance Int(v167, v170, v171);
    v169(&v344, &type metadata for Int);
    v172 = v318;
    (*(void (**)(char *, char *, unint64_t *))(*(void *)(v317 + 8) + 40LL))(v342, v126, v45);
    ((void (*)(char *, unint64_t *))v330)(v126, v45);
    v173 = v341;
    unint64_t v174 = swift_getAssociatedConformanceWitness( v337,  v343,  (uint64_t)v341,  (uint64_t)&protocol requirements base descriptor for FixedWidthInteger,  (uint64_t)&associated conformance descriptor for FixedWidthInteger.Numeric.Magnitude: FixedWidthInteger);
    if (v168 >= (*(uint64_t (**)(unint64_t *, unint64_t))(v174 + 56))(v173, v174))
    {
      v183 = v315;
      (*(void (**)(char *, char *, unint64_t *, uint64_t, unint64_t, uint64_t))(v166 + 256))( v164,  v172,  v45,  v335,  v165,  v166);
      v184 = v172;
      v181 = v330;
      ((void (*)(char *, unint64_t *))v330)(v184, v45);
      (*(void (**)(char *, unint64_t))(v314 + 8))(v164, v165);
      uint64_t v185 = swift_getAssociatedConformanceWitness( v339,  v343,  (uint64_t)v173,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
      (*(void (**)(char *, unint64_t, uint64_t, unint64_t *, unint64_t))(v185 + 96))( v183,  v165,  v166,  v173,  v185);
      uint64_t v182 = v316;
      v179 = v338;
      v178 = v335;
    }

    else
    {
      v175 = v315;
      (*(void (**)(char *, char *, unint64_t))(v314 + 32))(v315, v164, v165);
      v176 = swift_getAssociatedConformanceWitness( v339,  v343,  (uint64_t)v173,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
      v177 = v327;
      (*(void (**)(char *, unint64_t, uint64_t, unint64_t *, unint64_t))(v176 + 96))( v175,  v165,  v166,  v341,  v176);
      v178 = v335;
      (*(void (**)(char *, char *, unint64_t *, uint64_t, unint64_t *, unint64_t))(v176 + 256))( v177,  v172,  v45,  v335,  v341,  v176);
      v179 = v338;
      (*(void (**)(char *, unint64_t *))(v328 + 8))(v177, v341);
      v180 = v172;
      v181 = v330;
      ((void (*)(char *, unint64_t *))v330)(v180, v45);
      uint64_t v182 = v316;
    }

    uint64_t v186 = v331();
    ((void (**)(char *, char *, unint64_t *))v336)[2](v182, v342, v45);
    if ((v186 & 1) != 0)
    {
      v187 = v296() - 1;
      v188 = v321(v45, v178);
      v189 = v320(v45, v178);
      if ((v188 & 1) != 0)
      {
        if (v189 > 64)
        {
          v344 = v187;
          v190 = v329;
          (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v178 + 96))( &v344,  &type metadata for Int,  v333,  v45,  v178);
          v191 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v178 + 16) + 8LL)
                                                                               + 8LL))( v190,  v182,  v45);
          ((void (*)(char *, unint64_t *))v181)(v190, v45);
          uint64_t v192 = v182;
          goto LABEL_68;
        }

      if ((v21 & 0x1000000000000000LL) != 0) {
        goto LABEL_66;
      }
      goto LABEL_50;
    }

    if (v25 == v26) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    unint64_t v28 = v22 & 0xFFFFFFFFFFFFLL;
    if ((v21 & 0x2000000000000000LL) != 0) {
      unint64_t v28 = HIBYTE(v21) & 0xF;
    }
    if (v28 <= rawBits >> 16)
    {
      int64_t v57 = 31LL;
LABEL_106:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v57,  0);
    }

    if ((rawBits & 1) != 0) {
      goto LABEL_49;
    }
    Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((v21 & 0x1000000000000000LL) != 0)
    {
LABEL_66:
      v6._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
      *(Swift::String::Index *)(v0 + 16) = v6;
      if ((v19 & 1) == 0) {
        goto LABEL_58;
      }
      goto LABEL_67;
    }

        uint64_t v100 = (v56 - 1) & v56;
        char v101 = v55;
        int64_t v47 = __clz(__rbit64(v56)) + (v55 << 6);
        uint64_t v46 = v102;
      }

      (*(void (**)(char *, unint64_t, char *))(v8 + 16))( v39,  *(void *)(v46 + 48) + *(void *)(v8 + 72) * v47,  v5);
      uint64_t v54 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
      goto LABEL_51;
    }

    unint64_t v48 = (void *)v92;
    uint64_t v49 = *(void *)(v92 + 216);
    if (v49 < 0) {
      goto LABEL_75;
    }
    if (v49 == *(void *)(v92 + 224)) {
      break;
    }
LABEL_34:
    uint64_t v51 = v48[3];
    if (!v51) {
      goto LABEL_81;
    }
    uint64_t v52 = (void **)(v51 + 8 * v49);
    uint64_t v53 = *v52;
    v48[27] = v49 + 1;
    swift_unknownObjectRetain(v53, v42, v43, v44);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v5, (uint64_t *)v5))
    {
      uint64_t v110 = v53;
      swift_dynamicCast(v39, (uint64_t *)&v110, v91, v5, 7uLL);
      uint64_t v54 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
    }

    else
    {
      uint64_t v54 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v8 + 56);
      v54(v90, 1LL, 1LL, v5);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v53, (uint64_t)v5, v90);
      swift_unknownObjectRelease(v53);
      v80 = v89;
      (*(void (**)(char *, uint64_t *, uint64_t))(v14 + 16))(v27, v90, v89);
      if ((*(unsigned int (**)(char *, uint64_t, char *))(v8 + 48))(v27, 1LL, v5) == 1) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      }
      (*(void (**)(uint64_t *, uint64_t))(v14 + 8))(v90, v80);
      (*(void (**)(char *, char *, char *))(v8 + 32))(v39, v27, v5);
    }

    uint64_t v100 = v99;
    char v101 = v103;
LABEL_51:
    v54((uint64_t *)v39, 0LL, 1LL, v5);
    char v58 = *(void (**)(id *, char *, char *))(v8 + 32);
    v58(v109, v39, v5);
    if (v97)
    {
      if (_swift_isClassOrObjCExistentialType((uint64_t)v5, (uint64_t *)v5))
      {
        if (v9 != 8) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }
        unint64_t v62 = v109;
        int64_t v63 = *v109;
        swift_unknownObjectRetain(*v109, v59, v60, v61);
        (*(void (**)(id *, char *))(v8 + 8))(v62, v5);
      }

      else
      {
        uint64_t v77 = v107;
        v58(v107, (char *)v109, v5);
        int64_t v63 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v77, (uint64_t *)v5, v78, v79);
      }

      uint64_t v64 = objc_msgSend(v94, sel_member_, v63);
      swift_unknownObjectRelease(v63);
      if (!v64) {
        goto LABEL_71;
      }
      swift_unknownObjectRelease(v64);
      uint64_t v45 = v100;
      int64_t v103 = v101;
      int64_t v39 = v98;
    }

    else
    {
      if (!*(void *)(v7 + 16))
      {
        (*(void (**)(id *, char *))(v8 + 8))(v109, v5);
LABEL_71:
        unint64_t v28 = 0LL;
        goto LABEL_72;
      }

      char v65 = (*(uint64_t (**)(void, char *, uint64_t))(a4 + 32))(*(void *)(v7 + 40), v5, a4);
      unint64_t v66 = -1LL << *(_BYTE *)(v7 + 32);
      id v67 = v65 & ~v66;
      if (((*(void *)(v106 + ((v67 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v67) & 1) == 0)
      {
        Swift::String v76 = *(void (**)(id *, char *))(v8 + 8);
LABEL_70:
        v76(v109, v108);
        goto LABEL_71;
      }

      Swift::String v104 = ~v66;
      unint64_t v68 = *(void *)(a4 + 8);
      uint64_t v69 = *(uint64_t (**)(id *, id *, char *, uint64_t))(v68 + 8);
      unint64_t v70 = *(void *)(v8 + 72);
      uint64_t v71 = v8;
      unint64_t v72 = *(void (**)(id *, unint64_t, char *))(v8 + 16);
      while (1)
      {
        unint64_t v74 = v107;
        uint64_t v73 = v108;
        v72(v107, *(void *)(v105 + 48) + v70 * v67, v108);
        char v75 = v69(v74, v109, v73, v68);
        Swift::String v76 = *(void (**)(id *, char *))(v71 + 8);
        v76(v74, v73);
        if ((v75 & 1) != 0) {
          break;
        }
        id v67 = (v67 + 1) & v104;
        if (((*(void *)(v106 + ((v67 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v67) & 1) == 0) {
          goto LABEL_70;
        }
      }

      int64_t v5 = v108;
      v76(v109, v108);
      uint64_t v45 = v100;
      int64_t v103 = v101;
      Swift::Int v8 = v71;
      a4 = v85;
      uint64_t v7 = v105;
      int64_t v9 = v84;
      uint64_t v14 = v83;
      uint64_t v27 = v96;
      int64_t v39 = v98;
    }
  }

  uint64_t v50 = objc_msgSend(*(id *)(v92 + 208), sel_countByEnumeratingWithState_objects_count_, v87, v86, 16);
  v48[28] = v50;
  if (v50)
  {
    uint64_t v49 = 0LL;
    v48[27] = 0LL;
    goto LABEL_34;
  }

  v48[27] = -1LL;
LABEL_75:
  unint64_t v28 = 1LL;
  (*(void (**)(char *, uint64_t, uint64_t, char *))(v8 + 56))(v39, 1LL, 1LL, v5);
LABEL_72:
  outlined consume of [A : B].Iterator._Variant<A, B>(v102);
  return v28;
}

  *(void *)(v4 + 16) = v17;
  return v4;
}

      v29 |= v30 << 8;
LABEL_50:
      v13._Swift::UInt64 rawBits = v29 | v21;
      if (!--offsetBy) {
        goto LABEL_55;
      }
    }

    unint64_t v24 = v13._rawBits >> 16;
    if ((v5 & 0x1000000000000000LL) == 0)
    {
      if ((v5 & 0x2000000000000000LL) == 0)
      {
        unint64_t v25 = (char *)v20;
        uint64_t v26 = v6 & 0xFFFFFFFFFFFFLL;
        if ((v6 & 0x1000000000000000LL) == 0)
        {
          uint64_t v61 = v20;
          unint64_t v62 = v16;
          int64_t v57 = v19;
          unint64_t v25 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
          uint64_t v19 = v57;
          uint64_t v20 = v61;
          uint64_t v16 = v62;
        }

        if (v24 + 1 == v26)
        {
LABEL_30:
          unint64_t v23 = 1LL;
          goto LABEL_31;
        }

        if (!v25) {
          goto LABEL_83;
        }
        uint64_t v27 = *(unsigned __int16 *)&v25[v24];
        if (v27 == 2573) {
          goto LABEL_54;
        }
        goto LABEL_29;
      }

      int64_t v63 = v6;
      uint64_t v64 = v19;
      if (v24 + 1 == v16) {
        goto LABEL_30;
      }
      uint64_t v27 = *(unsigned __int16 *)((char *)&v63 + v24);
      if (v27 != 2573)
      {
LABEL_29:
        if ((v27 & 0x80808080) == 0) {
          goto LABEL_30;
        }
      }
    }

    if ((v9 & ~v8 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v52 = _StringGuts.nativeUnusedCapacity.getter(v9, v8);
      if ((v53 & 1) != 0)
      {
LABEL_208:
        v170 = 258LL;
        goto LABEL_209;
      }

      if (v50 >= 16 || (v8 & 0x2000000000000000LL) == 0 && v52 >= (uint64_t)v13)
      {
LABEL_55:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v50, v13);
        swift_bridgeObjectRelease(v7._rawBits);
        if ((v7._rawBits & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v179, v7._rawBits, v171, v12);
          goto LABEL_66;
        }

        if ((v7._rawBits & 0x2000000000000000LL) != 0)
        {
          swift_bridgeObjectRelease(v7._rawBits);
          uint64_t v82 = HIBYTE(v7._rawBits) & 0xF;
          v180 = v179;
          v181 = v7._rawBits & 0xFFFFFFFFFFFFFFLL;
          if (v82 >= v12)
          {
            uint64_t v83 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v171, v12, (uint64_t)&v180, v82);
            _StringGuts.appendInPlace(_:isASCII:)(v83, v84, (v7._rawBits & 0x4000000000000000LL) != 0);
LABEL_69:
            Swift::String v85 = a4;
            uint64_t v86 = startingAt;
            uint64_t v87 = v182 & 0xFFFFFFFFFFFFLL;
            if ((v183 & 0x2000000000000000LL) != 0) {
              uint64_t v87 = HIBYTE(v183) & 0xF;
            }
            a4 = v87;
            specialized String.append<A>(contentsOf:)(a3, v85, v80, v81);
            uint64_t v13 = v182;
            int64_t v9 = v183;
            int64_t v90 = HIBYTE(v183) & 0xF;
            if ((v183 & 0x2000000000000000LL) == 0) {
              int64_t v90 = v182 & 0xFFFFFFFFFFFFLL;
            }
            startingAt = v90;
            swift_bridgeObjectRetain_n(v183, 3LL, v88, v89);
            v91._Swift::UInt64 rawBits = v6._rawBits;
            uint64_t v11 = specialized Collection.subscript.getter(v91, v86, v174);
            Swift::Int v8 = v92;
            v179 = v48;
            uint64_t v15 = v49;
            v6._Swift::UInt64 rawBits = v11 >> 16;
            uint64_t v12 = v92 >> 16;
            if ((v49 & 0x1000000000000000LL) == 0)
            {
              v7._Swift::UInt64 rawBits = v12 - v6._rawBits;
              swift_bridgeObjectRetain_n(v49, 2LL, v48, (char *)v49);
              unint64_t v93 = v9;
              goto LABEL_75;
            }

            goto LABEL_152;
          }
        }

        else if ((v179 & 0x1000000000000000LL) != 0)
        {
          uint64_t v54 = (id)((v7._rawBits & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v55 = v179 & 0xFFFFFFFFFFFFLL;
          if ((v179 & 0xFFFFFFFFFFFFLL) >= (uint64_t)v12)
          {
LABEL_59:
            int64_t v56 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v171, v12, (uint64_t)v54, v55);
            _StringGuts.appendInPlace(_:isASCII:)(v56, v57, v179 < 0);
LABEL_66:
            swift_bridgeObjectRelease(v7._rawBits);
            goto LABEL_69;
          }
        }

        else
        {
          uint64_t v54 = _StringObject.sharedUTF8.getter(v179, v7._rawBits);
          uint64_t v55 = v165;
        }

          int64_t v30 = v20;
          if (v28 >= 2) {
            int64_t v30 = *(void *)v20;
          }
          if (*(_WORD *)(*(void *)(v30 + 8 * v25) + 16LL) == 101)
          {
            unint64_t v31 = *(unsigned __int8 *)(v20 + 18);
            switch(v27)
            {
              case 1:
                goto LABEL_56;
              case 5:
                if (*(unsigned int *)(v20 + 8) > v25)
                {
LABEL_57:
                  unint64_t v32 = v20;
                  if (v28 >= 2) {
                    unint64_t v32 = *(void *)v20;
                  }
                  uint64_t v26 = *(void *)(v32 + 8 * v25);
                  goto LABEL_40;
                }

  if (prespecializedLoggingEnabled) {
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Prespecializations library: Returning data %p, major version %u minor %u\n",  swift_prespecialized_data,  *swift_prespecialized_data,  swift_prespecialized_data[1]);
  }
  return swift_prespecialized_data;
}

    unint64_t v32 = v18 + (v18 >> 2);
    if (v32 <= v18 + 1) {
      unint64_t v32 = v18 + 1;
    }
    unint64_t v33 = malloc_good_size(8 * v32 + 8);
    uint64_t v34 = malloc(v33);
    if (!v34) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v31 = (unint64_t)v34;
    *uint64_t v34 = (v33 + 0x7FFFFFFF8LL) >> 3;
    if (v19)
    {
      memcpy(v34 + 2, v20, 8 * v18);
      int64_t v35 = malloc(0x10uLL);
      *int64_t v35 = qword_18C486CE8;
      v35[1] = v19;
      qword_18C486CE8 = (uint64_t)v35;
    }

    atomic_store(v31, &qword_18C486CD0);
    goto LABEL_55;
  }

  uint64_t v2 = *v21;
  __dmb(0xBu);
  if (!ExtendedExistentialTypes)
  {
    unint64_t v23 = (void **)qword_18C486CE8;
    if (qword_18C486CE8)
    {
      do
      {
        unint64_t v24 = (void **)*v23;
        free(v23[1]);
        free(v23);
        unint64_t v23 = v24;
      }

      while (v24);
    }

    qword_18C486CE8 = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C486CE0);
  qword_18C486CF0 = v2;
LABEL_79:
  if (v2) {
    return v2 + 16;
  }
  else {
    return 0LL;
  }
}

  while (1)
  {
    v6 += v9;
    uint64_t v27 = *(unsigned int *)(v6 + 4);
    int64_t v9 = 8 * v27 + 8;
    if (*(_DWORD *)(v6 + 4)) {
      goto LABEL_26;
    }
  }

  swift_getTypeByMangledNode(a1, (uint64_t)&v56, (swift::Demangle::__runtime::Node *)v19, a4, v54, v52, a7);
  uint64_t v44 = v53;
  if (v53 == v52)
  {
    uint64_t v45 = 4LL;
    uint64_t v44 = v52;
  }

  else
  {
    if (!v53) {
      goto LABEL_54;
    }
    uint64_t v45 = 5LL;
  }

  (*(void (**)(void))(*v44 + 8 * v45))();
LABEL_54:
  uint64_t v46 = v55;
  if (v55 == v54)
  {
    int64_t v47 = 4LL;
    uint64_t v46 = v54;
  }

  else
  {
    if (!v55) {
      goto LABEL_59;
    }
    int64_t v47 = 5LL;
  }

  (*(void (**)(void))(*v46 + 8 * v47))();
LABEL_59:
  int64_t v56 = off_189B8E500;
  unint64_t v48 = v96;
  if (v96 == v95)
  {
    uint64_t v49 = 4LL;
    unint64_t v48 = v95;
  }

  else
  {
    if (!v96) {
      goto LABEL_64;
    }
    uint64_t v49 = 5LL;
  }

  (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_64:
  int64_t v56 = off_189B8E4D8;
  int64_t result = swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v59);
  if (v60) {
    *(_BYTE *)(v60 + 48) = 0;
  }
  return result;
}

      unint64_t v25 = *v13;
      if (qword_18C486DD8 != -1) {
      uint64_t v26 = (const char **)a2;
      }
      if (*((_WORD *)a2 + 8) == 232)
      {
        uint64_t v27 = *((unsigned __int8 *)a2 + 18);
        unint64_t v28 = (const char ***)a2;
        if (v27 == 5 && *((_DWORD *)a2 + 2))
        {
          unint64_t v28 = (const char ***)*a2;
LABEL_56:
          uint64_t v26 = *v28;
        }

        else
        {
          uint64_t v26 = 0LL;
        }
      }

      if (*((_WORD *)v26 + 8) == 181)
      {
        int64_t v3 = *v26;
        goto LABEL_60;
      }

      int64_t v30 = descriptorFromStandardMangling((int **)v26);
      if (v30) {
        return (uint64_t)v30;
      }
      *(void *)uint64_t v102 = v25;
      swift::Demangle::__runtime::mangleNode((uint64_t)a2);
      if (v99)
      {
        int64_t v3 = 0LL;
        goto LABEL_60;
      }

      if (!__src)
      {
        memset(&__dst, 0, sizeof(__dst));
        goto LABEL_80;
      }

      unint64_t v31 = __len;
      if (__len <= 0x7FFFFFFFFFFFFFF7LL)
      {
        if (__len >= 0x17)
        {
          unint64_t v33 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
          if ((__len | 7) != 0x17) {
            unint64_t v33 = __len | 7;
          }
          uint64_t v34 = v33 + 1;
          p_dst = (std::string *)operator new(v33 + 1);
          __dst.__r_.__value_.__l.__size_ = __len;
          __dst.__r_.__value_.__l.__cap_ = v34 | 0x8000000000000000LL;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }

        else
        {
          __dst.__r_.__value_.__s.__size_ = __len;
          p_dst = &__dst;
          if (!__len)
          {
LABEL_79:
            p_dst->__r_.__value_.__s.__data_[v31] = 0;
            do
LABEL_80:
            do
            {
              unint64_t v36 = atomic_load(&qword_18C486D90);
              int64_t v37 = atomic_load((unint64_t *)&qword_18C486D98);
              int64_t v38 = atomic_load((unsigned int *)&dword_18C486D8C);
              int64_t v39 = atomic_load(&qword_18C486D90);
            }

            while (v36 != v39);
            if (v36) {
              unint64_t v40 = v37 == 0;
            }
            else {
              unint64_t v40 = 1;
            }
            if (!v40 && v38 != 0)
            {
              if (v42)
              {
                int64_t v3 = *(const char **)(v42 + 16);
                do
LABEL_193:
LABEL_60:
                if (v3) {
                  return (uint64_t)v3;
                }
                swift::Demangle::__runtime::mangleNodeAsObjcCString((swift::Demangle::__runtime *)a2, *v13, a3);
                if (!*(_DWORD *)v102)
                {
                  Protocol = objc_getProtocol(name);
                  if (Protocol) {
                    return (unint64_t)Protocol | 1;
                  }
                  else {
                    return 0LL;
                  }
                }

                return 0LL;
              }
            }

            do
            if (swift::runtime::trace::LogsToken != -1) {
              dispatch_once_f( &swift::runtime::trace::LogsToken,  0LL,  (dispatch_function_t)swift::runtime::trace::setupLogs);
            }
            if (swift::runtime::trace::TracingEnabled)
            {
              uint64_t v45 = os_signpost_id_generate((os_log_t)swift::runtime::trace::ScanLog);
              if (v45 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                uint64_t v46 = (os_log_s *)swift::runtime::trace::ScanLog;
                if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
                {
                  if (a2)
                  {
                    v102[0] = 0;
                    *(void *)&v102[1] = 0x101010101010101LL;
                    v102[9] = 1;
                    *(void *)&v102[10] = 0x101010100000000LL;
                    v102[18] = 1;
                    *(_WORD *)&v102[19] = 256;
                    v102[21] = 1;
                    name = 0LL;
                    Swift::String v104 = 0LL;
                    v105[0] = &unk_189B8B0E8;
                    v105[1] = swift::Demangle::__runtime::genericParameterName;
                    uint64_t v106 = v105;
                    swift::Demangle::__runtime::nodeToString( (swift::Demangle::__runtime::Node *)a2,  (__int128 *)v102,  &v107);
                    if ((v107.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                      int64_t v47 = &v107;
                    }
                    else {
                      int64_t v47 = (std::string *)v107.__r_.__value_.__r.__words[0];
                    }
                    *(_DWORD *)buf = 136315138;
                    char v109 = (const char *)v47;
                    _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v46,  OS_SIGNPOST_INTERVAL_BEGIN,  v45,  "section_scan",  "protocol scan for '%s'",  buf,  0xCu);
                    unint64_t v48 = v106;
                    if (v106 == v105)
                    {
                      uint64_t v49 = 4LL;
                      unint64_t v48 = v105;
LABEL_196:
                      (*(void (**)(void))(*v48 + 8 * v49))();
                    }

                    else if (v106)
                    {
                      uint64_t v49 = 5LL;
                      goto LABEL_196;
                    }
                  }

                  else
                  {
                    *(_DWORD *)buf = 136315138;
                    char v109 = "<null>";
                    _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v46,  OS_SIGNPOST_INTERVAL_BEGIN,  v45,  "section_scan",  "protocol scan for '%s'",  buf,  0xCu);
                  }
                }
              }
            }

            else
            {
LABEL_109:
              uint64_t v45 = 0LL;
            }

            unint64_t v96 = v45;
            do
              uint64_t v50 = __ldaxr((unint64_t *)&qword_18C486DB8);
            while (__stxr(v50 + 1, (unint64_t *)&qword_18C486DB8));
            if (qword_18C486DC0 && (uint64_t v51 = atomic_load((unint64_t *)qword_18C486DC0)) != 0)
            {
              uint64_t v52 = (int **)(qword_18C486DC0 + 8);
              uint64_t v53 = qword_18C486DC0 + 8 + 16 * v51;
              while (1)
              {
                uint64_t v54 = *v52;
                uint64_t v55 = v52[1];
                if (*v52 != v55) {
                  break;
                }
LABEL_115:
                v52 += 2;
              }

              int64_t v56 = *v52;
              while (1)
              {
                int64_t v57 = *v56;
                if ((v57 & 0xFFFFFFFD) != 0)
                {
                  int64_t v3 = (char *)v54 + (v57 & 0xFFFFFFFFFFFFFFFCLL);
                  if ((v57 & 1) != 0) {
                    int64_t v3 = *(const char **)v3;
                  }
                }

                ++v56;
                ++v54;
                if (v56 == v55) {
                  goto LABEL_115;
                }
              }

              if (v96 - 1 < 0xFFFFFFFFFFFFFFFELL)
              {
                char v58 = (os_log_s *)swift::runtime::trace::ScanLog;
                if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
                {
                  *(_DWORD *)uint64_t v102 = 134217984;
                  *(void *)&v102[4] = v3;
                  _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v58,  OS_SIGNPOST_INTERVAL_END,  v96,  "section_scan",  "result=%p",  v102,  0xCu);
                }
              }

              do
                uint64_t v59 = __ldxr((unint64_t *)&qword_18C486DB8);
              while (__stlxr(v59 - 1, (unint64_t *)&qword_18C486DB8));
              if ((char)__dst.__r_.__value_.__s.__size_ < 0) {
                std::string::__init_copy_ctor_external( &v97,  __dst.__r_.__value_.__l.__data_,  __dst.__r_.__value_.__l.__size_);
              }
              else {
                unint64_t v97 = __dst;
              }
              os_unfair_lock_lock((os_unfair_lock_t)&unk_18C486DA0);
              unint64_t v62 = qword_18C486D98;
              int64_t v63 = (qword_18C486D98 & 3) == 0;
              if ((qword_18C486D98 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
                int64_t v63 = 1;
              }
              unint64_t v93 = v63;
              uint64_t v94 = qword_18C486D98 & 0xFFFFFFFFFFFFFFFCLL;
              if (v63) {
                uint64_t v64 = 4;
              }
              else {
                uint64_t v64 = *(unsigned __int8 *)(qword_18C486D98 & 0xFFFFFFFFFFFFFFFCLL);
              }
              char v65 = dword_18C486D8C;
              unint64_t v66 = (_DWORD *)qword_18C486D90;
              if (!v67)
              {
                char v91 = v66 + 2;
                uint64_t v92 = v65 + 1;
                if ((1LL << v64) / ((1LL << v64) - (unint64_t)(v65 + 1)) < 4)
                {
                  unint64_t v95 = v62;
                  uint64_t v77 = v66;
                }

                else
                {
                  int64_t v90 = v65;
                  unint64_t v70 = (v64 + 1);
                  if (v70 >= 0x11) {
                    uint64_t v71 = 4;
                  }
                  else {
                    uint64_t v71 = 2;
                  }
                  if (v70 < 9) {
                    unint64_t v72 = 1LL;
                  }
                  else {
                    unint64_t v72 = v71;
                  }
                  uint64_t v73 = (unint64_t)calloc(2LL << v64, v72);
                  if (!v73) {
                    swift::hashable_support::findHashableBaseTypeOfHashableType();
                  }
                  if ((_DWORD)v72 != 1)
                  {
                    if ((_DWORD)v72 == 4) {
                      unint64_t v72 = 3LL;
                    }
                    else {
                      unint64_t v72 = 2LL;
                    }
                  }

                  uint64_t v78 = v72 | v73;
                  *(_BYTE *)uint64_t v73 = v64 + 1;
                  unint64_t v95 = v72 | v73;
                  if (v64) {
                    __asm { BR              X8 }
                  }

                  atomic_store(v78, (unint64_t *)&qword_18C486D98);
                  char v65 = v90;
                  if (!v93)
                  {
                    uint64_t v79 = malloc(0x10uLL);
                    LOBYTE(v78) = v95;
                    char *v79 = qword_18C486DA8;
                    v79[1] = v94;
                    qword_18C486DA8 = (uint64_t)v79;
                  }

                  uint64_t v77 = v66;
                }

                if (!v77 || (v80 = (unint64_t)v77, v65 >= *v77))
                {
                  uint64_t v81 = v65 + (v65 >> 2);
                  if (v81 <= v65 + 1) {
                    uint64_t v81 = v65 + 1;
                  }
                  uint64_t v82 = malloc_good_size(24 * v81 + 8);
                  uint64_t v83 = malloc(v82);
                  if (!v83) {
                    swift::hashable_support::findHashableBaseTypeOfHashableType();
                  }
                  v80 = (unint64_t)v83;
                  void *v83 = (v82 - 8) / 0x18;
                  if (v77)
                  {
                    memcpy(v83 + 2, v91, 24 * v65);
                    Swift::Int v84 = malloc(0x10uLL);
                    void *v84 = qword_18C486DA8;
                    v84[1] = v77;
                    qword_18C486DA8 = (uint64_t)v84;
                  }

                  atomic_store(v80, &qword_18C486D90);
                }

                Swift::String v85 = (void *)(v80 + 24LL * v65);
                if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  uint64_t v86 = &__dst;
                }
                else {
                  uint64_t v86 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                }
                if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  size = __dst.__r_.__value_.__s.__size_;
                }
                else {
                  size = __dst.__r_.__value_.__l.__size_;
                }
                v85[3] = v3;
                int64_t v88 = malloc(size);
                memcpy(v88, v86, size);
                v85[1] = v88;
                v85[2] = size;
                int64_t v89 = v95 & 3;
                atomic_store(v92, (unsigned int *)&dword_18C486D8C);
                __asm { BR              X11 }
              }

              __dmb(0xBu);
              {
                unint64_t v68 = (void **)qword_18C486DA8;
                if (qword_18C486DA8)
                {
                  do
                  {
                    uint64_t v69 = (void **)*v68;
                    free(v68[1]);
                    free(v68);
                    unint64_t v68 = v69;
                  }

                  while (v69);
                }

                qword_18C486DA8 = 0LL;
              }

              os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C486DA0);
            }

            else
            {
              do
LABEL_130:
                unint64_t v60 = __ldxr((unint64_t *)&qword_18C486DB8);
              while (__stlxr(v60 - 1, (unint64_t *)&qword_18C486DB8));
              if (v96 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                uint64_t v61 = (os_log_s *)swift::runtime::trace::ScanLog;
                if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
                {
                  *(_DWORD *)uint64_t v102 = 134217984;
                  *(void *)&v102[4] = 0LL;
                  _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v61,  OS_SIGNPOST_INTERVAL_END,  v96,  "section_scan",  "result=%p",  v102,  0xCu);
                }
              }

              int64_t v3 = 0LL;
            }

            goto LABEL_193;
          }
        }

        memmove(p_dst, __src, __len);
        goto LABEL_79;
      }

    this->__end_ = v17;
    if (end != v9 + 1) {
      memmove(&end[-v12], v9, v11);
    }
    if (v9 <= v3) {
      v3 += this->__end_ > v3;
    }
    *int64_t v9 = *v3;
    return (std::vector<unsigned int>::iterator)v9;
  }

  BOOL v18 = end - begin + 1;
  if (v18 >> 62) {
    abort();
  }
  uint64_t v20 = (char *)value - (char *)begin;
  if (v20 >> 1 > v18) {
    BOOL v18 = v20 >> 1;
  }
  else {
    unint64_t v21 = v18;
  }
  if (v21)
  {
    if (v21 >> 62) {
      goto LABEL_56;
    }
    unint64_t v22 = (char *)operator new(4 * v21);
  }

  else
  {
    unint64_t v22 = 0LL;
  }

  unint64_t v23 = (unsigned int *)&v22[4 * v8];
  unint64_t v24 = (unsigned int *)&v22[4 * v21];
  if (v8 != v21)
  {
LABEL_24:
    uint64_t v26 = begin;
    goto LABEL_25;
  }

  if (v7 >= 1)
  {
    unint64_t v25 = v8 + 2;
    if (v8 >= -1) {
      unint64_t v25 = v8 + 1;
    }
    v23 -= v25 >> 1;
    goto LABEL_24;
  }

  if (begin == __position.__i_) {
    int64_t v43 = 1LL;
  }
  else {
    int64_t v43 = v7 >> 1;
  }
  if (v43 >> 62) {
LABEL_56:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v44 = 4 * v43;
  uint64_t v45 = (char *)operator new(4 * v43);
  unint64_t v23 = (unsigned int *)&v45[v43 & 0xFFFFFFFFFFFFFFFCLL];
  unint64_t v24 = (unsigned int *)&v45[v44];
  if (!v22) {
    goto LABEL_24;
  }
  uint64_t v46 = (unsigned int *)&v45[v44];
  operator delete(v22);
  unint64_t v24 = v46;
  uint64_t v26 = this->__begin_;
LABEL_25:
  void *v23 = *v3;
  uint64_t v27 = v23;
  if (v26 != v9)
  {
    unint64_t v28 = (char *)begin + (v7 & 0xFFFFFFFFFFFFFFFCLL);
    int64_t v29 = v28 - (char *)v26 - 4;
    int64_t v30 = v9;
    uint64_t v27 = v23;
    if (v29 < 0x2C) {
      goto LABEL_60;
    }
    int64_t v30 = v9;
    uint64_t v27 = v23;
    unint64_t v31 = (v29 >> 2) + 1;
    unint64_t v32 = 4 * (v31 & 0x7FFFFFFFFFFFFFF8LL);
    int64_t v30 = &v9[v32 / 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v27 = &v23[v32 / 0xFFFFFFFFFFFFFFFCLL];
    unint64_t v33 = v23 - 4;
    uint64_t v34 = &begin[v8 - 4];
    int64_t v35 = v31 & 0x7FFFFFFFFFFFFFF8LL;
    do
    {
      unint64_t v36 = *(_OWORD *)v34;
      *((_OWORD *)v33 - 1) = *((_OWORD *)v34 - 1);
      *(_OWORD *)unint64_t v33 = v36;
      v33 -= 8;
      v34 -= 8;
      v35 -= 8LL;
    }

    while (v35);
    if (v31 != (v31 & 0x7FFFFFFFFFFFFFF8LL))
    {
LABEL_60:
      do
      {
        int64_t v37 = *--v30;
        *--uint64_t v27 = v37;
      }

      while (v30 != v26);
    }
  }

  int64_t v38 = this->__end_;
  int64_t v39 = (char *)v38 - (char *)v9;
  if (v38 != v9)
  {
    unint64_t v40 = v9;
    int64_t v41 = (char *)v38 - (char *)v9;
    int64_t v42 = v24;
    memmove(v23 + 1, v40, v41);
    unint64_t v24 = v42;
    uint64_t v26 = this->__begin_;
  }

  this->__begin_ = v27;
  this->__end_ = (unsigned int *)((char *)v23 + v39 + 4);
  this->__end_cap_.__value_ = v24;
  if (v26) {
    operator delete(v26);
  }
  return (std::vector<unsigned int>::iterator)v23;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

        unint64_t v24 = 0LL;
        goto LABEL_50;
      }

      uint64_t v16 = *(swift::Demangle::__runtime::Node **)v5;
    }

    if (*(_WORD *)(*((void *)v16 + 1) + 16LL) != 232) {
      goto LABEL_44;
    }
    BOOL v18 = v5;
    if (v15 != 2)
    {
      if (*((_DWORD *)v5 + 2) < 2u)
      {
        uint64_t v19 = 0LL;
        goto LABEL_29;
      }

      BOOL v18 = *(swift::Demangle::__runtime::Node **)v5;
    }

    uint64_t v19 = *((void *)v18 + 1);
LABEL_29:
    uint64_t v20 = *(unsigned __int8 *)(v19 + 18);
    if (v20 == 1 || v20 == 5 && *(_DWORD *)(v19 + 8) == 1)
    {
      unint64_t v21 = v5;
      if (v15 != 2)
      {
        if (*((_DWORD *)v5 + 2) < 2u)
        {
          unint64_t v22 = 0LL;
LABEL_37:
          if (*(_WORD *)(*(void *)v22 + 16LL) == 180)
          {
            if (v15 != 2)
            {
              if (*((_DWORD *)v5 + 2) < 2u)
              {
                unint64_t v23 = 0LL;
LABEL_52:
                unint64_t v25 = *((unsigned __int8 *)v23 + 18);
                if ((v25 - 1) >= 2)
                {
                  if (v25 != 5 || !*((_DWORD *)v23 + 2))
                  {
                    uint64_t v26 = 0LL;
                    goto LABEL_58;
                  }

                  unint64_t v23 = *(swift::Demangle::__runtime::Node **)v23;
                }

                uint64_t v26 = *(swift::Demangle::__runtime::Node **)v23;
LABEL_58:
                return;
              }

              int64_t v5 = *(swift::Demangle::__runtime::Node **)v5;
            }

            unint64_t v23 = (swift::Demangle::__runtime::Node *)*((void *)v5 + 1);
            goto LABEL_52;
          }

          goto LABEL_44;
        }

        unint64_t v21 = *(swift::Demangle::__runtime::Node **)v5;
      }

      unint64_t v22 = (unsigned __int8 *)*((void *)v21 + 1);
      goto LABEL_37;
    }

LABEL_46:
      uint64_t v20 = v3;
      goto LABEL_15;
    }
  }

      if ((v25 & 1) != 0) {
        goto LABEL_53;
      }
      if (!v27)
      {
        uint64_t v73 = v11;
        unint64_t v74 = rawBits;
        swift_bridgeObjectRetain(rawBits, v22, v23, v24);
        swift_retain(a10, v54, v55, v56);
        a9(&v75, &v73);
        swift_release((uint64_t)a10);
        swift_bridgeObjectRelease(rawBits);
        uint64_t v17 = v75;
        uint64_t v15 = v76;
        int64_t v57 = (v75 >> 59) & 1;
        if ((v76 & 0x1000000000000000LL) == 0) {
          LOBYTE(v57) = 1;
        }
        Swift::UInt64 rawBits = to._rawBits;
        if ((to._rawBits & 0xC) == 4LL << v57) {
          goto LABEL_70;
        }
        if ((v76 & 0x1000000000000000LL) != 0) {
          goto LABEL_71;
        }
        goto LABEL_52;
      }

      goto LABEL_56;
    }

    if (v27) {
      goto LABEL_56;
    }
    int64_t v41 = v11;
    int64_t v42 = v26;
    unint64_t v66 = v12;
    id v67 = v41;
    uint64_t v73 = v41;
    unint64_t v74 = rawBits;
    swift_bridgeObjectRetain(rawBits, v22, v23, v24);
    swift_retain(a10, v43, v44, v45);
    a9(&v75, &v73);
    swift_release((uint64_t)a10);
    swift_bridgeObjectRelease(rawBits);
    uint64_t v17 = v76;
    if ((v76 & 0x2000000000000000LL) != 0) {
      uint64_t v46 = HIBYTE(v76) & 0xF;
    }
    else {
      uint64_t v46 = v75 & 0xFFFFFFFFFFFFLL;
    }
    int64_t v47 = v46 << 16;
    unint64_t v48 = (v75 >> 59) & 1;
    uint64_t v49 = (v76 & 0x1000000000000000LL) == 0 || (v75 & 0x800000000000000LL) != 0;
    if (v49 == 1)
    {
      v50._Swift::UInt64 rawBits = v47 | 7;
      uint64_t v51 = v42;
      if ((v76 & 0x1000000000000000LL) == 0) {
        LOBYTE(v48) = 1;
      }
    }

    else
    {
      v50._Swift::UInt64 rawBits = v47 | 0xB;
      uint64_t v51 = v42;
    }

    uint64_t v11 = v67;
    if ((v51 & 0xC) == 4LL << v48)
    {
      char v65 = v46;
      v60._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v51)._rawBits;
      uint64_t v46 = v65;
      uint64_t v51 = v60._rawBits;
    }

    if ((v50._rawBits & 0xC) == 4LL << v49)
    {
      v61._Swift::UInt64 rawBits = v50._rawBits;
      unint64_t v68 = v51;
      unint64_t v62 = v46;
      v63._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v61)._rawBits;
      uint64_t v46 = v62;
      uint64_t v51 = v68;
      v50._Swift::UInt64 rawBits = v63._rawBits;
      uint64_t v52 = v63._rawBits >> 16;
      if ((v17 & 0x1000000000000000LL) == 0) {
        goto LABEL_44;
      }
    }

    else
    {
      uint64_t v52 = v50._rawBits >> 16;
      if ((v17 & 0x1000000000000000LL) == 0)
      {
LABEL_44:
        uint64_t v53 = v17;
        uint64_t v17 = v51;
        swift_bridgeObjectRelease(v53);
        uint64_t v34 = v52 - (v17 >> 16);
        goto LABEL_45;
      }
    }

    if (v46 < v51 >> 16 || v46 < v52) {
      goto LABEL_77;
    }
    uint64_t v34 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v51, v50);
    swift_bridgeObjectRelease(v17);
LABEL_45:
    uint64_t v27 = 1LL;
    uint64_t v12 = v66;
    unint64_t v25 = v72;
    if (v71 > 1) {
      goto LABEL_20;
    }
    goto LABEL_46;
  }

  if ((a6 & 1) != 0)
  {
    if ((a3 & 1) != 0) {
      return 0LL;
    }
LABEL_78:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/Flatten.swift",  19LL,  2,  0xC8uLL,  0);
  }

  if ((a3 & 1) != 0) {
    goto LABEL_78;
  }
  if (a4) {
    goto LABEL_56;
  }
  int64_t v29 = a5;
  uint64_t v73 = a7;
  unint64_t v74 = a8;
  swift_bridgeObjectRetain(a8, a2, a3, 0LL);
  a9(&v75, &v73);
  swift_bridgeObjectRelease(rawBits);
  unint64_t v31 = v75;
  int64_t v30 = v76;
  unint64_t v32 = (v75 >> 59) & 1;
  if ((v76 & 0x1000000000000000LL) == 0) {
    LOBYTE(v32) = 1;
  }
  unint64_t v33 = 4LL << v32;
  if ((v14 & 0xC) == 4LL << v32) {
    uint64_t v14 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v14)._rawBits;
  }
  if ((v29 & 0xC) != v33)
  {
    if ((v30 & 0x1000000000000000LL) == 0) {
      goto LABEL_16;
    }
    goto LABEL_58;
  }

  int64_t v29 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v29)._rawBits;
  if ((v30 & 0x1000000000000000LL) != 0)
  {
LABEL_58:
    char v58 = HIBYTE(v30) & 0xF;
    if ((v30 & 0x2000000000000000LL) == 0) {
      char v58 = v31 & 0xFFFFFFFFFFFFLL;
    }
    if (v58 >= v14 >> 16 && v58 >= v29 >> 16)
    {
      uint64_t v59 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v14, (Swift::String::Index)v29);
      swift_bridgeObjectRelease(v30);
      return v59;
    }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v325 + 56))(v326, 1LL, 1LL, v343);
  v160 = 0;
  return v160 & 1;
}

  swift_release((uint64_t)v162);
  if (v169 >= v37[2])
  {
    swift_release((uint64_t)v37);
    v131 = (uint64_t *)v141;
    uint64_t v108 = v161;
    goto LABEL_50;
  }

  *(void *)&v170[0] = v37;
  uint64_t v108 = v161;
  int64_t v117 = type metadata accessor for ContiguousArray(0LL, (uint64_t)v161, v115, v116);
  char v119 = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v117, v118);
  specialized MutableCollection.subscript.getter(v169, v117, v119);
  uint64_t v114 = (uint64_t)v37;
LABEL_48:
  swift_release(v114);
  v170[0] = v171[0];
  v170[1] = v171[1];
  unint64_t v122 = type metadata accessor for Array(0LL, (uint64_t)v108, v120, v121);
  unint64_t v125 = type metadata accessor for ArraySlice(0LL, (uint64_t)v108, v123, v124);
  unint64_t v127 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v125, v126);
  Array.append<A>(contentsOf:)((uint64_t)v170, v122, v125, v127);
  v131 = (uint64_t *)v141;
LABEL_50:
  uint64_t v132 = v172;
  BOOL v133 = swift_bridgeObjectRetain((unint64_t)v172, v128, v129, v130);
  uint64_t v134 = _ArrayBuffer.requestNativeBuffer()(v133, v108);
  swift_bridgeObjectRelease((uint64_t)v132);
  if (!v134)
  {
    *(void *)&v171[0] = v132;
    v137 = type metadata accessor for Array(0LL, (uint64_t)v108, v135, v136);
    v139 = swift_getWitnessTable(&protocol conformance descriptor for [A], v137, v138);
    uint64_t v134 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)v171, v137, v139);
  }

  swift_bridgeObjectRelease((uint64_t)v132);
  char *v131 = v134;
}

  __break(1u);
}

  uint64_t v49 = v17;
  uint64_t v50 = (void *)v21;
  result._uint64_t object = v50;
  result._uint64_t countAndFlagsBits = v49;
  return result;
}

  uint64_t v49 = v17;
  uint64_t v50 = (void *)v21;
  result._uint64_t object = v50;
  result._uint64_t countAndFlagsBits = v49;
  return result;
}

  unint64_t v22 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v20);
  if (v22 <= 63) {
    goto LABEL_39;
  }
LABEL_40:
  uint64_t v27 = (v6 & 0x800000000000000LL) != 0 || v21 == 0;
  unint64_t v28 = 4LL;
  if (!v27) {
    unint64_t v28 = 8LL;
  }
  return (Swift::String::Index)(v8 & 2 | v28 | v19 | 1);
}

  unint64_t v21 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v19);
  if (v21 <= 63) {
    goto LABEL_39;
  }
LABEL_40:
  uint64_t v26 = (v6 & 0x800000000000000LL) != 0 || v20 == 0;
  uint64_t v27 = 4LL;
  if (!v26) {
    uint64_t v27 = 8LL;
  }
  return (Swift::String::Index)(v7 & 2 | v27 | v18 | 1);
}

    if ((v54 & ~v52 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v52 & 0xFFFFFFFFFFFFFFFLL))
    {
      Swift::String v76 = _StringGuts.nativeUnusedCapacity.getter(v54, v52);
      if ((v77 & 1) != 0) {
        goto LABEL_236;
      }
      if (v74 > 15 || (v52 & 0x2000000000000000LL) == 0 && v76 >= v73)
      {
LABEL_52:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v74, v73);
        swift_bridgeObjectRelease(v70);
        uint64_t v78 = v273;
        if ((v70 & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v69, v70, v71, v72);
        }

        else
        {
          if ((v70 & 0x2000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v70);
            uint64_t v110 = HIBYTE(v70) & 0xF;
            v282 = v69;
            v283 = v70 & 0xFFFFFFFFFFFFFFLL;
            if (v110 < v72) {
              goto LABEL_221;
            }
            v111 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v71, v72, (uint64_t)&v282, v110);
            _StringGuts.appendInPlace(_:isASCII:)(v111, v112, (v70 & 0x4000000000000000LL) != 0);
            goto LABEL_72;
          }

          if ((v69 & 0x1000000000000000LL) != 0)
          {
            uint64_t v79 = (id)((v70 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v80 = v69 & 0xFFFFFFFFFFFFLL;
            if ((v69 & 0xFFFFFFFFFFFFLL) < v72) {
              goto LABEL_221;
            }
          }

          else
          {
            uint64_t v79 = _StringObject.sharedUTF8.getter(v69, v70);
            v80 = v248;
            if (v248 < v72) {
              goto LABEL_221;
            }
          }

          uint64_t v81 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v71, v72, (uint64_t)v79, v80);
          _StringGuts.appendInPlace(_:isASCII:)(v81, v82, v69 < 0);
        }

        swift_bridgeObjectRelease(v70);
LABEL_72:
        uint64_t v105 = (ValueMetadata *)v272;
        goto LABEL_73;
      }
    }

    else if (v74 > 15)
    {
      goto LABEL_52;
    }

    swift_bridgeObjectRelease(v70);
    uint64_t v83 = v278;
    swift_bridgeObjectRetain(v52, v84, v85, v86);
    uint64_t v87 = _StringGuts._convertedToSmall()(v83, v52);
    int64_t v89 = v88;
    swift_bridgeObjectRelease(v52);
    v90._Swift::UInt64 rawBits = v66 & 0xFFFFFFFFFFFF0000LL | 1;
    v91._Swift::UInt64 rawBits = v68 & 0xFFFFFFFFFFFF0000LL | 1;
    v92._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v90, v91, v69, v70);
    if (v92._rawBits < 0x10000) {
      v92._rawBits |= 3;
    }
    uint64_t v94 = specialized String.init(_:)(v92, v93, v69, v70);
    unint64_t v96 = v95;
    swift_bridgeObjectRelease(v70);
    unint64_t v97 = _StringGuts._convertedToSmall()(v94, v96);
    unint64_t v99 = v98;
    swift_bridgeObjectRelease(v96);
    uint64_t v100 = specialized _SmallString.init(_:appending:)(v87, v89, v97, v99);
    if ((v102 & 1) != 0) {
      goto LABEL_235;
    }
    int64_t v103 = v100;
    Swift::String v104 = v101;
    swift_bridgeObjectRelease(v52);
    v278 = v103;
    v279 = v104;
    uint64_t v105 = (ValueMetadata *)v272;
    uint64_t v78 = v273;
LABEL_73:
    uint64_t v113 = v271;
    uint64_t v114 = v268;
    v115 = (unint64_t)v266;
    int64_t v116 = v278 & 0xFFFFFFFFFFFFLL;
    if ((v279 & 0x2000000000000000LL) != 0) {
      int64_t v116 = HIBYTE(v279) & 0xF;
    }
    v271 = v116;
    String.append<A>(contentsOf:)(v78, v105, v113);
    char v119 = v278;
    uint64_t v120 = v279;
    int64_t v39 = (unint64_t *)((v279 & 0x2000000000000000LL) != 0 ? HIBYTE(v279) & 0xF : v278 & 0xFFFFFFFFFFFFLL);
    swift_bridgeObjectRetain_n(v279, 3LL, v117, v118);
    v121._Swift::UInt64 rawBits = v267;
    v38._Swift::UInt64 rawBits = specialized Collection.subscript.getter(v121, v114, v115);
    unint64_t v25 = v124;
    v272 = (uint64_t)v122;
    uint64_t v34 = v123;
    int64_t v35 = v38._rawBits >> 16;
    BOOL v18 = v124 >> 16;
    if ((v123 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v123, 3LL, (uint64_t)v122, (char *)v123);
      v178._Swift::UInt64 rawBits = v38._rawBits & 0xFFFFFFFFFFFF0000LL | 1;
      v179._Swift::UInt64 rawBits = v25 & 0xFFFFFFFFFFFF0000LL | 1;
      v180 = (ValueMetadata *)v272;
      v181._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v178, v179, v272, v34);
      if (v181._rawBits < 0x10000) {
        v181._rawBits |= 3;
      }
      uint64_t v12 = specialized Collection.count.getter(v181, v182, (unint64_t)v180, v34);
      swift_bridgeObjectRelease(v120);
      unint64_t v125 = v34;
    }

    else
    {
      uint64_t v12 = v18 - v35;
      swift_bridgeObjectRetain_n(v123, 2LL, (uint64_t)v122, (char *)v123);
      unint64_t v125 = v120;
    }

    swift_bridgeObjectRelease(v120);
    swift_bridgeObjectRelease(v125);
    char v126 = (Swift::Int)v39;
    if ((v120 & 0x1000000000000000LL) != 0) {
      char v126 = String.UTF8View._foreignCount()();
    }
    swift_bridgeObjectRelease(v120);
    unint64_t v127 = __OFADD__(v126, v12);
    unint64_t v32 = v126 + v12;
    if (!v127) {
      break;
    }
    __break(1u);
LABEL_124:
    v268 = v26;
    v265 = v33;
    v270 = v27;
    v263 = v28;
    v264 = v30;
    v183 = v29;
    v184 = v36._rawBits;
    v269 = v37;
    v185._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v38)._rawBits;
    int64_t v37 = v269;
    uint64_t v27 = v270;
    v36._Swift::UInt64 rawBits = v184;
    int64_t v30 = v264;
    unint64_t v33 = v265;
    int64_t v29 = v183;
    unint64_t v28 = v263;
    uint64_t v186 = v185._rawBits & 0xFFFFFFFFFFFFFFF3LL;
    uint64_t v26 = v268;
    v38._Swift::UInt64 rawBits = v38._rawBits & 0xC | v186 | 1;
    if ((v268 & 1) != 0) {
      goto LABEL_18;
    }
LABEL_125:
    v187 = v26;
    v265 = v33;
    v270 = v27;
    v263 = v28;
    v264 = v30;
    v262 = v29;
    v188 = v36._rawBits;
    v269 = v37;
    v189._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v26)._rawBits;
    int64_t v37 = v269;
    uint64_t v27 = v270;
    v36._Swift::UInt64 rawBits = v188;
    int64_t v30 = v264;
    unint64_t v33 = v265;
    int64_t v29 = v262;
    unint64_t v28 = v263;
    uint64_t v26 = v187 & 0xC | v189._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
    if ((v39 & 1) == 0)
    {
LABEL_126:
      v190 = (unint64_t)v33;
      v191 = v36._rawBits & 0xC;
      uint64_t v192 = v36._rawBits;
      if (v191 == 4)
      {
        v256 = v26;
        v257 = v36._rawBits;
        v258 = v37;
        v259._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v36)._rawBits;
        int64_t v37 = v258;
        v36._Swift::UInt64 rawBits = v257;
        uint64_t v192 = v259._rawBits;
        uint64_t v26 = v256;
      }

      if ((v35 & 0x2000000000000000LL) != 0) {
        v193 = HIBYTE(v35) & 0xF;
      }
      else {
        v193 = v34 & 0xFFFFFFFFFFFFLL;
      }
      if (v193 < v192 >> 16) {
        goto LABEL_241;
      }
      v194._Swift::UInt64 rawBits = v37;
      v195 = v36._rawBits;
      v196 = v26;
      v197 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)v192);
      if (v191 == 4) {
        v198._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v195)._rawBits;
      }
      else {
        v198._Swift::UInt64 rawBits = v195;
      }
      v199 = v194._rawBits;
      if ((v194._rawBits & 0xC) != 4LL)
      {
        if (v193 >= v198._rawBits >> 16) {
          goto LABEL_137;
        }
LABEL_241:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
      }

      v260 = v198._rawBits;
      v261._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v194)._rawBits;
      v198._Swift::UInt64 rawBits = v260;
      v199 = v261._rawBits;
      if (v193 < v260 >> 16) {
        goto LABEL_241;
      }
LABEL_137:
      if (v193 < v199 >> 16) {
        goto LABEL_241;
      }
      v200 = v38._rawBits;
      v201 = String.UTF8View._foreignDistance(from:to:)(v198, (Swift::String::Index)v199);
      v202 = v196;
      if ((v196 & 0xC) == 4) {
        v202 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v196)._rawBits;
      }
      v203 = v200;
      if ((v200 & 0xC) == 4)
      {
        v203 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v200)._rawBits;
        if (v193 < v202 >> 16) {
          goto LABEL_241;
        }
      }

      else if (v193 < v202 >> 16)
      {
        goto LABEL_241;
      }

      if (v193 < v203 >> 16) {
        goto LABEL_241;
      }
      v204 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)v202, (Swift::String::Index)v203);
      v205 = v190;
      v206 = _StringGuts.replaceSubrange<A>(_:with:)(v196, v200, v273, (ValueMetadata *)v272, v267);
      v208 = v207 - v206;
      if (__OFSUB__(v207, v206))
      {
        __break(1u);
      }

      else
      {
        unint64_t v127 = __OFADD__(v201, v208);
        v209 = v201 + v208;
        if (!v127)
        {
          unint64_t v127 = __OFSUB__(v209, v204);
          v204 = v209 - v204;
          if (!v127)
          {
            if (v206 == v207)
            {
              v210 = 0LL;
              v211 = v197 << 16;
            }

            else
            {
              v211 = v274[2];
              v205 = v274[3];
              if ((v205 & 0x1000000000000000LL) != 0) {
                goto LABEL_246;
              }
              if ((v205 & 0x2000000000000000LL) == 0)
              {
                if ((v211 & 0x1000000000000000LL) == 0) {
                  goto LABEL_249;
                }
                v251 = (char *)((v205 & 0xFFFFFFFFFFFFFFFLL) + 32);
                v252 = v211 & 0xFFFFFFFFFFFFLL;
                goto LABEL_217;
              }

              v278 = v274[2];
              v279 = v205 & 0xFFFFFFFFFFFFFFLL;
              if (v197 + 1 != (HIBYTE(v205) & 0xF))
              {
                v253 = *(unsigned __int16 *)((char *)&v278 + v197);
                goto LABEL_224;
              }

  uint64_t v12 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
LABEL_19:
  if (v9 + 1 == v13) {
    goto LABEL_30;
  }
  if (!v12) {
    goto LABEL_48;
  }
  uint64_t v14 = *(unsigned __int16 *)&v12[v9];
  if (v14 != 2573 && (v14 & 0x80808080) == 0) {
    goto LABEL_30;
  }
LABEL_40:
  uint64_t v17 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9);
  BOOL v18 = v9 + v17;
  if (__OFADD__(v9, v17)) {
    goto LABEL_42;
  }
LABEL_31:
  if (v6 >= v18) {
    return (Swift::String::Index)(a1._rawBits | 3);
  }
  uint64_t v19 = v17 << 8;
  if (v17 > 63) {
    uint64_t v19 = 0LL;
  }
  uint64_t v20 = v19 | (v9 << 16);
  if ((v3 & 0x1000000000000000LL) == 0 || (v4 & 0x800000000000000LL) != 0) {
    return (Swift::String::Index)(v20 | 7);
  }
  else {
    return (Swift::String::Index)(v20 | 0xB);
  }
}

    swift_bridgeObjectRelease(a3);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }

  v62(v74, a3);
LABEL_47:
  uint64_t v94 = v125;
  unint64_t v95 = v126;
  unint64_t v96 = v126(a3, a4);
  unint64_t v97 = v121;
  v64(v121, (uint64_t)v94, a3);
  if (v96 >= 65)
  {
    v62(v97, a3);
    unint64_t v98 = v123;
    goto LABEL_49;
  }

  uint64_t v106 = v95(a3, a4);
  v62(v97, a3);
  unint64_t v98 = v123;
  if (v106 == 64 && (v127(a3, a4) & 1) == 0)
  {
LABEL_49:
    v64(v122, (uint64_t)v125, a3);
    Swift::String v129 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v99 = v127(a3, a4);
    uint64_t v100 = v126(a3, a4);
    if ((v99 & 1) != 0)
    {
      if (v100 > 64)
      {
        int64_t v103 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        Swift::String v104 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
        uint64_t v105 = &v129;
        goto LABEL_58;
      }
    }

    else if (v100 > 63)
    {
      unint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
      int64_t v103 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      Swift::String v104 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
      uint64_t v105 = &v128;
LABEL_58:
      v103(v105, &type metadata for Int, v104, a3, a4);
      unint64_t v107 = v122;
      uint64_t v108 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  v122,  a3);
      v62(v29, a3);
      if ((v108 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_59;
    }

    unint64_t v107 = v122;
    v64(v29, (uint64_t)v122, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
LABEL_59:
    v62(v107, a3);
  }

  char v109 = v125;
  uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int64_t result = v62(v109, a3);
  if ((v110 & 0x8000000000000000LL) == 0)
  {
    if (v110 < 0x80)
    {
      uint64_t v53 = ((2 * v31) << ~(_BYTE)v110) | (v98 >> v110);
      uint64_t v54 = v31 >> v110;
      v111 = (v110 & 0x40) == 0;
      if ((v110 & 0x40) != 0) {
        uint64_t v53 = v31 >> v110;
      }
      uint64_t v112 = v31 >> 63;
      goto LABEL_65;
    }

  uint64_t v79 = v68(a3, a4);
LABEL_47:
  unint64_t v99 = v79;
  v65(v71, (uint64_t)v70, a3);
  if (v99 >= 65)
  {
    v63(v71, a3);
    uint64_t v100 = v127;
    goto LABEL_49;
  }

  char v109 = v68(a3, a4);
  v63(v71, a3);
  uint64_t v110 = v109 == 64;
  uint64_t v100 = v127;
  if (v110 && (v127(a3, a4) & 1) == 0)
  {
LABEL_49:
    char v101 = v121;
    v65(v121, (uint64_t)v70, a3);
    Swift::String v129 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v102 = v100(a3, a4);
    int64_t v103 = v68(a3, a4);
    if ((v102 & 1) != 0)
    {
      if (v103 > 64)
      {
        uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
        uint64_t v108 = &v129;
        goto LABEL_59;
      }
    }

    else if (v103 > 63)
    {
      unint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
      uint64_t v108 = &v128;
LABEL_59:
      v106(v108, &type metadata for Int, v107, a3, a4);
      v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v101,  a3);
      v63(v30, a3);
      if ((v111 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_60;
    }

    v65(v30, (uint64_t)v101, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63(v30, a3);
LABEL_60:
    v63(v101, a3);
  }

  uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int64_t result = v63(v70, a3);
  if ((v112 & 0x8000000000000000LL) != 0)
  {
    if (v112 > 0xFFFFFFFFFFFFFFC0LL)
    {
      uint64_t v55 = v122 >> -(char)v112;
      goto LABEL_64;
    }

    goto LABEL_24;
  }

  uint64_t v55 = v122 << v112;
  if (v112 >= 0x40) {
    uint64_t v55 = 0LL;
  }
LABEL_64:
  char *v126 = v55;
  return result;
}

  uint64_t v79 = v68(a3, a4);
LABEL_47:
  unint64_t v99 = v79;
  v65(v71, (uint64_t)v70, a3);
  if (v99 >= 65)
  {
    v62(v71, a3);
    uint64_t v100 = v127;
    goto LABEL_49;
  }

  char v109 = v68(a3, a4);
  v62(v71, a3);
  uint64_t v110 = v109 == 64;
  uint64_t v100 = v127;
  if (v110 && (v127(a3, a4) & 1) == 0)
  {
LABEL_49:
    char v101 = v121;
    v65(v121, (uint64_t)v70, a3);
    Swift::String v129 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v102 = v100(a3, a4);
    int64_t v103 = v68(a3, a4);
    if ((v102 & 1) != 0)
    {
      if (v103 > 64)
      {
        uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
        uint64_t v108 = &v129;
        goto LABEL_59;
      }
    }

    else if (v103 > 63)
    {
      unint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
      uint64_t v108 = &v128;
LABEL_59:
      v106(v108, &type metadata for Int, v107, a3, a4);
      v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v101,  a3);
      v62(v30, a3);
      if ((v111 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_60;
    }

    v65(v30, (uint64_t)v101, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v30, a3);
LABEL_60:
    v62(v101, a3);
  }

  uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int64_t result = v62(v70, a3);
  if ((v112 & 0x8000000000000000LL) != 0)
  {
    if (v112 > 0xFFFFFFFFFFFFFFC0LL)
    {
      uint64_t v64 = v122 << -(char)v112;
      goto LABEL_64;
    }

    goto LABEL_24;
  }

  uint64_t v64 = v122 >> v112;
  if (v112 >= 0x40) {
    uint64_t v64 = 0LL;
  }
LABEL_64:
  char *v126 = v64;
  return result;
}

      *int64_t v56 = 0LL;
    }
  }

  else
  {
    if ((1LL << v49) / ((1LL << v49) - (unint64_t)(v44 + 1)) > 3)
    {
      uint64_t v59 = (v49 + 1);
      *(void *)(v51 - 104) = v49;
      if (v59 >= 0x11) {
        unint64_t v60 = 4;
      }
      else {
        unint64_t v60 = 2;
      }
      if (v59 < 9) {
        uint64_t v61 = 1LL;
      }
      else {
        uint64_t v61 = v60;
      }
      unint64_t v62 = (unint64_t)calloc(2LL << v49, v61);
      if (v62)
      {
        if ((_DWORD)v61 != 1)
        {
          if ((_DWORD)v61 == 4) {
            uint64_t v61 = 3LL;
          }
          else {
            uint64_t v61 = 2LL;
          }
        }

        int64_t v63 = v61 | v62;
        *(_BYTE *)unint64_t v62 = v49 + 1;
        if (v49) {
          __asm { BR              X8 }
        }

        atomic_store(v63, (unint64_t *)(v45 + 16));
        if ((v82 & 1) == 0)
        {
          uint64_t v64 = malloc(0x10uLL);
          *uint64_t v64 = *(void *)(v45 + 32);
          v64[1] = v47;
          *(void *)(v45 + 32) = v64;
        }

        __swift::__runtime::llvm::hash_combine<__swift::__runtime::llvm::hash_code,swift::TargetMetadata<swift::InProcess> const*>( (void *)(v51 - 96),  v83);
        __asm { BR              X14 }
      }

      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }

    if (!v80 || (char v65 = (unint64_t)v80, v44 >= *v80))
    {
      unint64_t v66 = v44 + (v44 >> 2);
      if (v66 <= v44 + 1) {
        unint64_t v66 = v44 + 1;
      }
      id v67 = malloc_good_size(24 * v66 + 8);
      unint64_t v68 = malloc(v67);
      if (!v68) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      char v65 = (unint64_t)v68;
      *unint64_t v68 = (v67 - 8) / 0x18;
      if (v80)
      {
        memcpy(v68 + 2, v78, 24 * v44);
        uint64_t v69 = malloc(0x10uLL);
        *uint64_t v69 = *(void *)(v45 + 32);
        v69[1] = v80;
        *(void *)(v45 + 32) = v69;
      }

      atomic_store(v65, (unint64_t *)(v45 + 8));
    }

    if (!v79) {
      goto LABEL_42;
    }
    unint64_t v70 = (unint64_t *)(v45 + 48);
    do
      uint64_t v71 = __ldaxr(v70);
    while (__stxr(v71 + 1, v70));
    unint64_t v72 = *(unint64_t **)(v45 + 56);
    if (v72) {
      unint64_t v72 = (unint64_t *)atomic_load(v72);
    }
    do
      uint64_t v73 = __ldxr(v70);
    while (__stlxr(v73 - 1, v70));
    if (v72 == v79)
    {
LABEL_42:
      unint64_t v74 = (void *)(v65 + 8 + 24LL * v44);
      *unint64_t v74 = v43;
      v74[1] = v50;
      v74[2] = v81;
      atomic_store(v44 + 1, (unsigned int *)(v45 + 4));
      __asm { BR              X10 }
    }

    __dmb(0xBu);
    if (!*(_DWORD *)v45)
    {
      Swift::String v76 = *(void ***)(v45 + 32);
      int64_t v56 = (void *)(v45 + 32);
      char v75 = v76;
      if (v76)
      {
        do
        {
          uint64_t v77 = (void **)*v75;
          free(v75[1]);
          free(v75);
          char v75 = v77;
        }

        while (v77);
      }

      goto LABEL_46;
    }
  }

  os_unfair_lock_unlock(v46);
}

              uint64_t v26 = v19 - 1;
              uint64_t v27 = *(unsigned __int16 **)(*((void *)this + 11) + 8LL * (v19 - 1));
              unint64_t v28 = v27[8];
              int64_t v29 = (v28 - 139) > 0x21 || ((1LL << (v28 + 117)) & 0x200000019LL) == 0;
              if (!v29
                || ((v28 - 28) <= 0x2E
                  ? (int64_t v30 = ((1LL << (v28 - 28)) & 0x500000000001LL) == 0)
                  : (int64_t v30 = 1),
                    v30 ? (unint64_t v31 = v28 == 8) : (unint64_t v31 = 1),
                    v31))
              {
                *((_DWORD *)this + 24) = v26;
                unint64_t v32 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleIndexAsNode(this);
                if ((v12 & 1) != 0)
                {
LABEL_64:
                  Swift::Int v8 = (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  v11,  (swift::Demangle::__runtime::Node *)v27,  (swift::Demangle::__runtime::Node *)v21,  (char *)v18,  v32);
                  if (!v20) {
                    return (unint64_t)v8;
                  }
LABEL_65:
                  swift::Demangle::__runtime::Node::addChild(v8, v20, this, v33, v34);
                  return (unint64_t)v8;
                }

    if (v11 != v22)
    {
      while (*(_WORD *)(*(void *)v11 + 16LL) != 225)
      {
        uint64_t v11 = (swift::Demangle::__runtime::Node *)((char *)v11 + 8);
        if (v11 == v22)
        {
          uint64_t v11 = v22;
          break;
        }
      }
    }

    if (v10 == 5)
    {
    }

    else
    {
      unint64_t v23 = (swift::Demangle::__runtime::Node *)((char *)a2 + 8);
      if (v10 != 1) {
        unint64_t v23 = 0LL;
      }
      if (v10 == 2) {
        unint64_t v24 = (swift::Demangle::__runtime::Node *)((char *)a2 + 16);
      }
      else {
        unint64_t v24 = v23;
      }
      if (v11 == v24) {
        goto LABEL_61;
      }
    }

    unint64_t v25 = *(void *)v11;
    if (v25)
    {
      std::string::append(*(std::string **)(a1 + 8), *(const std::string::value_type **)v25, *(void *)(v25 + 8));
      uint64_t v26 = ":";
      uint64_t v27 = v4;
      unint64_t v28 = 1LL;
LABEL_62:
      std::string::append(v27, v26, v28);
      goto LABEL_63;
    }

        int64_t v47 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v23, 216, v44);
        while (1)
        {
          while (1)
          {
            swift::Demangle::__runtime::Node::addChild(v16, v47, v185, v45, v46);
            int64_t v37 = __len;
            if (__len)
            {
              int64_t v38 = (char *)__src;
              if (*(_BYTE *)__src == 95) {
                goto LABEL_217;
              }
            }

            int64_t v47 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v185, 78);
            unint64_t v48 = __len;
            if (__len < 2)
            {
              if (!__len) {
                goto LABEL_3;
              }
              uint64_t v49 = (unsigned __int8 *)__src;
              goto LABEL_52;
            }

            uint64_t v49 = (unsigned __int8 *)__src;
            if (*(_WORD *)__src == 24430)
            {
              uint64_t v55 = (char *)__src + 2;
              int64_t v56 = __len - 2;
              goto LABEL_146;
            }

            if (*(_WORD *)__src == 28771) {
              break;
            }
            switch(*(_WORD *)__src)
            {
              case 0x6C63:
                __src = (char *)__src + 2;
                __len -= 2LL;
                if (!v59) {
                  goto LABEL_3;
                }
                unint64_t v60 = v59;
                uint64_t v61 = v13;
                unint64_t v62 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  5LL);
                swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v62, v185, v63, v64);
                char v65 = v185;
                unint64_t v66 = *(void *)(v60 + 8);
                if (v66)
                {
                  id v67 = *(const void **)v60;
                  unint64_t v68 = (char *)*((void *)v185 + 1);
                  if (!v68 || (unint64_t)&v68[v66] > *((void *)v185 + 2))
                  {
                    uint64_t v69 = 2LL * *((void *)v185 + 4);
                    if (v69 <= v66 + 1) {
                      uint64_t v69 = v66 + 1;
                    }
                    *((void *)v185 + 4) = v69;
                    unint64_t v70 = v69 + 8;
                    uint64_t v71 = malloc(v69 + 8);
                    *uint64_t v71 = *((void *)v65 + 3);
                    unint64_t v68 = (char *)(v71 + 1);
                    *((void *)v65 + 2) = (char *)v71 + v70;
                    *((void *)v65 + 3) = v71;
                  }

                  *((void *)v65 + 1) = &v68[v66];
                  memmove(v68, v67, v66);
                }

                else
                {
                  unint64_t v68 = 0LL;
                }

                unint64_t v98 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v65,  81,  (uint64_t)v68,  v66);
                swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v98, v185, v99, v100);
                uint64_t v13 = v61;
                if (__len)
                {
LABEL_138:
                  if (*(_BYTE *)__src != 95) {
                    goto LABEL_139;
                  }
                }

                else
                {
LABEL_139:
                  while (1)
                  {
                    if (!v101) {
                      break;
                    }
                    uint64_t v102 = (swift::Demangle::__runtime::Node *)v101;
                    int64_t v103 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(v185, 232);
                    swift::Demangle::__runtime::Node::addChild(v103, v102, v185, v104, v105);
                    if (!v103) {
                      break;
                    }
                    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v47,  (swift::Demangle::__runtime::Node *)v103,  v185,  v45,  v46);
                    if (__len) {
                      goto LABEL_138;
                    }
                  }
                }

                if (!__len || *(_BYTE *)__src != 95) {
                  goto LABEL_3;
                }
                uint64_t v55 = (char *)__src + 1;
                int64_t v56 = __len - 1;
LABEL_146:
                __src = v55;
                __len = v56;
                break;
              case 0x5F69:
                __src = (char *)__src + 2;
                __len -= 2LL;
                uint64_t v52 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  6LL);
                if (!v52) {
                  goto LABEL_3;
                }
                goto LABEL_76;
              case 0x5F6B:
                __src = (char *)__src + 2;
                __len -= 2LL;
                uint64_t v52 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  7LL);
                if (!v52) {
                  goto LABEL_3;
                }
                goto LABEL_76;
              case 0x5F72:
                __src = (char *)__src + 2;
                __len -= 2LL;
                uint64_t v52 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  8LL);
                if (!v52) {
                  goto LABEL_3;
                }
                goto LABEL_76;
              default:
LABEL_52:
                uint64_t v50 = *v49;
                if (v50 == 100)
                {
                  ++v49;
                  unint64_t v48 = __len - 1;
                  __src = v49;
                  __len = v48;
                  if (!v48) {
                    goto LABEL_3;
                  }
                  uint64_t v50 = *v49;
                  uint64_t v51 = 64LL;
                }

                else
                {
                  uint64_t v51 = 0LL;
                }

                if (v50 == 103)
                {
                  ++v49;
                  --v48;
                  __src = v49;
                  __len = v48;
                  if (!v48) {
                    goto LABEL_3;
                  }
                  v51 |= 0x80uLL;
                  uint64_t v50 = *v49;
                }

                if (v50 == 111)
                {
                  ++v49;
                  --v48;
                  __src = v49;
                  __len = v48;
                  if (!v48) {
                    goto LABEL_3;
                  }
                  v51 |= 0x200uLL;
                  uint64_t v50 = *v49;
                }

                if (v50 == 115)
                {
                  ++v49;
                  --v48;
                  __src = v49;
                  __len = v48;
                  if (!v48) {
                    goto LABEL_3;
                  }
                  v51 |= 0x100uLL;
                  uint64_t v50 = *v49;
                }

                if (v50 != 95) {
                  goto LABEL_3;
                }
                __src = v49 + 1;
                __len = v48 - 1;
                if (!v51) {
                  goto LABEL_3;
                }
                uint64_t v52 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  v51);
                if (!v52) {
                  goto LABEL_3;
                }
LABEL_76:
                swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v52, v185, v53, v54);
                break;
            }
          }

          int64_t v57 = (char *)__src + 2;
          char v58 = __len - 2;
          __src = (char *)__src + 2;
          __len -= 2LL;
          if (v48 - 2 >= 2)
          {
            if (*v57 != 29286) {
              goto LABEL_90;
            }
            if (v58 >= 2) {
              uint64_t v106 = 2LL;
            }
            else {
              uint64_t v106 = v58;
            }
            __src = (char *)v57 + v106;
            __len = v58 - v106;
            if (!v107 || !__len || *(_BYTE *)__src != 95) {
              goto LABEL_3;
            }
            unint64_t v74 = v107;
            char v75 = v13;
            __src = (char *)__src + 1;
            --__len;
            Swift::String v76 = v185;
            uint64_t v77 = 0LL;
LABEL_154:
            uint64_t v108 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v76, 80, v77);
            swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v108, v185, v109, v110);
            v111 = v185;
            uint64_t v112 = *(void *)(v74 + 8);
            if (v112)
            {
              uint64_t v113 = *(const void **)v74;
              uint64_t v114 = (char *)*((void *)v185 + 1);
              if (!v114 || (unint64_t)&v114[v112] > *((void *)v185 + 2))
              {
                v115 = 2LL * *((void *)v185 + 4);
                if (v115 <= v112 + 1) {
                  v115 = v112 + 1;
                }
                *((void *)v185 + 4) = v115;
                int64_t v116 = v115 + 8;
                int64_t v117 = malloc(v115 + 8);
                char *v117 = *((void *)v111 + 3);
                uint64_t v114 = (char *)(v117 + 1);
                *((void *)v111 + 2) = (char *)v117 + v116;
                *((void *)v111 + 3) = v117;
              }

              *((void *)v111 + 1) = &v114[v112];
              memmove(v114, v113, v112);
            }

            else
            {
              uint64_t v114 = 0LL;
            }

            int64_t v118 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v111,  81,  (uint64_t)v114,  v112);
            swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v118, v185, v119, v120);
            uint64_t v13 = v75;
          }

          else
          {
            if (v48 < 3) {
              goto LABEL_3;
            }
LABEL_90:
            unint64_t v72 = *(unsigned __int8 *)v57;
            if (v72 == 105)
            {
              uint64_t v78 = (unsigned __int8 *)v57 + 1;
              memset(&v186, 0, sizeof(v186));
              uint64_t v79 = v58 - 1;
              __src = (char *)v57 + 1;
              __len = v79;
              if (v79)
              {
                while (1)
                {
                  v80 = *v78;
                  if (v80 == 95) {
                    break;
                  }
                  std::string::push_back(&v186, v80);
                  uint64_t v78 = (unsigned __int8 *)__src;
                  if (__len) {
                    uint64_t v78 = (unsigned __int8 *)__src + 1;
                  }
                  uint64_t v79 = __len - (__len != 0);
                  __src = v78;
                  __len = v79;
                  if (!v79) {
                    goto LABEL_181;
                  }
                }

                __src = v78 + 1;
                __len = v79 - 1;
                unint64_t v121 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode( v185,  80,  2LL);
                swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v121, v185, v122, v123);
                unint64_t v124 = v185;
                if ((v186.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  unint64_t v125 = &v186;
                }
                else {
                  unint64_t v125 = (std::string *)v186.__r_.__value_.__r.__words[0];
                }
                if ((v186.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  size = v186.__r_.__value_.__s.__size_;
                }
                else {
                  size = v186.__r_.__value_.__l.__size_;
                }
                if (size)
                {
                  unint64_t v127 = (char *)*((void *)v185 + 1);
                  if (!v127 || (unint64_t)&v127[size] > *((void *)v185 + 2))
                  {
                    unint64_t v128 = 2LL * *((void *)v185 + 4);
                    if (v128 <= size + 1) {
                      unint64_t v128 = size + 1;
                    }
                    *((void *)v185 + 4) = v128;
                    Swift::String v129 = v128 + 8;
                    v130 = malloc(v128 + 8);
                    *v130 = *((void *)v124 + 3);
                    unint64_t v127 = (char *)(v130 + 1);
                    *((void *)v124 + 2) = (char *)v130 + v129;
                    *((void *)v124 + 3) = v130;
                  }

                  *((void *)v124 + 1) = &v127[size];
                  memmove(v127, v125, size);
                }

                else
                {
                  unint64_t v127 = 0LL;
                }

                v135 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText( v124,  81,  (uint64_t)v127,  size);
                swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v135, v185, v136, v137);
                uint64_t v134 = 1;
                uint64_t v13 = "u16";
                goto LABEL_182;
              }

LABEL_52:
  unint64_t v21 = (v40 - 1) & v40;
  unint64_t v22 = __clz(__rbit64(v40)) + (v41 << 6);
  int64_t v6 = v41;
LABEL_21:
  unint64_t v23 = (__objc2_class **)(*(void *)(v3 + 48) + 16 * v22);
  unint64_t v25 = *v23;
  unint64_t v24 = (unint64_t)v23[1];
  int64_t v47 = v6;
  unint64_t v48 = v21;
  int64_t result = swift_bridgeObjectRetain(v24, v14, v15, v16);
  while (1)
  {
    unint64_t v28 = (unint64_t)v4[3];
    int64_t v29 = v28 >> 1;
    int64_t v30 = v2 + 1;
    if (v2 < v29) {
      goto LABEL_28;
    }
LABEL_22:
    v4[2] = (__objc2_class *)v2;
  }

  int64_t result = (int64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v28 > 1),  v30,  1,  (uint64_t)v4);
  uint64_t v4 = (__objc2_class **)result;
  *uint64_t v1 = result;
  int64_t v29 = *(void *)(result + 24) >> 1;
  if (v2 >= v29) {
    goto LABEL_22;
  }
  while (1)
  {
LABEL_28:
    uint64_t v34 = &v4[2 * v2 + 4];
    *uint64_t v34 = v25;
    v34[1] = (__objc2_class *)v24;
    ++v2;
    if (v21)
    {
      unint64_t v31 = __clz(__rbit64(v21));
      v21 &= v21 - 1;
      unint64_t v32 = v31 | (v6 << 6);
      goto LABEL_27;
    }

    int64_t v35 = v6 + 1;
    if (__OFADD__(v6, 1LL)) {
      break;
    }
    if (v35 >= v43) {
      goto LABEL_45;
    }
    unint64_t v36 = *(void *)(v44 + 8 * v35);
    int64_t v37 = v6 + 1;
    if (!v36)
    {
      int64_t v37 = v6 + 2;
      if (v6 + 2 >= v43) {
        goto LABEL_45;
      }
      unint64_t v36 = *(void *)(v44 + 8 * v37);
      if (!v36)
      {
        int64_t v37 = v6 + 3;
        if (v6 + 3 >= v43) {
          goto LABEL_45;
        }
        unint64_t v36 = *(void *)(v44 + 8 * v37);
        if (!v36)
        {
          int64_t v37 = v6 + 4;
          if (v6 + 4 >= v43) {
            goto LABEL_45;
          }
          unint64_t v36 = *(void *)(v44 + 8 * v37);
          if (!v36)
          {
            int64_t v38 = v6 + 5;
            while (v43 != v38)
            {
              unint64_t v36 = *(void *)(v44 + 8 * v38++);
              if (v36)
              {
                int64_t v37 = v38 - 1;
                goto LABEL_42;
              }
            }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x429uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Comparing indexes from different dictionaries",  45LL,  2,  "Swift/Dictionary.swift",  22LL,  2,  0x75CuLL,  0);
  }

  if ((v21 & 1) == 0)
  {
    outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1LL, v20);
    outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1LL, v88);
    swift_bridgeObjectRetain(v13, v89, v90, v91);
    goto LABEL_52;
  }

  uint64_t v27 = specialized static __CocoaDictionary.Index.== infix(_:_:)(v13, a2, a4, a5);
  outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1LL, v28);
  outlined copy of [A : B].Index._Variant<A, B>(v13, a2, 1LL, v29);
  swift_bridgeObjectRetain(v13, v30, v31, v32);
  if (v27)
  {
LABEL_4:
    outlined consume of [A : B].Index._Variant<A, B>(v13, a2, a3 & 1);
    outlined consume of [A : B].Index._Variant<A, B>(v13, a2, a3 & 1);
    outlined consume of [A : B].Index._Variant<A, B>(v13, a2, a3 & 1);
    return;
  }

        v342 = (v150 - 1) & v150;
        Swift::String v129 = __clz(__rbit64(v150)) + (v130 << 6);
      }

      v153 = *(void *)(v108 + 48) + *(void *)(v117 + 72) * v129;
      unint64_t v154 = *(void (**)(char *, unint64_t, uint64_t *))(v117 + 16);
      v155 = v328;
      uint64_t v148 = v126;
      v154(v328, v153, v126);
      v156 = *(void *)(v108 + 56) + *(void *)(v127 + 72) * v129;
      uint64_t v157 = v329;
      v158 = v346;
      (*(void (**)(char *, unint64_t, uint64_t *))(v127 + 16))(v329, v156, v346);
      v159 = &v125[*((int *)v131 + 12)];
      (*(void (**)(char *, char *, uint64_t *))(v347 + 32))(v125, v155, v148);
      int64_t v117 = v347;
      (*(void (**)(char *, char *, uint64_t *))(v127 + 32))(v159, v157, v158);
      v147 = v348;
      (*(void (**)(char *, void, uint64_t, unint64_t *))(v348 + 56))(v125, 0LL, 1LL, v131);
      goto LABEL_54;
    }

    uint64_t v132 = v313;
    BOOL v133 = *((void *)v313 + 27);
    unint64_t v127 = v344;
    unint64_t v128 = v330;
    if (v133 < 0)
    {
      v131 = v345;
      v151 = v348;
      goto LABEL_119;
    }

    uint64_t v134 = (void *)*((void *)v313 + 26);
    v131 = v345;
    if (v133 == *((void *)v313 + 28)) {
      break;
    }
LABEL_32:
    char v136 = *((void *)v132 + 3);
    if (!v136) {
      goto LABEL_133;
    }
    if ((unint64_t)(v133 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_126:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  0x1FFuLL,  0);
    }

    v137 = (void **)(v136 + 8 * v133);
    v138 = *v137;
    *((void *)v132 + 27) = v133 + 1;
    swift_unknownObjectRetain(v138, v121, v122, v123);
    v139 = (swift *)objc_msgSend(v134, sel_objectForKey_, v138);
    if (!v139) {
      goto LABEL_134;
    }
    v140 = v139;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v126, v126))
    {
      v349 = (swift *)v138;
      v141 = v341;
      swift_dynamicCast(v341, &v349, v311, v126, 7LL);
      unint64_t v142 = v346;
    }

    else
    {
      uint64_t v192 = v288;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v117 + 56))(v288, 1LL, 1LL, v126);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v138, (uint64_t)v126, v192);
      swift_unknownObjectRelease(v138);
      v193 = v290;
      uint64_t v194 = v289;
      v195 = v291;
      (*(void (**)(char *, uint64_t *, uint64_t))(v290 + 16))(v289, v192, v291);
      (*(void (**)(uint64_t *, uint64_t))(v193 + 8))(v192, v195);
      v141 = v341;
      (*(void (**)(char *, char *, uint64_t *))(v117 + 32))(v341, v194, v126);
      unint64_t v142 = v346;
      unint64_t v127 = v344;
    }

    v143 = v299;
    unint64_t v144 = &v141[*((int *)v131 + 12)];
    v145 = _swift_isClassOrObjCExistentialType((uint64_t)v142, v142);
    v146 = v298;
    if (v145)
    {
      v349 = v140;
      swift_dynamicCast(v144, &v349, &unk_189B8D230, v142, 7LL);
    }

    else
    {
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v127 + 56))(v143, 1LL, 1LL, v142);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v140, (uint64_t)v142, v143);
      swift_unknownObjectRelease(v140);
      v196 = v143;
      v197 = v292;
      v198 = v127;
      v199 = v293;
      (*(void (**)(char *, uint64_t *, uint64_t))(v292 + 16))(v146, v196, v293);
      (*(void (**)(uint64_t *, uint64_t))(v197 + 8))(v299, v199);
      (*(void (**)(char *, char *, uint64_t *))(v198 + 32))(v144, v146, v142);
      unint64_t v127 = v198;
    }

    v147 = v348;
    unint64_t v125 = v341;
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v348 + 56))(v341, 0LL, 1LL, v131);
    v130 = (uint64_t)v332;
    v342 = v333;
    uint64_t v148 = v126;
LABEL_54:
    (*(void (**)(char *, char *, unint64_t *))(v147 + 32))(v128, v125, v131);
    v160 = *((int *)v131 + 12);
    v161 = *(void (**)(char *, char *, uint64_t *))(v117 + 16);
    v162 = v326;
    v161(v326, v128, v148);
    v163 = v327;
    v164 = v162;
    uint64_t v165 = (unint64_t)v331;
    v166 = swift_dynamicCast(v327, v164, v148, v331, 6LL);
    v167 = v343;
    v168 = *(void (**)(char *, uint64_t, uint64_t, unint64_t))(v343 + 56);
    if (!v166)
    {
      v168(v163, 1LL, 1LL, v165);
      (*(void (**)(char *, unint64_t *))(v147 + 8))(v128, v131);
      (*(void (**)(char *, uint64_t))(v296 + 8))(v163, v297);
LABEL_63:
      v200 = v340;
      swift_release((uint64_t)v340);
      outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)i);
      v201 = (uint64_t)v200;
      goto LABEL_113;
    }

    v169 = &v128[v160];
    v168(v163, 0LL, 1LL, v165);
    v170 = *(void (**)(char *, char *, unint64_t))(v167 + 32);
    v171 = v128;
    v172 = v324;
    v170(v324, v163, v165);
    v173 = v323;
    unint64_t v174 = v346;
    (*(void (**)(char *, char *, uint64_t *))(v127 + 16))(v323, v169, v346);
    (*(void (**)(char *, unint64_t *))(v348 + 8))(v171, v131);
    v175 = v325;
    v176 = v338;
    v177 = swift_dynamicCast(v325, v173, v174, v338, 6LL);
    v178 = v337;
    v179 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v337 + 56);
    if ((v177 & 1) == 0)
    {
      v179(v175, 1LL, 1LL, v176);
      (*(void (**)(char *, unint64_t))(v343 + 8))(v172, v165);
      (*(void (**)(char *, uint64_t))(v294 + 8))(v175, v295);
      goto LABEL_63;
    }

    v179(v175, 0LL, 1LL, v176);
    v180 = *(void (**)(char *, char *, uint64_t))(v178 + 32);
    v181 = v318;
    v180(v318, v175, v176);
    uint64_t v182 = v321;
    v183 = &v321[*((int *)TupleTypeMetadata2 + 12)];
    v170(v321, v172, v165);
    v180(v183, v181, v176);
    v184 = v335;
    uint64_t v185 = v320;
    uint64_t v186 = &v320[*((int *)v335 + 12)];
    v170(v320, v182, v165);
    v180(v186, v183, v176);
    v187 = &v185[*((int *)v184 + 12)];
    v188 = v315;
    v170(v315, v185, v165);
    v189 = v317;
    v180(v317, v187, v176);
    v190 = (uint64_t)v316;
    v170(v316, v188, v165);
    v191 = (uint64_t)v319;
    v180(v319, v189, v176);
    _NativeDictionary._unsafeInsertNew(key:value:)(v190, v191, v340, v165, v176, v339);
    unint64_t v124 = v130;
    unint64_t v125 = v341;
    unint64_t v107 = v342;
    a2 = v334;
    int64_t v117 = v347;
  }

  v135 = objc_msgSend(*((id *)v313 + 26), sel_countByEnumeratingWithState_objects_count_, v310, v309, 16);
  uint64_t v132 = v313;
  *((void *)v313 + 28) = v135;
  if (v135)
  {
    BOOL v133 = 0LL;
    *((void *)v132 + 27) = 0LL;
    goto LABEL_32;
  }

  *((void *)v132 + 27) = -1LL;
  v151 = v348;
  uint64_t v108 = (unint64_t)i;
LABEL_119:
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v151 + 56))(v125, 1LL, 1LL, v131);
  char v101 = v340;
  swift_release((uint64_t)v340);
  v284 = v108;
LABEL_122:
  outlined consume of [A : B].Iterator._Variant<A, B>(v284);
  return v101;
}

        v291 = 127LL;
        v170 = v77((unint64_t *)v78, v68);
        v171 = v256(v78, v68);
        if ((v170 & 1) != 0)
        {
          unint64_t v66 = v254;
          if (v171 > 64)
          {
            unint64_t v174 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
            v175 = lazy protocol witness table accessor for type Int and conformance Int(v171, v172, v173);
            v174(&v291, &type metadata for Int, v175, v78, v68);
            v176 = v287;
            v177 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v83,  v287,  v78);
            v178 = (void (*)(char *, uint64_t))v288;
            ((void (*)(char *, uint64_t))v288)(v83, v78);
            v179 = v176;
            goto LABEL_62;
          }
        }

        else
        {
          unint64_t v66 = v254;
          if (v171 > 63)
          {
            v290 = 127LL;
            uint64_t v182 = *(uint64_t (**)(char *, char *, uint64_t))(v84 + 32);
            v183 = v263;
            v184 = v182(v263, v287, v78);
            uint64_t v185 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
            v188 = lazy protocol witness table accessor for type Int and conformance Int(v184, v186, v187);
            v185(&v290, &type metadata for Int, v188, v78, v68);
            v177 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v83,  v183,  v78);
            v178 = (void (*)(char *, uint64_t))v288;
            ((void (*)(char *, uint64_t))v288)(v83, v78);
            v179 = v183;
LABEL_62:
            v178(v179, v78);
            if ((v177 & 1) == 0)
            {
LABEL_63:
              unint64_t v72 = v289;
              v189 = (*(uint64_t (**)(swift *, uint64_t))(v63 + 136))(a2, v63);
              uint64_t v71 = v253;
              if (v189 >= 24) {
                goto LABEL_109;
              }
              goto LABEL_16;
            }

        unint64_t v174 = v156(v141, v101);
        v175 = v341;
        v131(v341, v162, v141);
        if (v174 >= 65)
        {
          v137((uint64_t)v175, v141);
          v131((char *)v4, v162, v141);
LABEL_54:
          v372 = 0x7FFFFFFFFFFFFFFFLL;
          v176 = v367(v141, v101);
          v177 = v156(v141, v101);
          if ((v176 & 1) != 0)
          {
            if (v177 > 64)
            {
              v180 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v101 + 96);
              v181 = lazy protocol witness table accessor for type Int and conformance Int(v177, v178, v179);
              uint64_t v182 = v363;
              v180(&v372, &type metadata for Int, v181, v141, v101);
              v183 = (*((uint64_t (**)(char *, uint64_t, uint64_t, char *))v102 + 2))(v182, v4, v141, v102);
              v137((uint64_t)v182, v141);
              v184 = v4;
LABEL_113:
              v137(v184, v141);
              v162 = v365;
              if ((v183 & 1) == 0) {
                goto LABEL_114;
              }
              v370 = (uint64_t (*)(void, void))v141;
              v355 = (char *)v137;
LABEL_167:
              v364 = v162;
              goto LABEL_168;
            }
          }

          else if (v177 > 63)
          {
LABEL_112:
            v371 = 0x7FFFFFFFFFFFFFFFLL;
            v245 = v363;
            v246 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v368 + 32))(v363, v4, v141);
            v247 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v101 + 96);
            v250 = lazy protocol witness table accessor for type Int and conformance Int(v246, v248, v249);
            v251 = v340;
            v247(&v371, &type metadata for Int, v250, v141, v101);
            v183 = (*((uint64_t (**)(char *, char *, uint64_t, char *))v102 + 2))(v251, v245, v141, v102);
            v137((uint64_t)v251, v141);
            v184 = (uint64_t)v245;
            goto LABEL_113;
          }

          v206 = v363;
          (*(void (**)(char *, uint64_t, uint64_t))(v368 + 32))(v363, v4, v141);
          (*(void (**)(uint64_t, uint64_t))(v101 + 120))(v141, v101);
          v137((uint64_t)v206, v141);
          v162 = v365;
LABEL_114:
          v230 = (*(uint64_t (**)(uint64_t, uint64_t))(v101 + 120))(v141, v101);
          v137(v162, v141);
          return v230;
        }

        v200 = v156(v141, v101);
        v137((uint64_t)v175, v141);
        if (v200 == 64)
        {
          v201 = v367(v141, v101);
          v131((char *)v4, v162, v141);
          if ((v201 & 1) == 0) {
            goto LABEL_54;
          }
        }

        else
        {
          v131((char *)v4, v162, v141);
        }

        v137(v4, v141);
        goto LABEL_114;
      }

      v215 = v128(v4, v101);
      v156 = *(uint64_t (**)(uint64_t, uint64_t))(v101 + 128);
      v370 = (uint64_t (*)(void, void))v4;
      v216 = v156(v4, v101);
      if ((v215 & 1) != 0)
      {
        if (v216 > 64)
        {
          v219 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v101 + 96);
          v220 = lazy protocol witness table accessor for type Int and conformance Int(v216, v217, v218);
          v221 = v363;
          v141 = (uint64_t)v370;
          v219(&v372, &type metadata for Int, v220, (uint64_t)v370, v101);
          v222 = v360;
          v223 = (*((uint64_t (**)(char *, char *, uint64_t, char *))v102 + 2))(v360, v221, v141, v102);
          v137 = (uint64_t (*)(uint64_t, uint64_t))v355;
          ((void (*)(char *, uint64_t))v355)(v221, v141);
          v137((uint64_t)v222, v141);
          v162 = v365;
          uint64_t v4 = (uint64_t)v348;
          if ((v223 & 1) != 0) {
            goto LABEL_167;
          }
          goto LABEL_52;
        }

        v302 = v361;
        v303 = (uint64_t)v362;
        v304 = (uint64_t)v370;
        v305 = swift_getAssociatedConformanceWitness( (uint64_t)v362,  (uint64_t)v370,  v361,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v305 + 8))( &unk_18180BE68,  256LL,  v302,  v305);
        v306 = v363;
        v307 = v27;
        v141 = v304;
        (*(void (**)(char *, uint64_t, uint64_t))(v303 + 24))(v307, v304, v303);
        v308 = v360;
        LOBYTE(v302) = (*((uint64_t (**)(char *, char *, uint64_t, char *))v102 + 2))(v360, v306, v304, v102);
        v309 = (void (*)(char *, uint64_t))v355;
        ((void (*)(char *, uint64_t))v355)(v306, v304);
        v310 = v339;
        (*(void (**)(char *, char *, uint64_t))(v368 + 32))(v339, v308, v141);
        if ((v302 & 1) != 0)
        {
          v309(v310, v141);
          v364 = v365;
          goto LABEL_168;
        }

        v311 = v372;
        v312 = (*(uint64_t (**)(uint64_t, uint64_t))(v101 + 120))(v141, v101);
        v309(v310, v141);
        v284 = v312 < v311;
        v137 = (uint64_t (*)(uint64_t, uint64_t))v309;
LABEL_145:
        v162 = v365;
        uint64_t v4 = (uint64_t)v348;
        if (v284) {
          goto LABEL_167;
        }
        goto LABEL_52;
      }

      if (v216 < 64)
      {
        v282 = v360;
        v141 = (uint64_t)v370;
        v283 = (*(uint64_t (**)(uint64_t, uint64_t))(v101 + 120))((uint64_t)v370, v101);
        v137 = (uint64_t (*)(uint64_t, uint64_t))v355;
        ((void (*)(char *, uint64_t))v355)(v282, v141);
        v284 = v283 < v372;
        goto LABEL_145;
      }

      v141 = (uint64_t)v370;
      v137 = (uint64_t (*)(uint64_t, uint64_t))v355;
      ((void (*)(char *, uint64_t (*)(uint64_t, unint64_t)))v355)(v360, v370);
      v162 = v365;
    }

    else
    {
      v154(v155, v4);
      v156 = *(uint64_t (**)(uint64_t, uint64_t))(v101 + 128);
      v137 = (uint64_t (*)(uint64_t, uint64_t))v154;
      v162 = v365;
      v141 = v4;
    }

    uint64_t v4 = (uint64_t)v348;
    goto LABEL_52;
  }

  v364 = v5;
  unint64_t v72 = v23;
  uint64_t v73 = swift_getAssociatedConformanceWitness( (uint64_t)v23,  v4,  v24,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v360 = *(char **)(v73 + 8);
  ((void (*)(void *, uint64_t, unint64_t, unint64_t))v360)(&unk_18180BE68, 256LL, v24, v73);
  unint64_t v74 = (void (*)(char *, uint64_t, const char *))*((void *)v72 + 3);
  v74(v27, v4, v72);
  char v75 = *(char **)(*(void *)(v366 + 32) + 8LL);
  Swift::String v76 = (uint64_t (*)(uint64_t (*)(uint64_t, unint64_t), char *, uint64_t, char *))*((void *)v75 + 2);
  LODWORD(v365) = v76(v369, v63, v4, v75);
  uint64_t v77 = *(void (**)(char *, uint64_t))(v368 + 8);
  v77(v63, v4);
  v345 = (char *)v73;
  ((void (*)(void *, uint64_t, unint64_t, unint64_t))v360)(&unk_18180BE68, 256LL, v24, v73);
  uint64_t v78 = (uint64_t)v362;
  v341 = (char *)v74;
  v74(v27, v4, v362);
  v346 = v75;
  v348 = (uint64_t (*)(char *, char *, uint64_t, char *))v76;
  uint64_t v79 = v76(v370, v63, v4, v75);
  v355 = (char *)v77;
  v77(v63, v4);
  if (((v365 ^ v79) & 1) == 0)
  {
    v111 = (uint64_t)v358;
    (*(void (**)(uint64_t (*)(uint64_t, unint64_t), uint64_t (*)(uint64_t, unint64_t), uint64_t))(*(void *)(v364 + 8) + 40LL))( v370,  v369,  v4);
    uint64_t v112 = v366;
    uint64_t v113 = v367(v4, v366);
    uint64_t v114 = *(void (**)(char *, uint64_t, uint64_t))(v368 + 16);
    v115 = v342;
    v114(v342, v111, v4);
    if ((v113 & 1) != 0)
    {
      v361 = v24;
      int64_t v116 = *(uint64_t (**)(uint64_t, uint64_t))(v112 + 128);
      int64_t v117 = v116(v4, v112);
      int64_t v90 = v112;
      uint64_t v87 = (void (*)(char *, uint64_t))v355;
      ((void (*)(char *, uint64_t))v355)(v115, v4);
      int64_t v118 = v354;
      v114(v354, v111, v4);
      if (v117 >= 65)
      {
        v372 = 0x8000000000000000LL;
        char v119 = v367;
        if ((v367(v4, v90) & 1) != 0)
        {
          uint64_t v120 = v116(v4, v90);
          uint64_t v123 = v118;
          uint64_t v92 = v349;
          Swift::Int v84 = v4;
          if (v120 >= 64)
          {
            v289 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v90 + 96);
            v290 = lazy protocol witness table accessor for type Int and conformance Int(v120, v121, v122);
            v291 = v363;
            v289(&v372, &type metadata for Int, v290, v84, v90);
            v292 = v348(v123, v291, v84, v346);
            uint64_t v87 = (void (*)(char *, uint64_t))v355;
            ((void (*)(char *, uint64_t))v355)(v291, v84);
            v87(v123, v84);
            unint64_t v125 = v367;
            v111 = (uint64_t)v358;
            char v126 = v347;
            if ((v292 & 1) != 0) {
              goto LABEL_138;
            }
          }

          else
          {
            unint64_t v124 = (*(uint64_t (**)(uint64_t, uint64_t))(v90 + 120))(v4, v90);
            uint64_t v87 = (void (*)(char *, uint64_t))v355;
            ((void (*)(char *, uint64_t))v355)(v123, v4);
            unint64_t v125 = v367;
            v111 = (uint64_t)v358;
            char v126 = v347;
            if (v124 < v372) {
              goto LABEL_138;
            }
          }

                      __break(1u);
                      goto LABEL_53;
                    }

                    goto LABEL_49;
                  }

      v39._Swift::UInt64 rawBits = 1LL;
      v40._Swift::UInt64 rawBits = 65537LL;
      v41._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v39, v40, 0x5CuLL, 0xE100000000000000LL);
      if (v41._rawBits < 0x10000) {
        v41._rawBits |= 3;
      }
      int64_t v43 = specialized String.init(_:)(v41, v42, 0x5CuLL, 0xE100000000000000LL);
      uint64_t v45 = v44;
      swift_bridgeObjectRelease(0xE100000000000000LL);
      if ((v45 & 0x2000000000000000LL) == 0) {
        goto LABEL_201;
      }
      swift_bridgeObjectRelease(v45);
      goto LABEL_56;
    }

    unint64_t v25 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
    unint64_t v28 = (v26 & 1) == 0 && v25 > 0;
    if ((v22 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (!v28)
      {
LABEL_37:
        int64_t v29 = _StringGuts.nativeCapacity.getter(v8, v9);
        if ((v30 & 1) != 0) {
          unint64_t v31 = 0LL;
        }
        else {
          unint64_t v31 = v29;
        }
        if (v31 + 0x4000000000000000LL < 0)
        {
          __break(1u);
LABEL_206:
          Swift::Int v8 = _StringGuts._foreignConvertedToSmall()(v8, v9);
          uint64_t v11 = v175;
          goto LABEL_52;
        }

        unint64_t v32 = 2 * v31;
        if (v32 > v21) {
          unint64_t v21 = v32;
        }
      }

      _StringGuts.grow(_:)(v21);
      goto LABEL_44;
    }

    if (!v28) {
      goto LABEL_37;
    }
LABEL_44:
    swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
    v186[0] = xmmword_1817FFD40;
    unint64_t v33 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)v186, 1LL);
    _StringGuts.appendInPlace(_:isASCII:)(v33, v34, 1);
    swift_bridgeObjectRelease(0xE100000000000000LL);
  }

  if (v43)
  {
    int64_t v89 = 0;
    int64_t v90 = 0LL;
    char v91 = v188;
    uint64_t v1 = v185;
    do
    {
      uint64_t v92 = v66 + v90;
      unint64_t v93 = v90 + 1;
      if (v90 >= 8) {
        uint64_t v94 = v63;
      }
      else {
        uint64_t v94 = v62;
      }
      unint64_t v95 = v94 >> (v89 & 0x38);
      unint64_t v96 = (8 * v66 + v89) & 0x38;
      unint64_t v97 = (-255LL << v96) - 1;
      unint64_t v98 = (unint64_t)v95 << v96;
      unint64_t v99 = v98 | v97 & v91;
      uint64_t v100 = v98 | v97 & v9;
      if (v92 < 8) {
        int64_t v9 = v100;
      }
      else {
        char v91 = v99;
      }
      v89 += 8;
      int64_t v90 = v93;
    }

    while (v43 != v93);
  }

  else
  {
    char v91 = v188;
    uint64_t v1 = v185;
  }

  swift_bridgeObjectRelease(v188);
  swift_bridgeObjectRelease(v8);
  uint64_t v132 = 0xA000000000000000LL;
  if (!(v9 & 0x8080808080808080LL | v91 & 0x80808080808080LL)) {
    uint64_t v132 = 0xE000000000000000LL;
  }
  v187 = v9;
  v188 = v132 & 0xFF00000000000000LL | (v88 << 56) | v91 & 0xFFFFFFFFFFFFFFLL;
LABEL_159:
  Swift::Int v8 = v187;
  int64_t v9 = v188;
  BOOL v133 = HIBYTE(v188) & 0xF;
  uint64_t v134 = v187 & 0xFFFFFFFFFFFFLL;
  if ((v188 & 0x2000000000000000LL) != 0) {
    v135 = HIBYTE(v188) & 0xF;
  }
  else {
    v135 = v187 & 0xFFFFFFFFFFFFLL;
  }
  if (!v135 && (v187 & ~v188 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v188);
    Swift::Int v8 = 0LL;
    uint64_t v157 = 0xE000000000000000LL;
    goto LABEL_191;
  }

  if ((v188 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v188);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    v158 = 0xA000000000000000LL;
    if (!(v9 & 0x80808080808080LL | v8 & 0x8080808080808080LL)) {
      v158 = 0xE000000000000000LL;
    }
    uint64_t v157 = v158 & 0xFF00000000000000LL | (v133 << 56) | v9 & 0xFFFFFFFFFFFFFFLL;
    goto LABEL_191;
  }

  swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v85, v86);
  if ((v9 & 0x1000000000000000LL) == 0)
  {
    if ((v8 & ~v9 & 0x2000000000000000LL) != 0) {
      goto LABEL_167;
    }
LABEL_189:
    if (v134 > 15) {
      goto LABEL_190;
    }
LABEL_171:
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
    swift_bridgeObjectRetain(v9, v138, v139, v140);
    v141 = _StringGuts._convertedToSmall()(v8, v9);
    v143 = v142;
    swift_bridgeObjectRelease(v9);
    v144._Swift::UInt64 rawBits = 1LL;
    v145._Swift::UInt64 rawBits = 1LL;
    v146._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v144, v145, 0LL, 0xE000000000000000LL);
    if (v146._rawBits < 0x10000) {
      v146._rawBits |= 3;
    }
    uint64_t v148 = specialized String.init(_:)(v146, v147, 0LL, 0xE000000000000000LL);
    v150 = v149;
    swift_bridgeObjectRelease(0xE000000000000000LL);
    v151 = _StringGuts._convertedToSmall()(v148, v150);
    v153 = v152;
    swift_bridgeObjectRelease(v150);
    unint64_t v154 = specialized _SmallString.init(_:appending:)(v141, v143, v151, v153);
    if ((v156 & 1) != 0) {
      goto LABEL_210;
    }
    Swift::Int v8 = v154;
    uint64_t v157 = v155;
    swift_bridgeObjectRelease(v9);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    goto LABEL_191;
  }

        v38._Swift::UInt64 rawBits = 1LL;
        v39._Swift::UInt64 rawBits = 65537LL;
        v40._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v38, v39, 0x22uLL, 0xE100000000000000LL);
        if (v40._rawBits < 0x10000) {
          v40._rawBits |= 3;
        }
        int64_t v9 = specialized String.init(_:)(v40, v41, 0x22uLL, 0xE100000000000000LL);
        int64_t v43 = v42;
        swift_bridgeObjectRelease(0xE100000000000000LL);
        if ((v43 & 0x2000000000000000LL) == 0) {
          goto LABEL_212;
        }
        swift_bridgeObjectRelease(v43);
        goto LABEL_56;
      }

      unint64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v7, object);
      uint64_t v27 = (v25 & 1) == 0 && v24 > 0;
      if ((v9 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
      {
        if (!v27)
        {
LABEL_37:
          unint64_t v28 = _StringGuts.nativeCapacity.getter(v7, object);
          if ((v29 & 1) != 0) {
            int64_t v30 = 0LL;
          }
          else {
            int64_t v30 = v28;
          }
          if (v30 + 0x4000000000000000LL < 0)
          {
            __break(1u);
LABEL_217:
            uint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, object);
            uint64_t countAndFlagsBits = v167;
            goto LABEL_52;
          }

          unint64_t v31 = 2 * v30;
          if (v31 > v21) {
            unint64_t v21 = v31;
          }
        }

        _StringGuts.grow(_:)(v21);
        goto LABEL_44;
      }

      if (!v27) {
        goto LABEL_37;
      }
LABEL_44:
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
      v176[0] = xmmword_1817FFD50;
      unint64_t v32 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)v176, 1LL);
      _StringGuts.appendInPlace(_:isASCII:)(v32, v33, 1);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }

    swift_bridgeObjectRetain_n(object, 5LL, v68, v69);
    v153._Swift::UInt64 rawBits = 1LL;
    v154._Swift::UInt64 rawBits = (v67 << 16) | 1;
    v155._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v153, v154, countAndFlagsBits, object);
    if (v155._rawBits < 0x10000) {
      v155._rawBits |= 3;
    }
    unint64_t v70 = specialized Collection.count.getter(v155, v156, countAndFlagsBits, object);
    swift_bridgeObjectRelease(object);
    if ((v1 & 0x1000000000000000LL) == 0) {
      goto LABEL_85;
    }
LABEL_192:
    uint64_t v157 = String.UTF8View._foreignCount()();
    uint64_t v71 = v157 + v70;
    if (__OFADD__(v157, v70)) {
      goto LABEL_194;
    }
LABEL_86:
    v175 = v67;
    if ((v7 & ~v1 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v1 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v43 = v177;
      uint64_t v7 = v178;
      unint64_t v72 = _StringGuts.nativeUnusedCapacity.getter(v177, v178);
      if ((v73 & 1) == 0)
      {
        if (v71 <= 15)
        {
          if ((v7 & 0x2000000000000000LL) != 0)
          {
            Swift::String v85 = 0;
            uint64_t v1 = v7;
            goto LABEL_138;
          }

          uint64_t v1 = v7;
          if (v72 < v70)
          {
LABEL_118:
            Swift::String v85 = 1;
            goto LABEL_138;
          }
        }

                  uint64_t v86 = (v92 - 1) & v92;
                  int64_t v90 = __clz(__rbit64(v92)) + (v85 << 6);
                  uint64_t v55 = v157;
                }

                (*(void (**)(char *, unint64_t, uint64_t *))(v8 + 16))( v39,  *(void *)(v55 + 48) + *(void *)(v8 + 72) * v90,  a2);
                uint64_t v83 = v39;
                Swift::Int v84 = *(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
              }

              unint64_t v99 = (uint64_t)v162;
              swift_release((uint64_t)v153);
              swift_release(v99);
              outlined consume of [A : B].Iterator._Variant<A, B>(v157);
              (*(void (**)(char *, uint64_t))(v143 + 8))(v96, v144);
              return 0LL;
            }

            v139 = v39;
            Swift::Int v84 = *(void (**)(char *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
            v84((char *)v66, 1LL, 1LL, a2);
            _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v82, (uint64_t)a2, v66);
            swift_unknownObjectRelease(v82);
            uint64_t v87 = v66;
            int64_t v88 = v140;
            int64_t v89 = v141;
            (*(void (**)(char *, uint64_t *, uint64_t))(v140 + 16))(v29, v87, v141);
            if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(v8 + 48))(v29, 1LL, a2) != 1)
            {
              (*(void (**)(uint64_t *, uint64_t))(v88 + 8))(v87, v89);
              uint64_t v83 = v139;
              (*(void (**)(char *, char *, uint64_t *))(v8 + 32))(v139, v29, a2);
              goto LABEL_36;
            }

          uint64_t v45 = 1781LL;
LABEL_53:
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v45,  0);
        }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

      uint64_t v59 = 1861LL;
      goto LABEL_55;
    }
  }

  else if (v14 > 15)
  {
    goto LABEL_14;
  }

  unint64_t v22 = _StringGuts._convertedToSmall()(v12, v11);
  unint64_t v24 = v23;
  swift_bridgeObjectRetain(x1_0, v23, v25, v26);
  v27._Swift::UInt64 rawBits = Substring.init(_:)(a1, x1_0, a3, a4);
  int64_t v29 = v28;
  unint64_t v31 = specialized String.init(_:)(v27, v63, v30, v28);
  unint64_t v33 = v32;
  swift_bridgeObjectRelease(v29);
  uint64_t v34 = _StringGuts._convertedToSmall()(v31, v33);
  unint64_t v36 = v35;
  swift_bridgeObjectRelease(v33);
  int64_t v37 = HIBYTE(v24) & 0xF;
  int64_t v38 = HIBYTE(v36) & 0xF;
  int64_t v39 = v38 + v37;
  if ((unint64_t)(v38 + v37) > 0xF)
  {
LABEL_58:
    uint64_t v61 = 266LL;
    goto LABEL_60;
  }

  if (v38)
  {
    unint64_t v40 = 0;
    int64_t v41 = 0LL;
    do
    {
      int64_t v42 = v37 + v41;
      int64_t v43 = v41 + 1;
      if (v41 >= 8) {
        uint64_t v44 = v36;
      }
      else {
        uint64_t v44 = v34;
      }
      uint64_t v45 = v44 >> (v40 & 0x38);
      uint64_t v46 = (8 * v37 + v40) & 0x38;
      int64_t v47 = (-255LL << v46) - 1;
      unint64_t v48 = (unint64_t)v45 << v46;
      uint64_t v49 = v47 & v24 | v48;
      uint64_t v50 = v47 & v22 | v48;
      if (v42 < 8) {
        unint64_t v22 = v50;
      }
      else {
        unint64_t v24 = v49;
      }
      v40 += 8;
      int64_t v41 = v43;
    }

    while (v38 != v43);
  }

  swift_bridgeObjectRelease(v11);
  uint64_t v51 = 0xA000000000000000LL;
  if (!(v22 & 0x8080808080808080LL | v24 & 0x80808080808080LL)) {
    uint64_t v51 = 0xE000000000000000LL;
  }
  *int64_t v5 = v22;
  v5[1] = v51 & 0xFF00000000000000LL | (v39 << 56) | v24 & 0xFFFFFFFFFFFFFFLL;
}

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    v67[0] = a3;
    v67[1] = a4 & 0xFFFFFFFFFFFFFFLL;
    if ((HIBYTE(a4) & 0xF) < v10) {
      goto LABEL_52;
    }
    if ((uint64_t)(v10 - v9) < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    uint64_t v51 = v5[1] & 0xFFFFFFFFFFFFFFFLL;
    specialized UnsafeMutablePointer.initialize(from:count:)( (char *)v67 + v9,  v10 - v9,  (char *)(v51 + (*(void *)(v51 + 0x18) & 0xFFFFFFFFFFFFLL) + 32));
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)( (*(void *)(v51 + 24) & 0xFFFFFFFFFFFFLL) + v10 - v9,  (a4 >> 62) & (*(uint64_t *)(v51 + 24) < 0));
    *int64_t v5 = *(void *)(v51 + 24);
  }

  v13._Swift::UInt64 rawBits = 0LL;
  unint64_t v32 = 1;
LABEL_57:
  result.value = v13;
  result.is_nil = v32;
  return result;
}

              if (!Node) {
                goto LABEL_57;
              }
              int64_t v63 = *(unsigned int *)(a3 + 8);
              if (v63 >= *(unsigned int *)(a3 + 12))
              {
                __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a3, v65, v63 + 1, 8LL);
                int64_t v63 = *(unsigned int *)(a3 + 8);
              }

              uint64_t v15 = v56;
              *(void *)(*(void *)a3 + 8 * v63) = Node;
              ++*(_DWORD *)(a3 + 8);
              ++v49;
            }

            else
            {
              if ((*v16 & 0x3F) != 0) {
                goto LABEL_57;
              }
              if (v51) {
                uint64_t v52 = (*((void *)v67[0] + v48) & 1LL) == 0;
              }
              else {
                uint64_t v52 = 0;
              }
              if (!v52) {
                swift::fatalError(0LL, "Expected metadata but got a metadata pack\n", v45, v46);
              }
              uint64_t v53 = _swift_buildDemanglingForMetadata(*((void *)v67[0] + v48), a4);
              if (!v53) {
                goto LABEL_57;
              }
              uint64_t v54 = v53;
              uint64_t v55 = *(unsigned int *)(a3 + 8);
              if (v55 >= *(unsigned int *)(a3 + 12))
              {
                __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a3, v65, v55 + 1, 8LL);
                uint64_t v55 = *(unsigned int *)(a3 + 8);
              }

              *(void *)(*(void *)a3 + 8 * v55) = v54;
              ++*(_DWORD *)(a3 + 8);
            }

            ++v48;
            ++v16;
          }

          while (v16 != v50);
          uint64_t v4 = 1LL;
        }

        else
        {
          uint64_t v4 = 1LL;
        }
      }

      else
      {
        uint64_t v4 = 0LL;
      }

    NonNullSrcObject = getNonNullSrcObject(a3, (Class)a4, (const char *)a2, v25);
    if (NonNullSrcObject)
    {
      int64_t v35 = swift_getObjectType(NonNullSrcObject);
      if (v35 != a4)
      {
        *a6 = v35;
        uint64_t v20 = v18(v78, a2, a3, v35, a5, a6, a7, a8);
        if ((_DWORD)v20) {
          return v20;
        }
      }
    }

    if (isa == 771)
    {
LABEL_61:
      unint64_t v40 = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a4);
      if (v40)
      {
        if (v40 == 2)
        {
          int64_t v42 = (swift::SwiftError *)*a3;
          uint64_t v44 = (uint64_t)a3;
          if (!swift::SwiftError::isPureNSError((swift::SwiftError *)*a3, v41))
          {
            uint64_t v45 = *(unsigned __int8 *)(*(void *)(*((void *)v42 + 5) - 8LL) + 80LL);
            uint64_t v44 = ((unint64_t)v42 + v45 + 72) & ~v45;
          }

          Type = swift::SwiftError::getType(v42, v43);
        }

        else
        {
          Type = swift_getObjectType(*a3);
          uint64_t v44 = (uint64_t)a3;
        }
      }

      else
      {
        Type = a3[3];
        uint64_t v44 = (uint64_t)swift::TargetExistentialTypeMetadata<swift::InProcess>::projectValue( a4,  (swift::SwiftError **)a3);
      }

      *a6 = Type;
      else {
        unint64_t v33 = 0LL;
      }
      unint64_t v28 = v78;
      int64_t v29 = a2;
      int64_t v30 = (uint64_t *)v44;
      MetatypeMetadata = Type;
LABEL_85:
      unint64_t v31 = a5;
      unint64_t v32 = a6;
LABEL_86:
      uint64_t v20 = tryCast(v28, v29, v30, MetatypeMetadata, v31, v32, v33, a8);
      if ((_DWORD)v20) {
        return v20;
      }
    }

    else if (isa == 773)
    {
      AsSwiftValue = swift::getAsSwiftValue((swift *)*a3, v23);
      if (AsSwiftValue)
      {
        ValueFromSwiftValue = swift::getValueFromSwiftValue(AsSwiftValue, v37);
        uint64_t v20 = tryCast(v78, a2, v39, ValueFromSwiftValue, a5, a6, 0LL, a8);
        if ((_DWORD)v20) {
          return v20;
        }
      }
    }

  a6 = 4294967293LL;
LABEL_53:
  if (__p)
  {
    int64_t v42 = __p;
    operator delete(__p);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&DynamicReplacementLock);
}

LABEL_45:
            v4[2] = (__objc2_class *)v2;
            goto LABEL_46;
          }
        }
      }
    }

              uint64_t v186 = v140;
              v187 = v323;
              v337 = (char *)*((void *)v140 + 15);
              ((void (*)(uint64_t, const char *))v337)(v74, v140);
              v188 = v325;
              ((void (*)(uint64_t, const char *))v345)(v74, v186);
              v124(v187, v74);
              v189 = (uint64_t (*)(unint64_t *, uint64_t))v301;
              LODWORD(v186) = ((uint64_t (*)(unint64_t *, uint64_t))v301)(v85, v100);
              if (((v186 ^ ((unsigned int (*)(unint64_t *, uint64_t))v328)(v103, v99)) & 1) != 0)
              {
                v190 = v189(v85, v100);
                v191 = v85;
                uint64_t v192 = v190;
                v193 = v296(v191, v100);
                uint64_t v194 = v300(v103, v99);
                if ((v192 & 1) != 0)
                {
                  if (v194 >= v193)
                  {
                    v239 = (void (**)(char *, uint64_t, const char *))v318;
                    v240 = v338;
                    v241 = v316;
                    v242 = swift_getAssociatedConformanceWitness( (uint64_t)v318,  v338,  v316,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    v243 = v317;
                    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v242 + 8))( &unk_18180BE68,  256LL,  v241,  v242);
                    v244 = v329;
                    v239[3](v243, v240, (const char *)v239);
                    LOBYTE(v239) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v100 + 32)
                                                                                                  + 8LL)
                                                                                      + 16LL))( v188,  v244,  v240);
                    v245 = v330;
                    v345 = *(const char **)(v330 + 8);
                    ((void (*)(char *, uint64_t))v345)(v244, v240);
                    v246 = v307;
                    (*(void (**)(char *, char *, uint64_t))(v245 + 32))(v307, v188, v240);
                    v247 = v335;
                    v248 = v309;
                    v249 = v333;
                    (*(void (**)(char *, char *, unint64_t *))(v335 + 32))(v309, v299, v333);
                    uint64_t v77 = v343;
                    v212 = v295;
                    if ((v239 & 1) != 0)
                    {
                      (*(void (**)(char *, unint64_t *))(v247 + 8))(v248, v249);
                      ((void (*)(char *, uint64_t))v345)(v246, v240);
                      v210 = v327;
                      goto LABEL_57;
                    }

                    v287 = v332;
                    v288 = v298;
                    (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, uint64_t))(v332 + 96))( v246,  v240,  v100,  v249,  v332);
                    v289 = v309;
                    LOBYTE(v287) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v287 + 32) + 8LL)
                                                                                                 + 16LL))( v288,  v309,  v249);
                    v290 = *(void (**)(char *, unint64_t *))(v247 + 8);
                    v290(v288, v249);
                    v290(v289, v249);
                    v211 = v326;
                    v210 = v327;
                    if ((v287 & 1) != 0) {
                      goto LABEL_57;
                    }
LABEL_76:
                    v291 = (*(uint64_t (**)(uint64_t))(v340 + 136))(v77);
                    ((void (*)(uint64_t, const char *))v337)(v74, v336);
                    v292 = (*(uint64_t (**)(uint64_t))(v339 + 136))(v74);
                    v334(v211, v74);
                    v293 = v292 < v291;
                    Swift::Int v84 = v210;
                    if (!v293) {
                      goto LABEL_16;
                    }
                    v213 = v210;
LABEL_79:
                    v212(v213, v77);
                    goto LABEL_80;
                  }

                  v195 = v298;
                  v196 = v333;
                  (*(void (**)(char *, char *, unint64_t *))(v335 + 32))(v298, v299, v333);
                  v197 = v329;
                  Swift::String v85 = (unint64_t *)v338;
                  (*(void (**)(char *, unint64_t *, uint64_t, uint64_t, uint64_t))(v100 + 96))( v195,  v196,  v332,  v338,  v100);
                  v198 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32) + 8LL)
                                                                                       + 16LL))( v188,  v197,  v85);
                  v199 = v330;
                }

                else
                {
                  if (v193 >= v194)
                  {
                    v250 = v315;
                    v251 = v333;
                    v252 = v313;
                    v253 = swift_getAssociatedConformanceWitness( (uint64_t)v315,  (uint64_t)v333,  v313,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                    v254 = v314;
                    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v253 + 8))( &unk_18180BE68,  256LL,  v252,  v253);
                    v255 = v298;
                    (*((void (**)(char *, unint64_t *, const char *))v250 + 3))(v254, v251, v250);
                    v256 = v332;
                    v257 = v188;
                    v258 = v299;
                    LODWORD(v345) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v332 + 32) + 8LL)
                                                                                                  + 40LL))( v299,  v255,  v251);
                    v259 = v335;
                    v331 = *(void *)(v335 + 8);
                    ((void (*)(char *, unint64_t *))v331)(v255, v251);
                    v260 = v330;
                    v261 = v308;
                    v262 = v257;
                    v263 = v338;
                    (*(void (**)(char *, char *, uint64_t))(v330 + 32))(v308, v262, v338);
                    v264 = *(void (**)(char *, char *, unint64_t *))(v259 + 32);
                    v265 = v326;
                    v266 = v303;
                    v264(v303, v258, v251);
                    if ((v345 & 1) != 0)
                    {
                      v267 = v329;
                      (*(void (**)(char *, unint64_t *, uint64_t, uint64_t, uint64_t))(v100 + 96))( v266,  v251,  v256,  v263,  v100);
                      v268 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v100 + 32)
                                                                                            + 8LL)
                                                                                + 16LL))( v261,  v267,  v263);
                      v269 = *(void (**)(char *, uint64_t))(v260 + 8);
                      v269(v267, v263);
                      v269(v261, v263);
                      uint64_t v77 = v343;
                      v212 = v295;
                      v210 = v327;
                      v211 = v265;
                      if ((v268 & 1) != 0) {
                        goto LABEL_57;
                      }
                    }

                    else
                    {
                      ((void (*)(char *, unint64_t *))v331)(v266, v251);
                      (*(void (**)(char *, uint64_t))(v260 + 8))(v261, v263);
                      uint64_t v77 = v343;
                      v212 = v295;
                      v210 = v327;
                      v211 = v265;
                    }

                    goto LABEL_76;
                  }

                  v207 = v332;
                  Swift::String v85 = v333;
                  v197 = v298;
                  (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, uint64_t))(v332 + 96))( v188,  v338,  v100,  v333,  v332);
                  v188 = v299;
                  v198 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v207 + 32) + 8LL)
                                                                                       + 16LL))( v197,  v299,  v85);
                  v199 = v335;
                }

                v204 = *(void (**)(char *, unint64_t *))(v199 + 8);
                v204(v197, v85);
                v205 = v188;
              }

              else
              {
                v200 = v296(v85, v100);
                v201 = v188;
                v202 = v299;
                if (v200 < v300(v103, v99))
                {
                  v203 = v298;
                  (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v99 + 96))( v201,  v85,  v100,  v103,  v99);
                  v198 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v99 + 32) + 8LL)
                                                                                       + 16LL))( v203,  v202,  v103);
                  v204 = *(void (**)(char *, unint64_t *))(v335 + 8);
                  v204(v203, v103);
                  v205 = v202;
                  v206 = v103;
                  goto LABEL_56;
                }

                v208 = v298;
                (*(void (**)(char *, char *, unint64_t *))(v335 + 32))(v298, v202, v103);
                v209 = v329;
                (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v100 + 96))( v208,  v103,  v99,  v85,  v100);
                v198 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v201,  v209,  v85);
                v204 = *(void (**)(char *, unint64_t *))(v330 + 8);
                v204(v209, v85);
                v205 = v201;
              }

              v206 = v85;
LABEL_56:
              v204(v205, v206);
              v211 = v326;
              v210 = v327;
              uint64_t v77 = v343;
              v212 = v295;
              if ((v198 & 1) != 0)
              {
LABEL_57:
                v213 = v210;
                goto LABEL_79;
              }

              goto LABEL_76;
            }

            uint64_t v100 = v331;
            unint64_t v99 = v332;
            v115 = v298;
            Swift::String v85 = (unint64_t *)v338;
            int64_t v103 = v333;
            (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, uint64_t))(v332 + 96))( v106,  v338,  v331,  v333,  v332);
            int64_t v116 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v99 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v94,  v115,  v103);
            (*(void (**)(char *, unint64_t *))(v335 + 8))(v115, v103);
          }

          else if (v111 >= v113)
          {
            v141 = (void (**)(char *, unint64_t *, const char *))v318;
            Swift::String v85 = (unint64_t *)v338;
            unint64_t v142 = v316;
            v143 = swift_getAssociatedConformanceWitness( (uint64_t)v318,  v338,  v316,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            unint64_t v144 = v106;
            v145 = v317;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v143 + 8))( &unk_18180BE68,  256LL,  v142,  v143);
            v146 = v329;
            v141[3](v145, v85, (const char *)v141);
            uint64_t v100 = v331;
            LOBYTE(v141) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v331 + 32) + 8LL)
                                                                                         + 40LL))( v106,  v146,  v85);
            v147 = v330;
            uint64_t v148 = *(void (**)(char *, unint64_t *))(v330 + 8);
            v148(v146, v85);
            v149 = v335;
            v150 = v310;
            int64_t v103 = v333;
            (*(void (**)(char *, char *, unint64_t *))(v335 + 16))(v310, v114, v333);
            v151 = v311;
            (*(void (**)(char *, char *, unint64_t *))(v147 + 32))(v311, v144, v85);
            if ((v141 & 1) == 0)
            {
              v148(v151, v85);
              (*(void (**)(char *, unint64_t *))(v149 + 8))(v150, v103);
              unint64_t v99 = v332;
              unint64_t v124 = v334;
              v140 = v336;
              unint64_t v74 = v344;
              goto LABEL_45;
            }

            unint64_t v152 = v149;
            unint64_t v99 = v332;
            v153 = v151;
            unint64_t v154 = v298;
            (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v332 + 96))( v153,  v85,  v100,  v103,  v332);
            int64_t v116 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v99 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v150,  v154,  v103);
            v155 = *(void (**)(char *, unint64_t *))(v152 + 8);
            v155(v154, v103);
            v155(v150, v103);
          }

          else
          {
            unint64_t v125 = v298;
            int64_t v103 = v333;
            (*(void (**)(char *, char *, unint64_t *))(v335 + 16))(v298, v94, v333);
            uint64_t v100 = v331;
            unint64_t v99 = v332;
            char v126 = v329;
            Swift::String v85 = (unint64_t *)v338;
            (*(void (**)(char *, unint64_t *, uint64_t, uint64_t, uint64_t))(v331 + 96))( v125,  v103,  v332,  v338,  v331);
            int64_t v116 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v126,  v106,  v85);
            unint64_t v127 = *(void (**)(char *, unint64_t *))(v330 + 8);
            v127(v126, v85);
            v127(v106, v85);
          }

          unint64_t v124 = v334;
        }

        else
        {
          v300 = *(uint64_t (**)(unint64_t *, uint64_t))(v99 + 128);
          int64_t v118 = v300(v103, v99);
          v296 = *(uint64_t (**)(unint64_t *, uint64_t))(v100 + 128);
          if (v118 >= v296(v85, v100))
          {
            unint64_t v128 = v298;
            (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v99 + 96))( v337,  v85,  v100,  v103,  v99);
            int64_t v116 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v99 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v94,  v128,  v103);
            (*(void (**)(char *, unint64_t *))(v335 + 8))(v128, v103);
            unint64_t v124 = v98;
          }

          else
          {
            char v119 = v298;
            (*(void (**)(char *, char *, unint64_t *))(v335 + 16))(v298, v94, v103);
            uint64_t v120 = v329;
            (*(void (**)(char *, unint64_t *, uint64_t, unint64_t *, uint64_t))(v100 + 96))( v119,  v103,  v99,  v85,  v100);
            unint64_t v121 = v337;
            int64_t v116 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v100 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v120,  v337,  v85);
            unint64_t v122 = *(void (**)(char *, unint64_t *))(v330 + 8);
            uint64_t v123 = v120;
            unint64_t v124 = v334;
            v122(v123, v85);
            v122(v121, v85);
          }
        }

        v140 = v336;
        unint64_t v74 = v344;
        if ((v116 & 1) != 0) {
          goto LABEL_29;
        }
        goto LABEL_45;
      }

      uint64_t v86 = v337;
      Swift::String v85 = (unint64_t *)v338;
      uint64_t v87 = v300;
      uint64_t v83 = v334;
    }

    else
    {
      uint64_t v81 = v301;
      uint64_t v82 = *(void (**)(void))(v301 + 16);
      uint64_t v83 = v334;
      Swift::Int v84 = v327;
      ((void (*)(void (*)(char *, uint64_t), uint64_t, uint64_t))v82)(v334, v327, v77);
      uint64_t v86 = v337;
      Swift::String v85 = (unint64_t *)v338;
      uint64_t v87 = v300;
    }

    int64_t v90 = (*((uint64_t (**)(uint64_t))v345 + 47))(v77);
    goto LABEL_9;
  }

  (*(void (**)(uint64_t, uint64_t))(v65 + 8))(a1, v72);
  uint64_t v73 = 1LL;
  unint64_t v74 = v344;
  char v75 = v341;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v342 + 56))(v75, v73, 1LL, v74);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
  }

  while (1)
  {
    unint64_t v24 = (unsigned int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5( v21,  v22);
    if (!v24) {
      goto LABEL_47;
    }
    uint64_t v26 = v25 - (void)v24 - 4;
    if (__OFSUB__(v25 - (void)v24, 4LL))
    {
      __break(1u);
LABEL_41:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
    }

    if ((v26 & 0x8000000000000000LL) != 0) {
      goto LABEL_39;
    }
    uint64_t v27 = (uint64_t)(v24 + 1);
    unint64_t v28 = *v24;
    int64_t v29 = HIBYTE(*v24) & 0x7F;
    if (v29 != 1)
    {
      if (v29 == 2)
      {
        if ((v28 & 0x400000) != 0) {
          int64_t v30 = 28LL;
        }
        else {
          int64_t v30 = 20LL;
        }
        if ((v28 & 0x80000) != 0)
        {
          unint64_t v31 = 6LL;
          if ((v28 & 0x400000) == 0) {
            unint64_t v31 = 4LL;
          }
          unint64_t v32 = (uint64_t)&v24[v31 + 2];
          if ((v32 & 7) != 0) {
            goto LABEL_41;
          }
          unint64_t v33 = *(void *)v32;
          uint64_t v14 = __OFADD__(v30 + 16, v33);
          v30 += 16 + v33;
          if (v14)
          {
            __break(1u);
LABEL_43:
            __break(1u);
            goto LABEL_44;
          }

          if ((v28 & 0x10) != 0)
          {
            uint64_t v14 = __OFADD__(v30, 8LL);
            v30 += 8LL;
            if (v14)
            {
              __break(1u);
LABEL_47:
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            }
          }

          if ((v30 & 0x8000000000000000LL) != 0) {
            goto LABEL_39;
          }
        }

        goto LABEL_29;
      }

      if (v29 != 3)
      {
        int64_t v30 = 0LL;
        uint64_t v34 = (uint64_t)(v24 + 1);
        goto LABEL_32;
      }
    }

    int64_t v30 = 4LL * ((~v28 & 0x7FFFFF) == 0);
LABEL_29:
    if (v26 < v30) {
      goto LABEL_39;
    }
    uint64_t v34 = v27 + v30;
LABEL_32:
    uint64_t v45 = v34;
    uint64_t v46 = v27 + v26;
    int64_t v35 = v8;
    if (v26 != v30)
    {
      unint64_t v36 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v45, 1LL);
      if (!v36) {
        goto LABEL_47;
      }
      int64_t v35 = *v36;
    }

    int64_t v37 = v26 == v30;
    outlined init with copy of Any((uint64_t)v47, (uint64_t)v43);
    int64_t v38 = v44;
    int64_t v39 = __swift_project_boxed_opaque_existential_0Tm(v43, v44);
    specialized project2 #1 <A, B><A1><A2>(_:) in project #1 <A, B><A1>(_:) in closure #2 in KeyPath._projectReadOnly(from:)( v28,  v27,  v34,  (uint64_t)v39,  v37,  (uint64_t)v47,  v8,  v38,  (uint64_t)v12,  v35);
    unint64_t v40 = *(void *)(v8 - 8);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, v9);
    __swift_destroy_boxed_opaque_existential_1Tm(v43);
    unint64_t v21 = v45;
    unint64_t v22 = v46;
  }

  (*(void (**)(uint64_t, char *, uint64_t))(v40 + 32))(v42, v12, v8);
  __swift_destroy_boxed_opaque_existential_1Tm(v43);
  return __swift_destroy_boxed_opaque_existential_1Tm(v47);
}

        uint64_t v17 = 0LL;
        unint64_t v21 = 0xE000000000000000LL;
        goto LABEL_46;
      }
    }

    else
    {
      uint64_t v7 = (int8x16_t *)_StringObject.sharedUTF8.getter(v0, v1);
      Swift::Int v8 = v1;
    }

    swift_bridgeObjectRetain(v4, v1, v2, v3);
    uint64_t v17 = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( v8,  (uint64_t)v7,  v8,  v5,  v4,  (uint64_t (*)(void))specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:));
    unint64_t v21 = v75;
    swift_bridgeObjectRelease(v4);
    goto LABEL_46;
  }

  uint64_t v12 = HIBYTE(v1) & 0xF;
  *(void *)&v80 = v0;
  *((void *)&v80 + 1) = v1 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v79 = (uint8x16_t)xmmword_1817FFDF0;
  if (!v12) {
    goto LABEL_45;
  }
  for (uint64_t i = 0LL; i != v12; ++i)
  if (v12 <= 8) {
    LOBYTE(v14) = 8;
  }
  else {
    uint64_t v14 = HIBYTE(v1) & 0xF;
  }
  uint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v14) & 0x38);
  if (v12 <= 8) {
    uint64_t v15 = 0LL;
  }
  uint64_t v16 = 8 - v12;
  if (v12 > 8) {
    uint64_t v16 = 0;
  }
  uint64_t v17 = v79.i64[0] & (0xFFFFFFFFFFFFFFFFLL >> (8 * (v16 & 7u)));
  BOOL v18 = v79.i64[1] & v15;
  uint64_t v19 = ((v79.i64[1] & v15 | v17) & 0x8080808080808080LL) == 0;
  uint64_t v20 = 0xA000000000000000LL;
  if (v19) {
    uint64_t v20 = 0xE000000000000000LL;
  }
  unint64_t v21 = v20 | (v12 << 56) | v18;
  if ((v21 & 0x4000000000000000LL) == 0)
  {
    v79.i64[0] = v17;
    v79.i64[1] = v18 & 0xFFFFFFFFFFFFFFLL;
    closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v79, HIBYTE(v21) & 0xF, v78);
    uint64_t v17 = v78[0];
    unint64_t v21 = v78[1];
  }

        uint64_t v17 = 0LL;
        unint64_t v21 = 0xE000000000000000LL;
        goto LABEL_46;
      }
    }

    else
    {
      uint64_t v7 = (int8x16_t *)_StringObject.sharedUTF8.getter(v0, v1);
      Swift::Int v8 = v1;
    }

    swift_bridgeObjectRetain(v4, v1, v2, v3);
    uint64_t v17 = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)( v8,  (uint64_t)v7,  v8,  v5,  v4,  (uint64_t (*)(void))specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:));
    unint64_t v21 = v75;
    swift_bridgeObjectRelease(v4);
    goto LABEL_46;
  }

  uint64_t v12 = HIBYTE(v1) & 0xF;
  *(void *)&v80 = v0;
  *((void *)&v80 + 1) = v1 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v79 = (uint8x16_t)xmmword_1817FFDF0;
  if (!v12) {
    goto LABEL_45;
  }
  for (uint64_t i = 0LL; i != v12; ++i)
    v79.i8[i] = *((_BYTE *)&v80 + i)
              - 32 * ((0x1FFF000000000000uLL >> ((*((unsigned __int8 *)&v80 + i) - 1) >> 1)) & 1);
  if (v12 <= 8) {
    LOBYTE(v14) = 8;
  }
  else {
    uint64_t v14 = HIBYTE(v1) & 0xF;
  }
  uint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v14) & 0x38);
  if (v12 <= 8) {
    uint64_t v15 = 0LL;
  }
  uint64_t v16 = 8 - v12;
  if (v12 > 8) {
    uint64_t v16 = 0;
  }
  uint64_t v17 = v79.i64[0] & (0xFFFFFFFFFFFFFFFFLL >> (8 * (v16 & 7u)));
  BOOL v18 = v79.i64[1] & v15;
  uint64_t v19 = ((v79.i64[1] & v15 | v17) & 0x8080808080808080LL) == 0;
  uint64_t v20 = 0xA000000000000000LL;
  if (v19) {
    uint64_t v20 = 0xE000000000000000LL;
  }
  unint64_t v21 = v20 | (v12 << 56) | v18;
  if ((v21 & 0x4000000000000000LL) == 0)
  {
    v79.i64[0] = v17;
    v79.i64[1] = v18 & 0xFFFFFFFFFFFFFFLL;
    closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v79, HIBYTE(v21) & 0xF, v78);
    uint64_t v17 = v78[0];
    unint64_t v21 = v78[1];
  }

        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }
    }

    __s2 = v4;
    uint64_t v26 = v3 & 0xFFFFFFFFFFFFFFLL;
    if (v11 >= v15)
    {
      p_s2 = &__s2;
      goto LABEL_40;
    }

    goto LABEL_45;
  }

  __s2 = a1._countAndFlagsBits;
  uint64_t v26 = object & 0xFFFFFFFFFFFFFFLL;
  if ((v2 & 0x2000000000000000LL) != 0)
  {
    __s1[0] = v1;
    __s1[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    BOOL v18 = __s1;
  }

  else
  {
    if ((v1 & 0x1000000000000000LL) != 0)
    {
      BOOL v18 = (void *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (v12 < v8) {
        goto LABEL_45;
      }
    }

    else
    {
      BOOL v18 = _StringObject.sharedUTF8.getter(v1, v2);
      if (v22 < v8) {
        goto LABEL_45;
      }
    }

    if (v8 && !v18) {
LABEL_32:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
  }

  int64_t v9 = v8;
  if (_swift_stdlib_memcmp(v18, &__s2, v8)) {
    return 0;
  }
  return _StringGuts.isOnGraphemeClusterBoundary(_:)((Swift::String::Index)(v9 << 16));
}

    if ((v27 & ~v25 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v25 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v44 = _StringGuts.nativeUnusedCapacity.getter(v27, v25);
      if ((v45 & 1) != 0)
      {
LABEL_216:
        v196 = 258LL;
        goto LABEL_217;
      }

      if (v42 >= 16 || (v25 & 0x2000000000000000LL) == 0 && v44 >= (uint64_t)v7._rawBits)
      {
LABEL_51:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v42, v7._rawBits);
        swift_bridgeObjectRelease(v9);
        if ((v9 & 0x1000000000000000LL) != 0)
        {
          _StringGuts._foreignAppendInPlace(_:)(v11, v9, v197, v12);
        }

        else
        {
          if ((v9 & 0x2000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease(v9);
            char v75 = HIBYTE(v9) & 0xF;
            v215 = v11;
            v216 = v9 & 0xFFFFFFFFFFFFFFLL;
            if (v75 < v12) {
              goto LABEL_181;
            }
            Swift::String v76 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v197, v12, (uint64_t)&v215, v75);
            _StringGuts.appendInPlace(_:isASCII:)(v76, v77, (v9 & 0x4000000000000000LL) != 0);
LABEL_68:
            uint64_t v78 = startingAt;
            uint64_t v79 = v221 & 0xFFFFFFFFFFFFLL;
            if ((v222 & 0x2000000000000000LL) != 0) {
              uint64_t v79 = HIBYTE(v222) & 0xF;
            }
            v197 = v79;
            specialized String.append<A>(contentsOf:)(v204, v208, v200, v201);
            uint64_t v12 = v221;
            v7._Swift::UInt64 rawBits = v222;
            uint64_t v82 = HIBYTE(v222) & 0xF;
            if ((v222 & 0x2000000000000000LL) == 0) {
              uint64_t v82 = v221 & 0xFFFFFFFFFFFFLL;
            }
            startingAt = v82;
            swift_bridgeObjectRetain_n(v222, 3LL, v80, v81);
            v83._Swift::UInt64 rawBits = v203._rawBits;
            int64_t v9 = specialized Collection.subscript.getter(v83, v213, v78);
            unint64_t v25 = v84;
            v213 = v40;
            Swift::Int v8 = v41;
            int64_t v42 = v84 >> 16;
            v208 = v9 >> 16;
            if ((v41 & 0x1000000000000000LL) == 0)
            {
              uint64_t v13 = v42 - (v9 >> 16);
              swift_bridgeObjectRetain_n(v41, 2LL, v40, (char *)v41);
              Swift::String v85 = v7._rawBits;
              goto LABEL_74;
            }

            goto LABEL_138;
          }

          if ((v11 & 0x1000000000000000LL) != 0)
          {
            uint64_t v46 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
            int64_t v47 = v11 & 0xFFFFFFFFFFFFLL;
          }

          else
          {
            uint64_t v46 = _StringObject.sharedUTF8.getter(v11, v9);
            int64_t v47 = v181;
          }

          unint64_t v48 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v197, v12, (uint64_t)v46, v47);
          _StringGuts.appendInPlace(_:isASCII:)(v48, v49, (v11 & 0x8000000000000000LL) != 0LL);
        }

        swift_bridgeObjectRelease(v9);
        goto LABEL_68;
      }
    }

    else if (v42 > 15)
    {
      goto LABEL_51;
    }

    swift_bridgeObjectRelease(v9);
    uint64_t v50 = v221;
    swift_bridgeObjectRetain(v25, v51, v52, v53);
    uint64_t v54 = _StringGuts._convertedToSmall()(v50, v25);
    int64_t v56 = v55;
    swift_bridgeObjectRelease(v25);
    v57._Swift::UInt64 rawBits = v8 & 0xFFFFFFFFFFFF0000LL | 1;
    v58._Swift::UInt64 rawBits = v39 & 0xFFFFFFFFFFFF0000LL | 1;
    v59._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v57, v58, v11, v9);
    if (v59._rawBits < 0x10000) {
      v59._rawBits |= 3;
    }
    uint64_t v61 = specialized String.init(_:)(v59, v60, v11, v9);
    int64_t v63 = v62;
    swift_bridgeObjectRelease(v9);
    uint64_t v64 = _StringGuts._convertedToSmall()(v61, v63);
    unint64_t v66 = v65;
    swift_bridgeObjectRelease(v63);
    id v67 = specialized _SmallString.init(_:appending:)(v54, v56, v64, v66);
    if ((v69 & 1) == 0)
    {
      unint64_t v70 = v67;
      uint64_t v71 = v68;
      swift_bridgeObjectRelease(v25);
      v221 = v70;
      v222 = v71;
      goto LABEL_68;
    }

  unint64_t v21 = v28;
  if (v28 == &v25)
  {
    unint64_t v22 = 4LL;
    unint64_t v21 = &v25;
  }

  else
  {
    if (!v28) {
      goto LABEL_50;
    }
    unint64_t v22 = 5LL;
  }

  ((void (*)(uint64_t (***)()))(*v21)[v22])(v21);
LABEL_50:
  int64_t result = v30;
  if (v30 == v29)
  {
    unint64_t v24 = 4LL;
    int64_t result = v29;
  }

  else
  {
    if (!v30) {
      return result;
    }
    unint64_t v24 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void *))(*result + 8 * v24))(result);
}

  __swift::__runtime::llvm::hashing::detail::hash_state::mix((unint64_t *)this + 8, (const char *)this);
  int64_t v47 = 0x9DDFEA08EB382D69LL
      * (*((void *)this + 13) ^ ((0x9DDFEA08EB382D69LL * (*((void *)this + 13) ^ *((void *)this + 11))) >> 47) ^ (0x9DDFEA08EB382D69LL * (*((void *)this + 13) ^ *((void *)this + 11))));
  unint64_t v48 = *((void *)this + 14);
  uint64_t v49 = *((void *)this + 8)
      - 0x4B6D499041670D8DLL * ((__src - (char *)this + a2) ^ ((unint64_t)(__src - (char *)this + a2) >> 47))
      - 0x622015F714C7D297LL
      * ((0x9DDFEA08EB382D69LL
        * (v48 ^ ((0x9DDFEA08EB382D69LL * (v48 ^ *((void *)this + 12))) >> 47) ^ (0x9DDFEA08EB382D69LL
                                                                                  * (v48 ^ *((void *)this + 12))))) ^ ((0x9DDFEA08EB382D69LL * (v48 ^ ((0x9DDFEA08EB382D69LL * (v48 ^ *((void *)this + 12))) >> 47) ^ (0x9DDFEA08EB382D69LL * (v48 ^ *((void *)this + 12))))) >> 47));
  uint64_t v50 = 0x9DDFEA08EB382D69LL
      * (v49 ^ (*((void *)this + 10)
              - 0x4B6D499041670D8DLL * (*((void *)this + 9) ^ (*((void *)this + 9) >> 47))
              - 0x622015F714C7D297LL * (v47 ^ (v47 >> 47))));
  return 0x9DDFEA08EB382D69LL
       * ((0x9DDFEA08EB382D69LL * (v49 ^ (v50 >> 47) ^ v50)) ^ ((0x9DDFEA08EB382D69LL * (v49 ^ (v50 >> 47) ^ v50)) >> 47));
}

        unint64_t v23 = 0LL;
LABEL_46:
        if (*(_DWORD *)a4) {
          return this;
        }
        if (v17 == ++v18) {
          goto LABEL_48;
        }
      }
    }
  }

  return this;
}

  *(_DWORD *)(v4 + 12736) = v23 + 1;
  v25[v23] = 120;
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  return this;
}

LABEL_42:
    unint64_t v21 = (v36 - 1) & v36;
    unint64_t v32 = __clz(__rbit64(v36)) + (v37 << 6);
    int64_t v6 = v37;
LABEL_27:
    unint64_t v33 = (__objc2_class **)(*(void *)(v3 + 48) + 16 * v32);
    unint64_t v25 = *v33;
    unint64_t v24 = (unint64_t)v33[1];
    int64_t result = swift_bridgeObjectRetain(v24, v30, v26, v27);
    if (v2 >= v29) {
      goto LABEL_22;
    }
  }

  __break(1u);
LABEL_65:
  __break(1u);
  return result;
}

  uint64_t v78 = *v8;
  uint64_t v102 = *v8;
  *Swift::Int v8 = 0x8000000000000000LL;
  uint64_t v79 = v96;
  if (!v50)
  {
    type metadata accessor for _NativeDictionary(0LL, (uint64_t)v99, (uint64_t)v96, *(void *)(v100 + 32));
    _NativeDictionary.copy()();
    uint64_t v78 = v102;
  }

  v80 = *(void *)(v97 + 72);
  uint64_t v81 = v80 * v13;
  uint64_t v82 = *(void *)(v78 + 56) + v80 * v13;
  uint64_t v83 = *(void (**)(_BYTE *, uint64_t, uint64_t *))(v97 + 32);
  Swift::Int v84 = v94;
  v83(v94, v82, v79);
  Swift::String v85 = v80 * a4;
  UnsafeMutablePointer.moveInitialize(from:count:)( (char *)(*(void *)(v78 + 56) + v85),  1LL,  (char *)(*(void *)(v78 + 56) + v81),  (uint64_t)v79);
  v83((_BYTE *)(*(void *)(v78 + 56) + v85), (uint64_t)v84, v79);
  uint64_t v86 = *v8;
  *Swift::Int v8 = v78;
  swift_bridgeObjectRelease(v86);
}

                int64_t v41 = _StringGuts.nativeCapacity.getter(v10, object);
                if ((v42 & 1) != 0) {
                  int64_t v43 = 0LL;
                }
                else {
                  int64_t v43 = v41;
                }
                if (v43 + 0x4000000000000000LL < 0)
                {
                  __break(1u);
                  goto LABEL_318;
                }

                uint64_t v44 = 2 * v43;
                if (v44 > v20) {
                  uint64_t v20 = v44;
                }
              }

              else if (!v27)
              {
                goto LABEL_42;
              }

              _StringGuts.grow(_:)(v20);
              goto LABEL_49;
            }

      if ((a4 & 0x1000000000000000LL) != 0)
      {
        uint64_t v44 = v16;
        uint64_t v45 = v14;
        uint64_t v46 = v12;
        v17._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v17)._rawBits;
      }

      else
      {
        int64_t v41 = v17._rawBits >> 16;
        if ((a4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v100 = a3;
          char v101 = a4 & 0xFFFFFFFFFFFFFFLL;
          int64_t v43 = *((unsigned __int8 *)&v100 + v41);
        }

        else
        {
          int64_t v42 = (unsigned __int8 *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a3 & 0x1000000000000000LL) == 0)
          {
            char v58 = v12;
            uint64_t v59 = v14;
            unint64_t v60 = v16;
            int64_t v42 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a3, a4);
            uint64_t v16 = v60;
            uint64_t v14 = v59;
            uint64_t v12 = v58;
          }

          int64_t v43 = v42[v41];
        }

        uint64_t v44 = v16;
        uint64_t v45 = v14;
        uint64_t v46 = v12;
        int64_t v47 = (char)v43;
        unint64_t v48 = __clz(v43 ^ 0xFF) - 24;
        if (v47 >= 0) {
          LOBYTE(v48) = 1;
        }
        v17._Swift::UInt64 rawBits = ((v41 + v48) << 16) | 5;
      }

      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v11))
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v11[2]->isa + 1,  1);
        uint64_t v11 = v102;
      }

      uint64_t v12 = v46;
      uint64_t v14 = v45;
      uint64_t v16 = v44;
      uint64_t v50 = v11[2];
      uint64_t v49 = (unint64_t)v11[3];
      if ((unint64_t)v50 >= v49 >> 1)
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v49 > 1,  (int64_t)&v50->isa + 1,  1);
        uint64_t v16 = v44;
        uint64_t v14 = v45;
        uint64_t v12 = v46;
        uint64_t v11 = v102;
      }

      v11[2] = (__objc2_class *)((char *)&v50->isa + 1);
      *((_DWORD *)v11 + (void)v50 + 8) = v29;
      --v7._rawBits;
      Swift::UInt64 rawBits = v97;
      uint64_t v15 = v98;
      if (!v7._rawBits) {
        goto LABEL_61;
      }
    }
  }

  v17._Swift::UInt64 rawBits = rawBits;
LABEL_61:
  uint64_t v61 = v17._rawBits >> 14;
  if (v17._rawBits >> 14 != v12)
  {
    int64_t v63 = (a3 >> 59) & 1;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v63) = 1;
    }
    uint64_t v64 = 4LL << v63;
    char v65 = rawBits >> 14;
    if ((a4 & 0x2000000000000000LL) != 0) {
      unint64_t v66 = HIBYTE(a4) & 0xF;
    }
    else {
      unint64_t v66 = a3 & 0xFFFFFFFFFFFFLL;
    }
    do
    {
      id v67 = v17._rawBits & 0xC;
      unint64_t v68 = (v17._rawBits & 1) == 0 || v67 == v64;
      uint64_t v69 = v68;
      if (v68)
      {
        unint64_t v70 = v17._rawBits;
        if (v67 == v64)
        {
          uint64_t v78 = v12;
          unint64_t v70 = _StringGuts._slowEnsureMatchingEncoding(_:)(v17)._rawBits;
          uint64_t v12 = v78;
        }

        if (v70 >> 14 < v65 || v70 >> 14 >= v12) {
          goto LABEL_117;
        }
        if ((v70 & 1) == 0)
        {
          uint64_t v71 = v12;
          v72._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v70)._rawBits;
          uint64_t v12 = v71;
          unint64_t v70 = v72._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
        }
      }

      else
      {
        if (v61 < v65) {
          goto LABEL_118;
        }
        unint64_t v70 = v17._rawBits;
        if (v61 >= v12) {
          goto LABEL_118;
        }
      }

      if ((a4 & 0x1000000000000000LL) != 0)
      {
        uint64_t v79 = v12;
        v80 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v70 & 0xFFFFFFFFFFFF0000LL))._0._value;
        uint64_t v12 = v79;
        char v75 = v80;
        if (v69) {
          goto LABEL_93;
        }
      }

      else
      {
        uint64_t v73 = v70 >> 16;
        if ((a4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v100 = a3;
          char v101 = a4 & 0xFFFFFFFFFFFFFFLL;
          char v75 = *((unsigned __int8 *)&v100 + v73);
          if (*((char *)&v100 + v73) < 0) {
            __asm { BR              X9 }
          }
        }

        else
        {
          unint64_t v74 = (unsigned __int8 *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a3 & 0x1000000000000000LL) == 0)
          {
            char v91 = v12;
            unint64_t v74 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a3, a4);
            uint64_t v12 = v91;
          }

          char v75 = v74[v73];
          if ((char)v74[v73] < 0) {
            __asm { BR              X9 }
          }
        }

        if (v69)
        {
LABEL_93:
          if (v67 == v64)
          {
            int64_t v89 = v12;
            v90._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v17)._rawBits;
            uint64_t v12 = v89;
            v17._Swift::UInt64 rawBits = v90._rawBits;
            if (v66 <= v90._rawBits >> 16) {
              goto LABEL_122;
            }
          }

          else if (v66 <= v17._rawBits >> 16)
          {
            goto LABEL_122;
          }

          if ((v17._rawBits & 1) == 0)
          {
            Swift::String v76 = v12;
            v77._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)(v17)._rawBits;
            uint64_t v12 = v76;
            v17._Swift::UInt64 rawBits = v17._rawBits & 0xC | v77._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
          }

          goto LABEL_99;
        }
      }

      if (v66 <= v17._rawBits >> 16) {
        goto LABEL_121;
      }
LABEL_99:
      if ((a4 & 0x1000000000000000LL) != 0)
      {
        Swift::Int v84 = v12;
        v17._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v17)._rawBits;
      }

      else
      {
        uint64_t v81 = v17._rawBits >> 16;
        if ((a4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v100 = a3;
          char v101 = a4 & 0xFFFFFFFFFFFFFFLL;
          uint64_t v83 = *((unsigned __int8 *)&v100 + v81);
        }

        else
        {
          uint64_t v82 = (unsigned __int8 *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a3 & 0x1000000000000000LL) == 0)
          {
            uint64_t v92 = v12;
            uint64_t v82 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a3, a4);
            uint64_t v12 = v92;
          }

          uint64_t v83 = v82[v81];
        }

        Swift::Int v84 = v12;
        Swift::String v85 = (char)v83;
        uint64_t v86 = __clz(v83 ^ 0xFF) - 24;
        if (v85 >= 0) {
          LOBYTE(v86) = 1;
        }
        v17._Swift::UInt64 rawBits = ((v81 + v86) << 16) | 5;
      }

      uint64_t v11 = v102;
      if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v102))
      {
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v11[2]->isa + 1,  1);
        uint64_t v11 = v102;
      }

      uint64_t v12 = v84;
      int64_t v88 = v11[2];
      uint64_t v87 = (unint64_t)v11[3];
      if ((unint64_t)v88 >= v87 >> 1)
      {
        unint64_t v96 = v12;
        specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( v87 > 1,  (int64_t)&v88->isa + 1,  1);
        uint64_t v12 = v96;
        uint64_t v11 = v102;
      }

      v11[2] = (__objc2_class *)((char *)&v88->isa + 1);
      *((_DWORD *)v11 + (void)v88 + 8) = v75;
      uint64_t v61 = v17._rawBits >> 14;
    }

    while (v17._rawBits >> 14 != v12);
  }

  swift_bridgeObjectRelease(a4);
  return v11;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Range.swift",  17LL,  2,  0x131uLL,  0);
  }

  return result;
}

  (*(void (**)(char *, unint64_t))(v41 + 8))(v15, AssociatedTypeWitness);
  if (v18 < 0x4000) {
    return 1LL;
  }
  v38._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)v18)._rawBits;
  String.subscript.getter(v38, a1, a2);
  swift_bridgeObjectRelease(v39);
  return 0LL;
}

    char v65 = v62;
    goto LABEL_43;
  }

  char v65 = v60;
LABEL_43:
  v56(v65, a3);
LABEL_44:
  uint64_t v77 = v101;
  uint64_t v78 = v101(a3, a4);
  uint64_t v79 = v95;
  ((void (*)(char *, char *, uint64_t))v57)(v95, v58, a3);
  if (v78 < 65)
  {
    uint64_t v83 = v77(a3, a4);
    v56(v79, a3);
    if (v83 != 64 || (v98(a3, a4) & 1) != 0) {
      goto LABEL_57;
    }
  }

  else
  {
    v56(v79, a3);
  }

  v80 = v94;
  ((void (*)(char *, char *, uint64_t))v57)(v94, v58, a3);
  int64_t v103 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v81 = v98(a3, a4);
  uint64_t v82 = v101(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
      goto LABEL_55;
    }
  }

  else if (v82 > 63)
  {
    uint64_t v102 = 0x7FFFFFFFFFFFFFFFLL;
    (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, a5, v87, a3, a4);
LABEL_55:
    Swift::Int v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v32,  v80,  a3);
    v56(v32, a3);
    if ((v84 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_56;
  }

  ((void (*)(char *, char *, uint64_t))v57)(v32, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v56(v32, a3);
LABEL_56:
  v56(v80, a3);
LABEL_57:
  Swift::String v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int64_t result = v56(v58, a3);
  if ((v85 & 0x8000000000000000LL) != 0)
  {
    uint64_t v52 = v100;
    if (v85 <= 0xFFFFFFFFFFFFFFC0LL) {
      uint64_t v51 = 0LL;
    }
    else {
      uint64_t v51 = v99 << -(char)v85;
    }
  }

  else
  {
    uint64_t v52 = v100;
    if (v85 >= 0x40) {
      uint64_t v51 = v99 >> 63;
    }
    else {
      uint64_t v51 = v99 >> v85;
    }
  }

    char v65 = v62;
    goto LABEL_43;
  }

  char v65 = v60;
LABEL_43:
  v56(v65, a3);
LABEL_44:
  uint64_t v77 = v101;
  uint64_t v78 = v101(a3, a4);
  uint64_t v79 = v95;
  ((void (*)(char *, char *, uint64_t))v57)(v95, v58, a3);
  if (v78 >= 65)
  {
    v56(v79, a3);
    goto LABEL_46;
  }

  uint64_t v83 = v77(a3, a4);
  v56(v79, a3);
  if (v83 == 64 && (v98(a3, a4) & 1) == 0)
  {
LABEL_46:
    v80 = v94;
    ((void (*)(char *, char *, uint64_t))v57)(v94, v58, a3);
    int64_t v103 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v81 = v98(a3, a4);
    uint64_t v82 = v101(a3, a4);
    if ((v81 & 1) != 0)
    {
      if (v82 > 64)
      {
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
        goto LABEL_55;
      }
    }

    else if (v82 >= 64)
    {
      uint64_t v102 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, a5, v87, a3, a4);
LABEL_55:
      Swift::Int v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v32,  v80,  a3);
      v56(v32, a3);
      if ((v84 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_56;
    }

    ((void (*)(char *, char *, uint64_t))v57)(v32, v80, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v56(v32, a3);
LABEL_56:
    v56(v80, a3);
  }

  Swift::String v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int64_t result = v56(v58, a3);
  if ((v85 & 0x8000000000000000LL) != 0)
  {
    uint64_t v51 = v100;
    if (v85 <= 0xFFFFFFFFFFFFFFC0LL) {
      uint64_t v52 = v99 >> 63;
    }
    else {
      uint64_t v52 = v99 >> -(char)v85;
    }
  }

  else
  {
    uint64_t v51 = v100;
    uint64_t v52 = v99 << v85;
    if (v85 >= 0x40) {
      uint64_t v52 = 0LL;
    }
  }

          __break(1u);
          goto LABEL_43;
        }

        swift::swift_dynamicCastFailure((swift *)v5, (const char *)v6, 0LL, a4);
      }

      if ((_DWORD)v7 != 773) {
        goto LABEL_42;
      }
      int64_t v6 = *(void *)(a2 + 8);
    }

    int64_t v9 = *a1;
    if (!(_DWORD)v9) {
      goto LABEL_22;
    }
    if ((_DWORD)v9 != 515)
    {
      if ((_DWORD)v9 == 773)
      {
        a1 = (uint64_t *)a1[1];
LABEL_22:
        swift_dynamicCastObjCClassMetatypeUnconditional((swift *)a1, (const char *)v6, a3, (uint64_t)a4, a5);
        return v5;
      }

      goto LABEL_42;
    }

      if (!strcmp(v16, v15))
      {
LABEL_53:
        if (prespecializedLoggingEnabled) {
          fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Prespecializations library: Found %s in SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES, disabling\n",  v16);
        }
        return 0LL;
      }
    }

    if (swift_prespecialized_data[1] >= 2u)
    {
      uint64_t v20 = (const char **)*((void *)swift_prespecialized_data + 2);
      if (v20)
      {
        unint64_t v21 = *v20;
        if (*v20)
        {
          unint64_t v22 = *v5;
          unint64_t v23 = v20 + 1;
          while (strcmp(v21, v22))
          {
            unint64_t v24 = *v23++;
            unint64_t v21 = v24;
            if (!v24) {
              goto LABEL_49;
            }
          }

          if (prespecializedLoggingEnabled) {
            fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Prespecializations library: Found %s in disabled processes list, disabling\n",  v21);
          }
          return 0LL;
        }
      }
    }
  }

  operator delete(v63.__r_.__value_.__l.__data_);
LABEL_28:
LABEL_44:
  operator delete(v64.__r_.__value_.__l.__data_);
LABEL_29:
  uint64_t v55 = (char)v60.__r_.__value_.__s.__size_;
  int64_t v56 = (void *)v60.__r_.__value_.__r.__words[0];
  if ((v60.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int64_t v57 = &v60;
  }
  else {
    int64_t v57 = (std::string *)v60.__r_.__value_.__r.__words[0];
  }
  char v58 = strdup((const char *)v57);
  if (v55 < 0) {
    operator delete(v56);
  }
  return v58;
}

    if (!j)
    {
      for (j = swift::_swift_getClass((unint64_t)*a1, a2); ((uint64_t)j[4].isa & 2) != 0; j = j[1].isa)
      {
        if (j[8].isa) {
          break;
        }
      }
    }

    uint64_t v15 = j->isa;
    if (j->isa > (Class)0x7FF) {
      LODWORD(v15) = 0;
    }
    if ((!(_DWORD)v15 || (_DWORD)v15 == 773 && (j = j[1].isa) != 0LL) && ((uint64_t)j[4].isa & 2) != 0)
    {
      uint64_t v16 = (uint64_t (**)())DynamicType[8];
      goto LABEL_53;
    }

    return 0LL;
  }

  if ((int)i > 772)
  {
    if ((_DWORD)i != 773)
    {
      return result;
    }

    goto LABEL_42;
  }

  if ((_DWORD)i == 769) {
    return DynamicType[1];
  }
  return result;
}

void specialized Array.append<A>(contentsOf:)(unint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16);
  int64_t v3 = (__objc2_class **)*v1;
  int64_t v4 = *(void *)(*v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
    goto LABEL_17;
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = (uint64_t)v3;
  if (!isUniquelyReferenced_nonNull_native || (int64_t v11 = (unint64_t)v3[3] >> 1, v11 < v5))
  {
    if (v4 <= v5) {
      int64_t v12 = v4 + v2;
    }
    else {
      int64_t v12 = v4;
    }
    int64_t v3 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)isUniquelyReferenced_nonNull_native,  v12,  1,  (uint64_t)v3);
    *uint64_t v1 = (uint64_t)v3;
    int64_t v11 = (unint64_t)v3[3] >> 1;
  }

  uint64_t v13 = v3[2];
  uint64_t v14 = v11 - (void)v13;
  if (v14 < 0) {
LABEL_17:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  unint64_t v15 = *(void *)(a1 + 16);
  if (!v15)
  {
    swift_bridgeObjectRelease(a1);
    if (!v2) {
      goto LABEL_15;
    }
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x4DEuLL,  0);
  }

  if (v14 < v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x694uLL,  0);
  }
  uint64_t v16 = (char *)&v3[4 * (void)v13 + 4];
  swift_bridgeObjectRetain(a1, v8, v9, v10);
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(a1 + 32), v15, v16);
  swift_bridgeObjectRelease_n(a1, 2LL);
  if (v15 < v2) {
    goto LABEL_18;
  }
  uint64_t v17 = v3[2];
  BOOL v18 = __OFADD__(v17, v15);
  uint64_t v19 = (__objc2_class *)((char *)v17 + v15);
  if (!v18)
  {
    v3[2] = v19;
LABEL_15:
    *uint64_t v1 = (uint64_t)v3;
    return;
  }

  __break(1u);
}

{
  uint64_t *v1;
  unint64_t v2;
  __objc2_class **v3;
  int64_t v4;
  int64_t v5;
  BOOL isUniquelyReferenced_nonNull_native;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  int64_t v12;
  __objc2_class *v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  __objc2_class *v17;
  BOOL v18;
  __objc2_class *v19;
  unint64_t v2 = *(void *)(a1 + 16);
  int64_t v3 = (__objc2_class **)*v1;
  int64_t v4 = *(void *)(*v1 + 16);
  int64_t v5 = v4 + v2;
  if (__OFADD__(v4, v2))
  {
    __break(1u);
    goto LABEL_17;
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = (uint64_t)v3;
  if (!isUniquelyReferenced_nonNull_native || (int64_t v11 = (unint64_t)v3[3] >> 1, v11 < v5))
  {
    if (v4 <= v5) {
      int64_t v12 = v4 + v2;
    }
    else {
      int64_t v12 = v4;
    }
    int64_t v3 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)isUniquelyReferenced_nonNull_native,  v12,  1,  (uint64_t)v3);
    *uint64_t v1 = (uint64_t)v3;
    int64_t v11 = (unint64_t)v3[3] >> 1;
  }

  uint64_t v13 = v3[2];
  uint64_t v14 = v11 - (void)v13;
  if (v14 < 0) {
LABEL_17:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  unint64_t v15 = *(void *)(a1 + 16);
  if (!v15)
  {
    swift_bridgeObjectRelease(a1);
    if (!v2) {
      goto LABEL_15;
    }
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x4DEuLL,  0);
  }

  if (v14 < v15) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x694uLL,  0);
  }
  uint64_t v16 = (char *)&v3[2 * (void)v13 + 4];
  swift_bridgeObjectRetain(a1, v8, v9, v10);
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(a1 + 32), v15, v16);
  swift_bridgeObjectRelease_n(a1, 2LL);
  if (v15 < v2) {
    goto LABEL_18;
  }
  uint64_t v17 = v3[2];
  BOOL v18 = __OFADD__(v17, v15);
  uint64_t v19 = (__objc2_class *)((char *)v17 + v15);
  if (!v18)
  {
    v3[2] = v19;
LABEL_15:
    *uint64_t v1 = (uint64_t)v3;
    return;
  }

  __break(1u);
}

void specialized Array.append<A>(contentsOf:)(unint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = *(void *)(a1 + 16);
  int64_t v5 = (__objc2_class **)*v3;
  int64_t v6 = *(void *)(*v3 + 16);
  int64_t v7 = v6 + v4;
  if (__OFADD__(v6, v4))
  {
    __break(1u);
    goto LABEL_17;
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
  *int64_t v3 = (uint64_t)v5;
  if (!isUniquelyReferenced_nonNull_native || (int64_t v15 = (unint64_t)v5[3] >> 1, v15 < v7))
  {
    if (v6 <= v7) {
      int64_t v16 = v6 + v4;
    }
    else {
      int64_t v16 = v6;
    }
    int64_t v5 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)isUniquelyReferenced_nonNull_native,  v16,  1,  (uint64_t)v5,  a2,  a3);
    *int64_t v3 = (uint64_t)v5;
    int64_t v15 = (unint64_t)v5[3] >> 1;
  }

  uint64_t v17 = v5[2];
  uint64_t v18 = v15 - (void)v17;
  if (v18 < 0) {
LABEL_17:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  unint64_t v19 = *(void *)(a1 + 16);
  if (!v19)
  {
    swift_bridgeObjectRelease(a1);
    if (!v4) {
      goto LABEL_15;
    }
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x4DEuLL,  0);
  }

  if (v18 < v19) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x694uLL,  0);
  }
  uint64_t v20 = (char *)&v5[5 * (void)v17 + 4];
  swift_bridgeObjectRetain(a1, v12, v13, v14);
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(a1 + 32), v19, v20, a3);
  swift_bridgeObjectRelease_n(a1, 2LL);
  if (v19 < v4) {
    goto LABEL_18;
  }
  unint64_t v21 = v5[2];
  BOOL v22 = __OFADD__(v21, v19);
  unint64_t v23 = (__objc2_class *)((char *)v21 + v19);
  if (!v22)
  {
    v5[2] = v23;
LABEL_15:
    *int64_t v3 = (uint64_t)v5;
    return;
  }

  __break(1u);
}

uint64_t Array.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int64_t v5 = v4;
  uint64_t v98 = a2;
  uint64_t v9 = *(uint64_t **)(a2 + 16);
  uint64_t v109 = *(v9 - 1);
  uint64_t v10 = MEMORY[0x1895F8858](a1);
  unint64_t v99 = (char *)&v93 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v10);
  unint64_t v96 = (char *)&v93 - v12;
  uint64_t v15 = type metadata accessor for Optional(0LL, (uint64_t)v9, v13, v14);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v102 = (char *)&v93 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = MEMORY[0x1895F8858](v17);
  unint64_t v97 = (char *)&v93 - v20;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  char v101 = (char *)&v93 - v22;
  uint64_t v106 = *(void (***)(void, uint64_t))(a3 - 8);
  MEMORY[0x1895F8858](v21);
  unint64_t v24 = (char *)&v93 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v25 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v111 = (char *)&v93 - v26;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 40);
  uint64_t v107 = a4;
  uint64_t v28 = v27(a3, a4);
  Swift::Int v29 = Array._getCount()();
  uint64_t v32 = v29 + v28;
  if (__OFADD__(v29, v28))
  {
    __break(1u);
    goto LABEL_41;
  }

  uint64_t v103 = v25;
  uint64_t v104 = v28;
  uint64_t v94 = v16;
  uint64_t v100 = v15;
  type metadata accessor for _ArrayBuffer(0LL, (uint64_t)v9, v30, v31);
  Swift::Bool v33 = _ArrayBuffer.beginCOWMutation()();
  uint64_t v108 = v5;
  uint64_t v105 = (uint64_t *)a3;
  if (v33
    && ((uint64_t v34 = *v5, v35 = *v5 & 0xFFFFFFFFFFFFFF8LL, !_swift_isClassOrObjCExistentialType((uint64_t)v9, v9))
      ? (uint64_t v36 = v34)
      : (uint64_t v36 = v34 & 0xFFFFFFFFFFFFFF8LL),
        v32 <= *(void *)(v36 + 24) >> 1))
  {
    int64_t v37 = (void (**)(void, uint64_t))v24;
    uint64_t v38 = a1;
  }

  else
  {
    uint64_t v39 = *v5;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v9, v9) && (v39 < 0 || (v39 & 0x4000000000000000LL) != 0))
    {
      if (v39 < 0) {
        uint64_t v92 = (void *)v39;
      }
      else {
        uint64_t v92 = (void *)(v39 & 0xFFFFFFFFFFFFFF8LL);
      }
      id v42 = objc_msgSend(v92, sel_count);
    }

    else
    {
      BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
      uint64_t v41 = v39 & 0xFFFFFFFFFFFFF8LL;
      if (!isClassOrObjCExistentialType) {
        uint64_t v41 = v39;
      }
      id v42 = *(id *)(v41 + 16);
    }

    int64_t v37 = (void (**)(void, uint64_t))v24;
    uint64_t v38 = a1;
    else {
      uint64_t v43 = (uint64_t)v42;
    }
    uint64_t v34 = _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(v33, v43, 1, v39, v9);
    *int64_t v5 = v34;
    uint64_t v35 = v34 & 0xFFFFFFFFFFFFFF8LL;
  }

  else {
    uint64_t v44 = v34;
  }
  uint64_t v45 = *(void *)(v44 + 16);
  BOOL v46 = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
  uint64_t v47 = *(unsigned __int8 *)(v109 + 80);
  uint64_t v48 = *(void *)(v109 + 72);
  else {
    uint64_t v49 = v34;
  }
  uint64_t v50 = (*(void *)(v49 + 24) >> 1) - v45;
  if (v50 < 0) {
LABEL_41:
  }
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  if (v46) {
    uint64_t v51 = v35;
  }
  else {
    uint64_t v51 = v34;
  }
  uint64_t v95 = (v47 + 32) & ~v47;
  uint64_t v52 = v51 + v95 + v48 * v45;
  uint64_t v53 = v106;
  uint64_t v54 = v38;
  uint64_t v55 = v38;
  uint64_t v56 = (uint64_t)v105;
  ((void (*)(void (**)(void, uint64_t), uint64_t, uint64_t *))v106[2])(v37, v55, v105);
  uint64_t v57 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v107 + 64))(v111, v52, v50, v56);
  if (v57 < v104) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/Array.swift",  17LL,  2,  0x4DEuLL,  0);
  }
  uint64_t v58 = v57;
  v53[1](v54, v56);
  uint64_t v59 = v108;
  if (v58 >= 1)
  {
    uint64_t v60 = *v108;
    else {
      uint64_t v61 = v60;
    }
    uint64_t v62 = *(void *)(v61 + 16);
    Swift::Int v63 = v62 + v58;
    if (__OFADD__(v62, v58))
    {
      __break(1u);
LABEL_49:
      uint64_t v105 = v59;
      uint64_t v106 = v37;
      do
      {
        ((void (*)(uint64_t, uint64_t))v107)(v60, v50);
        Array._reserveCapacityAssumingUniqueBuffer(oldCount:)(v63);
        uint64_t v78 = *(void *)v58;
        uint64_t v79 = v50;
        else {
          uint64_t v80 = v78;
        }
        unint64_t v81 = *(void *)(v80 + 24);
        uint64_t v82 = v102;
        ((void (*)(char *, uint64_t, uint64_t))v37)(v102, v56, v79);
        if (((unsigned int (*)(char *, uint64_t, uint64_t *))v59)(v82, 1LL, v9) == 1)
        {
          uint64_t v83 = v102;
LABEL_67:
          uint64_t v50 = v100;
          ((void (*)(char *, uint64_t))v107)(v83, v100);
          Swift::Int v86 = v63;
        }

        else
        {
          Swift::Int v84 = v81 >> 1;
          Swift::String v85 = *(void (**)(char *, char *, uint64_t *))(v109 + 32);
          if (v63 <= v84) {
            Swift::Int v86 = v84;
          }
          else {
            Swift::Int v86 = v63;
          }
          uint64_t v87 = v96;
          uint64_t v88 = v78 + v95 + v48 * v63;
          uint64_t v83 = v102;
          while (1)
          {
            v85(v87, v83, v9);
            if (v86 == v63) {
              break;
            }
            uint64_t v90 = v100;
            int64_t v89 = v101;
            ((void (*)(char *, uint64_t))v107)(v101, v100);
            char v91 = v99;
            v85(v99, v87, v9);
            v85((char *)v88, v91, v9);
            ++v63;
            v93(AssociatedTypeWitness, v104);
            uint64_t v83 = v102;
            ((void (*)(char *, char *, uint64_t))v106)(v102, v89, v90);
            v88 += v48;
          }

          (*(void (**)(char *, uint64_t *))(v109 + 8))(v87, v9);
          Swift::Int v63 = v86;
          uint64_t v50 = v100;
        }

        uint64_t v58 = (uint64_t)v108;
        uint64_t v75 = *v108;
        BOOL v76 = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
        uint64_t v77 = v75 & 0xFFFFFFFFFFFFF8LL;
        if (!v76) {
          uint64_t v77 = v75;
        }
        *(void *)(v77 + 16) = v86;
        uint64_t v60 = (uint64_t)v97;
        uint64_t v56 = (uint64_t)v101;
        int64_t v37 = v106;
        ((void (*)(char *, char *, uint64_t))v106)(v97, v101, v50);
        uint64_t v59 = v105;
      }

      while (((unsigned int (*)(uint64_t, uint64_t, uint64_t *))v105)(v60, 1LL, v9) != 1);
      goto LABEL_47;
    }

    else {
      uint64_t v64 = v60;
    }
    *(void *)(v64 + 16) = v63;
  }

  if (v58 != v50 || v56 == v98) {
    return (*(uint64_t (**)(char *, unint64_t))(v103 + 8))(v111, AssociatedTypeWitness);
  }
  uint64_t v66 = *v59;
  BOOL v67 = _swift_isClassOrObjCExistentialType((uint64_t)v9, v9);
  uint64_t v68 = v66 & 0xFFFFFFFFFFFFF8LL;
  if (!v67) {
    uint64_t v68 = v66;
  }
  Swift::Int v63 = *(void *)(v68 + 16);
  unint64_t v69 = AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v107,  v56,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v71 = *(void (**)(unint64_t, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v56 = (uint64_t)v101;
  uint64_t v104 = AssociatedConformanceWitness;
  unint64_t v93 = v71;
  ((void (*)(unint64_t))v71)(v69);
  uint64_t v72 = v94;
  int64_t v37 = *(void (***)(void, uint64_t))(v94 + 16);
  uint64_t v60 = (uint64_t)v97;
  uint64_t v50 = v100;
  ((void (*)(char *, uint64_t, uint64_t))v37)(v97, v56, v100);
  uint64_t v58 = (uint64_t)v59;
  uint64_t v59 = *(uint64_t **)(v109 + 48);
  unsigned int v73 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t *))v59)(v60, 1LL, v9);
  uint64_t v107 = *(void *)(v72 + 8);
  if (v73 != 1) {
    goto LABEL_49;
  }
LABEL_47:
  unint64_t v74 = (uint64_t (*)(uint64_t, uint64_t))v107;
  ((void (*)(uint64_t, uint64_t))v107)(v56, v50);
  (*(void (**)(char *, unint64_t))(v103 + 8))(v111, AssociatedTypeWitness);
  return v74(v60, v50);
}

uint64_t UnsafeMutableBufferPointer.initialize<A>(from:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a7 + 64))(a1, a3, a4, a6, a7);
}

uint64_t UnsafeMutableBufferPointer.startIndex.getter()
{
  return 0LL;
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.distance(from:to:)(Swift::Int from, Swift::Int to)
{
  return UnsafeMutableBufferPointer.distance(from:to:)(from, to, v2, v3, v4, 0x129uLL);
}

BOOL == infix(_:_:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == a2;
  if (!a2) {
    BOOL v2 = a1 == 0;
  }
  if (a1) {
    return v2;
  }
  else {
    return a2 == 0;
  }
}

{
  return a1 == a2;
}

{
  return a1 == a2;
}

Swift::Void __swiftcall Array.reserveCapacityForAppend(newElementsCount:)(Swift::Int newElementsCount)
{
  Swift::Int v2 = Array._getCount()();
  BOOL v3 = __OFADD__(v2, newElementsCount);
  Swift::Int v4 = v2 + newElementsCount;
  if (v3) {
    __break(1u);
  }
  else {
    Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(v4, 1);
  }
}

uint64_t specialized Array._customRemoveLast()()
{
  uint64_t v1 = *v0;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v0);
  *uint64_t v0 = v1;
  if (!isUniquelyReferenced_nonNull_native)
  {
    uint64_t v1 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew()(v1);
    *uint64_t v0 = v1;
    uint64_t v3 = *(void *)(v1 + 16);
    if (v3) {
      goto LABEL_3;
    }
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty Array",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x51CuLL,  0);
  }

  uint64_t v3 = *(void *)(v1 + 16);
  if (!v3) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v4 = v3 - 1;
  uint64_t v5 = v1 + 8 * v4;
  uint64_t v6 = *(unsigned int *)(v5 + 32);
  uint64_t v7 = *(unsigned __int16 *)(v5 + 36);
  *(void *)(v1 + 16) = v4;
  *uint64_t v0 = v1;
  return v6 | (v7 << 32);
}

{
  uint64_t *v0;
  uint64_t v1;
  int isUniquelyReferenced_nonNull_bridgeObject;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v1 = *v0;
  char isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(*v0);
  *uint64_t v0 = v1;
  if (!isUniquelyReferenced_nonNull_bridgeObject || v1 < 0 || (v1 & 0x4000000000000000LL) != 0)
  {
    uint64_t v1 = specialized _ArrayBuffer._consumeAndCreateNew()(v1);
    *uint64_t v0 = v1;
  }

  uint64_t v3 = *(void *)((v1 & 0xFFFFFFFFFFFFFF8LL) + 0x10);
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty Array",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x51CuLL,  0);
  }
  uint64_t v4 = v3 - 1;
  int64_t result = *(void *)((v1 & 0xFFFFFFFFFFFFFF8LL) + 8 * v4 + 0x20);
  *(void *)((v1 & 0xFFFFFFFFFFFFFF8LL) + 0x10) = v4;
  *uint64_t v0 = v1;
  return result;
}

uint64_t Array._customRemoveLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *v2;
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  else {
    uint64_t v7 = v5;
  }
  uint64_t v8 = *(void *)(v7 + 16);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty Array",  36LL,  2,  "Swift/Array.swift",  17LL,  2,  0x51CuLL,  0);
  }
  uint64_t v9 = v8 - 1;
  else {
    uint64_t v10 = v5;
  }
  uint64_t v11 = *(v6 - 1);
  (*(void (**)(uint64_t, unint64_t, uint64_t *))(v11 + 32))( a2,  v10 + ((*(unsigned __int8 *)(v11 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))
  + *(void *)(v11 + 72) * v9,
    v6);
  else {
    uint64_t v12 = v5;
  }
  *(void *)(v12 + 16) = v9;
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t *))(v11 + 56))(a2, 0LL, 1LL, v6);
}

uint64_t UnsafeMutablePointer.move()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 32LL))(a3, a1);
}

unint64_t specialized Array.remove(at:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v1);
  *uint64_t v1 = v3;
  if (!isUniquelyReferenced_nonNull_native)
  {
    uint64_t v3 = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew()(v3);
    *uint64_t v1 = v3;
  }

  uint64_t v5 = *(void *)(v3 + 16);
  if (v5 <= a1)
  {
    unint64_t v11 = 1339LL;
    goto LABEL_8;
  }

  if (a1 < 0)
  {
    unint64_t v11 = 1340LL;
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Array.swift",  17LL,  2,  v11,  0);
  }

  uint64_t v6 = v5 - 1;
  uint64_t v7 = v3 + 8 * a1;
  unsigned int v8 = *(_DWORD *)(v7 + 32);
  v7 += 32LL;
  uint64_t v9 = *(unsigned __int16 *)(v7 + 4);
  specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v7 + 8), v5 - 1 - a1, (char *)v7);
  *(void *)(v3 + 16) = v6;
  *uint64_t v1 = v3;
  return v8 | (unint64_t)(v9 << 32);
}

uint64_t specialized Array.remove(at:)(uint64_t a1)
{
  uint64_t v3 = *v1;
  int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject(*v1);
  *uint64_t v1 = v3;
  if (!isUniquelyReferenced_nonNull_bridgeObject || v3 < 0 || (v3 & 0x4000000000000000LL) != 0)
  {
    uint64_t v3 = specialized _ArrayBuffer._consumeAndCreateNew()(v3);
    *uint64_t v1 = v3;
  }

  uint64_t v5 = *(void *)((v3 & 0xFFFFFFFFFFFFFF8LL) + 0x10);
  if (v5 <= a1)
  {
    unint64_t v11 = 1339LL;
    goto LABEL_10;
  }

  if (a1 < 0)
  {
    unint64_t v11 = 1340LL;
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Array.swift",  17LL,  2,  v11,  0);
  }

  uint64_t v6 = v5 - 1;
  uint64_t v7 = v5 - 1 - a1;
  uint64_t v8 = (v3 & 0xFFFFFFFFFFFFFF8LL) + 8 * a1;
  uint64_t v9 = *(void *)(v8 + 0x20);
  specialized UnsafeMutablePointer.moveInitialize(from:count:)((char *)(v8 + 40), v7, (char *)(v8 + 32));
  *(void *)((v3 & 0xFFFFFFFFFFFFFF8LL) + 0x10) = v6;
  *uint64_t v1 = v3;
  return v9;
}

BOOL Array.remove(at:)@<W0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = *v3;
  uint64_t v8 = *(uint64_t **)(a2 + 16);
  else {
    uint64_t v9 = v7;
  }
  uint64_t v10 = *(void *)(v9 + 16);
  if (v10 <= a1)
  {
    unint64_t v17 = 1339LL;
    goto LABEL_15;
  }

  if (a1 < 0)
  {
    unint64_t v17 = 1340LL;
LABEL_15:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/Array.swift",  17LL,  2,  v17,  0);
  }

  else {
    uint64_t v11 = v7;
  }
  uint64_t v12 = *(v8 - 1);
  uint64_t v13 = *(void *)(v12 + 72);
  uint64_t v14 = (char *)(v11
  (*(void (**)(uint64_t, char *, uint64_t *))(v12 + 32))(a3, v14, v8);
  UnsafeMutablePointer.moveInitialize(from:count:)(&v14[v13], v10 - 1 - a1, v14, (uint64_t)v8);
  BOOL result = _swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
  if (result) {
    uint64_t v16 = v7 & 0xFFFFFFFFFFFFFF8LL;
  }
  else {
    uint64_t v16 = v7;
  }
  *(void *)(v16 + 16) = v10 - 1;
  return result;
}

uint64_t Array.insert(_:at:)(uint64_t a1, Swift::Int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t v8 = type metadata accessor for CollectionOfOne(0LL, v7, a3, a4);
  MEMORY[0x1895F8858](v8);
  uint64_t v10 = (char *)&v13 - v9;
  Array._checkIndex(_:)(a2);
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(v10, a1, v7);
  swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v8, v11);
  return Array.replaceSubrange<A>(_:with:)(a2, a2, (void (*)(void, void, void))v10, a3);
}

Swift::Void __swiftcall Array.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  if (keepingCapacity)
  {
    uint64_t v3 = v1;
    uint64_t v4 = *(uint64_t **)(v1 + 16);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v4, v4);
    uint64_t v6 = *v2;
    if (isClassOrObjCExistentialType)
    {
      if (v6 < 0 || (v6 & 0x4000000000000000LL) != 0 || (swift_isUniquelyReferenced_nonNull_bridgeObject(v6) & 1) == 0) {
        goto LABEL_6;
      }
    }

    else if (!swift_isUniquelyReferenced_nonNull_native(v6))
    {
LABEL_6:
      Swift::Int v8 = Array._getCapacity()();
      uint64_t v9 = _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(0LL, v8, v4);
      uint64_t v10 = *v2;
      *Swift::Int v2 = (uint64_t)v9;
      swift_bridgeObjectRelease(v10);
      return;
    }

    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v3, v7);
    RandomAccessCollection<>.indices.getter(v3, WitnessTable, (uint64_t)&protocol witness table for Int, (char *)v20);
    uint64_t v13 = v20[0];
    Swift::Int v14 = v20[1];
    uint64_t v17 = type metadata accessor for EmptyCollection(0LL, (uint64_t)v4, v15, v16);
    swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v17, v18);
    Array.replaceSubrange<A>(_:with:)(v13, v14, v19, v3);
  }

  else
  {
    uint64_t v11 = *v2;
    *Swift::Int v2 = (uint64_t)&_swiftEmptyArrayStorage;
    swift_bridgeObjectRelease(v11);
  }

void *Array.withUnsafeMutableBufferPointer<A>(_:)( void (*a1)(void *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  v15[3] = a4;
  Array._makeMutableAndUnique()();
  uint64_t v7 = *v4;
  Swift::Int v8 = *(uint64_t **)(a3 + 16);
  else {
    uint64_t v9 = v7;
  }
  uint64_t v10 = *(void *)(v9 + 16);
  else {
    uint64_t v11 = v7;
  }
  uint64_t v12 = *(unsigned __int8 *)(*(v8 - 1) + 80);
  uint64_t v13 = v11 + ((v12 + 32) & ~v12);
  v15[0] = v13;
  v15[1] = v10;
  a1(v15);
  return $defer #1 <A><A1>() in Array.withUnsafeMutableBufferPointer<A>(_:)(v15, v13, v10);
}

char *specialized closure #1 in Array.withContiguousStorageIfAvailable<A>(_:)( char *result, uint64_t a2, uint64_t a3, uint64_t a4, void *__dst)
{
  if (a3 < 0 || a2 < a3)
  {
    unint64_t v6 = 188LL;
    goto LABEL_13;
  }

  uint64_t v5 = a3 + a4;
  if (__OFADD__(a3, a4))
  {
    __break(1u);
    goto LABEL_16;
  }

  if (v5 < 0 || v5 > a2)
  {
    unint64_t v6 = 192LL;
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array index out of range",  24LL,  2,  "Swift/SwiftNativeNSArray.swift",  30LL,  2,  v6,  0);
  }

  if (a2)
  {
    if (!result) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/SwiftNativeNSArray.swift",  30LL,  2,  0xCBuLL,  0);
    }
    if ((unint64_t)(a4 - 0x1000000000000000LL) >> 61 == 7)
    {
      if (((8 * a4) & 0x8000000000000000LL) == 0) {
        return (char *)memmove(__dst, &result[8 * a3], 8 * a4);
      }
LABEL_17:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
    }

LABEL_16:
    __break(1u);
    goto LABEL_17;
  }

  return result;
}

      uint64_t v18 = (a3 & 0x3F) << 8;
      uint64_t v19 = a3 >> 12;
      uint64_t v20 = (v18 | (a3 >> 6) & 0x3F) << 8;
      if (a3 < 0x10000)
      {
        uint64_t v21 = 8487393;
      }

      else
      {
        uint64_t v19 = a3 >> 18;
        uint64_t v20 = (v20 | (a3 >> 12) & 0x3F) << 8;
        uint64_t v21 = -2122219023;
      }

      else {
        uint64_t v19 = a3 >> 6;
      }
      else {
        uint64_t v13 = 33217;
      }
      LODWORD(a3) = v18 | v19;
      goto LABEL_9;
    }

    uint64_t v12 = 148LL;
  }

  else
  {
    if (a3)
    {
      if (a4 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeBufferPointer with negative count",  39LL,  2LL,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  1343LL,  0);
      }
      uint64_t v17 = a3;
      uint64_t v16 = a4;
LABEL_12:
      closure #1 in closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)( v17,  v16,  a6,  a7,  v10,  v9,  a8,  v11);
    }

    uint64_t v12 = 136LL;
  }

  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2LL,  "Swift/StaticString.swift",  24LL,  2,  v12,  0);
  goto LABEL_15;
}

  swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
  swift_bridgeObjectRetain(v15, v21, v22, v23);
  unint64_t v24 = _StringGuts._convertedToSmall()(v14, v15);
  uint64_t v26 = v25;
  swift_bridgeObjectRelease(v15);
  v27._Swift::UInt64 rawBits = 1LL;
  v28._Swift::UInt64 rawBits = 1LL;
  v29._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v27, v28, 0LL, 0xE000000000000000LL);
  if (v29._rawBits < 0x10000) {
    v29._rawBits |= 3;
  }
  uint64_t v31 = specialized String.init(_:)(v29, v30, 0LL, 0xE000000000000000LL);
  Swift::Bool v33 = v32;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v34 = _StringGuts._convertedToSmall()(v31, v33);
  uint64_t v36 = v35;
  swift_bridgeObjectRelease(v33);
  int64_t v37 = specialized _SmallString.init(_:appending:)(v24, v26, v34, v36);
  if ((v39 & 1) != 0) {
    goto LABEL_338;
  }
  unint64_t v40 = v37;
  uint64_t v41 = v38;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  v377._uint64_t countAndFlagsBits = v40;
  v377._uint64_t object = v41;
  swift_bridgeObjectRelease(v15);
  a1 = (uint64_t *)v372;
LABEL_28:
  DynamicType = swift_getDynamicType(v3, a1, 0);
  TypeName = (uint64_t *)swift_getTypeName(DynamicType, 0);
  if (v48 < 0) {
    goto LABEL_311;
  }
  uint64_t v49 = (uint8x16_t *)TypeName;
  uint64_t v50 = v48;
  v373 = v9;
  v371 = a2;
  if (_allASCII(_:)(TypeName, v48))
  {
    uint64_t v53 = 1;
LABEL_31:
    if (!v50)
    {
      uint64_t v55 = 0LL;
      uint64_t v54 = 0xE000000000000000LL;
      goto LABEL_120;
    }

    if (v50 > 15)
    {
      uint64_t v54 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v49->i8,  v50,  v50,  v53 & 1);
      uint64_t v55 = *(void *)(v54 + 24);
      goto LABEL_120;
    }

    unint64_t v93 = v50 - 8;
    uint64_t v94 = 8LL;
    if (v50 < 8) {
      uint64_t v94 = v50;
    }
    if ((v94 & 0x8000000000000000LL) == 0)
    {
      if (v94 >= 8)
      {
        if (v94 >= 0x10)
        {
          uint64_t v95 = v94 & 0xFFFFFFFFFFFFFFF0LL;
          uint64_t v120 = vmovl_high_u8(*v49);
          unint64_t v121 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v120.i8);
          unint64_t v122 = vmovl_u8(*(uint8x8_t *)v49->i8);
          uint64_t v123 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v122.i8);
          unint64_t v124 = (int8x16_t)vmovl_high_u16(v120);
          unint64_t v125 = (int8x8_t)vextq_s8(v124, v124, 8uLL).u64[0];
          char v126 = (int8x16_t)vmovl_high_u16(v122);
          unint64_t v127 = (int8x8_t)vextq_s8(v126, v126, 8uLL).u64[0];
          *(int8x8_t *)v126.i8 = vorr_s8(*(int8x8_t *)v126.i8, *(int8x8_t *)v124.i8);
          v128.i64[0] = v126.u32[0];
          v128.i64[1] = v126.u32[1];
          Swift::String v129 = (int8x16_t)vshlq_u64(v128, (uint64x2_t)xmmword_1817FFCE0);
          *(int8x8_t *)v124.i8 = vorr_s8(*(int8x8_t *)v123.i8, *(int8x8_t *)v121.i8);
          v128.i64[0] = v124.u32[0];
          v128.i64[1] = v124.u32[1];
          v130 = vorrq_s8((int8x16_t)vshlq_u64(v128, (uint64x2_t)xmmword_1817FFCD0), v129);
          *(int8x8_t *)v124.i8 = vorr_s8(v127, v125);
          v128.i64[0] = v124.u32[0];
          v128.i64[1] = v124.u32[1];
          v131 = (int8x16_t)vshlq_u64(v128, (uint64x2_t)xmmword_1817FFCC0);
          *(int8x8_t *)v121.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v123, v123, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v121, v121, 8uLL));
          v128.i64[0] = v121.u32[0];
          v128.i64[1] = v121.u32[1];
          uint64_t v132 = vorrq_s8(v130, vorrq_s8((int8x16_t)vshlq_u64(v128, (uint64x2_t)xmmword_1817FFCB0), v131));
          uint64_t v55 = (uint64_t)vorr_s8(*(int8x8_t *)v132.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v132, v132, 8uLL));
          if (v94 == (v94 & 0xFFFFFFFFFFFFFFF0LL)) {
            goto LABEL_112;
          }
          unint64_t v96 = 8 * v95;
          if ((v94 & 8) == 0) {
            goto LABEL_110;
          }
        }

        else
        {
          uint64_t v55 = 0LL;
          unint64_t v96 = 0LL;
          uint64_t v95 = 0LL;
        }

        unint64_t v97 = v95;
        uint64_t v98 = vdupq_n_s64(v96);
        uint64_t v95 = v94 & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v96 = 8 * (v94 & 0xFFFFFFFFFFFFFFF8LL);
        unint64_t v99 = 0uLL;
        uint64_t v100 = (int8x16_t)(unint64_t)v55;
        char v101 = vaddq_s64(v98, (int64x2_t)xmmword_1817FFCC0);
        uint64_t v102 = vaddq_s64(v98, (int64x2_t)xmmword_1817FFCE0);
        uint64_t v103 = vaddq_s64(v98, (int64x2_t)xmmword_1817FFCB0);
        uint64_t v104 = vaddq_s64(v98, (int64x2_t)xmmword_1817FFCD0);
        uint64_t v105 = (uint8x8_t *)&v49->i8[v97];
        uint64_t v106 = (int8x16_t)vdupq_n_s64(0x38uLL);
        uint64_t v107 = v97 - (v94 & 0xFFFFFFFFFFFFFFF8LL);
        uint64_t v108 = vdupq_n_s64(0x40uLL);
        uint64_t v109 = 0uLL;
        uint64_t v110 = 0uLL;
        do
        {
          v111 = *v105++;
          uint64_t v112 = vmovl_u8(v111);
          uint64_t v113 = vmovl_high_u16(v112);
          v114.i64[0] = v113.u32[2];
          v114.i64[1] = v113.u32[3];
          v115 = v114;
          v114.i64[0] = v113.u32[0];
          v114.i64[1] = v113.u32[1];
          int64_t v116 = v114;
          int64_t v117 = vmovl_u16(*(uint16x4_t *)v112.i8);
          v114.i64[0] = v117.u32[2];
          v114.i64[1] = v117.u32[3];
          int64_t v118 = v114;
          v114.i64[0] = v117.u32[0];
          v114.i64[1] = v117.u32[1];
          uint64_t v110 = vorrq_s8((int8x16_t)vshlq_u64(v115, (uint64x2_t)vandq_s8((int8x16_t)v101, v106)), v110);
          uint64_t v109 = vorrq_s8((int8x16_t)vshlq_u64(v116, (uint64x2_t)vandq_s8((int8x16_t)v102, v106)), v109);
          unint64_t v99 = vorrq_s8((int8x16_t)vshlq_u64(v118, (uint64x2_t)vandq_s8((int8x16_t)v103, v106)), v99);
          uint64_t v100 = vorrq_s8((int8x16_t)vshlq_u64(v114, (uint64x2_t)vandq_s8((int8x16_t)v104, v106)), v100);
          uint64_t v102 = vaddq_s64(v102, v108);
          uint64_t v103 = vaddq_s64(v103, v108);
          uint64_t v104 = vaddq_s64(v104, v108);
          char v101 = vaddq_s64(v101, v108);
          v107 += 8LL;
        }

        while (v107);
        char v119 = vorrq_s8(vorrq_s8(v100, v109), vorrq_s8(v99, v110));
        uint64_t v55 = (uint64_t)vorr_s8(*(int8x8_t *)v119.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v119, v119, 8uLL));
        if (v94 == v95)
        {
LABEL_112:
          if (v50 < 9)
          {
            char v136 = 0LL;
          }

          else
          {
            char v136 = 0LL;
            v137 = 0LL;
            v138 = &v49->u8[8];
            do
            {
              v139 = *v138++;
              v136 |= (unint64_t)v139 << v137;
              v137 += 8LL;
              --v93;
            }

            while (v93);
          }

          v140 = 0xA000000000000000LL;
          if (((v136 | v55) & 0x8080808080808080LL) == 0) {
            v140 = 0xE000000000000000LL;
          }
          uint64_t v54 = v140 | (v50 << 56) | v136;
          goto LABEL_120;
        }
      }

      else
      {
        uint64_t v95 = 0LL;
        uint64_t v55 = 0LL;
        unint64_t v96 = 0LL;
      }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawPointer.copyMemory with negative count",  54LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x60DuLL,  0);
    }

    uint64_t v26 = validateUTF8(_:)(a1->i64, v22);
    if ((v28 & 1) != 0) {
      return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v22, v26, v27);
    }
    else {
      return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v22, v26 & 1);
    }
  }

  uint64_t v61 = v8;
  uint64_t v36 = *(uint64_t (**)(unint64_t *, uint64_t))(v8 + 64);
  uint64_t v58 = *(void *)(v12 + 16);
  uint64_t v59 = v36;
  for (uint64_t i = a1; ; uint64_t i = (uint8x16_t *)((char *)v60 + *(void *)(v12 + 72)))
  {
    uint64_t v60 = i;
    ((void (*)(char *))v58)(v20);
    if ((v59(v11, v61) & 1) != 0) {
      break;
    }
    LODWORD(v57) = v59(v11, v61);
    unint64_t v40 = (*(uint64_t (**)(unint64_t *))(v61 + 128))(v11);
    if (v40 > 64) {
      goto LABEL_28;
    }
    uint64_t v43 = v62;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v63,  (uint64_t)v11,  v62,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v43,  AssociatedConformanceWitness);
    (*((void (**)(char *, unint64_t *))v63 + 3))(v10, v11);
    LOBYTE(v43) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v61 + 32) + 8LL)
                                                                                + 32LL))( v20,  v18,  v11);
    uint64_t v57 = *(void (**)(char *, unint64_t *))(v12 + 8);
    v57(v18, v11);
    (*(void (**)(char *, char *, unint64_t *))(v12 + 32))(v15, v20, v11);
    if ((v43 & 1) != 0)
    {
      uint64_t v45 = (*(uint64_t (**)(unint64_t *))(v61 + 120))(v11);
      v57(v15, v11);
      goto LABEL_38;
    }

    v57(v15, v11);
LABEL_29:
    ;
  }

  unint64_t v40 = (*(uint64_t (**)(unint64_t *))(v61 + 128))(v11);
LABEL_36:
  if (v40 >= 64)
  {
LABEL_28:
    v65[0] = 0LL;
    uint64_t v57 = *(void (**)(char *, unint64_t *))(v61 + 96);
    uint64_t v38 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    ((void (*)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))v57)( v65,  &type metadata for Int,  v38,  v11,  v61);
    LODWORD(v57) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v61 + 16)
                                                                                             + 8LL)
                                                                                 + 8LL))( v20,  v18,  v11);
    uint64_t v39 = *(void (**)(char *, unint64_t *))(v12 + 8);
    v39(v18, v11);
    v39(v20, v11);
    goto LABEL_29;
  }

  uint64_t v45 = (*(uint64_t (**)(unint64_t *))(v61 + 120))(v11);
  (*(void (**)(char *, unint64_t *))(v12 + 8))(v20, v11);
LABEL_38:
  if (v45) {
    goto LABEL_29;
  }
LABEL_41:
  BOOL v46 = *(void *)(v12 + 72);
  if (!v46) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  if ((char *)v60 - (char *)a1 == 0x8000000000000000LL && v46 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  v65[0] = UnsafeBufferPointer.init(start:count:)((uint64_t)a1, ((char *)v60 - (char *)a1) / v46);
  v65[1] = v47;
  uint64_t v50 = (swift *)type metadata accessor for UnsafeBufferPointer(0LL, (uint64_t)v11, v48, v49);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, v50, v51);
  BOOL result = static String._fromCodeUnits<A, B>(_:encoding:repair:)( (uint64_t)v65,  (uint64_t)v64,  1,  v50,  a3,  WitnessTable,  a4);
  if (!v53) {
LABEL_45:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CString.swift",  19LL,  2,  0x1E3uLL,  0);
  return result;
}

  swift_bridgeObjectRelease(v30);
  return (v29 >> 16) - (v14 >> 16);
}

                            Swift::Int v86 = v260(a2, v63);
                            uint64_t v87 = (*(uint64_t (**)(swift *, uint64_t))(v63 + 104))(a2, v63);
                            if (v86 == 11)
                            {
                              if (v87 == 52)
                              {
                                char v91 = v275;
                                v65((char *)v275, v72, a2);
                                LODWORD(v91) = swift_dynamicCast( (char *)&v294,  v91,  a2,  (const char *)&type metadata for Double,  6uLL);
                                _D8 = v294;
                                unint64_t v93 = v278;
                                (*(void (**)(char *, uint64_t, swift *))(v289 + 32))(v278, v72, a2);
                                if ((_DWORD)v91)
                                {
                                  v71(v93, a2);
                                  __asm { FCVT            H8, D8 }
                                }

                                else
                                {
                                  Swift::String v129 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 168))(a2, v66);
                                  v130 = v93;
                                  v131 = v129;
                                  uint64_t v132 = *(void (**)(swift *, uint64_t))(v63 + 112);
                                  BOOL v133 = v63;
                                  uint64_t v134 = v279;
                                  v132(a2, v133);
                                  v135 = v281;
                                  char v136 = swift_getAssociatedConformanceWitness( v133,  (uint64_t)a2,  v281,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                                  v137 = (*(uint64_t (**)(uint64_t))(*(void *)(v136 + 8) + 120LL))(v135);
                                  (*(void (**)(char *, uint64_t))(v280 + 8))(v134, v135);
                                  v138 = v282;
                                  (*(void (**)(swift *, uint64_t))(v133 + 120))(a2, v133);
                                  v71(v130, a2);
                                  v139 = v133;
                                  v140 = v284;
                                  v141 = swift_getAssociatedConformanceWitness( v139,  (uint64_t)a2,  v284,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                                  unint64_t v142 = (*(uint64_t (**)(uint64_t))(*(void *)(v141 + 8) + 120LL))(v140);
                                  (*(void (**)(char *, uint64_t))(v283 + 8))(v138, v140);
                                  _D0 = (v131 << 63) | ((unint64_t)(v137 & 0x7FF) << 52) | v142 & 0xFFFFFFFFFFFFFLL;
                                  __asm { FCVT            H8, D0 }
                                }

                                goto LABEL_29;
                              }
                            }

                            else if (v86 == 8)
                            {
                              if (v87 == 23)
                              {
                                uint64_t v98 = v274;
                                v65((char *)v274, v72, a2);
                                LODWORD(v98) = swift_dynamicCast( (char *)&v294,  v98,  a2,  (const char *)&type metadata for Float,  6uLL);
                                _S8 = v294;
                                uint64_t v100 = v277;
                                (*(void (**)(char *, uint64_t, swift *))(v289 + 32))(v277, v72, a2);
                                if ((_DWORD)v98)
                                {
                                  v71(v100, a2);
                                  __asm { FCVT            H8, S8 }
                                }

                                else
                                {
                                  unint64_t v144 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 168))(a2, v66);
                                  v145 = v100;
                                  v146 = v144;
                                  v147 = *(void (**)(swift *, uint64_t))(v63 + 112);
                                  uint64_t v148 = v63;
                                  v149 = v279;
                                  v147(a2, v148);
                                  v150 = v281;
                                  v151 = swift_getAssociatedConformanceWitness( v148,  (uint64_t)a2,  v281,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                                  unint64_t v152 = (*(uint64_t (**)(uint64_t))(*(void *)(v151 + 8) + 120LL))(v150);
                                  (*(void (**)(char *, uint64_t))(v280 + 8))(v149, v150);
                                  v153 = v282;
                                  (*(void (**)(swift *, uint64_t))(v148 + 120))(a2, v148);
                                  v71(v145, a2);
                                  unint64_t v154 = v148;
                                  v155 = v284;
                                  v156 = swift_getAssociatedConformanceWitness( v154,  (uint64_t)a2,  v284,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                                  uint64_t v157 = (*(uint64_t (**)(uint64_t))(*(void *)(v156 + 8) + 120LL))(v155);
                                  (*(void (**)(char *, uint64_t))(v283 + 8))(v153, v155);
                                  _S0 = (v146 << 31) | (v152 << 23) | v157 & 0x7FFFFF;
                                  __asm { FCVT            H8, S0 }
                                }

                                goto LABEL_29;
                              }
                            }

                            else if (v86 == 5 && v87 == 10)
                            {
                              uint64_t v88 = v273;
                              v65((char *)v273, v72, a2);
                              LODWORD(v88) = swift_dynamicCast( (char *)&v294,  v88,  a2,  (const char *)&type metadata for Float16,  6uLL);
                              _H8 = v294;
                              uint64_t v90 = v276;
                              (*(void (**)(char *, uint64_t, swift *))(v289 + 32))(v276, v72, a2);
                              if ((_DWORD)v88)
                              {
                                v71(v90, a2);
                              }

                              else
                              {
                                v115 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 168))(a2, v66);
                                int64_t v116 = v90;
                                int64_t v117 = v115;
                                int64_t v118 = *(void (**)(swift *, uint64_t))(v63 + 112);
                                char v119 = v63;
                                uint64_t v120 = v279;
                                v118(a2, v119);
                                unint64_t v121 = v281;
                                unint64_t v122 = swift_getAssociatedConformanceWitness( v119,  (uint64_t)a2,  v281,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                                uint64_t v123 = (*(uint64_t (**)(uint64_t))(*(void *)(v122 + 8) + 120LL))(v121);
                                (*(void (**)(char *, uint64_t))(v280 + 8))(v120, v121);
                                unint64_t v124 = v282;
                                (*(void (**)(swift *, uint64_t))(v119 + 120))(a2, v119);
                                v71(v116, a2);
                                unint64_t v125 = v119;
                                char v126 = v284;
                                unint64_t v127 = swift_getAssociatedConformanceWitness( v125,  (uint64_t)a2,  v284,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                                unint64_t v128 = (*(uint64_t (**)(uint64_t))(*(void *)(v127 + 8) + 120LL))(v126);
                                (*(void (**)(char *, uint64_t))(v283 + 8))(v124, v126);
                                _H8 = (v117 << 15) | ((v123 & 0x1F) << 10) | v128 & 0x3FF;
                              }

                              goto LABEL_29;
                            }

                            specialized static BinaryFloatingPoint._convert<A>(from:)( (__int16 *)&v294,  v72,  (uint64_t)a2,  v63);
                            v71((char *)v72, a2);
                            _H8 = v294;
LABEL_29:
                            uint64_t v62 = 0;
                            uint64_t v61 = _H8;
                            return v61 | (v62 << 16);
                          }

                          __break(1u);
                          goto LABEL_110;
                        }

                            Swift::Int v86 = v257(a2, v63);
                            uint64_t v87 = (*(uint64_t (**)(swift *, uint64_t))(v63 + 104))(a2, v63);
                            if (v86 == 11)
                            {
                              if (v87 == 52)
                              {
                                char v91 = v272;
                                v65((char *)v272, v72, a2);
                                LODWORD(v91) = swift_dynamicCast( (char *)&v291,  v91,  a2,  (const char *)&type metadata for Double,  6uLL);
                                uint64_t v92 = *(double *)&v291;
                                unint64_t v93 = v275;
                                (*(void (**)(char *, const char *, swift *))(v286 + 32))(v275, v72, a2);
                                if ((_DWORD)v91)
                                {
                                  v71(v93, a2);
                                  *(float *)&_S8 = v92;
                                }

                                else
                                {
                                  Swift::String v129 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 168))(a2, v66);
                                  v130 = v93;
                                  v131 = v129;
                                  uint64_t v132 = *(void (**)(swift *, uint64_t))(v63 + 112);
                                  BOOL v133 = v63;
                                  uint64_t v134 = v276;
                                  v132(a2, v133);
                                  v135 = v278;
                                  char v136 = swift_getAssociatedConformanceWitness( v133,  (uint64_t)a2,  v278,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                                  v137 = (*(uint64_t (**)(uint64_t))(*(void *)(v136 + 8) + 120LL))(v135);
                                  (*(void (**)(char *, uint64_t))(v277 + 8))(v134, v135);
                                  v138 = v279;
                                  (*(void (**)(swift *, uint64_t))(v133 + 120))(a2, v133);
                                  v71(v130, a2);
                                  v139 = v133;
                                  v140 = v281;
                                  v141 = swift_getAssociatedConformanceWitness( v139,  (uint64_t)a2,  v281,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                                  unint64_t v142 = (*(uint64_t (**)(uint64_t))(*(void *)(v141 + 8) + 120LL))(v140);
                                  (*(void (**)(char *, uint64_t))(v280 + 8))(v138, v140);
                                  *(float *)&_S8 = COERCE_DOUBLE((v131 << 63) | ((unint64_t)(v137 & 0x7FF) << 52) | v142 & 0xFFFFFFFFFFFFFLL);
                                }

                                goto LABEL_29;
                              }
                            }

                            else if (v86 == 8)
                            {
                              if (v87 == 23)
                              {
                                uint64_t v95 = v271;
                                v65((char *)v271, v72, a2);
                                LODWORD(v95) = swift_dynamicCast( (char *)&v291,  v95,  a2,  (const char *)&type metadata for Float,  6uLL);
                                _S8 = v291;
                                unint64_t v96 = v274;
                                (*(void (**)(char *, const char *, swift *))(v286 + 32))(v274, v72, a2);
                                if ((_DWORD)v95)
                                {
                                  v71(v96, a2);
                                }

                                else
                                {
                                  v143 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 168))(a2, v66);
                                  unint64_t v144 = v96;
                                  v145 = v143;
                                  v146 = *(void (**)(swift *, uint64_t))(v63 + 112);
                                  v147 = v63;
                                  uint64_t v148 = v276;
                                  v146(a2, v147);
                                  v149 = v278;
                                  v150 = swift_getAssociatedConformanceWitness( v147,  (uint64_t)a2,  v278,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                                  v151 = (*(uint64_t (**)(uint64_t))(*(void *)(v150 + 8) + 120LL))(v149);
                                  (*(void (**)(char *, uint64_t))(v277 + 8))(v148, v149);
                                  unint64_t v152 = v279;
                                  (*(void (**)(swift *, uint64_t))(v147 + 120))(a2, v147);
                                  v71(v144, a2);
                                  v153 = v147;
                                  unint64_t v154 = v281;
                                  v155 = swift_getAssociatedConformanceWitness( v153,  (uint64_t)a2,  v281,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                                  v156 = (*(uint64_t (**)(uint64_t))(*(void *)(v155 + 8) + 120LL))(v154);
                                  (*(void (**)(char *, uint64_t))(v280 + 8))(v152, v154);
                                  _S8 = (v145 << 31) | (v151 << 23) | v156 & 0x7FFFFF;
                                }

                                goto LABEL_29;
                              }
                            }

                            else if (v86 == 5 && v87 == 10)
                            {
                              uint64_t v88 = v270;
                              v65((char *)v270, v72, a2);
                              LODWORD(v88) = swift_dynamicCast( (char *)&v291,  v88,  a2,  (const char *)&type metadata for Float16,  6uLL);
                              _H8 = v291;
                              uint64_t v90 = v273;
                              (*(void (**)(char *, const char *, swift *))(v286 + 32))(v273, v72, a2);
                              if ((_DWORD)v88)
                              {
                                v71(v90, a2);
                              }

                              else
                              {
                                v111 = (*(uint64_t (**)(swift *, uint64_t))(v66 + 168))(a2, v66);
                                uint64_t v112 = v90;
                                uint64_t v113 = v111;
                                uint64_t v114 = *(void (**)(swift *, uint64_t))(v63 + 112);
                                v115 = v63;
                                int64_t v116 = v276;
                                v114(a2, v115);
                                int64_t v117 = v278;
                                int64_t v118 = swift_getAssociatedConformanceWitness( v115,  (uint64_t)a2,  v278,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
                                char v119 = (*(uint64_t (**)(uint64_t))(*(void *)(v118 + 8) + 120LL))(v117);
                                (*(void (**)(char *, uint64_t))(v277 + 8))(v116, v117);
                                uint64_t v120 = v279;
                                (*(void (**)(swift *, uint64_t))(v115 + 120))(a2, v115);
                                v71(v112, a2);
                                unint64_t v121 = v115;
                                unint64_t v122 = v281;
                                uint64_t v123 = swift_getAssociatedConformanceWitness( v121,  (uint64_t)a2,  v281,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
                                unint64_t v124 = (*(uint64_t (**)(uint64_t))(*(void *)(v123 + 8) + 120LL))(v122);
                                (*(void (**)(char *, uint64_t))(v280 + 8))(v120, v122);
                                _H8 = (v113 << 15) | ((v119 & 0x1F) << 10) | v124 & 0x3FF;
                              }

                              __asm { FCVT            S8, H8 }

                              goto LABEL_29;
                            }

                            specialized static BinaryFloatingPoint._convert<A>(from:)( (int *)&v291,  v72,  (uint64_t)a2,  v63);
                            v71((char *)v72, a2);
                            _S8 = v291;
LABEL_29:
                            uint64_t v62 = 0;
                            uint64_t v61 = _S8;
                            goto LABEL_30;
                          }

                          __break(1u);
                          goto LABEL_111;
                        }

  Swift::String v85 = v255(a2, v62);
  Swift::Int v86 = (*(uint64_t (**)(swift *, uint64_t))(v62 + 104))(a2, v62);
  if (v85 == 11)
  {
    if (v86 == 52)
    {
      uint64_t v90 = v270;
      v64((char *)v270, v71, a2);
      LODWORD(v90) = swift_dynamicCast((char *)&v289, v90, a2, (const char *)&type metadata for Double, 6uLL);
      _D8 = *(double *)&v289;
      uint64_t v92 = v273;
      (*(void (**)(char *, uint64_t, swift *))(v284 + 32))(v273, v71, a2);
      if ((_DWORD)v90)
      {
        v70(v92, a2);
      }

      else
      {
        unint64_t v127 = (*(uint64_t (**)(swift *, uint64_t))(v65 + 168))(a2, v65);
        unint64_t v128 = v92;
        Swift::String v129 = v127;
        v130 = *(void (**)(swift *, uint64_t))(v62 + 112);
        v131 = v62;
        uint64_t v132 = v274;
        v130(a2, v131);
        BOOL v133 = v276;
        uint64_t v134 = swift_getAssociatedConformanceWitness( v131,  (uint64_t)a2,  v276,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        v135 = (*(uint64_t (**)(uint64_t))(*(void *)(v134 + 8) + 120LL))(v133);
        (*(void (**)(char *, uint64_t))(v275 + 8))(v132, v133);
        char v136 = v277;
        (*(void (**)(swift *, uint64_t))(v131 + 120))(a2, v131);
        v70(v128, a2);
        v137 = v131;
        v138 = v279;
        v139 = swift_getAssociatedConformanceWitness( v137,  (uint64_t)a2,  v279,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        v140 = (*(uint64_t (**)(uint64_t))(*(void *)(v139 + 8) + 120LL))(v138);
        (*(void (**)(char *, uint64_t))(v278 + 8))(v136, v138);
        *(void *)&_D8 = (v129 << 63) | ((unint64_t)(v135 & 0x7FF) << 52) | v140 & 0xFFFFFFFFFFFFFLL;
      }

      return *(void *)&_D8;
    }
  }

  else if (v85 == 8)
  {
    if (v86 == 23)
    {
      unint64_t v93 = v269;
      v64((char *)v269, v71, a2);
      LODWORD(v93) = swift_dynamicCast((char *)&v289, v93, a2, (const char *)&type metadata for Float, 6uLL);
      uint64_t v94 = *(float *)&v289;
      uint64_t v95 = v272;
      (*(void (**)(char *, uint64_t, swift *))(v284 + 32))(v272, v71, a2);
      if ((_DWORD)v93)
      {
        v70(v95, a2);
        _D8 = v94;
      }

      else
      {
        v141 = (*(uint64_t (**)(swift *, uint64_t))(v65 + 168))(a2, v65);
        unint64_t v142 = v95;
        v143 = v141;
        unint64_t v144 = *(void (**)(swift *, uint64_t))(v62 + 112);
        v145 = v62;
        v146 = v274;
        v144(a2, v145);
        v147 = v276;
        uint64_t v148 = swift_getAssociatedConformanceWitness( v145,  (uint64_t)a2,  v276,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        v149 = (*(uint64_t (**)(uint64_t))(*(void *)(v148 + 8) + 120LL))(v147);
        (*(void (**)(char *, uint64_t))(v275 + 8))(v146, v147);
        v150 = v277;
        (*(void (**)(swift *, uint64_t))(v145 + 120))(a2, v145);
        v70(v142, a2);
        v151 = v145;
        unint64_t v152 = v279;
        v153 = swift_getAssociatedConformanceWitness( v151,  (uint64_t)a2,  v279,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        unint64_t v154 = (*(uint64_t (**)(uint64_t))(*(void *)(v153 + 8) + 120LL))(v152);
        (*(void (**)(char *, uint64_t))(v278 + 8))(v150, v152);
        _D8 = COERCE_FLOAT((v143 << 31) | (v149 << 23) | v154 & 0x7FFFFF);
      }

      return *(void *)&_D8;
    }
  }

  else if (v85 == 5 && v86 == 10)
  {
    uint64_t v87 = v268;
    v64((char *)v268, v71, a2);
    LODWORD(v87) = swift_dynamicCast((char *)&v289, v87, a2, (const char *)&type metadata for Float16, 6uLL);
    _H8 = v289;
    int64_t v89 = v271;
    (*(void (**)(char *, uint64_t, swift *))(v284 + 32))(v271, v71, a2);
    if ((_DWORD)v87)
    {
      v70(v89, a2);
    }

    else
    {
      uint64_t v109 = (*(uint64_t (**)(swift *, uint64_t))(v65 + 168))(a2, v65);
      uint64_t v110 = v89;
      v111 = v109;
      uint64_t v112 = *(void (**)(swift *, uint64_t))(v62 + 112);
      uint64_t v113 = v62;
      uint64_t v114 = v274;
      v112(a2, v113);
      v115 = v276;
      int64_t v116 = swift_getAssociatedConformanceWitness( v113,  (uint64_t)a2,  v276,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      int64_t v117 = (*(uint64_t (**)(uint64_t))(*(void *)(v116 + 8) + 120LL))(v115);
      (*(void (**)(char *, uint64_t))(v275 + 8))(v114, v115);
      int64_t v118 = v277;
      (*(void (**)(swift *, uint64_t))(v113 + 120))(a2, v113);
      v70(v110, a2);
      char v119 = v113;
      uint64_t v120 = v279;
      unint64_t v121 = swift_getAssociatedConformanceWitness( v119,  (uint64_t)a2,  v279,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      unint64_t v122 = (*(uint64_t (**)(uint64_t))(*(void *)(v121 + 8) + 120LL))(v120);
      (*(void (**)(char *, uint64_t))(v278 + 8))(v118, v120);
      _H8 = (v111 << 15) | ((v117 & 0x1F) << 10) | v122 & 0x3FF;
    }

    __asm { FCVT            D8, H8 }

    return *(void *)&_D8;
  }

  specialized static BinaryFloatingPoint._convert<A>(from:)((unint64_t *)&v289, v71, (uint64_t)a2, v62);
  v70((char *)v71, a2);
  _D8 = *(double *)&v289;
  return *(void *)&_D8;
}

        v213 = v58;
        unsigned int v73 = v230(a3, v44);
        unint64_t v74 = v211;
        uint64_t v75 = v211(a4, a6);
        BOOL v76 = v214(a4, a6);
        if ((v75 & 1) != 0)
        {
          if (v76 > 64)
          {
            v232[0] = v73;
            uint64_t v79 = v74;
            uint64_t v80 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
            unint64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
            v80(v232, &type metadata for Int, v81, a4, a6);
            unint64_t v74 = v79;
            uint64_t v82 = v229;
            uint64_t v83 = (*(uint64_t (**)(uint64_t, void, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v56,  v229,  a4);
            v213((char *)v56, a4);
            Swift::Int v84 = v212;
            if ((v83 & 1) == 0)
            {
              Swift::String v85 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
              goto LABEL_32;
            }

            goto LABEL_52;
          }
        }

        else if (v76 > 63)
        {
          Swift::String v85 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
          char v101 = v205;
          uint64_t v102 = ((uint64_t (*)(char *, void, void (*)(char *, uint64_t)))v85)(v205, v229, a4);
          Swift::Int v84 = v212;
          if (v73 < 0)
          {
            v213(v101, a4);
            goto LABEL_52;
          }

          v232[0] = v73;
          uint64_t v105 = v74;
          uint64_t v106 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
          uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v102, v103, v104);
          v106(v232, &type metadata for Int, v107, a4, a6);
          unint64_t v74 = v105;
          uint64_t v108 = (*(uint64_t (**)(uint64_t, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                                  + 16LL))( v56,  v101,  a4);
          uint64_t v109 = v213;
          v213((char *)v56, a4);
          v109(v101, a4);
          uint64_t v82 = v229;
          if ((v108 & 1) != 0)
          {
LABEL_52:
            uint64_t v44 = v223;
            v222 = v230(a3, v223);
LABEL_57:
            uint64_t v100 = v228;
            uint64_t v71 = v225;
            goto LABEL_58;
          }

    __break(1u);
    return (*((uint64_t (**)(char *, char *, uint64_t))v18 + 4))(v12, v15, a3);
  }

  v31(v15, a3);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4) > v32)
  {
    Swift::Bool v33 = ((uint64_t (*)(char *, uint64_t))v31)(v52, a3);
    uint64_t v53 = v32;
    uint64_t v34 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v26 + 96);
    int64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v33, v35, v36);
    uint64_t v38 = v46;
    v34(&v53, &type metadata for Int, v37, a3, v26);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 200))(v51, v38, a3, a4);
    return ((uint64_t (*)(char *, uint64_t))v31)(v38, a3);
  }

  return (*((uint64_t (**)(char *, char *, uint64_t))v18 + 4))(v47, v52, a3);
}

        v213 = v58;
        unsigned int v73 = v230(a3, v44);
        unint64_t v74 = v211;
        uint64_t v75 = v211(a4, a6);
        BOOL v76 = v214(a4, a6);
        if ((v75 & 1) != 0)
        {
          if (v76 > 64)
          {
            v232[0] = v73;
            uint64_t v79 = v74;
            uint64_t v80 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
            unint64_t v81 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
            v80(v232, &type metadata for Int, v81, a4, a6);
            unint64_t v74 = v79;
            uint64_t v82 = v229;
            uint64_t v83 = (*(uint64_t (**)(char *, void, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                                  + 16LL))( v56,  v229,  a4);
            v213(v56, a4);
            Swift::Int v84 = v212;
            if ((v83 & 1) == 0)
            {
              Swift::String v85 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
              goto LABEL_32;
            }

            goto LABEL_52;
          }
        }

        else if (v76 > 63)
        {
          Swift::String v85 = *(void (**)(char *, uint64_t, uint64_t))(v24 + 16);
          char v101 = v205;
          uint64_t v102 = ((uint64_t (*)(char *, void, void (*)(char *, uint64_t)))v85)(v205, v229, a4);
          Swift::Int v84 = v212;
          if (v73 < 0)
          {
            v213(v101, a4);
            goto LABEL_52;
          }

          v232[0] = v73;
          uint64_t v105 = v74;
          uint64_t v106 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a6 + 96);
          uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v102, v103, v104);
          v106(v232, &type metadata for Int, v107, a4, a6);
          unint64_t v74 = v105;
          uint64_t v108 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a6 + 32) + 8LL)
                                                                                                 + 16LL))( v56,  v101,  a4);
          uint64_t v109 = v213;
          v213(v56, a4);
          v109(v101, a4);
          uint64_t v82 = v229;
          if ((v108 & 1) != 0)
          {
LABEL_52:
            uint64_t v44 = v222;
            uint64_t v21 = v230(a3, v222);
LABEL_57:
            uint64_t v100 = v227;
            uint64_t v71 = v224;
            goto LABEL_58;
          }

    __break(1u);
    return ((uint64_t (*)(char *, char *, uint64_t))v19[4])(v12, v43, a3);
  }

  v28(v43, a3);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4) > v29)
  {
    uint64_t v30 = ((uint64_t (*)(char *, uint64_t))v28)(v27, a3);
    uint64_t v49 = v29;
    uint64_t v31 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    uint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v30, v32, v33);
    v31(&v49, &type metadata for Int, v34, a3, v7);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a4 + 216))(v48, v17, a3, a4);
    return ((uint64_t (*)(char *, uint64_t))v28)(v17, a3);
  }

  return ((uint64_t (*)(char *, char *, uint64_t))v19[4])(v44, v27, a3);
}

    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  (char *)0xD000000000000051LL,  0x80000001818BAC10LL,  "Swift/Int128.swift",  18LL,  2,  0x99uLL,  0);
  }

  if (__PAIR128__(v19, result) >= __PAIR128__(0x8000000000000000LL, 1LL)) {
    _assertionFailure(_:_:file:line:flags:)( "Precondition failed",  19LL,  2LL,  (char *)0xD00000000000001ELL,  0x80000001818BAC70LL,  "Swift/Integers.swift",  20LL,  2,  0xEBEuLL,  0);
  }
  BOOL result = -result;
  uint64_t v21 = v25;
  if (v25 < 0) {
    goto LABEL_16;
  }
LABEL_11:
  uint64_t v22 = v24;
  uint64_t v23 = (unsigned __int128)-(__int128)__PAIR128__(v20, v24) >> 64;
  if (v9 < 0)
  {
    uint64_t v22 = -(uint64_t)v24;
    uint64_t v21 = v23;
  }

  *a1 = v22;
  a1[1] = v21;
  return result;
}

        __break(1u);
        goto LABEL_17;
      }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    default:
      uint64_t v5 = 0;
      break;
  }

  if ((HIBYTE(a1) & 0x7F) <= 3u) {
    uint64_t v9 = (0xDu >> (HIBYTE(a1) & 0xF)) & 1;
  }
  else {
    uint64_t v9 = 1;
  }
  InstantiateKeyPathBuffer.visitStoredComponent(kind:mutable:offset:)(v9, (a1 & 0x800000) != 0, rawValue, v5);
}

    Swift::Int v63 = (v36 - 1) & v36;
  }

    uint64_t v32 = v17 >> 6;
    Swift::Bool v33 = 1LL << v17;
    goto LABEL_24;
  }

  if ((v57 & 1) != 0)
  {
    _NativeSet.resize(capacity:)(v28);
    uint64_t v31 = v54;
  }

  else
  {
    uint64_t v31 = v54;
    if (v29 >= v28)
    {
      _NativeSet.copy()();
      if ((v24 & 1) != 0) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }

    _NativeSet.copyAndResize(capacity:)(v28);
  }

  uint64_t v34 = *v25;
  uint64_t v35 = ((uint64_t (*)(void, uint64_t, uint64_t))v53[0])(*(void *)(*v25 + 40), v5, v31);
  uint64_t v36 = -1LL << *(_BYTE *)(v34 + 32);
  uint64_t v17 = v35 & ~v36;
  uint64_t v32 = v17 >> 6;
  uint64_t v58 = v34 + 56;
  uint64_t v59 = v34;
  Swift::Bool v33 = 1LL << v17;
  if (((1LL << v17) & *(void *)(v34 + 56 + 8 * (v17 >> 6))) == 0) {
    goto LABEL_23;
  }
  uint64_t v57 = ~v36;
  int64_t v37 = *(void *)(v31 + 8);
  uint64_t v38 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v37 + 8);
  uint64_t v39 = *(void *)(v61 + 72);
  unint64_t v40 = *(void (**)(char *, unint64_t, uint64_t))(v61 + 16);
  do
  {
    uint64_t v30 = v39 * v17;
    v40(v8, *(void *)(v59 + 48) + v39 * v17, v5);
    uint64_t v41 = v38(v8, v60, v5, v37);
    (*(void (**)(char *, uint64_t))(v61 + 8))(v8, v5);
    if ((v41 & 1) != 0)
    {
      uint64_t v25 = v56;
      if ((v24 & 1) != 0) {
        goto LABEL_27;
      }
LABEL_31:
      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v5);
    }

    uint64_t v17 = (v17 + 1) & v57;
    uint64_t v32 = v17 >> 6;
    Swift::Bool v33 = 1LL << v17;
  }

  while ((*(void *)(v58 + 8 * (v17 >> 6)) & (1LL << v17)) != 0);
  uint64_t v25 = v56;
LABEL_23:
  if ((v24 & 1) != 0) {
    goto LABEL_31;
  }
LABEL_24:
  id v42 = *v25;
  *(void *)(*v25 + 8 * v32 + 56) |= v33;
  uint64_t v43 = v61;
  (*(void (**)(unint64_t, uint64_t, uint64_t))(v61 + 32))( *(void *)(v42 + 48) + *(void *)(v61 + 72) * v17,  v60,  v5);
  uint64_t v44 = *(void *)(v42 + 16);
  uint64_t v45 = __OFADD__(v44, 1LL);
  BOOL v46 = v44 + 1;
  if (v45)
  {
LABEL_30:
    __break(1u);
    goto LABEL_31;
  }

  *(void *)(v42 + 16) = v46;
  uint64_t v47 = 1LL;
  uint64_t v48 = v55;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v43 + 56))(v48, v47, 1LL, v5);
}

      _StringGuts.append(_:)(a2, a3, 0LL, v27);
      swift_bridgeObjectRelease(a3);
LABEL_17:
      _print_unlocked<A, B>(_:_:)( (uint64_t)v41,  (uint64_t)a6,  (swift *)byte_189B8D218,  (uint64_t)&type metadata for String,  (uint64_t)&protocol witness table for String);
      __swift_destroy_boxed_opaque_existential_1Tm(v41);
      swift_bridgeObjectRetain(a3, v28, v29, v30);
      v26 += 32LL;
      if (!--v24) {
        goto LABEL_11;
      }
    }

    uint64_t v27 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000LL) != 0) {
      goto LABEL_16;
    }
LABEL_15:
    uint64_t v27 = a2 & 0xFFFFFFFFFFFFLL;
    goto LABEL_16;
  }

    Swift::Int v14 = 1860LL;
LABEL_17:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v14,  0);
  }

  v17[0] = v2;
  v17[1] = v3 & 0xFFFFFFFFFFFFFFLL;
  if (startingAt < 0) {
    goto LABEL_16;
  }
  if ((uint64_t)(HIBYTE(v3) & 0xF) < endingAt)
  {
LABEL_14:
    Swift::Int v14 = 1861LL;
    goto LABEL_17;
  }

  uint64_t v12 = endingAt - startingAt;
  if (endingAt - startingAt < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t countAndFlagsBits = specialized static String._uncheckedFromUTF8(_:)((uint8x16_t *)((char *)v17 + startingAt), v12);
LABEL_19:
  result._uint64_t object = object;
  result._uint64_t countAndFlagsBits = countAndFlagsBits;
  return result;
}

    uint64_t v9 = 1LL;
    uint64_t v10 = *v0;
    uint64_t v11 = v0[1];
    if ((v11 & 0x1000000000000000LL) != 0)
    {
LABEL_31:
      uint64_t v17 = _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v1, v6);
      uint64_t object = v17._object;
      uint64_t countAndFlagsBits = v17._countAndFlagsBits;
      goto LABEL_28;
    }

    uint64_t v68 = v28;
    unint64_t v69 = v29;
    uint64_t v34 = *(void *)a1;
    Swift::Bool v33 = *(void *)(a1 + 8);
    goto LABEL_17;
  }

  uint64_t v55 = *(void *)(a1 + 16);
  uint64_t v56 = *(void *)(a1 + 24);
  uint64_t v57 = *(void *)a1 >> 16;
  uint64_t v58 = *(void *)(a1 + 8) >> 16;
  uint64_t v59 = *(void *)(a2 + 16);
  uint64_t v60 = *(void *)(a2 + 24);
  uint64_t v61 = *(void *)a2 >> 16;
  uint64_t v62 = *(void *)(a2 + 8) >> 16;
  if (v55 != v59 || v56 != v60 || v57 != v61 || v58 != v62) {
    return _stringCompareInternal(_:_:_:_:expecting:)(v55, v56, v57, v58, v59, v60, v61, v62, 1) & 1;
  }
  uint64_t v53 = 0;
  return v53 & 1;
}

    uint64_t v15 = v8 & 0xFC00FC00;
    if ((v8 & 0xFC00FC00) == 0xDC00D800) {
      uint64_t v16 = 32;
    }
    else {
      uint64_t v16 = 16;
    }
    uint64_t v44 = v9 - v16;
    if (v15 == -603924480) {
      uint64_t v17 = 32;
    }
    else {
      uint64_t v17 = 16;
    }
    uint64_t v43 = (unint64_t)v8 >> v17;
    if (v15 == -603924480)
    {
      uint64_t v18 = 0;
      goto LABEL_25;
    }

    uint64_t v26 = v7[1].u64[0];
    uint64_t v25 = v7[1].u64[1];
    uint64_t v27 = v25 >> 1;
    uint64_t v28 = v26 + 1;
    if (v25 >> 1 <= v26)
    {
      uint64_t v35 = v11;
      uint64_t v4 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v25 > 1),  v26 + 1,  1,  (uint64_t)v7);
      uint64_t v11 = v35;
      uint64_t v7 = (uint8x16_t *)v4;
      uint64_t v25 = (unint64_t)v4[3];
      uint64_t v27 = v25 >> 1;
    }

    v7[1].i64[0] = v28;
    v7[2].i8[v26] = -17;
    Swift::Int v29 = v26 + 2;
    if (v27 <= v28)
    {
      uint64_t v4 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v25 > 1),  v26 + 2,  1,  (uint64_t)v7);
      uint64_t v11 = &type metadata for Unicode.UTF16.ForwardParser;
      Swift::Int v29 = v26 + 2;
      uint64_t v28 = v26 + 1;
      uint64_t v7 = (uint8x16_t *)v4;
      uint64_t v25 = (unint64_t)v4[3];
      uint64_t v27 = v25 >> 1;
    }

    v7[1].i64[0] = v29;
    v7[2].i8[v28] = -65;
    uint64_t v30 = v26 + 3;
    if (v27 <= v29)
    {
      uint64_t v31 = v29;
      uint64_t v32 = v11;
      uint64_t v4 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v25 > 1),  v30,  1,  (uint64_t)v7);
      uint64_t v11 = v32;
      Swift::Int v29 = v31;
      uint64_t v7 = (uint8x16_t *)v4;
    }

    v7[1].i64[0] = v30;
    v7[2].i8[v29] = -67;
LABEL_6:
    uint64_t v9 = v44;
    Swift::Int v8 = v43;
  }

  if (a1 && a1 != v10)
  {
    uint64_t v12 = *a1;
    uint64_t v13 = a1 + 1;
    if ((v12 & 0xF800) == 0xD800)
    {
      Swift::Int v8 = v8 & 0xFFFF0000 | v12;
      uint64_t v9 = 16;
      ++a1;
      if (v13 == v10) {
        goto LABEL_16;
      }
      goto LABEL_12;
    }

    uint64_t v18 = 1;
    ++a1;
    Swift::Int v8 = v12;
LABEL_25:
    if ((unsigned __int16)v8 < 0x80u)
    {
      uint64_t v19 = (v8 + 1);
      if (!v19) {
        goto LABEL_6;
      }
      goto LABEL_27;
    }

    uint64_t v23 = (v8 & 0x3F) << 8;
    if ((unsigned __int16)v8 < 0x800u)
    {
      uint64_t v19 = (v23 | ((unsigned __int16)v8 >> 6)) + 33217;
      goto LABEL_27;
    }

    if ((v8 & 0xF800) != 0xD800)
    {
      Swift::Bool v33 = ((v23 | ((unsigned __int16)v8 >> 6) & 0x3F) << 8) | ((unsigned __int16)v8 >> 12);
LABEL_47:
      uint64_t v34 = 8487393;
LABEL_48:
      uint64_t v19 = v33 + v34;
      goto LABEL_27;
    }

    if ((v18 & 1) == 0)
    {
      uint64_t v36 = ((v8 & 0x3FF) << 10) | HIWORD(v8) & 0x3FF;
      Swift::Bool v33 = ((v36 + 0x10000) >> 4) & 0x3F00 | ((v36 + 0x10000) >> 18) | (((v36 >> 6) & 0x3F | (((v36 + 0x10000) & 0x3F) << 8)) << 16);
      uint64_t v34 = -2122219023;
      goto LABEL_48;
    }

    if ((unsigned __int16)v8 >= 0x80u)
    {
      int64_t v37 = (v8 & 0x3F) << 8;
      if ((unsigned __int16)v8 >= 0x800u)
      {
        Swift::Bool v33 = ((unsigned __int16)v8 >> 12) | ((v37 | ((unsigned __int16)v8 >> 6) & 0x3F) << 8);
        goto LABEL_47;
      }

      uint64_t v19 = (v37 | ((unsigned __int16)v8 >> 6)) + 33217;
    }

    else
    {
      uint64_t v19 = (unsigned __int16)v8 + 1;
    }

    uint64_t v16 = v8 & 0xFC00FC00;
    if ((v8 & 0xFC00FC00) == 0xDC00D800) {
      uint64_t v17 = 32;
    }
    else {
      uint64_t v17 = 16;
    }
    uint64_t v52 = v9 - v17;
    if (v16 == -603924480) {
      uint64_t v18 = 32;
    }
    else {
      uint64_t v18 = 16;
    }
    uint64_t v51 = (unint64_t)v8 >> v18;
    if (v16 == -603924480)
    {
      uint64_t v19 = 0;
      goto LABEL_25;
    }

    uint64_t v28 = v7[1].u64[0];
    uint64_t v27 = v7[1].u64[1];
    Swift::Int v29 = v27 >> 1;
    uint64_t v30 = v28 + 1;
    if (v27 >> 1 <= v28)
    {
      uint64_t v38 = v12;
      uint64_t v39 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v27 > 1),  v28 + 1,  1,  (uint64_t)v7);
      uint64_t v12 = v38;
      uint64_t v7 = (uint8x16_t *)v39;
      uint64_t v27 = (unint64_t)v39[3];
      Swift::Int v29 = v27 >> 1;
    }

    v7[1].i64[0] = v30;
    v7[2].i8[v28] = -17;
    uint64_t v31 = v28 + 2;
    if (v29 <= v30)
    {
      unint64_t v40 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v27 > 1),  v28 + 2,  1,  (uint64_t)v7);
      uint64_t v12 = &type metadata for Unicode.UTF16.ForwardParser;
      uint64_t v31 = v28 + 2;
      uint64_t v30 = v28 + 1;
      uint64_t v7 = (uint8x16_t *)v40;
      uint64_t v27 = (unint64_t)v40[3];
      Swift::Int v29 = v27 >> 1;
    }

    v7[1].i64[0] = v31;
    v7[2].i8[v30] = -65;
    uint64_t v32 = v28 + 3;
    if (v29 <= v31)
    {
      Swift::Bool v33 = v31;
      uint64_t v34 = v12;
      uint64_t v35 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v27 > 1),  v32,  1,  (uint64_t)v7);
      uint64_t v12 = v34;
      uint64_t v31 = v33;
      uint64_t v7 = (uint8x16_t *)v35;
    }

    v7[1].i64[0] = v32;
    v7[2].i8[v31] = -67;
    uint64_t v10 = 1LL;
LABEL_6:
    uint64_t v9 = v52;
    Swift::Int v8 = v51;
  }

  if (a1 && a1 != v11)
  {
    uint64_t v13 = *a1;
    Swift::Int v14 = a1 + 1;
    if ((v13 & 0xF800) == 0xD800)
    {
      Swift::Int v8 = v8 & 0xFFFF0000 | v13;
      uint64_t v9 = 16;
      ++a1;
      if (v14 == v11) {
        goto LABEL_16;
      }
      goto LABEL_12;
    }

    uint64_t v19 = 1;
    ++a1;
    Swift::Int v8 = v13;
LABEL_25:
    if ((unsigned __int16)v8 < 0x80u)
    {
      uint64_t v20 = (v8 + 1);
      if (!v20) {
        goto LABEL_6;
      }
      goto LABEL_27;
    }

    uint64_t v25 = (v8 & 0x3F) << 8;
    if ((unsigned __int16)v8 < 0x800u)
    {
      uint64_t v20 = (v25 | ((unsigned __int16)v8 >> 6)) + 33217;
      goto LABEL_27;
    }

    if ((v8 & 0xF800) != 0xD800)
    {
      uint64_t v36 = ((v25 | ((unsigned __int16)v8 >> 6) & 0x3F) << 8) | ((unsigned __int16)v8 >> 12);
LABEL_47:
      int64_t v37 = 8487393;
LABEL_48:
      uint64_t v20 = v36 + v37;
      goto LABEL_27;
    }

    if (!v19)
    {
      uint64_t v41 = ((v8 & 0x3FF) << 10) | HIWORD(v8) & 0x3FF;
      uint64_t v36 = ((v41 + 0x10000) >> 4) & 0x3F00 | ((v41 + 0x10000) >> 18) | (((v41 >> 6) & 0x3F | (((v41 + 0x10000) & 0x3F) << 8)) << 16);
      int64_t v37 = -2122219023;
      goto LABEL_48;
    }

    if ((unsigned __int16)v8 >= 0x80u)
    {
      id v42 = (v8 & 0x3F) << 8;
      if ((unsigned __int16)v8 >= 0x800u)
      {
        uint64_t v36 = ((unsigned __int16)v8 >> 12) | ((v42 | ((unsigned __int16)v8 >> 6) & 0x3F) << 8);
        goto LABEL_47;
      }

      uint64_t v20 = (v42 | ((unsigned __int16)v8 >> 6)) + 33217;
    }

    else
    {
      uint64_t v20 = (unsigned __int16)v8 + 1;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    uint64_t v26 = validateUTF8(_:)(a1->i64, v22);
    if ((v28 & 1) != 0) {
      repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v22, v26, v27);
    }
    else {
      specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v22, v26 & 1);
    }
    return 15LL;
  }

  uint64_t v61 = v8;
  uint64_t v36 = *(uint64_t (**)(unint64_t *, uint64_t))(v8 + 64);
  uint64_t v58 = *(void *)(v12 + 16);
  uint64_t v59 = v36;
  for (uint64_t i = a1; ; uint64_t i = (uint8x16_t *)((char *)v60 + *(void *)(v12 + 72)))
  {
    uint64_t v60 = i;
    ((void (*)(char *))v58)(v20);
    if ((v59(v11, v61) & 1) != 0) {
      break;
    }
    LODWORD(v57) = v59(v11, v61);
    unint64_t v40 = (*(uint64_t (**)(unint64_t *))(v61 + 128))(v11);
    if (v40 > 64) {
      goto LABEL_28;
    }
    uint64_t v43 = v62;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v63,  (uint64_t)v11,  v62,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v43,  AssociatedConformanceWitness);
    (*((void (**)(char *, unint64_t *))v63 + 3))(v10, v11);
    LOBYTE(v43) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v61 + 32) + 8LL)
                                                                                + 32LL))( v20,  v18,  v11);
    uint64_t v57 = *(void (**)(char *, unint64_t *))(v12 + 8);
    v57(v18, v11);
    (*(void (**)(char *, char *, unint64_t *))(v12 + 32))(v15, v20, v11);
    if ((v43 & 1) != 0)
    {
      uint64_t v45 = (*(uint64_t (**)(unint64_t *))(v61 + 120))(v11);
      v57(v15, v11);
      goto LABEL_38;
    }

    v57(v15, v11);
LABEL_29:
    ;
  }

  unint64_t v40 = (*(uint64_t (**)(unint64_t *))(v61 + 128))(v11);
LABEL_36:
  if (v40 >= 64)
  {
LABEL_28:
    v65[0] = 0LL;
    uint64_t v57 = *(void (**)(char *, unint64_t *))(v61 + 96);
    uint64_t v38 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    ((void (*)(void *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))v57)( v65,  &type metadata for Int,  v38,  v11,  v61);
    LODWORD(v57) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v61 + 16)
                                                                                             + 8LL)
                                                                                 + 8LL))( v20,  v18,  v11);
    uint64_t v39 = *(void (**)(char *, unint64_t *))(v12 + 8);
    v39(v18, v11);
    v39(v20, v11);
    goto LABEL_29;
  }

  uint64_t v45 = (*(uint64_t (**)(unint64_t *))(v61 + 120))(v11);
  (*(void (**)(char *, unint64_t *))(v12 + 8))(v20, v11);
LABEL_38:
  if (v45) {
    goto LABEL_29;
  }
LABEL_41:
  BOOL v46 = *(void *)(v12 + 72);
  if (!v46) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  if ((char *)v60 - (char *)a1 == 0x8000000000000000LL && v46 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  v65[0] = UnsafeBufferPointer.init(start:count:)((uint64_t)a1, ((char *)v60 - (char *)a1) / v46);
  v65[1] = v47;
  uint64_t v50 = (swift *)type metadata accessor for UnsafeBufferPointer(0LL, (uint64_t)v11, v48, v49);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, v50, v51);
  static String._fromCodeUnits<A, B>(_:encoding:repair:)((uint64_t)v65, (uint64_t)v64, 1, v50, a3, WitnessTable, a4);
  if (!v53) {
LABEL_45:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/CString.swift",  19LL,  2,  0x1E3uLL,  0);
  return 15LL;
}

  if (&full type metadata for [Character] == &full type metadata for String)
  {
    __break(1u);
  }

  else if (&full type metadata for [Character] != &full type metadata for Substring)
  {
    uint64_t v23 = (uint64_t)v7;
    specialized String.append<A>(contentsOf:)((uint64_t)v7, a2, a3, (char *)a4);
    swift_release(v23);
    return;
  }

  __break(1u);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v12 = *(void *)((v9 & 0xFFFFFFFFFFFFF8LL) + 0x10);
LABEL_6:
  uint64_t v13 = specialized _copyCollectionToContiguousArray<A>(_:)(a3, a4);
  if (a1 || v5 != v12)
  {
    specialized Array.replaceSubrange<A>(_:with:)(a1, v5, (uint64_t)v13);
  }

  else
  {
    Swift::Int v14 = *v10;
    char *v10 = (uint64_t)v13;
    swift_bridgeObjectRelease(v14);
  }

    uint64_t v16 = 1LL;
    uint64_t v17 = v11 + 1;
    if (!__OFADD__(v11, 1LL)) {
      goto LABEL_17;
    }
LABEL_28:
    __break(1u);
LABEL_29:
    __break(1u);
LABEL_30:
    uint64_t v12 = (char *)_StringObject.sharedUTF8.getter(a4, a5);
  }

          uint64_t v56 = 0LL;
          goto LABEL_31;
        }
      }

      else
      {
        uint64_t v68 = *(void (**)(unsigned __int8 *, uint64_t))(v39 + 8);
        v68(v42, v35);
        v68(v41, v35);
      }

      uint64_t v56 = 0LL;
      uint64_t v48 = v77;
      goto LABEL_31;
    }

    uint64_t v54 = v80;
  }

  else
  {
    unint64_t v81 = v12;
    uint64_t v82 = v27;
    v29((unsigned __int8 *)v23, v27, v17);
    uint64_t v49 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  a3,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    uint64_t v50 = *((int *)v49 + 12);
    uint64_t v32 = (char *)v23 + v50;
    uint64_t v51 = *((int *)v49 + 16);
    uint64_t v52 = *(_BYTE **)((char *)v23 + v51);
    uint64_t v53 = *((unsigned __int8 *)v23 + v51 + 8);
    if (swift_getEnumCaseMultiPayload(v28, v17) != 1)
    {
      LODWORD(v78) = v53;
      BOOL v76 = v52;
      uint64_t v57 = *v23;
      uint64_t v58 = *(void *)v28;
      uint64_t v59 = &v28[v50];
      uint64_t v79 = *(void *)&v28[v51];
      uint64_t v60 = v28[v51 + 8];
      uint64_t v61 = v80;
      uint64_t v62 = *(void (**)(_BYTE *, char *, uint64_t))(v80 + 32);
      v62(v14, v32, a3);
      Swift::Int v63 = v81;
      v62(v81, (char *)v59, a3);
      if (v57 == v58)
      {
        uint64_t v64 = (_BYTE *)v79;
        char v65 = (*(uint64_t (**)(_BYTE *, unsigned __int8 *, uint64_t))(v75 + 8))(v14, v63, a3);
        uint64_t v66 = v63;
        BOOL v67 = *(void (**)(_BYTE *, uint64_t))(v61 + 8);
        v67(v66, a3);
        v67(v14, a3);
        if ((v65 & 1) != 0)
        {
          if ((v78 & 1) != 0)
          {
            uint64_t v48 = v77;
            uint64_t v27 = v82;
            if ((v60 & 1) != 0)
            {
LABEL_30:
              uint64_t v56 = 1LL;
              goto LABEL_31;
            }
          }

          else
          {
            uint64_t v48 = v77;
            if (v76 == v64) {
              uint64_t v71 = v60;
            }
            else {
              uint64_t v71 = 1;
            }
            uint64_t v27 = v82;
            if ((v71 & 1) == 0) {
              goto LABEL_30;
            }
          }

          goto LABEL_16;
        }
      }

      else
      {
        unint64_t v69 = *(void (**)(_BYTE *, uint64_t))(v61 + 8);
        v69(v63, a3);
        v69(v14, a3);
      }

      uint64_t v56 = 0LL;
      uint64_t v48 = v77;
      uint64_t v27 = v82;
      goto LABEL_31;
    }

    uint64_t v54 = v80;
    uint64_t v27 = v82;
    uint64_t v35 = a3;
  }

  uint64_t v55 = v78;
  uint64_t v17 = v79;
  (*(void (**)(char *, uint64_t))(v54 + 8))(v32, v35);
  uint64_t v56 = 0LL;
  uint64_t v48 = v55;
LABEL_31:
  (*(void (**)(unsigned __int8 *, uint64_t))(v48 + 8))(v27, v17);
  return v56;
}

    swift_unknownObjectRelease(a1);
    uint64_t v30 = *(a5 - 1);
    uint64_t v13 = *(void *)(v30 + 72);
    uint64_t v20 = (*(unsigned __int8 *)(v30 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v30 + 80);
    uint64_t v15 = &_swiftEmptyArrayStorage;
LABEL_17:
    UnsafeMutablePointer.initialize(from:count:)((char *)(a2 + v13 * a3), v10, (char *)v15 + v20, (uint64_t)a5);
    return v15;
  }

  swift_unknownObjectRelease(a1);
  return v15;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    uint64_t v72 = (v35 - 1) & v35;
    Swift::Int v29 = __clz(__rbit64(v35)) + (v28 << 6);
    if (v71) {
      goto LABEL_5;
    }
  }

  *a1 = *(void *)a2;
  uint64_t v17 = ((unint64_t)a1 + v7 + 8) & v13;
  uint64_t v18 = (unint64_t)&a2[v7 + 8] & v13;
  (*(void (**)(uint64_t, uint64_t))(v6 + 16))(v17, v18);
  uint64_t v19 = (v8 + v18) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v20 = *(_BYTE *)(v19 + 8);
  uint64_t v21 = (v8 + v17) & 0xFFFFFFFFFFFFFFF8LL;
  *(void *)uint64_t v21 = *(void *)v19;
  *(_BYTE *)(v21 + 8) = v20;
  *((_BYTE *)v4 + v14) = v15 == 1;
  return v4;
}

    __break(1u);
    goto LABEL_17;
  }

  return result;
}

      uint64_t v13 = 0LL;
      Swift::Int v14 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 16);
      do
      {
        __dst = (char *)v14(&v7[v13], &__src[v13], a4);
        v13 += v9;
        --v5;
      }

      while (v5);
      return __dst;
    }

    uint64_t v11 = (uint64_t *)(a4 + 8);
    goto LABEL_14;
  }

  return __dst;
}

      uint64_t v13 = 0LL;
      Swift::Int v14 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 24);
      do
      {
        __dst = (char *)v14(&v7[v13], &__src[v13], a4);
        v13 += v9;
        --v5;
      }

      while (v5);
      return __dst;
    }

    uint64_t v11 = (uint64_t *)(a4 + 8);
    goto LABEL_14;
  }

  return __dst;
}

      uint64_t v13 = 0LL;
      Swift::Int v14 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 24);
      do
      {
        __dst = (char *)v14(&v7[v13], &__src[v13], a4);
        v13 += v9;
        --v5;
      }

      while (v5);
      return __dst;
    }

    uint64_t v11 = (uint64_t *)(a4 + 8);
    goto LABEL_14;
  }

  return __dst;
}

  if (v9 != MangledToPrettyFunctionNameCache + 32LL * dword_18C5757A8)
  {
    uint64_t v12 = *(void **)(v9 + 16);
    os_unfair_lock_unlock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
    return v12;
  }

    std::string::__init_copy_ctor_external( (std::string *)a4,  (const std::string::value_type *)*v16,  (std::string::size_type)v16[1]);
LABEL_40:
    *(_DWORD *)(a4 + 24) = 1;
    return;
  }

  a3[1] = *v16;
  uint64_t v31 = 0;
  a3[2] = *v14;
  uint64_t v27 = 0;
  swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v28, (uint64_t)v26);
  if (v27 != -1) {
    ((void (*)(char *, _BYTE *))off_189B8B2E0[v27])(&v32, v26);
  }
  uint64_t v22 = v31;
  if (!v31)
  {
    a3[4] = *v14;
    uint64_t v27 = 0;
    swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v28, (uint64_t)v26);
    if (v27 != -1) {
      ((void (*)(char *, _BYTE *))off_189B8B2E0[v27])(&v32, v26);
    }
    uint64_t v22 = v31;
    if (!v31)
    {
      a3[3] = *v14;
      uint64_t v27 = 0;
      swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v28, (uint64_t)v26);
      if (v27 != -1) {
        ((void (*)(char *, _BYTE *))off_189B8B2E0[v27])(&v32, v26);
      }
      uint64_t v22 = v31;
      if (!v31)
      {
        a3[5] = *v14;
        uint64_t v27 = 0;
        swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v28, (uint64_t)v26);
        if (v27 != -1) {
          ((void (*)(char *, _BYTE *))off_189B8B2E0[v27])(&v32, v26);
        }
        uint64_t v22 = v31;
        if (!v31)
        {
          *(_DWORD *)(a4 + 24) = 0;
LABEL_78:
          ((void (*)(_BYTE *, _BYTE *))off_189B8B2E0[v22])(v26, v28);
          return;
        }
      }
    }
  }

  if (v22 == 1) {
    uint64_t v23 = v28;
  }
  else {
    uint64_t v23 = 0LL;
  }
  unint64_t v24 = (uint64_t)&v30;
  if (v22 != 1) {
    unint64_t v24 = 23LL;
  }
  if (*(char *)v24 < 0)
  {
    uint64_t v18 = v22 == 1;
    uint64_t v25 = 8LL;
    if (v18) {
      uint64_t v25 = (uint64_t)&v29;
    }
    std::string::__init_copy_ctor_external((std::string *)a4, *(const std::string::value_type **)v23, *(void *)v25);
  }

  else
  {
    *(_OWORD *)a4 = *(_OWORD *)v23;
    *(void *)(a4 + 16) = *((void *)v23 + 2);
  }

  *(_DWORD *)(a4 + 24) = 1;
  uint64_t v22 = v31;
  if (v31 != -1) {
    goto LABEL_78;
  }
}

    uint64_t v18 = a2 + 1;
LABEL_17:
    uint64_t v16 = *v18;
    goto LABEL_18;
  }

  if ((_DWORD)v17 == 515 || (_DWORD)v17 == 516) {
    goto LABEL_16;
  }
LABEL_18:
  uint64_t v38 = v16;
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2, (uint64_t)v11, v12, v13);
  unint64_t v40 = v42;
  uint64_t v41 = 0x800000000LL;
  v42[32] = 0LL;
  v33[0] = off_189B8D5B0;
  v33[1] = &v37;
  uint64_t v34 = v33;
  v31[0] = off_189B8D5F8;
  v31[1] = &v37;
  uint64_t v32 = v31;
  swift_getTypeByMangledName(v35, a1, v14, v15, GenericArgs, v33, v31);
  uint64_t v19 = v32;
  if (v32 == v31)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = v31;
  }

  else
  {
    if (!v32) {
      goto LABEL_23;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_23:
  uint64_t v21 = v34;
  if (v34 == v33)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = v33;
    goto LABEL_27;
  }

  if (v34)
  {
    uint64_t v22 = 5LL;
LABEL_27:
    (*(void (**)(void))(*v21 + 8 * v22))();
  }

  if (v36)
  {
    if (v36 == 1)
    {
      unint64_t v24 = *(int *)(*v4 + 8) + *v4 + 8;
      uint64_t v25 = v29;
      __swift::__runtime::llvm::StringRef::str(v43, (uint64_t)v29);
      if (v30 < 0) {
        uint64_t v25 = (void *)v29[0];
      }
      uint64_t v26 = ((uint64_t (*)(void, void, void))v35[1])(v35[0], 0LL, 0LL);
      swift::fatalError( 0LL,  "failed to demangle superclass of %s from mangled name '%s': %s\n",  v27,  v28,  v24,  v25,  v26);
    }

    Swift::Int v8 = 0LL;
  }

  else
  {
    Swift::Int v8 = v35[0];
  }

  if (v40 != v42) {
    free(v40);
  }
  return v8;
}

    uint64_t v13 = *(_DWORD *)v9;
    Swift::Int v14 = *(_DWORD *)v9 & 0x1F;
    if (v14 != 3) {
      break;
    }
    if (*((_WORD *)a2 + 8) != 180) {
      return 0LL;
    }
    uint64_t v18 = *((unsigned __int8 *)a2 + 18);
    uint64_t v19 = a2;
    if (v18 == 2) {
      goto LABEL_28;
    }
    if (v18 == 5 && *((_DWORD *)a2 + 2) >= 2u)
    {
      uint64_t v19 = *(const char **)a2;
LABEL_28:
      uint64_t v20 = *((void *)v19 + 1);
      goto LABEL_55;
    }

    uint64_t v20 = 0LL;
LABEL_55:
    if (*(_WORD *)(v20 + 16) != 101) {
      return 0LL;
    }
    uint64_t v39 = *(void *)(v20 + 8);
    unint64_t v40 = &v9[*((int *)v9 + 2) + 8];
    if (v18 != 5) {
      goto LABEL_22;
    }
LABEL_218:
    if (!*((_DWORD *)a2 + 2)) {
      goto LABEL_22;
    }
    a2 = *(const char **)a2;
LABEL_220:
    a2 = *(const char **)a2;
LABEL_242:
    v135 = *((int *)v9 + 1);
    uint64_t v134 = (unsigned int *)(v9 + 4);
    BOOL v133 = v135;
    if ((_DWORD)v135)
    {
      uint64_t v9 = (char *)v134 + (v133 & 0xFFFFFFFFFFFFFFFELL);
      if ((v133 & 1) != 0) {
        uint64_t v9 = *(const char **)v9;
      }
      if (v9) {
        continue;
      }
    }

    return a2 == 0LL;
  }

  if (v14 != 1)
  {
    if (!v14)
    {
      if (*((_WORD *)a2 + 8) != 153) {
        return 0LL;
      }
      uint64_t v15 = *(const char **)a2;
      uint64_t v16 = *((void *)a2 + 1);
      uint64_t v17 = &v9[*((int *)v9 + 2) + 8];
      if (strncmp(v15, v17, v16) || strlen(v17) != v16) {
        return 0LL;
      }
LABEL_22:
      a2 = 0LL;
      goto LABEL_242;
    }

    if ((v13 & 0x10) != 0) {
      uint64_t v28 = (char *)v9;
    }
    else {
      uint64_t v28 = 0LL;
    }
    if ((v13 & 0x10) == 0) {
      return 0LL;
    }
    LOBYTE(v157) = 0;
    LOBYTE(v168) = 0;
    Swift::Int v29 = *((unsigned __int16 *)a2 + 8);
    if (v29 <= 0xA6)
    {
      if (v29 == 24)
      {
        if ((*(_DWORD *)v9 & 0x1F) != 0x10) {
          return 0LL;
        }
      }

      else if (v29 != 61 || (*(_DWORD *)v9 & 0x1F) != 0x12)
      {
        return 0LL;
      }

      goto LABEL_96;
    }

    if (v29 == 167)
    {
LABEL_96:
      uint64_t v64 = 0;
      char v65 = 1;
      goto LABEL_123;
    }

    if (v29 != 234)
    {
      if (v29 != 219) {
        return 0LL;
      }
      uint64_t v30 = *(_DWORD *)v9;
      if ((*(_DWORD *)v9 & 0x1F) != 0x11)
      {
        uint64_t v31 = (unsigned int *)(v9 + 8);
        uint64_t v32 = *((int *)v9 + 2);
        Swift::Bool v33 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))&v9[v32 + 8];
        if (v33)
        {
          uint64_t v34 = strlen(&v9[v32 + 8]);
          if ((v30 & 0x40000) == 0) {
            goto LABEL_53;
          }
LABEL_102:
          v200 = 0LL;
          v201[0] = 0LL;
          v199 = 0LL;
          uint64_t v148 = v34;
          BOOL v67 = (char *)v33 + v34;
          uint64_t v68 = v33;
          unint64_t v69 = (char *)v33 + v34 + 1;
          unint64_t v70 = strlen(v69);
          if (v70)
          {
            v153 = v28;
            uint64_t v35 = 0LL;
            uint64_t v10 = 0LL;
            v143 = v68;
            int64_t v37 = v68;
            uint64_t v7 = 0LL;
            uint64_t v71 = v67;
            while (1)
            {
              unsigned int v73 = *((unsigned __int8 *)v67 + 1);
              switch(v73)
              {
                case 'S':
                  uint64_t v7 = (char *)(v67 + 2);
                  uint64_t v72 = &v200;
                  break;
                case 'R':
                  uint64_t v10 = (void (***)(swift::Demangle::__runtime::Demangler *__hidden))(v67 + 2);
                  uint64_t v72 = &v199;
                  break;
                case 'N':
                  uint64_t v35 = (uint64_t)(v67 + 2);
                  uint64_t v72 = v201;
                  int64_t v37 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))(v67 + 2);
                  break;
                default:
                  goto LABEL_106;
              }

              uint64_t v71 = &v69[v70];
              void *v72 = v70 - 1;
LABEL_106:
              BOOL v67 = &v69[v70];
              v69 += v70 + 1;
              unint64_t v70 = strlen(v69);
              if (!v70)
              {
                uint64_t v31 = (unsigned int *)v200;
                uint64_t v32 = v201[0];
                BOOL v67 = v71;
                Swift::Int v2 = v199;
                uint64_t v28 = v153;
                Swift::Bool v33 = v143;
                goto LABEL_120;
              }
            }
          }

          Swift::Int v2 = 0LL;
          uint64_t v31 = 0LL;
          uint64_t v32 = 0LL;
          uint64_t v35 = 0LL;
          uint64_t v10 = 0LL;
          int64_t v37 = v68;
          Swift::Bool v33 = v68;
          uint64_t v7 = 0LL;
LABEL_120:
          uint64_t v38 = (const char *)(v67 - (const char *)v37);
          uint64_t v36 = 1;
          uint64_t v34 = v148;
        }

        else
        {
          uint64_t v34 = 0LL;
          if ((v30 & 0x40000) != 0) {
            goto LABEL_102;
          }
LABEL_53:
          uint64_t v35 = 0LL;
          uint64_t v36 = 0;
          int64_t v37 = v33;
          uint64_t v38 = (const char *)v34;
        }

        uint64_t v157 = v33;
        v158 = v34;
        v159 = (char *)v37;
        v160 = (char *)v38;
        v161 = v35;
        v162 = v32;
        v163 = v7;
        v164 = (uint64_t)v31;
        __s1 = v10;
        v166 = v2;
        v167 = v36;
        uint64_t v64 = 1;
        LOBYTE(v168) = 1;
        uint64_t v10 = &v157;
        char v65 = 0;
LABEL_123:
        Swift::Int v2 = *((unsigned __int8 *)a2 + 18);
        unint64_t v74 = a2;
        if ((_DWORD)v2 == 2)
        {
LABEL_127:
          unint64_t v6 = (_WORD *)*((void *)v74 + 1);
        }

        else
        {
          if ((_DWORD)v2 == 5 && *((_DWORD *)a2 + 2) >= 2u)
          {
            unint64_t v74 = *(const char **)a2;
            goto LABEL_127;
          }

          unint64_t v6 = 0LL;
        }

        if (v6[8] == 205)
        {
          if (v65)
          {
            uint64_t v75 = *((int *)v28 + 2);
            BOOL v76 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))&v28[v75 + 8];
            if (v76) {
              uint64_t v77 = strlen(&v28[v75 + 8]);
            }
            else {
              uint64_t v77 = 0LL;
            }
            uint64_t v82 = v28[2];
            unint64_t v154 = v28;
            if ((v82 & 4) == 0)
            {
              uint64_t v7 = 0LL;
              uint64_t v3 = 0LL;
              uint64_t v83 = v76;
              Swift::Int v84 = (const char *)v77;
              goto LABEL_168;
            }

            v200 = 0LL;
            v201[0] = 0LL;
            v199 = 0LL;
            unint64_t v144 = v77;
            Swift::String v85 = (char *)v76 + v77;
            Swift::Int v86 = v76;
            uint64_t v87 = (char *)v76 + v77 + 1;
            uint64_t v88 = strlen(v87);
            if (v88)
            {
              uint64_t v7 = 0LL;
              v149 = 0LL;
              v139 = v86;
              uint64_t v83 = v86;
              uint64_t v28 = 0LL;
              int64_t v89 = v85;
              while (1)
              {
                char v91 = *((unsigned __int8 *)v85 + 1);
                switch(v91)
                {
                  case 'S':
                    uint64_t v28 = (char *)(v85 + 2);
                    uint64_t v90 = &v200;
                    break;
                  case 'R':
                    v149 = (unint64_t)(v85 + 2);
                    uint64_t v90 = &v199;
                    break;
                  case 'N':
                    uint64_t v7 = (char *)(v85 + 2);
                    uint64_t v90 = v201;
                    uint64_t v83 = (void (**)(swift::Demangle::__runtime::Demangler *__hidden))(v85 + 2);
                    break;
                  default:
                    goto LABEL_145;
                }

                int64_t v89 = &v87[v88];
                char *v90 = v88 - 1;
LABEL_145:
                Swift::String v85 = &v87[v88];
                v87 += v88 + 1;
                uint64_t v88 = strlen(v87);
                if (!v88)
                {
                  uint64_t v82 = v200;
                  uint64_t v75 = v201[0];
                  Swift::String v85 = v89;
                  Swift::Int v2 = v199;
                  uint64_t v10 = &v157;
                  BOOL v76 = v139;
                  goto LABEL_167;
                }
              }
            }

            Swift::Int v2 = 0LL;
            uint64_t v82 = 0LL;
            uint64_t v75 = 0LL;
            uint64_t v7 = 0LL;
            v149 = 0LL;
            uint64_t v83 = v86;
            BOOL v76 = v86;
            uint64_t v28 = 0LL;
LABEL_167:
            Swift::Int v84 = (const char *)(v85 - (const char *)v83);
            uint64_t v3 = 1LL;
            uint64_t v77 = v144;
            uint64_t v4 = v149;
LABEL_168:
            uint64_t v157 = v76;
            v158 = v77;
            v159 = (char *)v83;
            v160 = (char *)v84;
            v161 = (uint64_t)v7;
            v162 = v75;
            v163 = v28;
            v164 = v82;
            __s1 = (void *)v4;
            v166 = v2;
            v167 = v3;
            uint64_t v64 = 1;
            LOBYTE(v168) = 1;
            uint64_t v28 = v154;
          }

          char v101 = *((unsigned __int8 *)v6 + 18);
          uint64_t v102 = (uint64_t *)v6;
          if (!v167) {
            return 0LL;
          }
          uint64_t v103 = *v102;
          uint64_t v104 = *(void *)(v103 + 8);
          if (v101 == 2)
          {
LABEL_179:
            unint64_t v6 = (_WORD *)*((void *)v6 + 1);
            unint64_t v81 = 1;
          }

          else
          {
            if (v101 == 5 && *((_DWORD *)v6 + 2) >= 2u)
            {
              unint64_t v6 = *(_WORD **)v6;
              goto LABEL_179;
            }

            unint64_t v6 = 0LL;
            unint64_t v81 = 1;
          }

  Swift::Bool v33 = 0LL;
LABEL_18:
  uint64_t v36 = (uint64_t (**)())v46;
  uint64_t v13 = v37;
  if (v35)
  {
    if (v35 == v34)
    {
      uint64_t v39 = v37;
      (*(void (**)(void *, void *))(v34[0] + 24LL))(v34, v37);
    }

    else
    {
      uint64_t v39 = (void *)(*(uint64_t (**)(void))(*v35 + 16LL))();
    }
  }

  else
  {
    uint64_t v39 = 0LL;
  }

  Swift::Int v14 = v40;
  if (!v33)
  {
    uint64_t v41 = 0LL;
    id v42 = 0;
    uint64_t v44 = 0LL;
    uint64_t v45 = 0LL;
    __p = 0LL;
    goto LABEL_33;
  }

  if (v33 == v32)
  {
    uint64_t v41 = v40;
    (*(void (**)(void *, _BYTE *))(v32[0] + 24LL))(v32, v40);
  }

  else
  {
    uint64_t v41 = (_BYTE *)(*(uint64_t (**)(void))(*v33 + 16LL))();
  }

  uint64_t v15 = v33;
  id v42 = 0;
  uint64_t v44 = 0LL;
  uint64_t v45 = 0LL;
  __p = 0LL;
  if (v33 == v32)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = v32;
  }

  else
  {
    if (!v33) {
      goto LABEL_33;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_33:
  uint64_t v17 = v35;
  if (v35 == v34)
  {
    uint64_t v18 = 4LL;
    uint64_t v17 = v34;
  }

  else
  {
    if (!v35) {
      goto LABEL_38;
    }
    uint64_t v18 = 5LL;
  }

  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_38:
  Swift::Int v86 = &v36;
  if (v31 == 1)
  {
    *(_WORD *)(a5 + 16) = 1;
    uint64_t v22 = v29;
    uint64_t v23 = v30;
    *(void *)(a5 + 8) = v30;
    *(void *)a5 = v23(v22, 2LL, 0LL);
    if (v31 == 1) {
      v30(v29, 3LL, 0LL);
    }
    uint64_t v21 = __p;
    if (__p) {
      goto LABEL_49;
    }
  }

  else
  {
    if (v31 || (uint64_t v19 = v29) == 0)
    {
      *(_WORD *)(a5 + 16) = 1;
      uint64_t v20 = "NULL type but no error provided";
LABEL_44:
      *(void *)a5 = v20;
      *(void *)(a5 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
      uint64_t v21 = __p;
      if (!__p) {
        goto LABEL_50;
      }
LABEL_49:
      uint64_t v44 = v21;
      operator delete(v21);
      goto LABEL_50;
    }

    if ((v29 & 1) == 0)
    {
      *(_WORD *)(a5 + 16) = 1;
      uint64_t v20 = "This entry point is only for packs";
      goto LABEL_44;
    }

    *(_WORD *)(a5 + 16) = 0;
    *(void *)a5 = v19;
    uint64_t v21 = __p;
    if (__p) {
      goto LABEL_49;
    }
  }

  if (a2 == 6)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "unwind", 6uLL))
    {
      Swift::Int v8 = *((void *)&v21 + 1);
      if (*((void *)&v21 + 1) == 4LL)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "auto",  4uLL))
        {
          _swift_backtraceSettings = 0;
          return;
        }

        Swift::Int v8 = *((void *)&v21 + 1);
        if (*((void *)&v21 + 1) == 4LL)
        {
          if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "fast",  4uLL))
          {
            _swift_backtraceSettings = 1;
            return;
          }

          Swift::Int v8 = *((void *)&v21 + 1);
        }
      }

      if (v8 == 7)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "precise",  7uLL))
        {
          _swift_backtraceSettings = 2;
          return;
        }

        Swift::Int v8 = *((void *)&v21 + 1);
      }

      swift::warning(0LL, "swift runtime: unknown unwind algorithm '%.*s'\n", a3, (char *)a4, v8, (void)v21);
      return;
    }

    a2 = v23;
  }

  if (a2 == 8)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "sanitize", 8uLL))
    {
      return;
    }

    a2 = v23;
  }

  if (a2 == 6)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "preset", 6uLL))
    {
      uint64_t v9 = *((void *)&v21 + 1);
      if (*((void *)&v21 + 1) == 4LL)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "auto",  4uLL))
        {
          dword_18C471490 = -1;
          return;
        }

        uint64_t v9 = *((void *)&v21 + 1);
      }

      if (v9 == 8)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "friendly",  8uLL))
        {
          dword_18C471490 = 0;
          return;
        }

        uint64_t v9 = *((void *)&v21 + 1);
      }

      if (v9 == 6)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "medium",  6uLL))
        {
          dword_18C471490 = 1;
          return;
        }

        uint64_t v9 = *((void *)&v21 + 1);
      }

      if (v9 == 4)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "full",  4uLL))
        {
          dword_18C471490 = 2;
          return;
        }

        uint64_t v9 = *((void *)&v21 + 1);
      }

      swift::warning(0LL, "swift runtime: unknown backtracing preset '%.*s'\n", a3, (char *)a4, v9, (void)v21);
      return;
    }

    a2 = v23;
  }

  if (a2 == 7)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "threads", 7uLL))
    {
      uint64_t v10 = *((void *)&v21 + 1);
      if (*((void *)&v21 + 1) == 3LL)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "all",  3uLL))
        {
          dword_18C471478 = 0;
          return;
        }

        uint64_t v10 = *((void *)&v21 + 1);
      }

      if (v10 == 7)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "crashed",  7uLL))
        {
          dword_18C471478 = 1;
          return;
        }

        uint64_t v10 = *((void *)&v21 + 1);
      }

      swift::warning(0LL, "swift runtime: unknown threads setting '%.*s'\n", a3, (char *)a4, v10, (void)v21);
      return;
    }

    a2 = v23;
  }

  if (a2 == 9)
  {
    if (!__swift::__runtime::llvm::StringRef::compare_insensitive(&v22, "registers", 9uLL))
    {
      uint64_t v11 = *((void *)&v21 + 1);
      if (*((void *)&v21 + 1) == 4LL)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "none",  4uLL))
        {
          dword_18C47147C = 0;
          return;
        }

        uint64_t v11 = *((void *)&v21 + 1);
      }

      if (v11 == 3)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "all",  3uLL))
        {
          dword_18C47147C = 1;
          return;
        }

        uint64_t v11 = *((void *)&v21 + 1);
      }

      if (v11 == 7)
      {
        if (!__swift::__runtime::llvm::StringRef::compare_insensitive( (unsigned __int8 **)&v21,  "crashed",  7uLL))
        {
          dword_18C47147C = 2;
          return;
        }

  if ((v4 & 1) == 0)
  {
    isa = v2[1].super.isa;
    uint64_t v15 = (uint64_t)isa[-1].isa[10].isa & 0xF8;
    return _getErrorCode<A>(_:)( (char *)v2 + ((unsigned __int16)(v15 + 39) & (unsigned __int16)~(_WORD)v15 & 0x1F8),  isa,  v4);
  }

  uint64_t v11 = atomic_load(v3);
  if (!v11)
  {
    uint64_t v12 = swift_conformsToProtocolCommon((uint64_t)v2[1].super.isa, (uint64_t)&protocol descriptor for Hashable);
    if (v12)
    {
      uint64_t v11 = v12;
      uint64_t v13 = (unint64_t)swift::hashable_support::findHashableBaseType((uint64_t)v2[1].super.isa);
    }

    else
    {
      uint64_t v17 = swift_conformsToProtocolCommon((uint64_t)v2[1].super.isa, (uint64_t)&protocol descriptor for Equatable);
      uint64_t v11 = v17 | 1;
      if (v17) {
        uint64_t v13 = (unint64_t)swift::findConformingSuperclass((uint64_t)v2[1].super.isa, *(void *)v17) | 1;
      }
      else {
        uint64_t v13 = 1LL;
      }
    }

    while (!__ldaxr(v3))
    {
      if (!__stlxr(v11, v3)) {
        goto LABEL_28;
      }
    }

    __clrex();
LABEL_28:
    uint64_t v19 = (unint64_t *)&v2[2];
    while (!__ldaxr(v19))
    {
      if (!__stlxr(v13, v19)) {
        goto LABEL_31;
      }
    }

    __clrex();
    if (v11 < 2) {
      return (unint64_t)v2;
    }
    goto LABEL_32;
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  if (*((_DWORD *)a2 + 2) != 3) {
    goto LABEL_18;
  }
  if (!*(_DWORD *)a4) {
    goto LABEL_18;
  }
  return this;
}

  uint64_t v13 = *(unsigned __int16 *)(*((void *)*a2 + 2) + 16LL) == 290;
  Swift::Int v14 = 2LL;
  if (*(_WORD *)(*((void *)*a2 + 2) + 16LL) == 290) {
    Swift::Int v14 = 3LL;
  }
  else {
    uint64_t v12 = (swift::Demangle::__runtime::Node *)*((void *)*a2 + v14);
  }
LABEL_21:
  uint64_t v15 = *((unsigned __int8 *)v12 + 18);
  if (v15 == 5 && *((_DWORD *)v12 + 2))
  {
    uint64_t v12 = *(swift::Demangle::__runtime::Node **)v12;
LABEL_25:
    uint64_t v16 = *(swift::Demangle::__runtime::Node **)v12;
    if (!v13) {
      goto LABEL_33;
    }
    goto LABEL_28;
  }

  uint64_t v16 = 0LL;
  if (!v13) {
    goto LABEL_33;
  }
LABEL_28:
  if (v8 == 5 && *((_DWORD *)a2 + 2) > 2u)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
  }

  else
  {
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
  }

        uint64_t v12 = a2;
        if (v11 >= 2) {
          uint64_t v12 = *(swift::Demangle::__runtime::Node **)a2;
        }
        if (*(_DWORD *)a4) {
          return this;
        }
LABEL_8:
        if (v7 == ++v8) {
          goto LABEL_20;
        }
      }

      if ((_DWORD)v10 != 2) {
        goto LABEL_7;
      }
      uint64_t v10 = 2LL;
LABEL_13:
      if (v10 <= v8) {
        goto LABEL_7;
      }
      goto LABEL_16;
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

    uint64_t v12 = a2;
    if (v11 >= 2) {
      uint64_t v12 = *(swift::Demangle::__runtime::Node **)a2;
    }
    if (*(_DWORD *)a4) {
      return this;
    }
LABEL_8:
    ++v8;
  }

  while (v7 != v8);
  if (v25)
  {
LABEL_21:
    uint64_t v13 = *(_DWORD *)(v5 + 12736);
    Swift::Int v14 = *(unsigned int *)(v5 + 12740);
    uint64_t v15 = *(char **)(v5 + 12728);
    if (v13 >= v14)
    {
      uint64_t v16 = *(void **)(v5 + 12744);
      uint64_t v17 = (char *)v16[1];
      if (&v15[v14] != v17)
      {
        uint64_t v18 = v16[2];
        goto LABEL_25;
      }

      uint64_t v19 = (unint64_t)&v15[v14 + 1];
      uint64_t v18 = v16[2];
      if (v19 <= v18)
      {
        v16[1] = v19;
        LODWORD(v20) = 1;
      }

      else
      {
LABEL_25:
        else {
          uint64_t v20 = (2 * v14);
        }
        uint64_t v21 = v20 + v14;
        if (!v17 || (unint64_t)&v17[v21] > v18)
        {
          uint64_t v22 = 2LL * v16[4];
          if (v22 <= v21 + 1) {
            uint64_t v22 = v21 + 1;
          }
          v16[4] = v22;
          uint64_t v23 = v22 + 8;
          this = malloc(v22 + 8);
          unint64_t v24 = (char *)this + v23;
          *this = v16[3];
          uint64_t v17 = (char *)(this + 1);
          __int128 v16[2] = v24;
          void v16[3] = this;
        }

        v16[1] = &v17[v21];
        if ((_DWORD)v14)
        {
          this = memcpy(v17, *(const void **)(v5 + 12728), v14);
          LODWORD(v14) = *(_DWORD *)(v5 + 12740);
          uint64_t v13 = *(_DWORD *)(v5 + 12736);
        }

        *(void *)(v5 + 12728) = v17;
        uint64_t v15 = v17;
      }

      *(_DWORD *)(v5 + 12740) = v14 + v20;
    }

    *(_DWORD *)(v5 + 12736) = v13 + 1;
    v15[v13] = 121;
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return this;
}

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return this;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v10 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    uint64_t v7 = (swift::Demangle::__runtime::Node *)((char *)v7 + 8);
    if (v7 == v9) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_19;
    }
  }

uint64_t Array.withUnsafeBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t, unint64_t), uint64_t a2, int64_t a3, uint64_t *a4)
{
  return _ArrayBuffer.withUnsafeBufferPointer<A>(_:)(a1, a2, a3, a4);
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)( Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::Int v8 = specialized Collection.count.getter(a1, a2, a3, a4);
  if (!v8) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v9 = v8;
  uint64_t v10 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v8, 0LL);
  if (v9 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  Swift::Int v14 = v10;
  uint64_t v15 = (uint64_t)(v10 + 4);
  swift_bridgeObjectRetain(a4, v11, v12, v13);
  v16._Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v17 = specialized Sequence._copySequenceContents(initializing:)(&v25, v15, v9, v16, a2._rawBits, a3, a4);
  if ((v26 ^ v29) >= 0x4000)
  {
    unint64_t v19 = v27;
    unint64_t v20 = v28;
    v21._Swift::UInt64 rawBits = v29;
    Substring.UTF8View.subscript.getter(v29, v25._rawBits, v26, v27, v28);
    uint64_t v22 = (v19 >> 59) & 1;
    if ((v20 & 0x1000000000000000LL) == 0) {
      LOBYTE(v22) = 1;
    }
    Swift::UInt64 rawBits = v21._rawBits;
    if ((v21._rawBits & 0xC) == 4LL << v22)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(v21)._rawBits;
      if ((v20 & 0x1000000000000000LL) == 0) {
        goto LABEL_14;
      }
    }

    else if ((v20 & 0x1000000000000000LL) == 0)
    {
      goto LABEL_14;
    }

    unint64_t v24 = HIBYTE(v20) & 0xF;
    if ((v20 & 0x2000000000000000LL) == 0) {
      unint64_t v24 = v19 & 0xFFFFFFFFFFFFLL;
    }
    if (v24 <= rawBits >> 16) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x90uLL,  0);
    }
    String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits);
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  if (v17 != v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  swift_bridgeObjectRelease(v28);
  return v14;
}

{
  Swift::String::Index v8;
  Swift::UInt64 rawBits;
  __objc2_class **v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  __objc2_class **v14;
  uint64_t v15;
  Swift::String::Index v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  Swift::String::Index v21;
  Swift::String::Index v22;
  Swift::String::Index v23;
  Swift::UInt64 v24;
  id v25;
  Swift::String::Index v26;
  Swift::String::Index v27;
  void v28[2];
  Swift::UInt64 v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  Swift::UInt64 v33;
  v8._Swift::UInt64 rawBits = specialized Collection.count.getter(a1, a2, a3, a4)._rawBits;
  if (v8._rawBits)
  {
    Swift::UInt64 rawBits = v8._rawBits;
    uint64_t v10 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( v8._rawBits,  0LL,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Unicode.Scalar>);
    if ((rawBits & 0x8000000000000000LL) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
    Swift::Int v14 = v10;
    uint64_t v15 = (uint64_t)(v10 + 4);
    swift_bridgeObjectRetain(a4, v11, v12, v13);
    v16._Swift::UInt64 rawBits = a1._rawBits;
    uint64_t v17 = specialized Sequence._copySequenceContents(initializing:)(&v29, v15, rawBits, v16, a2._rawBits, a3, a4);
    if ((v30 ^ v33) >= 0x4000)
    {
      unint64_t v20 = v31;
      unint64_t v19 = v32;
      v27._Swift::UInt64 rawBits = v33;
      v21._Swift::UInt64 rawBits = v33;
      v22._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:in:)(v21, v29, v30, v31, v32)._rawBits;
      if ((v19 & 0x1000000000000000LL) != 0)
      {
        _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v22._rawBits & 0xFFFFFFFFFFFF0000LL));
        v26._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v27)._rawBits;
        String.UnicodeScalarView._foreignIndex(after:)(v26);
      }

      else
      {
        unint64_t v24 = v22._rawBits >> 16;
        if ((v19 & 0x2000000000000000LL) != 0)
        {
          v28[0] = v20;
          v28[1] = v19 & 0xFFFFFFFFFFFFFFLL;
          _decodeScalar(_:startingAt:)((uint64_t)v28, v23._rawBits, v24);
          _StringGuts.validateScalarIndex(_:)(v27);
        }

        else
        {
          if ((v20 & 0x1000000000000000LL) != 0) {
            Swift::String::Index v25 = (id)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else {
            Swift::String::Index v25 = _StringObject.sharedUTF8.getter(v20, v19);
          }
          _decodeScalar(_:startingAt:)((uint64_t)v25, v23._rawBits, v24);
          _StringGuts.validateScalarIndex(_:)(v27);
          if ((v20 & 0x1000000000000000LL) == 0) {
            _StringObject.sharedUTF8.getter(v20, v19);
          }
        }
      }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
    }

    if (v17 != rawBits) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
    }
    swift_bridgeObjectRelease(v32);
  }

  else
  {
    return &_swiftEmptyArrayStorage;
  }

  return v14;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  uint64_t v5 = swift_allocObject(v4, 0x30uLL, 7uLL);
  int64_t v6 = _swift_stdlib_malloc_size(v5);
  uint64_t v7 = v6 - 32;
  if (v6 < 32) {
    uint64_t v7 = v6 - 25;
  }
  v5[2] = 2LL;
  v5[3] = 2 * (v7 >> 3);
  v5[4] = a1;
  v5[5] = a2;
  return v5;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)(unsigned int a1)
{
  if (HIWORD(a1)) {
    unint64_t v2 = 2LL;
  }
  else {
    unint64_t v2 = 1LL;
  }
  unint64_t v3 = specialized RandomAccessCollection<>.distance(from:to:)(0LL, v2, a1);
  if (!v3) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = v3;
  uint64_t v5 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v3, 0LL);
  if (v4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  int64_t v6 = v5;
  uint64_t v7 = specialized Sequence._copySequenceContents(initializing:)((uint64_t)&v10, (_WORD *)v5 + 16, v4, a1);
  unint64_t v8 = v11;
  if (HIWORD(v10))
  {
    if (v11 != 2)
    {
      Unicode.Scalar.UTF16View.subscript.getter(v11, v10);
      if (v8 >= 2) {
        goto LABEL_9;
      }
      goto LABEL_17;
    }
  }

  else if (v11 != 1)
  {
    Unicode.Scalar.UTF16View.subscript.getter(v11, v10);
    if (v8) {
LABEL_9:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
LABEL_17:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  if (v7 != v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  return v6;
}

{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  __objc2_class **v7;
  __objc2_class **v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v2 = 2LL;
  unint64_t v3 = 3LL;
  if (a1 >= 0x10000) {
    unint64_t v3 = 4LL;
  }
  if (a1 > 0x7FF) {
    unint64_t v2 = v3;
  }
  if (a1 >= 0x80) {
    uint64_t v4 = v2;
  }
  else {
    uint64_t v4 = 1LL;
  }
  uint64_t v5 = specialized RandomAccessCollection<>.distance(from:to:)(0LL, v4, a1);
  if (!v5) {
    return &_swiftEmptyArrayStorage;
  }
  int64_t v6 = v5;
  uint64_t v7 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v5, 0LL);
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  unint64_t v8 = v7;
  uint64_t v9 = specialized Sequence._copySequenceContents(initializing:)((uint64_t)&v13, (_BYTE *)v7 + 32, v6, a1);
  unsigned int v10 = v14;
  if (v13 < 0x80)
  {
    if (v14 == 1) {
      goto LABEL_12;
    }
LABEL_18:
    uint64_t v12 = v13;
    Unicode.Scalar.UTF8View.subscript.getter(v14, v13);
    specialized RandomAccessCollection<>.index(after:)(v10, v12);
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  if (v13 >= 0x800)
  {
    if (v13 >= 0x10000)
    {
      if (v14 != 4) {
        goto LABEL_18;
      }
    }

    else if (v14 != 3)
    {
      goto LABEL_18;
    }
  }

  else if (v14 != 2)
  {
    goto LABEL_18;
  }

{
  uint64_t v1;
  __objc2_class **v2;
  uint64_t v4;
  uint64_t v5;
  unsigned int v7;
  uint64_t v1 = __clz(a1) >> 3;
  if ((_DWORD)v1 == 4) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = 4 - v1;
  unint64_t v2 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(4 - v1, 0LL);
  uint64_t v5 = specialized Sequence._copySequenceContents(initializing:)(&v7, (uint64_t)(v2 + 4), v4, a1);
  if (v7) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }
  if (v5 != v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  return v2;
}

LABEL_12:
  if (v9 != v6) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  return v8;
}

    __break(1u);
LABEL_13:
    __break(1u);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
  }

  if (a3 != &type metadata for Unicode.UTF8)
  {
    unint64_t v11 = (*(uint64_t (**)(_DWORD *, ValueMetadata *, uint64_t))(a4 + 88))(a1, a3, a4);
    unint64_t v8 = v11 > 0x7F;
    if (v11 <= 0x7F) {
      LOBYTE(v7) = v11;
    }
    else {
      LOBYTE(v7) = 0;
    }
    return v7 | (v8 << 8);
  }

  if ((ValueMetadata *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)&type metadata for Unicode.UTF8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar) != &type metadata for _ValidUTF8Buffer) {
    goto LABEL_12;
  }
  if (!*a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  unsigned int v10 = (char)(*a1 - 1);
  unint64_t v8 = v10 < 0;
  uint64_t v7 = v10 & ~(v10 >> 31);
  return v7 | (v8 << 8);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
  }

  if (a2 != &type metadata for Unicode.UTF8)
  {
    BOOL result = (ValueMetadata *)(*(uint64_t (**)(_DWORD *, ValueMetadata *, uint64_t))(a3 + 88))(a1, a2, a3);
    unsigned int v10 = result > 0x7F;
    else {
      LOBYTE(v9) = 0;
    }
    goto LABEL_7;
  }

  BOOL result = (ValueMetadata *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)&type metadata for Unicode.UTF8,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
  if (result != &type metadata for _ValidUTF8Buffer) {
    goto LABEL_12;
  }
  if (!*a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }
  unint64_t v11 = (char)(*a1 - 1);
  unsigned int v10 = v11 < 0;
  uint64_t v9 = v11 & ~(v11 >> 31);
LABEL_7:
  *a4 = v9;
  a4[1] = v10;
  return result;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }

  v15[0] = v7;
  v15[1] = v6 & 0xFFFFFFFFFFFFFFLL;
  if (v10 - v9 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  uint64_t v13 = (char *)v15 + v9;
  Swift::Int v14 = v10 - v9;
LABEL_10:
  a1(v13, v14);
  swift_bridgeObjectRelease(v6);
}

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
    }

    __break(1u);
    goto LABEL_12;
  }

  int64_t v6 = (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL) + v3;
  uint64_t v7 = v6 ^ __ROR8__(v3, 51);
  unint64_t v8 = (*(void *)algn_18C487058 ^ 0x7465646279746573LL)
     + (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL);
  uint64_t v9 = __ROR8__(*(void *)algn_18C487058 ^ 0x7465646279746573LL, 48);
  unsigned int v10 = (v8 ^ v9) + __ROR8__(v6, 32);
  unint64_t v11 = v10 ^ __ROR8__(v8 ^ v9, 43);
  uint64_t v12 = v8 + v7;
  uint64_t v13 = v12 ^ __ROR8__(v7, 47);
  Swift::Int v14 = v10 + v13;
  uint64_t v15 = v14 ^ __ROR8__(v13, 51);
  Swift::String::Index v16 = (__ROR8__(v12, 32) ^ 0xFFLL) + v11;
  uint64_t v17 = __ROR8__(v11, 48);
  uint64_t v18 = __ROR8__(v14, 32) + (v16 ^ v17);
  unint64_t v19 = v18 ^ __ROR8__(v16 ^ v17, 43);
  unint64_t v20 = v15 + v16;
  Swift::String::Index v21 = __ROR8__(v20, 32);
  uint64_t v22 = v20 ^ __ROR8__(v15, 47);
  uint64_t v23 = v18 + v22;
  unint64_t v24 = (v18 + v22) ^ __ROR8__(v22, 51);
  Swift::String::Index v25 = v21 + v19;
  unint64_t v26 = (v21 + v19) ^ __ROR8__(v19, 48);
  unint64_t v27 = __ROR8__(v23, 32) + v26;
  unint64_t v28 = v27 ^ __ROR8__(v26, 43);
  Swift::UInt64 v29 = v24 + v25;
  uint64_t v30 = v29 ^ __ROR8__(v24, 47);
  uint64_t v31 = __ROR8__(v29, 32) + v28;
  uint64_t v32 = (v27 + v30) ^ __ROR8__(v30, 51);
  return __ROR8__(v31 ^ __ROR8__(v28, 48), 43) ^ __ROR8__(v32 + v31, 32) ^ (v32 + v31) ^ __ROR8__(v32, 47);
}

  uint64_t v12 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  *(void *)(*(void *)(v12 + 48) + 8 * a2) = v5;
  uint64_t v13 = *(void *)(v12 + 16);
  Swift::Int v14 = __OFADD__(v13, 1LL);
  uint64_t v15 = v13 + 1;
  if (v14)
  {
    __break(1u);
    goto LABEL_15;
  }

  *(void *)(v12 + 16) = v15;
  return result;
}

  uint64_t v12 = *v3;
  *(void *)(*v3 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  *(void *)(*(void *)(v12 + 48) + 8 * a2) = v5;
  uint64_t v13 = *(void *)(v12 + 16);
  Swift::Int v14 = __OFADD__(v13, 1LL);
  uint64_t v15 = v13 + 1;
  if (v14)
  {
    __break(1u);
    goto LABEL_15;
  }

  *(void *)(v12 + 16) = v15;
  return result;
}

  Swift::String::Index v25 = *v30;
  *(void *)(v25 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  BOOL result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v32 + 32))( *(void *)(v25 + 48) + *(void *)(v32 + 72) * a2,  v33,  v7);
  unint64_t v27 = *(void *)(v25 + 16);
  unint64_t v28 = __OFADD__(v27, 1LL);
  Swift::UInt64 v29 = v27 + 1;
  if (v28)
  {
    __break(1u);
    goto LABEL_15;
  }

  *(void *)(v25 + 16) = v29;
  return result;
}

      uint64_t v18 = (v23 - 1) & v23;
    }
  }

    uint64_t v31 = 1;
    return v31 & 1;
  }

  Swift::String::Index v25 = *(id *)(a2 + 16);
  if (!v25) {
    goto LABEL_12;
  }
LABEL_8:
  if (v25 == (id)1)
  {
    BOOL v46 = a2;
    unint64_t v26 = type metadata accessor for Set(0LL, (uint64_t)a3, a5, v18);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, v26, v27);
    Collection.first.getter(v26, WitnessTable, (uint64_t)v20);
    Swift::UInt64 v29 = *((void *)a3 - 1);
    if ((*(unsigned int (**)(char *, uint64_t, char *))(v29 + 48))(v20, 1LL, a3) == 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/Set.swift",  15LL,  2,  0x2CAuLL,  0);
    }
    uint64_t v30 = (*(uint64_t (**)(char *, swift *, uint64_t))(a6 + 48))(v20, v8, a6);
    if (v30 == 2)
    {
      MEMORY[0x1895F8858](v30);
      unint64_t v40 = v8;
      uint64_t v41 = a6;
      id v42 = *(void *)(a5 + 8);
      uint64_t v43 = v20;
      uint64_t v31 = Sequence.contains(where:)( (uint64_t (*)(char *))partial apply for closure #1 in Sequence<>.contains(_:),  (uint64_t)(&v44 - 6),  (uint64_t)v8,  (const char *)a6);
    }

    else
    {
      uint64_t v31 = v30 & 1;
    }

    (*(void (**)(char *, char *))(v29 + 8))(v20, a3);
  }

  else
  {
    (*(void (**)(uint64_t *, uint64_t, swift *))(v12 + 16))(v14, v11, v8);
    Swift::Bool v33 = (const char *)type metadata accessor for Set(0LL, (uint64_t)a3, a5, v32);
    if (swift_dynamicCast((char *)&v46, v14, v8, v33, 6uLL))
    {
      int64_t v37 = v46;
      uint64_t v31 = Set.isSubset(of:)(v46, a2, a3, a5);
      swift_bridgeObjectRelease(v37);
    }

    else
    {
      if (v21)
      {
        if (a2 < 0) {
          uint64_t v38 = (void *)a2;
        }
        else {
          uint64_t v38 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
        }
        swift_bridgeObjectRetain(a2, v34, v35, v36);
        a2 = (uint64_t)_NativeSet.init(_:capacity:)(v38, (uint64_t)objc_msgSend(v38, sel_count), a3, a5);
      }

      else
      {
        swift_bridgeObjectRetain(a2, v34, v35, v36);
      }

      uint64_t v31 = _NativeSet.isSubset<A>(of:)( v11,  a2,  (uint64_t)a3,  (uint64_t)v8,  a5,  a6,  (void (*)(unsigned __int8 *__return_ptr, int64x2_t *, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))closure #1 in _NativeSet.isSubset<A>(of:));
      swift_release(a2);
    }
  }

  return v31 & 1;
}

    uint64_t v30 = v63;
    unint64_t v27 = v64;
    ((void (*)(unint64_t, unint64_t))v60)(v28, v61);
    uint64_t v31 = 1LL;
    if (v59(v30, 1LL, a3) == 1) {
      goto LABEL_30;
    }
  }

  if (!*(void *)(a2 + 16)
    || (unint64_t v40 = (*(uint64_t (**)(void, uint64_t *, uint64_t))(a5 + 32))(*(void *)(a2 + 40), a3, a5),
        uint64_t v41 = -1LL << *(_BYTE *)(a2 + 32),
        id v42 = v40 & ~v41,
        ((*(void *)(v65 + ((v42 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v42) & 1) == 0))
  {
    Swift::Bool v33 = *(void (**)(id *, uint64_t *))(v11 + 8);
LABEL_11:
    v33(v68, a3);
    uint64_t v12 = v53;
    a5 = v54;
    unint64_t v11 = v66;
    a2 = v67;
    unint64_t v28 = AssociatedTypeWitness;
    goto LABEL_12;
  }

  uint64_t v43 = v11;
  uint64_t v44 = ~v41;
  uint64_t v45 = *(void *)(a5 + 8);
  BOOL v46 = *(uint64_t (**)(id *, id *, uint64_t *, uint64_t))(v45 + 8);
  uint64_t v47 = *(void *)(v43 + 72);
  uint64_t v48 = *(void (**)(id *, unint64_t, uint64_t *))(v43 + 16);
  while (1)
  {
    v48(v14, *(void *)(v67 + 48) + v47 * v42, a3);
    uint64_t v49 = v46(v14, v68, a3, v45);
    Swift::Bool v33 = *(void (**)(id *, uint64_t *))(v66 + 8);
    v33(v14, a3);
    if ((v49 & 1) != 0) {
      break;
    }
    id v42 = (v42 + 1) & v44;
    if (((*(void *)(v65 + ((v42 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v42) & 1) == 0) {
      goto LABEL_11;
    }
  }

  v33(v68, a3);
  uint64_t v31 = 0LL;
  unint64_t v28 = AssociatedTypeWitness;
LABEL_29:
  unint64_t v27 = v64;
LABEL_30:
  (*(void (**)(char *, unint64_t))(v55 + 8))(v27, v28);
  return v31;
}

    Swift::String::Index v25 = 1LL;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56LL))( a2,  v25,  1LL,  v6);
  }

  if (v5 < 0) {
    unint64_t v8 = (void *)*v2;
  }
  else {
    unint64_t v8 = (void *)(v5 & 0xFFFFFFFFFFFFFF8LL);
  }
  if (!objc_msgSend(v8, sel_count)) {
    goto LABEL_12;
  }
  uint64_t v12 = (unint64_t)objc_msgSend(swift_unknownObjectRetain(v8, v9, v10, v11), sel_count);
  BOOL result = type metadata accessor for __BridgingBufferStorage(0LL);
  if ((v12 - 0x1000000000000000LL) >> 61 == 7)
  {
    if (!__OFADD__(8 * v12, 24LL))
    {
      Swift::Int v14 = swift_bufferAllocate(result, 8 * v12 + 24, 7uLL);
      v14[2] = v12;
      objc_msgSend(v8, sel_getObjects_, v14 + 3);
      swift_bridgeObjectRelease(v5);
      uint64_t v15 = type metadata accessor for __CocoaSet.Index.Storage();
      Swift::String::Index v16 = (uint64_t)swift_allocObject(v15, 0x20uLL, 7uLL);
      *(void *)(v16 + 16) = v8;
      *(void *)(v16 + 24) = v14;
      uint64_t v17 = *(void *)(a1 + 24);
      swift_bridgeObjectRetain(v5, v18, v19, v20);
      uint64_t v22 = 0LL;
LABEL_11:
      unint64_t v24 = type metadata accessor for Set._Variant(0LL, v6, v17, v21);
      Set._Variant.remove(at:)(v16, v22, v7 != 0, v24, a2);
      outlined consume of [A : B].Index._Variant<A, B>(v16, v22, v7 != 0);
      Swift::String::Index v25 = 0LL;
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56LL))( a2,  v25,  1LL,  v6);
    }
  }

  else
  {
    __break(1u);
  }

  __break(1u);
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  __break(1u);
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  __break(1u);
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }

  unint64_t v8 = -a6;
  if (__OFSUB__(0LL, a6))
  {
    __break(1u);
LABEL_14:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  if ((v8 & 0x8000000000000000LL) != 0) {
    goto LABEL_14;
  }
  if (v8 >= 0x10000) {
    goto LABEL_12;
  }
  int64_t v6 = a4 - (unsigned __int16)v8;
  LOBYTE(v7) = (v6 & 0xFFFF0000) != 0;
LABEL_8:
  uint64_t v9 = 0x8000000000000000LL;
  if ((v7 & 1) != 0) {
    LOWORD(v6) = ~(unsigned __int16)(a6 >> 63);
  }
  else {
    uint64_t v9 = 0LL;
  }
  *a1 = v6;
  return v9;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }

  unint64_t v8 = -a6;
  if (__OFSUB__(0LL, a6))
  {
    __break(1u);
LABEL_14:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  if ((v8 & 0x8000000000000000LL) != 0) {
    goto LABEL_14;
  }
  if (v8 >= 0x100) {
    goto LABEL_12;
  }
  int64_t v6 = a4 - v8;
  LOBYTE(v7) = (v6 & 0xFFFFFF00) != 0;
LABEL_8:
  uint64_t v9 = 0x8000000000000000LL;
  if ((v7 & 1) != 0) {
    LOBYTE(v6) = ~(a6 >> 63);
  }
  else {
    uint64_t v9 = 0LL;
  }
  *a1 = v6;
  return v9;
}

  unint64_t v3 = __OFADD__(v2, 15LL);
  unint64_t v8 = v2 + 15;
  if (!v3)
  {
    uint64_t v9 = v8 & 0xFFFFFFFFFFFFFFF0LL;
    unsigned int v10 = type metadata accessor for __StringStorage();
    uint64_t v7 = swift_allocObject(v10, v9, 7uLL);
    BOOL result = _swift_stdlib_malloc_size(v7);
    uint64_t v5 = result - 32;
    if (!__OFSUB__(result, 32LL))
    {
LABEL_7:
      if (!__OFSUB__(v5, v1)) {
        return (int64_t)v7;
      }
      goto LABEL_17;
    }

    __break(1u);
LABEL_16:
    __break(1u);
LABEL_17:
    __break(1u);
  }

  __break(1u);
  return result;
}

  swift_bridgeObjectRetain(v8, a2, a3, a4);
LABEL_13:
  swift_bridgeObjectRelease(v8);
}

    uint64_t v4 = Unicode.UTF8.ForwardParser._invalidLength()();
    unint64_t v3 = 0;
    unint64_t v2 = 8 * v4;
    return v3 | (v2 << 8);
  }

  if ((v1 & 0x1E) == 0) {
    goto LABEL_12;
  }
  unint64_t v2 = 16;
  unint64_t v3 = 1;
  return v3 | (v2 << 8);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return result;
}

      __asm { FCVT            H0, S0 }

      *uint64_t v1 = _H0;
      return;
    default:
      Float16._roundSlowPath(_:)(a1);
      return;
  }

      __asm { FCVT            H0, S0 }

      *uint64_t v1 = _H0;
      return;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v20);
      return;
  }

      --v14;
      goto LABEL_13;
    }
  }

  else
  {
    if (v5)
    {
      Swift::Int v14 = -v12;
      uint64_t v15 = -(uint64_t)v10;
      if (!v10) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }

    if (!v13) {
      goto LABEL_19;
    }
  }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }

    v14[0] = a3;
    v14[1] = a4 & 0xFFFFFFFFFFFFFFLL;
    if ((uint64_t)(v5 - v4) < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }
    return specialized static String._uncheckedFromUTF8(_:)((uint8x16_t *)((char *)v14 + v4), v5 - v4);
  }

    v14 += v12;
LABEL_13:
    BOOL result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), __n);
    *a3 += __n;
    goto LABEL_14;
  }

    v27[2] = 0LL;
    unint64_t v28 = 0LL;
    Swift::UInt64 v29 = 2400LL;
    uint64_t v30 = 0LL;
    uint64_t v31 = 0;
    v27[0] = off_189B8E500;
    v27[1] = 0LL;
    uint64_t v66 = 0LL;
    Swift::Bool v33 = 0LL;
    uint64_t v34 = 0LL;
    uint64_t v32 = 0LL;
    uint64_t v35 = 0;
    uint64_t v47 = 0u;
    uint64_t v48 = 0u;
    uint64_t v49 = 0u;
    uint64_t v50 = 0u;
    uint64_t v51 = 0u;
    uint64_t v52 = 0u;
    uint64_t v53 = 0u;
    uint64_t v54 = 0u;
    uint64_t v55 = 0u;
    uint64_t v56 = 0u;
    uint64_t v57 = 0u;
    uint64_t v58 = 0u;
    uint64_t v59 = 0u;
    uint64_t v60 = 0u;
    uint64_t v61 = 0u;
    uint64_t v62 = 0u;
    Swift::Int v63 = 0u;
    uint64_t v36 = 0u;
    int64_t v37 = 0u;
    uint64_t v38 = 0u;
    uint64_t v39 = 0u;
    unint64_t v40 = 0u;
    uint64_t v41 = 0u;
    id v42 = 0u;
    uint64_t v43 = 0u;
    uint64_t v44 = 0u;
    uint64_t v45 = 0u;
    BOOL v46 = 0u;
    uint64_t v64 = 0;
    unint64_t v11 = _swift_buildDemanglingForMetadata(cls, (swift::Demangle::__runtime::NodeFactory *)v27, a4, a5);
    if (v11)
    {
      v17[0] = 0;
      uint64_t v18 = 0x101010101010101LL;
      unint64_t v19 = 0x101010100000000LL;
      unint64_t v20 = 1;
      Swift::String::Index v21 = 256;
      uint64_t v22 = 1;
      uint64_t v23 = 0LL;
      unint64_t v24 = 0LL;
      v25[0] = &unk_189B8B0E8;
      v25[1] = swift::Demangle::__runtime::genericParameterName;
      unint64_t v26 = v25;
      v17[1] = a3;
      if ((a3 & 1) == 0) {
        BYTE4(v19) = 0;
      }
      swift::Demangle::__runtime::nodeToString((swift::Demangle::__runtime::Node *)v11, (__int128 *)v17, &v16);
      *a1 = v16;
      uint64_t v12 = v26;
      if (v26 == v25)
      {
        uint64_t v13 = 4LL;
        uint64_t v12 = v25;
      }

      else
      {
        if (!v26) {
          goto LABEL_23;
        }
        uint64_t v13 = 5LL;
      }

      (*(void (**)(void))(*v12 + 8 * v13))();
    }

    else
    {
      MEMORY[0x186E0BC88](a1, "<<< invalid type >>>");
    }

    unint64_t v8 = *v5;
    if ((~*v5 & 0x80000000FFFFFFFFLL) != 0)
    {
      if ((v8 & 0x8000000000000000LL) != 0) {
        goto LABEL_19;
      }
      uint64_t v9 = *v5;
      while (1)
      {
        unint64_t v8 = __ldxr(v5);
        if (v8 != v9) {
          break;
        }
        unsigned int v10 = 1;
LABEL_25:
        if ((v10 & 1) != 0) {
          return this;
        }
        uint64_t v9 = v8;
        if ((v8 & 0x8000000000000000LL) != 0)
        {
LABEL_19:
          uint64_t v9 = v8;
          if (v8 != 0xFFFFFFFFLL) {
            return swift::HeapObjectSideTableEntry::decrementUnownedShouldFree( (swift::HeapObjectSideTableEntry *)(8 * v8),  1);
          }
        }
      }

      __clrex();
LABEL_24:
      unsigned int v10 = 0;
      goto LABEL_25;
    }
  }

  return this;
}

  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a2, a2, a3, a4);
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x800000000LL;
  *(void *)(a1 + 296) = 0LL;
  return a1;
}

  Swift::Bool v33 = 0LL;
LABEL_14:
  uint64_t v36 = a2;
  uint64_t v15 = v37;
  if (v35)
  {
    if (v35 == v34)
    {
      uint64_t v38 = v37;
      (*(void (**)(void *, _BYTE *))(v34[0] + 24LL))(v34, v37);
    }

    else
    {
      uint64_t v38 = (_BYTE *)(*(uint64_t (**)(void))(*v35 + 16LL))();
    }
  }

  else
  {
    uint64_t v38 = 0LL;
  }

  Swift::String::Index v16 = v39;
  if (!v33)
  {
    unint64_t v40 = 0LL;
    uint64_t v41 = 0;
    uint64_t v43 = 0LL;
    uint64_t v44 = 0LL;
    __p = 0LL;
    goto LABEL_29;
  }

  if (v33 == v32)
  {
    unint64_t v40 = v39;
    (*(void (**)(void *, _BYTE *))(v32[0] + 24LL))(v32, v39);
  }

  else
  {
    unint64_t v40 = (_BYTE *)(*(uint64_t (**)(void))(*v33 + 16LL))();
  }

  uint64_t v17 = v33;
  uint64_t v41 = 0;
  uint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  __p = 0LL;
  if (v33 == v32)
  {
    uint64_t v18 = 4LL;
    uint64_t v17 = v32;
  }

  else
  {
    if (!v33) {
      goto LABEL_29;
    }
    uint64_t v18 = 5LL;
  }

  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_29:
  unint64_t v19 = v35;
  if (v35 == v34)
  {
    unint64_t v20 = 4LL;
    unint64_t v19 = v34;
  }

  else
  {
    if (!v35) {
      goto LABEL_34;
    }
    unint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_34:
  uint64_t v45 = &v36;
  if (v31)
  {
    if (v31 == 1)
    {
      *(_WORD *)(a7 + 24) = 1;
      Swift::String::Index v21 = v29;
      uint64_t v22 = v30;
      *(void *)(a7 + 8) = v30;
      *(void *)a7 = v22(v21, 2LL, 0LL);
      goto LABEL_43;
    }

    goto LABEL_41;
  }

  if (!v29)
  {
LABEL_41:
    *(_WORD *)(a7 + 24) = 1;
    unint64_t v26 = "NULL type but no error provided";
LABEL_42:
    *(void *)a7 = v26;
    *(void *)(a7 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
    goto LABEL_43;
  }

  if ((v29 & 1) != 0)
  {
    *(_WORD *)(a7 + 24) = 1;
    unint64_t v26 = "Cannot demangle a free-standing pack";
    goto LABEL_42;
  }

  uint64_t v23 = swift_checkMetadataState(a1, v29);
  unint64_t v24 = v41;
  *(_WORD *)(a7 + 24) = 0;
  *(void *)a7 = v23;
  *(void *)(a7 + 8) = v25;
  *(_BYTE *)(a7 + 16) = v24;
  if (!v23)
  {
    *(void *)a7 = "unknown error";
    *(void *)(a7 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
    *(_WORD *)(a7 + 24) = 1;
  }

    unsigned int v10 = *(unsigned int *)v9;
    switch(v10 & 0x1F)
    {
      case 4uLL:
        if ((v10 & 0x80) == 0) {
          goto LABEL_18;
        }
        unint64_t v11 = v9 + 4;
        int64_t v6 = (uint64_t)&v11[4 * ((v10 >> 7) & 1)];
        break;
      case 0x10uLL:
        if ((v10 & 0x80) == 0) {
          goto LABEL_18;
        }
        int64_t v6 = (uint64_t)&v9[8 * ((v10 >> 7) & 1) + 22];
        unint64_t v11 = v9 + 26;
        break;
      case 0x11uLL:
      case 0x12uLL:
        if ((v10 & 0x80) == 0) {
          goto LABEL_18;
        }
        int64_t v6 = (uint64_t)&v9[8 * ((v10 >> 7) & 1) + 14];
        unint64_t v11 = v9 + 18;
        break;
      default:
        abort();
    }

    unint64_t v8 = *v11;
    if (*(_BYTE *)(a1 + 13)) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }

  if ((_DWORD)v7 == 515) {
    goto LABEL_11;
  }
  unint64_t v8 = 0LL;
  if ((_DWORD)v7 == 516) {
    goto LABEL_11;
  }
LABEL_19:
  if (*(_BYTE *)(a1 + 13)) {
    goto LABEL_21;
  }
LABEL_20:
  a3 = v39;
  if (!v8) {
    goto LABEL_52;
  }
LABEL_21:
  uint64_t v12 = 0LL;
  uint64_t v32 = 0;
  if ((int)v7 <= 514)
  {
    if ((v7 - 512) >= 3)
    {
      if ((_DWORD)v7) {
        goto LABEL_30;
      }
      if ((*(_BYTE *)(a2 + 32) & 2) == 0)
      {
        uint64_t v12 = 0LL;
        goto LABEL_30;
      }

      uint64_t v13 = (uint64_t *)(a2 + 64);
      goto LABEL_29;
    }

  uint64_t v7 = *(int *)(v6 + 16);
  unint64_t v8 = v7 + v6 + 16;
  if ((_DWORD)v7) {
    uint64_t v9 = v8 == 0;
  }
  else {
    uint64_t v9 = 1;
  }
  if (v9) {
    goto LABEL_17;
  }
  Swift::Int v14 = v8 + 16;
  uint64_t v15 = a2;
  Swift::String::Index v16 = (_DWORD *)(v8 + 16 + 12LL * a2);
  uint64_t v17 = (int)v16[2];
  if ((_DWORD)v17) {
    uint64_t v18 = (char *)v16 + v17 + 8;
  }
  else {
    uint64_t v18 = 0LL;
  }
  if (v18) {
    unint64_t v19 = strlen(v18);
  }
  else {
    unint64_t v19 = 0LL;
  }
  unint64_t v20 = v14 + 12LL * v15;
  uint64_t v23 = *(int *)(v20 + 4);
  Swift::String::Index v21 = v20 + 4;
  uint64_t v22 = v23;
  if ((_DWORD)v23) {
    unint64_t v24 = v22 == -v21;
  }
  else {
    unint64_t v24 = 1;
  }
  if (v24)
  {
    Swift::String::Index v25 = *v16 & 1;
    *(void *)a3 = v18;
    *(void *)(a3 + 8) = v19;
    *(void *)(a3 + 16) = 0LL;
    *(void *)(a3 + 24) = v25;
    return;
  }

  SymbolicMangledNameStringRef = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef((_BYTE *)(v22 + v21), a2);
  uint64_t v30 = SymbolicMangledNameStringRef;
  uint64_t v31 = v27;
  uint64_t v32 = 0LL;
  uint64_t v55 = 0;
  Swift::Bool v33 = *(void *)a1;
  if (*(void *)a1 > 0x7FFuLL) {
    LODWORD(v33) = 0;
  }
  if ((int)v33 <= 514)
  {
    if ((v33 - 512) >= 3)
    {
      if ((_DWORD)v33) {
        goto LABEL_42;
      }
      if ((*(_BYTE *)(a1 + 32) & 2) == 0)
      {
        uint64_t v32 = 0LL;
        goto LABEL_42;
      }

      uint64_t v34 = (uint64_t *)(a1 + 64);
      goto LABEL_41;
    }

      ++v6;
    }

    uint64_t v5 = *(unsigned __int8 *)v6;
    unint64_t v2 = (unsigned __int8 *)v6;
    if (*v6) {
      continue;
    }
    break;
  }

    swift::nameForMetadata(&v24, (uint64_t)cls, 1, a3, a4);
    size = (char)v24.__r_.__value_.__s.__size_;
    uint64_t v13 = v24.__r_.__value_.__r.__words[0];
    Swift::Int v14 = *v4;
    Name = (char *)protocol_getName(v14);
    if (size >= 0) {
      uint64_t v17 = &v24;
    }
    else {
      uint64_t v17 = (std::string *)v13;
    }
    swift::swift_dynamicCastFailure(cls, v17, (const char *)v14, Name, 0LL, v16);
  }

  unint64_t v8 = (Class)cls;
  if (!(_DWORD)v7) {
    goto LABEL_7;
  }
  if ((_DWORD)v7 != 773)
  {
    unint64_t v8 = (Class)cls;
    if ((_DWORD)v7 == 1024) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }

  unint64_t v8 = (Class)*((void *)cls + 1);
  if (!a2) {
    return cls;
  }
  do
  {
LABEL_8:
    if ((-[objc_class conformsToProtocol:](v8, "conformsToProtocol:", *v4) & 1) == 0)
    {
      swift::nameForMetadata(&v24, (uint64_t)cls, 1, v9, v10);
      uint64_t v18 = (char)v24.__r_.__value_.__s.__size_;
      unint64_t v19 = v24.__r_.__value_.__r.__words[0];
      unint64_t v20 = *v4;
      Swift::String::Index v21 = (char *)protocol_getName(v20);
      if (v18 >= 0) {
        uint64_t v23 = &v24;
      }
      else {
        uint64_t v23 = (std::string *)v19;
      }
      swift::swift_dynamicCastFailure(cls, v23, (const char *)v20, v21, 0LL, v22);
    }

    ++v4;
    --v5;
  }

  while (v5);
  return cls;
}

    Swift::Int v14 = v12 + 1;
    *(void *)&v6[8 * v12++] = v19;
  }

  while (!v17);
  if (a2)
  {
    uint64_t v32 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
    if (!v32 || v32 + 24 > *((void *)this + 2))
    {
      Swift::Bool v33 = 2LL * *((void *)this + 4);
      if (v33 <= 0x20) {
        Swift::Bool v33 = 32LL;
      }
      *((void *)this + 4) = v33;
      uint64_t v34 = v33 + 8;
      uint64_t v35 = malloc(v33 + 8);
      uint64_t v36 = (char *)v35 + v34;
      *uint64_t v35 = *((void *)this + 3);
      uint64_t v32 = ((unint64_t)v35 + 15) & 0xFFFFFFFFFFFFFFF8LL;
      *((void *)this + 2) = v36;
      *((void *)this + 3) = v35;
    }

    *((void *)this + 1) = v32 + 24;
    *(_WORD *)(v32 + 16) = 232;
    *(_BYTE *)(v32 + 18) = 0;
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v32, a2, this, a4, a5);
    if (!v14) {
      return v32;
    }
LABEL_47:
    uint64_t v39 = 8LL * v14;
    unint64_t v40 = v6 - 8;
    while (1)
    {
      BOOL v46 = *(swift::Demangle::__runtime::Node **)&v40[v39];
      if (!v46) {
        break;
      }
      uint64_t v47 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v47 || v47 + 24 > *((void *)this + 2))
      {
        uint64_t v48 = 2LL * *((void *)this + 4);
        if (v48 <= 0x20) {
          uint64_t v48 = 32LL;
        }
        *((void *)this + 4) = v48;
        uint64_t v49 = v48 + 8;
        uint64_t v50 = malloc(v48 + 8);
        uint64_t v51 = (char *)v50 + v49;
        *uint64_t v50 = *((void *)this + 3);
        uint64_t v47 = ((unint64_t)v50 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)this + 2) = v51;
        *((void *)this + 3) = v50;
      }

      uint64_t v31 = 0LL;
      *((void *)this + 1) = v47 + 24;
      *(_WORD *)(v47 + 16) = 45;
      *(_BYTE *)(v47 + 18) = 0;
      if (v32 && v47)
      {
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v47,  (swift::Demangle::__runtime::Node *)v32,  this,  a4,  a5);
        swift::Demangle::__runtime::Node::addChild((unsigned int *)v47, v46, this, v52, v53);
        uint64_t v31 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v31 || v31 + 24 > *((void *)this + 2))
        {
          uint64_t v41 = 2LL * *((void *)this + 4);
          if (v41 <= 0x20) {
            uint64_t v41 = 32LL;
          }
          *((void *)this + 4) = v41;
          id v42 = v41 + 8;
          uint64_t v43 = malloc(v41 + 8);
          *uint64_t v43 = *((void *)this + 3);
          uint64_t v31 = ((unint64_t)v43 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v43 + v42;
          *((void *)this + 3) = v43;
        }

        *((void *)this + 1) = v31 + 24;
        *(_WORD *)(v31 + 16) = 232;
        *(_BYTE *)(v31 + 18) = 0;
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v31,  (swift::Demangle::__runtime::Node *)v47,  this,  v44,  v45);
      }

      uint64_t v32 = v31;
      v39 -= 8LL;
      if (!v39) {
        return v31;
      }
    }

    return v32;
  }

  int64_t v37 = *((_DWORD *)this + 24);
  if (v37 && (v38 = v37 - 1, uint64_t v32 = *(void *)(*((void *)this + 11) + 8LL * v38), *(_WORD *)(v32 + 16) == 232))
  {
    *((_DWORD *)this + 24) = v38;
    if (v14) {
      goto LABEL_47;
    }
  }

  else
  {
    uint64_t v32 = 0LL;
    if (v14) {
      goto LABEL_47;
    }
  }

  return v32;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(unsigned int a1)
{
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  unint64_t v3 = swift_allocObject(v2, 0x28uLL, 7uLL);
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 1LL;
  v3[3] = 2 * (v5 >> 3);
  v3[4] = a1;
  return v3;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(unsigned __int16 a1)
{
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  unint64_t v3 = swift_allocObject(v2, 0x28uLL, 7uLL);
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 1LL;
  v3[3] = 2 * (v5 >> 3);
  v3[4] = a1;
  return v3;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(unsigned __int8 a1)
{
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  unint64_t v3 = swift_allocObject(v2, 0x28uLL, 7uLL);
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 1LL;
  v3[3] = 2 * (v5 >> 3);
  v3[4] = a1;
  return v3;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(int a1)
{
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  unint64_t v3 = swift_allocObject(v2, 0x28uLL, 7uLL);
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 1LL;
  v3[3] = 2 * (v5 >> 3);
  v3[4] = a1;
  return v3;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(__int16 a1)
{
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  unint64_t v3 = swift_allocObject(v2, 0x28uLL, 7uLL);
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 1LL;
  v3[3] = 2 * (v5 >> 3);
  v3[4] = a1;
  return v3;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(char a1)
{
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  unint64_t v3 = swift_allocObject(v2, 0x28uLL, 7uLL);
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 1LL;
  v3[3] = 2 * (v5 >> 3);
  v3[4] = a1;
  return v3;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)(void *a1)
{
  uint64_t v2 = specialized RandomAccessCollection<>.distance(from:to:)(0, (uint64_t)objc_msgSend(a1, sel_count), a1);
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v3 = v2;
  int64_t v4 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v2, 0LL);
  if (v3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v5 = v4;
  uint64_t v6 = specialized RandomAccessCollection<>.distance(from:to:)(0, (uint64_t)objc_msgSend(a1, sel_count), a1);
  if (v3 >= v6) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = v3;
  }
  if (v10 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v11 = v6;
  swift_unknownObjectRetain(a1, v7, v8, v9);
  specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)(0LL, v10, (void **)v5 + 4, a1);
  swift_unknownObjectRelease(a1);
  if ((id)v10 != objc_msgSend(a1, sel_count))
  {
    id v13 = objc_msgSend(a1, sel_objectAtIndex_, v10);
    specialized RandomAccessCollection<>.index(after:)(v10, a1);
    swift_unknownObjectRelease(v13);
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  if (v3 > v11) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  return v5;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)( unint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v5 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(HIBYTE(a2) & 0xF, 0LL);
  uint64_t v6 = specialized Sequence._copySequenceContents(initializing:)(&v9, (uint64_t)(v5 + 4), v2, a1, a2);
  unint64_t v7 = v10 & 0xF;
  if (v11 != v7)
  {
    if (v11 < v7) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
    }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  if (v6 != v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  return v5;
}

{
  uint64_t v4;
  __objc2_class **v5;
  __objc2_class **v6;
  uint64_t v7;
  char v8;
  if ((a2 & 0x1000000000000000LL) == 0)
  {
    if ((a2 & 0x2000000000000000LL) != 0) {
      int64_t v4 = HIBYTE(a2) & 0xF;
    }
    else {
      int64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
    }
    if (v4) {
      goto LABEL_6;
    }
    return &_swiftEmptyArrayStorage;
  }

  int64_t v4 = String.UTF8View._foreignCount()();
  if (!v4) {
    return &_swiftEmptyArrayStorage;
  }
LABEL_6:
  uint64_t v5 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v4, 0LL);
  if (v4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v6 = v5;
  unint64_t v7 = _StringGuts.copyUTF8(into:)((char *)v5 + 32, v4, a1, a2);
  if ((v8 & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy string contents",  52LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0x1AEuLL,  0);
  }
  if (v7 != v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  return v6;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  Swift::Int v8 = Substring.distance(from:to:)((Swift::String::Index)a1, (Swift::String::Index)a2);
  if (!v8) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v9 = v8;
  char v10 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( v8,  0LL,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Character>);
  if (v9 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  Swift::Int v14 = v10;
  uint64_t v15 = (uint64_t *)(v10 + 4);
  swift_bridgeObjectRetain(a4, v11, v12, v13);
  uint64_t v16 = specialized Sequence._copySequenceContents(initializing:)(&v21, v15, v9, a1, a2, a3, a4);
  v17._Swift::UInt64 rawBits = v25;
  if ((v22 ^ v25) >= 0x4000)
  {
    Substring.subscript.getter(v25, v21, v22, v23, v24);
    uint64_t v20 = v19;
    Substring.index(after:)(v17);
    swift_bridgeObjectRelease(v20);
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  if (v16 != v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  swift_bridgeObjectRelease(v24);
  return v14;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)( Swift::UInt64 a1, Swift::UInt64 a2, uint64_t a3, unint64_t a4)
{
  Swift::Int v8 = String.UTF16View.distance(from:to:)((Swift::String::Index)a1, (Swift::String::Index)a2);
  if (!v8) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v9 = v8;
  char v10 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v8, 0LL);
  if (v9 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  Swift::Int v14 = v10;
  uint64_t v15 = (uint64_t)(v10 + 4);
  swift_bridgeObjectRetain(a4, v11, v12, v13);
  v16._Swift::UInt64 rawBits = a1;
  uint64_t v17 = specialized Sequence._copySequenceContents(initializing:)(&v27, v15, v9, v16, a2, a3, a4);
  if ((v28 ^ v31._rawBits) >= 0x4000)
  {
    uint64_t v19 = v29;
    unint64_t v20 = v30;
    Swift::UInt64 rawBits = v31._rawBits;
    v22._Swift::UInt64 rawBits = v31._rawBits;
    Substring.UTF16View.subscript.getter(v22, v27._rawBits, v28, v29, v30);
    uint64_t v23 = ((unint64_t)v19 >> 59) & 1;
    if ((v20 & 0x1000000000000000LL) == 0) {
      LOBYTE(v23) = 1;
    }
    Swift::UInt64 v24 = rawBits;
    if ((rawBits & 0xC) == 4LL << v23) {
      Swift::UInt64 v24 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    unint64_t v25 = HIBYTE(v20) & 0xF;
    if ((v20 & 0x2000000000000000LL) == 0) {
      unint64_t v25 = v19 & 0xFFFFFFFFFFFFLL;
    }
    if (v25 > v24 >> 16)
    {
      if ((v20 & 0x1000000000000000LL) != 0)
      {
        specialized String.UTF16View._foreignIndex(after:)(v24);
      }

      else
      {
        uint64_t v26 = (v20 >> 62) & 1;
        if ((v20 & 0x2000000000000000LL) == 0) {
          LOBYTE(v26) = v19 < 0;
        }
        if ((v26 & 1) == 0)
        {
          if ((v24 & 0xC001) == 0) {
            _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v24);
          }
          if (!(v20 & 0x2000000000000000LL | v19 & 0x1000000000000000LL)) {
            _StringObject.sharedUTF8.getter(v19, v20);
          }
        }
      }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  0x93uLL,  0);
  }

  if (v17 != v9) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  swift_bridgeObjectRelease(v30);
  return v14;
}

void *specialized _copyCollectionToContiguousArray<A>(_:)(uint64_t a1)
{
  uint64_t v2 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>();
  uint64_t v3 = swift_allocObject(v2, 0x28uLL, 7uLL);
  int64_t v4 = _swift_stdlib_malloc_size(v3);
  uint64_t v5 = v4 - 32;
  if (v4 < 32) {
    uint64_t v5 = v4 - 25;
  }
  v3[2] = 1LL;
  v3[3] = 2 * (v5 >> 3);
  v3[4] = a1;
  return v3;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)( uint64_t a1, uint64_t a2, void (*a3)(__objc2_class **, uint64_t, uint64_t, uint64_t))
{
  if (!a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v5 = a2 - a1;
  if (a2 == a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v6 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(a2 - a1, 0LL);
  a3(v6 + 4, v5, a1, a2);
  uint64_t v9 = v8;
  if ((*(_WORD *)&UnsafeRawBufferPointer.Iterator.next()() & 0x100) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }
  if (v9 != v5) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  return v6;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v4 = a1;
  }
  uint64_t v5 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v5 = 11LL;
  }
  Swift::Int v6 = String.distance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)(v5 | (v4 << 16)));
  if (!v6) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v7 = v6;
  uint64_t v8 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( v6,  0LL,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Character>);
  if (v7 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v12 = v8;
  id v13 = (Swift::String_optional *)(v8 + 4);
  swift_bridgeObjectRetain(a2, v9, v10, v11);
  uint64_t v14 = specialized Sequence._copySequenceContents(initializing:)(v17, v13, v7, a1, a2);
  Swift::String_optional v15 = String.Iterator.next()();
  if (v15.value._object)
  {
    swift_bridgeObjectRelease((uint64_t)v15.value._object);
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  if (v14 != v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  swift_bridgeObjectRelease(v17[1]);
  return v12;
}

{
  uint64_t v4;
  Swift::Int v5;
  __objc2_class **v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  __objc2_class **v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _BYTE v15[8];
  uint64_t v16;
  if ((a2 & 0x1000000000000000LL) == 0)
  {
    uint64_t v4 = HIBYTE(a2) & 0xF;
    if ((a2 & 0x2000000000000000LL) == 0) {
      uint64_t v4 = a1;
    }
    uint64_t v5 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v4 << 16) | 7));
    if (v5) {
      goto LABEL_5;
    }
    return &_swiftEmptyArrayStorage;
  }

  uint64_t v5 = String.UTF16View._foreignCount()();
  if (!v5) {
    return &_swiftEmptyArrayStorage;
  }
LABEL_5:
  Swift::Int v6 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v5, 0LL);
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v10 = v6;
  uint64_t v11 = (uint64_t)(v6 + 4);
  swift_bridgeObjectRetain(a2, v7, v8, v9);
  uint64_t v12 = specialized Sequence._copySequenceContents(initializing:)((uint64_t)v15, v11, v5, a1, a2);
  *(Swift::UInt16_optional *)&id v13 = String.UTF16View.Iterator.next()();
  if ((v13 & 0x10000) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }
  if (v12 != v5) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  swift_bridgeObjectRelease(v16);
  return v10;
}

{
  Swift::String::Index v4;
  Swift::UInt64 rawBits;
  __objc2_class **v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  __objc2_class **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void v17[2];
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  v4._Swift::UInt64 rawBits = specialized Collection.count.getter(a1, a2)._rawBits;
  if (v4._rawBits)
  {
    Swift::UInt64 rawBits = v4._rawBits;
    Swift::Int v6 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( v4._rawBits,  0LL,  (uint64_t (*)(void))canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Unicode.Scalar>);
    if ((rawBits & 0x8000000000000000LL) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
    }
    uint64_t v10 = v6;
    uint64_t v11 = (uint64_t)(v6 + 4);
    swift_bridgeObjectRetain(a2, v7, v8, v9);
    uint64_t v12 = specialized Sequence._copySequenceContents(initializing:)(&v18, v11, rawBits, a1, a2);
    id v13 = v20;
    if (v20 < v21)
    {
      uint64_t v14 = v18;
      if ((v19 & 0x1000000000000000LL) != 0)
      {
        _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v20 << 16));
      }

      else
      {
        if ((v19 & 0x2000000000000000LL) != 0)
        {
          v17[0] = v18;
          v17[1] = v19 & 0xFFFFFFFFFFFFFFLL;
          Swift::String_optional v15 = v17;
        }

        else if ((v18 & 0x1000000000000000LL) != 0)
        {
          Swift::String_optional v15 = (void *)((v19 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          Swift::String_optional v15 = _StringObject.sharedUTF8.getter(v18, v19);
        }

        _decodeScalar(_:startingAt:)((uint64_t)v15, v14, v13);
      }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
    }

    if (v12 != rawBits) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
    }
    swift_bridgeObjectRelease(v19);
  }

  else
  {
    return &_swiftEmptyArrayStorage;
  }

  return v10;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)(char *a1, uint64_t a2)
{
  if (!a2) {
    return &_swiftEmptyArrayStorage;
  }
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
  uint64_t v5 = (char *)swift_allocObject(v4, 8 * a2 + 32, 7uLL);
  int64_t v6 = _swift_stdlib_malloc_size(v5);
  uint64_t v7 = v6 - 32;
  if (v6 < 32) {
    uint64_t v7 = v6 - 25;
  }
  *((void *)v5 + 2) = a2;
  *((void *)v5 + 3) = (2 * (v7 >> 3)) | 1;
  specialized UnsafeMutablePointer.initialize(from:count:)(a1, a2, v5 + 32);
  return (__objc2_class **)v5;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)(unint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v3 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>();
  uint64_t v4 = swift_allocObject(v3, 16 * v1 + 32, 7uLL);
  int64_t v5 = _swift_stdlib_malloc_size(v4);
  uint64_t v9 = v5 - 32;
  if (v5 < 32) {
    uint64_t v9 = v5 - 17;
  }
  v4[2] = v1;
  v4[3] = 2 * (v9 >> 4);
  swift_bridgeObjectRetain(a1, v6, v7, v8);
  uint64_t v10 = specialized Sequence._copySequenceContents(initializing:)(&v17, (uint64_t)(v4 + 4), v1, a1);
  if (v21) {
    goto LABEL_17;
  }
  int64_t v11 = v20 + 1;
  if (__OFADD__(v20, 1LL))
  {
    __break(1u);
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }

  int64_t v12 = (unint64_t)(v19 + 64) >> 6;
  if (v11 < v12)
  {
    if (!*(void *)(v18 + 8 * v11))
    {
      if (v20 + 2 >= v12) {
        goto LABEL_18;
      }
      if (!*(void *)(v18 + 8 * (v20 + 2)))
      {
        if (v20 + 3 >= v12) {
          goto LABEL_18;
        }
        if (!*(void *)(v18 + 8 * (v20 + 3)))
        {
          if (v20 + 4 >= v12) {
            goto LABEL_18;
          }
          if (!*(void *)(v18 + 8 * (v20 + 4)))
          {
            uint64_t v13 = v12 - v20 - 5;
            uint64_t v14 = (uint64_t *)(v18 + 8 * v20 + 40);
            while (v13)
            {
              uint64_t v15 = *v14++;
              --v13;
              if (v15) {
                goto LABEL_17;
              }
            }

            goto LABEL_18;
          }
        }
      }
    }

{
  uint64_t v1;
  uint64_t v3;
  char *v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v3 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>();
  uint64_t v4 = (char *)swift_allocObject(v3, 16 * v1 + 32, 7uLL);
  int64_t v5 = _swift_stdlib_malloc_size(v4);
  uint64_t v9 = v5 - 32;
  if (v5 < 32) {
    uint64_t v9 = v5 - 17;
  }
  *((void *)v4 + 2) = v1;
  *((void *)v4 + 3) = 2 * (v9 >> 4);
  swift_bridgeObjectRetain(a1, v6, v7, v8);
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)(a1 + 32), v1, v4 + 32);
  swift_bridgeObjectRelease(a1);
  return (__objc2_class **)v4;
}

LABEL_18:
  if (v10 != v1) {
    goto LABEL_23;
  }
  outlined consume of [A : B].Iterator._Variant<A, B>(v17);
  return (__objc2_class **)v4;
}

      __break(1u);
      goto LABEL_19;
    }

      uint64_t v6 = (v13 - 1) & v13;
      int64_t v11 = __clz(__rbit64(v13)) + (v4 << 6);
      if (v3) {
        goto LABEL_6;
      }
    }
  }

  __break(1u);
LABEL_41:
  __break(1u);
  return result;
}

      unint64_t v29 = validateUTF8(_:)(a1->i64, v25);
      if ((v73 & 1) != 0)
      {
        if ((v31 & 1) != 0) {
          return repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v25, v29, v30);
        }
        return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v25, v29 & 1);
      }

      if ((v31 & 1) == 0) {
        return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v25, v29 & 1);
      }
      return 0LL;
    }

    unint64_t v69 = v21;
    unint64_t v70 = v9;
    unint64_t v40 = *(uint64_t (**)(void))(v9 + 64);
    uint64_t v66 = *(void (**)(char *))(v14 + 16);
    BOOL v67 = v40;
    for (uint64_t i = a1; ; uint64_t i = (uint8x16_t *)((char *)v68 + *(void *)(v14 + 72)))
    {
      uint64_t v68 = i;
      uint64_t v45 = v69;
      v66(v23);
      LODWORD(v65) = v67();
      BOOL v46 = (*(uint64_t (**)(uint64_t))(v70 + 128))(v69);
      if ((v65 & 1) == 0)
      {
        if (v46 >= 64)
        {
          v74[0] = 0LL;
          char v65 = *(void *)(v70 + 96);
          uint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
          uint64_t v43 = v69;
          ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v65)( v74,  &type metadata for Int,  v52,  v69,  v70);
          LODWORD(v64) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v70 + 16) + 8LL)
                                                                            + 8LL))( v23,  v20,  v43);
          char v65 = *(void *)(v14 + 8);
          ((void (*)(char *, uint64_t))v65)(v23, v43);
          uint64_t v44 = v20;
LABEL_37:
          ((void (*)(char *, uint64_t))v65)(v44, v43);
          continue;
        }

        goto LABEL_47;
      }

      if (v46 > 64)
      {
LABEL_36:
        v74[0] = 0LL;
        char v65 = *(void *)(v70 + 96);
        id v42 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
        uint64_t v43 = v69;
        ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v65)( v74,  &type metadata for Int,  v42,  v69,  v70);
        LODWORD(v64) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v70 + 16) + 8LL)
                                                                          + 8LL))( v23,  v20,  v43);
        char v65 = *(void *)(v14 + 8);
        ((void (*)(char *, uint64_t))v65)(v20, v43);
        uint64_t v44 = v23;
        goto LABEL_37;
      }

      unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v71,  v69,  v10,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v10,  AssociatedConformanceWitness);
      (*((void (**)(char *))v71 + 3))(v12);
      LODWORD(v65) = (*(uint64_t (**)(char *, char *))(*(void *)(*(void *)(v70 + 32) + 8LL) + 32LL))( v23,  v20);
      uint64_t v50 = v69;
      uint64_t v64 = *(void (**)(char *, uint64_t))(v14 + 8);
      v64(v20, v69);
      (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v17, v23, v50);
      if ((v65 & 1) == 0)
      {
        v64(v17, v69);
        continue;
      }

      uint64_t v51 = (*(uint64_t (**)(uint64_t))(v70 + 120))(v69);
      v64(v17, v69);
LABEL_48:
      if (!v51)
      {
LABEL_52:
        uint64_t v53 = *(void *)(v14 + 72);
        if (!v53) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
        }
        if ((char *)v68 - (char *)a1 == 0x8000000000000000LL && v53 == -1) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
        }
        v74[0] = UnsafeBufferPointer.init(start:count:)((uint64_t)a1, ((char *)v68 - (char *)a1) / v53);
        v74[1] = v54;
        uint64_t v57 = (swift *)type metadata accessor for UnsafeBufferPointer(0LL, v69, v55, v56);
        uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, v57, v58);
        BOOL result = static String._fromCodeUnits<A, B>(_:encoding:repair:)( (uint64_t)v74,  (uint64_t)v72,  v73 & 1,  v57,  a4,  WitnessTable,  a5);
        if (v60) {
          return result;
        }
        return 0LL;
      }
    }

    BOOL v46 = (*(uint64_t (**)(uint64_t))(v70 + 128))(v69);
    if (v46 >= 64) {
      goto LABEL_36;
    }
LABEL_47:
    uint64_t v51 = (*(uint64_t (**)(uint64_t))(v70 + 120))(v69);
    (*(void (**)(char *, uint64_t))(v14 + 8))(v23, v69);
    goto LABEL_48;
  }

  if (!a1) {
    return 0LL;
  }
  Swift::Bool v33 = a1;
  if (a1->i16[0])
  {
    uint64_t v34 = &a1->u16[1];
    Swift::Bool v33 = a1;
    do
    {
      uint64_t v35 = *v34++;
      Swift::Bool v33 = (uint8x16_t *)((char *)v33 + 2);
    }

    while (v35);
  }

  uint64_t v36 = (char *)v33 - (char *)a1;
  if (v36 <= -2) {
    goto LABEL_33;
  }
  BOOL result = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, v36 / 2, v72, (char *)(v73 & 1));
  if (!v37) {
    return 0LL;
  }
  return result;
}

        v145 = v640;
        v146 = v638;
        v147 = swift_getAssociatedConformanceWitness( (uint64_t)v640,  (uint64_t)v69,  (uint64_t)v638,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v148 = *(char **)(v147 + 8);
        v149 = v639;
        v632 = (char *)v147;
        v629 = v148;
        ((void (*)(uint64_t *, uint64_t, void))v148)(&qword_18180BE70, 512LL, v146);
        v627 = (void (*)(char *, unint64_t *, char *))*((void *)v145 + 3);
        v627(v149, v69, (char *)v145);
        v150 = *(void *)(v631 + 8);
        v151 = v136;
        unint64_t v152 = *(void (**)(char *, char *, unint64_t *, uint64_t))(v150 + 24);
        v152(v125, v123, v69, v150);
        v153 = v151;
        v151(v123, v69);
        unint64_t v154 = (uint64_t (*)(unint64_t *, uint64_t))v645;
        if ((((uint64_t (*)(unint64_t *, uint64_t))v645)(v69, v67) & 1) != 0)
        {
          v155 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
          if (v155 < 64)
          {
            v158 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
            v153(v120, v69);
            if (v158 > -25) {
              goto LABEL_68;
            }
            goto LABEL_66;
          }

    BOOL v46 = (v25 - 1) & v25;
  }

  __break(1u);
  return result;
}

    *uint64_t v1 = 16;
    return (Swift::_MetadataKind_optional)rawValue;
  }

  switch(rawValue)
  {
    case 0x300uLL:
      *uint64_t v1 = 5;
      break;
    case 0x301uLL:
      *uint64_t v1 = 6;
      break;
    case 0x302uLL:
      *uint64_t v1 = 7;
      break;
    case 0x303uLL:
      *uint64_t v1 = 8;
      break;
    case 0x304uLL:
      *uint64_t v1 = 9;
      break;
    case 0x305uLL:
      *uint64_t v1 = 10;
      break;
    case 0x306uLL:
      *uint64_t v1 = 11;
      break;
    default:
      uint64_t v2 = 1;
      switch(rawValue)
      {
        case 0x200uLL:
          goto LABEL_17;
        case 0x201uLL:
          *uint64_t v1 = 2;
          break;
        case 0x202uLL:
          *uint64_t v1 = 3;
          break;
        case 0x203uLL:
          *uint64_t v1 = 4;
          break;
        default:
          if (rawValue) {
            goto LABEL_18;
          }
          uint64_t v2 = 0;
LABEL_17:
          *uint64_t v1 = v2;
          break;
      }

      break;
  }

  return (Swift::_MetadataKind_optional)rawValue;
}

        uint64_t v13 = __clz(__rbit64(v11));
        int64_t v5 = (v11 - 1) & v11;
        uint64_t v9 = v13 + (v10 << 6);
        uint64_t v6 = v10;
      }

      *a2++ = v9;
    }
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }

  __break(1u);
  return result;
}

        int64_t v12 = 1861LL;
        goto LABEL_21;
      }
    }

    int64_t v12 = 1860LL;
LABEL_21:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v12,  0);
  }

  specialized _StringGutsSlice._withNFCCodeUnits(_:)(a2, a3, a4, a5, a1);
LABEL_17:
  Hasher._combine(_:)(0xFFu);
}

  Swift::String::Index v16 = to._rawBits & 0xC;
  if ((to._rawBits & 2) == 0 || v16 == v14)
  {
    if (v16 == v14) {
      to._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(to)._rawBits;
    }
    if (to._rawBits >> 14 < v9 >> 14 || v15 < to._rawBits >> 14) {
      goto LABEL_78;
    }
    if ((to._rawBits & 1) != 0)
    {
      if ((v9 & 2) != 0) {
        goto LABEL_29;
      }
    }

    else
    {
      to._Swift::UInt64 rawBits = to._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(to)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
      if ((v9 & 2) != 0)
      {
LABEL_29:
        if ((to._rawBits & 2) != 0) {
          goto LABEL_33;
        }
      }
    }

    if (to._rawBits >> 14 != v9 >> 14 && to._rawBits >> 14 != v15) {
      to._Swift::UInt64 rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(to._rawBits, v9, v8, v7, v6);
    }
    goto LABEL_33;
  }

  if (to._rawBits >> 14 < v9 >> 14 || v15 < to._rawBits >> 14) {
    goto LABEL_22;
  }
LABEL_33:
  uint64_t v15 = to._rawBits >> 14;
  if (rawBits >> 14 < to._rawBits >> 14)
  {
    uint64_t v9 = 0LL;
    to._Swift::UInt64 rawBits = v8 >> 16;
    uint64_t v18 = HIBYTE(v6) & 0xF;
    uint64_t v19 = v6 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v20 = (v6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    uint64_t v14 = v7 & 0xFFFFFFFFFFFFLL;
    if (((v6 >> 60) & ((v7 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v21 = 8LL;
    }
    else {
      uint64_t v21 = 4LL;
    }
    while (1)
    {
      uint64_t v8 = v9 + 1;
      if (__OFADD__(v9, 1LL))
      {
        __break(1u);
LABEL_93:
        __break(1u);
LABEL_94:
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
LABEL_10:
        if (rawBits >> 14 < v9 >> 14 || v15 < rawBits >> 14)
        {
LABEL_78:
          uint64_t v17 = 65LL;
LABEL_79:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v17,  0);
        }

        if ((rawBits & 1) != 0)
        {
          if ((v9 & 2) != 0) {
            goto LABEL_14;
          }
LABEL_15:
          if (rawBits >> 14 != v9 >> 14 && rawBits >> 14 != v15) {
            Swift::UInt64 rawBits = _StringGuts._slowRoundDownToNearestCharacter(_:in:)(rawBits, v9, v8, v7, v6);
          }
        }

        else
        {
          Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3LL | 1;
          if ((v9 & 2) == 0) {
            goto LABEL_15;
          }
LABEL_14:
          if ((rawBits & 2) == 0) {
            goto LABEL_15;
          }
        }

        goto LABEL_18;
      }

      Swift::String::Index v22 = (rawBits >> 8) & 0x3F;
      uint64_t v23 = rawBits >> 16;
      if (!v22) {
        break;
      }
LABEL_53:
      Swift::String::Index v27 = v22 + v23;
      unint64_t v28 = v27 << 16;
      unint64_t v29 = v27 & 0xFFFFFFFFFFFFLL;
      if ((v27 & 0xFFFFFFFFFFFFLL) != to._rawBits)
      {
        if ((v6 & 0x1000000000000000LL) != 0) {
          goto LABEL_75;
        }
        if ((v6 & 0x2000000000000000LL) != 0)
        {
          uint64_t v54 = v7;
          uint64_t v55 = v19;
          if (v29 + 1 != v18)
          {
            Swift::Bool v33 = *(unsigned __int16 *)((char *)&v54 + v29);
LABEL_66:
            if (v33 == 2573 || (v33 & 0x8080) != 0)
            {
LABEL_75:
              BOOL v46 = v20;
              uint64_t v50 = v18;
              uint64_t v35 = v29;
              uint64_t v36 = v19;
              unint64_t v30 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v35);
              uint64_t v20 = v46;
              uint64_t v18 = v50;
              uint64_t v19 = v36;
              if (v30 > 63) {
                goto LABEL_73;
              }
              goto LABEL_72;
            }
          }
        }

        else
        {
          Swift::String::Index v31 = (char *)v20;
          uint64_t v32 = v7 & 0xFFFFFFFFFFFFLL;
          if ((v7 & 0x1000000000000000LL) == 0)
          {
            uint64_t v48 = v20;
            uint64_t v52 = v18;
            uint64_t v45 = v19;
            Swift::String::Index v31 = (char *)_StringObject.sharedUTF8.getter(v7, v6);
            uint64_t v19 = v45;
            uint64_t v20 = v48;
            uint64_t v18 = v52;
          }

          if (v29 + 1 != v32)
          {
            if (!v31) {
LABEL_99:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
            Swift::Bool v33 = *(unsigned __int16 *)&v31[v29];
            goto LABEL_66;
          }
        }

        unint64_t v30 = 1LL;
        goto LABEL_72;
      }

      unint64_t v30 = 0LL;
LABEL_72:
      v28 |= v30 << 8;
LABEL_73:
      Swift::UInt64 rawBits = v21 | v28 | 1;
      ++v9;
      if (v15 <= v28 >> 14) {
        return v8;
      }
    }

    if (v23 == to._rawBits)
    {
      Swift::String::Index v22 = 0LL;
      goto LABEL_53;
    }

    if ((v6 & 0x1000000000000000LL) == 0)
    {
      if ((v6 & 0x2000000000000000LL) == 0)
      {
        Swift::UInt64 v24 = (char *)v20;
        unint64_t v25 = v7 & 0xFFFFFFFFFFFFLL;
        if ((v7 & 0x1000000000000000LL) == 0)
        {
          uint64_t v49 = v20;
          uint64_t v53 = v18;
          uint64_t v38 = v19;
          Swift::UInt64 v24 = (char *)_StringObject.sharedUTF8.getter(v7, v6);
          uint64_t v20 = v49;
          uint64_t v18 = v53;
          uint64_t v19 = v38;
        }

        if (v23 + 1 == v25)
        {
LABEL_52:
          Swift::String::Index v22 = 1LL;
          goto LABEL_53;
        }

        if (!v24) {
          goto LABEL_99;
        }
        uint64_t v26 = *(unsigned __int16 *)&v24[v23];
        if (v26 == 2573) {
          goto LABEL_77;
        }
        goto LABEL_51;
      }

      uint64_t v54 = v7;
      uint64_t v55 = v19;
      if (v23 + 1 == v18) {
        goto LABEL_52;
      }
      uint64_t v26 = *(unsigned __int16 *)((char *)&v54 + v23);
      if (v26 != 2573)
      {
LABEL_51:
        if ((v26 & 0x80808080) == 0) {
          goto LABEL_52;
        }
      }
    }

  uint64_t v17 = v14 + v15;
  if (v16 >= v17) {
    Swift::String::Index v16 = v17;
  }
  if ((a5 & 0x1000000000000000LL) != 0) {
    return _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(v15, v16)._countAndFlagsBits;
  }
  if (v16 < v15) {
    goto LABEL_45;
  }
LABEL_22:
  if ((a5 & 0x2000000000000000LL) == 0)
  {
    if ((a4 & 0x1000000000000000LL) != 0)
    {
      uint64_t v18 = (id)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v19 = a4 & 0xFFFFFFFFFFFFLL;
      if ((a4 & 0xFFFFFFFFFFFFLL) >= v16)
      {
LABEL_25:
        uint64_t v20 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v15, v16, (uint64_t)v18, v19);
        return specialized static String._uncheckedFromUTF8(_:)(v20, v21);
      }
    }

    else
    {
      uint64_t v18 = _StringObject.sharedUTF8.getter(a4, a5);
      uint64_t v19 = v27;
      if (v27 >= v16) {
        goto LABEL_25;
      }
    }

        v57(v60, v5);
        goto LABEL_19;
      }
    }

    else if (v48 <= 32)
    {
      char v65 = v122;
      uint64_t v66 = v116;
      v46(v122, v116, v5);
      uint64_t v60 = v66;
      LODWORD(v66) = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
      uint64_t v57 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
      v57(v65, v5);
      uint64_t v36 = v120;
      goto LABEL_18;
    }

    uint64_t v61 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    uint64_t v62 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v48, v49, v50);
    Swift::Int v63 = v122;
    v61(&v125, &type metadata for UInt32, v62, v5, v7);
    uint64_t v60 = v116;
    uint64_t v64 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 16LL))( v63,  v116,  v5);
    uint64_t v57 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
    v57(v63, v5);
    uint64_t v36 = v120;
    if ((v64 & 1) != 0) {
      goto LABEL_34;
    }
    goto LABEL_18;
  }

        v54(v57, v5);
        goto LABEL_19;
      }
    }

    else if (v44 <= 32)
    {
      uint64_t v57 = v103;
      v95(v23, v103, v5);
      uint64_t v61 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
      uint64_t v54 = (void (*)(_BYTE *, uint64_t))*((void *)v10 + 1);
      v54(v23, v5);
      if (v111 < v61) {
        goto LABEL_32;
      }
      goto LABEL_18;
    }

    uint64_t v58 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    uint64_t v59 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v44, v45, v46);
    v58(&v111, &type metadata for UInt32, v59, v5, v7);
    uint64_t v57 = v103;
    uint64_t v60 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(void *)(*(void *)(v7 + 32) + 8LL) + 16LL))( v23,  v103,  v5);
    uint64_t v54 = (void (*)(_BYTE *, uint64_t))*((void *)v10 + 1);
    v54(v23, v5);
    if ((v60 & 1) != 0) {
      goto LABEL_32;
    }
    goto LABEL_18;
  }

  BOOL result = (*(uint64_t (**)(char *, unint64_t))(v31 + 8))(v17, AssociatedTypeWitness);
  if (*v4 < HIDWORD(a1)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  if (HIDWORD(a1))
  {
    unint64_t v28 = HIDWORD(a1);
    while (v28 <= HIDWORD(a1))
    {
      if (HIBYTE(v23)) {
        goto LABEL_31;
      }
      v23 |= v28 << (-(__clz(v23) & 0x18) & 0x18);
      unint64_t v29 = v28 > 0xFF;
      LODWORD(v28) = v28 >> 8;
      if (!v29) {
        goto LABEL_24;
      }
    }

    goto LABEL_30;
  }

  uint64_t v58 = v122(a3, a4);
  uint64_t v59 = v121(a3, a4);
  if ((v58 & 1) != 0)
  {
    if (v59 > 64) {
      goto LABEL_20;
    }
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    BOOL result = v65(v29, a3);
    if (v66 > 128) {
      goto LABEL_24;
    }
    goto LABEL_25;
  }

  if (v59 <= 63) {
    goto LABEL_23;
  }
LABEL_20:
  unint64_t v124 = 128LL;
  uint64_t v62 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  Swift::Int v63 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
  v62(&v124, &type metadata for Int, v63, a3, a4);
  uint64_t v64 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
  char v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  BOOL result = v65(v29, a3);
  if ((v64 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  uint64_t v109 = (uint64_t *)v65;
  BOOL v67 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v68 = v120;
  v67(v120, a2, a3);
  unint64_t v69 = v122(a3, a4);
  unint64_t v70 = v116;
  v67(v116, (uint64_t)v68, a3);
  char v119 = v30;
  if ((v69 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v109)(v70, a3);
    unsigned int v73 = v117;
    uint64_t v72 = v118;
    goto LABEL_42;
  }

  uint64_t v71 = v121(a3, a4);
  ((void (*)(char *, uint64_t))v109)(v70, a3);
  unsigned int v73 = v117;
  uint64_t v72 = v118;
  if (v71 <= 64) {
    goto LABEL_42;
  }
  unint64_t v74 = v111;
  v67(v111, (uint64_t)v120, a3);
  unint64_t v124 = 0x8000000000000000LL;
  uint64_t v75 = v122;
  if ((v122(a3, a4) & 1) != 0)
  {
    BOOL v76 = v121(a3, a4);
    if (v76 < 64)
    {
LABEL_37:
      v67(v29, (uint64_t)v74, a3);
      Swift::Int v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v83 = v109;
      ((void (*)(char *, uint64_t))v109)(v29, a3);
      if (v84 < v124) {
LABEL_70:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      goto LABEL_41;
    }

  uint64_t v120 = v30;
  uint64_t v52 = v28(a3, a4);
  uint64_t v53 = v30(a3, a4);
  if ((v52 & 1) != 0)
  {
    if (v53 > 64) {
      goto LABEL_20;
    }
  }

  else if (v53 >= 64)
  {
LABEL_20:
    unint64_t v122 = 128LL;
    uint64_t v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v57 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    v56(&v122, &type metadata for Int, v57, a3, a4);
    LOBYTE(v56) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v27,  a2,  a3);
    uint64_t v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    BOOL result = v58(v27, a3);
LABEL_28:
    uint64_t v71 = 0LL;
    uint64_t v72 = 0LL;
    unsigned int v73 = v118;
    goto LABEL_62;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
  unint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  BOOL result = v58(v27, a3);
  if (v70 > 128) {
    goto LABEL_28;
  }
LABEL_21:
  uint64_t v59 = *(void (**)(void))(v9 + 16);
  uint64_t v60 = v117;
  v59();
  uint64_t v61 = v119(a3, a4);
  ((void (*)(char *, char *, uint64_t))v59)(v23, v60, a3);
  if ((v61 & 1) == 0)
  {
    v58(v23, a3);
    Swift::Int v63 = v116;
    goto LABEL_45;
  }

  uint64_t v62 = v120(a3, a4);
  v58(v23, a3);
  Swift::Int v63 = v116;
  if (v62 <= 64) {
    goto LABEL_45;
  }
  uint64_t v64 = v111;
  ((void (*)(char *, char *, uint64_t))v59)(v111, v60, a3);
  unint64_t v122 = 0x8000000000000000LL;
  char v65 = v119;
  if ((v119(a3, a4) & 1) != 0)
  {
    uint64_t v66 = v120(a3, a4);
    if (v66 < 64)
    {
      unint64_t v69 = v27;
      goto LABEL_39;
    }

    unint64_t v81 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v82 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v81(&v122, &type metadata for Int, v82, a3, a4);
    uint64_t v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v64,  v27,  a3);
    goto LABEL_34;
  }

  unint64_t v74 = v65(a3, a4);
  uint64_t v75 = v120(a3, a4);
  if ((v74 & 1) != 0)
  {
    if (v75 <= 64)
    {
      Swift::Int v86 = AssociatedTypeWitness;
      Swift::String v85 = (void (**)(char *, uint64_t, const char *))v114;
      uint64_t v87 = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v88 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))( &unk_18180BE68,  256LL,  v86,  v87);
      v85[3](v88, a3, (const char *)v85);
      int64_t v89 = v111;
      LOBYTE(v85) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v27,  a3);
      v58(v27, a3);
      uint64_t v90 = v110;
      ((void (*)(char *, char *, uint64_t))v59)(v110, v89, a3);
      if ((v85 & 1) != 0)
      {
        v58(v90, a3);
        goto LABEL_73;
      }

      char v91 = v122;
      uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v58(v90, a3);
      uint64_t v45 = v92 < v91;
      uint64_t v60 = v117;
      uint64_t v64 = v111;
      if (v45) {
        goto LABEL_73;
      }
LABEL_43:
      uint64_t v108 = v64;
      goto LABEL_44;
    }

    uint64_t v78 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v79 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
    v78(&v122, &type metadata for Int, v79, a3, a4);
    uint64_t v64 = v111;
    uint64_t v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v27,  a3);
LABEL_34:
    uint64_t v83 = v80;
    v58(v27, a3);
    if ((v83 & 1) != 0) {
      goto LABEL_73;
    }
    goto LABEL_43;
  }

  if (v75 < 64)
  {
    unint64_t v69 = v27;
    uint64_t v64 = v111;
LABEL_39:
    ((void (*)(char *, char *, uint64_t))v59)(v69, v64, a3);
    Swift::Int v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
    if (v84 < v122) {
LABEL_73:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
    goto LABEL_43;
  }

  uint64_t v108 = v111;
LABEL_44:
  v58(v108, a3);
LABEL_45:
  unint64_t v93 = v120;
  uint64_t v94 = v120(a3, a4);
  uint64_t v95 = v115;
  ((void (*)(char *, char *, uint64_t))v59)(v115, v60, a3);
  if (v94 >= 65)
  {
    v58(v95, a3);
    goto LABEL_47;
  }

  uint64_t v103 = v93(a3, a4);
  v58(v95, a3);
  if (v103 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_47:
    ((void (*)(char *, char *, uint64_t))v59)(v63, v60, a3);
    unint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v96 = v119(a3, a4);
    unint64_t v97 = v120(a3, a4);
    if ((v96 & 1) != 0)
    {
      if (v97 > 64)
      {
        uint64_t v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
        uint64_t v102 = &v122;
        goto LABEL_56;
      }
    }

    else if (v97 >= 64)
    {
      unint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
      uint64_t v102 = &v121;
LABEL_56:
      v100(v102, &type metadata for Int, v101, a3, a4);
      uint64_t v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v27,  v63,  a3);
      v58(v27, a3);
      if ((v104 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_57;
    }

    ((void (*)(char *, char *, uint64_t))v59)(v27, v63, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
LABEL_57:
    v58(v63, a3);
  }

  uint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  BOOL result = v58(v60, a3);
  unsigned int v73 = v118;
  uint64_t v107 = *v118;
  uint64_t v106 = v118[1];
  if ((v105 & 0x8000000000000000LL) == 0)
  {
    if (v105 < 0x80)
    {
      uint64_t v71 = ((2 * v106) << ~(_BYTE)v105) | (v107 >> v105);
      uint64_t v72 = v106 >> v105;
      if ((v105 & 0x40) != 0)
      {
        uint64_t v71 = v72;
        uint64_t v72 = 0LL;
      }

      goto LABEL_62;
    }

  uint64_t v58 = v122(a3, a4);
  uint64_t v59 = v121(a3, a4);
  if ((v58 & 1) != 0)
  {
    if (v59 > 64) {
      goto LABEL_20;
    }
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    BOOL result = v65(v29, a3);
    if (v66 > 128) {
      goto LABEL_24;
    }
    goto LABEL_25;
  }

  if (v59 <= 63) {
    goto LABEL_23;
  }
LABEL_20:
  unint64_t v124 = 128LL;
  uint64_t v62 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  Swift::Int v63 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
  v62(&v124, &type metadata for Int, v63, a3, a4);
  uint64_t v64 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
  char v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  BOOL result = v65(v29, a3);
  if ((v64 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  uint64_t v109 = (uint64_t *)v65;
  BOOL v67 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v68 = v120;
  v67(v120, a2, a3);
  unint64_t v69 = v122(a3, a4);
  unint64_t v70 = v116;
  v67(v116, (uint64_t)v68, a3);
  char v119 = v30;
  if ((v69 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v109)(v70, a3);
    unsigned int v73 = v117;
    uint64_t v72 = v118;
    goto LABEL_42;
  }

  uint64_t v71 = v121(a3, a4);
  ((void (*)(char *, uint64_t))v109)(v70, a3);
  unsigned int v73 = v117;
  uint64_t v72 = v118;
  if (v71 <= 64) {
    goto LABEL_42;
  }
  unint64_t v74 = v111;
  v67(v111, (uint64_t)v120, a3);
  unint64_t v124 = 0x8000000000000000LL;
  uint64_t v75 = v122;
  if ((v122(a3, a4) & 1) != 0)
  {
    BOOL v76 = v121(a3, a4);
    if (v76 < 64)
    {
LABEL_37:
      v67(v29, (uint64_t)v74, a3);
      Swift::Int v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v83 = v109;
      ((void (*)(char *, uint64_t))v109)(v29, a3);
      if (v84 < v124) {
LABEL_74:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
      goto LABEL_41;
    }

  uint64_t v120 = v30;
  uint64_t v52 = v28(a3, a4);
  uint64_t v53 = v30(a3, a4);
  if ((v52 & 1) != 0)
  {
    if (v53 > 64) {
      goto LABEL_20;
    }
  }

  else if (v53 >= 64)
  {
LABEL_20:
    unint64_t v122 = 128LL;
    uint64_t v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v57 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    v56(&v122, &type metadata for Int, v57, a3, a4);
    LOBYTE(v56) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v27,  a2,  a3);
    uint64_t v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    BOOL result = v58(v27, a3);
LABEL_28:
    uint64_t v71 = 0LL;
    uint64_t v72 = 0LL;
    unsigned int v73 = v118;
    goto LABEL_62;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
  unint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  BOOL result = v58(v27, a3);
  if (v70 > 128) {
    goto LABEL_28;
  }
LABEL_21:
  uint64_t v59 = *(void (**)(void))(v9 + 16);
  uint64_t v60 = v117;
  v59();
  uint64_t v61 = v119(a3, a4);
  ((void (*)(char *, char *, uint64_t))v59)(v23, v60, a3);
  if ((v61 & 1) == 0)
  {
    v58(v23, a3);
    Swift::Int v63 = v116;
    goto LABEL_45;
  }

  uint64_t v62 = v120(a3, a4);
  v58(v23, a3);
  Swift::Int v63 = v116;
  if (v62 <= 64) {
    goto LABEL_45;
  }
  uint64_t v64 = v111;
  ((void (*)(char *, char *, uint64_t))v59)(v111, v60, a3);
  unint64_t v122 = 0x8000000000000000LL;
  char v65 = v119;
  if ((v119(a3, a4) & 1) != 0)
  {
    uint64_t v66 = v120(a3, a4);
    if (v66 < 64)
    {
      unint64_t v69 = v27;
      goto LABEL_39;
    }

    unint64_t v81 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v82 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v81(&v122, &type metadata for Int, v82, a3, a4);
    uint64_t v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v64,  v27,  a3);
    goto LABEL_34;
  }

  unint64_t v74 = v65(a3, a4);
  uint64_t v75 = v120(a3, a4);
  if ((v74 & 1) != 0)
  {
    if (v75 <= 64)
    {
      Swift::Int v86 = AssociatedTypeWitness;
      Swift::String v85 = (void (**)(char *, uint64_t, const char *))v114;
      uint64_t v87 = swift_getAssociatedConformanceWitness( (uint64_t)v114,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v88 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))( &unk_18180BE68,  256LL,  v86,  v87);
      v85[3](v88, a3, (const char *)v85);
      int64_t v89 = v111;
      LOBYTE(v85) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v27,  a3);
      v58(v27, a3);
      uint64_t v90 = v110;
      ((void (*)(char *, char *, uint64_t))v59)(v110, v89, a3);
      if ((v85 & 1) != 0)
      {
        v58(v90, a3);
        goto LABEL_73;
      }

      char v91 = v122;
      uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v58(v90, a3);
      uint64_t v45 = v92 < v91;
      uint64_t v60 = v117;
      uint64_t v64 = v111;
      if (v45) {
        goto LABEL_73;
      }
LABEL_43:
      uint64_t v108 = v64;
      goto LABEL_44;
    }

    uint64_t v78 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v79 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
    v78(&v122, &type metadata for Int, v79, a3, a4);
    uint64_t v64 = v111;
    uint64_t v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v111,  v27,  a3);
LABEL_34:
    uint64_t v83 = v80;
    v58(v27, a3);
    if ((v83 & 1) != 0) {
      goto LABEL_73;
    }
    goto LABEL_43;
  }

  if (v75 < 64)
  {
    unint64_t v69 = v27;
    uint64_t v64 = v111;
LABEL_39:
    ((void (*)(char *, char *, uint64_t))v59)(v69, v64, a3);
    Swift::Int v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
    if (v84 < v122) {
LABEL_73:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
    goto LABEL_43;
  }

  uint64_t v108 = v111;
LABEL_44:
  v58(v108, a3);
LABEL_45:
  unint64_t v93 = v120;
  uint64_t v94 = v120(a3, a4);
  uint64_t v95 = v115;
  ((void (*)(char *, char *, uint64_t))v59)(v115, v60, a3);
  if (v94 >= 65)
  {
    v58(v95, a3);
    goto LABEL_47;
  }

  uint64_t v103 = v93(a3, a4);
  v58(v95, a3);
  if (v103 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_47:
    ((void (*)(char *, char *, uint64_t))v59)(v63, v60, a3);
    unint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v96 = v119(a3, a4);
    unint64_t v97 = v120(a3, a4);
    if ((v96 & 1) != 0)
    {
      if (v97 > 64)
      {
        uint64_t v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
        uint64_t v102 = &v122;
        goto LABEL_56;
      }
    }

    else if (v97 >= 64)
    {
      unint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      char v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
      uint64_t v102 = &v121;
LABEL_56:
      v100(v102, &type metadata for Int, v101, a3, a4);
      uint64_t v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v27,  v63,  a3);
      v58(v27, a3);
      if ((v104 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_57;
    }

    ((void (*)(char *, char *, uint64_t))v59)(v27, v63, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
LABEL_57:
    v58(v63, a3);
  }

  uint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  BOOL result = v58(v60, a3);
  unsigned int v73 = v118;
  uint64_t v106 = *v118;
  uint64_t v107 = v118[1];
  if ((v105 & 0x8000000000000000LL) == 0)
  {
    if (v105 < 0x80)
    {
      uint64_t v72 = (v107 << v105) | (v106 >> 1 >> ~(_BYTE)v105);
      uint64_t v71 = v106 << v105;
      if ((v105 & 0x40) != 0)
      {
        uint64_t v72 = v71;
        uint64_t v71 = 0LL;
      }

      goto LABEL_62;
    }

    uint64_t v56 = v127(a3, a4);
    uint64_t v57 = v33(a3, a4);
    unint64_t v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64) {
        goto LABEL_20;
      }
    }

    else if (v57 > 63)
    {
LABEL_20:
      Swift::String v129 = 8LL;
      uint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      uint64_t v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
      Swift::Int v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        char v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        uint64_t v66 = v124;
        v65(v124, a2, a3);
        BOOL v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          uint64_t v71 = v123;
          unint64_t v70 = v124;
          uint64_t v68 = v125;
          uint64_t v79 = v125(a3, a4);
          goto LABEL_47;
        }

        uint64_t v68 = v125;
        unint64_t v69 = v125(a3, a4);
        v63(v26, a3);
        uint64_t v71 = v123;
        unint64_t v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          uint64_t v79 = v68(a3, a4);
LABEL_47:
          unint64_t v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            uint64_t v109 = v68(a3, a4);
            v63(v71, a3);
            uint64_t v110 = v109 == 64;
            uint64_t v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              BOOL result = v63(v70, a3);
              if ((v112 & 0x8000000000000000LL) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFF8LL)
                {
                  uint64_t v55 = v122 << -(char)v112;
                  goto LABEL_64;
                }
              }

              else if (v112 < 8)
              {
                uint64_t v55 = v122 >> v112;
                goto LABEL_64;
              }

              goto LABEL_24;
            }
          }

          else
          {
            v63(v71, a3);
            uint64_t v100 = v127;
          }

          char v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          Swift::String v129 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v102 = v100(a3, a4);
          uint64_t v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              uint64_t v108 = &v129;
              goto LABEL_59;
            }
          }

          else if (v103 > 63)
          {
            unint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            uint64_t v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v101,  a3);
            v63(v30, a3);
            if ((v111 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_60;
          }

          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }

        v115 = v63;
        uint64_t v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        Swift::String v129 = 0x8000000000000000LL;
        unsigned int v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          unint64_t v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            uint64_t v77 = v72;
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129) {
LABEL_69:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
            goto LABEL_44;
          }

          uint64_t v77 = v72;
          uint64_t v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          uint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v77,  v30,  a3);
        }

        else
        {
          uint64_t v80 = v73(a3, a4);
          unint64_t v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            Swift::Int v63 = v115;
            if (v81 > 64)
            {
              uint64_t v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }

            uint64_t v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }

          if (v81 <= 64)
          {
            char v91 = AssociatedTypeWitness;
            uint64_t v90 = (void (**)(char *, uint64_t, const char *))v120;
            unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            unint64_t v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))( &qword_18180BE68,  256LL,  v91,  AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            uint64_t v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v117,  v30,  a3);
            v115(v30, a3);
            uint64_t v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }

            unint64_t v96 = v129;
            unint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v95, a3);
            uint64_t v98 = v97 < v96;
            unint64_t v70 = v124;
            uint64_t v77 = v117;
            if (v98) {
              goto LABEL_69;
            }
LABEL_44:
            uint64_t v113 = v77;
            goto LABEL_45;
          }

          Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          uint64_t v77 = v117;
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
        }

        int64_t v89 = v86;
        Swift::Int v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0) {
          goto LABEL_69;
        }
        goto LABEL_44;
      }

    uint64_t v62 = v141(a3, a4);
    Swift::Int v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64) {
        goto LABEL_20;
      }
    }

    else if (v63 >= 64)
    {
LABEL_20:
      unint64_t v144 = 8LL;
      uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      uint64_t v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
      unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        unsigned int v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        unint64_t v74 = v140;
        v73(v140, a2, a3);
        uint64_t v75 = v141(a3, a4);
        BOOL v76 = v139;
        uint64_t v77 = v74;
        uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        uint64_t v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          uint64_t v80 = v140;
          goto LABEL_42;
        }

        uint64_t v79 = v32(a3, a4);
        v70(v76, a3);
        uint64_t v80 = v140;
        if (v79 <= 64) {
          goto LABEL_42;
        }
        unint64_t v81 = v135;
        v78(v135, v140, a3);
        unint64_t v144 = 0x8000000000000000LL;
        uint64_t v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          uint64_t v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            Swift::Int v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            uint64_t v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v135,  v88,  a3);
            int64_t v89 = v88;
            unint64_t v81 = v135;
            v70(v89, a3);
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v90 = v82(a3, a4);
          char v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
              uint64_t v103 = v133;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v103,  AssociatedConformanceWitness);
              uint64_t v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              uint64_t v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                + 16LL))( v135,  v106,  a3);
              uint64_t v108 = v106;
              unint64_t v81 = v107;
              v70(v108, a3);
              uint64_t v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }

              uint64_t v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              uint64_t v112 = v111 < v110;
              uint64_t v80 = v140;
              if (v112) {
                goto LABEL_64;
              }
            }

            else
            {
              uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              unint64_t v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              unint64_t v97 = v135;
              uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
              unint64_t v99 = v96;
              unint64_t v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0) {
                goto LABEL_64;
              }
            }

            goto LABEL_41;
          }

          if (v91 >= 64) {
            goto LABEL_41;
          }
        }

        uint64_t v100 = v142;
        v78(v142, v81, a3);
        char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144) {
LABEL_64:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        uint64_t v113 = v132;
        uint64_t v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          unint64_t v124 = v113(a3, a4);
          v70(v115, a3);
          unint64_t v125 = v124 == 64;
          int64_t v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            BOOL result = v70(v80, a3);
            v130 = *(unsigned __int8 *)v39;
            if ((v129 & 0x8000000000000000LL) != 0)
            {
              if (v129 >= 0xFFFFFFFFFFFFFFF9LL)
              {
                uint64_t v61 = v130 << -(char)v129;
                goto LABEL_59;
              }
            }

            else if (v129 < 8)
            {
              uint64_t v61 = v130 >> v129;
              goto LABEL_59;
            }

            goto LABEL_24;
          }
        }

        else
        {
          v70(v115, a3);
          int64_t v116 = v141;
        }

        v78(v40, v80, a3);
        unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
        int64_t v117 = v116(a3, a4);
        int64_t v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            uint64_t v123 = &v144;
            goto LABEL_54;
          }
        }

        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          uint64_t v123 = &v143;
LABEL_54:
          unint64_t v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
          v70(v127, a3);
          if ((v128 & 1) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
          goto LABEL_55;
        }

        char v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }

    uint64_t v62 = v141(a3, a4);
    Swift::Int v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64) {
        goto LABEL_20;
      }
    }

    else if (v63 >= 64)
    {
LABEL_20:
      unint64_t v144 = 8LL;
      uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      uint64_t v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
      unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        unsigned int v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        unint64_t v74 = v140;
        v73(v140, a2, a3);
        uint64_t v75 = v141(a3, a4);
        BOOL v76 = v139;
        uint64_t v77 = v74;
        uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        uint64_t v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          uint64_t v80 = v140;
          goto LABEL_42;
        }

        uint64_t v79 = v32(a3, a4);
        v70(v76, a3);
        uint64_t v80 = v140;
        if (v79 <= 64) {
          goto LABEL_42;
        }
        unint64_t v81 = v135;
        v78(v135, v140, a3);
        unint64_t v144 = 0x8000000000000000LL;
        uint64_t v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          uint64_t v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            Swift::Int v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            uint64_t v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v135,  v88,  a3);
            int64_t v89 = v88;
            unint64_t v81 = v135;
            v70(v89, a3);
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v90 = v82(a3, a4);
          char v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
              uint64_t v103 = v133;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v103,  AssociatedConformanceWitness);
              uint64_t v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              uint64_t v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                + 16LL))( v135,  v106,  a3);
              uint64_t v108 = v106;
              unint64_t v81 = v107;
              v70(v108, a3);
              uint64_t v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }

              uint64_t v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              uint64_t v112 = v111 < v110;
              uint64_t v80 = v140;
              if (v112) {
                goto LABEL_64;
              }
            }

            else
            {
              uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              unint64_t v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              unint64_t v97 = v135;
              uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
              unint64_t v99 = v96;
              unint64_t v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0) {
                goto LABEL_64;
              }
            }

            goto LABEL_41;
          }

          if (v91 >= 64) {
            goto LABEL_41;
          }
        }

        uint64_t v100 = v142;
        v78(v142, v81, a3);
        char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144) {
LABEL_64:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        uint64_t v113 = v132;
        uint64_t v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          unint64_t v124 = v113(a3, a4);
          v70(v115, a3);
          unint64_t v125 = v124 == 64;
          int64_t v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            BOOL result = v70(v80, a3);
            v130 = *(unsigned __int8 *)v39;
            if ((v129 & 0x8000000000000000LL) != 0)
            {
              if (v129 > 0xFFFFFFFFFFFFFFF8LL)
              {
                uint64_t v61 = v130 >> -(char)v129;
                goto LABEL_59;
              }
            }

            else if (v129 < 8)
            {
              uint64_t v61 = v130 << v129;
              goto LABEL_59;
            }

            goto LABEL_24;
          }
        }

        else
        {
          v70(v115, a3);
          int64_t v116 = v141;
        }

        v78(v40, v80, a3);
        unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
        int64_t v117 = v116(a3, a4);
        int64_t v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            uint64_t v123 = &v144;
            goto LABEL_54;
          }
        }

        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          uint64_t v123 = &v143;
LABEL_54:
          unint64_t v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
          v70(v127, a3);
          if ((v128 & 1) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
          goto LABEL_55;
        }

        char v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }

    LOBYTE(v61) = 0;
    goto LABEL_59;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  id v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      unint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_19;
    }

    uint64_t v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    unint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -8) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (v42 <= 64)
  {
    uint64_t v55 = v137;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    uint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
    uint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      LOBYTE(v61) = 0;
      uint64_t v39 = v132;
      goto LABEL_59;
    }

    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }

  unint64_t v144 = -8LL;
  uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  BOOL v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  uint64_t v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
  BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  unint64_t v40 = v131;
  uint64_t v39 = v132;
  if ((v48 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v62 = v141(a3, a4);
  Swift::Int v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
  }

  else if (v63 >= 64)
  {
LABEL_21:
    unint64_t v144 = 8LL;
    uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    uint64_t v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
    unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v70(v68, a3);
    if ((v69 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_30:
    uint64_t v61 = *(char *)v39 >> 7;
    goto LABEL_59;
  }

  uint64_t v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  int64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  BOOL result = v70(v88, a3);
  if (v89 > 8) {
    goto LABEL_30;
  }
LABEL_22:
  uint64_t v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v72 = v140;
  v71(v140, a2, a3);
  unsigned int v73 = v141(a3, a4);
  unint64_t v74 = v139;
  uint64_t v75 = v72;
  BOOL v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  uint64_t v132 = v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    uint64_t v78 = v140;
    goto LABEL_42;
  }

  uint64_t v77 = v32(a3, a4);
  v70(v74, a3);
  uint64_t v78 = v140;
  if (v77 <= 64) {
    goto LABEL_42;
  }
  uint64_t v79 = v135;
  v76(v135, v140, a3);
  unint64_t v144 = 0x8000000000000000LL;
  uint64_t v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    unint64_t v81 = v132(a3, a4);
    if (v81 >= 64)
    {
      Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      Swift::Int v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v86,  a3);
      uint64_t v87 = v86;
      uint64_t v79 = v135;
      v70(v87, a3);
      goto LABEL_41;
    }
  }

  else
  {
    uint64_t v90 = v80(a3, a4);
    char v91 = v132(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
        uint64_t v103 = v133;
        uint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        uint64_t v79 = v107;
        v70(v108, a3);
        uint64_t v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }

        uint64_t v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        uint64_t v78 = v140;
        if (v112) {
          goto LABEL_65;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        unint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        unint64_t v97 = v135;
        uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        unint64_t v99 = v96;
        uint64_t v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_65;
        }
      }

      goto LABEL_41;
    }

    if (v91 >= 64) {
      goto LABEL_41;
    }
  }

  uint64_t v100 = v142;
  v76(v142, v79, a3);
  char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_65:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  uint64_t v113 = v132;
  uint64_t v114 = v132(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    int64_t v116 = v141;
    goto LABEL_44;
  }

  unint64_t v124 = v113(a3, a4);
  v70(v115, a3);
  unint64_t v125 = v124 == 64;
  int64_t v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v117 = v116(a3, a4);
    int64_t v118 = v132(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        uint64_t v123 = &v144;
        goto LABEL_54;
      }
    }

    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v143;
LABEL_54:
      unint64_t v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
      v70(v127, a3);
      if ((v128 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    char v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }

  Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  BOOL result = v70(v78, a3);
  v130 = *(unsigned __int8 *)v39;
  if ((v129 & 0x8000000000000000LL) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFF8LL)
    {
      uint64_t v61 = v130 << -(char)v129;
      goto LABEL_59;
    }

    goto LABEL_18;
  }

  if (v129 >= 8) {
    uint64_t v61 = (char)v130 >> 7;
  }
  else {
    uint64_t v61 = (char)v130 >> v129;
  }
LABEL_59:
  *(_BYTE *)uint64_t v39 = v61;
  return result;
}

    uint64_t v56 = v127(a3, a4);
    uint64_t v57 = v33(a3, a4);
    unint64_t v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64) {
        goto LABEL_20;
      }
    }

    else if (v57 > 63)
    {
LABEL_20:
      Swift::String v129 = 16LL;
      uint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      uint64_t v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
      Swift::Int v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        char v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        uint64_t v66 = v124;
        v65(v124, a2, a3);
        BOOL v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          uint64_t v71 = v123;
          unint64_t v70 = v124;
          uint64_t v68 = v125;
          uint64_t v79 = v125(a3, a4);
          goto LABEL_47;
        }

        uint64_t v68 = v125;
        unint64_t v69 = v125(a3, a4);
        v63(v26, a3);
        uint64_t v71 = v123;
        unint64_t v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          uint64_t v79 = v68(a3, a4);
LABEL_47:
          unint64_t v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            uint64_t v109 = v68(a3, a4);
            v63(v71, a3);
            uint64_t v110 = v109 == 64;
            uint64_t v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              BOOL result = v63(v70, a3);
              if ((v112 & 0x8000000000000000LL) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFF0LL)
                {
                  uint64_t v55 = v122 << -(char)v112;
                  goto LABEL_64;
                }
              }

              else if (v112 < 0x10)
              {
                uint64_t v55 = v122 >> v112;
                goto LABEL_64;
              }

              goto LABEL_24;
            }
          }

          else
          {
            v63(v71, a3);
            uint64_t v100 = v127;
          }

          char v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          Swift::String v129 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v102 = v100(a3, a4);
          uint64_t v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              uint64_t v108 = &v129;
              goto LABEL_59;
            }
          }

          else if (v103 > 63)
          {
            unint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            uint64_t v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v101,  a3);
            v63(v30, a3);
            if ((v111 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_60;
          }

          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }

        v115 = v63;
        uint64_t v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        Swift::String v129 = 0x8000000000000000LL;
        unsigned int v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          unint64_t v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            uint64_t v77 = v72;
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129) {
LABEL_69:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
            goto LABEL_44;
          }

          uint64_t v77 = v72;
          uint64_t v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          uint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v77,  v30,  a3);
        }

        else
        {
          uint64_t v80 = v73(a3, a4);
          unint64_t v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            Swift::Int v63 = v115;
            if (v81 > 64)
            {
              uint64_t v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }

            uint64_t v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }

          if (v81 <= 64)
          {
            char v91 = AssociatedTypeWitness;
            uint64_t v90 = (void (**)(char *, uint64_t, const char *))v120;
            unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            unint64_t v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))( &qword_18180BE68,  256LL,  v91,  AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            uint64_t v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v117,  v30,  a3);
            v115(v30, a3);
            uint64_t v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }

            unint64_t v96 = v129;
            unint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v95, a3);
            uint64_t v98 = v97 < v96;
            unint64_t v70 = v124;
            uint64_t v77 = v117;
            if (v98) {
              goto LABEL_69;
            }
LABEL_44:
            uint64_t v113 = v77;
            goto LABEL_45;
          }

          Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          uint64_t v77 = v117;
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
        }

        int64_t v89 = v86;
        Swift::Int v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0) {
          goto LABEL_69;
        }
        goto LABEL_44;
      }

    uint64_t v62 = v141(a3, a4);
    Swift::Int v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64) {
        goto LABEL_20;
      }
    }

    else if (v63 >= 64)
    {
LABEL_20:
      unint64_t v144 = 16LL;
      uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      uint64_t v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
      unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        unsigned int v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        unint64_t v74 = v140;
        v73(v140, a2, a3);
        uint64_t v75 = v141(a3, a4);
        BOOL v76 = v139;
        uint64_t v77 = v74;
        uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        uint64_t v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          uint64_t v80 = v140;
          goto LABEL_42;
        }

        uint64_t v79 = v32(a3, a4);
        v70(v76, a3);
        uint64_t v80 = v140;
        if (v79 <= 64) {
          goto LABEL_42;
        }
        unint64_t v81 = v135;
        v78(v135, v140, a3);
        unint64_t v144 = 0x8000000000000000LL;
        uint64_t v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          uint64_t v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            Swift::Int v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            uint64_t v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v135,  v88,  a3);
            int64_t v89 = v88;
            unint64_t v81 = v135;
            v70(v89, a3);
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v90 = v82(a3, a4);
          char v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
              uint64_t v103 = v133;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v103,  AssociatedConformanceWitness);
              uint64_t v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              uint64_t v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                + 16LL))( v135,  v106,  a3);
              uint64_t v108 = v106;
              unint64_t v81 = v107;
              v70(v108, a3);
              uint64_t v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }

              uint64_t v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              uint64_t v112 = v111 < v110;
              uint64_t v80 = v140;
              if (v112) {
                goto LABEL_64;
              }
            }

            else
            {
              uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              unint64_t v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              unint64_t v97 = v135;
              uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
              unint64_t v99 = v96;
              unint64_t v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0) {
                goto LABEL_64;
              }
            }

            goto LABEL_41;
          }

          if (v91 >= 64) {
            goto LABEL_41;
          }
        }

        uint64_t v100 = v142;
        v78(v142, v81, a3);
        char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144) {
LABEL_64:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        uint64_t v113 = v132;
        uint64_t v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          unint64_t v124 = v113(a3, a4);
          v70(v115, a3);
          unint64_t v125 = v124 == 64;
          int64_t v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            BOOL result = v70(v80, a3);
            v130 = *(unsigned __int16 *)v39;
            if ((v129 & 0x8000000000000000LL) != 0)
            {
              if (v129 >= 0xFFFFFFFFFFFFFFF1LL)
              {
                uint64_t v61 = v130 << -(char)v129;
                goto LABEL_59;
              }
            }

            else if (v129 < 0x10)
            {
              uint64_t v61 = v130 >> v129;
              goto LABEL_59;
            }

            goto LABEL_24;
          }
        }

        else
        {
          v70(v115, a3);
          int64_t v116 = v141;
        }

        v78(v40, v80, a3);
        unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
        int64_t v117 = v116(a3, a4);
        int64_t v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            uint64_t v123 = &v144;
            goto LABEL_54;
          }
        }

        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          uint64_t v123 = &v143;
LABEL_54:
          unint64_t v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
          v70(v127, a3);
          if ((v128 & 1) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
          goto LABEL_55;
        }

        char v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }

    uint64_t v62 = v141(a3, a4);
    Swift::Int v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64) {
        goto LABEL_20;
      }
    }

    else if (v63 >= 64)
    {
LABEL_20:
      unint64_t v144 = 16LL;
      uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      uint64_t v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
      unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        unsigned int v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        unint64_t v74 = v140;
        v73(v140, a2, a3);
        uint64_t v75 = v141(a3, a4);
        BOOL v76 = v139;
        uint64_t v77 = v74;
        uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        uint64_t v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          uint64_t v80 = v140;
          goto LABEL_42;
        }

        uint64_t v79 = v32(a3, a4);
        v70(v76, a3);
        uint64_t v80 = v140;
        if (v79 <= 64) {
          goto LABEL_42;
        }
        unint64_t v81 = v135;
        v78(v135, v140, a3);
        unint64_t v144 = 0x8000000000000000LL;
        uint64_t v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          uint64_t v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            Swift::Int v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            uint64_t v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v135,  v88,  a3);
            int64_t v89 = v88;
            unint64_t v81 = v135;
            v70(v89, a3);
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v90 = v82(a3, a4);
          char v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
              uint64_t v103 = v133;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v103,  AssociatedConformanceWitness);
              uint64_t v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              uint64_t v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                + 16LL))( v135,  v106,  a3);
              uint64_t v108 = v106;
              unint64_t v81 = v107;
              v70(v108, a3);
              uint64_t v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }

              uint64_t v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              uint64_t v112 = v111 < v110;
              uint64_t v80 = v140;
              if (v112) {
                goto LABEL_64;
              }
            }

            else
            {
              uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              unint64_t v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              unint64_t v97 = v135;
              uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
              unint64_t v99 = v96;
              unint64_t v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0) {
                goto LABEL_64;
              }
            }

            goto LABEL_41;
          }

          if (v91 >= 64) {
            goto LABEL_41;
          }
        }

        uint64_t v100 = v142;
        v78(v142, v81, a3);
        char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144) {
LABEL_64:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        uint64_t v113 = v132;
        uint64_t v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          unint64_t v124 = v113(a3, a4);
          v70(v115, a3);
          unint64_t v125 = v124 == 64;
          int64_t v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            BOOL result = v70(v80, a3);
            v130 = *(unsigned __int16 *)v39;
            if ((v129 & 0x8000000000000000LL) != 0)
            {
              if (v129 > 0xFFFFFFFFFFFFFFF0LL)
              {
                uint64_t v61 = v130 >> -(char)v129;
                goto LABEL_59;
              }
            }

            else if (v129 < 0x10)
            {
              uint64_t v61 = v130 << v129;
              goto LABEL_59;
            }

            goto LABEL_24;
          }
        }

        else
        {
          v70(v115, a3);
          int64_t v116 = v141;
        }

        v78(v40, v80, a3);
        unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
        int64_t v117 = v116(a3, a4);
        int64_t v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            uint64_t v123 = &v144;
            goto LABEL_54;
          }
        }

        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          uint64_t v123 = &v143;
LABEL_54:
          unint64_t v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
          v70(v127, a3);
          if ((v128 & 1) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
          goto LABEL_55;
        }

        char v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }

    LOWORD(v61) = 0;
    goto LABEL_59;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  id v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      unint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_19;
    }

    uint64_t v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    unint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -16) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (v42 <= 64)
  {
    uint64_t v55 = v137;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    uint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
    uint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      LOWORD(v61) = 0;
      uint64_t v39 = v132;
      goto LABEL_59;
    }

    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }

  unint64_t v144 = -16LL;
  uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  BOOL v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  uint64_t v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
  BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  unint64_t v40 = v131;
  uint64_t v39 = v132;
  if ((v48 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v62 = v141(a3, a4);
  Swift::Int v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
  }

  else if (v63 >= 64)
  {
LABEL_21:
    unint64_t v144 = 16LL;
    uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    uint64_t v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
    unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v70(v68, a3);
    if ((v69 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_30:
    uint64_t v61 = (__int16)*v39 >> 15;
    goto LABEL_59;
  }

  uint64_t v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  int64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  BOOL result = v70(v88, a3);
  if (v89 > 16) {
    goto LABEL_30;
  }
LABEL_22:
  uint64_t v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v72 = v140;
  v71(v140, a2, a3);
  unsigned int v73 = v141(a3, a4);
  unint64_t v74 = v139;
  uint64_t v75 = v72;
  BOOL v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  uint64_t v132 = (unsigned __int16 *)v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    uint64_t v78 = v140;
    goto LABEL_42;
  }

  uint64_t v77 = v32(a3, a4);
  v70(v74, a3);
  uint64_t v78 = v140;
  if (v77 <= 64) {
    goto LABEL_42;
  }
  uint64_t v79 = v135;
  v76(v135, v140, a3);
  unint64_t v144 = 0x8000000000000000LL;
  uint64_t v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    unint64_t v81 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v81 >= 64)
    {
      Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      Swift::Int v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v86,  a3);
      uint64_t v87 = v86;
      uint64_t v79 = v135;
      v70(v87, a3);
      goto LABEL_41;
    }
  }

  else
  {
    uint64_t v90 = v80(a3, a4);
    char v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
        uint64_t v103 = v133;
        uint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        uint64_t v79 = v107;
        v70(v108, a3);
        uint64_t v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }

        uint64_t v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        uint64_t v78 = v140;
        if (v112) {
          goto LABEL_65;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        unint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        unint64_t v97 = v135;
        uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        unint64_t v99 = v96;
        uint64_t v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_65;
        }
      }

      goto LABEL_41;
    }

    if (v91 >= 64) {
      goto LABEL_41;
    }
  }

  uint64_t v100 = v142;
  v76(v142, v79, a3);
  char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_65:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  uint64_t v113 = v132;
  uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    int64_t v116 = v141;
    goto LABEL_44;
  }

  unint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  unint64_t v125 = v124 == 64;
  int64_t v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v117 = v116(a3, a4);
    int64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        uint64_t v123 = &v144;
        goto LABEL_54;
      }
    }

    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v143;
LABEL_54:
      unint64_t v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
      v70(v127, a3);
      if ((v128 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    char v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }

  Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  BOOL result = v70(v78, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFF0LL)
    {
      uint64_t v61 = v130 << -(char)v129;
      goto LABEL_59;
    }

    goto LABEL_18;
  }

  if (v129 >= 0x10) {
    uint64_t v61 = (__int16)v130 >> 15;
  }
  else {
    uint64_t v61 = (__int16)v130 >> v129;
  }
LABEL_59:
  char *v39 = v61;
  return result;
}

    uint64_t v56 = v127(a3, a4);
    uint64_t v57 = v33(a3, a4);
    unint64_t v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64) {
        goto LABEL_20;
      }
    }

    else if (v57 > 63)
    {
LABEL_20:
      Swift::String v129 = 32LL;
      uint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      uint64_t v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
      Swift::Int v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        char v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        uint64_t v66 = v124;
        v65(v124, a2, a3);
        BOOL v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          uint64_t v71 = v123;
          unint64_t v70 = v124;
          uint64_t v68 = v125;
          uint64_t v79 = v125(a3, a4);
          goto LABEL_47;
        }

        uint64_t v68 = v125;
        unint64_t v69 = v125(a3, a4);
        v63(v26, a3);
        uint64_t v71 = v123;
        unint64_t v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          uint64_t v79 = v68(a3, a4);
LABEL_47:
          unint64_t v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            uint64_t v109 = v68(a3, a4);
            v63(v71, a3);
            uint64_t v110 = v109 == 64;
            uint64_t v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              BOOL result = v63(v70, a3);
              if ((v112 & 0x8000000000000000LL) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFE0LL)
                {
                  uint64_t v55 = v122 << -(char)v112;
                  goto LABEL_64;
                }
              }

              else if (v112 < 0x20)
              {
                uint64_t v55 = v122 >> v112;
                goto LABEL_64;
              }

              goto LABEL_24;
            }
          }

          else
          {
            v63(v71, a3);
            uint64_t v100 = v127;
          }

          char v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          Swift::String v129 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v102 = v100(a3, a4);
          uint64_t v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              uint64_t v108 = &v129;
              goto LABEL_59;
            }
          }

          else if (v103 > 63)
          {
            unint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            uint64_t v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v101,  a3);
            v63(v30, a3);
            if ((v111 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_60;
          }

          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }

        v115 = v63;
        uint64_t v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        Swift::String v129 = 0x8000000000000000LL;
        unsigned int v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          unint64_t v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            uint64_t v77 = v72;
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129) {
LABEL_69:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
            goto LABEL_44;
          }

          uint64_t v77 = v72;
          uint64_t v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          uint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v77,  v30,  a3);
        }

        else
        {
          uint64_t v80 = v73(a3, a4);
          unint64_t v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            Swift::Int v63 = v115;
            if (v81 > 64)
            {
              uint64_t v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }

            uint64_t v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }

          if (v81 <= 64)
          {
            char v91 = AssociatedTypeWitness;
            uint64_t v90 = (void (**)(char *, uint64_t, const char *))v120;
            unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            unint64_t v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))( &qword_18180BE68,  256LL,  v91,  AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            uint64_t v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v117,  v30,  a3);
            v115(v30, a3);
            uint64_t v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }

            unint64_t v96 = v129;
            unint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v95, a3);
            uint64_t v98 = v97 < v96;
            unint64_t v70 = v124;
            uint64_t v77 = v117;
            if (v98) {
              goto LABEL_69;
            }
LABEL_44:
            uint64_t v113 = v77;
            goto LABEL_45;
          }

          Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          uint64_t v77 = v117;
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
        }

        int64_t v89 = v86;
        Swift::Int v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0) {
          goto LABEL_69;
        }
        goto LABEL_44;
      }

    uint64_t v62 = v141(a3, a4);
    Swift::Int v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64) {
        goto LABEL_20;
      }
    }

    else if (v63 >= 64)
    {
LABEL_20:
      unint64_t v144 = 32LL;
      uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      uint64_t v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
      unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        unsigned int v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        unint64_t v74 = v140;
        v73(v140, a2, a3);
        uint64_t v75 = v141(a3, a4);
        BOOL v76 = v139;
        uint64_t v77 = v74;
        uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        uint64_t v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          uint64_t v80 = v140;
          goto LABEL_42;
        }

        uint64_t v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
        v70(v76, a3);
        uint64_t v80 = v140;
        if (v79 <= 64) {
          goto LABEL_42;
        }
        unint64_t v81 = v135;
        v78(v135, v140, a3);
        unint64_t v144 = 0x8000000000000000LL;
        uint64_t v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          uint64_t v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if (v83 >= 64)
          {
            Swift::Int v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            uint64_t v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v135,  v88,  a3);
            int64_t v89 = v88;
            unint64_t v81 = v135;
            v70(v89, a3);
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v90 = v82(a3, a4);
          char v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
              uint64_t v103 = v133;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v103,  AssociatedConformanceWitness);
              uint64_t v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              uint64_t v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                + 16LL))( v135,  v106,  a3);
              uint64_t v108 = v106;
              unint64_t v81 = v107;
              v70(v108, a3);
              uint64_t v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }

              uint64_t v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              uint64_t v112 = v111 < v110;
              uint64_t v80 = v140;
              if (v112) {
                goto LABEL_64;
              }
            }

            else
            {
              uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              unint64_t v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              unint64_t v97 = v135;
              uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
              unint64_t v99 = v96;
              unint64_t v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0) {
                goto LABEL_64;
              }
            }

            goto LABEL_41;
          }

          if (v91 >= 64) {
            goto LABEL_41;
          }
        }

        uint64_t v100 = v142;
        v78(v142, v81, a3);
        char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144) {
LABEL_64:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        uint64_t v113 = v132;
        uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          unint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
          v70(v115, a3);
          unint64_t v125 = v124 == 64;
          int64_t v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            BOOL result = v70(v80, a3);
            v130 = *v39;
            if ((v129 & 0x8000000000000000LL) != 0)
            {
              if (v129 >= 0xFFFFFFFFFFFFFFE1LL)
              {
                uint64_t v61 = v130 << -(char)v129;
                goto LABEL_59;
              }
            }

            else if (v129 < 0x20)
            {
              uint64_t v61 = v130 >> v129;
              goto LABEL_59;
            }

            goto LABEL_24;
          }
        }

        else
        {
          v70(v115, a3);
          int64_t v116 = v141;
        }

        v78(v40, v80, a3);
        unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
        int64_t v117 = v116(a3, a4);
        int64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            uint64_t v123 = &v144;
            goto LABEL_54;
          }
        }

        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          uint64_t v123 = &v143;
LABEL_54:
          unint64_t v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
          v70(v127, a3);
          if ((v128 & 1) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
          goto LABEL_55;
        }

        char v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }

    uint64_t v56 = v127(a3, a4);
    uint64_t v57 = v33(a3, a4);
    unint64_t v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64) {
        goto LABEL_20;
      }
    }

    else if (v57 > 63)
    {
LABEL_20:
      Swift::String v129 = 32LL;
      uint64_t v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      uint64_t v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
      Swift::Int v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        char v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        uint64_t v66 = v124;
        v65(v124, a2, a3);
        BOOL v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          uint64_t v71 = v123;
          unint64_t v70 = v124;
          uint64_t v68 = v125;
          uint64_t v79 = v125(a3, a4);
          goto LABEL_47;
        }

        uint64_t v68 = v125;
        unint64_t v69 = v125(a3, a4);
        v63(v26, a3);
        uint64_t v71 = v123;
        unint64_t v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          uint64_t v79 = v68(a3, a4);
LABEL_47:
          unint64_t v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            uint64_t v109 = v68(a3, a4);
            v63(v71, a3);
            uint64_t v110 = v109 == 64;
            uint64_t v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              BOOL result = v63(v70, a3);
              if ((v112 & 0x8000000000000000LL) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFE0LL)
                {
                  uint64_t v55 = v122 >> -(char)v112;
                  goto LABEL_64;
                }
              }

              else if (v112 <= 0x1F)
              {
                uint64_t v55 = v122 << v112;
                goto LABEL_64;
              }

              goto LABEL_24;
            }
          }

          else
          {
            v63(v71, a3);
            uint64_t v100 = v127;
          }

          char v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          Swift::String v129 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v102 = v100(a3, a4);
          uint64_t v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              uint64_t v108 = &v129;
              goto LABEL_59;
            }
          }

          else if (v103 > 63)
          {
            unint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            uint64_t v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v101,  a3);
            v63(v30, a3);
            if ((v111 & 1) != 0) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
            }
            goto LABEL_60;
          }

          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }

        v115 = v63;
        uint64_t v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        Swift::String v129 = 0x8000000000000000LL;
        unsigned int v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          unint64_t v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            uint64_t v77 = v72;
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129) {
LABEL_69:
            }
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
            goto LABEL_44;
          }

          uint64_t v77 = v72;
          uint64_t v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          uint64_t v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v77,  v30,  a3);
        }

        else
        {
          uint64_t v80 = v73(a3, a4);
          unint64_t v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            Swift::Int v63 = v115;
            if (v81 > 64)
            {
              uint64_t v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }

            uint64_t v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }

          if (v81 <= 64)
          {
            char v91 = AssociatedTypeWitness;
            uint64_t v90 = (void (**)(char *, uint64_t, const char *))v120;
            unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            unint64_t v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))( &qword_18180BE68,  256LL,  v91,  AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            uint64_t v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v117,  v30,  a3);
            v115(v30, a3);
            uint64_t v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }

            unint64_t v96 = v129;
            unint64_t v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            Swift::Int v63 = v115;
            v115(v95, a3);
            uint64_t v98 = v97 < v96;
            unint64_t v70 = v124;
            uint64_t v77 = v117;
            if (v98) {
              goto LABEL_69;
            }
LABEL_44:
            uint64_t v113 = v77;
            goto LABEL_45;
          }

          Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          uint64_t v77 = v117;
          Swift::Int v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v117,  v30,  a3);
        }

        int64_t v89 = v86;
        Swift::Int v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0) {
          goto LABEL_69;
        }
        goto LABEL_44;
      }

    uint64_t v62 = v141(a3, a4);
    Swift::Int v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64) {
        goto LABEL_20;
      }
    }

    else if (v63 >= 64)
    {
LABEL_20:
      unint64_t v144 = 32LL;
      uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      uint64_t v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
      unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      BOOL result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        unsigned int v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        unint64_t v74 = v140;
        v73(v140, a2, a3);
        uint64_t v75 = v141(a3, a4);
        BOOL v76 = v139;
        uint64_t v77 = v74;
        uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        uint64_t v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          uint64_t v80 = v140;
          goto LABEL_42;
        }

        uint64_t v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
        v70(v76, a3);
        uint64_t v80 = v140;
        if (v79 <= 64) {
          goto LABEL_42;
        }
        unint64_t v81 = v135;
        v78(v135, v140, a3);
        unint64_t v144 = 0x8000000000000000LL;
        uint64_t v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          uint64_t v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if (v83 >= 64)
          {
            Swift::Int v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            uint64_t v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                             + 16LL))( v135,  v88,  a3);
            int64_t v89 = v88;
            unint64_t v81 = v135;
            v70(v89, a3);
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v90 = v82(a3, a4);
          char v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
              uint64_t v103 = v133;
              unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              uint64_t v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  v103,  AssociatedConformanceWitness);
              uint64_t v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              uint64_t v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                                + 16LL))( v135,  v106,  a3);
              uint64_t v108 = v106;
              unint64_t v81 = v107;
              v70(v108, a3);
              uint64_t v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }

              uint64_t v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              uint64_t v112 = v111 < v110;
              uint64_t v80 = v140;
              if (v112) {
                goto LABEL_64;
              }
            }

            else
            {
              uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              unint64_t v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              unint64_t v97 = v135;
              uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
              unint64_t v99 = v96;
              unint64_t v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0) {
                goto LABEL_64;
              }
            }

            goto LABEL_41;
          }

          if (v91 >= 64) {
            goto LABEL_41;
          }
        }

        uint64_t v100 = v142;
        v78(v142, v81, a3);
        char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144) {
LABEL_64:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        uint64_t v113 = v132;
        uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          unint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
          v70(v115, a3);
          unint64_t v125 = v124 == 64;
          int64_t v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            BOOL result = v70(v80, a3);
            v130 = *v39;
            if ((v129 & 0x8000000000000000LL) != 0)
            {
              if (v129 > 0xFFFFFFFFFFFFFFE0LL)
              {
                uint64_t v61 = v130 >> -(char)v129;
                goto LABEL_59;
              }
            }

            else if (v129 < 0x20)
            {
              uint64_t v61 = v130 << v129;
              goto LABEL_59;
            }

            goto LABEL_24;
          }
        }

        else
        {
          v70(v115, a3);
          int64_t v116 = v141;
        }

        v78(v40, v80, a3);
        unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
        int64_t v117 = v116(a3, a4);
        int64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            uint64_t v123 = &v144;
            goto LABEL_54;
          }
        }

        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          uint64_t v123 = &v143;
LABEL_54:
          unint64_t v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
          v70(v127, a3);
          if ((v128 & 1) != 0) {
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
          }
          goto LABEL_55;
        }

        char v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }

    uint64_t v61 = 0;
    goto LABEL_59;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  uint64_t v32 = *(int **)(a4 + 128);
  id v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      unint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_19;
    }

    uint64_t v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    unint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -32) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (v42 <= 64)
  {
    uint64_t v55 = v137;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    uint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
    uint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      uint64_t v61 = 0;
      uint64_t v39 = v132;
      goto LABEL_59;
    }

    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }

  unint64_t v144 = -32LL;
  uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  BOOL v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  uint64_t v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
  BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  unint64_t v40 = v131;
  uint64_t v39 = v132;
  if ((v48 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v62 = v141(a3, a4);
  Swift::Int v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
  }

  else if (v63 >= 64)
  {
LABEL_21:
    unint64_t v144 = 32LL;
    uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    uint64_t v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
    unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v70(v68, a3);
    if ((v69 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_30:
    uint64_t v61 = *v39 >> 31;
    goto LABEL_59;
  }

  uint64_t v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  int64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  BOOL result = v70(v88, a3);
  if (v89 > 32) {
    goto LABEL_30;
  }
LABEL_22:
  uint64_t v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v72 = v140;
  v71(v140, a2, a3);
  unsigned int v73 = v141(a3, a4);
  unint64_t v74 = v139;
  uint64_t v75 = v72;
  BOOL v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  uint64_t v132 = v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    uint64_t v78 = v140;
    goto LABEL_42;
  }

  uint64_t v77 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v74, a3);
  uint64_t v78 = v140;
  if (v77 <= 64) {
    goto LABEL_42;
  }
  uint64_t v79 = v135;
  v76(v135, v140, a3);
  unint64_t v144 = 0x8000000000000000LL;
  uint64_t v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    unint64_t v81 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v81 >= 64)
    {
      Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      Swift::Int v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v86,  a3);
      uint64_t v87 = v86;
      uint64_t v79 = v135;
      v70(v87, a3);
      goto LABEL_41;
    }
  }

  else
  {
    uint64_t v90 = v80(a3, a4);
    char v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
        uint64_t v103 = v133;
        uint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        uint64_t v79 = v107;
        v70(v108, a3);
        uint64_t v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }

        uint64_t v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        uint64_t v78 = v140;
        if (v112) {
          goto LABEL_65;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        unint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        unint64_t v97 = v135;
        uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        unint64_t v99 = v96;
        uint64_t v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_65;
        }
      }

      goto LABEL_41;
    }

    if (v91 >= 64) {
      goto LABEL_41;
    }
  }

  uint64_t v100 = v142;
  v76(v142, v79, a3);
  char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_65:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  uint64_t v113 = v132;
  uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    int64_t v116 = v141;
    goto LABEL_44;
  }

  unint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  unint64_t v125 = v124 == 64;
  int64_t v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v117 = v116(a3, a4);
    int64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        uint64_t v123 = &v144;
        goto LABEL_54;
      }
    }

    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v143;
LABEL_54:
      unint64_t v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
      v70(v127, a3);
      if ((v128 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    char v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }

  Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  BOOL result = v70(v78, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFE0LL)
    {
      uint64_t v61 = v130 << -(char)v129;
      goto LABEL_59;
    }

    goto LABEL_18;
  }

  if (v129 >= 0x20) {
    uint64_t v61 = v130 >> 31;
  }
  else {
    uint64_t v61 = v130 >> v129;
  }
LABEL_59:
  char *v39 = v61;
  return result;
}

  uint64_t v56 = v127(a3, a4);
  uint64_t v57 = v33(a3, a4);
  unint64_t v125 = v33;
  if ((v56 & 1) != 0)
  {
    if (v57 > 64) {
      goto LABEL_20;
    }
    goto LABEL_23;
  }

  if (v57 <= 63)
  {
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    Swift::Int v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v63(v30, a3);
    if (v64 <= 64) {
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v55 = 0LL;
    goto LABEL_64;
  }

    uint64_t v55 = 0LL;
    goto LABEL_65;
  }

  uint64_t v50 = AssociatedTypeWitness;
  uint64_t v51 = v120;
  uint64_t v52 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))( &qword_18180BE68,  256LL,  v50,  v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v30,  a3);
  uint64_t v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
    goto LABEL_17;
  }

  BOOL result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  uint64_t v55 = 0LL;
LABEL_65:
  char *v126 = v55;
  return result;
}

    uint64_t v61 = 0LL;
    goto LABEL_59;
  }

  v131 = v19;
  uint64_t v132 = a1;
  uint64_t v41 = v29(a3, a4);
  uint64_t v32 = *(uint64_t **)(a4 + 128);
  id v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      unint64_t v40 = v131;
      uint64_t v39 = v132;
      goto LABEL_19;
    }

    uint64_t v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    unint64_t v40 = v131;
    uint64_t v39 = v132;
    if (v54 >= -64) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (v42 <= 64)
  {
    uint64_t v55 = v137;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &qword_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
    uint64_t v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    uint64_t v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v58,  a3);
    uint64_t v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      uint64_t v61 = 0LL;
      uint64_t v39 = v132;
      goto LABEL_59;
    }

    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    BOOL result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }

  unint64_t v144 = -64LL;
  uint64_t v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  BOOL v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  uint64_t v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v47,  a3);
  BOOL result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  unint64_t v40 = v131;
  uint64_t v39 = v132;
  if ((v48 & 1) != 0) {
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v62 = v141(a3, a4);
  Swift::Int v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_21;
    }
  }

  else if (v63 >= 64)
  {
LABEL_21:
    unint64_t v144 = 64LL;
    uint64_t v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    BOOL v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    uint64_t v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    unint64_t v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v68,  a2,  a3);
    unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v70(v68, a3);
    if ((v69 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_30:
    uint64_t v61 = *v39 >> 63;
    goto LABEL_59;
  }

  uint64_t v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  int64_t v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  BOOL result = v70(v88, a3);
  if (v89 > 64) {
    goto LABEL_30;
  }
LABEL_22:
  uint64_t v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v72 = v140;
  v71(v140, a2, a3);
  unsigned int v73 = v141(a3, a4);
  unint64_t v74 = v139;
  uint64_t v75 = v72;
  BOOL v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  uint64_t v132 = v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    uint64_t v78 = v140;
    goto LABEL_42;
  }

  uint64_t v77 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v74, a3);
  uint64_t v78 = v140;
  if (v77 <= 64) {
    goto LABEL_42;
  }
  uint64_t v79 = v135;
  v76(v135, v140, a3);
  unint64_t v144 = 0x8000000000000000LL;
  uint64_t v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    unint64_t v81 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v81 >= 64)
    {
      Swift::Int v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      Swift::String v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      Swift::Int v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v86,  a3);
      uint64_t v87 = v86;
      uint64_t v79 = v135;
      v70(v87, a3);
      goto LABEL_41;
    }
  }

  else
  {
    uint64_t v90 = v80(a3, a4);
    char v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        uint64_t v102 = (void (**)(char *, uint64_t, const char *))v137;
        uint64_t v103 = v133;
        uint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        uint64_t v79 = v107;
        v70(v108, a3);
        uint64_t v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }

        uint64_t v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        uint64_t v78 = v140;
        if (v112) {
          goto LABEL_65;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        unint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        unint64_t v97 = v135;
        uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        unint64_t v99 = v96;
        uint64_t v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_65;
        }
      }

      goto LABEL_41;
    }

    if (v91 >= 64) {
      goto LABEL_41;
    }
  }

  uint64_t v100 = v142;
  v76(v142, v79, a3);
  char v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_65:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  uint64_t v113 = v132;
  uint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    int64_t v116 = v141;
    goto LABEL_44;
  }

  unint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  unint64_t v125 = v124 == 64;
  int64_t v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    unint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v117 = v116(a3, a4);
    int64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        uint64_t v123 = &v144;
        goto LABEL_54;
      }
    }

    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v143;
LABEL_54:
      unint64_t v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
      v70(v127, a3);
      if ((v128 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    char v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }

  Swift::String v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  BOOL result = v70(v78, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFC0LL)
    {
      uint64_t v61 = v130 << -(char)v129;
      goto LABEL_59;
    }

    goto LABEL_18;
  }

  if (v129 >= 0x40) {
    uint64_t v61 = v130 >> 63;
  }
  else {
    uint64_t v61 = v130 >> v129;
  }
LABEL_59:
  char *v39 = v61;
  return result;
}

  uint64_t v55 = v127(a3, a4);
  uint64_t v56 = v33(a3, a4);
  unint64_t v125 = v33;
  if ((v55 & 1) != 0)
  {
    if (v56 > 64) {
      goto LABEL_20;
    }
    goto LABEL_23;
  }

  if (v56 <= 63)
  {
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    Swift::Int v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v62(v30, a3);
    if (v63 <= 64) {
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v64 = 0LL;
    goto LABEL_64;
  }

  uint64_t v62 = v141(a3, a4);
  Swift::Int v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_20;
    }
    goto LABEL_23;
  }

  if (v63 < 64)
  {
LABEL_23:
    uint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v70(v71, a3);
    if (v72 <= 64) {
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v61 = 0LL;
    goto LABEL_59;
  }

  uint64_t v120 = v32;
  uint64_t v55 = v30(a3, a4);
  uint64_t v56 = v32(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64) {
      goto LABEL_20;
    }
  }

  else if (v56 > 63)
  {
LABEL_20:
    unint64_t v122 = 64LL;
    uint64_t v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
    v59(&v122, &type metadata for Int, v60, a3, a4);
    LOBYTE(v59) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v29,  a2,  a3);
    uint64_t v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v61(v29, a3);
LABEL_29:
    uint64_t v53 = 0LL;
    goto LABEL_48;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  unint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  BOOL result = v61(v29, a3);
  if (v74 > 64) {
    goto LABEL_29;
  }
LABEL_21:
  uint64_t v62 = *(void (**)(void))(v11 + 16);
  Swift::Int v63 = v117;
  v62();
  uint64_t v64 = v119(a3, a4);
  ((void (*)(char *, char *, uint64_t))v62)(v25, v63, a3);
  if ((v64 & 1) == 0)
  {
    unsigned int v73 = v25;
    uint64_t v66 = v116;
    goto LABEL_31;
  }

  char v65 = v120(a3, a4);
  v61(v25, a3);
  uint64_t v66 = v116;
  if (v65 < 65) {
    goto LABEL_32;
  }
  BOOL v67 = v110;
  ((void (*)(char *, char *, uint64_t))v62)(v110, v63, a3);
  unint64_t v122 = 0x8000000000000000LL;
  uint64_t v68 = v119;
  if ((v119(a3, a4) & 1) == 0)
  {
    int64_t v89 = v68(a3, a4);
    uint64_t v90 = v120(a3, a4);
    if ((v89 & 1) != 0)
    {
      if (v90 > 64)
      {
        unint64_t v93 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        uint64_t v94 = lazy protocol witness table accessor for type Int and conformance Int(v90, v91, v92);
        v93(&v122, &type metadata for Int, v94, a3, a4);
        BOOL v67 = v110;
        uint64_t v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v110,  v29,  a3);
        goto LABEL_54;
      }

      uint64_t v102 = AssociatedTypeWitness;
      char v101 = (void (**)(char *, uint64_t, const char *))v113;
      uint64_t v103 = swift_getAssociatedConformanceWitness( (uint64_t)v113,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v104 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v103 + 8))( &qword_18180BE68,  256LL,  v102,  v103);
      v101[3](v104, a3, (const char *)v101);
      uint64_t v105 = v110;
      LOBYTE(v101) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v110,  v29,  a3);
      v61(v29, a3);
      uint64_t v106 = v109;
      ((void (*)(char *, char *, uint64_t))v62)(v109, v105, a3);
      if ((v101 & 1) != 0)
      {
        v61(v106, a3);
        goto LABEL_68;
      }

      uint64_t v107 = v122;
      uint64_t v108 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v106, a3);
      uint64_t v47 = v108 < v107;
      Swift::Int v63 = v117;
      unsigned int v73 = v110;
      if (!v47) {
        goto LABEL_31;
      }
    }

    else
    {
      if (v90 >= 64)
      {
        unsigned int v73 = v110;
        goto LABEL_31;
      }

      unint64_t v99 = v110;
      ((void (*)(char *, char *, uint64_t))v62)(v29, v110, a3);
      uint64_t v100 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      unsigned int v73 = v99;
      if (v100 >= v122) {
        goto LABEL_31;
      }
    }

  uint64_t v62 = v141(a3, a4);
  Swift::Int v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64) {
      goto LABEL_20;
    }
    goto LABEL_23;
  }

  if (v63 < 64)
  {
LABEL_23:
    uint64_t v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    BOOL result = v70(v71, a3);
    if (v72 <= 64) {
      goto LABEL_25;
    }
LABEL_24:
    uint64_t v61 = 0LL;
    goto LABEL_59;
  }

  int64_t v5 = by.low == 0;
  by.low = -by.low;
  by.high = -(by.high + !v5);
LABEL_19:
  uint64_t v6 = !is_mul_ok(v2, by.low);
  uint64_t v7 = !is_mul_ok(v1, by.high);
  uint64_t v8 = __CFADD__(v2 * by.low, v1 * by.high);
  uint64_t v9 = v1 * by.low;
  uint64_t v10 = (*(_OWORD *)&by * __PAIR128__(v2, v1)) >> 64;
  int64_t v11 = __CFADD__(v2 * by.low + v1 * by.high, (v1 * (unsigned __int128)by.low) >> 64);
  if (by.high) {
    int64_t v12 = v2 == 0;
  }
  else {
    int64_t v12 = 1;
  }
  if (!v12 || v6 || v7 || v8)
  {
    if ((_DWORD)v4)
    {
      uint64_t v13 = -v10;
      int64_t v11 = 1;
      int64_t v5 = v9 == 0;
      uint64_t v14 = -(uint64_t)v9;
      if (v5) {
        goto LABEL_40;
      }
      goto LABEL_39;
    }
  }

  else
  {
    if ((_DWORD)v4)
    {
      uint64_t v13 = -v10;
      int64_t v5 = v9 == 0;
      uint64_t v14 = -(uint64_t)v9;
      if (v5)
      {
LABEL_40:
        int64_t v5 = v14 != 0;
        uint64_t v15 = v14 - 1;
        Swift::String::Index v16 = !v5;
        uint64_t v17 = __PAIR128__(v13, v15) + __PAIR128__(v16 << 63 >> 63, 1LL);
        uint64_t v10 = (__PAIR128__(v13, v15) + __PAIR128__(v16 << 63 >> 63, 1LL)) >> 64;
        uint64_t v9 = v17;
        if (v11) {
          goto LABEL_44;
        }
LABEL_46:
        uint64_t v18 = v4 ^ (v10 < 0);
        goto LABEL_47;
      }

LABEL_20:
  int64_t v5 = 1;
  return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v5);
}

  uint64_t v6 = a3 == 0;
  a3 = -(uint64_t)a3;
  a4 = -(uint64_t)(a4 + !v6);
LABEL_19:
  uint64_t v7 = !is_mul_ok(a2, a3);
  uint64_t v8 = !is_mul_ok(a1, a4);
  uint64_t v9 = __CFADD__(a2 * a3, a1 * a4);
  uint64_t v10 = a1 * a3;
  int64_t v11 = (__PAIR128__(a4, a3) * __PAIR128__(a2, a1)) >> 64;
  int64_t v12 = __CFADD__(a2 * a3 + a1 * a4, (a1 * (unsigned __int128)a3) >> 64);
  if (a4) {
    uint64_t v13 = a2 == 0;
  }
  else {
    uint64_t v13 = 1;
  }
  if (!v13 || v7 || v8 || v9)
  {
    if (!(_DWORD)v5) {
      goto LABEL_47;
    }
    uint64_t v14 = -v11;
    int64_t v12 = 1;
    uint64_t v6 = v10 == 0;
    uint64_t v15 = -(uint64_t)v10;
    if (v6) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }

  if (!(_DWORD)v5) {
    goto LABEL_44;
  }
  uint64_t v14 = -v11;
  uint64_t v6 = v10 == 0;
  uint64_t v15 = -(uint64_t)v10;
  if (!v6) {
LABEL_39:
  }
    --v14;
LABEL_40:
  uint64_t v6 = v15 != 0;
  Swift::String::Index v16 = v15 - 1;
  uint64_t v17 = !v6;
  int64_t v11 = (__PAIR128__(v14, v16) + __PAIR128__(v17 << 63 >> 63, 1LL)) >> 64;
  uint64_t v10 = v16 + 1;
LABEL_44:
  if (v12 || ((v5 ^ (v11 >= 0)) & 1) == 0) {
LABEL_47:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in *",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x29AuLL,  0);
  return v10;
}

      Swift::UInt64 v24 = ~v18 + a2;
      if (v22 < 4)
      {
        if (v22)
        {
          unint64_t v25 = v24 & ~(-1 << (8 * v22));
          bzero(a1, (v20 & ~v19) + v21);
          if (v22 == 3)
          {
            *(_WORD *)a1 = v25;
            a1[2] = BYTE2(v25);
          }

          else if (v22 == 2)
          {
            *(_WORD *)a1 = v25;
          }

          else
          {
            *a1 = v25;
          }
        }
      }

      else
      {
        bzero(a1, (v20 & ~v19) + v21);
        *(_DWORD *)a1 = v24;
      }

      __asm { BR              X10 }
    }

    uint64_t v23 = ((a3 - v18 + ~(-1 << (8 * v22))) >> (8 * v22)) + 1;
    if (HIWORD(v23))
    {
      uint64_t v14 = 4u;
      if (v18 >= a2) {
        goto LABEL_25;
      }
      goto LABEL_18;
    }

    if (v23 >= 0x100) {
      uint64_t v14 = 2;
    }
    else {
      uint64_t v14 = v23 > 1;
    }
  }

  if (v18 >= a2) {
    goto LABEL_25;
  }
  goto LABEL_18;
}

      Swift::UInt64 v24 = ~v18 + a2;
      if (v22 < 4)
      {
        if (v22)
        {
          unint64_t v25 = v24 & ~(-1 << (8 * v22));
          bzero(a1, (v20 & ~v19) + v21);
          if (v22 == 3)
          {
            *(_WORD *)a1 = v25;
            a1[2] = BYTE2(v25);
          }

          else if (v22 == 2)
          {
            *(_WORD *)a1 = v25;
          }

          else
          {
            *a1 = v25;
          }
        }
      }

      else
      {
        bzero(a1, (v20 & ~v19) + v21);
        *(_DWORD *)a1 = v24;
      }

      __asm { BR              X10 }
    }

    uint64_t v23 = ((a3 - v18 + ~(-1 << (8 * v22))) >> (8 * v22)) + 1;
    if (HIWORD(v23))
    {
      uint64_t v14 = 4u;
      if (v18 >= a2) {
        goto LABEL_25;
      }
      goto LABEL_18;
    }

    if (v23 >= 0x100) {
      uint64_t v14 = 2;
    }
    else {
      uint64_t v14 = v23 > 1;
    }
  }

  if (v18 >= a2) {
    goto LABEL_25;
  }
  goto LABEL_18;
}

      Swift::String::Index v22 = ~v16 + a2;
      if (v20 < 4)
      {
        if (v20)
        {
          uint64_t v23 = v22 & ~(-1 << (8 * v20));
          bzero(a1, (v18 & ~v17) + v19);
          if (v20 == 3)
          {
            *(_WORD *)a1 = v23;
            a1[2] = BYTE2(v23);
          }

          else if (v20 == 2)
          {
            *(_WORD *)a1 = v23;
          }

          else
          {
            *a1 = v23;
          }
        }
      }

      else
      {
        bzero(a1, (v18 & ~v17) + v19);
        *(_DWORD *)a1 = v22;
      }

      __asm { BR              X10 }
    }

    uint64_t v21 = ((a3 - v16 + ~(-1 << (8 * v20))) >> (8 * v20)) + 1;
    if (HIWORD(v21))
    {
      int64_t v12 = 4u;
      if (v16 >= a2) {
        goto LABEL_25;
      }
      goto LABEL_18;
    }

    if (v21 >= 0x100) {
      int64_t v12 = 2;
    }
    else {
      int64_t v12 = v21 > 1;
    }
  }

  if (v16 >= a2) {
    goto LABEL_25;
  }
  goto LABEL_18;
}

  os_unfair_lock_unlock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
  if (!a2)
  {
LABEL_22:
    uint64_t v15 = malloc(a2);
    memcpy(v15, a1, a2);
    memset(&v118, 0, sizeof(v118));
    uint64_t v79 = xmmword_18180BFB0;
    uint64_t v80 = 0LL;
    unint64_t v81 = 0;
    int64_t v116 = 0LL;
    uint64_t v83 = 0LL;
    Swift::Int v84 = 0LL;
    uint64_t v82 = 0LL;
    Swift::String v85 = 0;
    unint64_t v97 = 0u;
    uint64_t v98 = 0u;
    unint64_t v99 = 0u;
    uint64_t v100 = 0u;
    char v101 = 0u;
    uint64_t v102 = 0u;
    uint64_t v103 = 0u;
    uint64_t v104 = 0u;
    uint64_t v105 = 0u;
    uint64_t v106 = 0u;
    uint64_t v107 = 0u;
    uint64_t v108 = 0u;
    uint64_t v109 = 0u;
    uint64_t v110 = 0u;
    v111 = 0u;
    uint64_t v112 = 0u;
    uint64_t v113 = 0u;
    Swift::Int v86 = 0u;
    uint64_t v87 = 0u;
    uint64_t v88 = 0u;
    int64_t v89 = 0u;
    uint64_t v90 = 0u;
    char v91 = 0u;
    uint64_t v92 = 0u;
    unint64_t v93 = 0u;
    uint64_t v94 = 0u;
    uint64_t v95 = 0u;
    unint64_t v96 = 0u;
    uint64_t v114 = 0;
    v78[0] = off_189B8B130;
    v78[1] = &v117;
    v78[2] = &v118;
    uint64_t v77 = 0LL;
    Swift::String::Index v16 = swift::Demangle::__runtime::Demangler::demangleSymbol((uint64_t)v78, v15, a2, v76);
    uint64_t v17 = v77;
    if (v77 == v76)
    {
      uint64_t v18 = 4LL;
      uint64_t v17 = v76;
    }

    else
    {
      if (!v77)
      {
LABEL_28:
        if (!v16 || (uint64_t v19 = swift::Demangle::__runtime::Node::findByKind(v16, 76LL, 3), (v20 = v19) == 0))
        {
          int64_t v12 = 0LL;
          goto LABEL_69;
        }

        if (*(_BYTE *)(v19 + 18) != 5 || *(_DWORD *)(v19 + 8) < 3u) {
          goto LABEL_68;
        }
        uint64_t v21 = swift::Demangle::__runtime::Node::findByKind(v19, 24LL, 1);
        if (v21)
        {
          Swift::String::Index v22 = v21;
          uint64_t v23 = swift::Demangle::__runtime::Node::findByKind(v21, 153LL, 1);
          if (v23)
          {
            std::string::append(&v118, *(const std::string::value_type **)v23, *(void *)(v23 + 8));
            std::string::append(&v118, ".");
          }

          Swift::UInt64 v24 = swift::Demangle::__runtime::Node::findByKind(v22, 101LL, 1);
          if (v24)
          {
            std::string::append(&v118, *(const std::string::value_type **)v24, *(void *)(v24 + 8));
            std::string::append(&v118, ".");
          }
        }

        unint64_t v25 = 0LL;
        uint64_t v26 = 0LL;
        Swift::String::Index v27 = *(unsigned __int8 *)(v20 + 18);
        unint64_t v28 = v27 - 1;
        while (1)
        {
          unint64_t v29 = *(unsigned __int8 *)(v20 + 18);
          if (v27 == 1) {
            goto LABEL_46;
          }
          if (v27 != 5)
          {
            if (v27 == 2) {
              unint64_t v29 = 2LL;
            }
            else {
              unint64_t v29 = 0LL;
            }
LABEL_46:
            if (v25 >= v29) {
              break;
            }
            goto LABEL_49;
          }

    uint64_t v17 = 0LL;
    return _getForeignWitnessTable(result, v15, (uint64_t)v17);
  }

  return result;
}

    uint64_t v23 = (uint64_t *)(ConformingSuperclass + 1);
LABEL_19:
    uint64_t v21 = *v23;
    goto LABEL_20;
  }

  if ((_DWORD)v22 == 515 || (_DWORD)v22 == 516) {
    goto LABEL_18;
  }
LABEL_20:
  uint64_t v54 = v21;
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)ConformingSuperclass, v18, v19, v20);
  uint64_t v56 = v58;
  uint64_t v57 = 0x800000000LL;
  v58[32] = 0LL;
  v49[0] = off_189B8D258;
  v49[1] = &v53;
  uint64_t v50 = v49;
  v47[0] = off_189B8D2A0;
  v47[1] = &v53;
  uint64_t v48 = v47;
  swift_getTypeByMangledName(a1, SymbolicMangledNameStringRef, v16, (uint64_t)GenericArgs, v49, v47, (uint64_t)v51);
  Swift::UInt64 v24 = v48;
  if (v48 == v47)
  {
    unint64_t v25 = 4LL;
    Swift::UInt64 v24 = v47;
  }

  else
  {
    if (!v48) {
      goto LABEL_25;
    }
    unint64_t v25 = 5LL;
  }

  (*(void (**)(void))(*v24 + 8 * v25))();
LABEL_25:
  uint64_t v26 = v50;
  if (v50 == v49)
  {
    Swift::String::Index v27 = 4LL;
    uint64_t v26 = v49;
  }

  else
  {
    if (!v50) {
      goto LABEL_30;
    }
    Swift::String::Index v27 = 5LL;
  }

  (*(void (**)(void))(*v26 + 8 * v27))();
LABEL_30:
  if (v52) {
    unint64_t v28 = 0LL;
  }
  else {
    unint64_t v28 = v51[0];
  }
  if (v52 == 1 || !v28)
  {
    if (v52 == 1) {
      unint64_t v30 = (const char *)((uint64_t (*)(void))v51[1])();
    }
    else {
      unint64_t v30 = "NULL metadata but no error was provided";
    }
    v46[0] = swift_getTypeName(a3, 1);
    v46[1] = v31;
    v45[0] = findAssociatedTypeName(v13, a5);
    v45[1] = v32;
    Swift::Bool v33 = v43;
    __swift::__runtime::llvm::StringRef::str(v45, (uint64_t)v43);
    if (v44 < 0) {
      Swift::Bool v33 = (void *)v43[0];
    }
    uint64_t v34 = v41;
    __swift::__runtime::llvm::StringRef::str(v46, (uint64_t)v41);
    if (v42 < 0) {
      uint64_t v34 = (void *)v41[0];
    }
    uint64_t v35 = *(int *)(v13 + 8) + v13 + 8;
    __swift::__runtime::llvm::StringRef::str(v59, (uint64_t)v39);
    if (v40 >= 0) {
      uint64_t v38 = v39;
    }
    else {
      uint64_t v38 = (void *)v39[0];
    }
    swift::fatalError( 0LL,  "failed to demangle witness for associated type '%s' in conformance '%s: %s' from mangled name '%s' - %s\n",  v36,  v37,  v33,  v34,  v35,  v38,  v30);
  }

  if (v56 != v58) {
    free(v56);
  }
  return v28;
}

  uint64_t v17 = &v7[v6];
  if ((a2 & 0x80000000) != 0)
  {
    uint64_t v18 = 0LL;
    __objc2_class *v17 = 45;
    Swift::UInt64 v24 = v17 + 1;
    unint64_t v25 = -a2;
    do
    {
      v17[++v18] = (v25 % 0xA) | 0x30;
      uint64_t v19 = v25 > 9;
      v25 /= 0xAu;
    }

    while (v19);
    uint64_t v26 = &v17[v18];
    v17[v18 + 1] = 0;
    if (&v17[v18] > v17)
    {
      Swift::String::Index v27 = &v17[v18];
      do
      {
        unint64_t v28 = *v26;
        *v27-- = *v24;
        *v24++ = v28;
        uint64_t v23 = v24 >= v26;
        uint64_t v26 = v27;
      }

      while (!v23);
    }
  }

  else if (a2)
  {
    uint64_t v18 = 0LL;
    do
    {
      v17[v18++] = (a2 % 0xA) | 0x30;
      uint64_t v19 = a2 > 9;
      a2 /= 0xAu;
    }

    while (v19);
    v17[v18] = 0;
    uint64_t v20 = &v17[v18 - 1];
    if (&v17[v18] > v17)
    {
      uint64_t v21 = &v17[v18 - 1];
      do
      {
        Swift::String::Index v22 = *v20;
        *v21-- = *v17;
        *v17++ = v22;
        uint64_t v23 = v17 >= v20;
        uint64_t v20 = v21;
      }

      while (!v23);
    }
  }

  else
  {
    *(_WORD *)uint64_t v17 = 48;
    LODWORD(v18) = 1;
  }

  *(_DWORD *)(v4 + 8) += v18;
  return this;
}

  uint64_t v17 = &v7[v6];
  if (a2)
  {
    uint64_t v18 = 0LL;
    do
    {
      v17[v18++] = (a2 % 0xA) | 0x30;
      uint64_t v19 = a2 > 9;
      a2 /= 0xAuLL;
    }

    while (v19);
    v17[v18] = 0;
    uint64_t v20 = &v17[v18 - 1];
    if (&v17[v18] > v17)
    {
      uint64_t v21 = &v17[v18 - 1];
      do
      {
        Swift::String::Index v22 = *v20;
        *v21-- = *v17;
        *v17++ = v22;
        uint64_t v23 = v17 >= v20;
        uint64_t v20 = v21;
      }

      while (!v23);
    }
  }

  else
  {
    *(_WORD *)uint64_t v17 = 48;
    LODWORD(v18) = 1;
  }

  *(_DWORD *)(v4 + 8) += v18;
  return this;
}

  *((_DWORD *)this + 24) = v7;
LABEL_23:
  Swift::String::Index v16 = swift::Demangle::__runtime::Demangler::popContext(this, a2, a3, a4, a5);
  uint64_t v15 = 0LL;
  if (v8)
  {
    uint64_t v19 = v16;
    if (v16)
    {
      uint64_t v20 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v20 || v20 + 24 > *((void *)this + 2))
      {
        uint64_t v21 = 2LL * *((void *)this + 4);
        if (v21 <= 0x20) {
          uint64_t v21 = 32LL;
        }
        *((void *)this + 4) = v21;
        Swift::String::Index v22 = v21 + 8;
        uint64_t v23 = malloc(v21 + 8);
        Swift::UInt64 v24 = (char *)v23 + v22;
        __objc2_class *v23 = *((void *)this + 3);
        uint64_t v20 = ((unint64_t)v23 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)this + 2) = v24;
        *((void *)this + 3) = v23;
      }

      *((void *)this + 1) = v20 + 24;
      *(_WORD *)(v20 + 16) = 180;
      *(_BYTE *)(v20 + 18) = 0;
      swift::Demangle::__runtime::Node::addChild((unsigned int *)v20, v19, this, v17, v18);
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v20,  (swift::Demangle::__runtime::Node *)v8,  this,  v25,  v26);
      uint64_t v15 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v15 || v15 + 24 > *((void *)this + 2))
      {
        unint64_t v29 = 2LL * *((void *)this + 4);
        if (v29 <= 0x20) {
          unint64_t v29 = 32LL;
        }
        *((void *)this + 4) = v29;
        unint64_t v30 = v29 + 8;
        Swift::String::Index v31 = malloc(v29 + 8);
        *Swift::String::Index v31 = *((void *)this + 3);
        uint64_t v15 = ((unint64_t)v31 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)this + 2) = (char *)v31 + v30;
        *((void *)this + 3) = v31;
      }

      *((void *)this + 1) = v15 + 24;
      *(_WORD *)(v15 + 16) = 232;
      *(_BYTE *)(v15 + 18) = 0;
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v15,  (swift::Demangle::__runtime::Node *)v20,  this,  v27,  v28);
    }
  }

  return v15;
}

  uint64_t v17 = *a2;
  *((_DWORD *)v4 + 2) = v6 + 1;
  v7[v6] = v17;
  return result;
}

  uint64_t v18 = *a2;
  *((_DWORD *)v4 + 2) = v5 + 1;
  *(void *)&v7[8 * v5] = v18;
  return result;
}

  int64_t v11 = *((unsigned __int8 *)v5 + 18);
  if ((_DWORD)v11 == 5)
  {
    uint64_t v13 = *((_DWORD *)v5 + 2);
    uint64_t v55 = v13 - 2;
    if (v13)
    {
      uint64_t v15 = **(void **)v5 + 16LL;
    }

    else
    {
      uint64_t v13 = 0;
      uint64_t v15 = 16LL;
    }

    int64_t v12 = *(unsigned __int16 *)v15 == 23;
    uint64_t v14 = *(swift::Demangle::__runtime::Node **)v5;
  }

  else
  {
    int64_t v12 = *(unsigned __int16 *)(*(void *)v5 + 16LL) == 23;
    if ((_DWORD)v11 == 2)
    {
      uint64_t v55 = 0;
      uint64_t v13 = 2;
    }

    else
    {
      uint64_t v55 = -1;
      uint64_t v13 = 1;
    }

    uint64_t v14 = v5;
  }

  if (*(_WORD *)(*((void *)v14 + v12) + 16LL) == 129)
  {
    Swift::String::Index v16 = v11 - 1;
    if ((_DWORD)v11 != 1)
    {
      uint64_t v17 = v5;
      if ((_DWORD)v11 == 2)
      {
LABEL_35:
        uint64_t v18 = (swift::Demangle::__runtime::Node *)*((void *)v17 + v12);
LABEL_37:
        if (v12) {
          int64_t v12 = 2;
        }
        else {
          int64_t v12 = 1;
        }
        LODWORD(v11) = *((unsigned __int8 *)v5 + 18);
        goto LABEL_41;
      }

      if ((_DWORD)v11 != 5)
      {
LABEL_36:
        uint64_t v18 = 0LL;
        goto LABEL_37;
      }

      int64_t v11 = *((unsigned int *)v5 + 2);
    }

    if (v11 > v12)
    {
      uint64_t v17 = v5;
      if (v16 >= 2) {
        uint64_t v17 = *(swift::Demangle::__runtime::Node **)v5;
      }
      goto LABEL_35;
    }

    goto LABEL_36;
  }

    uint64_t v14 = (swift::Demangle::__runtime::Node *)a2;
    if ((v12 & 1) == 0) {
      uint64_t v14 = *a2;
    }
    if (*(_DWORD *)a4) {
      return this;
    }
LABEL_8:
    ++v9;
  }

  while (v7 != v9);
  if (v8 == 1)
  {
    uint64_t v15 = (swift::Demangle::__runtime::Node *)a2;
    if (**(void **)v15 == 1LL)
    {
      Swift::Int v63 = (_DWORD *)(v5 + 12736);
      Swift::String::Index v16 = *(_DWORD *)(v5 + 12736);
      uint64_t v17 = *(unsigned int *)(v5 + 12740);
      uint64_t v18 = *(char **)(v5 + 12728);
      if (v16 >= v17)
      {
        uint64_t v19 = *(void **)(v5 + 12744);
        uint64_t v20 = (char *)v19[1];
        if (&v18[v17] != v20)
        {
          uint64_t v21 = v19[2];
          goto LABEL_98;
        }

        uint64_t v52 = (unint64_t)&v18[v17 + 1];
        uint64_t v21 = v19[2];
        if (v52 > v21)
        {
LABEL_98:
          else {
            uint64_t v53 = (2 * v17);
          }
          uint64_t v58 = v53 + v17;
          if (!v20 || (unint64_t)&v20[v58] > v21)
          {
            uint64_t v59 = 2LL * v19[4];
            if (v59 <= v58 + 1) {
              uint64_t v59 = v58 + 1;
            }
            v19[4] = v59;
            uint64_t v60 = v59 + 8;
            this = (uint64_t *)malloc(v59 + 8);
            uint64_t v61 = (char *)this + v60;
            *this = v19[3];
            uint64_t v20 = (char *)(this + 1);
            v19[2] = v61;
            v19[3] = this;
          }

          v19[1] = &v20[v58];
          if ((_DWORD)v17)
          {
            this = (uint64_t *)memcpy(v20, *(const void **)(v5 + 12728), v17);
            LODWORD(v17) = *(_DWORD *)(v5 + 12740);
            Swift::String::Index v16 = *(_DWORD *)(v5 + 12736);
          }

          goto LABEL_93;
        }

  *(_DWORD *)(a1 + 8) = v5 + 1;
  BOOL result = *a2;
  v7[v5] = *a2;
  return result;
}

  uint64_t v14 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v11 == v13) {
      goto LABEL_21;
    }
  }

      *(_DWORD *)a3 = v7;
      *(void *)(a3 + 8) = v3;
      *(_DWORD *)(a3 + 16) = v6;
      return result;
    default:
      goto LABEL_18;
  }

          swift::Demangle::__runtime::Node::addChild(v11, (swift::Demangle::__runtime::Node *)v15, a3, v9, v10);
          v13 += 8;
          if (v13 == v7) {
            return v11;
          }
        }

      default:
        uint64_t v7 = 0LL;
        if (v13) {
          goto LABEL_16;
        }
        return v11;
    }

    if (v13 != v7) {
      goto LABEL_16;
    }
    return v11;
  }

  return (unsigned int *)v4;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)(char *a1, int64_t a2)
{
  if (!a2) {
    return &_swiftEmptyArrayStorage;
  }
  if (a2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v4 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int8>();
  int64_t v5 = (char *)swift_allocObject(v4, a2 + 32, 7uLL);
  size_t v6 = _swift_stdlib_malloc_size(v5);
  *((void *)v5 + 2) = a2;
  *((void *)v5 + 3) = 2 * v6 - 64;
  specialized UnsafeMutablePointer.initialize(from:count:)(a1, a2, v5 + 32);
  return (__objc2_class **)v5;
}

__objc2_class **specialized _copyCollectionToContiguousArray<A>(_:)(uint64_t a1)
{
  unint64_t v1 = a1;
  if (!((unint64_t)a1 >> 62))
  {
    uint64_t v2 = *(void *)((a1 & 0xFFFFFFFFFFFFF8LL) + 0x10);
    if (v2) {
      goto LABEL_3;
    }
    return &_swiftEmptyArrayStorage;
  }

  if (a1 >= 0) {
    a1 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  uint64_t v2 = (uint64_t)objc_msgSend((id)a1, sel_count);
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
LABEL_3:
  if (v2 <= 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v3 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
  uint64_t v4 = (void **)swift_allocObject(v3, 8 * v2 + 32, 7uLL);
  int64_t v5 = _swift_stdlib_malloc_size(v4);
  uint64_t v9 = v5 - 32;
  if (v5 < 32) {
    uint64_t v9 = v5 - 25;
  }
  v4[2] = (void *)v2;
  v4[3] = (void *)((2 * (v9 >> 3)) | 1);
  swift_bridgeObjectRetain(v1, v6, v7, v8);
  uint64_t v11 = specialized _ArrayBuffer._copyContents(initializing:)(v4 + 4, v2, v1, v10);
  uint64_t v14 = v11;
  unint64_t v15 = (unint64_t)v12;
  uint64_t v17 = v16;
  if ((unint64_t)v11 >> 62)
  {
    if (v11 >= 0) {
      v11 &= 0xFFFFFFFFFFFFFF8uLL;
    }
    if (v12 == objc_msgSend((id)v11, sel_count)) {
      goto LABEL_8;
    }
LABEL_18:
    uint64_t v19 = specialized _ArrayBuffer.subscript.read(v24, v15, v14, v13);
    id v21 = *v20;
    swift_unknownObjectRetain(*v20, (uint64_t)v20, v22, v23);
    ((void (*)(void *, void))v19)(v24, 0LL);
    specialized RandomAccessCollection<>.index(after:)(v15, v14);
    swift_unknownObjectRelease(v21);
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }

  if (v12 != *(id *)((v11 & 0xFFFFFFFFFFFFF8LL) + 0x10)) {
    goto LABEL_18;
  }
LABEL_8:
  if (v17 != v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  swift_bridgeObjectRelease(v14);
  return (__objc2_class **)v4;
}

__objc2_class **_copyCollectionToContiguousArray<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0LL, (uint64_t)AssociatedTypeWitness, v8, v9);
  uint64_t v48 = *(void *)(v10 - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v47 = (char *)&v41 - v12;
  uint64_t v45 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v14 = (char *)&v41 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v15 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v44 = *(void *)(v15 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v17 = (char *)&v41 - v16;
  uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 112);
  uint64_t v46 = a1;
  uint64_t v19 = v18(a2, a3);
  if (!v19) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v20 = v19;
  uint64_t v43 = v10;
  if (v19 < 1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  uint64_t v21 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
  uint64_t v22 = *(unsigned int *)(v21 + 48);
  uint64_t v23 = *(unsigned __int16 *)(v21 + 52);
  uint64_t v24 = *(AssociatedTypeWitness - 1);
  uint64_t v25 = *(void *)(v24 + 72);
  uint64_t v42 = v24;
  uint64_t v26 = *(unsigned __int8 *)(v24 + 80);
  Swift::String::Index v27 = swift_allocObject(v21, ((v26 + v22) & ~v26) + v25 * v20, v26 | v23);
  size_t v28 = _swift_stdlib_malloc_size(v27);
  if (!v25) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  uint64_t v32 = (v26 + 32) & ~v26;
  if (v28 - v32 == 0x8000000000000000LL && v25 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  uint64_t v34 = (uint64_t)(v28 - v32) / v25;
  swift_retain(v27, v29, v30, v31);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( (uint64_t)AssociatedTypeWitness,  AssociatedTypeWitness);
  v27[2] = v20;
  v27[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v34);
  swift_release((uint64_t)v27);
  (*(void (**)(char *, uint64_t, uint64_t))(v45 + 16))(v14, v46, a2);
  uint64_t v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t, uint64_t))(v6 + 64))( v17,  (char *)v27 + v32,  v20,  a2,  v6);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a2,  v15,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v38 = v47;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( v15,  AssociatedConformanceWitness);
  int v39 = (*(uint64_t (**)(char *, uint64_t, uint64_t *))(v42 + 48))(v38, 1LL, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v48 + 8))(v38, v43);
  if (v39 != 1) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: more than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x45DuLL,  0);
  }
  if (v36 != v20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid Collection: less than 'count' elements in collection",  60LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x462uLL,  0);
  }
  (*(void (**)(char *, unint64_t))(v44 + 8))(v17, v15);
  return (__objc2_class **)v27;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance [A]( uint64_t *a1, void (*a2)(void, void, void), uint64_t a3, uint64_t a4, uint64_t a5)
{
  return Array.replaceSubrange<A>(_:with:)(*a1, a1[1], a2, a5);
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance [A]@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = specialized Array.init(repeating:count:)( a1,  a2,  v6,  (uint64_t (*)(uint64_t, uint64_t))static Array._allocateUninitialized(_:));
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8LL))(a1, v6);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance [A]@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result = Array.init<A>(_:)(a1, a2, a2, a3);
  *a4 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance [A]( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Array.append<A>(contentsOf:)(a1, a4, a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance [A]( uint64_t a1, Swift::Int *a2, uint64_t a3, uint64_t a4)
{
  return Array.insert(_:at:)(a1, *a2, a3, a4);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance [A]( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return RangeReplaceableCollection.insert<A>(contentsOf:at:)(a1, a2, a5, a3, a6, a4);
}

uint64_t specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)( uint64_t a1, unsigned int a2, uint64_t a3)
{
  void (*v22)(uint64_t *__return_ptr, unint64_t, unint64_t);
  char v23;
  uint64_t result;
  unsigned int v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v30 = a1;
  uint64_t v6 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *(void *)(v9 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v10,  v11,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v15 = (char *)&v28 - v14;
  unsigned int v16 = *v3;
  if (a2)
  {
    if (!v16)
    {
LABEL_6:
      unint64_t v19 = 193LL;
      goto LABEL_32;
    }

    unsigned int v17 = *v3;
    while (v17 != a2)
    {
      BOOL v18 = v17 >= 0x100;
      v17 >>= 8;
      if (!v18) {
        goto LABEL_6;
      }
    }

    while (v16 != a2)
    {
      BOOL v18 = v16 >= 0x100;
      v16 >>= 8;
      if (!v18) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC2uLL,  0);
      }
    }

    unsigned int v16 = *v3;
    if (*v3 < a2) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
  }

  if (v16 != a2)
  {
    unsigned int v20 = 0;
    uint64_t v26 = v16;
    while (v16 >= v26 && v26 > a2)
    {
      if (HIBYTE(v20)) {
        goto LABEL_31;
      }
      v20 |= v26 << (-(__clz(v20) & 0x18) & 0x18);
      v26 >>= 8;
      if (v26 == a2) {
        goto LABEL_13;
      }
    }

LABEL_31:
    Swift::String::Index v27 = 0;
    unint64_t v19 = 167LL;
LABEL_32:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  v19,  v27);
  }

          v653 = -24LL;
          v173 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
          unint64_t v174 = lazy protocol witness table accessor for type Int and conformance Int(v155, v156, v157);
          v173(&v653, &type metadata for Int, v174, v69, v67);
          LOBYTE(v173) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                       + 16LL))( v120,  v123,  v69);
          v153(v123, v69);
          v153(v120, v69);
          if ((v173 & 1) == 0)
          {
LABEL_68:
            v218 = v639;
            ((void (*)(uint64_t *, uint64_t))v629)(&qword_18180BE70, 512LL);
            v627(v218, v69, v640);
            v219 = v622;
            v152(v125, v123, v69, v150);
            v153(v123, v69);
            v220 = (uint64_t (*)(unint64_t *, uint64_t))v645;
            char v136 = v153;
            if ((((uint64_t (*)(unint64_t *, uint64_t))v645)(v69, v67) & 1) != 0)
            {
              v221 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
              if (v221 < 64) {
                goto LABEL_79;
              }
LABEL_73:
              v653 = -24LL;
              v225 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v67 + 96);
              v226 = lazy protocol witness table accessor for type Int and conformance Int(v221, v222, v223);
              v225(&v653, &type metadata for Int, v226, v69, v67);
              LOBYTE(v225) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 16) + 8LL)
                                                                                           + 8LL))( v219,  v123,  v69);
              v153(v123, v69);
              v153(v219, v69);
              goto LABEL_89;
            }

            v224 = v220(v69, v67);
            v221 = ((uint64_t (*)(unint64_t *, uint64_t))v648)(v69, v67);
            if ((v224 & 1) != 0)
            {
              if (v221 > 64) {
                goto LABEL_73;
              }
              v235 = v639;
              ((void (*)(uint64_t *, uint64_t))v629)(&qword_18180BE68, 256LL);
              v627(v235, v69, v640);
              LOBYTE(v235) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                                           + 32LL))( v219,  v123,  v69);
              v153(v123, v69);
              v236 = v597;
              (*(void (**)(char *, char *, unint64_t *))(v646 + 32))(v597, v219, v69);
              if ((v235 & 1) != 0)
              {
                v227 = (*(uint64_t (**)(unint64_t *, uint64_t))(v67 + 120))(v69, v67);
                v228 = v236;
LABEL_80:
                v153(v228, v69);
                if (v227 == -24)
                {
LABEL_81:
                  v153(v125, v69);
                  v229 = v649;
                  v230 = ((uint64_t (*)(uint64_t))v644[17])(v649);
                  v231 = v643[21](v229);
                  uint64_t result = 0LL;
                  _ZF = (v231 & 1) == 0;
                  LOWORD(v233) = 0;
                  LOWORD(v234) = 0x8000;
                  if (!_ZF) {
                    v233 = v234;
                  }
                  if (v230)
                  {
                    LOWORD(v234) = word_18180BE4C[_ZF];
                    v233 = v234;
                  }

                  goto LABEL_275;
                }

          int64_t v116 = v221;
          v88(v221, (char *)v86, v8);
          int64_t v117 = v77(v8, v6);
          int64_t v118 = v215;
          v88(v215, v116, v8);
          if ((v117 & 1) != 0)
          {
            char v119 = v220;
            uint64_t v120 = v220(v8, v6);
            unint64_t v121 = v216;
            v216(v118, v8);
            unint64_t v122 = v217;
            if (v120 < 65) {
              goto LABEL_39;
            }
            uint64_t v123 = v210;
            v88(v210, v221, v8);
            v239[0] = 0x8000000000000000LL;
            unint64_t v124 = v219;
            if ((v219(v8, v6) & 1) != 0)
            {
              unint64_t v125 = v220(v8, v6);
              if (v125 < 64)
              {
                unint64_t v128 = v232;
                v88(v232, v123, v8);
                Swift::String v129 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
                v130 = v216;
                v216(v128, v8);
                char v119 = v220;
                v131 = v123;
                unint64_t v121 = v130;
                if (v129 < v239[0]) {
                  goto LABEL_94;
                }
                goto LABEL_38;
              }

              uint64_t v182 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
              v183 = lazy protocol witness table accessor for type Int and conformance Int(v125, v126, v127);
              v184 = v232;
              v182(v239, &type metadata for Int, v183, v8, v6);
              uint64_t v185 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v123,  v184,  v8);
              uint64_t v186 = v184;
              unint64_t v122 = v217;
              v187 = v216;
              v216(v186, v8);
              char v119 = v220;
              v131 = v123;
              unint64_t v121 = v187;
              if ((v185 & 1) != 0) {
LABEL_94:
              }
                _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
            }

            else
            {
              v173 = v124(v8, v6);
              char v119 = v220;
              unint64_t v174 = v220(v8, v6);
              if ((v173 & 1) != 0)
              {
                unint64_t v121 = v216;
                if (v174 <= 64)
                {
                  uint64_t v192 = (void (**)(char *, void (*)(char *, uint64_t), const char *))v214;
                  v193 = AssociatedTypeWitness;
                  uint64_t v194 = swift_getAssociatedConformanceWitness( (uint64_t)v214,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v195 = v212;
                  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v194 + 8))( &unk_18180BE68,  256LL,  v193,  v194);
                  v196 = v232;
                  v192[3](v195, v8, (const char *)v192);
                  v197 = v210;
                  LOBYTE(v192) = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v210,  v196,  v8);
                  v121(v196, v8);
                  v198 = v209;
                  v88(v209, v197, v8);
                  if ((v192 & 1) != 0)
                  {
                    v121(v198, v8);
                    goto LABEL_94;
                  }

                  v199 = v239[0];
                  v200 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
                  v121(v198, v8);
                  uint64_t v60 = v200 < v199;
                  unint64_t v122 = v217;
                  char v119 = v220;
                  v131 = v210;
                  if (v60) {
                    goto LABEL_94;
                  }
                }

                else
                {
                  v177 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(v6 + 96);
                  v178 = lazy protocol witness table accessor for type Int and conformance Int(v174, v175, v176);
                  v179 = v232;
                  v177(v239, &type metadata for Int, v178, v8, v6);
                  v180 = v210;
                  v181 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(v6 + 32) + 8LL) + 16LL))( v210,  v179,  v8);
                  v121(v179, v8);
                  v131 = v180;
                  unint64_t v122 = v217;
                  char v119 = v220;
                  if ((v181 & 1) != 0) {
                    goto LABEL_94;
                  }
                }
              }

              else
              {
                unint64_t v121 = v216;
                if (v174 < 64)
                {
                  v188 = v232;
                  v189 = v210;
                  v88(v232, v210, v8);
                  v190 = (*(uint64_t (**)(void *, uint64_t))(v6 + 120))(v8, v6);
                  v191 = v188;
                  char v119 = v220;
                  v121(v191, v8);
                  v131 = v189;
                  unint64_t v122 = v217;
                  if (v190 < v239[0]) {
                    goto LABEL_94;
                  }
                }

                else
                {
                  unint64_t v122 = v217;
                  v131 = v210;
                }
              }
            }
          }

          else
          {
            v131 = v118;
            unint64_t v122 = v217;
            char v119 = v220;
            unint64_t v121 = v216;
          }

  unsigned int v17 = v1[2];
  unsigned int v16 = v1[3];
  v18._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v4)._rawBits;
  if ((v16 & 0x1000000000000000LL) != 0)
  {
    v24._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v18)._rawBits;
  }

  else
  {
    unint64_t v19 = v18._rawBits >> 16;
    if ((v16 & 0x2000000000000000LL) != 0)
    {
      Swift::String::Index v27 = v17;
      size_t v28 = v16 & 0xFFFFFFFFFFFFFFLL;
      uint64_t v21 = *((unsigned __int8 *)&v27 + v19);
    }

    else
    {
      if ((v17 & 0x1000000000000000LL) != 0) {
        unsigned int v20 = (unsigned __int8 *)((v16 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        unsigned int v20 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v17, v16);
      }
      uint64_t v21 = v20[v19];
    }

    uint64_t v22 = (char)v21;
    uint64_t v23 = __clz(v21 ^ 0xFF) - 24;
    if (v22 >= 0) {
      LOBYTE(v23) = 1;
    }
    v24._Swift::UInt64 rawBits = ((v19 + v23) << 16) | 5;
  }

  if (v24._rawBits >> 14 < v4._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v25._Swift::UInt64 rawBits = v4._rawBits;
  specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v25, v24);
  return v15;
}

  size_t v28 = __OFADD__(v22, v27);
  v22 += v27;
  if (v28) {
    goto LABEL_295;
  }
LABEL_32:
  v275 = v24;
  uint64_t v29 = v9 & ~v6;
  if ((v29 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v30 = _StringGuts.nativeUnusedCapacity.getter(v9, v6);
    if ((v31 & 1) != 0)
    {
LABEL_309:
      v263 = 258LL;
      goto LABEL_310;
    }

    if (v22 < 16)
    {
      if ((v6 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(v19, 5LL);
        uint64_t v3 = v6;
      }

      else
      {
        if (v30 >= v27) {
          goto LABEL_38;
        }
LABEL_110:
        swift_bridgeObjectRelease_n(v19, 5LL);
        uint64_t v14 = v274;
        unint64_t v99 = v275;
        if ((v6 & 0x2000000000000000LL) != 0)
        {
          uint64_t v3 = v6;
LABEL_112:
          v100._Swift::UInt64 rawBits = (v99 << 16) | 1;
          v101._Swift::UInt64 rawBits = 1LL;
          v102._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v101, v100, v18, v19);
          if (v102._rawBits < 0x10000) {
            v102._rawBits |= 3;
          }
          BOOL v18 = specialized String.init(_:)(v102, v103, v18, v19);
          uint64_t v22 = v104;
          swift_bridgeObjectRelease(v19);
          uint64_t v24 = v277;
          if ((v22 & 0x2000000000000000LL) == 0) {
            goto LABEL_296;
          }
          swift_bridgeObjectRelease(v22);
          goto LABEL_116;
        }

        if ((v6 & 0x1000000000000000LL) != 0)
        {
          uint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, v6);
          uint64_t v3 = v266;
        }

        else
        {
          if ((v9 & 0x1000000000000000LL) != 0)
          {
            v261 = (unsigned __int8 *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            v261 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v6);
            uint64_t v21 = v96;
          }

          swift_bridgeObjectRetain(v6, v96, v97, v98);
          closure #1 in _StringGuts._convertedToSmall()(v261, v21, &v279);
          swift_bridgeObjectRelease(v6);
          uint64_t v9 = v279;
          uint64_t v3 = v280;
        }
      }

      uint64_t v14 = v274;
      unint64_t v99 = v275;
      goto LABEL_112;
    }
  }

  else if (v22 <= 15)
  {
    goto LABEL_110;
  }

  size_t v28 = __OFADD__(v22, v27);
  v22 += v27;
  if (v28) {
    goto LABEL_296;
  }
LABEL_32:
  v280 = v24;
  uint64_t v29 = v9 & ~v6;
  if ((v29 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v6 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v30 = _StringGuts.nativeUnusedCapacity.getter(v9, v6);
    if ((v31 & 1) != 0)
    {
LABEL_310:
      v268 = 258LL;
      goto LABEL_311;
    }

    if (v22 < 16)
    {
      if ((v6 & 0x2000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease_n(v19, 5LL);
        uint64_t v3 = v6;
      }

      else
      {
        if (v30 >= v27) {
          goto LABEL_38;
        }
LABEL_110:
        swift_bridgeObjectRelease_n(v19, 5LL);
        uint64_t v14 = v279;
        unint64_t v99 = v280;
        if ((v6 & 0x2000000000000000LL) != 0)
        {
          uint64_t v3 = v6;
LABEL_112:
          v100._Swift::UInt64 rawBits = (v99 << 16) | 1;
          v101._Swift::UInt64 rawBits = 1LL;
          v102._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v101, v100, v18, v19);
          if (v102._rawBits < 0x10000) {
            v102._rawBits |= 3;
          }
          BOOL v18 = specialized String.init(_:)(v102, v103, v18, v19);
          uint64_t v22 = v104;
          swift_bridgeObjectRelease(v19);
          uint64_t v24 = v282;
          if ((v22 & 0x2000000000000000LL) == 0) {
            goto LABEL_297;
          }
          swift_bridgeObjectRelease(v22);
          goto LABEL_116;
        }

        if ((v6 & 0x1000000000000000LL) != 0)
        {
          uint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, v6);
          uint64_t v3 = v271;
        }

        else
        {
          if ((v9 & 0x1000000000000000LL) != 0)
          {
            v266 = (unsigned __int8 *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }

          else
          {
            v266 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v6);
            uint64_t v21 = v96;
          }

          swift_bridgeObjectRetain(v6, v96, v97, v98);
          closure #1 in _StringGuts._convertedToSmall()(v266, v21, &v284);
          swift_bridgeObjectRelease(v6);
          uint64_t v9 = v284;
          uint64_t v3 = v285;
        }
      }

      uint64_t v14 = v279;
      unint64_t v99 = v280;
      goto LABEL_112;
    }
  }

  else if (v22 <= 15)
  {
    goto LABEL_110;
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  v23,  0);
  }

  uint64_t v2 = _swift_classOfObjCHeapObject((void *)a1);
  if (type metadata accessor for __StringStorage() == v2)
  {
    uint64_t v14 = *(void *)(v1 + 24);
    goto LABEL_22;
  }

  if (type metadata accessor for __SharedStringStorage() == v2)
  {
    uint64_t v14 = *(void *)(v1 + 32);
    goto LABEL_22;
  }

  uint64_t v6 = (unint64_t)objc_msgSend((id)v1, sel_copyWithZone_, 0);
  uint64_t v7 = v6;
  if ((v6 & 0x8000000000000000LL) != 0)
  {
    uint64_t v21 = specialized _SmallString.init(taggedCocoa:)((void *)v6, 4LL);
    if ((v22 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
    }
    return v21;
  }

  else
  {
    uint64_t v8 = objc_msgSend((id)v6, sel__fastCStringContents_, 1);
    uint64_t v9 = _stdlib_binary_CFStringGetLength(_:)(v7);
    uint64_t v13 = 0x4000000000000000LL;
    if (v8)
    {
      uint64_t v14 = v9 | 0xC000000000000000LL;
    }

    else
    {
      uint64_t v13 = 0x5000000000000000LL;
      uint64_t v14 = v9;
    }

    swift_bridgeObjectRetain(v13 | v7, v10, v11, v12);
    swift_unknownObjectRelease((id)v7);
  }

  return v14;
}

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
  }

  uint64_t v35 = 4;
  if (v4 < 0x10000) {
    uint64_t v35 = 2;
  }
  if (v4 >= 0x100) {
    Swift::Bool v33 = v35;
  }
  else {
    Swift::Bool v33 = 1;
  }
  uint64_t v34 = *(void *)(a1 - 8);
  if ((a2 & 0x100) == 0) {
    goto LABEL_37;
  }
LABEL_38:
  uint64_t v42 = (1 << (8 * v33)) - v4;
  if (v42 >= 0x7FFFFFFF) {
    uint64_t v42 = 0x7FFFFFFF;
  }
  if (v33 == 4) {
    uint64_t v42 = 0x7FFFFFFF;
  }
  uint64_t v43 = (v33 + v8);
  uint64_t v44 = (v43 + v7) & ~v7;
  if (v44 <= 1) {
    uint64_t v44 = 1LL;
  }
  uint64_t v46 = v7 < 8 && v43 < 0x19;
  if ((v10 & v46) != 0) {
    uint64_t v47 = 0;
  }
  else {
    uint64_t v47 = 0x20000;
  }
  if (v10) {
    uint64_t v48 = 0x200000;
  }
  else {
    uint64_t v48 = 3145728;
  }
  *(void *)&uint64_t v50 = (v33 + v8);
  *((void *)&v50 + 1) = v44;
  LODWORD(v51) = v48 | v11 | v7 & 0xFFCCFFFF | v47;
  HIDWORD(v51) = v42;
  swift::installCommonValueWitnesses((uint64_t)&v50, v34);
  *(void *)(v34 + 48) = swift_getMultiPayloadEnumTagSinglePayload;
  *(void *)(v34 + 56) = swift_storeMultiPayloadEnumTagSinglePayload;
  *(_OWORD *)(v34 + 64) = v50;
  uint64_t result = v51;
  *(double *)(v34 + 80) = v51;
  return result;
}

      abort();
    }
  }

  return 1LL;
}

      uint64_t v53 = 0LL;
      goto LABEL_49;
    }
  }

  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = **(_DWORD **)(a1 + 8);
  if (v7 == 232)
  {
    unsigned int v20 = *((unsigned __int8 *)a2 + 18);
    if (v20 == 5 && *((_DWORD *)a2 + 2))
    {
      a2 = *(const char **)a2;
LABEL_36:
      a2 = *(const char **)a2;
    }

    else
    {
      a2 = 0LL;
    }
  }

  if (v11 >= 2)
  {
LABEL_32:
    if ((v11 & 1) != 0)
    {
      uint64_t v25 = v2[1].super.isa;
      os_unfair_lock_lock((os_unfair_lock_t)&-[__SwiftValue hash]::warnedLock);
      if (qword_18C575A68 != -1) {
        dispatch_once_f( &qword_18C575A68,  &-[__SwiftValue hash]::warned,  (dispatch_function_t)swift::Lazy<std::unordered_set<swift::TargetMetadata<swift::InProcess> const*,std::hash<swift::TargetMetadata<swift::InProcess> const*>,std::equal_to<swift::TargetMetadata<swift::InProcess> const*>,std::allocator<swift::TargetMetadata<swift::InProcess> const*>>>::defaultInitCallback);
      }
      std::__hash_table<swift::TargetMetadata<swift::InProcess> const*,std::hash<swift::TargetMetadata<swift::InProcess> const*>,std::equal_to<swift::TargetMetadata<swift::InProcess> const*>,std::allocator<swift::TargetMetadata<swift::InProcess> const*>>::__emplace_unique_key_args<swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const* const&>( (uint64_t)&-[__SwiftValue hash]::warned,  &v25,  &v25);
      if (v21)
      {
        TypeName = swift_getTypeName((unint64_t)v25, 1);
          "e performance problems.\n",
          v23,
          v24,
          TypeName);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&-[__SwiftValue hash]::warnedLock);
      return 1LL;
    }
  }

  return (unint64_t)v2;
}

  while (v14 != v15)
  {
    unsigned int v17 = *v14++;
    swift::Demangle::__runtime::RemanglerBase::entryForNode(v19, this, v17, v3);
    int64_t v5 = v19[1] + 33 * v5;
  }

  return v5;
}

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  v316 = (char **)(v5 + 12728);
  size_t v28 = *(_DWORD *)(v5 + 12736);
  uint64_t v29 = *(unsigned int *)(v5 + 12740);
  uint64_t v30 = *(char **)(v5 + 12728);
  v308 = v19;
  Swift::String::Index v31 = *(void **)(v5 + 12744);
  uint64_t v32 = (char *)v31[1];
  if (&v30[v29] != v32)
  {
    Swift::Bool v33 = v31[2];
LABEL_39:
    v313 = v26;
    else {
      uint64_t v35 = (2 * v29);
    }
    uint64_t v36 = v35 + v29;
    if (!v32 || (unint64_t)&v32[v36] > v33)
    {
      int64_t v37 = 2LL * v31[4];
      if (v37 <= v36 + 1) {
        int64_t v37 = v36 + 1;
      }
      void v31[4] = v37;
      uint64_t v38 = v37 + 8;
      int v39 = malloc(v37 + 8);
      unint64_t v40 = (char *)v39 + v38;
      char *v39 = v31[3];
      uint64_t v32 = (char *)(v39 + 1);
      v31[2] = v40;
      v31[3] = v39;
    }

    v31[1] = &v32[v36];
    if ((_DWORD)v29)
    {
      memcpy(v32, *(const void **)(v5 + 12728), v29);
      LODWORD(v29) = *(_DWORD *)(v5 + 12740);
      size_t v28 = *(_DWORD *)(v5 + 12736);
    }

    uint64_t v26 = v313;
    *v316 = v32;
    uint64_t v30 = v32;
    goto LABEL_50;
  }

  uint64_t v34 = (unint64_t)&v30[v29 + 1];
  Swift::Bool v33 = v31[2];
  if (v34 > v33) {
    goto LABEL_39;
  }
  v31[1] = v34;
  LODWORD(v35) = 1;
LABEL_50:
  unint64_t v19 = v308;
  *(_DWORD *)(v5 + 12740) = v29 + v35;
LABEL_51:
  *(_DWORD *)(v5 + 12736) = v28 + 1;
  v30[v28] = 73;
  if ((v27 & 1) != 0)
  {
    if (v19) {
      goto LABEL_53;
    }
LABEL_74:
    uint64_t v57 = *(_DWORD *)(v5 + 12736);
    uint64_t v58 = *(unsigned int *)(v5 + 12740);
    uint64_t v59 = *(char **)(v5 + 12728);
    uint64_t v60 = *(void **)(v5 + 12744);
    uint64_t v61 = (char *)v60[1];
    if (&v59[v58] == v61)
    {
      Swift::Int v63 = (unint64_t)&v59[v58 + 1];
      uint64_t v62 = v60[2];
      if (v63 <= v62)
      {
        v60[1] = v63;
        LODWORD(v65) = 1;
LABEL_89:
        *(_DWORD *)(v5 + 12740) = v58 + v65;
LABEL_90:
        *(_DWORD *)(v5 + 12736) = v57 + 1;
        v59[v57] = 73;
        if (v26) {
          goto LABEL_54;
        }
        goto LABEL_91;
      }
    }

    else
    {
      uint64_t v62 = v60[2];
    }

    uint64_t v64 = v26;
    else {
      char v65 = (2 * v58);
    }
    uint64_t v66 = v65 + v58;
    if (!v61 || (unint64_t)&v61[v66] > v62)
    {
      BOOL v67 = 2LL * v60[4];
      if (v67 <= v66 + 1) {
        BOOL v67 = v66 + 1;
      }
      v60[4] = v67;
      uint64_t v68 = v67 + 8;
      unint64_t v69 = malloc(v67 + 8);
      unint64_t v70 = (char *)v69 + v68;
      *unint64_t v69 = v60[3];
      uint64_t v61 = (char *)(v69 + 1);
      v60[2] = v70;
      v60[3] = v69;
    }

    v60[1] = &v61[v66];
    if ((_DWORD)v58)
    {
      memcpy(v61, *(const void **)(v5 + 12728), v58);
      LODWORD(v58) = *(_DWORD *)(v5 + 12740);
      uint64_t v57 = *(_DWORD *)(v5 + 12736);
    }

    uint64_t v26 = v64;
    *v316 = v61;
    uint64_t v59 = v61;
    goto LABEL_89;
  }

  uint64_t v42 = *(_DWORD *)(v5 + 12736);
  uint64_t v43 = *(unsigned int *)(v5 + 12740);
  uint64_t v44 = *(char **)(v5 + 12728);
  if (v42 >= v43)
  {
    v309 = v19;
    uint64_t v45 = *(void **)(v5 + 12744);
    uint64_t v46 = (char *)v45[1];
    if (&v44[v43] == v46)
    {
      uint64_t v49 = (unint64_t)&v44[v43 + 1];
      uint64_t v47 = v45[2];
      if (v49 <= v47)
      {
        v45[1] = v49;
        LODWORD(v51) = 1;
LABEL_72:
        *(_DWORD *)(v5 + 12740) = v43 + v51;
        unint64_t v19 = v309;
        goto LABEL_73;
      }
    }

    else
    {
      uint64_t v47 = v45[2];
    }

    uint64_t v50 = v26;
    else {
      uint64_t v51 = (2 * v43);
    }
    uint64_t v52 = v51 + v43;
    if (!v46 || (unint64_t)&v46[v52] > v47)
    {
      uint64_t v53 = 2LL * v45[4];
      if (v53 <= v52 + 1) {
        uint64_t v53 = v52 + 1;
      }
      v45[4] = v53;
      uint64_t v54 = v53 + 8;
      uint64_t v55 = malloc(v53 + 8);
      uint64_t v56 = (char *)v55 + v54;
      char *v55 = v45[3];
      uint64_t v46 = (char *)(v55 + 1);
      void v45[2] = v56;
      v45[3] = v55;
    }

    v45[1] = &v46[v52];
    if ((_DWORD)v43)
    {
      memcpy(v46, *(const void **)(v5 + 12728), v43);
      LODWORD(v43) = *(_DWORD *)(v5 + 12740);
      uint64_t v42 = *(_DWORD *)(v5 + 12736);
    }

    uint64_t v26 = v50;
    *v316 = v46;
    uint64_t v44 = v46;
    goto LABEL_72;
  }

                        uint64_t v23 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a3, 232);
                        swift::Demangle::__runtime::Node::addChild(v23, v56, a3, v24, v25);
                        swift::Demangle::__runtime::Node::addChild( v32,  (swift::Demangle::__runtime::Node *)v23,  a3,  v26,  v27);
                        size_t v28 = v32;
LABEL_32:
                        swift::Demangle::__runtime::Node::addChild( v18,  (swift::Demangle::__runtime::Node *)v28,  a3,  v9,  v10);
                        if (++v20 == v19)
                        {
                          unint64_t v15 = (unint64_t)v18;
                          uint64_t v11 = v53;
                          uint64_t v13 = v54;
                          uint64_t v7 = v52;
                          goto LABEL_18;
                        }

                        continue;
                      }

                      uint64_t v41 = *((unsigned __int8 *)a1 + 18);
                      uint64_t v21 = (uint64_t *)a1;
                      if ((v41 - 1) < 2)
                      {
LABEL_29:
                        uint64_t v22 = *v21;
                      }

                      else
                      {
                        if (v41 == 5 && *((_DWORD *)a1 + 2))
                        {
                          uint64_t v21 = *(uint64_t **)a1;
                          goto LABEL_29;
                        }

                        uint64_t v22 = 0LL;
                      }

                      applyParamLabels(swift::Demangle::__runtime::Node *,swift::Demangle::__runtime::Node *,swift::Demangle::__runtime::NodeFactory &)::$_0::operator() const(swift::Demangle::__runtime::Node *)::{lambda(swift::Demangle::__runtime::Node *,swift::Demangle::__runtime::Node *)#1}::operator()( (uint64_t)v55,  v22,  (swift::Demangle::__runtime::Node **)v39,  v34,  v35);
                      goto LABEL_31;
                  }

                  break;
                }

                Swift::String::Index v31 = v15;
                if (v30 >= 2) {
                  Swift::String::Index v31 = *(void *)v15;
                }
                size_t v28 = *(unsigned int **)(v31 + 8 * v20);
                goto LABEL_43;
            }

            unint64_t v15 = v17;
          }

LABEL_23:
  *uint64_t v29 = v20;
  return result;
}

  *((void *)&v193 + 1) = v44;
  uint64_t v23 = v184;
  while (1)
  {
    uint64_t v51 = HIBYTE(v44) & 0xF;
    if ((v44 & 0x2000000000000000LL) != 0) {
      uint64_t v52 = HIBYTE(v44) & 0xF;
    }
    else {
      uint64_t v52 = v18 & 0xFFFFFFFFFFFFLL;
    }
    v183 = v7;
    if (!v52 && (v18 & ~v44 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain(object, v45, v46, v47);
      swift_bridgeObjectRelease(v44);
      *(void *)&v193 = countAndFlagsBits;
      *((void *)&v193 + 1) = object;
      uint64_t v52 = v182;
      goto LABEL_76;
    }

    uint64_t v7 = object & 0x2000000000000000LL;
    unint64_t v19 = HIBYTE(object) & 0xF;
    if ((v44 & 0x2000000000000000LL) != 0 && v7)
    {
      uint64_t v53 = v51 + v19;
      if ((unint64_t)(v51 + v19) <= 0xF)
      {
        if (v19)
        {
          int64_t v89 = 0;
          uint64_t v90 = 0LL;
          char v91 = v44;
          uint64_t v52 = v182;
          do
          {
            uint64_t v92 = v51 + v90;
            unint64_t v93 = v90 + 1;
            if (v90 >= 8) {
              uint64_t v94 = object;
            }
            else {
              uint64_t v94 = countAndFlagsBits;
            }
            uint64_t v95 = v94 >> (v89 & 0x38);
            unint64_t v96 = (8 * v51 + v89) & 0x38;
            unint64_t v97 = (-255LL << v96) - 1;
            uint64_t v98 = (unint64_t)v95 << v96;
            unint64_t v99 = v98 | v97 & v91;
            uint64_t v100 = v98 | v97 & v18;
            if (v92 < 8) {
              BOOL v18 = v100;
            }
            else {
              char v91 = v99;
            }
            v89 += 8;
            uint64_t v90 = v93;
          }

          while (v19 != v93);
        }

        else
        {
          char v91 = v44;
          uint64_t v52 = v182;
        }

        swift_bridgeObjectRelease(v44);
        uint64_t v106 = 0xA000000000000000LL;
        if (!(v18 & 0x8080808080808080LL | v91 & 0x80808080808080LL)) {
          uint64_t v106 = 0xE000000000000000LL;
        }
        *(void *)&v193 = v18;
        *((void *)&v193 + 1) = v106 & 0xFF00000000000000LL | (v53 << 56) | v91 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_74;
      }

      uint64_t v7 = 1LL;
    }

    uint64_t v186 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (v7) {
      int64_t v5 = HIBYTE(object) & 0xF;
    }
    else {
      int64_t v5 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(object, 2LL, v46, v47);
    if ((object & 0x1000000000000000LL) != 0) {
      goto LABEL_163;
    }
    swift_bridgeObjectRetain_n(object, 4LL, v54, v55);
    uint64_t v56 = v5;
    if ((v44 & 0x1000000000000000LL) == 0) {
      goto LABEL_38;
    }
LABEL_166:
    v175 = String.UTF8View._foreignCount()();
    uint64_t v58 = v175 + v56;
    if (__OFADD__(v175, v56)) {
      goto LABEL_168;
    }
LABEL_39:
    if ((v18 & ~v44 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v44 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v59 = *((void *)&v193 + 1);
      uint64_t v60 = _StringGuts.nativeUnusedCapacity.getter(v193, *((uint64_t *)&v193 + 1));
      if ((v61 & 1) != 0) {
        goto LABEL_173;
      }
      if (v58 <= 15 && ((v59 & 0x2000000000000000LL) != 0 || v60 < v56)) {
        goto LABEL_51;
      }
    }

    else if (v58 <= 15)
    {
      uint64_t v59 = *((void *)&v193 + 1);
LABEL_51:
      swift_bridgeObjectRelease_n(object, 5LL);
      BOOL v67 = v193;
      swift_bridgeObjectRetain(v59, v68, v69, v70);
      uint64_t v71 = _StringGuts._convertedToSmall()(v67, v59);
      unsigned int v73 = v72;
      swift_bridgeObjectRelease(v59);
      v74._Swift::UInt64 rawBits = (v5 << 16) | 1;
      v75._Swift::UInt64 rawBits = 1LL;
      v76._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v75, v74, countAndFlagsBits, object);
      if (v76._rawBits < 0x10000) {
        v76._rawBits |= 3;
      }
      uint64_t v78 = specialized String.init(_:)(v76, v77, countAndFlagsBits, object);
      uint64_t v80 = v79;
      swift_bridgeObjectRelease(object);
      unint64_t v81 = _StringGuts._convertedToSmall()(v78, v80);
      uint64_t v83 = v82;
      swift_bridgeObjectRelease(v80);
      Swift::Int v84 = specialized _SmallString.init(_:appending:)(v71, v73, v81, v83);
      uint64_t v7 = v183;
      if ((v86 & 1) != 0) {
        goto LABEL_172;
      }
      uint64_t v87 = v84;
      uint64_t v88 = v85;
      swift_bridgeObjectRelease(v59);
      *(void *)&v193 = v87;
      *((void *)&v193 + 1) = v88;
      uint64_t v52 = v182;
LABEL_75:
      uint64_t v23 = v184;
      goto LABEL_76;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v58, v56);
    swift_bridgeObjectRelease_n(object, 4LL);
    if ((object & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(object);
      _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, object, 0LL, v5);
      swift_bridgeObjectRelease(object);
      uint64_t v52 = v182;
LABEL_74:
      uint64_t v7 = v183;
      goto LABEL_75;
    }

    uint64_t v52 = v182;
    uint64_t v23 = v184;
    if (v7)
    {
      swift_bridgeObjectRelease_n(object, 2LL);
      v190 = countAndFlagsBits;
      v191 = object & 0xFFFFFFFFFFFFFFLL;
      uint64_t v62 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v19, (uint64_t)&v190, v19);
      _StringGuts.appendInPlace(_:isASCII:)(v62, v63, (object & 0x4000000000000000LL) != 0);
      uint64_t v7 = v183;
    }

    else
    {
      if ((countAndFlagsBits & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRelease(object);
        char v101 = (id)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v102 = v186;
        uint64_t v103 = v186;
        uint64_t v7 = v183;
      }

      else
      {
        char v101 = _StringObject.sharedUTF8.getter(countAndFlagsBits, object);
        uint64_t v103 = v176;
        swift_bridgeObjectRelease(object);
        if (v103 < v186) {
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
        }
        uint64_t v52 = v182;
        uint64_t v7 = v183;
        uint64_t v23 = v184;
        uint64_t v102 = v186;
      }

      uint64_t v104 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v102, (uint64_t)v101, v103);
      _StringGuts.appendInPlace(_:isASCII:)(v104, v105, countAndFlagsBits < 0);
      swift_bridgeObjectRelease(object);
    }

  uint64_t v64 = swift_release((uint64_t)v42);
  if (v57 <= 0) {
    goto LABEL_29;
  }
  uint64_t v108 = (uint64_t)&v94;
  MEMORY[0x1895F8858](v64);
  BOOL v67 = type metadata accessor for _ContiguousArrayBuffer(0LL, v106, v65, v66);
  *(&v94 - 6) = v67;
  *(&v94 - 5) = v44;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, v67, v68);
  unint64_t v70 = v109;
  uint64_t v90 = WitnessTable;
  char v91 = v109;
  uint64_t v92 = v57;
  unint64_t v93 = v56;
  (*(void (**)(void *__return_ptr, char *(*)(char *, uint64_t), uint64_t *, void *, uint64_t))(*(void *)(v109 + 8) + 72LL))( v110,  partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:),  &v94 - 8,  &unk_189B8D178,  v44);
  if ((v110[0] & 1) != 0)
  {
    (*(void (**)(uint64_t, uint64_t))(v70 + 64))(v44, v70);
    uint64_t v71 = v60 < 1;
    uint64_t v72 = v95;
    unsigned int v73 = v96;
    uint64_t v108 = v45;
    unint64_t v74 = v44;
    BOOL v76 = v105;
    uint64_t v75 = v106;
    if (!v71)
    {
      uint64_t v107 = *(char **)(v70 + 80);
      uint64_t v77 = *(void (**)(char *, uint64_t, uint64_t))(v70 + 192);
      do
      {
        uint64_t v78 = (void (*)(void *, void))((uint64_t (*)(void *, char *, uint64_t, uint64_t))v107)( v110,  v23,  v74,  v70);
        (*(void (**)(char *))(v76 + 16))(v73);
        v78(v110, 0LL);
        unint64_t v70 = v109;
        (*(void (**)(unint64_t, char *, uint64_t))(v76 + 32))(v56, v73, v75);
        v56 += v108;
        v77(v23, v74, v70);
      }

      while (v56 < v72);
    }

    uint64_t v80 = v97;
    uint64_t v79 = v98;
    unint64_t v81 = v99;
    (*(void (**)(uint64_t, char *, uint64_t))(v98 + 32))(v97, v23, v99);
    _expectEnd<A>(of:is:)((uint64_t)v29, v80, v74, v70);
    (*(void (**)(uint64_t, uint64_t))(v79 + 8))(v80, v81);
    uint64_t v82 = v29;
    uint64_t v83 = v74;
  }

  else
  {
LABEL_29:
    uint64_t v82 = v29;
    uint64_t v83 = v44;
  }

  uint64_t result = ((uint64_t (*)(char *, uint64_t))v104)(v82, v83);
  Swift::String v85 = *(void *)(v100 + 16);
  uint64_t v34 = __OFADD__(v85, v102);
  Swift::Int v86 = v85 + v102;
  if (v34) {
    goto LABEL_46;
  }
  uint64_t v34 = __OFADD__(v86, v101);
  uint64_t v87 = v86 + v101;
  if (v34)
  {
LABEL_47:
    __break(1u);
LABEL_48:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  if (v87 < 0) {
    goto LABEL_48;
  }
  *(void *)(v100 + 24) = *(void *)(v100 + 24) & 1LL | (2 * v87);
  return result;
}

  if (v18 > 15) {
    goto LABEL_24;
  }
LABEL_13:
  swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
  swift_bridgeObjectRetain(v16, v22, v23, v24);
  uint64_t v25 = _StringGuts._convertedToSmall()(v15, v16);
  Swift::String::Index v27 = v26;
  swift_bridgeObjectRelease(v16);
  v28._Swift::UInt64 rawBits = 1LL;
  v29._Swift::UInt64 rawBits = 1LL;
  v30._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v28, v29, 0LL, 0xE000000000000000LL);
  if (v30._rawBits < 0x10000) {
    v30._rawBits |= 3;
  }
  uint64_t v32 = specialized String.init(_:)(v30, v31, 0LL, 0xE000000000000000LL);
  uint64_t v34 = v33;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v35 = _StringGuts._convertedToSmall()(v32, v34);
  int64_t v37 = v36;
  swift_bridgeObjectRelease(v34);
  uint64_t v38 = specialized _SmallString.init(_:appending:)(v25, v27, v35, v37);
  if ((v40 & 1) != 0) {
    goto LABEL_197;
  }
  unint64_t v15 = v38;
  uint64_t v41 = v39;
  swift_bridgeObjectRelease(v16);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  *(void *)&v222 = v15;
  *((void *)&v222 + 1) = v41;
  uint64_t v6 = v214;
  uint64_t countAndFlagsBits = v8._countAndFlagsBits;
LABEL_25:
  uint64_t v48 = HIBYTE(v41) & 0xF;
  if ((v41 & 0x2000000000000000LL) != 0) {
    uint64_t v49 = HIBYTE(v41) & 0xF;
  }
  else {
    uint64_t v49 = v15 & 0xFFFFFFFFFFFFLL;
  }
  v211 = v8._object;
  if (!v49 && (v15 & ~v41 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain((unint64_t)v8._object, v42, v43, v44);
    swift_bridgeObjectRelease(v41);
    *(void *)&v222 = countAndFlagsBits;
    *((void *)&v222 + 1) = v8._object;
    goto LABEL_76;
  }

  uint64_t v50 = (uint64_t)v8._object & 0x2000000000000000LL;
  uint64_t v51 = ((unint64_t)v8._object >> 56) & 0xF;
  if ((v41 & 0x2000000000000000LL) != 0 && v50)
  {
    uint64_t v52 = v48 + v51;
    if (v48 + v51 <= 0xF)
    {
      if (v51)
      {
        uint64_t v88 = 0;
        int64_t v89 = 0LL;
        uint64_t v90 = v41;
        do
        {
          char v91 = v48 + v89;
          uint64_t v92 = v89 + 1;
          if (v89 >= 8) {
            unint64_t v93 = (unint64_t)v8._object;
          }
          else {
            unint64_t v93 = countAndFlagsBits;
          }
          uint64_t v94 = v93 >> (v88 & 0x38);
          uint64_t v95 = (8 * v48 + v88) & 0x38;
          unint64_t v96 = (-255LL << v95) - 1;
          unint64_t v97 = (unint64_t)v94 << v95;
          uint64_t v98 = v97 | v96 & v90;
          unint64_t v99 = v97 | v96 & v15;
          if (v91 < 8) {
            unint64_t v15 = v99;
          }
          else {
            uint64_t v90 = v98;
          }
          v88 += 8;
          int64_t v89 = v92;
        }

        while (v51 != v92);
      }

      else
      {
        uint64_t v90 = v41;
      }

      swift_bridgeObjectRelease(v41);
      uint64_t v104 = 0xA000000000000000LL;
      if (!(v15 & 0x8080808080808080LL | v90 & 0x80808080808080LL)) {
        uint64_t v104 = 0xE000000000000000LL;
      }
      *(void *)&v222 = v15;
      *((void *)&v222 + 1) = v104 & 0xFF00000000000000LL | (v52 << 56) | v90 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_75;
    }

    uint64_t v50 = 1LL;
  }

  v215 = v3;
  *(void *)&v216 = countAndFlagsBits;
  uint64_t v53 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v50) {
    uint64_t v54 = ((unint64_t)v8._object >> 56) & 0xF;
  }
  else {
    uint64_t v54 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n((uint64_t)v8._object, 2LL, v43, v44);
  if (((uint64_t)v8._object & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n((uint64_t)v8._object, 4LL, v55, v56);
    uint64_t v57 = v54;
    if ((v41 & 0x1000000000000000LL) == 0) {
      goto LABEL_39;
    }
LABEL_189:
    v207 = String.UTF8View._foreignCount()();
    uint64_t v59 = v207 + v57;
    if (!__OFADD__(v207, v57)) {
      goto LABEL_40;
    }
LABEL_191:
    __break(1u);
    goto LABEL_192;
  }

  swift_bridgeObjectRetain_n((uint64_t)v8._object, 5LL, v55, v56);
  v202._Swift::UInt64 rawBits = 1LL;
  v203._Swift::UInt64 rawBits = (v54 << 16) | 1;
  v204 = v216;
  v205._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v202, v203, v216, (unint64_t)v8._object);
  if (v205._rawBits < 0x10000) {
    v205._rawBits |= 3;
  }
  uint64_t v57 = specialized Collection.count.getter(v205, v206, v204, (unint64_t)v8._object);
  swift_bridgeObjectRelease((uint64_t)v8._object);
  if ((v41 & 0x1000000000000000LL) != 0) {
    goto LABEL_189;
  }
LABEL_39:
  uint64_t v58 = __OFADD__(v49, v57);
  uint64_t v59 = v49 + v57;
  if (v58) {
    goto LABEL_191;
  }
LABEL_40:
  if ((v15 & ~v41 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v59 <= 15)
    {
      uint64_t v60 = *((void *)&v222 + 1);
      goto LABEL_52;
    }

  swift_release((uint64_t)v24);
  uint64_t v51 = *v7;
  *uint64_t v7 = 0x8000000000000000LL;
  (*(void (**)(uint64_t, uint64_t, char *))(v31 + 32))( v55,  *(void *)(v51 + 48) + *(void *)(v31 + 72) * a3,  v12);
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(v20 - 1) + 32))( v56,  *(void *)(v51 + 56) + *(void *)(*(v20 - 1) + 72) * a3,  v20);
  _NativeDictionary._delete(at:)((Swift::_HashTable::Bucket)a3);
  uint64_t v52 = *v7;
  *uint64_t v7 = v51;
  swift_bridgeObjectRelease(v52);
}

  swift_release((uint64_t)v20);
  return Dictionary.Values.subscript.modify;
}

  if (v20 > 15) {
    goto LABEL_24;
  }
LABEL_13:
  swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
  swift_bridgeObjectRetain(v18, v24, v25, v26);
  Swift::String::Index v27 = _StringGuts._convertedToSmall()(v17, v18);
  uint64_t v29 = v28;
  swift_bridgeObjectRelease(v18);
  v30._Swift::UInt64 rawBits = 1LL;
  v31._Swift::UInt64 rawBits = 1LL;
  v32._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v30, v31, 0LL, 0xE000000000000000LL);
  if (v32._rawBits < 0x10000) {
    v32._rawBits |= 3;
  }
  uint64_t v34 = specialized String.init(_:)(v32, v33, 0LL, 0xE000000000000000LL);
  uint64_t v36 = v35;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  int64_t v37 = _StringGuts._convertedToSmall()(v34, v36);
  int v39 = v38;
  swift_bridgeObjectRelease(v36);
  unint64_t v40 = specialized _SmallString.init(_:appending:)(v27, v29, v37, v39);
  if ((v42 & 1) != 0) {
    goto LABEL_217;
  }
  unsigned int v17 = v40;
  uint64_t v43 = v41;
  swift_bridgeObjectRelease(v18);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  *(void *)&v239 = v17;
  *((void *)&v239 + 1) = v43;
  uint64_t v4 = v233;
LABEL_25:
  uint64_t v50 = HIBYTE(v43) & 0xF;
  if ((v43 & 0x2000000000000000LL) != 0) {
    uint64_t v51 = HIBYTE(v43) & 0xF;
  }
  else {
    uint64_t v51 = v17 & 0xFFFFFFFFFFFFLL;
  }
  v226 = *((void *)&v10 + 1);
  if (!v51 && (v17 & ~v43 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain(*((unint64_t *)&v10 + 1), v44, v45, v46);
    swift_bridgeObjectRelease(v43);
    v239 = v10;
    goto LABEL_76;
  }

  uint64_t v52 = *((void *)&v10 + 1) & 0x2000000000000000LL;
  uint64_t v53 = HIBYTE(*((void *)&v10 + 1)) & 0xFLL;
  if ((v43 & 0x2000000000000000LL) != 0 && v52)
  {
    uint64_t v54 = v50 + v53;
    if (v50 + v53 > 0xF)
    {
      uint64_t v52 = 1LL;
      goto LABEL_34;
    }

    if (v53)
    {
      uint64_t v90 = 0;
      char v91 = 0LL;
      uint64_t v92 = v43;
      do
      {
        unint64_t v93 = v50 + v91;
        uint64_t v94 = v91 + 1;
        if (v91 >= 8) {
          uint64_t v95 = *((void *)&v10 + 1);
        }
        else {
          uint64_t v95 = v10;
        }
        unint64_t v96 = v95 >> (v90 & 0x38);
        unint64_t v97 = (8 * v50 + v90) & 0x38;
        uint64_t v98 = (-255LL << v97) - 1;
        unint64_t v99 = (unint64_t)v96 << v97;
        uint64_t v100 = v99 | v98 & v92;
        char v101 = v99 | v98 & v17;
        if (v93 < 8) {
          unsigned int v17 = v101;
        }
        else {
          uint64_t v92 = v100;
        }
        v90 += 8;
        char v91 = v94;
      }

      while (v53 != v94);
    }

    else
    {
      uint64_t v92 = v43;
    }

    swift_bridgeObjectRelease(v43);
    uint64_t v107 = 0xA000000000000000LL;
    if (!(v17 & 0x8080808080808080LL | v92 & 0x80808080808080LL)) {
      uint64_t v107 = 0xE000000000000000LL;
    }
    *(void *)&v239 = v17;
    *((void *)&v239 + 1) = v107 & 0xFF00000000000000LL | (v54 << 56) | v92 & 0xFFFFFFFFFFFFFFLL;
LABEL_76:
    uint64_t v43 = v228;
    goto LABEL_77;
  }

  if (v18 > 15) {
    goto LABEL_24;
  }
LABEL_13:
  unsigned int v17 = (unint64_t)v6;
  swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
  swift_bridgeObjectRetain(v16, v22, v23, v24);
  uint64_t v25 = _StringGuts._convertedToSmall()(v15, v16);
  Swift::String::Index v27 = v26;
  swift_bridgeObjectRelease(v16);
  v28._Swift::UInt64 rawBits = 1LL;
  v29._Swift::UInt64 rawBits = 1LL;
  v30._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v28, v29, 0LL, 0xE000000000000000LL);
  if (v30._rawBits < 0x10000) {
    v30._rawBits |= 3;
  }
  uint64_t v32 = specialized String.init(_:)(v30, v31, 0LL, 0xE000000000000000LL);
  uint64_t v34 = v33;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v35 = _StringGuts._convertedToSmall()(v32, v34);
  int64_t v37 = v36;
  swift_bridgeObjectRelease(v34);
  uint64_t v38 = specialized _SmallString.init(_:appending:)(v25, v27, v35, v37);
  if ((v40 & 1) != 0) {
    goto LABEL_210;
  }
  unint64_t v15 = v38;
  uint64_t v41 = v39;
  swift_bridgeObjectRelease(v16);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  *(void *)&v230 = v15;
  *((void *)&v230 + 1) = v41;
  uint64_t v6 = (char *)v17;
LABEL_25:
  uint64_t v48 = HIBYTE(v41) & 0xF;
  if ((v41 & 0x2000000000000000LL) != 0) {
    uint64_t v49 = HIBYTE(v41) & 0xF;
  }
  else {
    uint64_t v49 = v15 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v50 = (uint64_t)"Dictionary.Values";
  if (!v49 && (v15 & ~v41 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain(0x80000001818B6150LL | 0x8000000000000000LL, v42, v43, v44);
    swift_bridgeObjectRelease(v41);
    *(void *)&v230 = 0xD000000000000011LL;
    *((void *)&v230 + 1) = 0x80000001818B6150LL | 0x8000000000000000LL;
    goto LABEL_73;
  }

  if ((v41 & 0x2000000000000000LL) != 0 && (0x80000001818B6150LL & 0x2000000000000000LL) != 0)
  {
    unsigned int v17 = v48 + ((0x80000001818B6150LL >> 56) & 0xF);
    if (v17 <= 0xF)
    {
      Swift::Int v86 = (0x80000001818B6150LL >> 56) & 0xF;
      if (v86)
      {
        uint64_t v88 = 0;
        int64_t v89 = 0LL;
        uint64_t v87 = v41;
        do
        {
          uint64_t v90 = v48 + v89;
          char v91 = v89 + 1;
          uint64_t v92 = 0x80000001818B6150LL | 0x8000000000000000LL;
          if (v89 < 8) {
            uint64_t v92 = 0xD000000000000011LL;
          }
          unint64_t v93 = v92 >> (v88 & 0x38);
          uint64_t v94 = (8 * v48 + v88) & 0x38;
          uint64_t v95 = (-255LL << v94) - 1;
          unint64_t v96 = (unint64_t)v93 << v94;
          unint64_t v97 = v96 | v95 & v87;
          uint64_t v98 = v96 | v95 & v15;
          if (v90 < 8) {
            unint64_t v15 = v98;
          }
          else {
            uint64_t v87 = v97;
          }
          v88 += 8;
          int64_t v89 = v91;
        }

        while (v86 != v91);
      }

      else
      {
        uint64_t v87 = v41;
      }

      swift_bridgeObjectRelease(v41);
      unint64_t v99 = 0xA000000000000000LL;
      if (!(v15 & 0x8080808080808080LL | v87 & 0x80808080808080LL)) {
        unint64_t v99 = 0xE000000000000000LL;
      }
      *(void *)&v230 = v15;
      *((void *)&v230 + 1) = v99 & 0xFF00000000000000LL | (v17 << 56) | v87 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_73;
    }
  }

  unsigned int v17 = (unint64_t)v6;
  uint64_t v6 = (char *)(0x80000001818B6150LL | 0x8000000000000000LL);
  if ((0x80000001818B6150LL & 0x2000000000000000LL) != 0) {
    uint64_t v51 = (0x80000001818B6150LL >> 56) & 0xF;
  }
  else {
    uint64_t v51 = 17LL;
  }
  swift_bridgeObjectRetain_n(0x80000001818B6150LL | 0x8000000000000000LL, 2LL, v43, v44);
  if ((0x80000001818B6150LL & 0x1000000000000000LL) != 0) {
    goto LABEL_202;
  }
  swift_bridgeObjectRetain_n(0x80000001818B6150LL | 0x8000000000000000LL, 4LL, v52, v53);
  uint64_t v54 = v51;
  if ((v41 & 0x1000000000000000LL) == 0) {
    goto LABEL_38;
  }
LABEL_205:
  v215 = String.UTF8View._foreignCount()();
  uint64_t v56 = v215 + v54;
  if (__OFADD__(v215, v54)) {
    goto LABEL_207;
  }
LABEL_39:
  if ((v15 & ~v41 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v57 = _StringGuts.nativeUnusedCapacity.getter(v15, v41);
    if ((v58 & 1) != 0) {
      goto LABEL_211;
    }
    uint64_t v59 = (v41 >> 61) & 1;
    if (v57 < v54) {
      LODWORD(v59) = 1;
    }
    if (v56 <= 15 && (_DWORD)v59) {
      goto LABEL_46;
    }
LABEL_51:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v56, v54);
    uint64_t v49 = (v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
    swift_bridgeObjectRelease_n(v49, 4LL);
    uint64_t v6 = (char *)v17;
    if (((v50 + 0x7FFFFFFFFFFFFFE0LL) & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease((v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
      _StringGuts._foreignAppendInPlace(_:)( 0xD000000000000011LL,  (v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL,  0LL,  v51);
    }

    else
    {
      uint64_t v83 = ((v50 + 0x7FFFFFFFFFFFFFE0LL) & 0x2000000000000000LL) == 0 || (v49 & 0x4000000000000000LL) != 0;
      swift_bridgeObjectRelease((v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
      if (((v50 + 0x7FFFFFFFFFFFFFE0LL) & 0x2000000000000000LL) != 0)
      {
        unsigned int v17 = v50 + 0x7FFFFFFFFFFFFFE0LL;
        swift_bridgeObjectRelease((v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
        v227 = 0xD000000000000011LL;
        v228 = (v50 + 0x7FFFFFFFFFFFFFE0LL) & 0xFFFFFFFFFFFFFFLL;
        uint64_t v100 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v51,  (uint64_t)&v227,  ((unint64_t)(v50 + 0x7FFFFFFFFFFFFFE0LL) >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v100, v101, v83);
        goto LABEL_73;
      }

      uint64_t v49 = (v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
      Swift::Int v84 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v51,  ((v50 + 0x7FFFFFFFFFFFFFE0LL) & 0xFFFFFFFFFFFFFFFLL) + 32,  17LL);
      _StringGuts.appendInPlace(_:isASCII:)(v84, v85, v83);
    }

    swift_bridgeObjectRelease(v49);
    goto LABEL_73;
  }

  if (v56 > 15) {
    goto LABEL_51;
  }
LABEL_46:
  swift_bridgeObjectRelease_n((v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL, 5LL);
  swift_bridgeObjectRetain(v41, v60, v61, v62);
  Swift::Int v63 = _StringGuts._convertedToSmall()(v15, v41);
  char v65 = v64;
  swift_bridgeObjectRelease(v41);
  v66._Swift::UInt64 rawBits = (v51 << 16) | 1;
  v67._Swift::UInt64 rawBits = 1LL;
  v68._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v67,  v66,  0xD000000000000011LL,  (v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
  if (v68._rawBits < 0x10000) {
    v68._rawBits |= 3;
  }
  unint64_t v70 = specialized String.init(_:)(v68, v69, 0xD000000000000011LL, (v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
  uint64_t v72 = v71;
  swift_bridgeObjectRelease((v50 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
  unsigned int v73 = _StringGuts._convertedToSmall()(v70, v72);
  uint64_t v49 = v74;
  swift_bridgeObjectRelease(v72);
  uint64_t v75 = specialized _SmallString.init(_:appending:)(v63, v65, v73, v49);
  if ((v77 & 1) != 0) {
    goto LABEL_210;
  }
  uint64_t v78 = v75;
  uint64_t v79 = v76;
  swift_bridgeObjectRelease(v41);
  *(void *)&v230 = v78;
  *((void *)&v230 + 1) = v79;
  uint64_t v6 = (char *)v17;
LABEL_73:
  uint64_t v102 = *((void *)&v230 + 1);
  uint64_t v103 = HIBYTE(*((void *)&v230 + 1)) & 0xFLL;
  if ((*((void *)&v230 + 1) & 0x2000000000000000LL) == 0) {
    uint64_t v103 = v230 & 0xFFFFFFFFFFFFLL;
  }
  if (v103 || ((unint64_t)v230 & ~*((void *)&v230 + 1) & 0x2000000000000000LL) != 0)
  {
    if ((*((void *)&v230 + 1) & 0x2000000000000000LL) == 0
      || (uint64_t v104 = specialized _SmallString.init(_:appending:)( v230,  *((unint64_t *)&v230 + 1),  0x5B28uLL,  0xE200000000000000LL),  (v81 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v80, v81, v82);
      _StringGuts.append(_:)(23336LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
      uint64_t v106 = *((void *)&v230 + 1);
      uint64_t v105 = v230;
    }

    else
    {
      uint64_t v105 = v104;
      uint64_t v106 = v80;
      swift_bridgeObjectRelease(v102);
      swift_bridgeObjectRelease(0xE200000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(*((uint64_t *)&v230 + 1));
    uint64_t v106 = 0xE200000000000000LL;
    uint64_t v105 = 23336LL;
  }

  uint64_t v110 = v232;
  v111 = HIBYTE(v232) & 0xF;
  if ((v232 & 0x2000000000000000LL) == 0) {
    v111 = v231 & 0xFFFFFFFFFFFFLL;
  }
  if (!v111 && (v231 & ~v232 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v232);
    v231 = v105;
    v232 = v106;
    goto LABEL_94;
  }

  if ((v232 & 0x2000000000000000LL) == 0)
  {
    if ((v106 & 0x2000000000000000LL) != 0) {
      goto LABEL_92;
    }
LABEL_89:
    uint64_t v49 = v105 & 0xFFFFFFFFFFFFLL;
LABEL_93:
    swift_bridgeObjectRetain(v106, v107, v108, v109);
    _StringGuts.append(_:)(v105, v106, 0LL, v49);
    swift_bridgeObjectRelease_n(v106, 2LL);
    goto LABEL_94;
  }

  if ((v106 & 0x2000000000000000LL) == 0) {
    goto LABEL_89;
  }
  uint64_t v112 = specialized _SmallString.init(_:appending:)(v231, v232, v105, v106);
  if ((v108 & 1) != 0)
  {
LABEL_92:
    uint64_t v49 = HIBYTE(v106) & 0xF;
    goto LABEL_93;
  }

  uint64_t v49 = v112;
  uint64_t v113 = v107;
  swift_bridgeObjectRelease(v110);
  swift_bridgeObjectRelease(v106);
  v231 = v49;
  v232 = v113;
LABEL_94:
  uint64_t v51 = v219;
  if ((v4 & 0xC000000000000001LL) != 0)
  {
    if (v4 < 0) {
      int64_t v117 = v4;
    }
    else {
      int64_t v117 = v4 & 0xFFFFFFFFFFFFFF8LL;
    }
    int64_t v118 = type metadata accessor for __CocoaDictionary.Iterator();
    char v119 = (unint64_t)swift_allocObject(v118, 0xE8uLL, 7uLL);
    v221 = 0LL;
    uint64_t v120 = 0LL;
    unint64_t v121 = 0LL;
    *(void *)(v119 + 208) = v117;
    *(void *)(v119 + 216) = 0LL;
    *(_OWORD *)(v119 + 16) = 0u;
    *(_OWORD *)(v119 + 32) = 0u;
    *(_OWORD *)(v119 + 48) = 0u;
    *(_OWORD *)(v119 + 64) = 0u;
    *(_OWORD *)(v119 + 80) = 0u;
    *(_OWORD *)(v119 + 96) = 0u;
    *(_OWORD *)(v119 + 112) = 0u;
    *(_OWORD *)(v119 + 128) = 0u;
    *(_OWORD *)(v119 + 144) = 0u;
    *(_OWORD *)(v119 + 160) = 0u;
    *(_OWORD *)(v119 + 176) = 0u;
    *(_OWORD *)(v119 + 192) = 0u;
    *(void *)(v119 + 224) = 0LL;
    uint64_t v41 = v119 | 0x8000000000000000LL;
  }

  else
  {
    unint64_t v122 = -1LL << *(_BYTE *)(v4 + 32);
    uint64_t v120 = ~v122;
    uint64_t v123 = *(void *)(v4 + 64);
    v221 = v4 + 64;
    unint64_t v124 = -v122;
    if (v124 < 64) {
      unint64_t v125 = ~(-1LL << v124);
    }
    else {
      unint64_t v125 = -1LL;
    }
    unint64_t v121 = v125 & v123;
    uint64_t v41 = v4;
  }

  v223 = v41 & 0x7FFFFFFFFFFFFFFFLL;
  v217[1] = v120;
  v220 = (unint64_t)(v120 + 64) >> 6;
  char v126 = swift_bridgeObjectRetain(v4, v114, v115, v116);
  v225 = 0LL;
  uint64_t v50 = 1LL;
  v226 = xmmword_1817FFC60;
  v218 = xmmword_1817FFC70;
  uint64_t v4 = (int64_t)v222;
  v224 = v41;
  while (1)
  {
    if ((v41 & 0x8000000000000000LL) != 0)
    {
      v135 = __CocoaDictionary.Iterator.next()(v126, v127, v52, v53);
      if (!v135) {
        goto LABEL_164;
      }
      v137 = v136;
      swift_unknownObjectRelease(v135);
      _forceBridgeFromObjectiveC<A>(_:_:)(v137, (char *)v3, v138, (char *)v4);
      swift_unknownObjectRelease(v137);
    }

    else
    {
      if (v121)
      {
        BOOL v133 = __clz(__rbit64(v121));
        v121 &= v121 - 1;
        uint64_t v134 = v133 | (v225 << 6);
      }

      else
      {
        v139 = v225 + 1;
        unint64_t v15 = v221;
        if (__OFADD__(v225, 1LL)) {
          goto LABEL_201;
        }
        if (v139 >= v220) {
          goto LABEL_164;
        }
        v140 = *(void *)(v221 + 8 * v139);
        if (!v140)
        {
          v141 = v225 + 2;
          if (v225 + 2 >= v220) {
            goto LABEL_164;
          }
          v140 = *(void *)(v221 + 8 * v141);
          if (!v140)
          {
            while (1)
            {
              v139 = v141 + 1;
              if (__OFADD__(v141, 1LL)) {
                break;
              }
              if (v139 >= v220) {
                goto LABEL_164;
              }
              v140 = *(void *)(v221 + 8 * v139);
              ++v141;
              if (v140) {
                goto LABEL_122;
              }
            }

            __break(1u);
LABEL_201:
            __break(1u);
LABEL_202:
            swift_bridgeObjectRetain_n((uint64_t)v6, 5LL, v52, v53);
            v211._Swift::UInt64 rawBits = 1LL;
            v212._Swift::UInt64 rawBits = (v51 << 16) | 1;
            v213._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v211, v212, 0xD000000000000011LL, (unint64_t)v6);
            if (v213._rawBits < 0x10000) {
              v213._rawBits |= 3;
            }
            uint64_t v54 = specialized Collection.count.getter(v213, v214, 0xD000000000000011LL, (unint64_t)v6);
            swift_bridgeObjectRelease((uint64_t)v6);
            if ((v41 & 0x1000000000000000LL) != 0) {
              goto LABEL_205;
            }
LABEL_38:
            uint64_t v55 = __OFADD__(v49, v54);
            uint64_t v56 = v49 + v54;
            if (!v55) {
              goto LABEL_39;
            }
LABEL_207:
            __break(1u);
LABEL_208:
            v184 = String.UTF8View._foreignCount()();
LABEL_175:
            uint64_t v55 = __OFADD__(v184, 2LL);
            uint64_t v185 = v184 + 2;
            if (v55)
            {
              __break(1u);
              goto LABEL_210;
            }

            if ((v3 & ~v15 & 0x2000000000000000LL) == 0
              || !swift_isUniquelyReferenced_nonNull_native(v15 & 0xFFFFFFFFFFFFFFFLL))
            {
              if (v185 <= 15) {
                goto LABEL_187;
              }
              goto LABEL_192;
            }

            uint64_t v186 = _StringGuts.nativeUnusedCapacity.getter(v3, v15);
            if ((v187 & 1) == 0)
            {
              v189 = (v15 & 0x2000000000000000LL) == 0 && v186 > 1;
              if (v185 <= 15 && !v189)
              {
LABEL_187:
                swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
                swift_bridgeObjectRetain(v15, v190, v191, v192);
                v193 = _StringGuts._convertedToSmall()(v3, v15);
                v195 = v194;
                swift_bridgeObjectRelease(v15);
                v196._Swift::UInt64 rawBits = 1LL;
                v197._Swift::UInt64 rawBits = 131073LL;
                v198._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v196, v197, 0x295DuLL, 0xE200000000000000LL);
                if (v198._rawBits < 0x10000) {
                  v198._rawBits |= 3;
                }
                v200 = specialized String.init(_:)(v198, v199, 0x295DuLL, 0xE200000000000000LL);
                v202 = v201;
                swift_bridgeObjectRelease(0xE200000000000000LL);
                v203 = _StringGuts._convertedToSmall()(v200, v202);
                v205 = v204;
                swift_bridgeObjectRelease(v202);
                v206 = specialized _SmallString.init(_:appending:)(v193, v195, v203, v205);
                if ((v207 & 1) == 0)
                {
                  uint64_t v3 = v206;
                  swift_bridgeObjectRelease(v15);
                  swift_bridgeObjectRelease(0x80000001818B6150LL | 0x8000000000000000LL);
                  swift_bridgeObjectRelease(0xE200000000000000LL);
                  return v3;
                }

    uint64_t v8 = 0LL;
    uint64_t v43 = 0u;
    memset(v44, 0, sizeof(v44));
    uint64_t v42 = 0u;
  }

  uint64_t v14 = *(void *)(v29 + 8 * v16);
  if (v14)
  {
    v13 += 2LL;
    goto LABEL_11;
  }

  while (1)
  {
    uint64_t v13 = v16 + 1;
    if (__OFADD__(v16, 1LL)) {
      break;
    }
    if (v13 >= v30)
    {
      Swift::String::Index v31 = v30 - 1;
      goto LABEL_23;
    }

    uint64_t v14 = *(void *)(v29 + 8 * v13);
    ++v16;
    if (v14) {
      goto LABEL_11;
    }
  }

        unint64_t v15 = v5 | 0xF000000000000000LL;
        unsigned int v16 = _allocateStringStorage(codeUnitCapacity:)(v5);
        *(void *)(v16 + 16) = v17;
        *(void *)(v16 + 24) = v5 | 0xF000000000000000LL;
        if (v17 < 0)
        {
          *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
          unint64_t v15 = *(void *)(v16 + 24);
        }

        *(_BYTE *)(v16 + 32 + (v15 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)&__src, v5, (char *)(v16 + 32));
        return *(void *)(v16 + 24);
      }

      return 0LL;
    }

  swift_release((uint64_t)v4);
  if ((a2 & 1) != 0)
  {
    uint64_t v29 = 1LL << v4[2].i8[0];
    if (v29 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v29 + 63) >> 6, v4 + 4);
    }
    else {
      v10->i64[0] = -1LL << v29;
    }
    v4[1].i64[0] = 0LL;
  }

  swift_release((uint64_t)v4);
  if ((a2 & 1) != 0)
  {
    size_t v28 = 1LL << v4[2].i8[0];
    if (v28 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v28 + 63) >> 6, v4 + 4);
    }
    else {
      v10->i64[0] = -1LL << v28;
    }
    v4[1].i64[0] = 0LL;
  }

  swift_release((uint64_t)v4);
  if ((a2 & 1) != 0)
  {
    uint64_t v24 = 1LL << v4[2].i8[0];
    if (v24 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v24 + 63) >> 6, v4 + 4);
    }
    else {
      v10->i64[0] = -1LL << v24;
    }
    v4[1].i64[0] = 0LL;
  }

  swift_release((uint64_t)v4);
  if ((a2 & 1) != 0)
  {
    uint64_t v30 = 1LL << v4[2].i8[0];
    if (v30 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v30 + 63) >> 6, v4 + 4);
    }
    else {
      v10->i64[0] = -1LL << v30;
    }
    v4[1].i64[0] = 0LL;
  }

  swift_release(v11);
  if ((v47 & 1) != 0)
  {
    uint64_t v44 = 1LL << *(_BYTE *)(v11 + 32);
    uint64_t v3 = v46;
    unsigned int v16 = (uint64_t)v55;
    if (v44 >= 64) {
      specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v44 + 63) >> 6, v30);
    }
    else {
      v30->i64[0] = -1LL << v44;
    }
    *(void *)(v11 + 16) = 0LL;
LABEL_29:
    uint64_t result = swift_release(v11);
    goto LABEL_30;
  }

  uint64_t result = swift_release(v11);
  uint64_t v3 = v46;
  unsigned int v16 = (uint64_t)v55;
LABEL_30:
  *uint64_t v3 = v16;
  return result;
}

    uint64_t v13 = (unint64_t)v3[2];
    uint64_t v12 = (unint64_t)v3[3];
    if (v13 >= v12 >> 1) {
      uint64_t v3 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v12 > 1),  v13 + 1,  1,  (uint64_t)v3);
    }
    v3[2] = (__objc2_class *)(v13 + 1);
    uint64_t v14 = &v3[v13];
    *((_DWORD *)v14 + 8) = v6;
    *((_WORD *)v14 + 18) = WORD2(v6);
    *(void *)uint64_t v2 = v3;
    *(Swift::tuple_scalar_Unicode_Scalar_normData_Unicode__NormData_optional *)&unint64_t v15 = Unicode._InternalNFD.Iterator.next()();
    uint64_t v6 = v15;
    if ((v15 & 0x1000000000000LL) != 0) {
      goto LABEL_35;
    }
  }

  if ((v6 & 0x600000000LL) != 0 && v6 >= 0x300)
  {
    uint64_t v8 = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(*(_DWORD *)(v2 + 12), v6);
    if ((v8 & 0x100000000LL) == 0) {
      goto LABEL_10;
    }
    LODWORD(v8) = _swift_stdlib_getComposition(v4, v6);
    if ((_DWORD)v8 != -1) {
      goto LABEL_10;
    }
  }

  if ((v6 & 0x7F800000000LL) != 0)
  {
LABEL_22:
    uint64_t v11 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v3);
    *(void *)uint64_t v2 = v3;
    if (v11) {
      goto LABEL_23;
    }
    unsigned int v17 = (int64_t)&v3[2]->isa + 1;
    goto LABEL_31;
  }

  LOBYTE(v5) = 0;
LABEL_39:
  *(_DWORD *)(v2 + 12) = v6;
  *(_BYTE *)(v2 + 16) = 0;
  return (Swift::Unicode::Scalar_optional)(v4 | ((unint64_t)v5 << 32));
}

    unsigned int v16 = v6._rawBits >> 16;
    if ((v10 & 0x2000000000000000LL) != 0)
    {
      uint64_t v59 = v11;
      uint64_t v60 = v10 & 0xFFFFFFFFFFFFFFLL;
      value = *((unsigned __int8 *)&v59 + v16);
      if (*((char *)&v59 + v16) < 0) {
        __asm { BR              X9 }
      }
    }

    else
    {
      if ((v11 & 0x1000000000000000LL) != 0) {
        unsigned int v17 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        unsigned int v17 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v10);
      }
      value = v17[v16];
      if ((char)v17[v16] < 0) {
        __asm { BR              X10 }
      }
    }

    if (value < 0xC0)
    {
LABEL_31:
      unint64_t v19 = 0LL;
      goto LABEL_32;
    }

      uint64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v7, v8);
      uint64_t v25 = (v23 & 1) == 0 && v22 >= v1;
      if ((v19 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v25)
        {
LABEL_41:
          uint64_t i = (unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
          swift_bridgeObjectRelease_n(i, 4LL);
          if (((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) & 0x1000000000000000LL) != 0)
          {
            swift_bridgeObjectRelease((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
            _StringGuts._foreignAppendInPlace(_:)( 0xD000000000000011LL,  (unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL,  0LL,  v15);
          }

          else
          {
            uint64_t v30 = ((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) & 0x2000000000000000LL) == 0
               || (i & 0x4000000000000000LL) != 0;
            swift_bridgeObjectRelease((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
            if (((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) & 0x2000000000000000LL) != 0)
            {
              uint64_t i = (unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
              swift_bridgeObjectRelease(i);
              *(void *)&v202 = 0xD000000000000011LL;
              *((void *)&v202 + 1) = (unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) & 0xFFFFFFFFFFFFFFLL;
              int64_t v117 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v15,  (uint64_t)&v202,  ((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) >> 56) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v117, v118, v30);
              swift_bridgeObjectRelease(i);
              goto LABEL_86;
            }

            uint64_t i = (unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL;
            Swift::String::Index v31 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v15,  ((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) & 0xFFFFFFFFFFFFFFFLL) + 32,  17LL);
            _StringGuts.appendInPlace(_:isASCII:)(v31, v32, v30);
          }

          swift_bridgeObjectRelease_n(i, 2LL);
          goto LABEL_86;
        }

  BOOL v18 = 0LL;
  unint64_t v19 = (uint8x16_t *)((char *)TypeName + v9);
  unsigned int v17 = 1;
  unsigned int v20 = TypeName;
  uint64_t v21 = TypeName;
  while (1)
  {
    uint64_t v24 = v21->i8[0];
    uint64_t v21 = (uint8x16_t *)((char *)v21 + 1);
    uint64_t v23 = v24;
    if (v24 < 0) {
      break;
    }
    uint64_t v22 = 1LL;
LABEL_25:
    v18 += v22;
    unsigned int v20 = v21;
    if (v21 == v19)
    {
      if (v9 <= 15) {
        goto LABEL_74;
      }
LABEL_64:
      unsigned int v16 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( TypeName->i8,  v9,  v9,  v17 & 1);
      unint64_t v15 = *(int8x8_t *)(v16 + 24);
      goto LABEL_185;
    }
  }

  if ((v23 + 32) < 0xE2u)
  {
    if (v23 == 224)
    {
      if (v21 == v19 || (v20->i8[1] & 0xE0) != 0xA0) {
        goto LABEL_65;
      }
      goto LABEL_49;
    }

    if ((v23 + 19) < 0xF4u)
    {
      if (v23 == 237)
      {
        if (v21 == v19) {
          goto LABEL_65;
        }
        uint64_t v25 = v20->u8[1];
        if (v25 > 0x9F) {
          goto LABEL_65;
        }
        goto LABEL_48;
      }

      if ((v23 + 16) < 0xFEu)
      {
        if (v23 == 240)
        {
        }

        else
        {
          if (v23 > 0xF3u)
          {
            if (v21 == v19) {
              goto LABEL_65;
            }
            uint64_t v26 = v20->u8[1];
            if (v26 > 0x8F) {
              goto LABEL_65;
            }
          }

          else
          {
            if (v21 == v19) {
              goto LABEL_65;
            }
            LOBYTE(v26) = v20->i8[1];
          }

          if ((v26 & 0xC0) != 0x80) {
            goto LABEL_65;
          }
        }

        if (&v20->i16[1] == (__int16 *)v19
          || (v20->i8[2] & 0xC0) != 0x80
          || (uint8x16_t *)((char *)v20->i32 + 3) == v19
          || (v20->i8[3] & 0xC0) != 0x80)
        {
          goto LABEL_65;
        }

        unsigned int v17 = 0;
        uint64_t v21 = (uint8x16_t *)((char *)v20->i64 + 4);
        uint64_t v22 = 4LL;
        goto LABEL_25;
      }
    }

    if (v21 == v19) {
      goto LABEL_65;
    }
    LOBYTE(v25) = v20->i8[1];
LABEL_48:
    if ((v25 & 0xC0) != 0x80) {
      goto LABEL_65;
    }
LABEL_49:
    unsigned int v17 = 0;
    uint64_t v21 = (uint8x16_t *)((char *)v20->i32 + 3);
    uint64_t v22 = 3LL;
    goto LABEL_25;
  }

  if (v21 != v19 && (v21->i8[0] & 0xC0) == 0x80)
  {
    unsigned int v17 = 0;
    uint64_t v21 = (uint8x16_t *)&v20->i16[1];
    uint64_t v22 = 2LL;
    goto LABEL_25;
  }

  if (v18 > 15) {
    goto LABEL_24;
  }
LABEL_13:
  uint64_t v22 = v5;
  swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
  swift_bridgeObjectRetain(v16, v23, v24, v25);
  uint64_t v26 = _StringGuts._convertedToSmall()(v15, v16);
  size_t v28 = v27;
  swift_bridgeObjectRelease(v16);
  v29._Swift::UInt64 rawBits = 1LL;
  v30._Swift::UInt64 rawBits = 1LL;
  v31._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v29, v30, 0LL, 0xE000000000000000LL);
  if (v31._rawBits < 0x10000) {
    v31._rawBits |= 3;
  }
  Swift::Bool v33 = specialized String.init(_:)(v31, v32, 0LL, 0xE000000000000000LL);
  uint64_t v35 = v34;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v36 = _StringGuts._convertedToSmall()(v33, v35);
  uint64_t v38 = v37;
  swift_bridgeObjectRelease(v35);
  int v39 = specialized _SmallString.init(_:appending:)(v26, v28, v36, v38);
  if ((v41 & 1) != 0) {
    goto LABEL_200;
  }
  unint64_t v15 = v39;
  uint64_t v42 = v40;
  swift_bridgeObjectRelease(v16);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  *(void *)&v222 = v15;
  *((void *)&v222 + 1) = v42;
  int64_t v5 = v22;
LABEL_25:
  uint64_t v49 = 131073LL;
  uint64_t v50 = HIBYTE(v42) & 0xF;
  if ((v42 & 0x2000000000000000LL) != 0) {
    uint64_t v51 = HIBYTE(v42) & 0xF;
  }
  else {
    uint64_t v51 = v15 & 0xFFFFFFFFFFFFLL;
  }
  if (!v51 && (v15 & ~v42 & 0x2000000000000000LL) == 0)
  {
    unint64_t v15 = 7628115LL;
    uint64_t v83 = 0xE300000000000000LL;
    swift_bridgeObjectRetain(0xE300000000000000LL, v43, v44, v45);
    swift_bridgeObjectRelease(v42);
LABEL_61:
    *(void *)&v222 = v15;
    *((void *)&v222 + 1) = v83;
    goto LABEL_62;
  }

  if ((v42 & 0x2000000000000000LL) != 0 && v50 <= 0xC)
  {
    uint64_t v52 = 8 * HIBYTE(v42);
    uint64_t v53 = (-255LL << (v52 & 0x38)) - 1;
    uint64_t v54 = 83LL << (v52 & 0x38);
    uint64_t v55 = v50 + 1;
    if (v50 >= 8)
    {
      uint64_t v56 = v54 | v53 & v42;
    }

    else
    {
      unint64_t v15 = v54 | v53 & v15;
      if (v50 != 7)
      {
        unint64_t v15 = (101LL << (8 * (v55 & 7u))) | ((-255LL << (8 * (v55 & 7u))) - 1) & v15;
        if (v50 < 6)
        {
          unint64_t v15 = (116LL << ((v52 + 16) & 0x38)) | ((-255LL << ((v52 + 16) & 0x38)) - 1) & v15;
          char v91 = v42;
          goto LABEL_57;
        }

        uint64_t v90 = 8;
        int64_t v89 = v42;
LABEL_56:
        char v91 = (116LL << (8 * (v90 & 7u))) | ((-255LL << (8 * (v90 & 7u))) - 1) & v89;
LABEL_57:
        swift_bridgeObjectRelease(v42);
        uint64_t v92 = 0xA000000000000000LL;
        if (!(v15 & 0x8080808080808080LL | v91 & 0x80808080808080LL)) {
          uint64_t v92 = 0xE000000000000000LL;
        }
        uint64_t v83 = (v92 & 0xFF00000000000000LL | (v50 << 56) | v91 & 0xFFFFFFFFFFFFFFLL) + 0x300000000000000LL;
        goto LABEL_61;
      }

      uint64_t v55 = 8;
      uint64_t v56 = v42;
    }

    int64_t v89 = (101LL << (8 * (v55 & 7u))) | ((-255LL << (8 * (v55 & 7u))) - 1) & v56;
    uint64_t v90 = v50 + 2;
    goto LABEL_56;
  }

  swift_bridgeObjectRetain_n(0xE300000000000000LL, 6LL, v44, v45);
  if ((v42 & 0x1000000000000000LL) != 0) {
    goto LABEL_194;
  }
  uint64_t v57 = __OFADD__(v51, 3LL);
  uint64_t v58 = v51 + 3;
  if (v57) {
    goto LABEL_196;
  }
LABEL_37:
  if ((v15 & ~v42 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v42 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v59 = _StringGuts.nativeUnusedCapacity.getter(v15, v42);
    if ((v60 & 1) != 0) {
      goto LABEL_201;
    }
    uint64_t v62 = (v42 & 0x2000000000000000LL) == 0 && v59 > 2;
    if (v58 <= 15 && !v62) {
      goto LABEL_48;
    }
LABEL_53:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v58, 3LL);
    swift_bridgeObjectRelease_n(0xE300000000000000LL, 6LL);
    v220 = xmmword_1817FFDD0;
    uint64_t v87 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 3LL, (uint64_t)&v220, 3LL);
    _StringGuts.appendInPlace(_:isASCII:)(v87, v88, 1);
    uint64_t v83 = *((void *)&v222 + 1);
    unint64_t v15 = v222;
    goto LABEL_62;
  }

  if (v58 > 15) {
    goto LABEL_53;
  }
LABEL_48:
  Swift::Int v63 = v5;
  swift_bridgeObjectRelease_n(0xE300000000000000LL, 5LL);
  swift_bridgeObjectRetain(v42, v64, v65, v66);
  BOOL v67 = _StringGuts._convertedToSmall()(v15, v42);
  unint64_t v69 = v68;
  swift_bridgeObjectRelease(v42);
  v70._Swift::UInt64 rawBits = v49 + 0x10000;
  v71._Swift::UInt64 rawBits = 1LL;
  v72._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v71, v70, 0x746553uLL, 0xE300000000000000LL);
  if (v72._rawBits < 0x10000) {
    v72._rawBits |= 3;
  }
  unint64_t v74 = specialized String.init(_:)(v72, v73, 0x746553uLL, 0xE300000000000000LL);
  BOOL v76 = v75;
  swift_bridgeObjectRelease(0xE300000000000000LL);
  uint64_t v77 = _StringGuts._convertedToSmall()(v74, v76);
  uint64_t v79 = v78;
  swift_bridgeObjectRelease(v76);
  uint64_t v80 = specialized _SmallString.init(_:appending:)(v67, v69, v77, v79);
  if ((v82 & 1) != 0) {
    goto LABEL_200;
  }
  unint64_t v15 = v80;
  uint64_t v83 = v81;
  swift_bridgeObjectRelease(v42);
  *(void *)&v222 = v15;
  *((void *)&v222 + 1) = v83;
  int64_t v5 = v63;
LABEL_62:
  unint64_t v93 = HIBYTE(v83) & 0xF;
  if ((v83 & 0x2000000000000000LL) == 0) {
    unint64_t v93 = v15 & 0xFFFFFFFFFFFFLL;
  }
  if (v93 || (v15 & ~v83 & 0x2000000000000000LL) != 0)
  {
    if ((v83 & 0x2000000000000000LL) == 0
      || (uint64_t v94 = specialized _SmallString.init(_:appending:)(v15, v83, 0x5B28uLL, 0xE200000000000000LL), (v85 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v84, v85, v86);
      _StringGuts.append(_:)(23336LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
      unint64_t v96 = *((void *)&v222 + 1);
      uint64_t v95 = v222;
    }

    else
    {
      uint64_t v95 = v94;
      unint64_t v96 = v84;
      swift_bridgeObjectRelease(v83);
      swift_bridgeObjectRelease(0xE200000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v83);
    unint64_t v96 = 0xE200000000000000LL;
    uint64_t v95 = 23336LL;
  }

  uint64_t v100 = v224;
  char v101 = HIBYTE(v224) & 0xF;
  if ((v224 & 0x2000000000000000LL) == 0) {
    char v101 = v223 & 0xFFFFFFFFFFFFLL;
  }
  if (!v101 && (v223 & ~v224 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v224);
    v223 = v95;
    v224 = v96;
    goto LABEL_83;
  }

  if ((v224 & 0x2000000000000000LL) == 0)
  {
    if ((v96 & 0x2000000000000000LL) != 0) {
      goto LABEL_81;
    }
LABEL_78:
    uint64_t v102 = v95 & 0xFFFFFFFFFFFFLL;
LABEL_82:
    swift_bridgeObjectRetain(v96, v97, v98, v99);
    _StringGuts.append(_:)(v95, v96, 0LL, v102);
    swift_bridgeObjectRelease_n(v96, 2LL);
    goto LABEL_83;
  }

  if ((v96 & 0x2000000000000000LL) == 0) {
    goto LABEL_78;
  }
  uint64_t v103 = specialized _SmallString.init(_:appending:)(v223, v224, v95, v96);
  if ((v98 & 1) != 0)
  {
LABEL_81:
    uint64_t v102 = HIBYTE(v96) & 0xF;
    goto LABEL_82;
  }

  uint64_t v104 = v103;
  uint64_t v105 = v97;
  swift_bridgeObjectRelease(v100);
  swift_bridgeObjectRelease(v96);
  v223 = v104;
  v224 = v105;
LABEL_83:
  uint64_t v109 = v212;
  if ((v3 & 0xC000000000000001LL) != 0)
  {
    if (v3 < 0) {
      uint64_t v110 = v3;
    }
    else {
      uint64_t v110 = v3 & 0xFFFFFFFFFFFFFF8LL;
    }
    v111 = type metadata accessor for __CocoaSet.Iterator();
    uint64_t v112 = (unint64_t)swift_allocObject(v111, 0xE8uLL, 7uLL);
    v214 = 0LL;
    uint64_t v113 = 0LL;
    uint64_t v114 = 0LL;
    *(void *)(v112 + 208) = v110;
    *(void *)(v112 + 216) = 0LL;
    *(_OWORD *)(v112 + 16) = 0u;
    *(_OWORD *)(v112 + 32) = 0u;
    *(_OWORD *)(v112 + 48) = 0u;
    *(_OWORD *)(v112 + 64) = 0u;
    *(_OWORD *)(v112 + 80) = 0u;
    *(_OWORD *)(v112 + 96) = 0u;
    *(_OWORD *)(v112 + 112) = 0u;
    *(_OWORD *)(v112 + 128) = 0u;
    *(_OWORD *)(v112 + 144) = 0u;
    *(_OWORD *)(v112 + 160) = 0u;
    *(_OWORD *)(v112 + 176) = 0u;
    *(_OWORD *)(v112 + 192) = 0u;
    *(void *)(v112 + 224) = 0LL;
    uint64_t v42 = v112 | 0x8000000000000000LL;
  }

  else
  {
    v115 = -1LL << *(_BYTE *)(v3 + 32);
    uint64_t v113 = ~v115;
    int64_t v116 = *(void *)(v3 + 56);
    v214 = v3 + 56;
    int64_t v117 = -v115;
    if (v117 < 64) {
      int64_t v118 = ~(-1LL << v117);
    }
    else {
      int64_t v118 = -1LL;
    }
    uint64_t v114 = v118 & v116;
    uint64_t v42 = v3;
  }

  v216 = v42 & 0x7FFFFFFFFFFFFFFFLL;
  v210[1] = v113;
  v213 = (unint64_t)(v113 + 64) >> 6;
  char v119 = swift_bridgeObjectRetain(v3, v106, v107, v108);
  v218 = 0LL;
  uint64_t v49 = 1LL;
  v219 = xmmword_1817FFC60;
  v211 = xmmword_1817FFC70;
  uint64_t v3 = (int64_t)v215;
  v217 = v42;
  while (1)
  {
    if ((v42 & 0x8000000000000000LL) != 0)
    {
      v130 = __CocoaSet.Iterator.next()(v119, v120, v121, v122);
      if (!v130) {
        goto LABEL_153;
      }
      uint64_t v132 = v130;
      _forceBridgeFromObjectiveC<A>(_:_:)(v130, (char *)v2, v131, (char *)v3);
      swift_unknownObjectRelease(v132);
    }

    else
    {
      if (v114)
      {
        unint64_t v128 = __clz(__rbit64(v114));
        v114 &= v114 - 1;
        Swift::String v129 = v128 | (v218 << 6);
      }

      else
      {
        BOOL v133 = v218 + 1;
        unint64_t v15 = v214;
        if (__OFADD__(v218, 1LL)) {
          goto LABEL_193;
        }
        if (v133 >= v213) {
          goto LABEL_153;
        }
        uint64_t v134 = *(void *)(v214 + 8 * v133);
        if (!v134)
        {
          v135 = v218 + 2;
          if (v218 + 2 >= v213) {
            goto LABEL_153;
          }
          uint64_t v134 = *(void *)(v214 + 8 * v135);
          if (!v134)
          {
            while (1)
            {
              BOOL v133 = v135 + 1;
              if (__OFADD__(v135, 1LL)) {
                break;
              }
              if (v133 >= v213) {
                goto LABEL_153;
              }
              uint64_t v134 = *(void *)(v214 + 8 * v133);
              ++v135;
              if (v134) {
                goto LABEL_111;
              }
            }

            __break(1u);
LABEL_193:
            __break(1u);
LABEL_194:
            v207 = String.UTF8View._foreignCount()();
            uint64_t v58 = v207 + 3;
            if (!__OFADD__(v207, 3LL)) {
              goto LABEL_37;
            }
LABEL_196:
            __break(1u);
LABEL_197:
            v208 = String.UTF8View._foreignCount()();
            v181 = v208 + 2;
            if (!__OFADD__(v208, 2LL))
            {
LABEL_165:
              if ((v15 & ~v2 & 0x2000000000000000LL) == 0
                || !swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
              {
                if (v181 <= 15) {
                  goto LABEL_176;
                }
                goto LABEL_181;
              }

              uint64_t v182 = _StringGuts.nativeUnusedCapacity.getter(v15, v2);
              if ((v183 & 1) == 0)
              {
                uint64_t v185 = (v2 & 0x2000000000000000LL) == 0 && v182 > 1;
                if (v181 <= 15 && !v185)
                {
LABEL_176:
                  swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
                  swift_bridgeObjectRetain(v2, v186, v187, v188);
                  v189 = _StringGuts._convertedToSmall()(v15, v2);
                  v191 = v190;
                  swift_bridgeObjectRelease(v2);
                  v192._Swift::UInt64 rawBits = 1LL;
                  v193._Swift::UInt64 rawBits = 131073LL;
                  v194._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v192, v193, 0x295DuLL, 0xE200000000000000LL);
                  if (v194._rawBits < 0x10000) {
                    v194._rawBits |= 3;
                  }
                  v196 = specialized String.init(_:)(v194, v195, 0x295DuLL, 0xE200000000000000LL);
                  v198 = v197;
                  swift_bridgeObjectRelease(0xE200000000000000LL);
                  v199 = _StringGuts._convertedToSmall()(v196, v198);
                  v201 = v200;
                  swift_bridgeObjectRelease(v198);
                  v202 = specialized _SmallString.init(_:appending:)(v189, v191, v199, v201);
                  if ((v203 & 1) == 0)
                  {
                    unint64_t v15 = v202;
                    swift_bridgeObjectRelease(v2);
                    swift_bridgeObjectRelease(0xE300000000000000LL);
                    swift_bridgeObjectRelease(0xE200000000000000LL);
                    return v15;
                  }

  uint64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
  uint64_t v26 = (v24 & 1) == 0 && v23 >= v17;
  if ((v20 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v26) {
      goto LABEL_41;
    }
    goto LABEL_34;
  }

  if (!v26)
  {
LABEL_34:
    Swift::String::Index v27 = _StringGuts.nativeCapacity.getter(v8, v9);
    if ((v28 & 1) != 0) {
      uint64_t v29 = 0LL;
    }
    else {
      uint64_t v29 = v27;
    }
    if (v29 + 0x4000000000000000LL < 0)
    {
      __break(1u);
LABEL_287:
      uint64_t v8 = _StringGuts._foreignConvertedToSmall()(v8, v9);
      int v39 = v242;
      goto LABEL_57;
    }

    uint64_t v30 = 2 * v29;
    if (v30 > v19) {
      unint64_t v19 = v30;
    }
  }

  _StringGuts.grow(_:)(v19);
LABEL_41:
  Swift::String::Index v31 = 0x80000001818B76F0LL | 0x8000000000000000LL;
  swift_bridgeObjectRelease_n(0x80000001818B76F0LL | 0x8000000000000000LL, 4LL);
  if ((0x80000001818B76F0LL & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
    _StringGuts._foreignAppendInPlace(_:)(0xD000000000000018LL, 0x80000001818B76F0LL | 0x8000000000000000LL, 0LL, v14);
  }

  else
  {
    uint64_t v32 = (0x80000001818B76F0LL & 0x2000000000000000LL) == 0 || (0x80000001818B76F0LL & 0x4000000000000000LL) != 0;
    swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
    if ((0x80000001818B76F0LL & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
      *(void *)&v255 = 0xD000000000000018LL;
      *((void *)&v255 + 1) = 0x80000001818B76F0LL & 0xFFFFFFFFFFFFFFLL;
      v231 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v14,  (uint64_t)&v255,  (0x80000001818B76F0LL >> 56) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v231, v232, v32);
      swift_bridgeObjectRelease(0x80000001818B76F0LL | 0x8000000000000000LL);
      goto LABEL_86;
    }

    Swift::String::Index v31 = 0x80000001818B76F0LL | 0x8000000000000000LL;
    Swift::Bool v33 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v14,  (0x80000001818B76F0LL & 0xFFFFFFFFFFFFFFFLL) + 32,  24LL);
    _StringGuts.appendInPlace(_:isASCII:)(v33, v34, v32);
  }

  swift_bridgeObjectRelease_n(v31, 2LL);
LABEL_86:
  uint64_t v80 = 34LL;
  unint64_t v81 = 0xE100000000000000LL;
  *(void *)&v255 = 34LL;
  *((void *)&v255 + 1) = 0xE100000000000000LL;
  uint64_t v82 = HIBYTE(x1_0) & 0xF;
  if ((x1_0 & 0x2000000000000000LL) == 0) {
    uint64_t v82 = a1 & 0xFFFFFFFFFFFFLL;
  }
  v250 = v82;
  if (!v82)
  {
    uint64_t v106 = 0xE100000000000000LL;
    goto LABEL_192;
  }

  uint64_t v83 = 0LL;
  v245 = (x1_0 & 0xFFFFFFFFFFFFFFFLL) + 32;
  v246 = x1_0 & 0xFFFFFFFFFFFFFFLL;
  Swift::Int v84 = 1;
  v247 = x1_0;
  v248 = a1;
  do
  {
    while (1)
    {
      if ((x1_0 & 0x1000000000000000LL) != 0)
      {
        int64_t v89 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v83 << 16));
        scalarLength = v89.scalarLength;
        value = v89._0._value;
      }

      else
      {
        if ((x1_0 & 0x2000000000000000LL) != 0)
        {
          v253 = a1;
          v254 = v246;
          Swift::Int v86 = &v253;
        }

        else
        {
          Swift::Int v86 = (uint64_t *)v245;
          if ((a1 & 0x1000000000000000LL) == 0) {
            Swift::Int v86 = (uint64_t *)_StringObject.sharedUTF8.getter(a1, x1_0);
          }
        }

        value = _decodeScalar(_:startingAt:)((uint64_t)v86, v42, v83);
      }

      uint64_t v90 = value;
      v83 += scalarLength;
      uint64_t v94 = (unsigned __int128)Unicode.Scalar._escaped(asASCII:)(0);
      char v91 = (void *)*((void *)&v94 + 1);
      if (*((void *)&v94 + 1))
      {
        uint64_t v95 = *((void *)&v255 + 1);
        unint64_t v96 = HIBYTE(*((void *)&v255 + 1)) & 0xFLL;
        if ((*((void *)&v255 + 1) & 0x2000000000000000LL) == 0) {
          unint64_t v96 = v255 & 0xFFFFFFFFFFFFLL;
        }
        if (v96 || ((unint64_t)v255 & ~*((void *)&v255 + 1) & 0x2000000000000000LL) != 0)
        {
          if ((*((void *)&v94 + 1) & 0x2000000000000000LL & *((void *)&v255 + 1)) == 0
            || (unint64_t v97 = specialized _SmallString.init(_:appending:)( v255,  *((unint64_t *)&v255 + 1),  v94,  *((unint64_t *)&v94 + 1)),  (v92 & 1) != 0))
          {
            if ((*((void *)&v94 + 1) & 0x2000000000000000LL) != 0) {
              Swift::String v85 = HIBYTE(*((void *)&v94 + 1)) & 0xFLL;
            }
            else {
              Swift::String v85 = v94 & 0xFFFFFFFFFFFFLL;
            }
            swift_bridgeObjectRetain(*((unint64_t *)&v94 + 1), (uint64_t)v91, v92, v93);
            _StringGuts.append(_:)(v94, *((unint64_t *)&v94 + 1), 0LL, v85);
            swift_bridgeObjectRelease_n(*((uint64_t *)&v94 + 1), 2LL);
          }

          else
          {
            uint64_t v98 = v97;
            unint64_t v99 = v91;
            swift_bridgeObjectRelease(v95);
            swift_bridgeObjectRelease(*((uint64_t *)&v94 + 1));
            *(void *)&v255 = v98;
            *((void *)&v255 + 1) = v99;
          }
        }

        else
        {
          swift_bridgeObjectRelease(*((uint64_t *)&v255 + 1));
          v255 = v94;
        }

        goto LABEL_94;
      }

      char v101 = v255;
      uint64_t v100 = *((void *)&v255 + 1);
      if ((v84 & 1) != 0)
      {
        LODWORD(v253) = 0;
        swift_bridgeObjectRetain(*((unint64_t *)&v255 + 1), 0LL, v92, v93);
        uint64_t v102 = specialized BidirectionalCollection.last.getter(v101, v100);
        swift_bridgeObjectRelease(v100);
        if ((v102 & 0x100000000LL) != 0) {
          goto LABEL_277;
        }
        if (!_GraphemeBreakingState.shouldBreak(between:and:)( (Swift::Unicode::Scalar)v102,  (Swift::Unicode::Scalar)v90)) {
          break;
        }
      }

      v253 = v101;
      v254 = v100;
      *(void *)&v255 = 0LL;
      *((void *)&v255 + 1) = 0xE000000000000000LL;
      uint64_t v106 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v90);
      uint64_t v80 = v103;
      uint64_t v107 = v103 & 0x2000000000000000LL;
      uint64_t v108 = HIBYTE(v103) & 0xF;
      uint64_t v109 = HIBYTE(v100) & 0xF;
      if ((v100 & 0x2000000000000000LL) != 0 && v107)
      {
        if ((unint64_t)(v108 + v109) <= 0xF)
        {
          swift_bridgeObjectRelease(v103);
          if (v108)
          {
            uint64_t v148 = 0;
            v149 = 0LL;
            v150 = v100;
            do
            {
              v151 = v109 + v149;
              unint64_t v152 = v149 + 1;
              if (v149 >= 8) {
                v153 = v80;
              }
              else {
                v153 = v106;
              }
              unint64_t v154 = v153 >> (v148 & 0x38);
              v155 = (8 * v109 + v148) & 0x38;
              v156 = (-255LL << v155) - 1;
              uint64_t v157 = (unint64_t)v154 << v155;
              v158 = v157 | v156 & v150;
              v159 = v157 | v156 & v101;
              if (v151 < 8) {
                char v101 = v159;
              }
              else {
                v150 = v158;
              }
              v148 += 8;
              v149 = v152;
            }

            while (v108 != v152);
          }

          else
          {
            v150 = v100;
          }

          swift_bridgeObjectRelease(v100);
          v170 = 0xE000000000000000LL;
          if (v101 & 0x8080808080808080LL | v150 & 0x80808080808080LL) {
            v170 = 0xA000000000000000LL;
          }
          v253 = v101;
          v254 = v170 & 0xFF00000000000000LL | ((v108 + v109) << 56) | v150 & 0xFFFFFFFFFFFFFFLL;
          x1_0 = v247;
          a1 = v248;
          goto LABEL_178;
        }

        uint64_t v107 = 1LL;
      }

      if (v107) {
        uint64_t v110 = HIBYTE(v103) & 0xF;
      }
      else {
        uint64_t v110 = v106 & 0xFFFFFFFFFFFFLL;
      }
      swift_bridgeObjectRetain(v103, v103, v104, v105);
      v249 = v110;
      if ((v80 & 0x1000000000000000LL) != 0)
      {
        swift_bridgeObjectRetain_n(v80, 5LL, v111, v112);
        v171._Swift::UInt64 rawBits = 1LL;
        v172._Swift::UInt64 rawBits = (v110 << 16) | 1;
        v173._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v171, v172, v106, v80);
        if (v173._rawBits < 0x10000) {
          v173._rawBits |= 3;
        }
        uint64_t v110 = specialized Collection.count.getter(v173, v174, v106, v80);
        swift_bridgeObjectRelease(v80);
        if ((v100 & 0x1000000000000000LL) != 0)
        {
LABEL_185:
          uint64_t v113 = String.UTF8View._foreignCount()();
          uint64_t v114 = v113 + v110;
          if (__OFADD__(v113, v110)) {
            goto LABEL_256;
          }
          goto LABEL_126;
        }
      }

      else
      {
        swift_bridgeObjectRetain_n(v80, 4LL, v111, v112);
        if ((v100 & 0x1000000000000000LL) != 0) {
          goto LABEL_185;
        }
      }

      if ((v100 & 0x2000000000000000LL) != 0) {
        uint64_t v113 = HIBYTE(v100) & 0xF;
      }
      else {
        uint64_t v113 = v101 & 0xFFFFFFFFFFFFLL;
      }
      uint64_t v114 = v113 + v110;
      if (__OFADD__(v113, v110))
      {
LABEL_256:
        __break(1u);
        goto LABEL_257;
      }

    specialized Set._Variant.insert(_:)((uint64_t *)&v132, v57);
    v56(v54, v40);
    BOOL v67 = v126;
    int v39 = v131;
    v125(v126, v131, v41);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v40,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL);
    unint64_t v69 = &v67[*((int *)TupleTypeMetadata3 + 12)];
    unint64_t v70 = &v67[*((int *)TupleTypeMetadata3 + 16)];
    uint64_t v71 = *(void *)v70;
    LODWORD(v67) = v70[8];
    v56((unsigned __int8 *)v69, v40);
    if ((_DWORD)v67 == 1)
    {
      Swift::Bool v33 = v130;
      (*(void (**)(char *, uint64_t))(v130 + 8))(v39, v41);
      unint64_t AssociatedTypeWitness = v115;
      uint64_t v42 = v113;
      goto LABEL_8;
    }

    if (v71 < 0)
    {
      (*(void (**)(char *, uint64_t))(v130 + 8))(v39, v41);
      goto LABEL_60;
    }

    uint64_t v72 = v121;
    v124(v121, v39, v41);
    unsigned int v73 = swift_getEnumCaseMultiPayload(v72, v41);
    unint64_t v74 = &v72[*((int *)swift_getTupleTypeMetadata3( 0LL,  (uint64_t)&type metadata for Int,  v40,  (uint64_t)&unk_189B88E40,  "offset element associatedWith ",  0LL)
               + 12)];
    if (v73 != 1) {
      break;
    }
    uint64_t v75 = v123;
    if (v123[2])
    {
      specialized __RawDictionaryStorage.find<A>(_:)(v57);
      if ((v76 & 1) != 0)
      {
        (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
        swift_bridgeObjectRelease((uint64_t)v133);
        swift_bridgeObjectRelease((uint64_t)v134);
        v56(v74, v40);
        swift_bridgeObjectRelease((uint64_t)v128);
        uint64_t v110 = v75;
        goto LABEL_56;
      }
    }

    uint64_t v77 = v71;
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v75);
    uint64_t v132 = v75;
    uint64_t v80 = specialized __RawDictionaryStorage.find<A>(_:)(v57);
    unint64_t v81 = v75[2];
    uint64_t v82 = (v79 & 1) == 0;
    uint64_t v83 = (uint64_t)v81 + v82;
    if (__OFADD__(v81, v82))
    {
      __break(1u);
LABEL_64:
      __break(1u);
LABEL_65:
      __break(1u);
LABEL_66:
      __break(1u);
LABEL_67:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for Int);
    }

    Swift::Int v84 = v79;
    if ((uint64_t)v75[3] >= v83)
    {
      if ((isUniquelyReferenced_nonNull_native & 1) != 0)
      {
        int v39 = v131;
        uint64_t v87 = v132;
        if ((v79 & 1) == 0) {
          goto LABEL_50;
        }
      }

      else
      {
        specialized _NativeDictionary.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
        int v39 = v131;
        uint64_t v87 = v132;
        if ((v84 & 1) == 0) {
          goto LABEL_50;
        }
      }
    }

    else
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)( v83,  isUniquelyReferenced_nonNull_native);
      Swift::String v85 = specialized __RawDictionaryStorage.find<A>(_:)(v57);
      if ((v84 & 1) != (v86 & 1)) {
        goto LABEL_67;
      }
      uint64_t v80 = v85;
      int v39 = v131;
      uint64_t v87 = v132;
      if ((v84 & 1) == 0)
      {
LABEL_50:
        v87[(v80 >> 6) + 8] = (__objc2_class *)((unint64_t)v87[(v80 >> 6) + 8] | (1LL << v80));
        uint64_t v107 = 8 * v80;
        *(__objc2_class **)((char *)&v87[6]->isa + v107) = (__objc2_class *)v57;
        *(__objc2_class **)((char *)&v87[7]->isa + v107) = (__objc2_class *)v77;
        uint64_t v108 = v87[2];
        uint64_t v105 = __OFADD__(v108, 1LL);
        uint64_t v109 = (__objc2_class *)((char *)&v108->isa + 1);
        if (v105) {
          goto LABEL_66;
        }
        char v101 = v87;
        v87[2] = v109;
        goto LABEL_52;
      }
    }

    char v101 = v87;
    *((void *)&v87[7]->isa + v80) = v77;
LABEL_52:
    Swift::Bool v33 = v130;
    unint64_t AssociatedTypeWitness = v115;
    uint64_t v42 = v113;
    uint64_t v123 = v101;
LABEL_53:
    swift_bridgeObjectRelease(0x8000000000000000LL);
    v56(v74, v40);
    uint64_t v41 = v114;
LABEL_8:
    uint64_t v32 = v116;
    ((void (*)(unint64_t, unint64_t))v118)(AssociatedTypeWitness, v119);
    if (v117(v42, 1LL, v41) == 1) {
      goto LABEL_5;
    }
    v124((unsigned __int8 *)v39, v42, v41);
  }

  uint64_t v88 = v128;
  int64_t v89 = v123;
  if (!v128[2] || (specialized __RawDictionaryStorage.find<A>(_:)(v71), uint64_t v88 = v128, (v90 & 1) == 0))
  {
    char v91 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v88);
    uint64_t v132 = v88;
    uint64_t v92 = v71;
    uint64_t v94 = specialized __RawDictionaryStorage.find<A>(_:)(v71);
    uint64_t v95 = v128[2];
    unint64_t v96 = (v93 & 1) == 0;
    unint64_t v97 = (uint64_t)v95 + v96;
    if (__OFADD__(v95, v96)) {
      goto LABEL_64;
    }
    uint64_t v98 = v93;
    if ((uint64_t)v128[3] >= v97)
    {
      if ((v91 & 1) == 0) {
        specialized _NativeDictionary.copy()((uint64_t (*)(void))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
      }
    }

    else
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v97, v91);
      unint64_t v99 = specialized __RawDictionaryStorage.find<A>(_:)(v92);
      if ((v98 & 1) != (v100 & 1)) {
        goto LABEL_67;
      }
      uint64_t v94 = v99;
    }

    int v39 = v131;
    uint64_t v102 = v132;
    unint64_t v128 = v132;
    if ((v98 & 1) != 0)
    {
      *((void *)&v132[7]->isa + v94) = v57;
    }

    else
    {
      v132[(v94 >> 6) + 8] = (__objc2_class *)((unint64_t)v132[(v94 >> 6) + 8] | (1LL << v94));
      uint64_t v103 = 8 * v94;
      *(__objc2_class **)((char *)&v102[6]->isa + v103) = (__objc2_class *)v92;
      *(__objc2_class **)((char *)&v102[7]->isa + v103) = (__objc2_class *)v57;
      uint64_t v104 = v102[2];
      uint64_t v105 = __OFADD__(v104, 1LL);
      uint64_t v106 = (__objc2_class *)((char *)&v104->isa + 1);
      if (v105) {
        goto LABEL_65;
      }
      v102[2] = v106;
    }

    Swift::Bool v33 = v130;
    unint64_t AssociatedTypeWitness = v115;
    uint64_t v42 = v113;
    goto LABEL_53;
  }

  (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
  swift_bridgeObjectRelease((uint64_t)v133);
  swift_bridgeObjectRelease((uint64_t)v134);
  v56(v74, v40);
  swift_bridgeObjectRelease((uint64_t)v88);
  uint64_t v110 = v89;
LABEL_56:
  swift_bridgeObjectRelease((uint64_t)v110);
  uint64_t v30 = 0;
  return v30 & 1;
}

      __break(1u);
      goto LABEL_24;
    }

  uint64_t v8 = 0LL;
  uint64_t v9 = (_BYTE *)(a1 + v2);
  uint64_t v10 = 1;
  uint64_t v11 = (_BYTE *)a1;
  uint64_t v12 = (_BYTE *)a1;
  do
  {
    uint64_t v14 = (char)*v12++;
    uint64_t v13 = v14;
    if ((v14 & 0x80000000) == 0)
    {
      unint64_t v15 = 1LL;
      goto LABEL_26;
    }

    if (v13 <= 0xDFu)
    {
      if (v12 == v9 || (*v12 & 0xC0) != 0x80) {
        goto LABEL_69;
      }
      uint64_t v10 = 0;
      uint64_t v12 = v11 + 2;
      unint64_t v15 = 2LL;
    }

    else
    {
      if (v13 == 224)
      {
        if (v12 == v9
          || ((unsigned int v16 = v11 + 2, (v11[1] + 64) >= 0xE0u) ? (v17 = v16 == v9) : (v17 = 1), v17))
        {
LABEL_69:
          unsigned int v20 = swift_allocError( (uint64_t)&unk_189B86A70,  (uint64_t)&protocol witness table for UTF8ValidationError,  0LL,  0);
          swift_willThrow();
          swift_errorRelease(v20);
          uint64_t v21 = specialized Collection.subscript.getter(v8, a1, v3);
          uint64_t v25 = v21;
          uint64_t v26 = v22;
          Swift::String::Index v27 = v23;
          size_t v28 = v24;
          uint64_t v29 = v21;
          if (v21 != v22
            && (specialized Slice.subscript.getter(v21, v21, v22, v23, v24), uint64_t v29 = v25 + 1, __OFADD__(v25, 1LL)))
          {
            v173 = 1525LL;
          }

          else
          {
            uint64_t v30 = 0LL;
            Swift::String::Index v31 = v26 + v25 - v29;
            if (v26 <= v29) {
              uint64_t v32 = v29;
            }
            else {
              uint64_t v32 = v26;
            }
            if (v28 <= v29) {
              Swift::Bool v33 = v29;
            }
            else {
              Swift::Bool v33 = v28;
            }
            uint64_t v34 = v33 - v29;
            uint64_t v35 = v32 - v29;
            do
            {
              if (v26 - v29 == v30) {
                goto LABEL_88;
              }
              if (v29 < v25)
              {
                v173 = 1812LL;
                goto LABEL_137;
              }

              if (v35 == v30)
              {
                v173 = 1813LL;
                goto LABEL_137;
              }

              if (v29 < 0)
              {
                v173 = 1781LL;
                goto LABEL_137;
              }

              if (v34 == v30)
              {
                v173 = 1782LL;
                goto LABEL_137;
              }

              if ((*(_BYTE *)(v27 + v29 + v30) & 0xC0) != 0x80) {
                goto LABEL_87;
              }
              uint64_t v36 = v25 + v30++;
            }

            while (!__OFADD__(v36, 1LL));
            __break(1u);
LABEL_87:
            Swift::String::Index v31 = v25 + v30;
LABEL_88:
            if (v31 < v25) {
              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
            }
            int64_t v37 = v31 + 1;
            if (__OFADD__(v31, 1LL))
            {
              __break(1u);
            }

            else if (v26 >= v37)
            {
              _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v25, v37, v27, v28);
              return 0LL;
            }

            v173 = 1820LL;
          }

    if (v7 <= 7)
    {
LABEL_24:
      unsigned int v16 = &a1[v5];
      switch((char)v8)
      {
        case 1:
          *unsigned int v16 = v15;
          break;
        case 2:
          *(_WORD *)unsigned int v16 = v15;
          break;
        case 3:
          *(_WORD *)unsigned int v16 = v15;
          __int128 v16[2] = BYTE2(v15);
          break;
        case 4:
          *(_DWORD *)unsigned int v16 = v15;
          break;
        default:
          *(_DWORD *)unsigned int v16 = v15;
          unsigned int v17 = v16 + 4;
          BOOL v18 = v8 - 4LL;
          goto LABEL_44;
      }
    }
  }

    v27[0] = off_189B8E500;
    uint64_t v14 = v66;
    if (v66 == v65)
    {
      unint64_t v15 = 4LL;
      uint64_t v14 = v65;
    }

    else
    {
      if (!v66) {
        goto LABEL_28;
      }
      unint64_t v15 = 5LL;
    }

    (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_28:
    v27[0] = off_189B8E4D8;
    uint64_t result = (std::string *)swift::Demangle::__runtime::NodeFactory::freeSlabs(v28);
    if (v30) {
      *(_BYTE *)(v30 + 48) = 0;
    }
    return result;
  }

  isa = (Class)cls;
LABEL_11:
  Name = class_getName(isa);
  return std::string::append(a1, Name);
}

  uint64_t v55 = v24;
  uint64_t v52 = v24 + v9;
  uint64_t v25 = *(v19 - 1);
  uint64_t v53 = v23;
  if ((a2 & 0x100) == 0)
  {
    Metadata = swift::allocateMetadata(0x70uLL, (const char *)8, a3, a4);
    size_t v28 = *(_OWORD *)(v25 + 16);
    Swift::String::Index v27 = *(_OWORD *)(v25 + 32);
    *(_OWORD *)Metadata = *(_OWORD *)v25;
    *((_OWORD *)Metadata + 1) = v28;
    *((_OWORD *)Metadata + 2) = v27;
    uint64_t v29 = *(_OWORD *)(v25 + 96);
    Swift::String::Index v31 = *(_OWORD *)(v25 + 48);
    uint64_t v30 = *(_OWORD *)(v25 + 64);
    *((_OWORD *)Metadata + 5) = *(_OWORD *)(v25 + 80);
    *((_OWORD *)Metadata + 6) = v29;
    *((_OWORD *)Metadata + 3) = v31;
    *((_OWORD *)Metadata + 4) = v30;
    *(v19 - 1) = Metadata;
    uint64_t v25 = (uint64_t)Metadata;
  }

  uint64_t v32 = v5;
  Swift::Bool v33 = 8LL * v5 + 56;
  LOWORD(v57) = 26;
  uint64_t v34 = swift::MetadataAllocator::Allocate( (swift::MetadataAllocator *)&v57,  (v33 + v8 + 15) & 0xFFFFFFFFFFFFFFF8LL,  (const char *)1,  a4);
  uint64_t v35 = v34;
  *((void *)v34 + 1) = v33 + v8 - 16;
  *((void *)v34 + 2) = 0x1600000000000000LL;
  uint64_t v36 = v55;
  *((void *)v34 + 3) = v55;
  *((void *)v34 + 4) = v5;
  int64_t v37 = v52;
  *((void *)v34 + 5) = v8;
  *((void *)v34 + 6) = v52;
  uint64_t v61 = 0LL;
  *(void *)&uint64_t v57 = v34;
  *((void *)&v57 + 1) = v33;
  if (v5)
  {
    uint64_t v38 = 0LL;
    int v39 = (uint64_t *)((char *)v34 + 56);
    do
    {
      unint64_t v40 = v33;
      uint64_t v41 = *v4++;
      *v39++ = v38;
      uint64_t v59 = 0LL;
      uint64_t v60 = 0LL;
      _swift_addRefCountStringForMetatype((uint64_t *)&v57, &v61, v41, &v59, &v60);
      *(void *)(v57 + *((void *)&v57 + 1)) = 0LL;
      Swift::Bool v33 = *((void *)&v57 + 1) + 8LL;
      *((void *)&v57 + 1) = v33;
      uint64_t v38 = v38 - v40 + v33;
      --v32;
    }

    while (v32);
    uint64_t v42 = (swift::MetadataAllocator *)v57;
    uint64_t v36 = v55;
    int64_t v37 = v52;
  }

  else
  {
    uint64_t v42 = v34;
  }

  *(void *)((char *)v42 + v33) = 0LL;
  *((void *)&v57 + 1) = 0LL;
  *(void *)uint64_t v57 = v61 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v43 = *a1;
  if (*a1 > 0x7FFuLL) {
    LODWORD(v43) = 0;
  }
  if (!(_DWORD)v43 || (_DWORD)v43 == 773 || (_DWORD)v43 == 515) {
    uint64_t v44 = (swift::MetadataAllocator **)(a1 - 3);
  }
  else {
    uint64_t v44 = (swift::MetadataAllocator **)(a1 - 2);
  }
  uint64_t v45 = (1 << (8 * v36)) - v53;
  if (v45 >= 0x7FFFFFFF) {
    uint64_t v45 = 0x7FFFFFFF;
  }
  if (v36 == 4) {
    uint64_t v45 = 0x7FFFFFFF;
  }
  *uint64_t v44 = v35;
  *(void *)(v25 + 8) = swift_generic_destroy;
  *(void *)(v25 + 16) = swift_generic_initWithCopy;
  *(void *)(v25 + 24) = swift_generic_assignWithCopy;
  *(void *)(v25 + 32) = swift_generic_initWithTake;
  *(void *)(v25 + 40) = swift_generic_assignWithTake;
  uint64_t v46 = (v37 + v7) & ~v7;
  if (v46 <= 1) {
    uint64_t v46 = 1LL;
  }
  uint64_t v48 = v7 < 8 && v37 < 0x19;
  if ((v12 & v48) != 0) {
    uint64_t v49 = 0;
  }
  else {
    uint64_t v49 = 0x20000;
  }
  if (v12) {
    uint64_t v50 = 0x200000;
  }
  else {
    uint64_t v50 = 3145728;
  }
  *(void *)&uint64_t v57 = v37;
  *((void *)&v57 + 1) = v46;
  LODWORD(v58) = v50 | v54 | v7 & 0xFFCCFFFF | v49;
  HIDWORD(v58) = v45;
  swift::installCommonValueWitnesses((uint64_t)&v57, v25);
  *(void *)(v25 + 48) = swift_getMultiPayloadEnumTagSinglePayload;
  *(void *)(v25 + 56) = swift_storeMultiPayloadEnumTagSinglePayload;
  *(_OWORD *)(v25 + 64) = v57;
  uint64_t result = v58;
  *(double *)(v25 + 80) = v58;
  return result;
}

    *(_DWORD *)(a5 + 24) = 0;
    return;
  }

  if (v8 < 0xFFFFFFFE) {
    goto LABEL_34;
  }
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 825, "initializeEnumMetadata", "Initializing enum");
  swift::BuilderError::BuilderError((swift::BuilderError *)&v28, "Don't know how to initialize enum metadata yet");
  if ((char)v28.__r_.__value_.__s.__size_ < 0)
  {
    std::string::__init_copy_ctor_external(&__p, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
    Swift::String::Index v27 = 1;
    if ((char)v28.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(v28.__r_.__value_.__l.__data_);
      BOOL v18 = v27;
      if (!v27) {
        goto LABEL_23;
      }
    }

    else
    {
      BOOL v18 = 1;
    }
  }

  else
  {
    __p = v28;
    Swift::String::Index v27 = 1;
    BOOL v18 = 1;
  }

  if (v18 == 1) {
    p_p = &__p;
  }
  else {
    p_p = 0LL;
  }
  uint64_t v24 = (uint64_t)&__p.__r_.__value_.__r.__words[2] + 7;
  if (v18 != 1) {
    uint64_t v24 = 23LL;
  }
  if (*(char *)v24 < 0)
  {
    uint64_t v21 = (const std::string::value_type *)p_p->__r_.__value_.__r.__words[0];
    goto LABEL_53;
  }

  uint64_t v44 = 1;
  uint64_t v45 = a3;
  uint64_t v46 = a4;
  uint64_t v47 = v49;
  uint64_t v48 = 0x800000000LL;
  _BYTE v49[32] = 0LL;
  v34[0] = off_189B8DEF0;
  v34[1] = &v44;
  v34[3] = v34;
  v33[0] = off_189B8DF38;
  v33[1] = &v44;
  v33[3] = v33;
  uint64_t v35 = v50;
  v36[0] = off_189B8DEF0;
  int64_t v37 = v36;
  v38[0] = off_189B8DF38;
  v36[1] = &v44;
  int v39 = v38;
  v38[1] = &v44;
  unint64_t v40 = 0;
  uint64_t v42 = 0LL;
  uint64_t v43 = 0LL;
  __p = 0LL;
  uint64_t v32 = (uint64_t *)&v35;
  if (!(_DWORD)a6) {
    goto LABEL_55;
  }
  BOOL v18 = 0LL;
  while (1)
  {
    unint64_t v19 = *(unsigned __int8 *)(v16 + 18);
    unsigned int v20 = v19 - 1;
    if ((_DWORD)v19 == 1) {
      goto LABEL_29;
    }
    if ((_DWORD)v19 != 5)
    {
      if ((_DWORD)v19 != 2) {
        goto LABEL_34;
      }
      unint64_t v19 = 2LL;
LABEL_29:
      if (v19 <= v18) {
        goto LABEL_34;
      }
      goto LABEL_30;
    }

    if (*(unsigned int *)(v16 + 8) <= v18)
    {
LABEL_34:
      uint64_t v22 = 0LL;
      goto LABEL_35;
    }

  if (v20) {
    unsigned int v16 = 0LL;
  }
  else {
    unsigned int v16 = v19[0];
  }
  unsigned int v17 = v16;
  __swift::__runtime::llvm::SmallVectorImpl<swift::Demangle::__runtime::ImplFunctionParam<swift::MetadataOrPack>>::emplace_back<swift::MetadataOrPack,swift::Demangle::__runtime::ImplParameterConvention &,swift::optionset::OptionSet<swift::Demangle::__runtime::ImplParameterInfoFlags,unsigned char> &>( a4,  &v17,  (unsigned int *)&ConventionFromString,  &v18);
  uint64_t v9 = 0LL;
LABEL_28:
  if (v20 == 1) {
    goto LABEL_29;
  }
  return v9;
}

  if (v20) {
    unsigned int v16 = 0LL;
  }
  else {
    unsigned int v16 = v19[0];
  }
  unsigned int v17 = v16;
  __swift::__runtime::llvm::SmallVectorImpl<swift::Demangle::__runtime::ImplFunctionParam<swift::MetadataOrPack>>::emplace_back<swift::MetadataOrPack,swift::Demangle::__runtime::ImplParameterConvention &,swift::optionset::OptionSet<swift::Demangle::__runtime::ImplParameterInfoFlags,unsigned char> &>( a4,  &v17,  (unsigned int *)&ConventionFromString,  &v18);
  uint64_t v9 = 0LL;
LABEL_28:
  if (v20 == 1) {
    goto LABEL_29;
  }
  return v9;
}

          char *v23 = v24;
          v23[1] = *((void *)v17 + 1);
          *(_DWORD *)(a1 + 8) = ++v15;
        }

        unsigned int v17 = (__swift::__runtime::llvm *)((char *)v17 + 16);
      }

      while (v17 != (__swift::__runtime::llvm *)((char *)v4 + 16 * v3));
    }

    __swift::__runtime::llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }

  *(void *)(a1 + 8) = 0LL;
  BOOL v18 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v18)
  {
    if (((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_18;
    }
    unint64_t v19 = ((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    uint64_t v10 = &result[2 * (v19 & 0x1FFFFFFFFFFFFFFELL)];
    unsigned int v20 = result + 2;
    uint64_t v21 = v19 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v20 - 2) = -4096LL;
      id *v20 = -4096LL;
      v20 += 4;
      v21 -= 2LL;
    }

    while (v21);
    if (v19 != (v19 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_18:
      uint64_t v22 = &result[2 * v18];
      do
      {
        char *v10 = -4096LL;
        v10 += 2;
      }

      while (v10 != v22);
    }
  }

  return result;
}

  std::string::push_back(a1, 34);
  return a1;
}

        uint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
      }

      uint64_t v3 = (char *)(*(void *)a2 + 8LL * *((unsigned int *)a2 + 2));
      if (v9 == (swift::Demangle::__runtime::Node *)v3) {
        return 1LL;
      }
LABEL_25:
      uint64_t v12 = (char *)v9 + 8;
      do
      {
        uint64_t v13 = *(swift::Demangle::__runtime::Node **)v4;
        uint64_t v4 = (swift::Demangle::__runtime::Node *)((char *)v4 + 8);
        uint64_t result = swift::Demangle::__runtime::SubstitutionEntry::deepEquals( this,  *((swift::Demangle::__runtime::Node **)v12 - 1),  v13);
        if ((_DWORD)result) {
          uint64_t v14 = v12 == v3;
        }
        else {
          uint64_t v14 = 1;
        }
        v12 += 8;
      }

      while (!v14);
      break;
  }

  return result;
}

  uint64_t v14 = 0LL;
  if (v10 == 1) {
    goto LABEL_20;
  }
LABEL_24:
  if (v10 == 2)
  {
    unint64_t v15 = (swift::Demangle::__runtime::Node **)((char *)a2 + 16);
  }

  else
  {
    if (v10 == 5)
    {
      unsigned int v16 = *(void *)a2;
      goto LABEL_27;
    }

    unint64_t v15 = 0LL;
  }

    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return result;
  }

  if (v9 != 5)
  {
    uint64_t v12 = 0LL;
    if (!v10) {
      goto LABEL_20;
    }
    goto LABEL_17;
  }

  uint64_t v11 = *(void *)a2;
LABEL_10:
  uint64_t v12 = (swift::Demangle::__runtime::Node **)(v11 + 8LL * *((unsigned int *)a2 + 2));
  if (v10 == v12) {
    goto LABEL_20;
  }
LABEL_17:
  uint64_t v13 = a3 + 1;
  while (1)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (++v10 == v12) {
      goto LABEL_20;
    }
  }

  unint64_t v19 = 1882;
  unsigned int v20 = 15;
LABEL_43:
  *(_DWORD *)a3 = v20;
  *(void *)(a3 + 8) = a2;
  *(_DWORD *)(a3 + 16) = v19;
  return this;
}

    *(_DWORD *)a6 = 0;
    *(void *)(a6 + 8) = 0LL;
    *(_DWORD *)(a6 + 16) = 0;
    return result;
  }

  if (v13 != 5)
  {
    unsigned int v16 = 0LL;
    if (!v14) {
      goto LABEL_20;
    }
    goto LABEL_17;
  }

  unint64_t v15 = *a2;
LABEL_10:
  unsigned int v16 = (swift::Demangle::__runtime::Node **)((char *)v15 + 8 * *((unsigned int *)a2 + 2));
  if (v14 == v16) {
    goto LABEL_20;
  }
LABEL_17:
  unsigned int v17 = a5 + 1;
  while (1)
  {
    if (*(_DWORD *)a6) {
      return result;
    }
    if (++v14 == v16) {
      goto LABEL_20;
    }
  }

      ++v7;
LABEL_24:
      if (v7 == v10) {
        goto LABEL_56;
      }
      uint64_t v12 = *(_DWORD *)(v4 + 12736);
      uint64_t v13 = *(unsigned int *)(v4 + 12740);
      uint64_t v14 = *(_BYTE **)(v4 + 12728);
      if (v12 < v13)
      {
LABEL_95:
        *(_DWORD *)(v4 + 12736) = v12 + 1;
        v14[v12] = 82;
        do
        {
          if (*(_DWORD *)a4) {
            return this;
          }
          ++v7;
        }

        while (v7 != v10);
        *(_DWORD *)a4 = 0;
        *(void *)(a4 + 8) = 0LL;
        *(_DWORD *)(a4 + 16) = 0;
        uint64_t v45 = (_DWORD *)(a4 + 16);
        uint64_t v54 = *(_DWORD *)(v4 + 12736);
        uint64_t v55 = *(unsigned int *)(v4 + 12740);
        uint64_t v56 = *(_BYTE **)(v4 + 12728);
        if (v54 < v55)
        {
LABEL_119:
          *(_DWORD *)(v4 + 12736) = v54 + 1;
          v56[v54] = 114;
          *(_DWORD *)a4 = 0;
          *(void *)(a4 + 8) = 0LL;
          goto LABEL_76;
        }

        uint64_t v57 = *(void **)(v4 + 12744);
        uint64_t v58 = (_BYTE *)v57[1];
        if (&v56[v55] == v58)
        {
          uint64_t v60 = (unint64_t)&v56[v55 + 1];
          uint64_t v59 = v57[2];
          if (v60 <= v59)
          {
            v57[1] = v60;
            LODWORD(v61) = 1;
LABEL_118:
            *(_DWORD *)(v4 + 12740) = v55 + v61;
            goto LABEL_119;
          }
        }

        else
        {
          uint64_t v59 = v57[2];
        }

        else {
          uint64_t v61 = (2 * v55);
        }
        uint64_t v62 = v61 + v55;
        if (v58) {
          Swift::Int v63 = (unint64_t)&v58[v61 + v55] > v59;
        }
        else {
          Swift::Int v63 = 1;
        }
        uint64_t v56 = (_BYTE *)v57[1];
        if (v63)
        {
          uint64_t v64 = 2LL * v57[4];
          if (v64 <= v62 + 1) {
            uint64_t v64 = v62 + 1;
          }
          v57[4] = v64;
          char v65 = v64 + 8;
          this = malloc(v64 + 8);
          uint64_t v66 = (char *)this + v65;
          *this = v57[3];
          uint64_t v56 = this + 1;
          v57[2] = v66;
          v57[3] = this;
        }

        v57[1] = &v56[v62];
        if ((_DWORD)v55)
        {
          this = memcpy(v56, *(const void **)(v4 + 12728), v55);
          LODWORD(v55) = *(_DWORD *)(v4 + 12740);
          uint64_t v54 = *(_DWORD *)(v4 + 12736);
        }

        *(void *)(v4 + 12728) = v56;
        goto LABEL_118;
      }

      unint64_t v15 = *(void **)(v4 + 12744);
      unsigned int v16 = (_BYTE *)v15[1];
      if (&v14[v13] == v16)
      {
        uint64_t v46 = (unint64_t)&v14[v13 + 1];
        unsigned int v17 = v15[2];
        if (v46 <= v17)
        {
          v15[1] = v46;
          LODWORD(v47) = 1;
LABEL_94:
          *(_DWORD *)(v4 + 12740) = v13 + v47;
          goto LABEL_95;
        }
      }

      else
      {
        unsigned int v17 = v15[2];
      }

      else {
        uint64_t v47 = (2 * v13);
      }
      uint64_t v48 = v47 + v13;
      if (v16) {
        uint64_t v49 = (unint64_t)&v16[v47 + v13] > v17;
      }
      else {
        uint64_t v49 = 1;
      }
      uint64_t v14 = (_BYTE *)v15[1];
      if (v49)
      {
        uint64_t v50 = 2LL * v15[4];
        if (v50 <= v48 + 1) {
          uint64_t v50 = v48 + 1;
        }
        void v15[4] = v50;
        uint64_t v51 = v50 + 8;
        uint64_t v52 = malloc(v50 + 8);
        uint64_t v53 = (char *)v52 + v51;
        *uint64_t v52 = v15[3];
        uint64_t v14 = v52 + 1;
        __int128 v15[2] = v53;
        v15[3] = v52;
      }

      v15[1] = &v14[v48];
      if ((_DWORD)v13)
      {
        memcpy(v14, *(const void **)(v4 + 12728), v13);
        LODWORD(v13) = *(_DWORD *)(v4 + 12740);
        uint64_t v12 = *(_DWORD *)(v4 + 12736);
      }

      *(void *)(v4 + 12728) = v14;
      goto LABEL_94;
    }
  }

  unsigned int v17 = *(_DWORD *)(v6 + 12736);
  BOOL v18 = *(unsigned int *)(v6 + 12740);
  unint64_t v19 = *(char **)(v6 + 12728);
  if (v17 >= v18)
  {
    unsigned int v20 = *(void **)(v6 + 12744);
    uint64_t v21 = (char *)v20[1];
    if (&v19[v18] != v21)
    {
      uint64_t v22 = v20[2];
      goto LABEL_28;
    }

    uint64_t v23 = (unint64_t)&v19[v18 + 1];
    uint64_t v22 = v20[2];
    if (v23 <= v22)
    {
      v20[1] = v23;
      LODWORD(v24) = 1;
    }

    else
    {
LABEL_28:
      else {
        uint64_t v24 = (2 * v18);
      }
      uint64_t v25 = v24 + v18;
      if (!v21 || (unint64_t)&v21[v25] > v22)
      {
        uint64_t v26 = 2LL * v20[4];
        if (v26 <= v25 + 1) {
          uint64_t v26 = v25 + 1;
        }
        v20[4] = v26;
        Swift::String::Index v27 = v26 + 8;
        this = malloc(v26 + 8);
        size_t v28 = (char *)this + v27;
        *this = v20[3];
        uint64_t v21 = (char *)(this + 1);
        void v20[2] = v28;
        v20[3] = this;
      }

      v20[1] = &v21[v25];
      if ((_DWORD)v18)
      {
        this = memcpy(v21, *(const void **)(v6 + 12728), v18);
        LODWORD(v18) = *(_DWORD *)(v6 + 12740);
        unsigned int v17 = *(_DWORD *)(v6 + 12736);
      }

      *(void *)(v6 + 12728) = v21;
      unint64_t v19 = v21;
    }

    *(_DWORD *)(v6 + 12740) = v18 + v24;
  }

  unsigned int v16 = 0;
  uint64_t v4 = 0LL;
  unint64_t v15 = 0;
  *(_DWORD *)(v6 + 12736) = v17 + 1;
  v19[v17] = 95;
LABEL_42:
  *(_DWORD *)a4 = v16;
  *(void *)(a4 + 8) = v4;
  *(_DWORD *)(a4 + 16) = v15;
  return this;
}

  *((_DWORD *)this + 3184) = v8 + 1;
  v10[v8] = 83;
  return 1LL;
}

  *((_DWORD *)v14 + 3184) = v15 + 1;
  v17[v15] = a3;
  uint64_t v32 = v8;
  Swift::Bool v33 = (a7 + 1);
  if (*(_DWORD *)a8) {
    return result;
  }
  uint64_t result = (char *)swift::Demangle::__runtime::CharVector::append(v41, v12, v11, *((void **)v14 + 1593));
  uint64_t v34 = *((unsigned __int8 *)v8 + 18);
  uint64_t v35 = v8;
  if (v34 != 2)
  {
    if (v34 == 5 && *((_DWORD *)v8 + 2) >= 2u)
    {
      uint64_t v35 = (uint64_t *)*v8;
      goto LABEL_30;
    }

    uint64_t v21 = 119;
LABEL_7:
    uint64_t v22 = 1;
LABEL_8:
    *(_DWORD *)a8 = v22;
    *(void *)(a8 + 8) = v8;
    *(_DWORD *)(a8 + 16) = v21;
    return result;
  }

uint64_t RangeReplaceableCollection.insert<A>(contentsOf:at:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v53 = a6;
  uint64_t v50 = a1;
  uint64_t v51 = a4;
  uint64_t v54 = a5;
  uint64_t v55 = a2;
  uint64_t v7 = *(const char **)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v11 = (char *)&v43 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v46 = (char *)&v43 - v13;
  uint64_t v14 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  unsigned int v17 = (char *)&v43 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  unint64_t v19 = (char *)&v43 - v18;
  uint64_t v52 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v22 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v21);
  uint64_t v23 = *(void *)(v22 - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v43 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v24);
  uint64_t v47 = v14;
  uint64_t v48 = (char *)&v43 - v27;
  size_t v28 = *(void (**)(char *, uint64_t, unint64_t))(v14 + 16);
  uint64_t v29 = v55;
  v28(v19, v55, AssociatedTypeWitness);
  v28(v17, v29, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))( v19,  v17,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v30 = v47;
  Swift::String::Index v31 = *(void (**)(char *, unint64_t))(v47 + 8);
  v31(v17, AssociatedTypeWitness);
  v31(v19, AssociatedTypeWitness);
  uint64_t v44 = v22;
  uint64_t v45 = v23;
  uint64_t v32 = TupleTypeMetadata2;
  Swift::Bool v33 = v46;
  uint64_t v34 = &v46[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v35 = v55;
  v28(v46, v55, AssociatedTypeWitness);
  v28(v34, v35, AssociatedTypeWitness);
  uint64_t v36 = &v11[*((int *)v32 + 12)];
  v28(v11, (uint64_t)v33, AssociatedTypeWitness);
  v28(v36, (uint64_t)v34, AssociatedTypeWitness);
  int64_t v37 = *(void (**)(char *, char *, unint64_t))(v30 + 32);
  v37(v26, v11, AssociatedTypeWitness);
  v31(v36, AssociatedTypeWitness);
  uint64_t v38 = &v11[*((int *)v32 + 12)];
  v37(v11, v33, AssociatedTypeWitness);
  v37(v38, v34, AssociatedTypeWitness);
  uint64_t v39 = v44;
  v37(&v26[*(int *)(v44 + 36)], v38, AssociatedTypeWitness);
  v31(v11, AssociatedTypeWitness);
  uint64_t v40 = v45;
  uint64_t v41 = v48;
  (*(void (**)(char *, char *, uint64_t))(v45 + 32))(v48, v26, v39);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v54 + 32))(v41, v50, v51, v53, v52);
  return (*(uint64_t (**)(char *, uint64_t))(v40 + 8))(v41, v39);
}

BOOL protocol witness for RangeReplaceableCollection.remove(at:) in conformance [A]@<W0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return Array.remove(at:)(*a1, a2, a3);
}

unint64_t specialized RangeReplaceableCollection.removeSubrange(_:)(unint64_t result)
{
  unsigned int v2 = *v1;
  if ((_DWORD)result)
  {
    if (!v2) {
LABEL_6:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC1uLL,  0);
    unsigned int v3 = *v1;
    while (v3 != (_DWORD)result)
    {
      BOOL v4 = v3 >= 0x100;
      v3 >>= 8;
      if (!v4) {
        goto LABEL_6;
      }
    }
  }

  if (HIDWORD(result))
  {
    if (!v2) {
LABEL_11:
    }
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xC2uLL,  0);
    while (v2 != HIDWORD(result))
    {
      BOOL v4 = v2 >= 0x100;
      v2 >>= 8;
      if (!v4) {
        goto LABEL_11;
      }
    }
  }

  unsigned int v5 = *v1;
  if (*v1 < result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unsigned int v6 = 0;
  if (v5 != (_DWORD)result)
  {
    unsigned int v8 = *v1;
    while (v5 >= v8 && v8 > result)
    {
      if (HIBYTE(v6)) {
LABEL_29:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
      v6 |= v8 << (-(__clz(v6) & 0x18) & 0x18);
      v8 >>= 8;
      if (v8 == (_DWORD)result) {
        goto LABEL_15;
      }
    }

LABEL_27:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v15, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    v370 = 0LL;
    v371 = 0LL;
    uint64_t v42 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v370, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v42, v43, 1);
    uint64_t v41 = 0xE000000000000000LL;
    goto LABEL_28;
  }

  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v40 = 0xA000000000000000LL;
  if (!(v13 & 0x80808080808080LL | v12 & 0x8080808080808080LL)) {
    uint64_t v40 = 0xE000000000000000LL;
  }
  v372._uint64_t countAndFlagsBits = v12;
  v372._uint64_t object = (void *)(v40 & 0xFF00000000000000LL | (v14 << 56) | v13 & 0xFFFFFFFFFFFFFFLL);
LABEL_29:
  TypeName = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for _DictionaryCodingKey, 0);
  if (v45 < 0) {
    goto LABEL_318;
  }
  uint64_t v46 = (uint8x16_t *)TypeName;
  uint64_t v47 = v45;
  v366 = v7;
  v367 = a1;
  if (_allASCII(_:)(TypeName, v45))
  {
    uint64_t v50 = 1;
LABEL_32:
    if (!v47)
    {
      uint64_t v52 = 0LL;
      uint64_t v51 = 0xE000000000000000LL;
      goto LABEL_121;
    }

    if (v47 > 15)
    {
      uint64_t v51 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v46->i8,  v47,  v47,  v50 & 1);
      uint64_t v52 = *(void *)(v51 + 24);
      goto LABEL_121;
    }

    uint64_t v90 = v47 - 8;
    char v91 = 8LL;
    if (v47 < 8) {
      char v91 = v47;
    }
    if ((v91 & 0x8000000000000000LL) == 0)
    {
      if (v91 >= 8)
      {
        if (v91 >= 0x10)
        {
          uint64_t v92 = v91 & 0xFFFFFFFFFFFFFFF0LL;
          int64_t v117 = vmovl_high_u8(*v46);
          int64_t v118 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v117.i8);
          char v119 = vmovl_u8(*(uint8x8_t *)v46->i8);
          uint64_t v120 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v119.i8);
          unint64_t v121 = (int8x16_t)vmovl_high_u16(v117);
          unint64_t v122 = (int8x8_t)vextq_s8(v121, v121, 8uLL).u64[0];
          uint64_t v123 = (int8x16_t)vmovl_high_u16(v119);
          unint64_t v124 = (int8x8_t)vextq_s8(v123, v123, 8uLL).u64[0];
          *(int8x8_t *)v123.i8 = vorr_s8(*(int8x8_t *)v123.i8, *(int8x8_t *)v121.i8);
          v125.i64[0] = v123.u32[0];
          v125.i64[1] = v123.u32[1];
          char v126 = (int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCE0);
          *(int8x8_t *)v121.i8 = vorr_s8(*(int8x8_t *)v120.i8, *(int8x8_t *)v118.i8);
          v125.i64[0] = v121.u32[0];
          v125.i64[1] = v121.u32[1];
          unint64_t v127 = vorrq_s8((int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCD0), v126);
          *(int8x8_t *)v121.i8 = vorr_s8(v124, v122);
          v125.i64[0] = v121.u32[0];
          v125.i64[1] = v121.u32[1];
          unint64_t v128 = (int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCC0);
          *(int8x8_t *)v118.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v118, v118, 8uLL));
          v125.i64[0] = v118.u32[0];
          v125.i64[1] = v118.u32[1];
          Swift::String v129 = vorrq_s8(v127, vorrq_s8((int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCB0), v128));
          uint64_t v52 = (uint64_t)vorr_s8(*(int8x8_t *)v129.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v129, v129, 8uLL));
          if (v91 == (v91 & 0xFFFFFFFFFFFFFFF0LL)) {
            goto LABEL_113;
          }
          unint64_t v93 = 8 * v92;
          if ((v91 & 8) == 0) {
            goto LABEL_111;
          }
        }

        else
        {
          uint64_t v52 = 0LL;
          unint64_t v93 = 0LL;
          uint64_t v92 = 0LL;
        }

        uint64_t v94 = v92;
        uint64_t v95 = vdupq_n_s64(v93);
        uint64_t v92 = v91 & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v93 = 8 * (v91 & 0xFFFFFFFFFFFFFFF8LL);
        unint64_t v96 = 0uLL;
        unint64_t v97 = (int8x16_t)(unint64_t)v52;
        uint64_t v98 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCC0);
        unint64_t v99 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCE0);
        uint64_t v100 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCB0);
        char v101 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCD0);
        uint64_t v102 = (uint8x8_t *)&v46->i8[v94];
        uint64_t v103 = (int8x16_t)vdupq_n_s64(0x38uLL);
        uint64_t v104 = v94 - (v91 & 0xFFFFFFFFFFFFFFF8LL);
        uint64_t v105 = vdupq_n_s64(0x40uLL);
        uint64_t v106 = 0uLL;
        uint64_t v107 = 0uLL;
        do
        {
          uint64_t v108 = *v102++;
          uint64_t v109 = vmovl_u8(v108);
          uint64_t v110 = vmovl_high_u16(v109);
          v111.i64[0] = v110.u32[2];
          v111.i64[1] = v110.u32[3];
          uint64_t v112 = v111;
          v111.i64[0] = v110.u32[0];
          v111.i64[1] = v110.u32[1];
          uint64_t v113 = v111;
          uint64_t v114 = vmovl_u16(*(uint16x4_t *)v109.i8);
          v111.i64[0] = v114.u32[2];
          v111.i64[1] = v114.u32[3];
          v115 = v111;
          v111.i64[0] = v114.u32[0];
          v111.i64[1] = v114.u32[1];
          uint64_t v107 = vorrq_s8((int8x16_t)vshlq_u64(v112, (uint64x2_t)vandq_s8((int8x16_t)v98, v103)), v107);
          uint64_t v106 = vorrq_s8((int8x16_t)vshlq_u64(v113, (uint64x2_t)vandq_s8((int8x16_t)v99, v103)), v106);
          unint64_t v96 = vorrq_s8((int8x16_t)vshlq_u64(v115, (uint64x2_t)vandq_s8((int8x16_t)v100, v103)), v96);
          unint64_t v97 = vorrq_s8((int8x16_t)vshlq_u64(v111, (uint64x2_t)vandq_s8((int8x16_t)v101, v103)), v97);
          unint64_t v99 = vaddq_s64(v99, v105);
          uint64_t v100 = vaddq_s64(v100, v105);
          char v101 = vaddq_s64(v101, v105);
          uint64_t v98 = vaddq_s64(v98, v105);
          v104 += 8LL;
        }

        while (v104);
        int64_t v116 = vorrq_s8(vorrq_s8(v97, v106), vorrq_s8(v96, v107));
        uint64_t v52 = (uint64_t)vorr_s8(*(int8x8_t *)v116.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v116, v116, 8uLL));
        if (v91 == v92)
        {
LABEL_113:
          if (v47 < 9)
          {
            BOOL v133 = 0LL;
          }

          else
          {
            BOOL v133 = 0LL;
            uint64_t v134 = 0LL;
            v135 = &v46->u8[8];
            do
            {
              char v136 = *v135++;
              v133 |= (unint64_t)v136 << v134;
              v134 += 8LL;
              --v90;
            }

            while (v90);
          }

          v137 = 0xA000000000000000LL;
          if (((v133 | v52) & 0x8080808080808080LL) == 0) {
            v137 = 0xE000000000000000LL;
          }
          uint64_t v51 = v137 | (v47 << 56) | v133;
          goto LABEL_121;
        }
      }

      else
      {
        uint64_t v92 = 0LL;
        uint64_t v52 = 0LL;
        unint64_t v93 = 0LL;
      }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v15, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    v364 = 0LL;
    v365 = 0LL;
    uint64_t v42 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v364, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v42, v43, 1);
    uint64_t v41 = 0xE000000000000000LL;
    goto LABEL_28;
  }

  swift_bridgeObjectRelease(v9);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v40 = 0xA000000000000000LL;
  if (!(v13 & 0x80808080808080LL | v12 & 0x8080808080808080LL)) {
    uint64_t v40 = 0xE000000000000000LL;
  }
  v366._uint64_t countAndFlagsBits = v12;
  v366._uint64_t object = (void *)(v40 & 0xFF00000000000000LL | (v14 << 56) | v13 & 0xFFFFFFFFFFFFFFLL);
LABEL_29:
  TypeName = (uint64_t *)swift_getTypeName((unint64_t)&type metadata for _GenericIndexKey, 0);
  if (v45 < 0) {
    goto LABEL_316;
  }
  uint64_t v46 = (uint8x16_t *)TypeName;
  uint64_t v47 = v45;
  v361 = v7;
  v363._uint64_t countAndFlagsBits = a1;
  if (_allASCII(_:)(TypeName, v45))
  {
    uint64_t v50 = 1;
LABEL_32:
    if (!v47)
    {
      uint64_t v52 = 0LL;
      uint64_t v51 = 0xE000000000000000LL;
      goto LABEL_121;
    }

    if (v47 > 15)
    {
      uint64_t v51 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)( v46->i8,  v47,  v47,  v50 & 1);
      uint64_t v52 = *(void *)(v51 + 24);
      goto LABEL_121;
    }

    uint64_t v90 = v47 - 8;
    char v91 = 8LL;
    if (v47 < 8) {
      char v91 = v47;
    }
    if ((v91 & 0x8000000000000000LL) == 0)
    {
      if (v91 >= 8)
      {
        if (v91 >= 0x10)
        {
          uint64_t v92 = v91 & 0xFFFFFFFFFFFFFFF0LL;
          int64_t v117 = vmovl_high_u8(*v46);
          int64_t v118 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v117.i8);
          char v119 = vmovl_u8(*(uint8x8_t *)v46->i8);
          uint64_t v120 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v119.i8);
          unint64_t v121 = (int8x16_t)vmovl_high_u16(v117);
          unint64_t v122 = (int8x8_t)vextq_s8(v121, v121, 8uLL).u64[0];
          uint64_t v123 = (int8x16_t)vmovl_high_u16(v119);
          unint64_t v124 = (int8x8_t)vextq_s8(v123, v123, 8uLL).u64[0];
          *(int8x8_t *)v123.i8 = vorr_s8(*(int8x8_t *)v123.i8, *(int8x8_t *)v121.i8);
          v125.i64[0] = v123.u32[0];
          v125.i64[1] = v123.u32[1];
          char v126 = (int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCE0);
          *(int8x8_t *)v121.i8 = vorr_s8(*(int8x8_t *)v120.i8, *(int8x8_t *)v118.i8);
          v125.i64[0] = v121.u32[0];
          v125.i64[1] = v121.u32[1];
          unint64_t v127 = vorrq_s8((int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCD0), v126);
          *(int8x8_t *)v121.i8 = vorr_s8(v124, v122);
          v125.i64[0] = v121.u32[0];
          v125.i64[1] = v121.u32[1];
          unint64_t v128 = (int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCC0);
          *(int8x8_t *)v118.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v118, v118, 8uLL));
          v125.i64[0] = v118.u32[0];
          v125.i64[1] = v118.u32[1];
          Swift::String v129 = vorrq_s8(v127, vorrq_s8((int8x16_t)vshlq_u64(v125, (uint64x2_t)xmmword_1817FFCB0), v128));
          uint64_t v52 = (uint64_t)vorr_s8(*(int8x8_t *)v129.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v129, v129, 8uLL));
          if (v91 == (v91 & 0xFFFFFFFFFFFFFFF0LL)) {
            goto LABEL_113;
          }
          unint64_t v93 = 8 * v92;
          if ((v91 & 8) == 0) {
            goto LABEL_111;
          }
        }

        else
        {
          uint64_t v52 = 0LL;
          unint64_t v93 = 0LL;
          uint64_t v92 = 0LL;
        }

        uint64_t v94 = v92;
        uint64_t v95 = vdupq_n_s64(v93);
        uint64_t v92 = v91 & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v93 = 8 * (v91 & 0xFFFFFFFFFFFFFFF8LL);
        unint64_t v96 = 0uLL;
        unint64_t v97 = (int8x16_t)(unint64_t)v52;
        uint64_t v98 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCC0);
        unint64_t v99 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCE0);
        uint64_t v100 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCB0);
        char v101 = vaddq_s64(v95, (int64x2_t)xmmword_1817FFCD0);
        uint64_t v102 = (uint8x8_t *)&v46->i8[v94];
        uint64_t v103 = (int8x16_t)vdupq_n_s64(0x38uLL);
        uint64_t v104 = v94 - (v91 & 0xFFFFFFFFFFFFFFF8LL);
        uint64_t v105 = vdupq_n_s64(0x40uLL);
        uint64_t v106 = 0uLL;
        uint64_t v107 = 0uLL;
        do
        {
          uint64_t v108 = *v102++;
          uint64_t v109 = vmovl_u8(v108);
          uint64_t v110 = vmovl_high_u16(v109);
          v111.i64[0] = v110.u32[2];
          v111.i64[1] = v110.u32[3];
          uint64_t v112 = v111;
          v111.i64[0] = v110.u32[0];
          v111.i64[1] = v110.u32[1];
          uint64_t v113 = v111;
          uint64_t v114 = vmovl_u16(*(uint16x4_t *)v109.i8);
          v111.i64[0] = v114.u32[2];
          v111.i64[1] = v114.u32[3];
          v115 = v111;
          v111.i64[0] = v114.u32[0];
          v111.i64[1] = v114.u32[1];
          uint64_t v107 = vorrq_s8((int8x16_t)vshlq_u64(v112, (uint64x2_t)vandq_s8((int8x16_t)v98, v103)), v107);
          uint64_t v106 = vorrq_s8((int8x16_t)vshlq_u64(v113, (uint64x2_t)vandq_s8((int8x16_t)v99, v103)), v106);
          unint64_t v96 = vorrq_s8((int8x16_t)vshlq_u64(v115, (uint64x2_t)vandq_s8((int8x16_t)v100, v103)), v96);
          unint64_t v97 = vorrq_s8((int8x16_t)vshlq_u64(v111, (uint64x2_t)vandq_s8((int8x16_t)v101, v103)), v97);
          unint64_t v99 = vaddq_s64(v99, v105);
          uint64_t v100 = vaddq_s64(v100, v105);
          char v101 = vaddq_s64(v101, v105);
          uint64_t v98 = vaddq_s64(v98, v105);
          v104 += 8LL;
        }

        while (v104);
        int64_t v116 = vorrq_s8(vorrq_s8(v97, v106), vorrq_s8(v96, v107));
        uint64_t v52 = (uint64_t)vorr_s8(*(int8x8_t *)v116.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v116, v116, 8uLL));
        if (v91 == v92)
        {
LABEL_113:
          if (v47 < 9)
          {
            BOOL v133 = 0LL;
          }

          else
          {
            BOOL v133 = 0LL;
            uint64_t v134 = 0LL;
            v135 = &v46->u8[8];
            do
            {
              char v136 = *v135++;
              v133 |= (unint64_t)v136 << v134;
              v134 += 8LL;
              --v90;
            }

            while (v90);
          }

          v137 = 0xA000000000000000LL;
          if (((v133 | v52) & 0x8080808080808080LL) == 0) {
            v137 = 0xE000000000000000LL;
          }
          uint64_t v51 = v137 | (v47 << 56) | v133;
          goto LABEL_121;
        }
      }

      else
      {
        uint64_t v92 = 0LL;
        uint64_t v52 = 0LL;
        unint64_t v93 = 0LL;
      }

  __break(1u);
  return result;
}

  uint64_t v22 = (unint64_t)v4[3];
  if (v22 >= 2)
  {
    uint64_t v23 = v22 >> 1;
    uint64_t v21 = __OFSUB__(v23, v7);
    uint64_t v24 = (__objc2_class *)(v23 - v7);
    if (v21) {
      goto LABEL_34;
    }
    v4[2] = v24;
  }

  return v4;
}

  __break(1u);
  return result;
}

  __break(1u);
}

  swift_release_n(v55, 2LL);
  uint64_t v40 = v54;
  swift_retain(v54, v41, v42, v43);
  uint64_t v44 = v56;
  while (!__ldaxr(v44))
  {
  }

  __clrex();
  swift_release((uint64_t)v40);
LABEL_32:
  swift_release((uint64_t)v40);
  unsigned int v8 = (void *)atomic_load(v44);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0xEEuLL,  0);
  }
  uint64_t v49 = swift_unknownObjectRetain(v8, v46, v47, v48);
  return v8;
}

  swift_release_n(v55, 2LL);
  uint64_t v40 = v54;
  swift_retain(v54, v41, v42, v43);
  uint64_t v44 = v56;
  while (!__ldaxr(v44))
  {
  }

  __clrex();
  swift_release((uint64_t)v40);
LABEL_32:
  swift_release((uint64_t)v40);
  unsigned int v8 = (void *)atomic_load(v44);
  if (!v8) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/DictionaryBridging.swift",  30LL,  2,  0x102uLL,  0);
  }
  uint64_t v49 = swift_unknownObjectRetain(v8, v46, v47, v48);
  return v8;
}

        v40(v130, a3);
        uint64_t v54 = 1LL;
        uint64_t v53 = v129;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v42 + 56))(v41, v54, 1LL, v53);
      }

      uint64_t v62 = v119;
      (*(void (**)(char *, char *, uint64_t))(v108 + 32))(v119, v128, a3);
      goto LABEL_19;
    }

    if (v60 >= v61)
    {
      Swift::Int v86 = v123;
      uint64_t v87 = v110;
      uint64_t v88 = swift_getAssociatedConformanceWitness( (uint64_t)v123,  a3,  v110,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      int64_t v89 = a3;
      uint64_t v90 = v109;
      (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v88 + 8))(&unk_18180BE68, 256LL, v87, v88);
      char v91 = v119;
      uint64_t v92 = v90;
      a3 = v89;
      (*((void (**)(char *, uint64_t, void))v86 + 3))(v92, v89, v86);
      unint64_t v93 = v128;
      LOBYTE(v87) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v44[4] + 8LL) + 40LL))( v128,  v91,  v89);
      uint64_t v94 = v89;
      uint64_t v40 = v122;
      v122(v91, v94);
      uint64_t v95 = v117;
      unint64_t v96 = v55;
      uint64_t v42 = v126;
      (*(void (**)(char *, char *, uint64_t))(v126 + 32))(v117, v96, v49);
      unint64_t v97 = v111;
      (*(void (**)(char *, char *, uint64_t))(v108 + 32))(v111, v93, a3);
      uint64_t v41 = v127;
      uint64_t v98 = v97;
      if ((v87 & 1) != 0)
      {
        unint64_t v99 = v127;
        uint64_t v100 = v125;
        char v101 = v118;
        (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v125 + 96))(v98, a3, v44, v49, v125);
        uint64_t v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v100 + 32) + 8LL) + 16LL))( v95,  v101,  v49);
        uint64_t v103 = *(void (**)(char *, uint64_t))(v42 + 8);
        v103(v101, v49);
        v103(v95, v49);
        uint64_t v41 = v99;
        if ((v102 & 1) != 0) {
          goto LABEL_27;
        }
      }

      else
      {
        v40(v97, a3);
        (*(void (**)(char *, uint64_t))(v42 + 8))(v95, v49);
      }

      goto LABEL_7;
    }

    uint64_t v68 = v119;
    ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v44[12])(v55, v49, v56, a3, v44);
    unint64_t v69 = v128;
    uint64_t v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v44[4] + 8LL) + 16LL))(v68, v128, a3);
    uint64_t v40 = v122;
    v122(v68, a3);
    BOOL v67 = v69;
  }

  else
  {
    Swift::Int v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v56 + 128))(v49, v56);
    uint64_t v64 = v128;
    if (v63 >= v45(a3, v44))
    {
      uint64_t v62 = v119;
      (*(void (**)(char *, char *, uint64_t))(v108 + 32))(v119, v64, a3);
LABEL_19:
      unint64_t v70 = v118;
      (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v56 + 96))(v62, a3, v44, v49, v56);
      uint64_t v71 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v56 + 32) + 8LL) + 16LL))( v55,  v70,  v49);
      uint64_t v72 = v126;
      unsigned int v73 = *(void (**)(char *, uint64_t))(v126 + 8);
      v73(v70, v49);
      unint64_t v74 = v55;
      uint64_t v42 = v72;
      v73(v74, v49);
      uint64_t v41 = v127;
      uint64_t v40 = v122;
      if ((v71 & 1) != 0) {
        goto LABEL_27;
      }
      goto LABEL_7;
    }

    char v65 = v119;
    ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v44[12])(v55, v49, v56, a3, v44);
    uint64_t v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v44[4] + 8LL) + 16LL))(v65, v64, a3);
    uint64_t v40 = v122;
    v122(v65, a3);
    BOOL v67 = v64;
  }

  v40(v67, a3);
  uint64_t v42 = v126;
  uint64_t v41 = v127;
  if ((v66 & 1) != 0) {
    goto LABEL_27;
  }
LABEL_7:
  uint64_t v52 = v44;
  uint64_t v53 = v129;
  (*(void (**)(char *, uint64_t, void *, uint64_t))(v125 + 96))(v130, a3, v52, v129);
  uint64_t v54 = 0LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v42 + 56))(v41, v54, 1LL, v53);
}

  uint64_t result = swift_release((uint64_t)v4);
  *unsigned int v2 = v35;
  return result;
}

  uint64_t result = swift_release((uint64_t)v4);
  *unsigned int v2 = v28;
  return result;
}

  __break(1u);
LABEL_28:
  __break(1u);
  return result;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2CAuLL,  0);
  }

  __break(1u);
}

          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
        }

      unsigned int v20 = v7._rawBits + (v13 << 16);
      uint64_t v21 = v20 & 0xFFFFFFFFFFFF0000LL;
      if (v10 != (v20 & 0xFFFFFFFFFFFF0000LL) >> 14)
      {
        uint64_t v23 = v20 >> 16;
        if ((v4 & 0x1000000000000000LL) != 0) {
          goto LABEL_47;
        }
        if ((v4 & 0x2000000000000000LL) != 0)
        {
          uint64_t v43 = v5;
          uint64_t v44 = v11;
          if (v23 + 1 != v8)
          {
            uint64_t v26 = *(unsigned __int16 *)((char *)&v43 + v23);
LABEL_38:
            if (v26 == 2573 || (v26 & 0x8080) != 0)
            {
LABEL_47:
              size_t v28 = v23;
              uint64_t v29 = v11;
              uint64_t v22 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v28);
              uint64_t v11 = v29;
              if (v22 > 63) {
                goto LABEL_45;
              }
              goto LABEL_44;
            }
          }
        }

        else
        {
          uint64_t v24 = (char *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v25 = v5 & 0xFFFFFFFFFFFFLL;
          if ((v5 & 0x1000000000000000LL) == 0)
          {
            uint64_t v42 = v11;
            uint64_t v24 = (char *)_StringObject.sharedUTF8.getter(v5, v4);
            uint64_t v11 = v42;
          }

          if (v23 + 1 != v25)
          {
            if (!v24) {
              goto LABEL_72;
            }
            uint64_t v26 = *(unsigned __int16 *)&v24[v23];
            goto LABEL_38;
          }
        }

        uint64_t v22 = 1LL;
        goto LABEL_44;
      }

      uint64_t v22 = 0LL;
LABEL_44:
      v21 |= v22 << 8;
LABEL_45:
      v7._Swift::UInt64 rawBits = v21 | v12;
      --offsetBy;
    }

    while (offsetBy);
  }

  return v7;
}

        uint64_t v46 = v71;
LABEL_28:
        uint64_t v47 = v38 >> 16;
        uint64_t v48 = v42 >> 16;
        uint64_t v49 = *(void *)(*(void *)(v46 + 8) + 8LL);
        (*(void (**)(Swift::UInt64 *__return_ptr, ValueMetadata *, uint64_t))(v49 + 64))(&v73, a4, v49);
        uint64_t v50 = v73;
        (*(void (**)(Swift::UInt64 *__return_ptr, ValueMetadata *, uint64_t))(v49 + 72))(&v73, a4, v49);
        uint64_t v51 = v50 >> 16;
        uint64_t v52 = v73 >> 16;
        if (v72 == v45 && v33 == v44 && v47 == v51 && v48 == v52)
        {
          swift_bridgeObjectRelease_n(v33, 2LL);
          uint64_t v53 = 0;
        }

        else
        {
          uint64_t v53 = _stringCompareInternal(_:_:_:_:expecting:)(v72, v33, v47, v48, v45, v44, v51, v52, 1);
          swift_bridgeObjectRelease(v33);
          swift_bridgeObjectRelease(v44);
        }

        return v53 & 1;
      }

      uint64_t v45 = *(void *)(a2 + 16);
      uint64_t v44 = *(void *)(a2 + 24);
    }

    swift_bridgeObjectRetain(v44, v39, v40, v41);
    goto LABEL_27;
  }

  if (a4 == &type metadata for String) {
    return specialized static StringProtocol.< infix<A>(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(void *)a2,  *(void *)(a2 + 8));
  }
  if (a4 != &type metadata for Substring)
  {
    if (a3 != (swift *)&type metadata for String)
    {
      uint64_t v68 = v28;
      unint64_t v69 = v29;
      uint64_t v34 = *(void *)(a1 + 16);
      Swift::Bool v33 = *(void *)(a1 + 24);
LABEL_17:
      uint64_t v71 = v25;
      uint64_t v72 = v34;
      swift_bridgeObjectRetain(v33, v22, (uint64_t)v23, v24);
      goto LABEL_20;
    }

    unsigned int v20 = v7[1].u64[0];
    do
    {
      uint64_t v21 = v7[1].u64[1];
      if (v20 >= v21 >> 1)
      {
        BOOL v4 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v21 > 1),  v20 + 1,  1,  (uint64_t)v7);
        uint64_t v11 = &type metadata for Unicode.UTF16.ForwardParser;
        unint64_t v7 = (uint8x16_t *)v4;
      }

      v7[1].i64[0] = v20 + 1;
      v7[2].i8[v20++] = v19 - 1;
      uint64_t v22 = v19 >= 0x100;
      v19 >>= 8;
    }

    while (v22);
    goto LABEL_6;
  }

  uint64_t v38 = v7[1].i64[0];
  swift_bridgeObjectRetain((unint64_t)v7, (uint64_t)v11, v5, v6);
  uint64_t v39 = specialized static String._uncheckedFromUTF8(_:)(v7 + 2, v38);
  swift_bridgeObjectRelease_n((uint64_t)v7, 2LL);
  return v39;
}

    uint64_t v21 = v7[1].u64[0];
    do
    {
      uint64_t v22 = v7[1].u64[1];
      if (v21 >= v22 >> 1)
      {
        uint64_t v47 = v10;
        uint64_t v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v22 > 1),  v21 + 1,  1,  (uint64_t)v7);
        uint64_t v12 = &type metadata for Unicode.UTF16.ForwardParser;
        unint64_t v7 = (uint8x16_t *)v24;
        uint64_t v10 = v47;
      }

      v7[1].i64[0] = v21 + 1;
      v7[2].i8[v21++] = v20 - 1;
      uint64_t v23 = v20 >= 0x100;
      v20 >>= 8;
    }

    while (v23);
    goto LABEL_6;
  }

  if ((a3 & 1) != 0 || ((v10 ^ 1) & 1) != 0)
  {
    uint64_t v44 = v7[1].i64[0];
    swift_bridgeObjectRetain((unint64_t)v7, (uint64_t)v12, v5, v6);
    uint64_t v43 = specialized static String._uncheckedFromUTF8(_:)(v7 + 2, v44);
    swift_bridgeObjectRelease_n((uint64_t)v7, 2LL);
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v7);
    return 0LL;
  }

  return v43;
}

        uint64_t v32 = specialized LazyMapSequence.Iterator.next()();
        if ((v32 & 0x100000000LL) != 0) {
          goto LABEL_34;
        }
        uint64_t v23 = v32;
        uint64_t v25 = 0LL;
      }
    }

    if (v25 != 1)
    {
      if (v25) {
        goto LABEL_37;
      }
LABEL_12:
      uint64_t v29 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v23, v25);
      goto LABEL_13;
    }

    goto LABEL_27;
  }

  uint64_t v27 = (unint64_t)v15 >> 63;
LABEL_34:
  swift_release(v36);
  swift_bridgeObjectRelease(v35);
  Swift::Bool v33 = a1 + a7;
  if (__OFADD__(a1, a7))
  {
    __break(1u);
  }

  else if (!__OFADD__(v33, v14))
  {
    __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v33 + v14, v27 & 1);
    return;
  }

  __break(1u);
LABEL_40:
  __break(1u);
}

        rawBits += v12 << 16;
        uint64_t v13 = 5;
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v14 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
      Swift::UInt64 rawBits = v14 & 0xFFFFFFFFFFFFFFF2LL | 1;
      unsigned int v8 = v14 >> 16;
      if ((v5 & 0x2000000000000000LL) == 0) {
        goto LABEL_15;
      }
    }

    v16[0] = v6;
    v16[1] = v5 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v12) = *((unsigned __int8 *)v16 + v8);
    if ((v12 & 0x80) == 0) {
      goto LABEL_26;
    }
    goto LABEL_17;
  }

  uint64_t result = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
LABEL_29:
  *a2 = result;
  return result;
}

        rawBits += v11 << 16;
        uint64_t v12 = 5;
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v13 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
      Swift::UInt64 rawBits = v13 & 0xFFFFFFFFFFFFFFF2LL | 1;
      unint64_t v7 = v13 >> 16;
      if ((v3 & 0x2000000000000000LL) == 0) {
        goto LABEL_15;
      }
    }

    v15[0] = v4;
    v15[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v11) = *((unsigned __int8 *)v15 + v7);
    if ((v11 & 0x80) == 0) {
      goto LABEL_26;
    }
    goto LABEL_17;
  }

  uint64_t result = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
LABEL_29:
  *a1 = result;
  return result;
}

        rawBits += v12 << 16;
        uint64_t v13 = 5;
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v14 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
      Swift::UInt64 rawBits = v14 & 0xFFFFFFFFFFFFFFF2LL | 1;
      unsigned int v8 = v14 >> 16;
      if ((v3 & 0x2000000000000000LL) == 0) {
        goto LABEL_15;
      }
    }

    v18[0] = v4;
    v18[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v12) = *((unsigned __int8 *)v18 + v8);
    if ((v12 & 0x80) == 0) {
      goto LABEL_26;
    }
    goto LABEL_17;
  }

  uint64_t v11 = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
LABEL_29:
  after->_Swift::UInt64 rawBits = v11;
}

        rawBits += v11 << 16;
        uint64_t v12 = 5;
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v13 = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
      Swift::UInt64 rawBits = v13 & 0xFFFFFFFFFFFFFFF2LL | 1;
      unint64_t v7 = v13 >> 16;
      if ((v3 & 0x2000000000000000LL) == 0) {
        goto LABEL_15;
      }
    }

    v15[0] = v4;
    v15[1] = v3 & 0xFFFFFFFFFFFFFFLL;
    LODWORD(v11) = *((unsigned __int8 *)v15 + v7);
    if ((v11 & 0x80) == 0) {
      goto LABEL_26;
    }
    goto LABEL_17;
  }

  uint64_t result = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
LABEL_29:
  *a1 = result;
  return result;
}

    if (v14 >= v15 && v14 < v13._rawBits >> 14) {
      goto LABEL_52;
    }
    goto LABEL_53;
  }

  uint64_t v22 = 0LL;
  uint64_t v23 = v12 >> 14;
  uint64_t v24 = (char *)&v34 + 6;
  do
  {
    if (v23 >= v14 && v14 >= v13._rawBits >> 14) {
      goto LABEL_52;
    }
    uint64_t v25 = v13._rawBits >> 16;
    if (!(v13._rawBits >> 16))
    {
      Swift::Bool v33 = 236LL;
      goto LABEL_56;
    }

    if ((v5 & 0x1000000000000000LL) != 0)
    {
      Swift::String::Index v31 = v24;
      v13._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v13)._rawBits;
      uint64_t v24 = v31;
    }

    else
    {
      if ((v5 & 0x2000000000000000LL) != 0)
      {
        uint64_t v35 = v6;
        uint64_t v36 = v5 & 0xFFFFFFFFFFFFFFLL;
        if ((*((_BYTE *)&v35 + v25 - 1) & 0xC0) == 0x80)
        {
          size_t v28 = 0LL;
          do
            uint64_t v29 = v24[v25 + v28--] & 0xC0;
          while (v29 == 128);
          uint64_t v30 = 1 - v28;
        }

        else
        {
          uint64_t v30 = 1LL;
        }

        v25 -= v30;
      }

      else
      {
        uint64_t v26 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v6 & 0x1000000000000000LL) == 0)
        {
          uint64_t v34 = v24;
          uint64_t v26 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
          uint64_t v24 = v34;
        }

        do
          uint64_t v27 = v26[--v25] & 0xC0;
        while (v27 == 128);
      }

      v13._Swift::UInt64 rawBits = (v25 << 16) | 5;
    }

    --v22;
  }

  while (v22 > offsetBy);
  if (v23 < v14 || v13._rawBits >> 14 >= v14)
  {
LABEL_53:
    uint64_t v32 = 0;
    goto LABEL_57;
  }

          v119(v122, v85);
          goto LABEL_28;
        }
      }

      else if (v110 <= 32)
      {
        Swift::String v85 = v268;
        v108(v86, v99, v268);
        char v126 = (*(uint64_t (**)(uint64_t, uint64_t))(v16 + 120))(v85, v16);
        unint64_t v122 = v99;
        char v119 = (void (*)(char *, uint64_t))v277;
        v277(v86, v85);
        uint64_t v98 = v275;
        if (v279 < v126) {
          goto LABEL_58;
        }
        goto LABEL_27;
      }

      uint64_t v123 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v16 + 96);
      unint64_t v124 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v110, v111, v112);
      Swift::String v85 = v268;
      v123(&v279, &type metadata for UInt32, v124, v268, v16);
      unint64_t v125 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v16 + 32) + 8LL) + 16LL))( v86,  v99,  v85);
      unint64_t v122 = v99;
      char v119 = (void (*)(char *, uint64_t))v277;
      v277(v86, v85);
      uint64_t v98 = v275;
      if ((v125 & 1) != 0) {
        goto LABEL_58;
      }
      goto LABEL_27;
    }

  *(void *)a4 = v11;
  *(_BYTE *)(a4 + 8) = v12;
  return result;
}

        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v14, 0LL);
        swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
        v287 = 0uLL;
        uint64_t v43 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v287, 0LL);
        _StringGuts.appendInPlace(_:isASCII:)(v43, v44, 1);
        uint64_t v38 = 0xE000000000000000LL;
        goto LABEL_28;
      }

      goto LABEL_262;
    }

    __break(1u);
    goto LABEL_28;
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "insufficient space to accommodate source.underestimatedCount elements",  69LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x2A5uLL,  0);
  }

  if (!v31) {
    goto LABEL_26;
  }
  uint64_t v34 = v56;
  uint64_t v58 = v56 - v64;
  if (v56 - v64 == 0x8000000000000000LL && v31 == -1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  }
  if (v58 / v31 < v33) {
    goto LABEL_27;
  }
  (*(void (**)(char *, uint64_t))(v57 + 8))(v24, a6);
  uint64_t v35 = v64;
  if ((*(_BYTE *)(v16 + 80) & v64) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "buffer base address must be properly aligned to access S.Element",  64LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x2AEuLL,  0);
  }
  if (__OFSUB__(0LL, v31))
  {
    __break(1u);
    goto LABEL_30;
  }

  uint64_t v36 = 0LL;
  int64_t v37 = v34 - v31 + 1;
  uint64_t v38 = v55;
  while (1)
  {
    uint64_t v39 = v37 >= v35 + v36;
    if (v31 > 0) {
      uint64_t v39 = v35 + v36 >= v37;
    }
    if (v39) {
      goto LABEL_23;
    }
    uint64_t v40 = v62;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v60,  a6,  v62,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( v40,  AssociatedConformanceWitness);
    uint64_t v42 = v63;
    uint64_t v43 = v59;
    (*(void (**)(char *, char *, unint64_t))(v16 + 32))(v59, v42, v38);
    (*(void (**)(uint64_t, char *, unint64_t))(v16 + 16))(v35 + v36, v43, v38);
    (*(void (**)(char *, unint64_t))(v16 + 8))(v43, v38);
    uint64_t v44 = v36 + v31;
    if (__OFADD__(v36, v31))
    {
      __break(1u);
LABEL_26:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }

    if ((v44 & 0x8000000000000000LL) == 0)
    {
      v36 += v31;
      if (v58 >= v44) {
        continue;
      }
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2D2uLL,  0);
  }

  (*(void (**)(char *, uint64_t))(v51 + 8))(v42, v52);
LABEL_23:
  uint64_t v48 = v53;
  uint64_t v50 = v61;
  uint64_t v49 = v62;
  (*(void (**)(uint64_t, char *, unint64_t))(v53 + 16))(v54, v61, v62);
  (*(void (**)(char *, unint64_t))(v48 + 8))(v50, v49);
  if (v36 / v31 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  return v35;
}

  uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v59 = 0;
LABEL_42:
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v33)(v37, a2);
  *(void *)uint64_t v41 = v58;
  *(_BYTE *)(v41 + 8) = v59;
  return result;
}

      uint64_t v35 = -128LL;
      goto LABEL_51;
    }
  }

  uint64_t v35 = -128LL;
  int64_t v116 = -128LL;
  uint64_t v36 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  int64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
  v36(&v116, &type metadata for Int, v37, a3, a4);
  uint64_t v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v28,  a3);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
  if ((v38 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_51:
  uint64_t v95 = v113;
  unint64_t v96 = *v113;
  unint64_t v97 = v113[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v98);
  if ((v35 & 0x8000000000000000LL) != 0)
  {
    if (v35 <= 0xFFFFFFFFFFFFFF80LL)
    {
      uint64_t result = 0LL;
      char v101 = 0LL;
      goto LABEL_55;
    }

    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v116, v97, v96, v102);
  }

  else if (v35 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v100);
  }

  char v101 = v116;
LABEL_55:
  *uint64_t v95 = v101;
  v95[1] = result;
  return result;
}

      uint64_t v35 = -128LL;
      goto LABEL_52;
    }
  }

  uint64_t v35 = -128LL;
  int64_t v116 = -128LL;
  uint64_t v36 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  int64_t v37 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
  v36(&v116, &type metadata for Int, v37, a3, a4);
  uint64_t v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( a2,  v28,  a3);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
  if ((v38 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_52:
  uint64_t v95 = v113;
  unint64_t v96 = *v113;
  unint64_t v97 = v113[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v98);
  if ((v35 & 0x8000000000000000LL) != 0)
  {
    if (v35 > 0xFFFFFFFFFFFFFF80LL)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v102);
    }
  }

  else
  {
    if (v35 >= 0x80)
    {
      uint64_t result = 0LL;
      char v101 = 0LL;
      goto LABEL_56;
    }

    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v116, v97, v96, v100);
  }

  char v101 = v116;
LABEL_56:
  *uint64_t v95 = v101;
  v95[1] = result;
  return result;
}

    swift_dynamicCastForeignClassMetatypeUnconditional((uint64_t)a1, v6, a3, (uint64_t)a4, a5);
  }

  return v5;
}

    uint64_t v9 = 1LL;
    goto LABEL_28;
  }

    uint64_t v9 = 1LL;
    goto LABEL_28;
  }

  operator delete(*(void **)(v22 - 96));
  if (((char)v41.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_17:
LABEL_29:
    operator delete(v43.__r_.__value_.__l.__data_);
    goto LABEL_30;
  }

  operator delete(*(void **)(v22 - 96));
  if (((char)v41.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_17:
LABEL_29:
    operator delete(v43.__r_.__value_.__l.__data_);
    goto LABEL_30;
  }

  operator delete(*(void **)(v22 - 96));
  if (((char)v41.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_17:
LABEL_29:
    operator delete(v43.__r_.__value_.__l.__data_);
    goto LABEL_30;
  }

LABEL_15:
  if (v5 < HIDWORD(result)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  if (HIDWORD(result))
  {
    unint64_t v7 = HIDWORD(result);
    while (v7 <= HIDWORD(result))
    {
      if (HIBYTE(v6)) {
        goto LABEL_29;
      }
      v6 |= v7 << (-(__clz(v6) & 0x18) & 0x18);
      BOOL v4 = v7 >= 0x100;
      LODWORD(v7) = v7 >> 8;
      if (!v4) {
        goto LABEL_21;
      }
    }

    goto LABEL_27;
  }

    __break(1u);
    goto LABEL_16;
  }

  return result;
}

    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v16);
  }

  uint64_t v25 = v31;
  v8[8] = v19;
  if ((v18 & 1) == 0) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v26 = *(void *)(v9 - 8);
  (*(void (**)(void *, unint64_t, uint64_t))(v26 + 32))( v14,  *(void *)(*v25 + 56LL) + *(void *)(v26 + 72) * v19,  v9);
  uint64_t v27 = 0LL;
LABEL_13:
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v26 + 56))(v14, v27, 1LL, v9);
  return _NativeDictionary.subscript.modify;
}

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  0x2A3uLL,  0);
    }
  }

  uint64_t v83 = *v50 - 1;
  Swift::Int v84 = v130;
  if (!__OFSUB__(*v50, 1LL))
  {
    if ((v83 & 0x8000000000000000LL) == 0)
    {
      Swift::String v85 = *(void *)(v134 + *(int *)(v64 + 36));
      if (v83 < *(void *)(v85 + 16))
      {
        uint64_t v87 = v126;
        Swift::Int v86 = v127;
        uint64_t v88 = v114;
        (*(void (**)(char *, unint64_t, uint64_t))(v126 + 16))( v114,  v85 + ((*(unsigned __int8 *)(v126 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v126 + 80))
        + *(void *)(v126 + 72) * v83,
          v127);
        int64_t v89 = v117;
        uint64_t v90 = v129;
        (*((void (**)(char *, uint64_t, const char *))v84 + 11))(v88, v129, v84);
        char v91 = &v88[*(int *)(v86 + 36)];
        uint64_t v92 = v90;
        unint64_t v93 = v119;
        uint64_t v94 = swift_getAssociatedConformanceWitness( v116,  v92,  v119,  (uint64_t)&protocol requirements base descriptor for BidirectionalCollection,  (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection);
        (*(void (**)(char *, uint64_t, unint64_t))(v94 + 32))(v91, v93, v94);
        (*(void (**)(char *, uint64_t))(v118 + 8))(v89, v93);
        (*(void (**)(char *, uint64_t))(v87 + 8))(v88, v86);
LABEL_14:
        uint64_t v107 = v120;
        *uint64_t v120 = v83;
        return (*(uint64_t (**)(char *, char *, unint64_t))(v128 + 32))( (char *)v107 + *(int *)(v115 + 36),  v63,  v60);
      }
    }

    goto LABEL_15;
  }

  __break(1u);
  return result;
}

      __break(1u);
      goto LABEL_16;
    }
  }

  return result;
}

      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for ObjectIdentifier);
    }
  }

  uint64_t v26 = *v33;
  *(void *)(*v33 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  uint64_t v27 = *(void *)(v26 + 48) + 40 * a2;
  size_t v28 = *(_OWORD *)v5;
  uint64_t v29 = *(_OWORD *)(v5 + 16);
  *(void *)(v27 + 32) = *(void *)(v5 + 32);
  *(_OWORD *)uint64_t v27 = v28;
  *(_OWORD *)(v27 + 16) = v29;
  uint64_t v30 = *(void *)(v26 + 16);
  Swift::String::Index v31 = __OFADD__(v30, 1LL);
  uint64_t v32 = v30 + 1;
  if (v31) {
    __break(1u);
  }
  else {
    *(void *)(v26 + 16) = v32;
  }
  return result;
}

      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for Int);
    }
  }

      ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v7);
    }
  }

  a2(&v12, v4);
  return v12;
}

  uint64_t v9 = _StringGuts.loadUnmanagedBreadcrumbs()(v1, v2);
  if (v9[2] == a1)
  {
    uint64_t v10 = HIBYTE(v4) & 0xF;
    if ((v4 & 0x2000000000000000LL) == 0) {
      uint64_t v10 = v5;
    }
    uint64_t v11 = v10 << 16;
    if ((v4 & 0x1000000000000000LL) == 0 || (v5 & 0x800000000000000LL) != 0) {
      return (Swift::String::Index)(v11 | 7);
    }
    else {
      return (Swift::String::Index)(v11 | 0xB);
    }
  }

  uint64_t v15 = v9[3];
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)((unint64_t)a1 >> 6, 1, v15);
  uint64_t v14 = (unint64_t)a1 >> 6;
  v7._Swift::UInt64 rawBits = *(void *)(v15 + 8 * ((unint64_t)a1 >> 6) + 32);
  uint64_t v16 = a1 & 0x3F;
  if (!v16) {
    return v7;
  }
  if ((v4 & 0x2000000000000000LL) != 0)
  {
    uint64_t v25 = HIBYTE(v4) & 0xF;
    v35[0] = v5;
    v35[1] = v4 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v19 = v7._rawBits >> 16;
    if (v7._rawBits >> 16 < v25)
    {
      if ((v7._rawBits & 0xC000) != 0) {
        uint64_t v26 = -1LL;
      }
      else {
        uint64_t v26 = 0LL;
      }
      while (1)
      {
        uint64_t v27 = *((char *)v35 + v19);
        if (v27 < 0)
        {
          uint64_t v29 = __clz(~(_BYTE)v27);
          uint64_t v30 = v29 - 24;
          size_t v28 = (v29 - 24);
          if (v30 == 4)
          {
            v26 += 2LL;
            if (v26 >= v16)
            {
LABEL_60:
              if (v16 >= v26)
              {
LABEL_61:
                v19 += v28;
                Swift::String::Index v31 = 5LL;
                return (Swift::String::Index)(v31 | (v19 << 16));
              }

  swift_bridgeObjectRelease(v6);
  return 0x7FFFFFFFFFFFFFFFLL;
}

  uint64_t result = (*(uint64_t (**)(int *, ValueMetadata *, uint64_t))(a3 + 88))(a1, a2, a3);
  if (result <= 0x7F)
  {
    uint64_t v13 = result + 1;
    goto LABEL_5;
  }

  uint64_t v16 = (result & 0x3F) << 8;
  if (result <= 0x7FF)
  {
    uint64_t v15 = v16 | (result >> 6);
    goto LABEL_12;
  }

  unsigned int v17 = (v16 | (result >> 6) & 0x3F) << 8;
  uint64_t v18 = (((v17 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
  uint64_t v13 = (v17 | (result >> 12)) + 8487393;
  if (WORD1(result)) {
    uint64_t v13 = v18;
  }
LABEL_5:
  *(_DWORD *)a4 = v13;
  *(_BYTE *)(a4 + 4) = 0;
  return result;
}

    if ((v3 & 0x1000000000000000LL) != 0) {
      goto LABEL_40;
    }
    if ((v3 & 0x2000000000000000LL) == 0) {
      break;
    }
    uint64_t v23 = v4;
    uint64_t v24 = v3 & 0xFFFFFFFFFFFFFFLL;
    if (v9 + 1 != (HIBYTE(v3) & 0xF))
    {
      uint64_t v15 = *(unsigned __int16 *)((char *)&v23 + v9);
      if (v15 == 2573 || (v15 & 0x80808080) != 0) {
        goto LABEL_40;
      }
    }

  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v22, v21);
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(v33 + 8))(v13, AssociatedTypeWitness);
  uint64_t v27 = v34;
  if (*v34 < v14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
  }
  if ((_DWORD)v14)
  {
    size_t v28 = v14;
    while (1)
    {
      uint64_t result = specialized Slice.subscript.getter(v28, v14);
      if (HIBYTE(v18)) {
        break;
      }
      v18 |= (result + 1) << (-(__clz(v18) & 0x18) & 0x18);
      uint64_t v29 = v28 > 0xFF;
      v28 >>= 8;
      if (!v29) {
        goto LABEL_20;
      }
    }

  uint64_t v23 = v12 & ~v13;
  if ((v23 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
    if ((v25 & 1) != 0) {
      goto LABEL_236;
    }
    if (v22 <= 15)
    {
      if ((v13 & 0x2000000000000000LL) != 0) {
        goto LABEL_56;
      }
      if (v24 < v20) {
        goto LABEL_48;
      }
    }
  }

  else if (v22 <= 15)
  {
    if ((v13 & 0x2000000000000000LL) != 0)
    {
LABEL_56:
      unsigned int v17 = "CollectionOfOne(";
      swift_bridgeObjectRelease_n(0x80000001818B7C00LL | 0x8000000000000000LL, 5LL);
      uint64_t v41 = v13;
      goto LABEL_57;
    }

  uint64_t v108 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v52 = v49(a2, a3);
  uint64_t v53 = v44(a2, a3);
  if ((v52 & 1) != 0)
  {
    if (v53 > 64)
    {
      uint64_t v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v57 = lazy protocol witness table accessor for type Int64 and conformance Int64(v53, v54, v55);
      uint64_t v58 = v101;
      v56(&v108, &type metadata for Int64, v57, a2, a3);
      uint64_t v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v58,  v48,  a2);
      v36(v58, a2);
      uint64_t v60 = v48;
      goto LABEL_34;
    }

    goto LABEL_23;
  }

  if (v53 <= 63)
  {
LABEL_23:
    unint64_t v69 = v101;
    (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v101, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    unint64_t v70 = v69;
LABEL_26:
    v36(v70, a2);
    goto LABEL_27;
  }

  uint64_t v107 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v79 = v101;
  uint64_t v80 = (*(uint64_t (**)(char *, char *, uint64_t))(v106 + 32))(v101, v48, a2);
  unint64_t v81 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  Swift::Int v84 = lazy protocol witness table accessor for type Int64 and conformance Int64(v80, v82, v83);
  Swift::String v85 = v100;
  v81(&v107, &type metadata for Int64, v84, a2, a3);
  uint64_t v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v85,  v79,  a2);
  v36(v85, a2);
  uint64_t v60 = v79;
LABEL_34:
  v36(v60, a2);
  if ((v59 & 1) != 0) {
    goto LABEL_41;
  }
LABEL_27:
  uint64_t v71 = *(void (**)(uint64_t, uint64_t))(a3 + 120);
  v71(a2, a3);
  v36(v29, a2);
  uint64_t v72 = ((uint64_t (*)(uint64_t, uint64_t))v71)(a2, a3);
LABEL_42:
  v36(v43, a2);
  return v72;
}

    uint64_t v12 = 0.0;
    return *(void *)&v12;
  }

  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v15 = *(void (**)(char *, uint64_t))(v6 + 8);
  v15(v8, a2);
  if ((v13 & 1) == 0)
  {
    unsigned int v17 = (double)(unint64_t)v14;
    if ((double)(unint64_t)v14 < 1.84467441e19)
    {
      uint64_t v12 = (double)(unint64_t)v14;
      if ((~*(void *)&v17 & 0x7FF0000000000000LL) == 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to UInt because it is either infinite or NaN",  77LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3129uLL,  0);
      }
      v15((char *)a1, a2);
      return *(void *)&v12;
    }

  unint64_t v99 = 127;
  uint64_t v46 = v95(a2, a3);
  uint64_t v47 = v34(a2, a3);
  if ((v46 & 1) != 0)
  {
    if (v47 > 8)
    {
      uint64_t v50 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v51 = lazy protocol witness table accessor for type Int8 and conformance Int8(v47, v48, v49);
      uint64_t v52 = v91;
      v50(&v99, v90, v51, a2, a3);
      uint64_t v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v52,  v38,  a2);
      v32(v52, a2);
      uint64_t v54 = v38;
      goto LABEL_34;
    }

    goto LABEL_23;
  }

  if (v47 <= 7)
  {
LABEL_23:
    uint64_t v62 = v91;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    Swift::Int v63 = v62;
LABEL_26:
    v32(v63, a2);
    goto LABEL_27;
  }

  uint64_t v98 = 127;
  unsigned int v73 = v91;
  unint64_t v74 = (*(uint64_t (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
  uint64_t v75 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  uint64_t v78 = lazy protocol witness table accessor for type Int8 and conformance Int8(v74, v76, v77);
  uint64_t v79 = v89;
  v75(&v98, v90, v78, a2, a3);
  uint64_t v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v79,  v73,  a2);
  v32(v79, a2);
  uint64_t v54 = v73;
LABEL_34:
  v32(v54, a2);
  if ((v53 & 1) != 0) {
    goto LABEL_40;
  }
LABEL_27:
  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
  uint64_t v66 = 0;
LABEL_41:
  *uint64_t v40 = v64;
  v40[1] = v66;
  return result;
}

  unint64_t v99 = 0x7FFF;
  uint64_t v46 = v95(a2, a3);
  uint64_t v47 = v34(a2, a3);
  if ((v46 & 1) != 0)
  {
    if (v47 > 16)
    {
      uint64_t v50 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v51 = lazy protocol witness table accessor for type Int16 and conformance Int16(v47, v48, v49);
      uint64_t v52 = v91;
      v50(&v99, v90, v51, a2, a3);
      uint64_t v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v52,  v38,  a2);
      v32(v52, a2);
      uint64_t v54 = v38;
      goto LABEL_34;
    }

    goto LABEL_23;
  }

  if (v47 <= 15)
  {
LABEL_23:
    uint64_t v62 = v91;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    Swift::Int v63 = v62;
LABEL_26:
    v32(v63, a2);
    goto LABEL_27;
  }

  uint64_t v98 = 0x7FFF;
  unsigned int v73 = v91;
  unint64_t v74 = (*(uint64_t (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
  uint64_t v75 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  uint64_t v78 = lazy protocol witness table accessor for type Int16 and conformance Int16(v74, v76, v77);
  uint64_t v79 = v89;
  v75(&v98, v90, v78, a2, a3);
  uint64_t v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v79,  v73,  a2);
  v32(v79, a2);
  uint64_t v54 = v73;
LABEL_34:
  v32(v54, a2);
  if ((v53 & 1) != 0) {
    goto LABEL_40;
  }
LABEL_27:
  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
  uint64_t v66 = 0;
LABEL_41:
  *(_WORD *)uint64_t v40 = v64;
  *(_BYTE *)(v40 + 2) = v66;
  return result;
}

  uint64_t v100 = 0x7FFFFFFF;
  uint64_t v46 = v96(a2, a3);
  uint64_t v47 = v34(a2, a3);
  if ((v46 & 1) != 0)
  {
    if (v47 > 32)
    {
      uint64_t v50 = *(void (**)(int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v51 = lazy protocol witness table accessor for type Int32 and conformance Int32(v47, v48, v49);
      uint64_t v52 = v92;
      v50(&v100, v91, v51, a2, a3);
      uint64_t v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v52,  v38,  a2);
      v32(v52, a2);
      uint64_t v54 = v38;
      goto LABEL_34;
    }

    goto LABEL_23;
  }

  if (v47 <= 31)
  {
LABEL_23:
    uint64_t v62 = v92;
    (*(void (**)(char *, char *, uint64_t))(v97 + 32))(v92, v38, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    Swift::Int v63 = v62;
LABEL_26:
    v32(v63, a2);
    goto LABEL_27;
  }

  unint64_t v99 = 0x7FFFFFFF;
  unsigned int v73 = v92;
  unint64_t v74 = (*(uint64_t (**)(char *, char *, uint64_t))(v97 + 32))(v92, v38, a2);
  uint64_t v75 = *(void (**)(int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  uint64_t v78 = lazy protocol witness table accessor for type Int32 and conformance Int32(v74, v76, v77);
  uint64_t v79 = v90;
  v75(&v99, v91, v78, a2, a3);
  uint64_t v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v79,  v73,  a2);
  v32(v79, a2);
  uint64_t v54 = v73;
LABEL_34:
  v32(v54, a2);
  if ((v53 & 1) != 0) {
    goto LABEL_40;
  }
LABEL_27:
  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
  uint64_t v66 = 0;
LABEL_41:
  *(_DWORD *)uint64_t v40 = v64;
  *(_BYTE *)(v40 + 4) = v66;
  return result;
}

  uint64_t v45 = v99(a3, a4);
  uint64_t v46 = v95;
  uint64_t v47 = v95(a3, a4);
  if ((v45 & 1) != 0)
  {
    if (v47 > 64) {
      goto LABEL_17;
    }
  }

  else if (v47 >= 64)
  {
LABEL_17:
    char v101 = 64LL;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    uint64_t v48 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  a2,  a3);
    uint64_t v49 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v49(v30, a3);
    if ((v48 & 1) == 0) {
      goto LABEL_18;
    }
LABEL_25:
    uint64_t v39 = *v37 >> 63;
    goto LABEL_59;
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
  uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v49 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v49(v30, a3);
  if (v59 > 64) {
    goto LABEL_25;
  }
LABEL_18:
  uint64_t v50 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v51 = v96;
  v50(v96, a2, a3);
  uint64_t v52 = v99(a3, a4);
  uint64_t v53 = v94;
  Swift::Int v86 = (void (*)(char *, char *, uint64_t))v50;
  v50(v94, (uint64_t)v51, a3);
  if ((v52 & 1) == 0)
  {
    v49(v53, a3);
    uint64_t v55 = v96;
    uint64_t v56 = v99;
    goto LABEL_43;
  }

  uint64_t v54 = v46(a3, a4);
  v49(v53, a3);
  uint64_t v55 = v96;
  uint64_t v56 = v99;
  if (v54 <= 64) {
    goto LABEL_43;
  }
  uint64_t v57 = v88;
  v86(v88, v96, a3);
  char v101 = 0x8000000000000000LL;
  if ((v56(a3, a4) & 1) != 0)
  {
    if (v46(a3, a4) < 64)
    {
      uint64_t v58 = v30;
      goto LABEL_37;
    }

    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    uint64_t v62 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v57,  v30,  a3);
    goto LABEL_32;
  }

  uint64_t v60 = v56(a3, a4);
  uint64_t v61 = v46(a3, a4);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      char v65 = v37;
      BOOL v67 = AssociatedTypeWitness;
      uint64_t v66 = (void (**)(char *, uint64_t, const char *))v91;
      uint64_t v68 = swift_getAssociatedConformanceWitness( (uint64_t)v91,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v69 = v89;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v68 + 8))( &qword_18180BE68,  256LL,  v67,  v68);
      v66[3](v69, a3, (const char *)v66);
      unint64_t v70 = v88;
      LOBYTE(v66) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v88,  v30,  a3);
      v49(v30, a3);
      uint64_t v71 = v87;
      v86(v87, v70, a3);
      if ((v66 & 1) != 0)
      {
        v49(v71, a3);
        goto LABEL_65;
      }

      uint64_t v72 = v101;
      unsigned int v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v49(v71, a3);
      unint64_t v74 = v73 < v72;
      int64_t v37 = v65;
      uint64_t v46 = v95;
      uint64_t v55 = v96;
      uint64_t v57 = v88;
      if (v74) {
        goto LABEL_65;
      }
LABEL_41:
      Swift::String v85 = v57;
      goto LABEL_42;
    }

    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    uint64_t v57 = v88;
    uint64_t v62 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v88,  v30,  a3);
LABEL_32:
    Swift::Int v63 = v62;
    v49(v30, a3);
    if ((v63 & 1) != 0) {
      goto LABEL_65;
    }
    goto LABEL_41;
  }

  if (v61 < 64)
  {
    uint64_t v58 = v30;
    uint64_t v57 = v88;
LABEL_37:
    v86(v58, v57, a3);
    uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v49(v30, a3);
    if (v64 < v101) {
LABEL_65:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
    goto LABEL_41;
  }

  Swift::String v85 = v88;
LABEL_42:
  v49(v85, a3);
LABEL_43:
  uint64_t v75 = v46(a3, a4);
  BOOL v76 = v93;
  v86(v93, v55, a3);
  if (v75 >= 65)
  {
    v49(v76, a3);
    goto LABEL_45;
  }

  unint64_t v81 = v46(a3, a4);
  v49(v76, a3);
  if (v81 == 64 && (v56(a3, a4) & 1) == 0)
  {
LABEL_45:
    uint64_t v77 = v92;
    v86(v92, v55, a3);
    char v101 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v78 = v56(a3, a4);
    uint64_t v79 = v77;
    LOBYTE(v77) = v78;
    uint64_t v80 = v46(a3, a4);
    if ((v77 & 1) != 0)
    {
      if (v80 > 64)
      {
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))( &v101,  v97,  v98,  a3,  a4);
        goto LABEL_54;
      }
    }

    else if (v80 >= 64)
    {
      uint64_t v100 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v100, v97, v98, a3, a4);
LABEL_54:
      uint64_t v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v30,  v79,  a3);
      v49(v30, a3);
      if ((v82 & 1) != 0) {
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
      goto LABEL_55;
    }

    v86(v30, v79, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v49(v30, a3);
LABEL_55:
    v49(v79, a3);
  }

  uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v49(v55, a3);
  Swift::Int v84 = *v37;
  if ((v83 & 0x8000000000000000LL) != 0)
  {
    if (v83 > 0xFFFFFFFFFFFFFFC0LL)
    {
      uint64_t v39 = v84 << -(char)v83;
      goto LABEL_59;
    }

    goto LABEL_12;
  }

  if (v83 >= 0x40) {
    uint64_t v39 = v84 >> 63;
  }
  else {
    uint64_t v39 = v84 >> v83;
  }
LABEL_59:
  *int64_t v37 = v39;
  return result;
}

  uint64_t v90 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v44 = v86(a2, a3);
  uint64_t v45 = v35(a2, a3);
  if ((v44 & 1) != 0)
  {
    if (v45 > 64)
    {
      uint64_t v46 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v47 = v81();
      uint64_t v48 = v83;
      v46(&v90, v82, v47, a2, a3);
      uint64_t v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v48,  v40,  a2);
      v33(v48, a2);
      uint64_t v50 = v40;
      goto LABEL_34;
    }

    goto LABEL_23;
  }

  if (v45 <= 63)
  {
LABEL_23:
    uint64_t v56 = v83;
    (*(void (**)(char *, char *, uint64_t))(v87 + 32))(v83, v40, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v57 = v56;
LABEL_26:
    v33(v57, a2);
    goto LABEL_27;
  }

  int64_t v89 = 0x7FFFFFFFFFFFFFFFLL;
  char v65 = v83;
  uint64_t v66 = (*(uint64_t (**)(char *, char *, uint64_t))(v87 + 32))(v83, v40, a2);
  BOOL v67 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
  uint64_t v68 = ((uint64_t (*)(uint64_t))v81)(v66);
  unint64_t v69 = v80;
  v67(&v89, v82, v68, a2, a3);
  uint64_t v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v69,  v65,  a2);
  v33(v69, a2);
  uint64_t v50 = v65;
LABEL_34:
  v33(v50, a2);
  if ((v49 & 1) != 0)
  {
    uint64_t v58 = 0LL;
    uint64_t v59 = 1;
    goto LABEL_42;
  }

  uint64_t v9 = (__PAIR128__(high, by.low) * __PAIR128__(v5, v4)) >> 64;
  uint64_t v10 = __CFADD__((__PAIR128__(v5, v4) * by.low) >> 64, v4 * high);
  uint64_t v11 = __CFADD__((v4 * (unsigned __int128)by.low) >> 64, v5 * by.low);
  uint64_t v12 = v4 * by.low;
  uint64_t v13 = (v5 * (unsigned __int128)by.low) >> 64;
  uint64_t v14 = v5 * high;
  uint64_t v15 = (v5 * (unsigned __int128)(unint64_t)high) >> 64;
  uint64_t v16 = v13 + ((v4 * (unsigned __int128)(unint64_t)high) >> 64);
  if (__CFADD__(v11, v14) | __CFADD__(v10, v11 + v14)) {
    unsigned int v17 = 1LL;
  }
  else {
    unsigned int v17 = 0LL;
  }
  unint64_t v19 = (__PAIR128__(v17, v16) + __PAIR128__(v15, v10 + (unint64_t)v11 + v14)) >> 64;
  uint64_t v18 = v16 + v10 + v11 + v14;
  if (!v6)
  {
    unsigned int v20 = -(uint64_t)v9;
    if (v12) {
      unsigned int v20 = ~v9;
    }
    uint64_t v21 = -(uint64_t)v12 - 1;
    uint64_t v9 = (__PAIR128__(v20, v12) - 1) >> 64;
    uint64_t v12 = -(uint64_t)v12;
    uint64_t v22 = v21 == -1;
    if (v9 == -1LL)
    {
      uint64_t v23 = v21 == -1;
    }

    else
    {
      if (v21 != -1)
      {
        uint64_t v22 = 0;
        uint64_t v25 = 0;
        uint64_t v24 = -v19;
        uint64_t v26 = -(uint64_t)v18;
        if (!v18) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }

      uint64_t v22 = 0;
      uint64_t v23 = 1LL;
    }

    v9 += v23;
    uint64_t v24 = -v19;
    uint64_t v25 = v22;
    uint64_t v26 = -(uint64_t)v18;
    if (!v18)
    {
LABEL_30:
      unint64_t v19 = (__PAIR128__(v24, v26 - 1) + __PAIR128__((uint64_t)((unint64_t)(v26 == 0) << 63) >> 63, v25)) >> 64;
      uint64_t v18 = v26 - 1 + v25;
      goto LABEL_34;
    }

      v101 += v108;
      uint64_t v104 = v105;
      if (v105 == v102) {
        goto LABEL_58;
      }
    }
  }

  uint64_t v103 = 1;
LABEL_58:
  uint64_t v113 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v99, v100, v103 & 1);
LABEL_60:
  unint64_t v124 = v113;
  unint64_t v125 = v114;
  char v126 = v451;
  unint64_t v127 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000LL) == 0) {
    unint64_t v127 = v450 & 0xFFFFFFFFFFFFLL;
  }
  if (v127 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
  {
    if ((v451 & 0x2000000000000000LL) != 0)
    {
      if ((v114 & 0x2000000000000000LL) != 0)
      {
        Swift::String v129 = specialized _SmallString.init(_:appending:)(v450, v451, v113, v114);
        if ((v115 & 1) == 0)
        {
          v130 = v129;
          v131 = v114;
          swift_bridgeObjectRelease(v126);
          swift_bridgeObjectRelease(v125);
          v450 = v130;
          v451 = v131;
          unint64_t v125 = v131;
          unint64_t v124 = v130;
          goto LABEL_73;
        }

        goto LABEL_71;
      }
    }

    else if ((v114 & 0x2000000000000000LL) != 0)
    {
LABEL_71:
      unint64_t v128 = HIBYTE(v125) & 0xF;
      goto LABEL_72;
    }

    unint64_t v128 = v113 & 0xFFFFFFFFFFFFLL;
LABEL_72:
    swift_bridgeObjectRetain(v125, v114, v115, v116);
    _StringGuts.append(_:)(v124, v125, 0LL, v128);
    swift_bridgeObjectRelease_n(v125, 2LL);
    unint64_t v124 = v450;
    unint64_t v125 = v451;
    goto LABEL_73;
  }

  swift_bridgeObjectRelease(v451);
  v450 = v124;
  v451 = v125;
LABEL_73:
  v135 = HIBYTE(v125) & 0xF;
  if ((v125 & 0x2000000000000000LL) == 0) {
    v135 = v124 & 0xFFFFFFFFFFFFLL;
  }
  v435 = v44;
  if (v135 || (v124 & ~v125 & 0x2000000000000000LL) != 0)
  {
    if ((v125 & 0x2000000000000000LL) == 0
      || (char v136 = specialized _SmallString.init(_:appending:)(v124, v125, 0x283EuLL, 0xE200000000000000LL),
          (v133 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000LL, v132, v133, v134);
      _StringGuts.append(_:)(10302LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
    }

    else
    {
      v137 = v136;
      v138 = v132;
      swift_bridgeObjectRelease(v125);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      v450 = v137;
      v451 = v138;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v125);
    v450 = 10302LL;
    v451 = 0xE200000000000000LL;
  }

  v139 = *(const char **)(v437 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v139,  (uint64_t)v1,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  associated type descriptor for SIMDScalar.SIMD8Storage);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v139,  (uint64_t)v1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for SIMDScalar,  (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  unint64_t v142 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v143 = swift_checkMetadataState(0LL, AssociatedTypeWitness);
  unint64_t v144 = AssociatedConformanceWitness;
  v145 = v142;
  ((void (*)(void))v142)(0LL);
  v445 = (uint64_t *)v1;
  v146 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v146, v87, v2);
  v147 = v445;
  uint64_t v148 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  DynamicType = (void *)swift_getDynamicType(v148, v147, 1);
  LODWORD(v147) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v147)
  {
    v150 = v443;
    memcpy(v443, v87, v2);
    v151 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v151, 7uLL);
    unint64_t v152 = (uint64_t)v445;
    v153 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v155 = (*(uint64_t (**)(uint64_t, uint64_t))(v153 + 8))(v152, v153);
    v156 = v154;
    uint64_t v157 = v451;
    v158 = HIBYTE(v451) & 0xF;
    if ((v451 & 0x2000000000000000LL) == 0) {
      v158 = v450 & 0xFFFFFFFFFFFFLL;
    }
    if (v158 || (v450 & ~v451 & 0x2000000000000000LL) != 0)
    {
      v159 = v145;
      if ((v451 & 0x2000000000000000LL) == 0)
      {
        if ((v154 & 0x2000000000000000LL) != 0)
        {
          v160 = HIBYTE(v154) & 0xF;
LABEL_124:
          _StringGuts.append(_:)(v155, v156, 0LL, v160);
          swift_bridgeObjectRelease(v156);
          goto LABEL_125;
        }

  if (v12 >= 1)
  {
    unint64_t v19 = &v14[v12];
    do
    {
      uint64_t v21 = *(void *)v14;
      v14 += 8;
      unsigned int v20 = v21;
      Swift::String::Index v31 = v14;
      uint64_t v22 = *a3;
      uint64_t v23 = v21 & 0xFFFFFFFFFFFFFFLL;
      if ((v21 & 0xFFFFFFFFFFFFFFLL) != 0) {
        uint64_t result = memcpy((void *)(a4 + v22), (const void *)(a5 + v22), v23);
      }
      *a3 = v22 + v23;
      if (HIBYTE(v20))
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *, char **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                 + ((v20 >> 53) & 0x7F8)))( v8,  &v31,  a3,  a4,  a5);
        uint64_t v14 = v31;
      }
    }

    while (v14 < v19);
  }

  unsigned int v20 = 16LL;
  if (a7)
  {
    unsigned int v20 = 32LL;
    uint64_t v21 = 2LL;
  }

  else
  {
    uint64_t v21 = 1LL;
  }

  (*(void (**)(uint64_t, uint64_t, void *))(*(a4 - 1) + v20))(a1, a3, a4);
  return v21;
}

    uint64_t v9 = (int **)(a1 + 8);
LABEL_16:
    unsigned int v8 = *v9;
    goto LABEL_17;
  }

  if ((_DWORD)v6 == 515 || (_DWORD)v6 == 516) {
    goto LABEL_15;
  }
LABEL_17:
  uint64_t v10 = 0LL;
  if ((int)v6 <= 514)
  {
    if ((v6 - 512) >= 3)
    {
      if ((_DWORD)v6) {
        goto LABEL_26;
      }
      goto LABEL_20;
    }

    JUMPOUT(0x18176F4E4LL);
  }

  return v1 + 8 * v6;
}

  if (*((_WORD *)v2 + 8) == 38)
  {
    unsigned int v8 = *((unsigned __int8 *)v2 + 18);
    if ((v8 - 1) >= 2)
    {
      if (v8 == 5) {
        uint64_t v9 = (void *)*v2;
      }
      else {
        uint64_t v9 = v2;
      }
      unsigned int v2 = (void *)*v2;
    }

    else
    {
      uint64_t v9 = v2;
    }

    unint64_t v7 = *(void *)*v2 & 0xFFFFFF00LL | (*(void *)v9[1] << 32);
    unsigned int v6 = *(void *)*v2;
  }

  else
  {
    unsigned int v6 = 0LL;
    unint64_t v7 = 0LL;
  }

  if (swift::runtime::trace::LogsToken != -1) {
    dispatch_once_f(&swift::runtime::trace::LogsToken, 0LL, (dispatch_function_t)swift::runtime::trace::setupLogs);
  }
  if (swift::runtime::trace::TracingEnabled)
  {
    uint64_t v11 = os_signpost_id_generate((os_log_t)swift::runtime::trace::ScanLog);
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v12 = (os_log_s *)swift::runtime::trace::ScanLog;
      if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
      {
        if (a2)
        {
          v32[0] = 0;
          *(void *)&v32[1] = 0x101010101010101LL;
          v32[9] = 1;
          *(void *)&v32[10] = 0x101010100000000LL;
          Swift::Bool v33 = 1;
          uint64_t v34 = 256;
          uint64_t v35 = 1;
          uint64_t v36 = 0LL;
          int64_t v37 = 0LL;
          v38[0] = &unk_189B8B0E8;
          v38[1] = swift::Demangle::__runtime::genericParameterName;
          uint64_t v39 = v38;
          swift::Demangle::__runtime::nodeToString((swift::Demangle::__runtime::Node *)a2, (__int128 *)v32, &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)buf = 136315138;
          uint64_t v42 = (const char *)p_p;
          _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v11,  "section_scan",  "metadata scan for %s",  buf,  0xCu);
          uint64_t v14 = v39;
          if (v39 == v38)
          {
            uint64_t v15 = 4LL;
            uint64_t v14 = v38;
            goto LABEL_58;
          }

          if (v39)
          {
            uint64_t v15 = 5LL;
LABEL_58:
            (*(void (**)(void))(*v14 + 8 * v15))();
          }
        }

        else
        {
          *(_DWORD *)buf = 136315138;
          uint64_t v42 = "<null>";
          _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v11,  "section_scan",  "metadata scan for %s",  buf,  0xCu);
        }
      }
    }
  }

  else
  {
LABEL_30:
    uint64_t v11 = 0LL;
  }

  uint64_t v16 = (unint64_t *)(a1 + 48);
  do
    unsigned int v17 = __ldaxr(v16);
  while (__stxr(v17 + 1, v16));
  uint64_t v18 = *(unint64_t **)(a1 + 56);
  if (!v18 || (unint64_t v19 = atomic_load(v18)) == 0)
  {
    do
LABEL_46:
      uint64_t v27 = __ldxr(v16);
    while (__stlxr(v27 - 1, v16));
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      size_t v28 = (os_log_s *)swift::runtime::trace::ScanLog;
      if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
      {
        *(_DWORD *)uint64_t v32 = 134217984;
        *(void *)&v32[4] = 0LL;
        _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v28,  OS_SIGNPOST_INTERVAL_END,  v11,  "section_scan",  "result=%p",  v32,  0xCu);
      }
    }

    return 0LL;
  }

  unsigned int v20 = (int **)(v18 + 1);
  uint64_t v21 = (uint64_t)&v18[2 * v19 + 1];
  while (1)
  {
    uint64_t v22 = *v20;
    uint64_t v23 = v20[1];
    if (*v20 != v23) {
      break;
    }
LABEL_36:
    v20 += 2;
  }

  uint64_t v24 = *v20;
  while (1)
  {
    uint64_t v26 = *v24;
    if ((*v24 & 3) != 1) {
      break;
    }
    uint64_t v25 = *(const char **)((char *)v22 + (v26 & 0xFFFFFFFFFFFFFFFCLL));
    if (v25) {
      goto LABEL_40;
    }
LABEL_41:
    ++v24;
    ++v22;
    if (v24 == v23) {
      goto LABEL_36;
    }
  }

  if ((v26 & 3) != 0) {
    goto LABEL_41;
  }
  uint64_t v25 = (char *)v22 + (v26 & 0xFFFFFFFFFFFFFFFCLL);
  if (!v25) {
    goto LABEL_41;
  }
LABEL_40:
  if (v11 - 1 < 0xFFFFFFFFFFFFFFFELL)
  {
    uint64_t v29 = (os_log_s *)swift::runtime::trace::ScanLog;
    if (os_signpost_enabled((os_log_t)swift::runtime::trace::ScanLog))
    {
      *(_DWORD *)uint64_t v32 = 134217984;
      *(void *)&v32[4] = v25;
      _os_signpost_emit_with_name_impl( &swift_runtimeSupportsNoncopyableTypes,  v29,  OS_SIGNPOST_INTERVAL_END,  v11,  "section_scan",  "result=%p",  v32,  0xCu);
    }
  }

  do
    uint64_t v30 = __ldxr(v16);
  while (__stlxr(v30 - 1, v16));
  return v25;
}

      *(void *)uint64_t v16 = v18;
      *((void *)v16 + 1) = a2[1];
      *result += 2;
    }

    a2 += 2;
  }

  return result;
}

  if (!v7) {
    return 0LL;
  }
  uint64_t v10 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v10 || v10 + 24 > *((void *)this + 2))
  {
    uint64_t v15 = 2LL * *((void *)this + 4);
    if (v15 <= 0x20) {
      uint64_t v15 = 32LL;
    }
    *((void *)this + 4) = v15;
    uint64_t v16 = v15 + 8;
    unsigned int v17 = malloc(v15 + 8);
    uint64_t v18 = (char *)v17 + v16;
    char *v17 = *((void *)this + 3);
    uint64_t v10 = ((unint64_t)v17 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = v18;
    *((void *)this + 3) = v17;
  }

  *((void *)this + 1) = v10 + 24;
  *(_WORD *)(v10 + 16) = 334;
  *(_BYTE *)(v10 + 18) = 0;
LABEL_22:
  swift::Demangle::__runtime::Node::addChild((unsigned int *)v10, v7, this, a4, a5);
  return v10;
}

  uint64_t v23 = memchr(__s, 32, __n);
  if (v23) {
    uint64_t v24 = v23 - v12 != -1;
  }
  else {
    uint64_t v24 = 0;
  }
  if (!a6) {
    goto LABEL_29;
  }
LABEL_23:
  uint64_t v25 = v17;
  if (*((_BYTE *)v17 + 18) == 5) {
    uint64_t v25 = (uint64_t *)*v17;
  }
  if (*(_WORD *)(v25[1] + 16) != 137) {
    goto LABEL_29;
  }
  if (*(_BYTE *)(a1 + 33)) {
    uint64_t v24 = 1;
  }
  uint64_t v26 = 1;
LABEL_30:
  if (a5) {
    uint64_t v27 = 1;
  }
  else {
    uint64_t v27 = v24;
  }
  if (a4 && (v27 & 1) != 0) {
    return (swift::Demangle::__runtime::Node *)v17;
  }
  size_t v28 = *((unsigned __int8 *)v17 + 18);
  uint64_t v29 = v17;
  Swift::Int v84 = v26;
  uint64_t v87 = v19;
  if (v28 == 5 && *((_DWORD *)v17 + 2))
  {
    uint64_t v29 = (uint64_t *)*v17;
LABEL_39:
    uint64_t v30 = *v29;
    goto LABEL_41;
  }

  uint64_t v30 = 0LL;
LABEL_41:
  Swift::String::Index v31 = a9;
  Swift::String v85 = v24;
  Swift::Int v86 = a4;
  if (!*(_BYTE *)(a1 + 25))
  {
    uint64_t v34 = 0LL;
    int64_t v37 = __na;
    if ((a6 & 1) != 0) {
      goto LABEL_93;
    }
    goto LABEL_90;
  }

  uint64_t v32 = a5;
  Swift::Bool v33 = (swift::Demangle::__runtime::Node *)v30;
  if (*(_WORD *)(v30 + 16) == 153)
  {
    uint64_t v35 = *(_BYTE **)v30;
    uint64_t v34 = *(swift::Demangle::__runtime::Node **)(v30 + 8);
    if (v34 == (swift::Demangle::__runtime::Node *)3)
    {
      if (*(_WORD *)v35 == 24415 && v35[2] == 67)
      {
        uint64_t v41 = *(unsigned __int8 *)(a1 + 42);
        goto LABEL_74;
      }

      if (*(void *)(a1 + 56) != 3LL) {
        goto LABEL_67;
      }
    }

    else if (v34 == (swift::Demangle::__runtime::Node *)5)
    {
      if (*(_DWORD *)v35 == 1718187859 && v35[4] == 116)
      {
        uint64_t v41 = *(unsigned __int8 *)(a1 + 41);
        goto LABEL_74;
      }

      if (*(void *)(a1 + 56) != 5LL) {
        goto LABEL_67;
      }
    }

    else
    {
      if (v34 != *(swift::Demangle::__runtime::Node **)(a1 + 56))
      {
LABEL_62:
        if (*(void *)v35 != 0x655F62646C6C5F5FLL || *((_DWORD *)v35 + 2) != 1601335416) {
          goto LABEL_67;
        }
        uint64_t v41 = *(unsigned __int8 *)(a1 + 40);
LABEL_74:
        if (v41) {
          uint64_t v42 = v24;
        }
        else {
          uint64_t v42 = 1;
        }
        if (v41) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = 0LL;
        }
        if ((v42 & 1) != 0) {
          goto LABEL_69;
        }
        goto LABEL_81;
      }

      if (!v34)
      {
LABEL_69:
        a5 = v32;
        goto LABEL_89;
      }
    }

    uint64_t v39 = memcmp(*(const void **)v30, *(const void **)(a1 + 48), *(void *)(v30 + 8));
    uint64_t v24 = v85;
    if (!v39)
    {
      uint64_t v34 = 0LL;
      goto LABEL_69;
    }

    goto LABEL_62;
  }

      uint64_t v14 = v4;
      if (v13 >= 2) {
        uint64_t v14 = *(swift::Demangle::__runtime::Node **)v4;
      }
      uint64_t v15 = (swift::Demangle::__runtime::Node *)*((void *)v14 + v8);
LABEL_20:
      if (*(_DWORD *)a4) {
        return this;
      }
      uint64_t v16 = *(_DWORD *)(v5 + 12736);
      unsigned int v17 = *(unsigned int *)(v5 + 12740);
      uint64_t v11 = *(char **)(v5 + 12728);
      if (v16 >= v17)
      {
        uint64_t v18 = *(void **)(v5 + 12744);
        unint64_t v19 = (char *)v18[1];
        if (&v11[v17] != v19)
        {
          unsigned int v20 = v18[2];
          goto LABEL_25;
        }

        uint64_t v21 = (unint64_t)&v11[v17 + 1];
        unsigned int v20 = v18[2];
        if (v21 <= v20)
        {
          v18[1] = v21;
          LODWORD(v24) = 1;
        }

        else
        {
LABEL_25:
          uint64_t v22 = v4;
          uint64_t v23 = v9;
          else {
            uint64_t v24 = (2 * v17);
          }
          uint64_t v25 = v24 + v17;
          if (!v19 || (unint64_t)&v19[v25] > v20)
          {
            uint64_t v26 = 2LL * v18[4];
            if (v26 <= v25 + 1) {
              uint64_t v26 = v25 + 1;
            }
            v18[4] = v26;
            uint64_t v27 = v26 + 8;
            this = (uint64_t *)malloc(v26 + 8);
            size_t v28 = (char *)this + v27;
            *this = v18[3];
            unint64_t v19 = (char *)(this + 1);
            v18[2] = v28;
            v18[3] = this;
          }

          v18[1] = &v19[v25];
          if ((_DWORD)v17)
          {
            this = (uint64_t *)memcpy(v19, *(const void **)(v5 + 12728), v17);
            LODWORD(v17) = *(_DWORD *)(v5 + 12740);
            uint64_t v16 = *(_DWORD *)(v5 + 12736);
          }

          uint64_t v9 = v23;
          BOOL v4 = v22;
          a4 = v29;
          *(void *)(v5 + 12728) = v19;
          uint64_t v11 = v19;
        }

        *(_DWORD *)(v5 + 12740) = v17 + v24;
        uint64_t v10 = v30;
      }

      *(_DWORD *)(v5 + 12736) = v16 + 1;
      v11[v16] = 95;
      if (v10 == ++v8) {
        goto LABEL_36;
      }
    }

    if ((_DWORD)v12 != 2) {
      goto LABEL_19;
    }
    uint64_t v12 = 2LL;
LABEL_14:
    if (v12 <= v8) {
      goto LABEL_19;
    }
    goto LABEL_15;
  }

LABEL_21:
  *unint64_t v1 = v6;
  return result;
}

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v21, 0LL);
    swift_bridgeObjectRelease_n(0xE000000000000000LL, 6LL);
    v190 = 0LL;
    v191 = 0LL;
    uint64_t v49 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 0LL, (uint64_t)&v190, 0LL);
    _StringGuts.appendInPlace(_:isASCII:)(v49, v50, 1);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    uint64_t v44 = *((void *)&v193 + 1);
    uint64_t v18 = v193;
  }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    __break(1u);
  }

  return result;
}

  if (a4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  return a1(a3, a4, &v13);
}

    unsigned int v8 = (v13 - 1) & v13;
    uint64_t v11 = __clz(__rbit64(v13)) + (v4 << 6);
LABEL_22:
    uint64_t v15 = 8 * v11;
    uint64_t v16 = *(void *)(*(void *)(v3 + 56) + v15);
    uint64_t result = specialized __RawDictionaryStorage.find<A>(_:)(*(void *)(*(void *)(v3 + 48) + v15));
    if ((v17 & 1) == 0 || *(void *)(*(void *)(a2 + 56) + 8 * result) != v16) {
      return 0LL;
    }
  }

  uint64_t v14 = v12 + 3;
  if (v14 >= v9) {
    return 1LL;
  }
  uint64_t v13 = *(void *)(v5 + 8 * v14);
  if (v13)
  {
    BOOL v4 = v14;
    goto LABEL_21;
  }

  while (1)
  {
    BOOL v4 = v14 + 1;
    if (__OFADD__(v14, 1LL)) {
      break;
    }
    if (v4 >= v9) {
      return 1LL;
    }
    uint64_t v13 = *(void *)(v5 + 8 * v4);
    ++v14;
    if (v13) {
      goto LABEL_21;
    }
  }

    unsigned int v8 = 0LL;
    uint64_t v42 = 0u;
    uint64_t v43 = 0u;
    uint64_t v40 = 0u;
    uint64_t v41 = 0u;
    uint64_t v39 = 0u;
  }

  uint64_t v15 = *(void *)(v29 + 8 * v17);
  if (v15)
  {
    v14 += 2LL;
    goto LABEL_9;
  }

  while (1)
  {
    uint64_t v14 = v17 + 1;
    if (__OFADD__(v17, 1LL)) {
      break;
    }
    if (v14 >= v30)
    {
      uint64_t v10 = v30 - 1;
      goto LABEL_21;
    }

    uint64_t v15 = *(void *)(v29 + 8 * v14);
    ++v17;
    if (v15) {
      goto LABEL_9;
    }
  }

    uint64_t v39 = (v19 - 1) & v19;
    uint64_t v40 = v20;
  }

  uint64_t v21 = v16 + 4;
  if (v16 + 4 >= v35)
  {
LABEL_25:
    uint64_t v34 = swift_retain((unint64_t *)a1, v13, v14, v15);
    outlined consume of [A : B].Iterator._Variant<A, B>((uint64_t)v34);
LABEL_26:
    swift_release(a1);
    swift_release((uint64_t)v5);
    return (unint64_t)v5;
  }

  unint64_t v19 = *(void *)(v38 + 8 * v21);
  if (v19)
  {
    unsigned int v20 = v16 + 4;
    goto LABEL_21;
  }

  while (1)
  {
    unsigned int v20 = v21 + 1;
    if (__OFADD__(v21, 1LL)) {
      break;
    }
    if (v20 >= v35) {
      goto LABEL_25;
    }
    unint64_t v19 = *(void *)(v38 + 8 * v20);
    ++v21;
    if (v19) {
      goto LABEL_21;
    }
  }

              uint64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v10, object);
              uint64_t v27 = (v25 & 1) == 0 && v24 > 6;
              if ((v21 & 0x2000000000000000LL) != 0
                && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
              {
                if (v27)
                {
LABEL_49:
                  swift_bridgeObjectRelease_n(0xE700000000000000LL, 6LL);
                  v288 = xmmword_1817FFD20;
                  uint64_t v45 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 7LL, (uint64_t)&v288, 7LL);
                  _StringGuts.appendInPlace(_:isASCII:)(v45, v46, 1);
                  swift_bridgeObjectRelease(0xE700000000000000LL);
                  goto LABEL_78;
                }

  v150 = v181;
  v151 = v197;
  ((void (*)(char *, char *, uint64_t))v186)(v181, &v203[*(int *)(v195 + 44)], v197);
  (*(void (**)(char *, uint64_t))(v188 + 8))(v192, v189);
  unint64_t v7 = v199;
  if (((unsigned int (*)(char *, uint64_t, unint64_t))TupleTypeMetadata2)(v150, 1LL, v199) == 1)
  {
    v138(v54, v137);
    (*(void (**)(char *, uint64_t))(v191 + 8))(v150, v151);
    unint64_t v96 = v209;
    uint64_t v102 = v210;
    BOOL v76 = (uint64_t)v211;
    unint64_t v152 = v196;
    goto LABEL_24;
  }

  (*(void (**)(char *, char *, uint64_t))(v193 + 32))(v180, v150, v7);
  unint64_t AssociatedConformanceWitness = (unint64_t)v138;
  v153 = v54;
  unint64_t v154 = v208;
  v155 = v213;
  (*(void (**)(char *, uint64_t, uint64_t))(v208 + 16))(v97, v212, v213);
  v156 = v190;
  (*(void (**)(char *, char *, char *))(v198 + 32))(v190, v153, v137);
  BOOL v76 = (uint64_t)v211;
  uint64_t v157 = (void (*)(char *, void))(*((uint64_t (**)(char *, char *, uint64_t, char *))v211 + 10))( v214,  v156,  v155,  v211);
  char v101 = v206;
  v158 = v97;
  unint64_t v97 = v205;
  (*(void (**)(char *))(v207 + 16))(v205);
  v157(v214, 0LL);
  ((void (*)(char *, char *))AssociatedConformanceWitness)(v156, v137);
  (*(void (**)(char *, uint64_t))(v154 + 8))(v158, v155);
  unint64_t v96 = v209;
  unint64_t v70 = (uint64_t)v182;
  (*((void (**)(char *, const char *))v209 + 8))(v101, v209);
  v159 = v180;
  v160 = (*((uint64_t (**)(uint64_t, char *, char *, const char *))v96 + 19))(v70, v180, v101, v96);
  v161 = *(void (**)(uint64_t, uint64_t))(v193 + 8);
  v161(v70, v7);
  (*(void (**)(char *, char *))(v207 + 8))(v97, v101);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v161)(v159, v7);
  uint64_t v102 = v210 + v160;
  unint64_t v152 = v196;
  if (!__OFADD__(v210, v160))
  {
LABEL_24:
    if ((static FlattenSequence<>.Index.< infix(_:_:)(v194, v152, v213, v76, v96) & 1) == 0) {
      return v102;
    }
    v163 = __OFSUB__(0LL, v102);
    uint64_t v102 = -v102;
    if (!v163) {
      return v102;
    }
    __break(1u);
    goto LABEL_28;
  }

  __break(1u);
  return result;
}

  v634 = (char *)v131;
  v164 = v648;
  uint64_t v165 = v646;
  v166 = swift_getAssociatedConformanceWitness( (uint64_t)v648,  (uint64_t)v69,  (uint64_t)v646,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v167 = *(void (**)(uint64_t *, uint64_t))(v166 + 8);
  v168 = v647;
  v633 = (char *)v166;
  v632 = v167;
  ((void (*)(uint64_t *, uint64_t, void))v167)(&qword_18180BE70, 512LL, v165);
  v169 = (float *)v650;
  v625 = (char *)*((void *)v164 + 3);
  ((void (*)(unsigned int (*)(void), unint64_t *, const char *))v625)(v168, v69, v164);
  v170 = *(void *)(v636 + 8);
  v171 = *(void (**)(uint64_t, float *, unint64_t *, uint64_t))(v170 + 24);
  v172 = v637;
  v171(v130, v169, v69, v170);
  ((void (*)(float *, unint64_t *))v149)(v169, v69);
  v173 = v656;
  if ((((uint64_t (*)(unint64_t *, char *))v656)(v69, v67) & 1) == 0)
  {
    v191 = ((uint64_t (*)(unint64_t *, char *))v173)(v69, v67);
    unint64_t v174 = ((uint64_t (*)(unint64_t *, char *))v634)(v69, v67);
    if ((v191 & 1) != 0)
    {
      if (v174 > 64) {
        goto LABEL_34;
      }
      v228 = v647;
      v632(&qword_18180BE68, 256LL);
      ((void (*)(unsigned int (*)(void), unint64_t *, const char *))v625)( v228,  v69,  v648);
      LOBYTE(v228) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4)
                                                                                                + 8LL)
                                                                                    + 16LL))( v172,  v169,  v69);
      ((void (*)(float *, unint64_t *))v149)(v169, v69);
      v229 = v606;
      (*(void (**)(char *, char *, unint64_t *))(v655 + 32))(v606, v172, v69);
      if ((v228 & 1) != 0)
      {
        ((void (*)(char *, unint64_t *))v149)(v229, v69);
        goto LABEL_79;
      }

      v207 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
      v208 = v229;
    }

    else
    {
      if (v174 >= 64)
      {
        v230 = v605;
        (*(void (**)(char *, char *, unint64_t *))(v655 + 32))(v605, v172, v69);
        ((void (*)(char *, unint64_t *))v149)(v230, v69);
        goto LABEL_81;
      }

      v207 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
      v208 = v172;
    }

    ((void (*)(char *, unint64_t *))v149)(v208, v69);
    if (v207 >= -149) {
      goto LABEL_81;
    }
    goto LABEL_79;
  }

  unint64_t v174 = ((uint64_t (*)(unint64_t *, char *))v634)(v69, v67);
  if (v174 < 64)
  {
    v177 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
    ((void (*)(char *, unint64_t *))v149)(v172, v69);
    if (v177 > -150) {
      goto LABEL_81;
    }
LABEL_79:
    ((void (*)(uint64_t, unint64_t *))v149)(v130, v69);
    if (((*(uint64_t (**)(uint64_t))(v651 + 168))(v654) & 1) == 0)
    {
      uint64_t result = 0LL;
      *v643 = 0;
      return result;
    }

    uint64_t result = 0LL;
    v190 = 0x80000000;
    goto LABEL_89;
  }

  v181 = v758;
  if ((v171 & 1) == 0) {
    goto LABEL_37;
  }
LABEL_22:
  v212 = v775;
  (*(void (**)(uint64_t, uint64_t))(v775 + 160))(v180, v775);
  ((void (*)(uint64_t, uint64_t))v750)(v180, v212);
  v213 = v757;
  v214 = v755;
  v215 = swift_getAssociatedConformanceWitness( (uint64_t)v757,  (uint64_t)v125,  v755,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v216 = *(char **)(v215 + 8);
  v217 = v756;
  v750 = (char *)v215;
  v730 = v216;
  ((void (*)(uint64_t *, uint64_t, unint64_t))v216)(&qword_18180BE70, 512LL, v214);
  v721 = (char *)*((void *)v213 + 3);
  ((void (*)(char *, unint64_t *, const char *))v721)(v217, v125, v213);
  v218 = v170;
  v219 = *(void **)(v733[1] + 24);
  v220 = v742;
  v720 = v733[1];
  v719 = (void (*)(unint64_t, char *, unint64_t *, unint64_t))v219;
  ((void (*)(uint64_t, char *, unint64_t *))v219)(v218, v169, v125);
  v221 = *(void (**)(char *, unint64_t *))(v777 + 8);
  v221(v169, v125);
  v222 = v769;
  LODWORD(v213) = ((uint64_t (*)(unint64_t *, uint64_t))v769)(v125, v168);
  v223 = v774;
  v224 = ((uint64_t (*)(uint64_t))v762)(v167);
  v225 = v167;
  v766 = (char *)v221;
  if (((v213 ^ v224) & 1) != 0)
  {
    v226 = ((uint64_t (*)(unint64_t *, uint64_t))v222)(v125, v168);
    v227 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v168);
    v228 = v768;
    v758 = v167;
    v229 = v223;
    v230 = ((uint64_t (*)(uint64_t, char **))v761)(v167, v223);
    v231 = v770;
    v232 = v228;
    v733 = v125;
    if ((v226 & 1) != 0)
    {
      if (v230 >= v227)
      {
        v298 = v756;
        ((void (*)(void *, uint64_t))v730)(&unk_18180BE68, 256LL);
        v299 = v776;
        v245 = v733;
        ((void (*)(char *, unint64_t *, char *))v721)(v298, v733, v757);
        v300 = v742;
        LOBYTE(v298) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v773 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v742,  v299,  v245);
        v301 = v766;
        ((void (*)(char *, unint64_t *))v766)(v299, v245);
        v302 = v690;
        (*(void (**)(char *, char *, unint64_t *))(v777 + 32))(v690, v300, v245);
        v303 = v772;
        v304 = v695;
        v305 = v758;
        (*(void (**)(char *, char *, uint64_t))(v772 + 16))(v695, v232, v758);
        if ((v298 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t))(v303 + 8))(v304, v305);
          ((void (*)(char *, unint64_t *))v301)(v302, v245);
          v237 = v305;
          v243 = v303;
          v241 = v301;
          v232 = v768;
        }

        else
        {
          v352 = v774;
          v353 = v770;
          ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v774[12])( v302,  v733,  v773,  v305,  v774);
          v354 = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v352[4] + 1) + 16LL))( v353,  v304,  v305);
          v355 = *(void (**)(char *, uint64_t))(v303 + 8);
          v355(v353, v305);
          v355(v304, v305);
          v242 = v352;
          v237 = v305;
          v243 = v303;
          v245 = v733;
          v244 = v773;
          v241 = v301;
          v232 = v768;
          v246 = v769;
          if ((v354 & 1) == 0) {
            goto LABEL_66;
          }
        }
      }

      else
      {
        v234 = v772;
        v233 = v773;
        v235 = v742;
        v236 = v770;
        v237 = v758;
        (*(void (**)(char *, char *, uint64_t))(v772 + 16))(v770, v228, v758);
        v238 = v776;
        v239 = v774;
        v240 = v733;
        (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v233 + 96))( v236,  v237,  v774,  v733,  v233);
        LOBYTE(v236) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v233 + 32)
                                                                                                 + 8LL)
                                                                                     + 16LL))( v235,  v238,  v240);
        v241 = v766;
        ((void (*)(char *, unint64_t *))v766)(v238, v240);
        ((void (*)(char *, unint64_t *))v241)(v235, v240);
        v242 = v239;
        v243 = v234;
        v244 = v233;
        v245 = v240;
        v246 = v769;
      }

  v60(v51, a3);
  uint64_t v88 = v229;
  int64_t v89 = v235;
  static FixedWidthInteger._random<A>(using:)(v232, a3, v230, v235, v231, v229);
  uint64_t v90 = &v61[*((int *)TupleTypeMetadata2 + 12)];
  v222 = *(void (**)(char *, char *, uint64_t, uint64_t, uint64_t))(v89 + 120);
  v222(v61, v90, (uint64_t)v237, a3, v89);
  v238 = (char *)v60;
  v60((char *)v88, a3);
  char v91 = v206;
  v226 = *(void (**)(char *, char *, unint64_t *))(v239 + 16);
  v227 = v90;
  v226(v206, v90, v12);
  uint64_t v92 = v241;
  unint64_t v93 = swift_getAssociatedConformanceWitness( v241,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for BinaryInteger,  (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v94 = *(uint64_t (**)(unint64_t *, unint64_t))(v93 + 64);
  LODWORD(v89) = v94(v12, v93);
  uint64_t v95 = v92;
  unint64_t v96 = v228;
  unint64_t v97 = v228(a3, v95);
  v218 = v25;
  v225 = v94;
  if (((v89 ^ v97) & 1) != 0)
  {
    uint64_t v98 = v94(v12, v93);
    v224 = *(uint64_t (**)(unint64_t *, unint64_t))(v93 + 128);
    v198 = v224(v12, v93);
    unint64_t v99 = ((uint64_t (*)(uint64_t, uint64_t))v234)(a3, v241);
    uint64_t v100 = v91;
    if ((v98 & 1) != 0)
    {
      if (v99 >= v198)
      {
        v223 = v93;
        v167 = v213;
        v168 = v212;
        v169 = swift_getAssociatedConformanceWitness( (uint64_t)v213,  (uint64_t)v12,  v212,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v170 = v25;
        v171 = v211;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v169 + 8))( &unk_18180BE68,  256LL,  v168,  v169);
        (*((void (**)(char *, unint64_t *, const char *))v167 + 3))(v171, v12, v167);
        v172 = swift_getAssociatedConformanceWitness( v220,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        LOBYTE(v168) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v172 + 16))( v91,  v170,  v12,  v172);
        v173 = v239;
        unint64_t v174 = *(void (**)(char *, unint64_t *))(v239 + 8);
        v174(v170, v12);
        v175 = v204;
        (*(void (**)(char *, char *, unint64_t *))(v173 + 32))(v204, v91, v12);
        v176 = v200;
        v221(v200, v237, a3);
        if ((v168 & 1) != 0)
        {
          ((void (*)(char *, uint64_t))v238)(v176, a3);
          v174(v175, v12);
          uint64_t v105 = v237;
          uint64_t v25 = v218;
          unint64_t v93 = v223;
        }

        else
        {
          uint64_t v192 = v241;
          v193 = v175;
          unint64_t v93 = v223;
          (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v241 + 96))( v193,  v12,  v223,  a3,  v241);
          uint64_t v194 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v192 + 32) + 8LL) + 16LL))( v49,  v176,  a3);
          v195 = (void (*)(char *, uint64_t))v238;
          ((void (*)(char *, uint64_t))v238)(v49, a3);
          v195(v176, a3);
          uint64_t v105 = v237;
          uint64_t v25 = v218;
          if ((v194 & 1) == 0) {
            goto LABEL_62;
          }
        }
      }

      else
      {
        char v101 = v237;
        v221(v49, v237, a3);
        (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v93 + 96))( v49,  a3,  v241,  v12,  v93);
        uint64_t v102 = swift_getAssociatedConformanceWitness( v220,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
        uint64_t v103 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v102 + 16))( v100,  v25,  v12,  v102);
        uint64_t v104 = *(void (**)(char *, unint64_t *))(v239 + 8);
        v104(v25, v12);
        v104(v100, v12);
        uint64_t v105 = v101;
        if ((v103 & 1) == 0) {
          goto LABEL_62;
        }
      }
    }

    else if (v198 >= v99)
    {
      v223 = v93;
      v177 = v216;
      v178 = v215;
      v179 = swift_getAssociatedConformanceWitness( (uint64_t)v216,  a3,  v215,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v180 = v214;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v179 + 8))( &unk_18180BE68,  256LL,  v178,  v179);
      (*((void (**)(char *, uint64_t, const char *))v177 + 3))(v180, a3, v177);
      v181 = v237;
      LOBYTE(v178) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v241 + 32) + 8LL)
                                                                        + 40LL))( v237,  v49,  a3);
      uint64_t v182 = (void (*)(char *, uint64_t))v238;
      ((void (*)(char *, uint64_t))v238)(v49, a3);
      v183 = v239;
      v184 = v205;
      (*(void (**)(char *, char *, unint64_t *))(v239 + 32))(v205, v100, v12);
      uint64_t v185 = v199;
      v221(v199, v181, a3);
      if ((v178 & 1) == 0)
      {
        v182(v185, a3);
        (*(void (**)(char *, unint64_t *))(v183 + 8))(v184, v12);
        goto LABEL_62;
      }

      uint64_t v186 = v218;
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v223 + 96))(v185, a3, v241, v12);
      v187 = swift_getAssociatedConformanceWitness( v220,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      v188 = v186;
      v189 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v187 + 16))( v184,  v186,  v12,  v187);
      v190 = *(void (**)(char *, unint64_t *))(v183 + 8);
      uint64_t v25 = v188;
      v190(v188, v12);
      v191 = v184;
      unint64_t v93 = v223;
      v190(v191, v12);
      uint64_t v105 = v237;
      if ((v189 & 1) == 0) {
        goto LABEL_62;
      }
    }

    else
    {
      uint64_t v110 = v241;
      (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v241 + 96))( v91,  v12,  v93,  a3,  v241);
      v111 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v110 + 32) + 8LL) + 16LL);
      uint64_t v105 = v237;
      uint64_t v112 = v111(v49, (uint64_t)v237, a3);
      ((void (*)(char *, uint64_t))v238)(v49, a3);
      if ((v112 & 1) == 0) {
        goto LABEL_62;
      }
    }
  }

  else
  {
    v224 = *(uint64_t (**)(unint64_t *, unint64_t))(v93 + 128);
    uint64_t v106 = v224(v12, v93);
    uint64_t v107 = v237;
    if (v106 >= ((uint64_t (*)(uint64_t, uint64_t))v234)(a3, v241))
    {
      v221(v49, v107, a3);
      (*(void (**)(char *, uint64_t, uint64_t, unint64_t *, unint64_t))(v93 + 96))( v49,  a3,  v241,  v12,  v93);
      uint64_t v113 = swift_getAssociatedConformanceWitness( v220,  a3,  (uint64_t)v12,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      uint64_t v109 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v113 + 16))( v91,  v25,  v12,  v113);
      uint64_t v114 = *(void (**)(char *, unint64_t *))(v239 + 8);
      v114(v25, v12);
      v114(v91, v12);
    }

    else
    {
      uint64_t v108 = v241;
      (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v241 + 96))( v91,  v12,  v93,  a3,  v241);
      uint64_t v109 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v108 + 32) + 8LL) + 16LL))( v49,  v107,  a3);
      ((void (*)(char *, uint64_t))v238)(v49, a3);
    }

    uint64_t v105 = v107;
    if ((v109 & 1) == 0) {
      goto LABEL_62;
    }
  }

  v223 = v93;
  v115 = v216;
  int64_t v116 = v215;
  int64_t v117 = swift_getAssociatedConformanceWitness( (uint64_t)v216,  a3,  v215,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  int64_t v118 = *(char **)(v117 + 8);
  char v119 = v214;
  v206 = (char *)v117;
  v205 = v118;
  ((void (*)(void *, uint64_t, unint64_t))v118)(&unk_18180BE68, 256LL, v116);
  uint64_t v120 = v105;
  unint64_t v121 = v201;
  unint64_t v122 = v119;
  uint64_t v123 = v219;
  v204 = (char *)*((void *)v115 + 3);
  ((void (*)(char *, uint64_t, const char *))v204)(v122, a3, v115);
  (*(void (**)(char *, char *, uint64_t))(v235 + 88))(v49, v120, a3);
  unint64_t v124 = v121;
  unint64_t v125 = (void (*)(char *, uint64_t))v238;
  ((void (*)(char *, uint64_t))v238)(v124, a3);
  (*(void (**)(char *, char *, uint64_t))(v241 + 168))(v49, v120, a3);
  v125(v49, a3);
  char v126 = v227;
  while (1)
  {
    v226(v240, v126, v12);
    uint64_t v134 = v223;
    v135 = v225;
    char v136 = v225(v12, v223);
    if (((v136 ^ v96(a3, v241)) & 1) == 0)
    {
      v149 = v224(v12, v134);
      if (v149 < ((uint64_t (*)(uint64_t, uint64_t))v234)(a3, v241))
      {
        unint64_t v127 = v241;
        (*(void (**)(char *, unint64_t *, unint64_t, uint64_t, uint64_t))(v241 + 96))( v240,  v12,  v134,  a3,  v241);
        unint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v127 + 32) + 8LL) + 16LL))( v49,  v123,  a3);
        Swift::String v129 = (void (*)(char *, uint64_t))v238;
        ((void (*)(char *, uint64_t))v238)(v49, a3);
        v130 = v239;
        goto LABEL_35;
      }

      unint64_t v96 = 0LL;
      uint64_t v52 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      uint64_t v53 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
      v52(&v96, &type metadata for Int, v53, a2, v5);
      uint64_t v54 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( v41,  v22,  a2);
LABEL_22:
      uint64_t v55 = v22;
LABEL_45:
      v35(v55, a2);
      return v54 & 1;
    }

    if (v24 >= 64) {
      goto LABEL_12;
    }
LABEL_10:
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v22, a1, a2);
    int64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
    uint64_t v35 = *(void (**)(char *, uint64_t))(v9 + 8);
    v35(v22, a2);
    if (v37) {
      goto LABEL_24;
    }
    goto LABEL_13;
  }

  uint64_t v95 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
  uint64_t v24 = v95(a2, v5);
  if (v24 < 64) {
    goto LABEL_10;
  }
LABEL_12:
  unint64_t v96 = 0LL;
  uint64_t v38 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
  uint64_t v39 = lazy protocol witness table accessor for type Int and conformance Int(v24, v25, v26);
  v38(&v96, &type metadata for Int, v39, a2, v5);
  uint64_t v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( a1,  v22,  a2);
  uint64_t v35 = *(void (**)(char *, uint64_t))(v9 + 8);
  v35(v22, a2);
  if ((v40 & 1) != 0) {
    goto LABEL_13;
  }
LABEL_24:
  if ((v23(a2, v5) & 1) != 0)
  {
    uint64_t v56 = v95(a2, v5);
    if (v56 < 64)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v22, a1, a2);
      uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      v35(v22, a2);
      uint64_t v60 = v93;
      if (v59 == -1) {
        goto LABEL_31;
      }
LABEL_39:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 168))(v94, a1, a2, v5);
      if ((v23(a2, v5) & 1) != 0)
      {
        uint64_t v75 = v95(a2, v5);
        if (v75 < 64)
        {
LABEL_48:
          uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
          uint64_t v51 = v60;
          goto LABEL_49;
        }
      }

      else
      {
        uint64_t v78 = v23(a2, v5);
        uint64_t v75 = v95(a2, v5);
        if ((v78 & 1) == 0)
        {
          if (v75 >= 64)
          {
            unint64_t v96 = 0LL;
            Swift::String v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
            Swift::Int v86 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
            v85(&v96, &type metadata for Int, v86, a2, v5);
            uint64_t v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( v60,  v22,  a2);
            v35(v60, a2);
            goto LABEL_22;
          }

          goto LABEL_48;
        }

        if (v75 <= 64)
        {
          uint64_t v82 = v92;
          uint64_t v83 = swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          Swift::Int v84 = v91;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v83 + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  v83);
          (*((void (**)(char *, uint64_t, const char *))v82 + 3))(v84, a2, v82);
          uint64_t v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8LL) + 32LL))( v60,  v22,  a2);
          v35(v22, a2);
          uint64_t v22 = v88;
          (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v88, v60, a2);
LABEL_52:
          uint64_t v54 = (v49 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5) == 0;
          goto LABEL_22;
        }
      }

      unint64_t v96 = 0LL;
      uint64_t v79 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      uint64_t v80 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
      v79(&v96, &type metadata for Int, v80, a2, v5);
      uint64_t v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( v60,  v22,  a2);
      v35(v22, a2);
      uint64_t v55 = v60;
      goto LABEL_45;
    }
  }

  else
  {
    uint64_t v61 = v23(a2, v5);
    uint64_t v56 = v95(a2, v5);
    if ((v61 & 1) == 0)
    {
      uint64_t v60 = v93;
      if (v56 < 64)
      {
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v22, a1, a2);
        char v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
        v35(v22, a2);
        if (v65 == -1) {
          goto LABEL_31;
        }
      }

      goto LABEL_39;
    }

    if (v56 <= 64)
    {
      uint64_t v66 = v92;
      BOOL v67 = *(void (**)(void *, uint64_t))(swift_getAssociatedConformanceWitness( (uint64_t)v92,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral)
                                                   + 8);
      uint64_t v68 = AssociatedTypeWitness;
      unint64_t v69 = v9;
      unint64_t v70 = v91;
      uint64_t v87 = v68;
      v67(&unk_18180BE68, 256LL);
      uint64_t v71 = v70;
      uint64_t v9 = v69;
      (*((void (**)(char *, uint64_t, const char *))v66 + 3))(v71, a2, v66);
      uint64_t v72 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8LL) + 32LL))( a1,  v22,  a2);
      v35(v22, a2);
      unsigned int v73 = v90;
      (*(void (**)(char *, uint64_t, uint64_t))(v69 + 16))(v90, a1, a2);
      if ((v72 & 1) != 0)
      {
        unint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
        v35(v73, a2);
        uint64_t v60 = v93;
        unint64_t AssociatedTypeWitness = v87;
        if (v74 == -1) {
          goto LABEL_31;
        }
      }

      else
      {
        v35(v73, a2);
        uint64_t v60 = v93;
        unint64_t AssociatedTypeWitness = v87;
      }

      goto LABEL_39;
    }
  }

  unint64_t v96 = -1LL;
  uint64_t v62 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
  Swift::Int v63 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v62(&v96, &type metadata for Int, v63, a2, v5);
  uint64_t v64 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 16) + 8LL) + 8LL))( a1,  v22,  a2);
  v35(v22, a2);
  uint64_t v60 = v93;
  if ((v64 & 1) == 0) {
    goto LABEL_39;
  }
LABEL_31:
  uint64_t v54 = 1;
  return v54 & 1;
}

  *a3 = v11;
  return result;
}

    if ((v30 & 1) != 0)
    {
      uint64_t v27 = 1LL << v5[2].i8[0];
      if (v27 >= 64) {
        specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v27 + 63) >> 6, v5 + 4);
      }
      else {
        v11->i64[0] = -1LL << v27;
      }
      v5[1].i64[0] = 0LL;
    }

    uint64_t result = swift_release((uint64_t)v5);
    unsigned int v3 = v29;
  }

  else
  {
    uint64_t result = swift_release((uint64_t)v5);
  }

  *unsigned int v3 = v9;
  return result;
}

    if ((v30 & 1) != 0)
    {
      uint64_t v27 = 1LL << v5[2].i8[0];
      if (v27 >= 64) {
        specialized UnsafeMutablePointer.assign(repeating:count:)(0LL, (unint64_t)(v27 + 63) >> 6, v5 + 4);
      }
      else {
        v11->i64[0] = -1LL << v27;
      }
      v5[1].i64[0] = 0LL;
    }

    uint64_t result = swift_release((uint64_t)v5);
    unsigned int v3 = v29;
  }

  else
  {
    uint64_t result = swift_release((uint64_t)v5);
  }

  *unsigned int v3 = v9;
  return result;
}

    uint64_t v11 = (v18 - 1) & v18;
    uint64_t v16 = __clz(__rbit64(v18)) + (v14 << 6);
LABEL_8:
    uint64_t result = specialized _NativeSet._unsafeInsertNew(_:)( *(void *)(*(void *)(v2 + 48) + 16 * v16),  *(void *)(*(void *)(v2 + 48) + 16 * v16 + 8),  (uint64_t)v7);
  }

  unint64_t v19 = v17 + 2;
  if (v19 < v12)
  {
    uint64_t v18 = v9[v19];
    if (!v18)
    {
      while (1)
      {
        uint64_t v14 = v19 + 1;
        if (__OFADD__(v19, 1LL)) {
          goto LABEL_28;
        }
        if (v14 >= v12) {
          goto LABEL_22;
        }
        uint64_t v18 = v9[v14];
        ++v19;
        if (v18) {
          goto LABEL_21;
        }
      }
    }

    uint64_t v14 = v19;
    goto LABEL_21;
  }

    uint64_t v11 = (v19 - 1) & v19;
    uint64_t v15 = __clz(__rbit64(v19)) + (v13 << 6);
LABEL_8:
    uint64_t v16 = *(void *)(v2 + 48) + 40 * v15;
    unsigned int v17 = *(_OWORD *)(v16 + 16);
    v22[0] = *(_OWORD *)v16;
    v22[1] = v17;
    uint64_t v23 = *(void *)(v16 + 32);
    specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)v22, (uint64_t)v7);
  }

  unsigned int v20 = v18 + 2;
  if (v20 < v12)
  {
    unint64_t v19 = v9[v20];
    if (!v19)
    {
      while (1)
      {
        uint64_t v13 = v20 + 1;
        if (__OFADD__(v20, 1LL)) {
          goto LABEL_28;
        }
        if (v13 >= v12) {
          goto LABEL_22;
        }
        unint64_t v19 = v9[v13];
        ++v20;
        if (v19) {
          goto LABEL_21;
        }
      }
    }

    uint64_t v13 = v20;
    goto LABEL_21;
  }

    uint64_t v15 = (v22 - 1) & v22;
    unsigned int v20 = __clz(__rbit64(v22)) + (v18 << 6);
LABEL_8:
    uint64_t result = a3(*(void *)(*(void *)(v6 + 48) + 8 * v20), v11);
  }

  uint64_t v23 = v21 + 2;
  if (v23 < v16)
  {
    uint64_t v22 = v13[v23];
    if (!v22)
    {
      while (1)
      {
        uint64_t v18 = v23 + 1;
        if (__OFADD__(v23, 1LL)) {
          goto LABEL_28;
        }
        if (v18 >= v16) {
          goto LABEL_22;
        }
        uint64_t v22 = v13[v18];
        ++v23;
        if (v22) {
          goto LABEL_21;
        }
      }
    }

    uint64_t v18 = v23;
    goto LABEL_21;
  }

    uint64_t v10 = (v23 - 1) & v23;
    uint64_t v18 = __clz(__rbit64(v23)) + (v16 << 6);
LABEL_8:
    unint64_t v19 = (unint64_t *)(*(void *)(v2 + 48) + 16 * v18);
    unsigned int v20 = *v19;
    uint64_t v21 = v19[1];
    swift_bridgeObjectRetain(v21, v13, v14, v15);
    uint64_t result = specialized _NativeSet._unsafeInsertNew(_:)(v20, v21, (uint64_t)v6);
  }

  uint64_t v24 = v22 + 2;
  if (v24 >= v11)
  {
LABEL_22:
    swift_release_n(v2, 2LL);
    goto LABEL_23;
  }

  uint64_t v23 = *(void *)(v8 + 8 * v24);
  if (v23)
  {
    uint64_t v16 = v24;
    goto LABEL_21;
  }

  while (1)
  {
    uint64_t v16 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v16 >= v11) {
      goto LABEL_22;
    }
    uint64_t v23 = *(void *)(v8 + 8 * v16);
    ++v24;
    if (v23) {
      goto LABEL_21;
    }
  }

    uint64_t v11 = (v17 - 1) & v17;
    uint64_t v15 = __clz(__rbit64(v17)) + (v13 << 6);
LABEL_8:
    outlined init with copy of AnyHashable(*(void *)(v2 + 48) + 40 * v15, (uint64_t)v19);
    specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)v19, (uint64_t)v7);
  }

  uint64_t v18 = v16 + 2;
  if (v18 >= v12)
  {
LABEL_22:
    swift_release_n(v2, 2LL);
    goto LABEL_24;
  }

  unsigned int v17 = *(void *)(v9 + 8 * v18);
  if (v17)
  {
    uint64_t v13 = v18;
    goto LABEL_21;
  }

  while (1)
  {
    uint64_t v13 = v18 + 1;
    if (__OFADD__(v18, 1LL)) {
      break;
    }
    if (v13 >= v12) {
      goto LABEL_22;
    }
    unsigned int v17 = *(void *)(v9 + 8 * v13);
    ++v18;
    if (v17) {
      goto LABEL_21;
    }
  }

    uint64_t v15 = (v22 - 1) & v22;
    unsigned int v20 = __clz(__rbit64(v22)) + (v18 << 6);
LABEL_8:
    uint64_t result = a3(*(void *)(*(void *)(v6 + 48) + 8 * v20), v11);
  }

  uint64_t v23 = v21 + 2;
  if (v23 >= v16)
  {
LABEL_22:
    swift_release(v6);
    goto LABEL_23;
  }

  uint64_t v22 = *(void *)(v13 + 8 * v23);
  if (v22)
  {
    uint64_t v18 = v23;
    goto LABEL_21;
  }

  while (1)
  {
    uint64_t v18 = v23 + 1;
    if (__OFADD__(v23, 1LL)) {
      break;
    }
    if (v18 >= v16) {
      goto LABEL_22;
    }
    uint64_t v22 = *(void *)(v13 + 8 * v18);
    ++v23;
    if (v22) {
      goto LABEL_21;
    }
  }

        Swift::UInt64 rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_28:
        *(_BYTE *)(a2 + v9++) = v23;
        if (a3 == v9)
        {
          uint64_t v9 = a3;
          goto LABEL_31;
        }
      }
    }
  }

  uint64_t v9 = 0LL;
  Swift::UInt64 rawBits = position._rawBits;
LABEL_31:
  a1->_Swift::UInt64 rawBits = position._rawBits;
  a1[1]._Swift::UInt64 rawBits = a5;
  a1[2]._Swift::UInt64 rawBits = a6;
  a1[3]._Swift::UInt64 rawBits = a7;
  a1[4]._Swift::UInt64 rawBits = rawBits;
  return v9;
}

    unint64_t v19 = 0LL;
    uint64_t v39 = 0LL;
    int64_t v37 = 0u;
    uint64_t v38 = 0u;
  }

  uint64_t v23 = *(void *)(v10 + 8 * v24);
  if (v23)
  {
    uint64_t v21 = v17 + 3;
    goto LABEL_9;
  }

  while (1)
  {
    uint64_t v21 = v24 + 1;
    if (__OFADD__(v24, 1LL)) {
      break;
    }
    if (v21 >= v31)
    {
      uint64_t v22 = v31 - 1;
      goto LABEL_21;
    }

    uint64_t v23 = *(void *)(v10 + 8 * v21);
    ++v24;
    if (v23) {
      goto LABEL_9;
    }
  }

  uint64_t v45 = 0LL;
  uint64_t v46 = a2 - 8;
  if (a2 > 8)
  {
    uint64_t v47 = 0LL;
    uint64_t v48 = &a1->u8[8];
    do
    {
      uint64_t v49 = *v48++;
      v45 |= (unint64_t)v49 << v47;
      v47 += 8LL;
      --v46;
    }

    while (v46);
  }

  return (uint64_t)v2;
}

    unsigned int v5 = 1LL;
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xC0uLL,  0);
  }

  v13.value._Swift::UInt64 rawBits = 0LL;
  v13.is_nil = 1;
  return v13;
}

      unint64_t v19 = v14;
      if (v14 <= a2) {
        goto LABEL_18;
      }
    }
  }

  if ((a4 & 0x1000000000000000LL) != 0)
  {
    unint64_t v7 = (_BYTE *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    if (a2 < a1) {
      goto LABEL_5;
    }
LABEL_181:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGraphemeBreaking.swift",  34LL,  2,  0x2A1uLL,  0);
  }

  unint64_t v7 = _StringObject.sharedUTF8.getter(a4, a5);
  if (a2 >= v6) {
    goto LABEL_181;
  }
LABEL_5:
  unsigned int v8 = v7 - 1;
  uint64_t v9 = v6;
  do
    uint64_t v10 = v8[v9--] & 0xC0;
  while (v10 == 128);
  uint64_t v11 = _decodeScalar(_:startingAt:)((uint64_t)v7, a2, v9);
  if (v9 <= a2)
  {
    unint64_t v19 = v9;
    return v6 - v19;
  }

  uint64_t v13 = v11;
  while (1)
  {
    uint64_t v55 = v13;
    unint64_t v19 = v9--;
    if ((v7[v9] & 0xC0) == 0x80)
    {
      uint64_t v56 = v19;
      do
        uint64_t v57 = v7[v56-- - 2] & 0xC0;
      while (v57 == 128);
      uint64_t v9 = v56 - 1;
    }

    uint64_t v58 = _decodeScalar(_:startingAt:)((uint64_t)v7, v12, v9);
    uint64_t v13 = v58;
    if (v58 == 13 && v55 == 10) {
      goto LABEL_99;
    }
    uint64_t v59 = vdupq_n_s32(v58);
    if (((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32( (uint32x4_t)xmmword_1817FFEC0,  (uint32x4_t)vaddq_s32(v59, (int32x4_t)xmmword_1817FFEB0)))) & 1) != 0 || v58 - 65281 < 0x9D || (vaddvq_s32((int32x4_t)vandq_s8( (int8x16_t)vcgtq_u32( (uint32x4_t)vaddq_s32(v59, (int32x4_t)xmmword_1817FFE80),  (uint32x4_t)xmmword_1817FFE90),  (int8x16_t)xmmword_1817FFEA0)) & 0xF) != 0 || v58 <= 0x2FF)
      && ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32( (uint32x4_t)xmmword_1817FFE70,  (uint32x4_t)vaddq_s32( vdupq_n_s32(v55),  (int32x4_t)xmmword_1817FFE60)))) & 1) != 0 || v55 - 8208 < 0x1A || v55 - 12288 < 0x2A || v55 - 65281 < 0x9D || v55 - 12439 > 0xFFFFFFA9 || v55 < 0x300 || v55 - 42192 > 0xFFFF8F2F))
    {
      return v6 - v19;
    }

    uint64_t v60 = Unicode._GraphemeBreakProperty.init(from:)(v58);
    uint64_t v61 = Unicode._GraphemeBreakProperty.init(from:)(v55);
    if (!v60) {
      break;
    }
    if (v60 == 1) {
      return v6 - v19;
    }
    switch(v61)
    {
      case 1u:
        return v6 - v19;
      case 2u:
      case 9u:
      case 0xCu:
        break;
      case 4u:
        switch(v60)
        {
          case 4u:
          case 7u:
            goto LABEL_99;
          case 8u:
            goto LABEL_178;
          case 0xCu:
            goto LABEL_142;
          default:
            goto LABEL_153;
        }

      case 5u:
        switch(v60)
        {
          case 4u:
          case 7u:
            goto LABEL_99;
          case 8u:
            goto LABEL_178;
          case 0xCu:
            goto LABEL_142;
          default:
            goto LABEL_153;
        }

      case 6u:
        switch(v60)
        {
          case 4u:
          case 7u:
            goto LABEL_99;
          case 8u:
            goto LABEL_178;
          case 0xCu:
            goto LABEL_142;
          default:
            goto LABEL_153;
        }

      case 0xAu:
        uint64_t v68 = v60;
        if (v60 > 0xCu) {
          goto LABEL_153;
        }
        if (((1 << v60) & 0xCE0) == 0) {
          goto LABEL_141;
        }
        break;
      case 0xBu:
        uint64_t v68 = v60;
        if (v60 > 0xCu) {
          goto LABEL_153;
        }
        if (((1 << v60) & 0x8B0) != 0) {
          break;
        }
LABEL_141:
        if (v68 == 12) {
          goto LABEL_142;
        }
        if (v68 != 8) {
          goto LABEL_153;
        }
        goto LABEL_178;
      default:
        if (v60 == 7) {
          break;
        }
        if (v60 == 8)
        {
          unint64_t v69 = v19;
          if (v61 != 8) {
            goto LABEL_178;
          }
          do
            unint64_t v70 = v8[v69--] & 0xC0;
          while (v70 == 128);
          _decodeScalar(_:startingAt:)((uint64_t)v7, v12, v69);
          uint64_t v71 = 0LL;
          while (1)
          {
            uint64_t v72 = specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( v69,  a2,  (uint64_t)v7);
            if ((v73 & 1) != 0) {
              break;
            }
            unint64_t v69 = v12;
            uint64_t v42 = __OFADD__(v71++, 1LL);
            if (v42) {
              goto LABEL_182;
            }
          }

          if ((v71 & 1) != 0) {
            return v6 - v19;
          }
        }

        else
        {
          if (v60 == 12)
          {
            uint64_t v62 = v19;
            if (v61 == 3)
            {
              do
                Swift::Int v63 = v8[v62--] & 0xC0;
              while (v63 == 128);
              _decodeScalar(_:startingAt:)((uint64_t)v7, v12, v62);
              do
              {
                uint64_t v64 = specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)( v62,  a2,  (uint64_t)v7);
                if ((v66 & 1) != 0) {
                  return v6 - v19;
                }
                uint64_t v62 = v65;
                BOOL v67 = Unicode._GraphemeBreakProperty.init(from:)(v64);
              }

              while (v67 == 2);
              if (v67 != 3) {
                return v6 - v19;
              }
              break;
            }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xC0uLL,  0);
  }

  v13.value._Swift::UInt64 rawBits = 0LL;
  v13.is_nil = 1;
  return v13;
}

  swift_bridgeObjectRelease(a3);
  return a1 - rawBits;
}

    LODWORD(v32) = 0;
    uint64_t v30 = 167LL;
    goto LABEL_23;
  }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }

  if (a4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  return a1(a3, a4, &v13);
}

  if (v13) {
    goto LABEL_13;
  }
LABEL_24:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  unint64_t v19 = v18 < v12;
  if (v17 != v10) {
    unint64_t v19 = v17 < v10;
  }
  if (v19) {
    goto LABEL_28;
  }
LABEL_27:
  *a2 = v12;
}

  if (a2 >= 9)
  {
    uint64_t v47 = 0LL;
    uint64_t v48 = 0LL;
    uint64_t v49 = &a1->u8[8];
    do
    {
      uint64_t v50 = *v49++;
      v47 |= (unint64_t)v50 << v48;
      v48 += 8LL;
      --v4;
    }

    while (v4);
  }

  return (uint64_t)v3;
}

                  LOBYTE(v16) = 0;
                  goto LABEL_22;
                }

                LOBYTE(v16) = 3;
              }
            }
          }
        }

      __asm { BR              X11 }
    }

    if (v13 >= 0x100) {
      unsigned int v6 = 2;
    }
    else {
      unsigned int v6 = v13 > 1;
    }
  }

  if (v9 < a2) {
    goto LABEL_14;
  }
  goto LABEL_21;
}

  *a3 = v13;
  return result;
}

    uint64_t v10 = (void *)(v13 & 0xFFFFFFFFFFFFFFF0LL);
    ++*(void *)(v13 & 0xFFFFFFFFFFFFFFF0LL);
    os_unfair_lock_unlock(lock);
    os_unfair_lock_lock((os_unfair_lock_t)(v13 & 0xFFFFFFFFFFFFFFF0LL | 8));
    os_unfair_lock_unlock((os_unfair_lock_t)(v13 & 0xFFFFFFFFFFFFFFF0LL | 8));
  }

  if (v11 > 62)
  {
    if (v11 != 63)
    {
      if (v11 == 255)
      {
LABEL_52:
        os_unfair_lock_unlock(lock);
        unsigned int v8 = a1[4];
        if ((_DWORD)v14 == 1 || (_DWORD)v14 == 3 || (_DWORD)v14 == 2) {
          goto LABEL_55;
        }
      }

      goto LABEL_60;
    }
  }

  else if (v11)
  {
    if (v11 != 1) {
      goto LABEL_60;
    }
  }

  if ((v13 & 8) != 0)
  {
    if (v9) {
      goto LABEL_52;
    }
    goto LABEL_21;
  }

  uint64_t v15 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
  *(_OWORD *)uint64_t v15 = 0u;
  *(_OWORD *)(v15 + 16) = 0u;
  *(_OWORD *)(v15 + 32) = 0u;
  *(void *)uint64_t v15 = 1LL;
  *(void *)(v15 + 16) = 0LL;
  *(void *)(v15 + 24) = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)(v15 + 8));
  uint64_t v25 = (os_unfair_lock_s *)v15;
  uint64_t v16 = (_OWORD *)(v13 & 0xFFFFFFFFFFFFFFF0LL);
  if ((v13 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    *(_OWORD *)(v15 + 24) = *v16;
    unsigned int v17 = *(void *)((v13 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v13 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    uint64_t v18 = *(void **)(v15 + 16);
    *(void *)(v15 + 16) = v17;
    if (v18) {
      operator delete(v18);
    }
  }

  atomic_store(v13 & 7 | v15 | 8, a1);
  LOBYTE(v26) = 1;
  os_unfair_lock_unlock(lock);
  HIBYTE(v26) = v14;
  if (v16)
  {
    unsigned int v20 = *(void **)((v13 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v13 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    if (v20) {
      operator delete(v20);
    }
    operator delete((void *)(v13 & 0xFFFFFFFFFFFFFFF0LL));
  }

    unsigned int v8 = (void *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
    ++*(void *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
    os_unfair_lock_unlock((os_unfair_lock_t)&SingletonMetadata);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 & 0xFFFFFFFFFFFFFFF0LL | 8));
    os_unfair_lock_unlock((os_unfair_lock_t)(v11 & 0xFFFFFFFFFFFFFFF0LL | 8));
  }

  if (v9 > 62)
  {
    if (v9 != 63)
    {
      if (v9 == 255)
      {
LABEL_52:
        os_unfair_lock_unlock((os_unfair_lock_t)&SingletonMetadata);
        unsigned int v6 = a1[1];
        if ((_DWORD)v12 == 1 || (_DWORD)v12 == 3 || (_DWORD)v12 == 2) {
          goto LABEL_55;
        }
      }

      goto LABEL_60;
    }
  }

  else if (v9)
  {
    if (v9 != 1) {
      goto LABEL_60;
    }
  }

  if ((v11 & 8) != 0)
  {
    if (v7) {
      goto LABEL_52;
    }
    goto LABEL_21;
  }

  uint64_t v13 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
  *(_OWORD *)uint64_t v13 = 0u;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(void *)uint64_t v13 = 1LL;
  *(void *)(v13 + 16) = 0LL;
  *(void *)(v13 + 24) = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)(v13 + 8));
  uint64_t v23 = (os_unfair_lock_s *)v13;
  uint64_t v14 = (_OWORD *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    *(_OWORD *)(v13 + 24) = *v14;
    uint64_t v15 = *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    uint64_t v16 = *(void **)(v13 + 16);
    *(void *)(v13 + 16) = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  atomic_store(v11 & 7 | v13 | 8, a1);
  LOBYTE(v24) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&SingletonMetadata);
  HIBYTE(v24) = v12;
  if (v14)
  {
    uint64_t v18 = *(void **)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    if (v18) {
      operator delete(v18);
    }
    operator delete((void *)(v11 & 0xFFFFFFFFFFFFFFF0LL));
  }

    unsigned int v8 = (void *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
    ++*(void *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476AF0);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 & 0xFFFFFFFFFFFFFFF0LL | 8));
    os_unfair_lock_unlock((os_unfair_lock_t)(v11 & 0xFFFFFFFFFFFFFFF0LL | 8));
  }

  if (v9 > 62)
  {
    if (v9 != 63)
    {
      if (v9 == 255)
      {
LABEL_52:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476AF0);
        unsigned int v6 = a1[1];
        if ((_DWORD)v12 == 1 || (_DWORD)v12 == 3 || (_DWORD)v12 == 2) {
          goto LABEL_55;
        }
      }

      goto LABEL_60;
    }
  }

  else if (v9)
  {
    if (v9 != 1) {
      goto LABEL_60;
    }
  }

  if ((v11 & 8) != 0)
  {
    if (v7) {
      goto LABEL_52;
    }
    goto LABEL_21;
  }

  uint64_t v13 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
  *(_OWORD *)uint64_t v13 = 0u;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(void *)uint64_t v13 = 1LL;
  *(void *)(v13 + 16) = 0LL;
  *(void *)(v13 + 24) = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)(v13 + 8));
  uint64_t v22 = (os_unfair_lock_s *)v13;
  uint64_t v14 = (_OWORD *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    *(_OWORD *)(v13 + 24) = *v14;
    uint64_t v15 = *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    uint64_t v16 = *(void **)(v13 + 16);
    *(void *)(v13 + 16) = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  atomic_store(v11 & 7 | v13 | 8, a1);
  LOBYTE(v23) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476AF0);
  HIBYTE(v23) = v12;
  if (v14)
  {
    unsigned int v17 = *(void **)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = 0LL;
    if (v17) {
      operator delete(v17);
    }
    operator delete((void *)(v11 & 0xFFFFFFFFFFFFFFF0LL));
  }

  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 16) = 0;
  return result;
}

      *((void *)this + 9) = v7 + 1;
      uint64_t v13 = *(_BYTE *)(*((void *)this + 7) + v7);
      goto LABEL_22;
    }

    uint64_t v13 = 2LL * *((void *)this + 4);
    if (v13 <= v12 + 1) {
      uint64_t v13 = v12 + 1;
    }
    *((void *)this + 4) = v13;
    uint64_t v14 = v13 + 8;
    uint64_t v15 = malloc(v13 + 8);
    uint64_t v16 = (char *)v15 + v14;
    *uint64_t v15 = *((void *)this + 3);
    uint64_t v11 = (char *)(v15 + 1);
    *((void *)this + 2) = v16;
    *((void *)this + 3) = v15;
    goto LABEL_24;
  }

  if ((unint64_t)v5 > *((void *)this + 2))
  {
    if (v5 <= 4uLL) {
      uint64_t v12 = 4LL;
    }
    else {
      uint64_t v12 = v5;
    }
    goto LABEL_21;
  }

  uint64_t v11 = 0LL;
  unsigned int v17 = (char *)v5;
LABEL_26:
  *((void *)this + 1) = v17;
  memcpy(v11, v10, v8);
  *((void *)this + 9) += v8;
  uint64_t result = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!result || result + 24 > *((void *)this + 2))
  {
    uint64_t v18 = 2LL * *((void *)this + 4);
    if (v18 <= 0x20) {
      uint64_t v18 = 32LL;
    }
    *((void *)this + 4) = v18;
    unint64_t v19 = v18 + 8;
    unsigned int v20 = malloc(v18 + 8);
    id *v20 = *((void *)this + 3);
    uint64_t result = ((unint64_t)v20 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = (char *)v20 + v19;
    *((void *)this + 3) = v20;
  }

  *((void *)this + 1) = result + 24;
  *(_WORD *)(result + 16) = 23;
  *(_BYTE *)(result + 18) = 3;
  *(void *)uint64_t result = v11;
  *(void *)(result + 8) = v8;
  return result;
}

    if (++v18 == v17) {
      return v9;
    }
  }

  uint64_t v24 = v23->u32[2];
LABEL_47:
  size_t v28 = *((_DWORD *)this + 24);
  if (v28) {
    goto LABEL_52;
  }
  return 0LL;
}

  {
    uint64_t v16 = *((unsigned __int8 *)v14 + 18);
    unsigned int v17 = (swift::Demangle::__runtime::Node **)v14;
    if ((v16 - 1) >= 2)
    {
      if (v16 == 5)
      {
        uint64_t v18 = *(swift::Demangle::__runtime::Node **)v14;
        unsigned int v17 = *(swift::Demangle::__runtime::Node ***)v14;
LABEL_30:
        unint64_t v19 = (swift::Demangle::__runtime::Node **)((char *)v18 + 8 * *((unsigned int *)v14 + 2));
        goto LABEL_36;
      }

      unsigned int v17 = 0LL;
    }

    switch(v16)
    {
      case 1:
        unint64_t v19 = (swift::Demangle::__runtime::Node **)((char *)v14 + 8);
        goto LABEL_36;
      case 2:
        unint64_t v19 = (swift::Demangle::__runtime::Node **)((char *)v14 + 16);
        goto LABEL_36;
      case 5:
        uint64_t v18 = *(swift::Demangle::__runtime::Node **)v14;
        goto LABEL_30;
    }

    unint64_t v19 = 0LL;
LABEL_36:
    while (v17 != v19)
    {
      if (*(_DWORD *)a4) {
        return result;
      }
      ++v17;
    }
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  uint64_t result = swift::Demangle::__runtime::CharVector::append(this + 1591, "HI", 2uLL, this[1593]);
  unsigned int v20 = 0LL;
  if (*((_BYTE *)a2 + 18) == 5)
  {
    if (*((_DWORD *)a2 + 2) < 3u) {
      unsigned int v20 = 0LL;
    }
    else {
      unsigned int v20 = *((void *)*a2 + 2);
    }
  }

  uint64_t v21 = *(unsigned __int16 *)(v20 + 16);
  if (v21 == 246 || v21 == 102)
  {
    uint64_t v22 = *(unsigned __int8 *)(v20 + 18);
    if ((v21 != 102) == (v22 == 4))
    {
      uint64_t v24 = 2713;
      uint64_t v25 = 1;
    }

    else
    {
      if (v22 == 4) {
        uint64_t v23 = *(void *)v20 + 2LL;
      }
      else {
        uint64_t v23 = 1LL;
      }
      uint64_t v25 = 0;
      unsigned int v20 = 0LL;
      uint64_t v24 = 0;
    }
  }

  else
  {
    uint64_t v24 = 2711;
    uint64_t v25 = 1;
  }

  *(_DWORD *)a4 = v25;
  *(void *)(a4 + 8) = v20;
  *(_DWORD *)(a4 + 16) = v24;
  return result;
}

  *((_DWORD *)this + 3184) = v9 + 1;
  v11[v9] = v8;
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  return result;
}

  v3[3184] = v5 + 1;
  v7[v5] = 101;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  v3[3184] = v6 + 1;
  v8[v6] = v5;
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  return this;
}

  v3[3184] = v5 + 1;
  v7[v5] = 65;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  v3[3184] = v5 + 1;
  v7[v5] = 84;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  v3[3184] = v5 + 1;
  v7[v5] = 113;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  {
    uint64_t v15 = *((unsigned __int8 *)v13 + 18);
    uint64_t v16 = (swift::Demangle::__runtime::Node **)v13;
    if ((v15 - 1) >= 2)
    {
      if (v15 == 5)
      {
        unsigned int v17 = *(swift::Demangle::__runtime::Node **)v13;
        uint64_t v16 = *(swift::Demangle::__runtime::Node ***)v13;
LABEL_30:
        uint64_t v18 = (swift::Demangle::__runtime::Node **)((char *)v17 + 8 * *((unsigned int *)v13 + 2));
        goto LABEL_36;
      }

      uint64_t v16 = 0LL;
    }

    switch(v15)
    {
      case 1:
        uint64_t v18 = (swift::Demangle::__runtime::Node **)((char *)v13 + 8);
        goto LABEL_36;
      case 2:
        uint64_t v18 = (swift::Demangle::__runtime::Node **)((char *)v13 + 16);
        goto LABEL_36;
      case 5:
        unsigned int v17 = *(swift::Demangle::__runtime::Node **)v13;
        goto LABEL_30;
    }

    uint64_t v18 = 0LL;
LABEL_36:
    while (v16 != v18)
    {
      if (*(_DWORD *)a4) {
        return result;
      }
      ++v16;
    }
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "Tb", 2uLL, this[1593]);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  v3[3184] = v5 + 1;
  v7[v5] = 75;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  v3[3184] = v5 + 1;
  v7[v5] = 121;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  v3[3184] = v5 + 1;
  v7[v5] = 95;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  v3[3184] = v5 + 1;
  v7[v5] = 100;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  *((_DWORD *)this + 3184) = v8 + 1;
  v10[v8] = 114;
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  return result;
}

  v3[3184] = v5 + 1;
  v7[v5] = 109;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  v3[3184] = v5 + 1;
  v7[v5] = 97;
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 16) = 0;
  return this;
}

  *((_DWORD *)this + 3184) = v9 + 1;
  v11[v9] = v8;
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  return result;
}

  *((_DWORD *)a1 + 2) = v5 + 1;
  v6[v5] = a2;
  return a1;
}

    uint64_t v10 = (swift::Demangle::__runtime::Node *)((char *)v10 + 8);
  }

  while (v10 != v12);
  if (v23) {
    goto LABEL_27;
  }
  if (a3) {
    uint64_t v18 = strlen(a3);
  }
  else {
    uint64_t v18 = 0LL;
  }
  this = (uint64_t *)swift::Demangle::__runtime::CharVector::append( (char **)(v7 + 12728),  a3,  v18,  *(void **)(v7 + 12744));
  unint64_t v19 = *((unsigned __int8 *)v6 + 18);
  unsigned int v20 = (swift::Demangle::__runtime::Node **)v6;
  if ((v19 - 1) >= 2)
  {
    if (v19 == 5)
    {
      uint64_t v21 = *(swift::Demangle::__runtime::Node ***)v6;
      unsigned int v20 = *(swift::Demangle::__runtime::Node ***)v6;
LABEL_41:
      uint64_t v22 = &v21[*((unsigned int *)v6 + 2)];
      goto LABEL_46;
    }

    unsigned int v20 = 0LL;
  }

  switch(v19)
  {
    case 1:
      uint64_t v22 = (swift::Demangle::__runtime::Node **)((char *)v6 + 8);
      goto LABEL_46;
    case 2:
      uint64_t v22 = (swift::Demangle::__runtime::Node **)((char *)v6 + 16);
      goto LABEL_46;
    case 5:
      uint64_t v21 = *(swift::Demangle::__runtime::Node ***)v6;
      goto LABEL_41;
  }

  uint64_t v22 = 0LL;
LABEL_46:
  while (v20 != v22)
  {
    if (*((_WORD *)*v20 + 8) != 94)
    {
      if (*(_DWORD *)a5) {
        return this;
      }
    }

    ++v20;
  }

  unsigned int v17 = 0;
  unsigned int v6 = 0LL;
  uint64_t v16 = 0;
LABEL_28:
  *(_DWORD *)a5 = v17;
  *(void *)(a5 + 8) = v6;
  *(_DWORD *)(a5 + 16) = v16;
  return this;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 75;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 99;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 117;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 68;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  if (v21 == 1) {
  if (v21 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 70;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *((_DWORD *)this + 3184) = v9 + 1;
  v11[v9] = v8;
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  return result;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 82;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  if (v21 == 1) {
  if (v21 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 76;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 98;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 80;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *((_DWORD *)this + 3184) = v8 + 1;
  v10[v8] = 80;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 104;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  if (v21 == 1) {
  if (v21 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 110;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  if (v21 == 1) {
  if (v21 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 88;
  uint64_t v21 = *(_DWORD *)(v6 + 12736);
  uint64_t v22 = *(unsigned int *)(v6 + 12740);
  uint64_t v23 = *(char **)(v6 + 12728);
  uint64_t v24 = *(void **)(v6 + 12744);
  uint64_t v25 = (char *)v24[1];
  if (&v23[v22] != v25)
  {
    uint64_t v26 = v24[2];
LABEL_25:
    else {
      size_t v28 = (2 * v22);
    }
    uint64_t v29 = v28 + v22;
    if (v25) {
      uint64_t v30 = (unint64_t)&v25[v28 + v22] > v26;
    }
    else {
      uint64_t v30 = 1;
    }
    uint64_t v23 = (char *)v24[1];
    if (v30)
    {
      Swift::String::Index v31 = 2LL * v24[4];
      if (v31 <= v29 + 1) {
        Swift::String::Index v31 = v29 + 1;
      }
      void v24[4] = v31;
      uint64_t v32 = v31 + 8;
      this = (unsigned int *)malloc(v31 + 8);
      Swift::Bool v33 = (char *)this + v32;
      *(void *)this = v24[3];
      uint64_t v23 = (char *)(this + 2);
      v24[2] = v33;
      v24[3] = this;
    }

    v24[1] = &v23[v29];
    if ((_DWORD)v22)
    {
      this = (unsigned int *)memcpy(v23, *(const void **)(v6 + 12728), v22);
      LODWORD(v22) = *(_DWORD *)(v6 + 12740);
      uint64_t v21 = *(_DWORD *)(v6 + 12736);
    }

    *(void *)(v6 + 12728) = v23;
    goto LABEL_40;
  }

  uint64_t v27 = (unint64_t)&v23[v22 + 1];
  uint64_t v26 = v24[2];
  if (v27 > v26) {
    goto LABEL_25;
  }
  v24[1] = v27;
  LODWORD(v28) = 1;
LABEL_40:
  *(_DWORD *)(v6 + 12740) = v22 + v28;
LABEL_41:
  *(_DWORD *)(v6 + 12736) = v21 + 1;
  v23[v21] = 98;
  uint64_t v34 = *((unsigned __int8 *)a2 + 18);
  if (v34 == 1) {
  if (v34 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  uint64_t v16 = 0LL;
LABEL_22:
  if (*(_DWORD *)a4) {
    return this;
  }
  uint64_t v14 = 0;
  if (!v16)
  {
    BOOL v4 = 0LL;
    uint64_t v13 = 0;
    goto LABEL_49;
  }

  uint64_t v23 = a3 + 2;
  while (1)
  {
    uint64_t v24 = *((unsigned __int8 *)v16 + 18);
    switch((_DWORD)v24)
    {
      case 1:
        uint64_t v25 = *((unsigned __int8 *)v16 + 18);
        break;
      case 5:
        uint64_t v25 = *((unsigned int *)v16 + 2);
        break;
      case 2:
        uint64_t v25 = 2LL;
        break;
      default:
        goto LABEL_54;
    }

    uint64_t v26 = v14;
    if (v25 <= v14) {
      break;
    }
    uint64_t v27 = v24 - 1;
    if ((_DWORD)v24 == 1) {
      goto LABEL_36;
    }
    if ((_DWORD)v24 != 5)
    {
      uint64_t v24 = 2LL;
LABEL_36:
      if (v24 <= v26) {
        goto LABEL_41;
      }
      goto LABEL_37;
    }

    if (*((unsigned int *)v16 + 2) <= v26)
    {
LABEL_41:
      BOOL v4 = 0LL;
      goto LABEL_42;
    }

  *((_DWORD *)this + 3184) = v8 + 1;
  v10[v8] = 90;
  uint64_t v23 = *((unsigned __int8 *)a2 + 18);
  if ((v23 - 1) < 2)
  {
LABEL_25:
    uint64_t v24 = *(swift::Demangle::__runtime::Node **)a2;
    goto LABEL_27;
  }

  if (v23 == 5 && *((_DWORD *)a2 + 2))
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
    goto LABEL_25;
  }

  uint64_t v24 = 0LL;
LABEL_27:
  if (SHIBYTE(v29) < 0) {
    operator delete(__p);
  }
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 116;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  if (v21 == 1) {
  if (v21 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 102;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  uint64_t v22 = a2;
  if ((v21 - 1) >= 2)
  {
    if (v21 == 5)
    {
      uint64_t v23 = *a2;
      uint64_t v22 = (swift::Demangle::__runtime::Node **)*a2;
      goto LABEL_29;
    }

    uint64_t v22 = 0LL;
  }

  switch(v21)
  {
    case 1:
      uint64_t v24 = a2 + 1;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 2:
      uint64_t v24 = a2 + 2;
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
    case 5:
      uint64_t v23 = *a2;
LABEL_29:
      uint64_t v24 = (swift::Demangle::__runtime::Node **)((char *)v23 + 8 * *((unsigned int *)a2 + 2));
      if (v22 == v24) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

  uint64_t v24 = 0LL;
  if (!v22)
  {
LABEL_39:
    *(_DWORD *)a4 = 0;
    *(void *)(a4 + 8) = 0LL;
    *(_DWORD *)(a4 + 16) = 0;
    return this;
  }

  *(_DWORD *)(v6 + 12736) = v12 + 1;
  v14[v12] = 119;
  this = (char *)swift::Demangle::__runtime::CharVector::append(v11, v10, 2uLL, *(void **)(v6 + 12744));
  size_t v28 = *((unsigned __int8 *)v5 + 18);
  if (v28 == 2) {
  if (v28 == 5 && *((_DWORD *)v5 + 2) > 1u)
  }
  {
    unsigned int v5 = *(swift::Demangle::__runtime::Node **)v5;
  }

  *(_DWORD *)a4 = 1;
  *(void *)(a4 + 8) = v5;
  uint64_t v18 = 119;
LABEL_27:
  *(_DWORD *)(a4 + 16) = v18;
  return this;
}

  *((_DWORD *)this + 3184) = v10 + 1;
  v12[v10] = 114;
  uint64_t v23 = *((unsigned __int8 *)a2 + 18);
  if (v23 == 1) {
  if (v23 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return result;
}

  *(_DWORD *)(v6 + 12736) = v8 + 1;
  v10[v8] = 107;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  if (v21 == 1) {
  if (v21 == 5 && *((_DWORD *)a2 + 2) == 1)
  }
  {
    a2 = *(swift::Demangle::__runtime::Node **)a2;
  }

  *(_DWORD *)a4 = 10;
  *(void *)(a4 + 8) = a2;
  *(_DWORD *)(a4 + 16) = 114;
  return this;
}

  *(_DWORD *)(a1 + 12736) = v7 + 1;
  v9[v7] = 90;
  uint64_t v21 = *((unsigned __int8 *)a2 + 18);
  if ((v21 - 1) >= 2)
  {
    if (v21 != 5 || !*((_DWORD *)a2 + 2))
    {
      uint64_t v22 = 0LL;
    }

    a2 = (uint64_t *)*a2;
  }

  uint64_t v22 = (uint64_t *)*a2;
}

  if (v12 == v10)
  {
LABEL_24:
    if (a3)
    {
      if (*(_DWORD *)a5) {
        return;
      }
    }

    uint64_t v16 = *((_DWORD *)this + 3184);
    unsigned int v17 = *((unsigned int *)this + 3185);
    uint64_t v18 = (_BYTE *)*((void *)this + 1591);
    unint64_t v19 = (void *)*((void *)this + 1593);
    unsigned int v20 = (_BYTE *)v19[1];
    if (&v18[v17] == v20)
    {
      uint64_t v22 = (unint64_t)&v18[v17 + 1];
      uint64_t v21 = v19[2];
      if (v22 <= v21)
      {
        v19[1] = v22;
        LODWORD(v23) = 1;
LABEL_45:
        *((_DWORD *)this + 3185) = v17 + v23;
LABEL_46:
        uint64_t v15 = 0;
        a2 = 0LL;
        uint64_t v14 = 0;
        *((_DWORD *)this + 3184) = v16 + 1;
        v18[v16] = 95;
        goto LABEL_47;
      }
    }

    else
    {
      uint64_t v21 = v19[2];
    }

    else {
      uint64_t v23 = (2 * v17);
    }
    uint64_t v24 = v23 + v17;
    if (v20) {
      uint64_t v25 = (unint64_t)&v20[v23 + v17] > v21;
    }
    else {
      uint64_t v25 = 1;
    }
    uint64_t v18 = (_BYTE *)v19[1];
    if (v25)
    {
      uint64_t v26 = 2LL * v19[4];
      if (v26 <= v24 + 1) {
        uint64_t v26 = v24 + 1;
      }
      v19[4] = v26;
      uint64_t v27 = v26 + 8;
      size_t v28 = malloc(v26 + 8);
      uint64_t v29 = (char *)v28 + v27;
      *size_t v28 = v19[3];
      uint64_t v18 = v28 + 1;
      v19[2] = v29;
      v19[3] = v28;
    }

    v19[1] = &v18[v24];
    if ((_DWORD)v17)
    {
      memcpy(v18, *((const void **)this + 1591), v17);
      LODWORD(v17) = *((_DWORD *)this + 3185);
      uint64_t v16 = *((_DWORD *)this + 3184);
    }

    *((void *)this + 1591) = v18;
    goto LABEL_45;
  }

  while (1)
  {
    if (*(_DWORD *)a5) {
      break;
    }
    if (++v12 == v10) {
      goto LABEL_24;
    }
  }

uint64_t RangeReplaceableCollection.removeSubrange(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *(uint64_t (**)(uint64_t))(a3 + 32);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(*(void *)(a3 + 8) + 8LL),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v7 = type metadata accessor for EmptyCollection(0LL, AssociatedTypeWitness, v5, v6);
  swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v7, v8);
  return v10(a1);
}

uint64_t protocol witness for RangeReplaceableCollection._customRemoveLast(_:) in conformance [A]()
{
  return protocol witness for Collection.isEmpty.getter in conformance <> ClosedRange<A>();
}

Swift::Bool __swiftcall RangeReplaceableCollection._customRemoveLast(_:)(Swift::Int a1)
{
  return protocol witness for Collection.isEmpty.getter in conformance <> ClosedRange<A>();
}

uint64_t specialized RangeReplaceableCollection.removeFirst()()
{
  unint64_t v1 = v0[1];
  uint64_t v2 = HIBYTE(v1) & 0xF;
  if ((v1 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = *v0 & 0xFFFFFFFFFFFFLL;
  }
  if (!v2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove first element from an empty collection",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x26CuLL,  0);
  }
  uint64_t v3 = specialized Collection.first.getter(*v0, v1);
  if (!v4) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x26EuLL,  0);
  }
  uint64_t v5 = v3;
  specialized RangeReplaceableCollection.removeFirst(_:)(1LL);
  return v5;
}

unint64_t specialized RangeReplaceableCollection.removeFirst()()
{
  unint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  if ((v2 & 0x2000000000000000LL) != 0) {
    uint64_t v3 = HIBYTE(v2) & 0xF;
  }
  else {
    uint64_t v3 = *v0 & 0xFFFFFFFFFFFFLL;
  }
  if (!v3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove first element from an empty collection",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x26CuLL,  0);
  }
  unint64_t v4 = specialized Collection.first.getter(*v0, v0[1]);
  if ((v4 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x26EuLL,  0);
  }
  unint64_t v5 = v4;
  uint64_t v6 = 7LL;
  if (((v2 >> 60) & ((v1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v6 = 11LL;
  }
  Swift::String::Index_optional v13 = String.UnicodeScalarView.index(_:offsetBy:limitedBy:)( (Swift::String::Index)15LL,  1LL,  (Swift::String::Index)(v6 | (v3 << 16)));
  if (v13.is_nil) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it has",  53LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x254uLL,  0);
  }
  Swift::UInt64 rawBits = v13.value._rawBits;
  v8._Swift::UInt64 rawBits = 15LL;
  v9._Swift::UInt64 rawBits = rawBits;
  Swift::UInt64 v10 = _StringGuts.validateScalarRange_5_7(_:)(v8, v9, v1, v2);
  specialized _StringGuts.replaceSubrange<A>(_:with:)(v10, v11);
  return v5;
}

uint64_t RangeReplaceableCollection.removeFirst()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v6 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  MEMORY[0x1895F8858](v10);
  uint64_t v12 = (char *)&v15 - v11;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v6 + 104))(a1, v6) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove first element from an empty collection",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x26CuLL,  0);
  }
  Collection.first.getter(a1, v6, (uint64_t)v12);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v13 + 48))(v12, 1LL, AssociatedTypeWitness) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x26EuLL,  0);
  }
  (*(void (**)(uint64_t, char *, unint64_t))(v13 + 32))(a3, v12, AssociatedTypeWitness);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 136))(1LL, a1, a2);
}

Swift::Int specialized RangeReplaceableCollection.removeFirst(_:)(Swift::Int offsetBy)
{
  if (offsetBy)
  {
    if (offsetBy < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x252uLL,  0);
    }
    unint64_t v2 = *v1;
    unint64_t v3 = v1[1];
    uint64_t v4 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000LL) == 0) {
      uint64_t v4 = *v1;
    }
    uint64_t v5 = 7LL;
    if (((v3 >> 60) & ((v2 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v5 = 11LL;
    }
    Swift::String::Index_optional v11 = String.UnicodeScalarView.index(_:offsetBy:limitedBy:)( (Swift::String::Index)15LL,  offsetBy,  (Swift::String::Index)(v5 | (v4 << 16)));
    if (v11.is_nil) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it has",  53LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x254uLL,  0);
    }
    Swift::UInt64 rawBits = v11.value._rawBits;
    v7._Swift::UInt64 rawBits = 15LL;
    v8._Swift::UInt64 rawBits = rawBits;
    Swift::UInt64 v9 = _StringGuts.validateScalarRange_5_7(_:)(v7, v8, v2, v3);
    return specialized _StringGuts.replaceSubrange<A>(_:with:)(v9, v10);
  }

  return offsetBy;
}

void specialized RangeReplaceableCollection.removeFirst(_:)(Swift::Int offsetBy)
{
  if (offsetBy)
  {
    if (offsetBy < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x252uLL,  0);
    }
    unint64_t v2 = *v1;
    unint64_t v3 = v1[1];
    uint64_t v4 = HIBYTE(v3) & 0xF;
    if ((v3 & 0x2000000000000000LL) == 0) {
      uint64_t v4 = *v1;
    }
    uint64_t v5 = 7LL;
    if (((v3 >> 60) & ((v2 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v5 = 11LL;
    }
    Swift::String::Index_optional v11 = String.index(_:offsetBy:limitedBy:)( (Swift::String::Index)15LL,  offsetBy,  (Swift::String::Index)(v5 | (v4 << 16)));
    if (v11.is_nil) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it has",  53LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x254uLL,  0);
    }
    Swift::UInt64 rawBits = v11.value._rawBits;
    v7._Swift::UInt64 rawBits = 15LL;
    v8._Swift::UInt64 rawBits = rawBits;
    Swift::UInt64 v9 = _StringGuts.validateScalarRange(_:)(v7, v8, v2, v3);
    _StringGuts.remove(from:to:)((Swift::String::Index)v9, v10);
  }

unint64_t specialized RangeReplaceableCollection.removeFirst(_:)(unint64_t result)
{
  if (result)
  {
    if ((result & 0x8000000000000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x252uLL,  0);
    }
    uint64_t v2 = *v1;
    unint64_t v3 = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*v1, result, 0, *v1);
    if ((v3 & 0x100000000LL) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it has",  53LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x254uLL,  0);
    }
    if (v2 < v3) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    return specialized RangeReplaceableCollection.removeSubrange(_:)(v2 | (v3 << 32));
  }

  return result;
}

Swift::Void __swiftcall RangeReplaceableCollection.removeFirst(_:)(Swift::Int a1)
{
  uint64_t v4 = v2;
  uint64_t v5 = v1;
  uint64_t v6 = *(void *)(v2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v6,  v1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  unsigned int v73 = (char *)&v61 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v68 = (char *)&v61 - v10;
  unint64_t v11 = v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v71 = *(void *)(v13 - 8);
  uint64_t v72 = v13;
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  BOOL v67 = (char *)&v61 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  unint64_t v69 = (char *)&v61 - v16;
  uint64_t v19 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v17, v18);
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  uint64_t v22 = (char *)&v61 - v21;
  uint64_t v23 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v24 = MEMORY[0x1895F8858](v20);
  uint64_t v75 = (char *)&v61 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  unint64_t v74 = (char *)&v61 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  uint64_t v30 = (char *)&v61 - v29;
  uint64_t v31 = MEMORY[0x1895F8858](v28);
  Swift::Bool v33 = (char *)&v61 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  uint64_t v36 = (char *)&v61 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  if (v39)
  {
    if (v39 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x252uLL,  0);
    }
    uint64_t v61 = v40;
    uint64_t v62 = v37;
    uint64_t v66 = (char *)&v61 - v38;
    uint64_t v64 = v4;
    uint64_t v41 = v39;
    char v65 = *(void (**)(unint64_t, uint64_t))(v6 + 64);
    v65(v11, v6);
    (*(void (**)(unint64_t, uint64_t))(v6 + 72))(v11, v6);
    (*(void (**)(char *, uint64_t, char *, unint64_t, uint64_t))(v6 + 144))(v36, v41, v33, v11, v6);
    uint64_t v42 = *(void (**)(char *, unint64_t))(v23 + 8);
    v42(v33, AssociatedTypeWitness);
    Swift::Int v63 = v42;
    v42(v36, AssociatedTypeWitness);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v23 + 48))(v22, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v61 + 8))(v22, v62);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it has",  53LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x254uLL,  0);
    }

    uint64_t v43 = *(void (**)(char *, char *, unint64_t))(v23 + 32);
    uint64_t v44 = v66;
    v43(v66, v22, AssociatedTypeWitness);
    uint64_t v62 = v3;
    v65(v11, v6);
    uint64_t v45 = *(void (**)(char *, char *, unint64_t))(v23 + 16);
    uint64_t v46 = v74;
    v45(v74, v30, AssociatedTypeWitness);
    uint64_t v47 = v75;
    v45(v75, v44, AssociatedTypeWitness);
    if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v46,  v47,  AssociatedTypeWitness) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    uint64_t v48 = v47;
    unint64_t AssociatedConformanceWitness = v11;
    uint64_t v49 = v44;
    uint64_t v50 = v63;
    v63(v48, AssociatedTypeWitness);
    v50(v46, AssociatedTypeWitness);
    uint64_t v51 = TupleTypeMetadata2;
    uint64_t v52 = v68;
    uint64_t v53 = &v68[*((int *)TupleTypeMetadata2 + 12)];
    v43(v68, v30, AssociatedTypeWitness);
    v43(v53, v49, AssociatedTypeWitness);
    uint64_t v54 = v73;
    uint64_t v55 = &v73[*((int *)v51 + 12)];
    v45(v73, v52, AssociatedTypeWitness);
    v45(v55, v53, AssociatedTypeWitness);
    uint64_t v56 = v67;
    v43(v67, v54, AssociatedTypeWitness);
    v50(v55, AssociatedTypeWitness);
    uint64_t v57 = &v54[*((int *)v51 + 12)];
    v43(v54, v52, AssociatedTypeWitness);
    v43(v57, v53, AssociatedTypeWitness);
    uint64_t v58 = v72;
    v43(&v56[*(int *)(v72 + 36)], v57, AssociatedTypeWitness);
    v50(v54, AssociatedTypeWitness);
    uint64_t v59 = v71;
    uint64_t v60 = v69;
    (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v69, v56, v58);
    (*(void (**)(char *, unint64_t))(v64 + 104))(v60, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t))(v59 + 8))(v60, v58);
  }

uint64_t protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance [A]( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], a3, a3);
  return RangeReplaceableCollection<>.removeAll(where:)(a1, a2, a3, WitnessTable, a4);
}

uint64_t RangeReplaceableCollection<>.removeAll(where:)( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v82 = (char *)a4;
  uint64_t v76 = a5;
  unint64_t v81 = a1;
  Swift::String::Index v7 = *(const char **)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v7,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v75 = (char *)v64 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unint64_t v70 = (char *)v64 - v11;
  uint64_t v78 = v7;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v7,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v14 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v13);
  uint64_t v73 = *(void *)(v14 - 8);
  uint64_t v74 = v14;
  uint64_t v15 = MEMORY[0x1895F8858](v14);
  unint64_t v69 = (char *)v64 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v15);
  uint64_t v71 = (char *)v64 - v17;
  unint64_t v80 = AssociatedConformanceWitness;
  uint64_t v19 = type metadata accessor for PartialRangeFrom(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v18);
  uint64_t v67 = *(void *)(v19 - 8);
  uint64_t v68 = v19;
  uint64_t v20 = MEMORY[0x1895F8858](v19);
  uint64_t v77 = (char *)v64 - v21;
  uint64_t v79 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  uint64_t v24 = (char *)v64 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v22);
  uint64_t v27 = (uint64_t (*)(char *))((char *)v64 - v26);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v30 = (char *)v64 - v29;
  uint64_t v31 = MEMORY[0x1895F8858](v28);
  Swift::Bool v33 = (char *)v64 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  uint64_t v36 = (char *)v64 - v35;
  MEMORY[0x1895F8858](v34);
  uint64_t v38 = (char *)v64 - v37;
  uint64_t v39 = v83;
  uint64_t result = MutableCollection._halfStablePartition(isSuffixElement:)(v81, a2, a3, (uint64_t)v82, (uint64_t)v64 - v37);
  if (!v39)
  {
    char v65 = v24;
    uint64_t v66 = v33;
    unint64_t v81 = v27;
    uint64_t v82 = v30;
    v64[1] = 0LL;
    uint64_t v41 = v79;
    uint64_t v83 = *(void (**)(void, void, void))(v79 + 16);
    v83(v36, v38, AssociatedTypeWitness);
    unint64_t v42 = v80;
    if (((*(uint64_t (**)(char *, char *, unint64_t))(*(void *)(v80 + 8) + 8LL))( v36,  v36,  AssociatedTypeWitness) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range cannot have an unordered lower bound.",  43LL,  2,  "Swift/Range.swift",  17LL,  2,  0x34FuLL,  0);
    }
    v64[0] = *(void *)(v41 + 8);
    ((void (*)(char *, unint64_t))v64[0])(v36, AssociatedTypeWitness);
    uint64_t v43 = *(void (**)(char *, char *, unint64_t))(v41 + 32);
    uint64_t v44 = v77;
    v43(v77, v38, AssociatedTypeWitness);
    uint64_t v45 = v66;
    uint64_t v46 = (void (*)(uint64_t (*)(char *), char *, unint64_t))v83;
    v83(v66, v44, AssociatedTypeWitness);
    uint64_t v47 = (void (*)(uint64_t))*((void *)v78 + 9);
    uint64_t v48 = (uint64_t)v82;
    uint64_t v79 = a3;
    v47(a3);
    uint64_t v49 = v81;
    v46(v81, v45, AssociatedTypeWitness);
    uint64_t v50 = v65;
    v46((uint64_t (*)(char *))v65, (char *)v48, AssociatedTypeWitness);
    if (((*(uint64_t (**)(uint64_t (*)(char *), char *, unint64_t, unint64_t))(v42 + 24))( v49,  v50,  AssociatedTypeWitness,  v42) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    uint64_t v51 = v50;
    uint64_t v52 = (void (*)(uint64_t (*)(char *), unint64_t))v64[0];
    ((void (*)(char *, unint64_t))v64[0])(v51, AssociatedTypeWitness);
    v52(v49, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v67 + 8))(v44, v68);
    uint64_t v53 = TupleTypeMetadata2;
    uint64_t v54 = v70;
    uint64_t v55 = &v70[*((int *)TupleTypeMetadata2 + 12)];
    v43(v70, v66, AssociatedTypeWitness);
    v43(v55, (char *)v48, AssociatedTypeWitness);
    uint64_t v56 = v75;
    uint64_t v57 = &v75[*((int *)v53 + 12)];
    uint64_t v58 = (void (*)(char *, char *, unint64_t))v83;
    v83(v75, v54, AssociatedTypeWitness);
    v58(v57, v55, AssociatedTypeWitness);
    uint64_t v59 = v69;
    v43(v69, v56, AssociatedTypeWitness);
    v52((uint64_t (*)(char *))v57, AssociatedTypeWitness);
    uint64_t v60 = &v56[*((int *)v53 + 12)];
    v43(v56, v54, AssociatedTypeWitness);
    v43(v60, v55, AssociatedTypeWitness);
    uint64_t v61 = v74;
    v43(&v59[*(int *)(v74 + 36)], v60, AssociatedTypeWitness);
    v52((uint64_t (*)(char *))v56, AssociatedTypeWitness);
    uint64_t v62 = v73;
    Swift::Int v63 = v71;
    (*(void (**)(char *, char *, uint64_t))(v73 + 32))(v71, v59, v61);
    (*(void (**)(char *, uint64_t))(v76 + 104))(v63, v79);
    return (*(uint64_t (**)(char *, uint64_t))(v62 + 8))(v63, v61);
  }

  return result;
}

unint64_t static Array.+ infix(_:_:)( unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v16 = a2;
  unint64_t v17 = a1;
  uint64_t v6 = type metadata accessor for Array(0LL, a3, a3, a4);
  swift_bridgeObjectRetain(a1, v7, v8, v9);
  swift_bridgeObjectRetain(a2, v10, v11, v12);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v6, v13);
  Array.append<A>(contentsOf:)((uint64_t)&v16, v6, v6, WitnessTable);
  return v17;
}

uint64_t static Array.+= infix(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v12 = a2;
  uint64_t v5 = type metadata accessor for Array(0LL, a3, a3, a4);
  swift_bridgeObjectRetain(a2, v6, v7, v8);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v5, v9);
  return Array.append<A>(contentsOf:)((uint64_t)&v12, v5, v5, WitnessTable);
}

uint64_t Array.customMirror.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = a1;
  uint64_t v7 = (swift *)type metadata accessor for Array(0LL, a2, a3, a4);
  v35[0] = 0LL;
  v35[1] = 0LL;
  swift_bridgeObjectRetain(a1, v8, v9, v10);
  uint64_t v11 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v38, (uint64_t)v35, v7);
  uint64_t v13 = v12;
  uint64_t v14 = swift_allocObject((uint64_t)&unk_189B780F0, 0x28uLL, 7uLL);
  v14[2] = v7;
  v14[3] = v7;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v7, v15);
  v14[4] = WitnessTable;
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for (label: String?, value: Any));
  uint64_t v19 = swift_getWitnessTable(&protocol conformance descriptor for [A], v7, v18);
  uint64_t v20 = type metadata accessor for LazyMapSequence(255LL, (uint64_t)v7, v17, v19);
  uint64_t v37 = WitnessTable;
  uint64_t v21 = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v20, &v37);
  uint64_t v23 = type metadata accessor for _CollectionBox(0LL, v20, v21, v22);
  uint64_t v24 = swift_allocObject(v23, 0x48uLL, 7uLL);
  v24[6] = a1;
  v24[7] = partial apply for closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v24[8] = v14;
  uint64_t v25 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v26 = swift_allocObject(v25, 0x18uLL, 7uLL);
  v26[2] = 0LL;
  swift_bridgeObjectRetain(a1, v27, v28, v29);
  Swift::Int v30 = Array._getCount()();
  uint64_t v31 = swift_allocObject(v25, 0x18uLL, 7uLL);
  v31[2] = v30;
  v24[2] = v26;
  v24[3] = &protocol witness table for _IndexBox<A>;
  void v24[4] = v31;
  v24[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v36 = v38;
  uint64_t v32 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v35, &v36, v7, v32, 6uLL);
  char v34 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v35);
  }
  *(void *)a5 = v7;
  *(void *)(a5 + 8) = v24;
  *(_BYTE *)(a5 + 16) = 5;
  *(void *)(a5 + 24) = v11;
  *(void *)(a5 + 32) = v13;
  *(_BYTE *)(a5 + 40) = v34;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( int a1@<W0>, char a2@<W1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  HIDWORD(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)( (uint64_t)&v22 + 4,  (uint64_t)v21,  (swift *)&type metadata for Unicode.Scalar);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LODWORD(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Unicode.Scalar, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for Unicode.Scalar;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  HIDWORD(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 4, (uint64_t)v21, (swift *)&type metadata for UInt32);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LODWORD(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for UInt32, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for UInt32;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  HIDWORD(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 4, (uint64_t)v21, (swift *)&type metadata for Int32);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LODWORD(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Int32, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for Int32;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  v25[0] = a1;
  v25[1] = a2;
  v23[0] = a4;
  v23[1] = a5;
  uint64_t v12 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v25, (uint64_t)v23, (swift *)&type metadata for UInt128);
  uint64_t v14 = v13;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  unint64_t v16 = swift_allocObject(v15, 0x40uLL, 7uLL);
  v16[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v16[7] = 0LL;
  uint64_t v17 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v18 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v18[2] = 0LL;
  uint64_t v19 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v19[2] = 0LL;
  __int128 v16[2] = v18;
  void v16[3] = &protocol witness table for _IndexBox<A>;
  v16[4] = v19;
  v16[5] = &protocol witness table for _IndexBox<A>;
  v24[0] = a1;
  v24[1] = a2;
  char v20 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v23, v24, (swift *)&type metadata for UInt128, v20, 6uLL);
  char v22 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v23);
  }
  *(void *)a6 = &type metadata for UInt128;
  *(void *)(a6 + 8) = v16;
  *(_BYTE *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = v12;
  *(void *)(a6 + 32) = v14;
  *(_BYTE *)(a6 + 40) = v22;
  return result;
}

{
  double (*v12)@<D0>(uint64_t@<X8>);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  const char *v20;
  uint64_t result;
  char v22;
  uint64_t v23[5];
  uint64_t v24[2];
  void v25[2];
  v25[0] = a1;
  v25[1] = a2;
  v23[0] = a4;
  v23[1] = a5;
  uint64_t v12 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v25, (uint64_t)v23, (swift *)&type metadata for Int128);
  uint64_t v14 = v13;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  unint64_t v16 = swift_allocObject(v15, 0x40uLL, 7uLL);
  v16[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v16[7] = 0LL;
  uint64_t v17 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v18 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v18[2] = 0LL;
  uint64_t v19 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v19[2] = 0LL;
  __int128 v16[2] = v18;
  void v16[3] = &protocol witness table for _IndexBox<A>;
  v16[4] = v19;
  v16[5] = &protocol witness table for _IndexBox<A>;
  v24[0] = a1;
  v24[1] = a2;
  char v20 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v23, v24, (swift *)&type metadata for Int128, v20, 6uLL);
  char v22 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v23);
  }
  *(void *)a6 = &type metadata for Int128;
  *(void *)(a6 + 8) = v16;
  *(_BYTE *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = v12;
  *(void *)(a6 + 32) = v14;
  *(_BYTE *)(a6 + 40) = v22;
  return result;
}

{
  double (*v12)@<D0>(uint64_t@<X8>);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  const char *v20;
  uint64_t result;
  char v22;
  uint64_t v23[5];
  uint64_t v24[2];
  void v25[2];
  v25[0] = a1;
  v25[1] = a2;
  v23[0] = a4;
  v23[1] = a5;
  uint64_t v12 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v25, (uint64_t)v23, (swift *)&type metadata for StaticBigInt);
  uint64_t v14 = v13;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  unint64_t v16 = swift_allocObject(v15, 0x40uLL, 7uLL);
  v16[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v16[7] = 0LL;
  uint64_t v17 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v18 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v18[2] = 0LL;
  uint64_t v19 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v19[2] = 0LL;
  __int128 v16[2] = v18;
  void v16[3] = &protocol witness table for _IndexBox<A>;
  v16[4] = v19;
  v16[5] = &protocol witness table for _IndexBox<A>;
  v24[0] = a1;
  v24[1] = a2;
  char v20 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v23, v24, (swift *)&type metadata for StaticBigInt, v20, 6uLL);
  char v22 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v23);
  }
  *(void *)a6 = &type metadata for StaticBigInt;
  *(void *)(a6 + 8) = v16;
  *(_BYTE *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = v12;
  *(void *)(a6 + 32) = v14;
  *(_BYTE *)(a6 + 40) = v22;
  return result;
}

{
  double (*v12)@<D0>(uint64_t@<X8>);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  const char *v20;
  uint64_t result;
  char v22;
  uint64_t v23[5];
  uint64_t v24[2];
  void v25[2];
  v25[0] = a1;
  v25[1] = a2;
  v23[0] = a4;
  v23[1] = a5;
  uint64_t v12 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v25, (uint64_t)v23, (swift *)&type metadata for String);
  uint64_t v14 = v13;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  unint64_t v16 = swift_allocObject(v15, 0x40uLL, 7uLL);
  v16[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v16[7] = 0LL;
  uint64_t v17 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v18 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v18[2] = 0LL;
  uint64_t v19 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v19[2] = 0LL;
  __int128 v16[2] = v18;
  void v16[3] = &protocol witness table for _IndexBox<A>;
  v16[4] = v19;
  v16[5] = &protocol witness table for _IndexBox<A>;
  v24[0] = a1;
  v24[1] = a2;
  char v20 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v23, v24, (swift *)&type metadata for String, v20, 6uLL);
  char v22 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v23);
  }
  *(void *)a6 = &type metadata for String;
  *(void *)(a6 + 8) = v16;
  *(_BYTE *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = v12;
  *(void *)(a6 + 32) = v14;
  *(_BYTE *)(a6 + 40) = v22;
  return result;
}

{
  double (*v12)@<D0>(uint64_t@<X8>);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  const char *v20;
  uint64_t result;
  char v22;
  uint64_t v23[5];
  uint64_t v24[2];
  void v25[2];
  v25[0] = a1;
  v25[1] = a2;
  v23[0] = a4;
  v23[1] = a5;
  uint64_t v12 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v25, (uint64_t)v23, (swift *)&type metadata for Character);
  uint64_t v14 = v13;
  outlined consume of Mirror.AncestorRepresentation(a4, a5);
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  unint64_t v16 = swift_allocObject(v15, 0x40uLL, 7uLL);
  v16[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v16[7] = 0LL;
  uint64_t v17 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v18 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v18[2] = 0LL;
  uint64_t v19 = swift_allocObject(v17, 0x18uLL, 7uLL);
  v19[2] = 0LL;
  __int128 v16[2] = v18;
  void v16[3] = &protocol witness table for _IndexBox<A>;
  v16[4] = v19;
  v16[5] = &protocol witness table for _IndexBox<A>;
  v24[0] = a1;
  v24[1] = a2;
  char v20 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v23, v24, (swift *)&type metadata for Character, v20, 6uLL);
  char v22 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v23);
  }
  *(void *)a6 = &type metadata for Character;
  *(void *)(a6 + 8) = v16;
  *(_BYTE *)(a6 + 16) = a3;
  *(void *)(a6 + 24) = v12;
  *(void *)(a6 + 32) = v14;
  *(_BYTE *)(a6 + 40) = v22;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, char a2@<W1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v23 = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v23, (uint64_t)v21, (swift *)&type metadata for UInt64);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v22 = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for UInt64, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for UInt64;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  uint64_t v23;
  uint64_t v23 = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v23, (uint64_t)v21, (swift *)&type metadata for Int64);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v22 = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Int64, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for Int64;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  uint64_t v23;
  uint64_t v23 = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v23, (uint64_t)v21, (swift *)&type metadata for UInt);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v22 = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for UInt, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for UInt;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  uint64_t v23;
  uint64_t v23 = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v23, (uint64_t)v21, (swift *)&type metadata for Int);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  uint64_t v22 = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Int, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for Int;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( __int16 a1@<W0>, char a2@<W1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  WORD1(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 2, (uint64_t)v21, (swift *)&type metadata for UInt16);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LOWORD(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for UInt16, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for UInt16;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  WORD1(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 2, (uint64_t)v21, (swift *)&type metadata for Int16);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LOWORD(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Int16, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for Int16;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( char a1@<W0>, char a2@<W1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  BYTE1(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 1, (uint64_t)v21, (swift *)&type metadata for UInt8);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LOBYTE(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for UInt8, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for UInt8;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  BYTE1(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 1, (uint64_t)v21, (swift *)&type metadata for Int8);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LOBYTE(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Int8, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for Int8;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

{
  double (*v10)@<D0>(uint64_t@<X8>);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t result;
  char v20;
  uint64_t v21[5];
  uint64_t v22;
  BYTE1(v22) = a1;
  v21[0] = a3;
  v21[1] = a4;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 1, (uint64_t)v21, (swift *)&type metadata for Bool);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a3, a4);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  LOBYTE(v22) = a1;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Bool, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a5 = &type metadata for Bool;
  *(void *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = a2;
  *(void *)(a5 + 24) = v10;
  *(void *)(a5 + 32) = v12;
  *(_BYTE *)(a5 + 40) = v20;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( char a1@<W0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>, float a5@<S0>)
{
  *((float *)&v22 + 1) = a5;
  v21[0] = a2;
  v21[1] = a3;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v22 + 4, (uint64_t)v21, (swift *)&type metadata for Float);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a2, a3);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  *(float *)&uint64_t v22 = a5;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, &v22, (swift *)&type metadata for Float, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a4 = &type metadata for Float;
  *(void *)(a4 + 8) = v14;
  *(_BYTE *)(a4 + 16) = a1;
  *(void *)(a4 + 24) = v10;
  *(void *)(a4 + 32) = v12;
  *(_BYTE *)(a4 + 40) = v20;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( char a1@<W0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>, double a5@<D0>)
{
  double v23 = a5;
  v21[0] = a2;
  v21[1] = a3;
  uint64_t v10 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v23, (uint64_t)v21, (swift *)&type metadata for Double);
  uint64_t v12 = v11;
  outlined consume of Mirror.AncestorRepresentation(a2, a3);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<EmptyCollection<()>, (label: String?, value: Any)>>);
  uint64_t v14 = swift_allocObject(v13, 0x40uLL, 7uLL);
  v14[6] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v14[7] = 0LL;
  uint64_t v15 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  unint64_t v16 = swift_allocObject(v15, 0x18uLL, 7uLL);
  __int128 v16[2] = 0LL;
  uint64_t v17 = swift_allocObject(v15, 0x18uLL, 7uLL);
  v17[2] = 0LL;
  v14[2] = v16;
  v14[3] = &protocol witness table for _IndexBox<A>;
  v14[4] = v17;
  uint64_t v14[5] = &protocol witness table for _IndexBox<A>;
  double v22 = a5;
  uint64_t v18 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v21, (uint64_t *)&v22, (swift *)&type metadata for Double, v18, 6uLL);
  char v20 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v21);
  }
  *(void *)a4 = &type metadata for Double;
  *(void *)(a4 + 8) = v14;
  *(_BYTE *)(a4 + 16) = a1;
  *(void *)(a4 + 24) = v10;
  *(void *)(a4 + 32) = v12;
  *(_BYTE *)(a4 + 40) = v20;
  return result;
}

uint64_t specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, char a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  v32[0] = a1;
  v32[1] = a2;
  v30[0] = a6;
  v30[1] = a7;
  uint64_t v28 = static Mirror._superclassIterator<A>(_:_:)( (uint64_t)v32,  (uint64_t)v30,  (swift *)&type metadata for String.UTF16View);
  uint64_t v16 = v15;
  outlined consume of Mirror.AncestorRepresentation(a6, a7);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<String.UTF16View, (label: String?, value: Any)>>);
  uint64_t v18 = swift_allocObject(v17, 0x50uLL, 7uLL);
  v18[6] = a3;
  v18[7] = a4;
  v18[8] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v18[9] = 0LL;
  uint64_t v19 = canonical specialized generic type metadata accessor for _IndexBox<String.Index>();
  char v20 = swift_allocObject(v19, 0x18uLL, 7uLL);
  void v20[2] = 15LL;
  uint64_t v21 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v21 = a3;
  }
  uint64_t v22 = 11LL;
  if (((a4 >> 60) & ((a3 & 0x800000000000000LL) == 0)) == 0) {
    uint64_t v22 = 7LL;
  }
  uint64_t v23 = v22 | (v21 << 16);
  uint64_t v24 = swift_allocObject(v19, 0x18uLL, 7uLL);
  uint64_t v24[2] = v23;
  v18[2] = v20;
  v18[3] = &protocol witness table for _IndexBox<A>;
  v18[4] = v24;
  v18[5] = &protocol witness table for _IndexBox<A>;
  v31[0] = a1;
  v31[1] = a2;
  uint64_t v25 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v30, v31, (swift *)&type metadata for String.UTF16View, v25, 6uLL);
  char v27 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v30);
  }
  *(void *)a8 = &type metadata for String.UTF16View;
  *(void *)(a8 + 8) = v18;
  *(_BYTE *)(a8 + 16) = a5;
  *(void *)(a8 + 24) = v28;
  *(void *)(a8 + 32) = v16;
  *(_BYTE *)(a8 + 40) = v27;
  return result;
}

{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  uint64_t result;
  char v27;
  double (*v28)@<D0>(uint64_t@<X8>);
  uint64_t v30[5];
  uint64_t v31[2];
  void v32[2];
  v32[0] = a1;
  v32[1] = a2;
  v30[0] = a6;
  v30[1] = a7;
  uint64_t v28 = static Mirror._superclassIterator<A>(_:_:)( (uint64_t)v32,  (uint64_t)v30,  (swift *)&type metadata for String.UTF8View);
  uint64_t v16 = v15;
  outlined consume of Mirror.AncestorRepresentation(a6, a7);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<String.UTF8View, (label: String?, value: Any)>>);
  uint64_t v18 = swift_allocObject(v17, 0x50uLL, 7uLL);
  v18[6] = a3;
  v18[7] = a4;
  v18[8] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v18[9] = 0LL;
  uint64_t v19 = canonical specialized generic type metadata accessor for _IndexBox<String.Index>();
  char v20 = swift_allocObject(v19, 0x18uLL, 7uLL);
  void v20[2] = 15LL;
  uint64_t v21 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v21 = a3;
  }
  uint64_t v22 = 11LL;
  if (((a4 >> 60) & ((a3 & 0x800000000000000LL) == 0)) == 0) {
    uint64_t v22 = 7LL;
  }
  uint64_t v23 = v22 | (v21 << 16);
  uint64_t v24 = swift_allocObject(v19, 0x18uLL, 7uLL);
  uint64_t v24[2] = v23;
  v18[2] = v20;
  v18[3] = &protocol witness table for _IndexBox<A>;
  v18[4] = v24;
  v18[5] = &protocol witness table for _IndexBox<A>;
  v31[0] = a1;
  v31[1] = a2;
  uint64_t v25 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v30, v31, (swift *)&type metadata for String.UTF8View, v25, 6uLL);
  char v27 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v30);
  }
  *(void *)a8 = &type metadata for String.UTF8View;
  *(void *)(a8 + 8) = v18;
  *(_BYTE *)(a8 + 16) = a5;
  *(void *)(a8 + 24) = v28;
  *(void *)(a8 + 32) = v16;
  *(_BYTE *)(a8 + 40) = v27;
  return result;
}

{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  uint64_t result;
  char v27;
  double (*v28)@<D0>(uint64_t@<X8>);
  uint64_t v30[5];
  uint64_t v31[2];
  void v32[2];
  v32[0] = a1;
  v32[1] = a2;
  v30[0] = a6;
  v30[1] = a7;
  uint64_t v28 = static Mirror._superclassIterator<A>(_:_:)( (uint64_t)v32,  (uint64_t)v30,  (swift *)&type metadata for String.UnicodeScalarView);
  uint64_t v16 = v15;
  outlined consume of Mirror.AncestorRepresentation(a6, a7);
  uint64_t v17 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CollectionBox<LazyMapSequence<String.UnicodeScalarView, (label: String?, value: Any)>>);
  uint64_t v18 = swift_allocObject(v17, 0x50uLL, 7uLL);
  v18[6] = a3;
  v18[7] = a4;
  v18[8] = specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:);
  v18[9] = 0LL;
  uint64_t v19 = canonical specialized generic type metadata accessor for _IndexBox<String.Index>();
  char v20 = swift_allocObject(v19, 0x18uLL, 7uLL);
  void v20[2] = 15LL;
  uint64_t v21 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    uint64_t v21 = a3;
  }
  uint64_t v22 = 11LL;
  if (((a4 >> 60) & ((a3 & 0x800000000000000LL) == 0)) == 0) {
    uint64_t v22 = 7LL;
  }
  uint64_t v23 = v22 | (v21 << 16);
  uint64_t v24 = swift_allocObject(v19, 0x18uLL, 7uLL);
  uint64_t v24[2] = v23;
  v18[2] = v20;
  v18[3] = &protocol witness table for _IndexBox<A>;
  v18[4] = v24;
  v18[5] = &protocol witness table for _IndexBox<A>;
  v31[0] = a1;
  v31[1] = a2;
  uint64_t v25 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v30, v31, (swift *)&type metadata for String.UnicodeScalarView, v25, 6uLL);
  char v27 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v30);
  }
  *(void *)a8 = &type metadata for String.UnicodeScalarView;
  *(void *)(a8 + 8) = v18;
  *(_BYTE *)(a8 + 16) = a5;
  *(void *)(a8 + 24) = v28;
  *(void *)(a8 + 32) = v16;
  *(_BYTE *)(a8 + 40) = v27;
  return result;
}

uint64_t Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 *a3@<X2>, unint64_t *a4@<X3>, swift *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, swift **a8@<X8>)
{
  Swift::Int v63 = a8;
  uint64_t v64 = a5;
  uint64_t v55 = a2;
  uint64_t v56 = a1;
  uint64_t v62 = *((void *)a5 - 1);
  MEMORY[0x1895F8858](a1);
  uint64_t v61 = (uint64_t *)((char *)&v54 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v15,  v14,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v57 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v18 = (char *)&v54 - v17;
  uint64_t v19 = *(void *)(a7 + 8);
  uint64_t v21 = type metadata accessor for LazySequence(0LL, a6, v19, v20);
  MEMORY[0x1895F8858](v21);
  uint64_t v23 = (char *)&v54 - v22;
  uint64_t v24 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for (label: String?, value: Any));
  uint64_t v25 = type metadata accessor for LazyMapSequence(0LL, a6, v24, v19);
  uint64_t v65 = *(void *)(v25 - 8);
  MEMORY[0x1895F8858](v25);
  char v27 = (char *)&v54 - v26;
  int v60 = *a3;
  unint64_t v28 = *a4;
  uint64_t v29 = a4[1];
  v66[0] = v28;
  v66[1] = v29;
  uint64_t v30 = a1;
  uint64_t v31 = v64;
  uint64_t v32 = static Mirror._superclassIterator<A>(_:_:)(v30, (uint64_t)v66, v64);
  uint64_t v58 = v33;
  uint64_t v59 = v32;
  outlined consume of Mirror.AncestorRepresentation(v28, v29);
  char v34 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 32LL);
  v34(v23, v55, a6);
  uint64_t v35 = swift_allocObject((uint64_t)&unk_189B78118, 0x28uLL, 7uLL);
  v35[2] = v31;
  v35[3] = a6;
  v35[4] = a7;
  v34(v27, (uint64_t)v23, a6);
  uint64_t v36 = &v27[*(int *)(v25 + 44)];
  *(void *)uint64_t v36 = closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)partial apply;
  *((void *)v36 + 1) = v35;
  uint64_t v67 = a7;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v25, &v67);
  uint64_t v39 = type metadata accessor for _CollectionBox(0LL, v25, WitnessTable, v38);
  uint64_t v40 = (char *)swift_allocObject(v39, *(unsigned int *)(v39 + 48), *(unsigned __int16 *)(v39 + 52));
  (*(void (**)(char *, char *, uint64_t))(v65 + 16))(&v40[*(void *)(*(void *)v40 + 360LL)], v27, v25);
  (*(void (**)(uint64_t, uint64_t))(a7 + 64))(a6, a7);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a7,  a6,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v43 = type metadata accessor for _IndexBox(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v42);
  uint64_t v44 = (char *)swift_allocObject(v43, *(unsigned int *)(v43 + 48), *(unsigned __int16 *)(v43 + 52));
  uint64_t v45 = *(void (**)(char *, char *, unint64_t))(v57 + 32);
  v45(&v44[*(void *)(*(void *)v44 + 96LL)], v18, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(a7 + 72))(a6, a7);
  (*(void (**)(char *, uint64_t))(v65 + 8))(v27, v25);
  uint64_t v46 = (char *)swift_allocObject(v43, *(unsigned int *)(v43 + 48), *(unsigned __int16 *)(v43 + 52));
  v45(&v46[*(void *)(*(void *)v46 + 96LL)], v18, AssociatedTypeWitness);
  *((void *)v40 + 2) = v44;
  *((void *)v40 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v40 + 4) = v46;
  *((void *)v40 + 5) = &protocol witness table for _IndexBox<A>;
  uint64_t v47 = v64;
  uint64_t v48 = v61;
  (*(void (**)(uint64_t *, uint64_t, swift *))(v62 + 32))(v61, v56, v64);
  uint64_t v49 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v66, v48, v47, v49, 6uLL);
  char v51 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v66);
  }
  uint64_t v52 = v63;
  *Swift::Int v63 = v47;
  v52[1] = (swift *)v40;
  *((_BYTE *)v52 + 16) = v60;
  uint64_t v53 = v58;
  v52[3] = (swift *)v59;
  v52[4] = v53;
  *((_BYTE *)v52 + 40) = v51;
  return result;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance [A]@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return Array.customMirror.getter(*v4, *(void *)(a1 + 16), a2, a3, a4);
}

Swift::String __swiftcall Collection._makeCollectionDescription(withTypeName:)(Swift::String_optional withTypeName)
{
  uint64_t v4 = v1;
  unint64_t object = (unint64_t)withTypeName.value._object;
  uint64_t countAndFlagsBits = withTypeName.value._countAndFlagsBits;
  uint64_t v6 = *(void *)(v2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&countAndFlagsBits - v9;
  uint64_t v13 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v11, v12);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&countAndFlagsBits - v15;
  uint64_t v17 = *(void *)(v4 - 8);
  MEMORY[0x1895F8858](v14);
  *(void *)&__int128 v78 = (char *)&countAndFlagsBits - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v81 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  v4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  MEMORY[0x1895F8858](v81);
  uint64_t v79 = v3;
  unint64_t v80 = (char *)&countAndFlagsBits - v19;
  unint64_t v76 = object;
  uint64_t v77 = v10;
  uint64_t v75 = v20;
  if (!object)
  {
    unint64_t v33 = 0xE100000000000000LL;
    uint64_t v34 = 91LL;
    goto LABEL_34;
  }

  unint64_t v21 = specialized static String._createEmpty(withInitialCapacity:)(4LL);
  uint64_t v23 = v22;
  unint64_t v83 = v21;
  unint64_t v84 = v22;
  uint64_t v24 = HIBYTE(v22) & 0xF;
  if ((v22 & 0x2000000000000000LL) == 0) {
    uint64_t v24 = v21 & 0xFFFFFFFFFFFFLL;
  }
  if (!v24 && (v21 & ~v22 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v22);
    unint64_t v28 = 0LL;
    unint64_t v29 = 0xE000000000000000LL;
    unint64_t v83 = 0LL;
    goto LABEL_12;
  }

  if ((v22 & 0x2000000000000000LL) != 0)
  {
    unint64_t v25 = specialized _SmallString.init(_:appending:)(v21, v22, 0LL, 0xE000000000000000LL);
    if ((v27 & 1) == 0)
    {
      unint64_t v28 = v25;
      unint64_t v29 = v26;
      swift_bridgeObjectRelease(v23);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v83 = v28;
LABEL_12:
      unint64_t v84 = v29;
      goto LABEL_13;
    }
  }

  _StringGuts.append(_:)(0LL, 0xE000000000000000LL, 0LL, 0LL);
  swift_bridgeObjectRelease(0xE000000000000000LL);
  unint64_t v28 = v83;
  unint64_t v29 = v84;
LABEL_13:
  uint64_t v35 = HIBYTE(v29) & 0xF;
  if ((v29 & 0x2000000000000000LL) == 0) {
    uint64_t v35 = v28 & 0xFFFFFFFFFFFFLL;
  }
  if (v35 || (v28 & ~v29 & 0x2000000000000000LL) != 0)
  {
    if ((v29 & 0x2000000000000000LL) != 0
      && (object & 0x2000000000000000LL) != 0
      && (unint64_t v36 = specialized _SmallString.init(_:appending:)(v28, v29, countAndFlagsBits, object), (v38 & 1) == 0))
    {
      unint64_t v39 = v36;
      unint64_t v40 = v37;
      swift_bridgeObjectRelease(v29);
      unint64_t v83 = v39;
      unint64_t v84 = v40;
      unint64_t v41 = v39;
    }

    else
    {
      if ((object & 0x2000000000000000LL) != 0) {
        uint64_t v42 = HIBYTE(object) & 0xF;
      }
      else {
        uint64_t v42 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }
      _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v42);
      unint64_t v41 = v83;
      unint64_t v40 = v84;
    }
  }

  else
  {
    swift_bridgeObjectRetain(object, v30, v31, v32);
    swift_bridgeObjectRelease(v29);
    unint64_t v41 = countAndFlagsBits;
    unint64_t v83 = countAndFlagsBits;
    unint64_t v84 = object;
    unint64_t v40 = object;
  }

  uint64_t v43 = HIBYTE(v40) & 0xF;
  if ((v40 & 0x2000000000000000LL) == 0) {
    uint64_t v43 = v41 & 0xFFFFFFFFFFFFLL;
  }
  if (v43 || (v41 & ~v40 & 0x2000000000000000LL) != 0)
  {
    if ((v40 & 0x2000000000000000LL) == 0
      || (unint64_t v44 = specialized _SmallString.init(_:appending:)(v41, v40, 0x5B28uLL, 0xE200000000000000LL), (v46 & 1) != 0))
    {
      _StringGuts.append(_:)(23336LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v34 = v83;
      unint64_t v33 = v84;
    }

    else
    {
      uint64_t v34 = v44;
      unint64_t v33 = v45;
      swift_bridgeObjectRelease(v40);
      swift_bridgeObjectRelease(0xE200000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v40);
    unint64_t v33 = 0xE200000000000000LL;
    uint64_t v34 = 23336LL;
  }

  uint64_t v10 = v77;
LABEL_34:
  uint64_t v47 = v78;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  unint64_t v83 = v34;
  unint64_t v84 = v33;
  (*(void (**)(uint64_t, void (*)(unint64_t, unint64_t), uint64_t))(v17 + 16))( v47,  v79,  v4);
  (*(void (**)(uint64_t, uint64_t))(v6 + 32))(v4, v6);
  unint64_t v48 = v81;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  v4,  v81,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v79 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v79(v48, AssociatedConformanceWitness);
  uint64_t v50 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48);
  if (v50(v16, 1LL, AssociatedTypeWitness) != 1)
  {
    uint64_t v62 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
    v62(v10, v16, AssociatedTypeWitness);
    uint64_t v63 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    __int128 v78 = xmmword_1817FFC60;
    while (1)
    {
      inited = swift_initStackObject(v63, v82);
      *((_OWORD *)inited + 1) = v78;
      inited[7] = AssociatedTypeWitness;
      boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
      v62(boxed_opaque_existential_0Tm, v10, AssociatedTypeWitness);
      specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  (uint64_t *)&v83);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      swift_setDeallocating((uint64_t)inited);
      swift_arrayDestroy((uint64_t)(inited + 4), 1LL, (uint64_t)&unk_189B8D218);
      v79(v81, AssociatedConformanceWitness);
      if (v50(v16, 1LL, AssociatedTypeWitness) == 1) {
        break;
      }
      v62(v10, v16, AssociatedTypeWitness);
      uint64_t v66 = v84;
      unint64_t v67 = HIBYTE(v84) & 0xF;
      if ((v84 & 0x2000000000000000LL) == 0) {
        unint64_t v67 = v83 & 0xFFFFFFFFFFFFLL;
      }
      if (v67 || (v83 & ~v84 & 0x2000000000000000LL) != 0)
      {
        if ((v84 & 0x2000000000000000LL) == 0
          || (unint64_t v68 = specialized _SmallString.init(_:appending:)(v83, v84, 0x202CuLL, 0xE200000000000000LL),
              (v70 & 1) != 0))
        {
          _StringGuts.append(_:)(8236LL, 0xE200000000000000LL, 0LL, 2LL);
          swift_bridgeObjectRelease(0xE200000000000000LL);
        }

        else
        {
          unint64_t v71 = v68;
          unint64_t v72 = v69;
          swift_bridgeObjectRelease(v66);
          swift_bridgeObjectRelease(0xE200000000000000LL);
          unint64_t v83 = v71;
          unint64_t v84 = v72;
        }

        uint64_t v10 = v77;
      }

      else
      {
        swift_bridgeObjectRelease(v84);
        unint64_t v83 = 8236LL;
        unint64_t v84 = 0xE200000000000000LL;
      }
    }
  }

  (*(void (**)(char *, unint64_t))(v75 + 8))(v80, v81);
  if (v76) {
    unint64_t v51 = 10589LL;
  }
  else {
    unint64_t v51 = 93LL;
  }
  if (v76) {
    unint64_t v52 = 0xE200000000000000LL;
  }
  else {
    unint64_t v52 = 0xE100000000000000LL;
  }
  uint64_t v53 = v84;
  unint64_t v54 = HIBYTE(v84) & 0xF;
  if ((v84 & 0x2000000000000000LL) == 0) {
    unint64_t v54 = v83 & 0xFFFFFFFFFFFFLL;
  }
  if (v54 || (v83 & ~v84 & 0x2000000000000000LL) != 0)
  {
    if ((v84 & 0x2000000000000000LL) == 0
      || (unint64_t v55 = specialized _SmallString.init(_:appending:)(v83, v84, v51, v52), (v57 & 1) != 0))
    {
      _StringGuts.append(_:)(v51, v52, 0LL, HIBYTE(v52) & 3);
      swift_bridgeObjectRelease(v52);
      unint64_t v51 = v83;
      unint64_t v52 = v84;
    }

    else
    {
      unint64_t v58 = v55;
      unint64_t v59 = v56;
      swift_bridgeObjectRelease(v53);
      swift_bridgeObjectRelease(v52);
      unint64_t v52 = v59;
      unint64_t v51 = v58;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v84);
  }

  uint64_t v60 = v51;
  uint64_t v61 = (void *)v52;
  result._unint64_t object = v61;
  result._uint64_t countAndFlagsBits = v60;
  return result;
}

uint64_t Array.description.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a2 - 8);
  uint64_t v5 = *(void *)(v4 + 64);
  uint64_t v6 = MEMORY[0x1895F8858](a1);
  uint64_t v7 = (char *)&v114 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = MEMORY[0x1895F8858](v6);
  uint64_t v10 = (char *)&v114 - v9;
  MEMORY[0x1895F8858](v8);
  unint64_t v124 = (char *)&v114 - v11;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v12 = 91LL;
  unint64_t v13 = 0xE100000000000000LL;
  uint64_t v127 = 91LL;
  unint64_t v128 = 0xE100000000000000LL;
  Swift::Int v123 = Array._getCount()();
  if (!v123) {
    goto LABEL_53;
  }
  uint64_t v114 = v5;
  uint64_t v12 = 0LL;
  unint64_t v122 = v3 & 0xC000000000000001LL;
  unint64_t v16 = 1LL;
  __int128 v121 = xmmword_1817FFC60;
  __int128 v116 = xmmword_1817FFC70;
  Swift::UInt64 v115 = 131073LL;
  char v119 = v7;
  uint64_t v120 = v3;
  while (1)
  {
    BOOL v23 = v122 == 0;
    char v24 = v23 | ~_swift_isClassOrObjCExistentialType(v2, (uint64_t *)v2);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v12, v24 & 1);
    if ((v24 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t, unint64_t))(v4 + 16))( v10,  v3 + ((*(unsigned __int8 *)(v4 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80))
      + *(void *)(v4 + 72) * v12,
        v2);
    }

    else
    {
      id v67 = _ArrayBuffer._getElementSlowPath(_:)(v12, v3, (uint64_t *)v2);
      unint64_t v13 = (unint64_t)v67;
      if (v114 != 8) {
        goto LABEL_124;
      }
      *(void *)&__int128 v125 = v67;
      (*(void (**)(char *, __int128 *, unint64_t))(v4 + 16))(v10, &v125, v2);
      swift_unknownObjectRelease((id)v13);
    }

    unint64_t v25 = *(void (**)(char *, char *, unint64_t))(v4 + 32);
    unint64_t v13 = (unint64_t)v124;
    unint64_t v26 = v10;
    v25(v124, v10, v2);
    uint64_t v27 = v12 + 1;
    if (__OFADD__(v12, 1LL))
    {
      __break(1u);
LABEL_112:
      Swift::Int v106 = String.UTF8View._foreignCount()();
      uint64_t v70 = v106 + 1;
      if (!__OFADD__(v106, 1LL)) {
        goto LABEL_65;
      }
      goto LABEL_114;
    }

    v25(v7, (char *)v13, v2);
    if ((v16 & 1) != 0) {
      goto LABEL_5;
    }
    uint64_t v31 = v127;
    uint64_t v30 = v128;
    unint64_t v32 = HIBYTE(v128) & 0xF;
    if ((v128 & 0x2000000000000000LL) != 0) {
      unint64_t v33 = HIBYTE(v128) & 0xF;
    }
    else {
      unint64_t v33 = v127 & 0xFFFFFFFFFFFFLL;
    }
    if (!v33 && (v127 & ~v128 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v128);
      uint64_t v127 = 8236LL;
      unint64_t v65 = 0xE200000000000000LL;
LABEL_46:
      unint64_t v128 = v65;
      goto LABEL_4;
    }

    if ((v128 & 0x2000000000000000LL) != 0 && v32 <= 0xD)
    {
      unint64_t v34 = 8 * (HIBYTE(v128) & 7);
      uint64_t v35 = (-255LL << v34) - 1;
      uint64_t v36 = 44LL << v34;
      char v37 = v32 + 1;
      if (v32 >= 8)
      {
        uint64_t v38 = v36 | v35 & v128;
LABEL_40:
        uint64_t v64 = (32LL << (8 * (v37 & 7u))) | ((-255LL << (8 * (v37 & 7u))) - 1) & v38;
      }

      else
      {
        uint64_t v31 = v36 | v35 & v127;
        if (v32 == 7)
        {
          char v37 = 8;
          uint64_t v38 = v128;
          goto LABEL_40;
        }

        uint64_t v31 = (32LL << (8 * (v37 & 7u))) | ((-255LL << (8 * (v37 & 7u))) - 1) & v31;
        uint64_t v64 = v128;
      }

      swift_bridgeObjectRelease(v128);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v66 = 0xE000000000000000LL;
      if (v31 & 0x8080808080808080LL | v64 & 0x80808080808080LL) {
        unint64_t v66 = 0xA000000000000000LL;
      }
      unint64_t v65 = (v66 & 0xFF00000000000000LL | (v32 << 56) | v64 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
      uint64_t v127 = v31;
      goto LABEL_46;
    }

    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v28, v29);
    if ((v30 & 0x1000000000000000LL) == 0)
    {
      BOOL v39 = __OFADD__(v33, 2LL);
      int64_t v40 = v33 + 2;
      if (v39) {
        break;
      }
      goto LABEL_22;
    }

    Swift::Int v68 = String.UTF8View._foreignCount()();
    int64_t v40 = v68 + 2;
    if (__OFADD__(v68, 2LL)) {
      break;
    }
LABEL_22:
    if ((v31 & ~v30 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v30 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v41 = _StringGuts.nativeUnusedCapacity.getter(v31, v30);
      if ((v42 & 1) != 0) {
        goto LABEL_126;
      }
      BOOL v44 = (v30 & 0x2000000000000000LL) == 0 && v41 > 1;
      if (v40 <= 15 && !v44)
      {
LABEL_35:
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        swift_bridgeObjectRetain(v30, v45, v46, v47);
        unint64_t v118 = _StringGuts._convertedToSmall()(v31, v30);
        unint64_t v117 = v48;
        swift_bridgeObjectRelease(v30);
        v49._Swift::UInt64 rawBits = 1LL;
        v50._Swift::UInt64 rawBits = v115;
        v51._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v49, v50, 0x202CuLL, 0xE200000000000000LL);
        if (v51._rawBits < 0x10000) {
          v51._rawBits |= 3;
        }
        unint64_t v53 = specialized String.init(_:)(v51, v52, 0x202CuLL, 0xE200000000000000LL);
        unint64_t v55 = v54;
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v56 = _StringGuts._convertedToSmall()(v53, v55);
        unint64_t v58 = v57;
        swift_bridgeObjectRelease(v55);
        unint64_t v59 = specialized _SmallString.init(_:appending:)(v118, v117, v56, v58);
        if ((v61 & 1) != 0) {
          goto LABEL_125;
        }
        uint64_t v62 = v59;
        unint64_t v63 = v60;
        swift_bridgeObjectRelease(v30);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        uint64_t v127 = v62;
        unint64_t v128 = v63;
        goto LABEL_4;
      }
    }

    else if (v40 <= 15)
    {
      goto LABEL_35;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v40, 2LL);
    swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
    __int128 v125 = v116;
    uint64_t v17 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v125, 2LL);
    _StringGuts.appendInPlace(_:isASCII:)(v17, v18, 1);
    swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_4:
    uint64_t v7 = v119;
    uint64_t v3 = v120;
LABEL_5:
    uint64_t v19 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v19, v126);
    *((_OWORD *)inited + 1) = v121;
    inited[7] = v2;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v25(boxed_opaque_existential_0Tm, v7, v2);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v127);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    unint64_t v16 = 0LL;
    ++v12;
    BOOL v22 = v27 == v123;
    uint64_t v10 = v26;
    if (v22) {
      goto LABEL_52;
    }
  }

  __break(1u);
LABEL_52:
  uint64_t v12 = v127;
  unint64_t v13 = v128;
LABEL_53:
  unint64_t v16 = HIBYTE(v13) & 0xF;
  unint64_t v2 = v12 & 0xFFFFFFFFFFFFLL;
  if ((v13 & 0x2000000000000000LL) != 0) {
    uint64_t v69 = HIBYTE(v13) & 0xF;
  }
  else {
    uint64_t v69 = v12 & 0xFFFFFFFFFFFFLL;
  }
  if (!v69 && (v12 & ~v13 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v13);
    return 93LL;
  }

  if ((v13 & 0x2000000000000000LL) != 0 && v16 != 15)
  {
    if (v16 < 8) {
      uint64_t v12 = (93LL << (8 * (HIBYTE(v13) & 7u))) | ((-255LL << (8 * (HIBYTE(v13) & 7u))) - 1) & v12;
    }
    goto LABEL_62;
  }

  swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v14, v15);
  if ((v13 & 0x1000000000000000LL) != 0) {
    goto LABEL_112;
  }
  BOOL v39 = __OFADD__(v69, 1LL);
  uint64_t v70 = v69 + 1;
  if (v39)
  {
LABEL_114:
    __break(1u);
    goto LABEL_115;
  }

LABEL_65:
  unint64_t v71 = v12 & ~v13;
  if ((v71 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v70 <= 15) {
      goto LABEL_82;
    }
LABEL_71:
    int64_t v74 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
    BOOL v77 = (v75 & 1) == 0 && v74 > 0;
    if ((v71 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v77) {
        goto LABEL_107;
      }
    }

    else if (v77)
    {
LABEL_106:
      _StringGuts.grow(_:)(v70);
LABEL_107:
      swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
      __int128 v125 = xmmword_1817FFC80;
      uint64_t v103 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v125, 1LL);
      _StringGuts.appendInPlace(_:isASCII:)(v103, v104, 1);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return v127;
    }

    uint64_t v99 = _StringGuts.nativeCapacity.getter(v12, v13);
    if ((v100 & 1) != 0) {
      uint64_t v101 = 0LL;
    }
    else {
      uint64_t v101 = v99;
    }
    if (v101 + 0x4000000000000000LL < 0)
    {
      __break(1u);
LABEL_124:
      swift_unknownObjectRelease((id)v13);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    uint64_t v102 = 2 * v101;
    if (v102 > v70) {
      uint64_t v70 = v102;
    }
    goto LABEL_106;
  }

  int64_t v72 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
  if ((v73 & 1) != 0)
  {
LABEL_126:
    unint64_t v110 = 258LL;
LABEL_127:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v110,  0);
  }

  if (v70 > 15) {
    goto LABEL_71;
  }
  if ((v13 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
    goto LABEL_83;
  }

  if (v72 > 0) {
    goto LABEL_71;
  }
LABEL_82:
  swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
  if ((v13 & 0x2000000000000000LL) != 0)
  {
LABEL_83:
    unint64_t v2 = v13;
  }

  else if ((v13 & 0x1000000000000000LL) != 0)
  {
    uint64_t v12 = _StringGuts._foreignConvertedToSmall()(v12, v13);
    unint64_t v2 = v113;
  }

  else
  {
    if ((v12 & 0x1000000000000000LL) != 0)
    {
      uint64_t v109 = (unsigned __int8 *)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v109 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v12, v13);
      unint64_t v2 = v78;
    }

    swift_bridgeObjectRetain(v13, v78, v79, v80);
    closure #1 in _StringGuts._convertedToSmall()(v109, v2, &v125);
    swift_bridgeObjectRelease(v13);
    unint64_t v2 = *((void *)&v125 + 1);
    uint64_t v12 = v125;
  }

  v81._Swift::UInt64 rawBits = 1LL;
  v82._Swift::UInt64 rawBits = 65537LL;
  v83._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v81, v82, 0x5DuLL, 0xE100000000000000LL);
  if (v83._rawBits < 0x10000) {
    v83._rawBits |= 3;
  }
  unint64_t v16 = specialized String.init(_:)(v83, v84, 0x5DuLL, 0xE100000000000000LL);
  uint64_t v70 = v85;
  swift_bridgeObjectRelease(0xE100000000000000LL);
  if ((v70 & 0x2000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v70);
    goto LABEL_88;
  }

  Swift::String result = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v24);
  if (result <= 63) {
    goto LABEL_61;
  }
LABEL_62:
  uint64_t v30 = 8LL;
  if (v8) {
    uint64_t v30 = 4LL;
  }
  *a1 = v4 & 2 | v30 | v23 | 1;
  return result;
}

  uint64_t v185 = a5;
  a5 = a2;
  uint64_t v27 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v27);
  uint64_t v28 = specialized Collection.subscript.getter(v18, (uint64_t)v11, v10);
  unint64_t v32 = v28;
  unint64_t v33 = v29;
  unint64_t v34 = v30;
  uint64_t v35 = v31;
  uint64_t v36 = v28;
  if (v28 != v29)
  {
    specialized Slice.subscript.getter(v28, v28, v29, v30, v31);
    uint64_t v36 = v32 + 1;
    if (__OFADD__(v32, 1LL))
    {
LABEL_186:
      v183 = 1525LL;
      goto LABEL_187;
    }
  }

  v184 = a4;
  a4 = v33 + v32 - v36;
  char v37 = v32;
  while (1)
  {
    if (v33 == v36) {
      goto LABEL_80;
    }
    uint64_t v38 = specialized Slice.subscript.getter(v36, v32, v33, v34, v35);
    if (__OFADD__(v36, 1LL)) {
      goto LABEL_186;
    }
    if ((v38 & 0xC0) != 0x80) {
      break;
    }
    ++v36;
    BOOL v39 = __OFADD__(v37++, 1LL);
    if (v39)
    {
      __break(1u);
LABEL_74:
      int64_t v40 = v10 - 8;
      int64_t v41 = 8LL;
      if (v10 < 8) {
        int64_t v41 = v10;
      }
      if ((v41 & 0x8000000000000000LL) == 0)
      {
        if (v41 < 8)
        {
          char v42 = 0LL;
          uint64_t v15 = 0LL;
          uint64_t v43 = 0LL;
          goto LABEL_165;
        }

        if (v41 >= 0x10)
        {
          char v42 = v41 & 0xFFFFFFFFFFFFFFF0LL;
          uint64_t v101 = vmovl_high_u8(*v11);
          uint64_t v102 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v101.i8);
          uint64_t v103 = vmovl_u8(*(uint8x8_t *)v11->i8);
          size_t v104 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v103.i8);
          uint64_t v105 = (int8x16_t)vmovl_high_u16(v101);
          Swift::Int v106 = (int8x8_t)vextq_s8(v105, v105, 8uLL).u64[0];
          uint64_t v107 = (int8x16_t)vmovl_high_u16(v103);
          uint64_t v108 = (int8x8_t)vextq_s8(v107, v107, 8uLL).u64[0];
          *(int8x8_t *)v107.i8 = vorr_s8(*(int8x8_t *)v107.i8, *(int8x8_t *)v105.i8);
          v109.i64[0] = v107.u32[0];
          v109.i64[1] = v107.u32[1];
          unint64_t v110 = (int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_1817FFCE0);
          *(int8x8_t *)v105.i8 = vorr_s8(*(int8x8_t *)v104.i8, *(int8x8_t *)v102.i8);
          v109.i64[0] = v105.u32[0];
          v109.i64[1] = v105.u32[1];
          uint64_t v111 = vorrq_s8((int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_1817FFCD0), v110);
          *(int8x8_t *)v105.i8 = vorr_s8(v108, v106);
          v109.i64[0] = v105.u32[0];
          v109.i64[1] = v105.u32[1];
          uint64_t v112 = (int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_1817FFCC0);
          *(int8x8_t *)v102.i8 = vorr_s8( (int8x8_t)*(_OWORD *)&vextq_s8(v104, v104, 8uLL),  (int8x8_t)*(_OWORD *)&vextq_s8(v102, v102, 8uLL));
          v109.i64[0] = v102.u32[0];
          v109.i64[1] = v102.u32[1];
          unint64_t v113 = vorrq_s8(v111, vorrq_s8((int8x16_t)vshlq_u64(v109, (uint64x2_t)xmmword_1817FFCB0), v112));
          uint64_t v15 = vorr_s8(*(int8x8_t *)v113.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v113, v113, 8uLL));
          if (v41 != (v41 & 0xFFFFFFFFFFFFFFF0LL))
          {
            uint64_t v43 = 8 * v42;
            if ((v41 & 8) == 0) {
              goto LABEL_165;
            }
            goto LABEL_159;
          }
        }

        else
        {
          uint64_t v15 = 0LL;
          uint64_t v43 = 0LL;
          char v42 = 0LL;
LABEL_159:
          uint64_t v78 = v42;
          uint64_t v79 = vdupq_n_s64(v43);
          char v42 = v41 & 0xFFFFFFFFFFFFFFF8LL;
          uint64_t v43 = 8 * (v41 & 0xFFFFFFFFFFFFFFF8LL);
          unint64_t v80 = 0uLL;
          Swift::String::Index v81 = (int8x16_t)(unint64_t)v15;
          Swift::String::Index v82 = vaddq_s64(v79, (int64x2_t)xmmword_1817FFCC0);
          Swift::String::Index v83 = vaddq_s64(v79, (int64x2_t)xmmword_1817FFCE0);
          Swift::String::Index v84 = vaddq_s64(v79, (int64x2_t)xmmword_1817FFCB0);
          uint64_t v85 = vaddq_s64(v79, (int64x2_t)xmmword_1817FFCD0);
          uint64_t v86 = (uint8x8_t *)&v11->i8[v78];
          uint64_t v87 = (int8x16_t)vdupq_n_s64(0x38uLL);
          char v88 = v78 - (v41 & 0xFFFFFFFFFFFFFFF8LL);
          unint64_t v89 = vdupq_n_s64(0x40uLL);
          unint64_t v90 = 0uLL;
          unint64_t v91 = 0uLL;
          do
          {
            unint64_t v92 = *v86++;
            unint64_t v93 = vmovl_u8(v92);
            char v94 = vmovl_high_u16(v93);
            v95.i64[0] = v94.u32[2];
            v95.i64[1] = v94.u32[3];
            unint64_t v96 = v95;
            v95.i64[0] = v94.u32[0];
            v95.i64[1] = v94.u32[1];
            unint64_t v97 = v95;
            unint64_t v98 = vmovl_u16(*(uint16x4_t *)v93.i8);
            v95.i64[0] = v98.u32[2];
            v95.i64[1] = v98.u32[3];
            uint64_t v99 = v95;
            v95.i64[0] = v98.u32[0];
            v95.i64[1] = v98.u32[1];
            unint64_t v91 = vorrq_s8((int8x16_t)vshlq_u64(v96, (uint64x2_t)vandq_s8((int8x16_t)v82, v87)), v91);
            unint64_t v90 = vorrq_s8((int8x16_t)vshlq_u64(v97, (uint64x2_t)vandq_s8((int8x16_t)v83, v87)), v90);
            unint64_t v80 = vorrq_s8((int8x16_t)vshlq_u64(v99, (uint64x2_t)vandq_s8((int8x16_t)v84, v87)), v80);
            Swift::String::Index v81 = vorrq_s8((int8x16_t)vshlq_u64(v95, (uint64x2_t)vandq_s8((int8x16_t)v85, v87)), v81);
            Swift::String::Index v83 = vaddq_s64(v83, v89);
            Swift::String::Index v84 = vaddq_s64(v84, v89);
            uint64_t v85 = vaddq_s64(v85, v89);
            Swift::String::Index v82 = vaddq_s64(v82, v89);
            v88 += 8LL;
          }

          while (v88);
          char v100 = vorrq_s8(vorrq_s8(v81, v90), vorrq_s8(v80, v91));
          uint64_t v15 = vorr_s8(*(int8x8_t *)v100.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v100, v100, 8uLL));
          if (v41 != v42)
          {
LABEL_165:
            uint64_t v114 = &v11->u8[v42];
            Swift::UInt64 v115 = v41 - v42;
            do
            {
              __int128 v116 = *v114++;
              *(void *)&v15 |= (unint64_t)v116 << (v43 & 0x38);
              v43 += 8LL;
              --v115;
            }

            while (v115);
          }
        }

        if (v10 < 9)
        {
          unint64_t v118 = 0LL;
        }

        else
        {
          if (v40 < 8)
          {
            unint64_t v117 = 0LL;
            unint64_t v118 = 0LL;
            char v119 = 0LL;
            goto LABEL_180;
          }

          if (v40 >= 0x10)
          {
            uint64_t v120 = (uint8x16_t *)&v11->u64[1];
            unint64_t v117 = v40 & 0xFFFFFFFFFFFFFFF0LL;
            __int128 v121 = (int64x2_t)xmmword_1817FFD60;
            unint64_t v122 = (int64x2_t)xmmword_1817FFD70;
            Swift::Int v123 = (int64x2_t)xmmword_1817FFD80;
            unint64_t v124 = (int64x2_t)xmmword_1817FFD90;
            __int128 v125 = (int64x2_t)xmmword_1817FFCC0;
            char v126 = (int64x2_t)xmmword_1817FFCE0;
            uint64_t v127 = (int8x16_t)vdupq_n_s64(0x38uLL);
            unint64_t v128 = vdupq_n_s64(0x80uLL);
            Swift::String v129 = (int64x2_t)xmmword_1817FFCB0;
            char v119 = 8 * (v40 & 0xFFFFFFFFFFFFFFF0LL);
            v130 = 0uLL;
            v131 = 0uLL;
            uint64_t v132 = (int64x2_t)xmmword_1817FFCD0;
            BOOL v133 = v40 & 0xFFFFFFFFFFFFFFF0LL;
            uint64_t v134 = 0uLL;
            v135 = 0uLL;
            char v136 = 0uLL;
            v137 = 0uLL;
            v138 = 0uLL;
            v139 = 0uLL;
            do
            {
              v140 = *v120++;
              v141 = vmovl_u8(*(uint8x8_t *)v140.i8);
              unint64_t v142 = vmovl_high_u16(v141);
              v143.i64[0] = v142.u32[2];
              v143.i64[1] = v142.u32[3];
              unint64_t v144 = v143;
              v145 = vmovl_high_u8(v140);
              v146 = vmovl_u16(*(uint16x4_t *)v145.i8);
              v143.i64[0] = v146.u32[2];
              v143.i64[1] = v146.u32[3];
              v147 = v143;
              v143.i64[0] = v146.u32[0];
              v143.i64[1] = v146.u32[1];
              uint64_t v148 = v143;
              v143.i64[0] = v142.u32[0];
              v143.i64[1] = v142.u32[1];
              v149 = v143;
              v150 = vmovl_u16(*(uint16x4_t *)v141.i8);
              v143.i64[0] = v150.u32[2];
              v143.i64[1] = v150.u32[3];
              v151 = v143;
              unint64_t v152 = vmovl_high_u16(v145);
              v143.i64[0] = v152.u32[0];
              v143.i64[1] = v152.u32[1];
              v153 = v143;
              v143.i64[0] = v150.u32[0];
              v143.i64[1] = v150.u32[1];
              unint64_t v154 = v143;
              v143.i64[0] = v152.u32[2];
              v143.i64[1] = v152.u32[3];
              v135 = vorrq_s8((int8x16_t)vshlq_u64(v144, (uint64x2_t)vandq_s8((int8x16_t)v125, v127)), v135);
              v137 = vorrq_s8((int8x16_t)vshlq_u64(v147, (uint64x2_t)vandq_s8((int8x16_t)v123, v127)), v137);
              char v136 = vorrq_s8((int8x16_t)vshlq_u64(v148, (uint64x2_t)vandq_s8((int8x16_t)v124, v127)), v136);
              uint64_t v134 = vorrq_s8((int8x16_t)vshlq_u64(v149, (uint64x2_t)vandq_s8((int8x16_t)v126, v127)), v134);
              v131 = vorrq_s8((int8x16_t)vshlq_u64(v151, (uint64x2_t)vandq_s8((int8x16_t)v129, v127)), v131);
              v138 = vorrq_s8((int8x16_t)vshlq_u64(v153, (uint64x2_t)vandq_s8((int8x16_t)v122, v127)), v138);
              v130 = vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)vandq_s8((int8x16_t)v132, v127)), v130);
              v139 = vorrq_s8((int8x16_t)vshlq_u64(v143, (uint64x2_t)vandq_s8((int8x16_t)v121, v127)), v139);
              char v126 = vaddq_s64(v126, v128);
              Swift::String v129 = vaddq_s64(v129, v128);
              uint64_t v132 = vaddq_s64(v132, v128);
              __int128 v125 = vaddq_s64(v125, v128);
              unint64_t v124 = vaddq_s64(v124, v128);
              Swift::Int v123 = vaddq_s64(v123, v128);
              unint64_t v122 = vaddq_s64(v122, v128);
              __int128 v121 = vaddq_s64(v121, v128);
              v133 -= 16LL;
            }

            while (v133);
            v155 = vorrq_s8( vorrq_s8(vorrq_s8(v130, v136), vorrq_s8(v134, v138)),  vorrq_s8(vorrq_s8(v131, v137), vorrq_s8(v135, v139)));
            unint64_t v118 = vorr_s8(*(int8x8_t *)v155.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v155, v155, 8uLL));
            if (v40 != v117)
            {
              if ((v40 & 8) == 0) {
                goto LABEL_180;
              }
              goto LABEL_177;
            }
          }

          else
          {
            unint64_t v118 = 0LL;
            char v119 = 0LL;
            unint64_t v117 = 0LL;
LABEL_177:
            v156 = v117;
            unint64_t v117 = v40 & 0xFFFFFFFFFFFFFFF8LL;
            uint64_t v157 = vdupq_n_s64(v119);
            char v119 = 8 * (v40 & 0xFFFFFFFFFFFFFFF8LL);
            v158 = (int8x16_t)(unint64_t)v118;
            v159 = 0uLL;
            v160 = vaddq_s64(v157, (int64x2_t)xmmword_1817FFCC0);
            v161 = vaddq_s64(v157, (int64x2_t)xmmword_1817FFCE0);
            v162 = vaddq_s64(v157, (int64x2_t)xmmword_1817FFCB0);
            v163 = vaddq_s64(v157, (int64x2_t)xmmword_1817FFCD0);
            v164 = (uint8x8_t *)((char *)&v11->u64[1] + v156);
            uint64_t v165 = (int8x16_t)vdupq_n_s64(0x38uLL);
            v166 = v156 - (v40 & 0xFFFFFFFFFFFFFFF8LL);
            v167 = vdupq_n_s64(0x40uLL);
            v168 = 0uLL;
            v169 = 0uLL;
            do
            {
              v170 = *v164++;
              v171 = vmovl_u8(v170);
              v172 = vmovl_high_u16(v171);
              v173.i64[0] = v172.u32[2];
              v173.i64[1] = v172.u32[3];
              unint64_t v174 = v173;
              v173.i64[0] = v172.u32[0];
              v173.i64[1] = v172.u32[1];
              v175 = v173;
              v176 = vmovl_u16(*(uint16x4_t *)v171.i8);
              v173.i64[0] = v176.u32[2];
              v173.i64[1] = v176.u32[3];
              v177 = v173;
              v173.i64[0] = v176.u32[0];
              v173.i64[1] = v176.u32[1];
              v169 = vorrq_s8((int8x16_t)vshlq_u64(v174, (uint64x2_t)vandq_s8((int8x16_t)v160, v165)), v169);
              v168 = vorrq_s8((int8x16_t)vshlq_u64(v175, (uint64x2_t)vandq_s8((int8x16_t)v161, v165)), v168);
              v159 = vorrq_s8((int8x16_t)vshlq_u64(v177, (uint64x2_t)vandq_s8((int8x16_t)v162, v165)), v159);
              v158 = vorrq_s8((int8x16_t)vshlq_u64(v173, (uint64x2_t)vandq_s8((int8x16_t)v163, v165)), v158);
              v161 = vaddq_s64(v161, v167);
              v162 = vaddq_s64(v162, v167);
              v163 = vaddq_s64(v163, v167);
              v160 = vaddq_s64(v160, v167);
              v166 += 8LL;
            }

            while (v166);
            v178 = vorrq_s8(vorrq_s8(v158, v168), vorrq_s8(v159, v169));
            unint64_t v118 = vorr_s8(*(int8x8_t *)v178.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v178, v178, 8uLL));
            if (v40 != v117)
            {
LABEL_180:
              v179 = v10 - v117 - 8;
              v180 = &v11->u8[v117 + 8];
              do
              {
                v181 = *v180++;
                *(void *)&v118 |= (unint64_t)v181 << (v119 & 0x38);
                v119 += 8LL;
                --v179;
              }

              while (v179);
            }
          }
        }

        uint64_t v182 = 0xA000000000000000LL;
        if (((*(void *)&v118 | *(void *)&v15) & 0x8080808080808080LL) == 0) {
          uint64_t v182 = 0xE000000000000000LL;
        }
        unint64_t v16 = v182 | (v10 << 56) | *(void *)&v118;
        goto LABEL_185;
      }

  if (v8 >= 0x4000)
  {
    v41._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)v8)._rawBits;
    String.subscript.getter(v41, a1, a2);
    unint64_t v25 = v42;
    BOOL v39 = 0LL;
    goto LABEL_63;
  }

  return 1LL;
}

    uint64_t v36 = (rawBits >> 14) - (unint64_t)(v9 >> 14);
    char v37 = __OFADD__(v36, v14);
    Swift::String result = v36 + v14;
    if (!v37) {
      return result;
    }
    __break(1u);
LABEL_69:
    uint64_t v10 = _StringObject.sharedUTF8.getter(v7, v6);
    uint64_t v11 = v39;
  }

      uint64_t v62 = v24;
      unint64_t v66 = v23;
      uint64_t v70 = v21;
      uint64_t v43 = v22;
      uint64_t v28 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v29);
      char v24 = v62;
      BOOL v23 = v66;
      BOOL v22 = v43;
      unint64_t v21 = v70;
      goto LABEL_41;
    }

      char v42 = v40 + 1;
      do
      {
        *((void *)v39 + v41 + 1) = *(void *)(v15 + 8 * v41);
        int64_t v41 = v42++;
      }

      while (v16 > v41);
      goto LABEL_67;
    }

      char v42 = v40 + 1;
      do
      {
        *((void *)v39 + v41 + 1) = *(void *)(v15 + 8 * v41);
        int64_t v41 = v42++;
      }

      while (v16 > v41);
      goto LABEL_67;
    }

LABEL_115:
  if ((v70 & 0x1000000000000000LL) != 0)
  {
    unint64_t v16 = _StringGuts._foreignConvertedToSmall()(v16, v70);
    uint64_t v112 = v111;
    swift_bridgeObjectRelease(v70);
    uint64_t v70 = v112;
  }

  else
  {
    if ((v16 & 0x1000000000000000LL) != 0)
    {
      uint64_t v107 = (unsigned __int8 *)((v70 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v108 = v16 & 0xFFFFFFFFFFFFLL;
    }

    else
    {
      uint64_t v107 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v16, v70);
    }

    closure #1 in _StringGuts._convertedToSmall()(v107, v108, &v125);
    swift_bridgeObjectRelease(v70);
    uint64_t v70 = *((void *)&v125 + 1);
    unint64_t v16 = v125;
  }

                (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v212 + 56))(v332, 1LL, 1LL, v345);
                v284 = v97;
                goto LABEL_122;
              }

              v237 = v342 + 3;
            }
          }

LABEL_88:
  uint64_t v86 = HIBYTE(v2) & 0xF;
  uint64_t v87 = HIBYTE(v70) & 0xF;
  if ((unint64_t)(v87 + v86) > 0xF)
  {
LABEL_125:
    unint64_t v110 = 266LL;
    goto LABEL_127;
  }

  if (v87)
  {
    char v88 = 0;
    unint64_t v89 = 0LL;
    do
    {
      unint64_t v90 = v86 + v89;
      unint64_t v91 = v89 + 1;
      if (v89 >= 8) {
        unint64_t v92 = v70;
      }
      else {
        unint64_t v92 = v16;
      }
      unint64_t v93 = v92 >> (v88 & 0x38);
      char v94 = (8 * v86 + v88) & 0x38;
      uint64_t v95 = (-255LL << v94) - 1;
      unint64_t v96 = (unint64_t)v93 << v94;
      unint64_t v97 = v96 | v95 & v2;
      unint64_t v98 = v96 | v95 & v12;
      if (v90 < 8) {
        uint64_t v12 = v98;
      }
      else {
        unint64_t v2 = v97;
      }
      v88 += 8;
      unint64_t v89 = v91;
    }

    while (v87 != v91);
  }

                  swift_release_n((uint64_t)v139, 2LL);
                  __int128 v121 = v103;
LABEL_89:
                  swift_release(v121);
                  return;
                }

                ++v109;
              }

          v340 = 0LL;
          v243 = *(void (**)(char **, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v244 = lazy protocol witness table accessor for type Int and conformance Int(v235, v236, v237);
          v245 = v338;
          v243(&v340, &type metadata for Int, v244, a3, a4);
          v246 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL);
          v247 = v320;
          LOBYTE(v240) = v246(v320, v245, a3);
          v69(v245, a3);
          v248 = v247;
LABEL_120:
          v69(v248, a3);
LABEL_121:
          if ((v304 & 0x8000000000000000LL) == 0)
          {
            if ((v240 & 1) != 0) {
              v289 = 0x8000;
            }
            else {
              v289 = 0;
            }
            *v337 = (((_WORD)v304 << 10) + 15360) & 0x7C00 | (v230 << ((10 - v304) & 0xF)) & 0x3FF | v289;
            goto LABEL_18;
          }

    unint64_t v55 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
    swift_willThrow();
    swift_errorRelease(v55);
    unint64_t v56 = specialized Collection.subscript.getter(v69, v68, v61 - v52);
    Swift::String::Index v51 = findInvalidRange #1 (_:) in validateUTF8(_:)(v56, v57, v58, v59);
    Swift::String::Index v52 = v60;
    uint64_t v11 = (uint8x16_t *)v68;
    if (v10) {
      continue;
    }
    break;
  }

  uint64_t v15 = v186;
  unint64_t v16 = v187;
  a4 = v184;
LABEL_185:
  (*(void (**)(int8x8_t, int64_t, uint64_t, uint64_t))(a5 + 24))(v15, v16, a4, a5);
  swift_bridgeObjectRelease(v16);
}

    unint64_t v124 = (v131 - 1) & v131;
    Swift::String v129 = __clz(__rbit64(v131)) + (v123 << 6);
    char v61 = v157;
LABEL_89:
    (*(void (**)(char *, unint64_t, uint64_t *))(v8 + 16))( v105,  *(void *)(v61 + 48) + *(void *)(v8 + 72) * v129,  a2);
    __int128 v121 = v105;
    unint64_t v122 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v8 + 56);
  }

  uint64_t v132 = v109 + 3;
  v131 = *(void *)&v154[8 * v132];
  if (v131)
  {
    Swift::Int v123 = v109 + 3;
    goto LABEL_88;
  }

  while (1)
  {
    Swift::Int v123 = v132 + 1;
    if (__OFADD__(v132, 1LL)) {
      goto LABEL_107;
    }
    v131 = *(void *)&v154[8 * v123];
    ++v132;
    if (v131) {
      goto LABEL_88;
    }
  }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }

  if ((a1 & 0x1000000000000000LL) != 0)
  {
    Swift::Int v68 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
  }

  else
  {
    char v88 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
    if (v89 < __n) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
    }
    Swift::Int v68 = v88;
    if (__n)
    {
      uint64_t v69 = a1 & 0xFFFFFFFFFFFFLL;
      if (!v88) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer has a nil start and nonzero count",  53LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x541uLL,  0);
      }
      goto LABEL_68;
    }
  }

  uint64_t v69 = a1 & 0xFFFFFFFFFFFFLL;
LABEL_68:
  uint64_t v70 = v4[1];
  unint64_t v71 = v70 & 0xFFFFFFFFFFFFFFFLL;
  int64_t v72 = (v70 & 0xFFFFFFFFFFFFFFFLL) + 32;
  char v73 = (char *)(v72 + (*(void *)(v70 + 24) & 0xFFFFFFFFFFFFLL));
  if (&v73[v69] > v68 && v73 < &v68[v69]) {
    goto LABEL_88;
  }
  memcpy(v73, v68, v69);
  int64_t v74 = *(void *)(v71 + 24);
  char v75 = (v74 & 0xFFFFFFFFFFFFLL) + v69;
  if (((v74 & a1 & 0x8000000000000000LL) != 0LL) != v16) {
    v75 |= 0xC000000000000000LL;
  }
  unint64_t v76 = v75 | 0x3000000000000000LL;
  *(void *)(v71 + 24) = v75 | 0x3000000000000000LL;
  *(_BYTE *)(v72 + (v75 & 0xFFFFFFFFFFFFLL)) = 0;
  BOOL v77 = *(void *)(v71 + 16);
  if (v77 < 0)
  {
    uint64_t v78 = (uint64_t *)((v72 + (v77 & 0xFFFFFFFFFFFFLL) + 7) & 0x7FFFFFFFFFFFFFF8LL);
    uint64_t v79 = *v78;
    const char *v78 = 0LL;
    swift_release(v79);
    unint64_t v76 = *(void *)(v71 + 24);
  }

  *uint64_t v4 = v76;
  swift_bridgeObjectRelease(a2);
}

            uint64_t v78 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
            if (!v78 || (uint64_t v79 = *((void *)this + 2), v78 + 24 > v79))
            {
              unint64_t v80 = 2LL * *((void *)this + 4);
              if (v80 <= 0x20) {
                unint64_t v80 = 32LL;
              }
              *((void *)this + 4) = v80;
              Swift::String::Index v81 = v80 + 8;
              Swift::String::Index v82 = malloc(v80 + 8);
              uint64_t v79 = (unint64_t)v82 + v81;
              *Swift::String::Index v82 = *((void *)this + 3);
              uint64_t v78 = ((unint64_t)v82 + 15) & 0xFFFFFFFFFFFFFFF8LL;
              *((void *)this + 2) = v79;
              *((void *)this + 3) = v82;
            }

            *(_WORD *)(v78 + 16) = 113;
            *(_BYTE *)(v78 + 18) = 0;
            Swift::String::Index v83 = (v78 + 31) & 0xFFFFFFFFFFFFFFF8LL;
            if (!v83 || v83 + 24 > v79)
            {
              Swift::String::Index v84 = 2LL * *((void *)this + 4);
              if (v84 <= 0x20) {
                Swift::String::Index v84 = 32LL;
              }
              *((void *)this + 4) = v84;
              uint64_t v85 = v84 + 8;
              uint64_t v86 = malloc(v84 + 8);
              uint64_t v87 = (char *)v86 + v85;
              char *v86 = *((void *)this + 3);
              Swift::String::Index v83 = ((unint64_t)v86 + 15) & 0xFFFFFFFFFFFFFFF8LL;
              *((void *)this + 2) = v87;
              *((void *)this + 3) = v86;
            }

            *((void *)this + 1) = v83 + 24;
            char v88 = strlen(v76);
            *(_WORD *)(v83 + 16) = 114;
            *(_BYTE *)(v83 + 18) = 3;
            *(void *)Swift::String::Index v83 = v76;
            *(void *)(v83 + 8) = v88;
            swift::Demangle::__runtime::Node::addChild( (unsigned int *)v78,  (swift::Demangle::__runtime::Node *)v83,  this,  v89,  v90);
            if (v75)
            {
              unint64_t v93 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleClangType(this);
              if (v93) {
                swift::Demangle::__runtime::Node::addChild((unsigned int *)v78, v93, this, v91, v92);
              }
            }

            swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v78,  this,  v91,  v92);
            unint64_t v71 = *((void *)this + 8);
            BOOL v77 = *((void *)this + 9);
            if (v77 < v71) {
              goto LABEL_102;
            }
            goto LABEL_112;
          default:
            goto LABEL_81;
        }
      }

      char v73 = *((void *)this + 9);
LABEL_81:
      BOOL v77 = v73 - 1;
LABEL_82:
      *((void *)this + 9) = v77;
      if (v77 >= v71) {
        goto LABEL_112;
      }
LABEL_102:
      char v94 = *(unsigned __int8 *)(*((void *)this + 7) + v77);
      if (v94 == 65)
      {
        uint64_t v95 = "@yield_once";
      }

      else
      {
        if (v94 != 71) {
          goto LABEL_112;
        }
        uint64_t v95 = "@yield_many";
      }

      *((void *)this + 9) = v77 + 1;
      unint64_t v96 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
      if (!v96 || v96 + 24 > *((void *)this + 2))
      {
        unint64_t v97 = 2LL * *((void *)this + 4);
        if (v97 <= 0x20) {
          unint64_t v97 = 32LL;
        }
        *((void *)this + 4) = v97;
        unint64_t v98 = v97 + 8;
        uint64_t v99 = malloc(v97 + 8);
        char *v99 = *((void *)this + 3);
        unint64_t v96 = ((unint64_t)v99 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)this + 2) = (char *)v99 + v98;
        *((void *)this + 3) = v99;
      }

      *((void *)this + 1) = v96 + 24;
      *(_WORD *)(v96 + 16) = 112;
      *(_BYTE *)(v96 + 18) = 3;
      *(void *)unint64_t v96 = v95;
      *(void *)(v96 + 8) = 11LL;
      swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v96,  this,  v69,  v70);
      unint64_t v71 = *((void *)this + 8);
      BOOL v77 = *((void *)this + 9);
LABEL_112:
      if (v77 < v71 && *(_BYTE *)(*((void *)this + 7) + v77) == 104)
      {
        *((void *)this + 9) = v77 + 1;
        char v100 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v100 || v100 + 24 > *((void *)this + 2))
        {
          uint64_t v101 = 2LL * *((void *)this + 4);
          if (v101 <= 0x20) {
            uint64_t v101 = 32LL;
          }
          *((void *)this + 4) = v101;
          uint64_t v102 = v101 + 8;
          uint64_t v103 = malloc(v101 + 8);
          char *v103 = *((void *)this + 3);
          char v100 = ((unint64_t)v103 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v103 + v102;
          *((void *)this + 3) = v103;
        }

        *((void *)this + 1) = v100 + 24;
        *(_WORD *)(v100 + 16) = 112;
        *(_BYTE *)(v100 + 18) = 3;
        *(void *)char v100 = "@Sendable";
        *(void *)(v100 + 8) = 9LL;
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v100,  this,  v69,  v70);
        unint64_t v71 = *((void *)this + 8);
        BOOL v77 = *((void *)this + 9);
      }

      if (v77 < v71 && *(_BYTE *)(*((void *)this + 7) + v77) == 72)
      {
        *((void *)this + 9) = v77 + 1;
        size_t v104 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v104 || v104 + 24 > *((void *)this + 2))
        {
          uint64_t v105 = 2LL * *((void *)this + 4);
          if (v105 <= 0x20) {
            uint64_t v105 = 32LL;
          }
          *((void *)this + 4) = v105;
          Swift::Int v106 = v105 + 8;
          uint64_t v107 = malloc(v105 + 8);
          unsigned __int8 *v107 = *((void *)this + 3);
          size_t v104 = ((unint64_t)v107 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v107 + v106;
          *((void *)this + 3) = v107;
        }

        *((void *)this + 1) = v104 + 24;
        *(_WORD *)(v104 + 16) = 112;
        *(_BYTE *)(v104 + 18) = 3;
        *(void *)size_t v104 = "@async";
        *(void *)(v104 + 8) = 6LL;
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v104,  this,  v69,  v70);
      }

      if (v38) {
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v38,  this,  v69,  v70);
      }
      uint64_t v108 = swift::Demangle::__runtime::Demangler::demangleImplParamConvention(this, 118);
      if (v108)
      {
        uint64_t v111 = (swift::Demangle::__runtime::Node *)v108;
        uint64_t v112 = 0;
        do
        {
          swift::Demangle::__runtime::Node::addChild((unsigned int *)v6, v111, this, v109, v110);
          char v119 = *((void *)this + 9);
          uint64_t v120 = "";
          if (v119 < *((void *)this + 8))
          {
            uint64_t v120 = "";
            if (*(_BYTE *)(*((void *)this + 7) + v119) == 119)
            {
              *((void *)this + 9) = v119 + 1;
              uint64_t v120 = "@noDerivative";
            }
          }

          __int128 v121 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
          if (!v121 || v121 + 24 > *((void *)this + 2))
          {
            unint64_t v122 = 2LL * *((void *)this + 4);
            if (v122 <= 0x20) {
              unint64_t v122 = 32LL;
            }
            *((void *)this + 4) = v122;
            Swift::Int v123 = v122 + 8;
            unint64_t v124 = malloc(v122 + 8);
            __int128 v125 = (char *)v124 + v123;
            *unint64_t v124 = *((void *)this + 3);
            __int128 v121 = ((unint64_t)v124 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *((void *)this + 2) = v125;
            *((void *)this + 3) = v124;
          }

          *((void *)this + 1) = v121 + 24;
          char v126 = strlen(v120);
          *(_WORD *)(v121 + 16) = 110;
          *(_BYTE *)(v121 + 18) = 3;
          *(void *)__int128 v121 = v120;
          *(void *)(v121 + 8) = v126;
          swift::Demangle::__runtime::Node::addChild( (unsigned int *)v111,  (swift::Demangle::__runtime::Node *)v121,  this,  v127,  v128);
          Swift::String v129 = *((void *)this + 9);
          if (v129 < *((void *)this + 8) && *(_BYTE *)(*((void *)this + 7) + v129) == 84)
          {
            *((void *)this + 9) = v129 + 1;
            unint64_t v118 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
            if (!v118 || v118 + 24 > *((void *)this + 2))
            {
              unint64_t v113 = 2LL * *((void *)this + 4);
              if (v113 <= 0x20) {
                unint64_t v113 = 32LL;
              }
              *((void *)this + 4) = v113;
              uint64_t v114 = v113 + 8;
              Swift::UInt64 v115 = malloc(v113 + 8);
              uint8x16_t *v115 = *((void *)this + 3);
              unint64_t v118 = ((unint64_t)v115 + 15) & 0xFFFFFFFFFFFFFFF8LL;
              *((void *)this + 2) = (char *)v115 + v114;
              *((void *)this + 3) = v115;
            }

            *((void *)this + 1) = v118 + 24;
            *(_WORD *)(v118 + 16) = 111;
            *(_BYTE *)(v118 + 18) = 3;
            *(void *)unint64_t v118 = "sending";
            *(void *)(v118 + 8) = 7LL;
            swift::Demangle::__runtime::Node::addChild( (unsigned int *)v111,  (swift::Demangle::__runtime::Node *)v118,  this,  v116,  v117);
          }

          ++v112;
          uint64_t v111 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleImplParamConvention( this,  118);
        }

        while (v111);
      }

      else
      {
        uint64_t v112 = 0;
      }

      v130 = *((void *)this + 9);
      if (v130 < *((void *)this + 8) && *(_BYTE *)(*((void *)this + 7) + v130) == 84)
      {
        *((void *)this + 9) = v130 + 1;
        v131 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        if (!v131 || v131 + 24 > *((void *)this + 2))
        {
          uint64_t v132 = 2LL * *((void *)this + 4);
          if (v132 <= 0x20) {
            uint64_t v132 = 32LL;
          }
          *((void *)this + 4) = v132;
          BOOL v133 = v132 + 8;
          uint64_t v134 = malloc(v132 + 8);
          *uint64_t v134 = *((void *)this + 3);
          v131 = ((unint64_t)v134 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *((void *)this + 2) = (char *)v134 + v133;
          *((void *)this + 3) = v134;
        }

        *((void *)this + 1) = v131 + 24;
        *(_WORD *)(v131 + 16) = 109;
        *(_BYTE *)(v131 + 18) = 0;
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v6,  (swift::Demangle::__runtime::Node *)v131,  this,  v109,  v110);
      }

      v135 = swift::Demangle::__runtime::Demangler::demangleImplResultConvention(this, 120);
      if (v135)
      {
        v138 = (swift::Demangle::__runtime::Node *)v135;
        do
        {
          if (v6) {
            swift::Demangle::__runtime::Node::addChild((unsigned int *)v6, v138, this, v136, v137);
          }
          v147 = *((void *)this + 9);
          uint64_t v148 = "";
          if (v147 < *((void *)this + 8))
          {
            uint64_t v148 = "";
            if (*(_BYTE *)(*((void *)this + 7) + v147) == 119)
            {
              *((void *)this + 9) = v147 + 1;
              uint64_t v148 = "@noDerivative";
            }
          }

          v143 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
          if (!v143 || v143 + 24 > *((void *)this + 2))
          {
            v139 = 2LL * *((void *)this + 4);
            if (v139 <= 0x20) {
              v139 = 32LL;
            }
            *((void *)this + 4) = v139;
            v140 = v139 + 8;
            v141 = malloc(v139 + 8);
            unint64_t v142 = (char *)v141 + v140;
            *v141 = *((void *)this + 3);
            v143 = ((unint64_t)v141 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *((void *)this + 2) = v142;
            *((void *)this + 3) = v141;
          }

          *((void *)this + 1) = v143 + 24;
          unint64_t v144 = strlen(v148);
          *(_WORD *)(v143 + 16) = 110;
          *(_BYTE *)(v143 + 18) = 3;
          *(void *)v143 = v148;
          *(void *)(v143 + 8) = v144;
          swift::Demangle::__runtime::Node::addChild( (unsigned int *)v138,  (swift::Demangle::__runtime::Node *)v143,  this,  v145,  v146);
          ++v112;
          v138 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleImplResultConvention( this,  120);
        }

        while (v138);
      }

      v150 = *((void *)this + 8);
      v149 = *((void *)this + 9);
      if (v149 >= v150 || *(_BYTE *)(*((void *)this + 7) + v149) != 89) {
        goto LABEL_181;
      }
      v151 = v112 + 1;
      break;
    default:
      return v59;
  }

  do
  {
    uint64_t v112 = v151;
    *((void *)this + 9) = v149 + 1;
    unint64_t v152 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleImplParamConvention( this,  121);
    if (!v152) {
      return 0LL;
    }
    if (v6) {
      swift::Demangle::__runtime::Node::addChild((unsigned int *)v6, v152, this, v136, v137);
    }
    v150 = *((void *)this + 8);
    v149 = *((void *)this + 9);
    if (v149 >= v150) {
      break;
    }
    v151 = v112 + 1;
  }

  while (*(_BYTE *)(*((void *)this + 7) + v149) == 89);
LABEL_181:
  if (v149 >= v150 || *(_BYTE *)(*((void *)this + 7) + v149) != 122) {
    goto LABEL_187;
  }
  *((void *)this + 9) = v149 + 1;
  v153 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::Demangler::demangleImplResultConvention( this,  122);
  if (!v153) {
    return 0LL;
  }
  if (v6) {
    swift::Demangle::__runtime::Node::addChild((unsigned int *)v6, v153, this, v136, v137);
  }
  ++v112;
  v150 = *((void *)this + 8);
  v149 = *((void *)this + 9);
LABEL_187:
  if (v149 >= v150 || *(_BYTE *)(*((void *)this + 7) + v149) != 95) {
    return 0LL;
  }
  *((void *)this + 9) = v149 + 1;
  if (v112 >= 1)
  {
    unint64_t v154 = 0LL;
    v155 = -(uint64_t)v112;
    v156 = 0LL;
    do
    {
      v158 = *((_DWORD *)this + 24);
      if (!v158) {
        return 0LL;
      }
      v159 = v158 - 1;
      v160 = *(swift::Demangle::__runtime::Node **)(*((void *)this + 11) + 8LL * v159);
      if (*((_WORD *)v160 + 8) != 232) {
        return 0LL;
      }
      *((_DWORD *)this + 24) = v159;
      v161 = *(unsigned __int8 *)(v6 + 18);
      switch(v161)
      {
        case 5:
          v163 = *(unsigned int *)(v6 + 8);
          v162 = v163 + ~v156;
          if (v163 > v162) {
            goto LABEL_203;
          }
          break;
        case 2:
          v162 = 1 - v156;
          break;
        case 1:
          v162 = v154;
          if (!v154)
          {
LABEL_203:
            v164 = v161 - 1;
            uint64_t v165 = v6;
            if (v164 >= 2) {
              uint64_t v165 = *(void *)v6;
            }
            uint64_t v157 = *(unsigned int **)(v165 + 8 * v162);
            goto LABEL_192;
          }

          break;
      }

      uint64_t v157 = 0LL;
LABEL_192:
      swift::Demangle::__runtime::Node::addChild(v157, v160, this, v136, v137);
      ++v156;
      --v154;
    }

    while (v155 != v154);
  }

  if (!v6) {
    return 0LL;
  }
  unint64_t v59 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v59 || v59 + 24 > *((void *)this + 2))
  {
    v166 = 2LL * *((void *)this + 4);
    if (v166 <= 0x20) {
      v166 = 32LL;
    }
    *((void *)this + 4) = v166;
    v167 = v166 + 8;
    v168 = malloc(v166 + 8);
    char *v168 = *((void *)this + 3);
    unint64_t v59 = ((unint64_t)v168 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = (char *)v168 + v167;
    *((void *)this + 3) = v168;
  }

  *((void *)this + 1) = v59 + 24;
  *(_WORD *)(v59 + 16) = 232;
  *(_BYTE *)(v59 + 18) = 0;
  swift::Demangle::__runtime::Node::addChild( (unsigned int *)v59,  (swift::Demangle::__runtime::Node *)v6,  this,  v136,  v137);
  return v59;
}

LABEL_62:
  swift_bridgeObjectRelease(v13);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v12;
}

          uint64_t v8 = 0;
          LODWORD(v15) = v7;
          goto LABEL_84;
        }

        uint64_t v5 = 1;
        if (!v6)
        {
          uint64_t v4 = v18;
          goto LABEL_72;
        }

        uint64_t v8 = 0;
        uint64_t v4 = v18;
        uint64_t v9 = v59;
LABEL_84:
        Swift::String::Index v51 = __OFSUB__(v6--, 1LL);
        if (!v51)
        {
          *(_DWORD *)uint64_t v9 = v15;
          uint64_t v9 = (__objc2_class **)((char *)v9 + 4);
          uint64_t v7 = v16;
          goto LABEL_2;
        }

        __break(1u);
LABEL_97:
        Swift::String::Index v52 = 688LL;
LABEL_91:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of range",  18LL,  2,  "Swift/ContiguousArrayBuffer.swift",  33LL,  2,  v52,  0);
      }

      BOOL v22 = WORD2(v15);
      BOOL v23 = v10[2];
      if (!v23) {
        break;
      }
      char v24 = (v15 >> 35);
      if (v24 > (*(unsigned __int16 *)&v19[8 * (void)v23 - 8] >> 3))
      {
        if ((v15 & 0x600000000LL) != 0 && v15 >= 0x300)
        {
          Composition = specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(v16, v15);
          if ((Composition & 0x100000000LL) == 0) {
            goto LABEL_13;
          }
          Composition = _swift_stdlib_getComposition(v16, v15);
          if ((_DWORD)Composition != -1) {
            goto LABEL_13;
          }
        }

        goto LABEL_38;
      }

      v251 = (v129 - 1) & v129;
      uint64_t v101 = __clz(__rbit64(v129)) + ((void)v130 << 6);
      v240 = v130;
    }

    uint64_t v103 = v261;
    size_t v104 = v252;
    uint64_t v105 = v267;
    (*(void (**)(char *, unint64_t, uint64_t *))(v261 + 16))( v252,  *(void *)(v80 + 48) + *(void *)(v261 + 72) * v101,  v267);
    Swift::Int v106 = v262;
    (*(void (**)(char *, unint64_t, uint64_t *))(v127 + 16))( v262,  *(void *)(v80 + 56) + *(void *)(v127 + 72) * v101,  v125);
    uint64_t v107 = &v102[*((int *)v126 + 12)];
    (*(void (**)(char *, char *, uint64_t *))(v103 + 32))(v102, v104, v105);
    (*(void (**)(char *, char *, uint64_t *))(v127 + 32))(v107, v106, v125);
    uint64_t v108 = v266;
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v266 + 56))(v102, 0LL, 1LL, v126);
LABEL_35:
    uint64_t v109 = v102;
    unint64_t v110 = v243;
    (*(void (**)(char *, char *, unint64_t *))(v108 + 32))(v243, v109, v126);
    uint64_t v111 = &v110[*((int *)v126 + 12)];
    uint64_t v112 = v255;
    unint64_t v113 = &v255[*((int *)TupleTypeMetadata2 + 12)];
    (*(void (**)(char *, char *, uint64_t *))(v103 + 32))(v104, v110, v105);
    uint64_t v114 = (unint64_t)v241;
    swift_dynamicCast(v112, v104, v105, v241, 7LL);
    (*(void (**)(char *, char *, uint64_t *))(v127 + 32))(v106, v111, v125);
    Swift::UInt64 v115 = v106;
    __int128 v116 = v259;
    swift_dynamicCast(v113, v115, v125, v259, 7LL);
    unint64_t v117 = v253;
    unint64_t v118 = &v253[*((int *)v254 + 12)];
    char v119 = (void (*)(char *, char *, unint64_t))v264[4];
    v119(v253, v112, v114);
    uint64_t v120 = *(void (**)(char *, char *, uint64_t *))(v265 + 32);
    v120(v118, v113, v116);
    __int128 v121 = v244;
    v119(v244, v117, v114);
    unint64_t v122 = v246;
    v120(v246, v118, v116);
    Swift::Int v123 = (uint64_t)v245;
    v119(v245, v121, v114);
    unint64_t v124 = (uint64_t)v247;
    v120(v247, v122, v116);
    unint64_t v71 = (unint64_t *)v260;
    _NativeDictionary._unsafeInsertNew(key:value:)(v123, v124, v260, v114, (uint64_t)v116, v258);
    unint64_t v92 = v249;
    unint64_t v93 = v250;
    unint64_t v80 = (unint64_t)v242;
  }

  BOOL v133 = v239;
  uint64_t v134 = *((void *)v239 + 27);
  __int128 v125 = v263;
  char v126 = v257;
  v135 = v237;
  if (v134 < 0)
  {
    v131 = v266;
    uint64_t v102 = v248;
    goto LABEL_116;
  }

  char v136 = (void *)*((void *)v239 + 26);
  if (v134 != *((void *)v239 + 28))
  {
LABEL_50:
    v138 = *((void *)v133 + 3);
    if (!v138) {
      goto LABEL_131;
    }
    v139 = v236;
    if ((unint64_t)(v134 - 0x1000000000000000LL) >> 61 != 7)
    {
      __break(1u);
LABEL_124:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/NativeDictionary.swift",  28LL,  2,  0x1FFuLL,  0);
    }

    v140 = (void **)(v138 + 8 * v134);
    v141 = *v140;
    *((void *)v133 + 27) = v134 + 1;
    swift_unknownObjectRetain(v141, v97, v98, v99);
    unint64_t v142 = (swift *)objc_msgSend(v136, sel_objectForKey_, v141);
    if (!v142) {
      goto LABEL_132;
    }
    v143 = v142;
    unint64_t v144 = v267;
    if (_swift_isClassOrObjCExistentialType((uint64_t)v267, v267))
    {
      v269 = (swift *)v141;
      uint64_t v102 = v248;
      swift_dynamicCast(v248, &v269, v238, v144, 7LL);
    }

    else
    {
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v261 + 56))(v92, 1LL, 1LL, v144);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v141, (uint64_t)v144, v92);
      swift_unknownObjectRelease(v141);
      v146 = v227;
      v147 = v144;
      uint64_t v148 = v228;
      (*(void (**)(char *, uint64_t *, uint64_t))(v227 + 16))(v135, v92, v228);
      (*(void (**)(uint64_t *, uint64_t))(v146 + 8))(v92, v148);
      uint64_t v102 = v248;
      (*(void (**)(void))(v261 + 32))();
    }

    v145 = &v102[*((int *)v126 + 12)];
    if (_swift_isClassOrObjCExistentialType((uint64_t)v125, v125))
    {
      v269 = v143;
      swift_dynamicCast(v145, &v269, &unk_189B8D230, v125, 7LL);
    }

    else
    {
      v149 = v268;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *))(v268 + 56))(v93, 1LL, 1LL, v125);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v143, (uint64_t)v125, v93);
      swift_unknownObjectRelease(v143);
      v150 = v229;
      v151 = v230;
      (*(void (**)(char *, uint64_t *, uint64_t))(v229 + 16))(v139, v93, v230);
      (*(void (**)(uint64_t *, uint64_t))(v150 + 8))(v93, v151);
      (*(void (**)(char *, char *, uint64_t *))(v149 + 32))(v145, v139, v125);
    }

    uint64_t v108 = v266;
    (*(void (**)(char *, void, uint64_t, unint64_t *))(v266 + 56))(v102, 0LL, 1LL, v126);
    uint64_t v105 = v267;
    uint64_t v127 = v268;
    uint64_t v103 = v261;
    Swift::Int v106 = v262;
    size_t v104 = v252;
    goto LABEL_35;
  }

  v137 = objc_msgSend(*((id *)v239 + 26), sel_countByEnumeratingWithState_objects_count_, v233, v232, 16);
  BOOL v133 = v239;
  *((void *)v239 + 28) = v137;
  if (v137)
  {
    uint64_t v134 = 0LL;
    *((void *)v133 + 27) = 0LL;
    goto LABEL_50;
  }

  *((void *)v133 + 27) = -1LL;
  v131 = v266;
  uint64_t v102 = v248;
  unint64_t v80 = (unint64_t)v242;
LABEL_116:
  (*(void (**)(char *, uint64_t, uint64_t, unint64_t *))(v131 + 56))(v102, 1LL, 1LL, v126);
  swift_release((uint64_t)v71);
  v222 = v80;
LABEL_119:
  outlined consume of [A : B].Iterator._Variant<A, B>(v222);
  return (uint64_t)v71;
}

          uint64_t v45 = HIBYTE(v12) & 0xF;
          uint64_t v46 = HIBYTE(v16) & 0xF;
          uint64_t v1 = v46 + v45;
          if (v46)
          {
            uint64_t v47 = 0;
            unint64_t v48 = 0LL;
            do
            {
              Swift::String::Index v49 = v45 + v48;
              Swift::String::Index v50 = v48 + 1;
              if (v48 >= 8) {
                Swift::String::Index v51 = v16;
              }
              else {
                Swift::String::Index v51 = v23;
              }
              Swift::String::Index v52 = v51 >> (v47 & 0x38);
              unint64_t v53 = (8 * v45 + v47) & 0x38;
              unint64_t v54 = (-255LL << v53) - 1;
              unint64_t v55 = (unint64_t)v52 << v53;
              unint64_t v56 = v55 | v54 & v12;
              unint64_t v57 = v55 | v54 & v9;
              if (v49 < 8) {
                uint64_t v9 = v57;
              }
              else {
                uint64_t v12 = v56;
              }
              v47 += 8;
              unint64_t v48 = v50;
            }

            while (v46 != v50);
          }

          swift_bridgeObjectRelease(v10);
          swift_bridgeObjectRelease((v3 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
          unint64_t v58 = 0xA000000000000000LL;
          if (!(v9 & 0x8080808080808080LL | v12 & 0x80808080808080LL)) {
            unint64_t v58 = 0xE000000000000000LL;
          }
          uint64_t v14 = v58 & 0xFF00000000000000LL | (v1 << 56) | v12 & 0xFFFFFFFFFFFFFFLL;
LABEL_85:
          v343 = v9;
LABEL_86:
          v344 = v14;
LABEL_87:
          TypeName = (uint64_t *)swift_getTypeName(a1, 0);
          if (v72 < 0) {
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
          }
          a1 = v72;
          if (!v72)
          {
            uint64_t v12 = 0LL;
            a1 = 0xE000000000000000LL;
LABEL_90:
            uint64_t v9 = 0LL;
            goto LABEL_91;
          }

          unint64_t v16 = (uint64_t)TypeName;
          uint64_t v78 = TypeName;
          uint64_t v79 = v72 & 0xFFFFFFFFFFFFFFF0LL;
          if ((v72 & 0xFFFFFFFFFFFFFFF0LL) != 0) {
            goto LABEL_140;
          }
LABEL_98:
          if ((*v78 & 0x8080808080808080LL) == 0)
          {
            ++v78;
LABEL_101:
            if ((unint64_t)v78 < v16 + (a1 & 0xFFFFFFFFFFFFFFFCLL))
            {
              if ((*(_DWORD *)v78 & 0x80808080) == 0)
              {
                uint64_t v78 = (uint64_t *)((char *)v78 + 4);
                goto LABEL_104;
              }

              goto LABEL_144;
            }

    NormData = _swift_stdlib_getNormData(value);
    uint64_t v19 = NormData | ((value - 44032) >> 2 < 0xAE9);
    if ((NormData & 0x7F8) != 0)
    {
      uint64_t v20 = 0;
      goto LABEL_34;
    }

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance [A](uint64_t a1)
{
  return Array.description.getter(*v1, *(void *)(a1 + 16));
}

uint64_t Array._cPointerArgs()(uint64_t a1, uint64_t *a2, uint64_t a3, char *a4)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (Array._getCount()())
    {
      uint64_t v16 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a2, v14, v15);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v16, v17);
      return (*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v16, WitnessTable);
    }

    swift_bridgeObjectRelease(a1);
  }

  else
  {
    swift_bridgeObjectRelease(a1);
    _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  }

  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      uint64_t v12 = (void *)a1;
    }
    else {
      uint64_t v12 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    swift_unknownObjectRetain(v12, v6, v7, v8);
  }

  else
  {
    else {
      uint64_t v12 = (void *)a1;
    }
    swift_bridgeObjectRetain(a1, v9, v10, v11);
  }

  return (uint64_t)v12;
}

id _ContiguousArrayBuffer.owner.getter()
{
  uint64_t v0 = (void *)EnumeratedSequence._base.modify();
  return swift_unknownObjectRetain(v0, v1, v2, v3);
}

void Array.init(_unsafeUninitializedCapacity:initializingWith:)( uint64_t a1, void (*a2)(void *, uint64_t *), uint64_t a3, uint64_t *a4)
{
  uint64_t v12 = static Array._allocateUninitialized(_:)(a1, a4);
  uint64_t v10 = 0LL;
  uint64_t v11 = v8;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }
  v9[0] = v8;
  v9[1] = a1;
  a2(v9, &v10);
  if (v4)
  {
    $defer #1 <A>() in Array.init(_unsafeUninitializedCapacity:initializingWith:)(&v10, a1, v9, &v11, &v12, a4);
    swift_bridgeObjectRelease(v12);
  }

  else
  {
    $defer #1 <A>() in Array.init(_unsafeUninitializedCapacity:initializingWith:)(&v10, a1, v9, &v11, &v12, a4);
  }

void *specialized $defer #1 <A>() in Array.init(_unsafeUninitializedCapacity:initializingWith:)( void *result, uint64_t a2, void *a3, void *a4, uint64_t *a5)
{
  if (*result > a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Initialized count set to greater than specified capacity.",  57LL,  2,  "Swift/Array.swift",  17LL,  2,  0x5EFuLL,  0);
  }
  if (*a3) {
    BOOL v5 = *a4 == *a3;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't reassign buffer in Array(unsafeUninitializedCapacity:initializingWith:)",  77LL,  2,  "Swift/Array.swift",  17LL,  2,  0x5F3uLL,  0);
  }
  uint64_t v6 = *a5;
  *(void *)(v6 + 16) = *result;
  *a5 = v6;
  return result;
}

BOOL $defer #1 <A>() in Array.init(_unsafeUninitializedCapacity:initializingWith:)( uint64_t *a1, uint64_t a2, void *a3, void *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v6 = *a1;
  if (*a1 > a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Initialized count set to greater than specified capacity.",  57LL,  2,  "Swift/Array.swift",  17LL,  2,  0x5EFuLL,  0);
  }
  if (*a3) {
    BOOL v7 = *a4 == *a3;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't reassign buffer in Array(unsafeUninitializedCapacity:initializingWith:)",  77LL,  2,  "Swift/Array.swift",  17LL,  2,  0x5F3uLL,  0);
  }
  uint64_t v8 = *a5;
  BOOL result = _swift_isClassOrObjCExistentialType((uint64_t)a6, a6);
  uint64_t v10 = v8 & 0xFFFFFFFFFFFFF8LL;
  if (!result) {
    uint64_t v10 = v8;
  }
  *(void *)(v10 + 16) = v6;
  return result;
}

void *$defer #1 <A><A1>() in Array.withUnsafeMutableBufferPointer<A>(_:)( void *result, uint64_t a2, uint64_t a3)
{
  if (*result) {
    BOOL v3 = *result == a2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3 || result[1] != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed",  73LL,  2,  "Swift/Array.swift",  17LL,  2,  0x67DuLL,  0);
  }
  return result;
}

void _preconditionFailure(_:file:line:)( const char *a1, uint64_t a2, char a3, const char *a4, uint64_t a5, char a6, unint64_t a7)
{
}

uint64_t IndexingIterator.init(_elements:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v9 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v16 - v10;
  uint64_t v12 = *(void *)(a2 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a4, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v12 + 8))(a1, a2);
  uint64_t v14 = type metadata accessor for IndexingIterator(0LL, a2, a3, v13);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v9 + 32))( a4 + *(int *)(v14 + 36),  v11,  AssociatedTypeWitness);
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.index(_:offsetBy:)(Swift::Int _, Swift::Int offsetBy)
{
  return UnsafeMutableBufferPointer.index(_:offsetBy:)(_, offsetBy, v2, v3, v4, 0x101uLL);
}

uint64_t static Array<A>.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v32 = a4;
  uint64_t v7 = *(a3 - 1);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v10 = (char *)&v28 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v28 - v11;
  Swift::Int v13 = Array._getCount()();
  if (v13 != Array._getCount()()) {
    return 0LL;
  }
  if (!v13) {
    return 1LL;
  }
  uint64_t v14 = _ArrayBuffer.identity.getter(a1, a3);
  if (v14 == _ArrayBuffer.identity.getter(a2, a3)) {
    return 1LL;
  }
  uint64_t v28 = v8;
  Swift::Int v31 = v13;
  if (v13 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v15 = 0LL;
  unint64_t v29 = a2 & 0xC000000000000001LL;
  unint64_t v30 = a1 & 0xC000000000000001LL;
  do
  {
    BOOL v16 = v31 == v15;
    if (v31 == v15) {
      break;
    }
    BOOL v17 = v30 == 0;
    char v18 = v17 | ~_swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v15, v18 & 1);
    if ((v18 & 1) != 0)
    {
      uint64_t v19 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
      v19( v12,  a1 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
      + *(void *)(v7 + 72) * v15,
        a3);
    }

    else
    {
      id v24 = _ArrayBuffer._getElementSlowPath(_:)(v15, a1, a3);
      unint64_t v25 = v24;
      if (v28 != 8) {
        goto LABEL_21;
      }
      id v33 = v24;
      uint64_t v19 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
      v19(v12, (unint64_t)&v33, a3);
      swift_unknownObjectRelease(v25);
    }

    BOOL v20 = v29 == 0;
    char v21 = v20 | ~_swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v15, v21 & 1);
    if ((v21 & 1) != 0)
    {
      v19( v10,  a2 + ((*(unsigned __int8 *)(v7 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
      + *(void *)(v7 + 72) * v15,
        a3);
    }

    else
    {
      id v26 = _ArrayBuffer._getElementSlowPath(_:)(v15, a2, a3);
      unint64_t v25 = v26;
      if (v28 != 8)
      {
LABEL_21:
        swift_unknownObjectRelease(v25);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

      id v33 = v26;
      v19(v10, (unint64_t)&v33, a3);
      swift_unknownObjectRelease(v25);
    }

    char v22 = (*(uint64_t (**)(char *, char *, uint64_t *))(v32 + 8))(v12, v10, a3);
    BOOL v23 = *(void (**)(char *, uint64_t *))(v7 + 8);
    v23(v10, a3);
    v23(v12, a3);
    ++v15;
  }

  while ((v22 & 1) != 0);
  return v16;
}

BOOL static _Pointer.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 48);
  uint64_t v7 = v6(a3, a4);
  return v7 == v6(a3, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> [A]( uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return static Array<A>.== infix(_:_:)(*a1, *a2, *(uint64_t **)(a3 + 16), *(void *)(a4 - 8));
}

void Array<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *(a3 - 1);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = MEMORY[0x1895F8858](v9);
  uint64_t v14 = (char *)&v26 - v13;
  uint64_t v27 = v15;
  MEMORY[0x1895F8858](v12);
  BOOL v17 = (char *)&v26 - v16;
  Swift::UInt v18 = Array._getCount()();
  uint64_t v30 = a1;
  Hasher._combine(_:)(v18);
  Swift::Int v29 = Array._getCount()();
  if (v29)
  {
    unint64_t v19 = 0LL;
    unint64_t v28 = a2 & 0xC000000000000001LL;
    do
    {
      BOOL v20 = v28 == 0;
      char v21 = v20 | ~_swift_isClassOrObjCExistentialType((uint64_t)a3, a3);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v19, v21 & 1);
      if ((v21 & 1) != 0)
      {
        (*(void (**)(char *, unint64_t, uint64_t *))(v8 + 16))( v14,  a2 + ((*(unsigned __int8 *)(v8 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80))
        + *(void *)(v8 + 72) * v19,
          a3);
        unint64_t v22 = v19 + 1;
        if (__OFADD__(v19, 1LL)) {
          goto LABEL_10;
        }
      }

      else
      {
        id v24 = _ArrayBuffer._getElementSlowPath(_:)(v19, a2, a3);
        unint64_t v25 = v24;
        if (v27 != 8)
        {
          swift_unknownObjectRelease(v24);
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }

        id v31 = v24;
        (*(void (**)(char *, id *, uint64_t *))(v8 + 16))(v14, &v31, a3);
        swift_unknownObjectRelease(v25);
        unint64_t v22 = v19 + 1;
        if (__OFADD__(v19, 1LL))
        {
LABEL_10:
          __break(1u);
          return;
        }
      }

      BOOL v23 = *(void (**)(char *, char *, uint64_t *))(v8 + 32);
      v23(v17, v14, a3);
      v23(v11, v17, a3);
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(a4 + 24))(v30, a3, a4);
      (*(void (**)(char *, uint64_t *))(v8 + 8))(v11, a3);
      ++v19;
    }

    while (v22 != v29);
  }

uint64_t Hasher.combine<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(a3 + 24))(v3);
}

Swift::Int Array<A>.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Array<A>.hashValue.getter( a1,  a2,  a3,  (void (*)(void *, uint64_t, uint64_t, uint64_t))Array<A>.hash(into:));
}

uint64_t _hashValue<A>(for:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))(0LL);
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> [A](uint64_t a1, uint64_t a2)
{
  return Array<A>.hashValue.getter(*v2, *(void *)(a1 + 16), *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> [A]( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <A> [A]( a1,  a2,  a3,  (void (*)(void *, void, void, uint64_t))Array<A>.hash(into:));
}

Swift::Int __swiftcall Hashable._rawHashValue(seed:)(Swift::Int seed)
{
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ seed ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ seed ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  (*(void (**)(void *))(v1 + 24))(v3);
  return Hasher._finalize()();
}

{
  uint64_t v1;
  void v3[5];
  __int128 v4;
  __int128 v5;
  v3[0] = 0LL;
  v3[1] = _swift_stdlib_Hashing_parameters ^ seed ^ 0x736F6D6570736575LL;
  v3[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ seed ^ 0x6C7967656E657261LL;
  v3[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  (*(void (**)(void *))(v1 + 24))(v3);
  return Hasher._finalize()();
}

void *Array.withUnsafeMutableBytes<A>(_:)( void (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[3] = a4;
  Array._makeMutableAndUnique()();
  uint64_t v7 = *v4;
  uint64_t v8 = *(uint64_t **)(a3 + 16);
  else {
    uint64_t v9 = v7;
  }
  uint64_t v10 = *(void *)(v9 + 16);
  else {
    uint64_t v11 = v7;
  }
  uint64_t v12 = *(v8 - 1);
  uint64_t v13 = v11 + ((*(unsigned __int8 *)(v12 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80));
  v17[0] = v13;
  v17[1] = v10;
  uint64_t v14 = *(void *)(v12 + 72);
  uint64_t v15 = v10 * v14;
  if ((unsigned __int128)(v10 * (__int128)v14) >> 64 != (v10 * v14) >> 63)
  {
    __break(1u);
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if (v15 < 0) {
    goto LABEL_11;
  }
  a1(v13, v13 + v15);
  return $defer #1 <A><A1>() in Array.withUnsafeMutableBufferPointer<A>(_:)(v17, v13, v10);
}

uint64_t specialized UnsafeMutableRawBufferPointer.init<A>(_:)(uint64_t result, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }
  if (a2)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer has a nil start and nonzero count",  63LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x69uLL,  0);
    }
  }

  return result;
}

uint64_t UnsafeMutableRawBufferPointer.init<A>(_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 - 8) + 72LL);
  uint64_t v4 = a2 * v3;
  if ((unsigned __int128)(a2 * (__int128)v3) >> 64 != (a2 * v3) >> 63)
  {
    __break(1u);
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_8;
  }
  if (v4)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer has a nil start and nonzero count",  63LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x69uLL,  0);
    }
  }

  return result;
}

uint64_t Array.withUnsafeBytes<A>(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, int64_t a3, uint64_t *a4)
{
  if (!_swift_isClassOrObjCExistentialType((uint64_t)a4, a4)
    || (a3 & 0x8000000000000000LL) == 0 && (a3 & 0x4000000000000000LL) == 0)
  {
    else {
      uint64_t v9 = a3;
    }
    uint64_t v10 = *(a4 - 1);
    uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
    if (_swift_isClassOrObjCExistentialType((uint64_t)a4, a4) && (a3 < 0 || (a3 & 0x4000000000000000LL) != 0))
    {
      if (a3 < 0) {
        uint64_t v26 = (void *)a3;
      }
      else {
        uint64_t v26 = (void *)(a3 & 0xFFFFFFFFFFFFFF8LL);
      }
      uint64_t v13 = (uint64_t)objc_msgSend(v26, sel_count);
      if (v13 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
    }

    else
    {
      else {
        uint64_t v12 = a3;
      }
      uint64_t v13 = *(void *)(v12 + 16);
    }

    uint64_t v14 = *(void *)(v10 + 72);
    uint64_t v15 = v13 * v14;
    if ((unsigned __int128)(v13 * (__int128)v14) >> 64 == (v13 * v14) >> 63)
    {
      if ((v15 & 0x8000000000000000LL) == 0) {
        return a1(v9 + ((v11 + 32) & ~v11), v9 + ((v11 + 32) & ~v11) + v15);
      }
    }

    else
    {
      __break(1u);
    }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  uint64_t v17 = type metadata accessor for _ArrayBuffer(0LL, (uint64_t)a4, v7, v8);
  swift_bridgeObjectRetain(a3, v18, v19, v20);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, v17, v21);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(WitnessTable + 56))(v17, WitnessTable);
  uint64_t v24 = *(unsigned __int8 *)(*(a4 - 1) + 80);
  uint64_t v25 = UnsafeRawBufferPointer.init<A>(_:)(v23 + ((v24 + 32) & ~v24), *(void *)(v23 + 16), a4);
  ((void (*)(uint64_t))a1)(v25);
  return swift_release(v23);
}

uint64_t specialized UnsafeRawBufferPointer.init<A>(_:)(uint64_t result, uint64_t a2)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }
  if (a2)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  return result;
}

uint64_t UnsafeRawBufferPointer.init<A>(_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 - 8) + 72LL);
  uint64_t v4 = a2 * v3;
  if ((unsigned __int128)(a2 * (__int128)v3) >> 64 != (a2 * v3) >> 63)
  {
    __break(1u);
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v4 < 0) {
    goto LABEL_8;
  }
  if (v4)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
    }
  }

  return result;
}

unint64_t _bridgeCocoaArray<A>(_:)(unint64_t a1)
{
  unint64_t v1 = specialized _bridgeCocoaArray<A>(_:)(a1);
  return swift_bridgeObjectRetain(v1, v2, v3, v4);
}

__objc2_class **Array._bridgeToObjectiveCImpl()(int64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000LL) != 0))
  {
    if (a1 < 0) {
      uint64_t v13 = (void *)a1;
    }
    else {
      uint64_t v13 = (void *)(a1 & 0xFFFFFFFFFFFFFF8LL);
    }
    return (__objc2_class **)swift_unknownObjectRetain(v13, v4, v5, v6);
  }

  else
  {
    else {
      uint64_t v10 = (unint64_t *)a1;
    }
    swift_bridgeObjectRetain(a1, v7, v8, v9);
    return _ContiguousArrayBuffer._asCocoaArray()(v10, a2, v11);
  }

uint64_t static Array._bridgeFromObjectiveCAdoptingNativeStorageOf(_:)(unint64_t *a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for __SwiftDeferredNSArray();
  id v8 = swift_unknownObjectRetain(a1, v5, v6, v7);
  uint64_t v9 = swift_dynamicCastClass((uint64_t)v8, v4);
  if (v9)
  {
    uint64_t v13 = *(unint64_t **)(v9 + 24);
    swift_retain(v13, v10, v11, v12);
    swift_unknownObjectRelease(a1);
    a1 = v13;
  }

  uint64_t v14 = type metadata accessor for _ContiguousArrayStorage(0LL, a2, v11, (uint64_t)v12);
  uint64_t result = swift_dynamicCastClass((uint64_t)a1, v14);
  if (!result)
  {
    swift_unknownObjectRelease(a1);
    return 0LL;
  }

  return result;
}

uint64_t _sSq3mapyqd_0_Sgqd_0_xqd__YKXEqd__YKs5ErrorRd__Ri_d_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyxs5NeverOqd_0_Isgnrzr_xSgAb2ERsd__Ri_d_0_r_0_lIetMgnrzo_Tpq5@<X0>( void (*a1)(char *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v19 = a1;
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = ((uint64_t (*)(void))MEMORY[0x1895F8858])();
  uint64_t v11 = (char *)&v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v13 = (char *)&v18 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v14 + 16))(v13, v15);
  uint64_t v16 = 1LL;
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v13, 1LL, v7) != 1)
  {
    (*(void (**)(char *, char *, uint64_t))(v8 + 32))(v11, v13, v7);
    v19(v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v11, v7);
    if (v4) {
      return result;
    }
    uint64_t v16 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL))(a4, v16, 1LL, a3);
}

uint64_t Array<A>._toCustomAnyHashable()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t result = type metadata accessor for _ArrayAnyHashableBox(0LL, a2, a3, a4);
  a5[3] = result;
  a5[4] = &protocol witness table for _ArrayAnyHashableBox<A>;
  *a5 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance <A> [A]@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  return Array<A>._toCustomAnyHashable()(*v4, *(void *)(a1 + 16), *(void *)(a2 - 8), a3, a4);
}

unint64_t _ArrayAnyHashableBox._base.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  a5[3] = type metadata accessor for Array(0LL, a2, a3, a4);
  *a5 = a1;
  return swift_bridgeObjectRetain(a1, v7, v8, v9);
}

uint64_t _ArrayAnyHashableBox.subscript.getter@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, ValueMetadata *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  Description = a3[-1].Description;
  uint64_t v11 = Description[8];
  uint64_t v12 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (uint64_t *)((char *)&v33 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  MEMORY[0x1895F8858](v12);
  uint64_t v15 = (swift **)((char *)&v33 - v14);
  char isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v16, v16);
  char v18 = ((a2 & 0xC000000000000001LL) == 0) | ~isClassOrObjCExistentialType;
  Array._checkSubscript(_:wasNativeTypeChecked:)( a1,  (a2 & 0xC000000000000001LL) == 0 || (isClassOrObjCExistentialType & 1) == 0);
  if ((v18 & 1) != 0)
  {
    unint64_t v19 = a2
    BOOL v20 = (void (*)(swift **, unint64_t, ValueMetadata *))Description[2];
    v20(v15, v19, a3);
  }

  else
  {
    id v31 = _ArrayBuffer._getElementSlowPath(_:)(a1, a2, &a3->Kind);
    uint64_t v32 = v31;
    if (v11 != 8)
    {
      swift_unknownObjectRelease(v31);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
    }

    *(void *)&__int128 v36 = v31;
    BOOL v20 = (void (*)(swift **, unint64_t, ValueMetadata *))Description[2];
    v20(v15, (unint64_t)&v36, a3);
    swift_unknownObjectRelease(v32);
  }

  if (a3 == &type metadata for String)
  {
    *((void *)&v37 + 1) = type metadata accessor for _ConcreteHashableBox( 0LL,  (uint64_t)&type metadata for String,  a4,  v21);
    uint64_t v38 = &protocol witness table for _ConcreteHashableBox<A>;
    Swift::Int v29 = (swift **)__swift_allocate_boxed_opaque_existential_0Tm(&v36);
    v20(v29, (unint64_t)v15, &type metadata for String);
    uint64_t result = ((uint64_t (*)(swift **, ValueMetadata *))Description[1])(v15, &type metadata for String);
    goto LABEL_8;
  }

  v20((swift **)v13, (unint64_t)v15, a3);
  unint64_t v22 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation);
  if ((swift_dynamicCast((char *)&v33, v13, (swift *)a3, v22, 6uLL) & 1) != 0)
  {
    uint64_t v23 = *((void *)&v34 + 1);
    uint64_t v24 = v35;
    uint64_t v25 = __swift_project_boxed_opaque_existential_0Tm(&v33, *((uint64_t *)&v34 + 1));
    MEMORY[0x1895F8858](v25);
    (*(void (**)(char *))(v27 + 16))((char *)&v33 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v24 + 8))(&v36, v23, v24);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v33);
    if (*((void *)&v37 + 1))
    {
      uint64_t result = ((uint64_t (*)(swift **, ValueMetadata *))Description[1])(v15, a3);
LABEL_8:
      __int128 v30 = v37;
      *(_OWORD *)a5 = v36;
      *(_OWORD *)(a5 + 16) = v30;
      *(void *)(a5 + 32) = v38;
      return result;
    }
  }

  else
  {
    uint64_t v35 = 0LL;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v33,  &demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation?);
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    uint64_t v38 = 0LL;
  }

  outlined destroy of AnyHashable?((uint64_t *)&v36);
  *(void *)(a5 + 24) = &unk_189B88A00;
  *(void *)(a5 + 32) = &protocol witness table for _ConcreteHashableBox<A>;
  *(_BYTE *)a5 = 0;
  _swift_makeAnyHashableUpcastingToHashableBaseType(v15, (objc_object *)a5, (uint64_t (***)())a3, a4);
  return ((uint64_t (*)(swift **, ValueMetadata *))Description[1])(v15, a3);
}

double _convertToAnyHashable<A>(_:)@<D0>( uint64_t a1@<X0>, uint64_t (***a2)()@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v9 + 16))(v8);
  return AnyHashable.init<A>(_:)((uint64_t)v8, a2, a3, a4);
}

uint64_t _ArrayAnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  uint64_t v48 = a4;
  Description = a3[-1].Description;
  uint64_t v7 = Description[8];
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  BOOL v44 = (uint64_t *)((char *)&v42 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v9 = MEMORY[0x1895F8858](v8);
  uint64_t v11 = (swift **)((char *)&v42 - v10);
  outlined init with copy of MirrorPath(v9, (uint64_t)&v56);
  uint64_t v12 = (swift *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  uint64_t v13 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ArrayAnyHashableProtocol);
  if (!swift_dynamicCast((char *)&v53, (uint64_t *)&v56, v12, v13, 6uLL))
  {
    unint64_t v55 = 0LL;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    outlined destroy of _HasContiguousBytes?( (uint64_t)&v53,  &demangling cache variable for type metadata for _ArrayAnyHashableProtocol?);
    return 2LL;
  }

  uint64_t v43 = v7;
  outlined init with take of MirrorPath(&v53, (uint64_t)v59);
  Swift::Int v14 = Array._getCount()();
  uint64_t v15 = v60;
  uint64_t v16 = v61;
  __swift_project_boxed_opaque_existential_0Tm(v59, v60);
  if (v14 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v17 = 0LL;
  unint64_t v47 = a2 & 0xC000000000000001LL;
  uint64_t v46 = a2;
  Swift::Int v45 = v14;
  while (1)
  {
    if (v14 == v17)
    {
      __swift_destroy_boxed_opaque_existential_1Tm(v59);
      return 1LL;
    }

    BOOL v18 = v47 == 0;
    char v19 = v18 | ~_swift_isClassOrObjCExistentialType((uint64_t)a3, &a3->Kind);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v17, v19 & 1);
    if ((v19 & 1) != 0)
    {
      BOOL v20 = (void (*)(swift **, unint64_t, ValueMetadata *))Description[2];
      v20( v11,  a2 + ((*((unsigned __int8 *)Description + 80) + 32LL) & ~(unint64_t)*((unsigned __int8 *)Description + 80))
      + Description[9] * v17,
        a3);
      if (a3 == &type metadata for String) {
        goto LABEL_15;
      }
    }

    else
    {
      id v29 = _ArrayBuffer._getElementSlowPath(_:)(v17, a2, &a3->Kind);
      __int128 v30 = v29;
      if (v43 != 8)
      {
        swift_unknownObjectRelease(v29);
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
      }

      *(void *)&__int128 v53 = v29;
      BOOL v20 = (void (*)(swift **, unint64_t, ValueMetadata *))Description[2];
      v20(v11, (unint64_t)&v53, a3);
      swift_unknownObjectRelease(v30);
      if (a3 == &type metadata for String)
      {
LABEL_15:
        *((void *)&v51 + 1) = type metadata accessor for _ConcreteHashableBox( 0LL,  (uint64_t)&type metadata for String,  v48,  v21);
        Swift::String::Index v52 = &protocol witness table for _ConcreteHashableBox<A>;
        id v31 = (swift **)__swift_allocate_boxed_opaque_existential_0Tm(&v50);
        v20(v31, (unint64_t)v11, &type metadata for String);
        ((void (*)(swift **, ValueMetadata *))Description[1])(v11, &type metadata for String);
        goto LABEL_16;
      }
    }

    unint64_t v22 = v44;
    v20((swift **)v44, (unint64_t)v11, a3);
    uint64_t v23 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation);
    if ((swift_dynamicCast((char *)&v53, v22, (swift *)a3, v23, 6uLL) & 1) == 0)
    {
      unint64_t v55 = 0LL;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      outlined destroy of _HasContiguousBytes?( (uint64_t)&v53,  &demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation?);
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      Swift::String::Index v52 = 0LL;
LABEL_12:
      outlined destroy of AnyHashable?((uint64_t *)&v50);
      *((void *)&v54 + 1) = &unk_189B88A00;
      unint64_t v55 = &protocol witness table for _ConcreteHashableBox<A>;
      LOBYTE(v53) = 0;
      _swift_makeAnyHashableUpcastingToHashableBaseType(v11, (objc_object *)&v53, (uint64_t (***)())a3, v48);
      ((void (*)(swift **, ValueMetadata *))Description[1])(v11, a3);
      goto LABEL_17;
    }

    uint64_t v24 = *((void *)&v54 + 1);
    uint64_t v25 = v55;
    uint64_t v26 = __swift_project_boxed_opaque_existential_0Tm(&v53, *((uint64_t *)&v54 + 1));
    MEMORY[0x1895F8858](v26);
    (*(void (**)(char *))(v28 + 16))((char *)&v42 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    ((void (*)(__int128 *__return_ptr, uint64_t, _UNKNOWN **))v25[1])(&v50, v24, v25);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v53);
    if (!*((void *)&v51 + 1)) {
      goto LABEL_12;
    }
    ((void (*)(swift **, ValueMetadata *))Description[1])(v11, a3);
LABEL_16:
    __int128 v53 = v50;
    __int128 v54 = v51;
    unint64_t v55 = v52;
LABEL_17:
    __int128 v56 = v53;
    __int128 v57 = v54;
    unint64_t v58 = v55;
    uint64_t v32 = v60;
    uint64_t v33 = v61;
    __swift_project_boxed_opaque_existential_0Tm(v59, v60);
    (*(void (**)(__int128 *__return_ptr, unint64_t, uint64_t, uint64_t))(v33 + 24))(&v53, v17, v32, v33);
    uint64_t v34 = *((void *)&v57 + 1);
    uint64_t v35 = v58;
    __swift_project_boxed_opaque_existential_0Tm(&v56, *((uint64_t *)&v57 + 1));
    ((void (*)(__int128 *__return_ptr, uint64_t, _UNKNOWN **))v35[1])(&v50, v34, v35);
    uint64_t v36 = *((void *)&v51 + 1);
    __int128 v37 = v52;
    __swift_project_boxed_opaque_existential_0Tm(&v50, *((uint64_t *)&v51 + 1));
    uint64_t v39 = *((void *)&v54 + 1);
    uint64_t v38 = v55;
    __swift_project_boxed_opaque_existential_0Tm(&v53, *((uint64_t *)&v54 + 1));
    ((void (*)(uint64_t *__return_ptr, uint64_t, _UNKNOWN **))v38[1])(v49, v39, v38);
    char v40 = ((uint64_t (*)(uint64_t *, uint64_t, _UNKNOWN **))v37[2])(v49, v36, v37);
    __swift_destroy_boxed_opaque_existential_1Tm(v49);
    if (v40 == 2) {
      break;
    }
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v50);
    outlined destroy of AnyHashable((uint64_t *)&v53);
    outlined destroy of AnyHashable((uint64_t *)&v56);
    ++v17;
    a2 = v46;
    Swift::Int v14 = v45;
    if ((v40 & 1) == 0) {
      goto LABEL_23;
    }
  }

  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v50);
  outlined destroy of AnyHashable((uint64_t *)&v53);
  outlined destroy of AnyHashable((uint64_t *)&v56);
LABEL_23:
  __swift_destroy_boxed_opaque_existential_1Tm(v59);
  return 0LL;
}

Swift::Int _ArrayAnyHashableBox._hashValue.getter(uint64_t a1, ValueMetadata *a2, uint64_t a3)
{
  v4[0] = 0LL;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v4[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v4[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  _ArrayAnyHashableBox._hash(into:)((uint64_t)v4, a1, a2, a3);
  return Hasher.finalize()();
}

double Hasher.init()@<D0>(uint64_t a1@<X8>)
{
  uint64_t v1 = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  uint64_t v2 = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  uint64_t v3 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v4 = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = v2;
  *(void *)(a1 + 32) = v1;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  return result;
}

void _ArrayAnyHashableBox._hash(into:)(uint64_t a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  Swift::UInt v8 = Array._getCount()();
  Hasher._combine(_:)(v8);
  if ((v8 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v8)
  {
    unint64_t v9 = 0LL;
    do
    {
      unint64_t v10 = v9 + 1;
      _ArrayAnyHashableBox.subscript.getter(v9, a2, a3, a4, (uint64_t)v18);
      uint64_t v11 = v19;
      uint64_t v12 = v20;
      __swift_project_boxed_opaque_existential_0Tm(v18, v19);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v12 + 8))(v15, v11, v12);
      uint64_t v13 = v16;
      uint64_t v14 = v17;
      __swift_project_boxed_opaque_existential_0Tm(v15, v16);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v14 + 32))(a1, v13, v14);
      __swift_destroy_boxed_opaque_existential_1Tm(v15);
      outlined destroy of AnyHashable(v18);
      unint64_t v9 = v10;
    }

    while (v8 != v10);
  }

Swift::Int __swiftcall Hasher.finalize()()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = v0[4] ^ *v0;
  uint64_t v3 = v1 + v0[1];
  uint64_t v4 = v3 ^ __ROR8__(v1, 51);
  uint64_t v5 = v2 + v0[3];
  uint64_t v6 = __ROR8__(v2, 48);
  uint64_t v7 = (v5 ^ v6) + __ROR8__(v3, 32);
  uint64_t v8 = v7 ^ __ROR8__(v5 ^ v6, 43);
  uint64_t v9 = v5 + v4;
  uint64_t v10 = v9 ^ __ROR8__(v4, 47);
  uint64_t v11 = (v7 ^ *v0) + v10;
  uint64_t v12 = v11 ^ __ROR8__(v10, 51);
  uint64_t v13 = (__ROR8__(v9, 32) ^ 0xFFLL) + v8;
  uint64_t v14 = __ROR8__(v8, 48);
  uint64_t v15 = __ROR8__(v11, 32) + (v13 ^ v14);
  uint64_t v16 = v15 ^ __ROR8__(v13 ^ v14, 43);
  uint64_t v17 = v12 + v13;
  uint64_t v18 = __ROR8__(v17, 32);
  uint64_t v19 = v17 ^ __ROR8__(v12, 47);
  uint64_t v20 = v15 + v19;
  uint64_t v21 = v20 ^ __ROR8__(v19, 51);
  uint64_t v22 = v18 + v16;
  uint64_t v23 = (v18 + v16) ^ __ROR8__(v16, 48);
  uint64_t v24 = __ROR8__(v20, 32) + v23;
  uint64_t v25 = v24 ^ __ROR8__(v23, 43);
  uint64_t v26 = v21 + v22;
  uint64_t v27 = v26 ^ __ROR8__(v21, 47);
  uint64_t v28 = __ROR8__(v26, 32) + v25;
  uint64_t v29 = (v24 + v27) ^ __ROR8__(v27, 51);
  return __ROR8__(v28 ^ __ROR8__(v25, 48), 43) ^ __ROR8__(v29 + v28, 32) ^ (v29 + v28) ^ __ROR8__(v29, 47);
}

Swift::Int __swiftcall _ArrayAnyHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  uint64_t v4 = v3;
  uint64_t v5 = v2;
  uint64_t v6 = v1;
  Description = v2[-1].Description;
  uint64_t v8 = MEMORY[0x1895F8858](_seed);
  uint64_t v10 = (uint64_t *)((char *)&v35 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  uint64_t v35 = v9;
  uint64_t v11 = MEMORY[0x1895F8858](v8);
  uint64_t v13 = (swift **)((char *)&v35 - v12);
  v45[0] = 0LL;
  v45[1] = _swift_stdlib_Hashing_parameters ^ v11 ^ 0x736F6D6570736575LL;
  void v45[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v45[3] = _swift_stdlib_Hashing_parameters ^ v11 ^ 0x6C7967656E657261LL;
  v45[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  Swift::UInt v15 = Array._getCount()();
  Hasher._combine(_:)(v15);
  if ((v15 & 0x8000000000000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v15)
  {
    unint64_t v16 = 0LL;
    unint64_t v38 = v6 & 0xC000000000000001LL;
    Swift::UInt v37 = v15;
    uint64_t v36 = Description;
    do
    {
      BOOL v22 = v38 == 0;
      char v23 = v22 | ~_swift_isClassOrObjCExistentialType((uint64_t)v5, &v5->Kind);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v16, v23 & 1);
      if ((v23 & 1) != 0)
      {
        uint64_t v24 = (void (*)(swift **, unint64_t, ValueMetadata *))Description[2];
        v24( v13,  v6 + ((*((unsigned __int8 *)Description + 80) + 32LL) & ~(unint64_t)*((unsigned __int8 *)Description + 80))
        + Description[9] * v16,
          v5);
        if (v5 == &type metadata for String) {
          goto LABEL_4;
        }
      }

      else
      {
        id v32 = _ArrayBuffer._getElementSlowPath(_:)(v16, v6, &v5->Kind);
        uint64_t v33 = v32;
        if (v35 != 8)
        {
          swift_unknownObjectRelease(v32);
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't unsafeBitCast between types of different sizes",  52LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x5FuLL,  0);
        }

        *(void *)&__int128 v42 = v32;
        uint64_t v24 = (void (*)(swift **, unint64_t, ValueMetadata *))Description[2];
        v24(v13, (unint64_t)&v42, v5);
        swift_unknownObjectRelease(v33);
        if (v5 == &type metadata for String)
        {
LABEL_4:
          *((void *)&v43 + 1) = type metadata accessor for _ConcreteHashableBox( 0LL,  (uint64_t)&type metadata for String,  v4,  v25);
          BOOL v44 = &protocol witness table for _ConcreteHashableBox<A>;
          uint64_t v17 = (swift **)__swift_allocate_boxed_opaque_existential_0Tm(&v42);
          v24(v17, (unint64_t)v13, &type metadata for String);
          ((void (*)(swift **, ValueMetadata *))Description[1])(v13, &type metadata for String);
          goto LABEL_5;
        }
      }

      v24((swift **)v10, (unint64_t)v13, v5);
      uint64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation);
      if ((swift_dynamicCast((char *)&v39, v10, (swift *)v5, v26, 6uLL) & 1) == 0)
      {
        int64_t v41 = 0LL;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        outlined destroy of _HasContiguousBytes?( (uint64_t)&v39,  &demangling cache variable for type metadata for _HasCustomAnyHashableRepresentation?);
        __int128 v42 = 0u;
        __int128 v43 = 0u;
        BOOL v44 = 0LL;
LABEL_13:
        outlined destroy of AnyHashable?((uint64_t *)&v42);
        *((void *)&v40 + 1) = &unk_189B88A00;
        int64_t v41 = &protocol witness table for _ConcreteHashableBox<A>;
        LOBYTE(v39) = 0;
        _swift_makeAnyHashableUpcastingToHashableBaseType(v13, (objc_object *)&v39, (uint64_t (***)())v5, v4);
        ((void (*)(swift **, ValueMetadata *))Description[1])(v13, v5);
        goto LABEL_6;
      }

      uint64_t v27 = *((void *)&v40 + 1);
      uint64_t v28 = v41;
      uint64_t v29 = __swift_project_boxed_opaque_existential_0Tm(&v39, *((uint64_t *)&v40 + 1));
      MEMORY[0x1895F8858](v29);
      (*(void (**)(char *))(v31 + 16))((char *)&v35 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL));
      ((void (*)(__int128 *__return_ptr, uint64_t, _UNKNOWN **))v28[1])(&v42, v27, v28);
      Description = v36;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v39);
      if (!*((void *)&v43 + 1)) {
        goto LABEL_13;
      }
      ((void (*)(swift **, ValueMetadata *))Description[1])(v13, v5);
LABEL_5:
      __int128 v39 = v42;
      __int128 v40 = v43;
      int64_t v41 = v44;
LABEL_6:
      ++v16;
      __int128 v42 = v39;
      __int128 v43 = v40;
      uint64_t v18 = v41;
      BOOL v44 = v41;
      uint64_t v19 = *((void *)&v40 + 1);
      __swift_project_boxed_opaque_existential_0Tm(&v42, *((uint64_t *)&v40 + 1));
      ((void (*)(__int128 *__return_ptr, uint64_t, _UNKNOWN **))v18[1])(&v39, v19, v18);
      uint64_t v20 = *((void *)&v40 + 1);
      uint64_t v21 = v41;
      __swift_project_boxed_opaque_existential_0Tm(&v39, *((uint64_t *)&v40 + 1));
      ((void (*)(void *, uint64_t, _UNKNOWN **))v21[4])(v45, v20, v21);
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v39);
      outlined destroy of AnyHashable((uint64_t *)&v42);
    }

    while (v37 != v16);
  }

  return Hasher._finalize()();
}

double Hasher.init(_seed:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  uint64_t v3 = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  uint64_t v4 = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  uint64_t v5 = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v4;
  *(void *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = v2;
  double result = 0.0;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  return result;
}

Swift::Int __swiftcall Hasher._finalize()()
{
  uint64_t v1 = v0[4] ^ *v0;
  uint64_t v2 = v0[2];
  uint64_t v3 = v2 + v0[1];
  uint64_t v4 = v3 ^ __ROR8__(v2, 51);
  uint64_t v5 = v0[3] + v1;
  uint64_t v6 = __ROR8__(v1, 48);
  uint64_t v7 = (v5 ^ v6) + __ROR8__(v3, 32);
  uint64_t v8 = v7 ^ __ROR8__(v5 ^ v6, 43);
  uint64_t v9 = v5 + v4;
  uint64_t v10 = v9 ^ __ROR8__(v4, 47);
  uint64_t v11 = (v7 ^ *v0) + v10;
  uint64_t v12 = v11 ^ __ROR8__(v10, 51);
  uint64_t v13 = (__ROR8__(v9, 32) ^ 0xFFLL) + v8;
  uint64_t v14 = __ROR8__(v8, 48);
  uint64_t v15 = __ROR8__(v11, 32) + (v13 ^ v14);
  uint64_t v16 = v15 ^ __ROR8__(v13 ^ v14, 43);
  uint64_t v17 = v12 + v13;
  uint64_t v18 = v17 ^ __ROR8__(v12, 47);
  uint64_t v19 = v15 + v18;
  uint64_t v20 = v19 ^ __ROR8__(v18, 51);
  uint64_t v21 = __ROR8__(v17, 32) + v16;
  uint64_t v22 = __ROR8__(v16, 48);
  uint64_t v23 = __ROR8__(v19, 32) + (v21 ^ v22);
  uint64_t v24 = v23 ^ __ROR8__(v21 ^ v22, 43);
  uint64_t v25 = v20 + v21;
  uint64_t v26 = v25 ^ __ROR8__(v20, 47);
  uint64_t v27 = v23 + v26;
  uint64_t v28 = v27 ^ __ROR8__(v26, 51);
  uint64_t v29 = __ROR8__(v25, 32) + v24;
  uint64_t v30 = __ROR8__(v24, 48);
  uint64_t v31 = __ROR8__(v27, 32) + (v29 ^ v30);
  uint64_t v32 = v31 ^ __ROR8__(v29 ^ v30, 43);
  uint64_t v33 = v28 + v29;
  uint64_t v34 = v33 ^ __ROR8__(v28, 47);
  uint64_t v35 = __ROR8__(v33, 32);
  v0[3] = v35;
  v0[4] = v32;
  v0[1] = v31;
  v0[2] = v34;
  return v35 ^ v34 ^ v32 ^ v31;
}

uint64_t _ArrayAnyHashableBox._unbox<A>()@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  unint64_t v14 = a1;
  uint64_t v8 = (swift *)type metadata accessor for Array(0LL, a2, (uint64_t)a3, a4);
  swift_bridgeObjectRetain(a1, v9, v10, v11);
  int v12 = swift_dynamicCast(a5, (uint64_t *)&v14, v8, a3, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a3 - 1) + 56LL))( a5,  v12 ^ 1u,  1LL,  a3);
}

uint64_t _ArrayAnyHashableBox._downCastConditional<A>(into:)( char *a1, unint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v8 = type metadata accessor for Optional(0LL, (uint64_t)a4, a3, (uint64_t)a4);
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  int v12 = (char *)&v26 - v11;
  uint64_t v13 = *((void *)a4 - 1);
  MEMORY[0x1895F8858](v10);
  uint64_t v15 = (char *)&v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v27 = a2;
  uint64_t v18 = (swift *)type metadata accessor for Array(0LL, a3, v16, v17);
  swift_bridgeObjectRetain(a2, v19, v20, v21);
  uint64_t v22 = swift_dynamicCast(v12, (uint64_t *)&v27, v18, a4, 6uLL);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v13 + 56);
  if ((_DWORD)v22)
  {
    v23(v12, 0LL, 1LL, a4);
    uint64_t v24 = *(void (**)(char *, char *, const char *))(v13 + 32);
    v24(v15, v12, a4);
    v24(a1, v15, a4);
  }

  else
  {
    v23(v12, 1LL, 1LL, a4);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  }

  return v22;
}

Swift::Int protocol witness for _ArrayAnyHashableProtocol.count.getter in conformance _ArrayAnyHashableBox<A>()
{
  return _ArrayAnyHashableBox.count.getter();
}

uint64_t protocol witness for _ArrayAnyHashableProtocol.subscript.getter in conformance _ArrayAnyHashableBox<A>@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return _ArrayAnyHashableBox.subscript.getter(a1, *v3, *(ValueMetadata **)(a2 + 16), *(void *)(a2 + 24), a3);
}

uint64_t _AnyHashableBox._canonicalBox.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  a3[3] = a1;
  a3[4] = a2;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(a3);
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)(a1 - 8) + 16LL))( boxed_opaque_existential_0Tm,  v3,  a1);
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _ArrayAnyHashableBox<A>( uint64_t a1, uint64_t a2)
{
  return _ArrayAnyHashableBox._isEqual(to:)(a1, *v2, *(ValueMetadata **)(a2 + 16), *(void *)(a2 + 24));
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _ArrayAnyHashableBox<A>( uint64_t a1)
{
  return _ArrayAnyHashableBox._hashValue.getter(*v1, *(ValueMetadata **)(a1 + 16), *(void *)(a1 + 24));
}

void protocol witness for _AnyHashableBox._hash(into:) in conformance _ArrayAnyHashableBox<A>( uint64_t a1, uint64_t a2)
{
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _ArrayAnyHashableBox<A>( Swift::Int _seed)
{
  return _ArrayAnyHashableBox._rawHashValue(_seed:)(_seed);
}

unint64_t protocol witness for _AnyHashableBox._base.getter in conformance _ArrayAnyHashableBox<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t *a4@<X8>)
{
  return _ArrayAnyHashableBox._base.getter(*v4, *(void *)(a1 + 16), a2, a3, a4);
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _ArrayAnyHashableBox<A>@<X0>( const char *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  return _ArrayAnyHashableBox._unbox<A>()(*v4, *(void *)(a2 + 16), a1, a3, a4);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _ArrayAnyHashableBox<A>( char *a1, const char *a2, uint64_t a3)
{
  return _ArrayAnyHashableBox._downCastConditional<A>(into:)(a1, *v3, *(void *)(a3 + 16), a2);
}

uint64_t _allocateUninitializedArray<A>(_:)(uint64_t a1, uint64_t *a2)
{
  if (a1 < 1) {
    return static Array._allocateUninitialized(_:)(a1, a2);
  }
  uint64_t v4 = getContiguousArrayStorageType<A>(for:)((uint64_t)a2, a2);
  uint64_t v5 = *(a2 - 1);
  uint64_t v6 = swift_allocObject( v4,  ((*(unsigned __int8 *)(v5 + 80) + (unint64_t)*(unsigned int *)(v4 + 48)) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80))
       + *(void *)(v5 + 72) * a1,
         *(unsigned __int8 *)(v5 + 80) | (unint64_t)*(unsigned __int16 *)(v4 + 52));
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( *(void *)(*v6 + 144LL),  *(uint64_t **)(*v6 + 144LL));
  v6[2] = a1;
  v6[3] = isClassOrObjCExistentialType | (unint64_t)(2 * a1);
  return (uint64_t)v6;
}

uint64_t getContiguousArrayStorageType<A>(for:)(uint64_t a1, uint64_t *a2)
{
  if (swift_isClassType(a2)) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (v5) {
    return canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
  }
  else {
    return type metadata accessor for _ContiguousArrayStorage(0LL, (uint64_t)a2, v3, v4);
  }
}

void _deallocateUninitializedArray<A>(_:)(uint64_t a1, uint64_t *a2)
{
}

uint64_t DefaultStringInterpolation.appendInterpolation<A>(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, ValueMetadata *, _UNKNOWN **, uint64_t))(a4 + 8))( v4,  &type metadata for DefaultStringInterpolation,  &protocol witness table for DefaultStringInterpolation,  a2);
}

void static String.+= infix(_:_:)(unint64_t *a1, unint64_t a2, unint64_t a3, char *a4)
{
  unint64_t v7 = a1[1];
  uint64_t v8 = HIBYTE(v7) & 0xF;
  if ((v7 & 0x2000000000000000LL) == 0) {
    uint64_t v8 = *a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v8 || (*a1 & ~v7 & 0x2000000000000000LL) != 0)
  {
    _StringGuts.append(_:)(a2, a3);
  }

  else
  {
    swift_bridgeObjectRetain(a3, a2, a3, a4);
    swift_bridgeObjectRelease(v7);
    *a1 = a2;
    a1[1] = a3;
  }

uint64_t debugPrint<A>(_:separator:terminator:to:)( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _print<A>(_:separator:terminator:to:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (void (*)(uint64_t *, uint64_t, void *, uint64_t, uint64_t))_debugPrint_unlocked<A, B>(_:_:));
}

uint64_t _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a6 - 8) + 8LL))(a3, a6);
}

__objc2_class **_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(newCount:requiredCapacity:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _ArrayBufferProtocol._forceCreateUniqueMutableBufferImpl(countForBuffer:minNewCapacity:requiredCapacity:)( a1,  a1,  a2,  a3,  a4);
}

uint64_t closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(*(void *)(a6 + 8) + 8LL) + 8LL),  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v21 - v14;
  unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a7,  a5,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v23 = *(void *)(v16 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v18 = (char *)&v21 - v17;
  (*(void (**)(uint64_t, uint64_t))(a7 + 64))(a5, a7);
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  unint64_t v22 = v16;
  if (a2)
  {
    uint64_t v24 = *(uint64_t (**)(_BYTE *, char *, uint64_t, uint64_t))(a7 + 80);
    do
    {
      uint64_t v19 = (void (*)(_BYTE *, void))v24(v25, v18, a5, a7);
      (*(void (**)(char *))(v13 + 16))(v15);
      v19(v25, 0LL);
      (*(void (**)(uint64_t, char *, unint64_t))(v13 + 32))(a1, v15, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t))(a7 + 192))(v18, a5, a7);
      a1 += *(void *)(v13 + 72);
      --a2;
    }

    while (a2);
  }

  _expectEnd<A>(of:is:)(a3, (uint64_t)v18, a5, a7);
  return (*(uint64_t (**)(char *, unint64_t))(v23 + 8))(v18, v22);
}

uint64_t _debugPrecondition(_:_:file:line:)( uint64_t (*a1)(void), uint64_t a2, const char *a3, uint64_t a4, char a5, const char *a6, uint64_t a7, char a8, unint64_t a9)
{
  uint64_t result = a1();
  if ((result & 1) == 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11LL, 2, a3, a4, a5, a6, a7, a8, a9, 0);
  }
  return result;
}

Swift::Int __swiftcall _growArrayCapacity(_:)(Swift::Int result)
{
  if (result + 0x4000000000000000LL < 0) {
    __break(1u);
  }
  else {
    result *= 2LL;
  }
  return result;
}

uint64_t static Int.* infix(_:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t result = a1 * a2;
  return result;
}

__objc2_class **_ArrayBufferProtocol._forceCreateUniqueMutableBufferImpl(countForBuffer:minNewCapacity:requiredCapacity:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
  uint64_t v11 = v10(a4, a5);
  uint64_t v12 = v10(a4, a5);
  if (v11 < a2)
  {
    if (v12 + 0x4000000000000000LL < 0)
    {
      __break(1u);
      goto LABEL_21;
    }

    v12 *= 2LL;
  }

  if (v12 <= a3) {
    uint64_t v13 = a3;
  }
  else {
    uint64_t v13 = v12;
  }
  if (v13 <= a1) {
    uint64_t v14 = a1;
  }
  else {
    uint64_t v14 = v13;
  }
  if (!v14) {
    return &_swiftEmptyArrayStorage;
  }
  unint64_t AssociatedTypeWitness = (uint64_t *)swift_getAssociatedTypeWitness( 0LL,  *(const char **)(*(void *)(*(void *)(a5 + 8) + 8LL) + 8LL),  a4,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v16 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
  uint64_t v17 = *(AssociatedTypeWitness - 1);
  uint64_t v18 = *(void *)(v17 + 72);
  uint64_t v19 = *(unsigned __int8 *)(v17 + 80);
  uint64_t v20 = swift_allocObject( v16,  ((v19 + *(unsigned int *)(v16 + 48)) & ~v19) + v18 * v14,  v19 | *(unsigned __int16 *)(v16 + 52));
  size_t v21 = _swift_stdlib_malloc_size(v20);
  if (!v18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  }
  int64_t v25 = v21 - ((v19 + 32) & ~v19);
  if (v25 == 0x8000000000000000LL && v18 == -1) {
LABEL_21:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  uint64_t v27 = v25 / v18;
  swift_retain(v20, v22, v23, v24);
  BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType( (uint64_t)AssociatedTypeWitness,  AssociatedTypeWitness);
  void v20[2] = a1;
  v20[3] = isClassOrObjCExistentialType | (unint64_t)(2 * v27);
  swift_release((uint64_t)v20);
  return (__objc2_class **)v20;
}

uint64_t static Strideable<>.- infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a4 + 32) + 40LL))(a1, a3);
}

{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t AssociatedConformanceWitness;
  uint64_t v13;
  uint64_t v6 = *(void *)(a4 + 32);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a3,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v13 - v9;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v6,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric);
  (*(void (**)(uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 16))( a2,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 48))(v10, a3, v6);
  return (*(uint64_t (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
}

Swift::Void __swiftcall _ArrayBufferProtocol._outlinedMakeUniqueBuffer(bufferCount:)(Swift::Int bufferCount)
{
  uint64_t v3 = (uint64_t (**)(uint64_t, uint64_t, char *))v2;
  uint64_t v4 = v1;
  uint64_t v6 = (*(uint64_t (**)(void))(v2 + 56))();
  if (!v6)
  {
    unint64_t v7 = (unint64_t *)_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(newCount:requiredCapacity:)( bufferCount,  bufferCount,  v4,  (uint64_t)v3);
    uint64_t v11 = v7;
    uint64_t v8 = default argument 3 of _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)(v4, (uint64_t)v3);
    uint64_t v10 = v9;
    _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( &v11,  bufferCount,  0LL,  (void (*)(char *, uint64_t))v8,  v9,  v4,  v3);
    swift_release(v10);
    uint64_t v6 = (uint64_t)v7;
  }

  swift_release(v6);
}

uint64_t _ArrayBufferProtocol._arrayAppendSequence<A>(_:)( void (*a1)(char *, char *, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v59 = a1;
  uint64_t v50 = a4;
  uint64_t v9 = *(void *)(*(void *)(a4 + 8) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v9 + 8),  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v56 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v47 = (char *)&v45 - v11;
  uint64_t v46 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v12, v13);
  uint64_t v57 = *(void *)(v46 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v46);
  uint64_t v16 = (char *)&v45 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v48 = (char *)&v45 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v45 - v19;
  unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v45 = *(void *)(v21 - 8);
  MEMORY[0x1895F8858](v21);
  uint64_t v23 = (char *)&v45 - v22;
  uint64_t v24 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 112);
  uint64_t v51 = v5;
  uint64_t v49 = a2;
  uint64_t v25 = v24(a2, v9);
  (*(void (**)(uint64_t, uint64_t))(a5 + 32))(a3, a5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a5,  a3,  v21,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v27 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  __int128 v54 = v23;
  unint64_t v55 = v21;
  Swift::String::Index v52 = v27;
  unint64_t v53 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v27)(v21);
  uint64_t v28 = v46;
  uint64_t v29 = v48;
  uint64_t v30 = v57;
  unint64_t v59 = *(void (**)(char *, char *, uint64_t))(v57 + 16);
  v59(v48, v20, v46);
  unint64_t v58 = *(uint64_t (**)(char *, uint64_t, unint64_t))(v56 + 48);
  int v31 = v58(v29, 1LL, AssociatedTypeWitness);
  uint64_t v57 = *(void *)(v30 + 8);
  if (v31 == 1)
  {
LABEL_2:
    uint64_t v32 = (uint64_t (*)(char *, uint64_t))v57;
    ((void (*)(char *, uint64_t))v57)(v20, v28);
    (*(void (**)(char *, unint64_t))(v45 + 8))(v54, v55);
    return v32(v29, v28);
  }

  else
  {
    while (1)
    {
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v29, v28);
      if (__OFADD__(v25, 1LL)) {
        break;
      }
      uint64_t v36 = v49;
      uint64_t v35 = v50;
      uint64_t v37 = v28;
      unint64_t v38 = (unint64_t *)_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(countForNewBuffer:minNewCapacity:)( v25,  v25 + 1,  v49,  v50);
      uint64_t v60 = v38;
      __int128 v39 = default argument 3 of _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)(v36, v35);
      uint64_t v41 = v40;
      _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( &v60,  v25,  0LL,  (void (*)(char *, uint64_t))v39,  v40,  v36,  (uint64_t (**)(uint64_t, uint64_t, char *))v35);
      swift_release(v41);
      swift_release((uint64_t)v38);
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(v35 + 128))(v36, v35);
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(v35 + 144))(v36, v35);
      v59(v16, v20, v28);
      if (v58(v16, 1LL, AssociatedTypeWitness) == 1)
      {
LABEL_3:
        ((void (*)(char *, uint64_t))v57)(v16, v28);
        uint64_t v34 = v25;
      }

      else
      {
        __int128 v43 = *(void (**)(char *, char *, unint64_t))(v56 + 32);
        if (v34 <= v25) {
          uint64_t v34 = v25;
        }
        BOOL v44 = v47;
        while (1)
        {
          v43(v44, v16, AssociatedTypeWitness);
          if (v34 == v25) {
            break;
          }
          ((void (*)(char *, uint64_t))v57)(v20, v28);
          v43((char *)(v42 + *(void *)(v56 + 72) * v25++), v44, AssociatedTypeWitness);
          v52(v55, v53);
          uint64_t v28 = v37;
          v59(v16, v20, v37);
        }

        (*(void (**)(char *, unint64_t))(v56 + 8))(v44, AssociatedTypeWitness);
        uint64_t v25 = v34;
      }

      uint64_t v29 = v48;
      (*(void (**)(uint64_t, uint64_t))(v50 + 112))(v34, v49);
      v59(v29, v20, v28);
    }

    __break(1u);
  }

  return result;
}

id ArraySlice._buffer.getter(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_unknownObjectRetain(a1, a2, a3, a4);
}

void ArraySlice._buffer.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)uint64_t v4 = a1;
  *(void *)(v4 + 8) = a2;
  *(void *)(v4 + 16) = a3;
  *(void *)(v4 + 24) = a4;
}

uint64_t (*ArraySlice._buffer.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

  ;
}

uint64_t specialized _SliceBuffer.init(_buffer:shiftedToStartIndex:)(uint64_t result, uint64_t a2)
{
  if (__OFSUB__(0LL, a2))
  {
    __break(1u);
    goto LABEL_7;
  }

  uint64_t v2 = *(void *)(result + 16);
  BOOL v3 = __OFADD__(a2, v2);
  uint64_t v4 = a2 + v2;
  if (v3)
  {
LABEL_7:
    __break(1u);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (v4 < a2) {
    goto LABEL_8;
  }
  if (v4 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  return result;
}

uint64_t _SliceBuffer.init(_buffer:shiftedToStartIndex:)(uint64_t result, uint64_t a2)
{
  if (__OFSUB__(0LL, a2))
  {
    __break(1u);
    goto LABEL_7;
  }

  uint64_t v2 = *(void *)(result + 16);
  BOOL v3 = __OFADD__(a2, v2);
  uint64_t v4 = a2 + v2;
  if (v3)
  {
LABEL_7:
    __break(1u);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (v4 < a2) {
    goto LABEL_8;
  }
  if (v4 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }
  return result;
}

Swift::Bool __swiftcall ArraySlice._hoistableIsNativeTypeChecked()()
{
  return v0 & 1;
}

uint64_t _SliceBuffer.arrayPropertyIsNativeTypeChecked.getter(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  return a4 & 1;
}

Swift::Int __swiftcall ArraySlice._getCount()()
{
  Swift::Int result = (v1 >> 1) - v0;
  if (__OFSUB__(v1 >> 1, v0)) {
    __break(1u);
  }
  return result;
}

uint64_t _SliceBuffer.count.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3)) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall ArraySlice._getCapacity()()
{
  Swift::Int v5 = (v3 >> 1) - v2;
  if (__OFSUB__(v3 >> 1, v2))
  {
    __break(1u);
  }

  else
  {
    if ((v3 & 1) == 0) {
      return v5;
    }
    uint64_t v6 = v4;
    uint64_t v7 = v2;
    uint64_t v8 = v1;
    uint64_t v9 = (void *)result;
    uint64_t v10 = type metadata accessor for __ContiguousArrayStorageBase();
    id v14 = swift_unknownObjectRetain(v9, v11, v12, v13);
    uint64_t v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v14, v10);
    if (!v15)
    {
      swift_unknownObjectRelease(v9);
      uint64_t v15 = &_swiftEmptyArrayStorage;
    }

    uint64_t v16 = *(void *)(v6 - 8);
    uint64_t v17 = v15[2];
    if ((__objc2_class **)(v8 + *(void *)(v16 + 72) * v7 + *(void *)(v16 + 72) * v5) != (__objc2_class **)((char *)v15 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80)) + *(void *)(v16 + 72) * (void)v17))
    {
      swift_release((uint64_t)v15);
      return v5;
    }

    unint64_t v18 = (unint64_t)v15[3];
    Swift::Int result = swift_release((uint64_t)v15);
    unint64_t v19 = (v18 >> 1) - (void)v17;
    BOOL v20 = __OFADD__(v5, v19);
    v5 += v19;
    if (!v20) {
      return v5;
    }
  }

  __break(1u);
  return result;
}

uint64_t _SliceBuffer.capacity.getter( uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5 = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
  }

  else
  {
    if ((a4 & 1) == 0) {
      return v5;
    }
    uint64_t v9 = (void *)result;
    uint64_t v10 = type metadata accessor for __ContiguousArrayStorageBase();
    id v14 = swift_unknownObjectRetain(v9, v11, v12, v13);
    uint64_t v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v14, v10);
    if (!v15)
    {
      swift_unknownObjectRelease(v9);
      uint64_t v15 = &_swiftEmptyArrayStorage;
    }

    uint64_t v16 = *(void *)(a5 - 8);
    uint64_t v17 = v15[2];
    if ((__objc2_class **)(a2 + *(void *)(v16 + 72) * a3 + *(void *)(v16 + 72) * v5) != (__objc2_class **)((char *)v15 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80)) + *(void *)(v16 + 72) * (void)v17))
    {
      swift_release((uint64_t)v15);
      return v5;
    }

    unint64_t v18 = (unint64_t)v15[3];
    Swift::Int result = swift_release((uint64_t)v15);
    unint64_t v19 = (v18 >> 1) - (void)v17;
    BOOL v20 = __OFADD__(v5, v19);
    v5 += v19;
    if (!v20) {
      return v5;
    }
  }

  __break(1u);
  return result;
}

Swift::Void __swiftcall ArraySlice._makeMutableAndUnique()()
{
  uint64_t v4 = v0;
  unint64_t v5 = v3[3];
  unint64_t v6 = *v3;
  if ((v5 & 1) != 0)
  {
    char isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*v3);
    *unint64_t v3 = v6;
    if ((isUniquelyReferenced_nonNull & 1) != 0) {
      return;
    }
    unint64_t v5 = v3[3];
  }

  uint64_t v8 = type metadata accessor for _SliceBuffer(0LL, *(void *)(v4 + 16), v1, v2);
  unint64_t v9 = v3[1];
  unint64_t v10 = v3[2];
  v14[0] = v6;
  v14[1] = v9;
  v14[2] = v10;
  v14[3] = v5;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, v8, v11);
  _ArrayBufferProtocol.init(copying:)((uint64_t)v14, v8, WitnessTable, (uint64_t)v15);
  __int128 v13 = v15[1];
  *(_OWORD *)unint64_t v3 = v15[0];
  *((_OWORD *)v3 + 1) = v13;
}

Swift::Void __swiftcall ArraySlice._checkSubscript_native(_:)(Swift::Int a1)
{
  if (a1 < v1 || (uint64_t)(v2 >> 1) <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
}

Swift::Void __swiftcall _SliceBuffer._checkValidSubscript(_:)(Swift::Int a1)
{
  if (a1 < v1 || (uint64_t)(v2 >> 1) <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
}

void __swiftcall ArraySlice._checkSubscript(_:wasNativeTypeChecked:)(Swift::Int _, Swift::Bool wasNativeTypeChecked)
{
}

Swift::Void __swiftcall ArraySlice._checkIndex(_:)(Swift::Int a1)
{
  if (a1 > (uint64_t)(v2 >> 1)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ArraySlice index is out of range",  32LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0xCEuLL,  0);
  }
  if (a1 < v1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ArraySlice index is out of range (before startIndex)",  52LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0xCFuLL,  0);
  }
}

uint64_t ArraySlice._getElement(_:wasNativeTypeChecked:matchingSubscriptCheck:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X6>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + *(void *)(*(void *)(a3 - 8) + 72LL) * a1,  a3);
}

uint64_t _SliceBuffer.getElement(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16LL))( a4,  a2 + *(void *)(*(void *)(a3 - 8) + 72LL) * a1,  a3);
}

uint64_t ArraySlice._getElementAddress(_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return a3 + *(void *)(*(void *)(a6 - 8) + 72LL) * a1;
}

id ArraySlice._owner.getter()
{
  uint64_t v0 = (void *)EnumeratedSequence._base.modify();
  return swift_unknownObjectRetain(v0, v1, v2, v3);
}

uint64_t ArraySlice._baseAddressIfContiguous.getter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a2 + *(void *)(*(void *)(a5 - 8) + 72LL) * a3;
}

uint64_t _SliceBuffer.firstElementAddressIfContiguous.getter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a2 + *(void *)(*(void *)(a5 - 8) + 72LL) * a3;
}

uint64_t _SliceBuffer.identity.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a2 + *(void *)(*(void *)(a5 - 8) + 72LL) * a3;
}

uint64_t _SliceBuffer.firstElementAddress.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a2 + *(void *)(*(void *)(a5 - 8) + 72LL) * a3;
}

uint64_t protocol witness for _ArrayProtocol.capacity.getter in conformance ArraySlice<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( a1,  a2,  (uint64_t (*)(void, void, void, void, void))ArraySlice.capacity.getter);
}

id protocol witness for _ArrayProtocol._owner.getter in conformance ArraySlice<A>()
{
  uint64_t v0 = (void *)EnumeratedSequence._base.modify();
  return swift_unknownObjectRetain(v0, v1, v2, v3);
}

uint64_t protocol witness for _ArrayProtocol._baseAddressIfContiguous.getter in conformance ArraySlice<A>( uint64_t a1)
{
  return *(void *)(v1 + 8) + *(void *)(*(void *)(*(void *)(a1 + 16) - 8LL) + 72LL) * *(void *)(v1 + 16);
}

uint64_t protocol witness for _ArrayProtocol.init(_:) in conformance ArraySlice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = type metadata accessor for _SliceBuffer(0LL, v7, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, v8, v9);
  uint64_t result = ArraySlice.init<A>(_:)(a1, v7, v8, WitnessTable);
  *a5 = result;
  a5[1] = v12;
  a5[2] = 0LL;
  a5[3] = v13;
  return result;
}

uint64_t ArraySlice.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(a3, a4);
}

id protocol witness for _ArrayProtocol._buffer.getter in conformance ArraySlice<A>@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, __int128 *a4@<X8>)
{
  __int128 v5 = *v4;
  __int128 v6 = v4[1];
  *a4 = *v4;
  a4[1] = v6;
  return swift_unknownObjectRetain((id)v5, a1, a2, a3);
}

unint64_t _SliceBuffer.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return a4 >> 1;
}

Swift::Int __swiftcall ArraySlice.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1LL);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Void __swiftcall ArraySlice.formIndex(after:)(Swift::Int *after)
{
  if (__OFADD__(*after, 1LL)) {
    __break(1u);
  }
  else {
    ++*after;
  }
}

Swift::Int __swiftcall ArraySlice.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1LL);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Void __swiftcall ArraySlice.formIndex(before:)(Swift::Int *before)
{
  if (__OFSUB__(*before, 1LL)) {
    __break(1u);
  }
  else {
    --*before;
  }
}

Swift::Int __swiftcall ArraySlice.index(_:offsetBy:)(Swift::Int _, Swift::Int offsetBy)
{
  BOOL v2 = __OFADD__(_, offsetBy);
  Swift::Int result = _ + offsetBy;
  if (v2) {
    __break(1u);
  }
  return result;
}

Swift::Int_optional __swiftcall ArraySlice.index(_:offsetBy:limitedBy:)( Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3 = specialized Array.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy);
  Swift::Bool v5 = v4 & 1;
  result.value = v3;
  result.is_nil = v5;
  return result;
}

Swift::Int __swiftcall ArraySlice.distance(from:to:)(Swift::Int from, Swift::Int to)
{
  BOOL v2 = __OFSUB__(to, from);
  Swift::Int result = to - from;
  if (v2) {
    __break(1u);
  }
  return result;
}

uint64_t ArraySlice.subscript.getter@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  if (a1 < a3 || (uint64_t)(a4 >> 1) <= a1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16LL))( a6,  a2 + *(void *)(*(void *)(a5 - 8) + 72LL) * a1,  a5);
}

uint64_t key path getter for ArraySlice.subscript(_:) : <A>ArraySlice<A>A@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return ArraySlice.subscript.getter( *a2,  *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  *(uint64_t *)((char *)a2 + a3 - 8),  a4);
}

uint64_t key path setter for ArraySlice.subscript(_:) : <A>ArraySlice<A>A( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = *(uint64_t *)((char *)a3 + a4 - 8);
  uint64_t v6 = *a3;
  type metadata accessor for ArraySlice(0LL, v5, (uint64_t)a3, a4);
  uint64_t v7 = ArraySlice.subscript.modify((uint64_t)v10, v6);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24LL))(v8, a1, v5);
  return ((uint64_t (*)(_BYTE *, void))v7)(v10, 0LL);
}

uint64_t (*ArraySlice.subscript.modify(uint64_t a1, uint64_t a2))()
{
  if (*(void *)(v2 + 16) > a2 || *(void *)(v2 + 24) >> 1 <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
  return EnumeratedSequence._base.modify;
}

uint64_t ArraySlice.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (v3[2] > a2 || v3[3] >> 1 <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8LL) + 40LL))( v3[1] + *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 72LL) * a2,  a1);
}

void ArraySlice.subscript.getter(Swift::Int a1, Swift::Int a2, void *a3, uint64_t a4)
{
  id v11 = swift_unknownObjectRetain(a3, v8, v9, v10);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v11, a4, a1, a2);
}

void key path getter for ArraySlice.subscript(_:) : <A>ArraySlice<A>A( uint64_t a1@<X0>, Swift::Int *a2@<X1>, void *a3@<X8>)
{
  *a3 = v4;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
}

void key path setter for ArraySlice.subscript(_:) : <A>ArraySlice<A>A( uint64_t a1, uint64_t a2, Swift::Int *a3, uint64_t a4)
{
  Swift::Int v4 = *a3;
  uint64_t v5 = (char *)a3[1];
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 16);
  unint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = type metadata accessor for ArraySlice(0LL, *(Swift::Int *)((char *)a3 + a4 - 8), (uint64_t)a3, a4);
  id v14 = swift_unknownObjectRetain(v6, v11, v12, v13);
  ArraySlice.subscript.setter(v14, v7, v8, v9, v4, v5, v10);
}

void ArraySlice.subscript.setter( void *a1, uint64_t a2, uint64_t a3, unint64_t a4, Swift::Int a5, char *a6, uint64_t a7)
{
  uint64_t v12 = *(void **)v7;
  uint64_t v13 = *(void *)(v7 + 8);
  uint64_t v14 = *(void *)(a7 + 16);
  ArraySlice._checkIndex(_:)(a5);
  ArraySlice._checkIndex(_:)((Swift::Int)a6);
  id v18 = swift_unknownObjectRetain(v12, v15, v16, v17);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v18, v13, a5, (uint64_t)a6);
  uint64_t v20 = v19;
  uint64_t v22 = v21;
  swift_unknownObjectRelease(v23);
  if (v20 + *(void *)(*(void *)(v14 - 8) + 72LL) * v22 != a2 + *(void *)(*(void *)(v14 - 8) + 72LL) * a3) {
    goto LABEL_2;
  }
  if ((uint64_t)(a4 >> 1) < a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (a5 == a3 && (char *)(a4 >> 1) == a6)
  {
    swift_unknownObjectRelease(a1);
  }

  else
  {
LABEL_2:
    v29[0] = a1;
    v29[1] = a2;
    v29[2] = a3;
    v29[3] = a4;
    unint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a7, v24);
    ArraySlice.replaceSubrange<A>(_:with:)(a5, a6, v29, a7, a7, WitnessTable);
  }

id _SliceBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Swift::Int v3 = (void *)specialized _SliceBuffer.subscript.getter(a1, a2, a3);
  return swift_unknownObjectRetain(v3, v4, v5, v6);
}

uint64_t ArraySlice.replaceSubrange<A>(_:with:)( uint64_t result, char *a2, void *a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v7 = v6[2];
  if (v7 > result) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ArraySlice replace: subrange start is before the startIndex",  59LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x53FuLL,  0);
  }
  uint64_t v8 = v6;
  unint64_t v10 = v6[3];
  unint64_t v11 = v10 >> 1;
  if ((uint64_t)(v10 >> 1) < (uint64_t)a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ArraySlice replace: subrange extends past the end",  49LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x542uLL,  0);
  }
  unint64_t v47 = v11 - v7;
  if (__OFSUB__(v11, v7))
  {
    __break(1u);
    goto LABEL_20;
  }

  uint64_t v12 = (void *)result;
  uint64_t v13 = &a2[-result];
  if (__OFSUB__(a2, result))
  {
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }

  Swift::Int result = (*(uint64_t (**)(uint64_t, unint64_t))(a6 + 112))(a5, a6);
  BOOL v19 = __OFSUB__(result, v13);
  uint64_t v20 = result - (void)v13;
  if (v19)
  {
LABEL_21:
    __break(1u);
    goto LABEL_22;
  }

  uint64_t v21 = result;
  if ((v10 & 1) == 0) {
    goto LABEL_15;
  }
  uint64_t v22 = (void *)*v8;
  int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*v8);
  *uint64_t v8 = (unint64_t)v22;
  if (!isUniquelyReferenced_nonNull) {
    goto LABEL_15;
  }
  uint64_t v45 = v20;
  unint64_t v46 = v8[1];
  uint64_t v24 = type metadata accessor for __ContiguousArrayStorageBase();
  id v28 = swift_unknownObjectRetain(v22, v25, v26, v27);
  uint64_t v29 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v28, v24);
  if (!v29)
  {
    swift_unknownObjectRelease(v22);
    uint64_t v29 = &_swiftEmptyArrayStorage;
  }

  uint64_t v30 = *(void *)(a4 + 16);
  uint64_t v31 = *(void *)(v30 - 8);
  uint64_t v32 = (char *)v29 + ((*(unsigned __int8 *)(v31 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v31 + 80));
  uint64_t v33 = v29[2];
  uint64_t v34 = *(void *)(v31 + 72);
  unint64_t v35 = v46 + v34 * v7;
  unint64_t v36 = v47;
  if ((char *)(v35 + v34 * v47) == &v32[v34 * (void)v33])
  {
    unint64_t v38 = (unint64_t)v29[3];
    Swift::Int result = swift_release((uint64_t)v29);
    unint64_t v39 = v38 >> 1;
    unint64_t v36 = v47;
    unint64_t v40 = v39 - (void)v33;
    BOOL v19 = __OFADD__(v47, v40);
    uint64_t v37 = v47 + v40;
    if (v19)
    {
LABEL_23:
      __break(1u);
      return result;
    }
  }

  else
  {
    Swift::Int result = swift_release((uint64_t)v29);
    uint64_t v37 = v47;
  }

  if (__OFADD__(v36, v45))
  {
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }

  if (v37 < (uint64_t)(v36 + v45))
  {
LABEL_15:
    uint64_t v41 = type metadata accessor for _SliceBuffer(0LL, *(void *)(a4 + 16), v17, v18);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, v41, v42);
    specialized _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)( v12,  (uint64_t)a2,  (uint64_t)a3,  v21,  v41,  a5,  WitnessTable,  a6);
    return (*(uint64_t (**)(void *, uint64_t))(*(void *)(a5 - 8) + 8LL))(a3, a5);
  }

  uint64_t v44 = type metadata accessor for _SliceBuffer(0LL, v30, v17, v18);
  return _SliceBuffer.replaceSubrange<A>(_:with:elementsOf:)((uint64_t)v12, a2, v21, a3, v44, a5, a6);
}

void (*ArraySlice.subscript.modify( void *a1, Swift::Int a2, Swift::Int a3, uint64_t a4))(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v9 = malloc(0x40uLL);
  *a1 = v9;
  v9[6] = a4;
  v9[7] = v4;
  v9[4] = a2;
  v9[5] = a3;
  unint64_t v10 = *(void **)v4;
  uint64_t v11 = *(void *)(v4 + 8);
  ArraySlice._checkIndex(_:)(a2);
  ArraySlice._checkIndex(_:)(a3);
  id v15 = swift_unknownObjectRetain(v10, v12, v13, v14);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v15, v11, a2, a3);
  *unint64_t v9 = v16;
  v9[1] = v17;
  void v9[2] = v18;
  v9[3] = v19;
  return ArraySlice.subscript.modify;
}

void ArraySlice.subscript.modify(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = **a1;
  uint64_t v6 = (uint64_t)v4[1];
  uint64_t v7 = (uint64_t)v4[2];
  unint64_t v8 = (unint64_t)v4[3];
  uint64_t v9 = (uint64_t)v4[6];
  Swift::Int v11 = (Swift::Int)v4[4];
  unint64_t v10 = (char *)v4[5];
  if ((a2 & 1) != 0)
  {
    id v12 = swift_unknownObjectRetain(v5, a2, a3, a4);
    ArraySlice.subscript.setter(v12, v6, v7, v8, v11, v10, v9);
    swift_unknownObjectRelease(*v4);
  }

  else
  {
    ArraySlice.subscript.setter( v5,  (uint64_t)v4[1],  (uint64_t)v4[2],  (unint64_t)v4[3],  (Swift::Int)v4[4],  (char *)v4[5],  (uint64_t)v4[6]);
  }

  free(v4);
}

uint64_t ArraySlice.count.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = (a4 >> 1) - a3;
  if (__OFSUB__(a4 >> 1, a3)) {
    __break(1u);
  }
  return result;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance ArraySlice<A>( uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  ArraySlice._makeMutableAndUnique()();
  if (v6 < v3[2] || v6 >= v3[3] >> 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8LL) + 40LL))( v3[1] + *(void *)(*(void *)(*(void *)(a3 + 16) - 8LL) + 72LL) * v6,  a1);
  return EnumeratedSequence._base.modify();
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance ArraySlice<A>( void *a1, uint64_t *a2))()
{
  uint64_t v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = ArraySlice.subscript.modify((uint64_t)v4, *a2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void protocol witness for MutableCollection.subscript.setter in conformance ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void (*protocol witness for MutableCollection.subscript.modify in conformance ArraySlice<A>( void *a1, Swift::Int *a2, uint64_t a3))(void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  v7[4] = v3;
  v7[5] = a3;
  Swift::Int v8 = *a2;
  Swift::Int v9 = a2[1];
  v7[6] = v8;
  v7[7] = v9;
  unint64_t v10 = *(void **)v3;
  uint64_t v11 = *(void *)(v3 + 8);
  ArraySlice._checkIndex(_:)(v8);
  ArraySlice._checkIndex(_:)(v9);
  id v15 = swift_unknownObjectRetain(v10, v12, v13, v14);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v15, v11, v8, v9);
  *uint64_t v7 = v16;
  v7[1] = v17;
  v7[2] = v18;
  v7[3] = v19;
  return protocol witness for MutableCollection.subscript.modify in conformance ArraySlice<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance ArraySlice<A>( void ***a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = **a1;
  uint64_t v6 = (uint64_t)v4[1];
  uint64_t v7 = (uint64_t)v4[2];
  unint64_t v8 = (unint64_t)v4[3];
  Swift::Int v10 = (Swift::Int)v4[6];
  Swift::Int v9 = (char *)v4[7];
  uint64_t v11 = (uint64_t)v4[5];
  if ((a2 & 1) != 0)
  {
    id v12 = swift_unknownObjectRetain(v5, a2, a3, a4);
    ArraySlice.subscript.setter(v12, v6, v7, v8, v10, v9, v11);
    swift_unknownObjectRelease(*v4);
  }

  else
  {
    ArraySlice.subscript.setter( v5,  (uint64_t)v4[1],  (uint64_t)v4[2],  (unint64_t)v4[3],  (Swift::Int)v4[6],  (char *)v4[7],  (uint64_t)v4[5]);
  }

  free(v4);
}

void *protocol witness for MutableCollection.partition(by:) in conformance ArraySlice<A>@<X0>( uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void *protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance ArraySlice<A>@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ArraySlice.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a3, a2, a4);
}

void *ArraySlice._withUnsafeMutableBufferPointerIfSupported<A>(_:)@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ArraySlice._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3, a4);
}

{
  void *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  void v15[2];
  uint64_t v7 = v4[2];
  unint64_t v8 = v4[3] >> 1;
  Swift::Int v9 = v8 - v7;
  if (__OFSUB__(v8, v7))
  {
    __break(1u);
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  id v12 = *(void *)(a2 + 16);
  ArraySlice._makeMutableAndUnique()();
  if (v9 < 0) {
    goto LABEL_8;
  }
  v15[0] = v4[1] + *(void *)(*(void *)(v12 - 8) + 72LL) * v4[2];
  uint64_t v13 = v15[0];
  v15[1] = v9;
  a1(v15);
  if (v5) {
    return $defer #1 <A><A1>() in ArraySlice.withUnsafeMutableBufferPointer<A>(_:)(v15, v13, v9);
  }
  $defer #1 <A><A1>() in ArraySlice.withUnsafeMutableBufferPointer<A>(_:)(v15, v13, v9);
  return (void *)(*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56LL))( a4,  0LL,  1LL,  a3);
}

void *ArraySlice.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>( void (*a1)(void *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ArraySlice._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3, a4);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance ArraySlice<A>( void *result)
{
  if (__OFSUB__(*result, 1LL)) {
    __break(1u);
  }
  else {
    --*result;
  }
  return result;
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance ArraySlice<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = specialized Array.index(_:offsetBy:limitedBy:)(*a1, a2, *a3);
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

void protocol witness for Collection.startIndex.getter in conformance ArraySlice<A>(void *a1@<X8>)
{
  *a1 = *(void *)(v1 + 16);
}

unint64_t protocol witness for Collection.endIndex.getter in conformance ArraySlice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t result = ArraySlice.endIndex.getter(a1, a2, a3, *(void *)(v4 + 24));
  *a4 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance ArraySlice<A>( void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = ArraySlice.subscript.read( v7,  *a2,  *(void *)v3,  *(void *)(v3 + 8),  *(void *)(v3 + 16),  *(void *)(v3 + 24),  *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*ArraySlice.subscript.read( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7))()
{
  uint64_t v10 = *(void *)(a7 - 8);
  *a1 = a7;
  a1[1] = v10;
  a1[2] = malloc(*(void *)(v10 + 64));
  if (a2 < a5 || (uint64_t)(a6 >> 1) <= a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
  }
  (*(void (**)(void))(v10 + 16))();
  return _ArrayBuffer.subscript.read;
}

void protocol witness for Collection.subscript.getter in conformance ArraySlice<A>( Swift::Int *a1@<X0>, void *a2@<X8>)
{
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
}

uint64_t protocol witness for Collection.indices.getter in conformance ArraySlice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.count.getter in conformance ArraySlice<A>(uint64_t a1, uint64_t a2)
{
  return ArraySlice.count.getter(a1, a2, *(void *)(v2 + 16), *(void *)(v2 + 24));
}

void *protocol witness for RandomAccessCollection.index(_:offsetBy:) in conformance ArraySlice<A>@<X0>( void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (__OFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + a2;
  }
  return result;
}

void *protocol witness for Collection.formIndex(after:) in conformance ArraySlice<A>(void *result)
{
  if (__OFADD__(*result, 1LL)) {
    __break(1u);
  }
  else {
    ++*result;
  }
  return result;
}

__n128 protocol witness for Sequence.makeIterator() in conformance ArraySlice<A>@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  __int128 v3 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v1;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = v3;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance ArraySlice<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( a1,  a2,  (uint64_t (*)(void, void, void, void, void))ArraySlice._copyToContiguousArray());
}

__objc2_class **ArraySlice._copyToContiguousArray()( void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  if ((a4 & 1) == 0) {
    goto LABEL_2;
  }
  uint64_t v14 = type metadata accessor for __ContiguousArrayStorageBase();
  uint64_t v17 = swift_unknownObjectRetain_n((uint64_t)a1, 2LL, v15, v16);
  uint64_t v18 = (__objc2_class **)swift_dynamicCastClass(v17, v14);
  if (!v18)
  {
    swift_unknownObjectRelease(a1);
    uint64_t v18 = &_swiftEmptyArrayStorage;
  }

  uint64_t v19 = v18[2];
  uint64_t v20 = (void *)swift_release((uint64_t)v18);
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
    goto LABEL_11;
  }

  uint64_t v20 = a1;
  if (v19 != (__objc2_class *)((a4 >> 1) - a3))
  {
LABEL_11:
    swift_unknownObjectRelease(v20);
LABEL_2:
    v22[0] = a1;
    v22[1] = a2;
    void v22[2] = a3;
    v22[3] = a4;
    uint64_t v10 = type metadata accessor for ArraySlice(0LL, a5, a3, a4);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v10, v11);
    uint64_t v13 = (uint64_t)_copyCollectionToContiguousArray<A>(_:)((uint64_t)v22, v10, WitnessTable);
    swift_unknownObjectRelease(a1);
    return (__objc2_class **)v13;
  }

  uint64_t v13 = swift_dynamicCastClass((uint64_t)a1, v14);
  swift_unknownObjectRelease(a1);
  if (!v13)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptyArrayStorage;
  }

  return (__objc2_class **)v13;
}

__n128 protocol witness for Sequence._copyContents(initializing:) in conformance ArraySlice<A>( uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = v9;
  __n128 result = (__n128)v8[1];
  *(_OWORD *)a1 = v8[0];
  *(__n128 *)(a1 + 16) = result;
  *(void *)(a1 + 32) = v6;
  return result;
}

void ArraySlice._copyContents(initializing:)( char *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, char *a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  unint64_t v13 = a6 >> 1;
  if (a6 >> 1 != a5)
  {
    if (!a1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempt to copy contents into nil buffer pointer",  48LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x500uLL,  0);
    }
    uint64_t v14 = v13 - a5;
    if (__OFSUB__(v13, a5))
    {
      __break(1u);
    }

    else if (v14 <= a2)
    {
      uint64_t v17 = &a4[*(void *)(*(void *)(a7 - 8) + 72LL) * a5];
      swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
      UnsafeMutablePointer.initialize(from:count:)(v17, v13 - a5, a1, a7);
      swift_unknownObjectRelease(a3);
      goto LABEL_7;
    }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Insufficient space allocated to copy array contents",  51LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x501uLL,  0);
  }

  uint64_t v14 = 0LL;
  unint64_t v13 = a5;
LABEL_7:
  *a8 = a3;
  a8[1] = a4;
  a8[2] = a5;
  a8[3] = a6;
  a8[4] = v13;
  a8[5] = v14;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance ArraySlice<A>@<X0>( uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return ArraySlice.withContiguousStorageIfAvailable<A>(_:)( a1,  *(void *)(v4 + 8),  *(void *)(v4 + 16),  *(void *)(v4 + 24),  *(void *)(a3 + 16),  a2,  a4);
}

uint64_t ArraySlice.withContiguousStorageIfAvailable<A>(_:)@<X0>( uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X3>, uint64_t a3@<X4>, unint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, uint64_t a7@<X8>)
{
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  if ((((a4 >> 1) - a3) & 0x8000000000000000LL) != 0) {
    goto LABEL_7;
  }
  uint64_t result = a1(a2 + *(void *)(*(void *)(a5 - 8) + 72LL) * a3);
  if (!v7) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a6 - 8) + 56LL))(a7, 0LL, 1LL, a6);
  }
  return result;
}

uint64_t ArraySlice.init(arrayLiteral:)(unint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    if ((a1 & 0x8000000000000000LL) != 0 || (a1 & 0x4000000000000000LL) != 0)
    {
      unint64_t v13 = a1;
      uint64_t v10 = type metadata accessor for Array(0LL, (uint64_t)a2, v5, (uint64_t)v6);
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v10, v11);
      unint64_t v8 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v13, v10, WitnessTable);
      swift_bridgeObjectRelease(a1);
    }

    else
    {
      swift_bridgeObjectRetain(a1, v4, v5, v6);
      BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
      swift_bridgeObjectRelease(a1);
      if (isClassOrObjCExistentialType) {
        return a1 & 0xFFFFFFFFFFFFFF8LL;
      }
      else {
        return a1;
      }
    }
  }

  else if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    return a1 & 0xFFFFFFFFFFFFFF8LL;
  }

  else
  {
    return a1;
  }

  return (uint64_t)v8;
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance ArraySlice<A>@<X0>( unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = ArraySlice.init(arrayLiteral:)(a1, *(uint64_t **)(a2 + 16));
  *a3 = result;
  a3[1] = v5;
  a3[2] = 0LL;
  a3[3] = v6;
  return result;
}

__objc2_class **ArraySlice.init()()
{
  return &_swiftEmptyArrayStorage;
}

__objc2_class **_SliceBuffer.init()()
{
  return &_swiftEmptyArrayStorage;
}

__objc2_class **ArraySlice.init(repeating:count:)(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct ArraySlice with count < 0",  41LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x2BEuLL,  0);
  }
  uint64_t v4 = a2;
  if (!a2)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(a3 - 1) + 8))(a1, a3);
    return &_swiftEmptyArrayStorage;
  }

  uint64_t v6 = static ArraySlice._allocateBufferUninitialized(minimumCapacity:)(a2, a3);
  unint64_t v10 = v9 >> 1;
  uint64_t v11 = (v9 >> 1) - v8;
  if (__OFSUB__(v9 >> 1, v8))
  {
    __break(1u);
    goto LABEL_19;
  }

  uint64_t v12 = v4 - v11;
  if (__OFSUB__(v4, v11))
  {
LABEL_19:
    __break(1u);
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }

  unint64_t v13 = (void *)v6;
  uint64_t v14 = v7;
  if (!v12) {
    goto LABEL_12;
  }
  uint64_t v15 = v8;
  uint64_t v16 = type metadata accessor for __ContiguousArrayStorageBase();
  id v20 = swift_unknownObjectRetain(v13, v17, v18, v19);
  uint64_t v21 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v20, v16);
  if (!v21)
  {
    swift_unknownObjectRelease(v13);
    uint64_t v21 = &_swiftEmptyArrayStorage;
  }

  uint64_t v22 = v21[2];
  BOOL v23 = __OFADD__(v22, v12);
  uint64_t v24 = (__objc2_class *)((char *)v22 + v12);
  if (v23) {
    goto LABEL_20;
  }
  v21[2] = v24;
  swift_release((uint64_t)v21);
  if (__OFADD__(v10, v12))
  {
LABEL_21:
    __break(1u);
LABEL_22:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  if (((v10 + v12) & 0x8000000000000000LL) != 0) {
    goto LABEL_22;
  }
  uint64_t v8 = v15;
LABEL_12:
  uint64_t v25 = *(a3 - 1);
  uint64_t v26 = *(void *)(v25 + 72);
  uint64_t v27 = v14 + v26 * v8;
  id v28 = *(void (**)(uint64_t, uint64_t, uint64_t *))(v25 + 16);
  do
  {
    v28(v27, a1, a3);
    v27 += v26;
    --v4;
  }

  while (v4);
  (*(void (**)(uint64_t, uint64_t *))(v25 + 8))(a1, a3);
  return (__objc2_class **)v13;
}

uint64_t static ArraySlice._allocateBufferUninitialized(minimumCapacity:)(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(0LL, a1, a2);
  return _SliceBuffer.init(_buffer:shiftedToStartIndex:)((uint64_t)v2, 0LL);
}

__objc2_class **_SliceBuffer.count.setter(__objc2_class **result)
{
  uint64_t v2 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24) >> 1;
  BOOL v4 = __OFSUB__(v3, v2);
  uint64_t v5 = v3 - v2;
  if (v4)
  {
    __break(1u);
    goto LABEL_11;
  }

  uint64_t v6 = (char *)result - v5;
  if (__OFSUB__(result, v5))
  {
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }

  if (v6)
  {
    uint64_t v7 = *(void **)v1;
    uint64_t v8 = type metadata accessor for __ContiguousArrayStorageBase();
    id v12 = swift_unknownObjectRetain(v7, v9, v10, v11);
    uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v12, v8);
    if (!result)
    {
      swift_unknownObjectRelease(v7);
      uint64_t result = &_swiftEmptyArrayStorage;
    }

    unint64_t v13 = result[2];
    BOOL v4 = __OFADD__(v13, v6);
    uint64_t v14 = (__objc2_class *)&v6[(void)v13];
    if (!v4)
    {
      result[2] = v14;
      swift_release((uint64_t)result);
      uint64_t result = (__objc2_class **)&v6[v3];
      if (!__OFADD__(v3, v6)) {
        return (__objc2_class **)_SliceBuffer.endIndex.setter((uint64_t)result);
      }
      goto LABEL_13;
    }

__objc2_class **ArraySlice.init(_uninitializedCount:)(uint64_t a1, uint64_t *a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't construct ArraySlice with count < 0",  41LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x2DBuLL,  0);
  }
  if (!a1) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v3 = static ArraySlice._allocateBufferUninitialized(minimumCapacity:)(a1, a2);
  unint64_t v5 = v4 >> 1;
  uint64_t v7 = (v4 >> 1) - v6;
  if (__OFSUB__(v4 >> 1, v6))
  {
    __break(1u);
    goto LABEL_16;
  }

  uint64_t v8 = a1 - v7;
  if (__OFSUB__(a1, v7))
  {
LABEL_16:
    __break(1u);
    goto LABEL_17;
  }

  uint64_t v9 = (void *)v3;
  if (v8)
  {
    uint64_t v10 = type metadata accessor for __ContiguousArrayStorageBase();
    id v14 = swift_unknownObjectRetain(v9, v11, v12, v13);
    uint64_t v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v14, v10);
    if (!v15)
    {
      swift_unknownObjectRelease(v9);
      uint64_t v15 = &_swiftEmptyArrayStorage;
    }

    uint64_t v16 = v15[2];
    BOOL v17 = __OFADD__(v16, v8);
    uint64_t v18 = (__objc2_class *)((char *)v16 + v8);
    if (!v17)
    {
      _OWORD v15[2] = v18;
      swift_release((uint64_t)v15);
      if (!__OFADD__(v5, v8))
      {
        if (((v5 + v8) & 0x8000000000000000LL) == 0) {
          return (__objc2_class **)v9;
        }
LABEL_19:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
      }

__objc2_class **static ArraySlice._allocateUninitialized(_:)@<X0>( uint64_t a1@<X0>, uint64_t *a2@<X1>, __objc2_class ***a3@<X8>)
{
  uint64_t result = ArraySlice.init(_uninitializedCount:)(a1, a2);
  uint64_t v8 = (__objc2_class **)((char *)v6 + *(void *)(*(a2 - 1) + 72) * (void)v7);
  *a3 = result;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v9;
  a3[4] = v8;
  return result;
}

Swift::Void __swiftcall ArraySlice.reserveCapacity(_:)(Swift::Int a1)
{
  uint64_t v5 = v1;
  unint64_t v7 = v4[3];
  uint64_t v8 = (void *)*v4;
  int64_t v9 = v7 >> 1;
  if ((v7 & 1) == 0) {
    goto LABEL_11;
  }
  int isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*v4);
  *unint64_t v4 = (unint64_t)v8;
  if (!isUniquelyReferenced_nonNull) {
    goto LABEL_11;
  }
  unint64_t v11 = v4[2];
  Swift::Int v12 = v9 - v11;
  if (__OFSUB__(v9, v11))
  {
    __break(1u);
    goto LABEL_39;
  }

  unint64_t v13 = v4[1];
  uint64_t v14 = type metadata accessor for __ContiguousArrayStorageBase();
  id v18 = swift_unknownObjectRetain(v8, v15, v16, v17);
  uint64_t v19 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v18, v14);
  if (!v19)
  {
    swift_unknownObjectRelease(v8);
    uint64_t v19 = &_swiftEmptyArrayStorage;
  }

  uint64_t v20 = *(void *)(*(void *)(v5 + 16) - 8LL);
  uint64_t v21 = v19[2];
  if ((__objc2_class **)(v13 + *(void *)(v20 + 72) * v11 + *(void *)(v20 + 72) * v12) == (__objc2_class **)((char *)v19 + ((*(unsigned __int8 *)(v20 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v20 + 80)) + *(void *)(v20 + 72) * (void)v21))
  {
    unint64_t v22 = (unint64_t)v19[3];
    swift_release((uint64_t)v19);
    unint64_t v23 = (v22 >> 1) - (void)v21;
    BOOL v24 = __OFADD__(v12, v23);
    v12 += v23;
    if (!v24) {
      goto LABEL_9;
    }
LABEL_39:
    __break(1u);
    return;
  }

  swift_release((uint64_t)v19);
LABEL_9:
  if (v12 >= a1) {
    return;
  }
  uint64_t v8 = (void *)*v4;
LABEL_11:
  int64_t v25 = v4[2];
  unint64_t v26 = v4[3] >> 1;
  Swift::Int v27 = v26 - v25;
  if (__OFSUB__(v26, v25))
  {
    __break(1u);
LABEL_32:
    __break(1u);
    goto LABEL_33;
  }

  unint64_t v28 = v4[1];
  uint64_t v29 = *(uint64_t **)(v5 + 16);
  if (v27 > a1) {
    a1 = v26 - v25;
  }
  if (a1)
  {
    uint64_t v30 = getContiguousArrayStorageType<A>(for:)((uint64_t)v29, v29);
    uint64_t v31 = *(v29 - 1);
    uint64_t v32 = *(void *)(v31 + 72);
    uint64_t v33 = *(unsigned __int8 *)(v31 + 80);
    uint64_t v34 = (__objc2_class **)swift_allocObject( v30,  ((v33 + *(unsigned int *)(v30 + 48)) & ~v33) + v32 * a1,  v33 | *(unsigned __int16 *)(v30 + 52));
    size_t v35 = _swift_stdlib_malloc_size(v34);
    if (!v32) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
    }
    int64_t v39 = v35 - ((v33 + 32) & ~v33);
    if (v39 == 0x8000000000000000LL && v32 == -1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
    }
    uint64_t v41 = v39 / v32;
    swift_retain((unint64_t *)v34, v36, v37, v38);
    BOOL isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v29, v29);
    v34[2] = (__objc2_class *)v27;
    v34[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v41));
    swift_release((uint64_t)v34);
    if (v9 < v25) {
LABEL_30:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  else
  {
    uint64_t v34 = &_swiftEmptyArrayStorage;
    if (v9 < v25) {
      goto LABEL_30;
    }
  }

  BOOL v24 = __OFSUB__(v9, v25);
  uint64_t v43 = v9 - v25;
  if (v24) {
    goto LABEL_32;
  }
  uint64_t v44 = *(v29 - 1);
  uint64_t v45 = (char *)v34 + ((*(unsigned __int8 *)(v44 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v44 + 80));
  uint64_t v46 = *(void *)(v44 + 72);
  swift_retain((unint64_t *)v34, v1, v2, v3);
  UnsafeMutablePointer.initialize(from:count:)((char *)(v28 + v46 * v25), v43, v45, (uint64_t)v29);
  if (__OFSUB__(0LL, v25))
  {
LABEL_33:
    __break(1u);
    goto LABEL_34;
  }

  unint64_t v47 = v34[2];
  swift_release((uint64_t)v34);
  BOOL v24 = __OFADD__(v25, v47);
  int64_t v48 = (int64_t)v47 + v25;
  if (v24)
  {
LABEL_34:
    __break(1u);
    goto LABEL_35;
  }

  if (v48 < v25) {
    goto LABEL_30;
  }
  if (v48 < 0) {
LABEL_35:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  swift_unknownObjectRelease(v8);
  *unint64_t v4 = (unint64_t)v34;
  v4[1] = (unint64_t)&v45[v46 * -v25];
  v4[2] = v25;
  v4[3] = (2 * v48) | 1;
}

char *_SliceBuffer._copyContents(subRange:initializing:)( uint64_t a1, uint64_t a2, char *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize with negative count",  51LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x442uLL,  0);
  }

  if (v13 < 0) {
    goto LABEL_9;
  }
  uint64_t v14 = *(void *)(*(void *)(a8 - 8) + 72LL);
  uint64_t v15 = (char *)(a5 + v14 * a1);
  uint64_t v16 = v14 * v13;
  BOOL v17 = &a3[v16];
  id v18 = &v15[v16];
  if (v15 < v17 && v18 > a3) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x444uLL,  0);
  }
  swift_arrayInitWithCopy(a3, v15, v13, a8);
  return v17;
}

Swift::Void __swiftcall ArraySlice._copyToNewBuffer(oldCount:)(Swift::Int oldCount)
{
  uint64_t v6 = oldCount + 1;
  __int128 v7 = v4[1];
  v15[0] = *v4;
  v15[1] = v7;
  uint64_t v8 = type metadata accessor for _SliceBuffer(0LL, *(void *)(v1 + 16), v2, v3);
  uint64_t WitnessTable = (uint64_t (**)(uint64_t, uint64_t, char *))swift_getWitnessTable( &protocol conformance descriptor for _SliceBuffer<A>,  v8,  v9);
  unint64_t v11 = _ArrayBufferProtocol._forceCreateUniqueMutableBuffer(countForNewBuffer:minNewCapacity:)( oldCount,  v6,  v8,  (uint64_t)WitnessTable);
  *(void *)&v15[0] = v11;
  Swift::Int v12 = default argument 3 of _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)(v8, (uint64_t)WitnessTable);
  uint64_t v14 = v13;
  _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)( (unint64_t **)v15,  oldCount,  0LL,  (void (*)(char *, uint64_t))v12,  v13,  v8,  WitnessTable);
  swift_release(v14);
  swift_release((uint64_t)v11);
}

Swift::Void __swiftcall ArraySlice._makeUniqueAndReserveCapacityIfNotUnique()()
{
  unint64_t v1 = v0[3];
  if ((v1 & 1) == 0
    || (unint64_t v2 = *v0,
        char isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull(*v0),
        *uint64_t v0 = v2,
        (isUniquelyReferenced_nonNull & 1) == 0))
  {
    unint64_t v4 = v0[2];
    if (__OFSUB__(v1 >> 1, v4)) {
      __break(1u);
    }
    else {
      ArraySlice._copyToNewBuffer(oldCount:)((v1 >> 1) - v4);
    }
  }

Swift::Void __swiftcall ArraySlice._reserveCapacityAssumingUniqueBuffer(oldCount:)(Swift::Int oldCount)
{
  uint64_t v5 = *(void *)(v2 + 16);
  unint64_t v4 = *(void *)(v2 + 24);
  Swift::Int v6 = (v4 >> 1) - v5;
  if (__OFSUB__(v4 >> 1, v5))
  {
    __break(1u);
    goto LABEL_11;
  }

  uint64_t v7 = v1;
  Swift::Int v3 = oldCount;
  if ((v4 & 1) != 0)
  {
    uint64_t v8 = *(void **)v2;
    uint64_t v9 = *(void *)(v2 + 8);
    uint64_t v10 = type metadata accessor for __ContiguousArrayStorageBase();
    id v14 = swift_unknownObjectRetain(v8, v11, v12, v13);
    uint64_t v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v14, v10);
    if (!v15)
    {
      swift_unknownObjectRelease(v8);
      uint64_t v15 = &_swiftEmptyArrayStorage;
    }

    uint64_t v16 = *(void *)(*(void *)(v7 + 16) - 8LL);
    BOOL v17 = v15[2];
    if ((__objc2_class **)(v9 + *(void *)(v16 + 72) * v5 + *(void *)(v16 + 72) * v6) == (__objc2_class **)((char *)v15 + ((*(unsigned __int8 *)(v16 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80)) + *(void *)(v16 + 72) * (void)v17))
    {
      unint64_t v18 = (unint64_t)v15[3];
      swift_release((uint64_t)v15);
      unint64_t v19 = (v18 >> 1) - (void)v17;
      BOOL v20 = __OFADD__(v6, v19);
      v6 += v19;
      if (v20)
      {
        __break(1u);
        return;
      }
    }

    else
    {
      swift_release((uint64_t)v15);
    }
  }

  if (v6 < v3 + 1) {
LABEL_11:
  }
    ArraySlice._copyToNewBuffer(oldCount:)(v3);
}

Swift::Bool __swiftcall _SliceBuffer.isMutableAndUniquelyReferenced()()
{
  if ((*(_BYTE *)(v0 + 24) & 1) != 0) {
    return swift_isUniquelyReferenced_nonNull(*(void *)v0);
  }
  else {
    return 0;
  }
}

__objc2_class **ArraySlice._appendElementAssumeUniqueAndCapacity(_:newElement:)( __objc2_class **result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t v5 = *(void *)(v3 + 24) >> 1;
  uint64_t v6 = v5 - v4;
  if (__OFSUB__(v5, v4))
  {
    __break(1u);
    goto LABEL_12;
  }

  uint64_t v7 = result;
  uint64_t v8 = (char *)result - v6 + 1;
  if (__OFSUB__((char *)result + 1, v6))
  {
LABEL_12:
    __break(1u);
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

  if (!v8)
  {
    uint64_t v20 = *(void *)(a3 + 16);
    return (__objc2_class **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v20 - 8) + 32LL))( *(void *)(v3 + 8)
                             + *(void *)(*(void *)(v20 - 8) + 72LL) * v4
                             + *(void *)(*(void *)(v20 - 8) + 72LL) * (void)v7,
                               a2,
                               v20);
  }

  uint64_t v11 = *(void **)v3;
  uint64_t v12 = type metadata accessor for __ContiguousArrayStorageBase();
  id v16 = swift_unknownObjectRetain(v11, v13, v14, v15);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v16, v12);
  if (!result)
  {
    swift_unknownObjectRelease(v11);
    uint64_t result = &_swiftEmptyArrayStorage;
  }

  BOOL v17 = result[2];
  BOOL v18 = __OFADD__(v17, v8);
  unint64_t v19 = (__objc2_class *)&v8[(void)v17];
  if (v18) {
    goto LABEL_13;
  }
  result[2] = v19;
  swift_release((uint64_t)result);
  uint64_t result = (__objc2_class **)&v8[v5];
  if (!__OFADD__(v5, v8))
  {
    uint64_t v20 = *(void *)(a3 + 16);
    _SliceBuffer.endIndex.setter((uint64_t)result);
    return (__objc2_class **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v20 - 8) + 32LL))( *(void *)(v3 + 8)
                             + *(void *)(*(void *)(v20 - 8) + 72LL) * v4
                             + *(void *)(*(void *)(v20 - 8) + 72LL) * (void)v7,
                               a2,
                               v20);
  }

LABEL_14:
  __break(1u);
  return result;
}

      (*(void (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
      return v19;
    }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range out of bounds",  19LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x2DAuLL,  0);
    }

    uint64_t v3 = 2LL;
    if (result < 0) {
      goto LABEL_14;
    }
  }

  else
  {
    uint64_t v3 = 1LL;
    if (result < 0) {
      goto LABEL_14;
    }
  }

  if (v3 < a2) {
    goto LABEL_14;
  }
  return result;
}

  uint64_t v42 = v78;
  ((void (*)(unint64_t, unint64_t))v84)(v40, AssociatedConformanceWitness);
  Swift::String::Index v81 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v7 + 48);
  if (v81(v42, 1LL, AssociatedTypeWitness) != 1)
  {
    unint64_t v80 = AssociatedConformanceWitness;
    uint64_t v44 = *(void (**)(char *, char *, uint64_t *))(v7 + 32);
    uint64_t v45 = v77;
    while (1)
    {
      v44(v45, v42, AssociatedTypeWitness);
      if (v39)
      {
        uint64_t v43 = v26;
        uint64_t v46 = __OFSUB__(v39--, 1LL);
        if (v46) {
          goto LABEL_46;
        }
      }

      else
      {
        unint64_t v47 = (unint64_t)v26[3];
        if ((uint64_t)((v47 >> 1) + 0x4000000000000000LL) < 0)
        {
          __break(1u);
          goto LABEL_49;
        }

        int64_t v48 = v47 & 0xFFFFFFFFFFFFFFFELL;
        if (v48 <= 1) {
          uint64_t v49 = 1LL;
        }
        else {
          uint64_t v49 = v48;
        }
        uint64_t v50 = getContiguousArrayStorageType<A>(for:)((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        uint64_t v51 = *(void *)(v7 + 72);
        uint64_t v43 = (__objc2_class **)swift_allocObject( v50,  ((v76 + *(unsigned int *)(v50 + 48)) & v75) + v51 * v49,  v76 | *(unsigned __int16 *)(v50 + 52));
        Swift::String::Index v52 = _swift_stdlib_malloc_size(v43);
        if (!v51) {
          goto LABEL_47;
        }
        uint64_t v56 = v79;
        if (v52 - v79 == 0x8000000000000000LL && v51 == -1) {
          goto LABEL_49;
        }
        unint64_t v58 = (uint64_t)(v52 - v79) / v51;
        swift_retain((unint64_t *)v43, v53, v54, v55);
        unint64_t v59 = _swift_isClassOrObjCExistentialType((uint64_t)AssociatedTypeWitness, AssociatedTypeWitness);
        v43[2] = (__objc2_class *)v49;
        v43[3] = (__objc2_class *)(v59 | (unint64_t)(2 * v58));
        swift_release((uint64_t)v43);
        uint64_t v60 = (char *)v43 + v56;
        uint64_t v61 = (unint64_t)v26[3] >> 1;
        uint64_t v62 = v61 * v51;
        unint64_t v63 = v43[3];
        if (v26[2])
        {
          uint64_t v64 = (char *)v26 + v56;
          if (v43 < v26 || v60 >= (char *)v26 + v56 + v62)
          {
            swift_arrayInitWithTakeFrontToBack((char *)v43 + v56, v64, v61, (uint64_t)AssociatedTypeWitness);
          }

          else if (v43 != v26)
          {
            swift_arrayInitWithTakeBackToFront((char *)v43 + v56, v64, v61, (uint64_t)AssociatedTypeWitness);
          }

          v26[2] = 0LL;
        }

        uint64_t v37 = &v60[v62];
        unint64_t v66 = ((unint64_t)v63 >> 1) - v61;
        swift_release((uint64_t)v26);
        uint64_t v45 = v77;
        uint64_t v42 = v78;
        uint64_t v46 = __OFSUB__(v66, 1LL);
        int64_t v39 = v66 - 1;
        if (v46)
        {
LABEL_46:
          __break(1u);
LABEL_47:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
        }
      }

      v44(v37, v45, AssociatedTypeWitness);
      v37 += *(void *)(v7 + 72);
      ((void (*)(unint64_t, unint64_t))v84)(v82, v80);
      unint64_t v26 = v43;
      if (v81(v42, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_42;
      }
    }
  }

  uint64_t v43 = v26;
LABEL_42:
  (*(void (**)(char *, unint64_t))(v72 + 8))(v83, v82);
  (*(void (**)(char *, uint64_t))(v73 + 8))(v42, v74);
  id v67 = (unint64_t)v43[3];
  if (v67 >= 2)
  {
    Swift::Int v68 = v67 >> 1;
    uint64_t v46 = __OFSUB__(v68, v39);
    uint64_t v69 = (__objc2_class *)(v68 - v39);
    if (v46)
    {
      __break(1u);
      goto LABEL_52;
    }

    v43[2] = v69;
  }

  return v43;
}

  if (v15 | v90) {
    return 0LL;
  }
  v81._Swift::UInt64 rawBits = v14;
  Swift::String::Index v82 = specialized LazyMapSequence<>.subscript.getter(v81, a7, a8, a9);
  return specialized RandomAccessCollection<>.distance(from:to:)(v13, a5, v82);
}

    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v13);
  }

  uint64_t v29 = v13 >> 6;
  uint64_t v30 = 1LL << v13;
LABEL_102:
  Swift::Int v106 = *v117;
  *(void *)(*v117 + 8 * v29 + 56) |= v30;
  uint64_t v107 = *(void *)(v106 + 48) + 40 * v13;
  uint64_t v108 = *a1;
  uint64_t v109 = a1[1];
  *(void *)(v107 + 32) = *((void *)a1 + 4);
  *(_OWORD *)uint64_t v107 = v108;
  *(_OWORD *)(v107 + 16) = v109;
  unint64_t v110 = *(void *)(v106 + 16);
  uint64_t v111 = __OFADD__(v110, 1LL);
  uint64_t v112 = v110 + 1;
  if (v111) {
    goto LABEL_110;
  }
  *(void *)(v106 + 16) = v112;
  *(void *)&uint64_t v105 = 0LL;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(void *)(a3 + 32) = 0LL;
  return *(double *)&v105;
}

  *a1 = a4;
  a1[1] = a5;
  return v5;
}

  uint64_t v20 = v7;
  uint64_t v21 = v6;
  BOOL v17 = type metadata accessor for Set(0LL, (uint64_t)a3, (uint64_t)a4, (uint64_t)a4);
  unint64_t v19 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for Set<A>, v17, v18);
  Set._subtract<A>(_:)((char *)&v20, v17, v17, v19);
  return (__objc2_class **)v21;
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }

  uint64_t v8 = -a6;
  if (__OFSUB__(0LL, a6))
  {
    __break(1u);
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
  }

  if ((v8 & 0x8000000000000000LL) != 0) {
    goto LABEL_16;
  }
  if (HIDWORD(v8)) {
    goto LABEL_14;
  }
  uint64_t v6 = a4 + a6;
  uint64_t v7 = a4 < v8;
LABEL_10:
  uint64_t v9 = 0x8000000000000000LL;
  if (v7) {
    uint64_t v6 = ~(a6 >> 63);
  }
  else {
    uint64_t v9 = 0LL;
  }
  *a1 = v6;
  return v9;
}

  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v10, v22, a3);
  (*(void (**)(uint64_t, uint64_t))(v12 + 32))(a3, v12);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v12,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int64_t v25 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v25(&v32, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v32 & 0x100) == 0)
  {
    unint64_t v26 = v32;
    while (!HIBYTE(v23))
    {
      v23 |= (v26 + 1) << (-(__clz(v23) & 0x18) & 0x18);
      v25(&v32, AssociatedTypeWitness, AssociatedConformanceWitness);
      unint64_t v26 = v32;
      if (BYTE1(v32) == 1) {
        goto LABEL_18;
      }
    }

    __break(1u);
    return result;
  }

  unint64_t v55 = v125;
  __int128 v54 = v126;
  uint64_t v56 = v128;
  uint64_t v57 = v124;
  static FixedWidthInteger._random<A>(using:)(v127, (uint64_t)v18, v126, v124, v128, (uint64_t)v125);
  unint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v56 + 8))(v54, v56);
  unint64_t v59 = v132;
  (*(void (**)(unint64_t *, uint64_t))(v57 + 64))(v18, v57);
  uint64_t v60 = v133;
  uint64_t v61 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v133[2] + 8LL) + 8LL))( v55,  v59,  v18);
  uint64_t v62 = v131;
  unint64_t v63 = *(void (**)(char *, unint64_t *))(v131 + 8);
  v63(v59, v18);
  if ((v61 & 1) != 0 && (v58 & 1) != 0)
  {
    v63(v55, v18);
    v123(v129, a3);
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v47)(v130, v110, a3);
  }

    unint64_t v55 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    uint64_t v56 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v43, v44, v45);
    uint64_t v57 = v71;
    v55(&v74, &type metadata for UInt64, v56, a2, a3);
    unint64_t v58 = v72;
    unint64_t v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8LL) + 16LL))( v57,  v72,  a2);
    int64_t v39 = v73;
    v73(v57, a2);
    v39(v58, a2);
    if ((v59 & 1) != 0) {
      goto LABEL_17;
    }
    goto LABEL_7;
  }

  if (v43 >= 65) {
    goto LABEL_14;
  }
  uint64_t v60 = v71;
  (*(void (**)(char *, char *, uint64_t))(v67 + 32))(v71, v72, a2);
  uint64_t v61 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  int64_t v39 = v73;
  v73(v60, a2);
  if (v74 < v61)
  {
LABEL_17:
    int64_t v39 = v73;
    v73(v33, a2);
    uint64_t v41 = 0LL;
    goto LABEL_18;
  }

    v15((char *)a1, a2);
    goto LABEL_15;
  }

  id v16 = (double)v14;
  uint64_t v12 = (double)v14;
  if ((~*(void *)&v16 & 0x7FF0000000000000LL) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because it is either infinite or NaN",  76LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3735uLL,  0);
  }
  if (v16 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Double value cannot be converted to Int because the result would be less than Int.min",  85LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3738uLL,  0);
  }
  v15((char *)a1, a2);
  return *(void *)&v12;
}

    _swift_stdlib_isLinkingConsonant(a2);
LABEL_15:
    LOBYTE(v8) = 1;
    return v8 & 1;
  }

  LOBYTE(v8) = 1;
  switch(v13)
  {
    case 1:
      return v8 & 1;
    case 2:
    case 9:
    case 12:
      goto LABEL_3;
    case 4:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }

      return v8 & 1;
    case 5:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }

      return v8 & 1;
    case 6:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }

      return v8 & 1;
    case 10:
      uint64_t v14 = v12;
      if (v12 > 0xCu) {
        goto LABEL_35;
      }
      if (((1 << v12) & 0xCE0) == 0) {
        goto LABEL_31;
      }
      goto LABEL_3;
    case 11:
      uint64_t v14 = v12;
      if (v12 > 0xCu) {
        goto LABEL_35;
      }
      if (((1 << v12) & 0x8B0) != 0) {
        goto LABEL_3;
      }
LABEL_31:
      if (v14 == 8) {
        goto LABEL_14;
      }
      if (v14 == 12) {
        goto LABEL_33;
      }
      goto LABEL_35;
    default:
      if (v12 == 7) {
        goto LABEL_3;
      }
      if (v12 != 8)
      {
        if (v12 == 12)
        {
          if (v13 == 3)
          {
            LOBYTE(v8) = !specialized _StringGuts.checkIfInEmojiSequence(at:with:)(a3, a4);
            return v8 & 1;
          }

  *a2 = v14;
  return result;
}

    JUMPOUT(0x18176B8B4LL);
  }

  std::string::append(a2, "> ");
  std::string::append(a2, "parent: ");
  uint64_t v10 = (objc_class *)a1[3];
  if (v10)
  {
    swift::nameForMetadata((uint64_t *)&__p, v10);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v12 = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t v12 = __p.__r_.__value_.__l.__size_;
    }
    std::string::append(a2, (const std::string::value_type *)v11, v12);
  }

  else
  {
    std::string::append(a2, "<null>");
  }

  return std::string::append(a2, " - ");
}

    getContextDescriptor(v2, (uint64_t)v14);
    if (!v14[0] || (swift::equalContexts(v14[0], (const char *)CanonicalTypeMetadata) & 1) == 0)
    {
      uint64_t v8 = 1;
LABEL_17:
      SuperclassForMaybeIncompleteMetadata = getSuperclassForMaybeIncompleteMetadata(v2, 0LL, 0, 1);
      if (SuperclassForMaybeIncompleteMetadata)
      {
        uint64_t v2 = SuperclassForMaybeIncompleteMetadata;
        uint64_t v11 = v10;
        while (1)
        {
          if ((v8 & 1) != 0)
          {
            getContextDescriptor(v2, (uint64_t)v14);
          }

          else if (CanonicalTypeMetadata == (uint64_t (***)())v2)
          {
            return CanonicalTypeMetadata;
          }

          uint64_t v2 = getSuperclassForMaybeIncompleteMetadata(v2, v11, 1, 1);
          uint64_t v11 = v12;
          if (!v2) {
            return 0LL;
          }
        }
      }

      return 0LL;
    }

    return (uint64_t (***)())v2;
  }

  if (!v4)
  {
    uint64_t v5 = *v3;
    if ((_DWORD)v5)
    {
      CanonicalTypeMetadata = (uint64_t (***)())((char *)v3 + v5);
    }
  }

  uint64_t v12 = 0;
LABEL_15:
  uint64_t v13 = **(void **)(v5 + 8);
  if (v13)
  {
    uint64_t v14 = **(unsigned __int8 **)(v5 + 16);
    if (v12)
    {
      if (v11 == (const char *)v13)
      {
LABEL_18:
        uint64_t v15 = 0LL;
        id v16 = 0LL;
        BOOL v17 = 0LL;
        goto LABEL_33;
      }
    }

    else
    {
      getContextDescriptor(v13, (uint64_t)&v37);
      if (v37)
      {
        uint64_t result = swift::equalContexts(v37, v11);
        if ((result & 1) != 0)
        {
          uint64_t v15 = 0LL;
          id v16 = 0LL;
          BOOL v17 = 0LL;
          uint64_t v11 = (const char *)v13;
          goto LABEL_33;
        }
      }
    }

    uint64_t result = getSuperclassForMaybeIncompleteMetadata(v13, 0LL, 0, v14 != 0);
    uint64_t v13 = v18;
    if (result)
    {
      unint64_t v19 = result;
      uint64_t v15 = 1LL;
      while (1)
      {
        if (v12)
        {
        }

        else
        {
          getContextDescriptor(v19, (uint64_t)&v37);
          if (v37)
          {
            uint64_t result = swift::equalContexts(v37, v11);
            if ((result & 1) != 0)
            {
              uint64_t v15 = 0LL;
              id v16 = 0LL;
              BOOL v17 = 0LL;
              uint64_t v11 = (const char *)v19;
              goto LABEL_33;
            }
          }
        }

        uint64_t result = getSuperclassForMaybeIncompleteMetadata(v19, v13, 1, v14 != 0);
        unint64_t v19 = result;
        uint64_t v13 = v20;
        if (!result) {
          goto LABEL_32;
        }
      }
    }

    uint64_t v15 = 1LL;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  uint64_t v10 = (unsigned __int128 *)(result + 16);
  do
  {
    uint64_t v13 = __ldxp(v10);
    uint64_t v12 = DWORD2(v13);
    uint64_t v11 = v13;
  }

  while (__stxp(v13, v10));
  if ((v13 & 0x8000000000000000LL) == 0 || v13 != 0xFFFFFFFFLL)
  {
    uint64_t v14 = 2 * (v4 + (v13 >> 1));
    if (v14 == -2 || v14 >> 1 != v4 + (v13 >> 1)) {
LABEL_40:
    }
      swift::RefCounts<swift::SideTableRefCountBits>::incrementUnownedSlow((swift *)result, a2, a3, a4);
    id v16 = HIDWORD(*((void *)&v13 + 1));
    while (1)
    {
      BOOL v17 = v11 & 0xFFFFFFFF00000001LL | (2LL * (v14 >> 1));
      BOOL v18 = v12;
      unint64_t v19 = v12 | (unint64_t)(v16 << 32);
      do
      {
        while (1)
        {
          uint64_t v20 = __ldxp(v10);
          uint64_t v12 = DWORD2(v20);
          uint64_t v21 = (void)v20 != v11;
          if (*((void *)&v20 + 1) != v19) {
            ++v21;
          }
          if (!v21) {
            break;
          }
          if (!__stxp(v20, v10)) {
            goto LABEL_32;
          }
        }
      }

      while (__stxp(__PAIR128__(v18, v17), v10));
LABEL_32:
      if ((void)v20 == v11 && *((void *)&v20 + 1) == v19) {
        break;
      }
      uint64_t v14 = 2 * (v4 + (v20 >> 1));
      unint64_t v23 = v14 != -2 && v14 >> 1 == v4 + (v20 >> 1);
      uint64_t v11 = v20;
      id v16 = HIDWORD(*((void *)&v20 + 1));
      if (!v23) {
        goto LABEL_40;
      }
    }
  }

  return result;
}

      memcpy(&v9[v20], v19, v18);
      v8 += v18;
    }

    while (v14 < 0x1Au);
    uint64_t v10 = 0;
    uint64_t v2 = *((void *)this + 9);
LABEL_41:
    uint64_t v33 = *((void *)this + 8);
    if (v2 >= v33) {
      return 0LL;
    }
    uint64_t v34 = *((void *)this + 7);
    if (*(_BYTE *)(v34 + v2) == 48)
    {
      *((void *)this + 9) = v2 + 1;
      break;
    }

    LODWORD(size) = 0;
    while (1)
    {
      uint64_t v36 = *(unsigned __int8 *)(v34 + v2);
      uint64_t v37 = v36 + 10 * size - 48;
      *((void *)this + 9) = ++v2;
      LODWORD(size) = v37;
      if (v33 == v2)
      {
        uint64_t v2 = v33;
        LODWORD(size) = v37;
        break;
      }
    }

    unint64_t v80 = v10;
    if (!v81)
    {
      unint64_t v38 = size;
      if (v2 + size <= v33)
      {
        uint64_t v42 = v8;
        uint64_t v43 = v7;
        if (size + (unint64_t)v8 > v7)
        {
          uint64_t v86 = v8;
          uint64_t v44 = v7;
          uint64_t v45 = (char *)*((void *)this + 1);
          if (&v9[v43] != v45)
          {
            uint64_t v46 = *((void *)this + 2);
            goto LABEL_71;
          }

          unint64_t v47 = &v9[v43 + size];
          uint64_t v46 = *((void *)this + 2);
          if ((unint64_t)v47 <= v46)
          {
            *((void *)this + 1) = v47;
            uint64_t v64 = size;
            __int128 v54 = v44;
            uint64_t v8 = v86;
          }

          else
          {
LABEL_71:
            __srca = (void *)v42;
            LODWORD(v48) = 2 * v44;
            else {
              int64_t v48 = v48;
            }
            uint64_t v79 = v48;
            uint64_t v49 = v48 + v43;
            if (!v45 || (unint64_t)&v45[v49] > v46)
            {
              uint64_t v50 = 2LL * *((void *)this + 4);
              if (v50 <= v49 + 1) {
                uint64_t v50 = v49 + 1;
              }
              *((void *)this + 4) = v50;
              uint64_t v51 = v50 + 8;
              Swift::String::Index v52 = malloc(v50 + 8);
              unint64_t v53 = (char *)v52 + v51;
              *Swift::String::Index v52 = *((void *)this + 3);
              uint64_t v45 = (char *)(v52 + 1);
              *((void *)this + 2) = v53;
              *((void *)this + 3) = v52;
            }

            *((void *)this + 1) = &v45[v49];
            if (v44)
            {
              memcpy(v45, v9, v43);
              uint64_t v9 = v45;
              __int128 v54 = v44;
            }

            else
            {
              uint64_t v9 = v45;
              __int128 v54 = 0;
            }

            uint64_t v8 = v86;
            uint64_t v42 = (unint64_t)__srca;
            uint64_t v64 = v79;
          }

          uint64_t v7 = v54 + v64;
        }

        unint64_t v65 = v34 + v2;
        memcpy(&v9[v42], (const void *)(v34 + v2), size);
        unint64_t v66 = 0LL;
        id v67 = -1;
        while (2)
        {
          if (v66 >= size)
          {
            uint64_t v70 = 0;
            if ((v67 & 0x80000000) == 0) {
              goto LABEL_115;
            }
LABEL_102:
          }

          else
          {
            uint64_t v70 = *(unsigned __int8 *)(v65 + v66);
            if ((v67 & 0x80000000) != 0) {
              goto LABEL_102;
            }
LABEL_115:
            if (!v70
              || v70 == 95
              || (v70 - 65) <= 0x19
              && *(unsigned __int8 *)(v65 + v66 - 1) - 91 <= 0xFFFFFFE5)
            {
              if ((int)(v66 - v67) >= 2)
              {
                unint64_t v71 = *((int *)this + 134);
                if ((int)v71 <= 25)
                {
                  *((_DWORD *)this + 134) = v71 + 1;
                  int64_t v72 = (char *)this + 16 * v71;
                  *((void *)v72 + 15) = v65 + v67;
                  *((void *)v72 + 16) = v66 - v67;
                }
              }

              id v67 = -1;
              goto LABEL_102;
            }
          }

          if ((_DWORD)size + 1 == ++v66)
          {
            uint64_t v10 = v80;
            goto LABEL_129;
          }

          continue;
        }
      }

      return 0LL;
    }

    if (v2 < v33 && *(_BYTE *)(v34 + v2) == 95) {
      *((void *)this + 9) = ++v2;
    }
    unint64_t v38 = size;
    memset(&__p, 0, sizeof(__p));
    if (!swift::Punycode::__runtime::decodePunycodeUTF8( (unsigned __int8 *)(v34 + v2),  size,  &__p))
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80) != 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      return 0LL;
    }

    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size = __p.__r_.__value_.__l.__size_;
    }
    if (size + v8 > v7)
    {
      unint64_t v40 = (char *)*((void *)this + 1);
      if (&v9[v7] != v40)
      {
        uint64_t v41 = *((void *)this + 2);
        goto LABEL_84;
      }

      unint64_t v55 = &v9[v7 + size];
      uint64_t v41 = *((void *)this + 2);
      if ((unint64_t)v55 <= v41)
      {
        *((void *)this + 1) = v55;
        LODWORD(v57) = size;
      }

      else
      {
LABEL_84:
        __srcb = v9;
        uint64_t v56 = 2 * v7;
        if (size > v56) {
          uint64_t v56 = size;
        }
        if (v56 <= 4) {
          uint64_t v57 = 4LL;
        }
        else {
          uint64_t v57 = v56;
        }
        unint64_t v58 = v57 + v7;
        if (!v40 || (unint64_t)&v40[v58] > v41)
        {
          unint64_t v59 = 2LL * *((void *)this + 4);
          if (v59 <= v58 + 1) {
            unint64_t v59 = v58 + 1;
          }
          *((void *)this + 4) = v59;
          uint64_t v60 = v59 + 8;
          uint64_t v87 = p_p;
          uint64_t v61 = malloc(v59 + 8);
          p_p = v87;
          uint64_t v62 = (char *)v61 + v60;
          *uint64_t v61 = *((void *)this + 3);
          unint64_t v40 = (char *)(v61 + 1);
          *((void *)this + 2) = v62;
          *((void *)this + 3) = v61;
        }

        *((void *)this + 1) = &v40[v58];
        if (v7)
        {
          unint64_t v63 = p_p;
          memcpy(v40, __srcb, v7);
          p_p = v63;
        }

        else
        {
          uint64_t v7 = 0;
        }

        uint64_t v9 = v40;
      }

      v7 += v57;
    }

    memcpy(&v9[v8], p_p, size);
LABEL_129:
    v8 += size;
    uint64_t v2 = *((void *)this + 9) + v38;
    *((void *)this + 9) = v2;
    uint64_t v6 = 1;
  }

  while ((v10 & 1) != 0);
  if (!v8) {
    return 0LL;
  }
  char v73 = (*((void *)this + 1) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
  if (!v73 || v73 + 24 > *((void *)this + 2))
  {
    int64_t v74 = 2LL * *((void *)this + 4);
    if (v74 <= 0x20) {
      int64_t v74 = 32LL;
    }
    *((void *)this + 4) = v74;
    char v75 = v74 + 8;
    unint64_t v76 = malloc(v74 + 8);
    BOOL v77 = (char *)v76 + v75;
    char *v76 = *((void *)this + 3);
    char v73 = ((unint64_t)v76 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    *((void *)this + 2) = v77;
    *((void *)this + 3) = v76;
  }

  *((void *)this + 1) = v73 + 24;
  *(_WORD *)(v73 + 16) = 101;
  *(_BYTE *)(v73 + 18) = 3;
  *(void *)char v73 = v9;
  *(void *)(v73 + 8) = v8;
  __p.__r_.__value_.__r.__words[0] = v73;
  swift::Demangle::__runtime::Vector<swift::Demangle::__runtime::Node *>::push_back( (const void **)this + 13,  (uint64_t *)&__p,  this);
  return v73;
}

  if (*((_WORD *)v7 + 8) != 223) {
  uint64_t v9 = *((unsigned __int8 *)v7 + 18);
  }
  if ((v9 - 1) < 2 || v9 == 5 && *((_DWORD *)v7 + 2)) {
  uint64_t v10 = this[3184];
  }
  uint64_t v11 = this[3185];
  uint64_t v12 = (char *)*((void *)this + 1591);
  if (v10 >= v11)
  {
    uint64_t v13 = (void *)*((void *)this + 1593);
    uint64_t v14 = (char *)v13[1];
    if (&v12[v11] == v14)
    {
      id v16 = (unint64_t)&v12[v11 + 1];
      uint64_t v15 = v13[2];
      if (v16 <= v15)
      {
        v13[1] = v16;
        LODWORD(v17) = 1;
LABEL_35:
        v4[3185] = v11 + v17;
        goto LABEL_36;
      }
    }

    else
    {
      uint64_t v15 = v13[2];
    }

    else {
      BOOL v17 = (2 * v11);
    }
    BOOL v18 = v17 + v11;
    if (!v14 || (unint64_t)&v14[v18] > v15)
    {
      unint64_t v19 = 2LL * v13[4];
      if (v19 <= v18 + 1) {
        unint64_t v19 = v18 + 1;
      }
      v13[4] = v19;
      uint64_t v20 = v19 + 8;
      this = (unsigned int *)malloc(v19 + 8);
      uint64_t v21 = (char *)this + v20;
      *(void *)this = v13[3];
      uint64_t v14 = (char *)(this + 2);
      void v13[2] = v21;
      v13[3] = this;
    }

    v13[1] = &v14[v18];
    if ((_DWORD)v11)
    {
      this = (unsigned int *)memcpy(v14, *((const void **)v4 + 1591), v11);
      LODWORD(v11) = v4[3185];
      uint64_t v10 = v4[3184];
    }

    *((void *)v4 + 1591) = v14;
    uint64_t v12 = v14;
    goto LABEL_35;
  }

      id v16 = *((unsigned __int8 *)a2 + 18);
      if (v16 == 2) {
        goto LABEL_18;
      }
      if (v16 == 5 && *((_DWORD *)a2 + 2) >= 2u)
      {
        uint64_t v5 = (uint64_t *)*a2;
LABEL_18:
        BOOL v17 = v5[1];
      }

      else
      {
        BOOL v17 = 0LL;
      }

      if (*(_DWORD *)a4) {
        return result;
      }
      uint64_t v9 = 0;
      uint64_t v8 = 0LL;
      uint64_t v11 = 0;
LABEL_99:
      *(_DWORD *)a4 = v9;
      *(void *)(a4 + 8) = v8;
      *(_DWORD *)(a4 + 16) = v11;
      return result;
  }

void ArraySlice.append(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(v2 + 16);
  uint64_t v6 = *(void *)(v2 + 24) >> 1;
  uint64_t v7 = (__objc2_class **)(v6 - v5);
  if (__OFSUB__(v6, v5))
  {
    __break(1u);
  }

  else
  {
    ArraySlice._reserveCapacityAssumingUniqueBuffer(oldCount:)(v6 - v5);
    ArraySlice._appendElementAssumeUniqueAndCapacity(_:newElement:)(v7, a1, a2);
  }

uint64_t ArraySlice.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a4,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v13 = type metadata accessor for IteratorSequence(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  __int128 v54 = (void (*)(char *, char *, uint64_t))((char *)&v53 - v15);
  uint64_t v59 = *(void *)(a3 - 8);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  BOOL v18 = (char *)&v53 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v55 = *(void *)(AssociatedTypeWitness - 8);
  unint64_t v56 = AssociatedTypeWitness;
  MEMORY[0x1895F8858](v16);
  uint64_t v60 = (char *)&v53 - v19;
  Swift::Int v20 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 40))(a3, a4);
  ArraySlice.reserveCapacityForAppend(newElementsCount:)(v20);
  uint64_t v21 = v4[2];
  uint64_t v22 = v5[3] >> 1;
  uint64_t v23 = v22 - v21;
  if (__OFSUB__(v22, v21))
  {
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v58 = a1;
  uint64_t v53 = v13;
  uint64_t v24 = *(void *)(a2 + 16);
  uint64_t v25 = v5[1];
  uint64_t v26 = *(void *)(*(void *)(v24 - 8) + 72LL);
  uint64_t v57 = v24;
  Swift::Int v27 = ArraySlice._getCapacity()();
  Swift::Int v28 = v27 - v23;
  if (__OFSUB__(v27, v23))
  {
LABEL_14:
    __break(1u);
LABEL_15:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  if (v28 < 0) {
    goto LABEL_15;
  }
  uint64_t v29 = v25 + v26 * v21 + v26 * v23;
  uint64_t v30 = v58;
  uint64_t v31 = v59;
  (*(void (**)(char *, uint64_t, uint64_t))(v59 + 16))(v18, v58, a3);
  uint64_t v32 = v60;
  uint64_t v33 = (*(uint64_t (**)(char *, uint64_t, Swift::Int, uint64_t, uint64_t))(a4 + 64))(v60, v29, v28, a3, a4);
  if (v33 < v20) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "newElements.underestimatedCount was an overestimate",  51LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x3C4uLL,  0);
  }
  uint64_t v34 = v33;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v31 + 8))(v30, a3);
  uint64_t v38 = v57;
  if (v34 < 1) {
    goto LABEL_9;
  }
  uint64_t v39 = v5[2];
  uint64_t v40 = v5[3] >> 1;
  BOOL v41 = __OFSUB__(v40, v39);
  uint64_t v42 = v40 - v39;
  if (v41)
  {
    __break(1u);
    goto LABEL_18;
  }

  uint64_t v43 = (__objc2_class **)(v42 + v34);
  if (__OFADD__(v42, v34))
  {
LABEL_18:
    __break(1u);
    return result;
  }

  type metadata accessor for _SliceBuffer(0LL, v57, v36, v37);
  _SliceBuffer.count.setter(v43);
LABEL_9:
  if (v34 != v28) {
    return (*(uint64_t (**)(char *, unint64_t))(v55 + 8))(v32, v56);
  }
  uint64_t v44 = v54;
  (*(void (**)(char *, char *, unint64_t))(v55 + 32))((char *)v54, v32, v56);
  uint64_t v47 = type metadata accessor for _SliceBuffer(0LL, v38, v45, v46);
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, v47, v48);
  uint64_t v50 = v53;
  uint64_t v52 = swift_getWitnessTable(&protocol conformance descriptor for IteratorSequence<A>, v53, v51);
  return _ArrayBufferProtocol._arrayAppendSequence<A>(_:)(v44, v47, v50, WitnessTable, v52);
}

Swift::Void __swiftcall ArraySlice.reserveCapacityForAppend(newElementsCount:)(Swift::Int newElementsCount)
{
  uint64_t v2 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24) >> 1;
  uint64_t v4 = v3 - v2;
  if (__OFSUB__(v3, v2))
  {
    __break(1u);
    goto LABEL_9;
  }

  Swift::Int v6 = ArraySlice._getCapacity()();
  Swift::Int v7 = v4 + newElementsCount;
  if (__OFADD__(v4, newElementsCount))
  {
LABEL_9:
    __break(1u);
    goto LABEL_10;
  }

  if (v6 >= v7)
  {
LABEL_7:
    ArraySlice.reserveCapacity(_:)(v7);
    return;
  }

  if (v6 + 0x4000000000000000LL >= 0)
  {
    uint64_t v8 = 2 * v6;
    if (v8 > v7) {
      Swift::Int v7 = v8;
    }
    goto LABEL_7;
  }

LABEL_10:
  __break(1u);
}

    v9._Swift::UInt64 rawBits = v29 | v46;
    if (v5 == v29 >> 14) {
      return 0LL;
    }
  }

  if (v51) {
LABEL_118:
  }
    swift_bridgeObjectRelease(v25);
  else {
    swift_bridgeObjectRelease(object);
  }
  return v9._rawBits;
}

    uint64_t v14 = *((void *)a4 - 1);
    uint64_t v13 = 1LL;
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56))(a6, v13, 1LL, a4);
  }

  uint64_t v9 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v10 = (void *)a2;
  }
  else {
    uint64_t v10 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  uint64_t v11 = objc_msgSend(v10, sel_objectForKey_, v9);
  swift_unknownObjectRelease(v9);
  if (!v11) {
    goto LABEL_10;
  }
  _forceBridgeFromObjectiveC<A>(_:_:)(v11, a4, v12, a6);
  swift_unknownObjectRelease(v11);
  uint64_t v13 = 0LL;
  uint64_t v14 = *((void *)a4 - 1);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56))(a6, v13, 1LL, a4);
}

  *uint64_t v5 = (uint64_t)v13;
  return v3;
}

    uint64_t v14 = *((void *)a4 - 1);
    uint64_t v13 = 1LL;
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56))(a6, v13, 1LL, a4);
  }

  uint64_t v9 = _bridgeAnythingToObjectiveC<A>(_:)(a1, a3);
  if (a2 < 0) {
    uint64_t v10 = (void *)a2;
  }
  else {
    uint64_t v10 = (void *)(a2 & 0xFFFFFFFFFFFFFF8LL);
  }
  uint64_t v11 = objc_msgSend(v10, sel_objectForKey_, v9);
  swift_unknownObjectRelease(v9);
  if (!v11) {
    goto LABEL_10;
  }
  _forceBridgeFromObjectiveC<A>(_:_:)(v11, a4, v12, a6);
  swift_unknownObjectRelease(v11);
  uint64_t v13 = 0LL;
  uint64_t v14 = *((void *)a4 - 1);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v14 + 56))(a6, v13, 1LL, a4);
}

    uint64_t v12 = *((void *)v5 - 1);
    uint64_t v11 = 1LL;
    return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v12 + 56))(a4, v11, 1LL, v5);
  }

  Swift::Int v7 = _bridgeAnythingToObjectiveC<A>(_:)(a2, *(uint64_t **)((char *)a2 + a3 - 24));
  if (v6 < 0) {
    uint64_t v8 = (void *)v6;
  }
  else {
    uint64_t v8 = (void *)(v6 & 0xFFFFFFFFFFFFFF8LL);
  }
  uint64_t v9 = objc_msgSend(v8, sel_objectForKey_, v7);
  swift_unknownObjectRelease(v7);
  if (!v9) {
    goto LABEL_10;
  }
  _forceBridgeFromObjectiveC<A>(_:_:)(v9, v5, v10, a4);
  swift_unknownObjectRelease(v9);
  uint64_t v11 = 0LL;
  uint64_t v12 = *((void *)v5 - 1);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, char *))(v12 + 56))(a4, v11, 1LL, v5);
}

  uint64_t v23 = *v117;
  uint64_t v24 = *(void *)(*v117 + 16);
  uint64_t v25 = v22 ^ 1u;
  uint64_t v26 = v24 + v25;
  if (__OFADD__(v24, v25)) {
    goto LABEL_108;
  }
  Swift::Int v27 = *(void *)(v23 + 24);
  if (v27 >= v26 && (a2 & 1) != 0)
  {
    Swift::Int v28 = (void *)*v117;
    if ((v22 & 1) != 0) {
      goto LABEL_100;
    }
    goto LABEL_14;
  }

  Swift::UInt64 v115 = v22;
  if ((a2 & 1) != 0)
  {
    if (v27 > v26) {
      uint64_t v26 = *(void *)(v23 + 24);
    }
    uint64_t v31 = specialized static _HashTable.scale(forCapacity:)(v26);
    LOBYTE(v123) = 1;
    size_t v35 = specialized static _SetStorage.allocate(scale:age:seed:)(v31, 0x100000000LL, 0LL, 1);
    if (*(void *)(v23 + 16))
    {
      uint64_t v36 = 1LL << *(_BYTE *)(v23 + 32);
      uint64_t v37 = (void *)(v23 + 56);
      uint64_t v38 = -1LL;
      if (v36 < 64) {
        uint64_t v38 = ~(-1LL << v36);
      }
      uint64_t v39 = v38 & *(void *)(v23 + 56);
      uint64_t v40 = (unint64_t)(v36 + 63) >> 6;
      swift_retain((unint64_t *)v23, v32, v33, v34);
      BOOL v41 = 0LL;
      while (1)
      {
        if (v39)
        {
          uint64_t v42 = __clz(__rbit64(v39));
          v39 &= v39 - 1;
          uint64_t v43 = v42 | (v41 << 6);
        }

        else
        {
          uint64_t v45 = v41 + 1;
          if (__OFADD__(v41, 1LL))
          {
            __break(1u);
LABEL_106:
            __break(1u);
LABEL_107:
            __break(1u);
LABEL_108:
            __break(1u);
            goto LABEL_109;
          }

          if (v45 >= v40) {
            goto LABEL_64;
          }
          uint64_t v46 = v37[v45];
          ++v41;
          if (!v46)
          {
            BOOL v41 = v45 + 1;
            if (v45 + 1 >= v40) {
              goto LABEL_64;
            }
            uint64_t v46 = v37[v41];
            if (!v46)
            {
              BOOL v41 = v45 + 2;
              if (v45 + 2 >= v40) {
                goto LABEL_64;
              }
              uint64_t v46 = v37[v41];
              if (!v46)
              {
                uint64_t v47 = v45 + 3;
                if (v47 >= v40)
                {
LABEL_64:
                  swift_release(v23);
                  uint64_t v69 = 1LL << *(_BYTE *)(v23 + 32);
                  if (v69 > 63) {
                    specialized UnsafeMutablePointer.assign(repeating:count:)( 0LL,  (unint64_t)(v69 + 63) >> 6,  (int64x2_t *)(v23 + 56));
                  }
                  else {
                    *uint64_t v37 = -1LL << v69;
                  }
                  *(void *)(v23 + 16) = 0LL;
                  break;
                }

                uint64_t v46 = v37[v47];
                if (!v46)
                {
                  while (1)
                  {
                    BOOL v41 = v47 + 1;
                    if (__OFADD__(v47, 1LL)) {
                      break;
                    }
                    if (v41 >= v40) {
                      goto LABEL_64;
                    }
                    uint64_t v46 = v37[v41];
                    ++v47;
                    if (v46) {
                      goto LABEL_38;
                    }
                  }

  *a1 = a4;
  a1[1] = v6;
  return v6;
}

  if (v19 < v17) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  if (v17 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x744uLL,  0);
  }
  if (v19 > a2) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
  }
  Swift::Int v20 = specialized UnsafeBufferPointer.init(rebasing:)(v17, v19, a1, a2);
  return a7(v20);
}

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  return 1LL;
}

    uint64_t v4 = Unicode.UTF8.ReverseParser._invalidLength()();
    uint64_t v3 = 0;
    uint64_t v2 = 8 * v4;
    return v3 | (v2 << 8);
  }

  if ((v1 & 0x1E00) == 0) {
    goto LABEL_10;
  }
  uint64_t v2 = 16;
  uint64_t v3 = 1;
  return v3 | (v2 << 8);
}

  Swift::String::Index v84 = v132;
  (*(void (**)(char *, char *, unint64_t *))(v62 + 32))(v132, v55, v18);
  uint64_t v85 = v111;
  uint64_t v86 = v117;
  ((void (*)(char *, unint64_t *, void *, uint64_t, void *))v111[9])(v84, v18, v60, a3, v111);
  uint64_t v87 = v112;
  ((void (*)(uint64_t, void *))v85[18])(a3, v85);
  char v88 = AssociatedTypeWitness;
  unint64_t v89 = v120;
  unint64_t v90 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v91 = v118;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v90 + 8))( &unk_18180BE80,  768LL,  v88,  v90);
  unint64_t v92 = v114;
  (*((void (**)(char *, uint64_t, const char *))v89 + 3))(v91, a3, v89);
  unint64_t v93 = v115;
  ((void (*)(char *, char *, uint64_t, void *))v85[24])(v87, v92, a3, v85);
  char v94 = v92;
  uint64_t v95 = v123;
  v123(v94, a3);
  v95(v87, a3);
  unint64_t v96 = v121;
  unint64_t v97 = *(void (**)(char *, char *, uint64_t, uint64_t))(v121 + 64);
  unint64_t v98 = v116;
  v97(v86, v93, a3, v121);
  v95(v93, a3);
  v95(v86, a3);
  uint64_t v99 = v129;
  v97(v129, v98, a3, v96);
  v95(v98, a3);
  v95(v99, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v113 + 24))(v86, v122, a3);
  return ((uint64_t (*)(char *, uint64_t))v95)(v86, a3);
}

  if (v18 < a1) {
    return 0LL;
  }
  uint64_t v23 = (void *)*v2;
  uint64_t v24 = type metadata accessor for __ContiguousArrayStorageBase();
  Swift::Int v28 = swift_unknownObjectRetain(v23, v25, v26, v27);
  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v28, v24);
  if (!result)
  {
    swift_unknownObjectRelease(v23);
    uint64_t result = &_swiftEmptyArrayStorage;
  }

  uint64_t v47 = result;
  uint64_t v31 = *(void *)(a2 + 16);
  uint64_t v32 = *(void *)(v31 - 8);
  uint64_t v33 = *(void *)(v32 + 72);
  if (!v33) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3829uLL,  0);
  uint64_t v34 = v8
      + v33 * v6
      - ((void)result
       + ((*(unsigned __int8 *)(v32 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v32 + 80)));
  if (v33 == -1 && v34 == 0x8000000000000000LL) {
LABEL_27:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division results in an overflow",  31LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x3830uLL,  0);
  uint64_t v36 = v34 / v33;
  uint64_t v37 = v7 + v36;
  if (__OFADD__(v7, v36))
  {
    __break(1u);
    goto LABEL_25;
  }

  uint64_t v24 = (uint64_t)result[2];
  if (v37 < v24)
  {
LABEL_25:
    uint64_t v38 = type metadata accessor for _ContiguousArrayBuffer(0LL, v31, v29, v30);
    BOOL v41 = type metadata accessor for EmptyCollection(0LL, v31, v39, v40);
    uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, v38, v42);
    uint64_t v45 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v41, v44);
    _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(v37, v24, 0LL, v46, v38, v41, WitnessTable, v45);
    return v47;
  }

  return result;
}

  uint64_t v51 = v78;
  uint64_t v52 = v38;
  uint64_t v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  __int128 v54 = *(void (**)(char *, char *, uint64_t))(v85 + 16);
  v54(v93, v51, v40);
  v54(v92, v80, v40);
  v77(v40, v24);
  uint64_t v55 = v88(v40, v24);
  if (v55 < 0) {
    goto LABEL_16;
  }
  unint64_t v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  char v88 = v13;
  uint64_t v57 = v40;
  uint64_t v58 = v75;
  uint64_t v59 = v74;
  uint64_t v60 = v86;
  if (v56)
  {
    uint64_t v61 = 0LL;
    uint64_t v87 = *(const char **)(v24 + 56);
    do
    {
      uint64_t v62 = v56;
      unint64_t v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      uint64_t v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 192))(v59, v58, v60);
      unint64_t v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      unint64_t v56 = v62;
      ++v61;
    }

    while (v62 != v61);
  }

  unint64_t v66 = v85;
  id v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  Swift::Int v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  uint64_t v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

  uint64_t v51 = v78;
  uint64_t v52 = v38;
  uint64_t v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  __int128 v54 = *(void (**)(char *, char *, uint64_t))(v85 + 16);
  v54(v93, v51, v40);
  v54(v92, v80, v40);
  v77(v40, v24);
  uint64_t v55 = v88(v40, v24);
  if (v55 < 0) {
    goto LABEL_16;
  }
  unint64_t v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  char v88 = v13;
  uint64_t v57 = v40;
  uint64_t v58 = v75;
  uint64_t v59 = v74;
  uint64_t v60 = v86;
  if (v56)
  {
    uint64_t v61 = 0LL;
    uint64_t v87 = *(const char **)(v24 + 56);
    do
    {
      uint64_t v62 = v56;
      unint64_t v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      uint64_t v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 224))(v59, v58, v60);
      unint64_t v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      unint64_t v56 = v62;
      ++v61;
    }

    while (v62 != v61);
  }

  unint64_t v66 = v85;
  id v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  Swift::Int v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  uint64_t v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

  uint64_t v51 = v78;
  uint64_t v52 = v38;
  uint64_t v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  __int128 v54 = *(void (**)(char *, char *, uint64_t))(v85 + 16);
  v54(v93, v51, v40);
  v54(v92, v80, v40);
  v77(v40, v24);
  uint64_t v55 = v88(v40, v24);
  if (v55 < 0) {
    goto LABEL_16;
  }
  unint64_t v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  char v88 = v13;
  uint64_t v57 = v40;
  uint64_t v58 = v75;
  uint64_t v59 = v74;
  uint64_t v60 = v86;
  if (v56)
  {
    uint64_t v61 = 0LL;
    uint64_t v87 = *(const char **)(v24 + 56);
    do
    {
      uint64_t v62 = v56;
      unint64_t v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      uint64_t v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 208))(v59, v58, v60);
      unint64_t v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      unint64_t v56 = v62;
      ++v61;
    }

    while (v62 != v61);
  }

  unint64_t v66 = v85;
  id v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  Swift::Int v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  uint64_t v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

  uint64_t v51 = v78;
  uint64_t v52 = v38;
  uint64_t v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  __int128 v54 = *(void (**)(char *, uint64_t, uint64_t))(v85 + 16);
  v54(v93, v80, v40);
  v54(v92, (uint64_t)v51, v40);
  v77(v40, v24);
  uint64_t v55 = v88(v40, v24);
  if (v55 < 0) {
    goto LABEL_16;
  }
  unint64_t v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  char v88 = v13;
  uint64_t v57 = v40;
  uint64_t v58 = v75;
  uint64_t v59 = v74;
  uint64_t v60 = v86;
  if (v56)
  {
    uint64_t v61 = 0LL;
    uint64_t v87 = *(const char **)(v24 + 56);
    do
    {
      uint64_t v62 = v56;
      unint64_t v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      uint64_t v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 192))(v59, v58, v60);
      unint64_t v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      unint64_t v56 = v62;
      ++v61;
    }

    while (v62 != v61);
  }

  unint64_t v66 = v85;
  id v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  Swift::Int v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  uint64_t v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

  uint64_t v51 = v78;
  uint64_t v52 = v38;
  uint64_t v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  __int128 v54 = *(void (**)(char *, uint64_t, uint64_t))(v85 + 16);
  v54(v93, v80, v40);
  v54(v92, (uint64_t)v51, v40);
  v77(v40, v24);
  uint64_t v55 = v88(v40, v24);
  if (v55 < 0) {
    goto LABEL_16;
  }
  unint64_t v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  char v88 = v13;
  uint64_t v57 = v40;
  uint64_t v58 = v75;
  uint64_t v59 = v74;
  uint64_t v60 = v86;
  if (v56)
  {
    uint64_t v61 = 0LL;
    uint64_t v87 = *(const char **)(v24 + 56);
    do
    {
      uint64_t v62 = v56;
      unint64_t v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      uint64_t v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 224))(v59, v58, v60);
      unint64_t v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      unint64_t v56 = v62;
      ++v61;
    }

    while (v62 != v61);
  }

  unint64_t v66 = v85;
  id v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  Swift::Int v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  uint64_t v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

  uint64_t v51 = v78;
  uint64_t v52 = v38;
  uint64_t v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  __int128 v54 = *(void (**)(char *, uint64_t, uint64_t))(v85 + 16);
  v54(v93, v80, v40);
  v54(v92, (uint64_t)v51, v40);
  v77(v40, v24);
  uint64_t v55 = v88(v40, v24);
  if (v55 < 0) {
    goto LABEL_16;
  }
  unint64_t v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  char v88 = v13;
  uint64_t v57 = v40;
  uint64_t v58 = v75;
  uint64_t v59 = v74;
  uint64_t v60 = v86;
  if (v56)
  {
    uint64_t v61 = 0LL;
    uint64_t v87 = *(const char **)(v24 + 56);
    do
    {
      uint64_t v62 = v56;
      unint64_t v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      uint64_t v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 208))(v59, v58, v60);
      unint64_t v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      unint64_t v56 = v62;
      ++v61;
    }

    while (v62 != v61);
  }

  unint64_t v66 = v85;
  id v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  Swift::Int v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  uint64_t v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

  uint64_t v58 = v86;
  uint64_t v57 = v87;
  ((void (*)(char *, char *, uint64_t))v83)(v86, v37, v87);
  uint64_t v59 = *(void (**)(char *, char *, uint64_t))(v92 + 16);
  uint64_t v60 = v85;
  v59(v98, v85, a3);
  v59(v99, v58, a3);
  v84(a3, v12);
  uint64_t v61 = v44(a3, v12);
  if (v61 < 0) {
    goto LABEL_16;
  }
  uint64_t v62 = v61;
  unint64_t v63 = *(void (**)(char *, uint64_t))(v79 + 8);
  v63(v58, v57);
  v63(v60, v57);
  uint64_t v64 = v80;
  unint64_t v65 = v78;
  unint64_t v66 = (uint64_t)v93;
  if (v62)
  {
    id v67 = 0LL;
    char v94 = *(const char **)(v12 + 56);
    do
    {
      Swift::Int v68 = v94;
      ((void (*)(uint64_t, uint64_t, uint64_t))v94)(v67, a3, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v67, a3, v12);
      uint64_t v69 = v97;
      (*(void (**)(char *, char *, uint64_t))(v95 + 192))(v65, v64, v66);
      uint64_t v70 = *(void (**)(char *, uint64_t))(v96 + 8);
      v70(v64, v66);
      v70(v65, v66);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v69, v67++, a3, v12);
    }

    while (v62 != v67);
  }

  unint64_t v71 = v92;
  int64_t v72 = *(void (**)(char *, uint64_t))(v92 + 8);
  v72(v99, a3);
  v72(v98, a3);
  char v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  int64_t v74 = v81;
  v73(v81, v100, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, a3);
}

  uint64_t v58 = v86;
  uint64_t v57 = v87;
  ((void (*)(char *, char *, uint64_t))v83)(v86, v37, v87);
  uint64_t v59 = *(void (**)(char *, char *, uint64_t))(v92 + 16);
  uint64_t v60 = v85;
  v59(v98, v85, a3);
  v59(v99, v58, a3);
  v84(a3, v12);
  uint64_t v61 = v44(a3, v12);
  if (v61 < 0) {
    goto LABEL_16;
  }
  uint64_t v62 = v61;
  unint64_t v63 = *(void (**)(char *, uint64_t))(v79 + 8);
  v63(v58, v57);
  v63(v60, v57);
  uint64_t v64 = v80;
  unint64_t v65 = v78;
  unint64_t v66 = (uint64_t)v93;
  if (v62)
  {
    id v67 = 0LL;
    char v94 = *(const char **)(v12 + 56);
    do
    {
      Swift::Int v68 = v94;
      ((void (*)(uint64_t, uint64_t, uint64_t))v94)(v67, a3, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v67, a3, v12);
      uint64_t v69 = v97;
      (*(void (**)(char *, char *, uint64_t))(v95 + 224))(v65, v64, v66);
      uint64_t v70 = *(void (**)(char *, uint64_t))(v96 + 8);
      v70(v64, v66);
      v70(v65, v66);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v69, v67++, a3, v12);
    }

    while (v62 != v67);
  }

  unint64_t v71 = v92;
  int64_t v72 = *(void (**)(char *, uint64_t))(v92 + 8);
  v72(v99, a3);
  v72(v98, a3);
  char v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  int64_t v74 = v81;
  v73(v81, v100, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, a3);
}

  uint64_t v58 = v86;
  uint64_t v57 = v87;
  ((void (*)(char *, char *, uint64_t))v83)(v86, v37, v87);
  uint64_t v59 = *(void (**)(char *, char *, uint64_t))(v92 + 16);
  uint64_t v60 = v85;
  v59(v98, v85, a3);
  v59(v99, v58, a3);
  v84(a3, v12);
  uint64_t v61 = v44(a3, v12);
  if (v61 < 0) {
    goto LABEL_16;
  }
  uint64_t v62 = v61;
  unint64_t v63 = *(void (**)(char *, uint64_t))(v79 + 8);
  v63(v58, v57);
  v63(v60, v57);
  uint64_t v64 = v80;
  unint64_t v65 = v78;
  unint64_t v66 = (uint64_t)v93;
  if (v62)
  {
    id v67 = 0LL;
    char v94 = *(const char **)(v12 + 56);
    do
    {
      Swift::Int v68 = v94;
      ((void (*)(uint64_t, uint64_t, uint64_t))v94)(v67, a3, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v67, a3, v12);
      uint64_t v69 = v97;
      (*(void (**)(char *, char *, uint64_t))(v95 + 208))(v65, v64, v66);
      uint64_t v70 = *(void (**)(char *, uint64_t))(v96 + 8);
      v70(v64, v66);
      v70(v65, v66);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v69, v67++, a3, v12);
    }

    while (v62 != v67);
  }

  unint64_t v71 = v92;
  int64_t v72 = *(void (**)(char *, uint64_t))(v92 + 8);
  v72(v99, a3);
  v72(v98, a3);
  char v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  int64_t v74 = v81;
  v73(v81, v100, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, a3);
}

        uint64_t v11 = v4 == 0;
        uint64_t v4 = -(uint64_t)v4;
        uint64_t v5 = -(v5 + !v11);
LABEL_38:
        uint64_t v10 = v6 + v4;
        uint64_t v21 = __CFADD__(v6, v4);
        uint64_t v11 = __CFADD__(v7, v5);
        uint64_t v9 = v7 + v5;
        if (v11) {
          goto LABEL_54;
        }
        if (!v21)
        {
LABEL_45:
          uint64_t v22 = 0LL;
LABEL_46:
          uint64_t v23 = v22 + v9;
          specialized static FixedWidthInteger._truncatingInit<A>(_:)();
          uint64_t v26 = v25 < v10;
          if (v24 != v23) {
            uint64_t v26 = v24 < v23;
          }
          if (!v26)
          {
            if ((v8 & 1) != 0) {
              goto LABEL_51;
            }
            Swift::Int v27 = __OFSUB__(0LL, v10);
            uint64_t v10 = -(uint64_t)v10;
            if (!v27) {
              goto LABEL_51;
            }
            __break(1u);
          }

    uint64_t v21 = 0LL;
  }

  else
  {
    uint64_t v21 = 0LL;
    if ((_DWORD)v18)
    {
      uint64_t v22 = 1 << (v18 - 1);
LABEL_4:
      uint64_t v23 = a5 + v10;
      switch((char)v22)
      {
        case 1:
          uint64_t v24 = *(unsigned __int8 *)(v23 + v19);
          goto LABEL_9;
        case 2:
          uint64_t v24 = *(unsigned __int16 *)(v23 + v19);
          goto LABEL_9;
        case 4:
          uint64_t v24 = *(unsigned int *)(v23 + v19);
          goto LABEL_9;
        case 8:
          uint64_t v24 = *(void *)(v23 + v19);
LABEL_9:
          uint64_t v25 = v24 - v14;
          if (v21) {
            goto LABEL_10;
          }
          goto LABEL_22;
        default:
          goto LABEL_49;
      }
    }

    uint64_t v25 = 0LL;
  }

        v6 += 2;
        if (!--v5) {
          return;
        }
      }

      if (a1) {
        ++*a1;
      }
      if (*v8 == 36) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8;
      }
      uint64_t v10 = strlen(v9);
      uint64_t v23 = 0LL;
      uint64_t v21 = 0LL;
      swift_getTypeByMangledName(0LL, (unsigned __int8 *)v9, v10, 0LL, v22, v20, (uint64_t)v24);
      uint64_t v13 = v21;
      if (v21 == v20)
      {
        uint64_t v13 = v20;
        uint64_t v14 = 4LL;
      }

      else
      {
        if (!v21) {
          goto LABEL_23;
        }
        uint64_t v14 = 5LL;
      }

      (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_23:
      uint64_t v15 = v23;
      if (v23 == v22)
      {
        uint64_t v15 = v22;
        uint64_t v16 = 4LL;
      }

      else
      {
        if (!v23)
        {
LABEL_28:
          uint64_t v17 = v25;
          if (v25 == 1)
          {
            fprintf(*v7, "Prespecializations library validation: unable to build metadata for mangled name '%s'\n", v9);
            if (a2) {
              ++*a2;
            }
            uint64_t v17 = v25;
          }

          if (v17) {
            BOOL v18 = 0LL;
          }
          else {
            BOOL v18 = v24[0];
          }
          uint64_t v19 = swift::compareGenericMetadata(v18, *v6, v11, v12);
          if (a2 && (v19 & 1) == 0) {
            ++*a2;
          }
          if (v25 == 1) {
            ((void (*)(void, uint64_t, void))v24[1])(v24[0], 3LL, 0LL);
          }
          goto LABEL_10;
        }

        uint64_t v16 = 5LL;
      }

      (*(void (**)(void))(*v15 + 8 * v16))();
      goto LABEL_28;
    }
  }

    uint64_t v4 = a1[1];
    if (!v4) {
      return 0LL;
    }
    return (*(unsigned __int8 *)(v4 + 2) >> 4) & 1;
  }

  if ((_DWORD)v3 == 515 || (_DWORD)v3 == 516) {
    goto LABEL_10;
  }
  return result;
}

    JUMPOUT(0x18176ADCCLL);
  }

  return v1 + 8 * v6;
}

    JUMPOUT(0x18176B048LL);
  }

  return v1 + 8 * v6;
}

  {
    if (*(_DWORD *)a4) {
      goto LABEL_14;
    }
    swift::Demangle::__runtime::RemanglerBase::addSubstitution( (char *)this,  (const swift::Demangle::__runtime::SubstitutionEntry *)v14);
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_14:
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
}

uint64_t ArraySlice._customRemoveLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v8 = (char *)&v20 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = v2[2];
  unint64_t v10 = v2[3];
  uint64_t v11 = (char *)(v10 >> 1);
  if (__OFSUB__(v10 >> 1, v9))
  {
    __break(1u);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't removeLast from an empty ArraySlice",  41LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x3E6uLL,  0);
  }

  uint64_t v12 = v2[1];
  specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)((uint64_t)(v11 - 1), *v2, v12, v9, v10);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, v12 + *(void *)(v6 + 72) * (void)(v11 - 1), v5);
  uint64_t v15 = type metadata accessor for EmptyCollection(0LL, v5, v13, v14);
  unint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v15, v16);
  ArraySlice.replaceSubrange<A>(_:with:)((uint64_t)(v11 - 1), v11, v18, a1, v15, WitnessTable);
  (*(void (**)(uint64_t, char *, uint64_t))(v6 + 32))(a2, v8, v5);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v6 + 56))(a2, 0LL, 1LL, v5);
}

uint64_t static FixedWidthInteger.&- infix(_:_:)@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 88))(a2);
}

uint64_t ArraySlice.remove(at:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = v3[1];
  uint64_t v8 = *(void *)(a2 + 16);
  specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)(a1, *v3, v7, v3[2], v3[3]);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v8 - 8) + 16LL))( a3,  v7 + *(void *)(*(void *)(v8 - 8) + 72LL) * a1,  v8);
  if (__OFADD__(a1, 1LL))
  {
    __break(1u);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  if (a1 + 1 < a1) {
    goto LABEL_5;
  }
  uint64_t v11 = type metadata accessor for EmptyCollection(0LL, v8, v9, v10);
  unint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v11, v12);
  return ArraySlice.replaceSubrange<A>(_:with:)(a1, (char *)(a1 + 1), v14, a2, v11, WitnessTable);
}

uint64_t ArraySlice.insert(_:at:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t v8 = type metadata accessor for CollectionOfOne(0LL, v7, a3, a4);
  MEMORY[0x1895F8858](v8);
  uint64_t v10 = (uint64_t *)((char *)&v14 - v9);
  ArraySlice._checkIndex(_:)((Swift::Int)a2);
  (*(void (**)(void *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 32LL))(v10, a1, v7);
  unint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v8, v11);
  return ArraySlice.replaceSubrange<A>(_:with:)((uint64_t)a2, a2, v10, a3, v8, WitnessTable);
}

Swift::Void __swiftcall ArraySlice.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  if (keepingCapacity)
  {
    if ((v2[3] & 1) != 0 && swift_isUniquelyReferenced_nonNull(*v2))
    {
      uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v4, v5);
      RandomAccessCollection<>.indices.getter(v4, WitnessTable, (uint64_t)&protocol witness table for Int, (char *)v26);
      uint64_t v7 = v26[0];
      uint64_t v8 = (char *)v26[1];
      uint64_t v11 = type metadata accessor for EmptyCollection(0LL, *(void *)(v4 + 16), v9, v10);
      unint64_t v13 = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v11, v12);
      ArraySlice.replaceSubrange<A>(_:with:)(v7, v8, v14, v4, v11, v13);
    }

    else
    {
      uint64_t v17 = v2[2];
      BOOL v18 = *(uint64_t **)(v4 + 16);
      Swift::Int v19 = ArraySlice._getCapacity()();
      uint64_t v20 = _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(0LL, v19, v18);
      uint64_t v21 = _SliceBuffer.init(_buffer:shiftedToStartIndex:)((uint64_t)v20, v17);
      uint64_t v22 = (void *)*v3;
      *uint64_t v3 = v21;
      v3[1] = v23;
      v3[2] = v24;
      v3[3] = v25;
      swift_unknownObjectRelease(v22);
    }
  }

  else
  {
    uint64_t v15 = *(unsigned __int8 *)(*(void *)(*(void *)(v1 + 16) - 8LL) + 80LL);
    uint64_t v16 = (void *)*v2;
    *uint64_t v2 = (unint64_t)&_swiftEmptyArrayStorage;
    v2[1] = (unint64_t)&_swiftEmptyArrayStorage + ((v15 + 32) & ~v15);
    *((_OWORD *)v2 + 1) = xmmword_1817FFC90;
    swift_unknownObjectRelease(v16);
  }

void *ArraySlice.withUnsafeMutableBufferPointer<A>(_:)( void (*a1)(void *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4[2];
  uint64_t v6 = v4[3] >> 1;
  uint64_t v7 = v6 - v5;
  if (__OFSUB__(v6, v5))
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  uint64_t v10 = *(void *)(a3 + 16);
  ArraySlice._makeMutableAndUnique()();
  if (v7 < 0) {
    goto LABEL_5;
  }
  v13[3] = a4;
  v13[0] = v4[1] + *(void *)(*(void *)(v10 - 8) + 72LL) * v4[2];
  uint64_t v11 = v13[0];
  v13[1] = v7;
  a1(v13);
  return $defer #1 <A><A1>() in ArraySlice.withUnsafeMutableBufferPointer<A>(_:)(v13, v11, v7);
}

uint64_t ArraySlice.withUnsafeBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  if (__OFSUB__(a6 >> 1, a5))
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  if ((((a6 >> 1) - a5) & 0x8000000000000000LL) != 0) {
    goto LABEL_5;
  }
  return a1(a4 + *(void *)(*(void *)(a7 - 8) + 72LL) * a5);
}

__objc2_class **_SliceBuffer.requestNativeBuffer()(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a4 & 1) == 0) {
    return 0LL;
  }
  uint64_t v8 = type metadata accessor for __ContiguousArrayStorageBase();
  uint64_t v11 = swift_unknownObjectRetain_n((uint64_t)a1, 2LL, v9, v10);
  uint64_t v12 = (__objc2_class **)swift_dynamicCastClass(v11, v8);
  if (!v12)
  {
    swift_unknownObjectRelease(a1);
    uint64_t v12 = &_swiftEmptyArrayStorage;
  }

  unint64_t v13 = v12[2];
  swift_release((uint64_t)v12);
  if (__OFSUB__(a4 >> 1, a3))
  {
    __break(1u);
    goto LABEL_11;
  }

  if (v13 != (__objc2_class *)((a4 >> 1) - a3))
  {
LABEL_11:
    swift_unknownObjectRelease(a1);
    return 0LL;
  }

  uint64_t result = (__objc2_class **)swift_dynamicCastClass((uint64_t)a1, v8);
  if (!result)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptyArrayStorage;
  }

  return result;
}

double protocol witness for RangeReplaceableCollection.init() in conformance ArraySlice<A>@<D0>( uint64_t a1@<X8>)
{
  *(void *)a1 = &_swiftEmptyArrayStorage;
  *(void *)(a1 + 8) = v2;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_1817FFC90;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance ArraySlice<A>( uint64_t a1, void *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return ArraySlice.replaceSubrange<A>(_:with:)(*(void *)a1, *(char **)(a1 + 8), a2, a5, a3, a4);
}

__objc2_class **protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance ArraySlice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, __objc2_class ***a4@<X8>)
{
  double result = ArraySlice.init(repeating:count:)(a1, a2, *(uint64_t **)(a3 + 16));
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance ArraySlice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t result = ArraySlice.init<A>(_:)(a1, *(void *)(a4 + 16), a2, a3);
  *a5 = result;
  a5[1] = v7;
  a5[2] = 0LL;
  a5[3] = v8;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append<A>(contentsOf:) in conformance ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return ArraySlice.append<A>(contentsOf:)(a1, a4, a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance ArraySlice<A>( uint64_t a1, char **a2, uint64_t a3, uint64_t a4)
{
  return ArraySlice.insert(_:at:)(a1, *a2, a3, a4);
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance ArraySlice<A>@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return ArraySlice.remove(at:)(*a1, a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection._customRemoveLast(_:) in conformance ArraySlice<A>( char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a2, a3);
  RangeReplaceableCollection<>._customRemoveLast(_:)(a1, a2, WitnessTable);
  return 1LL;
}

uint64_t specialized RangeReplaceableCollection<>._customRemoveLast(_:)(uint64_t a1)
{
  if (__OFSUB__(0LL, a1))
  {
    __break(1u);
    goto LABEL_6;
  }

  Swift::UInt64 rawBits = v1->_rawBits;
  unint64_t v2 = v1[1]._rawBits;
  unint64_t v4 = v1[2]._rawBits;
  unint64_t v5 = v1[3]._rawBits;
  Swift::String::Index_optional v16 = String.UnicodeScalarView.index(_:offsetBy:limitedBy:)( (Swift::String::Index)v2,  -a1,  (Swift::String::Index)v1->_rawBits);
  if (v16.is_nil) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x33AuLL,  0);
  }
  Swift::UInt64 v9 = v16.value._rawBits;
  if (v16.value._rawBits >> 14 < rawBits >> 14) {
LABEL_6:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  swift_bridgeObjectRetain(v5, *(uint64_t *)&v16.is_nil, v7, v8);
  v10._Swift::UInt64 rawBits = rawBits;
  v11._Swift::UInt64 rawBits = v9;
  Swift::UInt64 v12 = _StringGuts.validateScalarRange(_:in:)(v10, v11, rawBits, v2, v4, v5);
  Swift::UInt64 v14 = v13;
  swift_bridgeObjectRelease(v5);
  v1->_Swift::UInt64 rawBits = v12;
  v1[1]._Swift::UInt64 rawBits = v14;
  v1[2]._Swift::UInt64 rawBits = v4;
  v1[3]._Swift::UInt64 rawBits = v5;
  return 1LL;
}

{
  Swift::String::Index *v1;
  unint64_t v2;
  Swift::UInt64 rawBits;
  uint64_t v4;
  unint64_t v5;
  Swift::UInt64 v6;
  Swift::String::Index v7;
  Swift::String::Index v8;
  Swift::UInt64 v9;
  uint64_t v10;
  Swift::UInt64 v11;
  uint64_t v12;
  Swift::UInt64 v13;
  char *v14;
  char *v15;
  Swift::String::Index_optional v17;
  if (__OFSUB__(0LL, a1))
  {
    __break(1u);
    goto LABEL_6;
  }

  Swift::UInt64 rawBits = v1->_rawBits;
  unint64_t v2 = v1[1]._rawBits;
  unint64_t v5 = v1[2]._rawBits;
  unint64_t v4 = v1[3]._rawBits;
  uint64_t v17 = Substring.index(_:offsetBy:limitedBy:)((Swift::String::Index)v2, -a1, (Swift::String::Index)v1->_rawBits);
  if (v17.is_nil) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x33AuLL,  0);
  }
  uint64_t v6 = v17.value._rawBits;
  if (v17.value._rawBits >> 14 < rawBits >> 14) {
LABEL_6:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  v7._Swift::UInt64 rawBits = rawBits;
  v8._Swift::UInt64 rawBits = v6;
  Swift::UInt64 v9 = specialized Substring.subscript.getter(v7, v8, rawBits, v2, v5, v4);
  Swift::String::Index v11 = v10;
  Swift::UInt64 v13 = v12;
  uint64_t v15 = v14;
  swift_bridgeObjectRetain((unint64_t)v14, v10, v12, v14);
  swift_bridgeObjectRelease(v4);
  v1->_Swift::UInt64 rawBits = v9;
  v1[1]._Swift::UInt64 rawBits = v11;
  v1[2]._Swift::UInt64 rawBits = v13;
  v1[3]._Swift::UInt64 rawBits = (Swift::UInt64)v15;
  return 1LL;
}

uint64_t RangeReplaceableCollection<>._customRemoveLast(_:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v80 = a3;
  uint64_t v81 = (uint64_t)a1;
  uint64_t v5 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  int64_t v74 = (char *)&v67 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v69 = (char *)&v67 - v9;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v11 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v10);
  uint64_t v72 = *(void *)(v11 - 8);
  uint64_t v73 = v11;
  uint64_t v12 = MEMORY[0x1895F8858](v11);
  Swift::UInt64 v14 = (char *)&v67 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v12);
  uint64_t v70 = (char *)&v67 - v16;
  uint64_t v75 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v15);
  Swift::String::Index v82 = (char *)&v67 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v18, v19);
  uint64_t v67 = *(void *)(v20 - 8);
  uint64_t v68 = v20;
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  unint64_t v23 = (char *)&v67 - v22;
  uint64_t v24 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v21);
  uint64_t v78 = (char *)&v67 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v76 = (char *)&v67 - v28;
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  BOOL v77 = (char *)&v67 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v33 = (char *)&v67 - v32;
  uint64_t v34 = MEMORY[0x1895F8858](v31);
  uint64_t v36 = (char *)&v67 - v35;
  MEMORY[0x1895F8858](v34);
  uint64_t v38 = (char *)&v67 - v37;
  uint64_t v39 = *(void (**)(uint64_t, uint64_t))(v5 + 72);
  uint64_t v83 = a2;
  uint64_t v84 = v3;
  uint64_t v85 = v5;
  v39(a2, v5);
  uint64_t v40 = -v81;
  if (__OFSUB__(0LL, v81))
  {
    __break(1u);
    goto LABEL_6;
  }

  uint64_t v81 = (uint64_t)v14;
  BOOL v41 = *(void (**)(uint64_t))(v85 + 64);
  uint64_t v42 = v83;
  v41(v83);
  (*(void (**)(char *, uint64_t, char *, uint64_t))(v80 + 56))(v36, v40, v33, v42);
  uint64_t v43 = *(void (**)(char *, unint64_t))(v24 + 8);
  v43(v33, AssociatedTypeWitness);
  v43(v36, AssociatedTypeWitness);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v24 + 48))(v23, 1LL, AssociatedTypeWitness) == 1)
  {
    (*(void (**)(char *, uint64_t))(v67 + 8))(v23, v68);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x33AuLL,  0);
  }

  uint64_t v44 = *(void (**)(char *, char *, unint64_t))(v24 + 32);
  uint64_t v45 = v38;
  v44(v38, v23, AssociatedTypeWitness);
  uint64_t v46 = v75;
  uint64_t v47 = v83;
  uint64_t v48 = v84;
  (*(void (**)(char *, uint64_t, uint64_t))(v75 + 16))(v82, v84, v83);
  uint64_t v49 = v77;
  ((void (*)(uint64_t, uint64_t))v41)(v47, v85);
  uint64_t v50 = v49;
  uint64_t v80 = *(void *)(v46 + 8);
  ((void (*)(uint64_t, uint64_t))v80)(v48, v47);
  uint64_t v51 = *(void (**)(char *, char *, unint64_t))(v24 + 16);
  uint64_t v52 = v76;
  v51(v76, v50, AssociatedTypeWitness);
  uint64_t v53 = v78;
  v51(v78, v45, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v52,  v53,  AssociatedTypeWitness) & 1) == 0) {
LABEL_6:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  v43(v53, AssociatedTypeWitness);
  v43(v52, AssociatedTypeWitness);
  __int128 v54 = TupleTypeMetadata2;
  uint64_t v55 = v69;
  unint64_t v56 = &v69[*((int *)TupleTypeMetadata2 + 12)];
  v44(v69, v50, AssociatedTypeWitness);
  v44(v56, v45, AssociatedTypeWitness);
  uint64_t v57 = v74;
  uint64_t v58 = &v74[*((int *)v54 + 12)];
  v51(v74, v55, AssociatedTypeWitness);
  v51(v58, v56, AssociatedTypeWitness);
  uint64_t v59 = v81;
  v44((char *)v81, v57, AssociatedTypeWitness);
  v43(v58, AssociatedTypeWitness);
  uint64_t v60 = &v57[*((int *)v54 + 12)];
  v44(v57, v55, AssociatedTypeWitness);
  v44(v60, v56, AssociatedTypeWitness);
  uint64_t v61 = v73;
  v44((char *)(v59 + *(int *)(v73 + 36)), v60, AssociatedTypeWitness);
  v43(v57, AssociatedTypeWitness);
  uint64_t v62 = v72;
  unint64_t v63 = v70;
  (*(void (**)(char *, uint64_t, uint64_t))(v72 + 32))(v70, v59, v61);
  unint64_t v65 = v82;
  uint64_t v64 = v83;
  (*(void (**)(char *, uint64_t))(v85 + 88))(v63, v83);
  (*(void (**)(char *, uint64_t))(v62 + 8))(v63, v61);
  ((void (*)(char *, uint64_t))v80)(v65, v64);
  return 1LL;
}

unint64_t specialized RangeReplaceableCollection<>.removeFirst()()
{
  unint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  if (!((v2 ^ *v0) >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove items from an empty collection",  43LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2A5uLL,  0);
  }
  unint64_t v3 = v0[2];
  unint64_t v4 = v0[3];
  v5._Swift::UInt64 rawBits = *v0;
  unint64_t v6 = specialized Collection.first.getter(v5, v0[1], v3, v4);
  if ((v6 & 0x100000000LL) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2A6uLL,  0);
  }
  unint64_t v10 = v6;
  swift_bridgeObjectRetain(v4, v7, v8, v9);
  v11._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)v1)._rawBits;
  if ((v4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(after:)(v11)._rawBits;
  }

  else
  {
    Swift::UInt64 v12 = v11._rawBits >> 16;
    if ((v4 & 0x2000000000000000LL) != 0)
    {
      v28[0] = v3;
      v28[1] = v4 & 0xFFFFFFFFFFFFFFLL;
      int v14 = *((unsigned __int8 *)v28 + v12);
    }

    else
    {
      if ((v3 & 0x1000000000000000LL) != 0) {
        uint64_t v13 = (unsigned __int8 *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v13 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v4);
      }
      int v14 = v13[v12];
    }

    int v15 = (char)v14;
    unsigned int v16 = __clz(v14 ^ 0xFF) - 24;
    if (v15 >= 0) {
      LOBYTE(v16) = 1;
    }
    Swift::UInt64 rawBits = ((v12 + v16) << 16) | 5;
  }

  Swift::UInt64 v18 = v0[1];
  if (v18 >> 14 < rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  swift_bridgeObjectRelease(v0[3]);
  swift_bridgeObjectRetain(v4, v19, v20, v21);
  v22._Swift::UInt64 rawBits = rawBits;
  v23._Swift::UInt64 rawBits = v18;
  Swift::UInt64 v24 = _StringGuts.validateScalarRange(_:in:)(v22, v23, v1, v2, v3, v4);
  unint64_t v26 = v25;
  swift_bridgeObjectRelease(v4);
  *uint64_t v0 = v24;
  v0[1] = v26;
  v0[2] = v3;
  v0[3] = v4;
  return v10;
}

uint64_t specialized RangeReplaceableCollection<>.removeFirst()()
{
  unint64_t v1 = *v0;
  Swift::UInt64 v2 = v0[1];
  if (v2 >> 14 == *v0 >> 14) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove items from an empty collection",  43LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2A5uLL,  0);
  }
  unint64_t v4 = v0[2];
  unint64_t v3 = v0[3];
  uint64_t v5 = Substring.subscript.getter(*v0, *v0, v0[1], v4, v3);
  uint64_t v7 = v6;
  swift_bridgeObjectRetain(v3, v6, v8, v9);
  v10._Swift::UInt64 rawBits = Substring.index(after:)((Swift::String::Index)v1)._rawBits;
  if (v2 >> 14 < v10._rawBits >> 14)
  {
    swift_bridgeObjectRelease(v7);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  Swift::UInt64 rawBits = v10._rawBits;
  swift_bridgeObjectRelease(v3);
  v12._Swift::UInt64 rawBits = rawBits;
  v13._Swift::UInt64 rawBits = v2;
  Swift::UInt64 v14 = specialized Substring.subscript.getter(v12, v13, v1, v2, v4, v3);
  uint64_t v16 = v15;
  uint64_t v18 = v17;
  uint64_t v20 = v19;
  swift_bridgeObjectRetain((unint64_t)v19, v15, v17, v19);
  swift_bridgeObjectRelease(v3);
  *uint64_t v0 = v14;
  v0[1] = v16;
  v0[2] = v18;
  v0[3] = (Swift::UInt64)v20;
  return v5;
}

uint64_t RangeReplaceableCollection<>.removeFirst()@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, void (*a3)(uint64_t, uint64_t)@<X8>)
{
  uint64_t v72 = a3;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v68 = (char *)&v62 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v67 = (char *)&v62 - v10;
  uint64_t v75 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v73 = (char *)&v62 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v70 = (char *)&v62 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  int64_t v74 = (char *)&v62 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v19 = (char *)&v62 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v21 = (char *)&v62 - v20;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v23 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v22);
  uint64_t v65 = *(void *)(v23 - 8);
  uint64_t v66 = v23;
  uint64_t v24 = MEMORY[0x1895F8858](v23);
  unint64_t v63 = (char *)&v62 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  uint64_t v64 = (char *)&v62 - v27;
  uint64_t v28 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](v26);
  unint64_t v76 = (char *)&v62 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v30 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v5 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v33 = type metadata accessor for Optional(0LL, v30, v31, v32);
  MEMORY[0x1895F8858](v33);
  uint64_t v35 = (char *)&v62 - v34;
  uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 104);
  uint64_t v78 = v3;
  uint64_t v79 = a1;
  uint64_t v77 = v5;
  if ((v36(a1, v5) & 1) != 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove items from an empty collection",  43LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2A5uLL,  0);
  }
  Collection.first.getter(v79, v77, (uint64_t)v35);
  uint64_t v37 = *(void *)(v30 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v37 + 48))(v35, 1LL, v30) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2A6uLL,  0);
  }
  (*(void (**)(void (*)(uint64_t, uint64_t), char *, unint64_t))(v37 + 32))(v72, v35, v30);
  uint64_t v38 = v79;
  (*(void (**)(char *, uint64_t, uint64_t))(v28 + 16))(v76, v78, v79);
  uint64_t v39 = v77;
  (*(void (**)(uint64_t, uint64_t))(v77 + 64))(v38, v77);
  (*(void (**)(char *, uint64_t, uint64_t))(v39 + 184))(v19, v38, v39);
  uint64_t v40 = v75;
  BOOL v41 = *(void (**)(char *, unint64_t))(v75 + 8);
  v41(v19, AssociatedTypeWitness);
  uint64_t v42 = v74;
  uint64_t v43 = v38;
  uint64_t v44 = v40;
  (*(void (**)(uint64_t, uint64_t))(v39 + 72))(v43, v39);
  uint64_t v45 = *(void (**)(char *, char *, unint64_t))(v40 + 16);
  uint64_t v46 = v70;
  v45(v70, v21, AssociatedTypeWitness);
  uint64_t v47 = v73;
  v45(v73, v42, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v46,  v47,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v72 = *(void (**)(uint64_t, uint64_t))(v28 + 8);
  v72(v78, v79);
  v41(v47, AssociatedTypeWitness);
  v41(v46, AssociatedTypeWitness);
  uint64_t v48 = TupleTypeMetadata2;
  uint64_t v49 = v67;
  uint64_t v50 = &v67[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v51 = *(void (**)(char *, char *, unint64_t))(v44 + 32);
  v51(v67, v21, AssociatedTypeWitness);
  v51(v50, v42, AssociatedTypeWitness);
  uint64_t v52 = v68;
  uint64_t v53 = &v68[*((int *)v48 + 12)];
  v45(v68, v49, AssociatedTypeWitness);
  v45(v53, v50, AssociatedTypeWitness);
  __int128 v54 = v63;
  v51(v63, v52, AssociatedTypeWitness);
  v41(v53, AssociatedTypeWitness);
  uint64_t v55 = &v52[*((int *)v48 + 12)];
  v51(v52, v49, AssociatedTypeWitness);
  v51(v55, v50, AssociatedTypeWitness);
  uint64_t v56 = v66;
  v51(&v54[*(int *)(v66 + 36)], v55, AssociatedTypeWitness);
  v41(v52, AssociatedTypeWitness);
  uint64_t v58 = v64;
  uint64_t v57 = v65;
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v64, v54, v56);
  uint64_t v59 = v76;
  uint64_t v60 = v79;
  (*(void (**)(char *, uint64_t))(v77 + 88))(v58, v79);
  (*(void (**)(char *, uint64_t))(v57 + 8))(v58, v56);
  return ((uint64_t (*)(char *, uint64_t))v72)(v59, v60);
}

void specialized RangeReplaceableCollection<>.removeFirst(_:)(Swift::Int offsetBy)
{
  if (offsetBy)
  {
    if (offsetBy < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2BFuLL,  0);
    }
    unint64_t rawBits = v1->_rawBits;
    Swift::UInt64 v3 = v1[1]._rawBits;
    unint64_t v4 = v1[2]._rawBits;
    unint64_t v5 = v1[3]._rawBits;
    Swift::String::Index_optional v15 = Substring.UnicodeScalarView.index(_:offsetBy:limitedBy:)( (Swift::String::Index)v1->_rawBits,  offsetBy,  (Swift::String::Index)v3);
    if (v15.is_nil) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2C1uLL,  0);
    }
    Swift::UInt64 v9 = v15.value._rawBits;
    if (v3 >> 14 < v15.value._rawBits >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    swift_bridgeObjectRetain(v5, *(uint64_t *)&v15.is_nil, v7, v8);
    v10._unint64_t rawBits = v9;
    v11._unint64_t rawBits = v3;
    Swift::UInt64 v12 = _StringGuts.validateScalarRange(_:in:)(v10, v11, rawBits, v3, v4, v5);
    Swift::UInt64 v14 = v13;
    swift_bridgeObjectRelease(v5);
    v1->_unint64_t rawBits = v12;
    v1[1]._unint64_t rawBits = v14;
    v1[2]._unint64_t rawBits = v4;
    v1[3]._unint64_t rawBits = v5;
  }

{
  Swift::String::Index *v1;
  unint64_t rawBits;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  __int128 v6;
  Swift::UInt64 v7;
  uint64_t v8;
  Swift::UInt64 v9;
  uint64_t v10;
  Swift::UInt64 v11;
  char *v12;
  char *v13;
  if (offsetBy)
  {
    if (offsetBy < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2BFuLL,  0);
    }
    unint64_t rawBits = v1->_rawBits;
    Swift::UInt64 v3 = v1[1]._rawBits;
    unint64_t v5 = v1[2]._rawBits;
    unint64_t v4 = v1[3]._rawBits;
    *(Swift::String::Index_optional *)&uint64_t v6 = Substring.index(_:offsetBy:limitedBy:)( (Swift::String::Index)v1->_rawBits,  offsetBy,  (Swift::String::Index)v3);
    if ((BYTE8(v6) & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2C1uLL,  0);
    }
    if (v3 >> 14 < (unint64_t)v6 >> 14) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    *((void *)&v6 + 1) = v3;
    uint64_t v7 = specialized Substring.subscript.getter( (Swift::String::Index)v6,  *(Swift::String::Index *)((char *)&v6 + 8),  rawBits,  v3,  v5,  v4);
    Swift::UInt64 v9 = v8;
    Swift::String::Index v11 = v10;
    Swift::UInt64 v13 = v12;
    swift_bridgeObjectRetain((unint64_t)v12, v8, v10, v12);
    swift_bridgeObjectRelease(v4);
    v1->_unint64_t rawBits = v7;
    v1[1]._unint64_t rawBits = v9;
    v1[2]._unint64_t rawBits = v11;
    v1[3]._unint64_t rawBits = (Swift::UInt64)v13;
  }

uint64_t RangeReplaceableCollection<>.removeFirst(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(const char **)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v5,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  Swift::UInt64 v9 = (char *)&v70 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  uint64_t v77 = (char *)&v70 - v10;
  char v88 = v5;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v80 = *(void *)(v12 - 8);
  uint64_t v81 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  Swift::String::Index_optional v15 = (char *)&v70 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v13);
  uint64_t v78 = (char *)&v70 - v17;
  uint64_t v18 = (char *)a2;
  uint64_t v83 = *(void (***)(char *, uint64_t, char *))(a2 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v87 = (char *)&v70 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v70 - v24;
  uint64_t v26 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v23);
  uint64_t v84 = (char *)&v70 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  uint64_t v30 = MEMORY[0x1895F8858](v29);
  Swift::String::Index v82 = (char *)&v70 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v70 - v33;
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  uint64_t v37 = (char *)&v70 - v36;
  uint64_t result = MEMORY[0x1895F8858](v35);
  uint64_t v43 = (void (**)(char *, uint64_t, char *))((char *)&v70 - v42);
  if (v39)
  {
    if (v39 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2BFuLL,  0);
    }
    uint64_t v70 = v41;
    uint64_t v71 = result;
    uint64_t v76 = v40;
    uint64_t v73 = v15;
    int64_t v74 = v9;
    uint64_t v44 = v88;
    uint64_t v45 = v39;
    (*((void (**)(char *, const char *))v88 + 8))(v18, v88);
    uint64_t v75 = (void (*)(char *, const char *))*((void *)v44 + 9);
    v75(v18, v44);
    (*((void (**)(char *, uint64_t, char *, char *, const char *))v44 + 18))(v37, v45, v34, v18, v44);
    uint64_t v86 = v3;
    uint64_t v46 = *(void (**)(char *, unint64_t))(v26 + 8);
    v46(v34, AssociatedTypeWitness);
    uint64_t v72 = (void (*)(uint64_t, unint64_t))v46;
    v46(v37, AssociatedTypeWitness);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v26 + 48))(v25, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v70 + 8))(v25, v71);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/RangeReplaceableCollection.swift",  38LL,  2,  0x2C1uLL,  0);
    }

    uint64_t v47 = *(void (**)(void, char *, unint64_t))(v26 + 32);
    uint64_t v48 = v43;
    v47(v43, v25, AssociatedTypeWitness);
    uint64_t v49 = v83;
    uint64_t v50 = v86;
    v83[2](v87, v86, v18);
    uint64_t v51 = v82;
    v75(v18, v88);
    uint64_t v52 = v49[1];
    ((void (*)(uint64_t, char *))v52)(v50, v18);
    uint64_t v53 = *(void (**)(uint64_t, void, unint64_t))(v26 + 16);
    uint64_t v54 = v76;
    uint64_t v83 = v48;
    v53(v76, v48, AssociatedTypeWitness);
    uint64_t v55 = v84;
    v53((uint64_t)v84, v51, AssociatedTypeWitness);
    if (((*(uint64_t (**)(uint64_t, char *, unint64_t))(AssociatedConformanceWitness + 24))( v54,  v55,  AssociatedTypeWitness) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    unint64_t AssociatedConformanceWitness = (unint64_t)v52;
    uint64_t v56 = v72;
    v72((uint64_t)v55, AssociatedTypeWitness);
    v56(v54, AssociatedTypeWitness);
    uint64_t v57 = TupleTypeMetadata2;
    uint64_t v58 = *((int *)TupleTypeMetadata2 + 12);
    uint64_t v84 = v18;
    uint64_t v59 = v77;
    uint64_t v60 = &v77[v58];
    v47(v77, (char *)v83, AssociatedTypeWitness);
    v47(v60, v51, AssociatedTypeWitness);
    uint64_t v61 = v74;
    uint64_t v62 = &v74[*((int *)v57 + 12)];
    v53((uint64_t)v74, v59, AssociatedTypeWitness);
    v53((uint64_t)v62, v60, AssociatedTypeWitness);
    unint64_t v63 = v73;
    v47(v73, v61, AssociatedTypeWitness);
    v56((uint64_t)v62, AssociatedTypeWitness);
    uint64_t v64 = &v61[*((int *)v57 + 12)];
    v47(v61, v59, AssociatedTypeWitness);
    v47(v64, v60, AssociatedTypeWitness);
    uint64_t v65 = v81;
    v47(&v63[*(int *)(v81 + 36)], v64, AssociatedTypeWitness);
    v56((uint64_t)v61, AssociatedTypeWitness);
    uint64_t v66 = v80;
    uint64_t v67 = v78;
    (*(void (**)(char *, char *, uint64_t))(v80 + 32))(v78, v63, v65);
    uint64_t v68 = v87;
    uint64_t v69 = v84;
    (*((void (**)(char *, char *))v88 + 11))(v67, v84);
    (*(void (**)(char *, uint64_t))(v66 + 8))(v67, v65);
    return ((uint64_t (*)(char *, char *))AssociatedConformanceWitness)(v68, v69);
  }

  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance ArraySlice<A>( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a3, a3);
  return RangeReplaceableCollection<>.removeAll(where:)(a1, a2, a3, WitnessTable, a4);
}

uint64_t ArraySlice.customMirror.getter@<X0>( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  *(void *)&__int128 v41 = a1;
  *((void *)&v41 + 1) = a2;
  *(void *)&__int128 v42 = a3;
  *((void *)&v42 + 1) = a4;
  uint64_t v11 = (swift *)type metadata accessor for ArraySlice(0LL, a5, a3, a4);
  v38[0] = 0LL;
  v38[1] = 0LL;
  swift_unknownObjectRetain(a1, v12, v13, v14);
  uint64_t v37 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)&v41, (uint64_t)v38, v11);
  uint64_t v16 = v15;
  uint64_t v17 = swift_allocObject((uint64_t)&unk_189B78140, 0x28uLL, 7uLL);
  v17[2] = v11;
  v17[3] = v11;
  uint64_t WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v11, v18);
  void v17[4] = WitnessTable;
  uint64_t v20 = __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for (label: String?, value: Any));
  uint64_t v22 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v11, v21);
  uint64_t v23 = type metadata accessor for LazyMapSequence(255LL, (uint64_t)v11, v20, v22);
  uint64_t v40 = WitnessTable;
  uint64_t v24 = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, v23, &v40);
  uint64_t v26 = type metadata accessor for _CollectionBox(0LL, v23, v24, v25);
  uint64_t v27 = swift_allocObject(v26, 0x60uLL, 7uLL);
  v27[6] = a1;
  v27[7] = a2;
  v27[8] = a3;
  v27[9] = a4;
  v27[10] = closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)partial apply;
  v27[11] = v17;
  uint64_t v28 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  uint64_t v29 = swift_allocObject(v28, 0x18uLL, 7uLL);
  v29[2] = a3;
  uint64_t v30 = swift_allocObject(v28, 0x18uLL, 7uLL);
  v30[2] = a4 >> 1;
  v27[2] = v29;
  v27[3] = &protocol witness table for _IndexBox<A>;
  v27[4] = v30;
  v27[5] = &protocol witness table for _IndexBox<A>;
  v39[0] = v41;
  v39[1] = v42;
  swift_unknownObjectRetain(a1, v31, v32, v33);
  uint64_t v34 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  uint64_t result = swift_dynamicCast((char *)v38, (uint64_t *)v39, v11, v34, 6uLL);
  char v36 = result;
  if ((_DWORD)result) {
    uint64_t result = __swift_destroy_boxed_opaque_existential_1Tm(v38);
  }
  *(void *)a6 = v11;
  *(void *)(a6 + 8) = v27;
  *(_BYTE *)(a6 + 16) = 5;
  *(void *)(a6 + 24) = v37;
  *(void *)(a6 + 32) = v16;
  *(_BYTE *)(a6 + 40) = v36;
  return result;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance ArraySlice<A>@<X0>( uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return ArraySlice.customMirror.getter( *(void **)v2,  *(void *)(v2 + 8),  *(void *)(v2 + 16),  *(void *)(v2 + 24),  *(void *)(a1 + 16),  a2);
}

uint64_t ArraySlice.description.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v109 = a1;
  uint64_t v110 = a2;
  uint64_t v8 = *(void *)(a5 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](a1);
  uint64_t v105 = (char *)&v99 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v99 - v11;
  swift_bridgeObjectRelease(0xE000000000000000LL);
  uint64_t v15 = 91LL;
  unint64_t v16 = 0xE100000000000000LL;
  uint64_t v113 = 91LL;
  unint64_t v114 = 0xE100000000000000LL;
  unint64_t v108 = a4 >> 1;
  if (a4 >> 1 == a3) {
    goto LABEL_49;
  }
  uint64_t v107 = v12;
  unint64_t v16 = 1LL;
  __int128 v106 = xmmword_1817FFC60;
  __int128 v101 = xmmword_1817FFC70;
  Swift::UInt64 v100 = 131073LL;
  uint64_t v17 = a3;
  unint64_t v103 = a4;
  uint64_t v15 = (uint64_t)v105;
  uint64_t v104 = a3;
  while (1)
  {
    uint64_t v23 = v110;
    specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)(v17, v109, v110, a3, a4);
    uint64_t v24 = v23 + *(void *)(v8 + 72) * v17;
    uint64_t v25 = v107;
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v107, v24, a5);
    uint64_t v26 = v17 + 1;
    if (__OFADD__(v17, 1LL))
    {
      __break(1u);
      goto LABEL_82;
    }

    uint64_t v27 = *(void (**)(uint64_t, char *, uint64_t))(v8 + 32);
    v27(v15, v25, a5);
    if ((v16 & 1) != 0) {
      goto LABEL_6;
    }
    uint64_t v31 = v113;
    uint64_t v30 = v114;
    unint64_t v32 = HIBYTE(v114) & 0xF;
    if ((v114 & 0x2000000000000000LL) != 0) {
      unint64_t v33 = HIBYTE(v114) & 0xF;
    }
    else {
      unint64_t v33 = v113 & 0xFFFFFFFFFFFFLL;
    }
    if (!v33 && (v113 & ~v114 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v114);
      uint64_t v113 = 8236LL;
      unint64_t v114 = 0xE200000000000000LL;
      goto LABEL_4;
    }

    if ((v114 & 0x2000000000000000LL) != 0 && v32 <= 0xD)
    {
      unint64_t v34 = 8 * (HIBYTE(v114) & 7);
      uint64_t v35 = (-255LL << v34) - 1;
      uint64_t v36 = 44LL << v34;
      char v37 = v32 + 1;
      if (v32 >= 8)
      {
        uint64_t v38 = v36 | v35 & v114;
        a3 = v104;
LABEL_39:
        uint64_t v65 = (32LL << (8 * (v37 & 7u))) | ((-255LL << (8 * (v37 & 7u))) - 1) & v38;
      }

      else
      {
        uint64_t v31 = v36 | v35 & v113;
        a3 = v104;
        if (v32 == 7)
        {
          char v37 = 8;
          uint64_t v38 = v114;
          goto LABEL_39;
        }

        uint64_t v31 = (32LL << (8 * (v37 & 7u))) | ((-255LL << (8 * (v37 & 7u))) - 1) & v31;
        uint64_t v65 = v114;
      }

      swift_bridgeObjectRelease(v114);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      unint64_t v66 = 0xE000000000000000LL;
      if (v31 & 0x8080808080808080LL | v65 & 0x80808080808080LL) {
        unint64_t v66 = 0xA000000000000000LL;
      }
      uint64_t v113 = v31;
      unint64_t v114 = (v66 & 0xFF00000000000000LL | (v32 << 56) | v65 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
      a4 = v103;
      goto LABEL_5;
    }

    swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v28, v29);
    if ((v30 & 0x1000000000000000LL) == 0)
    {
      BOOL v39 = __OFADD__(v33, 2LL);
      int64_t v40 = v33 + 2;
      if (v39) {
        break;
      }
      goto LABEL_21;
    }

    Swift::Int v67 = String.UTF8View._foreignCount()();
    int64_t v40 = v67 + 2;
    if (__OFADD__(v67, 2LL)) {
      break;
    }
LABEL_21:
    if ((v31 & ~v30 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(v30 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v41 = _StringGuts.nativeUnusedCapacity.getter(v31, v30);
      if ((v42 & 1) != 0) {
        goto LABEL_86;
      }
      BOOL v44 = (v30 & 0x2000000000000000LL) == 0 && v41 > 1;
      if (v40 <= 15 && !v44)
      {
LABEL_34:
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
        swift_bridgeObjectRetain(v30, v45, v46, v47);
        unint64_t v102 = _StringGuts._convertedToSmall()(v31, v30);
        unint64_t v49 = v48;
        swift_bridgeObjectRelease(v30);
        v50._unint64_t rawBits = 1LL;
        v51._unint64_t rawBits = v100;
        v52._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v50, v51, 0x202CuLL, 0xE200000000000000LL);
        if (v52._rawBits < 0x10000) {
          v52._rawBits |= 3;
        }
        unint64_t v54 = specialized String.init(_:)(v52, v53, 0x202CuLL, 0xE200000000000000LL);
        unint64_t v56 = v55;
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v57 = _StringGuts._convertedToSmall()(v54, v56);
        unint64_t v59 = v58;
        swift_bridgeObjectRelease(v56);
        unint64_t v60 = specialized _SmallString.init(_:appending:)(v102, v49, v57, v59);
        if ((v62 & 1) != 0) {
          goto LABEL_85;
        }
        uint64_t v63 = v60;
        unint64_t v64 = v61;
        swift_bridgeObjectRelease(v30);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        uint64_t v113 = v63;
        unint64_t v114 = v64;
        a4 = v103;
        goto LABEL_4;
      }
    }

    else if (v40 <= 15)
    {
      goto LABEL_34;
    }

    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v40, 2LL);
    swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
    __int128 v111 = v101;
    uint64_t v18 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v111, 2LL);
    _StringGuts.appendInPlace(_:isASCII:)(v18, v19, 1);
    swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_4:
    a3 = v104;
LABEL_5:
    uint64_t v15 = (uint64_t)v105;
LABEL_6:
    uint64_t v20 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v20, v112);
    *((_OWORD *)inited + 1) = v106;
    inited[7] = a5;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v27((uint64_t)boxed_opaque_existential_0Tm, (char *)v15, a5);
    specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  &v113);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    swift_bridgeObjectRelease(0xE100000000000000LL);
    unint64_t v16 = 0LL;
    ++v17;
    if (v26 == v108) {
      goto LABEL_48;
    }
  }

  __break(1u);
LABEL_48:
  uint64_t v15 = v113;
  unint64_t v16 = v114;
LABEL_49:
  unint64_t v68 = HIBYTE(v16) & 0xF;
  if ((v16 & 0x2000000000000000LL) != 0) {
    uint64_t v69 = HIBYTE(v16) & 0xF;
  }
  else {
    uint64_t v69 = v15 & 0xFFFFFFFFFFFFLL;
  }
  if (!v69 && (v15 & ~v16 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v16);
    return 93LL;
  }

  if ((v16 & 0x2000000000000000LL) == 0 || v68 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, v13, v14);
    if ((v16 & 0x1000000000000000LL) == 0)
    {
      BOOL v39 = __OFADD__(v69, 1LL);
      int64_t v71 = v69 + 1;
      if (!v39)
      {
LABEL_62:
        if ((v15 & ~v16 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(v16 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v72 = _StringGuts.nativeUnusedCapacity.getter(v15, v16);
          if ((v73 & 1) != 0)
          {
LABEL_86:
            unint64_t v98 = 258LL;
LABEL_87:
            _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v98,  0);
          }

          BOOL v75 = (v16 & 0x2000000000000000LL) == 0 && v72 > 0;
          if (v71 <= 15 && !v75) {
            goto LABEL_73;
          }
        }

        else if (v71 <= 15)
        {
LABEL_73:
          swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
          swift_bridgeObjectRetain(v16, v76, v77, v78);
          unint64_t v79 = _StringGuts._convertedToSmall()(v15, v16);
          unint64_t v81 = v80;
          swift_bridgeObjectRelease(v16);
          v82._unint64_t rawBits = 1LL;
          v83._unint64_t rawBits = 65537LL;
          v84._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v82, v83, 0x5DuLL, 0xE100000000000000LL);
          if (v84._rawBits < 0x10000) {
            v84._rawBits |= 3;
          }
          unint64_t v86 = specialized String.init(_:)(v84, v85, 0x5DuLL, 0xE100000000000000LL);
          unint64_t v88 = v87;
          swift_bridgeObjectRelease(0xE100000000000000LL);
          unint64_t v89 = _StringGuts._convertedToSmall()(v86, v88);
          unint64_t v91 = v90;
          swift_bridgeObjectRelease(v88);
          unint64_t v92 = specialized _SmallString.init(_:appending:)(v79, v81, v89, v91);
          if ((v93 & 1) == 0)
          {
            uint64_t v70 = v92;
            swift_bridgeObjectRelease(v16);
            swift_bridgeObjectRelease(0xE100000000000000LL);
            return v70;
          }

          goto LABEL_85;
        }

        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v71, 1LL);
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
        __int128 v111 = xmmword_1817FFC80;
        char v94 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v111, 1LL);
        _StringGuts.appendInPlace(_:isASCII:)(v94, v95, 1);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        return v113;
      }

LABEL_84:
      __break(1u);
LABEL_85:
      unint64_t v98 = 266LL;
      goto LABEL_87;
    }

  unint64_t v86 = HIBYTE(v68) & 0xF;
  unint64_t v87 = HIBYTE(v70) & 0xF;
  if ((unint64_t)(v87 + v86) > 0xF)
  {
LABEL_119:
    uint64_t v110 = 266LL;
    goto LABEL_121;
  }

  if (v87)
  {
    unint64_t v88 = 0;
    unint64_t v89 = 0LL;
    do
    {
      unint64_t v90 = v86 + v89;
      unint64_t v91 = v89 + 1;
      if (v89 >= 8) {
        unint64_t v92 = v70;
      }
      else {
        unint64_t v92 = v67;
      }
      char v93 = v92 >> (v88 & 0x38);
      char v94 = (8 * v86 + v88) & 0x38;
      size_t v95 = (-255LL << v94) - 1;
      unint64_t v96 = (unint64_t)v93 << v94;
      Swift::Int v97 = v96 | v95 & v68;
      unint64_t v98 = v96 | v95 & v12;
      if (v90 < 8) {
        uint64_t v12 = v98;
      }
      else {
        unint64_t v68 = v97;
      }
      v88 += 8;
      unint64_t v89 = v91;
    }

    while (v87 != v91);
  }

      uint64_t v17 = (v7 + 31) & 0xFFFFFFFFFFFFFFF8LL;
      if (v17) {
        BOOL v44 = v17 + 24 > v8;
      }
      else {
        BOOL v44 = 1;
      }
      if (v44)
      {
LABEL_89:
        uint64_t v45 = 2LL * *((void *)a1 + 4);
        if (v45 <= 0x20) {
          uint64_t v45 = 32LL;
        }
        *((void *)a1 + 4) = v45;
        uint64_t v46 = v45 + 8;
        uint64_t v47 = malloc(v45 + 8);
        *uint64_t v47 = *((void *)a1 + 3);
        uint64_t v17 = ((unint64_t)v47 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        *((void *)a1 + 2) = (char *)v47 + v46;
        *((void *)a1 + 3) = v47;
      }

LABEL_82:
    Swift::Int v97 = String.UTF8View._foreignCount()();
    int64_t v71 = v97 + 1;
    if (!__OFADD__(v97, 1LL)) {
      goto LABEL_62;
    }
    goto LABEL_84;
  }

  if (v68 >= 8) {
    uint64_t v70 = v15;
  }
  else {
    uint64_t v70 = (93LL << (8 * (HIBYTE(v16) & 7u))) | ((-255LL << (8 * (HIBYTE(v16) & 7u))) - 1) & v15;
  }
  swift_bridgeObjectRelease(v16);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v70;
}

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
      }
    }

    else
    {
      uint64_t v70 = v91;
      if ((v6 & 0x1000000000000000LL) == 0) {
        goto LABEL_59;
      }
    }

    Swift::String::Index v85 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v6 & 0x2000000000000000LL) != 0) {
      Swift::String::Index v85 = HIBYTE(v6) & 0xF;
    }
    if (v85 < v39 >> 16) {
      goto LABEL_82;
    }
    char v37 = String.UTF8View._foreignDistance(from:to:)((Swift::String::Index)15LL, (Swift::String::Index)v39);
    swift_bridgeObjectRelease(v6);
    unint64_t v66 = __OFADD__(v7, v37);
    v7 += v37;
    if (!v66) {
      goto LABEL_60;
    }
    goto LABEL_73;
  }

  uint64_t v70 = v91;
LABEL_60:
  if ((specialized static Comparable.<= infix(_:_:)(v9, v8, v92, a4, v90, v70) & 1) == 0)
  {
    unint64_t v66 = __OFSUB__(0LL, v7);
    uint64_t v7 = -(uint64_t)v7;
    if (v66) {
      goto LABEL_74;
    }
  }

  return v7;
}

                  swift_release_n(v5, 2LL);
LABEL_83:
                  *uint64_t v3 = (uint64_t)v13;
                  uint64_t v65 = v13[5];
                  unint64_t v66 = *((void *)a1 + 3);
                  Swift::Int v67 = *((void *)a1 + 4);
                  __swift_project_boxed_opaque_existential_0Tm(a1, v66);
                  (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v67 + 8))(&v93, v66, v67);
                  unint64_t v68 = *((void *)&v94 + 1);
                  uint64_t v69 = v95;
                  __swift_project_boxed_opaque_existential_0Tm(&v93, *((uint64_t *)&v94 + 1));
                  uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v69 + 40))(v65, v68, v69);
                  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v93);
                  int64_t v71 = -1LL << *((_BYTE *)v13 + 32);
                  a2 = v70 & ~v71;
                  if (((*(void *)((char *)v13 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> a2) & 1) != 0)
                  {
                    int64_t v72 = ~v71;
                    do
                    {
                      outlined init with copy of AnyHashable(v13[6] + 40 * a2, (uint64_t)&v93);
                      char v73 = *((void *)&v94 + 1);
                      int64_t v74 = v95;
                      __swift_project_boxed_opaque_existential_0Tm(&v93, *((uint64_t *)&v94 + 1));
                      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v74 + 8))(v90, v73, v74);
                      BOOL v75 = v91;
                      uint64_t v76 = v92;
                      __swift_project_boxed_opaque_existential_0Tm(v90, v91);
                      uint64_t v77 = *((void *)a1 + 3);
                      uint64_t v78 = *((void *)a1 + 4);
                      __swift_project_boxed_opaque_existential_0Tm(a1, v77);
                      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v78 + 8))(v89, v77, v78);
                      unint64_t v79 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v76 + 16))(v89, v75, v76);
                      __swift_destroy_boxed_opaque_existential_1Tm(v89);
                      if (v79 == 2)
                      {
                        __swift_destroy_boxed_opaque_existential_1Tm(v90);
                        outlined destroy of AnyHashable((uint64_t *)&v93);
                      }

                      else
                      {
                        __swift_destroy_boxed_opaque_existential_1Tm(v90);
                        outlined destroy of AnyHashable((uint64_t *)&v93);
                        if ((v79 & 1) != 0) {
                          ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)((uint64_t)&type metadata for AnyHashable);
                        }
                      }

                      a2 = (a2 + 1) & v72;
                    }

                    while (((*(void *)((char *)v13 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> a2) & 1) != 0);
                  }

                  goto LABEL_90;
                }

                unint64_t v59 = v64;
              }
            }
          }

  size_t v95 = HIBYTE(v77) & 0xF;
  unint64_t v96 = HIBYTE(v79) & 0xF;
  if ((unint64_t)(v96 + v95) > 0xF)
  {
LABEL_117:
    uint64_t v120 = 266LL;
    goto LABEL_119;
  }

  if (v96)
  {
    Swift::Int v97 = 0;
    unint64_t v98 = 0LL;
    do
    {
      uint64_t v99 = v95 + v98;
      Swift::UInt64 v100 = v98 + 1;
      if (v98 >= 8) {
        __int128 v101 = v79;
      }
      else {
        __int128 v101 = v76;
      }
      unint64_t v102 = v101 >> (v97 & 0x38);
      unint64_t v103 = (8 * v95 + v97) & 0x38;
      uint64_t v104 = (-255LL << v103) - 1;
      uint64_t v105 = (unint64_t)v102 << v103;
      __int128 v106 = v105 | v104 & v77;
      uint64_t v107 = v105 | v104 & v16;
      if (v99 < 8) {
        unint64_t v16 = v107;
      }
      else {
        uint64_t v77 = v106;
      }
      v97 += 8;
      unint64_t v98 = v100;
    }

    while (v96 != v100);
  }

  unint64_t v92 = HIBYTE(v74) & 0xF;
  char v93 = HIBYTE(v76) & 0xF;
  if ((unint64_t)(v93 + v92) > 0xF)
  {
LABEL_117:
    __int128 v116 = 266LL;
    goto LABEL_119;
  }

  if (v93)
  {
    char v94 = 0;
    size_t v95 = 0LL;
    do
    {
      unint64_t v96 = v92 + v95;
      Swift::Int v97 = v95 + 1;
      if (v95 >= 8) {
        unint64_t v98 = v76;
      }
      else {
        unint64_t v98 = v73;
      }
      uint64_t v99 = v98 >> (v94 & 0x38);
      Swift::UInt64 v100 = (8 * v92 + v94) & 0x38;
      __int128 v101 = (-255LL << v100) - 1;
      unint64_t v102 = (unint64_t)v99 << v100;
      unint64_t v103 = v102 | v101 & v74;
      uint64_t v104 = v102 | v101 & v16;
      if (v96 < 8) {
        unint64_t v16 = v104;
      }
      else {
        int64_t v74 = v103;
      }
      v94 += 8;
      size_t v95 = v97;
    }

    while (v93 != v97);
  }

    Swift::String::Index v51 = (v97 - 1) & v97;
    unint64_t v89 = __clz(__rbit64(v97)) + (v98 << 6);
    unint64_t v122 = v98;
LABEL_83:
    (*(void (**)(char *, unint64_t, swift *))(v8 + 16))( v35,  *(void *)(v53 + 48) + *(void *)(v8 + 72) * v89,  a2);
LABEL_84:
    Swift::UInt64 v100 = *(void (**)(char *, uint64_t, uint64_t, swift *))(v8 + 56);
    while (1)
    {
      v100(v35, 0LL, 1LL, a2);
      __int128 v101 = (uint64_t *)v126;
      (*(void (**)(char *, char *, swift *))(v8 + 32))(v126, v35, a2);
      swift_dynamicCast(v14, v101, a2, (const char *)&type metadata for String, 7uLL);
      unint64_t v102 = v124;
      unint64_t v103 = *(void (**)(char *, char *, ValueMetadata *))(v125 + 32);
      v103(v124, v14, &type metadata for String);
      v103(v14, v102, &type metadata for String);
      uint64_t v105 = type metadata accessor for _NativeSet(0LL, (uint64_t)&type metadata for String, v127, v104);
      _NativeSet._unsafeUpdate(with:)((uint64_t)v14, v105);
      Swift::String::Index v53 = v123;
      if ((v123 & 0x8000000000000000LL) == 0) {
        break;
      }
LABEL_62:
      unint64_t v90 = *(void *)(v84 + 216);
      if (v90 < 0) {
        goto LABEL_93;
      }
      unint64_t v91 = (uint64_t *)v121;
      if (v90 == *(void *)(v84 + 224))
      {
        unint64_t v92 = objc_msgSend(*(id *)(v84 + 208), sel_countByEnumeratingWithState_objects_count_, v117, v116, 16);
        *(void *)(v84 + 224) = v92;
        if (!v92)
        {
          *(void *)(v84 + 216) = -1LL;
          goto LABEL_93;
        }

        unint64_t v90 = 0LL;
        *(void *)(v84 + 216) = 0LL;
      }

      char v93 = *(void *)(v84 + 24);
      if (!v93) {
        goto LABEL_102;
      }
      char v94 = (void **)(v93 + 8 * v90);
      if ((v94 & 7) != 0) {
LABEL_95:
      }
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x4F9uLL,  0);
      size_t v95 = *v94;
      *(void *)(v84 + 216) = v90 + 1;
      swift_unknownObjectRetain(v95, v85, v86, v87);
      if (_swift_isClassOrObjCExistentialType((uint64_t)a2, (uint64_t *)a2))
      {
        unint64_t v128 = v95;
        swift_dynamicCast(v35, (uint64_t *)&v128, v120, (const char *)a2, 7uLL);
        goto LABEL_84;
      }

      Swift::UInt64 v100 = *(void (**)(char *, uint64_t, uint64_t, swift *))(v8 + 56);
      v100((char *)v91, 1LL, 1LL, a2);
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v95, (uint64_t)a2, v91);
      swift_unknownObjectRelease(v95);
      __int128 v106 = v113;
      uint64_t v107 = v91;
      unint64_t v108 = v111;
      (*(void (**)(char *, uint64_t *, uint64_t))(v114 + 16))(v111, v107, v113);
      if ((*(unsigned int (**)(char *, uint64_t, swift *))(v8 + 48))(v108, 1LL, a2) == 1) {
LABEL_103:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
      (*(void (**)(swift *, uint64_t))(v114 + 8))(v121, v106);
      (*(void (**)(char *, char *, swift *))(v8 + 32))(v35, v108, a2);
    }
  }

  uint64_t v99 = v122 + 3;
  if (v122 + 3 >= v118) {
    goto LABEL_93;
  }
  Swift::Int v97 = *(void *)(v119 + 8 * v99);
  if (v97)
  {
    unint64_t v98 = v122 + 3;
    goto LABEL_82;
  }

  while (1)
  {
    unint64_t v98 = v99 + 1;
    if (__OFADD__(v99, 1LL)) {
      goto LABEL_101;
    }
    if (v98 >= v118) {
      break;
    }
    Swift::Int v97 = *(void *)(v119 + 8 * v98);
    ++v99;
    if (v97) {
      goto LABEL_82;
    }
  }

      uint64_t v8 = 0;
      ++v40;
      uint64_t v45 = v56 - (v48 + v49);
      uint64_t v46 = v53;
      if (!--v44) {
        goto LABEL_248;
      }
    }

    if (!v53) {
      goto LABEL_244;
    }
    --v53;
LABEL_81:
    if (v54) {
      goto LABEL_244;
    }
    goto LABEL_82;
  }

                Swift::String::Index v84 = _StringGuts.nativeUnusedCapacity.getter(v76, v75);
                unint64_t v87 = (v85 & 1) == 0 && v84 >= v70;
                if ((v76 & ~v75 & 0x2000000000000000LL) != 0
                  && swift_isUniquelyReferenced_nonNull_native(v75 & 0xFFFFFFFFFFFFFFFLL))
                {
                  uint64_t v13 = v243;
                  if (v87) {
                    goto LABEL_113;
                  }
LABEL_106:
                  __int128 v106 = _StringGuts.nativeCapacity.getter(v76, v75);
                  if ((v107 & 1) != 0) {
                    unint64_t v108 = 0LL;
                  }
                  else {
                    unint64_t v108 = v106;
                  }
                  if (v108 + 0x4000000000000000LL < 0)
                  {
                    __break(1u);
LABEL_269:
                    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
                  }

                  uint64_t v109 = 2 * v108;
                  if (v109 > v74) {
                    int64_t v74 = v109;
                  }
                }

                else
                {
                  uint64_t v13 = v243;
                  if (!v87) {
                    goto LABEL_106;
                  }
                }

                _StringGuts.grow(_:)(v74);
LABEL_113:
                swift_bridgeObjectRelease_n(v66, 4LL);
                if ((v66 & 0x1000000000000000LL) != 0)
                {
                  swift_bridgeObjectRelease(v66);
                  _StringGuts._foreignAppendInPlace(_:)(v65, v66, 0LL, v239);
                  swift_bridgeObjectRelease(v66);
                  unint64_t v4 = v240;
                }

                else if (v67)
                {
                  swift_bridgeObjectRelease_n(v66, 2LL);
                  *(void *)&v245 = v65;
                  *((void *)&v245 + 1) = v66 & 0xFFFFFFFFFFFFFFLL;
                  uint64_t v110 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v68, (uint64_t)&v245, v68);
                  _StringGuts.appendInPlace(_:isASCII:)(v110, v111, (v66 & 0x4000000000000000LL) != 0);
                  unint64_t v4 = v240;
                }

                else
                {
                  if ((v65 & 0x1000000000000000LL) != 0)
                  {
                    swift_bridgeObjectRelease(v66);
                    v130 = (id)((v66 & 0xFFFFFFFFFFFFFFFLL) + 32);
                    v131 = v65 & 0xFFFFFFFFFFFFLL;
                  }

                  else
                  {
                    v130 = _StringObject.sharedUTF8.getter(v65, v66);
                    v131 = v181;
                    swift_bridgeObjectRelease(v66);
                    if (v131 < (v65 & 0xFFFFFFFFFFFFLL)) {
                      goto LABEL_267;
                    }
                  }

                  unint64_t v4 = v240;
                  uint64_t v132 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  v65 & 0xFFFFFFFFFFFFLL,  (uint64_t)v130,  v131);
                  _StringGuts.appendInPlace(_:isASCII:)(v132, v133, v65 < 0);
                  swift_bridgeObjectRelease(v66);
                }

    uint64_t v12 = 0LL;
    uint64_t v70 = (uint8x16_t *)((char *)TypeName + v61);
    uint64_t v69 = 1;
    int64_t v71 = TypeName;
    int64_t v72 = TypeName;
    while (1)
    {
      BOOL v75 = v72->i8[0];
      int64_t v72 = (uint8x16_t *)((char *)v72 + 1);
      int64_t v74 = v75;
      if (v75 < 0) {
        break;
      }
      char v73 = 1LL;
LABEL_84:
      v12 += v73;
      int64_t v71 = v72;
      if (v72 == v70)
      {
        if (v61 > 15) {
          goto LABEL_122;
        }
        goto LABEL_132;
      }
    }

    if (v74 <= 0xDFu)
    {
      if (v72 == v70 || (v72->i8[0] & 0xC0) != 0x80) {
        goto LABEL_123;
      }
      uint64_t v69 = 0;
      int64_t v72 = (uint8x16_t *)&v71->i16[1];
      char v73 = 2LL;
      goto LABEL_84;
    }

    if (v74 == 224)
    {
      if (v72 == v70 || (v71->i8[1] & 0xE0) != 0xA0) {
        goto LABEL_123;
      }
      goto LABEL_102;
    }

    if (v74 <= 0xECu)
    {
LABEL_96:
      if (v72 == v70) {
        goto LABEL_123;
      }
      LOBYTE(v76) = v71->i8[1];
LABEL_101:
      if ((v76 & 0xC0) != 0x80) {
        goto LABEL_123;
      }
LABEL_102:
      uint64_t v69 = 0;
      int64_t v72 = (uint8x16_t *)((char *)v71->i32 + 3);
      char v73 = 3LL;
      goto LABEL_84;
    }

    if (v74 == 237)
    {
      if (v72 == v70) {
        goto LABEL_123;
      }
      uint64_t v76 = v71->u8[1];
      if (v76 > 0x9F) {
        goto LABEL_123;
      }
      goto LABEL_101;
    }

    if (v74 <= 0xEFu) {
      goto LABEL_96;
    }
    if (v74 == 240)
    {
      goto LABEL_116;
    }

    if ((v74 + 15) <= 2u)
    {
      if (v72 == v70) {
        goto LABEL_123;
      }
      LOBYTE(v77) = v71->i8[1];
LABEL_115:
      if ((v77 & 0xC0) != 0x80) {
        goto LABEL_123;
      }
LABEL_116:
      if (&v71->i16[1] == (__int16 *)v70
        || (v71->i8[2] & 0xC0) != 0x80
        || (uint8x16_t *)((char *)v71->i32 + 3) == v70
        || (v71->i8[3] & 0xC0) != 0x80)
      {
        goto LABEL_123;
      }

      uint64_t v69 = 0;
      int64_t v72 = (uint8x16_t *)((char *)v71->i64 + 4);
      char v73 = 4LL;
      goto LABEL_84;
    }

    if (v72 != v70)
    {
      uint64_t v77 = v71->u8[1];
      if (v77 <= 0x8F) {
        goto LABEL_115;
      }
    }

uint64_t ArraySlice.debugDescription.getter( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v181 = a4;
  uint64_t v182 = a3;
  uint64_t v188 = a1;
  uint64_t v189 = a2;
  uint64_t v7 = *(void *)(a5 - 8);
  uint64_t v8 = MEMORY[0x1895F8858](a1);
  v184 = (char *)&v178 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  v187 = (char *)&v178 - v10;
  Swift::String v11 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ArraySlice", 0xAuLL, 1);
  uint64_t countAndFlagsBits = v11._countAndFlagsBits;
  unint64_t object = (unint64_t)v11._object;
  unint64_t v194 = 0LL;
  unint64_t v195 = 0xE000000000000000LL;
  uint64_t v14 = specialized static String._createEmpty(withInitialCapacity:)(4LL);
  uint64_t v18 = v14;
  uint64_t v19 = v15;
  *(void *)&__int128 v193 = v14;
  *((void *)&v193 + 1) = v15;
  uint64_t v20 = HIBYTE(v15) & 0xF;
  int64_t v21 = v14 & 0xFFFFFFFFFFFFLL;
  if ((v15 & 0x2000000000000000LL) != 0) {
    uint64_t v22 = HIBYTE(v15) & 0xF;
  }
  else {
    uint64_t v22 = v14 & 0xFFFFFFFFFFFFLL;
  }
  if (v22 || (v14 & ~v15 & 0x2000000000000000LL) != 0)
  {
    if ((v15 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRetain_n(0xE000000000000000LL, 6LL, v16, v17);
      if ((v19 & 0x1000000000000000LL) != 0) {
        goto LABEL_169;
      }
      goto LABEL_8;
    }

    swift_bridgeObjectRelease(v15);
    swift_bridgeObjectRelease(0xE000000000000000LL);
    unint64_t v48 = 0xA000000000000000LL;
    if (!(v19 & 0x80808080808080LL | v18 & 0x8080808080808080LL)) {
      unint64_t v48 = 0xE000000000000000LL;
    }
    unint64_t v44 = v48 & 0xFF00000000000000LL | (v20 << 56) | v19 & 0xFFFFFFFFFFFFFFLL;
    *(void *)&__int128 v193 = v18;
  }

  else
  {
    swift_bridgeObjectRelease(v15);
    uint64_t v18 = 0LL;
    unint64_t v44 = 0xE000000000000000LL;
    *(void *)&__int128 v193 = 0LL;
  }

LABEL_76:
    uint64_t v107 = *((void *)&v193 + 1);
    uint64_t v108 = HIBYTE(*((void *)&v193 + 1)) & 0xFLL;
    if ((*((void *)&v193 + 1) & 0x2000000000000000LL) == 0) {
      uint64_t v108 = v193 & 0xFFFFFFFFFFFFLL;
    }
    if (v108 || ((unint64_t)v193 & ~*((void *)&v193 + 1) & 0x2000000000000000LL) != 0)
    {
      if ((*((void *)&v193 + 1) & 0x2000000000000000LL) == 0
        || (unint64_t v109 = specialized _SmallString.init(_:appending:)( v193,  *((unint64_t *)&v193 + 1),  0x5B28uLL,  0xE200000000000000LL),  (v65 & 1) != 0))
      {
        swift_bridgeObjectRetain(0xE200000000000000LL, v64, v65, v66);
        _StringGuts.append(_:)(23336LL, 0xE200000000000000LL, 0LL, 2LL);
        swift_bridgeObjectRelease_n(0xE200000000000000LL, 2LL);
        unint64_t v111 = *((void *)&v193 + 1);
        unint64_t v110 = v193;
      }

      else
      {
        unint64_t v110 = v109;
        unint64_t v111 = v64;
        swift_bridgeObjectRelease(v107);
        swift_bridgeObjectRelease(0xE200000000000000LL);
      }
    }

    else
    {
      swift_bridgeObjectRelease(*((uint64_t *)&v193 + 1));
      unint64_t v111 = 0xE200000000000000LL;
      unint64_t v110 = 23336LL;
    }

    uint64_t v115 = v195;
    unint64_t v116 = HIBYTE(v195) & 0xF;
    if ((v195 & 0x2000000000000000LL) == 0) {
      unint64_t v116 = v194 & 0xFFFFFFFFFFFFLL;
    }
    unint64_t v179 = object;
    if (v116 || (v194 & ~v195 & 0x2000000000000000LL) != 0)
    {
      if ((v195 & 0x2000000000000000LL) != 0)
      {
        if ((v111 & 0x2000000000000000LL) != 0)
        {
          unint64_t v167 = specialized _SmallString.init(_:appending:)(v194, v195, v110, v111);
          if ((v113 & 1) == 0)
          {
            unint64_t v168 = v167;
            unint64_t v169 = v112;
            swift_bridgeObjectRelease(v115);
            swift_bridgeObjectRelease(v111);
            unint64_t v194 = v168;
            unint64_t v195 = v169;
            uint64_t v52 = v182;
            goto LABEL_94;
          }

          uint64_t v117 = HIBYTE(v111) & 0xF;
          uint64_t v52 = v182;
LABEL_93:
          swift_bridgeObjectRetain(v111, v112, v113, v114);
          _StringGuts.append(_:)(v110, v111, 0LL, v117);
          swift_bridgeObjectRelease_n(v111, 2LL);
LABEL_94:
          uint64_t v23 = v184;
          goto LABEL_95;
        }
      }

      else if ((v111 & 0x2000000000000000LL) != 0)
      {
        uint64_t v117 = HIBYTE(v111) & 0xF;
        goto LABEL_93;
      }

      uint64_t v117 = v110 & 0xFFFFFFFFFFFFLL;
      goto LABEL_93;
    }

    swift_bridgeObjectRelease(v195);
    unint64_t v194 = v110;
    unint64_t v195 = v111;
LABEL_95:
    unint64_t object = v181;
    uint64_t v186 = v181 >> 1;
    if (v181 >> 1 == v52) {
      break;
    }
    unint64_t v44 = 1LL;
    __int128 v185 = xmmword_1817FFC60;
    __int128 v180 = xmmword_1817FFC70;
    uint64_t v19 = v52;
    while (1)
    {
      uint64_t v127 = v189;
      specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)(v19, v188, v189, v52, object);
      uint64_t v128 = v127 + *(void *)(v7 + 72) * v19;
      uint64_t v18 = (uint64_t)v187;
      (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))(v187, v128, a5);
      uint64_t countAndFlagsBits = v19 + 1;
      if (__OFADD__(v19, 1LL)) {
        break;
      }
      unint64_t v5 = *(void *)(v7 + 32);
      ((void (*)(char *, uint64_t, uint64_t))v5)(v23, v18, a5);
      if ((v44 & 1) != 0) {
        goto LABEL_108;
      }
      uint64_t v18 = v194;
      unint64_t v44 = v195;
      unint64_t v131 = HIBYTE(v195) & 0xF;
      if ((v195 & 0x2000000000000000LL) != 0) {
        unint64_t v132 = HIBYTE(v195) & 0xF;
      }
      else {
        unint64_t v132 = v194 & 0xFFFFFFFFFFFFLL;
      }
      if (!v132 && (v194 & ~v195 & 0x2000000000000000LL) == 0)
      {
        swift_bridgeObjectRelease(v195);
        unint64_t v194 = 8236LL;
        unint64_t v165 = 0xE200000000000000LL;
        goto LABEL_148;
      }

      if ((v195 & 0x2000000000000000LL) != 0 && v131 <= 0xD)
      {
        unint64_t v133 = 8 * (HIBYTE(v195) & 7);
        uint64_t v134 = (-255LL << v133) - 1;
        uint64_t v135 = 44LL << v133;
        char v136 = v131 + 1;
        if (v131 >= 8)
        {
          uint64_t v137 = v135 | v134 & v195;
LABEL_142:
          uint64_t v164 = (32LL << (8 * (v136 & 7u))) | ((-255LL << (8 * (v136 & 7u))) - 1) & v137;
        }

        else
        {
          uint64_t v18 = v135 | v134 & v194;
          if (v131 == 7)
          {
            char v136 = 8;
            uint64_t v137 = v195;
            goto LABEL_142;
          }

          uint64_t v18 = (32LL << (8 * (v136 & 7u))) | ((-255LL << (8 * (v136 & 7u))) - 1) & v18;
          uint64_t v164 = v195;
        }

        swift_bridgeObjectRelease(v195);
        swift_bridgeObjectRelease(0xE200000000000000LL);
        unint64_t v166 = 0xE000000000000000LL;
        if (v18 & 0x8080808080808080LL | v164 & 0x80808080808080LL) {
          unint64_t v166 = 0xA000000000000000LL;
        }
        unint64_t v165 = (v166 & 0xFF00000000000000LL | (v131 << 56) | v164 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000LL;
        unint64_t v194 = v18;
LABEL_148:
        unint64_t v195 = v165;
LABEL_149:
        uint64_t v7 = v183;
        goto LABEL_107;
      }

      swift_bridgeObjectRetain_n(0xE200000000000000LL, 6LL, v129, v130);
      if ((v44 & 0x1000000000000000LL) != 0) {
        unint64_t v132 = String.UTF8View._foreignCount()();
      }
      BOOL v57 = __OFADD__(v132, 2LL);
      int64_t v138 = v132 + 2;
      uint64_t v7 = v183;
      if (v57) {
        goto LABEL_162;
      }
      if ((v18 & ~v44 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v44 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v139 = _StringGuts.nativeUnusedCapacity.getter(v18, v44);
        if ((v140 & 1) != 0) {
          goto LABEL_173;
        }
        BOOL v142 = (v44 & 0x2000000000000000LL) == 0 && v139 > 1;
        if (v138 <= 15 && !v142)
        {
LABEL_137:
          swift_bridgeObjectRelease_n(0xE200000000000000LL, 5LL);
          swift_bridgeObjectRetain(v44, v143, v144, v145);
          unint64_t v146 = _StringGuts._convertedToSmall()(v18, v44);
          unint64_t v148 = v147;
          swift_bridgeObjectRelease(v44);
          v149._unint64_t rawBits = 1LL;
          v150._unint64_t rawBits = 131073LL;
          v151._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v149, v150, 0x202CuLL, 0xE200000000000000LL);
          if (v151._rawBits < 0x10000) {
            v151._rawBits |= 3;
          }
          unint64_t v153 = specialized String.init(_:)(v151, v152, 0x202CuLL, 0xE200000000000000LL);
          unint64_t v155 = v154;
          swift_bridgeObjectRelease(0xE200000000000000LL);
          unint64_t v156 = _StringGuts._convertedToSmall()(v153, v155);
          unint64_t v158 = v157;
          swift_bridgeObjectRelease(v155);
          unint64_t v159 = specialized _SmallString.init(_:appending:)(v146, v148, v156, v158);
          if ((v161 & 1) != 0) {
            goto LABEL_172;
          }
          unint64_t v162 = v159;
          unint64_t v163 = v160;
          swift_bridgeObjectRelease(v44);
          swift_bridgeObjectRelease(0xE200000000000000LL);
          unint64_t v194 = v162;
          unint64_t v195 = v163;
          unint64_t object = v181;
          uint64_t v52 = v182;
          goto LABEL_149;
        }
      }

      else if (v138 <= 15)
      {
        goto LABEL_137;
      }

      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v138, 2LL);
      swift_bridgeObjectRelease_n(0xE200000000000000LL, 6LL);
      __int128 v193 = v180;
      unint64_t v122 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 2LL, (uint64_t)&v193, 2LL);
      _StringGuts.appendInPlace(_:isASCII:)(v122, v123, 1);
      swift_bridgeObjectRelease(0xE200000000000000LL);
LABEL_107:
      uint64_t v23 = v184;
LABEL_108:
      uint64_t v124 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
      inited = swift_initStackObject(v124, v192);
      *((_OWORD *)inited + 1) = v185;
      inited[7] = a5;
      boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
      ((void (*)(void *, char *, uint64_t))v5)(boxed_opaque_existential_0Tm, v23, a5);
      specialized _debugPrint<A>(_:separator:terminator:to:)( (uint64_t)inited,  0x20uLL,  0xE100000000000000LL,  0LL,  0xE000000000000000LL,  (uint64_t *)&v194);
      swift_bridgeObjectRelease((uint64_t)inited);
      swift_bridgeObjectRelease(0xE000000000000000LL);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      unint64_t v44 = 0LL;
      ++v19;
      if (countAndFlagsBits == v186) {
        goto LABEL_96;
      }
    }

    __break(1u);
LABEL_162:
    __break(1u);
LABEL_163:
    swift_bridgeObjectRetain_n(object, 5LL, v54, v55);
    v171._unint64_t rawBits = 1LL;
    v172._unint64_t rawBits = (v5 << 16) | 1;
    v173._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v171, v172, countAndFlagsBits, object);
    if (v173._rawBits < 0x10000) {
      v173._rawBits |= 3;
    }
    Swift::Int v56 = specialized Collection.count.getter(v173, v174, countAndFlagsBits, object);
    swift_bridgeObjectRelease(object);
    if ((v44 & 0x1000000000000000LL) != 0) {
      goto LABEL_166;
    }
LABEL_38:
    BOOL v57 = __OFADD__(v52, v56);
    int64_t v58 = v52 + v56;
    if (!v57) {
      goto LABEL_39;
    }
LABEL_168:
    __break(1u);
LABEL_169:
    int64_t v21 = String.UTF8View._foreignCount()();
LABEL_8:
    uint64_t v23 = v184;
    if ((v18 & ~v19 & 0x2000000000000000LL) == 0
      || !swift_isUniquelyReferenced_nonNull_native(v19 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v21 <= 15) {
        goto LABEL_13;
      }
      goto LABEL_21;
    }

    unint64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v18, v19);
    if ((v25 & 1) != 0)
    {
LABEL_173:
      unint64_t v177 = 258LL;
      goto LABEL_174;
    }

    if (v21 <= 15 && (v24 & 0x8000000000000000LL) != 0)
    {
LABEL_13:
      swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
      swift_bridgeObjectRetain(v19, v26, v27, v28);
      unint64_t v5 = _StringGuts._convertedToSmall()(v18, v19);
      unint64_t v30 = v29;
      swift_bridgeObjectRelease(v19);
      v31._unint64_t rawBits = 1LL;
      v32._unint64_t rawBits = 1LL;
      v33._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v31, v32, 0LL, 0xE000000000000000LL);
      if (v33._rawBits < 0x10000) {
        v33._rawBits |= 3;
      }
      unint64_t v35 = specialized String.init(_:)(v33, v34, 0LL, 0xE000000000000000LL);
      unint64_t v37 = v36;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      unint64_t v38 = _StringGuts._convertedToSmall()(v35, v37);
      unint64_t v40 = v39;
      swift_bridgeObjectRelease(v37);
      unint64_t v41 = specialized _SmallString.init(_:appending:)(v5, v30, v38, v40);
      if ((v43 & 1) == 0)
      {
        uint64_t v18 = v41;
        unint64_t v44 = v42;
        swift_bridgeObjectRelease(v19);
        swift_bridgeObjectRelease(0xE000000000000000LL);
        *(void *)&__int128 v193 = v18;
        goto LABEL_23;
      }

              id v101 = (v113 - 1) & v113;
              unint64_t v111 = __clz(__rbit64(v113)) + (v109 << 6);
              if (!v103) {
                goto LABEL_77;
              }
LABEL_66:
              uint64_t v112 = *(void **)(v104 + 8 * v111);
              swift_unknownObjectRetain(v112, v105, v106, v107);
            }

            if (v108 == 0x1000000000000000LL) {
              goto LABEL_95;
            }
            v138[v108] = v112;
            swift_unknownObjectRelease(v112);
            if ((id *)++v108 == v140)
            {
              swift_release(v103);
              unint64_t v122 = (uint64_t)v139;
              goto LABEL_90;
            }

            continue;
          }
        }
      }

      else
      {
        unint64_t v92 = v124;
        (*(void (**)(id *, id *, uint64_t *))(v133 + 32))(v124, v8, v5);
        char v86 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v92, v5, v93, v94);
        if (v19 == (id *)0x1000000000000000LL) {
          goto LABEL_60;
        }
      }

    uint64_t v27 = v54;
LABEL_77:
    v106._unint64_t rawBits = 1LL;
    v107._unint64_t rawBits = 65537LL;
    v108._unint64_t rawBits = _StringGuts.validateScalarRange(_:)(v106, v107, 0x5DuLL, 0xE100000000000000LL);
    if (v108._rawBits < 0x10000) {
      v108._rawBits |= 3;
    }
    uint64_t v64 = specialized String.init(_:)(v108, v109, 0x5DuLL, 0xE100000000000000LL);
    unint64_t v95 = v110;
    swift_bridgeObjectRelease(0xE100000000000000LL);
    if ((v95 & 0x2000000000000000LL) == 0) {
      goto LABEL_108;
    }
    swift_bridgeObjectRelease(v95);
LABEL_81:
    unint64_t v111 = HIBYTE(v27) & 0xF;
    uint64_t v112 = HIBYTE(v95) & 0xF;
    if ((unint64_t)(v112 + v111) <= 0xF)
    {
      if (v112)
      {
        uint64_t v113 = 0;
        unint64_t v114 = 0LL;
        do
        {
          uint64_t v115 = v111 + v114;
          unint64_t v116 = v114 + 1;
          if (v114 >= 8) {
            uint64_t v117 = v95;
          }
          else {
            uint64_t v117 = v64;
          }
          uint64_t v118 = v117 >> (v113 & 0x38);
          unint64_t v119 = (8 * v111 + v113) & 0x38;
          unint64_t v120 = (-255LL << v119) - 1;
          uint64_t v121 = (unint64_t)v118 << v119;
          unint64_t v122 = v121 | v120 & v27;
          size_t v123 = v121 | v120 & v48;
          if (v115 < 8) {
            unint64_t v48 = v123;
          }
          else {
            uint64_t v27 = v122;
          }
          v113 += 8;
          unint64_t v114 = v116;
        }

        while (v112 != v116);
      }

      swift_bridgeObjectRelease(v54);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      return v48;
    }

          *v635 = v171;
          return result;
        }

              unint64_t v160 = 0;
              v254 = 1LL;
              v255 = v325;
              v256 = v326;
              v257 = v291;
              v258 = v290;
LABEL_89:
              (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v255 + 56))(v258, v254, 1LL, v343);
              (*(void (**)(uint64_t, char *, uint64_t))(*(void *)(v257 - 8) + 32LL))(v256, v258, v257);
              return v160 & 1;
            }

            if (v260 <= 64)
            {
              v271 = v311;
              v272 = v341;
              v273 = v312;
              v274 = swift_getAssociatedConformanceWitness( (uint64_t)v311,  (uint64_t)v341,  v312,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v275 = v313;
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v274 + 8))( &unk_18180BE68,  256LL,  v273,  v274);
              v276 = v327;
              (*((void (**)(char *, unint64_t *, const char *))v271 + 3))(v275, v272, v271);
              v277 = swift_getAssociatedConformanceWitness( v289,  v245,  (uint64_t)v272,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
              v278 = v292;
              LOBYTE(v273) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v277 + 32))( v292,  v276,  v272,  v277);
              v279 = *(void (**)(char *, unint64_t *))(v328 + 8);
              v279(v276, v272);
              v242(v288, v278, v272);
              if ((v273 & 1) != 0)
              {
                v280 = v288;
                v281 = v341;
                v282 = (*(uint64_t (**)(unint64_t *, unint64_t))(v246 + 120))(v341, v246);
                v279(v280, v281);
                if (!v282) {
                  goto LABEL_88;
                }
              }

              else
              {
                v279(v288, v341);
              }

              goto LABEL_76;
            }
          }

          v344 = 0LL;
          v261 = v327;
          v262 = v341;
          (*(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v246 + 96))( &v344,  &type metadata for Int,  v333,  v341,  v246);
          v263 = swift_getAssociatedConformanceWitness( v289,  v245,  (uint64_t)v262,  (uint64_t)&protocol requirements base descriptor for Numeric,  (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
          v264 = v292;
          v265 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(v263 + 8) + 8LL))( v292,  v261,  v262);
          v266 = *(void (**)(char *, unint64_t *))(v328 + 8);
          v266(v261, v262);
          v267 = v264;
          goto LABEL_87;
        }

              Swift::String v11 = 1;
              goto LABEL_82;
            }
          }

          Swift::String v11 = 0;
          goto LABEL_82;
        }
      }

  if (v30 == 1) {
    goto LABEL_77;
  }
  return v29;
}

      unint64_t v41 = 0LL;
LABEL_77:
      unint64_t v42 = *((unsigned __int8 *)v41 + 18);
      if (v42 != 1)
      {
        if (v42 != 5 || *((_DWORD *)v41 + 2) != 1)
        {
          *(_DWORD *)a4 = 10;
          *(void *)(a4 + 8) = v41;
          *(_DWORD *)(a4 + 16) = 321;
          return;
        }

        unint64_t v41 = *(swift::Demangle::__runtime::Node **)v41;
      }

      if (*(_DWORD *)a4) {
        return;
      }
      unint64_t v36 = v37 + 1;
      if (v35 == (_DWORD)v37 + 1) {
        goto LABEL_17;
      }
    }

    if ((_DWORD)v38 != 2) {
      goto LABEL_76;
    }
    unint64_t v38 = 2LL;
LABEL_71:
    if (v38 > v37) {
      goto LABEL_72;
    }
    goto LABEL_76;
  }

        uint64_t v47 = 0LL;
        goto LABEL_77;
      }

      unint64_t v41 = 119;
      unint64_t v42 = 1;
    }

    else
    {
      unint64_t v41 = 1162;
      unint64_t v42 = 6;
    }

LABEL_172:
      unint64_t v177 = 266LL;
LABEL_174:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StringGutsRangeReplaceable.swift",  38LL,  2,  v177,  0);
    }

          ((void (*)(uint64_t *__return_ptr, unint64_t, unint64_t))v298)(&v305, v41, v299);
          Swift::String::Index v34 = v306;
          unint64_t v163 = v296;
          if (!v306) {
            goto LABEL_285;
          }
        }

        unint64_t v37 = v297;
        if ((a2 & 0x2000000000000000LL) == 0) {
          goto LABEL_184;
        }
        unint64_t v41 = v164 + v295;
        if (v164 + v295 <= 0xF)
        {
          if (v295)
          {
            v244 = 0LL;
            v245 = 0LL;
            v246 = v308;
            do
            {
              v247 = v164 + v245;
              uint64_t v97 = v245++ >= 8;
              if (v97) {
                v248 = a2;
              }
              else {
                v248 = v43;
              }
              v249 = (8 * v164 + v244) & 0x38;
              v250 = (-255LL << v249) - 1;
              v251 = (unint64_t)(v248 >> (v244 & 0x38)) << v249;
              v252 = v251 | v250 & v246;
              v253 = v251 | v250 & v39;
              if (v247 < 8) {
                unint64_t v39 = v253;
              }
              else {
                v246 = v252;
              }
              v244 += 8LL;
            }

            while (v163 != v244);
          }

          else
          {
            v246 = v308;
          }

          swift_bridgeObjectRelease(v308);
          v259 = 0xA000000000000000LL;
          if (!(v39 & 0x8080808080808080LL | v246 & 0x80808080808080LL)) {
            v259 = 0xE000000000000000LL;
          }
          v307 = v39;
          v308 = v259 & 0xFF00000000000000LL | (v41 << 56) | v246 & 0xFFFFFFFFFFFFFFLL;
          goto LABEL_208;
        }

        *((void *)this + 1) = v8 + 24;
        *(_WORD *)(v8 + 16) = 232;
        *(_BYTE *)(v8 + 18) = 0;
        v145 = (unsigned int *)v8;
        unint64_t v146 = (swift::Demangle::__runtime::Node *)v21;
        goto LABEL_173;
      case 'z':
        if (v9 >= v6) {
          return 0LL;
        }
        *((void *)this + 9) = v5 + 2;
        uint64_t v113 = *(char *)(v10 + v9);
        if (v113 == 67)
        {
          uint64_t v18 = 22;
          unint64_t v73 = 1LL;
          return (int8x16_t *)swift::Demangle::__runtime::Demangler::popFunctionType(this, v18, v73, a4, a5);
        }

        if (v113 == 66)
        {
          uint64_t v18 = 165;
          unint64_t v73 = 1LL;
          return (int8x16_t *)swift::Demangle::__runtime::Demangler::popFunctionType(this, v18, v73, a4, a5);
        }

        break;
      default:
        return (int8x16_t *)v8;
    }
  }

  return 0LL;
}

LABEL_96:
  uint64_t v118 = v194;
  unint64_t v119 = HIBYTE(v195) & 0xF;
  unint64_t v120 = v194 & 0xFFFFFFFFFFFFLL;
  if ((v195 & 0x2000000000000000LL) != 0) {
    unint64_t v120 = HIBYTE(v195) & 0xF;
  }
  if (v120 || (v194 & ~v195 & 0x2000000000000000LL) != 0)
  {
    uint64_t v121 = v179;
    if ((v195 & 0x2000000000000000LL) != 0 && v119 <= 0xD)
    {
      if (v119 < 8)
      {
        uint64_t v118 = (93LL << (8 * (HIBYTE(v195) & 7u))) | ((-255LL << (8 * (HIBYTE(v195) & 7u))) - 1) & v194;
        if (v119 != 7) {
          uint64_t v118 = (41LL << (8 * ((v119 + 1) & 7))) | ((-255LL << (8 * ((v119 + 1) & 7))) - 1) & v118;
        }
      }

      swift_bridgeObjectRelease(v195);
      swift_bridgeObjectRelease(v121);
      swift_bridgeObjectRelease(0xE200000000000000LL);
    }

    else
    {
      _StringGuts.append(_:)(10589LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      swift_bridgeObjectRelease(v121);
      return v194;
    }
  }

  else
  {
    swift_bridgeObjectRelease(v195);
    swift_bridgeObjectRelease(v179);
    return 10589LL;
  }

  return v118;
}

        unint64_t v38 = 1LL;
LABEL_97:
        v29 |= v38 << 8;
        goto LABEL_10;
      }

      uint64_t v104 = specialized _SmallString.init(_:appending:)(v43, (unint64_t)v12, v30, v91);
      if ((v105 & 1) == 0)
      {
        char v43 = v104;
        swift_bridgeObjectRelease(v3);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        return v43;
      }

  __break(1u);
LABEL_97:
  __break(1u);
LABEL_98:
  __break(1u);
}

      uint64_t v103 = specialized _SmallString.init(_:appending:)(v42, (unint64_t)v12, v30, v90);
      if ((v104 & 1) == 0)
      {
        unint64_t v42 = v103;
        swift_bridgeObjectRelease(v2);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        return v42;
      }

  char v96 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v96);
  uint64_t v97 = specialized Collection.subscript.getter(v87, (uint64_t)v80, v79);
  uint64_t v102 = findInvalidRange #1 (_:) in validateUTF8(_:)(v97, v98, v99, v100);
  v373._uint64_t countAndFlagsBits = 0LL;
  v373._unint64_t object = (void *)0xE000000000000000LL;
  if (__OFADD__(v79, 15LL))
  {
LABEL_251:
    __break(1u);
    goto LABEL_252;
  }

  uint64_t v103 = v101;
  v353 = v13;
  v354 = v3;
  v355 = v2;
  _StringGuts.reserveCapacity(_:)(v79 + 15);
  while (1)
  {
    uint64_t v104 = specialized Collection.subscript.getter(v102, (uint64_t)v80, v79);
    uint64_t v108 = v373._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    uint64_t v46 = __OFADD__(v108, v79);
    unint64_t v109 = v108 + v79;
    if (v46)
    {
      __break(1u);
LABEL_246:
      __break(1u);
LABEL_247:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }

    unint64_t v110 = v104;
    if (__OFADD__(v109, 3LL)) {
      goto LABEL_246;
    }
    unint64_t v111 = v105;
    uint64_t v112 = v106;
    uint64_t v113 = v107;
    _StringGuts.reserveCapacity(_:)(v109 + 3);
    unint64_t v114 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v110, v111, v112, v113);
    _StringGuts.appendInPlace(_:isASCII:)(v114, v115, 0);
    v381 = 3LL;
    *(void *)&v376 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v376, &v381, &v373);
    unint64_t v116 = specialized Collection.subscript.getter(v103, (uint64_t)v80, v79);
    unint64_t v80 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v116, v117, v118, v119);
    unint64_t v79 = v120;
    uint64_t v121 = validateUTF8(_:)(v80, v120);
    if ((v77 & 1) == 0) {
      break;
    }
    uint64_t v102 = v121;
    uint64_t v103 = v76;
    if (!v79) {
      goto LABEL_113;
    }
  }

  _StringGuts.appendInPlace(_:isASCII:)((char *)v80, v79, 0);
LABEL_113:
  unint64_t object = (unint64_t)v373._object;
  uint64_t countAndFlagsBits = v373._countAndFlagsBits;
  uint64_t v2 = v355;
  uint64_t v3 = v354;
  uint64_t v13 = v353;
LABEL_143:
  v231 = v380;
  v232 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000LL) == 0) {
    v232 = v379 & 0xFFFFFFFFFFFFLL;
  }
  if (!v232 && (v379 & ~v380 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v380);
    v379 = countAndFlagsBits;
    v380 = object;
    goto LABEL_156;
  }

  if ((v380 & 0x2000000000000000LL) != 0)
  {
    if ((object & 0x2000000000000000LL) != 0)
    {
      v234 = specialized _SmallString.init(_:appending:)(v379, v380, countAndFlagsBits, object);
      if ((v77 & 1) != 0) {
        goto LABEL_154;
      }
      v235 = v234;
      v236 = v76;
      swift_bridgeObjectRelease(v231);
      swift_bridgeObjectRelease(object);
      v379 = v235;
      v380 = v236;
      unint64_t object = v236;
      uint64_t countAndFlagsBits = v235;
      goto LABEL_156;
    }

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( a1,  a2,  ArraySlice.description.getter);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance ArraySlice<A>( uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( a1,  a2,  ArraySlice.debugDescription.getter);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, void, void))
{
  return a3(*v3, v3[1], v3[2], v3[3], *(void *)(a1 + 16));
}

id ArraySlice._cPointerArgs()(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  return swift_unknownObjectRetain(a1, a2, a3, a4);
}

uint64_t _SliceBuffer.withUnsafeBufferPointer<A>(_:)( uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  if (__OFSUB__(a6 >> 1, a5))
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  if ((((a6 >> 1) - a5) & 0x8000000000000000LL) != 0) {
    goto LABEL_5;
  }
  return a1(a4 + *(void *)(*(void *)(a7 - 8) + 72LL) * a5);
}

void *$defer #1 <A><A1>() in ArraySlice.withUnsafeMutableBufferPointer<A>(_:)( void *result, uint64_t a2, uint64_t a3)
{
  if (*result) {
    BOOL v3 = *result == a2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3 || result[1] != a3) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed",  78LL,  2,  "Swift/ArraySlice.swift",  22LL,  2,  0x4EAuLL,  0);
  }
  return result;
}

uint64_t _SliceBuffer.replaceSubrange<A>(_:with:elementsOf:)( uint64_t a1, char *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  uint64_t v8 = v7;
  uint64_t v108 = (uint64_t)a4;
  uint64_t v14 = *(void *)(a5 + 16);
  uint64_t v105 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v16 = (char *)&v94 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v18,  v17,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v20 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v23 = (char *)&v94 - v22;
  uint64_t v24 = a6;
  uint64_t v104 = *(void *)(a6 - 8);
  uint64_t v25 = MEMORY[0x1895F8858](v21);
  unint64_t v29 = (char *)&v94 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v30 = &a2[-a1];
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_35;
  }

  uint64_t v103 = a3;
  uint64_t v31 = a3 - (void)v30;
  if (__OFSUB__(a3, v30))
  {
LABEL_35:
    __break(1u);
    goto LABEL_36;
  }

  uint64_t v107 = a2;
  uint64_t v32 = *(void *)(v8 + 16);
  uint64_t v33 = *(void *)(v8 + 24) >> 1;
  BOOL v34 = __OFSUB__(v33, v32);
  uint64_t v35 = v33 - v32;
  if (v34)
  {
LABEL_36:
    __break(1u);
LABEL_37:
    LODWORD(v92) = 0;
    unint64_t v91 = 14377LL;
    LOBYTE(v90) = 2;
    uint64_t v88 = "Division by zero";
    uint64_t v89 = 16LL;
    goto LABEL_52;
  }

  uint64_t v101 = v31;
  uint64_t v102 = v35;
  uint64_t v106 = v14;
  char v96 = v16;
  uint64_t v97 = v27;
  uint64_t v98 = v26;
  uint64_t v99 = v25;
  unint64_t v109 = a7;
  unint64_t v36 = *(void **)v8;
  uint64_t v37 = type metadata accessor for __ContiguousArrayStorageBase();
  id v41 = swift_unknownObjectRetain(v36, v38, v39, v40);
  unint64_t v42 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v41, v37);
  if (!v42)
  {
    swift_unknownObjectRelease(v36);
    unint64_t v42 = &_swiftEmptyArrayStorage;
  }

  uint64_t v43 = *(void *)(v105 + 72);
  if (!v43) {
    goto LABEL_37;
  }
  uint64_t v44 = v24;
  uint64_t v45 = *(void *)(v105 + 72);
  uint64_t v46 = (char *)v42 + ((*(unsigned __int8 *)(v105 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v105 + 80));
  uint64_t v47 = *(void *)(v8 + 8) + v43 * v32 - (void)v46;
  if (v45 == -1 && v47 == 0x8000000000000000LL)
  {
LABEL_51:
    LODWORD(v92) = 0;
    unint64_t v91 = 14384LL;
    LOBYTE(v90) = 2;
    uint64_t v88 = "Division results in an overflow";
    uint64_t v89 = 31LL;
LABEL_52:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  v88,  v89,  2,  "Swift/IntegerTypes.swift",  24LL,  v90,  v91,  v92);
  }

  uint64_t v49 = a1 - v32;
  if (__OFSUB__(a1, v32))
  {
    __break(1u);
    goto LABEL_39;
  }

  uint64_t v50 = v47 / v45;
  uint64_t v51 = v49 + v50;
  if (__OFADD__(v49, v50))
  {
LABEL_39:
    __break(1u);
    goto LABEL_40;
  }

  uint64_t v52 = &v107[-v32];
  if (__OFSUB__(v107, v32))
  {
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }

  uint64_t v100 = v8;
  uint64_t v53 = &v52[v50];
  if (__OFADD__(v52, v50))
  {
LABEL_41:
    __break(1u);
LABEL_42:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

  uint64_t v54 = v104;
  (*(void (**)(char *, uint64_t, uint64_t))(v104 + 16))(v29, v108, v44);
  uint64_t v55 = (uint64_t)&v53[-v51];
  if (__OFSUB__(v53, v51))
  {
    __break(1u);
LABEL_44:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.deinitialize with negative count",  53LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x493uLL,  0);
  }

  if (v55 < 0) {
    goto LABEL_44;
  }
  unint64_t v56 = (unint64_t)&v46[v51 * v45];
  uint64_t v104 = *(void *)(v54 + 8);
  ((void (*)(uint64_t, uint64_t))v104)(v108, v44);
  swift_arrayDestroy(v56, v55, v106);
  uint64_t v57 = v103;
  BOOL v34 = __OFSUB__(v103, v55);
  uint64_t v58 = v103 - v55;
  if (v34)
  {
    __break(1u);
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }

  unint64_t v59 = v46;
  uint64_t v60 = v45 * v103;
  unint64_t v95 = v56 + v45 * v103;
  if (v58)
  {
    char v61 = v42[2];
    if (__OFSUB__(v61, v53))
    {
      __break(1u);
    }

    else
    {
      UnsafeMutablePointer.moveInitialize(from:count:)( &v59[(void)v53 * v45],  (char *)v61 - v53,  (char *)(v56 + v45 * v103),  v106);
      char v62 = v42[2];
      BOOL v34 = __OFADD__(v62, v58);
      size_t v63 = (__objc2_class *)((char *)v62 + v58);
      if (!v34)
      {
        v42[2] = v63;
        goto LABEL_23;
      }
    }

    __break(1u);
    goto LABEL_51;
  }

uint64_t static ArraySlice<A>.== infix(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v83 = a6;
  uint64_t v84 = a2;
  uint64_t v14 = *(void *)(a9 - 8);
  MEMORY[0x1895F8858](a1);
  unint64_t v82 = &v63[-((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  uint64_t v18 = type metadata accessor for Optional((const char *)0xFF, a9, v16, v17);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, v18, v18, 0LL, 0LL);
  uint64_t v20 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v21 = MEMORY[0x1895F8858](v20);
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = &v63[-v24];
  uint64_t result = MEMORY[0x1895F8858](v23);
  BOOL v34 = &v63[-v30];
  int64_t v35 = a4 >> 1;
  unint64_t v36 = (a4 >> 1) - v31;
  if (__OFSUB__(a4 >> 1, v31))
  {
    __break(1u);
    goto LABEL_36;
  }

  unint64_t v37 = a8 >> 1;
  if (__OFSUB__(a8 >> 1, a7))
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }

  if (v36 != (a8 >> 1) - a7) {
    return 0LL;
  }
  if (!v36) {
    return 1LL;
  }
  uint64_t v38 = *(void *)(v14 + 72);
  uint64_t v39 = v84 + v38 * v31;
  if (v39 == v83 + v38 * a7) {
    return 1LL;
  }
  uint64_t v70 = v28;
  uint64_t v71 = v38;
  uint64_t v77 = v37;
  unint64_t v78 = v33;
  uint64_t v79 = v29;
  uint64_t v80 = v27;
  uint64_t v66 = v32;
  uint64_t v74 = result;
  uint64_t v76 = a7;
  uint64_t v69 = v31;
  if (v35 != v31)
  {
    uint64_t v42 = a1;
    uint64_t v43 = v31;
    specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)(v31, v42, v84, v31, a4);
    uint64_t result = (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t))(v14 + 16))(v34, v39, a9);
    uint64_t v41 = v43 + 1;
    if (!__OFADD__(v43, 1LL))
    {
      uint64_t v81 = *(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v14 + 56);
      v81(v34, 0LL, 1LL, a9);
      goto LABEL_10;
    }

LABEL_37:
    __break(1u);
    return result;
  }

  uint64_t v40 = v31;
  uint64_t v81 = *(void (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v14 + 56);
  v81(&v63[-v30], 1LL, 1LL, a9);
  uint64_t v41 = v40;
LABEL_10:
  uint64_t v44 = v80;
  uint64_t v75 = *(void (**)(_BYTE *, _BYTE *, uint64_t))(v80 + 16);
  v75(v25, v34, v18);
  uint64_t v45 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v14 + 48);
  unsigned int v46 = v45((uint64_t)v25, 1LL, a9);
  uint64_t v47 = *(void (**)(_BYTE *, uint64_t))(v44 + 8);
  if (v46 == 1)
  {
LABEL_11:
    v47(v34, v18);
    v47(v25, v18);
    return 1LL;
  }

  uint64_t v65 = a10;
  uint64_t v48 = v76;
  unint64_t v73 = v45;
  uint64_t v67 = v47;
  while (1)
  {
    v47(v25, v18);
    if (v48 == v77)
    {
      uint64_t v72 = v41;
      uint64_t v49 = 1LL;
      uint64_t v68 = v77;
      uint64_t v50 = v79;
      uint64_t v51 = v81;
    }

    else
    {
      uint64_t v51 = v81;
      if (v48 < v76 || v48 >= v77) {
LABEL_31:
      }
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
      uint64_t v72 = v41;
      (*(void (**)(_BYTE *, uint64_t, uint64_t))(v14 + 16))(v79, v83 + v48 * v71, a9);
      uint64_t v50 = v79;
      uint64_t v49 = 0LL;
      uint64_t v68 = v48 + 1;
    }

    uint64_t v81 = v51;
    v51(v50, v49, 1LL, a9);
    uint64_t v52 = v78;
    uint64_t v53 = &v78[*(int *)(v74 + 48)];
    uint64_t v54 = *(void (**)(uint64_t, _BYTE *, uint64_t))(v80 + 32);
    v54((uint64_t)v78, v34, v18);
    v54((uint64_t)v53, v50, v18);
    uint64_t v55 = v73;
    if (v73((uint64_t)v52, 1LL, a9) == 1)
    {
      uint64_t v47 = v67;
      v67(v78, v18);
      goto LABEL_24;
    }

    unint64_t v56 = v55;
    uint64_t v57 = v70;
    v75(v70, v52, v18);
    uint64_t v58 = v82;
    (*(void (**)(_BYTE *, _BYTE *, uint64_t))(v14 + 32))(v82, v53, a9);
    int v64 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(v65 + 8))(v57, v58, a9);
    unint64_t v59 = *(void (**)(_BYTE *, uint64_t))(v14 + 8);
    v59(v58, a9);
    v59(v57, a9);
    uint64_t v47 = v67;
    v67(v52, v18);
    uint64_t v55 = v73;
    if ((v64 & 1) == 0) {
      return 0LL;
    }
LABEL_24:
    uint64_t v60 = v72;
    if (v72 == v35)
    {
      v81(v34, 1LL, 1LL, a9);
      uint64_t v41 = v35;
    }

    else
    {
      char v61 = v81;
      if (v72 < v69 || v72 >= v35) {
        goto LABEL_31;
      }
      (*(void (**)(_BYTE *, uint64_t, uint64_t))(v14 + 16))(v34, v84 + v72 * v71, a9);
      uint64_t v41 = v60 + 1;
      v61(v34, 0LL, 1LL, a9);
    }

    v75(v25, v34, v18);
    unsigned int v62 = v55((uint64_t)v25, 1LL, a9);
    uint64_t v48 = v68;
    if (v62 == 1) {
      goto LABEL_11;
    }
  }

  (*(void (**)(_BYTE *, uint64_t))(v14 + 8))(v57, a9);
LABEL_33:
  (*(void (**)(_BYTE *, uint64_t))(v66 + 8))(v78, v74);
  return 0LL;
}

    if ((v15 & 0x7F800000000LL) == 0)
    {
      unint64_t v5 = 0;
      unint64_t v4 = v18;
      goto LABEL_70;
    }

  __break(1u);
  return result;
}

      v264 = v775;
      (*(void (**)(uint64_t, uint64_t))(v775 + 120))(v180, v775);
      ((void (*)(uint64_t, uint64_t))v750)(v180, v264);
      v265 = (uint64_t (*)(uint64_t, char **))v762;
      v266 = ((uint64_t (*)(uint64_t, char **))v762)(v167, v166);
      v267 = v168;
      if (((v266 ^ ((unsigned int (*)(unint64_t *, uint64_t))v769)(v125, v168)) & 1) != 0)
      {
        v268 = v265(v167, v166);
        v269 = ((uint64_t (*)(uint64_t, char **))v761)(v167, v166);
        v270 = ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v168);
        if ((v268 & 1) != 0)
        {
          v271 = v777;
          if (v270 >= v269)
          {
            v318 = (void (**)(char *, uint64_t, const char *))v724;
            v319 = v722;
            v320 = swift_getAssociatedConformanceWitness( (uint64_t)v724,  v167,  v722,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v321 = v723;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v320 + 8))( &unk_18180BE68,  256LL,  v319,  v320);
            v322 = v770;
            v318[3](v321, v167, (const char *)v318);
            v323 = v758;
            LOBYTE(v318) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*((void *)v166[4] + 1) + 16LL))( v758,  v322,  v167);
            v324 = v772;
            v325 = *(void (**)(char *, uint64_t))(v772 + 8);
            v325(v322, v167);
            v326 = *(void (**)(char *, uint64_t, uint64_t))(v324 + 32);
            v327 = v693;
            v326(v693, v323, v167);
            v328 = v691;
            (*(void (**)(char *, unint64_t, unint64_t *))(v271 + 16))(v691, v781, v125);
            v329 = v776;
            if ((v318 & 1) != 0)
            {
              (*(void (**)(char *, unint64_t *))(v271 + 8))(v328, v125);
              v325(v327, v167);
              v272 = v271;
              v282 = v781;
            }

            else
            {
              v267 = v773;
              (*(void (**)(char *, uint64_t, char **, unint64_t *, uint64_t))(v773 + 96))( v327,  v167,  v166,  v125,  v773);
              v393 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v267 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v329,  v328,  v125);
              v394 = *(void (**)(char *, unint64_t *))(v271 + 8);
              v394(v329, v125);
              v394(v328, v125);
              v272 = v271;
              v282 = v781;
              if ((v393 & 1) == 0) {
                goto LABEL_83;
              }
            }
          }

          else
          {
            v272 = v777;
            v273 = v776;
            v274 = v781;
            (*(void (**)(char *, unint64_t, unint64_t *))(v777 + 16))(v776, v781, v125);
            v275 = v770;
            v276 = v773;
            ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v166[12])( v273,  v125,  v773,  v167,  v166);
            v277 = v758;
            v278 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*((void *)v166[4] + 1) + 16LL))( v758,  v275,  v167);
            v279 = *(void (**)(char *, uint64_t))(v772 + 8);
            v280 = v275;
            v267 = v276;
            v279(v280, v167);
            v281 = v277;
            v282 = v274;
            v279((char *)v281, v167);
            if ((v278 & 1) == 0) {
              goto LABEL_83;
            }
          }

    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "invalid unsafeDowncast",  22LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x10DuLL,  0);
  }

  BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v6);
  int64_t v35 = *v6;
  if ((a3 & 1) != 0)
  {
    uint64_t v66 = v17;
    size_t v63 = isUniquelyReferenced_nonNull_native;
    if (v10 >= 0) {
      unint64_t v37 = v10 & 0xFFFFFFFFFFFFFF8LL;
    }
    else {
      unint64_t v37 = v10;
    }
    swift_bridgeObjectRetain(v35, v32, v33, v34);
    outlined copy of [A : B].Index._Variant<A, B>(v10, a2, 1LL, v38);
    uint64_t v39 = type metadata accessor for __CocoaSet.Index.Storage();
    if (!swift_dynamicCastClass(v37, v39)) {
      goto LABEL_37;
    }
    if (!swift_dynamicCastClass(v37, v39)) {
      goto LABEL_37;
    }
    uint64_t v43 = *(void *)(v37 + 24);
    if (*(void *)(v43 + 16) <= a2) {
      goto LABEL_36;
    }
    uint64_t v60 = a5;
    unsigned int v62 = (unint64_t *)v6;
    uint64_t v44 = *(void **)(v43 + 8 * a2 + 24);
    swift_unknownObjectRetain(v44, v40, v41, v42);
    outlined consume of [A : B].Index._Variant<A, B>(v10, a2, 1);
    _forceBridgeFromObjectiveC<A>(_:_:)(v44, v12, v45, v66);
    swift_unknownObjectRelease(v44);
    unsigned int v46 = *(void *)(v35 + 40);
    char v61 = v7;
    uint64_t v47 = *(void *)(v7 + 24);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(v47 + 32))(v46, v12, v47);
    uint64_t v49 = -1LL << *(_BYTE *)(v35 + 32);
    uint64_t v10 = v48 & ~v49;
    int v64 = v35 + 56;
    uint64_t v65 = v35;
    if (((*(void *)(v35 + 56 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v10) & 1) == 0)
    {
      (*(void (**)(char *, char *))(v67 + 8))(v66, v12);
LABEL_31:
      unint64_t v36 = 287LL;
LABEL_18:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Attempting to access Set elements using an invalid index",  56LL,  2,  "Swift/NativeSet.swift",  21LL,  2,  v36,  0);
    }

    uint64_t v50 = ~v49;
    uint64_t v51 = *(void *)(v47 + 8);
    uint64_t v52 = *(uint64_t (**)(char *, char *, char *, uint64_t))(v51 + 8);
    uint64_t v53 = *(void *)(v67 + 72);
    uint64_t v54 = *(void (**)(char *, uint64_t, char *))(v67 + 16);
    while (1)
    {
      v54(v15, *(void *)(v65 + 48) + v53 * v10, v12);
      uint64_t v55 = v52(v15, v66, v12, v51);
      unint64_t v56 = *(void (**)(char *, char *))(v67 + 8);
      v56(v15, v12);
      if ((v55 & 1) != 0) {
        break;
      }
      uint64_t v10 = (v10 + 1) & v50;
      if (((*(void *)(v64 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v10) & 1) == 0)
      {
        v56(v66, v12);
        goto LABEL_31;
      }
    }

    swift_bridgeObjectRelease(v65);
    v56(v66, v12);
    uint64_t v7 = v61;
    uint64_t v6 = (uint64_t *)v62;
    int64_t v35 = *v62;
    a5 = v60;
    LOBYTE(isUniquelyReferenced_nonNull_native) = v63;
  }

  else if (v10 < 0 {
         || 1LL << *(_BYTE *)(v35 + 32) <= v10
  }
         || ((*(void *)(v35 + (((unint64_t)v10 >> 3) & 0xFFFFFFFFFFFFF8LL) + 56) >> v10) & 1) == 0
         || *(_DWORD *)(v35 + 36) != (_DWORD)a2)
  {
    unint64_t v36 = 266LL;
    goto LABEL_18;
  }

  uint64_t v68 = v35;
  *uint64_t v6 = 0x8000000000000000LL;
  if (!isUniquelyReferenced_nonNull_native)
  {
    type metadata accessor for _NativeSet(0LL, (uint64_t)v12, *(void *)(v7 + 24), (uint64_t)v34);
    _NativeSet.copy()();
    int64_t v35 = v68;
  }

  (*(void (**)(uint64_t, uint64_t, char *))(v67 + 32))( a5,  *(void *)(v35 + 48) + *(void *)(v67 + 72) * v10,  v12);
  type metadata accessor for _NativeSet(0LL, (uint64_t)v12, *(void *)(v7 + 24), v57);
  _NativeSet._delete(at:)((Swift::_HashTable::Bucket)v10);
  uint64_t v58 = *v6;
  *uint64_t v6 = v35;
  swift_bridgeObjectRelease(v58);
}

    uint64_t v26 = 1LL;
LABEL_38:
    unint64_t rawBits = (rawBits + (v26 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
LABEL_12:
    ++v17;
  }

  while (v14 != rawBits >> 14);
  swift_bridgeObjectRelease_n(a2, 14LL);
  if (v34) {
    uint64_t v28 = 7LL;
  }
  else {
    uint64_t v28 = 11LL;
  }
  if ((v17 & 0x3F) == 0)
  {
    unint64_t v29 = *(__objc2_class ***)(v4 + 24);
    uint64_t v30 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v29);
    *(void *)(v4 + 24) = v29;
    if (!v30)
    {
      unint64_t v29 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v29[2]->isa + 1,  1,  (uint64_t)v29);
      *(void *)(v4 + 24) = v29;
    }

    uint64_t v32 = (unint64_t)v29[2];
    uint64_t v31 = (unint64_t)v29[3];
    if (v32 >= v31 >> 1) {
      unint64_t v29 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v31 > 1),  v32 + 1,  1,  (uint64_t)v29);
    }
    v29[2] = (__objc2_class *)(v32 + 1);
    v29[v32 + 4] = (__objc2_class *)(v28 | (v7 << 16));
    *(void *)(v4 + 24) = v29;
  }

  if (a2) {
    *(void *)a1 = (int)(a2 - 1);
  }
}

  if (a2) {
    *(void *)a1 = (int)(a2 - 1);
  }
}

  if (a2) {
    *(void *)(a1 + 24) = (int)(a2 - 1);
  }
}

  operator delete(*(void **)(v34 - 96));
  if ((*(char *)(v34 - 105) & 0x80000000) == 0)
  {
LABEL_23:
    goto LABEL_39;
  }

  int64_t v35 = (unsigned int *)swift::Demangle::__runtime::Demangler::createWithChildren( this,  182,  (swift::Demangle::__runtime::Node *)v22,  v15,  (char *)v11);
  uint64_t v38 = v35;
  if (v20 && v35) {
    swift::Demangle::__runtime::Node::addChild(v35, (swift::Demangle::__runtime::Node *)v20, this, v36, v37);
  }
  return v38;
}

    uint64_t v28 = v16;
    if (v27 >= 2) {
      uint64_t v28 = *(swift::Demangle::__runtime::Node **)v16;
    }
    unint64_t v4 = (swift::Demangle::__runtime::Node *)*((void *)v28 + v26);
LABEL_42:
    if (*((_WORD *)v16 + 8) != 232)
    {
      uint64_t v13 = 2734;
      goto LABEL_58;
    }

    unint64_t v29 = *((unsigned __int8 *)v4 + 18);
    if (v29 != 1)
    {
      if (v29 != 5 || *((_DWORD *)v4 + 2) != 1)
      {
        uint64_t v13 = 114;
        uint64_t v14 = 10;
        goto LABEL_49;
      }

      unint64_t v4 = *(swift::Demangle::__runtime::Node **)v4;
    }

    uint64_t v14 = v26 + 1;
    if (*(_DWORD *)a4) {
      return this;
    }
  }

    uint64_t v7 = (uint64_t *)*v7;
  }

  return result;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return static ArraySlice<A>.== infix(_:_:)( *(void *)a1,  *(void *)(a1 + 8),  *(void *)(a1 + 16),  *(void *)(a1 + 24),  a5,  *(void *)(a2 + 8),  *(void *)(a2 + 16),  *(void *)(a2 + 24),  *(void *)(a3 + 16),  *(void *)(a4 - 8)) & 1;
}

void ArraySlice<A>.hash(into:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v19 = a3;
  uint64_t v11 = *(void *)(a6 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v15 = (char *)&v18 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int64_t v16 = v13 >> 1;
  if (__OFSUB__(v13 >> 1, v12))
  {
    __break(1u);
  }

  else
  {
    Hasher._combine(_:)((v13 >> 1) - v12);
    if (v16 != a4)
    {
      if (a4 <= v16) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = a4;
      }
      do
      {
        if (v17 == a4) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
        }
        (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v15, v19 + *(void *)(v11 + 72) * a4, a6);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(a7 + 24))(a1, a6, a7);
        (*(void (**)(char *, uint64_t))(v11 + 8))(v15, a6);
        ++a4;
      }

      while (v16 != a4);
    }
  }

Swift::UInt ArraySlice<A>.hashValue.getter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(void *)(a5 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v12 = (char *)&v19[-1] - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v19[0] = 0LL;
  v19[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575LL;
  v19[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v19[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261LL;
  v19[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  int64_t v14 = v13 >> 1;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  Swift::UInt result = (v13 >> 1) - v15;
  if (__OFSUB__(v13 >> 1, v15))
  {
    __break(1u);
  }

  else
  {
    Hasher._combine(_:)(result);
    if (v14 != a3)
    {
      if (a3 <= v14) {
        uint64_t v17 = v14;
      }
      else {
        uint64_t v17 = a3;
      }
      do
      {
        if (v17 == a3) {
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Index out of bounds",  19LL,  2,  "Swift/SliceBuffer.swift",  23LL,  2,  0x132uLL,  0);
        }
        (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, a2 + *(void *)(v10 + 72) * a3, a5);
        (*(void (**)(void *, uint64_t, uint64_t))(a6 + 24))(v19, a5, a6);
        (*(void (**)(char *, uint64_t))(v10 + 8))(v12, a5);
        ++a3;
      }

      while (v14 != a3);
    }

    return Hasher._finalize()();
  }

  return result;
}

Swift::UInt protocol witness for Hashable.hashValue.getter in conformance <A> ArraySlice<A>( uint64_t a1, uint64_t a2)
{
  return ArraySlice<A>.hashValue.getter(a1, v2[1], v2[2], v2[3], *(void *)(a1 + 16), *(void *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> ArraySlice<A>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  v6[0] = 0LL;
  v6[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575LL;
  v6[2] = *(void *)algn_18C487058 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261LL;
  v6[4] = *(void *)algn_18C487058 ^ 0x7465646279746573LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  ArraySlice<A>.hash(into:)((uint64_t)v6, a2, v3[1], v3[2], v3[3], *(void *)(a2 + 16), v4);
  return Hasher._finalize()();
}

void *ArraySlice.withUnsafeMutableBytes<A>(_:)( void (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = v4[2];
  uint64_t v6 = v4[3] >> 1;
  uint64_t v7 = v6 - v5;
  if (__OFSUB__(v6, v5))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableBufferPointer with negative count",  46LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x47uLL,  0);
  }

  uint64_t v10 = *(void *)(a3 + 16);
  ArraySlice._makeMutableAndUnique()();
  if (v7 < 0) {
    goto LABEL_7;
  }
  uint64_t v15[3] = a4;
  uint64_t v11 = *(void *)(*(void *)(v10 - 8) + 72LL);
  uint64_t v12 = v4[1] + v11 * v4[2];
  v15[0] = v12;
  v15[1] = v7;
  uint64_t v13 = v7 * v11;
  if ((unsigned __int128)(v7 * (__int128)v11) >> 64 != (v7 * v11) >> 63)
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutableRawBufferPointer with negative count",  49LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x68uLL,  0);
  }

  if (v13 < 0) {
    goto LABEL_9;
  }
  a1(v12, v12 + v13);
  return $defer #1 <A><A1>() in ArraySlice.withUnsafeMutableBufferPointer<A>(_:)(v15, v12, v7);
}

uint64_t ArraySlice.withUnsafeBytes<A>(_:)( uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v7 = (a6 >> 1) - a5;
  if (__OFSUB__(a6 >> 1, a5))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }

  if (v7 < 0) {
    goto LABEL_7;
  }
  uint64_t v8 = *(void *)(*(void *)(a7 - 8) + 72LL);
  uint64_t v9 = v7 * v8;
  if ((unsigned __int128)(v7 * (__int128)v8) >> 64 != (v7 * v8) >> 63)
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
  }

  if (v9 < 0) {
    goto LABEL_9;
  }
  return a1(a4 + v8 * a5, a4 + v8 * a5 + v9);
}

uint64_t ArraySlice.init(_startIndex:)(uint64_t a1)
{
  return _SliceBuffer.init(_buffer:shiftedToStartIndex:)((uint64_t)&_swiftEmptyArrayStorage, a1);
}

uint64_t _ArrayProtocol.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for _ArrayProtocol,  associated type descriptor for _ArrayProtocol._Buffer);
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t v8 = *(void *)(*(void *)(*(void *)(swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for _ArrayProtocol,  (uint64_t)&associated conformance descriptor for _ArrayProtocol._ArrayProtocol._Buffer: _ArrayBufferProtocol)
                                         + 8)
                             + 8LL)
                 + 8LL);
  return RangeReplaceableCollection.init<A>(_:)(a1, a2, AssociatedTypeWitness, v7, v8);
}

uint64_t specialized RangeReplaceableCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v10)(uint64_t *__return_ptr, unint64_t, unint64_t);
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v13 - v7;
  (*(void (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v10 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v10(&v14, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v14 & 0x100) != 0)
  {
    uint64_t v11 = 0LL;
  }

  else
  {
    LODWORD(v11) = 0;
    do
    {
      if (BYTE3(v11)) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/ValidUTF8Buffer.swift",  27LL,  2,  0xA7uLL,  0);
      }
      uint64_t v11 = ((v14 + 1) << (-(__clz(v11) & 0x18) & 0x18)) | v11;
      v10(&v14, AssociatedTypeWitness, AssociatedConformanceWitness);
    }

    while ((v14 & 0x100) == 0);
  }

  (*(void (**)(char *, unint64_t))(v6 + 8))(v8, AssociatedTypeWitness);
  return v11;
}

{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t AssociatedConformanceWitness;
  void (*v10)(uint64_t *__return_ptr, unint64_t, unint64_t);
  Swift::String::Index v11;
  Swift::String::Index v12;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  a2,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v8 = (char *)&v14 - v7;
  int64_t v16 = xmmword_1817FFCA0;
  uint64_t v17 = 0LL;
  uint64_t v18 = 0xE000000000000000LL;
  (*(void (**)(uint64_t, uint64_t))(a3 + 32))(a2, a3);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a3,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v10 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v10(&v15, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v15 & 0x100000000LL) == 0)
  {
    do
    {
      v11._unint64_t rawBits = *((void *)&v16 + 1);
      v12._unint64_t rawBits = *((void *)&v16 + 1);
      specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v11, v12);
      v10(&v15, AssociatedTypeWitness, AssociatedConformanceWitness);
    }

    while (BYTE4(v15) != 1);
  }

  (*(void (**)(char *, unint64_t))(v6 + 8))(v8, AssociatedTypeWitness);
  return v16;
}

uint64_t RangeReplaceableCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 72))(a1, a3, a5, a2, a4);
}

{
  return RangeReplaceableCollection.init<A>(_:)(a1, a4, a2, a5, a3);
}

__objc2_class **_ArrayProtocol.filter(_:)( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v43 = a2;
  uint64_t v44 = a1;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a4 + 16) + 8LL) + 8LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t v36 = *(void *)(v10 - 8);
  uint64_t v37 = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v36 - v12;
  uint64_t v41 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v39 = (char *)&v36 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v14);
  uint64_t v17 = (char *)&v36 - v16;
  unint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v5,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v38 = *(void *)(v18 - 8);
  MEMORY[0x1895F8858](v18);
  __int128 v20 = (char *)&v36 - v19;
  unsigned int v46 = &_swiftEmptyArrayStorage;
  (*(void (**)(uint64_t, uint64_t))(v5 + 32))(a3, v5);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a3,  v18,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v22 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v40 = v20;
  unint64_t v45 = v18;
  unint64_t v23 = v18;
  uint64_t v24 = v22;
  v22(v23, AssociatedConformanceWitness);
  uint64_t v25 = v41;
  uint64_t v26 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v41 + 48);
  if (v26(v13, 1LL, AssociatedTypeWitness) == 1)
  {
    uint64_t v27 = v40;
LABEL_3:
    (*(void (**)(char *, unint64_t))(v38 + 8))(v27, v45);
    (*(void (**)(char *, uint64_t))(v36 + 8))(v13, v37);
    return v46;
  }

  else
  {
    uint64_t v42 = v24;
    unint64_t v29 = *(void (**)(char *, char *, unint64_t))(v25 + 32);
    uint64_t v27 = v40;
    v29(v17, v13, AssociatedTypeWitness);
    while (1)
    {
      char v30 = v44(v17);
      if (v4) {
        break;
      }
      if ((v30 & 1) != 0)
      {
        uint64_t v31 = v39;
        v29(v39, v17, AssociatedTypeWitness);
        uint64_t v34 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v32, v33);
        uint64_t v35 = (uint64_t)v31;
        uint64_t v27 = v40;
        ContiguousArray.append(_:)(v35, v34);
      }

      else
      {
        (*(void (**)(char *, unint64_t))(v41 + 8))(v17, AssociatedTypeWitness);
      }

      v42(v45, AssociatedConformanceWitness);
      if (v26(v13, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_3;
      }
      v29(v17, v13, AssociatedTypeWitness);
    }

    (*(void (**)(char *, unint64_t))(v41 + 8))(v17, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v38 + 8))(v27, v45);
    return (__objc2_class **)swift_release((uint64_t)v46);
  }

__objc2_class **Sequence._filter(_:)( uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v47 = a1;
  unint64_t v45 = a4;
  uint64_t v46 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v10 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v8, v9);
  uint64_t v39 = *(void *)(v10 - 8);
  uint64_t v40 = v10;
  uint64_t v11 = MEMORY[0x1895F8858](v10);
  uint64_t v13 = (char *)&v39 - v12;
  uint64_t v44 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v11);
  uint64_t v42 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v18 = (char *)&v39 - v17;
  uint64_t v19 = *(void *)(a3 - 8);
  MEMORY[0x1895F8858](v16);
  __int128 v21 = (char *)&v39 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v22 = swift_getAssociatedTypeWitness( 0LL,  a4,  a3,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Iterator);
  uint64_t v41 = *(void *)(v22 - 8);
  MEMORY[0x1895F8858](v22);
  uint64_t v24 = (char *)&v39 - v23;
  uint64_t v49 = &_swiftEmptyArrayStorage;
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v21, v48, a3);
  uint64_t v25 = (uint64_t)v45;
  (*((void (**)(uint64_t, const char *))v45 + 4))(a3, v45);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v25,  a3,  v22,  (uint64_t)&protocol requirements base descriptor for Sequence,  (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v27 = *(const char **)(AssociatedConformanceWitness + 16);
  uint64_t v48 = v24;
  unint64_t v43 = v22;
  ((void (*)(unint64_t, unint64_t))v27)(v22, AssociatedConformanceWitness);
  uint64_t v28 = v44;
  unint64_t v29 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v44 + 48);
  if (v29(v13, 1LL, AssociatedTypeWitness) == 1)
  {
    unint64_t v30 = v43;
LABEL_3:
    (*(void (**)(char *, unint64_t))(v41 + 8))(v48, v30);
    (*(void (**)(char *, uint64_t))(v39 + 8))(v13, v40);
    return v49;
  }

  else
  {
    unint64_t v45 = v27;
    uint64_t v32 = *(void (**)(char *, char *, unint64_t))(v28 + 32);
    unint64_t v30 = v43;
    v32(v18, v13, AssociatedTypeWitness);
    while (1)
    {
      char v33 = v47(v18);
      if (v4) {
        break;
      }
      if ((v33 & 1) != 0)
      {
        uint64_t v34 = v42;
        v32(v42, v18, AssociatedTypeWitness);
        uint64_t v37 = type metadata accessor for ContiguousArray(0LL, AssociatedTypeWitness, v35, v36);
        uint64_t v38 = (uint64_t)v34;
        unint64_t v30 = v43;
        ContiguousArray.append(_:)(v38, v37);
      }

      else
      {
        (*(void (**)(char *, unint64_t))(v44 + 8))(v18, AssociatedTypeWitness);
      }

      ((void (*)(unint64_t, unint64_t))v45)(v30, AssociatedConformanceWitness);
      if (v29(v13, 1LL, AssociatedTypeWitness) == 1) {
        goto LABEL_3;
      }
      v32(v18, v13, AssociatedTypeWitness);
    }

    (*(void (**)(char *, unint64_t))(v44 + 8))(v18, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v41 + 8))(v48, v30);
    return (__objc2_class **)swift_release((uint64_t)v49);
  }

uint64_t static Unicode.ASCII.encodedReplacementCharacter.getter()
{
  return 26LL;
}

uint64_t UInt8.init(_builtinIntegerLiteral:)(unsigned __int8 *a1, unint64_t a2)
{
  uint64_t result = 0LL;
  if (a2 <= 0x9FF && (a2 & 1) == 0) {
    return *a1;
  }
  return result;
}

uint64_t static Unicode.ASCII._isScalar(_:)()
{
  return 1LL;
}

uint64_t static Unicode.ASCII.decode(_:)(uint64_t result)
{
  return result;
}

unint64_t specialized Collection.first.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    v5._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)15LL)._rawBits;
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v5._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
    }

    else
    {
      Swift::UInt64 v6 = v5._rawBits >> 16;
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        v10[0] = a1;
        v10[1] = a2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt32 value = *((unsigned __int8 *)v10 + v6);
        if (*((char *)v10 + v6) < 0) {
          __asm { BR              X10 }
        }
      }

      else
      {
        if ((a1 & 0x1000000000000000LL) != 0) {
          uint64_t v7 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else {
          uint64_t v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
        }
        Swift::UInt32 value = v7[v6];
        if ((char)v7[v6] < 0) {
          __asm { BR              X11 }
        }
      }
    }
  }

  else
  {
    Swift::UInt32 value = 0;
  }

  LOBYTE(v10[0]) = v2 == 0;
  return value | ((unint64_t)(v2 == 0) << 32);
}

{
  uint64_t v2;
  Swift::String::Index v5;
  Swift::String::Index v6;
  Swift::UInt64 v7;
  void *v8;
  unsigned int value;
  void v11[2];
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    v5._unint64_t rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)15LL)._rawBits;
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v5._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
    }

    else
    {
      uint64_t v7 = v5._rawBits >> 16;
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        v11[0] = a1;
        v11[1] = a2 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v8 = v11;
      }

      else if ((a1 & 0x1000000000000000LL) != 0)
      {
        uint64_t v8 = (void *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        uint64_t v8 = _StringObject.sharedUTF8.getter(a1, a2);
      }

      Swift::UInt32 value = _decodeScalar(_:startingAt:)((uint64_t)v8, v6._rawBits, v7);
    }
  }

  else
  {
    Swift::UInt32 value = 0;
  }

  LOBYTE(v11[0]) = v2 == 0;
  return value | ((unint64_t)(v2 == 0) << 32);
}

uint64_t specialized Collection.first.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 == a2)
  {
    int v4 = 0;
  }

  else
  {
    if (a1 >= a2) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x715uLL,  0);
    }
    if (a1 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
    }
    if (a1 >= a4) {
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
    }
    int v4 = *(unsigned __int8 *)(a3 + a1);
  }

  return v4 | ((a1 == a2) << 8);
}

uint64_t specialized Collection.first.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v3) {
    return 0LL;
  }
  v5._unint64_t rawBits = 15LL;
  return String.subscript.getter(v5, a1, a2);
}

unint64_t specialized Collection.first.getter( Swift::String::Index a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  Swift::UInt64 v4 = a2 ^ a1._rawBits;
  if ((a2 ^ a1._rawBits) >= 0x4000)
  {
    v8._unint64_t rawBits = _StringGuts.validateScalarIndex(_:in:)(a1, a1._rawBits, a2, a3, a4)._rawBits;
    if ((a4 & 0x1000000000000000LL) != 0)
    {
      unsigned int value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v8._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
    }

    else
    {
      Swift::UInt64 v10 = v8._rawBits >> 16;
      if ((a4 & 0x2000000000000000LL) != 0)
      {
        v15[0] = a3;
        v15[1] = a4 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v11 = v15;
      }

      else if ((a3 & 0x1000000000000000LL) != 0)
      {
        uint64_t v11 = (void *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        uint64_t v13 = a4;
        Swift::UInt64 v14 = v8._rawBits >> 16;
        uint64_t v11 = _StringObject.sharedUTF8.getter(a3, v13);
        Swift::UInt64 v10 = v14;
      }

      unsigned int value = _decodeScalar(_:startingAt:)((uint64_t)v11, v9._rawBits, v10);
    }
  }

  else
  {
    unsigned int value = 0;
  }

  LOBYTE(v15[0]) = v4 < 0x4000;
  return value | ((unint64_t)(v4 < 0x4000) << 32);
}

uint64_t Collection.first.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a2,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v7 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v8 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  Swift::UInt64 v10 = &v23[-((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  MEMORY[0x1895F8858](v8);
  uint64_t v12 = &v23[-v11];
  (*(void (**)(uint64_t, uint64_t))(a2 + 64))(a1, a2);
  (*(void (**)(uint64_t, uint64_t))(a2 + 72))(a1, a2);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( a2,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  char v14 = (*(uint64_t (**)(_BYTE *, _BYTE *, unint64_t))(*(void *)(AssociatedConformanceWitness + 8)
                                                                      + 8LL))( v12,  v10,  AssociatedTypeWitness);
  uint64_t v15 = *(void (**)(_BYTE *, unint64_t))(v7 + 8);
  v15(v10, AssociatedTypeWitness);
  if ((v14 & 1) != 0)
  {
    v15(v12, AssociatedTypeWitness);
    unint64_t v16 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v16 - 8) + 56LL))( a3,  1LL,  1LL,  v16);
  }

  else
  {
    unint64_t v18 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t, uint64_t))(a2 + 80))( v23,  v12,  a1,  a2);
    uint64_t v20 = v19;
    unint64_t v21 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(a2 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v22 = *(void *)(v21 - 8);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v22 + 16))(a3, v20, v21);
    v18(v23, 0LL);
    v15(v12, AssociatedTypeWitness);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v22 + 56))(a3, 0LL, 1LL, v21);
  }

uint64_t Optional._unsafelyUnwrappedUnchecked.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](a1);
  Swift::UInt64 v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v4 + 16))(v6);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v4 + 8))(v6, a1);
  __break(1u);
  return result;
}

uint64_t UnsignedInteger<>.init<A>(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v123 = a6;
  uint64_t v9 = a2;
  uint64_t v126 = *(void *)(a4 + 8);
  unint64_t v111 = *(const char **)(*(void *)(v126 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v111,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v109 = (char *)&v105 - v12;
  uint64_t v116 = *(void *)(v9 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v113 = (char *)&v105 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v112 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v115 = (char *)&v105 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v121 = (char *)&v105 - v19;
  unint64_t v120 = *(const char **)(a5[3] + 16LL);
  unint64_t v119 = swift_getAssociatedTypeWitness( 0LL,  v120,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v20 = MEMORY[0x1895F8858](v119);
  uint64_t v118 = (char *)&v105 - v21;
  uint64_t v22 = *(void *)(a3 - 8);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v107 = (char *)&v105 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v108 = (char *)&v105 - v26;
  uint64_t v27 = MEMORY[0x1895F8858](v25);
  unint64_t v29 = (char *)&v105 - v28;
  uint64_t v30 = MEMORY[0x1895F8858](v27);
  uint64_t v32 = (char *)&v105 - v31;
  MEMORY[0x1895F8858](v30);
  uint64_t v34 = (char *)&v105 - v33;
  uint64_t v117 = (uint64_t (*)(uint64_t, void *))a5[8];
  char v35 = v117(a3, a5);
  uint64_t v124 = v29;
  uint64_t v125 = a1;
  if ((v35 & 1) != 0)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v22 + 16))(v34, a1, a3);
    unint64_t v36 = v119;
    uint64_t v37 = v120;
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  v119,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v39 = v118;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v36,  AssociatedConformanceWitness);
    (*((void (**)(char *, uint64_t, const char *))v37 + 3))(v39, a3, v37);
    LOBYTE(v36) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(a5[4] + 8LL) + 32LL))(v34, v32, a3);
    uint64_t v40 = v22;
    uint64_t v41 = *(void (**)(char *, uint64_t))(v22 + 8);
    v41(v32, a3);
    if ((v36 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Negative value is not representable",  35LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7BuLL,  0);
    }
    v41(v34, a3);
    uint64_t v22 = v40;
    unint64_t v29 = v124;
    a1 = v125;
  }

  uint64_t v122 = v22;
  uint64_t v42 = (uint64_t (*)(uint64_t, void *))a5[16];
  uint64_t v43 = v42(a3, a5);
  BOOL v44 = v43 < (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 56))(v9, a4);
  uint64_t v45 = v126;
  if (!v44)
  {
    uint64_t v106 = v32;
    uint64_t v105 = *(void (**)(char *, uint64_t, uint64_t))(v122 + 16);
    v105(v29, a1, a3);
    uint64_t v46 = v121;
    (*(void (**)(uint64_t, uint64_t))(a4 + 64))(v9, a4);
    uint64_t v47 = *(uint64_t (**)(uint64_t, uint64_t))(v45 + 64);
    uint64_t v48 = v45;
    int v49 = v47(v9, v45);
    int v50 = v117(a3, a5);
    uint64_t v51 = a5;
    unint64_t v114 = a5;
    if (((v49 ^ v50) & 1) != 0)
    {
      char v52 = v47(v9, v48);
      uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(v48 + 128))(v9, v48);
      uint64_t v54 = v124;
      uint64_t v55 = v42(a3, a5);
      if ((v52 & 1) != 0)
      {
        a1 = v125;
        uint64_t v56 = v122;
        if (v55 < v53)
        {
          uint64_t v57 = v106;
          v105(v106, (uint64_t)v54, a3);
          uint64_t v45 = v126;
          uint64_t v58 = v115;
          unint64_t v59 = v57;
          uint64_t v60 = v9;
          (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v126 + 96))(v59, a3, v114, v9, v126);
          char v61 = v121;
          char v62 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v45 + 32) + 8LL) + 16LL))( v121,  v58,  v60);
          size_t v63 = *(void (**)(char *, uint64_t))(v116 + 8);
          v63(v58, v60);
          int v64 = v61;
          uint64_t v9 = v60;
          v63(v64, v60);
          if ((v62 & 1) != 0) {
            goto LABEL_24;
          }
          goto LABEL_17;
        }

        unint64_t v76 = AssociatedTypeWitness;
        uint64_t v77 = v111;
        unint64_t v78 = swift_getAssociatedConformanceWitness( (uint64_t)v111,  v9,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v79 = v109;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v78 + 8))( &unk_18180BE68,  256LL,  v76,  v78);
        uint64_t v80 = v115;
        uint64_t v81 = v9;
        (*((void (**)(char *, uint64_t, const char *))v77 + 3))(v79, v9, v77);
        uint64_t v45 = v126;
        unint64_t v82 = v121;
        LOBYTE(v79) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v126 + 32) + 8LL)
                                                                         + 16LL))( v121,  v80,  v81);
        uint64_t v83 = v116;
        uint64_t v84 = v80;
        uint64_t v85 = *(void (**)(char *, uint64_t))(v116 + 8);
        v85(v84, v81);
        uint64_t v86 = v112;
        uint64_t v87 = v82;
        uint64_t v9 = v81;
        (*(void (**)(char *, char *, uint64_t))(v83 + 32))(v112, v87, v81);
        uint64_t v88 = v108;
        v105(v108, (uint64_t)v54, a3);
        if ((v79 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t))(v56 + 8))(v88, a3);
          v85(v86, v81);
          goto LABEL_24;
        }

        uint64_t v89 = v114;
        uint64_t v90 = v106;
        ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v114[12])(v86, v81, v45, a3, v114);
        char v91 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v89[4] + 8LL) + 16LL))(v90, v88, a3);
        uint64_t v92 = *(void (**)(char *, uint64_t))(v56 + 8);
        v92(v90, a3);
        v92(v88, a3);
        a1 = v125;
        if ((v91 & 1) != 0) {
LABEL_24:
        }
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
      }

      else
      {
        a1 = v125;
        uint64_t v56 = v122;
        if (v53 >= v55)
        {
          unint64_t v93 = v119;
          uint64_t v94 = v120;
          unint64_t v95 = swift_getAssociatedConformanceWitness( (uint64_t)v120,  a3,  v119,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          char v96 = v118;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v95 + 8))( &unk_18180BE68,  256LL,  v93,  v95);
          uint64_t v97 = v106;
          (*((void (**)(char *, uint64_t, const char *))v94 + 3))(v96, a3, v94);
          LOBYTE(v93) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v114[4] + 8LL) + 40LL))( v54,  v97,  a3);
          uint64_t v98 = *(void (**)(char *, uint64_t))(v56 + 8);
          v98(v97, a3);
          uint64_t v99 = v113;
          (*(void (**)(char *, char *, uint64_t))(v116 + 32))(v113, v121, v9);
          uint64_t v100 = v107;
          v105(v107, (uint64_t)v54, a3);
          uint64_t v45 = v126;
          if ((v93 & 1) != 0)
          {
            uint64_t v101 = v115;
            (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v126 + 96))(v100, a3, v114, v9, v126);
            uint64_t v102 = v101;
            char v103 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v45 + 32) + 8LL) + 16LL))( v99,  v101,  v9);
            uint64_t v104 = *(void (**)(char *, uint64_t))(v116 + 8);
            v104(v102, v9);
            v104(v99, v9);
            if ((v103 & 1) != 0) {
              goto LABEL_24;
            }
          }

          else
          {
            v98(v100, a3);
            (*(void (**)(char *, uint64_t))(v116 + 8))(v99, v9);
          }
        }

        else
        {
          uint64_t v69 = v114;
          uint64_t v70 = v106;
          uint64_t v45 = v126;
          ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v114[12])(v121, v9, v126, a3, v114);
          char v71 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69[4] + 8LL) + 16LL))(v70, v54, a3);
          (*(void (**)(char *, uint64_t))(v56 + 8))(v70, a3);
          if ((v71 & 1) != 0) {
            goto LABEL_24;
          }
        }
      }
    }

    else
    {
      uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v48 + 128))(v9, v48);
      uint64_t v66 = v124;
      uint64_t v45 = v48;
      if (v65 >= v42(a3, v51))
      {
        uint64_t v72 = v106;
        v105(v106, (uint64_t)v66, a3);
        unint64_t v73 = v115;
        (*(void (**)(char *, uint64_t, void *, uint64_t, uint64_t))(v48 + 96))(v72, a3, v51, v9, v48);
        char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v48 + 32) + 8LL) + 16LL))( v46,  v73,  v9);
        uint64_t v74 = *(void (**)(char *, uint64_t))(v116 + 8);
        v74(v73, v9);
        v74(v46, v9);
        a1 = v125;
        uint64_t v56 = v122;
      }

      else
      {
        uint64_t v67 = v106;
        ((void (*)(char *, uint64_t, uint64_t, uint64_t, void *))v51[12])(v46, v9, v48, a3, v51);
        char v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v51[4] + 8LL) + 16LL))(v67, v66, a3);
        uint64_t v56 = v122;
        (*(void (**)(char *, uint64_t))(v122 + 8))(v67, a3);
        a1 = v125;
      }

      uint64_t v54 = v66;
      if ((v68 & 1) != 0) {
        goto LABEL_24;
      }
    }

uint64_t static Unicode.ASCII.encode(_:)(unsigned int a1)
{
  int v1 = a1;
  if (a1 > 0x7F) {
    int v1 = 0;
  }
  return v1 | ((a1 > 0x7F) << 8);
}

uint64_t static Int.&<< infix(_:_:)(uint64_t a1, char a2)
{
  return a1 << a2;
}

uint64_t static BinaryInteger.< infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v104 = a1;
  uint64_t v105 = a2;
  uint64_t v99 = *(const char **)(*(void *)(a6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v99,  a4,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  char v96 = (char *)&v87 - v10;
  unint64_t v95 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t v94 = swift_getAssociatedTypeWitness( 0LL,  v95,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1895F8858](v94);
  unint64_t v93 = (char *)&v87 - v12;
  uint64_t v103 = *(void *)(a4 - 8);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v98 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v87 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v101 = (char *)&v87 - v19;
  uint64_t v102 = *(void *)(a3 - 8);
  uint64_t v20 = MEMORY[0x1895F8858](v18);
  uint64_t v22 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = MEMORY[0x1895F8858](v20);
  uint64_t v25 = (char *)&v87 - v24;
  MEMORY[0x1895F8858](v23);
  uint64_t v100 = (char *)&v87 - v26;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 64);
  int v28 = v27(a3, a5);
  if (((v28 ^ (*(unsigned int (**)(uint64_t, uint64_t))(a6 + 64))(a4, a6)) & 1) != 0)
  {
    uint64_t v87 = v25;
    uint64_t v88 = v22;
    unint64_t v29 = v99;
    uint64_t v89 = v17;
    char v30 = v27(a3, a5);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 128);
    uint64_t v91 = a5;
    uint64_t v32 = v31(a3, a5);
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    uint64_t v92 = a4;
    uint64_t v90 = a6;
    uint64_t v34 = v33(a4, a6);
    uint64_t v35 = a3;
    if ((v30 & 1) != 0)
    {
      if (v34 >= v32)
      {
        unint64_t v53 = v94;
        uint64_t v54 = v95;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v95,  a3,  v94,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v56 = v93;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v53,  AssociatedConformanceWitness);
        uint64_t v57 = v100;
        (*((void (**)(char *, uint64_t, const char *))v54 + 3))(v56, a3, v54);
        uint64_t v58 = v91;
        uint64_t v59 = v104;
        LOBYTE(v53) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v91 + 32) + 8LL)
                                                                          + 16LL))( v104,  v57,  a3);
        uint64_t v60 = v102;
        char v61 = *(void (**)(char *, uint64_t))(v102 + 8);
        v61(v57, v35);
        char v62 = v87;
        (*(void (**)(char *, uint64_t, uint64_t))(v60 + 16))(v87, v59, v35);
        uint64_t v63 = v103;
        int v64 = v89;
        uint64_t v65 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v89, v105, v92);
        if ((v53 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t))(v63 + 8))(v64, v65);
          v61(v62, v35);
          char v40 = 1;
        }

        else
        {
          uint64_t v83 = v90;
          uint64_t v84 = v101;
          (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v62, v35, v58, v65, v90);
          char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v83 + 32) + 8LL) + 16LL))( v84,  v64,  v65);
          uint64_t v85 = *(void (**)(char *, uint64_t))(v63 + 8);
          v85(v84, v65);
          v85(v64, v65);
        }
      }

      else
      {
        unint64_t v36 = v101;
        uint64_t v37 = v92;
        (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v105, v92);
        uint64_t v38 = v91;
        uint64_t v39 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v36, v37, v90, a3, v91);
        char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v38 + 32) + 8LL) + 16LL))( v104,  v39,  a3);
        (*(void (**)(char *, uint64_t))(v102 + 8))(v39, a3);
      }
    }

    else if (v32 >= v34)
    {
      uint64_t v66 = v92;
      unint64_t v67 = AssociatedTypeWitness;
      unint64_t v68 = swift_getAssociatedConformanceWitness( (uint64_t)v29,  v92,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v69 = v96;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v68 + 8))( &unk_18180BE68,  256LL,  v67,  v68);
      uint64_t v70 = v101;
      (*((void (**)(char *, uint64_t, const char *))v29 + 3))(v69, v66, v29);
      uint64_t v71 = v90;
      uint64_t v72 = v105;
      LOBYTE(v67) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8LL) + 40LL))( v105,  v70,  v66);
      uint64_t v73 = v103;
      uint64_t v74 = *(void (**)(char *, uint64_t))(v103 + 8);
      v74(v70, v66);
      uint64_t v75 = v102;
      unint64_t v76 = v88;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v88, v104, v35);
      uint64_t v77 = *(void (**)(char *, uint64_t, uint64_t))(v73 + 16);
      unint64_t v78 = v98;
      v77(v98, v72, v66);
      if ((v67 & 1) != 0)
      {
        uint64_t v79 = v71;
        uint64_t v80 = v91;
        uint64_t v81 = v100;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v91 + 96))(v78, v66, v79, v35, v91);
        char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v80 + 32) + 8LL) + 16LL))( v76,  v81,  v35);
        unint64_t v82 = *(void (**)(char *, uint64_t))(v75 + 8);
        v82(v81, v35);
        v82(v76, v35);
      }

      else
      {
        v74(v78, v66);
        (*(void (**)(char *, uint64_t))(v75 + 8))(v76, v35);
        char v40 = 0;
      }
    }

    else
    {
      uint64_t v46 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v104, a3);
      uint64_t v47 = v90;
      uint64_t v48 = v101;
      int v49 = v46;
      uint64_t v50 = v92;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v90 + 96))(v49, a3, v91, v92, v90);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v47 + 32) + 8LL) + 16LL))( v48,  v105,  v50);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v48, v50);
    }
  }

  else
  {
    uint64_t v41 = v104;
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 128))(a3, a5);
    uint64_t v43 = v105;
    if (v42 >= (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 128))(a4, a6))
    {
      uint64_t v51 = v101;
      (*(void (**)(char *, uint64_t, uint64_t))(v103 + 16))(v101, v43, a4);
      char v52 = v100;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(v51, a4, a6, a3, a5);
      char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v41,  v52,  a3);
      (*(void (**)(char *, uint64_t))(v102 + 8))(v52, a3);
    }

    else
    {
      BOOL v44 = v100;
      (*(void (**)(char *, uint64_t, uint64_t))(v102 + 16))(v100, v41, a3);
      uint64_t v45 = v101;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 96))(v44, a3, a5, a4, a6);
      char v40 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a6 + 32) + 8LL) + 16LL))( v45,  v43,  a4);
      (*(void (**)(char *, uint64_t))(v103 + 8))(v45, a4);
    }
  }

  return v40 & 1;
}

uint64_t static Unicode.ASCII.transcode<A>(_:from:)(_DWORD *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  if (a3 == &type metadata for Unicode.UTF16)
  {
    uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
    if (swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  (uint64_t)&type metadata for Unicode.UTF16,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar) == v6)
    {
      if ((*a1 & 0xFF80) != 0) {
        LOBYTE(v7) = 0;
      }
      else {
        LOBYTE(v7) = *a1 & 0x7F;
      }
      int v8 = (*a1 & 0xFF80) != 0;
      return v7 | (v8 << 8);
    }

uint64_t _identityCast<A, B>(_:to:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (a3 != a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "_identityCast to wrong type",  27LL,  2,  "Swift/Builtin.swift",  19LL,  2,  0x6CuLL,  0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a4 - 8) + 16LL))(a5, a1, a4);
}

uint64_t UInt32.init(_builtinIntegerLiteral:)(unsigned int *a1, unint64_t a2)
{
  if (a2 >> 9 <= 0x10 && (a2 & 1) == 0) {
    return *a1;
  }
  else {
    return 0LL;
  }
}

uint64_t static UInt32.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

BOOL static UInt32.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

uint64_t Optional.unsafelyUnwrapped.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v4 + 16))(v6);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1LL, v7) == 1)
  {
    (*(void (**)(char *, uint64_t))(v4 + 8))(v6, a1);
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "unsafelyUnwrapped of nil optional",  33LL,  2,  "Swift/Optional.swift",  20LL,  2,  0x163uLL,  0);
  }

  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v8 + 32))(a2, v6, v7);
}

BOOL static UInt8.< infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  return a1 < a2;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.ASCII( _BYTE *a1@<X8>)
{
  *a1 = 26;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.ASCII( unsigned __int8 *a1)
{
  return *a1;
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.ASCII@<X0>( uint64_t result@<X0>, _BYTE *a2@<X8>)
{
  else {
    char v2 = 0;
  }
  *a2 = v2;
  a2[1] = result > 0x7F;
  return result;
}

ValueMetadata *protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.ASCII@<X0>( _DWORD *a1@<X0>, ValueMetadata *a2@<X2>, uint64_t a3@<X3>, _BYTE *a4@<X8>)
{
  if (a2 == &type metadata for Unicode.UTF16)
  {
    uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
    uint64_t result = (ValueMetadata *)swift_getAssociatedTypeWitness( 0LL,  (const char *)a3,  (uint64_t)&type metadata for Unicode.UTF16,  (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding,  associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if (result == (ValueMetadata *)v7)
    {
      if ((*a1 & 0xFF80) != 0) {
        LOBYTE(v9) = 0;
      }
      else {
        LOBYTE(v9) = *a1 & 0x7F;
      }
      BOOL v10 = (*a1 & 0xFF80) != 0;
      goto LABEL_7;
    }

uint64_t protocol witness for static _UnicodeEncoding._isScalar(_:) in conformance Unicode.ASCII()
{
  return 1LL;
}

uint64_t Unicode.ASCII.Parser.parseScalar<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a3 + 16))(&v5, a2, a3);
  if ((v5 & 0x80u) != 0LL) {
    uint64_t v3 = 1LL;
  }
  else {
    uint64_t v3 = v5;
  }
  if (BYTE1(v5)) {
    return 0LL;
  }
  else {
    return v3;
  }
}

uint64_t Int8.init(_builtinIntegerLiteral:)(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 <= 0x8FF) {
    return *a1;
  }
  else {
    return 0LL;
  }
}

BOOL static Int8.>= infix(_:_:)(char a1, char a2)
{
  return a1 >= a2;
}

uint64_t protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.ASCII.Parser@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = Unicode.ASCII.Parser.parseScalar<A>(from:)(a1, a2, a3);
  *(void *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6;
  return result;
}

Swift::String __swiftcall String.init()()
{
  uint64_t v0 = 0LL;
  int v1 = (void *)0xE000000000000000LL;
  result._unint64_t object = v1;
  result._uint64_t countAndFlagsBits = v0;
  return result;
}

uint64_t assert(_:_:file:line:)( uint64_t (*a1)(void), uint64_t a2, uint64_t (*a3)(void), uint64_t a4, const char *a5, uint64_t a6, char a7, unint64_t a8)
{
  return assert(_:_:file:line:)(a1, a2, a3, a4, a5, a6, a7, a8, "Assertion failed", 16LL);
}

Swift::Bool __swiftcall _isDebugAssertConfiguration()()
{
  return 1;
}

void _assertionFailure(_:_:file:line:flags:)( const char *a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5, const char *a6, uint64_t a7, char a8, unint64_t a9, int a10)
{
  int v11 = a10;
  if ((a3 & 1) != 0)
  {
    if ((unint64_t)a1 >> 32) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    }
    _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n( a1,  (uint64_t (*)(uint64_t *))partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:));
    __break(1u);
  }

  else if (!a1)
  {
    unint64_t v12 = 136LL;
    goto LABEL_15;
  }

  uint64_t v13 = a2;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  char v14 = a8;
  uint64_t v15 = a7;
  uint64_t v16 = a6;
  unint64_t v17 = a5;
  uint64_t v18 = (uint64_t)a4;
  swift_bridgeObjectRetain(a5, a2, a3, a4);
  if ((v17 & 0x1000000000000000LL) != 0)
  {
    uint64_t v18 = specialized static String._copying(_:)(v18, v17);
    unint64_t v22 = v21;
    swift_bridgeObjectRelease(v17);
    unint64_t v17 = v22;
    int v11 = a10;
    if ((v17 & 0x2000000000000000LL) == 0)
    {
LABEL_11:
      if ((v18 & 0x1000000000000000LL) != 0)
      {
        uint64_t v19 = (const char *)((v17 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v20 = v18 & 0xFFFFFFFFFFFFLL;
LABEL_13:
        closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(v19, v20, v16, v15, v14, a1, v13, a9, v11);
        swift_bridgeObjectRelease(v17);
        __break(1u);
LABEL_14:
        unint64_t v12 = 148LL;
LABEL_15:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v12,  0);
      }

uint64_t precondition(_:_:file:line:)( uint64_t (*a1)(void), uint64_t a2, uint64_t (*a3)(void), uint64_t a4, const char *a5, uint64_t a6, char a7, unint64_t a8)
{
  return assert(_:_:file:line:)(a1, a2, a3, a4, a5, a6, a7, a8, "Precondition failed", 19LL);
}

uint64_t assert(_:_:file:line:)( uint64_t (*a1)(void), uint64_t a2, uint64_t (*a3)(void), uint64_t a4, const char *a5, uint64_t a6, char a7, unint64_t a8, const char *a9, uint64_t a10)
{
  uint64_t result = a1();
  if ((result & 1) == 0)
  {
    uint64_t v16 = (char *)a3();
    _assertionFailure(_:_:file:line:flags:)(a9, a10, 2LL, v16, v17, a5, a6, a7, a8, 0);
  }

  return result;
}

Swift::Bool __swiftcall _isReleaseAssertConfiguration()()
{
  return 0;
}

void assertionFailure(_:file:line:)( uint64_t (*a1)(void), uint64_t a2, const char *a3, uint64_t a4, char a5, unint64_t a6)
{
  BOOL v10 = (char *)a1();
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11LL, 2LL, v10, v11, a3, a4, a5, a6, 0);
}

Swift::Bool __swiftcall _isFastAssertConfiguration()()
{
  return 0;
}

const char *StaticString.init()()
{
  return "";
}

void _assertionFailure(_:_:file:line:flags:)( unint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, char a6, const char *a7, uint64_t a8, char a9, unint64_t a10, int a11)
{
  int v11 = a11;
  unint64_t v12 = a10;
  char v13 = a9;
  if ((a3 & 1) != 0)
  {
    if (HIDWORD(a1))
    {
LABEL_12:
      LOBYTE(v15) = 2;
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  v15,  3455LL,  0);
LABEL_13:
      LOBYTE(v15) = 2;
      _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeBufferPointer with negative count",  39LL,  2LL,  "Swift/UnsafeBufferPointer.swift",  31LL,  v15,  1343LL,  0);
    }

    if (WORD1(a1) > 0x10u || (a1 & 0xFFFFF800) == 0xD800) {
      goto LABEL_10;
    }
    a1 = _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n( a1,  (uint64_t (*)(uint64_t *))partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:));
    __break(1u);
  }

  else if (!a1)
  {
    uint64_t v14 = 136LL;
LABEL_11:
    LOBYTE(v15) = 2;
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2LL,  "Swift/StaticString.swift",  24LL,  v15,  v14,  0);
    goto LABEL_12;
  }

  if (a2 < 0) {
    goto LABEL_13;
  }
  closure #1 in _assertionFailure(_:_:file:line:flags:)((const char *)a1, a2, a4, a5, a6, a7, a8, v13, v12, v11);
  __break(1u);
LABEL_10:
  uint64_t v14 = 148LL;
  goto LABEL_11;
}

uint64_t _overflowChecked<A>(_:file:line:)@<X0>( _BYTE *a1@<X0>, char a2@<W1>, const char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v24 = a6;
  uint64_t v25 = a3;
  int v23 = a5;
  uint64_t v26 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, a7, (uint64_t)&type metadata for Bool, 0LL, 0LL);
  uint64_t v13 = *(TupleTypeMetadata2 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v16 = &v22[-((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  MEMORY[0x1895F8858](v14);
  uint64_t v18 = &v22[-v17];
  uint64_t v19 = *(void *)(a7 - 8);
  uint64_t v20 = *(void (**)(_BYTE *, _BYTE *, uint64_t))(v19 + 16);
  v20(&v22[-v17], a1, a7);
  v18[*((int *)TupleTypeMetadata2 + 12)] = a2;
  v20(v16, v18, a7);
  (*(void (**)(uint64_t, _BYTE *, uint64_t))(v19 + 32))(a8, v16, a7);
  if ((a2 & 1) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow/underflow",  18LL,  2,  v25,  v26,  v23,  v24,  0);
  }
  return (*(uint64_t (**)(_BYTE *, unint64_t *))(v13 + 8))(v18, TupleTypeMetadata2);
}

void _fatalErrorMessage(_:_:file:line:flags:)( unint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, char a6, const char *a7, uint64_t a8, char a9, unint64_t a10, int a11)
{
}

void _debugPreconditionFailure(_:file:line:)( const char *a1, uint64_t a2, char a3, const char *a4, uint64_t a5, char a6, unint64_t a7)
{
}

uint64_t Int32.init(_builtinIntegerLiteral:)(unsigned int *a1, unint64_t a2)
{
  if (a2 >> 8 <= 0x20) {
    return *a1;
  }
  else {
    return 0LL;
  }
}

BOOL static Int32.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

Swift::Bool __swiftcall _isStdlibInternalChecksEnabled()()
{
  return 0;
}

uint64_t closure #1 in _assertionFailure(_:_:file:line:flags:)( const char *a1, uint64_t a2, const char *a3, uint64_t a4, char a5, const char *a6, uint64_t a7, char a8, unint64_t a9, int a10)
{
  BOOL v10 = a3;
  int v11 = a10;
  unint64_t v12 = a9;
  if ((a5 & 1) == 0) {
    goto LABEL_7;
  }
  if ((unint64_t)a3 >> 32)
  {
    a1 = (const char *)_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
LABEL_7:
    if (v10) {
      goto LABEL_11;
    }
    uint64_t v14 = 136LL;
LABEL_10:
    LOBYTE(v15) = 2;
    a1 = (const char *)_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2LL,  "Swift/StaticString.swift",  24LL,  v15,  v14,  0);
LABEL_11:
    if ((a4 & 0x8000000000000000LL) == 0) {
      closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(v10, a4, a6, a7, a8, a1, a2, v12, v11);
    }
    LOBYTE(v15) = 2;
    _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeBufferPointer with negative count",  39LL,  2LL,  "Swift/UnsafeBufferPointer.swift",  31LL,  v15,  1343LL,  0);
  }

  if (WORD1(a3) > 0x10u || (a3 & 0xFFFFF800) == 0xD800)
  {
    uint64_t v14 = 148LL;
    goto LABEL_10;
  }

  return _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n( a3,  (uint64_t (*)(uint64_t *))partial apply for closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:));
}

void closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)( const char *a1, uint64_t a2, const char *a3, uint64_t a4, char a5, const char *a6, uint64_t a7, unint64_t a8, int a9)
{
  uint64_t v9 = a2;
  BOOL v10 = a1;
  int v11 = a9;
  if ((a5 & 1) != 0)
  {
    if ((unint64_t)a3 >> 32)
    {
LABEL_15:
      LOBYTE(v22) = 2;
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  v22,  3455LL,  0);
      goto LABEL_16;
    }

    if (WORD1(a3) <= 0x10u && (a3 & 0xFFFFF800) != 0xD800)
    {
      if (a3 < 0x80)
      {
        int v13 = 1;
LABEL_9:
        uint64_t v14 = ((_DWORD)a3 + v13);
        unsigned int v15 = __clz(v14);
        uint64_t v16 = 4 - (v15 >> 3);
        uint64_t v23 = (v14 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (v15 >> 3))));
        uint64_t v17 = (const char *)&v23;
        goto LABEL_12;
      }

{
  unsigned int v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  if ((a5 & 1) == 0)
  {
    if (a3)
    {
      if (a4 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      closure #1 in closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(a3, a4, a6, a7, a1, a2, a8, a9);
      return;
    }

    uint64_t v12 = 136LL;
LABEL_17:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v12,  0);
  }

  if ((unint64_t)a3 >> 32) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  if (WORD1(a3) > 0x10u || (a3 & 0xFFFFF800) == 0xD800)
  {
    uint64_t v12 = 148LL;
    goto LABEL_17;
  }

  if (a3 >= 0x80)
  {
    int v11 = (a3 & 0x3F) << 8;
    if (a3 >= 0x800)
    {
      int v13 = (v11 | (a3 >> 6) & 0x3F) << 8;
      uint64_t v14 = (((v13 | (a3 >> 12) & 0x3F) << 8) | (a3 >> 18)) - 2122219023;
      uint64_t v9 = (v13 | (a3 >> 12)) + 8487393;
    }

    else
    {
      uint64_t v9 = (v11 | (a3 >> 6)) + 33217;
    }
  }

  else
  {
    uint64_t v9 = (_DWORD)a3 + 1;
  }

  BOOL v10 = __clz(v9);
  unsigned int v15 = (v9 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (v10 >> 3))));
  closure #1 in closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)( (const char *)&v15,  4 - (v10 >> 3),  a6,  a7,  a1,  a2,  a8,  a9);
}

void closure #1 in closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)( const char *a1, uint64_t a2, const char *a3, uint64_t a4, const char *a5, uint64_t a6, unint64_t a7, int a8)
{
  if (a3)
  {
    if (a4 >= 0x80000000LL)
    {
LABEL_17:
      uint64_t v10 = 3687LL;
      goto LABEL_18;
    }

    if (a5)
    {
      if (a6 >= 0x80000000LL) {
        goto LABEL_17;
      }
      uint64_t v9 = a1;
      if (a1) {
        goto LABEL_12;
      }
      uint64_t v8 = 107LL;
    }

    else
    {
      uint64_t v8 = 106LL;
    }
  }

  else
  {
    uint64_t v8 = 105LL;
  }

  _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2LL,  "Swift/AssertCommon.swift",  24LL,  2,  v8,  0);
LABEL_12:
  if (a2 < 0x80000000LL)
  {
    if (HIDWORD(a7)) {
      goto LABEL_19;
    }
    _swift_stdlib_reportFatalErrorInFile(a3, a4, a5, a6, v9, a2, a7, a8);
    __break(1u);
LABEL_16:
    LOBYTE(v11) = 2;
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent a signed value",  43LL,  2LL,  "Swift/Integers.swift",  20LL,  v11,  3681LL,  0);
    while (1)
    {
LABEL_19:
      uint64_t v10 = 3455LL;
LABEL_18:
      LOBYTE(v11) = 2;
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  v11,  v10,  0);
    }
  }

  goto LABEL_17;
}

{
  unint64_t v8;
  unint64_t v9;
  if (!a3)
  {
    uint64_t v9 = 139LL;
    goto LABEL_19;
  }

  if (a4 >= 0x80000000LL) {
    goto LABEL_13;
  }
  if (!a5)
  {
    uint64_t v9 = 140LL;
    goto LABEL_19;
  }

  if (a6 >= 0x80000000LL)
  {
LABEL_13:
    uint64_t v8 = 3687LL;
    goto LABEL_15;
  }

  if (!a1)
  {
    uint64_t v9 = 141LL;
LABEL_19:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/AssertCommon.swift",  24LL,  2,  v9,  0);
  }

  if (a2 < (uint64_t)0xFFFFFFFF80000000LL) {
LABEL_12:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  if (a2 >= 0x80000000LL) {
    goto LABEL_13;
  }
  if (HIDWORD(a7))
  {
    uint64_t v8 = 3455LL;
LABEL_15:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  v8,  0);
  }

  _swift_stdlib_reportFatalErrorInFile(a3, a4, a5, a6, a1, a2, a7, a8);
}

uint64_t StaticString.withUTF8Buffer<A>(_:)( uint64_t (*a1)(unint64_t, uint64_t), uint64_t a2, unint64_t a3, uint64_t a4, char a5)
{
  if ((a5 & 1) == 0)
  {
    if (a3)
    {
      if (a4 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      return a1(a3, a4);
    }

    unint64_t v8 = 136LL;
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v8,  0);
  }

  if (HIDWORD(a3)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  if (WORD1(a3) > 0x10u || (a3 & 0xFFFFF800) == 0xD800)
  {
    unint64_t v8 = 148LL;
    goto LABEL_18;
  }

  if (a3 >= 0x80)
  {
    int v7 = (a3 & 0x3F) << 8;
    if (a3 >= 0x800)
    {
      unsigned int v9 = (v7 | (a3 >> 6) & 0x3F) << 8;
      unsigned int v10 = (((v9 | (a3 >> 12) & 0x3F) << 8) | (a3 >> 18)) - 2122219023;
      unsigned int v6 = (v9 | (a3 >> 12)) + 8487393;
      if (WORD1(a3)) {
        unsigned int v6 = v10;
      }
    }

    else
    {
      unsigned int v6 = (v7 | (a3 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v6 = a3 + 1;
  }

  uint64_t v11 = (v6 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (__clz(v6) >> 3))));
  return ((uint64_t (*)(uint64_t *))a1)(&v11);
}

size_t specialized String.withUTF8<A>(_:)(unint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = a1[1];
  if ((v2 & 0x1000000000000000LL) == 0)
  {
    if ((v2 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    size_t v4 = HIBYTE(v2) & 0xF;
    v10[0] = v1;
    v10[1] = v2 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v3 = v10;
    return _swift_stdlib_fwrite_stdout(v3, 1uLL, v4);
  }

  uint64_t v1 = specialized static String._copying(_:)(*a1, v2);
  unint64_t v7 = v6;
  swift_bridgeObjectRelease(v2);
  *a1 = v1;
  a1[1] = v7;
  unint64_t v2 = v7;
  if ((v7 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v1 & 0x1000000000000000LL) != 0)
  {
    uint64_t v3 = (void *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    size_t v4 = v1 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v3 = _StringObject.sharedUTF8.getter(v1, v2);
    if (!v3) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/OutputStream.swift",  24LL,  2,  0x239uLL,  0);
    }
    size_t v4 = v9;
  }

  return _swift_stdlib_fwrite_stdout(v3, 1uLL, v4);
}

uint64_t String.withUTF8<A>(_:)(uint64_t (*a1)(void *, uint64_t))
{
  uint64_t v3 = *v1;
  unint64_t v4 = v1[1];
  if ((v4 & 0x1000000000000000LL) == 0)
  {
    if ((v4 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v6 = HIBYTE(v4) & 0xF;
    v10[0] = v3;
    v10[1] = v4 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v5 = v10;
    return a1(v5, v6);
  }

  uint64_t v3 = specialized static String._copying(_:)(*v1, v1[1]);
  unint64_t v8 = v7;
  swift_bridgeObjectRelease(v4);
  *uint64_t v1 = v3;
  v1[1] = v8;
  unint64_t v4 = v8;
  if ((v8 & 0x2000000000000000LL) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    uint64_t v5 = (void *)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v5 = _StringObject.sharedUTF8.getter(v3, v4);
  }

  return a1(v5, v6);
}

void closure #1 in closure #1 in _assertionFailure(_:_:flags:)( const char *a1, uint64_t a2, const char *a3, uint64_t a4, int a5)
{
  if (!a3)
  {
    unint64_t v5 = 169LL;
    goto LABEL_11;
  }

  if (a4 < (uint64_t)0xFFFFFFFF80000000LL) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  }
  if (a4 >= 0x80000000LL) {
LABEL_7:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
  if (!a1)
  {
    unint64_t v5 = 170LL;
LABEL_11:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/AssertCommon.swift",  24LL,  2,  v5,  0);
  }

  if (a2 >= 0x80000000LL) {
    goto LABEL_7;
  }
  _swift_stdlib_reportFatalError(a3, a4, a1, a2, a5);
}

void _unimplementedInitializer(className:initName:file:line:column:)( unint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, char a6, const char *a7, uint64_t a8, char a9, unint64_t a10, unint64_t a11)
{
  unint64_t v12 = a10;
  unint64_t v11 = a11;
  char v13 = a9;
  if ((a3 & 1) != 0)
  {
    if (HIDWORD(a1)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    }
    if (WORD1(a1) > 0x10u || (a1 & 0xFFFFF800) == 0xD800) {
      goto LABEL_10;
    }
    a1 = _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n( a1,  (uint64_t (*)(uint64_t *))partial apply for closure #1 in _unimplementedInitializer(className:initName:file:line:column:));
    __break(1u);
  }

  else if (!a1)
  {
    unint64_t v14 = 136LL;
    goto LABEL_11;
  }

  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( (const char *)a1,  a2,  a4,  a5,  a6,  a7,  a8,  v13,  v12,  v11);
  __break(1u);
LABEL_10:
  unint64_t v14 = 148LL;
LABEL_11:
  _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v14,  0);
}

void closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( const char *a1, uint64_t a2, const char *a3, uint64_t a4, char a5, const char *a6, uint64_t a7, char a8, unint64_t a9, unint64_t a10)
{
  if ((a5 & 1) != 0)
  {
    if ((unint64_t)a3 >> 32) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
    }
    if (WORD1(a3) <= 0x10u && (a3 & 0xFFFFF800) != 0xD800)
    {
      _ss7UnicodeO6ScalarV17withUTF8CodeUnitsyxxSRys5UInt8VGKXEKlFyt_Tg5024_ss12StaticStringV14withd14BufferyxxSRys5G20VGXElFxAFXEfU_yt_Tg5AHxRi_zRi0_zlyytIsgyr_Tf1ncn_n( a3,  (uint64_t (*)(uint64_t *))partial apply for closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:));
      return;
    }

    unint64_t v10 = 148LL;
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v10,  0);
  }

  if (!a3)
  {
    unint64_t v10 = 136LL;
    goto LABEL_13;
  }

  if (a4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( a3,  a4,  a6,  a7,  a8,  a1,  a2,  a9,  a10);
}

void closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( const char *a1, uint64_t a2, const char *a3, uint64_t a4, char a5, const char *a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  if ((a5 & 1) == 0)
  {
    if (a3)
    {
      if (a4 < 0) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
      }
      closure #1 in closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( a3,  a4,  a6,  a7,  a1,  a2,  a8,  a9);
      return;
    }

    unint64_t v12 = 136LL;
LABEL_17:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/StaticString.swift",  24LL,  2,  v12,  0);
  }

  if ((unint64_t)a3 >> 32) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xD7FuLL,  0);
  }
  if (WORD1(a3) > 0x10u || (a3 & 0xFFFFF800) == 0xD800)
  {
    unint64_t v12 = 148LL;
    goto LABEL_17;
  }

  if (a3 >= 0x80)
  {
    int v11 = (a3 & 0x3F) << 8;
    if (a3 >= 0x800)
    {
      unsigned int v13 = (v11 | (a3 >> 6) & 0x3F) << 8;
      unsigned int v14 = (((v13 | (a3 >> 12) & 0x3F) << 8) | (a3 >> 18)) - 2122219023;
      unsigned int v9 = (v13 | (a3 >> 12)) + 8487393;
    }

    else
    {
      unsigned int v9 = (v11 | (a3 >> 6)) + 33217;
    }
  }

  else
  {
    unsigned int v9 = (_DWORD)a3 + 1;
  }

  unsigned int v10 = __clz(v9);
  uint64_t v15 = (v9 + 0xFEFEFEFEFEFEFFLL) & ~(-1LL << (8 * (4 - (v10 >> 3))));
  closure #1 in closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( (const char *)&v15,  4 - (v10 >> 3),  a6,  a7,  a1,  a2,  a8,  a9);
}

void closure #1 in closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)( const char *a1, uint64_t a2, const char *a3, uint64_t a4, const char *a5, uint64_t a6, unint64_t a7, unint64_t a8)
{
  if (!a3)
  {
    unint64_t v9 = 230LL;
    goto LABEL_20;
  }

  if (a4 >= 0x80000000LL) {
    goto LABEL_14;
  }
  if (!a5)
  {
    unint64_t v9 = 231LL;
    goto LABEL_20;
  }

  if (a6 >= 0x80000000LL)
  {
LABEL_14:
    unint64_t v8 = 3687LL;
    goto LABEL_16;
  }

  if (!a1)
  {
    unint64_t v9 = 232LL;
LABEL_20:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/AssertCommon.swift",  24LL,  2,  v9,  0);
  }

  if (a2 < (uint64_t)0xFFFFFFFF80000000LL) {
LABEL_13:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
  if (a2 >= 0x80000000LL) {
    goto LABEL_14;
  }
  if (HIDWORD(a7) || HIDWORD(a8))
  {
    unint64_t v8 = 3455LL;
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  v8,  0);
  }

  _swift_stdlib_reportUnimplementedInitializerInFile(a3, a4, a5, a6, a1, a2, a7, a8, 0);
}

void _undefined<A>(_:file:line:)( uint64_t (*a1)(void), uint64_t a2, const char *a3, uint64_t a4, char a5, unint64_t a6)
{
  unsigned int v10 = (char *)a1();
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11LL, 2LL, v10, v11, a3, a4, a5, a6, 0);
}

void _diagnoseUnexpectedEnumCaseValue<A, B>(type:rawValue:)( unint64_t a1, uint64_t a2, uint64_t a3, swift *a4)
{
  uint64_t v7 = specialized static String._createEmpty(withInitialCapacity:)(39LL);
  uint64_t v9 = v8;
  v50._uint64_t countAndFlagsBits = v7;
  v50._unint64_t object = (void *)v8;
  uint64_t v10 = HIBYTE(v8) & 0xF;
  if ((v8 & 0x2000000000000000LL) == 0) {
    uint64_t v10 = v7 & 0xFFFFFFFFFFFFLL;
  }
  if (v10 || (v7 & ~v8 & 0x2000000000000000LL) != 0)
  {
    if ((v8 & 0x2000000000000000LL) != 0
      && (0x80000001818B5330LL & 0x2000000000000000LL) != 0
      && (unint64_t v11 = specialized _SmallString.init(_:appending:)( v7,  v8,  0xD000000000000016LL,  0x80000001818B5330LL | 0x8000000000000000LL),  (v13 & 1) == 0))
    {
      uint64_t v14 = v11;
      uint64_t v15 = v12;
      swift_bridgeObjectRelease(v9);
      swift_bridgeObjectRelease(0x80000001818B5330LL | 0x8000000000000000LL);
      v50._uint64_t countAndFlagsBits = v14;
      v50._unint64_t object = v15;
    }

    else
    {
      if ((0x80000001818B5330LL & 0x2000000000000000LL) != 0) {
        unint64_t v16 = (0x80000001818B5330LL >> 56) & 0xF;
      }
      else {
        unint64_t v16 = 22LL;
      }
      _StringGuts.append(_:)(0xD000000000000016LL, 0x80000001818B5330LL | 0x8000000000000000LL, 0LL, v16);
      swift_bridgeObjectRelease(0x80000001818B5330LL | 0x8000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v8);
    v50._uint64_t countAndFlagsBits = 0xD000000000000016LL;
    v50._unint64_t object = (void *)(0x80000001818B5330LL | 0x8000000000000000LL);
  }

  TypeName = (uint64_t *)swift_getTypeName(a1, 0);
  if (v18 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  unsigned int v19 = (uint8x16_t *)TypeName;
  int64_t v20 = v18;
  int64_t v21 = validateUTF8(_:)(TypeName, v18);
  if ((v23 & 1) != 0) {
    unint64_t v24 = repairUTF8(_:firstKnownBrokenRange:)(v19->i8, v20, v21, v22);
  }
  else {
    unint64_t v24 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v19, v20, v21 & 1);
  }
  uint64_t countAndFlagsBits = v24;
  unint64_t object = v25;
  unint64_t v28 = ((unint64_t)v50._object >> 56) & 0xF;
  if (!v28 && (v50._countAndFlagsBits & ~(uint64_t)v50._object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v50._object);
    v50._uint64_t countAndFlagsBits = countAndFlagsBits;
    v50._unint64_t object = (void *)object;
    goto LABEL_32;
  }

  if (((uint64_t)v50._object & 0x2000000000000000LL) != 0)
  {
    if ((v25 & 0x2000000000000000LL) != 0)
    {
      unint64_t v30 = specialized _SmallString.init(_:appending:)(v50._countAndFlagsBits, (unint64_t)v50._object, v24, v25);
      if ((v32 & 1) == 0)
      {
        uint64_t v33 = v30;
        uint64_t v34 = v31;
        swift_bridgeObjectRelease((uint64_t)v50._object);
        swift_bridgeObjectRelease(object);
        v50._uint64_t countAndFlagsBits = v33;
        v50._unint64_t object = v34;
        unint64_t object = (unint64_t)v34;
        uint64_t countAndFlagsBits = v33;
        goto LABEL_32;
      }

      goto LABEL_30;
    }
  }

  else if ((v25 & 0x2000000000000000LL) != 0)
  {
LABEL_30:
    uint64_t v29 = HIBYTE(object) & 0xF;
    goto LABEL_31;
  }

  uint64_t v29 = v24 & 0xFFFFFFFFFFFFLL;
LABEL_31:
  _StringGuts.append(_:)(countAndFlagsBits, object, 0LL, v29);
  swift_bridgeObjectRelease(object);
  uint64_t countAndFlagsBits = v50._countAndFlagsBits;
  unint64_t object = (unint64_t)v50._object;
LABEL_32:
  Swift::String v35 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("(rawValue: ", 0xBuLL, 1);
  uint64_t v36 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000LL) == 0) {
    uint64_t v36 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (!v36 && (countAndFlagsBits & ~object & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(object);
    Swift::String v50 = v35;
    goto LABEL_46;
  }

  if ((object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v35._object & 0x2000000000000000LL) != 0)
    {
      unint64_t v38 = specialized _SmallString.init(_:appending:)( countAndFlagsBits,  object,  v35._countAndFlagsBits,  (unint64_t)v35._object);
      if ((v40 & 1) == 0)
      {
        uint64_t v41 = v38;
        uint64_t v42 = v39;
        swift_bridgeObjectRelease(object);
        swift_bridgeObjectRelease((uint64_t)v35._object);
        v50._uint64_t countAndFlagsBits = v41;
        v50._unint64_t object = v42;
        goto LABEL_46;
      }

      goto LABEL_44;
    }
  }

  else if (((uint64_t)v35._object & 0x2000000000000000LL) != 0)
  {
LABEL_44:
    uint64_t v37 = ((unint64_t)v35._object >> 56) & 0xF;
    goto LABEL_45;
  }

  uint64_t v37 = v35._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_45:
  _StringGuts.append(_:)(v35._countAndFlagsBits, (unint64_t)v35._object, 0LL, v37);
  swift_bridgeObjectRelease((uint64_t)v35._object);
LABEL_46:
  _print_unlocked<A, B>(_:_:)( a2,  (uint64_t)&v50,  a4,  (uint64_t)&type metadata for DefaultStringInterpolation,  (uint64_t)&protocol witness table for DefaultStringInterpolation);
  uint64_t v43 = v50._object;
  unint64_t v44 = ((unint64_t)v50._object >> 56) & 0xF;
  if (v44 || (v50._countAndFlagsBits & ~(uint64_t)v50._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v50._object & 0x2000000000000000LL) == 0
      || (unint64_t v47 = specialized _SmallString.init(_:appending:)( v50._countAndFlagsBits,  (unint64_t)v50._object,  0x2729uLL,  0xE200000000000000LL),  (v49 & 1) != 0))
    {
      _StringGuts.append(_:)(10025LL, 0xE200000000000000LL, 0LL, 2LL);
      swift_bridgeObjectRelease(0xE200000000000000LL);
      uint64_t v46 = v50._countAndFlagsBits;
      uint64_t v45 = v50._object;
    }

    else
    {
      uint64_t v46 = v47;
      uint64_t v45 = v48;
      swift_bridgeObjectRelease((uint64_t)v43);
      swift_bridgeObjectRelease(0xE200000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease((uint64_t)v50._object);
    uint64_t v45 = (void *)0xE200000000000000LL;
    uint64_t v46 = 10025LL;
  }

  _assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)v46, (unint64_t)v45, 0);
}

void DefaultStringInterpolation.appendInterpolation<A>(_:)(uint64_t a1, swift *a2)
{
}

void _diagnoseUnexpectedEnumCase<A>(type:)(unint64_t a1)
{
  unint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(58LL);
  uint64_t v4 = v3;
  unint64_t v36 = v2;
  unint64_t v37 = v3;
  uint64_t v5 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000LL) == 0) {
    uint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 || (v2 & ~v3 & 0x2000000000000000LL) != 0)
  {
    if ((v3 & 0x2000000000000000LL) != 0
      && (0x80000001818B5360LL & 0x2000000000000000LL) != 0
      && (unint64_t v6 = specialized _SmallString.init(_:appending:)( v2,  v3,  0xD000000000000037LL,  0x80000001818B5360LL | 0x8000000000000000LL),  (v8 & 1) == 0))
    {
      unint64_t v9 = v6;
      unint64_t v10 = v7;
      swift_bridgeObjectRelease(v4);
      swift_bridgeObjectRelease(0x80000001818B5360LL | 0x8000000000000000LL);
      unint64_t v36 = v9;
      unint64_t v37 = v10;
    }

    else
    {
      if ((0x80000001818B5360LL & 0x2000000000000000LL) != 0) {
        unint64_t v11 = (0x80000001818B5360LL >> 56) & 0xF;
      }
      else {
        unint64_t v11 = 55LL;
      }
      _StringGuts.append(_:)(0xD000000000000037LL, 0x80000001818B5360LL | 0x8000000000000000LL, 0LL, v11);
      swift_bridgeObjectRelease(0x80000001818B5360LL | 0x8000000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v3);
    unint64_t v36 = 0xD000000000000037LL;
    unint64_t v37 = 0x80000001818B5360LL | 0x8000000000000000LL;
  }

  TypeName = (uint64_t *)swift_getTypeName(a1, 0);
  if (v13 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v14 = (uint8x16_t *)TypeName;
  int64_t v15 = v13;
  int64_t v16 = validateUTF8(_:)(TypeName, v13);
  if ((v18 & 1) != 0) {
    unint64_t v19 = repairUTF8(_:firstKnownBrokenRange:)(v14->i8, v15, v16, v17);
  }
  else {
    unint64_t v19 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v14, v15, v16 & 1);
  }
  unint64_t v21 = v19;
  unint64_t v22 = v20;
  uint64_t v23 = HIBYTE(v37) & 0xF;
  if ((v37 & 0x2000000000000000LL) == 0) {
    uint64_t v23 = v36 & 0xFFFFFFFFFFFFLL;
  }
  if (!v23 && (v36 & ~v37 & 0x2000000000000000LL) == 0)
  {
    swift_bridgeObjectRelease(v37);
    unint64_t v36 = v21;
    unint64_t v37 = v22;
    goto LABEL_32;
  }

  if ((v37 & 0x2000000000000000LL) != 0)
  {
    if ((v20 & 0x2000000000000000LL) != 0)
    {
      unint64_t v25 = specialized _SmallString.init(_:appending:)(v36, v37, v19, v20);
      if ((v27 & 1) == 0)
      {
        unint64_t v28 = v25;
        unint64_t v29 = v26;
        swift_bridgeObjectRelease(v37);
        swift_bridgeObjectRelease(v22);
        unint64_t v36 = v28;
        unint64_t v37 = v29;
        unint64_t v22 = v29;
        unint64_t v21 = v28;
        goto LABEL_32;
      }

      goto LABEL_30;
    }
  }

  else if ((v20 & 0x2000000000000000LL) != 0)
  {
LABEL_30:
    uint64_t v24 = HIBYTE(v22) & 0xF;
    goto LABEL_31;
  }

  uint64_t v24 = v19 & 0xFFFFFFFFFFFFLL;
LABEL_31:
  _StringGuts.append(_:)(v21, v22, 0LL, v24);
  swift_bridgeObjectRelease(v22);
  unint64_t v21 = v36;
  unint64_t v22 = v37;
LABEL_32:
  uint64_t v30 = HIBYTE(v22) & 0xF;
  if ((v22 & 0x2000000000000000LL) == 0) {
    uint64_t v30 = v21 & 0xFFFFFFFFFFFFLL;
  }
  if (v30 || (v21 & ~v22 & 0x2000000000000000LL) != 0)
  {
    if ((v22 & 0x2000000000000000LL) == 0
      || (unint64_t v33 = specialized _SmallString.init(_:appending:)(v21, v22, 0x27uLL, 0xE100000000000000LL), (v35 & 1) != 0))
    {
      _StringGuts.append(_:)(39LL, 0xE100000000000000LL, 0LL, 1LL);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      uint64_t v32 = v36;
      unint64_t v31 = v37;
    }

    else
    {
      uint64_t v32 = v33;
      unint64_t v31 = v34;
      swift_bridgeObjectRelease(v22);
      swift_bridgeObjectRelease(0xE100000000000000LL);
    }
  }

  else
  {
    swift_bridgeObjectRelease(v22);
    unint64_t v31 = 0xE100000000000000LL;
    uint64_t v32 = 39LL;
  }

  _assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)v32, v31, 0);
}

void _diagnoseUnavailableCodeReached_aeic()()
{
}

Builtin::Int1 __swiftcall _stdlib_isOSVersionAtLeast(_:_:_:)(Builtin::Word a1, Builtin::Word a2, Builtin::Word a3)
{
  return __isPlatformVersionAtLeast(3LL, a1, a2, a3) != 0;
}

void _diagnoseUnavailableCodeReached()()
{
}

uint64_t BidirectionalCollection.index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v23 = a5;
  uint64_t v9 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  int64_t v16 = (char *)&v22 - v15;
  int64_t v17 = *(void (**)(char *, uint64_t, unint64_t))(v11 + 16);
  if (a2 < 0)
  {
    v17(v14, a1, AssociatedTypeWitness);
    uint64_t v19 = 0LL;
    unint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(a4 + 40);
    do
    {
      --v19;
      v20(v14, a3, a4);
    }

    while (v19 > a2);
    int64_t v16 = v14;
  }

  else
  {
    v17((char *)&v22 - v15, a1, AssociatedTypeWitness);
    if (a2)
    {
      char v18 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 192);
      do
      {
        v18(v16, a3, v9);
        --a2;
      }

      while (a2);
    }
  }

  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v11 + 32))(v23, v16, AssociatedTypeWitness);
}

uint64_t BidirectionalCollection.index(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v32 = a6;
  uint64_t v11 = *(void *)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v15 = (char *)&v30 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  int64_t v17 = (char *)&v30 - v16;
  uint64_t v31 = v18;
  uint64_t v19 = *(void (**)(char *, uint64_t, unint64_t))(v18 + 16);
  if (a2 < 0)
  {
    v19(v15, a1, AssociatedTypeWitness);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    uint64_t v25 = 0LL;
    uint64_t v26 = *(void *)(AssociatedConformanceWitness + 8);
    char v27 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v26 + 8);
    while ((v27(v15, a3, AssociatedTypeWitness, v26) & 1) == 0)
    {
      --v25;
      (*(void (**)(char *, uint64_t, uint64_t))(a5 + 40))(v15, a4, a5);
      if (v25 <= a2)
      {
        uint64_t v23 = v31;
        uint64_t v22 = v32;
        (*(void (**)(uint64_t, char *, unint64_t))(v31 + 32))(v32, v15, AssociatedTypeWitness);
        goto LABEL_11;
      }
    }

    uint64_t v23 = v31;
    (*(void (**)(char *, unint64_t))(v31 + 8))(v15, AssociatedTypeWitness);
    goto LABEL_14;
  }

  v19((char *)&v30 - v16, a1, AssociatedTypeWitness);
  if (a2)
  {
    uint64_t v20 = *(void *)(swift_getAssociatedConformanceWitness( v11,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    unint64_t v21 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v20 + 8);
    while ((v21(v17, a3, AssociatedTypeWitness, v20) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 192))(v17, a4, v11);
      if (!--a2) {
        goto LABEL_6;
      }
    }

    uint64_t v23 = v31;
    (*(void (**)(char *, unint64_t))(v31 + 8))(v17, AssociatedTypeWitness);
LABEL_14:
    uint64_t v28 = 1LL;
    uint64_t v22 = v32;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v23 + 56))( v22,  v28,  1LL,  AssociatedTypeWitness);
  }

Swift::UInt64 specialized BidirectionalCollection._index(_:offsetBy:)( Swift::String::Index a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a2;
  if (a2 < 0)
  {
    uint64_t v26 = 0LL;
    unint64_t v27 = HIBYTE(a4) & 0xF;
    if ((a4 & 0x2000000000000000LL) != 0) {
      uint64_t v28 = HIBYTE(a4) & 0xF;
    }
    else {
      uint64_t v28 = a3 & 0xFFFFFFFFFFFFLL;
    }
    if ((a4 & 0x2000000000000000LL) != 0) {
      uint64_t v29 = (a4 >> 62) & 1;
    }
    else {
      uint64_t v29 = a3 < 0;
    }
    uint64_t v30 = ((unint64_t)a3 >> 59) & 1;
    Swift::UInt64 v31 = 4 * v28;
    uint64_t v32 = a4 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v33 = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v3_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = 1;
    }
    uint64_t v34 = 4LL << v30;
    while (1)
    {
      if ((a1._rawBits & 0xC) == v34)
      {
        Swift::UInt64 rawBits = a1._rawBits;
        uint64_t v40 = v29;
        uint64_t v41 = v32;
        uint64_t v56 = v33;
        v42._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
        uint64_t v33 = v56;
        uint64_t v32 = v41;
        uint64_t v29 = v40;
        a1._Swift::UInt64 rawBits = v42._rawBits;
        if (v42._rawBits < 0x4000)
        {
LABEL_78:
          unint64_t v53 = 175LL;
          goto LABEL_79;
        }
      }

      else if (a1._rawBits < 0x4000)
      {
        goto LABEL_78;
      }

      if (v31 < a1._rawBits >> 14) {
        goto LABEL_78;
      }
      if ((a4 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v43 = a1._rawBits;
        uint64_t v44 = v29;
        uint64_t v45 = v32;
        uint64_t v56 = v33;
        Swift::UInt64 v46 = specialized String.UTF16View._foreignIndex(before:)(v43);
        uint64_t v33 = v56;
        uint64_t v32 = v45;
        uint64_t v29 = v44;
        a1._Swift::UInt64 rawBits = v46;
      }

      else if ((v29 & 1) != 0)
      {
        a1._Swift::UInt64 rawBits = (a1._rawBits & 0xFFFFFFFFFFFF0000LL) - 65523;
      }

      else
      {
        if ((a1._rawBits & 0xC000) == 0)
        {
          if ((a1._rawBits & 1) != 0)
          {
            Swift::UInt64 v35 = a1._rawBits >> 16;
            if ((a4 & 0x2000000000000000LL) == 0) {
              goto LABEL_53;
            }
LABEL_64:
            uint64_t v57 = a3;
            uint64_t v58 = v32;
            if (a1._rawBits < 0x10000) {
              goto LABEL_76;
            }
            if (v35 > v27) {
LABEL_81:
            }
              _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
            uint64_t v38 = 0LL;
            while ((*((_BYTE *)&v57 + v35 + v38 - 1) & 0xC0) == 0x80)
            {
              --v38;
              if (!(v35 + v38)) {
                goto LABEL_76;
              }
            }
          }

          else
          {
            Swift::UInt64 v47 = a1._rawBits;
            uint64_t v48 = v29;
            uint64_t v49 = v32;
            uint64_t v56 = v33;
            v50._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v47)._rawBits;
            uint64_t v33 = v56;
            uint64_t v32 = v49;
            uint64_t v29 = v48;
            a1._Swift::UInt64 rawBits = v50._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
            Swift::UInt64 v35 = a1._rawBits >> 16;
            if ((a4 & 0x2000000000000000LL) != 0) {
              goto LABEL_64;
            }
LABEL_53:
            unint64_t v36 = (char *)v33;
            uint64_t v37 = a3 & 0xFFFFFFFFFFFFLL;
            if ((a3 & 0x1000000000000000LL) != 0)
            {
              if (a1._rawBits < 0x10000) {
                goto LABEL_76;
              }
            }

            else
            {
              unsigned int v55 = v29;
              uint64_t v54 = v32;
              uint64_t v56 = v33;
              unint64_t v36 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
              uint64_t v33 = v56;
              uint64_t v32 = v54;
              uint64_t v29 = v55;
              if (a1._rawBits < 0x10000) {
LABEL_76:
              }
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
            }

            uint64_t v38 = 0LL;
            while ((v36[v35 - 1 + v38] & 0xC0) == 0x80)
            {
            }
          }

          uint64_t v51 = 1 - v38;
          if (v51 == 4) {
            a1._Swift::UInt64 rawBits = (a1._rawBits & 0xFFFFFFFFFFFF0000LL) - 245756;
          }
          else {
            a1._Swift::UInt64 rawBits = ((v35 - v51) << 16) | 5;
          }
          goto LABEL_73;
        }

        a1._Swift::UInt64 rawBits = a1._rawBits & 0xFFFFFFFFFFFF0000LL | 5;
      }

LABEL_73:
      if (--v26 <= v6) {
        return a1._rawBits;
      }
    }
  }

  if (a2)
  {
    if ((a4 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v8 = HIBYTE(a4) & 0xF;
    }
    else {
      Swift::UInt64 v8 = a3 & 0xFFFFFFFFFFFFLL;
    }
    if ((a4 & 0x2000000000000000LL) != 0) {
      BOOL v9 = (a4 & 0x4000000000000000LL) != 0;
    }
    else {
      BOOL v9 = a3 < 0;
    }
    uint64_t v10 = ((unint64_t)a3 >> 59) & 1;
    uint64_t v11 = a4 & 0xFFFFFFFFFFFFFFLL;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v1_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = 1;
    }
    uint64_t v12 = 4LL << v10;
    do
    {
      if ((a1._rawBits & 0xC) == v12)
      {
        Swift::UInt64 v17 = a1._rawBits;
        uint64_t v18 = v11;
        v19._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v17)._rawBits;
        uint64_t v11 = v18;
        a1._Swift::UInt64 rawBits = v19._rawBits;
      }

      Swift::UInt64 v13 = a1._rawBits >> 16;
      if (a1._rawBits >> 16 >= v8)
      {
        unint64_t v53 = 147LL;
LABEL_79:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  v53,  0);
      }

      if ((a4 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v20 = a1._rawBits;
        uint64_t v21 = v11;
        Swift::UInt64 v22 = specialized String.UTF16View._foreignIndex(after:)(v20);
        uint64_t v11 = v21;
        a1._Swift::UInt64 rawBits = v22;
        goto LABEL_13;
      }

      if (v9)
      {
        a1._Swift::UInt64 rawBits = (a1._rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
        goto LABEL_13;
      }

      if ((a1._rawBits & 0xC001) != 0)
      {
        if ((a4 & 0x2000000000000000LL) == 0) {
          goto LABEL_21;
        }
      }

      else
      {
        Swift::UInt64 v23 = a1._rawBits;
        uint64_t v24 = v11;
        v25._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v23)._rawBits;
        uint64_t v11 = v24;
        a1._Swift::UInt64 rawBits = v25._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
        Swift::UInt64 v13 = v25._rawBits >> 16;
        if ((a4 & 0x2000000000000000LL) == 0)
        {
LABEL_21:
          uint64_t v14 = (unsigned __int8 *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a3 & 0x1000000000000000LL) == 0)
          {
            uint64_t v56 = v11;
            uint64_t v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a3, a4);
            uint64_t v11 = v56;
          }

          int v15 = v14[v13];
          if ((v15 & 0x80) == 0)
          {
LABEL_32:
            uint64_t v16 = 1LL;
            goto LABEL_33;
          }

          goto LABEL_24;
        }
      }

      uint64_t v57 = a3;
      uint64_t v58 = v11;
      int v15 = *((unsigned __int8 *)&v57 + v13);
      if ((v15 & 0x80) == 0) {
        goto LABEL_32;
      }
LABEL_24:
      LODWORD(v16) = __clz(v15 ^ 0xFF) - 24;
      if ((_DWORD)v16 != 4)
      {
        uint64_t v16 = v16;
        goto LABEL_33;
      }

      if ((a1._rawBits & 0xC000) != 0)
      {
        uint64_t v16 = 4LL;
LABEL_33:
        a1._Swift::UInt64 rawBits = (a1._rawBits + (v16 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
        goto LABEL_13;
      }

      a1._Swift::UInt64 rawBits = a1._rawBits & 0xFFFFFFFFFFFF0000LL | 0x4004;
LABEL_13:
      --v6;
    }

    while (v6);
  }

  return a1._rawBits;
}

        uint64_t v57 = 1 - v44;
        if (v57 == 4) {
          a1._Swift::UInt64 rawBits = (a1._rawBits & 0xFFFFFFFFFFFF0000LL) - 245756;
        }
        else {
          a1._Swift::UInt64 rawBits = ((v41 - v57) << 16) | 5;
        }
      }

      if (--v31 <= v8) {
        return a1._rawBits;
      }
    }

    return 0LL;
  }

  else if (a2)
  {
    uint64_t v10 = ((unint64_t)a4 >> 59) & 1;
    if ((a5 & 0x1000000000000000LL) == 0) {
      LOBYTE(v1_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = 1;
    }
    uint64_t v11 = 4LL << v10;
    if ((a5 & 0x2000000000000000LL) != 0) {
      uint64_t v12 = HIBYTE(a5) & 0xF;
    }
    else {
      uint64_t v12 = a4 & 0xFFFFFFFFFFFFLL;
    }
    if ((a5 & 0x2000000000000000LL) != 0) {
      Swift::UInt64 v13 = (a5 & 0x4000000000000000LL) != 0;
    }
    else {
      Swift::UInt64 v13 = a4 < 0;
    }
    uint64_t v14 = a5 & 0xFFFFFFFFFFFFFFLL;
    int v15 = (a5 & 0xFFFFFFFFFFFFFFFLL) + 32;
    do
    {
      if ((a1._rawBits ^ a3) < 0x4000) {
        return 0LL;
      }
      if ((a1._rawBits & 0xC) == v11)
      {
        uint64_t v18 = a1._rawBits;
        Swift::String::Index v19 = v14;
        Swift::UInt64 v20 = v15;
        v21._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v18)._rawBits;
        int v15 = v20;
        uint64_t v14 = v19;
        a1._Swift::UInt64 rawBits = v21._rawBits;
      }

      uint64_t v16 = a1._rawBits >> 16;
      if (a1._rawBits >> 16 >= v12)
      {
        uint64_t v58 = 147LL;
LABEL_81:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF16View.swift",  27LL,  2,  v58,  0);
      }

      if ((a5 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v22 = a1._rawBits;
        Swift::UInt64 v23 = v14;
        uint64_t v24 = v15;
        Swift::String::Index v25 = specialized String.UTF16View._foreignIndex(after:)(v22);
        int v15 = v24;
        uint64_t v14 = v23;
        a1._Swift::UInt64 rawBits = v25;
        goto LABEL_13;
      }

      if (v13)
      {
        a1._Swift::UInt64 rawBits = (a1._rawBits & 0xFFFFFFFFFFFF0000LL) + 65549;
        goto LABEL_13;
      }

      if ((a1._rawBits & 0xC001) != 0)
      {
        if ((a5 & 0x2000000000000000LL) == 0) {
          goto LABEL_22;
        }
      }

      else
      {
        uint64_t v26 = a1._rawBits;
        unint64_t v27 = v14;
        uint64_t v28 = v15;
        v29._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v26)._rawBits;
        int v15 = v28;
        uint64_t v14 = v27;
        a1._Swift::UInt64 rawBits = v29._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
        uint64_t v16 = v29._rawBits >> 16;
        if ((a5 & 0x2000000000000000LL) == 0)
        {
LABEL_22:
          if ((a4 & 0x1000000000000000LL) != 0)
          {
            LODWORD(v17) = *(unsigned __int8 *)(v15 + v16);
            if ((v17 & 0x80) == 0) {
              goto LABEL_32;
            }
          }

          else
          {
            uint64_t v66 = v15;
            uint64_t v71 = v14;
            uint64_t v30 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a4, a5);
            int v15 = v66;
            uint64_t v14 = v71;
            LODWORD(v17) = v30[v16];
            if ((v17 & 0x80) == 0)
            {
LABEL_32:
              Swift::UInt64 v17 = 1LL;
              goto LABEL_33;
            }
          }

          goto LABEL_24;
        }
      }

      uint64_t v72 = a4;
      uint64_t v73 = v14;
      LODWORD(v17) = *((unsigned __int8 *)&v72 + v16);
      if ((v17 & 0x80) == 0) {
        goto LABEL_32;
      }
LABEL_24:
      LODWORD(v17) = __clz(v17 ^ 0xFF) - 24;
      if ((_DWORD)v17 != 4)
      {
        Swift::UInt64 v17 = v17;
        goto LABEL_33;
      }

      if ((a1._rawBits & 0xC000) != 0)
      {
        Swift::UInt64 v17 = 4LL;
LABEL_33:
        a1._Swift::UInt64 rawBits = (a1._rawBits + (v17 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
        goto LABEL_13;
      }

      a1._Swift::UInt64 rawBits = a1._rawBits & 0xFFFFFFFFFFFF0000LL | 0x4004;
LABEL_13:
      --v8;
    }

    while (v8);
  }

  return a1._rawBits;
}

  unint64_t v78 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, v5);
  uint64_t v81 = (v79 & 1) == 0 && v78 >= v14;
  if ((v75 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v14 = v260;
    if (v81)
    {
LABEL_110:
      _StringGuts.grow(_:)(v74);
      goto LABEL_111;
    }

              uint64_t v84 = v46 & 0xFFFFFFFFFFFFLL;
              if ((v14 & 0x2000000000000000LL) != 0) {
                uint64_t v84 = HIBYTE(v14) & 0xF;
              }
              if (v84 >= rawBits >> 16)
              {
                uint64_t v85 = String.UTF8View._foreignDistance(from:to:)( (Swift::String::Index)15LL,  (Swift::String::Index)rawBits);
                swift_bridgeObjectRelease(v14);
                char v52 = __OFADD__(v35, v85);
                v35 += v85;
                if (!v52) {
                  goto LABEL_56;
                }
                goto LABEL_78;
              }

      uint64_t v66 = v73;
      if (!v73 || v74 == v73) {
        return;
      }
      unint64_t v67 = (int *)specialized _pop<A>(from:as:count:)(&v73, 1LL);
      if (!v67) {
        goto LABEL_82;
      }
      v68._rawValue = (Builtin::RawPointer)(v66 + *v67);
      if (!v68._rawValue) {
        goto LABEL_82;
      }
      uint64_t v69 = _resolveKeyPathGenericArgReference(_:genericEnvironment:arguments:)(v68, a2[2], a2[3])._rawValue;
      v72[0] = (uint64_t)v69;
      MetatypeMetadata = swift_getMetatypeMetadata((uint64_t)v69);
      InstantiateKeyPathBuffer.pushDest<A>(_:)(v72, MetatypeMetadata);
      a2[4].value._rawValue = v69;
    }

    uint64_t v5 = v73;
    if (!v73) {
      return;
    }
  }

          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
        }

        if (!v43) {
          goto LABEL_119;
        }
        Swift::UInt64 v46 = *(unsigned __int16 *)&v43[v18];
      }

      if (v46 != 2573 && (v46 & 0x80808080) == 0) {
        goto LABEL_70;
      }
    }

    Swift::UInt64 v17 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v18);
  }

      uint64_t v91 = v61 & 0xFFFFFFFFFFFFLL;
      goto LABEL_74;
    }

    if ((v62 & 0x2000000000000000LL) == 0) {
      goto LABEL_73;
    }
    v248 = v2;
    v209 = v40;
    v210 = v33;
    v211 = v1;
    v212 = specialized _SmallString.init(_:appending:)(v273, v274, v61, v62);
    if ((v63 & 1) != 0)
    {
      uint64_t v91 = HIBYTE(v88) & 0xF;
      uint64_t v33 = v210;
      uint64_t v40 = v209;
      unint64_t v2 = v248;
      goto LABEL_74;
    }

    v213 = v212;
    v214 = v62;
    swift_bridgeObjectRelease(v89);
    swift_bridgeObjectRelease(v88);
    v273 = v213;
    v274 = v214;
    uint64_t v88 = v214;
    uint64_t v87 = v213;
    uint64_t v1 = v211;
    uint64_t v33 = v210;
    uint64_t v40 = v209;
    unint64_t v2 = v248;
  }

  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = v87;
    v274 = v88;
  }

        unint64_t v7 = 0LL;
        *a2 = 0;
        return v7;
      }

      if ((v5 & 0x8000) == 0)
      {
        if (a3 < 4) {
          goto LABEL_73;
        }
        unint64_t v36 = 6712937;
        goto LABEL_54;
      }

      if (a3 < 5) {
        goto LABEL_73;
      }
      a2[4] = 0;
      uint64_t v38 = 1718511917;
      goto LABEL_67;
    }

    Swift::UInt64 v8 = v6 - 14;
    BOOL v9 = v5 & 0x3FF | 0x400;
  }

  else
  {
    if ((v5 & 0x3FF) == 0)
    {
      if ((v5 & 0x8000) == 0)
      {
        if (a3 < 4) {
          goto LABEL_73;
        }
        unint64_t v36 = 3157552;
LABEL_54:
        *(_DWORD *)a2 = v36;
        return 3LL;
      }

      if (a3 < 5) {
        goto LABEL_73;
      }
      a2[4] = 0;
      uint64_t v38 = 808333357;
LABEL_67:
      *(_DWORD *)a2 = v38;
      return 4LL;
    }

    Swift::UInt64 v8 = -13;
    BOOL v9 = v5 & 0x3FF;
  }

  if ((v5 & 0x3FF) != 0) {
    uint64_t v10 = -2;
  }
  else {
    uint64_t v10 = -1;
  }
  if (a3 <= 3) {
    goto LABEL_73;
  }
  uint64_t v11 = 4 * v9;
  uint64_t v12 = a2;
  if ((v5 & 0x8000) != 0)
  {
    *a2 = 45;
    uint64_t v12 = a2 + 1;
  }

  Swift::UInt64 v13 = (4 * (v9 & 0x7FF)) | 2;
  uint64_t v14 = v10 + v11;
  if (v9 <= 0x68D && v8 == -13)
  {
    int v15 = 400000 * v13;
    uint64_t v16 = 400000 * v14;
    Swift::UInt64 v17 = 1600000 * v9;
    uint64_t v18 = 40000000 * v13;
    Swift::String::Index v19 = 40000000 * v14;
    if (v9 > 0x10) {
      Swift::String::Index v19 = v16;
    }
    else {
      Swift::UInt64 v17 = 160000000 * v9;
    }
    if (v9 > 0x10)
    {
      Swift::UInt64 v20 = -5;
    }

    else
    {
      int v15 = v18;
      Swift::UInt64 v20 = -7;
    }

    uint64_t v21 = 10 * v15;
    Swift::UInt64 v22 = 10 * v19;
    if (v17 >> 28) {
      Swift::UInt64 v23 = v17;
    }
    else {
      Swift::UInt64 v23 = 10 * v17;
    }
    if (v17 >> 28)
    {
      Swift::UInt64 v22 = v19;
      uint64_t v21 = v15;
      uint64_t v24 = v20;
    }

    else
    {
      uint64_t v24 = v20 - 1;
    }

    if (!((v21 ^ v22) >> 28))
    {
      if (v12 > &a2[a3 - 6]) {
        goto LABEL_73;
      }
      *uint64_t v12 = (v23 >> 28) | 0x30;
      Swift::String::Index v25 = v12 + 2;
      v12[1] = 46;
      uint64_t v26 = 5 * (v21 & 0xFFFFFFF);
      unint64_t v27 = 10 * (v22 & 0xFFFFFFF);
      uint64_t v28 = (v26 >> 27) & 0xF;
      if (v28 == v27 >> 28)
      {
        uint64_t v29 = 2 * v26;
        do
        {
          *v25++ = v28 | 0x30;
          v23 *= 10;
          uint64_t v30 = 5 * (v29 & 0xFFFFFFE);
          uint64_t v29 = 10 * (v29 & 0xFFFFFFE);
          unint64_t v27 = 10 * (v27 & 0xFFFFFFE);
          uint64_t v28 = (v30 >> 27) & 0xF;
        }

        while (v28 == v27 >> 28);
      }

      Swift::UInt64 v23 = 10 * (v23 & 0xFFFFFFF);
      uint64_t v12 = v25;
    }

    if (v12 > &a2[a3 - 6]) {
      goto LABEL_73;
    }
    *uint64_t v12 = ((v23 + 0x8000000) >> 28) | 0x30;
    *(_WORD *)(v12 + 1) = 11621;
    *(_WORD *)(v12 + 3) = *(_WORD *)&asciiDigitTable[-2 * v24];
    v12[5] = 0;
    return v12 + 5 - a2;
  }

  else
  {
    Swift::UInt64 v31 = (unsigned __int16)(v11 - ((unsigned __int16)(v11 >> (13 - v8)) << (13 - v8)));
    if (v8 <= 12) {
      uint64_t v32 = v11 >> (13 - v8);
    }
    else {
      uint64_t v32 = v11 << (v8 - 13);
    }
    if (v8 <= 12) {
      uint64_t v33 = v31;
    }
    else {
      uint64_t v33 = 0;
    }
    uint64_t v34 = &a2[a3];
    if (v32 > 9)
    {
      if (v32 > 0x3E7)
      {
        if (v12 > v34 - 6) {
          goto LABEL_73;
        }
        if (v32 >> 4 >= 0x271)
        {
          *v12++ = v32 / 0x2710 + 48;
          v32 %= 0x2710u;
        }

        *(_WORD *)uint64_t v12 = *(_WORD *)&asciiDigitTable[2 * ((unsigned __int16)v32 / 0x64u)];
        *((_WORD *)v12 + 1) = *(_WORD *)&asciiDigitTable[2 * ((unsigned __int16)v32 % 0x64u)];
        Swift::UInt64 v35 = v12 + 4;
      }

      else
      {
        if (v12 > v34 - 4) {
          goto LABEL_73;
        }
        if (v32 >= 0x64) {
          *v12++ = (unsigned __int16)v32 / 0x64u + 48;
        }
        *(_WORD *)uint64_t v12 = *(_WORD *)&asciiDigitTable[2 * ((unsigned __int16)v32 % 0x64u)];
        Swift::UInt64 v35 = v12 + 2;
      }
    }

    else
    {
      if (v12 > v34 - 3) {
        goto LABEL_73;
      }
      *uint64_t v12 = v32 + 48;
      Swift::UInt64 v35 = v12 + 1;
    }

    uint64_t v39 = (unint64_t)&a2[a3 - 3];
    *Swift::UInt64 v35 = 46;
    uint64_t v41 = v35 + 1;
    if (!v33)
    {
      *(_WORD *)(v35 + 1) = 48;
      return v35 - a2 + 2;
    }

    Swift::String::Index v42 = v33 << (v8 + 15);
    Swift::UInt64 v43 = 5 * ((v13 << (v8 + 15)) & 0xFFFFFFE);
    uint64_t v44 = (v14 << (v8 + 15)) & 0xFFFFFFF;
    uint64_t v45 = (v43 >> 27) & 0xF;
    Swift::UInt64 v46 = ((5 * v44) >> 27) & 0xF;
    if (v45 == v46)
    {
      Swift::UInt64 v47 = 2 * v43;
      uint64_t v48 = 10 * v44;
      while ((unint64_t)v41 <= v39)
      {
        v42 *= 10;
        *(_BYTE *)uint64_t v41 = v45 | 0x30;
        uint64_t v41 = (_WORD *)((char *)v41 + 1);
        uint64_t v49 = 5 * (v47 & 0xFFFFFFE);
        Swift::UInt64 v47 = 10 * (v47 & 0xFFFFFFE);
        uint64_t v44 = v48 & 0xFFFFFFE;
        uint64_t v48 = 10 * (v48 & 0xFFFFFFE);
        uint64_t v45 = (v49 >> 27) & 0xF;
        Swift::UInt64 v46 = ((5 * v44) >> 27) & 0xF;
        if (v45 != v46) {
          goto LABEL_80;
        }
      }

      goto LABEL_73;
    }

  std::string::push_back((std::string *)this, 62);
}

  *(_DWORD *)(v5 + 12736) = v42 + 1;
  v44[v42] = 115;
  if (!v19) {
    goto LABEL_74;
  }
LABEL_53:
  if (v26)
  {
LABEL_54:
    uint64_t v41 = strlen(v26);
    goto LABEL_92;
  }

      if (v32 == v40)
      {
LABEL_77:
        *(_DWORD *)a4 = 0;
        *(void *)(a4 + 8) = 0LL;
        *(_DWORD *)(a4 + 16) = 0;
        Swift::UInt64 v20 = v6 + 1592;
        uint64_t v21 = *((_DWORD *)v6 + 3184);
        Swift::String::Index v42 = *((unsigned int *)v6 + 3185);
        Swift::UInt64 v23 = (char *)v6[1591];
        Swift::UInt64 v43 = (void *)v6[1593];
        uint64_t v44 = (char *)v43[1];
        if (&v23[v42] == v44)
        {
          Swift::UInt64 v46 = (unint64_t)&v23[v42 + 1];
          uint64_t v45 = v43[2];
          if (v46 <= v45)
          {
            v43[1] = v46;
            LODWORD(v47) = 1;
LABEL_96:
            uint64_t v39 = v42 + v47;
            goto LABEL_97;
          }
        }

        else
        {
          uint64_t v45 = v43[2];
        }

        else {
          Swift::UInt64 v47 = (2 * v42);
        }
        uint64_t v48 = v47 + v42;
        if (v44) {
          uint64_t v49 = (unint64_t)&v44[v47 + v42] > v45;
        }
        else {
          uint64_t v49 = 1;
        }
        Swift::UInt64 v23 = (char *)v43[1];
        if (v49)
        {
          Swift::String::Index v50 = 2LL * v43[4];
          if (v50 <= v48 + 1) {
            Swift::String::Index v50 = v48 + 1;
          }
          v43[4] = v50;
          uint64_t v51 = v50 + 8;
          uint64_t result = malloc(v50 + 8);
          char v52 = (char *)result + v51;
          *uint64_t result = v43[3];
          Swift::UInt64 v23 = (char *)(result + 1);
          v43[2] = v52;
          v43[3] = result;
        }

        v43[1] = &v23[v48];
        if ((_DWORD)v42)
        {
          uint64_t result = memcpy(v23, (const void *)v6[1591], v42);
          LODWORD(v42) = *((_DWORD *)v6 + 3185);
          uint64_t v21 = *((_DWORD *)v6 + 3184);
        }

        v6[1591] = v23;
        goto LABEL_96;
      }

      uint64_t v41 = a3 + 2;
      while (1)
      {
        if (*(_DWORD *)a4) {
          return result;
        }
        if (++v32 == v40) {
          goto LABEL_77;
        }
      }

    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
      goto LABEL_99;
    case 0x18:
    case 0x3D:
      goto LABEL_9;
    case 0x47:
      goto LABEL_14;
    default:
      if (v10 != 1)
      {
        uint64_t v11 = 0;
        if (v10 != 219) {
          goto LABEL_99;
        }
LABEL_9:
        uint64_t v14 = *((unsigned __int8 *)a2 + 18);
        if ((v14 - 1) >= 2)
        {
          if (v14 != 5 || !*((_DWORD *)a2 + 2))
          {
            int v15 = 0LL;
LABEL_28:
            if (*(_DWORD *)a4) {
              return result;
            }
            Swift::UInt64 v20 = v6 + 1592;
            uint64_t v21 = *((_DWORD *)v6 + 3184);
            Swift::UInt64 v22 = *((unsigned int *)v6 + 3185);
            Swift::UInt64 v23 = (char *)v6[1591];
            uint64_t v24 = (void *)v6[1593];
            Swift::String::Index v25 = (char *)v24[1];
            if (&v23[v22] == v25)
            {
              uint64_t v34 = (unint64_t)&v23[v22 + 1];
              uint64_t v26 = v24[2];
              if (v34 <= v26)
              {
                v24[1] = v34;
                uint64_t v39 = v22 + 1;
LABEL_97:
                *((_DWORD *)v6 + 3185) = v39;
LABEL_98:
                BOOL v9 = 0;
                Swift::UInt64 v8 = 0LL;
                uint64_t v11 = 0;
                char *v20 = v21 + 1;
                v23[v21] = 95;
                goto LABEL_99;
              }
            }

            else
            {
              uint64_t v26 = v24[2];
            }

            else {
              Swift::UInt64 v35 = (2 * v22);
            }
            unint64_t v36 = v35 + v22;
            if (!v25 || (unint64_t)&v25[v36] > v26)
            {
              uint64_t v37 = 2LL * v24[4];
              if (v37 <= v36 + 1) {
                uint64_t v37 = v36 + 1;
              }
              void v24[4] = v37;
              uint64_t v38 = v37 + 8;
              uint64_t result = malloc(v37 + 8);
              *uint64_t result = v24[3];
              Swift::String::Index v25 = (char *)(result + 1);
              uint64_t v24[2] = (char *)result + v38;
              v24[3] = result;
            }

            v24[1] = &v25[v36];
            if ((_DWORD)v22)
            {
              uint64_t result = memcpy(v25, (const void *)v6[1591], v22);
              LODWORD(v22) = *((_DWORD *)v6 + 3185);
              uint64_t v21 = *((_DWORD *)v6 + 3184);
            }

            v6[1591] = v25;
            Swift::UInt64 v23 = v25;
            uint64_t v39 = v22 + v35;
            goto LABEL_97;
          }

          uint64_t v5 = (uint64_t *)*a2;
        }

        int v15 = (uint64_t *)*v5;
        goto LABEL_28;
      }

Swift::UInt64 specialized BidirectionalCollection._index(_:offsetBy:)( Swift::UInt64 result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 < 0)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = (a3 >> 59) & 1;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v1_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = 1;
    }
    uint64_t v11 = 4LL << v10;
    if ((a4 & 0x2000000000000000LL) != 0) {
      unint64_t v12 = HIBYTE(a4) & 0xF;
    }
    else {
      unint64_t v12 = a3 & 0xFFFFFFFFFFFFLL;
    }
    do
    {
      if ((result & 0xC) == v11)
      {
        uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)result)._rawBits;
        if (!(result >> 14))
        {
LABEL_31:
          unint64_t v13 = 152LL;
          goto LABEL_32;
        }
      }

      else if (!(result >> 14))
      {
        goto LABEL_31;
      }

      if ((a4 & 0x1000000000000000LL) != 0)
      {
        if (v12 < result >> 16)
        {
          unint64_t v13 = 157LL;
LABEL_32:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v13,  0);
        }

        uint64_t result = String.UTF8View._foreignIndex(before:)((Swift::String::Index)result)._rawBits;
      }

      else
      {
        uint64_t result = (result & 0xFFFFFFFFFFFF0000LL) - 65532;
      }

      --v9;
    }

    while (v9 > v5);
  }

  else if (a2)
  {
    uint64_t v6 = (a3 >> 59) & 1;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v6) = 1;
    }
    uint64_t v7 = 4LL << v6;
    if ((a4 & 0x2000000000000000LL) != 0) {
      unint64_t v8 = HIBYTE(a4) & 0xF;
    }
    else {
      unint64_t v8 = a3 & 0xFFFFFFFFFFFFLL;
    }
    do
    {
      while ((result & 0xC) == v7)
      {
        uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)result)._rawBits;
        if ((a4 & 0x1000000000000000LL) == 0) {
          goto LABEL_10;
        }
LABEL_13:
        if (v8 <= result >> 16)
        {
          unint64_t v13 = 144LL;
          goto LABEL_32;
        }

        uint64_t result = String.UTF8View._foreignIndex(after:)((Swift::String::Index)result)._rawBits;
        if (!--v5) {
          return result;
        }
      }

      if ((a4 & 0x1000000000000000LL) != 0) {
        goto LABEL_13;
      }
LABEL_10:
      uint64_t result = (result & 0xFFFFFFFFFFFF0000LL) + 65540;
      --v5;
    }

    while (v5);
  }

  return result;
}

uint64_t BidirectionalCollection._index(_:offsetBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v23 = a5;
  uint64_t v9 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v9,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v11 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v12 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v14 = (char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v22 - v15;
  Swift::UInt64 v17 = *(void (**)(char *, uint64_t, unint64_t))(v11 + 16);
  if (a2 < 0)
  {
    v17(v14, a1, AssociatedTypeWitness);
    uint64_t v19 = 0LL;
    Swift::UInt64 v20 = *(void (**)(char *, uint64_t, uint64_t))(a4 + 40);
    do
    {
      --v19;
      v20(v14, a3, a4);
    }

    while (v19 > a2);
    uint64_t v16 = v14;
  }

  else
  {
    v17((char *)&v22 - v15, a1, AssociatedTypeWitness);
    if (a2)
    {
      uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 192);
      do
      {
        v18(v16, a3, v9);
        --a2;
      }

      while (a2);
    }
  }

  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v11 + 32))(v23, v16, AssociatedTypeWitness);
}

uint64_t Collection._advanceForward(_:by:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Only BidirectionalCollections can be advanced by a negative amount",  66LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x3C3uLL,  0);
  }
  uint64_t v7 = a2;
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a4,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 16LL))( a5,  a1,  AssociatedTypeWitness);
  if (v7)
  {
    uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 192);
    do
    {
      uint64_t result = v12(a5, a3, a4);
      --v7;
    }

    while (v7);
  }

  return result;
}

uint64_t stride<A>(from:to:by:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  return stride<A>(from:to:by:)( a1,  a2,  a3,  a4,  a5,  (uint64_t (*)(char *, char *, char *, uint64_t, const char *))StrideTo.init(_start:end:stride:),  a6);
}

uint64_t StrideTo.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = *(const char **)(a1 + 24);
  uint64_t v9 = (int *)type metadata accessor for StrideToIterator(0LL, v7, (uint64_t)v8, a2);
  uint64_t v10 = a3 + v9[11];
  uint64_t v11 = v10 + *((int *)swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v7, "index value ", 0LL) + 12);
  uint64_t v12 = *(void *)(v7 - 8);
  uint64_t v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 32);
  v13(v11, v4, v7);
  v13(a3 + v9[9], v4 + *(int *)(a1 + 36), v7);
  uint64_t v14 = v4 + *(int *)(a1 + 40);
  uint64_t v15 = a3 + v9[10];
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v8,  v7,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)(AssociatedTypeWitness - 8) + 32LL))( v15,  v14,  AssociatedTypeWitness);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 16))(a3, v11, v7);
  *(void *)uint64_t v10 = 0LL;
  *(_BYTE *)(v10 + 8) = 0;
  return result;
}

uint64_t StrideToIterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v56 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0LL, (uint64_t)&unk_189B88E40, v5, "index value ", 0LL);
  MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v51 = (uint64_t *)((char *)&v45 - v7);
  uint64_t v8 = *(void *)(a1 + 24);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  v5,  (uint64_t)&protocol requirements base descriptor for Strideable,  associated type descriptor for Strideable.Stride);
  uint64_t v54 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v11 = (char *)&v45 - v10;
  uint64_t v12 = *(void *)(*(void *)(swift_getAssociatedConformanceWitness( v8,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: SignedNumeric)
                              + 8)
                  + 16LL);
  unint64_t v13 = swift_getAssociatedTypeWitness( 0LL,  (const char *)v12,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v16 = (char *)&v45 - v15;
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  Swift::String::Index v50 = (char *)&v45 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v17);
  uint64_t v19 = (uint64_t *)(v3 + *(int *)(a1 + 44));
  char v52 = TupleTypeMetadata2;
  unint64_t v53 = (char *)&v45 - v20;
  uint64_t v21 = (uint64_t)v19 + *((int *)TupleTypeMetadata2 + 12);
  uint64_t v55 = v22;
  uint64_t v23 = *(void (**)(void))(v22 + 16);
  uint64_t v48 = v19;
  uint64_t v49 = v21;
  Swift::UInt64 v46 = v23;
  v23();
  uint64_t v24 = v3 + *(int *)(a1 + 40);
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v12,  AssociatedTypeWitness,  v13,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v13,  AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t, uint64_t))(v12 + 24))(v16, AssociatedTypeWitness, v12);
  unint64_t v26 = swift_getAssociatedConformanceWitness( v8,  v5,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Strideable,  (uint64_t)&associated conformance descriptor for Strideable.Strideable.Stride: Comparable);
  unint64_t v27 = *(uint64_t (**)(uint64_t, char *, unint64_t, unint64_t))(v26 + 40);
  uint64_t v47 = v24;
  LOBYTE(v13) = v27(v24, v11, AssociatedTypeWitness, v26);
  (*(void (**)(char *, unint64_t))(v54 + 8))(v11, AssociatedTypeWitness);
  uint64_t v28 = v3 + *(int *)(a1 + 36);
  uint64_t v29 = *(void *)(v8 + 8);
  if ((v13 & 1) != 0) {
    uint64_t v30 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v29 + 32);
  }
  else {
    uint64_t v30 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v29 + 24);
  }
  Swift::UInt64 v31 = v53;
  if ((v30(v53, v28, v5) & 1) != 0)
  {
    uint64_t v32 = v55;
    (*(void (**)(char *, uint64_t))(v55 + 8))(v31, v5);
    uint64_t v33 = 1LL;
    uint64_t v34 = v56;
  }

  else
  {
    Swift::UInt64 v35 = v51;
    unint64_t v36 = (char *)v51 + *((int *)v52 + 12);
    uint64_t v38 = v48;
    uint64_t v37 = v49;
    uint64_t v39 = *v48;
    uint64_t v40 = *((unsigned __int8 *)v48 + 8);
    *uint64_t v51 = *v48;
    *((_BYTE *)v35 + 8) = v40;
    ((void (*)(char *, uint64_t, uint64_t))v46)(v36, v37, v5);
    uint64_t v41 = v50;
    uint64_t v42 = (*(uint64_t (**)(char *, uint64_t, uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 56))( v50,  v39,  v40,  v36,  v3,  v47,  v5,  v8);
    LOBYTE(v4_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = v43;
    uint64_t v32 = v55;
    (*(void (**)(char *, uint64_t))(v55 + 8))(v36, v5);
    *uint64_t v38 = v42;
    *((_BYTE *)v38 + 8) = v40 & 1;
    (*(void (**)(uint64_t, char *, uint64_t))(v32 + 40))(v37, v41, v5);
    uint64_t v34 = v56;
    (*(void (**)(uint64_t, char *, uint64_t))(v32 + 32))(v56, v31, v5);
    uint64_t v33 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v32 + 56))(v34, v33, 1LL, v5);
}

Swift::UInt64 specialized BidirectionalCollection._index(_:offsetBy:limitedBy:)( Swift::String::Index a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v8 = a2;
  if (a2 < 0)
  {
    uint64_t v31 = 0LL;
    uint64_t v32 = ((unint64_t)a4 >> 59) & 1;
    if ((a5 & 0x1000000000000000LL) == 0) {
      LOBYTE(v32) = 1;
    }
    uint64_t v33 = 4LL << v32;
    unint64_t v34 = HIBYTE(a5) & 0xF;
    uint64_t v35 = a4 & 0xFFFFFFFFFFFFLL;
    if ((a5 & 0x2000000000000000LL) != 0) {
      uint64_t v36 = HIBYTE(a5) & 0xF;
    }
    else {
      uint64_t v36 = a4 & 0xFFFFFFFFFFFFLL;
    }
    Swift::UInt64 v37 = 4 * v36;
    if ((a5 & 0x2000000000000000LL) != 0) {
      BOOL v38 = (a5 & 0x4000000000000000LL) != 0;
    }
    else {
      BOOL v38 = a4 < 0;
    }
    uint64_t v39 = a5 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v40 = (a5 & 0xFFFFFFFFFFFFFFFLL) + 32;
    while ((a1._rawBits ^ a3) >= 0x4000)
    {
      if ((a1._rawBits & 0xC) == v33)
      {
        Swift::UInt64 rawBits = a1._rawBits;
        uint64_t v71 = v35;
        Swift::UInt64 v46 = v37;
        BOOL v67 = v38;
        uint64_t v47 = v39;
        uint64_t v62 = v40;
        v48._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
        uint64_t v40 = v62;
        uint64_t v39 = v47;
        BOOL v38 = v67;
        Swift::UInt64 v37 = v46;
        uint64_t v35 = v71;
        a1._Swift::UInt64 rawBits = v48._rawBits;
        if (v48._rawBits < 0x4000)
        {
LABEL_80:
          unint64_t v58 = 175LL;
          goto LABEL_81;
        }
      }

      else if (a1._rawBits < 0x4000)
      {
        goto LABEL_80;
      }

      if (v37 < a1._rawBits >> 14) {
        goto LABEL_80;
      }
      if ((a5 & 0x1000000000000000LL) != 0)
      {
        Swift::UInt64 v49 = a1._rawBits;
        uint64_t v71 = v35;
        Swift::UInt64 v50 = v37;
        BOOL v68 = v38;
        uint64_t v51 = v39;
        uint64_t v63 = v40;
        Swift::UInt64 v52 = specialized String.UTF16View._foreignIndex(before:)(v49);
        uint64_t v40 = v63;
        uint64_t v39 = v51;
        BOOL v38 = v68;
        Swift::UInt64 v37 = v50;
        uint64_t v35 = v71;
        a1._Swift::UInt64 rawBits = v52;
      }

      else if (v38)
      {
        a1._Swift::UInt64 rawBits = (a1._rawBits & 0xFFFFFFFFFFFF0000LL) - 65523;
      }

      else if ((a1._rawBits & 0xC000) != 0)
      {
        a1._Swift::UInt64 rawBits = a1._rawBits & 0xFFFFFFFFFFFF0000LL | 5;
      }

      else
      {
        if ((a1._rawBits & 1) != 0)
        {
          Swift::UInt64 v41 = a1._rawBits >> 16;
          if ((a5 & 0x2000000000000000LL) == 0) {
            goto LABEL_56;
          }
        }

        else
        {
          Swift::UInt64 v53 = a1._rawBits;
          uint64_t v71 = v35;
          Swift::UInt64 v54 = v37;
          BOOL v69 = v38;
          uint64_t v55 = v39;
          uint64_t v64 = v40;
          v56._Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v53)._rawBits;
          uint64_t v40 = v64;
          uint64_t v39 = v55;
          BOOL v38 = v69;
          Swift::UInt64 v37 = v54;
          uint64_t v35 = v71;
          a1._Swift::UInt64 rawBits = v56._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
          Swift::UInt64 v41 = a1._rawBits >> 16;
          if ((a5 & 0x2000000000000000LL) == 0)
          {
LABEL_56:
            uint64_t v42 = (char *)v40;
            uint64_t v43 = v35;
            if ((a4 & 0x1000000000000000LL) != 0)
            {
              if (a1._rawBits >= 0x10000) {
                goto LABEL_58;
              }
            }

            else
            {
              uint64_t v71 = v35;
              uint64_t v60 = v39;
              Swift::UInt64 v61 = v37;
              BOOL v70 = v38;
              uint64_t v65 = v40;
              uint64_t v42 = (char *)_StringObject.sharedUTF8.getter(a4, a5);
              Swift::UInt64 v37 = v61;
              uint64_t v40 = v65;
              uint64_t v39 = v60;
              BOOL v38 = v70;
              uint64_t v35 = v71;
              if (a1._rawBits >= 0x10000)
              {
LABEL_58:
                uint64_t v44 = 0LL;
                while ((uint64_t)v41 <= v43)
                {
                  if ((v42[v41 - 1 + v44] & 0xC0) != 0x80) {
                    goto LABEL_73;
                  }
                }

LABEL_86:
                _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F6uLL,  0);
              }
            }

  uint64_t v62 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v62);
  uint64_t v63 = specialized Collection.subscript.getter(v53, (uint64_t)v46, v47);
  BOOL v68 = findInvalidRange #1 (_:) in validateUTF8(_:)(v63, v64, v65, v66);
  v370 = 0LL;
  v371 = 0xE000000000000000LL;
  if (__OFADD__(v47, 15LL))
  {
    __break(1u);
    goto LABEL_338;
  }

  BOOL v69 = v67;
  _StringGuts.reserveCapacity(_:)(v47 + 15);
  while (2)
  {
    BOOL v70 = specialized Collection.subscript.getter(v68, (uint64_t)v46, v47);
    uint64_t v74 = v370 & 0xFFFFFFFFFFFFLL;
    if ((v371 & 0x2000000000000000LL) != 0) {
      uint64_t v74 = HIBYTE(v371) & 0xF;
    }
    uint64_t v75 = __OFADD__(v74, v47);
    unint64_t v76 = v74 + v47;
    if (v75)
    {
      __break(1u);
LABEL_317:
      __break(1u);
LABEL_318:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }

    uint64_t v77 = v70;
    if (__OFADD__(v76, 3LL)) {
      goto LABEL_317;
    }
    unint64_t v78 = v71;
    uint64_t v79 = v72;
    uint64_t v80 = v73;
    _StringGuts.reserveCapacity(_:)(v76 + 3);
    uint64_t v81 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v77, v78, v79, v80);
    _StringGuts.appendInPlace(_:isASCII:)(v81, v82, 0);
    v373 = 3LL;
    v374 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v374, &v373, &v370);
    uint64_t v83 = specialized Collection.subscript.getter(v69, (uint64_t)v46, v47);
    Swift::UInt64 v46 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v83, v84, v85, v86);
    uint64_t v47 = v87;
    uint64_t v88 = validateUTF8(_:)(v46->i64, v87);
    if ((v48 & 1) != 0)
    {
      BOOL v68 = v88;
      BOOL v69 = v89;
      if (!v47) {
        goto LABEL_102;
      }
      continue;
    }

    break;
  }

  _StringGuts.appendInPlace(_:isASCII:)(v46->i8, v47, 0);
LABEL_102:
  Swift::UInt64 v52 = v370;
  uint64_t v51 = v371;
LABEL_121:
  uint64_t countAndFlagsBits = v372._countAndFlagsBits;
  unint64_t object = (unint64_t)v372._object;
  char v140 = ((unint64_t)v372._object >> 56) & 0xF;
  v141 = v372._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v141 && (v372._countAndFlagsBits & ~(uint64_t)v372._object & 0x2000000000000000LL) == 0)
  {
    v372._uint64_t countAndFlagsBits = v52;
    v372._unint64_t object = (void *)v51;
    __int128 v180 = object;
LABEL_154:
    swift_bridgeObjectRelease(v180);
    goto LABEL_155;
  }

  uint64_t v7 = v51 & 0x2000000000000000LL;
  BOOL v142 = HIBYTE(v51) & 0xF;
  uint64_t v143 = v140 + v142;
  if (v140 + v142 <= 0xF)
  {
    if (v142)
    {
      v230 = 0;
      v231 = 0LL;
      uint64_t v7 = v366;
      do
      {
        v232 = v140 + v231;
        v233 = v231 + 1;
        if (v231 >= 8) {
          v234 = v51;
        }
        else {
          v234 = v52;
        }
        v235 = v234 >> (v230 & 0x38);
        v236 = (8 * v140 + v230) & 0x38;
        v237 = (-255LL << v236) - 1;
        v238 = (unint64_t)v235 << v236;
        v239 = v238 | v237 & object;
        v240 = v238 | v237 & countAndFlagsBits;
        if (v232 < 8) {
          uint64_t countAndFlagsBits = v240;
        }
        else {
          unint64_t object = v239;
        }
        v230 += 8;
        v231 = v233;
      }

      while (v142 != v233);
    }

    else
    {
      uint64_t v7 = v366;
    }

    swift_bridgeObjectRelease(v51);
    v263 = 0xA000000000000000LL;
    if (!(countAndFlagsBits & 0x8080808080808080LL | object & 0x80808080808080LL)) {
      v263 = 0xE000000000000000LL;
    }
    v264 = (void *)(v263 & 0xFF00000000000000LL | (v143 << 56) | object & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v372._object);
    v372._uint64_t countAndFlagsBits = countAndFlagsBits;
    v372._unint64_t object = v264;
    goto LABEL_155;
  }

  uint64_t v7 = 1LL;
LABEL_129:
  if (v7) {
    uint64_t v144 = HIBYTE(v51) & 0xF;
  }
  else {
    uint64_t v144 = v52 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v51, 2LL, v48, v49);
  if ((v51 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(v51, 4LL, v145, v146);
    Swift::String::Index v149 = v144;
    if ((object & 0x1000000000000000LL) == 0) {
      goto LABEL_134;
    }
LABEL_322:
    v349 = String.UTF8View._foreignCount()();
    Swift::String::Index v151 = v349 + v149;
    if (!__OFADD__(v349, v149)) {
      goto LABEL_138;
    }
LABEL_324:
    __break(1u);
LABEL_325:
    swift_bridgeObjectRetain_n(object, 5LL, v147, v148);
    v350._Swift::UInt64 rawBits = 1LL;
    v351._Swift::UInt64 rawBits = (v52 << 16) | 1;
    v352._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v350, v351, v367, object);
    if (v352._rawBits < 0x10000) {
      v352._rawBits |= 3;
    }
    v354 = specialized Collection.count.getter(v352, v353, v367, object);
    v355 = object;
    v198 = v354;
    swift_bridgeObjectRelease(v355);
    __int128 v193 = v372._countAndFlagsBits;
    unint64_t v194 = (unint64_t)v372._object;
LABEL_182:
    if ((v194 & 0x2000000000000000LL) != 0) {
      goto LABEL_186;
    }
    v199 = (v193 & 0xFFFFFFFFFFFFLL) + v198;
    if (!__OFADD__(v193 & 0xFFFFFFFFFFFFLL, v198)) {
      goto LABEL_187;
    }
    do
    {
LABEL_185:
      __break(1u);
LABEL_186:
      v200 = HIBYTE(v194) & 0xF;
      v199 = v200 + v198;
    }

    while (__OFADD__(v200, v198));
    goto LABEL_187;
  }

  swift_bridgeObjectRetain_n(v51, 5LL, v145, v146);
  v345._Swift::UInt64 rawBits = 1LL;
  v346._Swift::UInt64 rawBits = (v144 << 16) | 1;
  v347._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v345, v346, v52, v51);
  if (v347._rawBits < 0x10000) {
    v347._rawBits |= 3;
  }
  Swift::String::Index v149 = specialized Collection.count.getter(v347, v348, v52, v51);
  swift_bridgeObjectRelease(v51);
  uint64_t countAndFlagsBits = v372._countAndFlagsBits;
  unint64_t object = (unint64_t)v372._object;
LABEL_134:
  if ((object & 0x2000000000000000LL) != 0) {
    Swift::String::Index v150 = HIBYTE(object) & 0xF;
  }
  else {
    Swift::String::Index v150 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  Swift::String::Index v151 = v150 + v149;
  if (__OFADD__(v150, v149)) {
    goto LABEL_324;
  }
LABEL_138:
  if ((countAndFlagsBits & ~object & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v151 > 15) {
      goto LABEL_144;
    }
LABEL_148:
    swift_bridgeObjectRelease_n(v51, 5LL);
    unint64_t v157 = v372._countAndFlagsBits;
    unint64_t v158 = v372._object;
    swift_bridgeObjectRetain((unint64_t)v372._object, v159, v160, v161);
    unint64_t v162 = _StringGuts._convertedToSmall()(v157, (unint64_t)v158);
    uint64_t v164 = v163;
    swift_bridgeObjectRelease((uint64_t)v158);
    v165._Swift::UInt64 rawBits = (v144 << 16) | 1;
    v166._Swift::UInt64 rawBits = 1LL;
    v167._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v166, v165, v52, v51);
    if (v167._rawBits < 0x10000) {
      v167._rawBits |= 3;
    }
    unint64_t v169 = specialized String.init(_:)(v167, v168, v52, v51);
    Swift::String::Index v171 = v170;
    swift_bridgeObjectRelease(v51);
    Swift::String::Index v172 = _StringGuts._convertedToSmall()(v169, v171);
    Swift::String::Index v174 = v173;
    swift_bridgeObjectRelease(v171);
    Swift::Int v175 = specialized _SmallString.init(_:appending:)(v162, v164, v172, v174);
    uint64_t v7 = v366;
    if ((v177 & 1) != 0) {
      goto LABEL_345;
    }
    uint64_t v178 = v175;
    unint64_t v179 = v176;
    swift_bridgeObjectRelease(v51);
    __int128 v180 = (uint64_t)v372._object;
    v372._uint64_t countAndFlagsBits = v178;
    v372._unint64_t object = v179;
    goto LABEL_154;
  }

  Swift::String::Index v152 = (unint64_t)v372._object;
  unint64_t v153 = _StringGuts.nativeUnusedCapacity.getter(v372._countAndFlagsBits, (uint64_t)v372._object);
  if ((v154 & 1) != 0) {
    goto LABEL_346;
  }
  if (v151 <= 15 && ((v152 & 0x2000000000000000LL) != 0 || v153 < v149)) {
    goto LABEL_148;
  }
LABEL_144:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v151, v149);
  swift_bridgeObjectRelease_n(v51, 4LL);
  if ((v51 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v51);
    _StringGuts._foreignAppendInPlace(_:)(v52, v51, 0LL, v144);
    swift_bridgeObjectRelease_n(v51, 2LL);
    uint64_t v7 = v366;
LABEL_155:
    unint64_t object = v368;
    goto LABEL_156;
  }

  unint64_t object = v368;
  if (v7)
  {
    swift_bridgeObjectRelease_n(v51, 2LL);
    v370 = v52;
    v371 = v51 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v155 = (char *)specialized UnsafeBufferPointer.init(rebasing:)( 0LL,  HIBYTE(v51) & 0xF,  (uint64_t)&v370,  HIBYTE(v51) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v155, v156, (v51 & 0x4000000000000000LL) != 0);
    uint64_t v7 = v366;
    swift_bridgeObjectRelease(v51);
    goto LABEL_156;
  }

  if ((v52 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v51);
    v253 = (id)((v51 & 0xFFFFFFFFFFFFFFFLL) + 32);
    v254 = v52 & 0xFFFFFFFFFFFFLL;
    uint64_t v7 = v366;
    v255 = v52 & 0xFFFFFFFFFFFFLL;
    goto LABEL_228;
  }

  v253 = _StringObject.sharedUTF8.getter(v52, v51);
  v255 = v362;
  swift_bridgeObjectRelease(v51);
  if (v255 < (v52 & 0xFFFFFFFFFFFFLL)) {
    goto LABEL_344;
  }
  v254 = v52 & 0xFFFFFFFFFFFFLL;
  uint64_t v7 = v366;
  unint64_t object = v368;
LABEL_228:
  v256 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v254, (uint64_t)v253, v255);
  _StringGuts.appendInPlace(_:isASCII:)(v256, v257, v52 < 0);
  swift_bridgeObjectRelease_n(v51, 2LL);
LABEL_156:
  uint64_t v183 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("(stringValue: ", 0xFuLL, 1);
  v184 = v372._object;
  __int128 v185 = ((unint64_t)v372._object >> 56) & 0xF;
  if (!v185 && (v372._countAndFlagsBits & ~(uint64_t)v372._object & 0x2000000000000000LL) == 0)
  {
    v372 = v183;
    swift_bridgeObjectRelease((uint64_t)v184);
    goto LABEL_169;
  }

  if (((uint64_t)v372._object & 0x2000000000000000LL) != 0)
  {
    if (((uint64_t)v183._object & 0x2000000000000000LL) != 0)
    {
      v187 = specialized _SmallString.init(_:appending:)( v372._countAndFlagsBits,  (unint64_t)v372._object,  v183._countAndFlagsBits,  (unint64_t)v183._object);
      if ((v181 & 1) != 0) {
        goto LABEL_167;
      }
      uint64_t v188 = v187;
      uint64_t v189 = v184;
      swift_bridgeObjectRelease((uint64_t)v183._object);
      swift_bridgeObjectRelease((uint64_t)v372._object);
      v372._uint64_t countAndFlagsBits = v188;
      v372._unint64_t object = v189;
      goto LABEL_169;
    }

  uint64_t v62 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
  swift_willThrow();
  swift_errorRelease(v62);
  uint64_t v63 = specialized Collection.subscript.getter(v53, (uint64_t)v46, v47);
  BOOL v68 = findInvalidRange #1 (_:) in validateUTF8(_:)(v63, v64, v65, v66);
  v364 = 0LL;
  v365 = 0xE000000000000000LL;
  if (__OFADD__(v47, 15LL))
  {
    __break(1u);
    goto LABEL_336;
  }

  BOOL v69 = v67;
  _StringGuts.reserveCapacity(_:)(v47 + 15);
  while (2)
  {
    BOOL v70 = specialized Collection.subscript.getter(v68, (uint64_t)v46, v47);
    uint64_t v74 = v364 & 0xFFFFFFFFFFFFLL;
    if ((v365 & 0x2000000000000000LL) != 0) {
      uint64_t v74 = HIBYTE(v365) & 0xF;
    }
    uint64_t v75 = __OFADD__(v74, v47);
    unint64_t v76 = v74 + v47;
    if (v75)
    {
      __break(1u);
LABEL_315:
      __break(1u);
LABEL_316:
      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
    }

    uint64_t v77 = v70;
    if (__OFADD__(v76, 3LL)) {
      goto LABEL_315;
    }
    unint64_t v78 = v71;
    uint64_t v79 = v72;
    uint64_t v80 = v73;
    _StringGuts.reserveCapacity(_:)(v76 + 3);
    uint64_t v81 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v77, v78, v79, v80);
    _StringGuts.appendInPlace(_:isASCII:)(v81, v82, 0);
    v367 = 3LL;
    v368 = 12435439LL;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v368, &v367, &v364);
    uint64_t v83 = specialized Collection.subscript.getter(v69, (uint64_t)v46, v47);
    Swift::UInt64 v46 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v83, v84, v85, v86);
    uint64_t v47 = v87;
    uint64_t v88 = validateUTF8(_:)(v46->i64, v87);
    if ((v48 & 1) != 0)
    {
      BOOL v68 = v88;
      BOOL v69 = v89;
      if (!v47) {
        goto LABEL_102;
      }
      continue;
    }

    break;
  }

  _StringGuts.appendInPlace(_:isASCII:)(v46->i8, v47, 0);
LABEL_102:
  Swift::UInt64 v52 = v364;
  uint64_t v51 = v365;
LABEL_121:
  uint64_t countAndFlagsBits = v366._countAndFlagsBits;
  unint64_t object = (unint64_t)v366._object;
  char v140 = ((unint64_t)v366._object >> 56) & 0xF;
  v141 = v366._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v141 && (v366._countAndFlagsBits & ~(uint64_t)v366._object & 0x2000000000000000LL) == 0)
  {
    v366._uint64_t countAndFlagsBits = v52;
    v366._unint64_t object = (void *)v51;
    unint64_t v157 = object;
    goto LABEL_154;
  }

  uint64_t v7 = v51 & 0x2000000000000000LL;
  BOOL v142 = HIBYTE(v51) & 0xF;
  uint64_t v143 = v140 + v142;
  if (v140 + v142 <= 0xF)
  {
    if (v142)
    {
      v287 = 0LL;
      v288 = 0LL;
      uint64_t v7 = v361;
      do
      {
        v289 = v140 + v288;
        v290 = v288++ >= 8;
        if (v290) {
          v291 = v51;
        }
        else {
          v291 = v52;
        }
        v292 = (8 * v140 + v287) & 0x38;
        v293 = (-255LL << v292) - 1;
        v294 = (unint64_t)(v291 >> (v287 & 0x38)) << v292;
        v295 = v294 | v293 & object;
        v296 = v294 | v293 & countAndFlagsBits;
        if (v289 < 8) {
          uint64_t countAndFlagsBits = v296;
        }
        else {
          unint64_t object = v295;
        }
        v287 += 8LL;
      }

      while (8 * v142 != v287);
    }

    else
    {
      uint64_t v7 = v361;
    }

    swift_bridgeObjectRelease(v51);
    v339 = 0xA000000000000000LL;
    if (!(countAndFlagsBits & 0x8080808080808080LL | object & 0x80808080808080LL)) {
      v339 = 0xE000000000000000LL;
    }
    v340 = (void *)(v339 & 0xFF00000000000000LL | (v143 << 56) | object & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v366._object);
    v366._uint64_t countAndFlagsBits = countAndFlagsBits;
    v366._unint64_t object = v340;
    goto LABEL_155;
  }

  uint64_t v7 = 1LL;
LABEL_129:
  if (v7) {
    uint64_t v144 = HIBYTE(v51) & 0xF;
  }
  else {
    uint64_t v144 = v52 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(v51, 2LL, v48, v49);
  if ((v51 & 0x1000000000000000LL) == 0)
  {
    swift_bridgeObjectRetain_n(v51, 4LL, v145, v146);
    Swift::String::Index v149 = v144;
    if ((object & 0x1000000000000000LL) == 0) {
      goto LABEL_134;
    }
LABEL_320:
    Swift::String::Index v150 = String.UTF8View._foreignCount()();
    Swift::String::Index v151 = v150 + v149;
    if (!__OFADD__(v150, v149)) {
      goto LABEL_138;
    }
LABEL_322:
    __break(1u);
LABEL_323:
    v346 = v150;
    swift_bridgeObjectRetain_n(v150, 5LL, v147, v148);
    v347._Swift::UInt64 rawBits = 1LL;
    v348._Swift::UInt64 rawBits = (v52 << 16) | 1;
    v349._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v347, v348, v363._countAndFlagsBits, v346);
    if (v349._rawBits < 0x10000) {
      v349._rawBits |= 3;
    }
    v198 = specialized Collection.count.getter(v349, v350, v363._countAndFlagsBits, v346);
    swift_bridgeObjectRelease(v346);
    __int128 v193 = v366._countAndFlagsBits;
    unint64_t v194 = (unint64_t)v366._object;
LABEL_181:
    if ((v194 & 0x2000000000000000LL) != 0) {
      goto LABEL_185;
    }
    v199 = (v193 & 0xFFFFFFFFFFFFLL) + v198;
    if (!__OFADD__(v193 & 0xFFFFFFFFFFFFLL, v198)) {
      goto LABEL_186;
    }
    do
    {
LABEL_184:
      __break(1u);
LABEL_185:
      v200 = HIBYTE(v194) & 0xF;
      v199 = v200 + v198;
    }

    while (__OFADD__(v200, v198));
    goto LABEL_186;
  }

  swift_bridgeObjectRetain_n(v51, 5LL, v145, v146);
  v342._Swift::UInt64 rawBits = 1LL;
  v343._Swift::UInt64 rawBits = (v144 << 16) | 1;
  v344._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v342, v343, v52, v51);
  if (v344._rawBits < 0x10000) {
    v344._rawBits |= 3;
  }
  Swift::String::Index v149 = specialized Collection.count.getter(v344, v345, v52, v51);
  swift_bridgeObjectRelease(v51);
  uint64_t countAndFlagsBits = v366._countAndFlagsBits;
  unint64_t object = (unint64_t)v366._object;
LABEL_134:
  if ((object & 0x2000000000000000LL) != 0) {
    Swift::String::Index v150 = HIBYTE(object) & 0xF;
  }
  else {
    Swift::String::Index v150 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  Swift::String::Index v151 = v150 + v149;
  if (__OFADD__(v150, v149)) {
    goto LABEL_322;
  }
LABEL_138:
  if ((countAndFlagsBits & ~object & 0x2000000000000000LL) == 0
    || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v151 > 15) {
      goto LABEL_144;
    }
    goto LABEL_148;
  }

  Swift::String::Index v152 = (unint64_t)v366._object;
  unint64_t v153 = _StringGuts.nativeUnusedCapacity.getter(v366._countAndFlagsBits, (uint64_t)v366._object);
  if ((v154 & 1) != 0) {
    goto LABEL_344;
  }
  if (v151 < 16 && ((v152 & 0x2000000000000000LL) != 0 || v153 < v149))
  {
LABEL_148:
    swift_bridgeObjectRelease_n(v51, 5LL);
    unint64_t v158 = v366._countAndFlagsBits;
    unint64_t v159 = v366._object;
    swift_bridgeObjectRetain((unint64_t)v366._object, v160, v161, v162);
    unint64_t v163 = _StringGuts._convertedToSmall()(v158, (unint64_t)v159);
    unint64_t v165 = v164;
    swift_bridgeObjectRelease((uint64_t)v159);
    v166._Swift::UInt64 rawBits = (v144 << 16) | 1;
    v167._Swift::UInt64 rawBits = 1LL;
    v168._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v167, v166, v52, v51);
    if (v168._rawBits < 0x10000) {
      v168._rawBits |= 3;
    }
    v170 = specialized String.init(_:)(v168, v169, v52, v51);
    Swift::String::Index v172 = v171;
    swift_bridgeObjectRelease(v51);
    Swift::String::Index v173 = _StringGuts._convertedToSmall()(v170, v172);
    Swift::Int v175 = v174;
    swift_bridgeObjectRelease(v172);
    uint64_t v176 = specialized _SmallString.init(_:appending:)(v163, v165, v173, v175);
    uint64_t v7 = v361;
    if ((v178 & 1) == 0)
    {
      unint64_t v179 = v176;
      __int128 v180 = v177;
      swift_bridgeObjectRelease(v51);
      unint64_t v157 = (uint64_t)v366._object;
      v366._uint64_t countAndFlagsBits = v179;
      v366._unint64_t object = v180;
LABEL_154:
      swift_bridgeObjectRelease(v157);
      goto LABEL_155;
    }

                    v253((char *)v289, a2);
                    ((void (*)(char *, uint64_t))v288)(v166, v78);
                    goto LABEL_3;
                  }
                }

                uint64_t v190 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
                uint64_t v191 = lazy protocol witness table accessor for type Int and conformance Int(v167, v168, v169);
                v190(&v291, &type metadata for Int, v191, v78, v68);
                unint64_t v166 = v287;
                uint64_t v192 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL)
                                                                          + 16LL))( v287,  v83,  v78);
                ((void (*)(char *, uint64_t))v288)(v83, v78);
                if ((v192 & 1) == 0) {
                  goto LABEL_74;
                }
                goto LABEL_86;
              }
            }

            else
            {
              uint64_t v102 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v68 + 96);
              uint64_t v103 = lazy protocol witness table accessor for type Int and conformance Int(v99, v100, v101);
              uint64_t v83 = v285;
              v102(&v291, &type metadata for Int, v103, v78, v68);
              uint64_t v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v68 + 32) + 8LL) + 16LL))( v287,  v83,  v78);
              uint64_t v84 = v284;
              v288 = *(void *)(v284 + 8);
              ((void (*)(char *, uint64_t))v288)(v83, v78);
              uint64_t v77 = v255;
              if ((v104 & 1) != 0) {
                goto LABEL_49;
              }
            }
          }

          else
          {
            uint64_t v84 = v284;
            unint64_t v109 = *(void (**)(char *, char *, uint64_t))(v284 + 16);
            if (v99 >= 64)
            {
              v109(v17, v287, v78);
              v288 = *(void *)(v84 + 8);
              ((void (*)(char *, uint64_t))v288)(v17, v78);
              uint64_t v83 = v285;
              uint64_t v77 = v255;
              goto LABEL_52;
            }

            uint64_t v83 = v285;
            v109(v285, v287, v78);
            unint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t))(v68 + 120))(v78, v68);
            v288 = *(void *)(v84 + 8);
            ((void (*)(char *, uint64_t))v288)(v83, v78);
            uint64_t v77 = v255;
            if (v110 < v291) {
              goto LABEL_49;
            }
          }
        }

        uint64_t v77 = (v83 - 1) & v83;
        uint64_t v81 = __clz(__rbit64(v83)) + (v79 << 6);
      }

      outlined init with copy of AnyHashable(*(void *)(v23 + 48) + 40 * v81, (uint64_t)&v123);
      specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v123, (uint64_t)v35);
    }
  }

  Swift::String::Index v48 = *(unsigned int *)(v23 + 36);
  Swift::UInt64 v49 = *(void **)(v23 + 40);
  Swift::UInt64 v50 = *(_BYTE *)(v23 + 32);
  LOBYTE(v123) = 0;
  uint64_t v51 = specialized static _SetStorage.allocate(scale:age:seed:)(v50, v48, v49, 0);
  uint64_t v28 = v51;
  if (!*(void *)(v23 + 16)) {
    goto LABEL_87;
  }
  Swift::UInt64 v52 = v51 + 7;
  Swift::UInt64 v53 = v23 + 56;
  Swift::UInt64 v54 = (unint64_t)((1LL << *((_BYTE *)v28 + 32)) + 63) >> 6;
  uint64_t v55 = 0LL;
  void v28[2] = *(void *)(v23 + 16);
  Swift::String::Index v56 = 1LL << *(_BYTE *)(v23 + 32);
  uint64_t v57 = -1LL;
  if (v56 < 64) {
    uint64_t v57 = ~(-1LL << v56);
  }
  unint64_t v58 = v57 & *(void *)(v23 + 56);
  uint64_t v59 = (unint64_t)(v56 + 63) >> 6;
  while (1)
  {
    if (v58)
    {
      uint64_t v60 = __clz(__rbit64(v58));
      v58 &= v58 - 1;
      Swift::UInt64 v61 = v60 | (v55 << 6);
      goto LABEL_48;
    }

    uint64_t v66 = v55 + 1;
    if (__OFADD__(v55, 1LL)) {
      goto LABEL_106;
    }
    if (v66 >= v59) {
      goto LABEL_87;
    }
    BOOL v67 = *(void *)(v53 + 8 * v66);
    ++v55;
    if (!v67)
    {
      uint64_t v55 = v66 + 1;
      if (v66 + 1 >= v59) {
        goto LABEL_87;
      }
      BOOL v67 = *(void *)(v53 + 8 * v55);
      if (!v67)
      {
        uint64_t v55 = v66 + 2;
        if (v66 + 2 >= v59) {
          goto LABEL_87;
        }
        BOOL v67 = *(void *)(v53 + 8 * v55);
        if (!v67) {
          break;
        }
      }
    }

      ++v44;
      v45 += 8LL;
    }

    while (v44 != v43);
    if (*(void *)(v1 + 16)) {
      goto LABEL_2;
    }
LABEL_84:
    uint64_t v4 = 0LL;
    *(_BYTE *)(v0 + 8) = 0;
    uint64_t v3 = 1;
  }

  else
  {
    if (!v43) {
      goto LABEL_84;
    }
LABEL_2:
    if ((*(_BYTE *)(v0 + 8) & 1) == 0)
    {
      specialized MutableCollection<>.reverse()();
      *(_BYTE *)(v0 + 8) = 1;
    }

    uint64_t v2 = specialized RangeReplaceableCollection<>.removeLast()();
    uint64_t v3 = 0;
    uint64_t v4 = v2 & 0xFFFFFFFFFFFFLL;
  }

LABEL_79:
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
          }
        }

        uint64_t v72 = a4;
        uint64_t v73 = v39;
        if (a1._rawBits < 0x10000) {
          goto LABEL_79;
        }
        uint64_t v44 = 0LL;
        while (1)
        {
          if (v41 > v34) {
            goto LABEL_86;
          }
          if ((*((_BYTE *)&v72 + v41 + v44 - 1) & 0xC0) != 0x80) {
            break;
          }
          --v44;
          if (!(v41 + v44)) {
            goto LABEL_79;
          }
        }

              _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  0xCFuLL,  0);
            }

    *v606 = v182;
    return result;
  }

  v130 = *(char **)(v67 + 128);
  unint64_t v131 = ((uint64_t (*)(unint64_t *, unint64_t))v130)(v69, v67);
  if (v131 >= 64)
  {
    uint64_t v143 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
    uint64_t v144 = lazy protocol witness table accessor for type Int and conformance Int(v131, v132, v133);
    v143(&v624, &type metadata for Int, v144, v69, v67);
    LOBYTE(v143) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                             + 8LL)
                                                                                 + 16LL))( v125,  v123,  v69);
    char v136 = *(void (**)(char *, unint64_t *))(v620 + 8);
    v136(v123, v69);
    goto LABEL_25;
  }

  uint64_t v134 = v620;
  (*(void (**)(char *, char *, unint64_t *))(v620 + 16))(v123, v125, v69);
  uint64_t v135 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
  char v136 = *(void (**)(char *, unint64_t *))(v134 + 8);
  v136(v123, v69);
LABEL_21:
  v619 = v130;
  unint64_t v156 = v611;
  unint64_t v157 = v609;
  unint64_t v158 = swift_getAssociatedConformanceWitness( (uint64_t)v611,  (uint64_t)v69,  (uint64_t)v609,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  unint64_t v159 = *(char **)(v158 + 8);
  unint64_t v160 = v610;
  v597 = (char *)v158;
  v596 = v159;
  ((void (*)(uint64_t *, uint64_t, void))v159)(&qword_18180BE70, 512LL, v157);
  v590 = (char *)*((void *)v156 + 3);
  ((void (*)(uint64_t (*)(void), unint64_t *, const char *))v590)(v160, v69, v156);
  char v161 = *((void *)v601 + 1);
  unint64_t v162 = (char *)v136;
  unint64_t v163 = *(void (**)(char *, char *, unint64_t *, uint64_t))(v161 + 24);
  v163(v125, v123, v69, v161);
  uint64_t v164 = v162;
  ((void (*)(char *, unint64_t *))v162)(v123, v69);
  unint64_t v165 = (uint64_t (*)(unint64_t *, unint64_t))v617;
  unint64_t v166 = ((uint64_t (*)(unint64_t *, unint64_t))v617)(v69, v67);
  v601 = v163;
  if ((v166 & 1) == 0)
  {
    uint64_t v183 = v165(v69, v67);
    unint64_t v167 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
    if ((v183 & 1) != 0)
    {
      if (v167 > 64) {
        goto LABEL_34;
      }
      v220 = v610;
      ((void (*)(uint64_t *, uint64_t))v596)(&qword_18180BE68, 256LL);
      ((void (*)(uint64_t (*)(void), unint64_t *, const char *))v590)(v220, v69, v611);
      LOBYTE(v22_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v120,  v123,  v69);
      ((void (*)(char *, unint64_t *))v164)(v123, v69);
      v221 = v575;
      (*(void (**)(char *, char *, unint64_t *))(v620 + 32))(v575, v120, v69);
      if ((v220 & 1) != 0)
      {
        ((void (*)(char *, unint64_t *))v164)(v221, v69);
        goto LABEL_69;
      }

      v199 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
      v200 = v221;
    }

    else
    {
      if (v167 >= 64)
      {
        v222 = v574;
        (*(void (**)(char *, char *, unint64_t *))(v620 + 32))(v574, v120, v69);
        ((void (*)(char *, unint64_t *))v164)(v222, v69);
        goto LABEL_71;
      }

      v199 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
      v200 = v120;
    }

    ((void (*)(char *, unint64_t *))v164)(v200, v69);
    if (v199 >= -1074) {
      goto LABEL_71;
    }
    goto LABEL_69;
  }

  unint64_t v167 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
  if (v167 < 64)
  {
    v170 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
    ((void (*)(char *, unint64_t *))v164)(v120, v69);
    if (v170 > -1075) {
      goto LABEL_71;
    }
LABEL_69:
    ((void (*)(char *, unint64_t *))v164)(v125, v69);
    if (((*((uint64_t (**)(uint64_t))v616 + 21))(v621) & 1) == 0)
    {
      uint64_t result = 0LL;
      *v606 = 0LL;
      return result;
    }

    uint64_t result = 0LL;
    uint64_t v182 = 0x8000000000000000LL;
    goto LABEL_79;
  }

          v395 = (uint64_t)v782;
          v396 = (void (*)(char *, uint64_t))v759;
          ((void (*)(char **, char **))v759)(v778, v782);
          (*(void (**)(uint64_t, unint64_t *))(v272 + 8))(v282, v125);
          v397 = (*(uint64_t (**)(uint64_t))(v764 + 168))(v779);
          v398 = *(void (**)(uint64_t, uint64_t))(v775 + 112);
          if ((v397 & 1) != 0)
          {
            v399 = v730;
            v398(v395, v775);
            (*(void (**)(char *, uint64_t))(v702 + 16))(v399, v395);
            v396(v399, v395);
          }

          else
          {
            v398(v395, v775);
          }

          return 0LL;
        }

        v758 = v167;
        if (v269 >= v270)
        {
          v330 = (void (**)(char *, unint64_t *, const char *))v757;
          v331 = v755;
          v332 = swift_getAssociatedConformanceWitness( (uint64_t)v757,  (uint64_t)v125,  v755,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v333 = v181;
          v334 = v756;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v332 + 8))( &unk_18180BE68,  256LL,  v331,  v332);
          v335 = v776;
          v336 = v334;
          v337 = v777;
          v330[3](v336, v125, (const char *)v330);
          v338 = v781;
          LOBYTE(v33_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = (*(uint64_t (**)(unint64_t, char *, unint64_t *))(*(void *)(*(void *)(v267 + 32) + 8LL)
                                                                                                 + 40LL))( v781,  v335,  v125);
          v339 = *(void (**)(char *, unint64_t *))(v337 + 8);
          v339(v335, v125);
          v340 = v772;
          v341 = v696;
          v342 = v758;
          (*(void (**)(char *, uint64_t, uint64_t))(v772 + 32))(v696, v333, v758);
          v343 = *(void (**)(char *, uint64_t, unint64_t *))(v337 + 16);
          v344 = v689;
          v343(v689, v338, v125);
          if ((v330 & 1) == 0)
          {
            v339(v344, v125);
            (*(void (**)(char *, uint64_t))(v340 + 8))(v341, v342);
            v272 = v777;
            v282 = v781;
            goto LABEL_83;
          }

          v345 = v774;
          v346 = v344;
          v347 = v267;
          v348 = v770;
          ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v774[12])( v346,  v125,  v347,  v342,  v774);
          v349 = (*(uint64_t (**)(char *, char *, uint64_t))(*((void *)v345[4] + 1) + 16LL))( v341,  v348,  v342);
          v350 = *(void (**)(char *, uint64_t))(v340 + 8);
          v351 = v348;
          v267 = v347;
          v282 = v781;
          v272 = v777;
          v350(v351, v342);
          v350(v341, v342);
          if ((v349 & 1) != 0) {
            goto LABEL_79;
          }
        }

        else
        {
          v289 = *(void (**)(uint64_t, uint64_t, char **, unint64_t *, uint64_t))(v168 + 96);
          v290 = v776;
          v289(v181, v758, v166, v125, v267);
          v282 = v781;
          v291 = (*(uint64_t (**)(char *, unint64_t, unint64_t *))(*(void *)(*(void *)(v267 + 32) + 8LL)
                                                                                         + 16LL))( v290,  v781,  v125);
          v272 = v777;
          (*(void (**)(char *, unint64_t *))(v777 + 8))(v290, v125);
          if ((v291 & 1) != 0) {
            goto LABEL_79;
          }
        }
      }

      else
      {
        v283 = ((uint64_t (*)(uint64_t, char **))v761)(v167, v166);
        v284 = v781;
        if (v283 >= ((uint64_t (*)(unint64_t *, uint64_t))v765)(v125, v168))
        {
          v292 = v776;
          (*(void (**)(char *, uint64_t, unint64_t *))(v777 + 16))(v776, v284, v125);
          v293 = v770;
          ((void (*)(char *, unint64_t *, uint64_t, uint64_t, char **))v166[12])( v292,  v125,  v168,  v167,  v166);
          v294 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*((void *)v166[4] + 1) + 16LL))( v181,  v293,  v167);
          v295 = *(void (**)(char *, uint64_t))(v772 + 8);
          v296 = v293;
          v267 = v168;
          v297 = v777;
          v295(v296, v167);
          v295((char *)v181, v167);
          v282 = v284;
          v272 = v297;
          if ((v294 & 1) != 0) {
            goto LABEL_79;
          }
        }

        else
        {
          v285 = *(void (**)(uint64_t, uint64_t, char **, unint64_t *, uint64_t))(v168 + 96);
          v286 = v776;
          v285(v181, v167, v166, v125, v267);
          v287 = (*(uint64_t (**)(char *, uint64_t, unint64_t *))(*(void *)(*(void *)(v267 + 32)
                                                                                            + 8LL)
                                                                                + 16LL))( v286,  v284,  v125);
          v288 = v777;
          (*(void (**)(char *, unint64_t *))(v777 + 8))(v286, v125);
          v282 = v284;
          v272 = v288;
          if ((v287 & 1) != 0) {
            goto LABEL_79;
          }
        }
      }

    uint64_t v85 = HIBYTE(v77) & 0xF;
    uint64_t v86 = HIBYTE(v84) & 0xF;
    uint64_t v87 = v86 + v85;
    if (v86)
    {
      uint64_t v88 = 0;
      uint64_t v89 = 0LL;
      do
      {
        uint64_t v90 = v85 + v89;
        uint64_t v91 = v89 + 1;
        if (v89 >= 8) {
          uint64_t v92 = v84;
        }
        else {
          uint64_t v92 = v82;
        }
        unint64_t v93 = v92 >> (v88 & 0x38);
        unint64_t v94 = (8 * v85 + v88) & 0x38;
        unint64_t v95 = (-255LL << v94) - 1;
        char v96 = (unint64_t)v93 << v94;
        uint64_t v97 = v96 | v95 & v77;
        uint64_t v98 = v96 | v95 & v12;
        if (v90 < 8) {
          Swift::UInt64 v12 = v98;
        }
        else {
          uint64_t v77 = v97;
        }
        v88 += 8;
        uint64_t v89 = v91;
      }

      while (v86 != v91);
    }

    swift_bridgeObjectRelease(v46);
    swift_bridgeObjectRelease(v13);
    uint64_t v101 = 0xA000000000000000LL;
    if (!(v12 & 0x8080808080808080LL | v77 & 0x80808080808080LL)) {
      uint64_t v101 = 0xE000000000000000LL;
    }
    v253 = v12;
    v254 = v101 & 0xFF00000000000000LL | (v87 << 56) | v77 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v3 = v251;
  }

  swift_bridgeObjectRetain_n(v170, 5LL, v175, v176);
  v230._Swift::UInt64 rawBits = 1LL;
  v231._Swift::UInt64 rawBits = (v46 << 16) | 1;
  v232._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v230, v231, v171, v170);
  if (v232._rawBits < 0x10000) {
    v232._rawBits |= 3;
  }
  uint64_t v4 = specialized Collection.count.getter(v232, v233, v171, v170);
  swift_bridgeObjectRelease(v170);
  if ((v12 & 0x1000000000000000LL) == 0) {
    goto LABEL_189;
  }
LABEL_238:
  v234 = String.UTF8View._foreignCount()();
  uint64_t v7 = v234 + v4;
  if (__OFADD__(v234, v4)) {
    goto LABEL_240;
  }
LABEL_190:
  if ((v82 & ~v12 & 0x2000000000000000LL) == 0 || !swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v7 > 15) {
      goto LABEL_202;
    }
LABEL_197:
    swift_bridgeObjectRelease_n(v170, 5LL);
    swift_bridgeObjectRetain(v12, v180, v181, v182);
    uint64_t v183 = _StringGuts._convertedToSmall()(v82, v12);
    __int128 v185 = v184;
    swift_bridgeObjectRelease(v12);
    v186._Swift::UInt64 rawBits = (v46 << 16) | 1;
    v187._Swift::UInt64 rawBits = 1LL;
    v188._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v187, v186, v171, v170);
    if (v188._rawBits < 0x10000) {
      v188._rawBits |= 3;
    }
    uint64_t v190 = specialized String.init(_:)(v188, v189, v171, v170);
    uint64_t v192 = v191;
    swift_bridgeObjectRelease(v170);
    __int128 v193 = _StringGuts._convertedToSmall()(v190, v192);
    unint64_t v195 = v194;
    swift_bridgeObjectRelease(v192);
    v196 = specialized _SmallString.init(_:appending:)(v183, v185, v193, v195);
    Swift::String::Index v151 = v251;
    if ((v198 & 1) == 0)
    {
      v199 = v196;
      v200 = v197;
      swift_bridgeObjectRelease(v12);
      swift_bridgeObjectRelease(v170);
      v253 = v199;
      v254 = v200;
      uint64_t v2 = v247;
      goto LABEL_225;
    }

    uint64_t v30 = swift_allocError((uint64_t)&unk_189B86A70, (uint64_t)&protocol witness table for UTF8ValidationError, 0LL, 0);
    swift_willThrow();
    swift_errorRelease(v30);
    uint64_t v31 = specialized Collection.subscript.getter(v19, v15, v14);
    uint64_t v35 = v31;
    uint64_t v36 = v32;
    Swift::UInt64 v37 = v33;
    BOOL v38 = v34;
    uint64_t v39 = v31;
    if (v31 != v32)
    {
      specialized Slice.subscript.getter(v31, v31, v32, v33, v34);
      uint64_t v39 = v35 + 1;
      if (__OFADD__(v35, 1LL))
      {
        uint64_t v51 = 1525LL;
        goto LABEL_109;
      }
    }

    uint64_t v40 = 0LL;
    Swift::UInt64 v41 = v36 + v35 - v39;
    if (v36 <= v39) {
      uint64_t v42 = v39;
    }
    else {
      uint64_t v42 = v36;
    }
    if (v38 <= v39) {
      uint64_t v43 = v39;
    }
    else {
      uint64_t v43 = v38;
    }
    uint64_t v44 = v43 - v39;
    uint64_t v45 = v42 - v39;
    while (1)
    {
      if (v36 - v39 == v40) {
        goto LABEL_98;
      }
      if (v39 < v35)
      {
        uint64_t v51 = 1812LL;
        goto LABEL_109;
      }

      if (v45 == v40)
      {
        uint64_t v51 = 1813LL;
        goto LABEL_109;
      }

      if (v39 < 0)
      {
        uint64_t v51 = 1781LL;
        goto LABEL_109;
      }

      if (v44 == v40)
      {
        uint64_t v51 = 1782LL;
        goto LABEL_109;
      }

      if ((*(_BYTE *)(v37 + v39 + v40) & 0xC0) != 0x80) {
        break;
      }
      Swift::UInt64 v46 = v35 + v40++;
      if (__OFADD__(v46, 1LL))
      {
        __break(1u);
LABEL_110:
        uint64_t v51 = 1861LL;
LABEL_109:
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v51,  0);
      }
    }

    Swift::UInt64 v41 = v35 + v40;
LABEL_98:
    if (v41 < v35) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/ClosedRange.swift",  23LL,  2,  0x15BuLL,  0);
    }
    uint64_t v47 = v41 + 1;
    if (__OFADD__(v41, 1LL))
    {
      __break(1u);
LABEL_118:
      uint64_t v51 = 1820LL;
      goto LABEL_109;
    }

    if (v36 < v47) {
      goto LABEL_118;
    }
    a3 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v35, v47, v37, v38);
    a4 = v48;
    a1 = (char *)v15;
    uint64_t v7 = v14;
    if (a3 < 0) {
LABEL_102:
    }
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }

    if ((v47 & 0xFFFFFFFE) != 2 || (*v48 & 1) != 0) {
      uint64_t v64 = 0;
    }
    else {
      uint64_t v64 = (*(_DWORD *)(*v48 & 0xFFFFFFFFFFFFFFFELL) >> 18) & 0x3F;
    }
    *(void *)uint64_t v44 = getExistentialValueWitnesses(v47 & 1, v45, v64);
    uint64_t v65 = v45 & 0x40FFFFFF | ((_DWORD)v47 << 31) | (v64 << 24);
    *((_DWORD *)v44 + 4) = v65;
    if (v46)
    {
      v65 |= 0x40000000u;
      *((_DWORD *)v44 + 4) = v65;
      *((void *)v44 + 3) = v46;
    }

    *((_DWORD *)v44 + 5) = v49;
    if (v47 >= 2)
    {
      uint64_t v66 = (v65 >> 30) & 1;
      if (v49 <= 1) {
        BOOL v67 = 1LL;
      }
      else {
        BOOL v67 = v47 >> 1;
      }
      if (v67 < 0xA || (BOOL v68 = (char *)v44 + 8 * v66, (unint64_t)(v68 - (char *)v48 + 24) < 0x20))
      {
        BOOL v69 = 0LL;
LABEL_92:
        BOOL v70 = v67 - v69;
        uint64_t v71 = v69;
        uint64_t v72 = (void *)((char *)v44 + 8 * v66 + v71 * 8 + 24);
        uint64_t v73 = &v48[v71];
        do
        {
          uint64_t v74 = *v73++;
          *v72++ = v74;
          --v70;
        }

        while (v70);
        goto LABEL_94;
      }

      BOOL v69 = v67 & 0x7FFFFFFC;
      uint64_t v75 = (__int128 *)(v48 + 2);
      unint64_t v76 = v68 + 40;
      uint64_t v77 = v69;
      do
      {
        unint64_t v78 = *v75;
        *(v76 - 1) = *(v75 - 1);
        char *v76 = v78;
        v75 += 2;
        v76 += 2;
        v77 -= 4LL;
      }

      while (v77);
      if (v67 != v69) {
        goto LABEL_92;
      }
    }

    *(_DWORD *)a7 = v42;
    *(void *)(a7 + 8) = a2;
    *(_DWORD *)(a7 + 16) = v41;
    return result;
  }

  Swift::UInt64 v37 = *((unsigned __int8 *)a2 + 18);
  if (v37 == 1)
  {
    uint64_t v39 = 0LL;
LABEL_46:
    uint64_t v40 = a2;
    goto LABEL_47;
  }

  if (v37 != 5)
  {
    uint64_t v39 = 1LL;
    goto LABEL_46;
  }

  BOOL v38 = *((unsigned int *)a2 + 2);
  if (v38 >= 5)
  {
    Swift::UInt64 v41 = 1151;
    uint64_t v42 = 1;
    goto LABEL_79;
  }

  uint64_t v39 = v38 - 1;
  uint64_t v40 = (uint64_t *)*a2;
LABEL_47:
  uint64_t v43 = (swift::Demangle::__runtime::Node *)v40[v39];
  if (*((_WORD *)v43 + 8) != 176
        !*(_DWORD *)a7))
  {
    swift::Demangle::__runtime::CharVector::append( (unsigned int *)v13,  9uLL,  *(swift::Demangle::__runtime::NodeFactory **)(a1 + 12744));
    swift::Demangle::__runtime::CharVector::append(v13, "subscript", 9uLL, *(void **)(a1 + 12744));
    *(_DWORD *)a7 = 0;
    *(void *)(a7 + 8) = 0LL;
    *(_DWORD *)(a7 + 16) = 0;
    uint64_t v44 = *((unsigned __int8 *)a2 + 18);
    uint64_t v45 = a2;
    if (v44 != 2)
    {
      uint64_t v36 = 0LL;
      if (v44 != 5)
      {
LABEL_54:
        if (*((_WORD *)v36 + 8) == 290)
        {
          if (v44 != 5) {
            goto LABEL_72;
          }
          goto LABEL_63;
        }

        if (v44 == 2)
        {
LABEL_67:
          uint64_t v47 = (unsigned int *)a2[1];
LABEL_77:
          Swift::UInt64 v41 = *(_DWORD *)a7;
          if (*(_DWORD *)a7) {
            return result;
          }
          uint64_t v42 = 0;
          a2 = 0LL;
          goto LABEL_79;
        }

        if (v44 != 5) {
          goto LABEL_76;
        }
LABEL_65:
        if (*((_DWORD *)a2 + 2) < 2u) {
          goto LABEL_76;
        }
        a2 = (uint64_t *)*a2;
        goto LABEL_67;
      }

      if (*((_DWORD *)a2 + 2) < 2u)
      {
        if (MEMORY[0x10] == 290)
        {
          uint64_t v36 = 0LL;
LABEL_63:
          if (*((_DWORD *)a2 + 2) >= 3u)
          {
            Swift::UInt64 v46 = *(swift::Demangle::__runtime::Node **)(*a2 + 16);
LABEL_73:
            uint64_t v47 = applyParamLabels(v36, v46, *(swift::Demangle::__runtime::NodeFactory **)a1);
            goto LABEL_77;
          }

Swift::UInt64 specialized BidirectionalCollection._index(_:offsetBy:limitedBy:)( Swift::UInt64 result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v7 = a2;
  if (a2 < 0)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = (a4 >> 59) & 1;
    if ((a5 & 0x1000000000000000LL) == 0) {
      LOBYTE(v12) = 1;
    }
    uint64_t v13 = 4LL << v12;
    if ((a5 & 0x2000000000000000LL) != 0) {
      unint64_t v14 = HIBYTE(a5) & 0xF;
    }
    else {
      unint64_t v14 = a4 & 0xFFFFFFFFFFFFLL;
    }
    while ((result ^ a3) >= 0x4000)
    {
      if ((result & 0xC) == v13)
      {
        uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)result)._rawBits;
        if (!(result >> 14))
        {
LABEL_35:
          unint64_t v15 = 152LL;
          goto LABEL_36;
        }
      }

      else if (!(result >> 14))
      {
        goto LABEL_35;
      }

      if ((a5 & 0x1000000000000000LL) != 0)
      {
        if (v14 < result >> 16)
        {
          unint64_t v15 = 157LL;
LABEL_36:
          _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v15,  0);
        }

        uint64_t result = String.UTF8View._foreignIndex(before:)((Swift::String::Index)result)._rawBits;
      }

      else
      {
        uint64_t result = (result & 0xFFFFFFFFFFFF0000LL) - 65532;
      }

      if (--v11 <= v7) {
        return result;
      }
    }

    return 0LL;
  }

  else if (a2)
  {
    uint64_t v8 = (a4 >> 59) & 1;
    if ((a5 & 0x1000000000000000LL) == 0) {
      LOBYTE(v8) = 1;
    }
    uint64_t v9 = 4LL << v8;
    if ((a5 & 0x2000000000000000LL) != 0) {
      unint64_t v10 = HIBYTE(a5) & 0xF;
    }
    else {
      unint64_t v10 = a4 & 0xFFFFFFFFFFFFLL;
    }
    do
    {
      while (1)
      {
        if ((result ^ a3) < 0x4000) {
          return 0LL;
        }
        if ((result & 0xC) != v9) {
          break;
        }
        uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)result)._rawBits;
        if ((a5 & 0x1000000000000000LL) == 0) {
          goto LABEL_11;
        }
LABEL_14:
        if (v10 <= result >> 16)
        {
          unint64_t v15 = 144LL;
          goto LABEL_36;
        }

        uint64_t result = String.UTF8View._foreignIndex(after:)((Swift::String::Index)result)._rawBits;
        if (!--v7) {
          return result;
        }
      }

      if ((a5 & 0x1000000000000000LL) != 0) {
        goto LABEL_14;
      }
LABEL_11:
      uint64_t result = (result & 0xFFFFFFFFFFFF0000LL) + 65540;
      --v7;
    }

    while (v7);
  }

  return result;
}

uint64_t BidirectionalCollection._index(_:offsetBy:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v32 = a6;
  uint64_t v11 = *(void *)(a5 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v11,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v13 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v15 = (char *)&v30 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v30 - v16;
  uint64_t v31 = v18;
  uint64_t v19 = *(void (**)(char *, uint64_t, unint64_t))(v18 + 16);
  if (a2 < 0)
  {
    v19(v15, a1, AssociatedTypeWitness);
    unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v11,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    uint64_t v25 = 0LL;
    uint64_t v26 = *(void *)(AssociatedConformanceWitness + 8);
    uint64_t v27 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v26 + 8);
    while ((v27(v15, a3, AssociatedTypeWitness, v26) & 1) == 0)
    {
      --v25;
      (*(void (**)(char *, uint64_t, uint64_t))(a5 + 40))(v15, a4, a5);
      if (v25 <= a2)
      {
        uint64_t v23 = v31;
        uint64_t v22 = v32;
        (*(void (**)(uint64_t, char *, unint64_t))(v31 + 32))(v32, v15, AssociatedTypeWitness);
        goto LABEL_11;
      }
    }

    uint64_t v23 = v31;
    (*(void (**)(char *, unint64_t))(v31 + 8))(v15, AssociatedTypeWitness);
    goto LABEL_14;
  }

  v19((char *)&v30 - v16, a1, AssociatedTypeWitness);
  if (a2)
  {
    uint64_t v20 = *(void *)(swift_getAssociatedConformanceWitness( v11,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    Swift::String::Index v21 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v20 + 8);
    while ((v21(v17, a3, AssociatedTypeWitness, v20) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 192))(v17, a4, v11);
      if (!--a2) {
        goto LABEL_6;
      }
    }

    uint64_t v23 = v31;
    (*(void (**)(char *, unint64_t))(v31 + 8))(v17, AssociatedTypeWitness);
LABEL_14:
    uint64_t v28 = 1LL;
    uint64_t v22 = v32;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v23 + 56))( v22,  v28,  1LL,  AssociatedTypeWitness);
  }

uint64_t Collection._advanceForward(_:by:limitedBy:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)a5,  a4,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  unint64_t v15 = (char *)&v22 - v14;
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Only BidirectionalCollections can be advanced by a negative amount",  66LL,  2,  "Swift/Collection.swift",  22LL,  2,  0x3D3uLL,  0);
  }
  uint64_t v22 = v13;
  uint64_t v23 = a6;
  (*(void (**)(char *, uint64_t, unint64_t))(v13 + 16))(v15, a1, AssociatedTypeWitness);
  if (a2)
  {
    uint64_t v16 = *(void *)(swift_getAssociatedConformanceWitness( a5,  a4,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable)
                    + 8);
    uint64_t v17 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v16 + 8);
    while ((v17(v15, a3, AssociatedTypeWitness, v16) & 1) == 0)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(a5 + 192))(v15, a4, a5);
      if (!--a2) {
        goto LABEL_6;
      }
    }

    uint64_t v19 = v22;
    (*(void (**)(char *, unint64_t))(v22 + 8))(v15, AssociatedTypeWitness);
    uint64_t v20 = 1LL;
    uint64_t v18 = v23;
  }

  else
  {
LABEL_6:
    uint64_t v19 = v22;
    uint64_t v18 = v23;
    (*(void (**)(uint64_t, char *, unint64_t))(v22 + 32))(v23, v15, AssociatedTypeWitness);
    uint64_t v20 = 0LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v19 + 56))( v18,  v20,  1LL,  AssociatedTypeWitness);
}

uint64_t specialized BidirectionalCollection._distance(from:to:)( Swift::UInt64 rawBits, unint64_t a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 v5 = a2 >> 14;
  if (rawBits >> 14 < a2 >> 14)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = (a3 >> 59) & 1;
    if ((a4 & 0x1000000000000000LL) == 0) {
      LOBYTE(v7) = 1;
    }
    uint64_t v8 = 4LL << v7;
    if ((a4 & 0x2000000000000000LL) != 0) {
      unint64_t v9 = HIBYTE(a4) & 0xF;
    }
    else {
      unint64_t v9 = a3 & 0xFFFFFFFFFFFFLL;
    }
    while (1)
    {
      uint64_t v10 = v6 + 1;
      if (__OFADD__(v6, 1LL))
      {
        __break(1u);
LABEL_36:
        unint64_t v16 = 144LL;
LABEL_39:
        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUTF8View.swift",  26LL,  2,  v16,  0);
      }

      if ((rawBits & 0xC) == v8)
      {
        Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
        if ((a4 & 0x1000000000000000LL) == 0)
        {
LABEL_7:
          Swift::UInt64 rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) + 65540;
          goto LABEL_8;
        }
      }

      else if ((a4 & 0x1000000000000000LL) == 0)
      {
        goto LABEL_7;
      }

      if (v9 <= rawBits >> 16) {
        goto LABEL_36;
      }
      Swift::UInt64 rawBits = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
LABEL_8:
      ++v6;
      if (v5 == rawBits >> 14) {
        return v10;
      }
    }
  }

  if (v5 >= rawBits >> 14) {
    return 0LL;
  }
  uint64_t v10 = 0LL;
  uint64_t v11 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v11) = 1;
  }
  uint64_t v12 = 4LL << v11;
  if ((a4 & 0x2000000000000000LL) != 0) {
    unint64_t v13 = HIBYTE(a4) & 0xF;
  }
  else {
    unint64_t v13 = a3 & 0xFFFFFFFFFFFFLL;
  }
  do
  {
    if (__OFSUB__(v10--, 1LL))
    {
      __break(1u);
LABEL_38:
      unint64_t v16 = 152LL;
      goto LABEL_39;
    }

    if ((rawBits & 0xC) == v12)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
      if (!(rawBits >> 14)) {
        goto LABEL_38;
      }
    }

    else if (!(rawBits >> 14))
    {
      goto LABEL_38;
    }

    if ((a4 & 0x1000000000000000LL) != 0)
    {
      if (v13 < rawBits >> 16)
      {
        unint64_t v16 = 157LL;
        goto LABEL_39;
      }

      Swift::UInt64 rawBits = String.UTF8View._foreignIndex(before:)((Swift::String::Index)rawBits)._rawBits;
    }

    else
    {
      Swift::UInt64 rawBits = (rawBits & 0xFFFFFFFFFFFF0000LL) - 65532;
    }
  }

  while (v5 != rawBits >> 14);
  return v10;
}

uint64_t BidirectionalCollection._distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v8,  a3,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v10 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v24 - v11;
  (*(void (**)(char *, uint64_t, unint64_t))(v10 + 16))((char *)&v24 - v11, a1, AssociatedTypeWitness);
  uint64_t v26 = a3;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v8,  a3,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  if (((*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                       + 16))( v12,  a2,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) == 0)
  {
    if (((*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 40))( v12,  a2,  AssociatedTypeWitness,  AssociatedConformanceWitness) & 1) != 0)
    {
      uint64_t v20 = *(void *)(AssociatedConformanceWitness + 8);
      Swift::String::Index v21 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v20 + 8);
      uint64_t result = v21(v12, a2, AssociatedTypeWitness, v20);
      uint64_t v19 = 0LL;
      if ((result & 1) == 0)
      {
        uint64_t v22 = *(void (**)(char *, uint64_t, uint64_t))(a4 + 40);
        while (!__OFSUB__(v19--, 1LL))
        {
          v22(v12, v26, a4);
          uint64_t result = v21(v12, a2, AssociatedTypeWitness, v20);
          if ((result & 1) != 0) {
            goto LABEL_14;
          }
        }

        goto LABEL_16;
      }

LABEL_13:
    uint64_t v19 = 0LL;
    goto LABEL_14;
  }

  uint64_t v14 = *(void *)(AssociatedConformanceWitness + 8);
  unint64_t v15 = *(uint64_t (**)(char *, uint64_t, unint64_t, uint64_t))(v14 + 8);
  uint64_t result = v15(v12, a2, AssociatedTypeWitness, v14);
  if ((result & 1) != 0) {
    goto LABEL_13;
  }
  uint64_t v25 = v10;
  uint64_t v17 = 0LL;
  uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 192);
  while (1)
  {
    uint64_t v19 = v17 + 1;
    if (__OFADD__(v17, 1LL)) {
      break;
    }
    v18(v12, v26, v8);
    uint64_t result = v15(v12, a2, AssociatedTypeWitness, v14);
    ++v17;
    if ((result & 1) != 0)
    {
      uint64_t v10 = v25;
      goto LABEL_14;
    }
  }

  __break(1u);
LABEL_16:
  __break(1u);
  return result;
}

    unint64_t v15 = 0;
    return v15 & 1;
  }

  if (!*(void *)(a2 + 16)) {
    goto LABEL_13;
  }
  unint64_t v16 = (*(uint64_t (**)(void, uint64_t *, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
  uint64_t v17 = -1LL << *(_BYTE *)(a2 + 32);
  uint64_t v18 = v16 & ~v17;
  uint64_t v27 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v18 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v18) & 1) == 0) {
    goto LABEL_13;
  }
  uint64_t v25 = ~v17;
  uint64_t v26 = a1;
  uint64_t v19 = *(void *)(a4 + 8);
  uint64_t v20 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v19 + 8);
  Swift::String::Index v21 = *(void *)(v8 + 72);
  uint64_t v22 = *(void (**)(char *, unint64_t, uint64_t *))(v8 + 16);
  do
  {
    v22(v10, *(void *)(a2 + 48) + v21 * v18, a3);
    unint64_t v15 = v20(v10, v26, a3, v19);
    (*(void (**)(char *, uint64_t *))(v8 + 8))(v10, a3);
    if ((v15 & 1) != 0) {
      break;
    }
    uint64_t v18 = (v18 + 1) & v25;
  }

  while (((*(void *)(v27 + ((v18 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v18) & 1) != 0);
  return v15 & 1;
}

        uint64_t v30 = (v34 - 1) & v34;
        uint64_t v32 = __clz(__rbit64(v34)) + (v26 << 6);
      }

      (*(void (**)(id *, unint64_t, uint64_t *))(v20 + 16))( v24,  *(void *)(a2 + 48) + *(void *)(v20 + 72) * v32,  a3);
      (*(void (**)(char *, unint64_t, char *))(v67 + 16))( v66,  *(void *)(a2 + 56) + *(void *)(v67 + 72) * v32,  a4);
      if (_swift_isClassOrObjCExistentialType((uint64_t)a3, a3))
      {
        if (v64 != 8) {
          goto LABEL_30;
        }
        BOOL v38 = *v24;
        swift_unknownObjectRetain(*v24, v35, v36, v37);
        (*(void (**)(id *, uint64_t *))(v20 + 8))(v24, a3);
      }

      else
      {
        uint64_t v45 = v57;
        (*(void (**)(id *, id *, uint64_t *))(v20 + 32))(v57, v24, a3);
        BOOL v38 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v45, a3, v46, v47);
      }

      uint64_t v39 = (swift *)objc_msgSend(v65, sel_objectForKey_, v38, v53);
      swift_unknownObjectRelease(v38);
      if (!v39) {
        break;
      }
      if (_swift_isClassOrObjCExistentialType((uint64_t)a4, (uint64_t *)a4))
      {
        uint64_t v40 = v20;
        BOOL v68 = v39;
        Swift::UInt64 v41 = v62;
        swift_dynamicCast(v62, (uint64_t *)&v68, v60, a4, 7uLL);
      }

      else
      {
        Swift::String::Index v48 = v55;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v67 + 56))(v55, 1LL, 1LL, a4);
        _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(v39, (uint64_t)a4, v48);
        swift_unknownObjectRelease(v39);
        Swift::UInt64 v49 = v53;
        Swift::UInt64 v50 = v56;
        uint64_t v51 = v48;
        (*(void (**)(char *, uint64_t *, uint64_t))(v54 + 16))(v56, v48, v53);
        uint64_t v40 = v20;
        (*(void (**)(uint64_t *, uint64_t))(v54 + 8))(v51, v49);
        Swift::UInt64 v41 = v62;
        (*(void (**)(char *, char *, char *))(v67 + 32))(v62, v50, a4);
      }

      uint64_t v42 = v66;
      uint64_t v43 = (*(uint64_t (**)(char *, char *, char *))(v63 + 8))(v66, v41, a4);
      uint64_t v44 = *(void (**)(char *, char *))(v67 + 8);
      v44(v42, a4);
      v44(v41, a4);
      a2 = v61;
      uint64_t v20 = v40;
      if ((v43 & 1) == 0) {
        return 0LL;
      }
    }

    (*(void (**)(char *, char *))(v67 + 8))(v66, a4);
  }

  return 0LL;
}

    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v10);
  }

    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for String);
  }

    KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for AnyHashable);
  }

    uint64_t v39 = v83;
    specialized static BinaryFloatingPoint._convert<A>(from:)(&v84, v83, (uint64_t)a2, a3);
    (*(void (**)(uint64_t, swift *))(v10 + 8))(v39, a2);
    _D8 = v84;
    return *(double *)&_D8;
  }

  if (v27 == 8)
  {
    if (v28 == 23)
    {
      uint64_t v35 = v83;
      (*(void (**)(uint64_t *, uint64_t, swift *))(v10 + 16))(v21, v83, a2);
      uint64_t v36 = swift_dynamicCast((char *)&v84, v21, a2, (const char *)&type metadata for Float, 6uLL);
      Swift::UInt64 v37 = *(float *)&v84;
      BOOL v38 = v76;
      (*(void (**)(char *, uint64_t, swift *))(v10 + 32))(v76, v35, a2);
      if (v36)
      {
        (*(void (**)(char *, swift *))(v10 + 8))(v38, a2);
        *(double *)&_D8 = v37;
      }

      else
      {
        uint64_t v65 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
        uint64_t v66 = v77;
        (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
        BOOL v67 = v79;
        BOOL v68 = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        BOOL v69 = (*(uint64_t (**)(uint64_t))(*(void *)(v68 + 8) + 120LL))(v67);
        (*(void (**)(char *, uint64_t))(v78 + 8))(v66, v67);
        BOOL v70 = v80;
        (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, swift *))(v10 + 8))(v38, a2);
        uint64_t v71 = (uint64_t)a2;
        uint64_t v72 = v82;
        uint64_t v73 = swift_getAssociatedConformanceWitness( a3,  v71,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v74 = (*(uint64_t (**)(uint64_t))(*(void *)(v73 + 8) + 120LL))(v72);
        (*(void (**)(char *, uint64_t))(v81 + 8))(v70, v72);
        *(double *)&_D8 = COERCE_FLOAT((v65 << 31) | (v69 << 23) | v74 & 0x7FFFFF);
      }

      return *(double *)&_D8;
    }

    goto LABEL_13;
  }

  if (v27 != 5 || v28 != 10) {
    goto LABEL_13;
  }
  Swift::String::Index v29 = v83;
  (*(void (**)(uint64_t *, uint64_t, swift *))(v10 + 16))(v26, v83, a2);
  uint64_t v30 = swift_dynamicCast((char *)&v84, v26, a2, (const char *)&type metadata for Float16, 6uLL);
  _H8 = v84;
  (*(void (**)(char *, uint64_t, swift *))(v10 + 32))(v24, v29, a2);
  if (v30)
  {
    (*(void (**)(char *, swift *))(v10 + 8))(v24, a2);
  }

  else
  {
    Swift::UInt64 v41 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
    uint64_t v42 = v77;
    (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
    uint64_t v43 = v79;
    uint64_t v44 = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
    uint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)(v44 + 8) + 120LL))(v43);
    (*(void (**)(char *, uint64_t))(v78 + 8))(v42, v43);
    Swift::UInt64 v46 = v80;
    (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
    (*(void (**)(char *, swift *))(v10 + 8))(v24, a2);
    uint64_t v47 = (uint64_t)a2;
    Swift::String::Index v48 = v82;
    Swift::UInt64 v49 = swift_getAssociatedConformanceWitness( a3,  v47,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
    Swift::UInt64 v50 = (*(uint64_t (**)(uint64_t))(*(void *)(v49 + 8) + 120LL))(v48);
    (*(void (**)(char *, uint64_t))(v81 + 8))(v46, v48);
    _H8 = (v41 << 15) | ((v45 & 0x1F) << 10) | v50 & 0x3FF;
  }

  __asm { FCVT            D8, H8 }

  return *(double *)&_D8;
}

    uint64_t v39 = v83;
    specialized static BinaryFloatingPoint._convert<A>(from:)((int *)&v84, v83, (uint64_t)a2, a3);
    (*(void (**)(const char *, swift *))(v10 + 8))(v39, a2);
    _S8 = SLODWORD(v84);
    return *(float *)&_S8;
  }

  if (v27 == 8)
  {
    if (v28 == 23)
    {
      uint64_t v36 = v83;
      (*(void (**)(uint64_t *, const char *, swift *))(v10 + 16))(v21, v83, a2);
      Swift::UInt64 v37 = swift_dynamicCast((char *)&v84, v21, a2, (const char *)&type metadata for Float, 6uLL);
      _S8 = SLODWORD(v84);
      BOOL v38 = v76;
      (*(void (**)(char *, const char *, swift *))(v10 + 32))(v76, v36, a2);
      if (v37)
      {
        (*(void (**)(char *, swift *))(v10 + 8))(v38, a2);
      }

      else
      {
        uint64_t v65 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
        uint64_t v66 = v77;
        (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
        BOOL v67 = v79;
        BOOL v68 = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
        BOOL v69 = (*(uint64_t (**)(uint64_t))(*(void *)(v68 + 8) + 120LL))(v67);
        (*(void (**)(char *, uint64_t))(v78 + 8))(v66, v67);
        BOOL v70 = v80;
        (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
        (*(void (**)(char *, swift *))(v10 + 8))(v38, a2);
        uint64_t v71 = (uint64_t)a2;
        uint64_t v72 = v82;
        uint64_t v73 = swift_getAssociatedConformanceWitness( a3,  v71,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
        uint64_t v74 = (*(uint64_t (**)(uint64_t))(*(void *)(v73 + 8) + 120LL))(v72);
        (*(void (**)(char *, uint64_t))(v81 + 8))(v70, v72);
        _S8 = (v65 << 31) | (v69 << 23) | v74 & 0x7FFFFF;
      }

      return *(float *)&_S8;
    }

    goto LABEL_13;
  }

  if (v27 != 5 || v28 != 10) {
    goto LABEL_13;
  }
  Swift::String::Index v29 = v83;
  (*(void (**)(uint64_t *, const char *, swift *))(v10 + 16))(v26, v83, a2);
  uint64_t v30 = swift_dynamicCast((char *)&v84, v26, a2, (const char *)&type metadata for Float16, 6uLL);
  _H8 = LOWORD(v84);
  (*(void (**)(char *, const char *, swift *))(v10 + 32))(v24, v29, a2);
  if (v30)
  {
    (*(void (**)(char *, swift *))(v10 + 8))(v24, a2);
  }

  else
  {
    Swift::UInt64 v41 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
    uint64_t v42 = v77;
    (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
    uint64_t v43 = v79;
    uint64_t v44 = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
    uint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)(v44 + 8) + 120LL))(v43);
    (*(void (**)(char *, uint64_t))(v78 + 8))(v42, v43);
    Swift::UInt64 v46 = v80;
    (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
    (*(void (**)(char *, swift *))(v10 + 8))(v24, a2);
    uint64_t v47 = (uint64_t)a2;
    Swift::String::Index v48 = v82;
    Swift::UInt64 v49 = swift_getAssociatedConformanceWitness( a3,  v47,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
    Swift::UInt64 v50 = (*(uint64_t (**)(uint64_t))(*(void *)(v49 + 8) + 120LL))(v48);
    (*(void (**)(char *, uint64_t))(v81 + 8))(v46, v48);
    _H8 = (v41 << 15) | ((v45 & 0x1F) << 10) | v50 & 0x3FF;
  }

  __asm { FCVT            S8, H8 }

  return *(float *)&_S8;
}

      Swift::UInt64 v41 = v83;
      specialized static BinaryFloatingPoint._convert<A>(from:)((__int16 *)&v84, v83, (uint64_t)a2, a3);
      (*(void (**)(uint64_t, swift *))(v11 + 8))(v41, a2);
      LOWORD(_D8) = v84;
      return *(float *)&_D8;
    }

    if (v29 != 23) {
      goto LABEL_13;
    }
    BOOL v38 = v83;
    (*(void (**)(uint64_t *, uint64_t, swift *))(v11 + 16))(v22, v83, a2);
    uint64_t v39 = swift_dynamicCast((char *)&v84, v22, a2, (const char *)&type metadata for Float, 6uLL);
    LODWORD(_D8) = v84;
    uint64_t v40 = v76;
    (*(void (**)(char *, uint64_t, swift *))(v11 + 32))(v76, v38, a2);
    if (v39)
    {
      (*(void (**)(char *, swift *))(v11 + 8))(v40, a2);
      __asm { FCVT            H8, S8 }
    }

    else
    {
      uint64_t v64 = (*(uint64_t (**)(swift *))(*(void *)(a3 + 16) + 168LL))(a2);
      uint64_t v65 = v77;
      (*(void (**)(swift *, uint64_t))(a3 + 112))(a2, a3);
      uint64_t v66 = v79;
      BOOL v67 = swift_getAssociatedConformanceWitness( a3,  (uint64_t)a2,  v79,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      BOOL v68 = (*(uint64_t (**)(uint64_t))(*(void *)(v67 + 8) + 120LL))(v66);
      (*(void (**)(char *, uint64_t))(v78 + 8))(v65, v66);
      BOOL v69 = v80;
      (*(void (**)(swift *, uint64_t))(a3 + 120))(a2, a3);
      (*(void (**)(char *, swift *))(v11 + 8))(v40, a2);
      BOOL v70 = (uint64_t)a2;
      uint64_t v71 = v82;
      uint64_t v72 = swift_getAssociatedConformanceWitness( a3,  v70,  v82,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      uint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)(v72 + 8) + 120LL))(v71);
      (*(void (**)(char *, uint64_t))(v81 + 8))(v69, v71);
      _S0 = (v64 << 31) | (v68 << 23) | v73 & 0x7FFFFF;
      __asm { FCVT            H8, S0 }
    }
  }

  return *(float *)&_D8;
}

      Swift::String::Index v56 = v109;
      uint64_t v57 = v113;
      static BinaryFloatingPoint._convert<A>(from:)(v15, v109, v113, (uint64_t)a3, v111, a5);
      (*(void (**)(uint64_t, swift *))(v110 + 8))(v56, a3);
      unint64_t v58 = v107;
      uint64_t v59 = swift_getAssociatedConformanceWitness( (uint64_t)v107,  v57,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v60 = v105;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v59 + 8))( &qword_18180BE70,  512LL,  AssociatedTypeWitness,  v59);
      Swift::UInt64 v61 = v104;
      (*((void (**)(char *, uint64_t, const char *))v58 + 3))(v60, v57, v58);
      (*(void (**)(char *, char *, uint64_t))(v108 + 64))(v15, v61, v57);
      uint64_t v62 = *(void (**)(char *, uint64_t))(v106 + 8);
      v62(v61, v57);
      return ((uint64_t (*)(char *, uint64_t))v62)(v15, v57);
    }

    if (v37 != 23) {
      goto LABEL_13;
    }
    Swift::UInt64 v50 = v109;
    uint64_t v51 = v110;
    (*(void (**)(uint64_t *, uint64_t, swift *))(v110 + 16))(v31, v109, a3);
    Swift::UInt64 v52 = swift_dynamicCast((char *)&v115, v31, a3, (const char *)&type metadata for Float, 6uLL);
    Swift::UInt64 v53 = v115;
    Swift::UInt64 v54 = v97;
    (*(void (**)(char *, uint64_t, swift *))(v51 + 32))(v97, v50, a3);
    if (v52)
    {
      (*(void (**)(char *, swift *))(v51 + 8))(v54, a3);
    }

    else
    {
      uint64_t v86 = (*(uint64_t (**)(swift *))(*(void *)(a5 + 16) + 168LL))(a3);
      uint64_t v87 = v98;
      (*(void (**)(swift *, uint64_t))(a5 + 112))(a3, a5);
      uint64_t v88 = v100;
      uint64_t v89 = swift_getAssociatedConformanceWitness( a5,  (uint64_t)a3,  v100,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawExponent: UnsignedInteger);
      uint64_t v90 = (*(unsigned __int8 (**)(uint64_t))(*(void *)(v89 + 8) + 120LL))(v88);
      (*(void (**)(char *, uint64_t))(v99 + 8))(v87, v88);
      uint64_t v91 = v101;
      (*(void (**)(swift *, uint64_t))(a5 + 120))(a3, a5);
      (*(void (**)(char *, swift *))(v51 + 8))(v54, a3);
      uint64_t v92 = v103;
      unint64_t v93 = swift_getAssociatedConformanceWitness( a5,  (uint64_t)a3,  v103,  (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint,  (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
      unint64_t v94 = (*(uint64_t (**)(uint64_t))(*(void *)(v93 + 8) + 120LL))(v92);
      (*(void (**)(char *, uint64_t))(v102 + 8))(v91, v92);
      Swift::UInt64 v53 = (v86 << 31) | (v90 << 23) | v94 & 0x7FFFFF;
    }

    v55.n128_u32[0] = v53;
    return (*(uint64_t (**)(__n128))(v111 + 64))(v55);
  }

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
      }
    }

    __break(1u);
    goto LABEL_13;
  }

      uint64_t v23 = *(__objc2_class ***)v2;
      BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*(void *)v2);
      *(void *)uint64_t v2 = v23;
      if (!isUniquelyReferenced_nonNull_native)
      {
        uint64_t v23 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v23[2]->isa + 1,  1,  (uint64_t)v23);
        *(void *)uint64_t v2 = v23;
      }

      uint64_t v26 = (unint64_t)v23[2];
      uint64_t v25 = (unint64_t)v23[3];
      if (v26 >= v25 >> 1) {
        uint64_t v23 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v25 > 1),  v26 + 1,  1,  (uint64_t)v23);
      }
      v23[2] = (__objc2_class *)(v26 + 1);
      uint64_t v27 = &v23[v26];
      *((_DWORD *)v27 + 8) = v19;
      *((_WORD *)v27 + 18) = v20;
      *(void *)uint64_t v2 = v23;
      unint64_t v15 = v34;
      goto LABEL_5;
    }

  uint64_t result = a1 - 1;
  *uint64_t v1 = v7;
  return result;
}

    if (v19) {
      v19(v13);
    }
    if (v7 == ++v8) {
      return 1LL;
    }
  }

  uint64_t v17 = v12;
  if ((a3("", v9, v10, &v17) & 1) != 0) {
    goto LABEL_13;
  }
  unint64_t v15 = v19;
  if (!v19) {
    return 0LL;
  }
  unint64_t v16 = 0LL;
LABEL_20:
  v15(v16);
  return 0LL;
}

  *a1 = a4;
  a1[1] = a5;
  a1[2] = a3;
  return a3;
}

    unint64_t v15 = 0;
    return v15 & 1;
  }

  if (!*(void *)(a2 + 16)) {
    goto LABEL_13;
  }
  unint64_t v16 = (*(uint64_t (**)(void, uint64_t *, uint64_t))(a4 + 32))(*(void *)(a2 + 40), a3, a4);
  uint64_t v17 = -1LL << *(_BYTE *)(a2 + 32);
  uint64_t v18 = v16 & ~v17;
  uint64_t v27 = a2 + 56;
  if (((*(void *)(a2 + 56 + ((v18 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v18) & 1) == 0) {
    goto LABEL_13;
  }
  uint64_t v25 = ~v17;
  uint64_t v26 = a1;
  uint64_t v19 = *(void *)(a4 + 8);
  uint64_t v20 = *(uint64_t (**)(char *, id *, uint64_t *, uint64_t))(v19 + 8);
  Swift::String::Index v21 = *(void *)(v8 + 72);
  uint64_t v22 = *(void (**)(char *, unint64_t, uint64_t *))(v8 + 16);
  do
  {
    v22(v10, *(void *)(a2 + 48) + v21 * v18, a3);
    unint64_t v15 = v20(v10, v26, a3, v19);
    (*(void (**)(char *, uint64_t *))(v8 + 8))(v10, a3);
    if ((v15 & 1) != 0) {
      break;
    }
    uint64_t v18 = (v18 + 1) & v25;
  }

  while (((*(void *)(v27 + ((v18 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v18) & 1) != 0);
  return v15 & 1;
}

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }

    unint64_t v13 = 1860LL;
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v13,  0);
  }

  v15[0] = a1;
  v15[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (a3 < 0) {
    goto LABEL_13;
  }
  if ((uint64_t)(HIBYTE(a2) & 0xF) < a4)
  {
LABEL_11:
    unint64_t v13 = 1861LL;
    goto LABEL_14;
  }

  uint64_t v11 = a4 - a3;
  if (a4 - a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v10 = (unsigned __int8 *)v15 + a3;
  return specialized closure #1 in _StringGutsSlice._withNFCCodeUnits(_:)(v10, v11, a5);
}

    unint64_t v13 = 1860LL;
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v13,  0);
  }

  v15[0] = a1;
  v15[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (a3 < 0) {
    goto LABEL_13;
  }
  if ((uint64_t)(HIBYTE(a2) & 0xF) < a4)
  {
LABEL_11:
    unint64_t v13 = 1861LL;
    goto LABEL_14;
  }

  uint64_t v11 = a4 - a3;
  if (a4 - a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v10 = (__objc2_class **)((char *)v15 + a3);
  return specialized closure #1 in _StringGutsSlice._withNFCCodeUnits(_:)(v10, v11, a5);
}

    uint64_t v12 = v7 & 0xFC00FC00;
    if ((v7 & 0xFC00FC00) == 0xDC00D800) {
      unint64_t v13 = 32;
    }
    else {
      unint64_t v13 = 16;
    }
    Swift::UInt64 v41 = v8 - v13;
    if (v12 == -603924480) {
      uint64_t v14 = 32;
    }
    else {
      uint64_t v14 = 16;
    }
    uint64_t v40 = (unint64_t)v7 >> v14;
    if (v12 == -603924480)
    {
      unint64_t v15 = 0;
      goto LABEL_22;
    }

    if ((v37 & 1) != 0) {
      break;
    }
    uint64_t v24 = (__objc2_class **)*a4;
    uint64_t v25 = swift_isUniquelyReferenced_nonNull_native(*a4);
    *a4 = (uint64_t)v24;
    if (!v25)
    {
      uint64_t v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v24[2]->isa + 1,  1,  (uint64_t)v24);
      *a4 = (uint64_t)v24;
    }

    uint64_t v27 = v24[2];
    uint64_t v26 = (unint64_t)v24[3];
    if ((unint64_t)v27 >= v26 >> 1) {
      uint64_t v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v26 > 1),  (int64_t)&v27->isa + 1,  1,  (uint64_t)v24);
    }
    uint64_t v24[2] = (__objc2_class *)((char *)&v27->isa + 1);
    *((_BYTE *)&v27->info + (void)v24) = -17;
    *a4 = (uint64_t)v24;
    uint64_t v28 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v24);
    *a4 = (uint64_t)v24;
    if (!v28)
    {
      uint64_t v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v24[2]->isa + 1,  1,  (uint64_t)v24);
      *a4 = (uint64_t)v24;
    }

    uint64_t v30 = v24[2];
    Swift::String::Index v29 = (unint64_t)v24[3];
    if ((unint64_t)v30 >= v29 >> 1) {
      uint64_t v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v29 > 1),  (int64_t)&v30->isa + 1,  1,  (uint64_t)v24);
    }
    uint64_t v24[2] = (__objc2_class *)((char *)&v30->isa + 1);
    *((_BYTE *)&v30->info + (void)v24) = -65;
    *a4 = (uint64_t)v24;
    BOOL isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v24);
    *a4 = (uint64_t)v24;
    if ((isUniquelyReferenced_nonNull_native & 1) == 0)
    {
      BOOL isUniquelyReferenced_nonNull_native = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  (int64_t)&v24[2]->isa + 1,  1,  (uint64_t)v24);
      uint64_t v24 = (__objc2_class **)isUniquelyReferenced_nonNull_native;
      *a4 = isUniquelyReferenced_nonNull_native;
    }

    uint64_t v32 = v24[2];
    uint64_t v31 = (unint64_t)v24[3];
    if ((unint64_t)v32 >= v31 >> 1)
    {
      BOOL isUniquelyReferenced_nonNull_native = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( (__objc2_class **)(v31 > 1),  (int64_t)&v32->isa + 1,  1,  (uint64_t)v24);
      uint64_t v24 = (__objc2_class **)isUniquelyReferenced_nonNull_native;
    }

    uint64_t v24[2] = (__objc2_class *)((char *)&v32->isa + 1);
    *((_BYTE *)&v32->info + (void)v24) = -67;
    *a4 = (uint64_t)v24;
    BOOL v38 = 1;
LABEL_3:
    uint64_t v8 = v41;
    uint64_t v7 = v40;
  }

  BOOL v38 = 1;
  return v38 & 1;
}

    unint64_t v13 = 1860LL;
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v13,  0);
  }

  v15[0] = a5;
  v15[1] = a6 & 0xFFFFFFFFFFFFFFLL;
  if (a1 < 0) {
    goto LABEL_13;
  }
  if ((uint64_t)(HIBYTE(a6) & 0xF) < a2)
  {
LABEL_11:
    unint64_t v13 = 1861LL;
    goto LABEL_14;
  }

  if (a2 - a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeBufferPointer with negative count",  39LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x53FuLL,  0);
  }
  uint64_t v11 = (char *)v15 + a1;
  return a3(v11);
}

        swift_bridgeObjectRelease(v9);
LABEL_14:
        Swift::UInt64 v5 = v115;
        uint64_t v10 = v116;
        if ((v4 & 0x1000000) == 0) {
          goto LABEL_68;
        }
LABEL_15:
        uint64_t v11 = HIBYTE(v10) & 0xF;
        if ((v10 & 0x2000000000000000LL) != 0) {
          uint64_t v12 = HIBYTE(v10) & 0xF;
        }
        else {
          uint64_t v12 = v5 & 0xFFFFFFFFFFFFLL;
        }
        if (!v12 && (v5 & ~v10 & 0x2000000000000000LL) == 0)
        {
          Swift::UInt64 v5 = 82LL;
          uint64_t v115 = 82LL;
          uint64_t v116 = 0xE100000000000000LL;
          swift_bridgeObjectRelease(v10);
          uint64_t v10 = 0xE100000000000000LL;
          goto LABEL_68;
        }

        if ((v10 & 0x2000000000000000LL) != 0 && v11 != 15) {
          break;
        }
        swift_bridgeObjectRetain_n(0xE100000000000000LL, 6LL, a3, a4);
        if ((v10 & 0x1000000000000000LL) != 0) {
          goto LABEL_107;
        }
        uint64_t v27 = __OFADD__(v12, 1LL);
        uint64_t v4 = v12 + 1;
        if (!v27) {
          goto LABEL_43;
        }
      }

      unint64_t v13 = 8 * (HIBYTE(v10) & 7);
      uint64_t v14 = (-255LL << v13) - 1;
      unint64_t v15 = 82LL << v13;
      unint64_t v16 = v15 | v14 & v10;
      uint64_t v17 = v15 | v14 & v5;
      if (v11 >= 8) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = v10;
      }
      if (v11 < 8) {
        Swift::UInt64 v5 = v17;
      }
      swift_bridgeObjectRelease(v10);
      swift_bridgeObjectRelease(0xE100000000000000LL);
      uint64_t v19 = 0xA000000000000000LL;
      if (!(v5 & 0x8080808080808080LL | v18 & 0x80808080808080LL)) {
        uint64_t v19 = 0xE000000000000000LL;
      }
      uint64_t v10 = (v19 & 0xFF00000000000000LL | (v11 << 56) | v18 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000LL;
      uint64_t v115 = v5;
      uint64_t v116 = v10;
    }

    else
    {
LABEL_43:
      if ((v5 & ~v10 & 0x2000000000000000LL) != 0
        && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
      {
        uint64_t v28 = _StringGuts.nativeUnusedCapacity.getter(v5, v10);
        if ((v29 & 1) != 0) {
          goto LABEL_114;
        }
        uint64_t v31 = (v10 & 0x2000000000000000LL) == 0 && v28 > 0;
        if (v4 > 15 || v31) {
          goto LABEL_59;
        }
LABEL_54:
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 5LL);
        swift_bridgeObjectRetain(v10, v32, v33, v34);
        uint64_t v35 = _StringGuts._convertedToSmall()(v5, v10);
        Swift::UInt64 v37 = v36;
        swift_bridgeObjectRelease(v10);
        v38._Swift::UInt64 rawBits = 1LL;
        v39._Swift::UInt64 rawBits = 65537LL;
        v40._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v38, v39, 0x52uLL, 0xE100000000000000LL);
        if (v40._rawBits < 0x10000) {
          v40._rawBits |= 3;
        }
        uint64_t v42 = specialized String.init(_:)(v40, v41, 0x52uLL, 0xE100000000000000LL);
        uint64_t v44 = v43;
        swift_bridgeObjectRelease(0xE100000000000000LL);
        uint64_t v45 = _StringGuts._convertedToSmall()(v42, v44);
        uint64_t v47 = v46;
        swift_bridgeObjectRelease(v44);
        Swift::String::Index v48 = specialized _SmallString.init(_:appending:)(v35, v37, v45, v47);
        if ((v50 & 1) != 0) {
          goto LABEL_113;
        }
        Swift::UInt64 v5 = v48;
        uint64_t v10 = v49;
        swift_bridgeObjectRelease(0xE100000000000000LL);
        uint64_t v51 = v116;
        uint64_t v115 = v5;
        uint64_t v116 = v10;
        swift_bridgeObjectRelease(v51);
      }

      else
      {
        if (v4 <= 15) {
          goto LABEL_54;
        }
LABEL_59:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v4, 1LL);
        swift_bridgeObjectRelease_n(0xE100000000000000LL, 6LL);
        unint64_t v114 = xmmword_1817FFF90;
        Swift::UInt64 v52 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 1LL, (uint64_t)&v114, 1LL);
        _StringGuts.appendInPlace(_:isASCII:)(v52, v53, 1);
        swift_bridgeObjectRelease(0xE100000000000000LL);
        Swift::UInt64 v5 = v115;
        uint64_t v10 = v116;
      }
    }
  }

  if (v58 >= 8) {
    uint64_t v60 = v5;
  }
  else {
    uint64_t v60 = (93LL << (8 * (HIBYTE(v10) & 7u))) | ((-255LL << (8 * (HIBYTE(v10) & 7u))) - 1) & v5;
  }
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease(0xE100000000000000LL);
  return v60;
}

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
    }

      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/SIMDVector.swift",  22LL,  2,  0x2CDuLL,  0);
    }

    uint64_t v57 = (void (*)(unsigned __int8 *, uint64_t, unint64_t, uint64_t, void *))v33[12];
    unint64_t v58 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v43, v44, v45);
    uint64_t v59 = v67;
    v57(&v73, v66, v58, a2, v33);
    LOBYTE(v57) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33[4] + 8LL) + 16LL))(v59, v37, a2);
    Swift::String::Index v29 = v41;
    v41(v59, a2);
    v41(v37, a2);
    uint64_t v31 = v71;
    uint64_t v30 = v72;
    goto LABEL_7;
  }

  if (v43 >= 9) {
    goto LABEL_13;
  }
  uint64_t v60 = v67;
  (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v67, v37, a2);
  Swift::UInt64 v61 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
  Swift::String::Index v29 = v41;
  v41(v60, a2);
  Swift::String::Index v56 = v73 >= v61;
LABEL_16:
  uint64_t v31 = v71;
  uint64_t v30 = v72;
  if (!v56)
  {
LABEL_17:
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
    BOOL v38 = 0;
    uint64_t v40 = 1;
    goto LABEL_18;
  }

    uint64_t v57 = (void (*)(unsigned __int16 *, uint64_t, unint64_t, uint64_t, void *))v33[12];
    unint64_t v58 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v43, v44, v45);
    uint64_t v59 = v67;
    v57(&v73, v66, v58, a2, v33);
    LOBYTE(v57) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33[4] + 8LL) + 16LL))(v59, v37, a2);
    Swift::String::Index v29 = v41;
    v41(v59, a2);
    v41(v37, a2);
    uint64_t v31 = v71;
    uint64_t v30 = v72;
    goto LABEL_7;
  }

  if (v43 >= 17) {
    goto LABEL_13;
  }
  uint64_t v60 = v67;
  (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v67, v37, a2);
  Swift::UInt64 v61 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
  Swift::String::Index v29 = v41;
  v41(v60, a2);
  Swift::String::Index v56 = v73 >= v61;
LABEL_16:
  uint64_t v31 = v71;
  uint64_t v30 = v72;
  if (!v56)
  {
LABEL_17:
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
    BOOL v38 = 0;
    uint64_t v40 = 1;
    goto LABEL_18;
  }

    uint64_t v57 = (void (*)(unsigned int *, uint64_t, unint64_t, uint64_t, void *))v33[12];
    unint64_t v58 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v43, v44, v45);
    uint64_t v59 = v67;
    v57(&v73, v66, v58, a2, v33);
    LOBYTE(v57) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33[4] + 8LL) + 16LL))(v59, v37, a2);
    Swift::String::Index v29 = v41;
    v41(v59, a2);
    v41(v37, a2);
    uint64_t v31 = v71;
    uint64_t v30 = v72;
    goto LABEL_7;
  }

  if (v43 >= 33) {
    goto LABEL_13;
  }
  uint64_t v60 = v67;
  (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v67, v37, a2);
  Swift::UInt64 v61 = ((uint64_t (*)(uint64_t, void *))v33[15])(a2, v33);
  Swift::String::Index v29 = v41;
  v41(v60, a2);
  Swift::String::Index v56 = v73 >= v61;
LABEL_16:
  uint64_t v31 = v71;
  uint64_t v30 = v72;
  if (!v56)
  {
LABEL_17:
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
    BOOL v38 = 0;
    uint64_t v40 = 1;
    goto LABEL_18;
  }

    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Overflow in -",  13LL,  2,  "Swift/LegacyInt128.swift",  24LL,  2,  0x5FuLL,  0);
  }

  uint64_t v12 = v5 - v7;
  uint64_t v10 = v4 - v6;
  unint64_t v13 = v4 < v6;
  if (v5 < v7)
  {
    if (!v10) {
      LOBYTE(v13) = 1;
    }
    if (!v13)
    {
      --v10;
      goto LABEL_24;
    }

    goto LABEL_13;
  }

    uint64_t v26 = v10 & ~v11;
    if ((v26 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v27 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
      if ((v28 & 1) != 0) {
        goto LABEL_334;
      }
      if (v25 > 15) {
        goto LABEL_21;
      }
      if ((v11 & 0x2000000000000000LL) != 0) {
        goto LABEL_62;
      }
      if (v27 > 7)
      {
LABEL_21:
        Swift::String::Index v29 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
        uint64_t v32 = (v30 & 1) == 0 && v29 > 7;
        if ((v26 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v32) {
            goto LABEL_50;
          }
        }

        else if (v32)
        {
          goto LABEL_49;
        }

        uint64_t v47 = _StringGuts.nativeCapacity.getter(v10, v11);
        if ((v48 & 1) != 0) {
          Swift::UInt64 v49 = 0LL;
        }
        else {
          Swift::UInt64 v49 = v47;
        }
        if (v49 + 0x4000000000000000LL >= 0)
        {
          Swift::UInt64 v50 = 2 * v49;
          if (v50 > v25) {
            uint64_t v25 = v50;
          }
LABEL_49:
          _StringGuts.grow(_:)(v25);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000LL, 6LL);
          v297 = xmmword_181800000;
          uint64_t v51 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 8LL, (uint64_t)&v297, 8LL);
          _StringGuts.appendInPlace(_:isASCII:)(v51, v52, 1);
          swift_bridgeObjectRelease(0xE800000000000000LL);
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }

        __break(1u);
LABEL_325:
        uint64_t v10 = _StringGuts._foreignConvertedToSmall()(v10, v11);
        unint64_t v13 = v285;
        goto LABEL_63;
      }
    }

    else
    {
      if (v25 > 15) {
        goto LABEL_21;
      }
      if ((v11 & 0x2000000000000000LL) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
        unint64_t v13 = v11;
        goto LABEL_63;
      }
    }

    swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
    if ((v11 & 0x1000000000000000LL) != 0) {
      goto LABEL_325;
    }
    if ((v10 & 0x1000000000000000LL) != 0)
    {
      Swift::String::Index v56 = (unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      Swift::String::Index v56 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v11);
      unint64_t v13 = v53;
    }

    swift_bridgeObjectRetain(v11, v53, v54, v55);
    closure #1 in _StringGuts._convertedToSmall()(v56, v13, &v297);
    swift_bridgeObjectRelease(v11);
    unint64_t v13 = *((void *)&v297 + 1);
    uint64_t v10 = v297;
LABEL_63:
    v57._Swift::UInt64 rawBits = 1LL;
    v58._Swift::UInt64 rawBits = 524289LL;
    v59._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v57, v58, 0x203A747261747328uLL, 0xE800000000000000LL);
    if (v59._rawBits < 0x10000) {
      v59._rawBits |= 3;
    }
    Swift::UInt64 v61 = specialized String.init(_:)(v59, v60, 0x203A747261747328uLL, 0xE800000000000000LL);
    uint64_t v63 = v62;
    swift_bridgeObjectRelease(0xE800000000000000LL);
    if ((v63 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v63);
      goto LABEL_67;
    }

    uint64_t v26 = v10 & ~v11;
    if ((v26 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v27 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
      if ((v28 & 1) != 0) {
        goto LABEL_334;
      }
      if (v25 > 15) {
        goto LABEL_21;
      }
      if ((v11 & 0x2000000000000000LL) != 0) {
        goto LABEL_62;
      }
      if (v27 > 7)
      {
LABEL_21:
        Swift::String::Index v29 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
        uint64_t v32 = (v30 & 1) == 0 && v29 > 7;
        if ((v26 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v32) {
            goto LABEL_50;
          }
        }

        else if (v32)
        {
          goto LABEL_49;
        }

        uint64_t v47 = _StringGuts.nativeCapacity.getter(v10, v11);
        if ((v48 & 1) != 0) {
          Swift::UInt64 v49 = 0LL;
        }
        else {
          Swift::UInt64 v49 = v47;
        }
        if (v49 + 0x4000000000000000LL >= 0)
        {
          Swift::UInt64 v50 = 2 * v49;
          if (v50 > v25) {
            uint64_t v25 = v50;
          }
LABEL_49:
          _StringGuts.grow(_:)(v25);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000LL, 6LL);
          v297 = xmmword_181800000;
          uint64_t v51 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 8LL, (uint64_t)&v297, 8LL);
          _StringGuts.appendInPlace(_:isASCII:)(v51, v52, 1);
          swift_bridgeObjectRelease(0xE800000000000000LL);
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }

        __break(1u);
LABEL_325:
        uint64_t v10 = _StringGuts._foreignConvertedToSmall()(v10, v11);
        unint64_t v13 = v285;
        goto LABEL_63;
      }
    }

    else
    {
      if (v25 > 15) {
        goto LABEL_21;
      }
      if ((v11 & 0x2000000000000000LL) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
        unint64_t v13 = v11;
        goto LABEL_63;
      }
    }

    swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
    if ((v11 & 0x1000000000000000LL) != 0) {
      goto LABEL_325;
    }
    if ((v10 & 0x1000000000000000LL) != 0)
    {
      Swift::String::Index v56 = (unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      Swift::String::Index v56 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v11);
      unint64_t v13 = v53;
    }

    swift_bridgeObjectRetain(v11, v53, v54, v55);
    closure #1 in _StringGuts._convertedToSmall()(v56, v13, &v297);
    swift_bridgeObjectRelease(v11);
    unint64_t v13 = *((void *)&v297 + 1);
    uint64_t v10 = v297;
LABEL_63:
    v57._Swift::UInt64 rawBits = 1LL;
    v58._Swift::UInt64 rawBits = 524289LL;
    v59._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v57, v58, 0x203A747261747328uLL, 0xE800000000000000LL);
    if (v59._rawBits < 0x10000) {
      v59._rawBits |= 3;
    }
    Swift::UInt64 v61 = specialized String.init(_:)(v59, v60, 0x203A747261747328uLL, 0xE800000000000000LL);
    uint64_t v63 = v62;
    swift_bridgeObjectRelease(0xE800000000000000LL);
    if ((v63 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v63);
      goto LABEL_67;
    }

    uint64_t v25 = v9 & ~countAndFlagsBits;
    if ((v25 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v26 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
      if ((v27 & 1) != 0) {
        goto LABEL_303;
      }
      if (v24 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000LL) != 0) {
        goto LABEL_62;
      }
      if (v26 > 7)
      {
LABEL_21:
        uint64_t v28 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
        uint64_t v31 = (v29 & 1) == 0 && v28 > 7;
        if ((v25 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v31) {
            goto LABEL_50;
          }
        }

        else if (v31)
        {
          goto LABEL_49;
        }

        Swift::UInt64 v46 = _StringGuts.nativeCapacity.getter(v9, countAndFlagsBits);
        if ((v47 & 1) != 0) {
          Swift::String::Index v48 = 0LL;
        }
        else {
          Swift::String::Index v48 = v46;
        }
        if (v48 + 0x4000000000000000LL >= 0)
        {
          Swift::UInt64 v49 = 2 * v48;
          if (v49 > v24) {
            uint64_t v24 = v49;
          }
LABEL_49:
          _StringGuts.grow(_:)(v24);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000LL, 6LL);
          v253 = xmmword_181800000;
          Swift::UInt64 v50 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 8LL, (uint64_t)&v253, 8LL);
          _StringGuts.appendInPlace(_:isASCII:)(v50, v51, 1);
          swift_bridgeObjectRelease(0xE800000000000000LL);
          v251 = object;
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }

        __break(1u);
LABEL_296:
        unint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, countAndFlagsBits);
        uint64_t v12 = v241;
        goto LABEL_63;
      }
    }

    else
    {
      if (v24 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000LL) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
        uint64_t v12 = countAndFlagsBits;
        goto LABEL_63;
      }
    }

    swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
    if ((countAndFlagsBits & 0x1000000000000000LL) != 0) {
      goto LABEL_296;
    }
    if ((v9 & 0x1000000000000000LL) != 0)
    {
      uint64_t v55 = (unsigned __int8 *)((countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v55 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, countAndFlagsBits);
      uint64_t v12 = v52;
    }

    swift_bridgeObjectRetain(countAndFlagsBits, v52, v53, v54);
    closure #1 in _StringGuts._convertedToSmall()(v55, v12, &v253);
    swift_bridgeObjectRelease(countAndFlagsBits);
    uint64_t v12 = *((void *)&v253 + 1);
    unint64_t v9 = v253;
LABEL_63:
    v56._Swift::UInt64 rawBits = 1LL;
    v57._Swift::UInt64 rawBits = 524289LL;
    v58._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v56, v57, 0x203A747261747328uLL, 0xE800000000000000LL);
    if (v58._rawBits < 0x10000) {
      v58._rawBits |= 3;
    }
    uint64_t v2 = specialized String.init(_:)(v58, v59, 0x203A747261747328uLL, 0xE800000000000000LL);
    Swift::UInt64 v61 = v60;
    swift_bridgeObjectRelease(0xE800000000000000LL);
    if ((v61 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v61);
      goto LABEL_67;
    }

    uint64_t v25 = v9 & ~countAndFlagsBits;
    if ((v25 & 0x2000000000000000LL) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      uint64_t v26 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
      if ((v27 & 1) != 0) {
        goto LABEL_303;
      }
      if (v24 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000LL) != 0) {
        goto LABEL_62;
      }
      if (v26 > 7)
      {
LABEL_21:
        uint64_t v28 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
        uint64_t v31 = (v29 & 1) == 0 && v28 > 7;
        if ((v25 & 0x2000000000000000LL) != 0
          && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v31) {
            goto LABEL_50;
          }
        }

        else if (v31)
        {
          goto LABEL_49;
        }

        Swift::UInt64 v46 = _StringGuts.nativeCapacity.getter(v9, countAndFlagsBits);
        if ((v47 & 1) != 0) {
          Swift::String::Index v48 = 0LL;
        }
        else {
          Swift::String::Index v48 = v46;
        }
        if (v48 + 0x4000000000000000LL >= 0)
        {
          Swift::UInt64 v49 = 2 * v48;
          if (v49 > v24) {
            uint64_t v24 = v49;
          }
LABEL_49:
          _StringGuts.grow(_:)(v24);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000LL, 6LL);
          v253 = xmmword_181800000;
          Swift::UInt64 v50 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, 8LL, (uint64_t)&v253, 8LL);
          _StringGuts.appendInPlace(_:isASCII:)(v50, v51, 1);
          swift_bridgeObjectRelease(0xE800000000000000LL);
          v251 = object;
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }

        __break(1u);
LABEL_296:
        unint64_t v9 = _StringGuts._foreignConvertedToSmall()(v9, countAndFlagsBits);
        uint64_t v12 = v241;
        goto LABEL_63;
      }
    }

    else
    {
      if (v24 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000LL) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
        uint64_t v12 = countAndFlagsBits;
        goto LABEL_63;
      }
    }

    swift_bridgeObjectRelease_n(0xE800000000000000LL, 5LL);
    if ((countAndFlagsBits & 0x1000000000000000LL) != 0) {
      goto LABEL_296;
    }
    if ((v9 & 0x1000000000000000LL) != 0)
    {
      uint64_t v55 = (unsigned __int8 *)((countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL) + 32);
    }

    else
    {
      uint64_t v55 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, countAndFlagsBits);
      uint64_t v12 = v52;
    }

    swift_bridgeObjectRetain(countAndFlagsBits, v52, v53, v54);
    closure #1 in _StringGuts._convertedToSmall()(v55, v12, &v253);
    swift_bridgeObjectRelease(countAndFlagsBits);
    uint64_t v12 = *((void *)&v253 + 1);
    unint64_t v9 = v253;
LABEL_63:
    v56._Swift::UInt64 rawBits = 1LL;
    v57._Swift::UInt64 rawBits = 524289LL;
    v58._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v56, v57, 0x203A747261747328uLL, 0xE800000000000000LL);
    if (v58._rawBits < 0x10000) {
      v58._rawBits |= 3;
    }
    uint64_t v2 = specialized String.init(_:)(v58, v59, 0x203A747261747328uLL, 0xE800000000000000LL);
    Swift::UInt64 v61 = v60;
    swift_bridgeObjectRelease(0xE800000000000000LL);
    if ((v61 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v61);
      goto LABEL_67;
    }

      unint64_t v13 = ~v10 + a2;
      if (v11 < 4)
      {
        if ((_DWORD)v11)
        {
          uint64_t v14 = v13 & ~(-1 << (8 * v11));
          bzero(a1, v11);
          if ((_DWORD)v11 == 3)
          {
            *(_WORD *)a1 = v14;
            a1[2] = BYTE2(v14);
          }

          else if ((_DWORD)v11 == 2)
          {
            *(_WORD *)a1 = v14;
          }

          else
          {
            *a1 = v14;
          }
        }
      }

      else
      {
        bzero(a1, v11);
        *(_DWORD *)a1 = v13;
      }

      __asm { BR              X10 }
    }

    uint64_t v12 = ((a3 - v10 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v12))
    {
      uint64_t v7 = 4u;
      if (v10 >= a2) {
        goto LABEL_20;
      }
      goto LABEL_13;
    }

    if (v12 >= 0x100) {
      uint64_t v7 = 2;
    }
    else {
      uint64_t v7 = v12 > 1;
    }
  }

  if (v10 >= a2) {
    goto LABEL_20;
  }
  goto LABEL_13;
}

    uint64_t result = swift_conformsToProtocolCommon((uint64_t)a4, (uint64_t)&protocol descriptor for Hashable);
    NSStringHashableConformance = result;
    if (!result) {
      return result;
    }
    goto LABEL_14;
  }

  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)a4, a2, a3, (char *)a4);
  uint64_t result = (*(uint64_t (**)(const char *, uint64_t))(*(void *)(*GenericArgs - 8) + 48LL))(a3, 1LL);
  if ((_DWORD)result) {
    goto LABEL_13;
  }
  return result;
}

    uint64_t v14 = (uint64_t *)(v12 + 8);
LABEL_14:
    uint64_t v11 = *v14;
    goto LABEL_15;
  }

  if ((_DWORD)v13 == 515 || (_DWORD)v13 == 516) {
    goto LABEL_13;
  }
LABEL_15:
  uint64_t v27 = v11;
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((uint64_t *)v12, a2, a3, a4);
  Swift::String::Index v29 = v31;
  uint64_t v30 = 0x800000000LL;
  v31[32] = 0LL;
  void v22[2] = a1;
  uint64_t v23 = v22;
  v22[0] = off_189B8B320;
  v22[1] = &v26;
  v20[0] = off_189B8B368;
  v20[1] = &v26;
  void v20[2] = a1;
  Swift::String::Index v21 = v20;
  swift_getTypeByMangledName((const char *)0x3F, a5, a6, (uint64_t)GenericArgs, v22, v20, (uint64_t)v24);
  unint64_t v15 = v21;
  if (v21 == v20)
  {
    unint64_t v16 = 4LL;
    unint64_t v15 = v20;
  }

  else
  {
    if (!v21) {
      goto LABEL_20;
    }
    unint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_20:
  uint64_t v17 = v23;
  if (v23 == v22)
  {
    uint64_t v18 = 4LL;
    uint64_t v17 = v22;
  }

  else
  {
    if (!v23) {
      goto LABEL_25;
    }
    uint64_t v18 = 5LL;
  }

  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_25:
  if (v25 == 1)
  {
    swift::BuilderErrorOr<InProcessReaderWriter::Buffer<swift::TargetMetadata<swift::InProcess> const>>::BuilderErrorOr( a7,  v24);
    if (v25 == 1) {
      ((void (*)(void, uint64_t, void))v24[1])(v24[0], 3LL, 0LL);
    }
  }

  else
  {
    if (v25) {
      uint64_t v19 = 0LL;
    }
    else {
      uint64_t v19 = v24[0];
    }
    *(void *)a7 = v19;
    *(_DWORD *)(a7 + 24) = 0;
  }

  if (v29 != v31) {
    free(v29);
  }
}

          this = swift::Demangle::__runtime::isSpecialized((swift::Demangle::__runtime *)v5, v7);
          if ((this & 1) == 0)
          {
LABEL_59:
            *(_DWORD *)a3 = 0;
            *(void *)(a3 + 8) = 0LL;
            *(_DWORD *)(a3 + 16) = 0;
            *(void *)(a3 + 24) = v5;
            return this;
          }

          continue;
        }

        *(_DWORD *)a3 = 1;
        *(void *)(a3 + 8) = v5;
        unint64_t v13 = 4108;
LABEL_71:
        *(_DWORD *)(a3 + 16) = v13;
        return this;
      case 0x18:
      case 0x3D:
      case 0xA7:
      case 0xDB:
      case 0xEA:
        uint64_t v14 = 2;
LABEL_30:
        this = swift::Demangle::__runtime::NodeFactory::createNode(a2, (__int16)v7);
        unint64_t v16 = (unsigned int *)this;
        uint64_t v17 = *(unsigned __int8 *)(v5 + 18);
        uint64_t v18 = (swift::Demangle::__runtime **)v5;
        if (v17 != 5 || !*(_DWORD *)(v5 + 8))
        {
          *(_DWORD *)a3 = 1;
          *(void *)(a3 + 8) = v5;
          unint64_t v13 = 4069;
          goto LABEL_71;
        }

        uint64_t v18 = *(swift::Demangle::__runtime ***)v5;
LABEL_34:
        uint64_t v19 = *v18;
        if (swift::Demangle::__runtime::isSpecialized(*v18, v15))
        {
          this = ((uint64_t (*)(swift::Demangle::__runtime *__hidden, swift::Demangle::__runtime::Node *, swift::Demangle::__runtime::NodeFactory *))swift::Demangle::__runtime::getUnspecialized)( v19,  a2,  v20);
          if (*(_DWORD *)a3) {
            return this;
          }
          uint64_t v19 = *(swift::Demangle::__runtime **)(a3 + 24);
        }

        this = (uint64_t)swift::Demangle::__runtime::Node::addChild(v16, v19, a2, v21, v22);
        if (v14 < 2)
        {
LABEL_81:
          *(_DWORD *)a3 = 0;
          *(void *)(a3 + 8) = 0LL;
          *(_DWORD *)(a3 + 16) = 0;
          *(void *)(a3 + 24) = v16;
          return this;
        }

        uint64_t v25 = v14;
        uint64_t v26 = 1LL;
        while (1)
        {
          uint64_t v28 = *(unsigned __int8 *)(v5 + 18);
          if ((_DWORD)v28 == 2)
          {
            if (v28 > v26) {
              goto LABEL_46;
            }
          }

          else if ((_DWORD)v28 == 5 && *(unsigned int *)(v5 + 8) > v26)
          {
LABEL_46:
            Swift::String::Index v29 = v28 - 1;
            uint64_t v30 = v5;
            if (v29 >= 2) {
              uint64_t v30 = *(void *)v5;
            }
            uint64_t v27 = *(swift::Demangle::__runtime::Node **)(v30 + 8 * v26);
            goto LABEL_40;
          }

          uint64_t v27 = 0LL;
LABEL_40:
          this = (uint64_t)swift::Demangle::__runtime::Node::addChild(v16, v27, a2, v23, v24);
          if (v25 == ++v26) {
            goto LABEL_81;
          }
        }

      case 0x47:
        uint64_t v31 = *(unsigned __int8 *)(v5 + 18);
        uint64_t v32 = v5;
        if (v31 == 2) {
          goto LABEL_56;
        }
        if (v31 != 5 || *(_DWORD *)(v5 + 8) <= 1u)
        {
          *(_DWORD *)a3 = 1;
          *(void *)(a3 + 8) = v5;
          unint64_t v13 = 4120;
          goto LABEL_71;
        }

        uint64_t v32 = *(void *)v5;
LABEL_56:
        uint64_t v33 = *(swift::Demangle::__runtime **)(v32 + 8);
        this = swift::Demangle::__runtime::isSpecialized(v33, v7);
        if ((this & 1) == 0) {
          goto LABEL_59;
        }
        this = (uint64_t)swift::Demangle::__runtime::getUnspecialized((uint64_t *)&v47, v33, a2, v34);
        if ((_DWORD)v47)
        {
          *(_OWORD *)a3 = v47;
          *(void *)(a3 + 16) = v48;
          return this;
        }

        Node = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 71);
        unint64_t v16 = Node;
        uint64_t v40 = *(unsigned __int8 *)(v5 + 18);
        Swift::UInt64 v41 = (swift::Demangle::__runtime::Node **)v5;
        if (v40 == 5 && *(_DWORD *)(v5 + 8))
        {
          Swift::UInt64 v41 = *(swift::Demangle::__runtime::Node ***)v5;
LABEL_76:
          uint64_t v42 = *v41;
        }

        else
        {
          uint64_t v42 = 0LL;
        }

        swift::Demangle::__runtime::Node::addChild(Node, v42, a2, v38, v39);
        this = (uint64_t)swift::Demangle::__runtime::Node::addChild(v16, v49, a2, v43, v44);
        if (*(_BYTE *)(v5 + 18) == 5 && *(_DWORD *)(v5 + 8) == 3) {
          this = (uint64_t)swift::Demangle::__runtime::Node::addChild( v16,  *(swift::Demangle::__runtime::Node **)(*(void *)v5 + 16LL),  a2,  v45,  v46);
        }
        goto LABEL_81;
      case 0x53:
        uint64_t v35 = *(unsigned __int8 *)(v5 + 18);
        if (v35 == 5 && *(_DWORD *)(v5 + 8))
        {
          Swift::UInt64 v5 = *(void *)v5;
LABEL_64:
          uint64_t v36 = *(void *)v5;
          if (*(_WORD *)(*(void *)v5 + 16LL) == 232)
          {
            *(_DWORD *)a3 = 0;
            *(void *)(a3 + 8) = 0LL;
            *(_DWORD *)(a3 + 16) = 0;
            *(void *)(a3 + 24) = v36;
            return this;
          }

          *(_DWORD *)a3 = 1;
          *(void *)(a3 + 8) = v36;
          unint64_t v13 = 4103;
        }

        else
        {
          *(_DWORD *)a3 = 1;
          *(void *)(a3 + 8) = v5;
          unint64_t v13 = 4101;
        }

        goto LABEL_71;
      default:
        *(_DWORD *)a3 = 5;
        *(void *)(a3 + 8) = v5;
        unint64_t v13 = 4137;
        goto LABEL_71;
    }
  }

  if (v9 != v11)
  {
    BOOL v70 = (_anonymous_namespace_::Remangler *)((char *)this + 12688);
    while (1)
    {
      unint64_t v13 = *(_DWORD ***)v9;
      if (*(_WORD *)(*(void *)v9 + 16LL) == 78)
      {
        uint64_t v14 = *((unsigned __int8 *)v13 + 18);
        unint64_t v15 = *(_DWORD ***)v9;
        if (v14 == 5 && *((_DWORD *)v13 + 2)) {
          break;
        }
      }

    uint64_t v8 = 0LL;
  }

  if (v5 == 5)
  {
    if (!*((_DWORD *)a2 + 2))
    {
      uint64_t v7 = 0LL;
      goto LABEL_13;
    }

    uint64_t v6 = *(swift::Demangle::__runtime::Node ****)a2;
    goto LABEL_5;
  }

  uint64_t v7 = 0LL;
  if (v5 != 2) {
    goto LABEL_8;
  }
LABEL_11:
  uint64_t v8 = (swift::Demangle::__runtime::Node *)*((void *)v4 + 1);
}

  unint64_t v13 = (char **)((char *)this + 12728);
  uint64_t v14 = (void *)*((void *)this + 1593);
  unint64_t v15 = "MXX";
LABEL_22:
  uint64_t result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(v13, v15, 3uLL, v14);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

uint64_t BidirectionalCollection<>.popLast()@<X0>( uint64_t a1@<X0>, void (*a2)(void, void)@<X1>, uint64_t a3@<X8>)
{
  uint64_t v94 = a3;
  uint64_t v92 = a2;
  uint64_t v5 = *((void *)a2 + 1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v85 = (char *)&v74 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v79 = (char *)&v74 - v10;
  uint64_t v91 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  uint64_t v90 = (char *)&v74 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v88 = (char *)&v74 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v86 = (void (**)(char *, uint64_t))((char *)&v74 - v16);
  uint64_t v17 = MEMORY[0x1895F8858](v15);
  uint64_t v89 = (char *)&v74 - v18;
  MEMORY[0x1895F8858](v17);
  uint64_t v20 = (char *)&v74 - v19;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v22 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v21);
  uint64_t v83 = *(void *)(v22 - 8);
  uint64_t v84 = v22;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v80 = (char *)&v74 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  unint64_t v82 = (char *)&v74 - v26;
  uint64_t v27 = *(void *)(a1 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  uint64_t v30 = (char *)&v74 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v28);
  unint64_t v93 = (char *)&v74 - v31;
  unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v5 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v35 = type metadata accessor for Optional(0LL, v32, v33, v34);
  uint64_t v36 = MEMORY[0x1895F8858](v35);
  BOOL v38 = (char *)&v74 - v37;
  unint64_t v96 = v32;
  uint64_t v39 = *(void *)(v32 - 8);
  MEMORY[0x1895F8858](v36);
  Swift::UInt64 v41 = (char *)&v74 - v40;
  uint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 104);
  uint64_t v95 = v3;
  if ((v42(a1, v5) & 1) != 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(v39 + 56))(v94, 1LL, 1LL, v96);
  }
  uint64_t v77 = v20;
  uint64_t v44 = v92;
  BidirectionalCollection.last.getter(a1, (uint64_t)v92, (uint64_t)v38);
  uint64_t v78 = v39;
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v39 + 48))(v38, 1LL, v96) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BidirectionalCollection.swift",  35LL,  2,  0x13BuLL,  0);
  }
  uint64_t v45 = *(void (**)(uint64_t, char *, unint64_t))(v78 + 32);
  uint64_t v75 = v41;
  unint64_t v76 = v45;
  v45((uint64_t)v41, v38, v96);
  Swift::UInt64 v46 = *(void (**)(char *, uint64_t, uint64_t))(v27 + 16);
  uint64_t v47 = v95;
  v46(v93, v95, a1);
  Swift::String::Index v48 = v77;
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(a1, v5);
  v46(v30, v47, a1);
  Swift::UInt64 v49 = (char *)v86;
  (*(void (**)(uint64_t, uint64_t))(v5 + 72))(a1, v5);
  Swift::UInt64 v50 = *(void (**)(uint64_t, uint64_t))(v27 + 8);
  v50(v47, a1);
  uint64_t v51 = v89;
  (*((void (**)(char *, uint64_t, void (*)(uint64_t, uint64_t)))v44 + 4))(v49, a1, v44);
  uint64_t v52 = v91;
  Swift::UInt64 v53 = *(void (**)(char *, unint64_t))(v91 + 8);
  uint64_t v86 = (void (**)(char *, uint64_t))v5;
  Swift::UInt64 v54 = v53;
  v53(v49, AssociatedTypeWitness);
  uint64_t v92 = v50;
  v50((uint64_t)v30, a1);
  uint64_t v55 = v52;
  Swift::String::Index v56 = *(void (**)(char *, char *, unint64_t))(v52 + 16);
  uint64_t v57 = v88;
  v56(v88, v48, AssociatedTypeWitness);
  unint64_t v58 = v90;
  v56(v90, v51, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v57,  v58,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v54(v58, AssociatedTypeWitness);
  v54(v57, AssociatedTypeWitness);
  uint64_t v59 = v51;
  uint64_t v60 = v79;
  Swift::UInt64 v61 = TupleTypeMetadata2;
  uint64_t v62 = &v79[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v63 = *(void (**)(char *, char *, unint64_t))(v55 + 32);
  v63(v79, v77, AssociatedTypeWitness);
  v63(v62, v59, AssociatedTypeWitness);
  uint64_t v64 = v85;
  uint64_t v65 = &v85[*((int *)v61 + 12)];
  v56(v85, v60, AssociatedTypeWitness);
  v56(v65, v62, AssociatedTypeWitness);
  uint64_t v66 = v80;
  v63(v80, v64, AssociatedTypeWitness);
  v54(v65, AssociatedTypeWitness);
  BOOL v67 = &v64[*((int *)v61 + 12)];
  v63(v64, v60, AssociatedTypeWitness);
  v63(v67, v62, AssociatedTypeWitness);
  uint64_t v68 = v84;
  v63(&v66[*(int *)(v84 + 36)], v67, AssociatedTypeWitness);
  v54(v64, AssociatedTypeWitness);
  BOOL v70 = v82;
  uint64_t v69 = v83;
  (*(void (**)(char *, char *, uint64_t))(v83 + 32))(v82, v66, v68);
  uint64_t v71 = v93;
  v86[11](v70, a1);
  (*(void (**)(char *, uint64_t))(v69 + 8))(v70, v68);
  v92((uint64_t)v71, a1);
  uint64_t v72 = v94;
  unint64_t v73 = v96;
  v76(v94, v75, v96);
  return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v78 + 56))(v72, 0LL, 1LL, v73);
}

unint64_t specialized BidirectionalCollection.last.getter(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v2 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v2)
  {
    uint64_t v5 = 7LL;
    if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
      uint64_t v5 = 11LL;
    }
    v6._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(v5 | (v2 << 16)))._rawBits;
    if (!(v6._rawBits >> 14)) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
    }
    if ((a2 & 0x1000000000000000LL) != 0)
    {
      v20._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v6)._rawBits;
      v21._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)(v20)._rawBits;
      Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v21._rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
    }

    else
    {
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        uint64_t v26 = a1;
        uint64_t v27 = a2 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v13 = (char *)&v26 + (v6._rawBits >> 16);
        if ((*(v13 - 1) & 0xC0) == 0x80)
        {
          uint64_t v14 = 0LL;
          uint64_t v15 = v13 - 2;
          do
            int v16 = v15[v14--] & 0xC0;
          while (v16 == 128);
          uint64_t v11 = 1 - v14;
        }

        else
        {
          uint64_t v11 = 1LL;
        }
      }

      else
      {
        if ((a1 & 0x1000000000000000LL) != 0)
        {
          id v7 = (id)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }

        else
        {
          Swift::UInt64 rawBits = v6._rawBits;
          id v7 = _StringObject.sharedUTF8.getter(a1, a2);
          v6._Swift::UInt64 rawBits = rawBits;
        }

        uint64_t v8 = 0LL;
        Swift::UInt64 v9 = (Swift::UInt64)v7 + (v6._rawBits >> 16) - 1;
        do
          int v10 = *(_BYTE *)(v9 + v8--) & 0xC0;
        while (v10 == 128);
        uint64_t v11 = -v8;
      }

      v17._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)((v6._rawBits - (v11 << 16)) & 0xFFFFFFFFFFFF0000LL | 5))._rawBits >> 16;
      if ((a2 & 0x2000000000000000LL) != 0)
      {
        uint64_t v26 = a1;
        uint64_t v27 = a2 & 0xFFFFFFFFFFFFFFLL;
        Swift::UInt32 value = *((unsigned __int8 *)&v26 + v17._rawBits);
        if (*((char *)&v26 + v17._rawBits) < 0) {
          __asm { BR              X11 }
        }
      }

      else
      {
        if ((a1 & 0x1000000000000000LL) != 0)
        {
          uint64_t v18 = (a2 & 0xFFFFFFFFFFFFFFFLL) + 32;
        }

        else
        {
          uint64_t v22 = a2;
          Swift::UInt64 v23 = v17._rawBits;
          id v24 = _StringObject.sharedUTF8.getter(a1, v22);
          v17._Swift::UInt64 rawBits = v23;
          uint64_t v18 = (uint64_t)v24;
        }

        Swift::UInt32 value = *(unsigned __int8 *)(v18 + v17._rawBits);
        if (*(char *)(v18 + v17._rawBits) < 0) {
          __asm { BR              X12 }
        }
      }
    }
  }

  else
  {
    Swift::UInt32 value = 0;
  }

  LOBYTE(v26) = v2 == 0;
  return value | ((unint64_t)(v2 == 0) << 32);
}

unint64_t specialized BidirectionalCollection.last.getter( unint64_t a1, Swift::String::Index a2, uint64_t a3, uint64_t a4)
{
  Swift::UInt64 v4 = a1 >> 14;
  Swift::UInt64 v5 = a2._rawBits >> 14;
  if (a1 >> 14 == a2._rawBits >> 14)
  {
    Swift::UInt32 value = 0;
    goto LABEL_3;
  }

  v10._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(a2)._rawBits;
  if (!(v10._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "String index is out of bounds",  29LL,  2,  "Swift/StringUnicodeScalarView.swift",  35LL,  2,  0x84uLL,  0);
  }
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v10)._rawBits;
  }

  else
  {
    if ((a4 & 0x2000000000000000LL) != 0)
    {
      uint64_t v31 = a3;
      uint64_t v32 = a4 & 0xFFFFFFFFFFFFFFLL;
      int v16 = (char *)&v31 + (v10._rawBits >> 16);
      if ((*(v16 - 1) & 0xC0) == 0x80)
      {
        uint64_t v17 = 0LL;
        uint64_t v18 = v16 - 2;
        do
          int v19 = v18[v17--] & 0xC0;
        while (v19 == 128);
        uint64_t v15 = 1 - v17;
      }

      else
      {
        uint64_t v15 = 1LL;
      }
    }

    else
    {
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        id v11 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }

      else
      {
        Swift::UInt64 v30 = v10._rawBits;
        id v11 = _StringObject.sharedUTF8.getter(a3, a4);
        v10._Swift::UInt64 rawBits = v30;
      }

      uint64_t v12 = 0LL;
      Swift::UInt64 v13 = (Swift::UInt64)v11 + (v10._rawBits >> 16) - 1;
      do
        int v14 = *(_BYTE *)(v13 + v12--) & 0xC0;
      while (v14 == 128);
      uint64_t v15 = -v12;
    }

    Swift::UInt64 rawBits = (v10._rawBits - (v15 << 16)) & 0xFFFFFFFFFFFF0000LL | 5;
  }

  char v21 = (a4 & 0x1000000000000000LL) == 0 || (a3 & 0x800000000000000LL) != 0;
  uint64_t v22 = 4LL << v21;
  if ((rawBits & 0xC) == v22 || (rawBits & 1) == 0)
  {
    if ((rawBits & 0xC) == v22) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    }
    if (rawBits >> 14 >= v4 && rawBits >> 14 < v5)
    {
      if ((rawBits & 1) == 0) {
        Swift::UInt64 rawBits = _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF2LL | 1;
      }
      goto LABEL_34;
    }

    unint64_t v26 = 43LL;
LABEL_42:
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Substring index is out of bounds",  32LL,  2,  "Swift/StringIndexValidation.swift",  33LL,  2,  v26,  0);
  }

  if (rawBits >> 14 < v4 || rawBits >> 14 >= v5)
  {
    unint64_t v26 = 143LL;
    goto LABEL_42;
  }

LABEL_34:
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    Swift::UInt32 value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000LL))._0._value;
  }

  else
  {
    Swift::UInt64 v24 = rawBits >> 16;
    if ((a4 & 0x2000000000000000LL) != 0)
    {
      uint64_t v31 = a3;
      uint64_t v32 = a4 & 0xFFFFFFFFFFFFFFLL;
      Swift::UInt32 value = *((unsigned __int8 *)&v31 + v24);
      if (*((char *)&v31 + v24) < 0) {
        __asm { BR              X11 }
      }
    }

    else
    {
      if ((a3 & 0x1000000000000000LL) != 0)
      {
        uint64_t v25 = (a4 & 0xFFFFFFFFFFFFFFFLL) + 32;
      }

      else
      {
        uint64_t v27 = a4;
        Swift::UInt64 v28 = rawBits >> 16;
        id v29 = _StringObject.sharedUTF8.getter(a3, v27);
        Swift::UInt64 v24 = v28;
        uint64_t v25 = (uint64_t)v29;
      }

      Swift::UInt32 value = *(unsigned __int8 *)(v25 + v24);
      if (*(char *)(v25 + v24) < 0) {
        __asm { BR              X12 }
      }
    }
  }

  v232 = v10 & 0xFFFFFFFFFFFFLL;
  if (v52) {
    Swift::UInt64 v4 = HIBYTE(*((void *)&v10 + 1)) & 0xFLL;
  }
  else {
    Swift::UInt64 v4 = v10 & 0xFFFFFFFFFFFFLL;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v10 + 1), 2LL, v45, v46);
  v234 = v10;
  if ((*((void *)&v10 + 1) & 0x1000000000000000LL) != 0) {
    goto LABEL_206;
  }
  swift_bridgeObjectRetain_n(*((uint64_t *)&v10 + 1), 4LL, v55, v56);
  uint64_t v57 = v4;
  if ((v43 & 0x1000000000000000LL) == 0) {
    goto LABEL_39;
  }
LABEL_209:
  v221 = String.UTF8View._foreignCount()();
  unint64_t v58 = v221 + v57;
  if (__OFADD__(v221, v57)) {
    goto LABEL_211;
  }
LABEL_40:
  if ((v17 & ~v43 & 0x2000000000000000LL) != 0 && swift_isUniquelyReferenced_nonNull_native(v43 & 0xFFFFFFFFFFFFFFFLL))
  {
    uint64_t v59 = *((void *)&v239 + 1);
    uint64_t v60 = _StringGuts.nativeUnusedCapacity.getter(v239, *((uint64_t *)&v239 + 1));
    if ((v61 & 1) != 0) {
      goto LABEL_218;
    }
    if (v58 <= 15 && ((v59 & 0x2000000000000000LL) != 0 || v60 < v57)) {
      goto LABEL_52;
    }
  }

  else if (v58 <= 15)
  {
    uint64_t v59 = *((void *)&v239 + 1);
LABEL_52:
    swift_bridgeObjectRelease_n(v12, 5LL);
    BOOL v67 = v239;
    swift_bridgeObjectRetain(v59, v68, v69, v70);
    uint64_t v71 = _StringGuts._convertedToSmall()(v67, v59);
    unint64_t v73 = v72;
    swift_bridgeObjectRelease(v59);
    v74._Swift::UInt64 rawBits = (v4 << 16) | 1;
    v75._Swift::UInt64 rawBits = 1LL;
    unint64_t v76 = v234;
    v77._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v75, v74, v234, v12);
    if (v77._rawBits < 0x10000) {
      v77._rawBits |= 3;
    }
    uint64_t v79 = specialized String.init(_:)(v77, v78, v76, v12);
    uint64_t v81 = v80;
    swift_bridgeObjectRelease(v12);
    unint64_t v82 = _StringGuts._convertedToSmall()(v79, v81);
    uint64_t v84 = v83;
    swift_bridgeObjectRelease(v81);
    uint64_t v85 = specialized _SmallString.init(_:appending:)(v71, v73, v82, v84);
    if ((v87 & 1) != 0) {
      goto LABEL_217;
    }
    uint64_t v88 = v85;
    uint64_t v89 = v86;
    swift_bridgeObjectRelease(v59);
    *(void *)&v239 = v88;
    *((void *)&v239 + 1) = v89;
    goto LABEL_57;
  }

  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v58, v57);
  swift_bridgeObjectRelease_n(v12, 4LL);
  if ((v12 & 0x1000000000000000LL) != 0)
  {
    swift_bridgeObjectRelease(v12);
    _StringGuts._foreignAppendInPlace(_:)(v234, v12, 0LL, v4);
    swift_bridgeObjectRelease(v12);
LABEL_57:
    uint64_t v43 = v228;
    Swift::UInt64 v4 = v233;
    goto LABEL_77;
  }

  uint64_t v43 = v228;
  unint64_t v58 = v234;
  if (v52)
  {
    swift_bridgeObjectRelease_n(v12, 2LL);
    v236 = v58;
    v237 = v12 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v62 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v53, (uint64_t)&v236, v53);
    _StringGuts.appendInPlace(_:isASCII:)(v62, v63, (v12 & 0x4000000000000000LL) != 0);
    Swift::UInt64 v4 = v233;
  }

  else
  {
    if ((v234 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v12);
      uint64_t v102 = (id)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v103 = v232;
      Swift::UInt64 v4 = v233;
      uint64_t v104 = v232;
    }

    else
    {
LABEL_215:
      uint64_t v102 = _StringObject.sharedUTF8.getter(v58, v12);
      uint64_t v104 = v223;
      swift_bridgeObjectRelease(v12);
      if (v104 < v232) {
        _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x745uLL,  0);
      }
      uint64_t v12 = v226;
      uint64_t v43 = v228;
      uint64_t v103 = v232;
      Swift::UInt64 v4 = v233;
    }

    uint64_t v105 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0LL, v103, (uint64_t)v102, v104);
    _StringGuts.appendInPlace(_:isASCII:)(v105, v106, v58 < 0);
    swift_bridgeObjectRelease(v12);
  }

  v624 = -1074LL;
  v184 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
  __int128 v185 = lazy protocol witness table accessor for type Int and conformance Int(v167, v168, v169);
  v184(&v624, &type metadata for Int, v185, v69, v67);
  LOBYTE(v184) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32) + 8LL)
                                                                               + 16LL))( v120,  v123,  v69);
  ((void (*)(char *, unint64_t *))v164)(v123, v69);
  ((void (*)(char *, unint64_t *))v164)(v120, v69);
LABEL_71:
  v589 = (void (*)(char *, unint64_t *))v164;
  v230 = v610;
  ((void (*)(uint64_t *, uint64_t))v596)(&qword_18180BE70, 512LL);
  ((void (*)(uint64_t (*)(void), unint64_t *, const char *))v590)(v230, v69, v611);
  v231 = v593;
  v601(v125, v123, v69, v161);
  ((void (*)(char *, unint64_t *))v164)(v123, v69);
  v232 = (uint64_t (*)(unint64_t *, unint64_t))v617;
  if ((((uint64_t (*)(unint64_t *, unint64_t))v617)(v69, v67) & 1) == 0)
  {
    v238 = v232(v69, v67);
    v233 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
    v236 = (uint64_t)v603;
    v237 = v620;
    if ((v238 & 1) != 0)
    {
      if (v233 > 64)
      {
LABEL_76:
        v624 = -1074LL;
        v239 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
        v240 = lazy protocol witness table accessor for type Int and conformance Int(v233, v234, v235);
        v239(&v624, &type metadata for Int, v240, v69, v67);
        LOBYTE(v239) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 16)
                                                                                                 + 8LL)
                                                                                     + 8LL))( v231,  v123,  v69);
        v241 = v589;
        v589(v123, v69);
        v241(v231, v69);
        goto LABEL_86;
      }

      v243 = v610;
      ((void (*)(uint64_t *, uint64_t))v596)(&qword_18180BE68, 256LL);
      ((void (*)(uint64_t (*)(void), unint64_t *, const char *))v590)(v243, v69, v611);
      LODWORD(v601) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                                + 8LL)
                                                                                    + 32LL))( v231,  v123,  v69);
      v244 = v589;
      v589(v123, v69);
      v251 = v568;
      (*(void (**)(char *, char *, unint64_t *))(v237 + 32))(v568, v231, v69);
      if ((v601 & 1) != 0)
      {
        v245 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
        v244(v251, v69);
        if (v245 != -1074) {
          goto LABEL_94;
        }
LABEL_86:
        v589(v125, v69);
        v246 = v621;
        v247 = (*(uint64_t (**)(uint64_t))(v618 + 136))(v621);
        v248 = (*((uint64_t (**)(uint64_t))v616 + 21))(v246);
        uint64_t result = 0LL;
        v249 = -0.0;
        if ((v248 & 1) == 0) {
          v249 = 0.0;
        }
        *(void *)&v250 = 0x8000000000000001LL;
        if ((v248 & 1) == 0) {
          v250 = COERCE_DOUBLE(1LL);
        }
        if (v247) {
          v249 = v250;
        }
        goto LABEL_274;
      }
    }

    else
    {
      if (v233 < 64) {
        goto LABEL_82;
      }
      v251 = v567;
      (*(void (**)(char *, char *, unint64_t *))(v620 + 32))(v567, v231, v69);
    }

    v589(v251, v69);
    goto LABEL_94;
  }

  v233 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
  v236 = (uint64_t)v603;
  v237 = v620;
  if (v233 >= 64) {
    goto LABEL_76;
  }
LABEL_82:
  v242 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
  v589(v231, v69);
  if (v242 == -1074) {
    goto LABEL_86;
  }
LABEL_94:
  v252 = v605;
  (*(void (**)(uint64_t *, char *, unint64_t *))(v237 + 32))(v605, v125, v69);
  v253 = v232(v69, v67);
  Swift::String::Index v171 = *(char **)(v237 + 16);
  v254 = v592;
  ((void (*)(char *, uint64_t *, unint64_t *))v171)(v592, v252, v69);
  if ((v253 & 1) == 0)
  {
    v202 = v589;
    v589(v254, v69);
    char v136 = v591;
    goto LABEL_131;
  }

  v255 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
  v202 = v589;
  v589(v254, v69);
  char v136 = v591;
  if (v255 <= 64) {
    goto LABEL_131;
  }
  v130 = v577;
  ((void (*)(char *, uint64_t *, unint64_t *))v171)(v577, v605, v69);
  v624 = 0x8000000000000000LL;
  v256 = (uint64_t (*)(unint64_t *, unint64_t))v617;
  if ((((uint64_t (*)(unint64_t *, unint64_t))v617)(v69, v67) & 1) != 0)
  {
    v257 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
    if (v257 < 64) {
      goto LABEL_120;
    }
    goto LABEL_102;
  }

  v260 = v256(v69, v67);
  v257 = ((uint64_t (*)(unint64_t *, unint64_t))v619)(v69, v67);
  if ((v260 & 1) != 0)
  {
    if (v257 <= 64)
    {
LABEL_127:
      v292 = v610;
      ((void (*)(uint64_t *, uint64_t))v596)(&qword_18180BE68, 256LL);
      ((void (*)(uint64_t (*)(void), unint64_t *, const char *))v590)(v292, v69, v611);
      LOBYTE(v292) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(void *)(*(void *)(v67 + 32)
                                                                                               + 8LL)
                                                                                   + 16LL))( v130,  v123,  v69);
      v202(v123, v69);
      v293 = v560;
      ((void (*)(char *, char *, unint64_t *))v171)(v560, v130, v69);
      if ((v292 & 1) != 0)
      {
        v202(v293, v69);
        goto LABEL_281;
      }

      v620 = v624;
      v287 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v69, v67);
      v202(v293, v69);
      v288 = v620;
      goto LABEL_129;
    }

  v660 = -149LL;
  uint64_t v192 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
  __int128 v193 = lazy protocol witness table accessor for type Int and conformance Int(v174, v175, v176);
  v192(&v660, &type metadata for Int, v193, v69, v67);
  LOBYTE(v192) = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                + 16LL))( v172,  v169,  v69);
  ((void (*)(float *, unint64_t *))v149)(v169, v69);
  ((void (*)(char *, unint64_t *))v149)(v172, v69);
LABEL_81:
  v256 = v647;
  v632(&qword_18180BE70, 512LL);
  ((void (*)(unsigned int (*)(void), unint64_t *, const char *))v625)(v256, v69, v648);
  v257 = v624;
  v639 = (char *)v130;
  v171(v130, v169, v69, v170);
  ((void (*)(float *, unint64_t *))v149)(v169, v69);
  v258 = v656;
  if ((((uint64_t (*)(unint64_t *, char *))v656)(v69, v67) & 1) != 0)
  {
    __int128 v180 = (uint64_t (*)(unint64_t *, char *))v634;
    v259 = ((uint64_t (*)(unint64_t *, char *))v634)(v69, v67);
    v262 = v628;
    if (v259 < 64)
    {
LABEL_92:
      v266 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
      ((void (*)(char *, unint64_t *))v149)(v257, v69);
      if (v266 == -149) {
        goto LABEL_96;
      }
LABEL_111:
      v278 = v655;
      v279 = v629;
      (*(void (**)(char *, char *, unint64_t *))(v655 + 32))(v629, v639, v69);
      v280 = ((uint64_t (*)(unint64_t *, char *))v656)(v69, v67);
      v203 = *(void *)(v278 + 16);
      ((void (*)(char *, char *, unint64_t *))v203)(v262, v279, v69);
      if ((v280 & 1) != 0)
      {
        v281 = v180(v69, v67);
        ((void (*)(char *, unint64_t *))v149)(v262, v69);
        if (v281 <= 64) {
          goto LABEL_138;
        }
        v282 = v612;
        ((void (*)(char *, char *, unint64_t *))v203)(v612, v279, v69);
        v660 = 0x8000000000000000LL;
        v283 = v656;
        if ((((uint64_t (*)(unint64_t *, char *))v656)(v69, v67) & 1) != 0)
        {
          v284 = v180(v69, v67);
          if (v284 < 64)
          {
            ((void (*)(float *, char *, unint64_t *))v203)(v169, v282, v69);
            v287 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
            v288 = v282;
            goto LABEL_126;
          }

          v288 = v282;
          v297 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
          v298 = lazy protocol witness table accessor for type Int and conformance Int(v284, v285, v286);
          v297(&v660, &type metadata for Int, v298, v69, v67);
          v296 = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                + 16LL))( v288,  v169,  v69);
LABEL_121:
          v299 = v296;
          ((void (*)(float *, unint64_t *))v149)(v169, v69);
          if ((v299 & 1) != 0) {
            goto LABEL_288;
          }
          goto LABEL_136;
        }

        v290 = ((uint64_t (*)(unint64_t *, char *))v283)(v69, v67);
        v291 = v180(v69, v67);
        if ((v290 & 1) != 0)
        {
          if (v291 <= 64) {
            goto LABEL_134;
          }
          v294 = (void (*)(int64_t *, ValueMetadata *, unint64_t, unint64_t *, char *))*((void *)v67 + 12);
          v295 = lazy protocol witness table accessor for type Int and conformance Int(v291, v292, v293);
          v294(&v660, &type metadata for Int, v295, v69, v67);
          v288 = v612;
          v296 = (*(uint64_t (**)(char *, float *, unint64_t *))(*(void *)(*((void *)v67 + 4) + 8LL)
                                                                                + 16LL))( v612,  v169,  v69);
          goto LABEL_121;
        }

        if (v291 < 64)
        {
          v288 = v612;
          ((void (*)(float *, char *, unint64_t *))v203)(v169, v612, v69);
          v287 = (*((uint64_t (**)(unint64_t *, char *))v67 + 15))(v69, v67);
LABEL_126:
          v300 = v287;
          ((void (*)(float *, unint64_t *))v149)(v169, v69);
          if (v300 < v660) {
            goto LABEL_288;
          }
LABEL_136:
          v289 = v288;
          goto LABEL_137;
        }

        v289 = v612;
      }

      else
      {
        v289 = v262;
      }

        unint64_t v26 = _StringGuts.nativeCapacity.getter(v7, v8);
        if ((v27 & 1) != 0) {
          Swift::UInt64 v28 = 0LL;
        }
        else {
          Swift::UInt64 v28 = v26;
        }
        if (v28 + 0x4000000000000000LL < 0) {
          goto LABEL_249;
        }
        id v29 = 2 * v28;
        if (v29 > v11) {
          id v11 = v29;
        }
      }

      else if (!v25)
      {
        goto LABEL_34;
      }

      _StringGuts.grow(_:)(v11);
      goto LABEL_41;
    }
  }

  else
  {
    if (v11 > 15) {
      goto LABEL_23;
    }
    if ((v8 & 0x2000000000000000LL) == 0) {
      goto LABEL_48;
    }
  }

  swift_bridgeObjectRelease_n((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL, 5LL);
  for (uint64_t i = v8; ; uint64_t i = v193)
  {
LABEL_57:
    v39._Swift::UInt64 rawBits = (v15 << 16) | 1;
    v40._Swift::UInt64 rawBits = 1LL;
    v41._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)( v40,  v39,  0xD000000000000011LL,  (unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    if (v41._rawBits < 0x10000) {
      v41._rawBits |= 3;
    }
    uint64_t v43 = specialized String.init(_:)( v41,  v42,  0xD000000000000011LL,  (unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    uint64_t v45 = v44;
    swift_bridgeObjectRelease((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    if ((v45 & 0x2000000000000000LL) != 0)
    {
      swift_bridgeObjectRelease(v45);
    }

    else if ((v45 & 0x1000000000000000LL) != 0)
    {
      uint64_t v43 = _StringGuts._foreignConvertedToSmall()(v43, v45);
      v200 = v199;
      swift_bridgeObjectRelease(v45);
      uint64_t v45 = v200;
    }

    else
    {
      if ((v43 & 0x1000000000000000LL) != 0)
      {
        uint64_t v191 = (unsigned __int8 *)((v45 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v192 = v43 & 0xFFFFFFFFFFFFLL;
      }

      else
      {
        uint64_t v191 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v43, v45);
      }

      closure #1 in _StringGuts._convertedToSmall()(v191, v192, &v202);
      swift_bridgeObjectRelease(v45);
      uint64_t v45 = *((void *)&v202 + 1);
      uint64_t v43 = v202;
    }

    Swift::UInt64 v46 = HIBYTE(i) & 0xF;
    uint64_t v47 = HIBYTE(v45) & 0xF;
    uint64_t v1 = v47 + v46;
    if (v47)
    {
      Swift::String::Index v48 = 0;
      Swift::UInt64 v49 = 0LL;
      do
      {
        Swift::UInt64 v50 = v46 + v49;
        uint64_t v51 = v49 + 1;
        if (v49 >= 8) {
          uint64_t v52 = v45;
        }
        else {
          uint64_t v52 = v43;
        }
        Swift::UInt64 v53 = v52 >> (v48 & 0x38);
        Swift::UInt64 v54 = (8 * v46 + v48) & 0x38;
        uint64_t v55 = (-255LL << v54) - 1;
        Swift::String::Index v56 = (unint64_t)v53 << v54;
        uint64_t v57 = v56 | v55 & i;
        unint64_t v58 = v56 | v55 & v7;
        if (v50 < 8) {
          id v7 = v58;
        }
        else {
          uint64_t i = v57;
        }
        v48 += 8;
        Swift::UInt64 v49 = v51;
      }

      while (v47 != v51);
    }

    swift_bridgeObjectRelease(v8);
    swift_bridgeObjectRelease((unint64_t)(v12 + 0x7FFFFFFFFFFFFFE0LL) | 0x8000000000000000LL);
    uint64_t v59 = 0xA000000000000000LL;
    if (!(v7 & 0x8080808080808080LL | i & 0x80808080808080LL)) {
      uint64_t v59 = 0xE000000000000000LL;
    }
    uint64_t v60 = v59 & 0xFF00000000000000LL | (v1 << 56) | i & 0xFFFFFFFFFFFFFFLL;
LABEL_85:
    v203 = v7;
    v204 = v60;
LABEL_86:
    unint64_t v73 = _uint64ToString(_:radix:uppercase:)(a1, 16LL, 0);
    uint64_t countAndFlagsBits = v73._countAndFlagsBits;
    unint64_t object = v73._object;
    if (((uint64_t)v73._object & 0x1000000000000000LL) != 0)
    {
      uint64_t v77 = String.UTF16View._foreignCount()();
    }

    else
    {
      unint64_t v76 = ((unint64_t)v73._object >> 56) & 0xF;
      uint64_t v77 = String.UTF16View._nativeGetOffset(for:)((Swift::String::Index)((v76 << 16) | 7));
    }

    uint64_t v78 = 16 - v77;
    if (__OFSUB__(16LL, v77))
    {
      __break(1u);
LABEL_220:
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }

    if (v78 < 0) {
      goto LABEL_220;
    }
    if (v78)
    {
      uint64_t v79 = v77 - 16;
      do
      {
        uint64_t countAndFlagsBits = specialized static String.+ infix(_:_:)( 0x30uLL,  0xE100000000000000LL,  countAndFlagsBits,  (unint64_t)object);
        uint64_t v81 = v80;
        swift_bridgeObjectRelease(0xE100000000000000LL);
        swift_bridgeObjectRelease((uint64_t)object);
        unint64_t object = v81;
      }

      while (!__CFADD__(v79++, 1LL));
    }

    else
    {
      uint64_t v81 = v73._object;
    }

    id v7 = specialized static String.+ infix(_:_:)( 0x7830uLL,  0xE200000000000000LL,  countAndFlagsBits,  (unint64_t)v81);
    a1 = v83;
    swift_bridgeObjectRelease(0xE200000000000000LL);
    swift_bridgeObjectRelease((uint64_t)v81);
    uint64_t v8 = v203;
    id v11 = v204;
    uint64_t v86 = HIBYTE(v204) & 0xF;
    if ((v204 & 0x2000000000000000LL) != 0) {
      uint64_t v87 = HIBYTE(v204) & 0xF;
    }
    else {
      uint64_t v87 = v203 & 0xFFFFFFFFFFFFLL;
    }
    if (!v87 && (v203 & ~v204 & 0x2000000000000000LL) == 0)
    {
      swift_bridgeObjectRelease(v204);
      v203 = v7;
      v204 = a1;
      goto LABEL_187;
    }

    uint64_t v15 = a1 & 0x2000000000000000LL;
    uint64_t i = HIBYTE(a1) & 0xF;
    if ((v204 & 0x2000000000000000LL) != 0 && v15)
    {
      uint64_t v88 = v86 + i;
      if (v86 + i <= 0xF)
      {
        if (i)
        {
          uint64_t v106 = 0;
          uint64_t v107 = 0LL;
          uint64_t v1 = v204;
          do
          {
            uint64_t v108 = v86 + v107;
            unint64_t v109 = v107 + 1;
            if (v107 >= 8) {
              unint64_t v110 = a1;
            }
            else {
              unint64_t v110 = v7;
            }
            unint64_t v111 = v110 >> (v106 & 0x38);
            uint64_t v112 = (8 * v86 + v106) & 0x38;
            uint64_t v113 = (-255LL << v112) - 1;
            unint64_t v114 = (unint64_t)v111 << v112;
            uint64_t v115 = v114 | v113 & v1;
            uint64_t v116 = v114 | v113 & v8;
            if (v108 < 8) {
              uint64_t v8 = v116;
            }
            else {
              uint64_t v1 = v115;
            }
            v106 += 8;
            uint64_t v107 = v109;
          }

          while (i != v109);
        }

        else
        {
          uint64_t v1 = v204;
        }

        swift_bridgeObjectRelease(v204);
        swift_bridgeObjectRelease(a1);
        unint64_t v148 = 0xA000000000000000LL;
        if (!(v8 & 0x8080808080808080LL | v1 & 0x80808080808080LL)) {
          unint64_t v148 = 0xE000000000000000LL;
        }
        v203 = v8;
        v204 = v148 & 0xFF00000000000000LL | (v88 << 56) | v1 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_187;
      }

      uint64_t v15 = 1LL;
    }

    uint64_t v1 = v15 ? HIBYTE(a1) & 0xF : v7 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a1, 2LL, v84, v85);
    if ((a1 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(a1, 5LL, v89, v90);
      v176._Swift::UInt64 rawBits = 1LL;
      v177._Swift::UInt64 rawBits = (v1 << 16) | 1;
      v178._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v176, v177, v7, a1);
      if (v178._rawBits < 0x10000) {
        v178._rawBits |= 3;
      }
      uint64_t v12 = (const char *)specialized Collection.count.getter(v178, v179, v7, a1);
      swift_bridgeObjectRelease(a1);
      if ((v11 & 0x1000000000000000LL) == 0)
      {
LABEL_112:
        uint64_t v18 = __OFADD__(v87, v12);
        int v14 = (uint64_t)&v12[v87];
        if (v18) {
          goto LABEL_226;
        }
        goto LABEL_113;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(a1, 4LL, v89, v90);
      uint64_t v12 = (const char *)v1;
      if ((v11 & 0x1000000000000000LL) == 0) {
        goto LABEL_112;
      }
    }

    __int128 v180 = String.UTF8View._foreignCount()();
    int v14 = (uint64_t)&v12[v180];
    if (__OFADD__(v180, v12))
    {
LABEL_226:
      __break(1u);
LABEL_227:
      swift_bridgeObjectRetain_n(v14, 5LL, v16, v17);
      v181._Swift::UInt64 rawBits = 1LL;
      v182._Swift::UInt64 rawBits = (v15 << 16) | 1;
      v183._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v181, v182, 0xD000000000000011LL, v14);
      if (v183._rawBits < 0x10000) {
        v183._rawBits |= 3;
      }
      uint64_t v1 = specialized Collection.count.getter(v183, v184, 0xD000000000000011LL, v14);
      swift_bridgeObjectRelease(v14);
      if ((v8 & 0x1000000000000000LL) != 0)
      {
LABEL_230:
        __int128 v185 = String.UTF8View._foreignCount()();
        id v11 = v185 + v1;
        if (!__OFADD__(v185, v1)) {
          goto LABEL_15;
        }
LABEL_232:
        __break(1u);
        goto LABEL_233;
      }

      goto LABEL_14;
    }

        Swift::UInt64 v30 = (v46 - 1) & v46;
        uint64_t v39 = __clz(__rbit64(v46)) + (v45 << 6);
        uint64_t v69 = v45;
      }

      (*(void (**)(char *, unint64_t, char *))(v5 + 16))( v22,  *(void *)(v3 + 48) + *(void *)(v5 + 72) * v39,  v4);
      goto LABEL_36;
    }

    uint64_t v40 = *(void *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8);
    if (v40 < 0) {
      goto LABEL_41;
    }
    if (v40 == *(void *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0xE0)) {
      break;
    }
LABEL_20:
    uint64_t v42 = *(void *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0x18);
    if (!v42) {
      goto LABEL_47;
    }
    uint64_t v43 = (void **)(v42 + 8 * v40);
    uint64_t v44 = *v43;
    *(void *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = v40 + 1;
    swift_unknownObjectRetain(v44, v18, v19, v20);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v4, (uint64_t *)v4))
    {
      uint64_t v71 = v44;
      swift_dynamicCast(v22, (uint64_t *)&v71, v64, v4, 7uLL);
LABEL_36:
      Swift::String::Index v48 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v5 + 56);
      goto LABEL_37;
    }

    Swift::String::Index v48 = *(void (**)(uint64_t *, uint64_t, uint64_t, char *))(v5 + 56);
    v48(v58, 1LL, 1LL, v4);
    _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v44, (uint64_t)v4, v58);
    swift_unknownObjectRelease(v44);
    Swift::UInt64 v54 = v67;
    (*(void (**)(uint64_t, uint64_t *, uint64_t))(v68 + 16))(v57, v58, v67);
    if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(v5 + 48))(v57, 1LL, v4) == 1) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BridgeObjectiveC.swift",  28LL,  2,  0xFCuLL,  0);
    }
    (*(void (**)(uint64_t *, uint64_t))(v68 + 8))(v58, v54);
    (*(void (**)(char *, uint64_t, char *))(v5 + 32))(v22, v57, v4);
LABEL_37:
    v48((uint64_t *)v22, 0LL, 1LL, v4);
    (*(void (**)(id *, char *, char *))(v5 + 32))(v9, v22, v4);
    Swift::UInt64 v49 = *(void *)(v70 + 24);
    Swift::UInt64 v50 = Set.contains(_:)(v9, *v2, (uint64_t *)v4, v49);
    uint64_t v52 = type metadata accessor for Set._Variant(0LL, (uint64_t)v4, v49, v51);
    if ((v50 & 1) != 0)
    {
      Swift::UInt64 v53 = v65;
      Set._Variant.remove(_:)(v9, v52, v65);
      (*(void (**)(uint64_t, uint64_t))(v68 + 8))(v53, v67);
      uint64_t v37 = v9;
    }

    else
    {
      uint64_t v36 = v66;
      Set._Variant.insert(_:)(v66, v9, v52);
      uint64_t v37 = v36;
    }

    (*(void (**)(void *, char *))(v5 + 8))(v37, v4);
  }

  Swift::UInt64 v41 = objc_msgSend( *(id *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0xD0),  sel_countByEnumeratingWithState_objects_count_,  v61,  v60,  16);
  *(void *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0xE_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = v41;
  if (v41)
  {
    uint64_t v40 = 0LL;
    *(void *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = 0LL;
    goto LABEL_20;
  }

  *(void *)((v3 & 0x7FFFFFFFFFFFFFFFLL) + 0xD8) = -1LL;
LABEL_41:
  (*(void (**)(char *, uint64_t, uint64_t, char *))(v5 + 56))(v22, 1LL, 1LL, v4);
  return outlined consume of [A : B].Iterator._Variant<A, B>(v3);
}

        uint64_t v18 = 1861LL;
        goto LABEL_38;
      }
    }

    uint64_t v18 = 1860LL;
LABEL_38:
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  v18,  0);
  }

  uint64_t countAndFlagsBits = 0LL;
  unint64_t object = 0LL;
LABEL_41:
  result.value._unint64_t object = object;
  result.value._uint64_t countAndFlagsBits = countAndFlagsBits;
  return result;
}

      if ((~v12 & 0x6000000000000000LL) != 0
        || (object & 0x2000000000000000LL) == 0
        || (object & 0x4000000000000000LL) == 0)
      {
        Swift::UInt64 v23 = _stringCompareInternal(_:_:expecting:)(v11, v12, countAndFlagsBits, object, 0);
        swift_bridgeObjectRelease(v12);
        if ((v23 & 1) != 0) {
          return v5;
        }
      }

      else
      {
        swift_bridgeObjectRelease(v12);
      }

      ++v5;
    }

    while (v5 != v2);
  }

  return -1LL;
}

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
    }
  }

  v22[0] = v4;
  v22[1] = v3 & 0xFFFFFFFFFFFFFFLL;
  if (rawBits < 0x10000) {
    goto LABEL_34;
  }
  int v14 = 0LL;
  while (1)
  {
    if (v12 > v7) {
      goto LABEL_39;
    }
    if ((*((_BYTE *)v22 + v12 + v14 - 1) & 0xC0) != 0x80) {
      break;
    }
    --v14;
    if (!(v12 + v14)) {
      goto LABEL_34;
    }
  }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
    }
  }

  v21[0] = v4;
  v21[1] = v3 & 0xFFFFFFFFFFFFFFLL;
  if (before._rawBits < 0x10000) {
    goto LABEL_34;
  }
  Swift::UInt64 v13 = 0LL;
  while (1)
  {
    if (v11 > v6) {
      goto LABEL_38;
    }
    if ((*((_BYTE *)v21 + v11 + v13 - 1) & 0xC0) != 0x80) {
      break;
    }
    --v13;
    if (!(v11 + v13)) {
      goto LABEL_34;
    }
  }

      _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/UnsafeBufferPointer.swift",  31LL,  2,  0x6F5uLL,  0);
    }
  }

  v23[0] = v4;
  v23[1] = v3 & 0xFFFFFFFFFFFFFFLL;
  if (rawBits < 0x10000) {
    goto LABEL_34;
  }
  uint64_t v15 = 0LL;
  while (1)
  {
    if (v13 > v8) {
      goto LABEL_39;
    }
    if ((*((_BYTE *)v23 + v13 + v15 - 1) & 0xC0) != 0x80) {
      break;
    }
    --v15;
    if (!(v13 + v15)) {
      goto LABEL_34;
    }
  }

  Swift::String::Index v152 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v39, v67);
  v64(v65, v39);
  unint64_t v153 = v246;
  (*(void (**)(uint64_t))(*(void *)(v72 + 8) + 16LL))(v66);
  unint64_t v154 = *(uint64_t (**)(void, char *, uint64_t))(*(void *)(*(void *)(v71 + 32) + 8LL) + 16LL);
  unint64_t v155 = v241;
  unint64_t v156 = v154(v241, v153, v66);
  unint64_t v157 = *(void (**)(void (*)(char *, char *, uint64_t), uint64_t))(v243 + 8);
  v157(v155, v66);
  v157((void (*)(char *, char *, uint64_t))v153, v66);
  if ((v156 & 1) != 0) {
    return -v152;
  }
  else {
    return v152;
  }
}

  result.low.high = v9;
  result.low.low = v12;
  result.high.high = v19;
  result.high.low = v18;
  return result;
}

    uint64_t v18 = v15 == 1;
    goto LABEL_35;
  }

  if (v13 > 2097182)
  {
    if (v13 == 2097183)
    {
      int v14 = (void **)(a1 + 296);
      uint64_t v15 = *(_DWORD *)(a1 + 320);
      if (!v15)
      {
        InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  636,  "installCommonValueWitnesses",  "case sizeWithAlignmentMask(32, 31, 0)");
        goto LABEL_52;
      }
    }

    else
    {
      if (v13 != 4194367) {
        goto LABEL_41;
      }
      int v14 = (void **)(a1 + 328);
      uint64_t v15 = *(_DWORD *)(a1 + 352);
      if (!v15)
      {
        InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  645,  "installCommonValueWitnesses",  "case sizeWithAlignmentMask(64, 63, 0)");
        goto LABEL_52;
      }
    }

    goto LABEL_34;
  }

  if (v13 == 524295)
  {
    int v14 = (void **)(a1 + 232);
    uint64_t v15 = *(_DWORD *)(a1 + 256);
    if (!v15)
    {
      InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  618,  "installCommonValueWitnesses",  "case sizeWithAlignmentMask(8, 7, 0)");
      goto LABEL_52;
    }

    goto LABEL_34;
  }

  if (v13 == 1048591)
  {
    int v14 = (void **)(a1 + 264);
    uint64_t v15 = *(_DWORD *)(a1 + 288);
    if (!v15)
    {
      InProcessReaderWriter::log( *(InProcessReaderWriter **)a1,  "GenericMetadataBuilder.h",  627,  "installCommonValueWitnesses",  "case sizeWithAlignmentMask(16, 15, 0)");
LABEL_52:
      char v21 = *v14;
      *a3 = **v14;
      a3[1] = v21[1];
      a3[2] = v21[2];
      a3[3] = v21[3];
      a3[4] = v21[4];
      a3[5] = v21[5];
      a3[6] = v21[6];
      a3[7] = v21[7];
      goto LABEL_53;
    }

    goto LABEL_34;
  }

    if ((v5 & 0x100) != 0) {
      goto LABEL_39;
    }
    if (v10 < v23)
    {
      uint64_t v31 = *(void *)(a2 + 8);
    }

    swift::blockOnMetadataDependency(*(void *)(a1 + 32), v5, v22, v4);
  }

  if (v9 == 63)
  {
    if (v23 > 1u) {
      goto LABEL_39;
    }
    goto LABEL_34;
  }

  if (v9 != 255) {
LABEL_50:
  }
    abort();
LABEL_39:
  uint64_t v27 = *(_OWORD **)(v31 + 16);
  if (!v27)
  {
    if ((unint64_t)v32 | *((void *)&v32 + 1) | (unint64_t)v33 | *((void *)&v33 + 1))
    {
      uint64_t v27 = operator new(0x20uLL);
      Swift::UInt64 v28 = v33;
      *uint64_t v27 = v32;
      v27[1] = v28;
      id v29 = *(void **)(v31 + 16);
      *(void *)(v31 + 16) = v27;
      if (v29)
      {
        operator delete(v29);
        uint64_t v27 = *(_OWORD **)(v31 + 16);
      }
    }

    else
    {
      uint64_t v27 = 0LL;
    }
  }

  *(void *)(v31 + 16) = 0LL;
  uint64_t result = *(void *)(a1 + 32);
  if (v23 != 1 && v23 != 3 && v23 != 2) {
    goto LABEL_50;
  }
  return result;
}

    if ((v11 & 8) == 0) {
      break;
    }
    if (v7) {
      goto LABEL_48;
    }
LABEL_19:
    uint64_t v8 = (void *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
    ++*(void *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476AB0);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 & 0xFFFFFFFFFFFFFFF0LL | 8));
    os_unfair_lock_unlock((os_unfair_lock_t)(v11 & 0xFFFFFFFFFFFFFFF0LL | 8));
  }

  Swift::UInt64 v13 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
  *(_OWORD *)Swift::UInt64 v13 = 0u;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(void *)Swift::UInt64 v13 = 1LL;
  *(void *)(v13 + 16) = 0LL;
  *(void *)(v13 + 24) = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)(v13 + 8));
  Swift::UInt64 v23 = (os_unfair_lock_s *)v13;
  int v14 = (_OWORD *)(v11 & 0xFFFFFFFFFFFFFFF0LL);
  if ((v11 & 0xFFFFFFFFFFFFFFF0LL) != 0)
  {
    *(_OWORD *)(v13 + 24) = *v14;
    uint64_t v15 = *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x1_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = 0LL;
    int v16 = *(void **)(v13 + 16);
    *(void *)(v13 + 16) = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  atomic_store(v11 & 7 | v13 | 8, a1);
  LOBYTE(v24) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C476AB0);
  HIBYTE(v24) = v12;
  if (v14)
  {
    uint64_t v18 = *(void **)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
    *(void *)((v11 & 0xFFFFFFFFFFFFFFF0LL) + 0x1_assertionFailure(_:_:flags:)("Fatal error", 11LL, 2LL, (char *)0xD000000000000018LL, 0x80000001818BB410LL, 0) = 0LL;
    if (v18) {
      operator delete(v18);
    }
    operator delete((void *)(v11 & 0xFFFFFFFFFFFFFFF0LL));
  }

  if (*from) {
    int v19 = ((unint64_t)*from & 0x8000000000000001LL) == 1;
  }
  else {
    int v19 = 1;
  }
  if (v19)
  {
    Swift::String::Index v20 = *from;
    *from = 0LL;
    *to = v20;
  }

  else
  {
    objc_moveWeak(to, from);
  }

LABEL_3:
  LOBYTE(v31) = v4 == v5;
  return value | ((unint64_t)(v4 == v5) << 32);
}

  Swift::UInt64 v4 = *(void *)(v1 + 184);
  Swift::UInt64 v5 = *(void *)(v4 - 8);
  if ((*(_BYTE *)(v5 + 82) & 1) == 0)
  {
LABEL_4:
    v0[2] = 0LL;
    return;
  }

  uint64_t v18 = 0LL;
  int v19 = v0 + 8;
  Swift::String::Index v20 = v0[7];
  char v21 = 1LL << *((_BYTE *)v0 + 32);
  uint64_t v22 = -1LL;
  if (v21 < 64) {
    uint64_t v22 = ~(-1LL << v21);
  }
  Swift::UInt64 v23 = v22 & v0[8];
  Swift::UInt64 v24 = (unint64_t)(v21 + 63) >> 6;
  while (2)
  {
    if (v23)
    {
      uint64_t v25 = __clz(__rbit64(v23));
      v23 &= v23 - 1;
      unint64_t v26 = v25 | (v18 << 6);
LABEL_26:
      swift_arrayDestroy(v20 + *(void *)(v5 + 72) * v26, 1LL, v4);
      continue;
    }

    break;
  }

  uint64_t v15 = __OFADD__(v18++, 1LL);
  if (v15) {
    goto LABEL_41;
  }
  if (v18 >= v24) {
    goto LABEL_4;
  }
  uint64_t v27 = v19[v18];
  if (v27)
  {
LABEL_37:
    Swift::UInt64 v23 = (v27 - 1) & v27;
    unint64_t v26 = __clz(__rbit64(v27)) + (v18 << 6);
    goto LABEL_26;
  }

  Swift::UInt64 v28 = v18 + 1;
  if (v18 + 1 >= v24) {
    goto LABEL_4;
  }
  uint64_t v27 = v19[v28];
  if (v27)
  {
    ++v18;
    goto LABEL_37;
  }

  while (1)
  {
    uint64_t v18 = v28 + 1;
    if (__OFADD__(v28, 1LL)) {
      break;
    }
    if (v18 >= v24) {
      goto LABEL_4;
    }
    uint64_t v27 = v19[v18];
    ++v28;
    if (v27) {
      goto LABEL_37;
    }
  }

      *(void *)a6 = v7;
      *(void *)(a6 + 8) = swift::TypeLookupError::TypeLookupError(char const*)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
LABEL_4:
      *(_BYTE *)(a6 + 16) = 1;
      return result;
    default:
      goto LABEL_23;
  }

  Swift::UInt64 v5 = 0LL;
  Swift::String::Index v6 = *(unsigned __int8 **)this;
  *a3 = 0LL;
  id v7 = v4;
  do
  {
    uint64_t v8 = *v6;
    if (v8 >= 0x3A)
    {
      if (v8 < 0x61)
      {
        if (v8 - 65 > 0x19) {
          break;
        }
        Swift::UInt64 v9 = -55;
      }

      else
      {
        if (v8 >= 0x7B) {
          break;
        }
        Swift::UInt64 v9 = -87;
      }
    }

    else
    {
      Swift::UInt64 v9 = -48;
    }

    Swift::String::Index v10 = v9 + v8;
    id v11 = v5 * a2 + v10;
    *a3 = v11;
    ++v6;
    Swift::UInt64 v5 = v11;
    --v7;
  }

  while (v7);
  if (v4 != v7)
  {
    *(void *)this = v6;
    *((void *)this + 1) = v7;
    return 0LL;
  }

  return 1LL;
}

  uint64_t v3 = 0LL;
LABEL_4:
  if (__p)
  {
    unint64_t v181 = __p;
    operator delete(__p);
  }

  return v3;
}

    Swift::UInt64 v9 = 0LL;
LABEL_4:
    id v7 = v12 + 1;
    if (*(_DWORD *)a4) {
      return this;
    }
  }

uint64_t specialized BidirectionalCollection.last.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000LL) == 0) {
    uint64_t v2 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v2) {
    return 0LL;
  }
  uint64_t v5 = 7LL;
  if (((a2 >> 60) & ((a1 & 0x800000000000000LL) == 0)) != 0) {
    uint64_t v5 = 11LL;
  }
  v6._Swift::UInt64 rawBits = String.index(before:)((Swift::String::Index)(v5 | (v2 << 16)))._rawBits;
  return String.subscript.getter(v6, a1, a2);
}

uint64_t BidirectionalCollection.last.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v6,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v9 = MEMORY[0x1895F8858](AssociatedTypeWitness);
  id v11 = &v22[-((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  MEMORY[0x1895F8858](v9);
  Swift::UInt64 v13 = &v22[-v12];
  if (((*(uint64_t (**)(uint64_t, uint64_t))(v6 + 104))(a1, v6) & 1) != 0)
  {
    unint64_t v14 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v6 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v14 - 8) + 56LL))( a3,  1LL,  1LL,  v14);
  }

  else
  {
    (*(void (**)(uint64_t, uint64_t))(v6 + 72))(a1, v6);
    (*(void (**)(_BYTE *, uint64_t, uint64_t))(a2 + 32))(v11, a1, a2);
    int v16 = *(void (**)(_BYTE *, unint64_t))(v8 + 8);
    v16(v11, AssociatedTypeWitness);
    uint64_t v17 = (void (*)(_BYTE *, void))(*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t, uint64_t))(v6 + 80))( v22,  v13,  a1,  v6);
    uint64_t v19 = v18;
    unint64_t v20 = swift_getAssociatedTypeWitness( 0LL,  *(const char **)(v6 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
    uint64_t v21 = *(void *)(v20 - 8);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v21 + 16))(a3, v19, v20);
    v17(v22, 0LL);
    v16(v13, AssociatedTypeWitness);
    return (*(uint64_t (**)(uint64_t, void, uint64_t, unint64_t))(v21 + 56))(a3, 0LL, 1LL, v20);
  }

uint64_t BidirectionalCollection<>.removeLast()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v73 = a3;
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a1,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v66 = (char *)&v64 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = MEMORY[0x1895F8858](v7);
  uint64_t v65 = (char *)&v64 - v10;
  uint64_t v77 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v11 = MEMORY[0x1895F8858](v9);
  unint64_t v76 = (char *)&v64 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = MEMORY[0x1895F8858](v11);
  uint64_t v74 = (char *)&v64 - v14;
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v17 = (char *)&v64 - v16;
  uint64_t v18 = MEMORY[0x1895F8858](v15);
  uint64_t v75 = (char *)&v64 - v19;
  MEMORY[0x1895F8858](v18);
  uint64_t v78 = (char *)&v64 - v20;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v22 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v21);
  uint64_t v69 = *(void *)(v22 - 8);
  uint64_t v70 = v22;
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  BOOL v67 = (char *)&v64 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v25 = MEMORY[0x1895F8858](v23);
  uint64_t v68 = (char *)&v64 - v26;
  uint64_t v27 = *(void *)(a1 - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v25);
  Swift::UInt64 v30 = (char *)&v64 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v28);
  uint64_t v79 = (char *)&v64 - v31;
  uint64_t v80 = v5;
  unint64_t v32 = swift_getAssociatedTypeWitness( 255LL,  *(const char **)(v5 + 8),  a1,  (uint64_t)&protocol requirements base descriptor for Sequence,  associated type descriptor for Sequence.Element);
  uint64_t v35 = type metadata accessor for Optional(0LL, v32, v33, v34);
  MEMORY[0x1895F8858](v35);
  uint64_t v37 = (char *)&v64 - v36;
  uint64_t v38 = a2;
  BidirectionalCollection.last.getter(a1, a2, (uint64_t)&v64 - v36);
  uint64_t v39 = *(void *)(v32 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v39 + 48))(v37, 1LL, v32) == 1) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2,  "Swift/BidirectionalCollection.swift",  35LL,  2,  0x14BuLL,  0);
  }
  (*(void (**)(uint64_t, char *, unint64_t))(v39 + 32))(v73, v37, v32);
  uint64_t v40 = *(void (**)(char *, uint64_t, uint64_t))(v27 + 16);
  uint64_t v41 = v81;
  v40(v79, v81, a1);
  uint64_t v42 = v80;
  uint64_t v43 = v78;
  (*(void (**)(uint64_t, uint64_t))(v80 + 64))(a1, v80);
  v40(v30, v41, a1);
  (*(void (**)(uint64_t, uint64_t))(v42 + 72))(a1, v42);
  uint64_t v44 = *(void (**)(uint64_t, uint64_t))(v27 + 8);
  v44(v41, a1);
  uint64_t v45 = v75;
  (*(void (**)(char *, uint64_t, uint64_t))(v38 + 32))(v17, a1, v38);
  uint64_t v46 = v77;
  uint64_t v47 = *(void (**)(char *, unint64_t))(v77 + 8);
  v47(v17, AssociatedTypeWitness);
  v44((uint64_t)v30, a1);
  Swift::String::Index v48 = *(void (**)(char *, char *, unint64_t))(v46 + 16);
  Swift::UInt64 v49 = v74;
  v48(v74, v43, AssociatedTypeWitness);
  Swift::UInt64 v50 = v76;
  v48(v76, v45, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v49,  v50,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v47(v50, AssociatedTypeWitness);
  v47(v49, AssociatedTypeWitness);
  unint64_t v76 = (char *)v44;
  uint64_t v51 = TupleTypeMetadata2;
  uint64_t v52 = v65;
  Swift::UInt64 v53 = &v65[*((int *)TupleTypeMetadata2 + 12)];
  Swift::UInt64 v54 = *(void (**)(char *, char *, unint64_t))(v46 + 32);
  v54(v65, v78, AssociatedTypeWitness);
  v54(v53, v45, AssociatedTypeWitness);
  uint64_t v55 = v66;
  Swift::String::Index v56 = &v66[*((int *)v51 + 12)];
  v48(v66, v52, AssociatedTypeWitness);
  v48(v56, v53, AssociatedTypeWitness);
  uint64_t v57 = v67;
  v54(v67, v55, AssociatedTypeWitness);
  v47(v56, AssociatedTypeWitness);
  unint64_t v58 = &v55[*((int *)v51 + 12)];
  v54(v55, v52, AssociatedTypeWitness);
  v54(v58, v53, AssociatedTypeWitness);
  uint64_t v59 = v70;
  v54(&v57[*(int *)(v70 + 36)], v58, AssociatedTypeWitness);
  v47(v55, AssociatedTypeWitness);
  Swift::UInt64 v61 = v68;
  uint64_t v60 = v69;
  (*(void (**)(char *, char *, uint64_t))(v69 + 32))(v68, v57, v59);
  uint64_t v62 = v79;
  (*(void (**)(char *, uint64_t))(v80 + 88))(v61, a1);
  (*(void (**)(char *, uint64_t))(v60 + 8))(v61, v59);
  return ((uint64_t (*)(char *, uint64_t))v76)(v62, a1);
}

uint64_t BidirectionalCollection<>.removeLast(_:)( uint64_t a1, uint64_t a2, void (*a3)(char *, unint64_t))
{
  uint64_t v85 = a3;
  uint64_t v5 = *((void *)a3 + 1);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v5,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v7 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v9 = (char *)&v71 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v7);
  unint64_t v76 = (char *)&v71 - v10;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v5,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v80 = *(void *)(v12 - 8);
  uint64_t v81 = v12;
  uint64_t v13 = MEMORY[0x1895F8858](v12);
  uint64_t v77 = (char *)&v71 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = MEMORY[0x1895F8858](v13);
  uint64_t v78 = (char *)&v71 - v16;
  uint64_t v17 = a2;
  uint64_t v18 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v15);
  uint64_t v89 = (char *)&v71 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v20, v21);
  uint64_t v23 = MEMORY[0x1895F8858](v22);
  uint64_t v25 = (char *)&v71 - v24;
  uint64_t v26 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v27 = MEMORY[0x1895F8858](v23);
  uint64_t v83 = (char *)&v71 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v29 = MEMORY[0x1895F8858](v27);
  unint64_t v82 = (char *)&v71 - v30;
  uint64_t v31 = MEMORY[0x1895F8858](v29);
  uint64_t v32 = MEMORY[0x1895F8858](v31);
  uint64_t v34 = (char *)&v71 - v33;
  uint64_t v35 = MEMORY[0x1895F8858](v32);
  uint64_t v37 = (char *)&v71 - v36;
  uint64_t result = MEMORY[0x1895F8858](v35);
  if (v41)
  {
    if (v41 < 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Number of elements to remove should be non-negative",  51LL,  2,  "Swift/BidirectionalCollection.swift",  35LL,  2,  0x15CuLL,  0);
    }
    uint64_t v71 = v42;
    uint64_t v72 = result;
    uint64_t v87 = (char *)&v71 - v39;
    uint64_t v74 = v18;
    uint64_t v75 = v40;
    uint64_t v73 = v9;
    uint64_t v43 = (char *)v17;
    uint64_t v44 = v41;
    (*(void (**)(uint64_t, uint64_t))(v5 + 72))(v17, v5);
    uint64_t v45 = v5;
    uint64_t v46 = *(void (**)(uint64_t))(v5 + 64);
    uint64_t v86 = v45;
    v46(v17);
    uint64_t v47 = (void (*)(char *, uint64_t, char *, uint64_t))*((void *)v85 + 7);
    uint64_t v88 = v3;
    v47(v37, -v44, v34, v17);
    Swift::String::Index v48 = *(void (**)(char *, unint64_t))(v26 + 8);
    v48(v34, AssociatedTypeWitness);
    uint64_t v85 = v48;
    v48(v37, AssociatedTypeWitness);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v26 + 48))(v25, 1LL, AssociatedTypeWitness) == 1)
    {
      (*(void (**)(char *, uint64_t))(v71 + 8))(v25, v72);
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't remove more items from a collection than it contains",  58LL,  2,  "Swift/BidirectionalCollection.swift",  35LL,  2,  0x15FuLL,  0);
    }

    Swift::UInt64 v49 = *(void (**)(char *, char *, unint64_t))(v26 + 32);
    Swift::UInt64 v50 = v87;
    v49(v87, v25, AssociatedTypeWitness);
    uint64_t v51 = v74;
    uint64_t v52 = v88;
    (*(void (**)(char *, uint64_t, char *))(v74 + 16))(v89, v88, v43);
    Swift::UInt64 v53 = v75;
    ((void (*)(char *, uint64_t))v46)(v43, v86);
    Swift::UInt64 v54 = *(void (**)(uint64_t, char *))(v51 + 8);
    v54(v52, v43);
    uint64_t v55 = *(void (**)(char *, uint64_t, unint64_t))(v26 + 16);
    Swift::String::Index v56 = v82;
    v55(v82, (uint64_t)v53, AssociatedTypeWitness);
    uint64_t v57 = v83;
    v55(v83, (uint64_t)v50, AssociatedTypeWitness);
    if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v56,  v57,  AssociatedTypeWitness) & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
    }
    unint64_t AssociatedConformanceWitness = (unint64_t)v54;
    unint64_t v58 = v85;
    v85(v57, AssociatedTypeWitness);
    v58(v56, AssociatedTypeWitness);
    uint64_t v83 = v43;
    uint64_t v59 = TupleTypeMetadata2;
    uint64_t v60 = v76;
    Swift::UInt64 v61 = &v76[*((int *)TupleTypeMetadata2 + 12)];
    v49(v76, v53, AssociatedTypeWitness);
    v49(v61, v87, AssociatedTypeWitness);
    uint64_t v62 = v73;
    uint64_t v63 = &v73[*((int *)v59 + 12)];
    v55(v73, (uint64_t)v60, AssociatedTypeWitness);
    v55(v63, (uint64_t)v61, AssociatedTypeWitness);
    uint64_t v64 = v77;
    v49(v77, v62, AssociatedTypeWitness);
    v58(v63, AssociatedTypeWitness);
    uint64_t v65 = &v62[*((int *)v59 + 12)];
    v49(v62, v60, AssociatedTypeWitness);
    v49(v65, v61, AssociatedTypeWitness);
    uint64_t v66 = v81;
    v49(&v64[*(int *)(v81 + 36)], v65, AssociatedTypeWitness);
    v58(v62, AssociatedTypeWitness);
    uint64_t v67 = v80;
    uint64_t v68 = v78;
    (*(void (**)(char *, char *, uint64_t))(v80 + 32))(v78, v64, v66);
    uint64_t v69 = v89;
    uint64_t v70 = v83;
    (*(void (**)(char *, char *))(v86 + 88))(v68, v83);
    (*(void (**)(char *, uint64_t))(v67 + 8))(v68, v66);
    return ((uint64_t (*)(char *, char *))AssociatedConformanceWitness)(v69, v70);
  }

  return result;
}

uint64_t static SignedNumeric.- prefix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
}

{
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 - 8) + 16LL))(a4, a1, a2);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
}

uint64_t BidirectionalCollection.dropLast(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v80 = a4;
  uint64_t v90 = a3;
  uint64_t v7 = *(void *)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  (const char *)v7,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v9 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v79 = (char *)&v71 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v75 = (char *)&v71 - v11;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v78 = *(void *)(v13 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v74 = (char *)&v71 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  unint64_t v76 = (char *)&v71 - v17;
  uint64_t v91 = a2;
  uint64_t v82 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v81 = (char *)&v71 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v19, v20);
  uint64_t v87 = *(void *)(v21 - 8);
  uint64_t v88 = v21;
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  uint64_t v89 = (char *)&v71 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v71 - v25;
  uint64_t v27 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v24);
  uint64_t v85 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v83 = (char *)&v71 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v84 = (char *)&v71 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v71 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  uint64_t v39 = (char *)&v71 - v38;
  MEMORY[0x1895F8858](v37);
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't drop a negative number of elements from a collection",  58LL,  2,  "Swift/BidirectionalCollection.swift",  35LL,  2,  0x17CuLL,  0);
  }
  uint64_t v72 = v13;
  uint64_t v73 = (char *)&v71 - v40;
  uint64_t v41 = v91;
  (*(void (**)(uint64_t, uint64_t))(v7 + 72))(v91, v7);
  uint64_t v42 = -a1;
  uint64_t v43 = *(void (**)(uint64_t, uint64_t))(v7 + 64);
  v43(v41, v7);
  (*(void (**)(char *, uint64_t, char *, uint64_t))(v90 + 56))(v39, v42, v36, v41);
  uint64_t v90 = v7;
  uint64_t v44 = *(void (**)(char *, unint64_t))(v27 + 8);
  v44(v36, AssociatedTypeWitness);
  v44(v39, AssociatedTypeWitness);
  uint64_t v45 = v81;
  uint64_t v46 = v82;
  (*(void (**)(char *, char *, uint64_t))(v82 + 16))(v81, v4, v41);
  uint64_t v47 = v89;
  (*(void (**)(char *, char *, uint64_t))(v87 + 32))(v89, v26, v88);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v27 + 48))(v47, 1LL, AssociatedTypeWitness) == 1)
  {
    Swift::String::Index v48 = v73;
    Swift::UInt64 v49 = v45;
    uint64_t v50 = v91;
    v43(v91, v90);
    uint64_t v82 = *(void *)(v46 + 8);
    ((void (*)(char *, uint64_t))v82)(v49, v50);
    (*(void (**)(char *, uint64_t))(v87 + 8))(v89, v88);
  }

  else
  {
    uint64_t v82 = *(void *)(v46 + 8);
    ((void (*)(char *, uint64_t))v82)(v45, v91);
    Swift::String::Index v48 = v73;
    (*(void (**)(char *, char *, unint64_t))(v27 + 32))(v73, v89, AssociatedTypeWitness);
  }

  uint64_t v52 = v84;
  uint64_t v51 = v85;
  Swift::UInt64 v53 = v83;
  v43(v91, v90);
  Swift::UInt64 v54 = v52;
  uint64_t v55 = *(void (**)(char *, char *, unint64_t))(v27 + 16);
  v55(v53, v54, AssociatedTypeWitness);
  v55(v51, v48, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v53,  v51,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v44(v51, AssociatedTypeWitness);
  v44(v53, AssociatedTypeWitness);
  Swift::String::Index v56 = TupleTypeMetadata2;
  uint64_t v57 = *((int *)TupleTypeMetadata2 + 12);
  unint64_t v58 = v75;
  uint64_t v89 = v4;
  uint64_t v59 = &v75[v57];
  uint64_t v60 = *(void (**)(char *, char *, unint64_t))(v27 + 32);
  v60(v75, v54, AssociatedTypeWitness);
  v60(v59, v48, AssociatedTypeWitness);
  Swift::UInt64 v61 = v79;
  uint64_t v62 = &v79[*((int *)v56 + 12)];
  v55(v79, v58, AssociatedTypeWitness);
  v55(v62, v59, AssociatedTypeWitness);
  uint64_t v63 = v74;
  v60(v74, v61, AssociatedTypeWitness);
  v44(v62, AssociatedTypeWitness);
  uint64_t v64 = &v61[*((int *)v56 + 12)];
  v60(v61, v58, AssociatedTypeWitness);
  v60(v64, v59, AssociatedTypeWitness);
  uint64_t v65 = v72;
  v60(&v63[*(int *)(v72 + 36)], v64, AssociatedTypeWitness);
  v44(v61, AssociatedTypeWitness);
  uint64_t v66 = v78;
  uint64_t v67 = v76;
  (*(void (**)(char *, char *, uint64_t))(v78 + 32))(v76, v63, v65);
  uint64_t v68 = v89;
  uint64_t v69 = v91;
  (*(void (**)(char *, uint64_t))(v90 + 88))(v67, v91);
  ((void (*)(char *, uint64_t))v82)(v68, v69);
  return (*(uint64_t (**)(char *, uint64_t))(v66 + 8))(v67, v65);
}

uint64_t BidirectionalCollection.suffix(_:)@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v82 = a4;
  uint64_t v87 = a3;
  uint64_t v6 = *(const char **)(a3 + 8);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 255LL,  v6,  a2,  (uint64_t)&protocol requirements base descriptor for Collection,  associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2( 0LL,  AssociatedTypeWitness,  AssociatedTypeWitness,  "lower upper ",  0LL);
  uint64_t v8 = MEMORY[0x1895F8858](TupleTypeMetadata2);
  uint64_t v10 = (char *)&v73 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v8);
  uint64_t v78 = (char *)&v73 - v11;
  uint64_t v94 = v6;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v6,  a2,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for Collection,  (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for Range(0LL, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v81 = *(void *)(v13 - 8);
  uint64_t v14 = MEMORY[0x1895F8858](v13);
  uint64_t v77 = (char *)&v73 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = MEMORY[0x1895F8858](v14);
  uint64_t v79 = (char *)&v73 - v17;
  uint64_t v84 = *(void *)(a2 - 8);
  MEMORY[0x1895F8858](v16);
  uint64_t v83 = (char *)&v73 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = type metadata accessor for Optional(0LL, AssociatedTypeWitness, v19, v20);
  uint64_t v91 = *(void *)(v21 - 8);
  uint64_t v92 = v21;
  uint64_t v22 = MEMORY[0x1895F8858](v21);
  unint64_t v93 = (char *)&v73 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  uint64_t v26 = (char *)&v73 - v25;
  uint64_t v27 = *(void *)(AssociatedTypeWitness - 8);
  uint64_t v28 = MEMORY[0x1895F8858](v24);
  uint64_t v88 = (char *)&v73 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  uint64_t v86 = (char *)&v73 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  uint64_t v89 = (char *)&v73 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v73 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  uint64_t v39 = (char *)&v73 - v38;
  MEMORY[0x1895F8858](v37);
  uint64_t v85 = (char *)&v73 - v40;
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Can't take a suffix of negative length from a collection",  56LL,  2,  "Swift/BidirectionalCollection.swift",  35LL,  2,  0x19BuLL,  0);
  }
  uint64_t v41 = a1;
  uint64_t v74 = v10;
  uint64_t v43 = v94;
  uint64_t v42 = v95;
  uint64_t v44 = (void (*)(uint64_t, const char *))*((void *)v94 + 9);
  uint64_t v75 = v13;
  unint64_t v76 = v44;
  v44(a2, v94);
  uint64_t v45 = -v41;
  uint64_t v46 = (void (*)(uint64_t, const char *))*((void *)v43 + 8);
  v46(a2, v43);
  (*(void (**)(char *, uint64_t, char *, uint64_t))(v87 + 56))(v39, v45, v36, a2);
  uint64_t v47 = *(void (**)(char *, unint64_t))(v27 + 8);
  v47(v36, AssociatedTypeWitness);
  v47(v39, AssociatedTypeWitness);
  Swift::String::Index v48 = v83;
  uint64_t v49 = v84;
  (*(void (**)(char *, uint64_t, uint64_t))(v84 + 16))(v83, v42, a2);
  uint64_t v50 = v93;
  (*(void (**)(char *, char *, uint64_t))(v91 + 32))(v93, v26, v92);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v27 + 48))(v50, 1LL, AssociatedTypeWitness) == 1)
  {
    uint64_t v51 = v85;
    uint64_t v52 = v48;
    Swift::UInt64 v53 = v94;
    v46(a2, v94);
    uint64_t v87 = *(void *)(v49 + 8);
    ((void (*)(char *, uint64_t))v87)(v52, a2);
    (*(void (**)(char *, uint64_t))(v91 + 8))(v93, v92);
    Swift::UInt64 v54 = v53;
  }

  else
  {
    uint64_t v87 = *(void *)(v49 + 8);
    ((void (*)(char *, uint64_t))v87)(v48, a2);
    uint64_t v51 = v85;
    (*(void (**)(char *, char *, unint64_t))(v27 + 32))(v85, v93, AssociatedTypeWitness);
    Swift::UInt64 v54 = v94;
  }

  uint64_t v55 = v89;
  v76(a2, v54);
  Swift::String::Index v56 = *(void (**)(char *, char *, unint64_t))(v27 + 16);
  uint64_t v57 = v86;
  v56(v86, v51, AssociatedTypeWitness);
  unint64_t v58 = v88;
  v56(v88, v55, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))( v57,  v58,  AssociatedTypeWitness) & 1) == 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  v47(v58, AssociatedTypeWitness);
  v47(v57, AssociatedTypeWitness);
  uint64_t v59 = v51;
  uint64_t v60 = TupleTypeMetadata2;
  Swift::UInt64 v61 = v78;
  uint64_t v62 = &v78[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v63 = *(void (**)(char *, char *, unint64_t))(v27 + 32);
  v63(v78, v59, AssociatedTypeWitness);
  v63(v62, v55, AssociatedTypeWitness);
  uint64_t v64 = v74;
  uint64_t v65 = &v74[*((int *)v60 + 12)];
  v56(v74, v61, AssociatedTypeWitness);
  v56(v65, v62, AssociatedTypeWitness);
  uint64_t v66 = v77;
  v63(v77, v64, AssociatedTypeWitness);
  v47(v65, AssociatedTypeWitness);
  uint64_t v67 = &v64[*((int *)v60 + 12)];
  v63(v64, v61, AssociatedTypeWitness);
  v63(v67, v62, AssociatedTypeWitness);
  uint64_t v68 = v75;
  v63(&v66[*(int *)(v75 + 36)], v67, AssociatedTypeWitness);
  v47(v64, AssociatedTypeWitness);
  uint64_t v69 = v81;
  uint64_t v70 = v79;
  (*(void (**)(char *, char *, uint64_t))(v81 + 32))(v79, v66, v68);
  uint64_t v71 = v95;
  (*((void (**)(char *, uint64_t))v94 + 11))(v70, a2);
  ((void (*)(uint64_t, uint64_t))v87)(v71, a2);
  return (*(uint64_t (**)(char *, uint64_t))(v69 + 8))(v70, v68);
}

uint64_t _UnsafeBitset.wordCount.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

unint64_t static _UnsafeBitset.word(for:)(unint64_t a1)
{
  return a1 >> 6;
}

uint64_t static _UnsafeBitset.Word.capacity.getter()
{
  return 64LL;
}

unint64_t static UInt./ infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero",  16LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x321DuLL,  0);
  }
  return a1 / a2;
}

uint64_t static _UnsafeBitset.bit(for:)(char a1)
{
  return a1 & 0x3F;
}

unint64_t static UInt.% infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Division by zero in remainder operation",  39LL,  2,  "Swift/IntegerTypes.swift",  24LL,  2,  0x32F1uLL,  0);
  }
  return a1 % a2;
}

unint64_t static _UnsafeBitset.split(_:)(unint64_t a1)
{
  return a1 >> 6;
}

uint64_t static _UnsafeBitset.join(word:bit:)(uint64_t a1, uint64_t a2)
{
  return a2 + (a1 << 6);
}

uint64_t static FixedWidthInteger.&* infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 96))(a3, a1);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 96))(a3, a1);
}

unint64_t static _UnsafeBitset.wordCount(forCapacity:)(uint64_t a1)
{
  return (unint64_t)(a1 + 63) >> 6;
}

uint64_t _UnsafeBitset.capacity.getter(uint64_t a1, uint64_t a2)
{
  return a2 << 6;
}

Swift::Bool __swiftcall _UnsafeBitset.isValid(_:)(Swift::Int a1)
{
  return a1 >= 0 && a1 <= v1 << 6;
}

Swift::Bool __swiftcall _UnsafeBitset.uncheckedContains(_:)(Swift::Int a1)
{
  return (*(void *)(v1 + (((unint64_t)a1 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a1) & 1LL;
}

Swift::Bool __swiftcall _UnsafeBitset.Word.uncheckedContains(_:)(Swift::Int a1)
{
  return (v1 >> a1) & 1;
}

Swift::Bool __swiftcall _UnsafeBitset.uncheckedInsert(_:)(Swift::Int a1)
{
  unint64_t v2 = ((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  uint64_t v3 = 1LL << a1;
  uint64_t v4 = *(void *)(v1 + v2);
  Swift::Bool result = (v4 & (1LL << a1)) == 0;
  *(void *)(v1 + v2) = v4 | v3;
  return result;
}

Swift::Bool __swiftcall _UnsafeBitset.Word.uncheckedInsert(_:)(Swift::Int a1)
{
  uint64_t v2 = 1LL << a1;
  Swift::Bool result = (*v1 & (1LL << a1)) == 0;
  *v1 |= v2;
  return result;
}

Swift::Bool __swiftcall _UnsafeBitset.uncheckedRemove(_:)(Swift::Int a1)
{
  unint64_t v2 = ((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFF8LL;
  uint64_t v3 = 1LL << a1;
  uint64_t v4 = *(void *)(v1 + v2);
  Swift::Bool result = (v4 & (1LL << a1)) != 0;
  *(void *)(v1 + v2) = v4 & ~v3;
  return result;
}

Swift::Bool __swiftcall _UnsafeBitset.Word.uncheckedRemove(_:)(Swift::Int a1)
{
  uint64_t v2 = 1LL << a1;
  Swift::Bool result = (*v1 & (1LL << a1)) != 0;
  *v1 &= ~v2;
  return result;
}

Swift::Void __swiftcall _UnsafeBitset.clear()()
{
}

uint64_t static _UnsafeBitset.Word.empty.getter()
{
  return 0LL;
}

unint64_t specialized UnsafeMutablePointer.assign(repeating:count:)( unint64_t result, unint64_t a2, int64x2_t *a3)
{
  if ((a2 & 0x8000000000000000LL) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.update(repeating:count:) with negative count",  65LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x3BCuLL,  0);
  }
  if (a2)
  {
    if (a2 < 4)
    {
      unint64_t v3 = 0LL;
LABEL_8:
      uint64_t v7 = (unint64_t *)a3 + v3;
      unint64_t v8 = a2 - v3;
      do
      {
        *v7++ = result;
        --v8;
      }

      while (v8);
      return result;
    }

    unint64_t v3 = a2 & 0xFFFFFFFFFFFFFFFCLL;
    int64x2_t v4 = vdupq_n_s64(result);
    uint64_t v5 = a3 + 1;
    unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v5[-1] = v4;
      *uint64_t v5 = v4;
      v5 += 2;
      v6 -= 4LL;
    }

    while (v6);
    if (v3 != a2) {
      goto LABEL_8;
    }
  }

  return result;
}

uint64_t UnsafeMutablePointer.assign(repeating:count:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeMutablePointer.update(repeating:count:) with negative count",  65LL,  2,  "Swift/UnsafePointer.swift",  25LL,  2,  0x3BCuLL,  0);
  }
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)(a4 - 8);
    uint64_t v9 = *(void *)(v8 + 72);
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 24);
    do
    {
      Swift::Bool result = v10(a3, v7, a4);
      a3 += v9;
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t _UnsafeBitset.count.getter(int8x8_t *a1, uint64_t a2)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Range requires lowerBound <= upperBound",  39LL,  2,  "Swift/Range.swift",  17LL,  2,  0x2F2uLL,  0);
  }
  uint64_t v2 = 0LL;
  while (a2)
  {
    int8x8_t v3 = *a1++;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8(v3);
    v4.i16[0] = vaddlv_u8(v4);
    --a2;
    BOOL v5 = __OFADD__(v2, v4.u32[0]);
    v2 += v4.u32[0];
    if (v5)
    {
      __break(1u);
      return v2;
    }
  }

  return v2;
}

uint64_t _UnsafeBitset.Word.count.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

  ;
}

  ;
}

uint64_t _UnsafeBitset.Iterator.index.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t (*_UnsafeBitset.Iterator.index.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t _UnsafeBitset.Iterator.word.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t (*_UnsafeBitset.Iterator.word.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Int_optional __swiftcall _UnsafeBitset.Iterator.next()()
{
  unint64_t v1 = v0[3];
  if (v1)
  {
    Swift::Bool v2 = 0;
    v0[3] = (v1 - 1) & v1;
    Swift::Int v3 = __clz(__rbit64(v1)) | (v0[2] << 6);
    goto LABEL_14;
  }

  uint64_t v4 = v0[2];
  BOOL v5 = __OFADD__(v4, 1LL);
  uint64_t v6 = v4 + 1;
  if (v5)
  {
LABEL_13:
    __break(1u);
    goto LABEL_14;
  }

  uint64_t v7 = v0[1];
  if (v6 >= v7)
  {
LABEL_11:
    Swift::Int v3 = 0LL;
    Swift::Bool v2 = 1;
    goto LABEL_14;
  }

  v0[2] = v6;
  uint64_t v8 = *v0;
  unint64_t v9 = *(void *)(*v0 + 8 * v6);
  v0[3] = v9;
  if (!v9)
  {
    while (1)
    {
      uint64_t v10 = v6 + 1;
      if (__OFADD__(v6, 1LL)) {
        break;
      }
      if (v10 >= v7) {
        goto LABEL_11;
      }
      v0[2] = v10;
      unint64_t v9 = *(void *)(v8 + 8 * v10);
      v0[3] = v9;
      ++v6;
      if (v9) {
        goto LABEL_7;
      }
    }

    __break(1u);
    goto LABEL_13;
  }

  uint64_t v10 = v6;
LABEL_7:
  Swift::Bool v2 = 0;
  v0[3] = (v9 - 1) & v9;
  Swift::Int v3 = __clz(__rbit64(v9)) + (v10 << 6);
LABEL_14:
  result.Swift::UInt32 value = v3;
  result.is_nil = v2;
  return result;
}

Swift::Int_optional __swiftcall _UnsafeBitset.Word.next()()
{
  unint64_t v1 = *v0;
  if (*v0)
  {
    Swift::Int v2 = __clz(__rbit64(v1));
    *uint64_t v0 = (v1 - 1) & v1;
  }

  else
  {
    Swift::Int v2 = 0LL;
  }

  Swift::Bool v3 = v1 == 0;
  result.Swift::UInt32 value = v2;
  result.is_nil = v3;
  return result;
}

Swift::Int protocol witness for IteratorProtocol.next() in conformance _UnsafeBitset.Iterator@<X0>( uint64_t a1@<X8>)
{
  Swift::Int_optional v3 = _UnsafeBitset.Iterator.next()();
  *(void *)a1 = v3.value;
  *(_BYTE *)(a1 + 8) = v3.is_nil;
  return v3.value;
}

void protocol witness for Sequence.makeIterator() in conformance _UnsafeBitset(uint64_t **a1@<X8>)
{
  Swift::Int v2 = *(uint64_t **)v1;
  uint64_t v3 = *(void *)(v1 + 8);
  if (v3 < 1) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = (uint64_t *)*v2;
  }
  *a1 = v2;
  a1[1] = (uint64_t *)v3;
  a1[2] = 0LL;
  a1[3] = v4;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _UnsafeBitset()
{
  return _UnsafeBitset.count.getter(*(int8x8_t **)v0, *(void *)(v0 + 8));
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance _UnsafeBitset()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*(unint64_t **)v0, *(void *)(v0 + 8));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _UnsafeBitset( unint64_t **a1, unint64_t *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)( a1,  a2,  a3,  *(unint64_t **)v3,  *(void *)(v3 + 8));
}

uint64_t _UnsafeBitset.Word.value.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*_UnsafeBitset.Word.value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

uint64_t static UInt.bitWidth.getter()
{
  return 64LL;
}

uint64_t static FixedWidthInteger.&<< infix<A>(_:_:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = MEMORY[0x1895F8858](a1);
  uint64_t v13 = (char *)&v20 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = *(void *)(v14 - 8);
  MEMORY[0x1895F8858](v11);
  uint64_t v17 = (char *)&v20 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *))(v18 + 16))(v13);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(a5 + 8) + 96LL))(v13, a4, a6, a3);
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 216))(a1, v17, a3, a5);
  return (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v17, a3);
}

BOOL static UInt.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

unint64_t _UnsafeBitset.Word.minimum.getter(unint64_t a1)
{
  return __clz(__rbit64(a1)) & 0x3F;
}

unint64_t UInt.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

unint64_t _UnsafeBitset.Word.maximum.getter(unint64_t a1)
{
  unint64_t v1 = __clz(a1) ^ 0x3F;
  if (a1) {
    return v1;
  }
  else {
    return 0LL;
  }
}

unint64_t UInt.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

uint64_t _UnsafeBitset.Word.complement.getter(uint64_t a1)
{
  return ~a1;
}

Swift::_UnsafeBitset::Word __swiftcall _UnsafeBitset.Word.subtracting(elementsBelow:)(Swift::Int elementsBelow)
{
  return (Swift::_UnsafeBitset::Word)((-1LL << elementsBelow) & v1);
}

uint64_t static UnsignedInteger<>.max.getter(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 8);
  MEMORY[0x1895F8858](a1);
  uint64_t v4 = (char *)&v13 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = *(void *)(v5 + 8);
  uint64_t v7 = *(void *)(*(void *)(v6 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  (const char *)v7,  a1,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v13 - v9;
  unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v7,  a1,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  AssociatedTypeWitness,  AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 24))(v10, a1, v7);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 184))(v4, a1, v6);
  return (*(uint64_t (**)(char *, uint64_t))(v2 + 8))(v4, a1);
}

Swift::_UnsafeBitset::Word __swiftcall _UnsafeBitset.Word.intersecting(elementsBelow:)(Swift::Int elementsBelow)
{
  return (Swift::_UnsafeBitset::Word)(v1 & ~(-1LL << elementsBelow));
}

Swift::_UnsafeBitset::Word __swiftcall _UnsafeBitset.Word.intersecting(elementsAbove:)(Swift::Int elementsAbove)
{
  return (Swift::_UnsafeBitset::Word)((-2LL << elementsAbove) & v1);
}

uint64_t static _UnsafeBitset.Word.allBits.getter()
{
  return -1LL;
}

uint64_t UInt.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t _UnsafeBitset.Word.underestimatedCount.getter(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

BOOL _UnsafeBitset.Word.isEmpty.getter(uint64_t a1)
{
  return a1 == 0;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance _UnsafeBitset.Word()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _UnsafeBitset.Word( unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

void protocol witness for IteratorProtocol.next() in conformance _UnsafeBitset.Word(uint64_t a1@<X8>)
{
  unint64_t v2 = *v1;
  if (*v1)
  {
    unint64_t v3 = __clz(__rbit64(v2));
    *uint8x8_t v1 = (v2 - 1) & v2;
  }

  else
  {
    unint64_t v3 = 0LL;
  }

  *(void *)a1 = v3;
  *(_BYTE *)(a1 + 8) = v2 == 0;
}

uint64_t Bool._value.getter(char a1)
{
  return a1 & 1;
}

uint64_t Bool._value.setter(uint64_t result)
{
  *uint8x8_t v1 = result;
  return result;
}

uint64_t (*Bool._value.modify())(void, void)
{
  return EnumeratedSequence._base.modify;
}

Swift::Bool __swiftcall Bool.init()()
{
  return 0;
}

Swift::Bool __swiftcall Bool.init(_:)(Builtin::Int1 a1)
{
  return a1;
}

Swift::Bool __swiftcall Bool.init(_:)(Swift::Bool a1)
{
  return a1;
}

BOOL static Bool.random<A>(using:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ((*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3) & 0x20000) == 0;
}

uint64_t static FixedWidthInteger.>> infix<A>(_:_:)@<X0>( void (*a1)(char *, char *, uint64_t)@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v8 = (void (*)(char *, uint64_t))a3;
  v241 = a1;
  v223 = *(const char **)(*(void *)(a5 + 24) + 16LL);
  unint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  v223,  a3,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1895F8858](AssociatedTypeWitness);
  v221 = (char *)&v215 - v11;
  v234 = *(char **)(a4 + 8);
  v232 = *(const char **)(*((void *)v234 + 3) + 16LL);
  unint64_t v230 = swift_getAssociatedTypeWitness( 0LL,  v232,  a2,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1895F8858](v230);
  v229 = (char *)&v215 - v13;
  uint64_t v238 = *((void *)v8 - 1);
  uint64_t v14 = MEMORY[0x1895F8858](v12);
  uint64_t v16 = (char *)&v215 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = MEMORY[0x1895F8858](v14);
  uint64_t v19 = (char *)&v215 - v18;
  uint64_t v20 = MEMORY[0x1895F8858](v17);
  v219 = (char *)&v215 - v21;
  uint64_t v22 = MEMORY[0x1895F8858](v20);
  v216 = (char *)&v215 - v23;
  uint64_t v24 = MEMORY[0x1895F8858](v22);
  v224 = (char *)&v215 - v25;
  uint64_t v26 = MEMORY[0x1895F8858](v24);
  v225 = (char *)&v215 - v27;
  uint64_t v28 = MEMORY[0x1895F8858](v26);
  v218 = (char *)&v215 - v29;
  uint64_t v30 = MEMORY[0x1895F8858](v28);
  v226 = (char *)&v215 - v31;
  uint64_t v32 = MEMORY[0x1895F8858](v30);
  v227 = (char *)&v215 - v33;
  uint64_t v34 = MEMORY[0x1895F8858](v32);
  uint64_t v36 = (char *)&v215 - v35;
  uint64_t v37 = MEMORY[0x1895F8858](v34);
  v235 = (char *)&v215 - ((v38 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v39 = MEMORY[0x1895F8858](v37);
  v233 = (char *)&v215 - v40;
  uint64_t v41 = MEMORY[0x1895F8858](v39);
  v239 = (char *)&v215 - v42;
  uint64_t v43 = MEMORY[0x1895F8858](v41);
  v240 = (char *)&v215 - v44;
  MEMORY[0x1895F8858](v43);
  uint64_t v237 = v45;
  uint64_t v46 = *(void (**)(void))(v45 + 16);
  v231 = (char *)&v215 - v47;
  v46();
  v242 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 56);
  uint64_t v243 = a4;
  uint64_t v48 = v242(a2, a4);
  uint64_t v49 = -v48;
  if (__OFSUB__(0LL, v48))
  {
    __break(1u);
    goto LABEL_85;
  }

  uint64_t v50 = *(uint64_t (**)(void *, uint64_t))(a5 + 64);
  char v51 = v50(v8, a5);
  uint64_t v228 = a6;
  if ((v51 & 1) == 0)
  {
    char v62 = v50(v8, a5);
    v236 = *(uint64_t (**)(void *, uint64_t))(a5 + 128);
    uint64_t v63 = v236(v8, a5);
    if ((v62 & 1) != 0)
    {
      if (v63 <= 64)
      {
        v215 = v50;
        unint64_t v76 = v223;
        unint64_t v77 = AssociatedTypeWitness;
        unint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( (uint64_t)v223,  (uint64_t)v8,  AssociatedTypeWitness,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v79 = v221;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))( &unk_18180BE68,  256LL,  v77,  AssociatedConformanceWitness);
        (*((void (**)(char *, void (*)(char *, uint64_t), const char *))v76 + 3))(v79, v8, v76);
        uint64_t v80 = v241;
        LODWORD(v217) = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL) + 16LL))( v241,  v36,  v8);
        uint64_t v81 = v238;
        uint64_t v82 = *(void (**)(char *, void *))(v238 + 8);
        v82(v36, v8);
        (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v81 + 16))(v19, v80, v8);
        if ((v217 & 1) != 0)
        {
          v82(v19, v8);
          goto LABEL_23;
        }

        uint64_t v91 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
        v82(v19, v8);
        BOOL v132 = v91 < v49;
        uint64_t v57 = v36;
        uint64_t v50 = v215;
        uint64_t v60 = v82;
        Swift::UInt64 v61 = v241;
        if (v132) {
          goto LABEL_23;
        }
      }

      else
      {
        v245[0] = v49;
        uint64_t v66 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
        unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
        uint64_t v57 = v36;
        v66(v245, &type metadata for Int, v67, v8, a5);
        Swift::UInt64 v61 = v241;
        char v68 = (*(uint64_t (**)(void, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                              + 16LL))( v241,  v57,  v8);
        uint64_t v60 = *(void (**)(char *, void *))(v238 + 8);
        v60(v57, v8);
        if ((v68 & 1) != 0) {
          goto LABEL_23;
        }
      }
    }

    else if (v63 < 64)
    {
      uint64_t v72 = v238;
      uint64_t v57 = v36;
      uint64_t v73 = v36;
      Swift::UInt64 v61 = v241;
      (*(void (**)(char *, void, void (*)(char *, uint64_t)))(v238 + 16))(v73, v241, v8);
      uint64_t v74 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
      uint64_t v75 = *(void (**)(char *, void *))(v72 + 8);
      v75(v57, v8);
      BOOL v132 = v74 < v49;
      uint64_t v60 = v75;
      if (v132) {
        goto LABEL_23;
      }
    }

    else
    {
      uint64_t v83 = v238;
      uint64_t v84 = (*(uint64_t (**)(char *, void, void (*)(char *, uint64_t)))(v238 + 16))(v16, v241, v8);
      uint64_t v57 = v36;
      if (v49 <= 0)
      {
        uint64_t v60 = *(void (**)(char *, void *))(v83 + 8);
        v60(v16, v8);
        Swift::UInt64 v61 = v241;
        goto LABEL_26;
      }

      v245[0] = v49;
      uint64_t v87 = v83;
      uint64_t v88 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
      unint64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v84, v85, v86);
      v88(v245, &type metadata for Int, v89, v8, a5);
      char v90 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                            + 16LL))( v16,  v36,  v8);
      uint64_t v60 = *(void (**)(char *, void *))(v87 + 8);
      v60(v36, v8);
      v60(v16, v8);
      Swift::UInt64 v61 = v241;
      if ((v90 & 1) != 0) {
        goto LABEL_23;
      }
    }

LABEL_26:
    v220 = v57;
    uint64_t v94 = v242(a2, v243);
    char v95 = v50(v8, a5);
    uint64_t v96 = v236(v8, a5);
    v217 = v60;
    if ((v95 & 1) != 0)
    {
      if (v96 > 64)
      {
        v245[0] = v94;
        uint64_t v99 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
        unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v96, v97, v98);
        uint64_t v101 = v220;
        v99(v245, &type metadata for Int, v100, v8, a5);
        char v102 = (*(uint64_t (**)(char *, void, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                               + 16LL))( v101,  v61,  v8);
        v60(v101, v8);
        uint64_t v93 = v237;
        if ((v102 & 1) == 0)
        {
          uint64_t v103 = *(void (**)(char *, void, void (*)(char *, uint64_t)))(v238 + 16);
          goto LABEL_38;
        }

        goto LABEL_56;
      }

      uint64_t v106 = v60;
      uint64_t v103 = *(void (**)(char *, void, void (*)(char *, uint64_t)))(v238 + 16);
      uint64_t v107 = v220;
      v103(v220, v61, v8);
      uint64_t v108 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
      v106(v107, v8);
      BOOL v132 = v94 < v108;
      uint64_t v93 = v237;
      if (v132) {
        goto LABEL_56;
      }
    }

    else
    {
      uint64_t v93 = v237;
      if (v96 > 63)
      {
        unint64_t v109 = v219;
        uint64_t v103 = *(void (**)(char *, void, void (*)(char *, uint64_t)))(v238 + 16);
        uint64_t v110 = ((uint64_t (*)(char *, void, void (*)(char *, uint64_t)))v103)(v219, v241, v8);
        if (v94 < 0)
        {
          v217(v109, v8);
          goto LABEL_56;
        }

        v245[0] = v94;
        uint64_t v113 = *(void (**)(void *, ValueMetadata *, unint64_t, void (*)(char *, uint64_t), uint64_t))(a5 + 96);
        unint64_t v114 = lazy protocol witness table accessor for type Int and conformance Int(v110, v111, v112);
        uint64_t v115 = v220;
        v113(v245, &type metadata for Int, v114, v8, a5);
        uint64_t v93 = v237;
        char v116 = (*(uint64_t (**)(char *, char *, void (*)(char *, uint64_t)))(*(void *)(*(void *)(a5 + 32) + 8LL)
                                                                                               + 16LL))( v115,  v109,  v8);
        uint64_t v117 = v115;
        uint64_t v118 = v217;
        v217(v117, v8);
        v118(v109, v8);
        if ((v116 & 1) != 0)
        {
LABEL_56:
          uint64_t v49 = v242(a2, v243);
          goto LABEL_61;
        }
      }

      else
      {
        uint64_t v103 = *(void (**)(char *, void, void (*)(char *, uint64_t)))(v238 + 16);
        uint64_t v104 = v220;
        v103(v220, v241, v8);
        uint64_t v105 = (*(uint64_t (**)(void *, uint64_t))(a5 + 120))(v8, a5);
        v217(v104, v8);
        if (v94 < v105) {
          goto LABEL_56;
        }
      }
    }

    if (v15 <= 15)
    {
LABEL_16:
      swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
      swift_bridgeObjectRetain(v13, v19, v20, v21);
      uint64_t v22 = _StringGuts._convertedToSmall()(v12, v13);
      uint64_t v24 = v23;
      swift_bridgeObjectRelease(v13);
      v25._Swift::UInt64 rawBits = 1LL;
      v26._Swift::UInt64 rawBits = 1LL;
      v27._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v25, v26, 0LL, 0xE000000000000000LL);
      if (v27._rawBits < 0x10000) {
        v27._rawBits |= 3;
      }
      uint64_t v29 = specialized String.init(_:)(v27, v28, 0LL, 0xE000000000000000LL);
      uint64_t v31 = v30;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      uint64_t v32 = _StringGuts._convertedToSmall()(v29, v31);
      uint64_t v34 = v33;
      swift_bridgeObjectRelease(v31);
      uint64_t v35 = specialized _SmallString.init(_:appending:)(v22, v24, v32, v34);
      if ((v37 & 1) != 0) {
        goto LABEL_345;
      }
      uint64_t v38 = v35;
      uint64_t v39 = v36;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      v372._uint64_t countAndFlagsBits = v38;
      v372._unint64_t object = v39;
      goto LABEL_24;
    }

    if (v15 <= 15)
    {
LABEL_16:
      swift_bridgeObjectRelease_n(0xE000000000000000LL, 5LL);
      swift_bridgeObjectRetain(v13, v19, v20, v21);
      uint64_t v22 = _StringGuts._convertedToSmall()(v12, v13);
      uint64_t v24 = v23;
      swift_bridgeObjectRelease(v13);
      v25._Swift::UInt64 rawBits = 1LL;
      v26._Swift::UInt64 rawBits = 1LL;
      v27._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v25, v26, 0LL, 0xE000000000000000LL);
      if (v27._rawBits < 0x10000) {
        v27._rawBits |= 3;
      }
      uint64_t v29 = specialized String.init(_:)(v27, v28, 0LL, 0xE000000000000000LL);
      uint64_t v31 = v30;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      uint64_t v32 = _StringGuts._convertedToSmall()(v29, v31);
      uint64_t v34 = v33;
      swift_bridgeObjectRelease(v31);
      uint64_t v35 = specialized _SmallString.init(_:appending:)(v22, v24, v32, v34);
      if ((v37 & 1) != 0) {
        goto LABEL_343;
      }
      uint64_t v38 = v35;
      uint64_t v39 = v36;
      swift_bridgeObjectRelease(0xE000000000000000LL);
      v366._uint64_t countAndFlagsBits = v38;
      v366._unint64_t object = v39;
      goto LABEL_24;
    }

  __break(1u);
}

  __break(1u);
LABEL_27:
  __break(1u);
  return result;
}

  __break(1u);
}

    uint64_t v17 = (v24 - 1) & v24;
    uint64_t v21 = __clz(__rbit64(v24)) + (v19 << 6);
LABEL_11:
    uint64_t v22 = *(void *)(v5 + 48) + 40 * v21;
    uint64_t v93 = *(_OWORD *)v22;
    uint64_t v94 = *(_OWORD *)(v22 + 16);
    char v95 = *(void *)(v22 + 32);
    specialized _NativeSet._unsafeInsertNew(_:)((uint64_t)&v93, (uint64_t)v13);
  }

  uint64_t v25 = v23 + 3;
  if (v25 >= v18) {
    goto LABEL_55;
  }
  uint64_t v24 = v15[v25];
  if (v24)
  {
    uint64_t v19 = v25;
    goto LABEL_26;
  }

  while (1)
  {
    uint64_t v19 = v25 + 1;
    if (__OFADD__(v25, 1LL)) {
      break;
    }
    if (v19 >= v18) {
      goto LABEL_55;
    }
    uint64_t v24 = v15[v19];
    ++v25;
    if (v24) {
      goto LABEL_26;
    }
  }

  __break(1u);
LABEL_27:
  __break(1u);
  return result;
}

        _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "",  0LL,  2,  "Swift/StringBridge.swift",  24LL,  2,  0x22FuLL,  0);
      }

      uint64_t v23 = 588LL;
    }

    else
    {
LABEL_18:
      uint64_t v16 = specialized _SmallString.init(taggedCocoa:)((void *)v1, 4LL);
      if ((v18 & 1) == 0)
      {
        uint64_t v14 = v16;
        swift_unknownObjectRetain((id)v1, v17, v18, v19);
        return v14;
      }

      uint64_t v23 = 585LL;
    }

    if (v14 >= v15 && v14 < v13._rawBits >> 14) {
      goto LABEL_51;
    }
    goto LABEL_52;
  }

  uint64_t v22 = 0LL;
  uint64_t v23 = v12 >> 14;
  uint64_t v24 = (char *)&v34 + 6;
  do
  {
    if (v23 >= v14 && v14 >= v13._rawBits >> 14) {
      goto LABEL_51;
    }
    uint64_t v25 = v13._rawBits >> 16;
    if (!(v13._rawBits >> 16))
    {
      uint64_t v33 = 236LL;
      goto LABEL_55;
    }

    if ((v5 & 0x1000000000000000LL) != 0)
    {
      uint64_t v31 = v24;
      v13._Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v13)._rawBits;
      uint64_t v24 = v31;
    }

    else
    {
      if ((v5 & 0x2000000000000000LL) != 0)
      {
        uint64_t v35 = v6;
        uint64_t v36 = v5 & 0xFFFFFFFFFFFFFFLL;
        if ((*((_BYTE *)&v35 + v25 - 1) & 0xC0) == 0x80)
        {
          uint64_t v28 = 0LL;
          do
            uint64_t v29 = v24[v25 + v28--] & 0xC0;
          while (v29 == 128);
          uint64_t v30 = 1 - v28;
        }

        else
        {
          uint64_t v30 = 1LL;
        }

        v25 -= v30;
      }

      else
      {
        uint64_t v26 = (char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((v6 & 0x1000000000000000LL) == 0)
        {
          uint64_t v34 = v24;
          uint64_t v26 = (char *)_StringObject.sharedUTF8.getter(v6, v5);
          uint64_t v24 = v34;
        }

        do
          uint64_t v27 = v26[--v25] & 0xC0;
        while (v27 == 128);
      }

      v13._Swift::UInt64 rawBits = (v25 << 16) | 5;
    }

    --v22;
  }

  while (v22 > offsetBy);
  if (v23 < v14 || v13._rawBits >> 14 >= v14)
  {
LABEL_52:
    uint64_t v32 = 0;
    goto LABEL_56;
  }

  uint64_t v16 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v11);
  uint64_t v17 = v11 + v16;
  if (__OFADD__(v11, v16)) {
    goto LABEL_28;
  }
LABEL_17:
  if (v9 < v17)
  {
    uint64_t v18 = v16 << 8;
    if (v16 > 63) {
      uint64_t v18 = 0LL;
    }
    uint64_t v19 = v7 & 2 | (unint64_t)(v11 << 16) | v18;
    if ((a5 & 0x1000000000000000LL) == 0 || (a4 & 0x800000000000000LL) != 0) {
      uint64_t v20 = 5LL;
    }
    else {
      uint64_t v20 = 9LL;
    }
    return v19 | v20;
  }

  return v8;
}

    if (v14 <= 15) {
      goto LABEL_13;
    }
    goto LABEL_27;
  }

  v288._uint64_t countAndFlagsBits = 0LL;
  v288._unint64_t object = (void *)0xE000000000000000LL;
  uint64_t v38 = v6;
  while (1)
  {
LABEL_28:
    swift_bridgeObjectRelease(v38);
LABEL_29:
    if ((_DWORD)v4) {
      uint64_t v45 = 0x1000000;
    }
    else {
      uint64_t v45 = 0;
    }
    if (v3) {
      uint64_t v46 = 0x10000;
    }
    else {
      uint64_t v46 = 0;
    }
    if ((_DWORD)v2) {
      uint64_t v47 = 256;
    }
    else {
      uint64_t v47 = 0;
    }
    uint64_t v48 = _GraphemeBreakingState.description.getter(v47 | v1 | v46 | v45, v39, v40, v41);
    uint64_t v52 = v48;
    uint64_t v53 = v49;
    uint64_t countAndFlagsBits = v288._countAndFlagsBits;
    unint64_t object = (unint64_t)v288._object;
    uint64_t v56 = ((unint64_t)v288._object >> 56) & 0xF;
    uint64_t v57 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v57 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000LL) == 0)
    {
      v288._uint64_t countAndFlagsBits = v48;
      v288._unint64_t object = (void *)v49;
      swift_bridgeObjectRelease(object);
      goto LABEL_88;
    }

    uint64_t v58 = v49 & 0x2000000000000000LL;
    uint64_t v59 = HIBYTE(v49) & 0xF;
    if (((uint64_t)v288._object & 0x2000000000000000LL) != 0 && v58)
    {
      uint64_t v60 = v56 + v59;
      if (v56 + v59 <= 0xF)
      {
        if (v59)
        {
          uint64_t v98 = 0;
          uint64_t v99 = 0LL;
          do
          {
            unint64_t v100 = v56 + v99;
            uint64_t v101 = v99 + 1;
            if (v99 >= 8) {
              char v102 = v49;
            }
            else {
              char v102 = v48;
            }
            uint64_t v103 = v102 >> (v98 & 0x38);
            uint64_t v104 = (8 * v56 + v98) & 0x38;
            uint64_t v105 = (-255LL << v104) - 1;
            uint64_t v106 = (unint64_t)v103 << v104;
            uint64_t v107 = v106 | v105 & object;
            uint64_t v108 = v106 | v105 & countAndFlagsBits;
            if (v100 < 8) {
              uint64_t countAndFlagsBits = v108;
            }
            else {
              unint64_t object = v107;
            }
            v98 += 8;
            uint64_t v99 = v101;
          }

          while (v59 != v101);
        }

        swift_bridgeObjectRelease(v49);
        unint64_t v109 = 0xA000000000000000LL;
        if (!(countAndFlagsBits & 0x8080808080808080LL | object & 0x80808080808080LL)) {
          unint64_t v109 = 0xE000000000000000LL;
        }
        uint64_t v110 = (void *)(v109 & 0xFF00000000000000LL | (v60 << 56) | object & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v288._object);
        v288._uint64_t countAndFlagsBits = countAndFlagsBits;
        v288._unint64_t object = v110;
        goto LABEL_88;
      }

      uint64_t v58 = 1LL;
    }

    if (v58) {
      Swift::UInt64 v61 = HIBYTE(v49) & 0xF;
    }
    else {
      Swift::UInt64 v61 = v48 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v49, 2LL, v50, v51);
    if ((v53 & 0x1000000000000000LL) != 0)
    {
      swift_bridgeObjectRetain_n(v53, 5LL, v62, v63);
      v240._Swift::UInt64 rawBits = 1LL;
      v241._Swift::UInt64 rawBits = (v61 << 16) | 1;
      v242._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v240, v241, v52, v53);
      if (v242._rawBits < 0x10000) {
        v242._rawBits |= 3;
      }
      uint64_t v64 = specialized Collection.count.getter(v242, v243, v52, v53);
      swift_bridgeObjectRelease(v53);
      uint64_t countAndFlagsBits = v288._countAndFlagsBits;
      unint64_t object = (unint64_t)v288._object;
      if (((uint64_t)v288._object & 0x1000000000000000LL) != 0)
      {
LABEL_226:
        uint64_t v244 = String.UTF8View._foreignCount()();
        uint64_t v65 = v244 + v64;
        if (!__OFADD__(v244, v64)) {
          goto LABEL_56;
        }
        goto LABEL_54;
      }
    }

    else
    {
      swift_bridgeObjectRetain_n(v53, 4LL, v62, v63);
      uint64_t v64 = v61;
      if ((object & 0x1000000000000000LL) != 0) {
        goto LABEL_226;
      }
    }

    if ((object & 0x2000000000000000LL) == 0)
    {
      uint64_t v65 = (countAndFlagsBits & 0xFFFFFFFFFFFFLL) + v64;
      if (!__OFADD__(countAndFlagsBits & 0xFFFFFFFFFFFFLL, v64)) {
        goto LABEL_56;
      }
      goto LABEL_54;
    }

    while (1)
    {
      uint64_t v66 = HIBYTE(object) & 0xF;
      uint64_t v65 = v66 + v64;
      if (!__OFADD__(v66, v64)) {
        break;
      }
LABEL_54:
      __break(1u);
    }

  uint64_t v54 = Array._getCount()();
  if (v54 < v26) {
    goto LABEL_38;
  }
  uint64_t v55 = v54;
  (*(void (**)(uint64_t, uint64_t))(v79 + 8))(v80, v81);
  Array._checkIndex(_:)(v55);
  swift_release(v24);
  uint64_t v56 = (void *)_ArrayBuffer.subscript.getter(v26, v55, v24, v10);
  uint64_t v58 = v57;
  uint64_t v60 = v59;
  char v62 = v61;
  swift_release(v24);
  if ((v62 & 1) == 0) {
    goto LABEL_28;
  }
  uint64_t v69 = type metadata accessor for __ContiguousArrayStorageBase();
  uint64_t v72 = swift_unknownObjectRetain_n((uint64_t)v56, 3LL, v70, v71);
  uint64_t v73 = (__objc2_class **)swift_dynamicCastClass(v72, v69);
  if (!v73)
  {
    swift_unknownObjectRelease(v56);
    uint64_t v73 = &_swiftEmptyArrayStorage;
  }

  uint64_t v74 = v73[2];
  uint64_t v75 = swift_release((uint64_t)v73);
  if (__OFSUB__(v62 >> 1, v60))
  {
    __break(1u);
    goto LABEL_42;
  }

  uint64_t v75 = (uint64_t)v56;
  if (v74 != (__objc2_class *)((v62 >> 1) - v60))
  {
LABEL_42:
    swift_unknownObjectRelease_n(v75, 2LL);
LABEL_28:
    uint64_t v86 = (uint64_t)v56;
    uint64_t v87 = v58;
    uint64_t v88 = v60;
    unint64_t v89 = v62;
    uint64_t v65 = type metadata accessor for ArraySlice(0LL, (uint64_t)v10, v63, v64);
    unint64_t v67 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v65, v66);
    char v68 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v86, v65, v67);
    swift_unknownObjectRelease(v56);
    goto LABEL_35;
  }

  char v68 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v56, v69);
  swift_unknownObjectRelease_n((uint64_t)v56, 2LL);
  if (!v68)
  {
    swift_unknownObjectRelease(v56);
    char v68 = &_swiftEmptyArrayStorage;
  }

    uint64_t v52 = 0LL;
    uint64_t v53 = 0LL;
    goto LABEL_65;
  }

  if (v105 <= 0xFFFFFFFFFFFFFF80LL)
  {
LABEL_19:
    uint64_t v52 = v51 >> 63;
    uint64_t v53 = v52;
    goto LABEL_65;
  }

  uint64_t v108 = v51 >> -(char)v105;
  uint64_t v53 = v51 >> 63;
  uint64_t v52 = ((2 * v51) << (v105 - 1)) | (v106 >> -(char)v105);
LABEL_65:
  uint64_t v107 = v120;
  *char v120 = v52;
  v107[1] = v53;
  return result;
}

  uint64_t v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v74 = v140;
  v73(v140, a2, a3);
  uint64_t v75 = v141(a3, a4);
  unint64_t v76 = v139;
  unint64_t v77 = v74;
  uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  BOOL v132 = v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    uint64_t v80 = v140;
    goto LABEL_43;
  }

  uint64_t v79 = v32(a3, a4);
  v70(v76, a3);
  uint64_t v80 = v140;
  if (v79 <= 64) {
    goto LABEL_43;
  }
  uint64_t v81 = v135;
  v78(v135, v140, a3);
  uint64_t v144 = 0x8000000000000000LL;
  uint64_t v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    uint64_t v83 = v132(a3, a4);
    if (v83 >= 64)
    {
      uint64_t v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      uint64_t v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v88,  a3);
      unint64_t v89 = v88;
      uint64_t v81 = v135;
      v70(v89, a3);
      goto LABEL_42;
    }
  }

  else
  {
    char v90 = v82(a3, a4);
    uint64_t v91 = v132(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        char v102 = (void (**)(char *, uint64_t, const char *))v137;
        uint64_t v103 = v133;
        uint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        uint64_t v81 = v107;
        v70(v108, a3);
        unint64_t v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }

        uint64_t v110 = v144;
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        uint64_t v80 = v140;
        if (v112) {
          goto LABEL_65;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        uint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        uint64_t v97 = v135;
        uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        uint64_t v99 = v96;
        uint64_t v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_65;
        }
      }

      goto LABEL_42;
    }

    if (v91 >= 64) {
      goto LABEL_42;
    }
  }

  unint64_t v100 = v142;
  v78(v142, v81, a3);
  uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_65:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_42:
  v70(v81, a3);
LABEL_43:
  uint64_t v113 = v132;
  unint64_t v114 = v132(a3, a4);
  uint64_t v115 = v138;
  v78(v138, v80, a3);
  if (v114 < 65)
  {
    uint64_t v124 = v113(a3, a4);
    v70(v115, a3);
    uint64_t v125 = v124 == 64;
    char v116 = v141;
    if (!v125 || (v141(a3, a4) & 1) != 0) {
      goto LABEL_57;
    }
  }

  else
  {
    v70(v115, a3);
    char v116 = v141;
  }

  v78(v40, v80, a3);
  uint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v117 = v116(a3, a4);
  uint64_t v118 = v132(a3, a4);
  if ((v117 & 1) != 0)
  {
    if (v118 > 64)
    {
      uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v144;
      goto LABEL_55;
    }
  }

  else if (v118 >= 64)
  {
    char v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
    uint64_t v123 = &v143;
LABEL_55:
    uint64_t v127 = v142;
    v121(v123, &type metadata for Int, v122, a3, a4);
    uint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
    v70(v127, a3);
    if ((v128 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_56;
  }

  char v126 = v142;
  v78(v142, v40, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v126, a3);
LABEL_56:
  v70(v40, a3);
LABEL_57:
  uint64_t v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  Swift::Int_optional result = v70(v80, a3);
  v130 = *(unsigned __int8 *)v39;
  if ((v129 & 0x8000000000000000LL) == 0)
  {
    if (v129 < 8)
    {
      Swift::UInt64 v61 = v130 << v129;
      goto LABEL_60;
    }

    goto LABEL_25;
  }

  if (v129 <= 0xFFFFFFFFFFFFFFF8LL) {
    Swift::UInt64 v61 = (char)v130 >> 7;
  }
  else {
    Swift::UInt64 v61 = (char)v130 >> -(char)v129;
  }
LABEL_60:
  *(_BYTE *)uint64_t v39 = v61;
  return result;
}

  uint64_t v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v74 = v140;
  v73(v140, a2, a3);
  uint64_t v75 = v141(a3, a4);
  unint64_t v76 = v139;
  unint64_t v77 = v74;
  uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  BOOL v132 = (unsigned __int16 *)v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    uint64_t v80 = v140;
    goto LABEL_43;
  }

  uint64_t v79 = v32(a3, a4);
  v70(v76, a3);
  uint64_t v80 = v140;
  if (v79 <= 64) {
    goto LABEL_43;
  }
  uint64_t v81 = v135;
  v78(v135, v140, a3);
  uint64_t v144 = 0x8000000000000000LL;
  uint64_t v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    uint64_t v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      uint64_t v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      uint64_t v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v88,  a3);
      unint64_t v89 = v88;
      uint64_t v81 = v135;
      v70(v89, a3);
      goto LABEL_42;
    }
  }

  else
  {
    char v90 = v82(a3, a4);
    uint64_t v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        char v102 = (void (**)(char *, uint64_t, const char *))v137;
        uint64_t v103 = v133;
        uint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        uint64_t v81 = v107;
        v70(v108, a3);
        unint64_t v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }

        uint64_t v110 = v144;
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        uint64_t v80 = v140;
        if (v112) {
          goto LABEL_65;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        uint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        uint64_t v97 = v135;
        uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        uint64_t v99 = v96;
        uint64_t v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_65;
        }
      }

      goto LABEL_42;
    }

    if (v91 >= 64) {
      goto LABEL_42;
    }
  }

  unint64_t v100 = v142;
  v78(v142, v81, a3);
  uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_65:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_42:
  v70(v81, a3);
LABEL_43:
  uint64_t v113 = v132;
  unint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  uint64_t v115 = v138;
  v78(v138, v80, a3);
  if (v114 < 65)
  {
    uint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
    v70(v115, a3);
    uint64_t v125 = v124 == 64;
    char v116 = v141;
    if (!v125 || (v141(a3, a4) & 1) != 0) {
      goto LABEL_57;
    }
  }

  else
  {
    v70(v115, a3);
    char v116 = v141;
  }

  v78(v40, v80, a3);
  uint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v117 = v116(a3, a4);
  uint64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  if ((v117 & 1) != 0)
  {
    if (v118 > 64)
    {
      uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v144;
      goto LABEL_55;
    }
  }

  else if (v118 >= 64)
  {
    char v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
    uint64_t v123 = &v143;
LABEL_55:
    uint64_t v127 = v142;
    v121(v123, &type metadata for Int, v122, a3, a4);
    uint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
    v70(v127, a3);
    if ((v128 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_56;
  }

  char v126 = v142;
  v78(v142, v40, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v126, a3);
LABEL_56:
  v70(v40, a3);
LABEL_57:
  uint64_t v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  Swift::Int_optional result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) == 0)
  {
    if (v129 < 0x10)
    {
      Swift::UInt64 v61 = v130 << v129;
      goto LABEL_60;
    }

    goto LABEL_25;
  }

  if (v129 <= 0xFFFFFFFFFFFFFFF0LL) {
    Swift::UInt64 v61 = (__int16)v130 >> 15;
  }
  else {
    Swift::UInt64 v61 = (__int16)v130 >> -(char)v129;
  }
LABEL_60:
  char *v39 = v61;
  return result;
}

  uint64_t v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v74 = v140;
  v73(v140, a2, a3);
  uint64_t v75 = v141(a3, a4);
  unint64_t v76 = v139;
  unint64_t v77 = v74;
  uint64_t v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  BOOL v132 = v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    uint64_t v80 = v140;
    goto LABEL_43;
  }

  uint64_t v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v76, a3);
  uint64_t v80 = v140;
  if (v79 <= 64) {
    goto LABEL_43;
  }
  uint64_t v81 = v135;
  v78(v135, v140, a3);
  uint64_t v144 = 0x8000000000000000LL;
  uint64_t v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    uint64_t v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      uint64_t v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      uint64_t v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v88,  a3);
      unint64_t v89 = v88;
      uint64_t v81 = v135;
      v70(v89, a3);
      goto LABEL_42;
    }
  }

  else
  {
    char v90 = v82(a3, a4);
    uint64_t v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        char v102 = (void (**)(char *, uint64_t, const char *))v137;
        uint64_t v103 = v133;
        uint64_t v104 = swift_getAssociatedConformanceWitness( (uint64_t)v137,  a3,  v133,  (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral,  (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))( &qword_18180BE68,  256LL,  v103,  v104);
        uint64_t v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        uint64_t v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL)
                                                                          + 16LL))( v135,  v106,  a3);
        uint64_t v108 = v106;
        uint64_t v81 = v107;
        v70(v108, a3);
        unint64_t v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }

        uint64_t v110 = v144;
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        uint64_t v112 = v111 < v110;
        uint64_t v80 = v140;
        if (v112) {
          goto LABEL_65;
        }
      }

      else
      {
        uint64_t v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        char v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        uint64_t v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        uint64_t v97 = v135;
        uint64_t v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v135,  v96,  a3);
        uint64_t v99 = v96;
        uint64_t v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0) {
          goto LABEL_65;
        }
      }

      goto LABEL_42;
    }

    if (v91 >= 64) {
      goto LABEL_42;
    }
  }

  unint64_t v100 = v142;
  v78(v142, v81, a3);
  uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144) {
LABEL_65:
  }
    _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent a signed value",  43LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE61uLL,  0);
LABEL_42:
  v70(v81, a3);
LABEL_43:
  uint64_t v113 = v132;
  unint64_t v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  uint64_t v115 = v138;
  v78(v138, v80, a3);
  if (v114 < 65)
  {
    uint64_t v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
    v70(v115, a3);
    uint64_t v125 = v124 == 64;
    char v116 = v141;
    if (!v125 || (v141(a3, a4) & 1) != 0) {
      goto LABEL_57;
    }
  }

  else
  {
    v70(v115, a3);
    char v116 = v141;
  }

  v78(v40, v80, a3);
  uint64_t v144 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v117 = v116(a3, a4);
  uint64_t v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  if ((v117 & 1) != 0)
  {
    if (v118 > 64)
    {
      uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      uint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      uint64_t v123 = &v144;
      goto LABEL_55;
    }
  }

  else if (v118 >= 64)
  {
    char v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    uint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
    uint64_t v123 = &v143;
LABEL_55:
    uint64_t v127 = v142;
    v121(v123, &type metadata for Int, v122, a3, a4);
    uint64_t v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8LL) + 16LL))( v127,  v40,  a3);
    v70(v127, a3);
    if ((v128 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "Not enough bits to represent the passed value",  45LL,  2,  "Swift/Integers.swift",  20LL,  2,  0xE67uLL,  0);
    }
    goto LABEL_56;
  }

  char v126 = v142;
  v78(v142, v40, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v126, a3);
LABEL_56:
  v70(v40, a3);
LABEL_57:
  uint64_t v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  Swift::Int_optional result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000LL) == 0)
  {
    if (v129 < 0x20)
    {
      Swift::UInt64 v61 = v130 << v129;
      goto LABEL_60;
    }

    goto LABEL_25;
  }

  if (v129 <= 0xFFFFFFFFFFFFFFE0LL) {
    Swift::UInt64 v61 = v130 >> 31;
  }
  else {
    Swift::UInt64 v61 = v130 >> -(char)v129;
  }
LABEL_60:
  char *v39 = v61;
  return result;
}

  if (v16 < 0) {
    goto LABEL_31;
  }
  uint64_t v14 = -(uint64_t)v15;
  if (v15) {
    uint64_t v13 = ~v16;
  }
  else {
    uint64_t v13 = -v16;
  }
LABEL_32:
  result.remainder.high = v13;
  result.remainder.low = v14;
  result.quotient.high = v11;
  result.quotient.low = v12;
  return result;
}

      if (!v43) {
        goto LABEL_83;
      }
LABEL_36:
      uint64_t v19 = v43 + v17;
      uint64_t v18 = v17;
LABEL_37:
      specialized _pop<A>(from:as:count:)(&v43, v18);
      if (v43 && v44 != v43)
      {
        uint64_t v26 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v43, 1LL);
        if (!v26) {
          goto LABEL_82;
        }
        uint64_t v25 = *v26;
      }

      else
      {
        uint64_t v25 = 0LL;
      }

      uint64_t v27 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v41, 1LL);
      if (!v27) {
        goto LABEL_82;
      }
      uint64_t v28 = *v27;
      uint64_t v29 = v41;
      uint64_t v30 = BYTE3(v28) & 0x7F;
      if (v30 == 1 || v30 == 3)
      {
        if ((~(_DWORD)v28 & 0x7FFFFF) == 0)
        {
          uint64_t v31 = 4LL;
LABEL_60:
          if (!v41) {
LABEL_83:
          }
            _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer has a nil start and nonzero count",  56LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x486uLL,  0);
LABEL_63:
          uint64_t v36 = v41 + v31;
          uint64_t v37 = v31;
          goto LABEL_64;
        }
      }

      else if (v30 == 2)
      {
        uint64_t v31 = 28LL;
        if ((v28 & 0x400000) == 0) {
          uint64_t v31 = 20LL;
        }
        if ((v28 & 0x80000) == 0) {
          goto LABEL_60;
        }
        if (!v41) {
          goto LABEL_82;
        }
        uint64_t v32 = 24LL;
        if ((v28 & 0x400000) == 0) {
          uint64_t v32 = 16LL;
        }
        uint64_t v33 = v41 + v32 + 4;
        if ((v33 & 7) != 0) {
LABEL_77:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "load from misaligned raw pointer",  32LL,  2,  "Swift/UnsafeRawPointer.swift",  28LL,  2,  0x1B8uLL,  0);
        uint64_t v34 = v31 + 16;
        uint64_t v35 = *(void *)v33;
        uint64_t v24 = __OFADD__(v34, v35);
        uint64_t v31 = v34 + v35;
        if (v24) {
          goto LABEL_79;
        }
        if ((v28 & 0x10) != 0)
        {
          uint64_t v24 = __OFADD__(v31, 8LL);
          v31 += 8LL;
          if (v24) {
            goto LABEL_81;
          }
        }

        if (v31 < 0) {
LABEL_76:
        }
          _fatalErrorMessage(_:_:file:line:flags:)( (unint64_t)"Fatal error",  11LL,  2,  "UnsafeRawBufferPointer with negative count",  42LL,  2,  "Swift/UnsafeRawBufferPointer.swift",  34LL,  2,  0x485uLL,  0);
        goto LABEL_63;
      }

      uint64_t v31 = 0LL;
      uint64_t v36 = 0LL;
      uint64_t v37 = 0LL;
      if (v41) {
        goto LABEL_63;
      }
LABEL_64:
      specialized _pop<A>(from:as:count:)(&v41, v37);
      if (v41 && v42 != v41)
      {
        uint64_t v39 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v41, 1LL);
        if (!v39) {
          goto LABEL_82;
        }
        uint64_t v38 = *v39;
      }

      else
      {
        uint64_t v38 = 0LL;
      }

      RawKeyPathComponent.value.getter(v14, v15, v19, (uint64_t *)v45);
      RawKeyPathComponent.value.getter(v28, v29, v36, v46);
      specialized static KeyPathComponent.== infix(_:_:)(v45);
      if ((v40 & 1) == 0) {
        return 0LL;
      }
      if (!v25) {
        return v38 == 0;
      }
      Swift::Int_optional result = 0LL;
      if (!v38 || v25 != v38) {
        return result;
      }
    }

    if (v16 != 3) {
      goto LABEL_21;
    }
LABEL_19:
    if ((~(_DWORD)v14 & 0x7FFFFF) != 0)
    {
LABEL_21:
      uint64_t v17 = 0LL;
      uint64_t v18 = 0LL;
      uint64_t v19 = 0LL;
      if (!v43) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }

    uint64_t v17 = 4LL;
    goto LABEL_26;
  }

  return !v8 || v9 == v8;
}

    v8 += v15;
    uint64_t v11 = v12;
  }

  while (v12 != v9);
  if (v2 <= 15) {
    goto LABEL_98;
  }
  uint64_t v38 = v2;
  if ((v10 & 1) != 0) {
LABEL_94:
  }
    uint64_t v38 = v2 | 0xC000000000000000LL;
  uint64_t v39 = v38 | 0x3000000000000000LL;
  uint64_t v40 = _allocateStringStorage(codeUnitCapacity:)(v2);
  *(void *)(v40 + 16) = v41;
  *(void *)(v40 + 24) = v39;
  if (v41 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0LL;
    uint64_t v39 = *(void *)(v40 + 24);
  }

  *(_BYTE *)(v40 + 32 + (v39 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)a1, v3, (char *)(v40 + 32));
  return *(void *)(v40 + 24);
}

      goto LABEL_5;
    }

    if (v20 == 12) {
      goto LABEL_67;
    }
    if (v21 != 4) {
      break;
    }
    if (v20 == 3 || v20 == 6)
    {
LABEL_45:
      LOBYTE(v33) = v21;
      if (v29) {
        uint64_t v22 = v9;
      }
      else {
        uint64_t v22 = *((void *)&v28 + 1);
      }
      uint64_t v31 = v22;
      uint64_t v32 = 0;
      goto LABEL_9;
    }

    if (v20 != 17) {
      goto LABEL_5;
    }
LABEL_9:
    uint64_t v9 = v14;
    uint64_t v30 = v14;
    uint64_t v10 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v14, a2, a3);
    uint64_t v14 = v17;
    if ((v18 & 1) != 0) {
      goto LABEL_67;
    }
  }

  if (v21 == 16)
  {
    switch(v20)
    {
      case 3u:
      case 6u:
      case 0x11u:
        goto LABEL_45;
      case 0x10u:
        goto LABEL_9;
      default:
        goto LABEL_5;
    }
  }

  if (v21 != 12)
  {
    if (v20 <= 0x11 && ((1 << v20) & 0x20048) != 0)
    {
      if (v21 > 0x11 || ((1 << v21) & 0x20048) == 0) {
        goto LABEL_45;
      }
      goto LABEL_9;
    }

    if (v21 > 0x11 || ((1 << v21) & 0x20048) == 0)
    {
LABEL_5:
      else {
        uint64_t v15 = v33;
      }
      specialized _StringGuts.decidePostFormatBackward(between:and:with:)(v20, v15, (uint64_t)&v27, v12);
      if ((v16 & 1) != 0) {
        goto LABEL_67;
      }
      goto LABEL_9;
    }

    goto LABEL_26;
  }

    uint64_t v11 = 1;
    return v11 | (v11 << 8);
  }

  uint64_t v11 = 0;
  return v11 | (v11 << 8);
}

              *(void *)uint64_t v25 = v26;
              *(_OWORD *)(v25 + 8) = *(_OWORD *)((char *)v20 + 8);
              ++*(_DWORD *)(a1 + 8);
            }

            uint64_t v20 = (__swift::__runtime::llvm *)((char *)v20 + 24);
          }

          while (v20 != (__swift::__runtime::llvm *)((char *)v4 + 24 * v3));
        }

        __swift::__runtime::llvm::deallocate_buffer(v4, (void *)(24 * v3));
      }
    }

    else
    {
      uint64_t v12 = result;
    }

    uint64_t v19 = &result[3 * v10];
    do
    {
      *uint64_t v12 = -2LL;
      v12 += 3;
    }

    while (v12 != v19);
    goto LABEL_16;
  }

  *(void *)(a1 + 8) = 0LL;
  uint64_t v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    uint64_t v14 = 24LL * v13 - 24;
    if (v14 < 0x18)
    {
      uint64_t v15 = result;
LABEL_21:
      uint64_t v24 = &result[3 * v13];
      do
      {
        *uint64_t v15 = -2LL;
        v15 += 3;
      }

      while (v15 != v24);
      return result;
    }

    uint64_t v21 = v14 / 0x18 + 1;
    uint64_t v15 = &result[3 * (v21 & 0x1FFFFFFFFFFFFFFELL)];
    uint64_t v22 = v21 & 0x1FFFFFFFFFFFFFFELL;
    uint64_t v23 = result;
    do
    {
      char *v23 = -2LL;
      void v23[3] = -2LL;
      v23 += 6;
      v22 -= 2LL;
    }

    while (v22);
    if (v21 != (v21 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_21;
    }
  }

  return result;
}

  uint64_t v12 = (v11 + 1);
  if (*((_WORD *)a2 + 8) == 229)
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = 0;
    uint64_t v15 = "";
    switch(a2[18])
    {
      case 1:
        uint64_t v14 = 0;
        uint64_t v13 = 1LL;
        goto LABEL_48;
      case 2:
        goto LABEL_51;
      case 3:
        uint64_t v13 = 0LL;
        uint64_t v14 = *((_DWORD *)a2 + 2);
        uint64_t v15 = *(const char **)a2;
        goto LABEL_48;
      case 5:
        uint64_t v13 = *((unsigned int *)a2 + 2);
        if (v13 <= 1)
        {
          uint64_t v14 = 0;
LABEL_48:
          Swift::Int_optional result = operator new(0x28uLL);
          *Swift::Int_optional result = "TypeDecoder.h:%u: Node kind %u %.*s - fewer children (%zu) than required (2)";
          result[1] = 0xE5000005EBLL;
          *((_DWORD *)result + 4) = v14;
          result[3] = v15;
          result[4] = v13;
          *(void *)a4 = result;
          *(void *)(a4 + 8) = swift::TypeLookupError::TypeLookupError<swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1}>(swift::TypeLookupError swift::TypeLookupErrorImpl<int,unsigned int,int,char const*,unsigned long>(char const*,int,unsigned int,int,char const*,unsigned long)::{lambda(void)#1} const&)::{lambda(void *,swift::TypeLookupError::Command,void *)#1}::__invoke;
          uint64_t v26 = 1;
          goto LABEL_81;
        }

        a2 = *(const char **)a2;
LABEL_51:
        uint64_t v27 = *(const char **)a2;
        if (v59 == 1)
        {
          uint64_t v30 = v57;
          uint64_t v31 = v58;
          *(void *)(a4 + 8) = v58;
          Swift::Int_optional result = (void *)v31(v30, 2LL, 0LL);
          uint64_t v32 = 0;
          *(void *)a4 = result;
          *(_BYTE *)(a4 + 16) = 1;
          goto LABEL_77;
        }

        if (v59) {
          uint64_t v33 = 0LL;
        }
        else {
          uint64_t v33 = v57;
        }
        if (!result) {
          goto LABEL_74;
        }
        uint64_t v36 = result;
        uint64_t v37 = 0LL;
        uint64_t v53 = (const void *)(v10 + 16);
        break;
      default:
        goto LABEL_48;
    }

    do
    {
      uint64_t v38 = (*v6)[11];
      if ((*v6)[10] == v38) {
        swift::fatalError(0LL, "advancePackExpansion() without beginPackExpansion()\n", v34, v35);
      }
      *(void *)(v38 - 8) = v37;
      uint64_t v39 = v56;
      if (v56 == 1)
      {
        uint64_t v40 = v54;
        uint64_t v41 = v55;
        *(void *)(a4 + 8) = v55;
        Swift::Int_optional result = (void *)v41(v40, 2LL, 0LL);
        *(void *)a4 = result;
        *(_BYTE *)(a4 + 16) = 1;
      }

      else
      {
        uint64_t v42 = v54;
        if (v56) {
          uint64_t v42 = 0LL;
        }
        *(void *)(v4 + 16) = v42;
        uint64_t v43 = *(unsigned int *)(v10 + 8);
        uint64_t v44 = *(void *)v10;
        uint64_t v45 = (_OWORD *)v4;
        if (v43 >= *(_DWORD *)(v10 + 12))
        {
          uint64_t v48 = v43 + 1;
          if (v44 <= v4 && v44 + 32 * v43 > v4)
          {
            uint64_t v52 = v4 - v44;
            Swift::Int_optional result = __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v53, v48, 32LL);
            uint64_t v44 = *(void *)v10;
            uint64_t v45 = (_OWORD *)(*(void *)v10 + v52);
          }

          else
          {
            Swift::Int_optional result = __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(v10, v53, v48, 32LL);
            uint64_t v44 = *(void *)v10;
            uint64_t v45 = (_OWORD *)v4;
          }
        }

        uint64_t v46 = (_OWORD *)(v44 + 32LL * *(unsigned int *)(v10 + 8));
        uint64_t v47 = v45[1];
        char *v46 = *v45;
        v46[1] = v47;
        ++*(_DWORD *)(v10 + 8);
      }

      if (v56 == 1) {
        Swift::Int_optional result = (void *)v55(v54, 3LL, 0LL);
      }
      if (v39 == 1)
      {
        uint64_t v32 = 0;
        goto LABEL_77;
      }

      uint64_t v37 = (void *)((char *)v37 + 1);
    }

    while (v36 != v37);
LABEL_74:
    uint64_t v49 = (*v6)[11];
    if ((*v6)[10] == v49) {
      swift::fatalError(0LL, "endPackExpansion() without beginPackExpansion()\n", v34, v35);
    }
    (*v6)[11] = v49 - 16;
    uint64_t v32 = 1;
LABEL_77:
    if (v59 == 1) {
      Swift::Int_optional result = (void *)v58(v57, 3LL, 0LL);
    }
    if ((v32 & 1) == 0) {
      return result;
    }
LABEL_80:
    uint64_t v26 = 0;
    *(_BYTE *)a4 = 0;
LABEL_81:
    *(_BYTE *)(a4 + 16) = v26;
  }

  else
  {
    uint64_t v17 = v59;
    if (v59 == 1)
    {
      uint64_t v18 = v57;
      uint64_t v19 = v58;
      *(void *)(a4 + 8) = v58;
      Swift::Int_optional result = (void *)v19(v18, 2LL, 0LL);
      *(void *)a4 = result;
      *(_BYTE *)(a4 + 16) = 1;
    }

    else
    {
      uint64_t v21 = v57;
      if (v59) {
        uint64_t v21 = 0LL;
      }
      *(void *)(v4 + 16) = v21;
      uint64_t v22 = *(unsigned int *)(v10 + 8);
      uint64_t v23 = *(void *)v10;
      if (v22 >= *(_DWORD *)(v10 + 12))
      {
        uint64_t v50 = v22 + 1;
        if (v23 <= v4 && v23 + 32 * v22 > v4)
        {
          char v51 = v4 - v23;
          Swift::Int_optional result = __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod( v10,  (const void *)(v10 + 16),  v50,  32LL);
          uint64_t v23 = *(void *)v10;
          uint64_t v4 = *(void *)v10 + v51;
        }

        else
        {
          Swift::Int_optional result = __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod( v10,  (const void *)(v10 + 16),  v50,  32LL);
          uint64_t v23 = *(void *)v10;
        }
      }

      uint64_t v24 = (_OWORD *)(v23 + 32LL * *(unsigned int *)(v10 + 8));
      uint64_t v25 = *(_OWORD *)(v4 + 16);
      *uint64_t v24 = *(_OWORD *)v4;
      v24[1] = v25;
      ++*(_DWORD *)(v10 + 8);
    }

    if (v59 == 1) {
      Swift::Int_optional result = (void *)v58(v57, 3LL, 0LL);
    }
    if (v17 != 1) {
      goto LABEL_80;
    }
  }

  return result;
}

  *(_DWORD *)(v4 + 12736) = v9 + 1;
  v11[v9] = 113;
LABEL_27:
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  return this;
}

  uint64_t v19 = ***((_BYTE ***)v15 + 1);
  uint64_t v20 = *((_DWORD *)this + 3184);
  uint64_t v21 = *((unsigned int *)this + 3185);
  uint64_t v22 = this[1591];
  uint64_t v23 = this[1593];
  uint64_t v24 = (char *)*((void *)v23 + 1);
  if (&v22[v21] != v24)
  {
    uint64_t v25 = *((void *)v23 + 2);
LABEL_31:
    LODWORD(v27) = 2 * v21;
    else {
      uint64_t v27 = v27;
    }
    uint64_t v34 = v27;
    uint64_t v28 = v27 + v21;
    if (!v24 || (unint64_t)&v24[v28] > v25)
    {
      uint64_t v29 = 2LL * *((void *)v23 + 4);
      if (v29 <= v28 + 1) {
        uint64_t v29 = v28 + 1;
      }
      *((void *)v23 + 4) = v29;
      uint64_t v33 = v19;
      uint64_t v30 = v29 + 8;
      Swift::Int_optional result = (uint64_t *)malloc(v29 + 8);
      *Swift::Int_optional result = *((void *)v23 + 3);
      uint64_t v24 = (char *)(result + 1);
      uint64_t v31 = (char *)result + v30;
      uint64_t v19 = v33;
      *((void *)v23 + 2) = v31;
      *((void *)v23 + 3) = result;
    }

    *((void *)v23 + 1) = &v24[v28];
    if ((_DWORD)v21)
    {
      Swift::Int_optional result = (uint64_t *)memcpy(v24, this[1591], v21);
      LODWORD(v21) = *((_DWORD *)this + 3185);
      uint64_t v20 = *((_DWORD *)this + 3184);
    }

    uint64_t v32 = v34;
    this[1591] = v24;
    uint64_t v22 = v24;
    goto LABEL_43;
  }

  uint64_t v26 = (unint64_t)&v22[v21 + 1];
  uint64_t v25 = *((void *)v23 + 2);
  if (v26 > v25) {
    goto LABEL_31;
  }
  *((void *)v23 + 1) = v26;
  uint64_t v32 = 1;
LABEL_43:
  *((_DWORD *)this + 3185) = v21 + v32;
LABEL_44:
  *((_DWORD *)this + 3184) = v20 + 1;
  v22[v20] = v19;
  if (*((_BYTE *)a2 + 18) != 5) {
    goto LABEL_50;
  }
  if (*((_DWORD *)a2 + 2) >= 3u)
  {
    if (*(_DWORD *)a4) {
      return result;
    }
    if (*((_BYTE *)a2 + 18) != 5) {
      goto LABEL_50;
    }
  }

  if (*((_DWORD *)a2 + 2) < 4u
  {
LABEL_50:
    *(_DWORD *)a4 = 0;
    a4[1] = 0LL;
    *((_DWORD *)a4 + 4) = 0;
  }

  return result;
}

  *((_DWORD *)this + 3184) = v9 + 1;
  v11[v9] = 81;
  if (!v8)
  {
    uint64_t v26 = *((_DWORD *)this + 3184);
    uint64_t v27 = *((unsigned int *)this + 3185);
    uint64_t v28 = (char *)this[1591];
    if (v26 < v27)
    {
LABEL_77:
      *((_DWORD *)this + 3184) = v26 + 1;
      char v51 = 120;
LABEL_81:
      v28[v26] = v51;
      goto LABEL_82;
    }

    uint64_t v29 = this[1593];
    uint64_t v30 = (char *)v29[1];
    if (&v28[v27] == v30)
    {
      uint64_t v41 = (unint64_t)&v28[v27 + 1];
      uint64_t v31 = v29[2];
      if (v41 <= v31)
      {
        v29[1] = v41;
        LODWORD(v42) = 1;
LABEL_76:
        *((_DWORD *)this + 3185) = v27 + v42;
        goto LABEL_77;
      }
    }

    else
    {
      uint64_t v31 = v29[2];
    }

    else {
      uint64_t v42 = (2 * v27);
    }
    uint64_t v43 = v42 + v27;
    if (!v30 || (unint64_t)&v30[v43] > v31)
    {
      uint64_t v44 = 2LL * v29[4];
      if (v44 <= v43 + 1) {
        uint64_t v44 = v43 + 1;
      }
      void v29[4] = v44;
      uint64_t v45 = v44 + 8;
      Swift::Int_optional result = malloc(v44 + 8);
      *Swift::Int_optional result = v29[3];
      uint64_t v30 = (char *)(result + 1);
      v29[2] = (char *)result + v45;
      v29[3] = result;
    }

    v29[1] = &v30[v43];
    if ((_DWORD)v27)
    {
      Swift::Int_optional result = memcpy(v30, this[1591], v27);
      LODWORD(v27) = *((_DWORD *)this + 3185);
      uint64_t v26 = *((_DWORD *)this + 3184);
    }

    this[1591] = v30;
    uint64_t v28 = v30;
    goto LABEL_76;
  }

LABEL_82:
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  {
    uint64_t v17 = *((unsigned __int8 *)v15 + 18);
    uint64_t v18 = (swift::Demangle::__runtime::Node **)v15;
    if ((v17 - 1) >= 2)
    {
      if (v17 == 5)
      {
        uint64_t v19 = *(swift::Demangle::__runtime::Node **)v15;
        uint64_t v18 = *(swift::Demangle::__runtime::Node ***)v15;
LABEL_35:
        uint64_t v20 = (swift::Demangle::__runtime::Node **)((char *)v19 + 8 * *((unsigned int *)v15 + 2));
        goto LABEL_41;
      }

      uint64_t v18 = 0LL;
    }

    switch(v17)
    {
      case 1:
        uint64_t v20 = (swift::Demangle::__runtime::Node **)((char *)v15 + 8);
        goto LABEL_41;
      case 2:
        uint64_t v20 = (swift::Demangle::__runtime::Node **)((char *)v15 + 16);
        goto LABEL_41;
      case 5:
        uint64_t v19 = *(swift::Demangle::__runtime::Node **)v15;
        goto LABEL_35;
    }

    uint64_t v20 = 0LL;
LABEL_41:
    while (v18 != v20)
    {
      if (*(_DWORD *)a4) {
        return result;
      }
      ++v18;
    }
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  Swift::Int_optional result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "Tn", 2uLL, this[1593]);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

  {
    uint64_t v17 = *((unsigned __int8 *)v15 + 18);
    uint64_t v18 = (swift::Demangle::__runtime::Node **)v15;
    if ((v17 - 1) >= 2)
    {
      if (v17 == 5)
      {
        uint64_t v19 = *(swift::Demangle::__runtime::Node **)v15;
        uint64_t v18 = *(swift::Demangle::__runtime::Node ***)v15;
LABEL_35:
        uint64_t v20 = (swift::Demangle::__runtime::Node **)((char *)v19 + 8 * *((unsigned int *)v15 + 2));
        goto LABEL_41;
      }

      uint64_t v18 = 0LL;
    }

    switch(v17)
    {
      case 1:
        uint64_t v20 = (swift::Demangle::__runtime::Node **)((char *)v15 + 8);
        goto LABEL_41;
      case 2:
        uint64_t v20 = (swift::Demangle::__runtime::Node **)((char *)v15 + 16);
        goto LABEL_41;
      case 5:
        uint64_t v19 = *(swift::Demangle::__runtime::Node **)v15;
        goto LABEL_35;
    }

    uint64_t v20 = 0LL;
LABEL_41:
    while (v18 != v20)
    {
      if (*(_DWORD *)a4) {
        return result;
      }
      ++v18;
    }
  }

  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  Swift::Int_optional result = (uint64_t *)swift::Demangle::__runtime::CharVector::append(this + 1591, "TN", 2uLL, this[1593]);
  *(_DWORD *)a4 = 0;
  *(void *)(a4 + 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
  return result;
}

    uint64_t v21 = v4;
    if (v20 >= 2) {
      uint64_t v21 = *(swift::Demangle::__runtime::Node **)v4;
    }
    uint64_t v18 = (swift::Demangle::__runtime::Node *)*((void *)v21 + i);
LABEL_11:
    swift::Demangle::__runtime::Node::addChild(Node, v18, this[5], v15, v16);
  }

  if ((_DWORD)v19 == 2 && i < 2) {
    goto LABEL_20;
  }
LABEL_29:
  uint64_t v4 = (swift::Demangle::__runtime::Node *)Node;
LABEL_30:
  uint64_t v22 = swift::Demangle::__runtime::NodeFactory::createNode(this[5], 235);
  uint64_t v23 = a3 + 1;
  uint64_t v24 = this[4];
  while (1)
  {
    if (v24)
    {
      uint64_t v25 = this[3];
      if (*(_BYTE *)v25 == 95) {
        break;
      }
    }

    if (v26)
    {
      uint64_t v27 = (swift::Demangle::__runtime::Node *)v26;
      uint64_t v28 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(this[5], 232);
      swift::Demangle::__runtime::Node::addChild(v28, v27, this[5], v29, v30);
      if (v28)
      {
        swift::Demangle::__runtime::Node::addChild( (unsigned int *)v22,  (swift::Demangle::__runtime::Node *)v28,  this[5],  v31,  v32);
        uint64_t v24 = this[4];
        if (v24) {
          continue;
        }
      }
    }

    return 0LL;
  }

  this[3] = (swift::Demangle::__runtime::NodeFactory *)((char *)v25 + 1);
  this[4] = (swift::Demangle::__runtime::NodeFactory *)((char *)v24 - 1);
  uint64_t v34 = *(unsigned __int8 *)(v22 + 18);
  if ((v34 - 1) < 2 || v34 == 5 && *(_DWORD *)(v22 + 8))
  {
    uint64_t v35 = (unsigned int *)swift::Demangle::__runtime::NodeFactory::createNode(this[5], 232);
    swift::Demangle::__runtime::Node::addChild(v35, v4, this[5], v36, v37);
    uint64_t v38 = *((unsigned __int16 *)v4 + 8);
    switch(v38)
    {
      case 24:
        uint64_t v39 = 13;
        break;
      case 61:
        uint64_t v39 = 14;
        break;
      case 219:
        uint64_t v39 = 15;
        break;
      default:
        return 0LL;
    }

    uint64_t v4 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(this[5], v39);
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v4,  (swift::Demangle::__runtime::Node *)v35,  this[5],  v40,  v41);
    swift::Demangle::__runtime::Node::addChild( (unsigned int *)v4,  (swift::Demangle::__runtime::Node *)v22,  this[5],  v42,  v43);
  }

  return v4;
}

  *(_DWORD *)(a1 + 12736) = v15 + 1;
  v17[v15] = 70;
  uint64_t v33 = (uint64_t *)v11;
  uint64_t v34 = a6 + 1;
  if (!*(_DWORD *)a7)
  {
    swift::Demangle::__runtime::CharVector::append(v39, v10, v9, *(void **)(a1 + 12744));
    uint64_t v35 = *(_WORD *)(*(void *)(v11 + 8) + 16LL) == 290
        ? (swift::Demangle::__runtime::Node **)applyParamLabels( *(swift::Demangle::__runtime::Node **)(v11 + 8),  *(swift::Demangle::__runtime::Node **)(v11 + 16),  *(swift::Demangle::__runtime::NodeFactory **)a1)
        : *(swift::Demangle::__runtime::Node ***)(v11 + 8);
    uint64_t v21 = *(_DWORD *)a7;
    if (!*(_DWORD *)a7)
    {
      uint64_t v22 = 0;
      uint64_t v11 = 0LL;
      goto LABEL_8;
    }
  }

  uint64_t v32 = v17 - 1;
  uint64_t v33 = v14;
  if (v32 >= 2) {
    uint64_t v33 = (void *)*v14;
  }
  uint64_t v34 = a7 + 1;
  if (!*(_DWORD *)a8)
  {
    swift::Demangle::__runtime::CharVector::append((char **)(a1 + 12728), v12, v11, *(void **)(a1 + 12744));
    __p = *(std::string *)(a6 + 8);
    *(void *)(a6 + 16) = 0LL;
    *(void *)(a6 + 24) = 0LL;
    *(void *)(a6 + 8) = 0LL;
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      if (!__p.__r_.__value_.__l.__size_) {
        goto LABEL_38;
      }
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }

    else
    {
      if (!__p.__r_.__value_.__s.__size_) {
        goto LABEL_38;
      }
      p_p = &__p;
    }

    if (p_p->__r_.__value_.__s.__data_[0] - 48 <= 9)
    {
      std::operator+<char>();
      __p = v60;
    }