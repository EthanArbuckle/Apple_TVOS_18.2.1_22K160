}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

  ;
}

void sub_100005C94(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100005CE0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100005CF0(uint64_t a1)
{
}

void sub_100005CF8(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v6 + 40);
  uint64_t v7 = CUDescriptionWithLevel(a3, 30LL);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  NSAppendPrintF_safe(&obj, "%@\n", v8);
  objc_storeStrong((id *)(v6 + 40), obj);

  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
}

void sub_100005DAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100006034(uint64_t a1, void *a2)
{
  id v3 = a2;
  v4 = *(void **)(a1 + 48);
  id v7 = v3;
  if (!v4)
  {
    v5 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    uint64_t v6 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v5;

    v4 = *(void **)(a1 + 48);
    id v3 = v7;
  }

  [v4 addObject:v3];
  if (!*(_BYTE *)(a1 + 56))
  {
    if (dword_1008D5E28 <= 30
      && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5E28,  "void CBStackDeviceMonitorCPP::addMonitor(CBStackDeviceMonitorBTStack * _Nonnull __strong)",  30LL,  "Add listeners");
    }

    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_10087EE38);
    }
    sub_1003AE390(off_1008D5F38, a1);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_10087EE58);
    }
    sub_10000876C((uint64_t)off_1008D5F48 + 240, a1 + 8);
    if (qword_1008D5F00 != -1) {
      dispatch_once(&qword_1008D5F00, &stru_10087EDB8);
    }
    sub_100008BE0((uint64_t)off_1008D5EF8 + 64, a1 + 16);
    if (qword_1008D5F60 != -1) {
      dispatch_once(&qword_1008D5F60, &stru_10087EE78);
    }
    sub_100008EA4(qword_1008D5F58 + 40, a1 + 24);
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_10087EDD8);
    }
    sub_100594810((uint64_t)off_1008D5F08, a1 + 32, 0);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_10087EE18);
    }
    sub_1005DC2BC((uint64_t)off_1008D5F28, a1 + 40);
    *(_BYTE *)(a1 + 56) = 1;
  }
}

void sub_100006258( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_10000626C(uint64_t a1)
{
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL))) {
    LogPrintF_safe( &dword_1008D5E28,  "-[CBStackDeviceMonitorBTStack activate]_block_invoke",  30LL,  "Accessory power changed (coalesced)");
  }
  return [*(id *)(a1 + 32) updateDevices];
}

id sub_1000062DC(uint64_t a1)
{
  if (dword_1008D5E28 <= 20 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 20LL))) {
    LogPrintF_safe( &dword_1008D5E28,  "-[CBStackDeviceMonitorBTStack activate]_block_invoke_2",  20LL,  "Accessory power changed (raw)");
  }
  return [*(id *)(*(void *)(a1 + 32) + 32) trigger];
}

void sub_100006448(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_msgSend(*(id *)(a1 + 48), "removeObject:");
  if (*(_BYTE *)(a1 + 56) && ![*(id *)(a1 + 48) count])
  {
    if (dword_1008D5E28 <= 30
      && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5E28,  "void CBStackDeviceMonitorCPP::removeMonitor(CBStackDeviceMonitorBTStack * _Nonnull __strong)",  30LL,  "Remove listeners");
    }

    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_10087EE38);
    }
    sub_1003AE4C8((uint64_t)off_1008D5F38, a1);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_10087EE58);
    }
    sub_100009168((uint64_t)off_1008D5F48 + 240, a1 + 8);
    if (qword_1008D5F00 != -1) {
      dispatch_once(&qword_1008D5F00, &stru_10087EDB8);
    }
    sub_100009168((uint64_t)off_1008D5EF8 + 64, a1 + 16);
    if (qword_1008D5F60 != -1) {
      dispatch_once(&qword_1008D5F60, &stru_10087EE78);
    }
    sub_100009168(qword_1008D5F58 + 40, a1 + 24);
    *(_BYTE *)(a1 + 56) = 0;
  }
}

void sub_1000065D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1000066C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

LABEL_16:
      -[CBStackDeviceMonitorBTStack updateDevices](self, "updateDevices");
    }
  }

  if (self->_wifiCriticalOverride) {
    v16 = self->_wifiCriticalOverride == 1;
  }
  else {
    v16 = (-[CUSystemMonitor wifiFlags](self->_systemMonitor, "wifiFlags") >> 8) & 1;
  }
  if (v16 != self->_wifiCritical)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v17 = "no";
      if (v16) {
        v18 = "no";
      }
      else {
        v18 = "yes";
      }
      if (v16) {
        v17 = "yes";
      }
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _update]", 30LL, "WiFi critical changed: %s -> %s", v18, v17);
    }

    self->_wifiCritical = v16;
    bleDiscoveryArray = self->_bleDiscoveryArray;
    self->_bleDiscoveryArray = 0LL;
  }

  if (-[CBDaemonServer _identitiesShouldRun](self, "_identitiesShouldRun")) {
    -[CBDaemonServer _identitiesEnsureStarted](self, "_identitiesEnsureStarted");
  }
  else {
    -[CBDaemonServer _identitiesEnsureStopped](self, "_identitiesEnsureStopped");
  }
  v20 = -[CBDaemonServer _bleAdvertiserShouldRun](self, "_bleAdvertiserShouldRun");
  v21 = -[CBDaemonServer _stackBLEScannerShouldRun](self, "_stackBLEScannerShouldRun");
  v22 = v21;
  if ((v20 & 1) != 0 || !v21)
  {
    if (v20) {
      goto LABEL_36;
    }
  }

  else if (self->_stackBLEScannerNeedsAdvertisingAddress)
  {
LABEL_36:
    -[CBDaemonServer _bleAddressMonitorEnsureStarted](self, "_bleAddressMonitorEnsureStarted");
    goto LABEL_39;
  }

  -[CBDaemonServer _bleAddressMonitorEnsureStopped](self, "_bleAddressMonitorEnsureStopped");
LABEL_39:
  if (v20) {
    -[CBDaemonServer _bleAdvertiserEnsureStarted](self, "_bleAdvertiserEnsureStarted");
  }
  else {
    -[CBDaemonServer _bleAdvertiserEnsureStopped](self, "_bleAdvertiserEnsureStopped");
  }
  if (-[CBDaemonServer _stackAccessoryMonitorShouldRun](self, "_stackAccessoryMonitorShouldRun")) {
    -[CBDaemonServer _stackAccessoryMonitorEnsureStarted](self, "_stackAccessoryMonitorEnsureStarted");
  }
  else {
    -[CBDaemonServer _stackAccessoryMonitorEnsureStopped](self, "_stackAccessoryMonitorEnsureStopped");
  }
  if (v22) {
    -[CBDaemonServer _stackBLEScannerEnsureStarted](self, "_stackBLEScannerEnsureStarted");
  }
  else {
    -[CBDaemonServer _stackBLEScannerEnsureStopped](self, "_stackBLEScannerEnsureStopped");
  }
  if (-[CBDaemonServer _stackClassicScannerShouldRun](self, "_stackClassicScannerShouldRun")) {
    -[CBDaemonServer _stackClassicScannerEnsureStarted](self, "_stackClassicScannerEnsureStarted");
  }
  else {
    -[CBDaemonServer _stackClassicScannerEnsureStopped](self, "_stackClassicScannerEnsureStopped");
  }
  if (-[CBDaemonServer _stackDeviceMonitorShouldRun](self, "_stackDeviceMonitorShouldRun")) {
    -[CBDaemonServer _stackDeviceMonitorEnsureStarted](self, "_stackDeviceMonitorEnsureStarted");
  }
  else {
    -[CBDaemonServer _stackDeviceMonitorEnsureStopped](self, "_stackDeviceMonitorEnsureStopped");
  }
  if (self->_prefAccessoryDaemonEnabled) {
    -[CBDaemonServer _accessoryDaemonEnsureStarted](self, "_accessoryDaemonEnsureStarted");
  }
  else {
    -[CBDaemonServer _accessoryDaemonEnsureStopped](self, "_accessoryDaemonEnsureStopped");
  }
  v23 = -[CBDaemonServer _whbDiscoveryShouldRun](self, "_whbDiscoveryShouldRun");
  v24 = v23;
  if (self->_prefRemoteClientEnabled && (v23 & 1) != 0 || self->_prefRemoteServerEnabled) {
    -[CBDaemonServer _remoteEnsureStarted](self, "_remoteEnsureStarted");
  }
  else {
    -[CBDaemonServer _remoteEnsureStopped](self, "_remoteEnsureStopped");
  }
  if (v24) {
    -[CBDaemonServer _whbDiscoveryEnsureStarted](self, "_whbDiscoveryEnsureStarted");
  }
  else {
    -[CBDaemonServer _whbDiscoveryEnsureStopped](self, "_whbDiscoveryEnsureStopped");
  }
}
}

  return v10;
}

  sub_1001EF5E4((uint64_t)v37);
  if (a4) {
    sub_1000B1838(a2);
  }
  return v9;
}

  sub_1000A5EC0(a1, v3);
}

  *(_WORD *)v27 = bswap32(v6 - 7) >> 16;
  LOWORD(v22) = v6;
  return sub_10009CE80(a1, a2, (unsigned __int8 *)&v20);
}

    sub_1001EE2A0();
  }

  return v2;
}

  sub_1001EE2A0();
}

  v13 = 0LL;
  if (sub_10012ECBC((uint64_t *)&v13))
  {
    while (1)
    {
      v4 = v13;
      v5 = *((unsigned __int8 *)v13 + 124);
      if (v5 != 7)
      {
        *((_BYTE *)v13 + 124) = 7;
        id v7 = *((_DWORD *)v4 + 51);
        sub_100136880((uint64_t)v4);
        sub_1001AE924(0LL, (uint64_t)v13, 129LL, 0LL, 0LL);
        if (!v7)
        {
          sub_1001E6EB8((uint64_t)v13, 129LL);
          sub_1001E1B88((uint64_t)v13);
          sub_10012E320(v13);
        }

        goto LABEL_25;
      }

  LOBYTE(result) = sub_1001A6168(**(__int128 ***)(a2 + 24), *(char **)(a2 + 40), *(unsigned __int16 *)(a2 + 50), 0LL);
  if ((_BYTE)result)
  {
    v8 = *(_WORD *)(a2 + 32);
    v9 = **(__int128 ***)(a2 + 24);
    v12[0] = 1;
    v12[1] = v4;
    v13 = v8;
    v14 = 17;
    v10 = v12;
LABEL_19:
    LOBYTE(result) = sub_1001A6168(v9, v10, 5uLL, 0LL);
  }

  return result;
}

  v9 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read ID info", v10, v11, v12, v13, v14, v15, v16, v19);
    v17 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v9;
}

  v9 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read Encryption Info", v10, v11, v12, v13, v14, v15, v16, v19);
    v17 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v9;
}

    v11 = (os_log_s *)qword_1008F76F8;
    v15 = os_log_type_enabled((os_log_t)qword_1008F76F8, OS_LOG_TYPE_DEFAULT);
    v10 = 0LL;
    if (!v15) {
      goto LABEL_21;
    }
    v16 = 0;
    v13 = "BandSwitchManager: ---------- Switch from HRB in progress to ISM ----------";
    v14 = (uint8_t *)&v16;
    goto LABEL_20;
  }

  if (!v5) {
    goto LABEL_9;
  }
  result = 0LL;
  if (a2 <= 0x13 && ((1 << a2) & 0xC8000) != 0)
  {
    id v7 = (os_log_s *)qword_1008F76F8;
    if (os_log_type_enabled((os_log_t)qword_1008F76F8, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 0;
      v8 = "BandSwitchManager: ---------- Change from HRB to HRB ----------";
      v9 = (uint8_t *)&v18;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, v9, 2u);
      goto LABEL_12;
    }

    goto LABEL_12;
  }

  return result;
}

      v17 = a2 + 152 * v8;
      if ((unint64_t)v7 >= *v9)
      {
        v25 = *(void *)(a1 + 24);
        v26 = 0x86BCA1AF286BCA1BLL * ((uint64_t)&v7[-v25] >> 3);
        v27 = v26 + 1;
        if (v26 + 1 > 0x1AF286BCA1AF286LL) {
          abort();
        }
        if (0xD79435E50D79436LL * ((*v9 - v25) >> 3) > v27) {
          v27 = 0xD79435E50D79436LL * ((*v9 - v25) >> 3);
        }
        if (0x86BCA1AF286BCA1BLL * ((*v9 - v25) >> 3) >= 0xD79435E50D7943LL) {
          v28 = 0x1AF286BCA1AF286LL;
        }
        else {
          v28 = v27;
        }
        if (v28) {
          v29 = (char *)sub_100266944(a1 + 40, v28);
        }
        else {
          v29 = 0LL;
        }
        v30 = &v29[152 * v26];
        v31 = *(_OWORD *)(v17 + 16);
        *(_OWORD *)v30 = *(_OWORD *)v17;
        *((_OWORD *)v30 + 1) = v31;
        v32 = *(_OWORD *)(v17 + 32);
        v33 = *(_OWORD *)(v17 + 48);
        v34 = *(_OWORD *)(v17 + 80);
        *((_OWORD *)v30 + 4) = *(_OWORD *)(v17 + 64);
        *((_OWORD *)v30 + 5) = v34;
        *((_OWORD *)v30 + 2) = v32;
        *((_OWORD *)v30 + 3) = v33;
        v35 = *(_OWORD *)(v17 + 96);
        v36 = *(_OWORD *)(v17 + 112);
        v37 = *(_OWORD *)(v17 + 128);
        *((void *)v30 + 18) = *(void *)(v17 + 144);
        *((_OWORD *)v30 + 7) = v36;
        *((_OWORD *)v30 + 8) = v37;
        *((_OWORD *)v30 + 6) = v35;
        v39 = *(char **)(a1 + 24);
        v38 = *(char **)(a1 + 32);
        v40 = v30;
        if (v38 != v39)
        {
          do
          {
            v41 = *(_OWORD *)(v38 - 152);
            *(_OWORD *)(v40 - 136) = *(_OWORD *)(v38 - 136);
            *(_OWORD *)(v40 - 152) = v41;
            v42 = *(_OWORD *)(v38 - 120);
            v43 = *(_OWORD *)(v38 - 104);
            v44 = *(_OWORD *)(v38 - 88);
            *(_OWORD *)(v40 - 72) = *(_OWORD *)(v38 - 72);
            *(_OWORD *)(v40 - 88) = v44;
            *(_OWORD *)(v40 - 104) = v43;
            *(_OWORD *)(v40 - 120) = v42;
            v45 = *(_OWORD *)(v38 - 56);
            v46 = *(_OWORD *)(v38 - 40);
            v47 = *(_OWORD *)(v38 - 24);
            *((void *)v40 - 1) = *((void *)v38 - 1);
            *(_OWORD *)(v40 - 24) = v47;
            *(_OWORD *)(v40 - 40) = v46;
            *(_OWORD *)(v40 - 56) = v45;
            v40 -= 152;
            v38 -= 152;
          }

          while (v38 != v39);
          v38 = *(char **)(a1 + 24);
        }

        id v7 = v30 + 152;
        *(void *)(a1 + 24) = v40;
        *(void *)(a1 + 32) = v30 + 152;
        *(void *)(a1 + 40) = &v29[152 * v28];
        if (v38) {
          operator delete(v38);
        }
      }

      else
      {
        v18 = *(_OWORD *)(v17 + 16);
        *(_OWORD *)id v7 = *(_OWORD *)v17;
        *((_OWORD *)v7 + 1) = v18;
        v19 = *(_OWORD *)(v17 + 32);
        v20 = *(_OWORD *)(v17 + 48);
        v21 = *(_OWORD *)(v17 + 80);
        *((_OWORD *)v7 + 4) = *(_OWORD *)(v17 + 64);
        *((_OWORD *)v7 + 5) = v21;
        *((_OWORD *)v7 + 2) = v19;
        *((_OWORD *)v7 + 3) = v20;
        v22 = *(_OWORD *)(v17 + 96);
        v23 = *(_OWORD *)(v17 + 112);
        v24 = *(_OWORD *)(v17 + 128);
        *((void *)v7 + 18) = *(void *)(v17 + 144);
        *((_OWORD *)v7 + 7) = v23;
        *((_OWORD *)v7 + 8) = v24;
        *((_OWORD *)v7 + 6) = v22;
        v7 += 152;
      }

      *(void *)(a1 + 32) = v7;
      ++v8;
    }

    while (v8 != v10);
  }

  sub_100264E70((_DWORD *)a1);
  return 1LL;
}
}
        }

        v13 = (void *)v5[1];
        if (v13)
        {
          do
          {
            v14 = v13;
            v13 = (void *)*v13;
          }

          while (v13);
        }

        else
        {
          do
          {
            v14 = (void *)v5[2];
            v15 = *v14 == (void)v5;
            v5 = v14;
          }

          while (!v15);
        }

        v5 = v14;
      }

      while (v14 != (void *)(a1 + 232));
    }

    if ([v3 count]) {
      [v2 setObject:v3 forKey:@"centralSessions"];
    }
    if ([v4 count]) {
      [v2 setObject:v4 forKey:@"peripheralSessions"];
    }
    v16 = [v2 count];
    v17 = (os_log_s *)qword_1008F7680;
    v18 = os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT);
    if (v16)
    {
      if (v18)
      {
        v19 = sub_100283A1C();
        v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
        v21 = (void *)objc_claimAutoreleasedReturnValue([v20 absoluteString]);
        *(_DWORD *)buf = 138412290;
        v30 = v21;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Writing restoration data to %@", buf, 0xCu);
      }

      v22 = sub_100283A1C();
      v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
      [v2 writeToURL:v23 error:0];
    }

    else
    {
      if (v18)
      {
        v24 = sub_100283A1C();
        v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
        v26 = (void *)objc_claimAutoreleasedReturnValue([v25 absoluteString]);
        *(_DWORD *)buf = 138412290;
        v30 = v26;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "No more restorable session data, removing restoration data at %@",  buf,  0xCu);
      }

      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      v27 = sub_100283A1C();
      v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
      [v23 removeItemAtURL:v28 error:0];
    }
  }
}

  if (v24 >= a4) {
    v24 = a4;
  }
  *(void *)(a1 + 224) = v24;
  v36 = sub_1002E6E00();
  sub_10002418C(buf, "HFP");
  sub_10002418C(__p, "Jitter");
  (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v36 + 88LL))(v36, buf, __p, a1 + 304);
  if (v45 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE3(v50) < 0) {
    operator delete(*(void **)buf);
  }
  v37 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    v38 = *(_DWORD *)(a1 + 216);
    v39 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
    v40 = *(void *)(a1 + 224);
    v41 = *(_DWORD *)(a1 + 304);
    sub_1002E6E9C();
    v42 = sub_1002CE214();
    *(_DWORD *)buf = 67110144;
    *(_DWORD *)&buf[4] = v38;
    v47 = 2048;
    v48 = v39;
    v49 = 2048;
    v50 = v40;
    v51 = 1024;
    v52 = v41;
    v53 = 1024;
    v54 = v42;
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "SendThread with codec type %d, interval %llu, buffer size %zu, jitter %d, spec-ErroneousData %d",  buf,  0x28u);
  }

  *(_DWORD *)(a1 + 220) = a6;
  *(void *)(a1 + 176) = sub_1002073BC((uint64_t)(v15 + 50));
  return a1;
}

  return v6;
}

  v9 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v10 = "YES";
    if (!byte_1008F00F0) {
      v10 = "NO";
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = v10;
    v15 = 1024;
    v16 = byte_1008F00F0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "support for ADV Buffering is %s (%d buffers)",  buf,  0x12u);
  }

  v11 = v4;
LABEL_23:

  return v11;
}

          ++v13;
        }
      }

      v9 = (void *)v3[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          v10 = (void *)v3[2];
          v11 = *v10 == (void)v3;
          id v3 = v10;
        }

        while (!v11);
      }

      id v3 = v10;
    }

    while (v10 != v4);
  }

        v10 += 8LL;
      }

      v17 = *(void **)(v8 + 8);
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (void *)*v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          v18 = *(void **)(v8 + 16);
          v19 = *v18 == v8;
          v8 = (uint64_t)v18;
        }

        while (!v19);
      }

      v8 = (uint64_t)v18;
      if (v18 != v41) {
        continue;
      }
      break;
    }
  }

  v21 = *(uint64_t **)(v42 + 88);
  v20 = *(uint64_t **)(v42 + 96);
  while (v21 != v20)
  {
    v8 = *v21;
    v22 = *(unsigned __int16 **)(*v21 + 120);
    if (v22 != *(unsigned __int16 **)(*v21 + 128))
    {
      v23 = -(uint64_t)v22;
      while (1)
      {
        *(void *)buf = 0LL;
        *(void *)&buf[8] = 0LL;
        uuid_copy(buf, (const unsigned __int8 *)v22 + 2);
        if (*v22 == (_DWORD)a2) {
          break;
        }
        v22 += 13;
        v23 -= 26LL;
        if (v22 == *(unsigned __int16 **)(v8 + 128))
        {
          v20 = *(uint64_t **)(v42 + 96);
          goto LABEL_30;
        }
      }

      v34 = sub_10024F00C();
      sub_100252278(v34, *v22);
      sub_10036B95C(26 - v23, *(void *)(v8 + 128), -v23);
      *(void *)(v8 + 128) = v35;
      if (v35 == *(void *)(v8 + 120))
      {
        if (!*(_BYTE *)(v8 + 4)) {
          sub_1003655CC(v42, v8);
        }
        v36 = *(uint64_t **)(v42 + 96);
        v37 = (char *)v36 - (char *)(v21 + 1);
        if (v36 != v21 + 1) {
          memmove(v21, v21 + 1, (char *)v36 - (char *)(v21 + 1));
        }
        *(void *)(v42 + 96) = (char *)v21 + v37;
        v38 = *(void **)(v8 + 120);
        if (v38)
        {
          *(void *)(v8 + 128) = v38;
          operator delete(v38);
        }

        goto LABEL_55;
      }

      return;
    }

        v10 += 8LL;
      }

      v17 = *(void **)(v8 + 8);
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (void *)*v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          v18 = *(void **)(v8 + 16);
          v19 = *v18 == v8;
          v8 = (uint64_t)v18;
        }

        while (!v19);
      }

      v8 = (uint64_t)v18;
      if (v18 != v41) {
        continue;
      }
      break;
    }
  }

  v21 = *(uint64_t **)(v42 + 88);
  v20 = *(uint64_t **)(v42 + 96);
  while (v21 != v20)
  {
    v8 = *v21;
    v22 = *(unsigned __int16 **)(*v21 + 120);
    if (v22 != *(unsigned __int16 **)(*v21 + 128))
    {
      v23 = -(uint64_t)v22;
      while (1)
      {
        *(void *)buf = 0LL;
        *(void *)&buf[8] = 0LL;
        uuid_copy(buf, (const unsigned __int8 *)v22 + 2);
        if (*v22 == (_DWORD)a2) {
          break;
        }
        v22 += 13;
        v23 -= 26LL;
        if (v22 == *(unsigned __int16 **)(v8 + 128))
        {
          v20 = *(uint64_t **)(v42 + 96);
          goto LABEL_30;
        }
      }

      v34 = sub_10024F00C();
      sub_100252278(v34, *v22);
      sub_10036B95C(26 - v23, *(void *)(v8 + 128), -v23);
      *(void *)(v8 + 128) = v35;
      if (v35 == *(void *)(v8 + 120))
      {
        if (!*(_BYTE *)(v8 + 4)) {
          sub_1003655CC(v42, v8);
        }
        v36 = *(uint64_t **)(v42 + 96);
        v37 = (char *)v36 - (char *)(v21 + 1);
        if (v36 != v21 + 1) {
          memmove(v21, v21 + 1, (char *)v36 - (char *)(v21 + 1));
        }
        *(void *)(v42 + 96) = (char *)v21 + v37;
        v38 = *(void **)(v8 + 120);
        if (v38)
        {
          *(void *)(v8 + 128) = v38;
          operator delete(v38);
        }

        goto LABEL_55;
      }

      return;
    }

  sub_100242F54((uint64_t)v14);
  sub_1003CA1D0(a1);
  return sub_100242FAC((uint64_t)v14);
}

    ;
  }

  return result;
}

  v43 = 0u;
  v44 = 0u;
  v42 = 0u;
  v41 = 0u;
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_100896DE8);
  }
  v12 = sub_10059A34C((uint64_t)off_1008D5F08);
  v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  v14 = [v13 countByEnumeratingWithState:&v41 objects:v48 count:16];
  if (!v14) {
    goto LABEL_80;
  }
  v15 = *(void *)v42;
  id obj = v13;
  while (2)
  {
    v16 = 0LL;
    do
    {
      if (*(void *)v42 != v15) {
        objc_enumerationMutation(obj);
      }
      v17 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)v16);
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100896E48);
      }
      v18 = off_1008D5F28;
      sub_10002418C(__p, "IsAppleWatch");
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100896E48);
      }
      if ((sub_1005CE518((uint64_t)off_1008D5F28, v17) & 1) != 0)
      {
LABEL_29:
        v19 = 1;
      }

      else
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_100896E48);
        }
        v21 = off_1008D5F28;
        sub_10002418C(v37, "A1603");
        if ((sub_1005CE5A8((uint64_t)v21, v17, (uint64_t)v37) & 1) != 0)
        {
          v19 = 1;
        }

        else
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_100896E48);
          }
          v22 = off_1008D5F28;
          sub_10002418C(v35, "A2051");
          if ((sub_1005CE5A8((uint64_t)v22, v17, (uint64_t)v35) & 1) != 0)
          {
            v19 = 1;
          }

          else
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_100896E48);
            }
            v23 = off_1008D5F28;
            sub_10002418C(v33, "A3085");
            if ((sub_1005CE5A8((uint64_t)v23, v17, (uint64_t)v33) & 1) != 0)
            {
              v19 = 1;
            }

            else
            {
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_100896E48);
              }
              v24 = off_1008D5F28;
              sub_10002418C(v31, "A2538");
              if ((sub_1005CE5A8((uint64_t)v24, v17, (uint64_t)v31) & 1) != 0)
              {
                v19 = 1;
              }

              else
              {
                if (qword_1008D5F30 != -1) {
                  dispatch_once(&qword_1008D5F30, &stru_100896E48);
                }
                sub_1005CF060((uint64_t)off_1008D5F28, v17, (uint64_t)&buf);
                v25 = *((void *)&buf + 1);
                if ((v50 & 0x80u) == 0) {
                  v25 = v50;
                }
                v19 = v25 != 0;
              }

              if (v32 < 0) {
                operator delete(v31[0]);
              }
            }

            if (v34 < 0) {
              operator delete(v33[0]);
            }
          }

          if (v36 < 0) {
            operator delete(v35[0]);
          }
        }

        if (v38 < 0) {
          operator delete(v37[0]);
        }
      }

      if (v40 < 0)
      {
        operator delete(__p[0]);
        if (v19) {
          goto LABEL_43;
        }
      }

      else if (v19)
      {
        goto LABEL_43;
      }

      if (v10 >= a4)
      {
        v27 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = a4;
          _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Warning: More than %zu classic and/or LE devices connected",  (uint8_t *)&buf,  0xCu);
        }

        v13 = obj;
        goto LABEL_80;
      }

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100896E48);
      }
      sub_1005CC0D4((uint64_t)off_1008D5F28, v17, (uint64_t)&buf);
      if ((v50 & 0x80u) == 0) {
        v20 = (const char *)&buf;
      }
      else {
        v20 = (const char *)buf;
      }
      strlcpy(&a2[248 * v10], v20, 0xF8uLL);
      ++v10;
LABEL_43:
      v16 = (char *)v16 + 1;
    }

    while (v14 != v16);
    v13 = obj;
    v26 = [obj countByEnumeratingWithState:&v41 objects:v48 count:16];
    v14 = v26;
    if (v26) {
      continue;
    }
    break;
  }

    v11 = 0LL;
    goto LABEL_17;
  }

  if ((*(unsigned int (**)(void *))(*a1 + 16LL))(a1) >= 2)
  {
    v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067C854(v8, v9, v10);
    }
  }

  v4 = (void *)a1[28];
  if (v4 == a1 + 29) {
    goto LABEL_16;
  }
LABEL_15:
  v11 = v4[4];
LABEL_17:
  sub_100242FAC((uint64_t)v13);
  return v11;
}

  if (*(_DWORD *)(v0 + 132) == 9)
  {
    id v3 = (os_log_s *)qword_1008F75D8;
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "RFCOMM channel update complete", buf, 2u);
      v0 = qword_1008F72C0;
    }

    *(_DWORD *)(v0 + 128) = 0;
LABEL_20:
    sub_100416100();
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008983A0);
  }
  v4 = off_1008D60A8;
  *(void *)buf = 0LL;
  v10 = 0LL;
  sub_100242F28((uint64_t)buf, (uint64_t)off_1008D60A8 + 224);
  v4[556] = v1;
  return sub_100242FAC((uint64_t)buf);
}
}

    dispatch_once(&qword_1008D60F0, &stru_10089A4F8);
    goto LABEL_14;
  }

  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10089A4F8);
  }
  v10 = off_1008D60E8;
  v11 = (void *)objc_claimAutoreleasedReturnValue(-[BTCloudSoundProfileRecord soundProfileData](v4, "soundProfileData"));
  sub_1004B3BB0((uint64_t)v10, v11);

LABEL_15:
}
}

          v9 = v10;
          break;
        default:
          v9 = 3306LL;
          break;
      }

      ++v7;
    }

    while (v7 < *(unsigned __int8 *)(a1 + 56));
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    if (!(_BYTE)v8) {
      goto LABEL_21;
    }
LABEL_23:
    v23 = sub_1000EA6F8(*(void *)(a1 + 48) + 128LL, *(unsigned __int8 *)(a1 + 57), v8, (uint64_t)&v29);
  }

  else
  {
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    LODWORD(v9) = 3301;
LABEL_21:
    v23 = sub_1000E93E8(*(void *)(a1 + 48) + 128LL, *(unsigned __int8 *)(a1 + 57), 19, v9);
  }

  if (v23 && os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR)) {
    sub_10068E738();
  }
  return sub_100242CD8(__p);
}

  sub_1003E4AB0((uint64_t)v10, 1);
  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_1008A0008);
  }
  sub_10053584C((uint64_t)off_1008D67B0, (unsigned __int8 *)v10, a3, 0);
  v39[0] = 0LL;
  v39[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A00C8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 1u, 0, 0LL, 0LL, (unsigned __int8 *)v39);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A00C8);
  }
  v12 = off_1008D5F28;
  v13 = sub_100241F94((const unsigned __int8 *)v39);
  v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
  *((_BYTE *)sub_1005C6AC0((uint64_t)v12, v14) + 161) = 1;

  memset(buf, 0, 24);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A00C8);
  }
  v15 = off_1008D5F28;
  v16 = sub_100241F94((const unsigned __int8 *)v39);
  v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  sub_1005CE910((uint64_t)v15, v17, (uint64_t *)buf);

  v30 = a1;
  v18 = *(_BYTE **)buf;
  if (*(_BYTE **)buf != &buf[8])
  {
    do
    {
      v19 = sub_1002E6D7C();
      v20 = v18 + 32;
      v21 = (*(uint64_t (**)(uint64_t, std::string *, _BYTE *))(*(void *)v19 + 792LL))(v19, v10, v18 + 32);
      v22 = (os_log_s *)qword_1008F75E0;
      if (v21)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
        {
          sub_1003CF00C((uint64_t)v10, __p);
          if (v32 >= 0) {
            v23 = __p;
          }
          else {
            v23 = (void **)__p[0];
          }
          *(_DWORD *)v35 = 136446466;
          v36 = v20;
          v37 = 2082;
          v38 = v23;
          _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Unable to set tag:%{public}s for valid classicDevice %{public}s after LE device paired",  v35,  0x16u);
LABEL_40:
          if (v32 < 0) {
            operator delete(__p[0]);
          }
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
      {
        sub_1003CF00C((uint64_t)v10, __p);
        if (v32 >= 0) {
          v24 = __p;
        }
        else {
          v24 = (void **)__p[0];
        }
        *(_DWORD *)v35 = 136446466;
        v36 = v20;
        v37 = 2082;
        v38 = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Set tag:%{public}s for valid classicDevice %{public}s after LE device paired",  v35,  0x16u);
        goto LABEL_40;
      }

      v25 = (void *)*((void *)v18 + 1);
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = (void *)*v25;
        }

        while (v25);
      }

      else
      {
        do
        {
          v26 = (_BYTE *)*((void *)v18 + 2);
          v27 = *(void *)v26 == (void)v18;
          v18 = v26;
        }

        while (!v27);
      }

      v18 = v26;
    }

    while (v26 != &buf[8]);
  }

  __p[0] = 0LL;
  __p[1] = 0LL;
  sub_100242F28((uint64_t)__p, v30 + 48);
  v28 = *(void *)(v30 + 112);
  if (v28) {
    sub_100525DE8(v28, 0);
  }
  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_1008A0068);
  }
  sub_1003CA474((uint64_t)off_1008D67E0);
  sub_10052B470(v30, (unsigned __int8 *)v10, 0LL);
  sub_100242FAC((uint64_t)__p);
  sub_10023E78C((uint64_t)buf, *(char **)&buf[8]);
  return 0LL;
}

      v11 = v33;
      if (v33 >= (void *)v34)
      {
        v13 = ((char *)v33 - (_BYTE *)__p) >> 3;
        v14 = (v34 - (_BYTE *)__p) >> 2;
        if (v14 <= v13 + 1) {
          v14 = v13 + 1;
        }
        else {
          v15 = v14;
        }
        if (v15) {
          v16 = (char *)sub_100008BA0((uint64_t)&v34, v15);
        }
        else {
          v16 = 0LL;
        }
        v17 = &v16[8 * v13];
        *(void *)v17 = v10;
        v12 = v17 + 8;
        v19 = (char *)__p;
        v18 = (char *)v33;
        if (v33 != __p)
        {
          do
          {
            v20 = *((void *)v18 - 1);
            v18 -= 8;
            *((void *)v17 - 1) = v20;
            v17 -= 8;
          }

          while (v18 != v19);
          v18 = (char *)__p;
        }

        __p = v17;
        v33 = v12;
        v34 = &v16[8 * v15];
        if (v18) {
          operator delete(v18);
        }
      }

      else
      {
        *v33 = v10;
        v12 = v11 + 1;
      }

      v33 = v12;
      if (++v7 == v8) {
        goto LABEL_42;
      }
    }

    v10 = (char *)operator new(0x50uLL);
    *((_WORD *)v10 + 12) = *(_WORD *)v9;
    *((_DWORD *)v10 + 4) = 0;
    v10[20] = 0;
    *(void *)v10 = &off_1008A01E8;
    *((void *)v10 + 1) = v10 + 24;
LABEL_9:
    *((_WORD *)v10 + 13) = 0;
    *((_DWORD *)v10 + 11) = 0;
    *(_OWORD *)(v10 + 28) = v31;
LABEL_15:
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    goto LABEL_16;
  }

  v12 = 0LL;
LABEL_42:
  if (v12 == __p)
  {
    v21 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *(unsigned __int16 *)(a1 + 42);
      v23 = *(unsigned __int16 *)(a1 + 44);
      v24 = *(id *)(a1 + 16);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)&buf[4] = v22;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v23;
      *(_WORD *)&buf[14] = 2112;
      v36 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "No descriptors found in range [0x%04x, 0x%04x] on device %@",  buf,  0x18u);
    }
  }

  v25 = *(void **)(a1 + 24);
  v26 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)buf = v25;
  *(void *)&buf[8] = v26;
  if (v26)
  {
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      v28 = __ldxr(p_shared_owners);
    while (__stxr(v28 + 1, p_shared_owners));
  }

  sub_100442FB0(v25, (uint64_t **)&__p, *(_WORD *)(a1 + 42));
  v4 = 0LL;
  if (v26)
  {
    v29 = (unint64_t *)&v26->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  for (j = 0LL; j != 4; ++j)
  {
    size = a2->__r_.__value_.__s.__size_;
    if ((size & 0x80u) == 0LL) {
      v13 = a2;
    }
    else {
      v13 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if ((size & 0x80u) != 0LL) {
      size = a2->__r_.__value_.__l.__size_;
    }
    v14 = sub_1003DCD38(v13, (unsigned __int8 *)v13 + size, (unsigned __int8 *)&v21[j]);
    v15 = a2->__r_.__value_.__s.__size_;
    v16 = (char)v15;
    v17 = (char *)a2 + v15;
    if (v16 >= 0)
    {
      v18 = (std::string::size_type)a2;
    }

    else
    {
      v17 = (char *)(a2->__r_.__value_.__r.__words[0] + a2->__r_.__value_.__l.__size_);
      v18 = a2->__r_.__value_.__r.__words[0];
    }

    result = std::string::erase(a2, (std::string::size_type)&v14[-v18], v17 - (char *)v14);
  }

  return result;
}

    v19 = 0;
    id v7 = sub_1002E6E00();
    sub_10002418C(buf, "COEXDEBUG");
    sub_10002418C(__p, "wifiStateBand");
    v8 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, unsigned int *))(*(void *)v7 + 88LL))( v7,  buf,  __p,  &v19);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
    if (v24 < 0)
    {
      operator delete(*(void **)buf);
      if (!v8)
      {
LABEL_21:
        v18 = 0LL;
        v9 = sub_1002E6E00();
        sub_10002418C(buf, "COEXDEBUG");
        sub_10002418C(__p, "UCMWifiStateBitmap");
        v10 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t *))(*(void *)v9 + 144LL))( v9,  buf,  __p,  &v18);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
        if (v24 < 0) {
          operator delete(*(void **)buf);
        }
        if (v18) {
          v11 = v10;
        }
        else {
          v11 = 0;
        }
        if (v11 == 1) {
          atomic_store(1u, (unsigned __int8 *)(a1 + 18));
        }
        v17 = 0;
        v12 = sub_1002E6E00();
        sub_10002418C(buf, "COEXDEBUG");
        sub_10002418C(__p, "wifiStateCritical2_4");
        v13 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, unsigned __int8 *))(*(void *)v12 + 72LL))( v12,  buf,  __p,  &v17);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
        if (v24 < 0)
        {
          operator delete(*(void **)buf);
          if (!v13) {
            goto LABEL_35;
          }
        }

        else if (!v13)
        {
LABEL_35:
          v14 = atomic_load((unsigned __int8 *)(a1 + 18));
          goto LABEL_38;
        }

        atomic_store(v17, (unsigned __int8 *)(a1 + 18));
        goto LABEL_35;
      }
    }

    else if (!v8)
    {
      goto LABEL_21;
    }

    atomic_store(v19, (unsigned int *)(a1 + 96));
    goto LABEL_21;
  }

  v10 = sub_1002E6E9C();
  v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 2560LL))(v10);
  if (!(_DWORD)v11) {
    goto LABEL_23;
  }
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  v12 = sub_1005CE2FC((uint64_t)off_1008D5F28, v3);
  v13 = sub_1002E6BF0();
  v11 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 920LL))(v13);
  if ((_DWORD)v11
    && (v11 = _os_feature_enabled_impl("BluetoothFeatures", "EnableLEConnectionTxPowerBoost"), (_DWORD)v11))
  {
    v14 = 0;
  }

  else
  {
LABEL_23:
    v14 = 0;
  }

  v15 = sub_10058E47C(v11, v3);
  v16 = sub_10058DFD4(a1, v3);
  v40 = 0LL;
  v41[0] = 0LL;
  v41[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  sub_1005D7264((uint64_t)off_1008D5F28, v3, (uint64_t)&v40);
  v17 = v40;
  if (v40 != v41)
  {
    while (1)
    {
      v18 = v17[4];
      v19 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        v20 = sub_1005BFB9C(v18);
        v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
        *(_DWORD *)buf = 138544642;
        v43 = v3;
        v44 = 2114;
        v45 = (uint64_t)v21;
        v46 = 1024;
        *(_DWORD *)v47 = 0;
        *(_WORD *)&v47[4] = 1024;
        *(_DWORD *)&v47[6] = v16;
        v48 = 1024;
        v49 = v15;
        v50 = 1024;
        v51 = v38;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "device %{public}@ with address %{public}@ filter accept list options: conn_cmpt_option=%d, minRSSI=%d, PHYs=%x conn_scan_pri=%d waiting for controller to complete. ",  buf,  0x2Eu);
      }

      if ((a3 & 1) != 0 || (v15 & 4) != 0) {
        break;
      }
      if (v16)
      {
        if (*(_BYTE *)(a1 + 1118)) {
          v22 = 1;
        }
        else {
          v22 = v14;
        }
        if (((v22 | v38) & 1) != 0) {
          break;
        }
      }

      else if (v38 || v14)
      {
        break;
      }

        v8 = (void *)v3[1];
        if (v8)
        {
          do
          {
            v9 = v8;
            v8 = (void *)*v8;
          }

          while (v8);
        }

        else
        {
          do
          {
            v9 = (void *)v3[2];
            v10 = *v9 == (void)v3;
            id v3 = v9;
          }

          while (!v10);
        }

        id v3 = v9;
        if (v9 == (void *)(a1 + 2048)) {
          goto LABEL_25;
        }
      }

      uint64_t v6 = *(unsigned __int8 *)(v5 + 81);
      if (v6 != 16 && v6 != 32)
      {
        if (!sub_100610CCC(v5))
        {
LABEL_14:
          if (*(_BYTE *)(*(void *)(v3[5] + 8LL) + 272LL)) {
            v4 = 1;
          }
          goto LABEL_16;
        }

        v5 = v3[5];
      }

      id v7 = (void *)sub_100610E3C(v5);
      if (v7[1] != *v7 && (sub_100610C38(v3[5]) & 1) != 0) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }

void sub_1000069DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100006A20(id a1, NSString *a2, CBDevice *a3, BOOL *a4)
{
  v4 = a3;
  -[CBDevice setChangeFlags:](v4, "setChangeFlags:", 0LL);
  -[CBDevice setOldDiscoveryFlags:](v4, "setOldDiscoveryFlags:", -[CBDevice discoveryFlags](v4, "discoveryFlags"));
  -[CBDevice setDiscoveryFlags:]( v4,  "setDiscoveryFlags:",  (unint64_t)-[CBDevice discoveryFlags](v4, "discoveryFlags") & 0xFFFFFFFFFF5FFFFFLL);
}

void sub_100006A80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100006A94(uint64_t a1, void *a2, void *a3)
{
  id v12 = a2;
  id v5 = a3;
  unint64_t v6 = (unint64_t)[v5 changeFlags];
  unint64_t v7 = (unint64_t)[v5 oldDiscoveryFlags];
  unint64_t v8 = (unint64_t)[v5 discoveryFlags] ^ v7;
  if (v8) {
    v6 |= 0x800000000uLL;
  }
  unint64_t v9 = v6 | v8;
  objc_msgSend(v5, "setChangeFlags:", (unint64_t)objc_msgSend(v5, "changeFlags") | v9);
  if ((*(void *)(*(void *)(a1 + 32) + 64LL) & v9) != 0
    && (*(void *)(*(void *)(a1 + 32) + 64) & (unint64_t)[v5 discoveryFlags]) != 0)
  {
    if (dword_1008D5E28 <= 30
      && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5E28,  "-[CBStackDeviceMonitorBTStack updateDevices]_block_invoke_2",  30LL,  "Device found: %@",  v5,  v12);
    }

    id v10 = objc_retainBlock(*(id *)(*(void *)(a1 + 32) + 48LL));
    v11 = v10;
    if (v10) {
      (*((void (**)(id, id))v10 + 2))(v10, v5);
    }
  }

  else if (dword_1008D5E28 <= 10 {
         && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 10LL)))
  }
  {
    LogPrintF_safe( &dword_1008D5E28,  "-[CBStackDeviceMonitorBTStack updateDevices]_block_invoke_2",  10LL,  "Device found: %@, unchanged",  v5,  v12);
  }
}

void sub_100006C1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100006F18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100007230( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10000743C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100007474(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  if (!v2) {
    uint64_t v2 = *(void *)(a2 + 16);
  }
  *(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v2;
  return result;
}

void sub_1000076BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000079D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void (**a12)(void))
{
  _Unwind_Resume(a1);
}

void sub_100007A50(uint64_t a1)
{
}

void sub_100007A58(uint64_t a1)
{
}

void sub_100007A60(void *a1)
{
}

void sub_100007B24(uint64_t a1)
{
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL))) {
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::accessoryInEarStateChanged(BT::Device * _Nonnull)",  30LL,  "Device placement changed");
  }
  uint64_t v2 = sub_100404FE8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100008500;
  v3[3] = &unk_10087EB20;
  v3[4] = a1;
  sub_100405384(v2, v3);
}

void sub_100007BD4(uint64_t a1, uint64_t a2, int a3)
{
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL))) {
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::accessoryStreamStateChanged(BT::Device * _Nonnull, uint8_t)",  30LL,  "Audio stream state changed: %u",  a3);
  }
  uint64_t v5 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_100008500;
  v6[3] = &unk_10087EB20;
  v6[4] = a1;
  sub_100405384(v5, v6);
}

void sub_100007C90(uint64_t a1, uint64_t a2, int a3)
{
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
  {
    sub_1003CF00C(a2, __p);
    if (SHIBYTE(v9) >= 0) {
      unint64_t v6 = __p;
    }
    else {
      unint64_t v6 = (void **)__p[0];
    }
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::aclConnected(BT::Device * _Nonnull, BTResult)",  30LL,  "ACL connected: %s, result %d",  (const char *)v6,  a3);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v7 = sub_100404FE8();
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)3221225472LL;
  unint64_t v9 = sub_100008500;
  id v10 = &unk_10087EB20;
  uint64_t v11 = a1;
  sub_100405384(v7, __p);
}

void sub_100007D84( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100007DA0(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_100007DA8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
  {
    sub_1003CF00C(a2, __p);
    if (SHIBYTE(v11) >= 0) {
      unint64_t v8 = __p;
    }
    else {
      unint64_t v8 = (void **)__p[0];
    }
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::aclDisconnected(BT::Device * _Nonnull, BTResult, BTResult)",  30LL,  "ACL disconnected: %s, result %d, reason %d",  (const char *)v8,  a3,  a4);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v9 = sub_100404FE8();
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)3221225472LL;
  uint64_t v11 = sub_100008500;
  id v12 = &unk_10087EB20;
  uint64_t v13 = a1;
  sub_100405384(v9, __p);
}

void sub_100007EAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100007EC8(uint64_t a1, uint64_t a2, int a3, int a4)
{
}

void sub_100007ED0(uint64_t a1, uint64_t a2, int a3)
{
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL))) {
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::deviceInfoChanged(BT::Device * _Nonnull, BT::DEVICE_INFO_CHANGED_TYPE)",  30LL,  "Device info changed: 0x%X",  a3);
  }
  uint64_t v5 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_100008500;
  v6[3] = &unk_10087EB20;
  v6[4] = a1;
  sub_100405384(v5, v6);
}

void sub_100007F88(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_100007F90(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue([v3 UUIDString]);
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::gapNameUpdated(NSUUID * _Nonnull __strong)",  30LL,  "GAP named updated: Device %@",  v4);
  }

  uint64_t v5 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_100008500;
  v6[3] = &unk_10087EB20;
  v6[4] = a1;
  sub_100405384(v5, v6);
}

void sub_10000806C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100008088(uint64_t a1, void *a2)
{
}

void sub_100008090(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue([v3 UUIDString]);
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::leDeviceInfoChanged(NSUUID * _Nonnull __strong, BT::LE_DEVICE_INFO_CHANGED_TYPE)",  30LL,  "leDeviceInfoChanged: Device %@",  v4);
  }

  uint64_t v5 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_100008500;
  v6[3] = &unk_10087EB20;
  v6[4] = a1;
  sub_100405384(v5, v6);
}

void sub_10000816C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100008188(uint64_t a1, void *a2)
{
}

void sub_100008190(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (dword_1008D5E28 <= 30 && (dword_1008D5E28 != -1 || _LogCategory_Initialize(&dword_1008D5E28, 30LL)))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue([v3 UUIDString]);
    LogPrintF_safe( &dword_1008D5E28,  "virtual void CBStackDeviceMonitorCPP::gattDeviceInitCompleted(NSUUID * _Nonnull __strong)",  30LL,  "GATT device init completed: Device %@",  v4);
  }

  uint64_t v5 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_100008500;
  v6[3] = &unk_10087EB20;
  v6[4] = a1;
  sub_100405384(v5, v6);
}

void sub_10000826C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100008288(uint64_t a1, void *a2)
{
}

void sub_100008290(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_1000082F8;
  v5[3] = &unk_10087EB68;
  v5[4] = a1;
  int v6 = a2;
  sub_100405384(v4, v5);
}

void sub_1000082F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1008D9E00);
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  id v3 = *(id *)(v2 + 48);
  id v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v12;
    do
    {
      for (i = 0LL; i != v4; i = (char *)i + 1)
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v3);
        }
        uint64_t v7 = *(void **)(*((void *)&v11 + 1) + 8LL * (void)i);
        unint64_t v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v7 dispatchQueue]);
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 3221225472LL;
        v9[2] = sub_100008488;
        v9[3] = &unk_10087EB48;
        v9[4] = v7;
        int v10 = *(_DWORD *)(a1 + 40);
        dispatch_async(v8, v9);
      }

      id v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }

    while (v4);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1008D9E00);
}

void sub_100008468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100008488(uint64_t a1)
{
  return [*(id *)(a1 + 32) localDeviceEvent:*(unsigned int *)(a1 + 40)];
}

void sub_100008498(uint64_t a1, int a2)
{
  uint64_t v3 = a1 - 16;
  uint64_t v4 = sub_100404FE8();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_1000082F8;
  v5[3] = &unk_10087EB68;
  v5[4] = v3;
  int v6 = a2;
  sub_100405384(v4, v5);
}

void sub_100008500(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1008D9E00);
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  id v2 = *(id *)(v1 + 48);
  id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v10;
    do
    {
      for (i = 0LL; i != v3; i = (char *)i + 1)
      {
        if (*(void *)v10 != v4) {
          objc_enumerationMutation(v2);
        }
        int v6 = *(void **)(*((void *)&v9 + 1) + 8LL * (void)i);
        uint64_t v7 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v6 dispatchQueue]);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_100008684;
        block[3] = &unk_10087EA48;
        block[4] = v6;
        dispatch_async(v7, block);
      }

      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }

    while (v3);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1008D9E00);
}

void sub_100008664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100008684(uint64_t a1)
{
  return [*(id *)(a1 + 32) updateDevices];
}

uint64_t sub_10000868C(uint64_t a1)
{
  return a1;
}

void sub_1000086B4(id *a1)
{
}

void sub_10000876C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_1000087F4(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_1000087F4(uint64_t a1, char *__src, char *a3)
{
  id v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    __int128 v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      v19 = 0LL;
    }
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        v23 = (char *)sub_100008BA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }

    *(void *)v20 = *(void *)v3;
    v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    __int128 v9 = __src + 8;
    __int128 v10 = v6 - 8;
    __int128 v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_1000089F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100008A30(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(char **)a1;
  uint64_t v5 = *(_BYTE **)(a1 + 8);
  unint64_t v6 = (v5 - v4) >> 3;
  if (v6 < (v3 - (uint64_t)v4) >> 3)
  {
    if (v5 == v4)
    {
      __int128 v11 = 0LL;
      uint64_t v9 = 8 * v6;
    }

    else
    {
      unint64_t v7 = (char *)sub_100008BA0(v2, v6);
      uint64_t v4 = *(char **)a1;
      uint64_t v8 = *(char **)(a1 + 8);
      uint64_t v9 = (uint64_t)&v7[8 * v6];
      __int128 v11 = &v7[8 * v10];
      if (v8 != *(char **)a1)
      {
        uint64_t v12 = v9;
        do
        {
          uint64_t v13 = *((void *)v8 - 1);
          v8 -= 8;
          *(void *)(v12 - 8) = v13;
          v12 -= 8LL;
        }

        while (v8 != v4);
        uint64_t v4 = *(char **)a1;
        goto LABEL_9;
      }
    }

    uint64_t v12 = v9;
LABEL_9:
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = v11;
    if (v4) {
      operator delete(v4);
    }
  }

char *sub_100008ADC(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    unint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }

    while (v8 != v6);
  }

  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    unint64_t v7 = *(char **)(a2 + 8);
  }

  *(void *)(a2 + 16) = v11 + v12;
  uint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void *sub_100008BA0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_100008BD4();
  }
  return operator new(8 * a2);
}

void sub_100008BD4()
{
}

void sub_100008BE0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_100008C68(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_100008C68(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      v19 = 0LL;
    }
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        v23 = (char *)sub_100008BA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }

    *(void *)v20 = *(void *)v3;
    v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_100008E6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100008EA4(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_100008F2C(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_100008F2C(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      v19 = 0LL;
    }
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        v23 = (char *)sub_100008BA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }

    *(void *)v20 = *(void *)v3;
    v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_100009130( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100009168(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 != v4)
  {
    int64_t v6 = v4 - (v5 + 8);
    if (v4 != v5 + 8) {
      memmove(v5, v5 + 8, v4 - (v5 + 8));
    }
    *(void *)(a1 + 16) = &v5[v6];
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_1000091F4(id a1)
{
  uint64_t v1 = operator new(0x2B0uLL);
  sub_10040749C((uint64_t)v1);
  off_1008D5EF8 = v1;
}

void sub_100009224(_Unwind_Exception *a1)
{
}

void sub_100009238(id a1)
{
  uint64_t v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_100009268(_Unwind_Exception *a1)
{
}

void sub_10000927C(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_1000092AC(_Unwind_Exception *a1)
{
}

void sub_1000092C0(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_1000092F0(_Unwind_Exception *a1)
{
}

void sub_100009304(id a1)
{
  uint64_t v1 = operator new(0x118uLL);
  sub_1003ADFF0((uint64_t)v1);
  off_1008D5F38 = v1;
}

void sub_100009334(_Unwind_Exception *a1)
{
}

void sub_100009348(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100009378(_Unwind_Exception *a1)
{
}

void sub_10000938C(id a1)
{
  uint64_t v1 = operator new(0x110uLL);
  sub_100551DD0();
  qword_1008D5F58 = (uint64_t)v1;
}

void sub_1000093BC(_Unwind_Exception *a1)
{
}

void sub_1000095B0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000095C8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000095D8(uint64_t a1)
{
}

void sub_1000095E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v3 + 40);
  uint64_t v4 = CUDescriptionWithLevel(a3, *(unsigned int *)(a1 + 40));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  NSAppendPrintF_safe(&obj, "%@\n", v5);
  objc_storeStrong((id *)(v3 + 40), obj);
}

id sub_10000978C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _screenOnChanged];
}

id sub_100009794(uint64_t a1)
{
  return [*(id *)(a1 + 32) _screenOnChanged];
}

LABEL_57:
LABEL_58:
          if (v17 == (id)++v20)
          {
            uint64_t v17 = [v15 countByEnumeratingWithState:&v48 objects:v52 count:16];
            if (v17) {
              goto LABEL_13;
            }
            goto LABEL_65;
          }
        }
      }

      v41 = 0;
      v39 = 0;
      v40 = 2;
      v45 = 82;
      v46 = 1;
      v47 = 78;
      v43 = 43;
      v44 = 1;
      v19 = @"FakeAccessoryID";
LABEL_65:

      HIDWORD(v36) = v41;
      BYTE1(v36) = v39;
      LOBYTE(v36) = v40;
      uint64_t v12 = (__CFString *)objc_claimAutoreleasedReturnValue( -[CBAccessoryDaemon diagnosticAccessoryFakeWithIdentifier:leftPercent:leftState:rightPercent:rightState:casePercent:caseState:lidClosed:obcMinutes:error:]( v38,  "diagnosticAccessoryFakeWithIdentifier:leftPercent:leftState:rightPercent:rightState:casePe rcent:caseState:lidClosed:obcMinutes:error:",  v19,  v47,  v46,  v45,  v44,  v43,  v36,  v37));
LABEL_66:
      int64_t v6 = v42;
    }
  }

  else if (a4)
  {
    v35 = CBErrorF(4294960591LL, "No input string");
    uint64_t v12 = 0LL;
    *a4 = (id)objc_claimAutoreleasedReturnValue(v35);
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  if (*(_WORD *)(qword_1008DD390 + 2042)) {
    return *(unsigned __int16 *)(qword_1008DD390 + 2042);
  }
  else {
    return 5LL;
  }
}

    v28 = sub_1000B17F4(v21 + 1LL);
    *(void *)&buf[8] = v28;
    if (v28)
    {
      *(_WORD *)&buf[16] = v21;
      memmove(v28, (const void *)(v13 + v19), v21);
      *(_BYTE *)(*(void *)&buf[8] + v21) = 0;
      v29 = v21 + v19;
      uint64_t v30 = (unsigned __int16)(v21 + v19);
      if (v30 < v11)
      {
        v31 = *(unsigned __int8 *)(v13 + (unsigned __int16)(v21 + v19));
        if (v31 == 61)
        {
          v32 = v30 + 1;
          if (v32 < v11 && *(_BYTE *)(v13 + v32) == 63)
          {
            *(_DWORD *)buf = 0;
            v29 += 2;
          }

          else
          {
LABEL_65:
            ++v29;
          }
        }

        else if (v31 == 63)
        {
          *(_DWORD *)buf = 1;
          goto LABEL_65;
        }
      }

      *(void *)&buf[24] = v13 + v29;
      v53 = *(unsigned __int8 **)&buf[24];
      v19 = (_WORD)v53 - v13;
      (*(void (**)(uint8_t *))a1)(buf);
      sub_1000B1838(*(void **)&buf[8]);
      *(_WORD *)&buf[16] = 0;
      goto LABEL_69;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Parse command failed - %!, continuing", v33, v34, v35, v36, v37, v38, v39, 106LL);
      v40 = (os_log_s *)sub_100086554(0);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        v41 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = v41;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0xFFFF;
        _os_log_error_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
      }
    }

    v44 = *(void (**)(uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(*(void *)(qword_1008DFDB0 + 24) + 104LL);
    v45 = sub_1000E4D84(v35, a1);
    v44(a3, v50, v21, v45, v17);
    return v17;
  }

  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
    v19 = 0;
LABEL_16:
    v20 = 0;
    LOBYTE(v17) = 24;
    goto LABEL_26;
  }

  v23 = *((_WORD *)a2 + 5);
  uint64_t v24 = *((_WORD *)a2 + 6);
  v19 = v23 - v24;
  if ((v23 - v24) > 0x3Eu)
  {
    v20 = 0;
    LOBYTE(v17) = -127;
    goto LABEL_26;
  }

  if ((_BYTE)v23 == (_BYTE)v24)
  {
    v19 = 0;
    LOBYTE(v17) = 0;
    v20 = 0;
    goto LABEL_26;
  }

  v39 = 0LL;
  v20 = 0;
  LOBYTE(v17) = 0;
  while (1)
  {
    if (*((_BYTE *)a2 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c",  4271,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    if (*((_BYTE *)a2 + 15)) {
      break;
    }
    v40 = *((unsigned __int16 *)a2 + 6);
    v41 = *a2;
    *((_WORD *)a2 + 6) = v40 + 1;
    v42 = *(unsigned __int8 *)(v41 + v40) >> 2;
    v43 = sub_1000E4C8C(v42, a1);
    *((_WORD *)v50 + v39) = sub_1000DB7D8(v43);
    if (!v43)
    {
      LOBYTE(v17) = 18;
LABEL_50:
      v19 = ++v39;
      v20 = v42;
      goto LABEL_51;
    }

    if (*(_BYTE *)(v43 + 134) != 3)
    {
      LOBYTE(v17) = 49;
      goto LABEL_50;
    }

    ++v39;
LABEL_51:
    if (v39 >= v19) {
      goto LABEL_26;
    }
  }

  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
LABEL_61:
  *((_BYTE *)a2 + 15) = 1;
  LOBYTE(v17) = 17;
  v19 = v39;
LABEL_26:
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"AVDT_Start_Ind\n\tTransaction=%d\n\tStreamHandles=",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  a3);
    v32 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      v33 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      v49 = v33;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  v34 = qword_1008DFDB0;
  if (*(unsigned __int8 *)(qword_1008DFDB0 + 103) | v17)
  {
    sub_1000DC0F4(a1, a3, (__int16 *)v50, v19, v20, v17);
    if (!(_BYTE)v17)
    {
      v34 = qword_1008DFDB0;
      goto LABEL_32;
    }
  }

  else
  {
LABEL_32:
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)(v34 + 24) + 96LL))(a3, v50, v19);
    LOBYTE(v17) = 0;
  }

  return v17;
}

          v32 = (uint64_t)v26;
          *(_DWORD *)(*(void *)(a3 + 16) + 24 * v25 + 16) = v30;
          v5 += 24;
          v33 = *(void *)(a3 + 16);
          v27 -= *(int *)(v33 + 24 * v25 + 16);
          if (v27 < v5)
          {
            *v101 = 1;
            *(_DWORD *)(*(void *)(a3 + 16) + 24 * v25 + 16) += (_DWORD)v27 - (_DWORD)v5;
            v33 = *(void *)(a3 + 16);
          }

          *(void *)(v33 + 24 * v25 + _Block_object_dispose((const void *)(v1 - 80), 8) = v27;
          v34 = *(void *)(a3 + 16) + 24 * v25;
          v35 = *(_BYTE **)(v34 + 8);
          v36 = *(int *)(v34 + 16);
          if ((v31 & 1) != 0)
          {
            v37 = v6 - (unsigned __int16)v9;
            v38 = v36;
          }

          else
          {
            v39 = v10;
            sub_1001ED1C4(v32);
            uint64_t v10 = v39;
            v37 = 0;
            v38 = *(_DWORD *)(*(void *)(a3 + 16) + 24 * v25 + 16);
          }

          if (v37 >= v38)
          {
            if ((int)v36 >= 1)
            {
              v40 = (char *)(v99 + (unsigned __int16)v9);
              v41 = &v35[v36];
              do
              {
                v42 = *v40++;
                *v35++ = v42;
              }

              while (v35 < v41);
              v38 = *(_DWORD *)(*(void *)(a3 + 16) + 24 * v25 + 16);
            }

            uint64_t v9 = (v9 + v38);
          }

          else
          {
            uint64_t v10 = 1;
          }

          if (!*v101)
          {
            v26 = (const char *)v32;
            ++v25;
            unint64_t v7 = v99;
            continue;
          }

          break;
        }

        uint64_t v12 = v25 + 1;
        break;
      case 32:
        *(void *)(a3 + 16) = a4;
        if (v6 <= 6)
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
        }

        else if (v6 != 7)
        {
          uint64_t v10 = 0;
          uint64_t v24 = *(unsigned __int8 *)(v7 + 7);
          *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 80), 8) = v24;
          uint64_t v9 = 8LL;
          goto LABEL_111;
        }

        uint64_t v24 = *(unsigned __int8 *)(a3 + 8);
        uint64_t v10 = 1;
LABEL_111:
        if (!v24) {
          goto LABEL_147;
        }
        v55 = 0LL;
        v98 = v6 - 1;
        v100 = v101;
        while (2)
        {
          if (v10)
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
LABEL_119:
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
            v56 = v9;
            goto LABEL_120;
          }

          *(_DWORD *)(*(void *)(a3 + 16) + 24 * v55) = bswap32(*(_DWORD *)(v7 + (unsigned __int16)v9));
          v56 = (v9 + 4);
          if (v98 <= (unsigned __int16)(v9 + 4))
          {
LABEL_120:
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
            v58 = 0;
            v57 = 0;
            uint64_t v10 = 1;
            uint64_t v9 = v56;
            goto LABEL_121;
          }

          *(_WORD *)(*(void *)(a3 + 16) + 24 * v55 + 4) = bswap32(*(unsigned __int16 *)(v7 + (unsigned __int16)(v9 + 4))) >> 16;
          if (v98 <= (unsigned __int16)(v9 + 6))
          {
            v58 = 0;
            v57 = 0;
            uint64_t v10 = 1;
            uint64_t v9 = (v9 + 6);
          }

          else
          {
            uint64_t v10 = 0;
            v57 = __rev16(*(unsigned __int16 *)(v7 + (unsigned __int16)(v9 + 6)));
            uint64_t v9 = (v9 + 8);
            v58 = 1;
          }

  v23 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionHomeTimeDurationFromStageOneToDisabledValue");
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v23 + 88LL))(v23, buf, __p, &v85);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v24) {
      goto LABEL_65;
    }
  }

  else if (!v24)
  {
    goto LABEL_65;
  }

  v25 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v85;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "LeConnectionHomeTimeDurationFromStageOneToDisabledValue=%d (override)",  buf,  8u);
  }

  *(_WORD *)(a1 + 15_Block_object_dispose((const void *)(v1 - 80), 8) = 32;
  v25 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "MaxConnPerBundleID");
  v26 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v25 + 88LL))(v25, buf, __p, __s);
  if (*(_DWORD *)__s) {
    v27 = v26;
  }
  else {
    v27 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v27) {
      goto LABEL_68;
    }
  }

  else if (!v27)
  {
    goto LABEL_68;
  }

  v28 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 15_Block_object_dispose((const void *)(v1 - 80), 8) = *(_WORD *)__s;
  v29 = (os_log_s *)qword_1008F7698;
  if (os_log_type_enabled((os_log_t)qword_1008F7698, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v28;
    _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding - MaxConnPerBundleID %d",  buf,  8u);
  }

LABEL_70:
  return v12;
}

    *(_DWORD *)((char *)a1 + 1_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
    goto LABEL_42;
  }

  return 0LL;
}

        uint64_t v9 = 0LL;
        uint64_t v13 = 8;
        goto LABEL_152;
      }

      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c",  1386,  "ByteStream_NumReadBytesAvail(bs) >= 1");
    default:
      unint64_t v14 = 0;
      goto LABEL_165;
  }

    v25 = *(void (***)(uint64_t, uint64_t, int *))(a2 + 80);
LABEL_72:
    if (!v25) {
      v25 = (void (**)(uint64_t, uint64_t, int *))qword_1008E2218;
    }
    if (v25)
    {
      v26 = *v25;
      if (v26) {
        v26(a1, a2, &dword_1008E223D);
      }
    }

    return;
  }

  if (!sub_10012D514(a2)) {
    sub_1001EE2A0();
  }
  uint64_t v9 = *(char *)(a2 + 152);
  if ((v9 & 0x80000000) == 0)
  {
    if (*(_BYTE *)(sub_1001EDBA0(0x28u) + 10) && (*(_BYTE *)(a2 + 152) & 0x7F) == 2)
    {
      if (dword_1008E2244)
      {
        if (!a3) {
          goto LABEL_30;
        }
LABEL_23:
        LODWORD(v40) = a3 - 1;
        v38 = &v39;
        v39 = a2;
        LOWORD(v37) = 16;
        sub_1001EE6E8( (uint64_t)sub_10011B7C4,  &v37,  (42949673 * (unint64_t)(*(unsigned __int16 *)(a2 + 136) + 99)) >> 32,  &dword_1008E2244);
        return;
      }

      v36 = a2;
      if (!sub_100128D24(42LL))
      {
        *(_BYTE *)(a2 + 152) |= 0x80u;
        if (a3) {
          goto LABEL_23;
        }
      }
    }

    sub_100657858();
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid periodic advertising sync established event packet size : %d, expecting %d",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v4);
    uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_38:
    }
      sub_100657858();
  }

        v63 = 1LL;
LABEL_71:
        sub_1001C4510((uint64_t)&v139, v63);
        return;
      }

      v93 = ccaes_siv_decrypt_mode();
      v94 = (unsigned __int16)ccsiv_plaintext_size(v93, *(unsigned __int8 *)(v14 + 268));
      v95 = sub_1000B17F4(v94);
      bzero(v95, v94);
      v96 = ccsiv_one_shot(v93, 32LL, v14 + 302, 0LL, 0LL, 0LL, 0LL, 54LL, v18, v95);
      if ((_DWORD)v96)
      {
        v97 = v96;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"ccsiv_one_shot returned %d", v98, v99, v100, v101, v102, v103, v104, v97);
          v105 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        goto LABEL_77;
      }

      *(_OWORD *)(v14 + 286) = *v95;
      if (*((void *)v95 + 2) != *(void *)(v14 + 28) || *((void *)v95 + 3) != *(void *)(v14 + 36))
      {
LABEL_77:
        sub_1000B1838(v95);
LABEL_78:
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Remote keys verification failed, sending error",  v115,  v116,  v117,  v118,  v119,  v120,  v121,  v138);
          v122 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        v63 = 7LL;
        goto LABEL_71;
      }

      v124 = *((_DWORD *)v95 + 8) != *(_DWORD *)(v14 + 1)
          || *((unsigned __int16 *)v95 + 18) != *(unsigned __int16 *)(v14 + 5);
      sub_1000B1838(v95);
      if (v124) {
        goto LABEL_78;
      }
      if (!sub_1001C4A08(v14))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Error generating AES_SIV", v129, v130, v131, v132, v133, v134, v135, v138);
          v136 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR)) {
            goto LABEL_69;
          }
        }

        goto LABEL_70;
      }

      v126 = (_OWORD *)(qword_1008ED850 + 44LL * *(unsigned __int8 *)(v14 + 269));
      v127 = *(_OWORD *)&v144[12];
      v128 = *(_OWORD *)v144;
      *v126 = v143;
      v126[1] = v128;
      *(_OWORD *)((char *)v126 + 2_Block_object_dispose((const void *)(v1 - 80), 8) = v127;
      sub_1001C4B9C(v14, v125);
      return;
    case 3u:
      v35 = 0LL;
      goto LABEL_44;
    case 4u:
      return;
    default:
      if (v6 == 255)
      {
        if (a3 < 3) {
          v36 = 1LL;
        }
        else {
          v36 = a2[2];
        }
        if (sub_1000A86F0())
        {
          v45 = sub_1001C3008(v36);
          sub_1001EE134( (uint64_t)"Received status %s(%d) from device %:",  v46,  v47,  v48,  v49,  v50,  v51,  v52,  (uint64_t)v45);
          v53 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            v54 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = v54;
            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        v35 = v36;
        goto LABEL_44;
      }

      if (v6 != 240)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Received unknown opcode %x", v37, v38, v39, v40, v41, v42, v43, *a2);
          v44 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        v35 = 3LL;
LABEL_44:
        sub_1001C476C((uint64_t)&v139, v35);
        return;
      }

      uint64_t v9 = sub_10012D890((uint64_t)&v139);
      sub_10018A690(v9);
      uint64_t v10 = sub_1001C33FC((uint64_t)&v139);
      if (v10)
      {
        *((_BYTE *)v10 + 334) = 1;
        sub_1001C3604((uint64_t)v10);
      }

      return;
  }

      uint64_t v15 = 0LL;
LABEL_71:
      if (SHIBYTE(v26) < 0) {
        operator delete((void *)v24.__r_.__value_.__l.__cap_);
      }
      return v15;
    case 17:
      *(_DWORD *)buf = 17;
      sub_10002418C(&v28[4], "hci cmd 0x2011 0x00 0x12 0x12 0x12 0xB0 0x68 0x43");
      uint64_t v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 18:
      *(_DWORD *)buf = 18;
      sub_10002418C( &v28[4],  "hci cmd 0x2006 0x20 0x03 0x20 0x03 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x07 0x00");
      uint64_t v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 19:
      *(_DWORD *)buf = 19;
      sub_10002418C(&v28[4], "hci cmd 0x2008 0x03 0x31 0x32 0x33");
      uint64_t v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 20:
      *(_DWORD *)buf = 20;
      sub_10002418C(&v28[4], "hci cmd 0x2024 0xFB 0x00 0x48 0x08");
      uint64_t v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 21:
      *(_DWORD *)buf = 21;
      sub_10002418C(&v28[4], "hci cmd 0x200A 0x01");
      uint64_t v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    case 22:
      *(_DWORD *)buf = 22;
      sub_10002418C(&v28[4], "hci cmd 0xFE45 0x01 0x01");
      uint64_t v30 = 0LL;
      sub_1001FAC6C((uint64_t *)(a1 + 40), (uint64_t)buf);
      goto LABEL_67;
    default:
      goto LABEL_70;
  }

          ++v47;
        }

        while (v47 != v46);
      }

      else
      {
        v48 = v44;
      }

            sub_10024EA0C((uint64_t)__p, v14 + 48, v15, v14);
            v43 = v42;
            for (j = a1[22]; j != v43; j -= 48LL)
            {
            }

            uint64_t v11 = 0LL;
            a1[22] = v43;
            goto LABEL_15;
          }
        }
      }

    abort();
  }

    v31 += 48LL;
    if (v31 == v32) {
      return sub_100242FAC((uint64_t)v57);
    }
  }

  if (memcmp(v35, v39, v34)) {
    goto LABEL_70;
  }
LABEL_72:
  v42 = (void *)*v56;
  if (!*v56) {
    goto LABEL_83;
  }
  v43 = *(void *)v31;
  v44 = a1 + 152;
  do
  {
    v45 = v42[4];
    v46 = v45 >= v43;
    if (v45 >= v43) {
      v47 = v42;
    }
    else {
      v47 = v42 + 1;
    }
    if (v46) {
      v44 = (uint64_t)v42;
    }
    v42 = (void *)*v47;
  }

  while (*v47);
  if ((uint64_t *)v44 != v56 && v43 >= *(void *)(v44 + 32))
  {
    v49 = sub_100246028( a1,  v43,  (void *)(v31 + 8),  *(_DWORD *)(v31 + 32),  *(_DWORD *)(v31 + 36),  *(_DWORD *)(v31 + 40),  *(unsigned __int8 *)(v31 + 44),  0,  0);
    v50 = **(void **)(v44 + 40);
    if (v50) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v50 + 24LL))(v50, v31 + 8, v49);
    }
  }

  else
  {
LABEL_83:
    v48 = (os_log_s *)qword_1008F75C8;
    if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_FAULT)) {
      sub_100662F54(a2, v33 >> 7, v48);
    }
  }

  sub_10024EA0C((uint64_t)buf, v31 + 48, *(void *)(a1 + 176), v31);
  v52 = v51;
  for (i = *(void *)(a1 + 176); i != v52; i -= 48LL)
  {
  }

  *(void *)(a1 + 176) = v52;
  return sub_100242FAC((uint64_t)v57);
}

      *(_BYTE *)(a1 + 351) = 0;
      goto LABEL_72;
    }

    memset(&__p, 0, sizeof(__p));
    uint64_t v12 = sub_1002E6B38();
    if ((*(unsigned int (**)(uint64_t, std::string *))(*(void *)v12 + 64LL))(v12, &__p))
    {
LABEL_40:
      uint64_t v13 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "43430B0", buf, 2u);
      }

      *(_WORD *)(a1 + 366) = 0;
      *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
      *(_BYTE *)(a1 + 339) = 0;
      *(_BYTE *)(a1 + 209) = 0;
      *(void *)(v2 + 65) = 0LL;
LABEL_43:
      goto LABEL_45;
    }

    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      unint64_t v14 = __p.__r_.__value_.__l.__size_;
      if (!__p.__r_.__value_.__l.__size_) {
        goto LABEL_40;
      }
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }

    else
    {
      unint64_t v14 = __p.__r_.__value_.__s.__size_;
      if (!__p.__r_.__value_.__s.__size_) {
        goto LABEL_40;
      }
      p_p = &__p;
    }

    if (v14 >= 2)
    {
      uint64_t v16 = (char *)p_p + v14;
      uint64_t v17 = p_p;
      while (1)
      {
        unint64_t v18 = (char *)memchr(v17, 66, v14 - 1);
        if (!v18) {
          break;
        }
        if (*(_WORD *)v18 == 12610)
        {
          v52 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "43430B1", buf, 2u);
          }

          *(_BYTE *)(a1 + 207) = 1;
          goto LABEL_43;
        }

        uint64_t v17 = (std::string *)(v18 + 1);
        unint64_t v14 = v16 - (char *)v17;
      }
    }

    goto LABEL_40;
  }

  if (v3 - 2000 <= 0x7CF)
  {
    *(_BYTE *)(a1 + 169) = 1;
    *(_BYTE *)(a1 + 176) = 1;
    *(_BYTE *)(a1 + 189) = 1;
    *(_BYTE *)(a1 + 197) = 1;
    *(_BYTE *)(a1 + 191) = 1;
    *(_WORD *)(a1 + 171) = 257;
    *(_BYTE *)(a1 + 209) = 1;
    *(_BYTE *)(a1 + 199) = 1;
    *(_BYTE *)(a1 + 180) = 1;
    *(_BYTE *)(a1 + 211) = 1;
    *(_BYTE *)(a1 + 220) = 1;
    *(_BYTE *)(a1 + 185) = 1;
    *(_BYTE *)(a1 + 259) = 1;
    *(_BYTE *)(a1 + 293) = 1;
    *(_BYTE *)(a1 + 315) = 1;
    *(_BYTE *)(a1 + 313) = 1;
    *(_BYTE *)(a1 + 327) = 1;
    *(_BYTE *)(a1 + 333) = 1;
    *(_BYTE *)(a1 + 323) = 1;
    *(_BYTE *)(a1 + 32_Block_object_dispose((const void *)(v1 - 80), 8) = 1;
    *(_BYTE *)(a1 + 340) = 1;
    *(_BYTE *)(a1 + 223) = 1;
    *(_BYTE *)(a1 + 344) = 1;
    *(_BYTE *)(a1 + 367) = 1;
    *(_WORD *)(a1 + 380) = 257;
    *(_BYTE *)(a1 + 256) = 1;
    *(_BYTE *)(a1 + 262) = 1;
    *(_WORD *)(a1 + 269) = 257;
    *(_DWORD *)(a1 + 214) = 16843009;
    *(_DWORD *)(v2 + 56) = 16843009;
    *(void *)(v2 + 65) = 0x101010101010101LL;
    if (v3 >= 0x7D1)
    {
      *(_BYTE *)(a1 + 25_Block_object_dispose((const void *)(v1 - 80), 8) = 1;
      *(_BYTE *)(a1 + 320) = 1;
      *(_BYTE *)(a1 + 390) = 1;
      *(_BYTE *)(a1 + 392) = 1;
      *(_BYTE *)(a1 + 413) = 1;
      *(_DWORD *)(a1 + 224) = 16843009;
      *(_DWORD *)(a1 + 384) = 16843009;
      if (sub_1002CE238())
      {
        *(_BYTE *)(a1 + 28_Block_object_dispose((const void *)(v1 - 80), 8) = 1;
        *(_BYTE *)(a1 + 291) = 1;
      }

      *(_WORD *)(a1 + 303) = 257;
      *(_WORD *)(a1 + 369) = 257;
      *(_BYTE *)(a1 + 394) = 1;
      *(_WORD *)(a1 + 419) = 257;
      *(_BYTE *)(a1 + 431) = 1;
      *(_BYTE *)(a1 + 426) = 1;
      *(_BYTE *)(a1 + 305) = 1;
      *(_BYTE *)(a1 + 404) = 1;
      *(_BYTE *)(a1 + 331) = 1;
      *(_BYTE *)(a1 + 349) = 1;
      *(_BYTE *)(a1 + 312) = 1;
      *(_WORD *)(a1 + 310) = 257;
      if (v3 >= 0x7D2)
      {
        *(_BYTE *)(a1 + 417) = 1;
        *(_BYTE *)(a1 + 437) = 1;
      }
    }

    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 2304LL))(a1)
      || (*(unsigned int (**)(uint64_t))(*(void *)a1 + 2456LL))(a1))
    {
      *(_BYTE *)(a1 + 279) = 1;
    }

    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 2456LL))(a1))
    {
      *(_BYTE *)(a1 + 285) = 1;
      *(_BYTE *)(a1 + 274) = 1;
      *(_WORD *)(a1 + 283) = 257;
      *(_WORD *)(a1 + 275) = 257;
    }
  }

      uint64_t v9 = (char *)v9 + 1;
    }

    while (v7 != v9);
    v43 = [obj countByEnumeratingWithState:&v59 objects:v71 count:16];
    unint64_t v7 = v43;
  }

  while (v43);
LABEL_84:

  v44 = (os_log_s *)qword_1008F7568;
  if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v52;
    _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "dispatchCrashLogsToAnalytics: Processed %d crash logs",  buf,  8u);
  }

  return v47;
}

    v45 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      v98 = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Dropping update of device %{public}@ as it is no longer subscribed",  buf,  0xCu);
    }

    goto LABEL_72;
  }

  for (j = *(const unsigned __int8 **)(a1 + 336); ; j += 20)
  {
    v42 = sub_100241F94(j);
    v43 = (void *)objc_claimAutoreleasedReturnValue(v42);
    v44 = [v43 isEqual:v25];

    if ((v44 & 1) != 0) {
      break;
    }
  }

  if (qword_1008D5F60 != -1) {
    dispatch_once(&qword_1008D5F60, &stru_100894690);
  }
  v50 = sub_100556DEC(qword_1008D5F58, a4);
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v51 = (id)objc_claimAutoreleasedReturnValue(v50);
  v52 = [v51 countByEnumeratingWithState:&v63 objects:v79 count:16];
  if (v52)
  {
    v53 = *(void *)v64;
    do
    {
      v54 = 0LL;
      do
      {
        if (*(void *)v64 != v53) {
          objc_enumerationMutation(v51);
        }
        v55 = *(void **)(*((void *)&v63 + 1) + 8LL * (void)v54);
        if (qword_1008D9278 != -1) {
          dispatch_once(&qword_1008D9278, &stru_100894670);
        }
        if (sub_100413550(qword_1008D9270, v55) && sub_100395D28((void *)a1, v55))
        {
          v56 = (os_log_s *)qword_1008F7628;
          if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            *(void *)&buf[4] = v55;
            _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "%{public}@ is already connected and has an existing service, firing event now",  buf,  0xCu);
          }

          if (qword_1008D67C8 != -1) {
            dispatch_once(&qword_1008D67C8, &stru_100894590);
          }
          sub_100287E84((uint64_t)off_1008D67C0, a2, a1, v55, 1u);
        }

        v54 = (char *)v54 + 1;
      }

      while (v52 != v54);
      v52 = [v51 countByEnumeratingWithState:&v63 objects:v79 count:16];
    }

    while (v52);
  }
}

      v40 = (void *)v52[0];
      goto LABEL_71;
    }

    if (buf[0])
    {
      if ((sub_10025FD88(&v50, (uint64_t)buf) & 1) != 0)
      {
        v37 = (unint64_t)a4[2];
        v38 = a4[1];
        if ((unint64_t)v38 >= v37)
        {
          v41 = ((char *)v38 - (_BYTE *)*a4) >> 4;
          v42 = v41 + 1;
          v43 = v37 - (void)*a4;
          if (v43 >> 3 > v42) {
            v42 = v43 >> 3;
          }
          else {
            v44 = v42;
          }
          if (v44) {
            v45 = (char *)sub_1003ADAF8((uint64_t)(a4 + 2), v44);
          }
          else {
            v45 = 0LL;
          }
          v46 = &v45[16 * v41];
          v47 = &v45[16 * v44];
          *(_OWORD *)v46 = v50;
          v39 = v46 + 16;
          v49 = (char *)*a4;
          v48 = (char *)a4[1];
          if (v48 != *a4)
          {
            do
            {
              *((_OWORD *)v46 - 1) = *((_OWORD *)v48 - 1);
              v46 -= 16;
              v48 -= 16;
            }

            while (v48 != v49);
            v48 = (char *)*a4;
          }

          *a4 = v46;
          a4[1] = v39;
          a4[2] = v47;
          if (v48) {
            operator delete(v48);
          }
        }

        else
        {
          *v38 = v50;
          v39 = v38 + 1;
        }

        a4[1] = v39;
        goto LABEL_70;
      }

      uint64_t v13 = (void *)v52[0];
    }

    v40 = v13;
LABEL_71:
    sub_10023BF24((uint64_t)&v51, v40);
    unint64_t v21 = 1LL;
    goto LABEL_25;
  }

        *(_BYTE *)(a2 + 1435) = v27;
        std::string::operator=((std::string *)(a2 + 1480), a4);
      }

      v79[0] = 0LL;
      v79[1] = 0LL;
      sub_100242F28((uint64_t)v79, (uint64_t)a1[13].i64);
      v46 = a1[19].u64[0];
      v47 = a1[17].i64[1];
      v48 = a1[18].i64[0];
      v49 = (void *)(v47 + 8 * (v46 / 0x66));
      if (v48 == v47) {
        v50 = 0LL;
      }
      else {
        v50 = *v49 + 40 * (v46 % 0x66);
      }
LABEL_74:
      v51 = v50 - 4080;
      while (1)
      {
        v52 = v48 == v47
            ? 0LL
            : *(void *)(v47 + 8 * ((a1[19].i64[1] + v46) / 0x66)) + 40 * ((a1[19].i64[1] + v46) % 0x66);
        if (v50 == v52) {
          break;
        }
        if (*(void *)v50 == a2)
        {
          v53 = *(_DWORD *)(v50 + 24);
          if ((v53 & a3) != 0)
          {
            v55 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
            {
              sub_1003CF00C(a2, uu);
              if (uu[23] >= 0) {
                v56 = uu;
              }
              else {
                v56 = *(_BYTE **)uu;
              }
              *(_DWORD *)buf = 67109378;
              *(_DWORD *)&buf[4] = v53;
              *(_WORD *)&buf[8] = 2082;
              *(void *)&buf[10] = v56;
              _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "Connection request for 0x%x to device %{public}s already queued, ignoring duplicate request",  buf,  0x12u);
              if ((uu[23] & 0x80000000) != 0) {
                operator delete(*(void **)uu);
              }
              v53 = *(_DWORD *)(v50 + 24);
            }

            sub_100422510(a1);
            a3 &= ~v53;
            v47 = a1[17].i64[1];
            v48 = a1[18].i64[0];
            break;
          }
        }

        v50 += 40LL;
        v51 += 40LL;
        if (*v49 == v51)
        {
          v54 = v49[1];
          ++v49;
          v50 = v54;
          goto LABEL_74;
        }
      }

      if (v48 == v47)
      {
        v58 = 0LL;
      }

      else
      {
        v57 = a1[19].i64[1] + a1[19].i64[0];
        v58 = *(void *)(v47 + 8 * (v57 / 0x66)) + 40 * (v57 % 0x66);
      }

      if (v50 == v58)
      {
        v65 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(a2, uu);
          v66 = uu[23] >= 0 ? uu : *(_BYTE **)uu;
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = v66;
          _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "No connection request for the device %{public}s, adding to connection request queue",  buf,  0xCu);
          if ((uu[23] & 0x80000000) != 0) {
            operator delete(*(void **)uu);
          }
        }

        *(void *)uu = a2;
        *(_DWORD *)&uu[8] = 0;
        *(void *)&uu[16] = 0LL;
        v85 = a3;
        v86 = a5;
        v87 = mach_continuous_time();
        sub_10041D048((int64x2_t *)a1[17].i64, (uint64_t)uu);
        v67 = sub_1002E6E00();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v67 + 8LL))(v67))
        {
          v68 = a1[6].i64[1];
          v78[0] = _NSConcreteStackBlock;
          v78[1] = 3221225472LL;
          v78[2] = sub_100426840;
          v78[3] = &unk_10087F8E0;
          v78[4] = a1;
          v78[5] = a2;
          sub_100405460(v68, 60000LL, v78);
        }

        sub_100422510(a1);
        v69 = a1[19].u64[1];
        if (v69 < 2)
        {
          sub_100242F54((uint64_t)v79);
          sub_100422B6C((uint64_t)a1, a2, 0xFFFFFFFFLL, 0, 0LL, 0LL, 0);
          sub_1003E4044(a2, 1);
          if (sub_1003CF350((unsigned __int8 *)a2)
            && !sub_1003D0670(a2)
            && sub_1003D2B2C(a2, 19))
          {
            v71 = (uint64_t (***)(void *, uint64_t))sub_1002E9328();
            v45 = (**v71)(v71, a2);
            if ((_DWORD)v45)
            {
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
              {
                sub_1003CF00C(a2, uu);
                sub_10067DC54();
              }

              sub_100423730(a1, a2);
            }

            goto LABEL_135;
          }

          else {
            v72 = 0;
          }
          sub_100426A10((uint64_t)a1, a2, v72, a5);
        }

        else
        {
          v70 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uu = 134217984;
            *(void *)&uu[4] = v69;
            _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "Queued up connection request - queue size is %lu",  uu,  0xCu);
          }

          sub_100422510(a1);
        }
      }

      else
      {
        if (a3)
        {
          v59 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            sub_1003CF00C(a2, buf);
            v60 = v89 >= 0 ? buf : *(_BYTE **)buf;
            v61 = *(_DWORD *)(v50 + 24);
            *(_DWORD *)uu = 136446722;
            *(void *)&uu[4] = v60;
            *(_WORD *)&uu[12] = 1024;
            *(_DWORD *)&uu[14] = v61;
            *(_WORD *)&uu[18] = 1024;
            *(_DWORD *)&uu[20] = a3;
            _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "There is an existing connection request for the device %{public}s, but current service mask 0x%x and new s ervice mask 0x%x are different. Appening new service to existing service mask",  uu,  0x18u);
            if (v89 < 0) {
              operator delete(*(void **)buf);
            }
          }

          v62 = sub_100425684((uint64_t)a1, *(void *)v50);
          for (i = 0; i != 31; ++i)
          {
            v64 = ((1 << i) & a3) != 0 && (v62 & a3) == 0;
            if (v64) {
              *(_DWORD *)(v50 + 24) |= 1 << i;
            }
          }
        }

        sub_100422510(a1);
      }

      v45 = 0LL;
LABEL_135:
      sub_100242FAC((uint64_t)v79);
      goto LABEL_136;
    }

    v42 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067DC98(v42, v43, v44);
    }
  }

  v45 = 202LL;
LABEL_136:
  sub_100242FAC((uint64_t)v80);
  return v45;
}

  v26 = *(unsigned __int16 *)(a1 + 1088);
  v27 = *(unsigned __int16 *)(a1 + 1086);
  if (v26 < v27)
  {
    v28 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT)) {
      sub_10069706C(v26, v27, v28);
    }
  }

  v29 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyHighMinInterval");
  uint64_t v30 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v29 + 88LL))(v29, buf, __p, &v96);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v30) {
      goto LABEL_84;
    }
  }

  else if (!v30)
  {
    goto LABEL_84;
  }

  v31 = v96;
  v32 = (os_log_s *)qword_1008F7620;
  if ((v96 - 8) >= 0xF9A && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v31;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "Override rejected latency minInterval:%d LeConnectionLatencyHigh",  buf,  8u);
    LOWORD(v31) = v96;
    v32 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 1092) = v31;
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v31;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "Override latency minInterval:%d LeConnectionLatencyHigh",  buf,  8u);
  }

uint64_t sub_100009F5C(void *a1)
{
  id v1 = a1;
  if ([v1 caseInsensitiveCompare:@"Charging"])
  {
    if ([v1 caseInsensitiveCompare:@"Discharging"])
    {
      if ([v1 caseInsensitiveCompare:@"FullyCharged"]) {
        uint64_t v2 = 4 * ([v1 caseInsensitiveCompare:@"OBC"] == 0);
      }
      else {
        uint64_t v2 = 3LL;
      }
    }

    else
    {
      uint64_t v2 = 2LL;
    }
  }

  else
  {
    uint64_t v2 = 1LL;
  }

  return v2;
}

LABEL_35:
    self->_prefAccessoryDaemonStayConnectedSeconds = v15;
  }

  -[CBAccessoryDaemon _update](self, "_update");
}

      if ((v18 & 0x10) != 0)
      {
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v12 airplaySourceAuthTagData]);

        v31 = (void *)objc_claimAutoreleasedReturnValue( -[RPIdentity authTagForData:type:error:]( v2->_identitySelf,  "authTagForData:type:error:",  v4,  2LL,  0LL));
        v32 = v30;
        v33 = v31;
        v34 = v32;
        v35 = v33;
        v75 = v34;
        if (v34 == v33)
        {
        }

        else
        {
          if ((v34 == 0LL) != (v33 != 0LL))
          {
            v36 = v34;
            v37 = [v34 isEqual:v33];

            if ((v37 & 1) != 0) {
              goto LABEL_43;
            }
          }

          else
          {
          }

          [v12 setAirplaySourceAuthTagData:v35];
          v68 = 1;
        }
}
          }
        }
      }

      uint64_t v12 = (char *)v12 + 1;
    }

    while (v12 != v10);
    uint64_t v10 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v58,  v64,  16LL);
  }

  while (v10);

  if (!v45) {
    goto LABEL_43;
  }
LABEL_47:
}

    v27 = 0LL;
    goto LABEL_10;
  }

  uint64_t v13 = v19;
  if (cclr_encrypt_block(v32, a4, &v34, &v34))
  {
    unint64_t v14 = v31;
    if (dword_1008D6460 <= 90
      && (dword_1008D6460 != -1 || _LogCategory_Initialize(&dword_1008D6460, 90LL)))
    {
      LogPrintF_safe( &dword_1008D6460,  "-[CBAdvertiserDaemon _encryptInvitationPayload:payloadLength:authTag:irkData:keyInfo:keyInfoLength:]",  90LL,  "Unable to encrypt invitation due to %d");
    }

            LOBYTE(v10) = 0;
            goto LABEL_20;
          }
        }

        if ([v12 code] == (id)-6723)
        {
          uint64_t v13 = sub_100526E6C(v11);
          LOBYTE(v10) = 1;
          if (!v13) {
            goto LABEL_20;
          }
          unint64_t v14 = (v13 + 310000);
          if (!(_DWORD)v14) {
            goto LABEL_20;
          }
          if (!a4) {
            goto LABEL_35;
          }
          uint64_t v15 = CBErrorF(v14, "Cancel pairing failed");
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
        }

        else
        {
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v6 error]);
          unint64_t v18 = sub_1005270E0(v11, (uint64_t)v10, v17 != 0LL);

          LOBYTE(v10) = 1;
          if (!v18 || v18 == -310000) {
            goto LABEL_20;
          }
          if (!a4) {
            goto LABEL_35;
          }
          v19 = CBErrorF((v18 + 310000), "Accept/Reject pairing failed");
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v19);
        }

    uint64_t v9 = a1;
    uint64_t v10 = 11LL;
    goto LABEL_36;
  }

  if (v6 > 63)
  {
    if (v6 == 64)
    {
      if ((*(_BYTE *)(qword_1008DDE00 + 45) & 4) == 0) {
        goto LABEL_31;
      }
      uint64_t v8 = "AT+BCS=130\r";
    }

    else
    {
      if (v6 != 127) {
        goto LABEL_32;
      }
      if ((*(_BYTE *)(qword_1008DDE00 + 44) & 4) == 0) {
        goto LABEL_31;
      }
      uint64_t v8 = "AT+BCS=127\r";
    }

    goto LABEL_35;
  }

  if (v6 != 1)
  {
    if (v6 == 2)
    {
      if ((*(_BYTE *)(qword_1008DDE00 + 44) & 2) != 0)
      {
        uint64_t v8 = "AT+BCS=2\r";
LABEL_25:
        uint64_t v9 = a1;
        uint64_t v10 = 9LL;
LABEL_36:
        sub_1000A5C70(v9, 0LL, v8, v10, 0, 29);
        goto LABEL_37;
      }

      goto LABEL_31;
    }

            *((_BYTE *)a1 + 20) = 2;
            goto LABEL_42;
          }
        }

        else
        {
          uint64_t v10 = *((unsigned __int16 *)a1 + 9);
        }

        if (v10 < *((unsigned __int16 *)a1 + 8))
        {
          unint64_t v22 = a1[1];
          *((_WORD *)a1 + 9) = v10 + 1;
          *((_BYTE *)v22 + v10) = v8;
          goto LABEL_42;
        }

        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Receive overflow - discarding (buf length %d)\n",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *((unsigned __int16 *)a1 + 9));
          unint64_t v18 = (os_log_s *)sub_100086554(0);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            v19 = sub_1001EDDCC();
            LODWORD(buf[0]) = 136446466;
            *(void **)((char *)buf + 4) = v19;
            WORD2(buf[1]) = 1024;
            *(_DWORD *)((char *)&buf[1] + 6) = 0xFFFF;
            _os_log_error_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  (uint8_t *)buf,  0x12u);
          }
        }

        *(_DWORD *)((char *)a1 + 1_Block_object_dispose((const void *)(v1 - 80), 8) = 0;
      }

      if (i != 4)
      {
        if (i != 2)
        {
          if (i || v8 != 13 || *((_BYTE *)a1 + 21)) {
            goto LABEL_42;
          }
          goto LABEL_35;
        }

        if (v8 != 13)
        {
          if (v8 != 10)
          {
            if (!*((_BYTE *)a1 + 21)) {
              *((_BYTE *)a1 + 20) = 0;
            }
            goto LABEL_42;
          }

          if (!*((_BYTE *)a1 + 21)) {
LABEL_41:
          }
            *((_BYTE *)a1 + 20) = 3;
        }

        ;
      }

      sub_100090F08((uint64_t)a1, 0);
      sub_100102438(a1);
      unint64_t v14 = v72;
    }

    else
    {
      sub_100090F08((uint64_t)a1, 0);
      sub_100102438(a1);
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"DOWNGRADE_CFM no alternate handle to downgrade from.",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v71);
        v42 = (os_log_s *)sub_100086554(0x56u);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    sub_100102978((unsigned __int16)v2, v14, 0);
    v43 = &qword_1008F29F0[134 * v2];
    v45 = *((unsigned __int8 *)v43 + 77);
    v44 = (unsigned __int8 *)v43 + 77;
    if (v45 != 1)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"DOWNGRADE_CFM upgrading transport since this downgrade was triggered by a upgrade to different alternate transport",  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v71);
        v53 = (os_log_s *)sub_100086554(0x56u);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v74 = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      sub_1000FE4E0(a1, *v44, qword_1008F29F0[134 * v2 + 14]);
    }

    if ((_DWORD)v12 == 0xFFFF)
    {
LABEL_49:
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Invalid handle for downgrade", v63, v64, v65, v66, v67, v68, v69, v71);
        v70 = (os_log_s *)sub_100086554(0x56u);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Got a downgrade confirmation from lmhandle 0x%4x", v54, v55, v56, v57, v58, v59, v60, *a1);
      v61 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        v62 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        v74 = v62;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"DOWNGRADE_CFM not supposed to get a downgrade CFM from the central.",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v71);
      uint64_t v10 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v74 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    sub_1001081C8((__int128 *)a1, 33, 2);
  }

  v54 = word_1008E2239;
  LOBYTE(word_1008E2239) = v5;
  result = sub_10011A99C(a1, 0);
  LOBYTE(word_1008E2239) = v54;
  ++byte_1008E2238;
  return result;
}

        v54 = *((_BYTE *)v22 + 16) != 0;
        v55 = (_BYTE *)a3;
        v56 = v61;
        v57 = (unsigned __int16 *)v33;
        v58 = v35;
LABEL_39:
        sub_10018B864(v55, v56, v57, v58, v54, a6);
        return;
      }

      if (v59)
      {
LABEL_45:
        memmove(v59, v33, (unsigned __int16)(v10 - 4));
        v22[7] = v10;
        return;
      }
    }

    v59 = *(unsigned __int16 **)v22;
    if (!*(void *)v22)
    {
      if (!a4) {
        sub_1001EE2A0();
      }
      v59 = (unsigned __int16 *)sub_1000B17F4(v24);
      *(void *)unint64_t v22 = v59;
      if (!v59) {
        return;
      }
    }

    goto LABEL_45;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Broadcast packet on non-ACL handle 0x%x. Bailing.", v13, v14, v15, v16, v17, v18, v19, a3);
    v20 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
LABEL_32:
    }
      sub_100657858();
  }

        *(_DWORD *)(a1 + 60) = 4;
        sub_100200260(v18, (unsigned __int8 *)(a1 + 65));
        return;
      }

    sub_10021E798(v20, a2);
    goto LABEL_36;
  }

  return 111LL;
}

  CFDictionaryRemoveValue(v5, @"MagicAccKey");
  if ((a2 & 0x80) == 0)
  {
LABEL_20:
    if ((a2 & 0x100) == 0) {
      goto LABEL_21;
    }
    goto LABEL_37;
  }

    v27 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&buf[4] = CStringPtr;
      v31 = 2080;
      v32 = v16;
      v33 = 2048;
      v34 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Warning: \tIllegal %s value %s(%lld), ignoring!",  buf,  0x20u);
    }

    valuePtr = v7;
    goto LABEL_38;
  }

  return v7;
}

      sqlite3_finalize(ppStmt);
    }
  }

          uint64_t v30 = *(_DWORD *)(v28 + 24) - 8194;
          uint64_t v16 = v30 > 0xE;
          v31 = (1 << v30) & 0x409B;
          v32 = v16 || v31 == 0;
          v105 = v21;
          if (v32)
          {
            v33 = *(id *)(v28 + 80);
          }

          else
          {
            v33 = *(id *)(a1 + 424);
            v108 |= (unint64_t)[*(id *)(a1 + 424) count] > *(unsigned __int8 *)(a1 + 432);
          }

          v117 = 0u;
          v118 = 0u;
          v115 = 0u;
          v116 = 0u;
          v34 = v33;
          v35 = [v34 countByEnumeratingWithState:&v115 objects:v123 count:16];
          if (!v35) {
            goto LABEL_57;
          }
          v36 = *(void *)v116;
          break;
        case 7:
          v51 = (os_log_s *)qword_1008F7568;
          if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
          {
            v52 = v21;
            v53 = *(void **)(v28 + 8);
            v54 = *(unsigned __int8 *)(v28 + 40);
            *(_DWORD *)buf = 138543618;
            *(void *)&buf[4] = v53;
            v125 = 1024;
            v126 = v54;
            v55 = v53;
            _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "Warning: finishSession: %{public}@ in state %d",  buf,  0x12u);

            unint64_t v21 = v52;
          }

          goto LABEL_84;
        default:
          v56 = (os_log_s *)qword_1008F7568;
          if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v103;
            *(_DWORD *)&buf[4] = v29;
            _os_log_error_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_ERROR,  "finishSession: Unhandled status %d",  buf,  8u);
          }

          goto LABEL_66;
      }

      do
      {
        v37 = 0LL;
        do
        {
          if (*(void *)v116 != v36) {
            objc_enumerationMutation(v34);
          }
          v38 = *(void *)(*((void *)&v115 + 1) + 8LL * (void)v37);
          v39 = *(_DWORD *)(v28 + 24) - 8194;
          uint64_t v16 = v39 > 0xE;
          v40 = (1 << v39) & 0x409B;
          if (!v16 && v40 != 0) {
            goto LABEL_49;
          }
          if (![*(id *)(*((void *)&v115 + 1) + 8 * (void)v37) hasPrefix:@"/private/var/mobile/Library/Logs/Bluetooth/AccessoryVersionInfo"])
          {
            v108 = 1;
LABEL_49:
            -[NSMutableOrderedSet addObject:](v4, "addObject:", v38, v103);
            v27 = v28;
            goto LABEL_50;
          }

          if (!*(_BYTE *)(v107 + 34)) {
            goto LABEL_49;
          }
LABEL_50:
          v37 = (char *)v37 + 1;
        }

        while (v35 != v37);
        v42 = [v34 countByEnumeratingWithState:&v115 objects:v123 count:16];
        v35 = v42;
      }

      while (v42);
LABEL_57:

      a1 = v107;
      unint64_t v21 = v105;
LABEL_66:
      if (*(_BYTE *)(a1 + 34))
      {
        v57 = *(_DWORD *)(v28 + 24) - 8194;
        uint64_t v16 = v57 > 0x22;
        v58 = (1LL << v57) & 0x47A877F9BLL;
        if (!v16 && v58 != 0)
        {
          v106 = v21;
          v60 = sub_10035C48C(a1, v28);
          v61 = (void *)objc_claimAutoreleasedReturnValue(v60);
          v62 = v61;
          if (v61 && (!*(void *)(a1 + 24) || *(_BYTE *)(a1 + 16)))
          {
            v113 = 0u;
            v114 = 0u;
            v111 = 0u;
            v112 = 0u;
            v63 = v61;
            v64 = [v63 countByEnumeratingWithState:&v111 objects:v122 count:16];
            if (v64)
            {
              v65 = *(void *)v112;
              do
              {
                for (i = 0LL; i != v64; i = (char *)i + 1)
                {
                  if (*(void *)v112 != v65) {
                    objc_enumerationMutation(v63);
                  }
                  -[NSMutableOrderedSet addObject:]( v4,  "addObject:",  *(void *)(*((void *)&v111 + 1) + 8LL * (void)i),  v103);
                }

                v64 = [v63 countByEnumeratingWithState:&v111 objects:v122 count:16];
              }

              while (v64);
            }

            a1 = v107;
          }

          unint64_t v21 = v106;
        }
      }

      sub_10035A15C(v28);
      ++v104;
LABEL_84:
      if (++v21 == *(uint64_t **)(a1 + 48))
      {
LABEL_104:
        v78 = (os_log_s *)qword_1008F7568;
        if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
        {
          v79 = -[NSMutableOrderedSet count](v4, "count");
          *(_DWORD *)buf = 134218240;
          *(void *)&buf[4] = v79;
          v125 = 1024;
          v126 = v104;
          _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_DEFAULT,  "finishSession: Sending %lu file(s) from %d session(s)",  buf,  0x12u);
        }

        if (*(void *)(a1 + 24))
        {
          v80 = (os_log_s *)qword_1008F7568;
          if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
          {
            if (*(_BYTE *)(a1 + 16)) {
              v81 = "Diagnostic Extension";
            }
            else {
              v81 = "Sysdiagnose";
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = v81;
            _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_DEFAULT,  "finishSession: %{public}s - Accessory Log Retrieval Completed",  buf,  0xCu);
          }

          if ((v108 & 1) != 0) {
            v82 = v4;
          }
          else {
            v82 = 0LL;
          }
          sub_100360718(a1, v82);
          goto LABEL_116;
        }

        if ((v108 & 1) != 0)
        {
          if (*(_BYTE *)(a1 + 33))
          {
            v83 = (os_log_s *)qword_1008F7568;
            v19 = 0LL;
            if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_DEFAULT,  "finishSession: Force send complete",  buf,  2u);
              goto LABEL_116;
            }
          }

          else
          {
            v91 = sub_1002E6BF0();
            if ((((*(uint64_t (**)(uint64_t))(*(void *)v91 + 328LL))(v91) & 1) != 0
               || (v92 = sub_1002E6BF0(), ((*(uint64_t (**)(uint64_t))(*(void *)v92 + 384LL))(v92) & 1) != 0)
               || (v93 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v93 + 424LL))(v93)))
              && (v94 = sub_1002E6E00(), (*(unsigned int (**)(uint64_t))(*(void *)v94 + 8LL))(v94)))
            {
              v95 = *(unsigned __int8 *)(a1 + 34);
              v96 = (os_log_s *)qword_1008F7568;
              v97 = os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT);
              if (v95)
              {
                if (v97)
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "finishSession: Retrieved crash log, opening Tap-to-Radar",  buf,  2u);
                }

                v98 = sub_1002E8E64();
                (*(void (**)(uint64_t, NSMutableOrderedSet *, uint64_t, void))(*(void *)v98 + 168LL))( v98,  v4,  1LL,  *(unsigned int *)(v27 + 24));
              }

              else
              {
                if (v97)
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "finishSession: Internal Settings - Accessory Log Retrieval Completed",  buf,  2u);
                }

                v99 = sub_1002E8E64();
                v100 = *(unsigned int *)(v27 + 24);
                v101 = *(id *)v27;
                v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithString:](&OBJC_CLASS___NSString, "stringWithString:", v101));
                (*(void (**)(uint64_t, NSMutableOrderedSet *, void, uint64_t, void *))(*(void *)v99 + 152LL))( v99,  v4,  0LL,  v100,  v102);
              }

  uint64_t v9 = 22LL;
LABEL_36:
  if (SHIBYTE(v28[1]) < 0) {
    operator delete(*((void **)&v27 + 1));
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(*((void **)&v25 + 1));
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(*((void **)&v23 + 1));
  }
  nullsub_63((char *)&v22 + 1, v6);
  return v9;
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

        if ((v51 & 0x80000000) == 0) {
          sub_1001AFF38(v51);
        }
        if (v24)
        {
          sub_10043F3F4(a1, 219LL, xdict, v24);
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
            sub_10068A058();
          }
        }

        goto LABEL_40;
      }
    }

    else if ([v15 isEqualToString:@"setLePathLossEnable"])
    {
      LOBYTE(v93[0]) = 0;
      uint64_t v24 = sub_10025D848(v91, 0, v33, v34, v35, v36, v37, v38, (uint64_t)"kCBLePathLossReportingEnable");
      if (!v24)
      {
        LOBYTE(v92[0]) = 0;
        sub_100242CA4(v92);
        v31 = sub_1001214B4(248, (uint64_t)sub_1004E7778, v39, v40, v41, v42, v43, v44, v90);
        sub_100242CD0(v92);
        sub_100242CD8(v92);
        v32 = 248;
        goto LABEL_18;
      }
    }

    else if ([v15 isEqualToString:@"setLePathLossParam"])
    {
      LOBYTE(v92[0]) = 0;
      v88 = 0;
      v87[1] = 0;
      LOWORD(v93[0]) = 0;
      uint64_t v24 = sub_10025D848(v91, 0, v45, v46, v47, v48, v49, v50, (uint64_t)"kCBLeHighThreshold");
      if (!v24)
      {
        v87[0] = 0;
        sub_100242CA4(v87);
        v31 = sub_1001214B4(247, (uint64_t)sub_1004E7778, v74, v75, v76, v77, v78, v79, v90);
        sub_100242CD0(v87);
        sub_100242CD8(v87);
        v32 = 247;
        goto LABEL_18;
      }
    }

    else
    {
      if ([v15 isEqualToString:@"readLeRemoteTxPower"])
      {
        LOBYTE(v93[0]) = 0;
        uint64_t v24 = sub_10025D848(v91, 0, v56, v57, v58, v59, v60, v61, (uint64_t)"kCBLePHYType");
        if (v24)
        {
          v32 = 0;
          v51 = 0xFFFFFFFFLL;
          v31 = 114;
        }

        else
        {
          LOBYTE(v92[0]) = 0;
          sub_100242CA4(v92);
          if (v16) {
            v51 = sub_1001AFED4(1, (uint64_t)sub_1004E7778, (uint64_t)&value, 8);
          }
          else {
            v51 = 0xFFFFFFFFLL;
          }
          v31 = sub_100128D24(0xF6u, v80, v81, v82, v83, v84, v85, v86, v90);
          sub_100242CD0(v92);
          sub_100242CD8(v92);
          v32 = 246;
        }

        goto LABEL_19;
      }

      if (![v15 isEqualToString:@"readLeLocalTxPower"])
      {
        if ((v16 & 1) == 0)
        {
LABEL_40:

          goto LABEL_41;
        }

        uint64_t v24 = 0;
        v32 = 0;
        v31 = 114;
        v51 = 0xFFFFFFFFLL;
        goto LABEL_25;
      }

      LOBYTE(v93[0]) = 0;
      uint64_t v24 = sub_10025D848(v91, 0, v62, v63, v64, v65, v66, v67, (uint64_t)"kCBLePHYType");
      if (!v24 && LOBYTE(v93[0]) - 1 <= 3)
      {
        LOBYTE(v92[0]) = 0;
        sub_100242CA4(v92);
        v31 = sub_1001214B4(245, (uint64_t)sub_1004E7784, v68, v69, v70, v71, v72, v73, v90);
        sub_100242CD0(v92);
        sub_100242CD8(v92);
        v32 = 245;
        goto LABEL_18;
      }
    }

    v32 = 0;
    v31 = 114;
    goto LABEL_18;
  }

  sub_10043F3F4(a1, 219LL, xdict, v13);
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_10068A0D0();
  }
LABEL_41:
}

    unint64_t v21 = sub_1002E6E9C();
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    unint64_t v22 = sub_1005CC198((uint64_t)off_1008D5F28, *(void **)(a1 + 32), 0);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 3608LL))(v21, v22);
    goto LABEL_38;
  }

  *(_DWORD *)__s = 0;
  uint64_t v15 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "MaxConnPerBundleIDFromEndConnectingClient");
  uint64_t v16 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v15 + 88LL))(v15, buf, __p, __s);
  if (*(_DWORD *)__s) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v17) {
      goto LABEL_46;
    }
  }

  else if (!v17)
  {
    goto LABEL_46;
  }

  unint64_t v18 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 160) = *(_WORD *)__s;
  v19 = (os_log_s *)qword_1008F7698;
  if (os_log_type_enabled((os_log_t)qword_1008F7698, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding - MaxConnPerBundleIDFromEndConnectingClient %d",  buf,  8u);
  }

void *sub_10000AA64(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  result = *(void **)(a1 + 40);
  if (v3 == result[1]) {
    return [result _accessoryDiscoveryFoundDevice:a2];
  }
  return result;
}

void sub_10000AA80(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3 && *(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 8LL))
  {
    id v8 = v3;
    if (dword_1008D5F68 <= 90
      && (dword_1008D5F68 != -1 || _LogCategory_Initialize(&dword_1008D5F68, 90LL)))
    {
      uint64_t v4 = CUPrintNSError(v8);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryDaemon _accessoryDiscoveryEnsureStarted]_block_invoke_2",  90LL,  "### Accessory discovery start failed: %@",  v5);
    }

    [*(id *)(a1 + 32) invalidate];
    uint64_t v6 = *(void *)(a1 + 40);
    unint64_t v7 = *(void **)(v6 + 8);
    *(void *)(v6 + _Block_object_dispose((const void *)(v1 - 80), 8) = 0LL;

    id v3 = v8;
  }
}

void sub_10000ABF0(id a1, NSString *a2, CBAccessoryInfo *a3, BOOL *a4)
{
}

void sub_10000AEEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (*(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 40LL))
  {
    uint64_t v9 = v3;
    unsigned __int16 v5 = (unsigned __int16)[v3 deviceFlags];
    uint64_t v4 = v9;
    if ((v5 & 0x4000) != 0 || (unsigned __int8 v6 = [v9 deviceFlags], v4 = v9, (v6 & 2) != 0))
    {
      unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( CBProductInfo,  "productInfoWithProductID:",  [v4 productID]));
      unsigned int v8 = [v7 flags];

      if ((v8 & 0x100000) != 0) {
        [*(id *)(a1 + 40) _update];
      }
      [*(id *)(a1 + 40) _connectionMonitorFoundDevice:v9];
      uint64_t v4 = v9;
    }
  }
}

void sub_10000AFA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (*(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 40LL))
  {
    uint64_t v9 = v3;
    unsigned __int16 v5 = (unsigned __int16)[v3 deviceFlags];
    uint64_t v4 = v9;
    if ((v5 & 0x4000) == 0)
    {
      unsigned __int8 v6 = [v9 deviceFlags];
      uint64_t v4 = v9;
      if ((v6 & 2) == 0)
      {
        unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( CBProductInfo,  "productInfoWithProductID:",  [v9 productID]));
        unsigned int v8 = [v7 flags];

        uint64_t v4 = v9;
        if ((v8 & 0x100000) != 0)
        {
          [*(id *)(a1 + 40) _update];
          uint64_t v4 = v9;
        }
      }
    }
  }
}

void sub_10000B04C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3 && *(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 40LL))
  {
    id v8 = v3;
    if (dword_1008D5F68 <= 90
      && (dword_1008D5F68 != -1 || _LogCategory_Initialize(&dword_1008D5F68, 90LL)))
    {
      uint64_t v4 = CUPrintNSError(v8);
      unsigned __int16 v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryDaemon _connectionMonitorEnsureStarted]_block_invoke_3",  90LL,  "### Connection monitor: start failed: %@",  v5);
    }

    [*(id *)(a1 + 32) invalidate];
    uint64_t v6 = *(void *)(a1 + 40);
    unint64_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = 0LL;

    id v3 = v8;
  }
}

void sub_10000B590(uint64_t a1, void *a2)
{
  id v10 = a2;
  if (v10)
  {
    if (dword_1008D5F68 <= 90
      && (dword_1008D5F68 != -1 || _LogCategory_Initialize(&dword_1008D5F68, 90LL)))
    {
      uint64_t v3 = CUPrintNSError(v10);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryDaemon _connectionMonitorFoundDevice:]_block_invoke",  90LL,  "### Connection monitor: connect failed %@ for %@",  v4,  *(void *)(a1 + 32));
    }

    [*(id *)(a1 + 40) invalidate];
    [*(id *)(*(void *)(a1 + 48) + 32) setObject:0 forKeyedSubscript:*(void *)(a1 + 56)];
  }

  else
  {
    if (dword_1008D5F68 <= 30
      && (dword_1008D5F68 != -1 || _LogCategory_Initialize(&dword_1008D5F68, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryDaemon _connectionMonitorFoundDevice:]_block_invoke",  30LL,  "Connection monitor: connect completed %@",  *(void *)(a1 + 32));
    }

    id v5 = [*(id *)(a1 + 64) mutableCopy];
    uint64_t v6 = v5;
    if (v5) {
      unint64_t v7 = (NSMutableDictionary *)v5;
    }
    else {
      unint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    }
    id v8 = v7;

    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 72)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v8, "setObject:forKeyedSubscript:", v9, *(void *)(a1 + 56));

    CFPrefs_SetValue(@"com.apple.bluetooth", @"accessoryDaemonConnectTimes", v8);
    [*(id *)(a1 + 48) _connectionMonitorUpdate];
  }
}

LABEL_53:
}

  uint64_t v4 = (void *)v2;

  return v4;
}

    (*(void (**)(uint64_t, uint64_t, void))(*(void *)(qword_1008DFDB0 + 24) + 88LL))( a3,  v45,  a2);
    return a2;
  }

  if (a4 == 2)
  {
    uint64_t v17 = sub_1000E4B00(a3, a1);
    unint64_t v18 = v17;
    v19 = qword_1008DFDB0;
    if ((_DWORD)v17)
    {
      if (*(unsigned __int8 *)(qword_1008DFDB0 + 97) > (unsigned __int16)(v17 - 1)
        && (v20 = *(void *)(qword_1008DFDB0 + 8)) != 0)
      {
        unint64_t v21 = (unsigned __int16)(v17 - 1);
        unint64_t v22 = v20 + 144LL * (unsigned __int16)(v17 - 1);
        sub_1000DD6D8(v22, 5);
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Disconnecting media transport", v23, v24, v25, v26, v27, v28, v29, v68);
          uint64_t v30 = (os_log_s *)sub_100086554(3u);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            v31 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446210;
            v70 = v31;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        v32 = v20 + 144LL * v21;
        v34 = *(unsigned __int16 *)(v32 + 128);
        v33 = (_WORD *)(v32 + 128);
        v35 = sub_1001759FC(v34, 436LL);
        if (!(_DWORD)v35)
        {
          LOBYTE(a2) = 0;
          *(_BYTE *)(v20 + 144LL * v21 + 133) = a3;
          return a2;
        }

        v36 = v35;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Error disconnecting media transport - %!", v37, v38, v39, v40, v41, v42, v43, v36);
          v44 = (os_log_s *)sub_100086554(3u);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        *v33 = 0;
        sub_1000B90AC(0LL);
        sub_1000DC6BC(v22);
        v19 = qword_1008DFDB0;
        a2 = 49LL;
      }

      else
      {
        a2 = 18LL;
      }
    }

    else
    {
      a2 = 1LL;
    }

    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v19 + 24) + 88LL))(a3, v18, a2);
  }

  else
  {
    LOBYTE(a2) = 0;
  }

  return a2;
}

  if (*(_WORD *)(qword_1008E2BF0 + 2042)) {
    return *(unsigned __int16 *)(qword_1008E2BF0 + 2042);
  }
  else {
    return 5LL;
  }
}

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Can't add attribute to parent handle 0x%04x, with 0x%04x extra handles",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  a1);
    v52 = (os_log_s *)sub_100086554(0x44u);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 4017LL;
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Enforce Policy error %!", v55, v56, v57, v58, v59, v60, v61, v20);
    v62 = (os_log_s *)sub_100086554(0x37u);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

  return v20;
}

    if (++v24 == v25) {
      goto LABEL_54;
    }
  }

  v31 = *(void *)(a1 + 168);
  v32 = *(void *)(a1 + 176);
  if (v31 == v32) {
    return sub_100242FAC((uint64_t)v57);
  }
  v33 = *((unsigned __int8 *)a2 + 23);
  v35 = (unsigned __int8 *)*a2;
  v34 = (size_t)a2[1];
  if ((v33 & 0x80u) == 0LL) {
    v36 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    v36 = a2[1];
  }
  while (1)
  {
    v37 = (const void *)*(unsigned __int8 *)(v31 + 31);
    v38 = (char)v37;
    if (v36 != v37) {
      goto LABEL_70;
    }
    v39 = v38 >= 0 ? (unsigned __int8 *)(v31 + 8) : *(unsigned __int8 **)(v31 + 8);
    if ((v33 & 0x80) != 0) {
      break;
    }
    if (!(_DWORD)v33) {
      goto LABEL_72;
    }
    v40 = a2;
    v41 = v33;
    while (*(unsigned __int8 *)v40 == *v39)
    {
      v40 = (const void **)((char *)v40 + 1);
      ++v39;
      if (!--v41) {
        goto LABEL_72;
      }
    }

      if (v25) {
        *((_DWORD *)v22 + 1_Block_object_dispose((const void *)(v1 - 80), 8) = v25;
      }
    }

    if (*(_BYTE *)(a1 + 48))
    {
      __p[0] = 0;
      sub_100242CA4(__p);
      sub_1003EDDE0((void *)a1);
      sub_100242CD8(__p);
    }

    sub_1003F0354(a1, (uint64_t)a2);
LABEL_61:
    unint64_t v14 = 0LL;
    goto LABEL_62;
  }

  unint64_t v21 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__p = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "updateDeviceRatchet, Magic Pairing Layer not initialized",  __p,  2u);
  }

  return 17LL;
}

  v28 = &off_10087FAA8;
  if (v29) {
    sub_1002CD254(v29);
  }
}

void *sub_10000BC0C(void *result)
{
  if (result[4] == *(void *)(result[5] + 72LL))
  {
    id v1 = result;
    if (dword_1008D5F68 <= 30
      && (dword_1008D5F68 != -1 || _LogCategory_Initialize(&dword_1008D5F68, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryDaemon _connectionMonitorUpdate]_block_invoke",  30LL,  "Connection monitor: periodic timer fired");
    }

    return [(id)v1[5] _connectionMonitorUpdate];
  }

  return result;
}

LABEL_90:
                  if (dword_1008D5F68 <= 30
                    && (dword_1008D5F68 != -1 || _LogCategory_Initialize(&dword_1008D5F68, 30LL)))
                  {
                    LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryInfo _powerSourceUpdateWithPartID:]",  30LL,  "Accessory power source create with battery level: %d",  (int)(float)(v16 * 100.0));
                  }

                  v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (int)(float)(v16 * 100.0)));
                  v52 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v24,  "objectForKeyedSubscript:",  @"Current Capacity"));
                  v53 = v51;
                  v54 = v52;
                  v98 = v34;
                  v99 = v33;
                  if (v53 == v54)
                  {

                    goto LABEL_101;
                  }

                  v55 = v54;
                  if ((v53 == 0LL) != (v54 != 0LL))
                  {
                    v56 = [v53 isEqual:v54];

                    if ((v56 & 1) != 0)
                    {
LABEL_101:
                      v57 = @"Battery Power";
                      if (v18 == 1) {
                        v57 = @"AC Power";
                      }
                      v58 = v57;
                      v59 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v24,  "objectForKeyedSubscript:",  @"Power Source State"));
                      v60 = v58;
                      v61 = v59;
                      if (v60 == v61)
                      {

                        goto LABEL_110;
                      }

                      v62 = v61;
                      if (v61)
                      {
                        v63 = -[__CFString isEqual:](v60, "isEqual:", v61);

                        if ((v63 & 1) != 0)
                        {
LABEL_110:
                          if (v18 == 1) {
                            v64 = &__kCFBooleanTrue;
                          }
                          else {
                            v64 = &__kCFBooleanFalse;
                          }
                          v65 = v64;
                          v66 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v24,  "objectForKeyedSubscript:",  @"Is Charging"));
                          v67 = v65;
                          v68 = v66;
                          if (v67 == v68)
                          {

                            goto LABEL_120;
                          }

                          v69 = v68;
                          if (v68)
                          {
                            v70 = [v67 isEqual:v68];

                            if ((v70 & 1) != 0)
                            {
LABEL_120:
                              else {
                                v71 = &__kCFBooleanTrue;
                              }
                              v72 = v71;
                              v73 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v24,  "objectForKeyedSubscript:",  @"Low Warn Level"));
                              v74 = v72;
                              v75 = v73;
                              if (v74 == v75)
                              {

                                v77 = v103;
                                goto LABEL_130;
                              }

                              v76 = v75;
                              v77 = v103;
                              if (v75)
                              {
                                v78 = [v74 isEqual:v75];

                                if ((v78 & 1) != 0)
                                {
LABEL_130:
                                  -[CBDevice accessoryStatusOBCTime](v5, "accessoryStatusOBCTime");
                                  if ((int)(v79 / 60.0) < 1)
                                  {
LABEL_139:
                                    v86 = *(Class *)((char *)&v77->super.isa + v100);
                                    v104 = v86;
                                    v87 = v102;
                                    if (!v86)
                                    {
                                      v88 = IOPSCreatePowerSource(&v104);
                                      v86 = v104;
                                      *(Class *)((char *)&v77->super.isa + v100) = v104;
                                      if (dword_1008D5F68 <= 30
                                        && (dword_1008D5F68 != -1
                                         || (v92 = _LogCategory_Initialize(&dword_1008D5F68, 30LL), v86 = v104, v92)))
                                      {
                                        if (v86) {
                                          v89 = "yes";
                                        }
                                        else {
                                          v89 = "no";
                                        }
                                        v90 = CUPrintErrorCode(v88);
                                        v91 = (void *)objc_claimAutoreleasedReturnValue(v90);
                                        v97 = v89;
                                        v77 = v103;
                                        LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryInfo _powerSourceUpdateWithPartID:]",  30LL,  "Accessory power source create: %@, power source ID: %s, error return: %@",  v103,  v97,  v91);

                                        v87 = 1;
                                        v86 = v104;
                                      }

                                      else
                                      {
                                        v87 = 1;
                                      }
                                    }

                                    if (v86)
                                    {
                                      if (v87)
                                      {
                                        v93 = IOPSSetPowerSourceDetails();
                                        if (dword_1008D5F68 <= 30)
                                        {
                                          v94 = v93;
                                          if (dword_1008D5F68 != -1
                                            || _LogCategory_Initialize(&dword_1008D5F68, 30LL))
                                          {
                                            v95 = CUPrintErrorCode(v94);
                                            v96 = (void *)objc_claimAutoreleasedReturnValue(v95);
                                            LogPrintF_safe( &dword_1008D5F68,  "-[CBAccessoryInfo _powerSourceUpdateWithPartID:]",  30LL,  "Accessory power source update: %@, error: %@, publish power source %@ for device: %@",  v77,  v96,  v24,  v5);
                                          }
                                        }
                                      }
                                    }

                                    uint64_t v6 = v101;
                                    goto LABEL_155;
                                  }

                                  v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:"));
                                  v81 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v24,  "objectForKeyedSubscript:",  @"Time to Full Charge"));
                                  v82 = v80;
                                  v83 = v81;
                                  if (v82 == v83)
                                  {
                                  }

                                  else
                                  {
                                    v84 = v83;
                                    if ((v82 == 0LL) != (v83 != 0LL))
                                    {
                                      v85 = [v82 isEqual:v83];

                                      if ((v85 & 1) != 0) {
                                        goto LABEL_138;
                                      }
                                    }

                                    else
                                    {
                                    }

                                    -[NSMutableDictionary setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v82,  @"Time to Full Charge");
                                    v102 = 1;
                                  }

          v29 = IOIteratorNext(v59);
          if (!v29) {
            goto LABEL_113;
          }
        }

        v23 = v37;
        (*(void (**)(uint64_t))(*(void *)v55 + 24LL))(v55);
        ((void (*)(IOCFPlugInInterface **))(*theInterface)->Release)(theInterface);
LABEL_106:
        unint64_t v7 = (_BYTE *)(&xmmword_1008DDFF8 + 8);
        uint64_t v3 = (CFRunLoopRef *)(&xmmword_1008DDFF8 + 8);
LABEL_98:
        IOObjectRelease(v59);
        goto LABEL_99;
      }

    if ((v41 & 0x30) != 0)
    {
      if (v17 != (char *)v28)
      {
        while (1)
        {
          v49 = *(void *)(*(void *)v17 + 8LL);
          v50 = *(_DWORD *)(v49 + 20);
          buf = *(__n128 *)(v49 + 4);
          v168 = v50;
          sub_100634334(&v164, &buf);
          v122 = xmmword_1006BD914;
          v123 = 0;
          v17 += 8;
          if (v17 == (char *)v28)
          {
            uint64_t v17 = (char *)v28;
            break;
          }
        }
      }

LABEL_138:
                                  goto LABEL_139;
                                }
                              }

                              else
                              {
                              }

                              -[NSMutableDictionary setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v74,  @"Low Warn Level");
                              v102 = 1;
                              goto LABEL_130;
                            }
                          }

                          else
                          {
                          }

                          -[NSMutableDictionary setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v67,  @"Is Charging");
                          v102 = 1;
                          goto LABEL_120;
                        }
                      }

                      else
                      {
                      }

                      -[NSMutableDictionary setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v60,  @"Power Source State");
                      v102 = 1;
                      goto LABEL_110;
                    }
                  }

                  else
                  {
                  }

                  -[NSMutableDictionary setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v53,  @"Current Capacity");
                  v102 = 1;
                  goto LABEL_101;
                }

                if ((_DWORD)v40 != 520) {
                  goto LABEL_160;
                }
              }
            }

            else if ((int)v40 > 558 && (_DWORD)v40 != 569 && (_DWORD)v40 != 570)
            {
              goto LABEL_160;
            }

                if ((v3 & 0xFFFFFFFE) == 0x14) {
                  goto LABEL_142;
                }
                (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(&__p, a1);
                v33 = std::string::compare(&__p, "C2");
                if ((v33 & 0x80000000) == 0 || v3 == 25 || v3 == 23) {
LABEL_142:
                }
                  *(_WORD *)(a1 + 399) = 257;
                v34 = sub_1002E6BF0();
                *(_BYTE *)(a1 + 192) = 0;
                *(_BYTE *)(a1 + 321) = 1;
                *(_BYTE *)(a1 + 357) = 1;
                *(_BYTE *)(a1 + 394) = 1;
                *(_BYTE *)(a1 + 225) = 1;
                *(_BYTE *)(a1 + 272) = 1;
                *(_BYTE *)(a1 + 282) = (*(unsigned int (**)(uint64_t))(*(void *)a1 + 2312LL))(a1) != 0;
                *(_WORD *)(a1 + 273) = 257;
                if (v3 == 20)
                {
                  v35 = sub_1002E6BF0();
                }

                *(_BYTE *)(a1 + 279) = 1;
                *(_WORD *)(a1 + 283) = 257;
                *(_BYTE *)(a1 + 285) = 1;
                *(_BYTE *)(a1 + 292) = 1;
                *(_WORD *)(a1 + 295) = 257;
                *(_BYTE *)(a1 + 299) = 1;
                *(_BYTE *)(a1 + 353) = 1;
                *(_BYTE *)(a1 + 303) = 1;
                *(_BYTE *)(a1 + 297) = 1;
                if (sub_1002CE238())
                {
                  *(_WORD *)(a1 + 290) = 257;
                  *(_DWORD *)(a1 + 286) = 16843009;
                }

                *(_BYTE *)(a1 + 415) = 1;
LABEL_151:
                if (v20)
                {
                  *(_BYTE *)(a1 + 352) = 1;
                  *(_BYTE *)(a1 + 300) = 1;
                  *(_BYTE *)(a1 + 394) = 1;
                  *(_BYTE *)(a1 + 302) = 1;
                  *(_BYTE *)(a1 + 402) = 1;
                  *(_BYTE *)(a1 + 225) = 1;
                  *(_BYTE *)(a1 + 272) = 1;
                  *(_BYTE *)(a1 + 282) = (*(unsigned int (**)(uint64_t))(*(void *)a1 + 2312LL))(a1) != 0;
                  *(_WORD *)(a1 + 273) = 257;
                  *(_BYTE *)(a1 + 277) = 1;
                  *(_WORD *)(a1 + 279) = 257;
                  *(_BYTE *)(a1 + 281) = 1;
                  *(_WORD *)(a1 + 283) = 257;
                  *(_BYTE *)(a1 + 285) = 1;
                  *(_BYTE *)(a1 + 395) = 1;
                  *(_BYTE *)(a1 + 361) = 1;
                  v36 = sub_1002E6BF0();
                }

                v37 = sub_1002E6BF0();
                if ((*(unsigned int (**)(uint64_t))(*(void *)v37 + 352LL))(v37))
                {
                  if (v9 < 0xF && ((0x6251u >> v9) & 1) != 0)
                  {
                    v41 = 1;
                  }

                  else
                  {
                    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(&__p, a1);
                    v38 = std::string::compare(&__p, "C2");
                    v41 = v3 == 23 || v38 >= 0 || v3 == 25;
                  }

                  if (v41) {
                    *(_BYTE *)(a1 + 359) = 1;
                  }
                }

                v42 = sub_1002E6BF0();
                *(_BYTE *)(a1 + 413) = 0;
                if (v10) {
                  *(_BYTE *)(a1 + 360) = 1;
                }
                if (v3 - 21 <= 4)
                {
                  *(_WORD *)(a1 + 267) = 257;
                  *(_WORD *)(a1 + 304) = 257;
                }

                break;
            }

            goto LABEL_181;
          }

          if (v3 >= 0x16)
          {
            *(_BYTE *)(a1 + 354) = 1;
            *(_BYTE *)(a1 + 391) = 1;
            *(_BYTE *)(a1 + 230) = 1;
            *(_BYTE *)(a1 + 422) = 1;
            *(_BYTE *)(a1 + 404) = 1;
            *(_BYTE *)(a1 + 401) = 1;
            (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(&__p, a1);
            if ((char)__p.__r_.__value_.__s.__size_ < 0)
            {
              if (__p.__r_.__value_.__l.__size_ == 2)
              {
                v51 = *(unsigned __int16 *)__p.__r_.__value_.__l.__data_;
                operator delete(__p.__r_.__value_.__l.__data_);
                if (v51 == 12355) {
                  goto LABEL_204;
                }
              }

              else
              {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
            }

            else if (__p.__r_.__value_.__s.__size_ == 2 && LOWORD(__p.__r_.__value_.__l.__data_) == 12355)
            {
              goto LABEL_204;
            }

            *(_BYTE *)(a1 + 421) = 1;
            *(_BYTE *)(a1 + 423) = 1;
LABEL_204:
            id v10 = 1;
            *(_BYTE *)(a1 + 265) = 1;
            if ((v3 & 0xFFFFFFFE) == 0x14) {
              goto LABEL_207;
            }
            (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(&__p, a1);
            v53 = std::string::compare(&__p, "C2");
            if (v3 - 23 < 3 || (v53 & 0x80000000) == 0)
            {
LABEL_207:
              *(_BYTE *)(a1 + 346) = 1;
              *(_BYTE *)(a1 + 240) = 1;
            }

            uint64_t v11 = 1;
LABEL_82:
            (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 16LL))(&__p, a1);
            unint64_t v22 = std::string::compare(&__p, "C2");
            unint64_t v21 = 0;
            v23 = 0;
            v20 = v10;
            if (v22 < 0) {
              goto LABEL_86;
            }
            goto LABEL_85;
          }

          if (v3 == 20)
          {
            id v10 = 0;
            uint64_t v11 = 1;
            *(_BYTE *)(a1 + 346) = 1;
            *(_BYTE *)(a1 + 240) = 1;
            goto LABEL_82;
          }

LABEL_79:
            v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
            v43 = v42;
            v44 = @"apple_wireless_keyboard";
          }

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v46, 8);
}

  v42 = *(unsigned __int16 *)(a4 + 4);
  if (a2 == 3) {
    goto LABEL_88;
  }
  if (v21)
  {
    v59 = WORD6(xmmword_1008F6E30[0]);
    goto LABEL_86;
  }

    sub_100657858();
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid periodic advertising sync transfer received event packet size : %d, expecting ",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v4);
    uint64_t v12 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_46:
    }
      sub_100657858();
  }

    unint64_t v7 = 104LL;
    goto LABEL_9;
  }

  uint64_t v6 = 0LL;
LABEL_8:
  unint64_t v7 = 829LL;
LABEL_9:
  id v8 = qword_1008EDC60;
  *(_WORD *)(qword_1008EDC60 + 66) = 0;
  uint64_t v9 = *(void **)(v8 + 56);
  if (v9)
  {
    sub_1000B1838(v9);
    *(void *)(qword_1008EDC60 + 56) = 0LL;
  }

  sub_10010C410((unsigned __int8 *)&v55);
  if (v6) {
    sub_1000B1838(v6);
  }
  return v7;
}

      v52 = v48 != v46 && v48 == v44;
      v42 = v52;
      if (SHIBYTE(v143) < 0) {
        operator delete(*(void **)buf);
      }
      v26 = __p[23];
    }

    if (v26 < 0) {
      operator delete(*(void **)__p);
    }
    if ((v42 & 1) == 0)
    {
      v85 = (os_log_s *)qword_1008F75C8;
      if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
      {
        sub_100494958(a2, (uint64_t)__p);
        v86 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
        v87 = *((char *)a3 + 23) >= 0 ? a3 : (void *)*a3;
        *(_DWORD *)buf = 136446466;
        *(void *)&buf[4] = v86;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v87;
        _os_log_error_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_ERROR,  "session %{public}s name %{public}s is not allowed to use PipeEndpointPriorityHighLeOnly",  buf,  0x16u);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      goto LABEL_14;
    }
  }

  v133 = a5;
  v132 = a6;
  v134 = a7;
  v135 = a8;
  v53 = *(void **)(a1 + 144);
  if (v53 == v17)
  {
LABEL_119:
    v69 = (os_log_s *)qword_1008F75C8;
    v70 = v133;
    if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_DEFAULT))
    {
      if (v133 < 5 && ((0x17u >> v133) & 1) != 0)
      {
        v71 = (&off_100889948)[v133];
      }

      else if (v133 == 3)
      {
        v71 = "isochronous";
      }

      else
      {
        v71 = "unknown";
      }

      v93 = a3;
      v94 = *((char *)a3 + 23);
      v95 = (void *)*v93;
      sub_100494958(a2, (uint64_t)buf);
      if (v94 >= 0) {
        v96 = v93;
      }
      else {
        v96 = v95;
      }
      v97 = "client";
      if (a4 == 1) {
        v97 = "server";
      }
      *(_DWORD *)__p = 136448002;
      *(void *)&__p[4] = v71;
      if (a4 == 2) {
        v97 = "peer-to-peer";
      }
      if (v143 >= 0) {
        v98 = buf;
      }
      else {
        v98 = *(_BYTE **)buf;
      }
      v99 = "No ";
      *(_WORD *)&__p[12] = 2082;
      *(void *)&__p[14] = v97;
      v100 = "";
      if (v134) {
        v99 = "";
      }
      *(_WORD *)&__p[22] = 2082;
      *(void *)&__p[24] = v96;
      v101 = "NO";
      if (v135) {
        v100 = "NO";
      }
      *(_WORD *)v146 = 2082;
      *(void *)&v146[2] = v98;
      v102 = "Socket";
      if (v132) {
        v102 = "Skywalk";
      }
      *(_WORD *)&v146[10] = 2082;
      *(void *)&v146[12] = v99;
      v147 = 2082;
      v148 = v100;
      v70 = v133;
      v149 = 2082;
      v150 = v102;
      if (v133 == 4) {
        v101 = "YES";
      }
      v151 = 2082;
      v152 = v101;
      _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "Registering %{public}s priority %{public}s endpoint %{public}s for session %{public}s %{public}sencrypti on required, %{public}sERTM, with %{public}s transport, staOnLe:%{public}s.",  __p,  0x52u);
      a3 = v93;
      if (SHIBYTE(v143) < 0) {
        operator delete(*(void **)buf);
      }
    }

    if (*(_BYTE *)(a1 + 56))
    {
      v140 = 0;
      sub_100242CA4(&v140);
      *(_OWORD *)__p = *(_OWORD *)&off_1008895D0;
      *(_OWORD *)&__p[16] = *(_OWORD *)&off_1008895E0;
      *(void *)v146 = sub_100244DF0;
      v103 = *((unsigned __int8 *)a3 + 23);
      if ((v103 & 0x80u) == 0) {
        v104 = a3;
      }
      else {
        v104 = (void *)*a3;
      }
      if ((v103 & 0x80u) != 0) {
        v103 = *((_DWORD *)a3 + 2);
      }
      else {
        v105 = dword_1006BFA50[v70 - 1];
      }
      v106 = sub_10008FA18(v104, (v103 + 1), a4, v105, v134, v135, a9, v70 == 4, (__int128 *)__p);
      if (v106)
      {
        v107 = (os_log_s *)qword_1008F75C8;
        if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
        {
          v124 = *((char *)a3 + 23);
          v125 = (void *)*a3;
          sub_100494958(a2, (uint64_t)v138);
          v126 = v124 >= 0 ? a3 : v125;
          v127 = v139 >= 0 ? v138 : (void **)v138[0];
          *(_DWORD *)buf = 136446722;
          *(void *)&buf[4] = v126;
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v127;
          v143 = 1024;
          v144 = v106;
          _os_log_error_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_ERROR,  "Failed to register endpoint %{public}s for session %{public}s with result %{bluetooth:OI_STATUS}u",  buf,  0x1Cu);
          if (v139 < 0) {
            operator delete(v138[0]);
          }
        }

        sub_100242CD8(&v140);
        goto LABEL_14;
      }

      sub_100242CD8(&v140);
    }

    v108 = (void *)v18[5];
    v109 = operator new(0x30uLL);
    sub_10024E19C(v109, (__int128 *)a3, a4, v70, v132, v134, v135, a9);
    v110 = v108[6];
    v111 = (void *)v108[5];
    if ((unint64_t)v111 >= v110)
    {
      v113 = v108[4];
      v114 = ((uint64_t)v111 - v113) >> 3;
      v115 = v110 - v113;
      v116 = v115 >> 2;
      else {
        v117 = v116;
      }
      if (v117) {
        v118 = (char *)sub_100008BA0((uint64_t)(v108 + 6), v117);
      }
      else {
        v118 = 0LL;
      }
      v119 = &v118[8 * v114];
      v120 = &v118[8 * v117];
      *(void *)v119 = v109;
      v112 = v119 + 8;
      v122 = (char *)v108[4];
      v121 = (char *)v108[5];
      if (v121 != v122)
      {
        do
        {
          v123 = *((void *)v121 - 1);
          v121 -= 8;
          *((void *)v119 - 1) = v123;
          v119 -= 8;
        }

        while (v121 != v122);
        v121 = (char *)v108[4];
      }

      v108[4] = v119;
      v108[5] = v112;
      v108[6] = v120;
      if (v121) {
        operator delete(v121);
      }
    }

    else
    {
      *v111 = v109;
      v112 = v111 + 1;
    }

    unint64_t v22 = 0LL;
    v108[5] = v112;
    goto LABEL_15;
  }

  v54 = *((_BYTE *)a3 + 23);
  v131 = (char)v54;
  v129 = a3[1];
  v130 = v54;
  if ((v54 & 0x80u) == 0) {
    v55 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    v55 = a3[1];
  }
  v128 = (const void *)*a3;
  if ((v54 & 0x80u) == 0) {
    v56 = (unsigned __int8 *)a3;
  }
  else {
    v56 = (unsigned __int8 *)*a3;
  }
  v136 = a3;
LABEL_99:
  v57 = v53[5];
  v59 = *(unsigned __int8 ***)(v57 + 32);
  v58 = *(unsigned __int8 ***)(v57 + 40);
  while (1)
  {
    if (v59 == v58)
    {
      v67 = (void *)v53[1];
      if (v67)
      {
        do
        {
          v68 = v67;
          v67 = (void *)*v67;
        }

        while (v67);
      }

      else
      {
        do
        {
          v68 = (void *)v53[2];
          v52 = *v68 == (void)v53;
          v53 = v68;
        }

        while (!v52);
      }

      v53 = v68;
      a3 = v136;
      if (v68 == v17) {
        goto LABEL_119;
      }
      goto LABEL_99;
    }

    v60 = *v59;
    v61 = (*v59)[23];
    v62 = (v61 & 0x80u) == 0LL ? (*v59)[23] : *((void *)*v59 + 1);
    if (v62 == v55) {
      break;
    }
LABEL_112:
    ++v59;
  }

  if ((v61 & 0x80) == 0)
  {
    if (!(*v59)[23]) {
      goto LABEL_125;
    }
    v63 = v56;
    v64 = *v59;
    while (*v64 == *v63)
    {
      ++v64;
      ++v63;
      if (!--v61) {
        goto LABEL_125;
      }
    }

    goto LABEL_112;
  }

  v65 = v55;
  v66 = memcmp(*(const void **)v60, v56, *((void *)*v59 + 1));
  v55 = v65;
  if (v66) {
    goto LABEL_112;
  }
LABEL_125:
  if (!v60[39])
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
    {
      sub_100494958(v53[4], (uint64_t)__p);
      sub_100662B50();
    }

    goto LABEL_166;
  }

  v72 = *(void *)(a1 + 168);
  v73 = *(void *)(a1 + 176);
  v74 = v131;
  if (v72 == v73)
  {
LABEL_141:
    v81 = (os_log_s *)qword_1008F75C8;
    if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_INFO))
    {
      v82 = (void *)*v136;
      sub_100494958(v53[4], (uint64_t)__p);
      if (v131 >= 0) {
        v83 = v136;
      }
      else {
        v83 = v82;
      }
      if (__p[23] >= 0) {
        v84 = __p;
      }
      else {
        v84 = *(_BYTE **)__p;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&buf[4] = v83;
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v84;
      _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_INFO,  "Delaying registration of endpoint %{public}s as it is currently being unregistered by session %{public}s",  buf,  0x16u);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      v74 = *((_BYTE *)v136 + 23);
    }

    *(void *)__p = a2;
    if (v74 < 0)
    {
      sub_100024238(&__p[8], (void *)*v136, v136[1]);
    }

    else
    {
      *(_OWORD *)&__p[8] = *(_OWORD *)v136;
      *(void *)&__p[24] = v136[2];
    }

    *(_DWORD *)v146 = a4;
    *(_DWORD *)&v146[4] = v133;
    *(_DWORD *)&v146[8] = v132;
    v146[12] = v134;
    v146[13] = v135;
    v146[14] = a9;
    v88 = *(void *)(a1 + 176);
    if (v88 >= *(void *)(a1 + 184))
    {
      v91 = sub_10024EAA0((char **)(a1 + 168), (uint64_t)__p);
      v92 = __p[31];
      *(void *)(a1 + 176) = v91;
      if (v92 < 0) {
        operator delete(*(void **)&__p[8]);
      }
    }

    else
    {
      *(void *)v88 = *(void *)__p;
      v89 = *(_OWORD *)&__p[8];
      *(void *)(v88 + 24) = *(void *)&__p[24];
      *(_OWORD *)(v88 + _Block_object_dispose((const void *)(v1 - 80), 8) = v89;
      memset(&__p[8], 0, 24);
      v90 = *(void *)&v146[7];
      *(void *)(v88 + 32) = *(void *)v146;
      *(void *)(v88 + 39) = v90;
      *(void *)(a1 + 176) = v88 + 48;
    }

    unint64_t v22 = 10LL;
    goto LABEL_15;
  }

  while (2)
  {
    v75 = *(unsigned __int8 *)(v72 + 31);
    v76 = (char)v75;
    if ((v75 & 0x80u) != 0LL) {
      v75 = *(void *)(v72 + 16);
    }
    if (v55 != v75)
    {
LABEL_140:
      v72 += 48LL;
      if (v72 == v73) {
        goto LABEL_141;
      }
      continue;
    }

    break;
  }

  if (v76 >= 0) {
    v77 = (unsigned __int8 *)(v72 + 8);
  }
  else {
    v77 = *(unsigned __int8 **)(v72 + 8);
  }
  if (v131 < 0)
  {
    v79 = v55;
    v80 = memcmp(v128, v77, v129);
    v55 = v79;
    if (!v80)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_165;
      }
      goto LABEL_166;
    }

    goto LABEL_140;
  }

  if (v131)
  {
    v78 = 0LL;
    while (*((unsigned __int8 *)v136 + v78) == v77[v78])
    {
      if (v130 == ++v78)
      {
        if (!os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR)) {
          goto LABEL_166;
        }
        goto LABEL_165;
      }
    }

    goto LABEL_140;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
  {
LABEL_165:
    sub_100494958(*(void *)v72, (uint64_t)__p);
    sub_100662B94();
  }

  v100 = 0;
  v42 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENOverrideMaxDailyShortAPWakes");
  v43 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v42 + 88LL))(v42, buf, __p, &v100);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v43) {
      goto LABEL_87;
    }
  }

  else if (!v43)
  {
    goto LABEL_87;
  }

  v44 = v100;
  *(_DWORD *)(a1 + 22_Block_object_dispose((const void *)(v1 - 80), 8) = (unsigned __int16)v100;
  v45 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v44;
    _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Overriding fMaxDailyShortAPWakeAllowanceInSeconds = %d ",  buf,  8u);
  }

      v7 += 16LL;
      if (v7 == v6)
      {
        v60 = (_OWORD *)v92;
        if ((void)v92 != v6)
        {
          do
          {
            memset(v90, 0, sizeof(v90));
            *(_OWORD *)v90 = *v60;
            sub_10025EB84(v90);
            ++v60;
          }

          while (v60 != *((_OWORD **)&v92 + 1));
          unint64_t v7 = v92;
          goto LABEL_83;
        }

        unint64_t v7 = v6;
        if (v6) {
          goto LABEL_84;
        }
LABEL_85:
        v61 = v69;
        v62 = (void *)v69[1];
        if (v62)
        {
          do
          {
            v63 = v62;
            v62 = (void *)*v62;
          }

          while (v62);
        }

        else
        {
          do
          {
            v63 = (void *)v61[2];
            v64 = *v63 == (void)v61;
            v61 = v63;
          }

          while (!v64);
        }

        uint64_t v3 = v63;
        if (v63 == v68) {
          goto LABEL_95;
        }
        goto LABEL_6;
      }
    }

    id v10 = 0LL;
    uint64_t v11 = (unsigned __int8 *)(*(void *)(v7 + 8) + 24LL);
    while (1)
    {
      uint64_t v12 = *((_DWORD *)v11 - 4);
      if (v12 == 3) {
        break;
      }
      if (v12 == 256)
      {
        uint64_t v13 = *(_DWORD *)v11;
        memset(v90, 0, sizeof(v90));
        v91 = 0LL;
        sub_10002418C(v90, "L2CAP ServiceClass: ");
        memset(&v73, 0, sizeof(v73));
        if (v74 == 3)
        {
          if (WORD1(v74) > 4u)
          {
            v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  *((void *)&v74 + 1)));
            v27 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(void *)&buf[4] = v26;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "service long UUID: %@", buf, 0xCu);
            }

            v28 = *(void **)(a1 + 1304);
            v84[0] = @"kCBMsgArgServiceUUID";
            v84[1] = @"kCBMsgArgPSM";
            v85[0] = v26;
            v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  (unsigned __int16)v13,  v68));
            v85[1] = v29;
            uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v85,  v84,  2LL));
            [v28 addObject:v30];

            v31 = sub_1001EB74C(*((unsigned int **)&v74 + 1));
            std::string::assign(&v73, v31);
          }

          else
          {
            if (WORD1(v74) == 2)
            {
              LOWORD(__p[0]) = bswap32(WORD4(v74)) >> 16;
              unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", __p, 2LL));
              uint64_t v15 = (os_log_s *)qword_1008F7578;
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&buf[4] = DWORD2(v74);
                *(_WORD *)&buf[8] = 2112;
                *(void *)&buf[10] = v14;
                _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "service short UUID: (0x%x) %@",  buf,  0x12u);
              }

              uint64_t v16 = *(void **)(a1 + 1304);
              v88[0] = @"kCBMsgArgServiceUUID";
              v88[1] = @"kCBMsgArgPSM";
              v89[0] = v14;
              uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  (unsigned __int16)v13,  v68));
              v89[1] = v17;
              unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v89,  v88,  2LL));
              [v16 addObject:v18];
            }

            else
            {
              LODWORD(__p[0]) = bswap32(DWORD2(v74));
              v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", __p));
              v39 = (os_log_s *)qword_1008F7578;
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&buf[4] = DWORD2(v74);
                *(_WORD *)&buf[8] = 2112;
                *(void *)&buf[10] = v38;
                _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "service short UUID: (0x%x) %@",  buf,  0x12u);
              }

              v40 = *(void **)(a1 + 1304);
              v86[0] = @"kCBMsgArgServiceUUID";
              v86[1] = @"kCBMsgArgPSM";
              v87[0] = v38;
              v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  (unsigned __int16)v13,  v68));
              v87[1] = v41;
              v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v87,  v86,  2LL));
              [v40 addObject:v42];
            }

            v43 = sub_1001EBA4C(DWORD2(v74));
            std::string::assign(&v73, v43);
          }

          uint64_t v4 = (v4 + 1);
        }

        memset(buf, 0, 24);
        sub_10002418C(buf, "\n");
        __p[0] = 0LL;
        __p[1] = 0LL;
        cap = 0LL;
        sub_1003D4034((const void **)v90, (const void **)&v73.__r_.__value_.__l.__data_, &v82);
        if ((buf[23] & 0x80u) == 0) {
          v44 = buf;
        }
        else {
          v44 = *(uint8_t **)buf;
        }
        if ((buf[23] & 0x80u) == 0) {
          v45 = buf[23];
        }
        else {
          v45 = *(void *)&buf[8];
        }
        v46 = std::string::append(&v82, (const std::string::value_type *)v44, v45);
        v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
        cap = v46->__r_.__value_.__l.__cap_;
        *(_OWORD *)__p = v47;
        v46->__r_.__value_.__l.__size_ = 0LL;
        v46->__r_.__value_.__l.__cap_ = 0LL;
        v46->__r_.__value_.__r.__words[0] = 0LL;
        v48 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          v49 = __p;
          if (cap < 0) {
            v49 = (void **)__p[0];
          }
          goto LABEL_68;
        }

        goto LABEL_69;
      }

LABEL_80:
          v46 = objc_claimAutoreleasedReturnValue([v42 localizedStringForKey:v44 value:&stru_1008A57D8 table:@"CBLocalizable"]);
LABEL_81:
          v34 = (void *)v46;

          goto LABEL_82;
        }

        -[CBDevice batteryLevelRight](v5, "batteryLevelRight");
        uint64_t v16 = v21;
        unint64_t v18 = -[CBDevice batteryStateRight](v5, "batteryStateRight");
        v19 = 5LL;
        v20 = 4LL;
      }

      unint64_t v22 = "Headset";
      goto LABEL_27;
    }
  }

  v46 = location;

  return v46;
}

          v74 = (id *)(v139 + 5);
          v100 = (id)v139[5];
          NSAppendPrintF_safe(&v100, "}");
          objc_storeStrong(v74, v100);
          v97 = &off_10087FAA8;
          if (v98) {
            sub_1002CD254(v98);
          }
          v34 += 12;
          v38 = ", ";
        }

        while (v34 != v88);
      }
    }

    v97 = 0LL;
    v98 = 0LL;
    v99 = 0LL;
    sub_100050EE8( (char *)&v97,  *((__int128 **)v87 + 1),  *((__int128 **)v87 + 2),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)v87 + 2) - *((void *)v87 + 1)) >> 2));
    if (v97 != v98)
    {
      v75 = (id *)(v139 + 5);
      v96 = (id)v139[5];
      NSAppendPrintF_safe(&v96, ", UUIDs: ");
      objc_storeStrong(v75, v96);
      v76 = (unsigned int *)v97;
      v77 = v98;
      if (v97 != v98)
      {
        v78 = "";
        do
        {
          v79 = (id *)(v139 + 5);
          v95 = (id)v139[5];
          sub_1006344B4((uint64_t)v76, &__p);
          if (v94 >= 0) {
            p_p = (const char *)&__p;
          }
          else {
            p_p = (const char *)__p;
          }
          NSAppendPrintF_safe(&v95, "%s%s", v78, p_p);
          objc_storeStrong(v79, v95);
          if (v94 < 0) {
            operator delete(__p);
          }
          v76 += 5;
          v78 = ", ";
        }

        while (v76 != v77);
      }
    }

    v81 = *((_DWORD *)v87 + 42);
    if (v81)
    {
      v82 = (id *)(v139 + 5);
      v91 = (id)v139[5];
      if (v81 >= 0x20000)
      {
        if (v81 >= 327680)
        {
          if (v81 > 589824)
          {
            if (v81 <= 2147418111)
            {
              switch(v81)
              {
                case 589825:
                  v84 = "FindNearbyPencil";
                  break;
                case 655360:
                  v84 = "AccessDigitalHomeKey";
                  break;
                case 786432:
                  v84 = "ProxControlDeviceClose";
                  break;
                default:
LABEL_233:
                  v84 = "?";
                  break;
              }
            }

            else
            {
              switch(v81)
              {
                case 2147418112:
                  v84 = "InternalTestNoLockScan";
                  break;
                case 2147418113:
                  v84 = "InternalTestNoScreenOffScan";
                  break;
                case 2147418114:
                  v84 = "InternalTestScanWithNoDups";
                  break;
                case 2147418115:
                  v84 = "InternalTestScanWithDups";
                  break;
                case 2147418116:
                  v84 = "InternalTestScanFor20Seconds";
                  break;
                case 2147418117:
                  v84 = "InternalTestActiveScan";
                  break;
                case 2147418118:
                  v84 = "InternalTestUUIDScan";
                  break;
                case 2147418119:
                  v84 = "InternalTestScanFor10ClockSeconds";
                  break;
                case 2147418120:
                  v84 = "InternalTestScanBoost";
                  break;
                default:
                  goto LABEL_233;
              }
            }
          }

          else if (v81 > 458752)
          {
            switch(v81)
            {
              case 524288:
                v84 = "ADPD";
                break;
              case 524289:
                v84 = "ADPDBuffer";
                break;
              case 524290:
                v84 = "MicroLocation";
                break;
              case 524291:
                v84 = "MicroLocationLeech";
                break;
              default:
                if (v81 == 458753)
                {
                  v84 = "PrecisionFindingFindee";
                }

                else
                {
                  if (v81 != 589824) {
                    goto LABEL_233;
                  }
                  v84 = "FindNearbyRemote";
                }

                break;
            }
          }

          else
          {
            switch(v81)
            {
              case 393216:
                v84 = "CaptiveNetworkJoin";
                break;
              case 393217:
                v84 = "UseCaseSIMTransfer";
                break;
              case 393218:
                v84 = "MacSetup";
                break;
              case 393219:
                v84 = "AppleIDSignIn";
                break;
              case 393220:
                v84 = "AppleIDSignInSettings";
                break;
              default:
                if (v81 == 327680)
                {
                  v84 = "RapportThirdParty";
                }

                else
                {
                  if (v81 != 458752) {
                    goto LABEL_233;
                  }
                  v84 = "PrecisionFindingFinder";
                }

                break;
            }
          }
        }

        else
        {
          switch(v81)
          {
            case 131072:
              v84 = "SharingDefault";
              break;
            case 131073:
              v84 = "SharingPhoneAutoUnlock";
              break;
            case 131074:
              v84 = "SharingSiriWatchAuth";
              break;
            case 131075:
              v84 = "SharingMacAutoUnlock";
              break;
            case 131076:
              v84 = "SharingEDTScreenOn";
              break;
            case 131077:
              v84 = "SharingEDTWiFiDisabled";
              break;
            case 131078:
              v84 = "SharingEDTWombatEligibleAsDefaultCamera";
              break;
            case 131079:
              v84 = "SharingEDTWombatCameraPicker";
              break;
            case 131080:
              v84 = "SharingWombatBackground";
              break;
            case 131081:
              v84 = "SharingUniversalControl";
              break;
            case 131082:
              v84 = "SharingPeopleProximity";
              break;
            case 131083:
              v84 = "SharingEDTEnsembleOpenDisplayPrefs";
              break;
            case 131084:
              v84 = "SharingEDTNearbydMotionStopped";
              break;
            case 131085:
              v84 = "SharingDoubleBoostGenericScan";
              break;
            case 131086:
              v84 = "SharingEDTIncomingAdvertisement ";
              break;
            case 131087:
              v84 = "SharingEDTWombatStreamStart";
              break;
            case 131088:
              v84 = "SharingOYAutoUnlock";
              break;
            case 131089:
              goto LABEL_233;
            case 131090:
              v84 = "SharingAirDrop";
              break;
            case 131091:
              v84 = "SharingNearbyInvitationHost";
              break;
            case 131092:
              v84 = "SharingNearbyInvitationParticipant";
              break;
            case 131093:
              v84 = "SharingAirDropAskToAirDrop";
              break;
            case 131094:
              v84 = "SharingAirDropTempIdentity";
              break;
            case 131095:
              v84 = "SharingAirDropNeedsCLink";
              break;
            case 131096:
              v84 = "SharingRemoteWidgetUpdate";
              break;
            case 131097:
              v84 = "SharingCountryCodeUpdate";
              break;
            case 131098:
              v84 = "SharingMacPhoneAutoUnlock";
              break;
            case 131099:
              v84 = "SharingVisionProDiscovery";
              break;
            case 131100:
              v84 = "SharingVisionProStateChange";
              break;
            case 131101:
              v84 = "SharingContinuityScreen";
              break;
            case 131102:
              v84 = "SharingEDTRemoteDisplay";
              break;
            default:
              if (v81 == 196608)
              {
                v84 = "DigitalIDTSA";
              }

              else
              {
                if (v81 != 0x40000) {
                  goto LABEL_233;
                }
                v84 = "DigitalCarKeyThirdParty";
              }

              break;
          }
        }
      }

      else
      {
        switch(v81)
        {
          case 65536:
            v84 = "FindMyAction";
            break;
          case 65537:
            v84 = "FindMyBackground";
            break;
          case 65538:
            v84 = "FindMyActionHELE";
            break;
          case 65539:
            v84 = "FindMyBackgroundHELE";
            break;
          case 65540:
            v84 = "FindMyActionTransient";
            break;
          case 65541:
            v84 = "FindMyBackgroundTransient";
            break;
          case 65542:
            v84 = "FindMyActionHELETransient";
            break;
          case 65543:
            v84 = "FindMyBackgroundHELETransient";
            break;
          case 65544:
            v84 = "FindMyNotOptedIn";
            break;
          case 65545:
            v84 = "FindMyOptedIn";
            break;
          case 65546:
            v84 = "FindMySepAlertsEnabled";
            break;
          case 65547:
            v84 = "FindMyTemporaryAggressiveLegacy";
            break;
          case 65548:
            v84 = "FindMyTemporaryLongAggressive";
            break;
          case 65549:
            v84 = "FindMyBTFindingUserInitiated";
            break;
          case 65550:
            v84 = "FindMyHELE";
            break;
          case 65551:
            v84 = "FindMyBeaconOnDemand";
            break;
          case 65552:
            v84 = "FindMyWildTimedScan";
            break;
          case 65553:
            v84 = "FindMyBackgroundLeechScan";
            break;
          case 65554:
            v84 = "FindMySnifferMode";
            break;
          case 65555:
            v84 = "FindMyUnpair";
            break;
          case 65556:
            v84 = "FindMyUnpairHELE";
            break;
          case 65557:
            v84 = "FindMyPlaySound";
            break;
          case 65558:
            v84 = "FindMyPlaySoundHELE";
            break;
          case 65559:
            v84 = "FindMyNotOptedInBeepOnMoveWaking";
            break;
          case 65560:
            v84 = "FindMyUTTransient";
            break;
          case 65561:
            v84 = "FindMyUTHELETransient";
            break;
          default:
            v83 = v81 - 1;
            v84 = "HealthKit";
            switch(v83)
            {
              case 0:
                goto LABEL_234;
              case 1:
                v84 = "HomeKit";
                break;
              case 2:
                v84 = "FindMyObjectConnection";
                break;
              case 3:
                v84 = "FindMyObjectConnectionTransient";
                break;
              case 4:
                v84 = "MIDI";
                break;
              case 5:
                v84 = "Continuity";
                break;
              case 6:
                v84 = "InstantHotSpot";
                break;
              case 7:
                v84 = "NearBy";
                break;
              case 8:
                v84 = "Sharing";
                break;
              case 9:
                v84 = "HearingSupport";
                break;
              case 10:
                v84 = "Magnet";
                break;
              case 11:
                v84 = "HID";
                break;
              case 12:
                v84 = "LEA";
                break;
              case 13:
                v84 = "External";
                break;
              case 14:
                v84 = "ExternalMedical";
                break;
              case 15:
                v84 = "ExternalLock";
                break;
              case 16:
                v84 = "ExternalWatch";
                break;
              case 17:
                v84 = "SmartRouting";
                break;
              case 18:
                v84 = "DigitalID";
                break;
              case 19:
                v84 = "DigitalKey";
                break;
              case 20:
                v84 = "DigitalCarKey";
                break;
              case 21:
                v84 = "HeySiri";
                break;
              case 22:
                v84 = "ThirdPartyApp";
                break;
              case 23:
                v84 = "CNJ";
                break;
              default:
                switch("HealthKit")
                {
                  case 0x100u:
                    v84 = "DevicePresenceDetection";
                    break;
                  case 0x101u:
                    v84 = "AudioBox";
                    break;
                  case 0x102u:
                    v84 = "SIMTransfer";
                    break;
                  case 0x103u:
                    v84 = "ProximityScreenOnLeechScan";
                    break;
                  case 0x104u:
                    v84 = "MacMigrate";
                    break;
                  case 0x107u:
                    v84 = "HIDUARTService";
                    break;
                  case 0x108u:
                    v84 = "AccessibilitySwitchControlPairing";
                    break;
                  case 0x109u:
                    v84 = "BaseBandFastConnect";
                    break;
                  case 0x10Au:
                    v84 = "SafetyAlerts";
                    break;
                  case 0x10Bu:
                    v84 = "LECarPlay";
                    break;
                  case 0x10Cu:
                    v84 = "TCCBluetooth";
                    break;
                  case 0x10Du:
                    v84 = "AOPBufferLeech";
                    break;
                  default:
                    goto LABEL_233;
                }

                break;
            }

            break;
        }
      }

      sub_1001081C8((__int128 *)a1, 1, 1);
      v91 = dword_1008F29B4;
      if (dword_1008F29B4)
      {
        v92 = 0;
        do
        {
          v93 = v92;
          v94 = &qword_1008F29F0[134 * v92];
          if ((unsigned __int16 *)*v94 == a1)
          {
            *(void *)&v159 = 0LL;
            sub_1000B080C((uint64_t)&v159);
            v95 = SWORD2(v159) + 1000 * v159;
            v96 = SWORD2(qword_1008F29F0[134 * v93 + 24]) + 1000 * LODWORD(qword_1008F29F0[134 * v93 + 24]);
            if (v95 == v96) {
              v97 = 0xFFFFFFFFLL;
            }
            else {
              v97 = 8 * HIDWORD(qword_1008F29F0[134 * v93 + 11]) / (v95 - v96);
            }
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"Done with connection, %d total bytes sent in %d seconds (%d kbps)",  v98,  v99,  v100,  v101,  v102,  v103,  v104,  HIDWORD(qword_1008F29F0[134 * v93 + 11]));
              v105 = (os_log_s *)sub_100086554(0x56u);
              if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
              {
                v106 = sub_1001EDDCC();
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = v106;
                _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }

            if (*((void *)&xmmword_1008F29B8 + 1)) {
              (*((void (**)(unsigned __int16 *, uint64_t, uint64_t))&xmmword_1008F29B8 + 1))(a1, 1LL, v97);
            }
            v107 = HIDWORD(qword_1008F29F0[134 * v93 + 6]);
            if ((_DWORD)v107) {
              sub_1001EEB14(v107);
            }
            v108 = &qword_1008F29F0[134 * v93];
            v111 = (void *)v108[8];
            v110 = v108 + 8;
            v109 = v111;
            if (v111)
            {
              sub_1000B1838(v109);
              *v110 = 0LL;
              LODWORD(qword_1008F29F0[134 * v93 + 9]) = 0;
            }

            v112 = dword_1008F29B4;
            v91 = --dword_1008F29B4;
            if (v112 != 1) {
              memcpy(&qword_1008F29F0[134 * (v112 - 2)], v94, 0x430uLL);
            }
            bzero(&qword_1008F29F0[134 * v91], 0x430uLL);
            v92 = 0;
          }

          else
          {
            ++v92;
          }
        }

        while (v92 < v91);
      }

    sub_100657858();
    return 101LL;
  }

  v35 = (_DWORD *)v34;
  v36 = 0LL;
  while (!sub_10012D98C(v35))
  {
    ++v36;
    v35 = (_DWORD *)((char *)v35 + 7);
    if (v36 >= v165[0]) {
      goto LABEL_19;
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Already connected to this address.", v61, v62, v63, v64, v65, v66, v67, v159);
    v68 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 133LL;
}

  if (((v94 | v93) & 4) != 0) {
    v96 = sub_1001CD768( v13[78],  byte_1008D8ED3,  (v93 & v94 & 8) != 0);
  }
  else {
    v96 = 1;
  }
LABEL_83:
  v13[16] = v96;
  result = sub_1001CD880((uint64_t)v13, 0);
  if ((_DWORD)result) {
    goto LABEL_73;
  }
  return result;
}

    if (qword_1008D5F00 != -1) {
      dispatch_once(&qword_1008D5F00, &stru_100895718);
    }
    sub_100409094((uint64_t)off_1008D5EF8, 0LL, 0);
    if (qword_1008D60D0 != -1) {
      dispatch_once(&qword_1008D60D0, &stru_1008956D8);
    }
    memset(&v39, 0, sizeof(v39));
    uint64_t v24 = sub_100424360((int64x2_t *)off_1008D60C8, v9, a2, &v39, 2LL);
    return v24;
  }

  v32 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v39.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "BTDeviceConnectServicesWithParameters, BTDeviceConnectOwnerNoMagicPairing",  (uint8_t *)&v39,  2u);
  }

  sub_1003D7014(v9, 1);
  __p[0] = 0LL;
  __p[1] = 0LL;
  if (*a4 == 0LL) {
    goto LABEL_80;
  }
  v33 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v39.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "BTDeviceConnectServicesWithParameters, connectwithLinkey",  (uint8_t *)&v39,  2u);
  }

  memset(&v39, 0, 20);
  sub_10052525C((uint64_t)&v39, a4, 5u);
  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_100895738);
  }
  uint64_t v24 = sub_10053584C((uint64_t)off_1008D67B0, (unsigned __int8 *)v9, (__n128 *)&v39, 0);
LABEL_73:
  nullsub_63(&v39, v30);
  if (!(_DWORD)v24) {
    goto LABEL_80;
  }
  return v24;
}

  *a3 = v10;
  if (v45)
  {
    v46 = v45;
    operator delete(v45);
  }

  return 0LL;
}

        v12 += 2LL;
      }

      if (v79 != 6)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
          sub_10067D12C(&v74, v75);
        }
        goto LABEL_80;
      }

      uint64_t v30 = WORD1(v79);
      if (WORD1(v79))
      {
        v31 = 0LL;
        v32 = 0LL;
        do
        {
          if (*(_BYTE *)(*((void *)&v79 + 1) + v31) == 6)
          {
            v33 = *((void *)&v79 + 1) + v31;
            v34 = qword_1008F72C0;
            *(_DWORD *)(qword_1008F72C0 + 14_Block_object_dispose((const void *)(v1 - 80), 8) = *(_DWORD *)(*(void *)(*((void *)&v79 + 1) + v31 + 8) + 8LL);
            *(_WORD *)(v34 + 152) = *(_DWORD *)(*(void *)(v33 + 8) + 24LL);
          }

          else
          {
            v35 = (os_log_s *)qword_1008F75D8;
            if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "AttributeValue inside OI_ATTRID_BluetoothProfileDescriptorList wasn't a OI_DATAELEM_SEQ, skipping",  buf,  2u);
              uint64_t v30 = WORD1(v79);
            }
          }

          ++v32;
          v31 += 16LL;
        }

        while (v32 < v30);
        unint64_t v14 = (int)__p[1];
LABEL_58:
        if (v14 != 4) {
          goto LABEL_71;
        }
        if (v79 != 6)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
            sub_10067D12C(&v72, v73);
          }
          goto LABEL_80;
        }

        if (WORD1(v79))
        {
          v36 = 0LL;
          v37 = 0LL;
          do
          {
            if (*(_BYTE *)(*((void *)&v79 + 1) + v36) == 6)
            {
              v38 = *(void *)(*((void *)&v79 + 1) + v36 + 8);
              v39 = *(unsigned __int16 *)(v38 + 8);
              v40 = *(_DWORD *)(v38 + 24);
              if (v39 == 25)
              {
                sub_1003DB30C(*(void *)(qword_1008F72C0 + 112), v40);
              }

              else if (v39 == 23)
              {
                sub_1003DB3E8(*(void *)(qword_1008F72C0 + 112), v40);
              }
            }

            else if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
            {
              sub_10067D100(&v70, v71);
            }

            ++v37;
            v36 += 16LL;
          }

          while (v37 < WORD1(v79));
          unint64_t v14 = (int)__p[1];
LABEL_71:
          if (v14 == 785)
          {
            if (v79 != 1)
            {
              if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
                sub_10067D0D4(&v68, v69);
              }
              goto LABEL_80;
            }

            *(_WORD *)(qword_1008F72C0 + 154) = WORD4(v79);
          }
        }
      }

      if (sub_10025FD88(&v78, (uint64_t)&v79))
      {
        *(void *)buf = &__p[1];
        v41 = sub_1002DBC4C( (uint64_t **)&qword_1008F0AD0,  (unsigned int *)&__p[1],  (uint64_t)&unk_1006C2518,  (_DWORD **)buf);
        *(_OWORD *)(v41 + 5) = v78;
      }

      goto LABEL_80;
    }

  v32 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionCM_AND_Mask");
  v33 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t *))(*(void *)v32 + 88LL))(v32, buf, __p, &v58);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v33) {
      goto LABEL_88;
    }
  }

  else if (!v33)
  {
    goto LABEL_88;
  }

  v34 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v58;
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionCM_AND_Mask (%d)",  buf,  8u);
  }

LABEL_155:
}

id sub_10000D178()
{
  if (qword_1008D9E30 != -1) {
    dispatch_once(&qword_1008D9E30, &stru_10087F680);
  }
  return (id)qword_1008D9E10;
}

void sub_10000D1B8(id a1, NSString *a2, BOOL *a3)
{
  uint64_t v3 = a2;
  id v4 = sub_10000D178();
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    unint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v6, 0xCu);
  }
}

LABEL_110:
        v109 = (id *)(v240 + 5);
        v210 = (id)v240[5];
        NSAppendPrintF_safe(&v210, "\n");
        objc_storeStrong(v109, v210);
        goto LABEL_111;
      }

      goto LABEL_106;
    }

            ++v21;
            v20 = *(unsigned __int8 *)(*(void *)(a2 + 8) + v21);
            if (!*(_BYTE *)(*(void *)(a2 + 8) + v21)) {
              goto LABEL_121;
            }
            break;
          case 'o':
            v34 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_190:
              v119 = "ByteStream_NumReadBytesAvail(*pBs) >= (10)";
LABEL_192:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2745,  v119);
            }

            v35 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v119 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_192;
            }

            goto LABEL_78;
          case 'p':
            v36 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_194:
              v120 = "ByteStream_NumReadBytesAvail((*pBs)) >= (sizeof(*pVal))";
LABEL_196:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2665,  v120);
            }

            v37 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v120 = "((*pBs)).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_196;
            }

            goto LABEL_82;
          case 'w':
            v75 = (const void **)a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_198:
              v121 = "ByteStream_NumReadBytesAvail(*pBs) >= (72)";
LABEL_200:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2751,  v121);
            }

            v76 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v121 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_200;
            }

            memmove((void *)(*a3 + v76), *v75, 0x48uLL);
            v33 = *((_WORD *)a3 + 6) + 72;
            goto LABEL_87;
          case 'z':
            v77 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_202:
              v122 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_204:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2626,  v122);
            }

            v78 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v122 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_204;
            }

            v79 = *(_DWORD *)v77;
            v80 = *a3;
            *((_WORD *)a3 + 6) = v78 + 1;
            *(_BYTE *)(v80 + v7_Block_object_dispose((const void *)(v1 - 80), 8) = v79;
            if (a6) {
              *a6 = v79;
            }
            goto LABEL_110;
          default:
            switch(v20)
            {
              case '1':
                v27 = a1++;
                if (*((_BYTE *)a3 + 15))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_150:
                  v108 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_152:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2577,  v108);
                }

                v28 = *((unsigned __int16 *)a3 + 6);
                if (*((_BYTE *)a3 + 14) != 2)
                {
                  v108 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_152;
                }

                v29 = *(_DWORD *)v27;
                uint64_t v30 = *a3;
                *((_WORD *)a3 + 6) = v28 + 1;
                *(_BYTE *)(v30 + v2_Block_object_dispose((const void *)(v1 - 80), 8) = v29;
                break;
              case '2':
                v81 = a1++;
                if (*((_BYTE *)a3 + 15))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_206:
                  v123 = "ByteStream_NumReadBytesAvail(*pBs) >= 2";
LABEL_208:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2584,  v123);
                }

                v82 = *((unsigned __int16 *)a3 + 6);
                if (*((_BYTE *)a3 + 14) != 2)
                {
                  v123 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_208;
                }

                v83 = *(_DWORD *)v81;
                *(_BYTE *)(*a3 + v82) = v83;
                *(_BYTE *)(*a3 + *((unsigned __int16 *)a3 + 6) + 1) = BYTE1(v83);
                v61 = *((_WORD *)a3 + 6) + 2;
                goto LABEL_109;
              case '3':
                v84 = a1++;
                if (*((_BYTE *)a3 + 15))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_210:
                  v124 = "ByteStream_NumReadBytesAvail(*pBs) >= 3";
LABEL_212:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2591,  v124);
                }

                v85 = *((unsigned __int16 *)a3 + 6);
                if (*((_BYTE *)a3 + 14) != 2)
                {
                  v124 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_212;
                }

                v86 = *(_DWORD *)v84;
                *(_BYTE *)(*a3 + v85) = v86;
                *(_BYTE *)(*a3 + *((unsigned __int16 *)a3 + 6) + 1) = BYTE1(v86);
                *(_BYTE *)(*a3 + *((unsigned __int16 *)a3 + 6) + 2) = BYTE2(v86);
                v61 = *((_WORD *)a3 + 6) + 3;
                goto LABEL_109;
              case '4':
                v87 = a1++;
                if (*((_BYTE *)a3 + 15))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_214:
                  v125 = "ByteStream_NumReadBytesAvail(*pBs) >= 4";
LABEL_216:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2598,  v125);
                }

                v88 = *((unsigned __int16 *)a3 + 6);
                if (*((_BYTE *)a3 + 14) != 2)
                {
                  v125 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_216;
                }

                v89 = *(_DWORD *)v87;
                *(_BYTE *)(*a3 + v8_Block_object_dispose((const void *)(v1 - 80), 8) = v89;
                *(_BYTE *)(*a3 + *((unsigned __int16 *)a3 + 6) + 1) = BYTE1(v89);
                *(_BYTE *)(*a3 + *((unsigned __int16 *)a3 + 6) + 2) = BYTE2(v89);
                *(_BYTE *)(*a3 + *((unsigned __int16 *)a3 + 6) + 3) = HIBYTE(v89);
                v61 = *((_WORD *)a3 + 6) + 4;
                goto LABEL_109;
              case '8':
                v38 = a1++;
                if (*((_BYTE *)a3 + 15))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_218:
                  v126 = "ByteStream_NumReadBytesAvail(*pBs) >= (8)";
LABEL_220:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2605,  v126);
                }

                v39 = *((unsigned __int16 *)a3 + 6);
                if (*((_BYTE *)a3 + 14) != 2)
                {
                  v126 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_220;
                }

                goto LABEL_108;
              default:
                goto LABEL_128;
            }

            goto LABEL_110;
        }
      }
    }
  }

LABEL_99:
    v99 = (id *)(v240 + 5);
    v214 = (id)v240[5];
    NSAppendPrintF_safe(&v214, "\n");
    objc_storeStrong(v99, v214);
    goto LABEL_100;
  }

  v95 = (id *)(v240 + 5);
  v216 = (id)v240[5];
  NSAppendPrintF_safe(&v216, "\n");
  objc_storeStrong(v95, v216);
  v96 = (id *)(v240 + 5);
  v215 = (id)v240[5];
  v97 = CUDescriptionWithLevel(v167, v7);
  v98 = (void *)objc_claimAutoreleasedReturnValue(v97);
  NSAppendPrintF_safe(&v215, "%@\n", v98);
  objc_storeStrong(v96, v215);

  if (!v170) {
    goto LABEL_101;
  }
  if (v171 >= 0xB) {
    goto LABEL_99;
  }
LABEL_100:
  v100 = (id *)(v240 + 5);
  v213 = (id)v240[5];
  v101 = CUDescriptionWithLevel(v170, v7);
  v102 = (void *)objc_claimAutoreleasedReturnValue(v101);
  NSAppendPrintF_safe(&v213, "%@\n", v102);
  objc_storeStrong(v100, v213);

LABEL_101:
  if (v166) {
    v103 = v171 > 0xA;
  }
  else {
    v103 = 1;
  }
  if (!v103)
  {
    if (v171 < 0xB)
    {
LABEL_107:
      v105 = (id *)(v240 + 5);
      v211 = (id)v240[5];
      v106 = CUDescriptionWithLevel(v166, v7);
      v107 = (void *)objc_claimAutoreleasedReturnValue(v106);
      NSAppendPrintF_safe(&v211, "%@\n", v107);
      objc_storeStrong(v105, v211);

      goto LABEL_108;
    }

        if (v53 <= ++v25)
        {
          sub_1001EE0E4("[bm3_usb] ConfigureInterfaces failed with 0x%x\n", v23);
          goto LABEL_42;
        }
      }

      *(_WORD *)(v16 + 24) = 256;
      if (*(_WORD *)(v16 + 20) == 1452
        && (unsigned __int16)*v50 - 33424 <= 6
        && ((1 << (*v50 + 112)) & 0x53) != 0)
      {
        *(_WORD *)(v16 + 24) = 770;
      }

      v28 = IOIteratorNext(v59);
      if (v28)
      {
        v29 = v28;
        while (1)
        {
          theInterface = 0LL;
          theScore = 0;
          v55 = 0LL;
          v54 = 0;
          uint64_t v30 = CFUUIDGetConstantUUIDWithBytes( 0LL,  0x2Du,  0x97u,  0x86u,  0xC6u,  0x9Eu,  0xF3u,  0x11u,  0xD4u,  0xADu,  0x51u,  0,  0xAu,  0x27u,  5u,  0x28u,  0x61u);
          v31 = CFUUIDGetConstantUUIDWithBytes( 0LL,  0xC2u,  0x44u,  0xE8u,  0x58u,  0x10u,  0x9Cu,  0x11u,  0xD4u,  0x91u,  0xD4u,  0,  0x50u,  0xE4u,  0xC6u,  0x42u,  0x6Fu);
          v23 = IOCreatePlugInInterfaceForService(v29, v30, v31, &theInterface, &theScore);
          IOObjectRelease(v29);
          if (v23 || (v32 = theInterface) == 0LL)
          {
            if (!v23) {
              v23 = -1;
            }
            unint64_t v7 = (_BYTE *)(&xmmword_1008DDFF8 + 8);
            goto LABEL_98;
          }

          QueryInterface = (*theInterface)->QueryInterface;
          v34 = CFUUIDGetConstantUUIDWithBytes( kCFAllocatorSystemDefault,  0x87u,  0x52u,  0x66u,  0x3Bu,  0xC0u,  0x7Bu,  0x4Bu,  0xAEu,  0x95u,  0x84u,  0x22u,  3u,  0x2Fu,  0xABu,  0x9Cu,  0x5Au);
          v35 = CFUUIDGetUUIDBytes(v34);
          if (((unsigned int (*)(IOCFPlugInInterface **, void, void, uint64_t *))QueryInterface)( v32,  *(void *)&v35.byte0,  *(void *)&v35.byte8,  &v55))
          {
            v36 = 1;
          }

          else
          {
            v36 = v55 == 0;
          }

          if (v36)
          {
            ((void (*)(IOCFPlugInInterface **))(*theInterface)->Release)(theInterface);
            v23 = -1;
            goto LABEL_106;
          }

          v37 = (*(uint64_t (**)(void))(*(void *)v55 + 136LL))();
          if (v37) {
            break;
          }
          uint64_t v3 = (CFRunLoopRef *)(&xmmword_1008DDFF8 + 8);
          if (v54 == *(_BYTE *)(v16 + 24))
          {
            *(void *)(v16 + 56) = theInterface;
            v38 = v55;
            v39 = (*(uint64_t (**)(uint64_t))(*(void *)v55 + 64LL))(v55);
            if (!v39)
            {
              v64[0] = 0;
              char *v19 = v38;
              v40 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v38 + 152LL))(v38, v64);
              if (v40)
              {
                v23 = v40;
              }

              else
              {
                if (v64[0] == 3)
                {
                  v41 = 1;
                  while (1)
                  {
                    v63 = 0;
                    v62 = 0;
                    v61 = 0;
                    v60 = 0;
                    v42 = (*(uint64_t (**)(uint64_t, void, char *, __int16 *, char *, __int16 *, char *))(*(void *)v38 + 208LL))( v38,  v41,  (char *)&v63 + 1,  &v63,  &v62,  &v61,  &v60);
                    if (v42) {
                      break;
                    }
                    v43 = v62;
                    if (v62 == 3)
                    {
                      v44 = HIBYTE(v63);
                      if (HIBYTE(v63) != 1) {
                        goto LABEL_92;
                      }
                      v45 = v16 + 98;
                    }

                    else if (v62 == 2)
                    {
                      v44 = HIBYTE(v63);
                      v45 = v16 + 114;
                      if (HIBYTE(v63) != 1)
                      {
                        if (HIBYTE(v63)) {
                          goto LABEL_92;
                        }
                        v45 = v16 + 122;
                      }
                    }

                    else
                    {
                      if (v62 || HIBYTE(v63) != 3)
                      {
LABEL_92:
                        v23 = -1;
                        goto LABEL_94;
                      }

                      v44 = 1;
                      v45 = v16 + 106;
                    }

                    *(_WORD *)v45 = *(unsigned __int8 *)(v16 + 24);
                    *(_BYTE *)(v45 + 2) = v43;
                    *(_BYTE *)(v45 + 3) = v44;
                    *(_WORD *)(v45 + 4) = v61;
                    *(_BYTE *)(v45 + 7) = v41;
                    *(_BYTE *)(v45 + 6) = v63 & 0xF | (v44 << 7);
                    if (v64[0] < ++v41)
                    {
                      uint64_t v3 = (CFRunLoopRef *)(&xmmword_1008DDFF8 + 8);
                      goto LABEL_90;
                    }
                  }

                  v23 = v42;
LABEL_94:
                  unint64_t v7 = (_BYTE *)(&xmmword_1008DDFF8 + 8);
                  uint64_t v3 = (CFRunLoopRef *)(&xmmword_1008DDFF8 + 8);
LABEL_95:
                  if (*v19)
                  {
                    (*(void (**)(void))(*(void *)*v19 + 72LL))(*v19);
                    char *v19 = 0LL;
                  }

  if (sub_1002E8D94())
  {
    v44 = sub_1002E8D94();
    (*(void (**)(uint64_t, _BYTE *))(*(void *)v44 + 256LL))(v44, v62);
  }

  if ((v62[39] & 0x80000000) != 0) {
    operator delete(*(void **)&v62[16]);
  }
  return sub_100242CD8(&v59);
}

    v40 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      *(void *)&buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Added device %{public}@ to connection overflow list",  buf,  0xCu);
    }

    unint64_t v7 = (id *)(a1 + 752);
    goto LABEL_102;
  }

  if (!v20)
  {
LABEL_53:
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    sub_1005D3DE4((uint64_t)off_1008D5F28, v5, (uint64_t)buf);
    if (!*(void *)buf && !*(void *)&buf[8])
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      sub_1005D3AD4((uint64_t)off_1008D5F28, v5);
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    sub_1005D1F20((uint64_t)off_1008D5F28, v5, 1);
    if (qword_1008D92A8 != -1) {
      dispatch_once(&qword_1008D92A8, &stru_1008A2BB0);
    }
    sub_10064CA40(qword_1008D92A0, v5, 1LL);
    v133 = 2;
    v132 = 10;
    LOWORD(v113) = 12;
    v131 = 12;
    v130 = 200;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    v29 = sub_1005CE2FC((uint64_t)off_1008D5F28, v5);
    uint64_t v30 = v29;
    switch(v29)
    {
      case 196608:
        goto LABEL_69;
      case 257:
        v39 = 0;
        LOWORD(v113) = 12;
        v131 = 12;
LABEL_141:
        v57 = 1;
        goto LABEL_144;
      case 19:
LABEL_69:
        LOWORD(v113) = *(_WORD *)(a1 + 1104);
        v131 = *(_WORD *)(a1 + 1106);
        v133 = *(_BYTE *)(a1 + 1108);
        v31 = *(_BYTE *)(a1 + 1109);
        break;
      default:
        sub_100241F90(buf, v5);
        if (sub_100599CBC(a1, buf))
        {
          v31 = 6;
        }

        else
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
          }
          v55 = off_1008D5F28;
          sub_10002418C(v128, "FastConnection");
          v56 = sub_1005CE5A8((uint64_t)v55, v5, (uint64_t)v128);
          if (v129 < 0) {
            operator delete(v128[0]);
          }
          if (!v56)
          {
            if (v30 == 18)
            {
              v133 = 2;
              v132 = 4;
              LOWORD(v113) = 23;
              v131 = 23;
              *(_DWORD *)v140 = 0;
              v86 = sub_1002E6E00();
              sub_10002418C(buf, "LE");
              sub_10002418C(&v149, "SRPipeMinConInt");
              v87 = (*(uint64_t (**)(uint64_t, uint8_t *, void ***, uint8_t *))(*(void *)v86 + 88LL))( v86,  buf,  &v149,  v140);
              else {
                v88 = 0;
              }
              if (SHIBYTE(v151) < 0) {
                operator delete(v149);
              }
              if (v88)
              {
                v89 = (os_log_s *)qword_1008F7620;
                v90 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
                v91 = *(_WORD *)v140;
                if (v90)
                {
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)&buf[4] = *(_DWORD *)v140;
                  _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value (%d) SRPipe min connection interval",  buf,  8u);
                  v91 = *(_WORD *)v140;
                }

                LOWORD(v113) = v91;
              }

              LODWORD(v110.__r_.__value_.__l.__data_) = 0;
              v92 = sub_1002E6E00();
              sub_10002418C(buf, "LE");
              sub_10002418C(&v149, "SRPipeMaxConInt");
              v93 = (*(uint64_t (**)(uint64_t, uint8_t *, void ***, std::stringbuf::string_type *))(*(void *)v92 + 88LL))( v92,  buf,  &v149,  &v110);
              if (SLODWORD(v110.__r_.__value_.__l.__data_) > 0) {
                v94 = v93;
              }
              else {
                v94 = 0;
              }
              if (SHIBYTE(v151) < 0) {
                operator delete(v149);
              }
              if (v94)
              {
                v95 = (os_log_s *)qword_1008F7620;
                v96 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
                data = (unsigned __int16)v110.__r_.__value_.__l.__data_;
                if (v96)
                {
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)&buf[4] = v110.__r_.__value_.__l.__data_;
                  _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value (%d) SRPipe max connection interval",  buf,  8u);
                  data = (unsigned __int16)v110.__r_.__value_.__l.__data_;
                }

                v131 = data;
              }

              v127 = 0;
              v98 = sub_1002E6E00();
              sub_10002418C(buf, "LE");
              sub_10002418C(&v149, "SRPipeSpecialParamsOff");
              v99 = (*(uint64_t (**)(uint64_t, uint8_t *, void ***, char *))(*(void *)v98 + 72LL))( v98,  buf,  &v149,  &v127);
              if (v127) {
                v100 = v99;
              }
              else {
                v100 = 0;
              }
              if (SHIBYTE(v151) < 0) {
                operator delete(v149);
              }
              if (v100)
              {
                v101 = (os_log_s *)qword_1008F7620;
                if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_DEFAULT,  "Warning: Disabling special SRPipe connection intervals",  buf,  2u);
                }

                LOWORD(v113) = 12;
                v131 = 12;
              }

              v39 = 0;
              v57 = v100 ^ 1;
              goto LABEL_144;
            }

            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
            }
            if (sub_1005CF748((uint64_t)off_1008D5F28, v5))
            {
              v57 = 0;
            }

            else
            {
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
              }
              v107 = off_1008D5F28;
              sub_10002418C(v125, "requiresCTOFix");
              v57 = sub_1005CE5A8((uint64_t)v107, v5, (uint64_t)v125);
              if (v126 < 0) {
                operator delete(v125[0]);
              }
              if (v57)
              {
                v130 = 300;
                goto LABEL_135;
              }
            }

LABEL_106:
    v104 = (id *)(v240 + 5);
    v212 = (id)v240[5];
    NSAppendPrintF_safe(&v212, "\n");
    objc_storeStrong(v104, v212);
    goto LABEL_107;
  }

                  if ((v17 & 0x100000000000000LL) != 0)
                  {
                    self->_objectDiscoveryFlags |= 2u;
                    if ((v17 & 0x200000000000000LL) == 0)
                    {
LABEL_108:
                      if ((v17 & 0x10000000000LL) == 0) {
                        goto LABEL_110;
                      }
LABEL_109:
                      self->_anyRangeScan = 1;
                      goto LABEL_110;
                    }
                  }

                  else if ((v17 & 0x200000000000000LL) == 0)
                  {
                    goto LABEL_108;
                  }

                  self->_objectDiscoveryFlags |= 1u;
                  if ((v17 & 0x10000000000LL) != 0) {
                    goto LABEL_109;
                  }
LABEL_110:
                  v73 = [v19 bleRSSIThresholdHint];
                  if ((v121 & 0x100000000LL) != 0) {
                    v74 = -120;
                  }
                  else {
                    v74 = -90;
                  }
                  if (v74 <= (v73 & (v73 >> 31))) {
                    v74 = v73 & (v73 >> 31);
                  }
                  v75 = v74 == 0;
                  v76 = v126;
                  v126 = v76;
                  v77 = [v19 bleScanRateOverride];
                  if (!v77 && (self->_screenOn || (v77 = [v19 bleScanRateScreenOff]) == 0))
                  {
                    v77 = [v19 bleScanRate];
                    if (!v77) {
                      self->_scanRateAnyDefault = 1;
                    }
                  }

                  if (v77 > self->_scanRateHighest) {
                    self->_scanRateHighest = v77;
                  }
                  v125 |= v75;
                  if (v21 < 0)
                  {
                    v142 = 0LL;
                    v143 = 0LL;
                    sub_10056AB04(&v142, &__dst, 0x16uLL);
                    v140 = 0LL;
                    v141 = 0LL;
                    sub_10056AB04(&v140, &v150, 0x16uLL);
                    if ([v128 count]) {
                      v78 = 3;
                    }
                    else {
                      v78 = 2;
                    }
                    v79 = v126;
                    if ((v125 & 1) != 0) {
                      v79 = -90;
                    }
                    if (v116) {
                      v80 = -120;
                    }
                    else {
                      v80 = v79;
                    }
                    targetCore = self->_targetCore;
                    if ((v121 & 1) != 0)
                    {
                      v82 = sub_1002E6E9C();
                      v83 = (*(uint64_t (**)(uint64_t))(*(void *)v82 + 2328LL))(v82);
                    }

                    else
                    {
                      v83 = 0;
                    }

                    sub_10004A304( (uint64_t)a6,  v122,  v124,  v78,  (uint64_t)&v142,  (uint64_t)&v140,  v80,  0,  !v127,  targetCore,  1,  v128,  v83,  0,  v118,  BYTE4(v117) & 1,  v119 & 1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
                    for (m = 0LL; m != 22; ++m)
                      *((_BYTE *)&v153[-1] + m) = 0;
                    for (n = 0LL; n != 22; ++n)
                      *((_BYTE *)&v151[-1] + n) = 0;
                    v140 = &off_10087FAA8;
                    if (v141) {
                      sub_1002CD254(v141);
                    }
                    v142 = &off_10087FAA8;
                    if (v143) {
                      sub_1002CD254(v143);
                    }
                    v115 = 0;
                  }

                  uint64_t v11 = v21 >= 0;
                  break;
                default:
                  goto LABEL_92;
              }
            }
          }
        }
      }

      id v10 = -[NSArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v144,  v149,  16LL);
    }

    while (v10);

    if (v11)
    {
      if ((v121 & 1) != 0)
      {
        v86 = sub_1002E6E9C();
        v133 = (*(uint64_t (**)(uint64_t))(*(void *)v86 + 2328LL))(v86);
      }

      else
      {
        v133 = 0;
      }

      v135 = !v127;
      if ((self->_aggregateDiscoveryTypes.bitArray[1] & 0x40) != 0 && !self->_screenOn && v111)
      {

        BYTE1(__dst) = 56;
        BYTE5(__dst) = 2;
        BYTE1(v150) = 56;
        BYTE5(v150) = 2;
        v88 = -[NSData length](v111, "length");
        memcpy((char *)&__dst + 6, -[NSData bytes](v111, "bytes"), v88);
        if (v88) {
          memset((char *)&v150 + 6, 255, v88);
        }
        v142 = 0LL;
        v143 = 0LL;
        sub_10056AB04(&v142, &__dst, 0x16uLL);
        v140 = 0LL;
        v141 = 0LL;
        sub_10056AB04(&v140, &v150, 0x16uLL);
        v89 = [v128 count];
        if ((v125 & 1) != 0) {
          v90 = -90;
        }
        else {
          v90 = v126;
        }
        if (v116) {
          v90 = -120;
        }
        if (v89) {
          v91 = 3;
        }
        else {
          v91 = 2;
        }
        sub_10004A304( (uint64_t)a6,  @"AcceptedInvitation",  v124,  v91,  (uint64_t)&v142,  (uint64_t)&v140,  v90,  0,  v135,  self->_targetCore,  1,  0LL,  v133,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
        for (ii = 0LL; ii != 22; ++ii)
          *((_BYTE *)&v153[-1] + ii) = 0;
        for (jj = 0LL; jj != 22; ++jj)
          *((_BYTE *)&v151[-1] + jj) = 0;
        v140 = &off_10087FAA8;
        if (v141) {
          sub_1002CD254(v141);
        }
        v142 = &off_10087FAA8;
        if (v143) {
          sub_1002CD254(v143);
        }
        v115 = 0;
        v122 = @"AcceptedInvitation";
      }

      if (v124 == 22)
      {
        if ((v117 & 1) != 0)
        {

          v142 = 0LL;
          v143 = 0LL;
          sub_10056AB04(&v142, &__dst, 0x16uLL);
          v140 = 0LL;
          v141 = 0LL;
          sub_10056AB04(&v140, &v150, 0x16uLL);
          if ((v125 & 1) != 0) {
            v94 = -90;
          }
          else {
            v94 = v126;
          }
          if (v116) {
            v94 = -120;
          }
          sub_10004A304( (uint64_t)a6,  @"NearbyInfoV2",  0x16u,  2,  (uint64_t)&v142,  (uint64_t)&v140,  v94,  0,  v135,  self->_targetCore,  1,  0LL,  v133,  v115 & 1,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
          v140 = &off_10087FAA8;
          if (v141) {
            sub_1002CD254(v141);
          }
          v142 = &off_10087FAA8;
          if (v143) {
            sub_1002CD254(v143);
          }
          v122 = @"NearbyInfoV2";
        }

        else
        {
          v138 = 0u;
          v139 = 0u;
          v136 = 0u;
          v137 = 0u;
          v131 = self->_discoveryArray;
          v96 = -[NSArray countByEnumeratingWithState:objects:count:]( v131,  "countByEnumeratingWithState:objects:count:",  &v136,  v148,  16LL);
          if (v96)
          {
            if ((v121 & 0x100000000LL) != 0) {
              v97 = -120;
            }
            else {
              v97 = -90;
            }
            v98 = *(void *)v137;
            do
            {
              for (kk = 0LL; kk != v96; kk = (char *)kk + 1)
              {
                if (*(void *)v137 != v98) {
                  objc_enumerationMutation(v131);
                }
                v100 = *(void **)(*((void *)&v136 + 1) + 8LL * (void)kk);
                if ((int)[v100 bleRSSIThresholdHint] > 0
                  || (v101 = v97, v97 <= (int)[v100 bleRSSIThresholdHint]))
                {
                  if ((int)[v100 bleRSSIThresholdHint] > 0
                    || (v102 = [v100 bleRSSIThresholdHint], v101 = v102, !v102))
                  {
                    v101 = -90;
                  }
                }

                v103 = (void *)objc_claimAutoreleasedReturnValue([v100 deviceFilter]);
                v104 = (void *)objc_claimAutoreleasedReturnValue(-[CBStackBLEScannerBTStack _deviceFilterUUIDs:](self, "_deviceFilterUUIDs:", v103));

                v128 = v104;
                if ([v104 count]) {
                  v105 = 3;
                }
                else {
                  v105 = 2;
                }
                v106 = v100;
                if ((*((_BYTE *)[v106 discoveryTypesInternalPtr] + 2) & 0x20) != 0)
                {

                  bzero(&__dst, 0x16uLL);
                  bzero(&v150, 0x16uLL);
                  v142 = 0LL;
                  v143 = 0LL;
                  sub_10056AB04(&v142, &__dst, 0x16uLL);
                  v140 = 0LL;
                  v141 = 0LL;
                  sub_10056AB04(&v140, &v150, 0x16uLL);
                  sub_10004A304( (uint64_t)a6,  @"MiLo",  0x16u,  v105,  (uint64_t)&v142,  (uint64_t)&v140,  v101,  0,  v135,  self->_targetCore,  1,  v104,  v133,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
                  v140 = &off_10087FAA8;
                  if (v141) {
                    sub_1002CD254(v141);
                  }
                  v142 = &off_10087FAA8;
                  if (v143) {
                    sub_1002CD254(v143);
                  }
                  v122 = @"MiLo";
                }

                if ((*((_BYTE *)[v106 discoveryTypesInternalPtr] + 2) & 8) != 0)
                {

                  LOBYTE(__dst) = 4;
                  LOBYTE(v150) = 4;
                  v142 = 0LL;
                  v143 = 0LL;
                  sub_10056AB04(&v142, &__dst, 0x16uLL);
                  v140 = 0LL;
                  v141 = 0LL;
                  sub_10056AB04(&v140, &v150, 0x16uLL);
                  sub_10004A304( (uint64_t)a6,  @"Invitation",  0x16u,  v105,  (uint64_t)&v142,  (uint64_t)&v140,  v101,  0,  v135,  self->_targetCore,  1,  v104,  v133,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
                  v140 = &off_10087FAA8;
                  if (v141) {
                    sub_1002CD254(v141);
                  }
                  v142 = &off_10087FAA8;
                  if (v143) {
                    sub_1002CD254(v143);
                  }
                  v122 = @"Invitation";
                }
              }

              v96 = -[NSArray countByEnumeratingWithState:objects:count:]( v131,  "countByEnumeratingWithState:objects:count:",  &v136,  v148,  16LL);
            }

            while (v96);
          }
        }
      }

      else
      {
        if ((v110 & 1) != 0 && !self->_screenOn)
        {

          v115 = 0;
          LOWORD(__dst) = 14080;
          LOWORD(v150) = 14080;
          v122 = @"AUAction";
        }

        else if (v113)
        {
          LOBYTE(__dst) = 1;
          LOBYTE(v150) = 1;
          v95 = -[NSData length](v113, "length");
          memcpy((char *)&__dst + 2, -[NSData bytes](v113, "bytes"), v95);
          if (v95) {
            memset((char *)&v150 + 2, 255, v95);
          }

          v128 = 0LL;
        }

        v142 = 0LL;
        v143 = 0LL;
        sub_10056AB04(&v142, &__dst, 0x16uLL);
        v140 = 0LL;
        v141 = 0LL;
        sub_10056AB04(&v140, &v150, 0x16uLL);
        v107 = [v128 count];
        if ((v125 & 1) != 0) {
          v108 = -90;
        }
        else {
          v108 = v126;
        }
        if (v116) {
          v108 = -120;
        }
        if (v107) {
          v109 = 3;
        }
        else {
          v109 = 2;
        }
        sub_10004A304( (uint64_t)a6,  v122,  v124,  v109,  (uint64_t)&v142,  (uint64_t)&v140,  v108,  0,  v135,  self->_targetCore,  1,  v128,  v133,  v115 & 1,  v118,  BYTE4(v117) & 1,  v119 & 1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
        v140 = &off_10087FAA8;
        if (v141) {
          sub_1002CD254(v141);
        }
        v142 = &off_10087FAA8;
        if (v143) {
          sub_1002CD254(v143);
        }
      }
    }

    v87 = v128;
  }

  else
  {

    v111 = 0LL;
    v113 = 0LL;
    v87 = 0LL;
  }
}

              v34 = v109;
              uint64_t v17 = v109;
LABEL_108:
              if (v17)
              {
                v98 = (os_log_s *)qword_1008F7560;
                if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 67109632;
                  *(_DWORD *)&buf[4] = v108;
                  *(_WORD *)&buf[8] = 1024;
                  *(_DWORD *)&buf[10] = v34;
                  *(_WORD *)&buf[14] = 1024;
                  *(_DWORD *)&buf[16] = v109;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_ERROR,  "parseAACPSetupComplete Key:%d Dumped %d of %d bytes ",  buf,  0x14u);
                }

                sub_10040F8BC(a2, v17);
              }

              goto LABEL_112;
            }

            v34 = v109;
            uint64_t v17 = v109;
            if (v109 != 2) {
              goto LABEL_108;
            }
            v47 = sub_10040F7FC(a2);
            if (v47)
            {
              v48 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&buf[4] = v47;
                _os_log_error_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_ERROR,  "parseAACPSetupComplete AACP status %d",  buf,  8u);
              }
            }

  v53 = 0;
  sub_10002418C(&v57, "FWStreamLogging");
  sub_10002418C(__p, "FWCoreDumpTrigger");
  (*(void (**)(uint64_t, std::string *, void **, BOOL *))(*(void *)a1 + 72LL))(a1, &v57, __p, &v53);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v53)
  {
    sub_10002418C(&v57, "FWStreamLogging");
    sub_10002418C(__p, "FWCoreDumpTrigger");
    (*(void (**)(uint64_t, std::string *, void **, void))(*(void *)a1 + 80LL))(a1, &v57, __p, 0LL);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
    memset(&v57, 0, sizeof(v57));
    sub_10002418C(__p, "FWStreamLogging");
    sub_10002418C(v43, "FWCoreDumpReason");
    v33 = (*(uint64_t (**)(uint64_t, void **, void **, std::string *))(*(void *)a1 + 56LL))( a1,  __p,  v43,  &v57);
    if (v44 < 0) {
      operator delete(v43[0]);
    }
    if (v56 < 0)
    {
      operator delete(__p[0]);
      if ((v33 & 1) != 0)
      {
LABEL_122:
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768LL;
        block[2] = sub_1002C8364;
        block[3] = &unk_10088E2A0;
        else {
          v42 = v57;
        }
        global_queue = dispatch_get_global_queue(0LL, 0LL);
        dispatch_async(global_queue, block);
        return;
      }
    }

    else if ((v33 & 1) != 0)
    {
      goto LABEL_122;
    }

    std::string::assign(&v57, "Manually triggered core dump");
    goto LABEL_122;
  }

  if (*(unsigned __int16 *)(a1 + 1094) < *(unsigned __int16 *)(a1 + 1092)
    && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    sub_10069700C();
  }

  v41 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyVeryHighMinInterval");
  v42 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v41 + 88LL))(v41, buf, __p, &v96);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v42) {
      goto LABEL_120;
    }
  }

  else if (!v42)
  {
    goto LABEL_120;
  }

  v43 = v96;
  v44 = (os_log_s *)qword_1008F7620;
  if ((v96 - 8) >= 0xF9A && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v43;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_FAULT,  "Override rejected latency minInterval:%d LeConnectionLatencyVeryHigh",  buf,  8u);
    LOWORD(v43) = v96;
    v44 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 109_Block_object_dispose((const void *)(v1 - 80), 8) = v43;
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v43;
    _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "Override latency minInterval:%d LeConnectionLatencyVeryHigh",  buf,  8u);
  }

        v75 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "Failure, setting new connectionState",  buf,  2u);
        }

        sub_1005911F0(a1, 0);
LABEL_109:
        sub_100242CD8(&v79);
        return sub_100242FAC((uint64_t)v83);
      }
    }

    else
    {
      if (!v48)
      {
        v73 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEFAULT,  "Success, setting new connectionState",  buf,  2u);
        }

        sub_1005911F0(a1, 1u);
        v74 = sub_1002E8EE8();
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, unint64_t))(*(void *)v74 + 104LL))( v74,  v46,  v47,  v80,  1LL,  (unint64_t)(*(double *)(a1 + 560) * 1000.0));
        goto LABEL_109;
      }

      if (v48 == 133)
      {
        v50 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v51 = "Already connected - we should be getting a connection event imminently";
LABEL_88:
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v51, buf, 2u);
          goto LABEL_106;
        }

        goto LABEL_106;
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698C9C();
    }
    if (v48 == 1309)
    {
      v77 = sub_1002E6E00();
      sub_10002418C(v78, "");
      sub_1004FB370(v77, 1309LL, (uint64_t)v78, 1);
    }

    sub_100242C98(&v79);
    sub_1001D5AEC(v52, v53, v54, v55, v56, v57, v58, v59);
    sub_10023BF24(a1 + 360, *(void **)(a1 + 368));
    *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 80), 8) = 0LL;
    *(void *)(a1 + 376) = 0LL;
    *(void *)(a1 + 360) = a1 + 368;
    sub_1001BA2D4(v60, v61, v62, v63, v64, v65, v66, v67);
    sub_100242CD0(&v79);
    v68 = *(const unsigned __int8 **)(a1 + 336);
    if (v68 != v15)
    {
      do
      {
        v69 = sub_100241F94(v68 + 25);
        v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
        sub_100241F90(buf, v70);
        sub_1005A1444(a1, buf, 1, v48, 1);

        v71 = (const unsigned __int8 *)*((void *)v68 + 1);
        if (v71)
        {
          do
          {
            v72 = v71;
            v71 = *(const unsigned __int8 **)v71;
          }

          while (v71);
        }

        else
        {
          do
          {
            v72 = (const unsigned __int8 *)*((void *)v68 + 2);
            v23 = *(void *)v72 == (void)v68;
            v68 = v72;
          }

          while (!v23);
        }

        v68 = v72;
      }

      while (v72 != v15);
    }

    sub_10023BF24(a1 + 336, *(void **)(a1 + 344));
    *(void *)(a1 + 344) = 0LL;
    *(void *)(a1 + 352) = 0LL;
    *(void *)(a1 + 336) = v15;
    sub_10023BF24(a1 + 608, *(void **)(a1 + 616));
    *(void *)(a1 + 60_Block_object_dispose((const void *)(v1 - 80), 8) = a1 + 616;
    *(void *)(a1 + 624) = 0LL;
    *(void *)(a1 + 616) = 0LL;
    goto LABEL_106;
  }

  uint64_t v2 = qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    uint64_t v3 = "Stack is shutting down, we should not even be here.";
LABEL_4:
    id v4 = (os_log_s *)v2;
    id v5 = 2;
LABEL_5:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, buf, v5);
  }

  return sub_100242FAC((uint64_t)v83);
}

  if ((sub_1005EE698(a1) & 1) == 0)
  {
    v44 = sub_100404FE8();
    __p[0] = _NSConcreteStackBlock;
    __p[1] = (void *)3221225472LL;
    __p[2] = sub_1005ED760;
    __p[3] = &unk_10087EB68;
    *(void *)&v190 = a1;
    DWORD2(v190) = 2;
    sub_100405384(v44, __p);
  }

  v45 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    v46 = *(unsigned __int8 *)(a1 + 2352);
    v47 = *(unsigned __int8 *)(a1 + 144);
    v48 = *(unsigned __int8 *)(*((void *)v168 + 1) + 144LL);
    v49 = sub_1005F396C(a1);
    v50 = *(unsigned __int8 *)(a1 + 1255);
    LODWORD(__p[0]) = 67110144;
    HIDWORD(__p[0]) = v46;
    LOWORD(__p[1]) = 1024;
    *(_DWORD *)((char *)&__p[1] + 2) = v47;
    HIWORD(__p[1]) = 1024;
    LODWORD(__p[2]) = v48;
    WORD2(__p[2]) = 1024;
    *(_DWORD *)((char *)&__p[2] + 6) = v49;
    WORD1(__p[3]) = 1024;
    HIDWORD(__p[3]) = v50;
    _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "fShouldRetainDupsNextUpdate %d, screen? %d, retaindup? %d, EN scans? %d, created[EN]=%d",  (uint8_t *)__p,  0x20u);
  }

  if (*(_BYTE *)(a1 + 1255))
  {
    v51 = v166;
    if (*(_BYTE *)(a1 + 144)) {
      v52 = 0;
    }
    else {
      v52 = *(_BYTE *)(*((void *)v168 + 1) + 144LL) != 0;
    }
    *(_BYTE *)(a1 + 2352) = v52;
    v53 = (os_log_s *)qword_1008F75B8;
    v54 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
    if (v54)
    {
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v52;
      v56 = "EN adv buffer created - new retain dups value %d";
LABEL_124:
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, v56, (uint8_t *)__p, 8u);
    }
  }

  else
  {
    v51 = v166;
    if (sub_1005F396C(a1))
    {
      v53 = (os_log_s *)qword_1008F75B8;
      v54 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
      if (!v54) {
        goto LABEL_125;
      }
      v55 = *(unsigned __int8 *)(a1 + 2352);
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v55;
      v56 = "EN is active - disallow retain dup from clients - current retain dups value %d";
      goto LABEL_124;
    }

    if (*(_BYTE *)(a1 + 144)) {
      v57 = 0;
    }
    else {
      v57 = *(_BYTE *)(*((void *)v168 + 1) + 144LL) != 0;
    }
    *(_BYTE *)(a1 + 2352) = v57;
    v53 = (os_log_s *)qword_1008F75B8;
    v54 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT);
    if (v54)
    {
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v57;
      v56 = "EN is not active - new retain dups value %d";
      goto LABEL_124;
    }
  }

LABEL_108:
  v108 = self->_whbDiscoveryDaemon;
  if (!v108) {
    goto LABEL_112;
  }
  v94 = v108;
  if (v171 >= 0xB) {
    goto LABEL_110;
  }
LABEL_111:
  v110 = (id *)(v240 + 5);
  v209 = (id)v240[5];
  v111 = CUDescriptionWithLevel(v94, v7);
  v112 = (void *)objc_claimAutoreleasedReturnValue(v111);
  NSAppendPrintF_safe(&v209, "%@\n", v112);
  objc_storeStrong(v110, v209);

LABEL_112:
  v113 = (char *)-[NSMutableDictionary count](self->_deviceMap, "count");
  if (v113)
  {
    if (!v4)
    {
      v114 = (id *)(v240 + 5);
      v208 = (id)v240[5];
      NSAppendPrintF_safe(&v208, "\n");
      objc_storeStrong(v114, v208);
    }

    v115 = (id *)(v240 + 5);
    v207 = (id)v240[5];
    NSAppendPrintF_safe(&v207, "== Combined devices: %d ==\n", (_DWORD)v113);
    objc_storeStrong(v115, v207);
    v203 = 0LL;
    v204 = &v203;
    v205 = 0x2020000000LL;
    v206 = 0LL;
    deviceMap = self->_deviceMap;
    v200[0] = _NSConcreteStackBlock;
    v200[1] = 3221225472LL;
    v200[2] = sub_10000E668;
    v200[3] = &unk_10087F030;
    v200[4] = &v239;
    v200[5] = &v203;
    v201 = v165;
    v202 = a3;
    -[NSMutableDictionary enumerateKeysAndObjectsUsingBlock:](deviceMap, "enumerateKeysAndObjectsUsingBlock:", v200);
    v117 = v204[3];
    v118 = (unint64_t)v113 >= v117;
    v119 = &v113[-v117];
    if (v119 != 0LL && v118)
    {
      v120 = (id *)(v240 + 5);
      v199 = (id)v240[5];
      NSAppendPrintF_safe(&v199, "... %d more, %d total\n", (_DWORD)v119, (_DWORD)v113);
      objc_storeStrong(v120, v199);
    }

    v121 = (id *)(v240 + 5);
    v198 = (id)v240[5];
    NSAppendPrintF_safe(&v198, "\n");
    objc_storeStrong(v121, v198);
    _Block_object_dispose(&v203, 8);
    id v4 = 1;
  }

  v122 = -[NSMutableOrderedSet count](self->_lostDevicesForCBSpatial, "count");
  if (v122)
  {
    v123 = (id *)(v240 + 5);
    v197 = (id)v240[5];
    NSAppendPrintF_safe(&v197, "== Lost CBSpatial Devices: %d ==\n", (_DWORD)v122);
    objc_storeStrong(v123, v197);
    lostDevicesForCBSpatial = self->_lostDevicesForCBSpatial;
    v195[0] = _NSConcreteStackBlock;
    v195[1] = 3221225472LL;
    v195[2] = sub_10000E710;
    v195[3] = &unk_10087F058;
    v195[4] = &v239;
    v196 = v165;
    -[NSMutableOrderedSet enumerateObjectsUsingBlock:](lostDevicesForCBSpatial, "enumerateObjectsUsingBlock:", v195);
    v125 = (id *)(v240 + 5);
    v194 = (id)v240[5];
    NSAppendPrintF_safe(&v194, "\n");
    objc_storeStrong(v125, v194);
    id v4 = 1;
  }

  v126 = -[NSMutableSet count](self->_xpcConnections, "count");
  if (v126)
  {
    if (!v4)
    {
      v127 = (id *)(v240 + 5);
      v193 = (id)v240[5];
      NSAppendPrintF_safe(&v193, "\n");
      objc_storeStrong(v127, v193);
    }

    v128 = (id *)(v240 + 5);
    v192 = (id)v240[5];
    NSAppendPrintF_safe(&v192, "== XPC Cnx: %d ==\n", (_DWORD)v126);
    objc_storeStrong(v128, v192);
    v190 = 0u;
    v191 = 0u;
    v188 = 0u;
    v189 = 0u;
    v129 = self->_xpcConnections;
    v130 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v129,  "countByEnumeratingWithState:objects:count:",  &v188,  v248,  16LL);
    if (v130)
    {
      v131 = *(void *)v189;
      do
      {
        for (i = 0LL; i != v130; i = (char *)i + 1)
        {
          if (*(void *)v189 != v131) {
            objc_enumerationMutation(v129);
          }
          v133 = *(void *)(*((void *)&v188 + 1) + 8LL * (void)i);
          v134 = (id *)(v240 + 5);
          v187 = (id)v240[5];
          v135 = CUDescriptionWithLevel(v133, v7);
          v136 = (void *)objc_claimAutoreleasedReturnValue(v135);
          NSAppendPrintF_safe(&v187, "%@", v136);
          objc_storeStrong(v134, v187);

          if (v7 > 0x14)
          {
            v137 = (id *)(v240 + 5);
            v186 = (id)v240[5];
            NSAppendPrintF_safe(&v186, "\n");
            objc_storeStrong(v137, v186);
          }
        }

        v130 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v129,  "countByEnumeratingWithState:objects:count:",  &v188,  v248,  16LL);
      }

      while (v130);
    }

    v138 = (id *)(v240 + 5);
    v185 = (id)v240[5];
    NSAppendPrintF_safe(&v185, "\n");
    objc_storeStrong(v138, v185);
    id v4 = 1;
  }

  if (v171 <= 0x14)
  {
    v183 = 0u;
    v184 = 0u;
    v181 = 0u;
    v182 = 0u;
    v139 = (void *)CFPrefs_CopyKeys(@"com.apple.bluetooth", 0LL);
    v140 = 0;
    v141 = [v139 countByEnumeratingWithState:&v181 objects:v247 count:16];
    if (v141)
    {
      v142 = *(void *)v182;
      do
      {
        for (j = 0LL; j != v141; j = (char *)j + 1)
        {
          if (*(void *)v182 != v142) {
            objc_enumerationMutation(v139);
          }
          v144 = *(void *)(*((void *)&v181 + 1) + 8LL * (void)j);
          v145 = objc_opt_class(&OBJC_CLASS___NSString);
          if ((objc_opt_isKindOfClass(v144, v145) & 1) != 0)
          {
            if (!v4)
            {
              v146 = (id *)(v240 + 5);
              v180 = (id)v240[5];
              NSAppendPrintF_safe(&v180, "\n");
              objc_storeStrong(v146, v180);
            }

            v147 = (void *)CFPrefs_CopyTypedValue(@"com.apple.bluetooth", v144, 0LL, 0LL);
            v148 = (id *)(v240 + 5);
            v179 = (id)v240[5];
            v149 = CUPrintNSObjectOneLine(v147);
            v150 = (void *)objc_claimAutoreleasedReturnValue(v149);
            NSAppendPrintF_safe(&v179, "Pref: '%@' = '%@'\n", v144, v150);
            objc_storeStrong(v148, v179);

            ++v140;
            id v4 = 1;
          }
        }

        v141 = [v139 countByEnumeratingWithState:&v181 objects:v247 count:16];
      }

      while (v141);
    }

    v177 = 0u;
    v178 = 0u;
    v175 = 0u;
    v176 = 0u;
    v245[0] = @"accessoryDaemonConnections";
    v245[1] = @"accessoryDaemonConnectSeconds";
    v245[2] = @"accessoryDaemonEnabled";
    v245[3] = @"adjustHIDSniffForStereoSCO";
    v245[4] = @"APLogCloudCollectionEnabled";
    v245[5] = @"authTagIntegrityCheckEnabled";
    v245[6] = @"bleAdvertising";
    v245[7] = @"bleScanning";
    v245[8] = @"btvcDefaultAdvRSSI";
    v245[9] = @"CBExtensionRSSIOverride";
    v245[10] = @"disableCentralSkipSniff";
    v245[11] = @"disabledExtensions";
    v245[12] = @"discoveryProxy";
    v245[13] = @"enableSpecialSniffTransitions";
    v245[14] = @"enforceApprovedExtensions";
    v245[15] = @"enforceApprovedList";
    v245[16] = @"extensionsEnabled";
    v245[17] = @"filterNearbyActionExtraData";
    v245[18] = @"intelligenceDaemonEnabled";
    v245[19] = @"memoryPressureFlags";
    v245[20] = @"move3PPLEMSToLegacyMode";
    v245[21] = @"move3PPLEMSToLegacyModeSerial";
    v245[22] = @"NCSecondaryAdvInstance";
    v245[23] = @"remoteClientEnabled";
    v245[24] = @"remoteServerEnabled";
    v245[25] = @"BluetoothAutoSeekKeyboard";
    v245[26] = @"BluetoothAutoSeekPointingDevice";
    v245[27] = @"SpatialSoundProfileAllowed";
    v245[28] = @"systemReferenceTimeDisabled";
    v245[29] = @"whbDiscoveryAlways";
    v245[30] = @"whbMaxLEConnections";
    v245[31] = @"wiproxAdvertising";
    v245[32] = @"UseLowLatencyGameController";
    v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v245, 33LL));
    v152 = [v151 countByEnumeratingWithState:&v175 objects:v246 count:16];
    if (v152)
    {
      v153 = *(void *)v176;
      v172 = v151;
      do
      {
        for (k = 0LL; k != v152; k = (char *)k + 1)
        {
          if (*(void *)v176 != v153) {
            objc_enumerationMutation(v172);
          }
          v155 = *(const __CFString **)(*((void *)&v175 + 1) + 8LL * (void)k);
          v156 = CFPreferencesCopyValue( v155,  @"com.apple.Bluetooth",  kCFPreferencesAnyUser,  kCFPreferencesCurrentHost);
          v157 = (void *)v156;
          if (v156)
          {
            v158 = (id *)(v240 + 5);
            v174 = (id)v240[5];
            v159 = CUPrintNSObjectOneLine(v156);
            v160 = (void *)objc_claimAutoreleasedReturnValue(v159);
            NSAppendPrintF_safe(&v174, "Pref: '%@' = '%@' (legacy)\n", v155, v160);
            objc_storeStrong(v158, v174);

            ++v140;
          }
        }

        v151 = v172;
        v152 = [v172 countByEnumeratingWithState:&v175 objects:v246 count:16];
      }

      while (v152);
    }

    if (v140 >= 1)
    {
      v161 = (id *)(v240 + 5);
      v173 = (id)v240[5];
      NSAppendPrintF_safe(&v173, "\n");
      objc_storeStrong(v161, v173);
    }
  }

  v162 = (id)v240[5];

  _Block_object_dispose(&v239, 8);
  return v162;
}

            *(void *)(*a3 + v39) = *(void *)*v38;
            v61 = *((_WORD *)a3 + 6) + 8;
            goto LABEL_109;
          case 'f':
          case 'j':
          case 'q':
          case 'r':
          case 's':
          case 't':
          case 'u':
          case 'v':
          case 'x':
          case 'y':
LABEL_128:
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"unknown cmd parm type %d",  v96,  v97,  v98,  v99,  v100,  v101,  v102,  *(unsigned __int8 *)(*(void *)(a2 + 8) + v21));
              v103 = (os_log_s *)sub_100086554(0x2Eu);
              if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v135 = sub_1001EDDCC();
                v136 = 1024;
                v137 = 615;
                _os_log_error_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
              }
            }

            sub_1000B1838(ptr);
            return 615LL;
          case 'g':
            v40 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_167:
              v113 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_169:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2648,  v113);
            }

            v41 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v113 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_169;
            }

            v42 = *(_DWORD *)v40;
            v43 = *a3;
            *((_WORD *)a3 + 6) = v41 + 1;
            *(_BYTE *)(v43 + v41) = v42;
            if (a7) {
              *a7 = v42;
            }
            goto LABEL_110;
          case 'h':
            v44 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_171:
              v114 = "ByteStream_NumReadBytesAvail(*pBs) >= 2";
LABEL_173:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2637,  v114);
            }

            v45 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v114 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_173;
            }

            v46 = (_BYTE *)*v44;
            *(_BYTE *)(*a3 + v45) = *v46;
            *(_BYTE *)(*a3 + *((unsigned __int16 *)a3 + 6) + 1) = v46[1];
            *((_WORD *)a3 + 6) += 2;
            if (a4) {
              *a4 = v46;
            }
            goto LABEL_110;
          case 'i':
            v47 = (const void **)a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_175:
              v115 = "ByteStream_NumReadBytesAvail(*pBs) >= ((240))";
LABEL_177:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2718,  v115);
            }

            v48 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v115 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_177;
            }

            memmove((void *)(*a3 + v48), *v47, 0xF0uLL);
            v33 = *((_WORD *)a3 + 6) + 240;
            goto LABEL_87;
          case 'k':
            v36 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_179:
              v116 = "ByteStream_NumReadBytesAvail((*pBs)) >= (sizeof(*pVal))";
LABEL_180:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2658,  v116);
            }

            v37 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v116 = "((*pBs)).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_180;
            }

            goto LABEL_82;
          case 'l':
            v49 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_182:
              v117 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_184:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2701,  v117);
            }

            v50 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v117 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_184;
            }

            v51 = *(_DWORD *)v49;
            v52 = *a3;
            *((_WORD *)a3 + 6) = v50 + 1;
            *(_BYTE *)(v52 + v50) = v51;
            v53 = v51;
            v54 = v51 + ((v51 + 3) >> 2);
            else {
              v55 = -1;
            }
            byte_1008F6E18 = v55;
            goto LABEL_110;
          case 'm':
            v56 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_186:
              v118 = "ByteStream_NumReadBytesAvail(*pBs) >= (5)";
LABEL_188:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2739,  v118);
            }

            v57 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v118 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_188;
            }

            v58 = (int *)*v56;
            v59 = *a3 + v57;
            v60 = *v58;
            *(_BYTE *)(v59 + 4) = *((_BYTE *)v58 + 4);
            *(_DWORD *)v59 = v60;
            v61 = *((_WORD *)a3 + 6) + 5;
            goto LABEL_109;
          case 'n':
            v62 = a6;
            v63 = a7;
            v64 = (const char **)a1++;
            v65 = *v64;
            v66 = strlen(*v64);
            v67 = v66;
            else {
              v68 = 248;
            }
            v69 = *a3;
            v70 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
              v71 = 0;
            }

            else
            {
              v71 = *((unsigned __int16 *)a3 + 5) - (_DWORD)v70;
            }

            if (v71 < v68)
            {
              v127 = "ByteStream_NumReadBytesAvail(*pBs) >= (len)";
              goto LABEL_223;
            }

            if (*((_BYTE *)a3 + 14) != 2)
            {
              v127 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
LABEL_223:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2683,  v127);
            }

            memmove((void *)(v69 + v70), v65, v68);
            *((_WORD *)a3 + 6) += v68;
            v90 = v68 > 0xF7u;
            a7 = v63;
            a6 = v62;
            a5 = v130;
            uint64_t v13 = v131;
            a4 = v129;
            if (!v90)
            {
              while (!*((_BYTE *)a3 + 15))
              {
                v91 = *((unsigned __int16 *)a3 + 6);
                if (*((_BYTE *)a3 + 14) != 2)
                {
                  v104 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_135;
                }

                v92 = *a3;
                *((_WORD *)a3 + 6) = v91 + 1;
                *(_BYTE *)(v92 + v91) = 0;
                v93 = (unsigned __int16)v67++;
                if (v93 >= 0xF7) {
                  goto LABEL_110;
                }
              }

              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_133:
              v104 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_135:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2685,  v104);
            }

    (*(void (**)(uint64_t))(*(void *)v57 + 8LL))(v57);
    if (__p)
    {
      v61 = (char *)__p;
      operator delete(__p);
    }

    id v8 = 0LL;
  }

  else
  {
    unint64_t v7 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT)) {
      sub_100674FC8(a2, v7);
    }
    id v8 = 1010LL;
  }
}

void sub_10000E590(_Unwind_Exception *a1)
{
}

uint64_t sub_10000E650(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10000E660(uint64_t a1)
{
}

void sub_10000E668(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v6 + 40);
  uint64_t v7 = CUDescriptionWithLevel(a3, *(unsigned int *)(a1 + 48));
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  NSAppendPrintF_safe(&obj, "%@\n", v8);
  objc_storeStrong((id *)(v6 + 40), obj);

  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
  unint64_t v10 = *(void *)(v9 + 24) + 1LL;
  *(void *)(v9 + 24) = v10;
}

void sub_10000E710(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v2 + 40);
  uint64_t v3 = CUDescriptionWithLevel(a2, *(unsigned int *)(a1 + 40));
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  NSAppendPrintF_safe(&obj, "%@\n", v4);
  objc_storeStrong((id *)(v2 + 40), obj);
}

void *sub_10000E7D4(void *result)
{
  uint64_t v1 = result[4];
  if (!*(_BYTE *)(v1 + 8))
  {
    uint64_t v2 = result;
    *(_BYTE *)(v1 + _Block_object_dispose(&STACK[0x338], 8) = 1;
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer activate]_block_invoke", 30LL, "Activate");
    }

    return [(id)v2[4] _activate];
  }

  return result;
}

LABEL_50:
  -[CBDaemonServer _prefsChanged](self, "_prefsChanged");
  notify_post("com.apple.bluetooth.daemonStarted");
}

    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( &OBJC_CLASS___CBProductInfo,  "productInfoWithProductID:",  a1));
    uint64_t v2 = objc_claimAutoreleasedReturnValue([v1 productName]);
    goto LABEL_53;
  }

  if ((int)a1 <= 799)
  {
    if ((int)a1 > 776)
    {
      switch((int)a1)
      {
        case 777:
          uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
          uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_wireless_mouse" value:&stru_1008A57D8 table:@"CBLocalizable"]);
          break;
        case 780:
          uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
          uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_mighty_mouse" value:&stru_1008A57D8 table:@"CBLocalizable"]);
          break;
        case 781:
LABEL_51:
          uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
          uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_magic_mouse" value:&stru_1008A57D8 table:@"CBLocalizable"]);
          break;
        case 782:
LABEL_25:
          uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
          uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_magic_trackpad" value:&stru_1008A57D8 table:@"CBLocalizable"]);
          break;
        default:
          goto LABEL_50;
      }

      goto LABEL_53;
    }

    switch((_DWORD)a1)
    {
      case 0x29A:
LABEL_45:
        uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
        uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_magic_keyboard_touch" value:&stru_1008A57D8 table:@"CBLocalizable"]);
        break;
      case 0x29C:
LABEL_11:
        uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
        uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_magic_keyboard" value:&stru_1008A57D8 table:@"CBLocalizable"]);
        break;
      case 0x29F:
LABEL_33:
        uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
        uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_magic_keyboard_touch_keypad" value:&stru_1008A57D8 table:@"CBLocalizable"]);
        break;
      default:
        goto LABEL_50;
    }
  }

  else
  {
    if ((int)a1 <= 8212)
    {
      switch((int)a1)
      {
        case 800:
          goto LABEL_11;
        case 801:
          goto LABEL_45;
        case 802:
          goto LABEL_33;
        case 803:
          goto LABEL_51;
        case 804:
          goto LABEL_25;
        default:
          goto LABEL_50;
      }
    }

    if ((_DWORD)a1 != 8220 && (_DWORD)a1 != 8216 && (_DWORD)a1 != 8213) {
      goto LABEL_50;
    }
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
    uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_airpods_case" value:&stru_1008A57D8 table:@"CBLocalizable"]);
  }

  if (*(_WORD *)(qword_1008DD350 + 4)) {
    return *(unsigned __int16 *)(qword_1008DD350 + 4);
  }
  else {
    return 5LL;
  }
}

      __src += (unsigned __int16)v36;
      v2 -= v36;
      v43 = qword_1008DD390;
      if (!*(_WORD *)(qword_1008DD390 + 2042))
      {
LABEL_51:
        if (*(_BYTE *)(v43 + 2040))
        {
          sub_100089C14();
        }

        else
        {
          sub_100089C90();
        }
      }
    }

    while ((_WORD)v2);
  }

    ++byte_1008E223C;
    byte_1008E223B = -1;
    do
      uint64_t v13 = (void *)*v13;
    while (v13);
    if (!*(_BYTE *)(a2 + 225) && sub_10012EB98() > 1)
    {
      a1 = 13LL;
LABEL_63:
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"SCO/eSCO connection failed, decrementing ACL reference counter and releasing SCO connection for addr=%:",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  (uint64_t)&dword_1008E223D);
        v23 = (os_log_s *)sub_100086554(0x3Eu);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v42 = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      uint64_t v24 = (unsigned __int16 *)sub_10012D8E8((uint64_t)&dword_1008E223D);
      if (v24) {
        sub_10012E320(v24);
      }
      sub_10010CAA4(a2, 0x13u);
      goto LABEL_69;
    }

    if (*(_BYTE *)(a2 + 278))
    {
      uint64_t v15 = sub_100191D30();
    }

    else
    {
      v36 = a2;
      uint64_t v15 = sub_100128D24(26LL);
    }

    if (v15 == 628) {
      a1 = a1;
    }
    else {
      a1 = v15;
    }
    if ((_DWORD)a1) {
      goto LABEL_63;
    }
LABEL_77:
    if ((_DWORD)a4) {
      return;
    }
    v27 = sub_10012DF44((uint64_t)&dword_1008E223D);
    if (v27)
    {
      *((void *)v27 + 6) = a2;
      return;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not allocate sco connection handle", v28, v29, v30, v31, v32, v33, v34, v36);
      v35 = (os_log_s *)sub_100086554(0x3Eu);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    HIBYTE(word_1008E2239) = 0;
    a1 = 106LL;
    goto LABEL_70;
  }

  if ((v9 & 0x7F) != 0) {
    goto LABEL_23;
  }
  sub_10010CAA4(a2, 0x13u);
  HIBYTE(word_1008E2239) = 0;
  unint64_t v10 = *(void (***)(uint64_t, uint64_t, int *))(a2 + 80);
  if (!v10) {
    unint64_t v10 = (void (**)(uint64_t, uint64_t, int *))qword_1008E2218;
  }
  if (v10 && *v10) {
    (*v10)(1336LL, a2, &dword_1008E223D);
  }
}

    if (++v20 == 32)
    {
      if (!a3) {
        return;
      }
      v40 = *(void *)(a2 + 192);
      if (v40)
      {
        v41 = *(void *)(v40 + 88);
        if (v41)
        {
          v42 = sub_1002E6BF0();
          if (((*(uint64_t (**)(uint64_t))(*(void *)v42 + 328LL))(v42) & 1) != 0
            || (v43 = sub_1002E6BF0(), ((*(uint64_t (**)(uint64_t))(*(void *)v43 + 384LL))(v43) & 1) != 0)
            || (v44 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v44 + 424LL))(v44)))
          {
            *(_DWORD *)buf = 0;
            v45 = (void *)acc_transportClient_createEndpoint( *(void *)(a2 + 128),  2LL,  13LL,  @"none",  &stru_100888120,  0LL);
            v46 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
            v47 = *(id *)(v40 + 64);
            v48 = *(id *)(v40 + 72);
            v90 = *(id *)(v40 + 24);
            if ((unint64_t)[v47 length] >= 2)
            {
              v49 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys[0]) = 141558275;
                *(void **)((char *)keys + 4) = (void *)1752392040;
                WORD2(keys[1]) = 2113;
                *(void **)((char *)&keys[1] + 6) = v47;
                _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: Left bud serial %{private, mask.hash}@",  (uint8_t *)keys,  0x16u);
              }

              v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", 2LL));
              v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjectsAndKeys:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjectsAndKeys:",  v50,  kCFACCProperties_Endpoint_AACP_CertificateInfo_Type,  v47,  kCFACCProperties_Endpoint_AACP_CertificateInfo_Serial,  0LL));
              -[NSMutableArray addObject:](v46, "addObject:", v51);
            }

            if ((unint64_t)[v48 length] >= 2)
            {
              v52 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys[0]) = 141558275;
                *(void **)((char *)keys + 4) = (void *)1752392040;
                WORD2(keys[1]) = 2113;
                *(void **)((char *)&keys[1] + 6) = v48;
                _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: Right bud serial %{private, mask.hash}@",  (uint8_t *)keys,  0x16u);
              }

              v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", 3LL));
              v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjectsAndKeys:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjectsAndKeys:",  v53,  kCFACCProperties_Endpoint_AACP_CertificateInfo_Type,  v48,  kCFACCProperties_Endpoint_AACP_CertificateInfo_Serial,  0LL));
              -[NSMutableArray addObject:](v46, "addObject:", v54);
            }

            if (!-[NSMutableArray count](v46, "count") && (unint64_t)[v90 length] >= 2)
            {
              v55 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys[0]) = 141558275;
                *(void **)((char *)keys + 4) = (void *)1752392040;
                WORD2(keys[1]) = 2113;
                *(void **)((char *)&keys[1] + 6) = v90;
                _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: Single tethered serial %{private, mask.hash}@",  (uint8_t *)keys,  0x16u);
              }

              v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", 1LL));
              v57 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjectsAndKeys:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjectsAndKeys:",  v56,  kCFACCProperties_Endpoint_AACP_CertificateInfo_Type,  v90,  kCFACCProperties_Endpoint_AACP_CertificateInfo_Serial,  0LL));
              -[NSMutableArray addObject:](v46, "addObject:", v57);

              *(_DWORD *)buf = 1;
            }

            v58 = (os_log_s *)qword_1008F7560;
            if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(keys[0]) = 141558275;
              *(void **)((char *)keys + 4) = (void *)1752392040;
              WORD2(keys[1]) = 2113;
              *(void **)((char *)&keys[1] + 6) = v46;
              _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: Dictionary %{private, mask.hash}@",  (uint8_t *)keys,  0x16u);
            }

            if (v45)
            {
              v59 = -[NSMutableArray count](v46, "count");
              v60 = (os_log_s *)qword_1008F7560;
              if (v59)
              {
                if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                {
                  v61 = *(void **)(a2 + 128);
                  LODWORD(keys[0]) = 138543618;
                  *(void **)((char *)keys + 4) = v45;
                  WORD2(keys[1]) = 2114;
                  *(void **)((char *)&keys[1] + 6) = v61;
                  _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: Creating certificate endpoint %{public}@ for %{public}@",  (uint8_t *)keys,  0x16u);
                }

                *(void *)(a2 + 144) = v45;
                *(_DWORD *)valuePtr = 0;
                *(_DWORD *)valuePtr = sub_1003E0230(v91, 9);
                v62 = sub_1002E6E00();
                v63 = (os_log_s *)qword_1008F7560;
                if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(keys[0]) = 67109120;
                  HIDWORD(keys[0]) = *(_DWORD *)valuePtr;
                  _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: isCertificateSupported %d",  (uint8_t *)keys,  8u);
                }

                v64 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
                acc_transportClient_setPropertyForEndpointWithUUID( kCFACCProperties_Endpoint_AACP_CertificateSupported,  v64,  v45);
                *(_DWORD *)__p = a4;
                v65 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, __p);
                acc_transportClient_setPropertyForEndpointWithUUID( kCFACCProperties_Endpoint_AACP_FirstConnectionAfterPair,  v65,  v45);
                acc_transportClient_setPropertyForEndpointWithUUID( kCFACCProperties_Endpoint_AACP_CertificateSerial,  v46,  v45);
                if (sub_10021A5BC(a1, (_DWORD *)v91, a2, *(_DWORD *)valuePtr != 0))
                {
                  *(_DWORD *)(a2 + 600) = 1;
                  v66 = sub_1002E8D94();
                  v97 = *(_DWORD *)(v91 + 128);
                  v98 = *(_WORD *)(v91 + 132);
                  (*(void (**)(uint64_t, int *, uint64_t, void))(*(void *)v66 + 368LL))( v66,  &v97,  1LL,  0LL);
                  v96 = 3;
                  if (qword_1008D60E0 != -1) {
                    dispatch_once(&qword_1008D60E0, &stru_100888C10);
                  }
                  v88 = v47;
                  sub_10021F3F4((uint64_t)off_1008D60D8, v91, &v96);
                  v67 = *(_DWORD *)buf;
                  if (!*(_DWORD *)buf)
                  {
                    if (v96 == 1) {
                      v67 = 2;
                    }
                    else {
                      v67 = 3;
                    }
                    *(_DWORD *)buf = v67;
                  }

                  v68 = (os_log_s *)qword_1008F7560;
                  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(keys[0]) = 67109120;
                    HIDWORD(keys[0]) = v67;
                    _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware GAPA_AUTH_SUPPORTED for this connection certificateInfoType=%d",  (uint8_t *)keys,  8u);
                  }

                  Mutable = CFArrayCreateMutable(0LL, 0LL, 0LL);
                  v47 = v88;
                  v70 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
                  CFArrayAppendValue(Mutable, v70);
                  acc_transportClient_setPropertyForEndpointWithUUID( kCFACCProperties_Endpoint_AudioProduct_AuthSupported,  Mutable,  v45);
                  CFRelease(v70);
                  CFArrayRemoveAllValues(Mutable);
                  CFRelease(Mutable);
                }

                v95[0] = _NSConcreteStackBlock;
                v95[1] = 3221225472LL;
                v95[2] = sub_100231618;
                v95[3] = &unk_100888140;
                v95[4] = a1;
                v95[5] = v91;
                acc_transportClient_setEndpointPropertyDidChangeHandler( v95,  kCFACCProperties_Endpoint_AudioProduct_AuthChallenge);
                v94[0] = _NSConcreteStackBlock;
                v94[1] = 3221225472LL;
                v94[2] = sub_100231B4C;
                v94[3] = &unk_100888140;
                v94[4] = a1;
                v94[5] = v91;
                acc_transportClient_setEndpointPropertyDidChangeHandler( v94,  kCFACCProperties_Endpoint_AudioProduct_AuthState);
                v93[0] = _NSConcreteStackBlock;
                v93[1] = 3221225472LL;
                v93[2] = sub_100231E34;
                v93[3] = &unk_100888140;
                v93[4] = a1;
                v93[5] = v91;
                acc_transportClient_setEndpointPropertyDidChangeHandler( v93,  kCFACCProperties_Endpoint_AACP_CertificateRequired);
                CFRelease(v64);
                CFRelease(v65);
              }

              else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
              {
                sub_1003CF00C(v91, keys);
                sub_1006606A4();
              }

              CFRelease(v45);
            }

            else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
            {
              sub_1003CF00C(v91, keys);
              sub_100660658();
            }
          }

          acc_transportClient_setPropertyForConnectionWithUUID( kCFACCProperties_Connection_EndpointUUIDForAccessoryInfo,  v41,  *(void *)(a2 + 128));
          v76 = acc_transportClient_publishConnection(*(void *)(a2 + 128));
          v77 = (os_log_s *)qword_1008F7560;
          if (v76)
          {
            if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            sub_1003CF00C(v91, buf);
            if ((buf[23] & 0x80u) == 0) {
              v78 = buf;
            }
            else {
              v78 = *(uint8_t **)buf;
            }
            v79 = *(void *)(a2 + 128);
            *(_DWORD *)valuePtr = 136446466;
            *(void *)&valuePtr[4] = v78;
            v107 = 2112;
            *(void *)v108 = v79;
            _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: Published connection for device %{public}s, connection %@",  valuePtr,  0x16u);
LABEL_119:
            v73 = *(void **)buf;
LABEL_121:
            operator delete(v73);
            return;
          }

          if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
          {
            sub_1003CF00C(v91, buf);
            if ((buf[23] & 0x80u) == 0) {
              v80 = buf;
            }
            else {
              v80 = *(uint8_t **)buf;
            }
            v81 = *(void *)(a2 + 128);
            *(_DWORD *)valuePtr = 136446466;
            *(void *)&valuePtr[4] = v80;
            v107 = 2112;
            *(void *)v108 = v81;
            _os_log_error_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_ERROR,  "publishAccRemoteFirmware: Failed to publish connection for device %{public}s, connection %@",  valuePtr,  0x16u);
            goto LABEL_119;
          }
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
        {
          sub_10066062C();
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
      {
        sub_100660600();
      }

      return;
    }
  }

  v116 = 0LL;
  v115 = 0u;
  memset(keys, 0, sizeof(keys));
  v113 = 0LL;
  v112 = 0u;
  memset(buf, 0, sizeof(buf));
  v25 = *(void *)(a2 + 128);
  v26 = v24[7];
  v100[0] = _NSConcreteStackBlock;
  v100[1] = 3221225472LL;
  v100[2] = sub_100230D60;
  v100[3] = &unk_1008880C0;
  v100[4] = a1;
  v27 = acc_transportClient_createEndpoint(v25, 2LL, 7LL, v26, v100, 0LL);
  if (v27)
  {
    v99[0] = _NSConcreteStackBlock;
    v99[1] = 3221225472LL;
    v99[2] = sub_10023128C;
    v99[3] = &unk_1008880E0;
    v99[4] = a1;
    acc_transportClient_setEndpointPropertyDidChangeHandler(v99, v89);
    v24[11] = v27;
    v28 = v24 + 11;
    keys[0] = v87;
    keys[1] = v86;
    keys[2] = v85;
    keys[3] = v84;
    *(void *)&v115 = v83;
    *((void *)&v115 + 1) = v21;
    v116 = v22;
    v29 = v24[2];
    uint64_t v30 = v24[3];
    *(void *)buf = *v24;
    *(void *)&buf[8] = v29;
    *(void *)&buf[16] = v24[1];
    *(void *)&buf[24] = v30;
    *((void *)&v112 + 1) = v24[10];
    v31 = (const __CFString *)v24[5];
    *(void *)&v112 = v24[6];
    Length = CFStringGetLength(v31);
    v33 = 5LL;
    if (!Length) {
      v33 = 4LL;
    }
    v113 = v24[v33];
    v34 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)buf,  7LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    acc_transportClient_setAccessoryInfo(*v28, v34);
    v35 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, v24 + 12);
    acc_transportClient_setPropertyForEndpointWithUUID(v23, v35, *v28);
    v36 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(v91, __p);
      v37 = __p;
      if (v105 < 0) {
        v37 = *(_BYTE **)__p;
      }
      v38 = *(void *)(a2 + 128);
      v39 = v24[11];
      *(_DWORD *)valuePtr = 136446978;
      *(void *)&valuePtr[4] = v37;
      v107 = 1024;
      *(_DWORD *)v108 = v20;
      *(_WORD *)&v108[4] = 2112;
      *(void *)&v108[6] = v38;
      v109 = 2112;
      v110 = v39;
      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "publishAccRemoteFirmware: Created EA endpoint for device %{public}s (index %d), connection %@, endpoint %@",  valuePtr,  0x26u);
      if (v105 < 0) {
        operator delete(*(void **)__p);
      }
    }

    CFRelease(v34);
    CFRelease(v35);
    goto LABEL_50;
  }

  v71 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(v91, valuePtr);
    v72 = v108[9] >= 0 ? valuePtr : *(_BYTE **)valuePtr;
    *(_DWORD *)__p = 136446466;
    *(void *)&__p[4] = v72;
    v103 = 1024;
    v104 = v20;
    _os_log_error_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_ERROR,  "publishAccRemoteFirmware: Failed to create CoreAccessories EA endpoint for device %{public}s (index %d)",  __p,  0x12u);
    if ((v108[9] & 0x80000000) != 0)
    {
      v73 = *(void **)valuePtr;
      goto LABEL_121;
    }
  }

  sub_100242FAC((uint64_t)v38);
  return v9;
}

  if (v29)
  {
    uint64_t v30 = (uint64_t *)v29;
    operator delete(v29);
  }

  return sub_100242FAC((uint64_t)v34);
}

      ++v1;
    }

    while (v1 != v2);
  }

  uint64_t v15 = sub_100404FE8();
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_1005D875C;
  v16[3] = &unk_100880C30;
  v16[4] = &buf;
  sub_100405384(v15, v16);
  _Block_object_dispose(&buf, 8);
  sub_1005DD104((uint64_t)&v41, v42[0]);
  if (v20)
  {
    unint64_t v21 = (char *)v20;
    operator delete(v20);
  }

  if (v23)
  {
    uint64_t v24 = (char *)v23;
    operator delete(v23);
  }

  if (v26)
  {
    v27 = (char *)v26;
    operator delete(v26);
  }

  if (v29)
  {
    __dst = v29;
    operator delete(v29);
  }

  v182 = 0LL;
  v180 = 0u;
  v181 = 0u;
  *(_OWORD *)v179 = 0u;
  sub_100494958(v187, (uint64_t)__p);
  sub_10040CD60(v179, __p, v11, &v184, *v166, v10);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  v165 = (unsigned __int8 *)v22;
  if (qword_1008D9298 != -1) {
    dispatch_once(&qword_1008D9298, &stru_1008A4118);
  }
  sub_10040D074(qword_1008D9290, (uint64_t)v179);
  if ((void *)v18 == v16)
  {
    uint64_t v24 = 0;
  }

  else
  {
    uint64_t v30 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(v187, (uint64_t)&buf);
      v31 = (char)buf.__r_.__value_.__s.__size_;
      v32 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      v33 = v203;
      sub_100494E68(v187, v203);
      if (v31 >= 0) {
        v32 = &buf;
      }
      if (SBYTE7(v204) < 0) {
        v33 = *(uint8_t **)v203;
      }
      v34 = sub_1005E2B18(*(_DWORD *)(*((void *)v168 + 1) + 168LL));
      LODWORD(__p[0]) = 136446722;
      *(void **)((char *)__p + 4) = v32;
      WORD2(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 6) = v33;
      HIWORD(__p[2]) = 2082;
      __p[3] = (void *)v34;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s(%{public}s) %{public}s already scanning, stopping first",  (uint8_t *)__p,  0x20u);
      if (SBYTE7(v204) < 0) {
        operator delete(*(void **)v203);
      }
    }

    sub_1005F24EC(a1, v187, 0, 0, 1);
    *(_BYTE *)(a1 + 1840) = 1;
  }

  __p[0] = &v187;
  sub_100029574((uint64_t **)(a1 + 2040), &v187, (uint64_t)&unk_1006C2518, (uint64_t **)__p)[5] = (uint64_t)v168;
  v35 = sub_100494958(v187, (uint64_t)v177);
  *((_DWORD *)v168 + 52) = sub_1005F0830(v35, (uint64_t *)v177, v168[81]);
  if (v178 < 0) {
    operator delete(v177[0]);
  }
  v36 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
  {
    sub_100494958(v187, (uint64_t)v176);
    sub_10069C944(v176, (int *)v168 + 52, (uint64_t)v198, v36);
  }

  if (*(_BYTE *)(*((void *)v168 + 1) + 143LL))
  {
    v37 = (os_log_s *)qword_1008F76D8;
    if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(a1 + 1792)) {
        v38 = "YES";
      }
      else {
        v38 = "NO";
      }
      LODWORD(__p[0]) = 136446210;
      *(void **)((char *)__p + 4) = (void *)v38;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "New request to do scan with Exposure Notification fENAdvBufferEnabled:%{public}s",  (uint8_t *)__p,  0xCu);
    }

    sub_100616A44((uint64_t)v168);
    v168[81] = 16;
    *((_DWORD *)v168 + 24) = 4;
    **((_BYTE **)v168 + 1) = 1;
    if (*(_BYTE *)(a1 + 1792)) {
      sub_1005F313C(a1, 2LL);
    }
    if (*(_BYTE *)(a1 + 1255))
    {
      sub_1005E9E20(a1, 2LL, 1);
      sub_1005EA3D8(a1);
    }

    else
    {
      sub_1005F377C(a1);
    }
  }

  if (*(_BYTE *)(a1 + 4386))
  {
    v39 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
    {
      sub_100494958(v187, (uint64_t)&buf);
      v157 = (char)buf.__r_.__value_.__s.__size_;
      v158 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      v159 = v203;
      sub_100494E68(v187, v203);
      if (v157 >= 0) {
        v158 = &buf;
      }
      if (SBYTE7(v204) < 0) {
        v159 = *(uint8_t **)v203;
      }
      v160 = sub_1005E2B18(*(_DWORD *)(*((void *)v168 + 1) + 168LL));
      LODWORD(__p[0]) = 136446722;
      *(void **)((char *)__p + 4) = v158;
      WORD2(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 6) = v159;
      HIWORD(__p[2]) = 2082;
      __p[3] = (void *)v160;
      _os_log_error_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "WILLSLEEP violation! Session %{public}s(%{public}s) %{public}s asking to start scan",  (uint8_t *)__p,  0x20u);
      if (SBYTE7(v204) < 0) {
        operator delete(*(void **)v203);
      }
    }
  }

  if ((_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures") & 1) == 0)
  {
    v40 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "ADVBUFF Legacy mode", (uint8_t *)__p, 2u);
    }

    if (sub_1006112E4((uint64_t)v168))
    {
      *(_BYTE *)(a1 + 170) = 0;
    }

    else if (v24)
    {
      *(_BYTE *)(a1 + 170) = *(_BYTE *)(a1 + 167);
    }

    if (!sub_1006112F4((uint64_t)v168))
    {
      if (!v24) {
        goto LABEL_106;
      }
      *(_BYTE *)(a1 + 714) = *(_BYTE *)(a1 + 711);
      goto LABEL_105;
    }

    if (sub_1006112E4((uint64_t)v168)
      && (v41 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v41 + 704LL))(v41) < 2))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069C8B8();
      }
    }

    else
    {
      *(_BYTE *)(a1 + 714) = 0;
    }

    if (v24)
    {
LABEL_105:
      v43 = sub_100404FE8();
      __p[0] = _NSConcreteStackBlock;
      __p[1] = (void *)3221225472LL;
      __p[2] = sub_1005ED760;
      __p[3] = &unk_10087EB68;
      *(void *)&v190 = a1;
      DWORD2(v190) = 2;
      sub_100405384(v43, __p);
    }
  }

  uint64_t v15 = sub_100298544(7, (UInt8 *)(a1 + 408), 16LL, &v27);
  if (v15 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E648();
    }
    goto LABEL_97;
  }

  if (v15 || v27 != 16)
  {
    arc4random_buf((void *)(a1 + 408), 0x10uLL);
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E810();
    }
    if (sub_10029871C(7u, (const UInt8 *)(a1 + 408), 0x10u))
    {
      uint64_t v16 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "Failed to set new Cloud Nonce!",  buf,  2u);
        uint64_t v16 = (os_log_s *)qword_1008F75A8;
      }

      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_10069E7E4();
      }
      goto LABEL_97;
    }
  }

  if (sub_1001115A4((__int128 *)(a1 + 136), 1, 0, (void *)(a1 + 184)))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E784();
    }
    goto LABEL_97;
  }

  sub_10029871C(8u, (const UInt8 *)(a1 + 184), 0x10u);
  if (sub_1001115A4((__int128 *)(a1 + 136), 3, 0, (void *)(a1 + 200)))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E724();
    }
    goto LABEL_97;
  }

  if (v9 && sub_10061A890(a1))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E674();
    }
    sub_10061A988();
    unint64_t v22 = sub_1002E6E00();
    sub_1004FC118(v22, 1);
  }

  v26 = 0;
  v25 = 0;
  uint64_t v24 = 1;
  uint64_t v17 = sub_100298544(16, (UInt8 *)&v25, 6LL, &v27);
  if (v17 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E6A0();
    }
    goto LABEL_97;
  }

  if (v17 || v27 != 6)
  {
    arc4random_buf(&v25, 6uLL);
    LOBYTE(v25) = v25 | 0xC0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069E6F8();
    }
    if (sub_10029871C(0x10u, (const UInt8 *)&v25, 6u))
    {
      unint64_t v18 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "Failed to set new local static random address!",  buf,  2u);
        unint64_t v18 = (os_log_s *)qword_1008F75A8;
      }

      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_10069E6CC();
      }
      goto LABEL_97;
    }
  }

  *(void *)(a1 + 216) = ((unint64_t)v25 << 40) | ((unint64_t)BYTE1(v25) << 32) | ((unint64_t)BYTE2(v25) << 24) | ((unint64_t)HIBYTE(v25) << 16) | ((unint64_t)v26 << 8) | HIBYTE(v26) | ((unint64_t)v24 << 48);
  sub_1000B1BE8((__int128 *)(a1 + 136), (__n128 *)(a1 + 168));
  sub_1001C73B8(*(void *)(a1 + 216));
  uint64_t v6 = sub_100619AEC(a1);
  if ((_DWORD)v6 != 130)
  {
    if ((_DWORD)v6 != 103 || (uint64_t v6 = sub_100619C74((__n128 *)a1), !(_DWORD)v6))
    {
      v20 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        sub_1005BFC20(*(void *)(a1 + 216), &__p);
        unint64_t v21 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &__p
            : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 68225283;
        uint64_t v30 = 16;
        v31 = 2097;
        v32 = a1 + 184;
        v33 = 1041;
        v34 = 16;
        v35 = 2097;
        v36 = a1 + 200;
        v37 = 1041;
        v38 = 16;
        v39 = 2097;
        v40 = a1 + 136;
        v41 = 1041;
        v42 = 16;
        v43 = 2097;
        v44 = a1 + 168;
        v45 = 2080;
        v46 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "IRK=%{private}.16P DHK=%{private}.16P IR=%{private}.16P ER=%{private}.16P fLocalStaticRandomAddress:%s",  buf,  0x4Cu);
      }

      *(_BYTE *)(a1 + 371_Block_object_dispose(&STACK[0x338], 8) = 1;
      sub_10061AA00(a1);
      goto LABEL_6;
    }
  }

  if (!v20 && v36) {
    operator delete[](v36);
  }
  if (!HIDWORD(v34) && v37) {
    operator delete[](v37);
  }
  return sub_100242FAC((uint64_t)v38);
}

id sub_10000EF38(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _xpcListenerEvent:a2];
}

id sub_10000EF44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [*(id *)(a1 + 32) _xpcPublisherConnectionsAction:a2 token:a3 info:a4];
}

void sub_10000EF58(id a1, int a2)
{
  if (dword_1008D5FD8 <= 90)
  {
    uint64_t v2 = *(void *)&a2;
    if (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL))
    {
      uint64_t v3 = CUPrintErrorCode(v2);
      id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _activate]_block_invoke_3",  90LL,  "### XPC publisher error: connections, %@",  v4);
    }
  }

id sub_10000EFEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [*(id *)(a1 + 32) _xpcPublisherDiscoveryAction:a2 token:a3 info:a4];
}

void sub_10000F000(id a1, int a2)
{
  if (dword_1008D5FD8 <= 90)
  {
    uint64_t v2 = *(void *)&a2;
    if (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL))
    {
      uint64_t v3 = CUPrintErrorCode(v2);
      id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _activate]_block_invoke_5",  90LL,  "### XPC publisher error: discovery, %@",  v4);
    }
  }

id sub_10000F094(uint64_t a1)
{
  return [*(id *)(a1 + 32) _prefsChanged];
}

dispatch_source_s *sub_10000F104(uint64_t a1)
{
  result = *(dispatch_source_s **)(a1 + 32);
  if (result == *(dispatch_source_s **)(*(void *)(a1 + 40) + 144LL))
  {
    unint64_t data = dispatch_source_get_data(result);
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      uint64_t v4 = CUPrintFlags32(data, &unk_1006BA43A);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _activate]_block_invoke_7",  30LL,  "Memory pressure changed: %@",  v5);
    }

    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = *(_DWORD *)(v6 + 168);
    if (!v7) {
      LOBYTE(v7) = data;
    }
    *(_DWORD *)(v6 + 140) = v7 & 6;
    return (dispatch_source_s *)[*(id *)(a1 + 40) _updateMemoryPressure];
  }

  return result;
}

id sub_10000F1EC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _update];
}

id sub_10000F1F4(uint64_t a1)
{
  return [*(id *)(a1 + 32) scheduleSpatialUpdateImmediate:0];
}

id sub_10000F200(uint64_t a1)
{
  return [*(id *)(a1 + 32) scheduleSpatialUpdateImmediate:0];
}

id sub_10000F20C(uint64_t a1)
{
  *(_DWORD *)(*(void *)(a1 + 32) + 232) = [*(id *)(a1 + 40) screenOn];
  return [*(id *)(a1 + 32) _update];
}

uint64_t sub_10000F23C(uint64_t a1)
{
  int v2 = *(_DWORD *)(*(void *)(a1 + 32) + 156LL);
  uint64_t state64 = 0LL;
  uint64_t result = notify_get_state(v2, &state64);
  uint64_t v4 = state64;
  int v5 = state64 != 0;
  if (dword_1008D5FD8 <= 30)
  {
    if (dword_1008D5FD8 != -1 || (uint64_t result = _LogCategory_Initialize(&dword_1008D5FD8, 30LL), (_DWORD)result))
    {
      uint64_t v6 = "yes";
      if (*(_BYTE *)(*(void *)(a1 + 32) + 152LL)) {
        int v7 = "yes";
      }
      else {
        int v7 = "no";
      }
      if (!v4) {
        uint64_t v6 = "no";
      }
      uint64_t result = LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _activate]_block_invoke_12",  30LL,  "Odeon changed: %s -> %s",  v7,  v6);
    }
  }

  uint64_t v8 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v8 + 152) != v5)
  {
    *(_BYTE *)(v8 + 152) = v5;
    return (uint64_t)[*(id *)(a1 + 32) scheduleSpatialUpdateImmediate:0];
  }

  return result;
}

id sub_10000F324(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updateUserControllerCloudDevices];
}

id sub_10000F32C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updateUserControllerCloudDevices];
}

uint64_t sub_10000F334(uint64_t a1)
{
  return CUStateDumpWithObject("CBDaemon", *(void *)(a1 + 32), &dword_1008D5FD8);
}

id sub_10000F36C(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 81LL) = 20;
  if (dword_1008D5FD8 <= 30 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
  {
    unsigned int v2 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 81LL);
    if (v2 > 9)
    {
      if (v2 == 10)
      {
        uint64_t v3 = "NotStarted";
        goto LABEL_15;
      }

      if (v2 == 20)
      {
        uint64_t v3 = "Complete";
        goto LABEL_15;
      }
    }

    else
    {
      if (!*(_BYTE *)(*(void *)(a1 + 32) + 81LL))
      {
        uint64_t v3 = "Unknown";
        goto LABEL_15;
      }

      if (v2 == 1)
      {
        uint64_t v3 = "FrameworkUnavailable";
LABEL_15:
        LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _activate]_block_invoke_16", 30LL, "Device setup %s", v3);
        return [*(id *)(a1 + 32) _update];
      }
    }

    uint64_t v3 = "?";
    goto LABEL_15;
  }

  return [*(id *)(a1 + 32) _update];
}

id sub_10000F4B0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _invalidate];
}

LABEL_88:
    self->_prefCBExtensionRSSIOverride = v29;
  }

  v31 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"deviceSetupState", &v106);
  if (v106) {
    goto LABEL_117;
  }
  v32 = v31;
  deviceSetupState = self->_deviceSetupState;
  if (v31 == deviceSetupState) {
    goto LABEL_117;
  }
  if (dword_1008D5FD8 <= 30)
  {
    if (dword_1008D5FD8 != -1) {
      goto LABEL_93;
    }
    if (_LogCategory_Initialize(&dword_1008D5FD8, 30LL))
    {
      LODWORD(deviceSetupState) = self->_deviceSetupState;
LABEL_93:
      if ((int)deviceSetupState > 9)
      {
        if ((_DWORD)deviceSetupState == 10)
        {
          v34 = "NotStarted";
          goto LABEL_105;
        }

        if ((_DWORD)deviceSetupState == 20)
        {
          v34 = "Complete";
          goto LABEL_105;
        }
      }

      else
      {
        if (!(_DWORD)deviceSetupState)
        {
          v34 = "Unknown";
          goto LABEL_105;
        }

        if ((_DWORD)deviceSetupState == 1)
        {
          v34 = "FrameworkUnavailable";
          goto LABEL_105;
        }
      }

      v34 = "?";
LABEL_105:
      if (v32 > 9u)
      {
        if (v32 == 10)
        {
          v35 = "NotStarted";
          goto LABEL_115;
        }

        if (v32 == 20)
        {
          v35 = "Complete";
          goto LABEL_115;
        }
      }

      else
      {
        if (!v32)
        {
          v35 = "Unknown";
          goto LABEL_115;
        }

        if (v32 == 1)
        {
          v35 = "FrameworkUnavailable";
LABEL_115:
          LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "DeviceSetupState: %s -> %s",  v34,  v35);
          goto LABEL_116;
        }
      }

      v35 = "?";
      goto LABEL_115;
    }
  }

                          *((_BYTE *)a1 + 15) = 1;
                          goto LABEL_89;
                        }

                        *((_BYTE *)a1 + 15) = 1;
LABEL_87:
                        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestac"
                                               "k/l2cap/signalman.c");
                        goto LABEL_88;
                      }

                      *((_BYTE *)a1 + 15) = 1;
LABEL_86:
                      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/"
                                             "l2cap/signalman.c");
                      v52 = *((unsigned __int8 *)a1 + 14);
                      *((_BYTE *)a1 + 15) = 1;
                      if (v52 != 1) {
                        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1356,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                      }
                      goto LABEL_87;
                    }

                    *((_BYTE *)a1 + 15) = 1;
LABEL_85:
                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
                    v51 = *((unsigned __int8 *)a1 + 14);
                    *((_BYTE *)a1 + 15) = 1;
                    if (v51 != 1) {
                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1355,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                    }
                    goto LABEL_86;
                  }

                  *((_BYTE *)a1 + 15) = 1;
LABEL_84:
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
                  v50 = *((unsigned __int8 *)a1 + 14);
                  *((_BYTE *)a1 + 15) = 1;
                  if (v50 != 1) {
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1354,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                  }
                  goto LABEL_85;
                }

                *((_BYTE *)a1 + 15) = 1;
              }

              else
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
                v48 = *((unsigned __int8 *)a1 + 14);
                *((_BYTE *)a1 + 15) = 1;
                if (v48 != 1) {
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1352,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                }
              }

              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              v49 = *((unsigned __int8 *)a1 + 14);
              *((_BYTE *)a1 + 15) = 1;
              if (v49 != 1) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1353,  "(*pBs).__RWFlag == BYTESTREAM_READ");
              }
              goto LABEL_84;
            case 5:
              if (*((_BYTE *)a1 + 14) != 1) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1365,  "(*pBs).__RWFlag == BYTESTREAM_READ");
              }
              if ((v22 & 1) != 0)
              {
                v44 = *((unsigned __int16 *)a1 + 5);
                v45 = *((unsigned __int16 *)a1 + 6);
                if (v44 > v45)
                {
                  v46 = *a1;
                  *((_WORD *)a1 + 6) = v45 + 1;
                  LOBYTE(v72) = *(_BYTE *)(v46 + v45);
                  v47 = v44 - (v45 + 1);
LABEL_72:
                  if (v47 >= v18 - 1) {
                    *((_WORD *)a1 + 6) += v18 - 1;
                  }
                  else {
                    *((_BYTE *)a1 + 15) = 1;
                  }
                  v67 = (char *)&v72;
                  goto LABEL_90;
                }
              }

              else
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              }

              *((_BYTE *)a1 + 15) = 1;
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              v47 = 0;
              goto LABEL_72;
            default:
              if (sub_1000A86F0())
              {
                sub_1001EE134( (uint64_t)"rcvd config rsp with unknown option (%d) len %d, ignoring option",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v17);
                v31 = (os_log_s *)sub_100086554(0x2Fu);
                if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                {
                  v53 = sub_1001EDDCC();
                  *(_DWORD *)buf = 136446466;
                  v75 = v53;
                  v76 = 1024;
                  v77 = 0xFFFF;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
                }
              }

              if (*((_BYTE *)a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
                v32 = 0;
              }

              else
              {
                v32 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
              }

              if (v32 >= v18) {
                *((_WORD *)a1 + 6) += v18;
              }
              else {
                *((_BYTE *)a1 + 15) = 1;
              }
              goto LABEL_90;
          }
        }
      }

      break;
    }

    unint64_t v22 = 0;
    *((_BYTE *)a1 + 15) = 1;
    goto LABEL_27;
  }

  v68 = 0LL;
  v69 = 0LL;
  v70 = 0LL;
  v67 = 0LL;
  uint64_t v16 = 0LL;
  if (v13)
  {
LABEL_97:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"SignalMan_RecvConfigRsp - %!", v54, v55, v56, v57, v58, v59, v60, 411LL);
      v61 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else
  {
LABEL_101:
    sub_100178498(v66, v65, v63, v64, (uint64_t)v69, (uint64_t)v68, (uint64_t)v70, (uint64_t)v16, v67, v62);
  }

  v31 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v32 = *v2;
  *unsigned int v2 = (void *)v31;

  v33 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v34 = *(void **)(a1 + 752);
  *(void *)(a1 + 752) = v33;

  v35 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v36 = *(void **)(a1 + 760);
  *(void *)(a1 + 760) = v35;

  v37 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v38 = *(void **)(a1 + 768);
  *(void *)(a1 + 76_Block_object_dispose(&STACK[0x338], 8) = v37;

  v39 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v40 = *(void **)(a1 + 776);
  *(void *)(a1 + 776) = v39;

  v41 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v42 = *(void **)(a1 + 784);
  *(void *)(a1 + 784) = v41;

  v43 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v44 = *(void **)(a1 + 792);
  *(void *)(a1 + 792) = v43;

  v45 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  v46 = *(void **)(a1 + 824);
  *(void *)(a1 + 824) = v45;

  *(_BYTE *)(a1 + 1109) = 24;
  v47 = sub_1002E6E9C();
  *(_BYTE *)(a1 + 110_Block_object_dispose(&STACK[0x338], 8) = (*(uint64_t (**)(uint64_t, void))(*(void *)v47 + 3464LL))( v47,  *(unsigned __int8 *)(a1 + 1109));
  v48 = sub_1002E6E00();
  v49 = *(void **)(a1 + 552);
  *(void *)(a1 + 552) = 0LL;

  *(void *)buf = 0LL;
  sub_1000B0400((uint64_t)buf);
  v50 = *(__int16 *)&buf[4];
  *(void *)(a1 + 872) = *(int *)buf;
  *(void *)(a1 + 880) = v50;
  *(_BYTE *)(a1 + 88_Block_object_dispose(&STACK[0x338], 8) = 0;
  v169 = 0;
  *(_BYTE *)(a1 + 106_Block_object_dispose(&STACK[0x338], 8) = 0;
  *(_BYTE *)(a1 + 1074) = 0;
  *(_DWORD *)(a1 + 1070) = 0;
  v51 = sub_1002E6E00();
  sub_10002418C(buf, "ScanCore");
  sub_10002418C(__p, "IsScanCoreConnectionOverriden");
  v52 = (_BYTE *)(a1 + 1068);
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v51 + 72LL))( v51,  buf,  __p,  a1 + 1068))
  {
    v53 = *v52;
    if (v171 < 0) {
      operator delete(__p[0]);
    }
    if (v175 < 0)
    {
      operator delete(*(void **)buf);
      if (!v53) {
        goto LABEL_137;
      }
    }

    else if (!v53)
    {
      goto LABEL_137;
    }

    v54 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "Overriding Connection Scan Parameters on ScanCore.",  buf,  2u);
    }

    v55 = sub_1002E6E00();
    sub_10002418C(buf, "ScanCore");
    sub_10002418C(__p, "IsScanCoreEnabledConnectionScan");
    if (!(*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v55 + 72LL))( v55,  buf,  __p,  a1 + 1074))
    {
      if (v171 < 0) {
        operator delete(__p[0]);
      }
      if (v175 < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_134;
    }

    v56 = *(unsigned __int8 *)(a1 + 1074);
    if (v171 < 0) {
      operator delete(__p[0]);
    }
    if (v175 < 0)
    {
      operator delete(*(void **)buf);
      if (!v56) {
        goto LABEL_134;
      }
    }

    else if (!v56)
    {
LABEL_134:
      v66 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEFAULT,  "Overriding ScanCore Disabled for Connection Scan.",  buf,  2u);
      }

  v35 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionCM_XOR_Mask");
  v36 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v35 + 88LL))( v35,  buf,  __p,  (char *)&v57 + 4);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v36) {
      goto LABEL_96;
    }
  }

  else if (!v36)
  {
    goto LABEL_96;
  }

  v37 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = HIDWORD(v57);
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionCM_XOR_Mask (%d)",  buf,  8u);
  }

LABEL_116:
  self->_deviceSetupState = v32;
LABEL_117:
  v36 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"discoveryProxy", &v106);
  if (v106) {
    v37 = 0;
  }
  else {
    v37 = v36 == 0;
  }
  v38 = !v37;
  if (self->_prefDiscoveryProxy != v38)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v39 = "yes";
      if (v38) {
        v40 = "no";
      }
      else {
        v40 = "yes";
      }
      if (!v38) {
        v39 = "no";
      }
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _prefsChanged]", 30LL, "DiscoveryProxy: %s -> %s", v40, v39);
    }

    self->_prefDiscoveryProxy = v38;
  }

  v41 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"enforceApprovedExtensions", &v106);
  if (v106) {
    v42 = 0;
  }
  else {
    v42 = v41 == 0;
  }
  v43 = !v42;
  if (self->_prefEnforceApprovedExtensions != v43)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v44 = "yes";
      if (v43) {
        v45 = "no";
      }
      else {
        v45 = "yes";
      }
      if (!v43) {
        v44 = "no";
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "EnforceApprovedExtensions: %s -> %s",  v45,  v44);
    }

    self->_prefEnforceApprovedExtensions = v43;
  }

  v46 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"enforceApprovedList", &v106);
  if (v106) {
    v47 = 0;
  }
  else {
    v47 = v46 == 0;
  }
  v48 = !v47;
  if (self->_prefEnforceApprovedList != v48)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v49 = "yes";
      if (v48) {
        v50 = "no";
      }
      else {
        v50 = "yes";
      }
      if (!v48) {
        v49 = "no";
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "EnforceApprovedlist: %s -> %s",  v50,  v49);
    }

    self->_prefEnforceApprovedList = v48;
  }

  TypeID = CFDataGetTypeID();
  v52 = (void *)CFPrefs_CopyTypedValue(@"com.apple.bluetooth", @"filterNearbyActionExtraData", TypeID, 0LL);
  prefFilterNearbyActionExtraData = self->_prefFilterNearbyActionExtraData;
  v54 = v52;
  v55 = prefFilterNearbyActionExtraData;
  if (v54 == v55)
  {

    v58 = v54;
LABEL_179:

    goto LABEL_180;
  }

  v56 = v55;
  if ((v54 == 0LL) == (v55 != 0LL))
  {

LABEL_174:
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v59 = CUPrintNSDataHex(self->_prefFilterNearbyActionExtraData, 100LL, 0LL);
      v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
      v61 = CUPrintNSDataHex(v54, 100LL, 0LL);
      v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "FilterNearbyActionExtraData: <%@> -> <%@>",  v60,  v62);
    }

    v63 = v54;
    v58 = self->_prefFilterNearbyActionExtraData;
    self->_prefFilterNearbyActionExtraData = v63;
    goto LABEL_179;
  }

  v57 = -[NSData isEqual:](v54, "isEqual:", v55);

  if ((v57 & 1) == 0) {
    goto LABEL_174;
  }
LABEL_180:
  v64 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"extensionsEnabled", &v106);
  v65 = v64 != 0;
  if (v106)
  {
    v66 = v64;
    v65 = GestaltGetDeviceClass(v64) - 1 < 3 || v66 != 0;
  }

  if (self->_prefExtensionsEnabled != v65)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v68 = "yes";
      if (v65) {
        v69 = "no";
      }
      else {
        v69 = "yes";
      }
      if (!v65) {
        v68 = "no";
      }
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _prefsChanged]", 30LL, "ExtensionsEnabled: %s -> %s", v69, v68);
    }

    self->_prefExtensionsEnabled = v65;
  }

  v70 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"memoryPressureFlags", 0LL);
  prefMemoryPressureFlags = self->_prefMemoryPressureFlags;
  if (v70 != prefMemoryPressureFlags)
  {
    if (dword_1008D5FD8 <= 30)
    {
      if (dword_1008D5FD8 == -1)
      {
        prefMemoryPressureFlags = self->_prefMemoryPressureFlags;
      }

      v72 = CUPrintFlags32(prefMemoryPressureFlags, &unk_1006BA43A);
      v73 = (void *)objc_claimAutoreleasedReturnValue(v72);
      v74 = CUPrintFlags64(v70, &unk_1006BA43A);
      v75 = (void *)objc_claimAutoreleasedReturnValue(v74);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "MemoryPressureFlags: %@ -> %@",  v73,  v75);
    }

  uint64_t result = 0LL;
  *a5 = v54;
  *uint64_t v6 = (_WORD)v52 + 1;
  return result;
}

  if ((v106 & _os_feature_enabled_impl("BluetoothFeatures", "ConnectionSetup")) == 1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEBUG))
    {
      sub_1003CF00C(a3, buf);
      sub_100662558();
    }

    v111 = v8;
    *(void *)__p = &v111;
    v100 = sub_10023F1E0(a1 + 448, &v111, (uint64_t)&unk_1006C2518, (void **)__p);
    sub_10023A6E4(v100 + 3, v114);
  }

  sub_1002400EC(v114);

  return 0LL;
}

  v53 = *(void **)(a1 + 224);
  if (v53 != (void *)(a1 + 232))
  {
    do
    {
      v55 = v53[4];
      v54 = (id *)v53[5];
      if (!(*((unsigned int (**)(id *))*v54 + 2))(v54))
      {
        v56 = (void *)objc_claimAutoreleasedReturnValue([v54[27] objectForKeyedSubscript:v7]);
        if (v56)
        {
          if ((v70 & 1) == 0)
          {
            sub_1002809BC((uint64_t)[v54[10] removeObjectForKey:v7], v55, (uint64_t)v54, v7, a4, 0);
            [v54[27] removeObjectForKey:v7];
          }
        }

        else
        {
          v56 = (void *)objc_claimAutoreleasedReturnValue([v54[28] objectForKey:v7]);
          if (v56)
          {
            v57 = (os_log_s *)qword_1008F7628;
            if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
            {
              sub_100494958(v55, (uint64_t)&v84);
              v58 = (v84.__r_.__value_.__s.__size_ & 0x80u) == 0
                  ? &v84
                  : (std::string *)v84.__r_.__value_.__r.__words[0];
              *(_DWORD *)buf = 138543874;
              *(void *)&buf[4] = v7;
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v58;
              *(_WORD *)&buf[22] = 1024;
              *(_DWORD *)&buf[24] = v67;
              _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "Reconnecting device %{public}@ for session %{public}s linkReady %d",  buf,  0x1Cu);
            }

            objc_msgSend(v54[28], "removeObjectForKey:", v7, v61);
            sub_100391320((uint64_t)v54, v55, v7, v56);
          }
        }
      }

      v59 = (void *)v53[1];
      if (v59)
      {
        do
        {
          v60 = v59;
          v59 = (void *)*v59;
        }

        while (v59);
      }

      else
      {
        do
        {
          v60 = (void *)v53[2];
          v51 = *v60 == (void)v53;
          v53 = v60;
        }

        while (!v51);
      }

      v53 = v60;
    }

    while (v60 != (void *)(a1 + 232));
  }
}

              v19 = 0LL;
            }

            else
            {
              if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
                sub_100670728();
              }
              v19 = 2LL;
            }
          }
        }

        else
        {
          v84 = (os_log_s *)qword_1008F7568;
          if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "Warning: finishSession: No real log files to send",  buf,  2u);
          }

          v19 = 1LL;
        }

        if (!*(_BYTE *)(a1 + 34))
        {
          v87 = sub_1002E6BF0();
          if (((*(uint64_t (**)(uint64_t))(*(void *)v87 + 328LL))(v87) & 1) != 0
            || (v88 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v88 + 424LL))(v88)))
          {
            v89 = sub_1002E6E00();
            if ((*(unsigned int (**)(uint64_t))(*(void *)v89 + 8LL))(v89))
            {
              v90 = sub_1002E6E00();
              sub_10002418C(buf, "AccessoryLogging");
              sub_10002418C(v109, "StoredLogsRetrieved");
              (*(void (**)(uint64_t, _BYTE *, void **, void))(*(void *)v90 + 80LL))( v90,  buf,  v109,  v108 & 1);
              if (v110 < 0) {
                operator delete(v109[0]);
              }
              if (SHIBYTE(v128) < 0) {
                operator delete(*(void **)buf);
              }
            }
          }
        }

        v85 = (uint64_t *)__p;
        if (__p != v120)
        {
          do
          {
            if (qword_1008D60E0 != -1) {
              dispatch_once(&qword_1008D60E0, &stru_100892EF0);
            }
            ++v85;
          }

          while (v85 != (uint64_t *)v120);
        }

        sub_100352F5C(a1);
LABEL_132:
        if (__p)
        {
          v120 = (char *)__p;
          operator delete(__p);
        }

        goto LABEL_134;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
  {
    sub_1006706FC();
    v19 = 1LL;
    goto LABEL_132;
  }

  v19 = 1LL;
LABEL_134:

  return v19;
}

  v96 = 0;
  v61 = sub_1002E6E00();
  sub_10002418C(buf, "LeObserver");
  sub_10002418C(__p, "OverrideContactTracingLowDutyScanDurationSeconds");
  v62 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v61 + 88LL))(v61, buf, __p, &v96);
  if (v96) {
    v63 = v62;
  }
  else {
    v63 = 0;
  }
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v63) {
      goto LABEL_128;
    }
  }

  else if (!v63)
  {
    goto LABEL_128;
  }

  *(_WORD *)(a1 + 256) = v96;
  v64 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v64 + 176LL))(v64))
  {
    v65 = (os_log_s *)qword_1008F76C8;
    if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
    {
      v66 = *(unsigned __int16 *)(a1 + 256);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v66;
      _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "Overriding fLowDutyCycleScanDurationWhileContactTracing with %d seconds",  buf,  8u);
    }
  }

LABEL_203:
    self->_prefMemoryPressureFlags = v70;
    dispatchQueue = (dispatch_queue_s *)self->_dispatchQueue;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1000106B8;
    block[3] = &unk_10087EEC8;
    block[4] = self;
    dispatch_async(dispatchQueue, block);
  }

  v77 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"NCSecondaryAdvInstance", &v106);
  if (v106) {
    v78 = 0;
  }
  else {
    v78 = v77 == 0;
  }
  v79 = !v78;
  if (self->_prefNCSecondaryAdvInstance != v79)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v80 = "yes";
      if (v79) {
        v81 = "no";
      }
      else {
        v81 = "yes";
      }
      if (!v79) {
        v80 = "no";
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "NonConnectableSecondaryAdvertisingInstance: %s -> %s",  v81,  v80);
    }

    self->_prefNCSecondaryAdvInstance = v79;
  }

  v82 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"remoteClientEnabled", &v106);
  v83 = v82 != 0;
  if (v106)
  {
    DeviceClass = GestaltGetDeviceClass(v82);
    v83 = DeviceClass == 4 || DeviceClass == 7;
  }

  if (self->_prefRemoteClientEnabled != v83)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v86 = "yes";
      if (v83) {
        v87 = "no";
      }
      else {
        v87 = "yes";
      }
      if (!v83) {
        v86 = "no";
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "RemoteClientEnabled: %s -> %s",  v87,  v86);
    }

    self->_prefRemoteClientEnabled = v83;
  }

  v88 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"remoteServerEnabled", &v106);
  v89 = v88 != 0;
  if (v106)
  {
    v90 = GestaltGetDeviceClass(v88);
    v89 = v90 == 4 || v90 == 7;
  }

  if (self->_prefRemoteServerEnabled != v89)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v92 = "yes";
      if (v89) {
        v93 = "no";
      }
      else {
        v93 = "yes";
      }
      if (!v89) {
        v92 = "no";
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "RemoteServerEnabled: %s -> %s",  v93,  v92);
    }

    self->_prefRemoteServerEnabled = v89;
  }

  CFPrefs_GetInt64(@"com.apple.bluetooth", @"systemReferenceTimeDisabled", &v106);
  self->_prefSystemReferenceTimeDisabled = 1;
  if (dword_1008D5FD8 <= 30)
  {
    v94 = "yes";
    if (dword_1008D5FD8 != -1)
    {
LABEL_259:
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _prefsChanged]", 30LL, "SystemReferenceTimeDisabled: %s", v94);
      goto LABEL_261;
    }

    if (_LogCategory_Initialize(&dword_1008D5FD8, 30LL))
    {
      if (!self->_prefSystemReferenceTimeDisabled) {
        v94 = "no";
      }
      goto LABEL_259;
    }
  }

LABEL_261:
  v95 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"whbDiscoveryAlways", &v106);
  if (v106) {
    v96 = 1;
  }
  else {
    v96 = v95 == 0;
  }
  v97 = !v96;
  if (self->_prefWHBDiscoveryAlways != v97)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v98 = "yes";
      if (v97) {
        v99 = "no";
      }
      else {
        v99 = "yes";
      }
      if (!v97) {
        v98 = "no";
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "WHBDiscoveryAlways: %s -> %s",  v99,  v98);
    }

    self->_prefWHBDiscoveryAlways = v97;
  }

  v100 = CFPrefs_GetInt64(@"com.apple.bluetooth", @"wiproxAdvertising", &v106);
  if (v106) {
    v101 = 0;
  }
  else {
    v101 = v100 == 0;
  }
  v102 = !v101;
  if (self->_prefWiProxAdvertising != v102)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      v103 = "yes";
      if (v102) {
        v104 = "no";
      }
      else {
        v104 = "yes";
      }
      if (!v102) {
        v103 = "no";
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _prefsChanged]",  30LL,  "WiProxAdvertising: %s -> %s",  v104,  v103);
    }

    self->_prefWiProxAdvertising = v102;
  }

  -[CBAccessoryDaemon prefsChanged](self->_accessoryDaemon, "prefsChanged");
  -[CBDaemonServer scheduleUpdateImmediate:](self, "scheduleUpdateImmediate:", 0LL);
}

id sub_1000106B8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updateMemoryPressure];
}

_BYTE *sub_100010C20(uint64_t a1)
{
  uint64_t result = *(_BYTE **)(a1 + 32);
  if (result[353]) {
    return [result _update];
  }
  return result;
}

void sub_100010DC8(uint64_t a1)
{
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) object]);
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___CBDevice);
  if ((objc_opt_isKindOfClass(v2, v3) & 1) != 0)
  {
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    id v4 = *(id *)(*(void *)(a1 + 40) + 536LL);
    id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v12;
      do
      {
        for (i = 0LL; i != v6; i = (char *)i + 1)
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v11 + 1) + 8 * (void)i) activatedController]);
          unint64_t v10 = (void (**)(void, void))objc_claimAutoreleasedReturnValue([v9 tipiChangedHandler]);

          if (v10) {
            ((void (**)(void, void *))v10)[2](v10, v2);
          }
        }

        id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }

      while (v6);
    }
  }
}

LABEL_60:
        if (!v15) {
          goto LABEL_65;
        }
        goto LABEL_64;
      }

      v37 = 0LL;
      unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(-[RPIdentity authTagForData:type:error:](v3, "authTagForData:type:error:", v21, 2LL, &v37));
      v23 = v37;
      if (v22)
      {
        selfAuthTagNonConnectable = self->_selfAuthTagNonConnectable;
        v25 = v22;
        v26 = selfAuthTagNonConnectable;
        if (v25 == v26)
        {
        }

        else
        {
          v27 = v26;
          if (!v26)
          {

            goto LABEL_51;
          }

          v28 = -[NSData isEqual:](v25, "isEqual:", v26);

          if ((v28 & 1) == 0)
          {
LABEL_51:
            if (dword_1008D5FD8 <= 30
              && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
            {
              v32 = CUPrintNSDataHex(self->_selfAuthTagNonConnectable, 100LL, 1LL);
              v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
              v34 = CUPrintNSDataHex(v25, 100LL, 1LL);
              v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
              LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _updateSelfAuthTag]",  30LL,  "SelfAuthTagNC: updated <%@> -> <%@>",  v33,  v35);
            }

            v36 = self->_selfAuthTagNonConnectable;
            self->_selfAuthTagNonConnectable = v25;

            -[CBDaemonServer _bleAdvertiserUpdateWithAuthTagNC](self, "_bleAdvertiserUpdateWithAuthTagNC");
LABEL_64:
            -[CBDaemonServer scheduleUpdateImmediate:](self, "scheduleUpdateImmediate:", 1LL);
LABEL_65:

            goto LABEL_66;
          }
        }

        if (dword_1008D5FD8 > 30
          || dword_1008D5FD8 == -1 && !_LogCategory_Initialize(&dword_1008D5FD8, 30LL))
        {
          goto LABEL_59;
        }

        v31 = CUPrintNSDataHex(v25, 100LL, 1LL);
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v31);
        LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _updateSelfAuthTag]",  30LL,  "SelfAuthTagNC: unchanged: %@",  v30);
      }

      else
      {
        if (dword_1008D5FD8 > 30
          || dword_1008D5FD8 == -1 && !_LogCategory_Initialize(&dword_1008D5FD8, 30LL))
        {
          goto LABEL_59;
        }

        v29 = CUPrintNSError(v23);
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
        LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _updateSelfAuthTag]", 30LL, "SelfAuthTag: failed: %@", v30);
      }

LABEL_59:
      goto LABEL_60;
    }

    v38 = 0LL;
    id v5 = (void *)objc_claimAutoreleasedReturnValue(-[RPIdentity authTagForData:type:error:](v3, "authTagForData:type:error:", v4, 2LL, &v38));
    id v6 = v38;
    if (v5)
    {
      selfAuthTag = self->_selfAuthTag;
      uint64_t v8 = v5;
      uint64_t v9 = selfAuthTag;
      if (v8 == v9)
      {
      }

      else
      {
        unint64_t v10 = v9;
        if (!v9)
        {

          goto LABEL_20;
        }

        __int128 v11 = -[NSData isEqual:](v8, "isEqual:", v9);

        if ((v11 & 1) == 0)
        {
LABEL_20:
          if (dword_1008D5FD8 <= 30
            && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
          {
            uint64_t v16 = CUPrintNSDataHex(self->_selfAuthTag, 100LL, 1LL);
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
            unint64_t v18 = CUPrintNSDataHex(v8, 100LL, 1LL);
            v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
            LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _updateSelfAuthTag]",  30LL,  "SelfAuthTag: updated <%@> -> <%@>",  v17,  v19);
          }

          v20 = v8;
          __int128 v13 = self->_selfAuthTag;
          self->_selfAuthTag = v20;
          uint64_t v15 = 1;
          goto LABEL_31;
        }
      }

      if (dword_1008D5FD8 > 30
        || dword_1008D5FD8 == -1 && !_LogCategory_Initialize(&dword_1008D5FD8, 30LL))
      {
LABEL_28:
        uint64_t v15 = 0;
LABEL_32:

        goto LABEL_33;
      }

      __int128 v14 = CUPrintNSDataHex(v8, 100LL, 1LL);
      __int128 v13 = (NSData *)objc_claimAutoreleasedReturnValue(v14);
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _updateSelfAuthTag]", 30LL, "SelfAuthTag: unchanged: %@", v13);
    }

    else
    {
      if (dword_1008D5FD8 > 30
        || dword_1008D5FD8 == -1 && !_LogCategory_Initialize(&dword_1008D5FD8, 30LL))
      {
        goto LABEL_28;
      }

      __int128 v12 = CUPrintNSError(v6);
      __int128 v13 = (NSData *)objc_claimAutoreleasedReturnValue(v12);
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _updateSelfAuthTag]", 30LL, "SelfAuthTag: failed: %@", v13);
    }

    uint64_t v15 = 0;
LABEL_31:

    goto LABEL_32;
  }

    *((_WORD *)v33 + 111) = v30;
    *((_BYTE *)v33 + 12) = 1;
    *((_BYTE *)v33 + 307) = 0;
    *((_BYTE *)v33 + 409) = self->_advertiseEnableEPA;
    v31 = sub_100404FE8();
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 3321888768LL;
    v35[2] = sub_10002D5A8;
    v35[3] = &unk_10087FA68;
    v35[4] = btSessionPtrConnectable;
    v36 = &off_10087FAE8;
    v37 = (unsigned int *)v33;
    sub_1002CD1E0((uint64_t)v33);
    sub_100405384(v31, v35);
    self->_advertisingStartedConnectable = 1;
    v36 = &off_10087FAE8;
    if (v37) {
      sub_1002CD254(v37);
    }
  }

  sub_1002CD254((unsigned int *)v33);
}
}

            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c");
            v61 = 1;
LABEL_61:
            v60 += 5LL;
            v62 = v63;
            if (v58 == v60)
            {
              v354 = *(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)(v4 + v7 + 32) + 40LL);
              if (v354) {
                v354(v4 + v7 + 9, v407, v411);
              }
LABEL_368:
              sub_1000B1838(v411);
              return;
            }
          }

          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c");
LABEL_57:
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c");
          v63 = v62;
LABEL_58:
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c");
LABEL_59:
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c");
          goto LABEL_60;
        }

        sub_1001EE134( (uint64_t)"BATT_INFO_MSG_BATT_INFO Could not allocate %d bytes",  v374,  v375,  v376,  v377,  v378,  v379,  v380,  5 * v57);
        v381 = (os_log_s *)sub_100086554(0x53u);
        if (!os_log_type_enabled(v381, OS_LOG_TYPE_ERROR)) {
          return;
        }
      }

      else
      {
        sub_1001EE134((uint64_t)"BATT_INFO_MSG_BATT_INFO: count = 0", v233, v234, v235, v236, v237, v238, v239, v401);
        v240 = (os_log_s *)sub_100086554(0x53u);
        if (!os_log_type_enabled(v240, OS_LOG_TYPE_ERROR)) {
          return;
        }
      }

      goto LABEL_528;
    case 6u:
      LOWORD(buf[0]) = 0;
      if ((a3 & 0xFFFE) != 2) {
        LOWORD(buf[0]) = a2[1];
      }
      v66 = qword_1008DAFA0 + v7;
      v67 = *(void (**)(uint64_t, _DWORD *))(*(void *)(qword_1008DAFA0 + v7 + 32) + 48LL);
      if (!v67) {
        return;
      }
      goto LABEL_373;
    case 8u:
      buf[0] = 0;
      if (a3 <= 2)
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c");
      }

      else
      {
        LOBYTE(buf[0]) = *((_BYTE *)a2 + 2);
        if ((_DWORD)a3 != 3)
        {
          BYTE1(buf[0]) = *((_BYTE *)a2 + 3);
          if (a3 > 4)
          {
            BYTE2(buf[0]) = *((_BYTE *)a2 + 4);
            if ((_DWORD)a3 != 5) {
              HIBYTE(buf[0]) = *((_BYTE *)a2 + 5);
            }
LABEL_372:
            v66 = v4 + v7;
            v67 = *(void (**)(uint64_t, _DWORD *))(*(void *)(v4 + v7 + 32) + 56LL);
            if (v67) {
LABEL_373:
            }
              v67(v66 + 9, buf);
            return;
          }

    LOBYTE(v6) = 0;
    return v6;
  }

  if (*(_BYTE *)(v6 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c",  4827,  "(*pBs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(v6 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
LABEL_27:
    *(_BYTE *)(v6 + 15) = 1;
    LOBYTE(v6) = 17;
    goto LABEL_28;
  }

  v19 = *(unsigned __int16 *)(v6 + 12);
  v20 = *(void *)v6;
  *(_WORD *)(v6 + 12) = v19 + 1;
  unint64_t v21 = *(_BYTE *)(v20 + v19);
  if (v21) {
    LOBYTE(v6) = v21;
  }
  else {
    LOBYTE(v6) = 24;
  }
LABEL_28:
  if (v22) {
    v22(a3, v63, *(unsigned __int8 *)(qword_1008DFDB0 + 99), 0LL, 0LL, v6);
  }
  return v6;
}

        sub_100242FAC((uint64_t)v46);
        return 0LL;
    }
  }

      uint64_t v30 = sub_1002075D4(a2 + 400);
      goto LABEL_66;
    }

    goto LABEL_58;
  }

  if (sub_10025D7E8(a1)) {
    *(_BYTE *)(a1 + 173) = 1;
  }
  if (*(_BYTE *)(a1 + 185)) {
    *(_BYTE *)(a3 + 137) = v92;
  }
  v38 = v90;
  v37 = v91;
  if (v90) {
    v39 = v91 == 0;
  }
  else {
    v39 = 1;
  }
  if (!v39 || v83)
  {
    if (v91 == 0xFFFF || v90 == 0xFFFF)
    {
      v90 = 0LL;
      v91 = 0LL;
    }

    else if ((_DWORD)v91 && (_DWORD)v90)
    {
      v40 = v89 != 0;
      *(_BYTE *)(a3 + 120) = 1;
      *(_DWORD *)(a3 + 12_Block_object_dispose(&STACK[0x338], 8) = v38;
      *(_DWORD *)(a3 + 132) = v37;
      *(_BYTE *)(a3 + 136) = v40;
    }
  }

  if (v85)
  {
    v48 = *(unsigned __int8 *)(a1 + 171);
    *(_BYTE *)(a3 + 13_Block_object_dispose(&STACK[0x338], 8) = v48;
    if (!v48 && os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
      sub_10068A5E0();
    }
  }

  else
  {
    *(_BYTE *)(a3 + 13_Block_object_dispose(&STACK[0x338], 8) = 0;
  }

  v49 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 2392LL))(v49))
  {
    value = xpc_dictionary_get_value(a2, "kCBScanOptionZone");
    if (*(_BYTE *)(a1 + 170))
    {
      v51 = value;
      if (value)
      {
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
        {
          applier[0] = _NSConcreteStackBlock;
          applier[1] = 3221225472LL;
          applier[2] = sub_1004F0740;
          applier[3] = &unk_10088A098;
          applier[4] = a3;
          if (!xpc_array_apply(v51, applier))
          {
LABEL_77:
            uint64_t v17 = 3LL;
            goto LABEL_118;
          }
        }
      }
    }
  }

  v52 = *(id *)(a1 + 96);
  v53 = xpc_dictionary_get_value(a2, "kCBScanOptionAppleFilter");
  v54 = v53;
  if (!v53) {
    goto LABEL_112;
  }
  if (xpc_get_type(v53) != (xpc_type_t)&_xpc_type_array) {
    goto LABEL_112;
  }
  v61[0] = _NSConcreteStackBlock;
  v61[1] = 3221225472LL;
  v61[2] = sub_1004F08AC;
  v61[3] = &unk_10089D780;
  v63 = a1;
  v62 = v52;
  v64 = a3;
  v55 = xpc_array_apply(v54, v61);

  if (!v55)
  {
    uint64_t v17 = 3LL;
  }

  else
  {
LABEL_112:
    v56 = *(id *)(a3 + 152);
    v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithSet:](&OBJC_CLASS___NSMutableSet, "setWithSet:", v56));

    if (![v57 count]) {
      [v57 addObject:*(void *)(a1 + 96)];
    }
    v58 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v99 = (const char *)v57;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Setting client list to %@", buf, 0xCu);
    }

    objc_storeStrong((id *)(a3 + 152), v57);
    sub_1004F22F8(a3);
    uint64_t v17 = 0LL;
    unint64_t v10 = v57;
  }

LABEL_118:
  if (v94)
  {
    v95 = v94;
    operator delete(v94);
  }

  return v17;
}

  v41 = 0LL;
LABEL_61:

  return v41;
}

      __int128 v12 = v38 + v39 + v41;
LABEL_61:
      __int128 v11 = v12;
      if (v12 >= a3 || (v18 & 1) != 0) {
        goto LABEL_75;
      }
    }
  }

  unint64_t v18 = 0;
LABEL_75:
  v51 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v51 + 8LL))(v51))
  {
    v52 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v52 + 408LL))(v52))
    {
      v53 = sub_1002E6BF0();
      (*(void (**)(uint64_t, void))(*(void *)v53 + 976LL))(v53, 0LL);
    }
  }

  return v18 & 1;
}

LABEL_66:
}

  if ([(id)v111[5] length])
  {
    v43 = (void *)v111[5];
    v44 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name"));
    v45 = v43;
    v46 = v44;
    if (v45 == v46)
    {
    }

    else
    {
      v47 = v46;
      if ((v45 == 0LL) == (v46 != 0LL))
      {

        goto LABEL_75;
      }

      v48 = [v45 isEqual:v46];

      if ((v48 & 1) == 0)
      {
LABEL_75:
        -[CBDevice setName:](self, "setName:", v111[5]);
        v9 |= 0x80000000000uLL;
        if (!(_DWORD)v13) {
          goto LABEL_78;
        }
        goto LABEL_76;
      }
    }
  }

  if (!(_DWORD)v13) {
    goto LABEL_78;
  }
LABEL_76:
  if ((_DWORD)v13 != -[CBDevice productID](self, "productID"))
  {
    -[CBDevice setProductID:](self, "setProductID:", v13);
    v9 |= 0x80000000000uLL;
  }

    v53 = *((void *)&xmmword_1008DD4E8 + v41);
    *(_DWORD *)(v53 + 16) = v54;
    if (v59 >= v56) {
      break;
    }
    v57 = v59;
  }

  while (v54 < v58);
  if (v59 < v56) {
    goto LABEL_77;
  }
  v102 = v54 == v58;
  v93 = v122;
  v92 = v124;
  if (v102) {
    goto LABEL_80;
  }
LABEL_78:
  if (sub_1000A86F0()
    && (sub_1001EE134((uint64_t)"Number of common services don't match.", v103, v104, v105, v106, v107, v108, v109, v121),
        v110 = (os_log_s *)sub_100086554(0x51u),
        os_log_type_enabled(v110, OS_LOG_TYPE_ERROR)))
  {
    if ((sub_1006580BC(v110, v92) & 1) != 0)
    {
LABEL_81:
      v111 = *(_DWORD *)(*((void *)&xmmword_1008DD4E8 + v41) + 52LL);
      if ((sub_10008D900(a1) & 1) == 0 && (byte_1008DDC50 || (v111 & 1) == 0))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"CL Asking to pair", v112, v113, v114, v115, v116, v117, v118, v121);
          v119 = (os_log_s *)sub_100086554(0x51u);
          if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
          {
            v120 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446210;
            v128 = v120;
            _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        sub_1001D377C(a1, 1);
      }
    }
  }

  else
  {
LABEL_80:
    if (v92) {
      goto LABEL_81;
    }
  }

  sub_10009272C((__int128 *)a1, v93, v123);
  sub_1000B1838(v123);
}

        *((_BYTE *)a1 + 15) = 1;
LABEL_67:
        v36 = 8;
        goto LABEL_76;
      case 4LL:
        v20 = sub_1000B17F4(0x10uLL);
        *(void *)(i + _Block_object_dispose(&STACK[0x338], 8) = v20;
        if (v12 == 3)
        {
          if (!v20) {
            return 106LL;
          }
          if (*((_BYTE *)a1 + 14) != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  998,  "(*ByteStream).__RWFlag == BYTESTREAM_READ");
          }
          if (*((_BYTE *)a1 + 15))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
            unint64_t v21 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v21 != 1) {
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  999,  "(*ByteStream).__RWFlag == BYTESTREAM_READ");
            }
            goto LABEL_73;
          }

          v25 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v25 > 3)
          {
            v26 = *a1;
            char *v20 = bswap32(*(_DWORD *)(*a1 + v25));
            v27 = v25 + 4;
            *((_WORD *)a1 + 6) = v27;
            if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v27 >= 0xC)
            {
              v28 = *(void *)(i + 8);
              v29 = v27;
              uint64_t v30 = v28 + 16;
              v31 = (char *)(v26 + v29);
              v32 = (_BYTE *)(v28 + 4);
              do
              {
                v33 = *v31++;
                *v32++ = v33;
              }

              while ((unint64_t)v32 < v30);
              v34 = *((_WORD *)a1 + 6) + 12;
              goto LABEL_58;
            }

            goto LABEL_74;
          }

          *((_BYTE *)a1 + 15) = 1;
          goto LABEL_73;
        }

        if (!v20) {
          return 106LL;
        }
        if (*((_BYTE *)a1 + 14) != 1) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  1006,  "(*ByteStream).__RWFlag == BYTESTREAM_READ");
        }
        if (*((_BYTE *)a1 + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
          v23 = *((unsigned __int8 *)a1 + 14);
          *((_BYTE *)a1 + 15) = 1;
          if (v23 != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  1007,  "(*ByteStream).__RWFlag == BYTESTREAM_READ");
          }
        }

        else
        {
          v35 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v35 > 3)
          {
            char *v20 = bswap32(*(_DWORD *)(*a1 + v35));
            *((_WORD *)a1 + 6) = v35 + 4;
            if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v35 + 4) > 3)
            {
              *(_DWORD *)(*(void *)(i + 8) + 4LL) = bswap32(*(_DWORD *)(*a1 + (unsigned __int16)(v35 + 4)));
              *((_WORD *)a1 + 6) = v35 + 8;
              if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v35 + 8) > 3)
              {
                *(_DWORD *)(*(void *)(i + 8) + 8LL) = bswap32(*(_DWORD *)(*a1 + (unsigned __int16)(v35 + 8)));
                *((_WORD *)a1 + 6) = v35 + 12;
                if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v35 + 12) >= 4)
                {
                  *(_DWORD *)(*(void *)(i + 8) + 12LL) = bswap32(*(_DWORD *)(*a1 + (unsigned __int16)(v35 + 12)));
                  v34 = v35 + 16;
LABEL_58:
                  *((_WORD *)a1 + 6) = v34;
                  goto LABEL_75;
                }

        v134 = v24;
        v135 = v25;
        v136 = v26;
        v137 = v28;
        v138 = 0;
        v139 = v33;
        v140 = v35;
        v141 = v69;
        v142 = v70;
        v143 = 0;
        v144 = 0;
        v145 = v112;
        sub_1000AED78(&v134);
        if (!v112) {
          return;
        }
LABEL_77:
        sub_1000B1838(v112);
        return;
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Could not allocate memory for the LE periodic advertising report event",  v114,  v115,  v116,  v117,  v118,  v119,  v120,  v131);
        v121 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    v112 = 0LL;
    goto LABEL_66;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid periodic advertising report event packet size : %d, expecting at least %d",  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v4);
    __int128 v12 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_56:
    }
      sub_100657858();
  }

    v91 = sub_1001DBEB0(v72, v35, v31);
    if (!(_DWORD)v91) {
      return;
    }
    v92 = v91;
    sub_1001EE134((uint64_t)"Save received packet failed in Receive_UIH %! (%d)", v93, v94, v95, v96, v97, v98, v99, v92);
    v100 = (os_log_s *)sub_100086554(0x32u);
    if (!os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_39:
    sub_100657858();
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"%! (%d)", v5, v6, v7, v8, v9, v10, v11, 917LL);
    __int128 v12 = (os_log_s *)sub_100086554(0x32u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_35:
    }
      sub_100657858();
  }

  [*(id *)(a1 + 376) removeObjectForKey:v11];
  sub_100390F24(a1);
LABEL_111:
}

          a1 = (int64x2_t *)v77;
          sub_100422B6C(v77, a2, 0LL, 3, 901LL, 0LL, 0);
          v27 = 1;
          LOBYTE(a5) = v76;
          a4 = v75;
        }

  sub_100242CD8(&v51);
  return v31;
}

          if (v13 < 0x14) {
            v44 = 5;
          }
          else {
            v44 = 6;
          }
          v45 = sub_1002E6E00();
          if ((*(unsigned int (**)(uint64_t))(*(void *)v45 + 320LL))(v45))
          {
            v46 = sub_1002E6E00();
            v44 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 328LL))(v46);
          }

          v47 = sub_1004AFE74(a1, v21, v44);
          sub_1004B028C(v47, v21, 1);
LABEL_72:
          sub_100242CD8(&v48);
          return;
        }

        if (!v34) {
          goto LABEL_66;
        }
        if (*(_BYTE *)(a1 + 852)) {
          v43 = "default";
        }
        else {
          v43 = "non-default";
        }
        *(_DWORD *)buf = 136315138;
        v50 = v43;
        v35 = "Warning: Enhanced diversity antenna pair set to %s config at stream start based on defaults write";
      }

      else
      {
        v38 = sub_1002E8D54();
        v39 = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 248LL))(v38);
        v40 = v39;
        if (v39 >= 2 && v39 != *(_DWORD *)(a1 + 856))
        {
          v41 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Device orientation outdated, updating orientation first",  buf,  2u);
          }

          *(_DWORD *)(a1 + 856) = v40;
        }

        sub_1004B0108(a1);
        v33 = qword_1008F7570;
        if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_66;
        }
        if (*(_BYTE *)(a1 + 852)) {
          v42 = "default";
        }
        else {
          v42 = "non-default";
        }
        *(_DWORD *)buf = 136315138;
        v50 = v42;
        v35 = "Enhanced diversity antenna pair set to %s config at stream start based on orientation";
      }

      v36 = (os_log_s *)v33;
      v37 = 12;
      goto LABEL_65;
    }

    uint64_t v15 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Stack is not ready, cannot update diversity settings",  buf,  2u);
    }
  }
}

void sub_100011B70(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    uint64_t v3 = *(void **)(v2 + 512);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_100011BE0;
    v5[3] = &unk_10087F180;
    v5[4] = v2;
    id v4 = v3;
    [v4 getCloudPairedDevicesWithCompletionHandler:v5];
  }

void sub_100011BE0(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  if (v5)
  {
    if (dword_1008D5FD8 <= 90
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
    {
      uint64_t v6 = CUPrintNSError(v5);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _updateUserControllerCloudDevices]_block_invoke_2",  90LL,  "Error fetching cloud paired device metadata due to %@",  v7);
    }
  }

  else
  {
    [*(id *)(a1 + 32) _userControllerCloudUpdateWithDevices:v8];
    [*(id *)(a1 + 32) _userControllerUploadLocalControllerInfo];
  }
}

void sub_100011D38(_Unwind_Exception *a1)
{
}

void *sub_100011E88(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[53])
  {
    [result _bleAdvertiserAddressChanged:0];
    return [*(id *)(a1 + 40) _updateSelfAuthTag];
  }

  return result;
}

LABEL_14:
  __int128 v13 = (void *)objc_claimAutoreleasedReturnValue(-[CBAdvertiserDaemon advertiserArray](v4, "advertiserArray"));
  if (v13)
  {

LABEL_16:
    __int128 v14 = 0;
    goto LABEL_19;
  }

  if (!-[NSMutableArray count](self->_bleAdvertiserArray, "count")) {
    goto LABEL_16;
  }
  -[CBAdvertiserDaemon setAdvertiserArray:](v4, "setAdvertiserArray:", self->_bleAdvertiserArray);
  __int128 v14 = 1;
LABEL_19:
  uint64_t v15 = -[CBDaemonServer _bleAdvertiserUpdateSpatialInteraction](self, "_bleAdvertiserUpdateSpatialInteraction");
  uint64_t v16 = -[CBDaemonServer _bleAdvertiserUpdateWithAuthTagNC](self, "_bleAdvertiserUpdateWithAuthTagNC");
  if (v5)
  {
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( -[CBStackAddressMonitor nonConnectableAddressData]( self->_addressMonitor,  "nonConnectableAddressData"));
    unint64_t v18 = v17 == 0LL;

    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472LL;
    v19[2] = sub_1000121F4;
    v19[3] = &unk_10087F1F8;
    v20 = v4;
    unint64_t v21 = self;
    unint64_t v22 = v18;
    -[CBAdvertiserDaemon activateWithCompletion:](v20, "activateWithCompletion:", v19);
  }

  else if (v14 + v15 != (int)(v16 << 31) >> 31 {
         && dword_1008D5FD8 <= 30
  }
         && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
  {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserEnsureStarted]",  30LL,  "BLE advertiser updated: %@",  v4);
  }
}
  }

  else
  {
    LOBYTE(v4) = 0;
  }

  return (char)v4;
}

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v29, 8);
}

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v34, 8);
}

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v34, 8);
}

  return v2;
}

  __int128 v14 = *(char **)(v4 + 168);
  if (v14)
  {
    sub_1000A9064(v14);
    *(void *)(v4 + 16_Block_object_dispose(&STACK[0x338], 8) = 0LL;
  }

  if (*(_DWORD *)v4)
  {
    sub_1000A85A0();
    sub_10011E7EC(1211LL);
    sub_1000A8688();
LABEL_18:
    if (dword_1008DE0E8)
    {
      *(_WORD *)(*(void *)(a1 + 144) + 24LL) = 0;
      *(void *)(a1 + 136) = 0LL;
      if (sub_1000A961C(a1))
      {
        j__pthread_mutex_lock(v6);
        if (!v5[134])
        {
          if (byte_1008DE068 == 1) {
            sub_1000BAAF0("[IsochPipeReadCB] -- btdev->nbrOfOutstandingIsochReads < 1 -- need to restart");
          }
          void *v5 = 0;
        }

        j__pthread_mutex_unlock(v6);
      }
    }

    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"IsocReadRequestCB btdev->open is false", v15, v16, v17, v18, v19, v20, v21, v23);
    unint64_t v22 = (os_log_s *)sub_100086554(0x3Au);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
}

      v3 += 144LL;
      --v2;
    }

    while (v2);
  }

  return 0LL;
}

  unint64_t v10 = off_100883B80[v7];
  __int128 v11 = strlen(v10);
  return sub_1000EF214(a1, 2, v10, v11, 0);
}

      uint64_t v6 = v11 + v12;
      if (v6 >= v5) {
        goto LABEL_17;
      }
    }
  }

  uint64_t result = 0LL;
  uint64_t v7 = 0;
LABEL_17:
  *(_BYTE *)(v4 + 60) = v7 & 1;
  *(_BYTE *)(a1 + 57) = (v7 & 2) != 0;
  return result;
}

    sub_100657858();
LABEL_15:
    v31 = 8;
LABEL_20:
    sub_10011DC18((__int128 *)a1, v31, (char *)v6);
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Connection is invalid", v40, v41, v42, v43, v44, v45, v46, v90);
    v47 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

    sub_1001967F4("aaaa", 3u, 0LL, (_BYTE *)a1, a4, v11, v12, v13, 0LL);
    return;
  }

  uint64_t v15 = a2;
  if ((a2 & 0x1010101) != 1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"%! - rejecting connect attempt to invalid PSM %d",  v26,  v27,  v28,  v29,  v11,  v12,  v13,  407LL);
      uint64_t v30 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_14;
  }

  uint64_t v16 = sub_10010C9D4(a1);
  if ((_DWORD)v16)
  {
    uint64_t v17 = v16;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"OI_LP_ConnectionAdded failed (%!), rejecting connection",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v17);
      v25 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    v28 = sub_10017AB4C((unsigned int *)a1);
    sub_10017B47C(*(unsigned __int16 **)(v28 + 112));
    return;
  }

  v38 = *(unsigned __int16 *)a2;
  v39 = sub_1000B17F4(0x18uLL);
  if (v39)
  {
    v40 = (uint64_t)v39;
    *v39 = *(_WORD *)(a1 + 4);
    v39[1] = (v38 >> 1) & 0x3F;
    *((_BYTE *)v39 + 4) = v38 >> 14;
    if (v38 >> 14 == 1)
    {
      v41 = a2[2] | (a2[4] << 8);
      v42 = -4;
    }

    else
    {
      v41 = 0;
      v42 = -2;
    }

    v59 = v42 + a3;
    v39[3] = v41;
    v39[8] = v59;
    v60 = sub_1000B17F4(v59);
    *(void *)(v40 + _Block_object_dispose(&STACK[0x338], 8) = v60;
    if (v60)
    {
      memmove(v60, &a2[a3 - *(unsigned __int16 *)(v40 + 16)], *(unsigned __int16 *)(v40 + 16));
      if (!*(_BYTE *)(*(void *)(sub_10017AB4C((unsigned int *)a1) + 112) + 3LL))
      {
        sub_10017F7AC((unsigned int *)a1, v38, v40, a4, a5);
        return;
      }

      if (*(_BYTE *)(*(void *)(sub_10017AB4C((unsigned int *)a1) + 112) + 3LL) == 1)
      {
        sub_100180368((unsigned int *)a1, v38, v40, a4, a5);
        return;
      }

      if (*(_BYTE *)(*(void *)(sub_10017AB4C((unsigned int *)a1) + 112) + 3LL) == 2)
      {
        sub_100180890((unsigned int *)a1, v38, v40, a4, a5);
        return;
      }

      goto LABEL_49;
    }

    sub_1000B1838((void *)v40);
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Could not allocate enough memory for incoming frame.",  v61,  v62,  v63,  v64,  v65,  v66,  v67,  v71);
      v68 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
        goto LABEL_44;
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Could not allocate enough memory for incoming frame.",  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v71);
    v58 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
LABEL_44:
    }
      sub_100657858();
  }

  if (*(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 144LL)
    && *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 18LL) == (_DWORD)v10)
  {
    uint64_t v16 = (a2 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v16
      || v16 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
    {
      uint64_t v17 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      unint64_t v18 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      if (v17 <= v16)
      {
        if (v16 - v18 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL)) {
          goto LABEL_31;
        }
      }

      else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
                + (_BYTE)v18) & 0x3Fu) < v16)
      }
      {
        goto LABEL_31;
      }
    }

    if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL))
      && *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 151LL)
      && *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 144LL) == 1)
    {
      sub_100182D14(a1, a3);
      sub_10018332C(a1);
      sub_100181EEC((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
      sub_100183428(a1, a3, a4, a5);
      v19 = *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 152LL);
      *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL) = v19;
      v20 = sub_100182EE0((uint64_t)a1);
      if ((_DWORD)v20)
      {
        unint64_t v21 = v20;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to send a REJ %!", v22, v23, v24, v25, v26, v27, v28, v21);
          v29 = (os_log_s *)sub_100086554(0x2Fu);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      uint64_t v15 = 0LL;
      *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 3LL) = 1;
      return v15;
    }
  }

  id v5 = *(unsigned __int8 *)(v2 + 16);
  sub_1001EC0C4(*(void *)v2);
  if (v5) {
    sub_1001EC0C4(*(void *)(v2 + 8));
  }
}

  __int128 v11 = 0;
  *((_BYTE *)a1 + 15) = 1;
LABEL_15:
  v130 = v9 + a3;
  if (a3 <= 3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Bogus length in configuration request - must be corrupt packet",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v125);
      v20 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        sub_10065C798();
      }
    }

    __int128 v12 = 411LL;
  }

  else
  {
    __int128 v12 = 0LL;
  }

  v128 = a4;
  v126 = a2;
  unint64_t v21 = *((unsigned __int16 *)a1 + 6);
  unint64_t v22 = v130;
  if (v130 > v21)
  {
    v129 = 0;
    v23 = 0LL;
    LOBYTE(v24) = 0;
    __len = 0;
    while (1)
    {
      if (*((_BYTE *)a1 + 15)) {
        goto LABEL_133;
      }
      if (*((_BYTE *)a1 + 14) != 1) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1179,  "(*pBs).__RWFlag == BYTESTREAM_READ");
      }
      v25 = *((unsigned __int16 *)a1 + 5);
      if (v25 <= v21) {
        break;
      }
      v26 = *a1;
      v27 = v21 + 1LL;
      *((_WORD *)a1 + 6) = v27;
      v28 = *(_BYTE *)(v26 + v21);
      if (v25 <= v27)
      {
        LOBYTE(v24) = v28;
        goto LABEL_30;
      }

      v29 = *a1;
      *((_WORD *)a1 + 6) = v21 + 2;
      __len = *(unsigned __int8 *)(v29 + v27);
      uint64_t v30 = 1;
LABEL_31:
      uint64_t v24 = v28 & 0x7F;
      switch(v28 & 0x7F)
      {
        case 1:
          if (*((_BYTE *)a1 + 14) != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1190,  "(*pBs).__RWFlag == BYTESTREAM_READ");
          }
          if ((v30 & 1) != 0)
          {
            v31 = *((unsigned __int16 *)a1 + 6);
            if (*((unsigned __int16 *)a1 + 5) - (int)v31 >= 2)
            {
              WORD2(v132[0]) = *(_WORD *)(*a1 + v31);
              *((_WORD *)a1 + 6) = v31 + 2;
              goto LABEL_90;
            }
          }

          else
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }

          *((_BYTE *)a1 + 15) = 1;
LABEL_90:
          LODWORD(v132[0]) |= 1u;
          goto LABEL_113;
        case 2:
          LODWORD(v132[0]) |= 2u;
          if (*((_BYTE *)a1 + 14) != 1) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1194,  "(*pBs).__RWFlag == BYTESTREAM_READ");
          }
          if ((v30 & 1) == 0) {
            goto LABEL_111;
          }
          v44 = *((unsigned __int16 *)a1 + 6);
          WORD3(v132[0]) = *(_WORD *)(*a1 + v44);
          goto LABEL_81;
        case 3:
          LODWORD(v132[0]) |= 4u;
          if ((v30 & 1) == 0)
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_83:
            *((_BYTE *)a1 + 15) = 1;
            if (*((_BYTE *)a1 + 14) != 1) {
LABEL_175:
            }
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1199,  "(*pBs).__RWFlag == BYTESTREAM_READ");
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
            goto LABEL_85;
          }

          v45 = *((unsigned __int16 *)a1 + 6);
          v46 = v45 + 1;
          *((_WORD *)a1 + 6) = v45 + 1;
          if (*((_BYTE *)a1 + 14) != 1) {
            goto LABEL_175;
          }
          v47 = *((unsigned __int16 *)a1 + 5);
          if (v47 > v46)
          {
            v48 = *a1;
            v49 = v45 + 2;
            *((_WORD *)a1 + 6) = v49;
            BYTE8(v132[0]) = *(_BYTE *)(v48 + v46);
            v50 = v47 - v49;
            goto LABEL_86;
          }

      sub_1001A6168(v19, &v38, 5uLL, 0LL);
LABEL_15:
      sub_1001A6960(i);
    }
  }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Failed to write value to attribute handle 0x%04x with result %d",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  *(unsigned __int16 *)(i + 32));
      uint64_t v24 = (os_log_s *)sub_100086554(0x44u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    v25 = *(_WORD *)(i + 32);
    v26 = **(__int128 ***)(i + 24);
    v32[0] = 1;
    v32[1] = v6;
    v33 = v25;
    v34 = a2;
    v27 = v32;
    goto LABEL_18;
  }

    unint64_t v22 = *(const void **)(a6 + 80);
    v23 = *(unsigned __int16 *)(a6 + 88);
    if (v22)
    {
      memmove(__dst, v22, 24 * v23);
      sub_1000B1838(*(void **)(a6 + 80));
      LOWORD(v23) = *(_WORD *)(a6 + 88);
    }

    *(void *)(a6 + 80) = __dst;
    *(_WORD *)(a6 + 8_Block_object_dispose(&STACK[0x338], 8) = v23 + a4;
    if (v12) {
      v32 = v12;
    }
    else {
      v32 = -1;
    }
    if (v37 > v32)
    {
      v38[0] = 16;
      *(_WORD *)&v38[1] = v32 + 1;
      *(_WORD *)&v38[3] = v37;
      v39 = 0;
      *(_OWORD *)&v38[5] = xmmword_1006BD89C;
      uint64_t v7 = sub_1001A2D24(*(void *)a6, (uint64_t)sub_1001C04DC, (int *)v38, a6);
      if (!(_DWORD)v7) {
        return;
      }
      goto LABEL_26;
    }
  }

  uint64_t v7 = 0LL;
LABEL_26:
  v34 = *(void (**)(uint64_t, void, void, uint64_t))(a6 + 16);
  v33 = *(void *)(a6 + 24);
  *(void *)(a6 + 16) = 0LL;
  v34(v7, *(void *)(a6 + 80), *(unsigned __int16 *)(a6 + 88), v33);
  v35 = *(void **)(a6 + 80);
  if (v35) {
    sub_1000B1838(v35);
  }
  *(void *)(a6 + 80) = 0LL;
  *(_WORD *)(a6 + 8_Block_object_dispose(&STACK[0x338], 8) = 0;
}

      uint64_t v9 = 0;
      goto LABEL_15;
    }
  }

  *((_BYTE *)a2 + 15) = 1;
  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  id v8 = *((unsigned __int8 *)a2 + 15);
  if (!*((_BYTE *)a2 + 15)) {
    goto LABEL_14;
  }
  id v4 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read start stream", v10, v11, v12, v13, v14, v15, v16, v19);
    uint64_t v17 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v4;
}

  id v8 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read Bonding Status", v9, v10, v11, v12, v13, v14, v15, v18);
    uint64_t v16 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v8;
}

  unint64_t v10 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read Disconnect", v11, v12, v13, v14, v15, v16, v17, v20);
    unint64_t v18 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v10;
}

  uint64_t result = 0LL;
  *a1 = v8;
  return result;
}

    unint64_t v22 = 1LL;
    goto LABEL_15;
  }

  uint64_t v24 = *((unsigned __int8 *)a3 + 23);
  if ((v24 & 0x80u) != 0LL) {
    uint64_t v24 = a3[1];
  }
  if (!v24)
  {
    unint64_t v22 = 5LL;
    goto LABEL_15;
  }

  if (a5 == 4)
  {
    sub_100494958(a2, (uint64_t)__p);
    v25 = __p[23];
    v26 = __p[23];
    v27 = *(_BYTE **)__p;
    if (__p[23] < 0) {
      v25 = *(void *)&__p[8];
    }
    else {
      v27 = __p;
    }
    if (v25 >= 0x1F) {
      v25 = 31LL;
    }
    if (!v25) {
      goto LABEL_60;
    }
    v28 = &v27[v25];
    v29 = v27;
    uint64_t v30 = v28;
    do
    {
      if (*v29 == 99)
      {
        v31 = &_mh_execute_header.magic + 1;
        while (v31 != 31)
        {
          if (&v29[v31] == v28) {
            goto LABEL_37;
          }
          v32 = v29[v31];
          v33 = aComAppleSharin_0[v31++];
          if (v32 != v33) {
            goto LABEL_28;
          }
        }

        uint64_t v30 = v29;
      }

    __int128 v11 = 1LL;
    goto LABEL_15;
  }

  __int128 v13 = v7[5];
  __int128 v14 = a1[21];
  uint64_t v15 = a1[22];
  if (v14 != v15)
  {
    uint64_t v16 = a3[23];
    unint64_t v18 = *(char **)a3;
    uint64_t v17 = *((void *)a3 + 1);
    if ((v16 & 0x80u) == 0LL) {
      v19 = a3[23];
    }
    else {
      v19 = *((void *)a3 + 1);
    }
    do
    {
      if (*(void *)v14 == a2)
      {
        v20 = *(unsigned __int8 *)(v14 + 31);
        unint64_t v21 = (char)v20;
        if ((v20 & 0x80u) != 0LL) {
          v20 = *(void *)(v14 + 16);
        }
        if (v19 == v20)
        {
          if (v21 >= 0) {
            unint64_t v22 = (unsigned __int8 *)(v14 + 8);
          }
          else {
            unint64_t v22 = *(unsigned __int8 **)(v14 + 8);
          }
          if ((v16 & 0x80) == 0)
          {
            if ((_DWORD)v16)
            {
              for (i = 0LL; i != v16; ++i)
              {
              }

              v40 = (os_log_s *)qword_1008F75C8;
              if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_DEFAULT))
              {
LABEL_64:
                sub_100494958(a2, (uint64_t)__p);
                if (v50 >= 0) {
                  v41 = __p;
                }
                else {
                  v41 = (void **)__p[0];
                }
                *(_DWORD *)buf = 136446466;
                v53 = a3;
                v54 = 2082;
                v55 = v41;
                _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Unregistering pending endpoint %{public}s on session %{public}s",  buf,  0x16u);
                if (v50 < 0) {
                  operator delete(__p[0]);
                }
                uint64_t v15 = a1[22];
              }
            }

            else
            {
              v40 = (os_log_s *)qword_1008F75C8;
              if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_64;
              }
            }

            goto LABEL_70;
          }

          if (!memcmp(v18, v22, v17))
          {
            v40 = (os_log_s *)qword_1008F75C8;
            if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_DEFAULT))
            {
              a3 = *(char **)a3;
              goto LABEL_64;
            }

  sub_100255D4C(a1, 1);
  uint64_t v7 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "AudioSendThread stopping", buf, 2u);
  }

  if (!(a2 | a4))
  {
    v28[0] = 0LL;
    v28[1] = 0LL;
    sub_100242F28((uint64_t)v28, (uint64_t)(a1 + 20));
    v26 = a1[44];
    if (v26) {
      sub_1004579D0(v26);
    }
    sub_100242F54((uint64_t)v28);
    sub_100242FAC((uint64_t)v28);
  }

  return (*(uint64_t (**)(void *))(*a1 + 184LL))(a1);
}

      LODWORD(__p[0]) = 2;
      v25[0] = __p;
      id v8 = sub_1002BBE00(&v27, (int *)__p, (uint64_t)&unk_1006C2518, (_DWORD **)v25);
      goto LABEL_29;
  }

  return 100LL;
}
}

  unint64_t v21 = sub_1002E6E00();
  if ((v45.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unint64_t v22 = &v45;
  }
  else {
    unint64_t v22 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  sub_10002418C(buf, (char *)v22);
  sub_10002418C(__p, "protectWLAN");
  v23 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v21 + 128LL))(v21, buf, __p, &v48);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0)
  {
    operator delete(*(void **)buf);
    if (!v23) {
      goto LABEL_28;
    }
  }

  else if (!v23)
  {
    goto LABEL_28;
  }

  uint64_t v24 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v25 = &v45;
    if ((v45.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      v25 = (std::string *)v45.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = v25;
    v51 = 1024;
    v52 = v48;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "%s protectWLAN parameter set to %d",  buf,  0x12u);
  }

  unint64_t v18 = 1;
LABEL_28:
  v26 = sub_1002E6E00();
  if ((v45.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    v27 = &v45;
  }
  else {
    v27 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  sub_10002418C(buf, (char *)v27);
  sub_10002418C(__p, "protectLEA");
  v28 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v26 + 128LL))(v26, buf, __p, &v47);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0)
  {
    operator delete(*(void **)buf);
    if (!v28) {
      goto LABEL_42;
    }
  }

  else if (!v28)
  {
    goto LABEL_42;
  }

  v29 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v30 = &v45;
    if ((v45.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v30 = (std::string *)v45.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = v30;
    v51 = 1024;
    v52 = v47;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%s protectLEA parameter set to %d", buf, 0x12u);
  }

  unint64_t v18 = 1;
LABEL_42:
  v31 = sub_1002E6E00();
  if ((v45.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    v32 = &v45;
  }
  else {
    v32 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  sub_10002418C(buf, (char *)v32);
  sub_10002418C(__p, "protectHFPA2DP");
  v33 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v31 + 128LL))(v31, buf, __p, &v47);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0)
  {
    operator delete(*(void **)buf);
    if (!v33) {
      goto LABEL_56;
    }
  }

  else if (!v33)
  {
    goto LABEL_56;
  }

  v34 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v35 = &v45;
    if ((v45.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      v35 = (std::string *)v45.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = v35;
    v51 = 1024;
    v52 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "%s protectHFPA2DP parameter set to %d",  buf,  0x12u);
  }

  unint64_t v18 = 1;
LABEL_56:
  v36 = sub_1002E6E00();
  if ((v45.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    v37 = &v45;
  }
  else {
    v37 = (std::string *)v45.__r_.__value_.__r.__words[0];
  }
  sub_10002418C(buf, (char *)v37);
  sub_10002418C(__p, "percentageWithCriticalPriority");
  v38 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v36 + 128LL))(v36, buf, __p, &v46);
  if (v44 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0)
  {
    operator delete(*(void **)buf);
    if (v38)
    {
LABEL_63:
      v39 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        v40 = &v45;
        if ((v45.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          v40 = (std::string *)v45.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&buf[4] = v40;
        v51 = 1024;
        v52 = v46;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "%s percentageWithCriticalPriority parameter set to %d",  buf,  0x12u);
      }

      goto LABEL_69;
    }
  }

  else if (v38)
  {
    goto LABEL_63;
  }

  if (v18)
  {
LABEL_69:
    *a3 = v49;
    *a4 = v48;
    *a5 = v47;
    *a6 = v15;
    *a7 = v46;
    v41 = 1LL;
    goto LABEL_71;
  }

  v41 = 0LL;
LABEL_71:
  return v41;
}

  id v5 = sub_1002E6E9C();
  (*(void (**)(__int128 *__return_ptr))(*(void *)v5 + 16LL))(&buf);
  if ((v20 & 0x80000000) == 0)
  {
LABEL_24:
    byte_1008EFFA8 = 0;
    goto LABEL_26;
  }

  if (*((void *)&buf + 1) != 2LL)
  {
    operator delete((void *)buf);
    goto LABEL_26;
  }

  uint64_t v6 = *(unsigned __int16 *)buf;
  operator delete((void *)buf);
  if (v6 == 12355) {
    goto LABEL_24;
  }
LABEL_26:
  uint64_t v7 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFFA8) {
      id v8 = "enabled";
    }
    else {
      id v8 = "disabled";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "BT chip support for LowPowerCore Scan : %s",  (uint8_t *)&buf,  0xCu);
  }

  unint64_t v18 = 0;
  uint64_t v9 = sub_1002E6E00();
  sub_10002418C(&buf, "LowPowerCoreScan");
  sub_10002418C(__p, "DisableLowPowerCoreScan");
  unint64_t v10 = (*(uint64_t (**)(uint64_t, __int128 *, void **, unsigned __int8 *))(*(void *)v9 + 72LL))( v9,  &buf,  __p,  &v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (v20 < 0)
  {
    operator delete((void *)buf);
    if (!v10) {
      goto LABEL_46;
    }
  }

  else if (!v10)
  {
    goto LABEL_46;
  }

  __int128 v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Overriding Disabling LowPowerCore Scan=%d",  (uint8_t *)&buf,  8u);
  }

  if (byte_1008EFFA8) {
    __int128 v12 = v18 == 0;
  }
  else {
    __int128 v12 = 0;
  }
  __int128 v13 = v12;
  byte_1008EFFA8 = v13;
LABEL_46:
  __int128 v14 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFFA8) {
      uint64_t v15 = "enabled";
    }
    else {
      uint64_t v15 = "disabled";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "support for new LowPowerCore scan is %s",  (uint8_t *)&buf,  0xCu);
  }

  if ((*(unsigned int (**)(uint64_t))(*(void *)v1 + 424LL))(v1))
  {
    uint64_t v6 = sub_1002E6E9C();
    (*(void (**)(__int128 *__return_ptr))(*(void *)v6 + 16LL))(&buf);
    if ((v21 & 0x80000000) == 0)
    {
LABEL_21:
      byte_1008EFFD8 = 0;
      goto LABEL_23;
    }

    if (*((void *)&buf + 1) != 2LL)
    {
      operator delete((void *)buf);
      goto LABEL_23;
    }

    uint64_t v7 = *(unsigned __int16 *)buf;
    operator delete((void *)buf);
    if (v7 == 12355) {
      goto LABEL_21;
    }
  }

    LODWORD(v6) = 0;
    goto LABEL_15;
  }

  id v4 = v3;
  if (!CFDictionaryContainsKey(v3, @"FamilyCode")) {
    goto LABEL_14;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(v4, @"FamilyCode");
  uint64_t v6 = Value;
  if (Value)
  {
    uint64_t v7 = CFGetTypeID(Value);
    if (v7 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      id v8 = CFNumberGetValue(v6, kCFNumberIntType, &valuePtr);
      LODWORD(v6) = v8 != 0;
      if (v8)
      {
        if (valuePtr == -536723452) {
          uint64_t v9 = 2;
        }
        else {
          uint64_t v9 = 1;
        }
        *a2 = v9;
      }

      goto LABEL_15;
    }

    goto LABEL_14;
  }

    uint64_t v17 = 0;
    unint64_t v18 = 1;
    if (!v20) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (a3) {
    *a3 = 0LL;
  }
  id v4 = *v9;
LABEL_53:
  sub_100242FAC((uint64_t)v29);
  return v4;
}

  sub_100242FAC((uint64_t)v11);
  return v6;
}

    sub_100242FAC((uint64_t)v20);
  }

    v4 += 16LL;
  }

  unint64_t v10 = (void **)&v12;
  sub_100438558(&v10);
}

      __int128 v12 = 0LL;
      goto LABEL_15;
    }

    id v4 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "Name requests can't be paused. FULL STEAM AHEAD!",  buf,  2u);
    }
  }

  id v5 = *(void *)(a1 + 344);
  if (v5 || *(void *)(a1 + 368) == *(void *)(a1 + 376))
  {
    uint64_t v6 = qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = "Scan in progress";
      if (!v5) {
        uint64_t v7 = "No scans queued";
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = v7;
      id v8 = "%{public}s - returning";
      uint64_t v9 = (os_log_s *)v6;
      unint64_t v10 = 12;
      goto LABEL_13;
    }

    goto LABEL_14;
  }

  v36[0] = 0LL;
  v36[1] = 0LL;
  sub_100242F28((uint64_t)v36, a1 + 48);
  __int128 v12 = *(_BYTE *)(a1 + 112) != 0;
  if (*(_BYTE *)(a1 + 112))
  {
    uint64_t v17 = *(uint64_t **)(a1 + 368);
    while (1)
    {
      v39 = *v17;
      sub_100452954(&v40, v17 + 1);
      sub_100456F30((void *)(*(void *)(a1 + 368) + 24LL), *(void **)(a1 + 376), *(void **)(a1 + 368));
      v19 = v18;
      v20 = *(void *)(a1 + 376);
      if (v20 != v18)
      {
        do
        {
          unint64_t v21 = v20 - 24;
          sub_100032BD4(v20 - 16);
          v20 = v21;
        }

        while (v21 != v19);
      }

      *(void *)(a1 + 376) = v19;
      if (v39)
      {
        *(void *)(a1 + 344) = v39;
        sub_100452954((void *)(a1 + 352), &v40);
      }

      else if (v40)
      {
        if (qword_1008D61A8 != -1) {
          dispatch_once(&qword_1008D61A8, &stru_100899560);
        }
        unint64_t v22 = (void *)qword_1008D61A0;
        v23 = (std::__shared_weak_count *)v41;
        v35[0] = v40;
        v35[1] = v41;
        if (v41)
        {
          uint64_t v24 = (unint64_t *)(v41 + 8);
          do
            v25 = __ldxr(v24);
          while (__stxr(v25 + 1, v24));
        }

        v26 = sub_100452A84(a1, v35);
        v27 = sub_100496954(v22, v26);
        if (v23)
        {
          p_shared_owners = (unint64_t *)&v23->__shared_owners_;
          do
            v29 = __ldaxr(p_shared_owners);
          while (__stlxr(v29 - 1, p_shared_owners));
          if (!v29)
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
        }

        uint64_t v30 = (os_log_s *)qword_1008F7590;
        if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR))
        {
          if (v27)
          {
            sub_100494958(v27, (uint64_t)buf);
            v31 = buf;
            if (v43 < 0) {
              v31 = *(_BYTE **)buf;
            }
            *(_DWORD *)v44 = 136446210;
            v45 = v31;
            _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Had no object for the scan from %{public}s",  v44,  0xCu);
            if (v43 < 0) {
              operator delete(*(void **)buf);
            }
          }

          else
          {
            sub_10068056C(v44, &v45, v30);
          }
        }

        (*(void (**)(uint64_t))(*(void *)v40 + 16LL))(v40);
        (*(void (**)(uint64_t))(*(void *)v40 + 24LL))(v40);
      }

      if (*(void *)(a1 + 344)) {
        break;
      }
      uint64_t v17 = *(uint64_t **)(a1 + 368);
    }

    v33 = sub_100404EB8();
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472LL;
    v34[2] = sub_100454618;
    v34[3] = &unk_10087EB20;
    v34[4] = a1;
    sub_100405384(v33, v34);
LABEL_53:
    sub_100242F54((uint64_t)v36);
    sub_100242F54((uint64_t)v37);
  }

  else
  {
    v32 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "Stack wasn't started - returning", buf, 2u);
    }
  }

  sub_100242FAC((uint64_t)v36);
LABEL_15:
  sub_100242FAC((uint64_t)v37);
  sub_100242FAC((uint64_t)v38);
  __int128 v13 = (std::__shared_weak_count *)v41;
  if (v41)
  {
    __int128 v14 = (unint64_t *)(v41 + 8);
    do
      uint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  return v12;
}
    }
  }

  return 1LL;
}

  uint64_t v9 = *(_DWORD *)(*(void *)(a2 + 8) + 168LL);
  v63 = 0LL;
  *(_OWORD *)v61 = 0u;
  v62 = 0u;
  v60 = 0u;
  memset(v59, 0, sizeof(v59));
  v49 = v9;
  sub_1005E0630(a1, v9, (uint64_t)v59);
  if (!BYTE8(v59[0]))
  {
    unint64_t v18 = *(void *)(a2 + 8) + 280LL;
    goto LABEL_65;
  }

  unint64_t v10 = *(void *)(a2 + 8);
  memset((char *)&v58[1] + 12, 0, 48);
  *(_OWORD *)((char *)&v58[4] + _Block_object_dispose(&STACK[0x338], 8) = 0u;
  __int128 v11 = *(_OWORD *)(v10 + 296);
  v57 = *(_OWORD *)(v10 + 280);
  v58[0] = v11;
  *(_OWORD *)((char *)v58 + 12) = *(_OWORD *)(v10 + 308);
  memset(&v58[2], 0, 24);
  sub_10060E68C( &v58[2],  *(void *)(v10 + 328),  *(void *)(v10 + 336),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v10 + 336) - *(void *)(v10 + 328)) >> 5));
  memset((char *)&v58[3] + 8, 0, 24);
  sub_100050EE8( (char *)&v58[3] + 8,  *(__int128 **)(v10 + 352),  *(__int128 **)(v10 + 360),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v10 + 360) - *(void *)(v10 + 352)) >> 2));
  LOBYTE(v58[5]) = *(_BYTE *)(v10 + 376);
  __int128 v12 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
  {
    v41 = byte_1008F1E9F;
    if (v6)
    {
      sub_100494958(v6, (uint64_t)v55);
      if (v56 >= 0) {
        v42 = v55;
      }
      else {
        v42 = (void **)v55[0];
      }
    }

    else
    {
      v42 = (void **)"NA";
    }

    v43 = sub_1005E2B18(v49);
    sub_1005E3244((unsigned __int8 *)&v57, &v54);
    size = (char)v54.__r_.__value_.__s.__size_;
    v45 = v54.__r_.__value_.__r.__words[0];
    sub_1005E3244((unsigned __int8 *)v59, &v53);
    v46 = &v54;
    if (size < 0) {
      v46 = (std::stringbuf::string_type *)v45;
    }
    if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      v47 = &v53;
    }
    else {
      v47 = (std::stringbuf::string_type *)v53.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 67110146;
    *(_DWORD *)&buf[4] = v41;
    *(_WORD *)v65 = 2080;
    *(void *)&v65[2] = v42;
    v66 = 2080;
    v67 = v43;
    v68 = 2080;
    v69 = v46;
    v70 = 2080;
    v71 = v47;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "updateAgentScanUseCaseEntry controllerSupportsScanRx:%d session:%s usecase:%s previous:%s entry:%s",  buf,  0x30u);
    if (v6 && v56 < 0) {
      operator delete(v55[0]);
    }
  }

  if (BYTE8(v57)) {
    __int128 v13 = BYTE7(v57) == 0;
  }
  else {
    __int128 v13 = 1;
  }
  __int128 v14 = !v13 && BYTE5(v57) == 0;
  uint64_t v15 = v14;
  if (!v14) {
    goto LABEL_34;
  }
  uint64_t v16 = v58[0] != 0LL;
  if (byte_1008F1E9F)
  {
LABEL_35:
    sub_1005E37D4(*(_DWORD **)(a2 + 8), v59);
    goto LABEL_36;
  }

  if (!BYTE7(v59[0]) && v58[0] == 0LL)
  {
LABEL_34:
    uint64_t v16 = 0;
    goto LABEL_35;
  }

  uint64_t v15 = 1;
LABEL_36:
  v19 = *(void *)(a2 + 8);
  v20 = *(unsigned __int16 *)(v19 + 312);
  unint64_t v21 = *(unsigned __int16 *)(v19 + 314);
  unint64_t v22 = *(_BYTE *)(v19 + 283);
  *(_BYTE *)(v19 + 120) = 1;
  *(_DWORD *)(v19 + 12_Block_object_dispose(&STACK[0x338], 8) = v21;
  *(_DWORD *)(v19 + 132) = v20;
  *(_BYTE *)(v19 + 136) = v22;
  *(_BYTE *)v19 = *(_BYTE *)(v19 + 280);
  *(_BYTE *)(v19 + 1) = *(_BYTE *)(v19 + 286);
  v51 = 0LL;
  v52 = 0LL;
  __p = 0LL;
  sub_100050EE8( (char *)&__p,  *(__int128 **)(v19 + 352),  *(__int128 **)(v19 + 360),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v19 + 360) - *(void *)(v19 + 352)) >> 2));
  if (__p)
  {
    v51 = (__int128 *)__p;
    operator delete(__p);
  }

  *(_BYTE *)(a2 + 224) = *(_BYTE *)(v19 + 376);
  v23 = *(void *)(a2 + 8);
  *(_BYTE *)(v23 + 273) = *(_BYTE *)(v19 + 316);
  *(_DWORD *)(v23 + 384) = *(_DWORD *)(v19 + 320);
  if (((v15 | v16) & 1) == 0)
  {
    uint64_t v24 = *(void *)(v19 + 304);
    *(_DWORD *)(v23 + 18_Block_object_dispose(&STACK[0x338], 8) = *(void *)(v19 + 296);
    *(_DWORD *)(v23 + 192) = v24;
  }

  sub_1005E3858(v23);
  v26 = *(void *)(v19 + 328);
  for (i = *(void *)(v19 + 336); v26 != i; v26 += 96LL)
  {
    *(void *)buf = 0LL;
    *(void *)v65 = 0LL;
    sub_10056AB04(buf, (const void *)(v26 + 40), *(unsigned __int16 *)(v26 + 90));
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = 0uLL;
    sub_10056AB04(&v54, (const void *)(v26 + 65), *(unsigned __int16 *)(v26 + 92));
    v27 = sub_1002E6BF0();
    v28 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 616LL))(v27);
    v29 = *(void *)(a2 + 8);
    uint64_t v30 = *(id *)(v29 + 152);
    v31 = (void *)objc_claimAutoreleasedReturnValue([v30 anyObject]);
    if (v28) {
      v32 = 3;
    }
    else {
      v32 = 1;
    }
    sub_10004A304( v29,  v31,  *(unsigned __int8 *)(v26 + 22),  *(_BYTE *)(v26 + 26),  (uint64_t)buf,  (uint64_t)&v54,  *(_BYTE *)(v26 + 21),  *(_BYTE *)(v26 + 23),  *(_BYTE *)(v26 + 23) != 0,  v32,  *(_BYTE *)(v26 + 25),  *(void **)v26,  *(_BYTE *)(v26 + 16),  *(_DWORD *)(v26 + 17),  BYTE1(*(_DWORD *)(v26 + 17)),  BYTE2(*(_DWORD *)(v26 + 17)),  HIBYTE(*(_DWORD *)(v26 + 17)),  0LL,  0xFFFF,  0xFFFF,  0xFFFF);

    v54.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
    if (v54.__r_.__value_.__l.__size_) {
      sub_1002CD254((unsigned int *)v54.__r_.__value_.__l.__size_);
    }
    *(void *)buf = &off_10087FAA8;
    if (*(void *)v65) {
      sub_1002CD254(*(unsigned int **)v65);
    }
  }

  if ((v49 & 0xFFFF0000) == 0x10000)
  {
    v33 = _os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures");
    v34 = HIWORD(v59[0]) ? v33 : 0;
    if (v34 == 1 && *(_BYTE *)(*(void *)(a2 + 8) + 201LL))
    {
      v35 = sub_1002E6BF0();
      v36 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 704LL))(v35);
      v37 = *(unsigned __int16 *)(v19 + 294);
      v38 = (v36 != 0) & (v37 >> 1);
      v39 = (v37 & (v36 != v38)) != 0 ? v38 | 2 : (v36 != 0) & (v37 >> 1);
      if (v39) {
        *(_BYTE *)(*(void *)(a2 + 8) + 122LL) = v39;
      }
    }
  }

  unint64_t v18 = v19 + 280;
  if (*((void *)&v58[3] + 1))
  {
    *(void *)&v58[4] = *((void *)&v58[3] + 1);
    operator delete(*((void **)&v58[3] + 1));
  }

  *(void *)buf = &v58[2];
  sub_10004FEA4((void ***)buf);
LABEL_65:
  if (v61[1])
  {
    *(void **)&v62 = v61[1];
    operator delete(v61[1]);
  }

  *(void *)&v57 = &v60;
  sub_10004FEA4((void ***)&v57);
  return v18;
}

  return v2;
}

  return v2;
}

  id v5 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LESecuredConnectionDebugKeys");
  uint64_t v6 = (unsigned __int8 *)(a1 + 592);
  if ((*(unsigned int (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v5 + 72LL))( v5,  buf,  __p,  a1 + 592))
  {
    uint64_t v7 = *v6;
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    if (v13 < 0)
    {
      operator delete(*(void **)buf);
      if (v7) {
        goto LABEL_28;
      }
    }

    else if (v7)
    {
      goto LABEL_28;
    }

    id v8 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Warning: Using LE 4.2 Secured Conenctions DEBUG KEYS !!!!!!!!",  buf,  2u);
    }

    sub_1001D46A0(*v6);
  }

  else
  {
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    if (v13 < 0) {
      operator delete(*(void **)buf);
    }
  }

void *sub_1000121DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v2 == result[3]) {
    return [result _update];
  }
  return result;
}

void sub_1000121F4(int8x16_t *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  uint64_t v5 = a1[2].i64[0];
  if (v5 != *(void *)(a1[2].i64[1] + 24)) {
    goto LABEL_21;
  }
  if (v3)
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      uint64_t v6 = CUPrintNSError(v4);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserEnsureStarted]_block_invoke_2",  30LL,  "### BLE advertiser failed: %@",  v7);
    }

    [(id)a1[2].i64[0] invalidate];
    uint64_t v9 = a1[2].i64[1];
    unint64_t v10 = *(void **)(v9 + 24);
    *(void *)(v9 + 24) = 0LL;

    goto LABEL_21;
  }

  if (dword_1008D5FD8 <= 30)
  {
    if (dword_1008D5FD8 == -1)
    {
      uint64_t v5 = a1[2].i64[0];
    }

    if (a1[3].i8[0]) {
      id v8 = "yes";
    }
    else {
      id v8 = "no";
    }
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserEnsureStarted]_block_invoke_2",  30LL,  "BLE advertiser activated: %@, restart %s",  v5,  v8);
  }

LABEL_15:
  if (a1[3].i8[0])
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserEnsureStarted]_block_invoke_2",  30LL,  "BLE advertiser forced update schedule: %@",  a1[2].i64[0]);
    }

    dispatch_source_t v11 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(a1[2].i64[1] + 88));
    uint64_t v12 = a1[2].i64[1];
    __int128 v13 = *(void **)(v12 + 48);
    *(void *)(v12 + 4_Block_object_dispose(&STACK[0x338], 8) = v11;
    __int128 v14 = v11;

    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100012440;
    handler[3] = &unk_10087F1D0;
    handler[4] = v14;
    int8x16_t v16 = a1[2];
    id v15 = (id)v16.i64[0];
    int8x16_t v18 = vextq_s8(v16, v16, 8uLL);
    dispatch_source_set_event_handler(v14, handler);
    CUDispatchTimerSet(v14, 1.0, -1.0, 1.0);
    dispatch_activate(v14);
  }

  -[CBDaemonServer scheduleAdvertiserUpdateImmediate:](self, "scheduleAdvertiserUpdateImmediate:", 0LL);
  v7[2](v7, 0LL);
}

  -[CBDaemonServer scheduleControlUpdateImmediate:](self, "scheduleControlUpdateImmediate:", 0LL);
  v7[2](v7, 0LL);
}

  v7[2](v7, 0LL);
}

  v7[2](v7, 0LL);
}

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v29, 8);
}

    __int128 v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_s1));
    -[CBControllerInfo setFirmwareName:](v3, "setFirmwareName:", v13);

    goto LABEL_16;
  }

  *((void *)*v10 + 5) = *v23;
LABEL_16:
  else {
    uint64_t v24 = 6;
  }
  *(_BYTE *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 24) = a4;
  v25 = *(void *)(a3 + 64);
  *(_WORD *)(v25 + 6) = 0;
  *(void *)(v25 + 64) = 0LL;
  *(void *)(sub_10017AB4C((unsigned int *)v25) + 8_Block_object_dispose(&STACK[0x338], 8) = 0LL;
  *(void *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 96) = 0LL;
  *(_WORD *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 36) = a5;
  *(_WORD *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 32) = a5;
  *(_WORD *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 34) = -1;
  *(_WORD *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 40) = 3000;
  *(_BYTE *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 26) = 3;
  *(_BYTE *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 16) = 4;
  *(void *)sub_10017AB4C(*(unsigned int **)(a3 + 64)) = a1;
  v26 = sub_1000B17F4(a5);
  v27 = *(void *)(a3 + 64);
  *(void *)(v27 + 4_Block_object_dispose(&STACK[0x338], 8) = v26;
  *(_BYTE *)(sub_10017AB4C((unsigned int *)v27) + 30) = 0;
  *(_BYTE *)(sub_10017AB4C(*(unsigned int **)(a3 + 64)) + 17) = 0;
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Creating L2CAP with priority %d",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  *(unsigned __int8 *)(a3 + 54));
    v35 = (os_log_s *)sub_100086554(0x51u);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v65 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (*(_BYTE *)(a3 + 54) == 13)
  {
    if (sub_10008D8B4(a1))
    {
      if (sub_100089F30(a1, 1))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Force upgrade TS not ready A", v42, v36, v37, v38, v39, v40, v41, v63);
          v43 = (os_log_s *)sub_100086554(0x51u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            v44 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446210;
            v65 = v44;
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
      }
    }

    *(_BYTE *)(*((void *)&xmmword_1008DD4E8 + a2) + 75LL) = 1;
    v45 = sub_100101BB8(a1, 200, v36, v37, v38, v39, v40, v41);
    v46 = sub_10017AB4C(*v10);
    if (!v45)
    {
      *(_WORD *)(v46 + 3_Block_object_dispose(&STACK[0x338], 8) = 200;
      goto LABEL_32;
    }
  }

  else
  {
    v46 = sub_10017AB4C(*v10);
  }

  *(_WORD *)(v46 + 3_Block_object_dispose(&STACK[0x338], 8) = -1;
LABEL_32:
  (*v10)[18] = 0;
  if (sub_10012D514(a1))
  {
    v47 = sub_10017AB4C(*v10);
    v48 = *(_WORD *)(a1 + 52);
    v49 = *(_DWORD *)(a1 + 48);
    goto LABEL_36;
  }

  if (sub_10012D5EC(a1))
  {
    v47 = sub_10017AB4C(*v10);
    v48 = *(_WORD *)(a1 + 53);
    v49 = *(_DWORD *)(a1 + 49);
LABEL_36:
    *(_DWORD *)(v47 + 10) = v49;
    *(_WORD *)(v47 + 14) = v48;
  }

  v50 = *(unsigned int **)(a3 + 64);
  if (!*(_BYTE *)(a3 + 56))
  {
    uint64_t v12 = sub_100186230(v50, 0, 0);
    if (!(_DWORD)v12) {
      goto LABEL_49;
    }
    goto LABEL_56;
  }

  *(_BYTE *)(sub_10017AB4C(v50) + 42) = 32;
  *(_BYTE *)(sub_10017AB4C(*v10) + 43) = 32;
  *(_WORD *)(sub_10017AB4C(*v10) + 44) = 10000;
  *(_WORD *)(sub_10017AB4C(*v10) + 46) = 0;
  if ((dword_1008DDC54 & 0x10) != 0 && (*(_BYTE *)(*((void *)&xmmword_1008DD4E8 + a2) + 52LL) & 0x10) != 0) {
    v51 = 2576;
  }
  else {
    v51 = 2042;
  }
  *(_WORD *)(sub_10017AB4C(*v10) + 4_Block_object_dispose(&STACK[0x338], 8) = v51;
  *(_WORD *)(sub_10017AB4C(*v10) + 50) = 0;
  if (*(_BYTE *)(a3 + 57)) {
    *(_BYTE *)(sub_10017AB4C(*v10) + 7_Block_object_dispose(&STACK[0x338], 8) = 1;
  }
  uint64_t v12 = sub_100186230(*v10, 3, 1);
  sub_100185A9C(*((unsigned __int16 *)*v10 + 2), 0);
  if ((_DWORD)v12)
  {
LABEL_56:
    sub_1001734D8((uint64_t)*v10);
    return v12;
  }

      id v4 = qword_1008DDC98;
      qword_1008DDC98 = *(uint64_t *)((char *)&qword_1008DDC98 + 4);
      dword_1008DDCA0 = 0;
      dword_1008DDC8C = v4;
      if (!v4) {
        goto LABEL_20;
      }
LABEL_19:
      uint64_t v2 = ((uint64_t (*)(void))sub_100098A64)();
LABEL_20:
      id v3 = byte_1008DDC88;
LABEL_21:
      if (v3) {
        sub_100098A64(v2);
      }
      return sub_10008C9AC();
    case 2:
    case 3:
      sub_1000FC0A8();
      sub_10008C9DC();
      goto LABEL_15;
    default:
      goto LABEL_19;
  }

  *(void *)(v11 + _Block_object_dispose(&STACK[0x338], 8) = a1;
  *(void *)(v11 + 4_Block_object_dispose(&STACK[0x338], 8) = sub_10009C980;
  *(void *)(v11 + 64) = sub_10009CA94;
  int8x16_t v16 = *(_WORD *)(sub_1001EDBA0(4u) + 4);
  if (!v16) {
    int8x16_t v16 = 4;
  }
  *(_WORD *)(*(void *)(qword_1008F29A0 + 32) + 16LL) = v16;
  uint64_t v17 = *(_WORD *)(sub_1001EDBA0(4u) + 6);
  if (!v17) {
    uint64_t v17 = 8;
  }
  *(_WORD *)(*(void *)(qword_1008F29A0 + 32) + 18LL) = v17;
  int8x16_t v18 = *(_WORD *)(sub_1001EDBA0(4u) + 8);
  v19 = *(void *)(qword_1008F29A0 + 32);
  if (!v18) {
    int8x16_t v18 = 20;
  }
  *(_WORD *)(v19 + 20) = v18;
  xmmword_1008DDD78 = xmmword_1006BC050;
  DWORD2(xmmword_1008DDD7_Block_object_dispose(&STACK[0x338], 8) = a2;
  *(void *)&v27 = &unk_100881DF8;
  WORD4(v27) = 4;
  *(void *)&v28 = *(void *)a3;
  WORD4(v2_Block_object_dispose(&STACK[0x338], 8) = *(_WORD *)(a3 + 8);
  xmmword_1008DDD78 = xmmword_1006BC050;
  DWORD2(xmmword_1008DDD7_Block_object_dispose(&STACK[0x338], 8) = a2;
  *(void *)&v25 = &unk_100881E58;
  WORD4(v25) = 4;
  *(void *)&v26 = *(void *)a3;
  WORD4(v26) = *(_WORD *)(a3 + 8);
  uint64_t v5 = sub_1001E139C((uint64_t)&v27, (int *)v19);
  sub_1001E1634(**(unsigned int **)(qword_1008F29A0 + 32), (uint64_t)&v25);
  if ((_DWORD)v5 || (uint64_t v5 = sub_1000E7588(), (_DWORD)v5))
  {
LABEL_27:
    sub_1001E1520(**(_DWORD **)(qword_1008F29A0 + 32));
    v20 = qword_1008F29A0;
    *(void *)(qword_1008F29A0 + _Block_object_dispose(&STACK[0x338], 8) = 0LL;
    if (*(_BYTE *)(v20 + 89))
    {
      unint64_t v21 = 0LL;
      unint64_t v22 = 8LL;
      do
      {
        v23 = *(void **)(*(void *)(*(void *)(v20 + 32) + 8LL) + v22);
        if (v23)
        {
          sub_1000B1838(v23);
          *(void *)(*(void *)(*(void *)(qword_1008F29A0 + 32) + 8LL) + v22) = 0LL;
          v20 = qword_1008F29A0;
        }

        ++v21;
        v22 += 32LL;
      }

      while (v21 < *(unsigned __int8 *)(v20 + 89));
    }

    uint64_t v24 = *(void ***)(v20 + 32);
    if (v24[1])
    {
      sub_1000B1838(v24[1]);
      uint64_t v24 = *(void ***)(qword_1008F29A0 + 32);
      v24[1] = 0LL;
    }

    sub_1000B1838(v24);
    *(void *)(qword_1008F29A0 + 32) = 0LL;
  }

  return v5;
}

  if (*((_BYTE *)v2 + 94) || *((_BYTE *)v2 + 95))
  {
    if (!*(_DWORD *)(qword_1008DDE00 + 56))
    {
      v29[1] = v2;
      v29[0] = (const void *)2;
      if (sub_1001EE6E8((uint64_t)sub_1000A8330, v29, 100, (int *)(qword_1008DDE00 + 56)))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Register disconnect timeout handler",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  (uint64_t)v29[0]);
          v26 = (os_log_s *)sub_100086554(0xFu);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_10065A878();
          }
        }
      }
    }
  }

  else
  {
    v27 = *(unsigned int *)(qword_1008DDE00 + 56);
    if ((_DWORD)v27)
    {
      sub_1001EEB14(v27);
      *(_DWORD *)(qword_1008DDE00 + 56) = 0;
    }

    v28 = sub_1000A5BC8(a1);
    if (v28) {
      *((_BYTE *)v28 + 95) = 0;
    }
    if (*(_BYTE *)(qword_1008DDE00 + 49))
    {
      sub_1000A80C4(a1, *((_DWORD *)v2 + 21));
    }

    else
    {
      LODWORD(v30[0]) = 2;
      DWORD2(v30[0]) = *(_DWORD *)(qword_1008DDE00 + 52);
      WORD2(v30[0]) = a1;
      (*(void (**)(_OWORD *))(qword_1008DDE00 + 24))(v30);
      sub_1001EF1E4(v2 + 13);
      sub_1000B1838(v2);
      --*(_BYTE *)(qword_1008DDE00 + 16);
    }
  }

          __int128 v13 = *(void *)v6;
          *((_WORD *)v6 + 6) = v12 + 1;
          *(_BYTE *)(v13 + v12) = 0;
LABEL_73:
          a2 += 16;
          if (!--v7) {
            return result;
          }
          break;
        case 3u:
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_113:
            v64 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_115:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  807,  v64);
          }

          v41 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v64 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_115;
          }

          v42 = *(void *)v6;
          *((_WORD *)v6 + 6) = v41 + 1;
          *(_BYTE *)(v42 + v41) = 3;
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_117:
            v65 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_119:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  808,  v65);
          }

          v43 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v65 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_119;
          }

          v44 = a2[1];
          v45 = *(void *)v6;
          *((_WORD *)v6 + 6) = v43 + 1;
          *(_BYTE *)(v45 + v43) = v44;
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_121:
            v66 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_123:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  809,  v66);
          }

          v46 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v66 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_123;
          }

          v47 = a2[2];
          v48 = *(void *)v6;
          *((_WORD *)v6 + 6) = v46 + 1;
          *(_BYTE *)(v48 + v46) = v47;
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_125:
            v67 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_127:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  810,  v67);
          }

          v49 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v67 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_127;
          }

          v50 = a2[3];
          v51 = *(void *)v6;
          *((_WORD *)v6 + 6) = v49 + 1;
          *(_BYTE *)(v51 + v49) = v50;
          goto LABEL_73;
        case 4u:
        case 7u:
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_84:
            v56 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_86:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  814,  v56);
          }

          __int128 v14 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v56 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_86;
          }

          id v15 = a2[3] + 2;
          int8x16_t v16 = *(void *)v6;
          *((_WORD *)v6 + 6) = v14 + 1;
          *(_BYTE *)(v16 + v14) = v15;
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_88:
            v57 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_90:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  815,  v57);
          }

          uint64_t v17 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v57 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_90;
          }

          int8x16_t v18 = a2[1];
          v19 = *(void *)v6;
          *((_WORD *)v6 + 6) = v17 + 1;
          *(_BYTE *)(v19 + v17) = v18;
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_92:
            v58 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_94:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  816,  v58);
          }

          v20 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v58 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_94;
          }

          unint64_t v21 = a2[2];
          unint64_t v22 = *(void *)v6;
          *((_WORD *)v6 + 6) = v20 + 1;
          *(_BYTE *)(v22 + v20) = v21;
          v23 = *(void *)v6;
          uint64_t v24 = *((unsigned __int16 *)v6 + 6);
          v25 = (const void *)*((void *)a2 + 1);
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
            v26 = 0;
          }

          else
          {
            v26 = *((unsigned __int16 *)v6 + 5) - (_DWORD)v24;
          }

          v52 = a2[3];
          if (v26 < (int)v52)
          {
            v61 = "ByteStream_NumReadBytesAvail(*pBs) >= (cap->genericData.dataLen)";
            goto LABEL_105;
          }

          if (v6[14] != 2)
          {
            v61 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
LABEL_105:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  817,  v61);
          }

          v53 = (void *)(v23 + v24);
LABEL_72:
          uint64_t result = memmove(v53, v25, v52);
          *((_WORD *)v6 + 6) += a2[3];
          goto LABEL_73;
        case 5u:
        case 6u:
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_96:
            v59 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_98:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  821,  v59);
          }

          v27 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v59 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_98;
          }

          v28 = a2[3] + 1;
          v29 = *(void *)v6;
          *((_WORD *)v6 + 6) = v27 + 1;
          *(_BYTE *)(v29 + v27) = v28;
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
LABEL_100:
            v60 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_102:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  822,  v60);
          }

          uint64_t v30 = *((unsigned __int16 *)v6 + 6);
          if (v6[14] != 2)
          {
            v60 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_102;
          }

          v31 = a2[1];
          v32 = *(void *)v6;
          *((_WORD *)v6 + 6) = v30 + 1;
          *(_BYTE *)(v32 + v30) = v31;
          v33 = a2[3];
          if (!a2[3]) {
            goto LABEL_73;
          }
          v34 = *(void *)v6;
          v35 = *((unsigned __int16 *)v6 + 6);
          v25 = (const void *)*((void *)a2 + 1);
          if (v6[15])
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c");
            v36 = 0;
            v33 = a2[3];
          }

          else
          {
            v36 = *((unsigned __int16 *)v6 + 5) - (_DWORD)v35;
          }

          if (v36 < v33)
          {
            v62 = "ByteStream_NumReadBytesAvail(*pBs) >= (cap->genericData.dataLen)";
LABEL_107:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  824,  v62);
          }

          if (v6[14] != 2)
          {
            v62 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
            goto LABEL_107;
          }

    sub_1001DAAF0(a1, a2);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"OI_HandsfreeRaw_FastConnect_DestroyChannel Handsfree AG service not started!",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v15);
    __int128 v14 = (os_log_s *)sub_100086554(0x10u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

      id v4 = v8 + v9;
    }
  }

  return 0LL;
}

      unint64_t v21 = (v21 + 1 + v22);
      if (++v19 == v4) {
        goto LABEL_20;
      }
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"pos(%d) + transportSize(%d) > dataSize(%d)", v31, v32, v33, v34, v35, v36, v37, v21);
      v38 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

  if (*(_BYTE *)(qword_1008F6D08 + 15))
  {
    v26 = 1;
  }

  else
  {
    uint64_t result = sub_100118094(0LL);
    v26 = !result;
  }

  byte_1008F6D10 = v26;
  return result;
}

        sub_1001EE2A0();
        break;
    }

    sub_1001EEF6C();
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"OI_HCIIfc_SendCompleted, HCI not initialized - ignoring event",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v27);
    unint64_t v10 = (os_log_s *)sub_100086554(0x2Eu);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }
    }

    sub_10010D3AC(129LL, v13, (uint64_t)(v13 + 24), 1LL, 0LL);
LABEL_14:
    __int128 v13 = 0LL;
    goto LABEL_15;
  }

    sub_100657858();
    goto LABEL_16;
  }

  unint64_t v22 = *a2;
  *(_DWORD *)(v10 + 2_Block_object_dispose(&STACK[0x338], 8) = v22;
  if (v22 > *(unsigned __int16 *)(sub_10017AB4C((unsigned int *)a1) + 36))
  {
    v23 = *(unsigned int *)(v10 + 28);
    sub_10017AB4C((unsigned int *)a1);
    sub_1001EE134((uint64_t)"SDU Size exceeds MTU (SDU Size=%d inMTU=%d\n", v24, v25, v26, v27, v28, v29, v30, v23);
    v31 = (os_log_s *)sub_100086554(0x2Fu);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  if (*(unsigned __int16 *)(sub_10017AB4C((unsigned int *)a1) + 72) < a3)
  {
    sub_10017AB4C((unsigned int *)a1);
    sub_1001EE134( (uint64_t)"PDU Size exceeds MaxPDUSize (PDU Size=%d maxPDUSize=%d\n",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  a3);
    v43 = (os_log_s *)sub_100086554(0x2Fu);
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  dispatch_source_t v11 = (char *)sub_1000B17F4(*(unsigned int *)(v10 + 28));
  *(void *)(v10 + 16) = v11;
  if (v11)
  {
    ++a2;
    LOWORD(a3) = a3 - 2;
    goto LABEL_2;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to allocate reassemblyPacket memory.\n", v45, v46, v47, v48, v49, v50, v51, v53);
    v52 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 106LL;
}

  if (a2 != 240) {
    goto LABEL_21;
  }
}

  uint64_t v5 = sub_1001C33FC(a1);
  if (!v5)
  {
LABEL_19:
    uint64_t v7 = 0LL;
    id v8 = 0;
    goto LABEL_20;
  }

  uint64_t v6 = (*((_BYTE *)v5 + 7) - 1);
  uint64_t v7 = v6 < 0xEF;
  if (v6 >= 0xEF) {
    id v8 = 0;
  }
  else {
    id v8 = *((_BYTE *)v5 + 7);
  }
LABEL_20:
  if (sub_1000A86F0())
  {
    if (v7) {
      uint64_t v9 = "";
    }
    else {
      uint64_t v9 = "Not";
    }
    sub_1001C34B0(v8);
    sub_1001EE134( (uint64_t)"%s delaying security enforcement for Address=%: keys available ? %s pairing state :(%s)%d",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)v9);
    uint64_t v17 = (os_log_s *)sub_100086554(0x55u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v20 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  return v7;
}

    sub_1001CBE38((__int128 *)a1, 8, v5);
    return;
  }

  __p[0] = 0LL;
  __p[1] = 0LL;
  sub_100242F28((uint64_t)__p, a1 + 360);
  if (a2)
  {
    for (i = *(void *)(a1 + 336); i != *(void *)(a1 + 344); i += 8LL)
    {
      if (**(void **)i == a2)
      {
        unint64_t v21 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int16 *))(**(void **)(*(void *)i + 768LL) + 152LL))( *(void *)(*(void *)i + 768LL),  a2,  a3,  a4,  a5,  a6);
        goto LABEL_23;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, buf);
    sub_10065F89C();
  }

  unint64_t v21 = 312LL;
LABEL_23:
  sub_100242FAC((uint64_t)__p);
  return v21;
}

  sub_100242FAC((uint64_t)v51);
  return v11;
}
}

    v189 = @"Unknown";
    goto LABEL_16;
  }

  if (!v200.__r_.__value_.__s.__size_) {
    goto LABEL_15;
  }
  uint64_t v9 = &v200;
LABEL_14:
  v189 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  v9,  +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding")));
LABEL_16:
  unint64_t v10 = sub_1003D06C0(v3);
LABEL_17:
  v186 = v5;
  v190 = v3;
  v183 = v10;
  dispatch_source_t v11 = *(int ***)(a2 + 328);
  uint64_t v12 = *(int ***)(a2 + 336);
  if (v11 == v12)
  {
    v26 = v195;
  }

  else
  {
    do
    {
      __int128 v13 = **v11;
      __int128 v14 = v198;
      if (v198 >= v199)
      {
        int8x16_t v16 = (char *)v197;
        uint64_t v17 = (v198 - (_BYTE *)v197) >> 2;
        int8x16_t v18 = v17 + 1;
        v19 = v199 - (_BYTE *)v197;
        if ((v199 - (_BYTE *)v197) >> 1 > v18) {
          int8x16_t v18 = v19 >> 1;
        }
        else {
          v20 = v18;
        }
        if (v20)
        {
          unint64_t v21 = (char *)sub_10024E33C((uint64_t)&v199, v20);
          int8x16_t v16 = (char *)v197;
          __int128 v14 = v198;
        }

        else
        {
          unint64_t v21 = 0LL;
        }

        unint64_t v22 = &v21[4 * v17];
        *(_DWORD *)unint64_t v22 = v13;
        id v15 = v22 + 4;
        while (v14 != v16)
        {
          v23 = *((_DWORD *)v14 - 1);
          v14 -= 4;
          *((_DWORD *)v22 - 1) = v23;
          v22 -= 4;
        }

        v197 = v22;
        v198 = v15;
        v199 = &v21[4 * v20];
        if (v16) {
          operator delete(v16);
        }
      }

      else
      {
        *(_DWORD *)v198 = v13;
        id v15 = v14 + 4;
      }

      v198 = v15;
      uint64_t v24 = *((char *)*v11 + 8);
      v25 = v195;
      if (v195 >= v196)
      {
        v27 = (char *)v194;
        v28 = (v195 - (_BYTE *)v194) >> 2;
        v29 = v28 + 1;
        uint64_t v30 = v196 - (_BYTE *)v194;
        if ((v196 - (_BYTE *)v194) >> 1 > v29) {
          v29 = v30 >> 1;
        }
        else {
          v31 = v29;
        }
        if (v31)
        {
          v32 = (char *)sub_10024E33C((uint64_t)&v196, v31);
          v27 = (char *)v194;
          v25 = v195;
        }

        else
        {
          v32 = 0LL;
        }

        v33 = &v32[4 * v28];
        *(_DWORD *)v33 = v24;
        v26 = v33 + 4;
        while (v25 != v27)
        {
          v34 = *((_DWORD *)v25 - 1);
          v25 -= 4;
          *((_DWORD *)v33 - 1) = v34;
          v33 -= 4;
        }

        v194 = v33;
        v195 = v26;
        v196 = &v32[4 * v31];
        if (v27) {
          operator delete(v27);
        }
      }

      else
      {
        *(_DWORD *)v195 = v24;
        v26 = v25 + 4;
      }

      v195 = v26;
      ++v11;
    }

    while (v11 != v12);
  }

  if (v194 == v26)
  {
    v35 = 0LL;
    v40 = 0;
    v37 = v6;
    v43 = v190;
    v44 = v186;
  }

  else
  {
    LODWORD(v35) = 0;
    v36 = (unsigned int *)v194;
    v37 = v6;
    do
    {
      v39 = *v36++;
      v38 = v39;
      if (v39 <= 0xFFFFFF9B) {
        v35 = v35;
      }
      else {
        v35 = v38;
      }
    }

    while (v36 != (unsigned int *)v26);
    v40 = *(_DWORD *)(a2 + 316) - ((unint64_t)(v26 - (_BYTE *)v194) >> 2);
    v41 = (os_log_s *)(id)qword_1008F7578;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
    {
      v42 = *(_DWORD *)(a2 + 316);
      LODWORD(__str.__r_.__value_.__l.__data_) = 67109632;
      HIDWORD(__str.__r_.__value_.__r.__words[0]) = v40;
      LOWORD(__str.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&__str.__r_.__value_.__r.__words[1] + 2) = v42;
      HIWORD(__str.__r_.__value_.__r.__words[1]) = 2048;
      __str.__r_.__value_.__l.__cap_ = (v195 - (_BYTE *)v194) >> 2;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_INFO,  "TotalFrameDropped calculation: totalFrameDropped = %d, a2dpMetric.fTotalPurgeCount = %u, rssiAtSkip.size() = %lu",  (uint8_t *)&__str,  0x18u);
    }

    v43 = v190;
    v44 = v186;
  }

  if (v197 == v198)
  {
    v47 = 0;
    v45 = 0;
    goto LABEL_71;
  }

  v45 = *((_DWORD *)v198 - 1);
  if (v45 - 1 >= 0x3B)
  {
    if (v45)
    {
      id v4 = (double)v45 / 60.0;
      v46 = vcvtad_u64_f64(v4);
      goto LABEL_69;
    }

    v47 = 0;
LABEL_71:
    v46 = 0;
    goto LABEL_72;
  }

  v46 = 1;
LABEL_69:
  v47 = (v40 & ~(v40 >> 31)) / v45;
LABEL_72:
  v48 = *(_DWORD *)(a2 + 248);
  v49 = v45 - v48;
  if (v45 != v48 && v48)
  {
    id v4 = (double)v49 / (double)v48;
    *(double *)(a2 + 240) = v4;
  }

  v50 = v49 - 1 < 0x3B;
  if (v49 - 1 >= 0x3B && v45 != v48)
  {
    id v4 = (double)v49 / 60.0;
    v50 = vcvtad_u64_f64(v4);
  }

  *(_DWORD *)(a2 + 252) = v50;
  v51 = v48 - 1 < 0x3B;
  if (v48 >= 0x3C)
  {
    id v4 = (double)v48 / 60.0;
    v51 = vcvtad_u64_f64(v4);
  }

  *(_DWORD *)(a2 + 24_Block_object_dispose(&STACK[0x338], 8) = v51;
  v52 = *(_DWORD *)(a2 + 232);
  if (v52 - 1 >= 0x3B)
  {
    if (v52)
    {
      id v4 = (double)v52 / 60.0;
      v52 = vcvtad_u64_f64(v4);
    }
  }

  else
  {
    v52 = 1;
  }

  *(_DWORD *)(a2 + 232) = v52;
  v53 = *(void *)(a2 + 288);
  if (v53) {
    v54 = *(void *)(a2 + 264) / v53;
  }
  else {
    v54 = 0LL;
  }
  v55 = *(void *)(a2 + 280);
  if (v55)
  {
    v56 = *(unsigned int *)(a2 + 272) / v55;
    if (v46)
    {
LABEL_89:
      LODWORD(v4) = *(_DWORD *)(a2 + 256);
      id v4 = (double)*(unint64_t *)&v4;
      v57 = v4 / (double)v46;
      goto LABEL_92;
    }
  }

  else
  {
    v56 = 0LL;
    if (v46) {
      goto LABEL_89;
    }
  }

  v57 = 0.0;
LABEL_92:
  v58 = *(unsigned int **)(a2 + 352);
  v59 = *(unsigned int **)(a2 + 360);
  if (v58 == v59)
  {
    v62 = 0LL;
    v61 = 0;
  }

  else
  {
    v60 = 0;
    v61 = 0;
    LODWORD(v62) = 0;
    do
    {
      v64 = *v58++;
      v63 = v64;
      v65 = v64 - 1;
      else {
        v66 = v63;
      }
      if (v65 >= 0x64) {
        v62 = v62;
      }
      else {
        v62 = v66;
      }
      if (v65 >= 0x64) {
        v63 = 0;
      }
      else {
        ++v61;
      }
      v60 += v63;
    }

    while (v58 != v59);
    if (v61) {
      v61 = v60 / v61;
    }
  }

  v67 = v51 == 0;
  if (v51) {
    v68 = 2 * *(char *)(a2 + 388) - (int)v54;
  }
  else {
    v68 = *(char *)(a2 + 388);
  }
  if (v67) {
    v69 = v61;
  }
  else {
    v69 = 2 * v61 - v56;
  }
  *(void *)(a2 + 296) = v68;
  *(void *)(a2 + 304) = v69;
  if (v45 >> 7 > 0x2A2 || (id v4 = (double)v45, v8 + v7 >= (double)v45))
  {
    v70 = 0;
  }

  else
  {
    id v4 = v4 - (v8 + v7);
    v70 = v4;
  }

  v141 = v56;
  v142 = v54;
  v153 = v47;
  v163 = v40 & ~(v40 >> 31);
  v159 = v61;
  v181 = v46;
  if ((_DWORD)v202 != 76)
  {
    v175 = 0;
    v173 = 0;
    goto LABEL_137;
  }

  v71 = v8;
  if (v8 < 0x15180)
  {
    if (v71 - 1 < 0x3B)
    {
      v72 = 1;
LABEL_124:
      v175 = v72;
      goto LABEL_126;
    }

    if (v71)
    {
      id v4 = (double)v71 / 60.0;
      v72 = vcvtad_u64_f64(v4);
      goto LABEL_124;
    }
  }

  v175 = 0;
LABEL_126:
  if (v70 - 1 >= 0x3B)
  {
    if (v70)
    {
      id v4 = (double)v70 / 60.0;
      v73 = vcvtad_u64_f64(v4);
    }

    else
    {
      v73 = 0;
    }
  }

  else
  {
    v73 = 1;
  }

  v74 = v7;
  v173 = v73;
  if (v7 < 0x15180)
  {
    if (v74 - 1 < 0x3B)
    {
      v75 = 1;
LABEL_136:
      v177 = v75;
      goto LABEL_138;
    }

    if (v74)
    {
      id v4 = (double)v74 / 60.0;
      v75 = vcvtad_u64_f64(v4);
      goto LABEL_136;
    }
  }

  uint64_t v9 = *(unsigned __int16 *)(a1 + 64);
  if (v9 >= 0xA) {
    LOWORD(v9) = 10;
  }
  v2[280] = v9;
  v2[282] = *(_WORD *)(a1 + 66);
}

  reply = xpc_dictionary_create_reply(xdict);
  dispatch_source_t v11 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    xpc_dictionary_set_string(v11, "kCBMsgArgDeviceName", (const char *)p_p);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v11);
    xpc_release(v11);
  }

  uint64_t v5 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFF78) {
      uint64_t v6 = "enabled";
    }
    else {
      uint64_t v6 = "disabled";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "BT chip support for LowPowerCore Scan : %s",  (uint8_t *)&buf,  0xCu);
  }

  int8x16_t v16 = 0;
  uint64_t v7 = sub_1002E6E00();
  sub_10002418C(&buf, "LowPowerCoreScan");
  sub_10002418C(__p, "DisableLowPowerCoreScan");
  id v8 = (*(uint64_t (**)(uint64_t, __int128 *, void **, unsigned __int8 *))(*(void *)v7 + 72LL))( v7,  &buf,  __p,  &v16);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if (v18 < 0)
  {
    operator delete((void *)buf);
    if (!v8) {
      goto LABEL_35;
    }
  }

  else if (!v8)
  {
    goto LABEL_35;
  }

  uint64_t v9 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Overriding Disabling LowPowerCore Scan=%d",  (uint8_t *)&buf,  8u);
  }

  if (byte_1008EFF78) {
    unint64_t v10 = v16 == 0;
  }
  else {
    unint64_t v10 = 0;
  }
  dispatch_source_t v11 = v10;
  byte_1008EFF78 = v11;
LABEL_35:
  uint64_t v12 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFF78) {
      __int128 v13 = "enabled";
    }
    else {
      __int128 v13 = "disabled";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "support for new LowPowerCore scan is %s",  (uint8_t *)&buf,  0xCu);
  }

  uint64_t v12 = sub_1002E6BF0();
  if (v7 > (double)(*(unsigned int (**)(uint64_t))(*(void *)v12 + 464LL))(v12))
  {
    __int128 v13 = sub_1002E6E9C();
    (*(void (**)(uint64_t))(*(void *)v13 + 1248LL))(v13);
    __int128 v14 = sub_1002E6BF0();
    id v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 392LL))(v14) ^ 1;
    if (a2 != -536870144) {
      LOBYTE(v15) = 1;
    }
    if ((v15 & 1) == 0)
    {
      int8x16_t v16 = *(_DWORD *)(sub_1002E6E9C() + 708);
      if (v16 - 2000 <= 0x7CF)
      {
        v47 = 0LL;
        v48 = 0LL;
        v45 = 0LL;
        v46 = 0LL;
        v43 = 0LL;
        v44 = 0LL;
        v42 = 0LL;
        if (((*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 176LL))(a1, 0LL) & 1) != 0)
        {
          uint64_t v17 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v47;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Calling PPS - durationSleep %d, controllerDidSleep %d",  buf,  0xEu);
          }

          int8x16_t v18 = sub_1002E6E9C();
          v19 = (*(uint64_t (**)(uint64_t, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *))(*(void *)v18 + 1184LL))( v18,  (char *)&v48 + 4,  &v48,  (char *)&v47 + 4,  &v47,  (char *)&v46 + 4,  &v46,  (char *)&v45 + 4,  &v45,  (char *)&v44 + 4,  &v44,  (char *)&v43 + 4,  &v43,  (char *)&v42 + 4,  &v42);
          v20 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67112704;
            *(_DWORD *)&buf[4] = v19;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = HIDWORD(v48);
            *(_WORD *)&buf[14] = 1024;
            *(_DWORD *)&buf[16] = v48;
            *(_WORD *)&buf[20] = 1024;
            *(_DWORD *)&buf[22] = HIDWORD(v47);
            *(_WORD *)&buf[26] = 1024;
            *(_DWORD *)&buf[28] = v47;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = HIDWORD(v46);
            *(_WORD *)&buf[38] = 1024;
            *(_DWORD *)&buf[40] = v46;
            *(_WORD *)&buf[44] = 1024;
            *(_DWORD *)&buf[46] = HIDWORD(v45);
            *(_WORD *)&buf[50] = 1024;
            *(_DWORD *)&buf[52] = v45;
            *(_WORD *)&buf[56] = 1024;
            *(_DWORD *)&buf[58] = HIDWORD(v44);
            *(_WORD *)&buf[62] = 1024;
            LODWORD(v50) = v44;
            WORD2(v50) = 1024;
            *(_DWORD *)((char *)&v50 + 6) = HIDWORD(v43);
            WORD5(v50) = 1024;
            HIDWORD(v50) = v43;
            LOWORD(v51) = 1024;
            *(_DWORD *)((char *)&v51 + 2) = HIDWORD(v42);
            WORD3(v51) = 1024;
            DWORD2(v51) = v42;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "PPS completed with result %d durationTotal %d, durationActive %d, durationIdle %d, durationSleep %d disabl eCounter %d, iPATxBT %d, ePATxBT %d, iPATxLE %d, ePATxLE %d, connectedRxBT %d, connectedRxLE %d, scanRxBT %d scanRxLE %d, totalPHYCal %d",  buf,  0x5Cu);
          }

          unint64_t v21 = v47;
          unint64_t v22 = v47 == 0;
        }

        else
        {
          unint64_t v22 = 0;
          v19 = 205;
          unint64_t v21 = v47;
        }

        v25 = v21 != 0;
        v26 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&buf[4] = v19;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v47;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&buf[16] = v21 != 0;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "result %d, durationSleep %d, controllerDidSleep %d",  buf,  0x14u);
        }

        if (v19) {
          return;
        }
LABEL_41:
        if (v25) {
          return;
        }
        v28 = sub_1002E6BF0();
        if (((*(uint64_t (**)(uint64_t))(*(void *)v28 + 328LL))(v28) & 1) == 0)
        {
          v29 = sub_1002E6BF0();
        }

        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_100892D18);
        }
        uint64_t v30 = *((_DWORD *)off_1008D6190 + 40) + *((_DWORD *)off_1008D6190 + 39);
        if (v30)
        {
          v31 = sub_1002E6BF0();
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v31 + 344LL))(v31))
          {
            v37 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
              sub_10066E140(v30, v37, v38, v7);
            }
            return;
          }
        }

        v32 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218752;
          *(void *)&buf[4] = (uint64_t)v7;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v30;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = 0;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v22;
          _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "Detected that BT did not sleep during AP sleep of %lld seconds.  Restarting nb connections: %d, controllerDi dSleep: %d, retry: %d",  buf,  0x1Eu);
          if (!v22) {
            goto LABEL_59;
          }
        }

        else if (!v22)
        {
          goto LABEL_59;
        }

        v33 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v33 + 344LL))(v33))
        {
          v47 = 0LL;
          v48 = 0LL;
          v45 = 0LL;
          v46 = 0LL;
          v43 = 0LL;
          v44 = 0LL;
          v42 = 0LL;
          v34 = sub_1002E6E9C();
          v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *))(*(void *)v34 + 1184LL))( v34,  (char *)&v48 + 4,  &v48,  (char *)&v47 + 4,  &v47,  (char *)&v46 + 4,  &v46,  (char *)&v45 + 4,  &v45,  (char *)&v44 + 4,  &v44,  (char *)&v43 + 4,  &v43,  (char *)&v42 + 4,  &v42);
          v36 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v35;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v47;
            _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Retry PPS completed with result %d, durationSleep %d",  buf,  0xEu);
          }

          if (!v35 && (_DWORD)v47) {
            return;
          }
        }

  CFRelease(v4);
  return v6 ^ 1;
}

    LOBYTE(v15) = 0;
  }

  LOBYTE(v20) = 0;
LABEL_17:
  if (a3 != 2)
  {
    if (a3 == 1)
    {
      unint64_t v21 = 0LL;
    }

    else
    {
      if (a3)
      {
        unint64_t v22 = 0;
        v23 = 7LL;
        goto LABEL_33;
      }

      LOBYTE(v2_Block_object_dispose(&STACK[0x338], 8) = (_BYTE)v15;
      unint64_t v21 = 1LL;
    }

    *(_BYTE *)((unint64_t)&v28 | v21) = v20;
  }

  v23 = 0LL;
  unint64_t v22 = 2 - a3;
LABEL_33:
  uu2[0] = 0;
  sub_100242CA4(uu2);
  a6(a4, v23, &v28, v22);
  sub_100242CD8(uu2);

  return sub_100242FAC((uint64_t)v27);
}

  *(_WORD *)(a1 + 144) = 432;
  v108 = 0;
  unint64_t v10 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ENForceCustomAdvInterval");
  dispatch_source_t v11 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v10 + 88LL))(v10, buf, __p, &v108);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v11) {
      goto LABEL_23;
    }
  }

  else if (!v11)
  {
    goto LABEL_23;
  }

  uint64_t v12 = v108;
  *(_WORD *)(a1 + 144) = v108;
  __int128 v13 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Overriding ENForceCustomAdvInterval = %d ",  buf,  8u);
  }

    id v8 = 5LL;
    goto LABEL_18;
  }

  if (__p.__r_.__value_.__s.__size_ >= a3) {
    goto LABEL_15;
  }
  p_p = &__p;
LABEL_17:
  strlcpy(a2, (const char *)p_p, a3);
  id v8 = 0LL;
LABEL_18:
  return v8;
}

    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)v48 = a6;
      *(_WORD *)&v48[4] = 2048;
      *(void *)&v48[6] = a2;
      *(_WORD *)&v48[14] = 2114;
      *(void *)&v48[16] = v15;
      v49 = 1024;
      v50 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Gatt device connected on transport %d on handle %p address:%{public}@ with status %{bluetooth:OI_STATUS}u",  buf,  0x22u);
    }

    if (a6 == 2)
    {
      if (qword_1008D5F10 != -1) {
        dispatch_once(&qword_1008D5F10, &stru_100897428);
      }
      if (!sub_100593548((uint64_t)off_1008D5F08, a2, uu) || uuid_is_null(uu))
      {
        int8x16_t v18 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
        {
          v19 = sub_1005BFB9C(a3);
          v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
          *(_DWORD *)buf = 138543362;
          *(void *)v48 = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Warning: Device %{public}@ wasn't being tracked by le device manager, ignoring connection indication",  buf,  0xCu);
        }

        goto LABEL_37;
      }
    }

    else if (a6 == 1)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100897448);
      }
      sub_1005C8684((uint64_t)off_1008D5F28, a3, 1u, 0, 0LL, 0LL, buf);
      uuid_copy(uu, buf);
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100897448);
      }
      unint64_t v21 = off_1008D5F28;
      unint64_t v22 = sub_100241F94(uu);
      v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
      sub_1005D1FA8((uint64_t)v21, v23, 1, a3);

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100897448);
      }
      uint64_t v24 = off_1008D5F28;
      v25 = sub_100241F94(uu);
      v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
      sub_1005D3868((uint64_t)v24, v26, 1, 1, 0);
    }

    v27 = sub_100241F94(uu);
    v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    v29 = sub_10041291C(a1, v28, a6);

    if (v29)
    {
      uint64_t v30 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
      {
        v31 = sub_100241F94(uu);
        v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
        *(_DWORD *)buf = 138543618;
        *(void *)v48 = v32;
        *(_WORD *)&v48[8] = 2114;
        *(void *)&v48[10] = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Waiting on disconnection of BR/EDR GATT L2CAP for device %{public}@ %{public}@",  buf,  0x16u);
      }

      v33 = sub_100241F94(uu);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100412C1C;
      block[3] = &unk_100897340;
      v42 = a1;
      v34 = (id)objc_claimAutoreleasedReturnValue(v33);
      v41 = v34;
      v43 = a2;
      v44 = a5;
      v45 = a6;
      v46 = a4;
      v35 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, block);
      v36 = *(void **)(a1 + 72);
      v37 = objc_retainBlock(v35);
      [v36 setObject:v37 forKey:v34];
    }

    else
    {
      v38 = sub_100241F94(uu);
      v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
      sub_100412C34(a1, v39, a2, a6, a4, a5);
    }

    goto LABEL_37;
  }

  sub_100242FAC((uint64_t)v18);
  return v4;
}

  sub_100242FAC((uint64_t)v18);
  return v4;
}

  id v3 = 0LL;
LABEL_16:
  sub_100242FAC((uint64_t)v14);
  return v3;
}

  if (a3) {
    __int128 v14 = 103;
  }
  else {
    __int128 v14 = 104;
  }
  sub_100411948(a1, v6, v14, 0);
  if (v7)
  {
    sub_100207454((uint64_t)(v7 + 50), a3);
    sub_100207464((uint64_t)(v7 + 50), 1);
    return 255LL;
  }

  else
  {
    id v15 = (os_log_s *)qword_1008F7598;
    uint64_t result = os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_10068201C(a3, v15);
      return 0LL;
    }
  }

  return result;
}

    uint64_t v7 = 1;
    goto LABEL_16;
  }

  uint64_t v5 = sub_1003E235C((uint64_t)a2, v17, &v13);
  if (v13) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  if (!v6)
  {
    if (!sub_1003D0454((uint64_t)a2, &v14))
    {
      uint64_t v7 = 0;
      goto LABEL_16;
    }

    if ((v14 & 0x1F00) == 0x500) {
      goto LABEL_11;
    }
    id v8 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Service is not capable because major is not peripheral",  (uint8_t *)&v11,  2u);
    }

    goto LABEL_15;
  }

  uint64_t v7 = 4 * (sub_10011B978((unsigned __int8 *)v17, 4388, &v12) == 0);
LABEL_16:
  uint64_t v9 = *(_DWORD *)(a1 + 32);
  int8x16_t v16 = 0LL;
  sub_1000B0400((uint64_t)&v16);
  *(void *)&dispatch_source_t v11 = (int)v16;
  *((void *)&v11 + 1) = SWORD2(v16);
  return sub_1003D1FC4((uint64_t)a2, v9, v7, &v11, 0);
}

  if (!*(_DWORD *)(a1 + 56))
  {
    uint64_t v30 = 0uLL;
    v28 = 0uLL;
    v29 = 0;
    sub_10052523C((uint64_t)&v28);
    if (qword_1008D67B8 != -1) {
      dispatch_once(&qword_1008D67B8, &stru_1008A0008);
    }
    if (sub_100535750((uint64_t)off_1008D67B0, v2, &v28))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR)) {
        sub_10068F5B8();
      }
    }

    else
    {
      uint64_t v9 = sub_10052528C((uint64_t)&v28);
      v25 = 0;
      sub_100242CA4(&v25);
      dispatch_source_t v11 = nullsub_63(&v28, v10);
      uint64_t v12 = sub_1005252DC();
      LODWORD(v11) = sub_10018496C(v11, v12, &v30, *(unsigned __int8 *)(a1 + 66));
      sub_100242CD0(&v25);
      if ((_DWORD)v11)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR)) {
          sub_10068F558();
        }
      }

      else
      {
        __int128 v13 = v9;
        if (qword_1008D5F20 != -1) {
          dispatch_once(&qword_1008D5F20, &stru_1008A0028);
        }
        __int128 v14 = *(unsigned __int8 **)(a1 + 40);
        v23 = *(_OWORD **)(a1 + 32);
        uint64_t v24 = qword_1008D5F18;
        id v15 = *v14;
        int8x16_t v16 = v14[1];
        uint64_t v17 = v14[2];
        int8x16_t v18 = v14[3];
        v19 = v14[4];
        v20 = v14[5];
        unint64_t v21 = *(unsigned __int8 *)(a1 + 66);
        sub_1003D01A0((uint64_t)v2, (uint64_t)buf);
        sub_10062E260( v24,  (v15 << 40) | (v16 << 32) | (v17 << 24) | (v18 << 16) | (v19 << 8) | v20,  1,  &v30,  v23,  v21 != 0,  v13 == 8,  (uint64_t)buf);
        if (SBYTE3(v35) < 0) {
          operator delete(*(void **)buf);
        }
      }

      sub_100242CD8(&v25);
    }

    nullsub_63(&v28, v8);
  }

  free(*(void **)(a1 + 32));
  buf[0] = 0;
  sub_100242CA4(buf);
  sub_100118D88(*(void *)(a1 + 48), 3);
  return sub_100242CD8(buf);
}

    if (a2)
    {
      uint64_t v6 = 0;
      if (!a3 || *(_OWORD *)a2 == xmmword_1008F1258)
      {
LABEL_25:
        *(_BYTE *)(a1 + 64) = v6;
        if (!a2) {
          goto LABEL_31;
        }
        goto LABEL_26;
      }

      if (a3->n128_u64[0] != (void)xmmword_1008F1258 || a3->n128_u64[1] != *((void *)&xmmword_1008F1258 + 1))
      {
        id v8 = 1;
        goto LABEL_23;
      }
    }

    uint64_t v6 = 0;
    goto LABEL_25;
  }

  uint64_t v6 = 2;
  if (!a3 || *(_OWORD *)a2 == xmmword_1008F1258) {
    goto LABEL_25;
  }
  if (a3->n128_u64[0] == (void)xmmword_1008F1258 && a3->n128_u64[1] == *((void *)&xmmword_1008F1258 + 1)) {
    goto LABEL_14;
  }
  id v8 = 3;
LABEL_23:
  *(_BYTE *)(a1 + 64) = v8;
LABEL_26:
  if (*(void *)a2 != (void)xmmword_1008F1258 || *(void *)(a2 + 8) != *((void *)&xmmword_1008F1258 + 1))
  {
    uint64_t result = *(__n128 *)a2;
    *(_OWORD *)a1 = *(_OWORD *)a2;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
    sub_100690834(a1);
  }
  return 10LL;
}

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
    sub_100691148(a1);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, 10LL);
}

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
    sub_100691238(a1);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, 10LL);
}

  uint64_t v7 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DefaultConnectionInterval");
  id v8 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v7 + 88LL))(v7, buf, __p, &v172);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v8) {
      goto LABEL_27;
    }
  }

  else if (!v8)
  {
    goto LABEL_27;
  }

  uint64_t v9 = v172;
  unint64_t v10 = (os_log_s *)qword_1008F7620;
  if ((v172 - 8) > 0x3E0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100696EEC();
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value %d ms for default LE connection interval",  buf,  8u);
      LOWORD(v9) = v172;
    }

    *(_WORD *)(a1 + 834) = v9;
  }

  *a2 = v8;
  return result;
}

  if (v162)
  {
    v163 = (char *)v162;
    operator delete(v162);
  }

  if (__p)
  {
    v166 = (char *)__p;
    operator delete(__p);
  }

  sub_100328B0C((uint64_t)&data);
  sub_100242FAC((uint64_t)v169);

  return v22;
}

LABEL_21:
}

  uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 112LL);
  if (!v17)
  {
    if (dword_1008D5FD8 <= 60
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 60LL)))
    {
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesGet]_block_invoke",  60LL,  "### Self identity not found");
    }

    goto LABEL_31;
  }

  if (dword_1008D5FD8 <= 30)
  {
    if (dword_1008D5FD8 == -1)
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 112LL);
    }

    int8x16_t v18 = CUPrintFlags32(v10, &unk_1006BA819);
    v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesGet]_block_invoke",  30LL,  "Self identity: %@, %@",  v17,  v19);
  }

  if (!*p_btSession) {
    return;
  }
LABEL_22:
  if (v2->_btDiscoveryAgent) {
    return;
  }
  __p = 0LL;
  v34 = 0LL;
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_10087FC30);
  }
  sub_100452724((uint64_t)off_1008D63D0, *p_btSession, (unint64_t *)&v2->_btDiscoveryAgent, (uint64_t *)&__p);
  if (!__p)
  {
    if (dword_1008D6300 <= 90
      && (dword_1008D6300 != -1 || _LogCategory_Initialize(&dword_1008D6300, 90LL)))
    {
      LogPrintF_safe(&dword_1008D6300, "-[CBStackClassicScannerBTStack activate]", 90LL, "### Create scan agent failed");
    }

    goto LABEL_46;
  }

  *(_OWORD *)v32 = *(_OWORD *)off_10087FBD8;
  sub_10044EB34((uint64_t *)__p, (uint64_t)v2->_btDiscoveryAgent, v32, (uint64_t)v2);
  if (qword_1008D63D8 != -1) {
    dispatch_once(&qword_1008D63D8, &stru_10087FC30);
  }
  int8x16_t v18 = off_1008D63D0;
  uint64_t v30 = __p;
  v31 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
  }

  unint64_t v21 = sub_100453844((uint64_t)v18, (uint64_t *)&v30, 0, -1);
  unint64_t v22 = v31;
  if (v31)
  {
    v23 = (unint64_t *)&v31->__shared_owners_;
    do
      uint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  if (!v21) {
    goto LABEL_42;
  }
  if (dword_1008D6300 <= 90)
  {
    if (dword_1008D6300 != -1 || _LogCategory_Initialize(&dword_1008D6300, 90LL))
    {
      v25 = CUPrintErrorCode((v21 + 310000));
      v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
      LogPrintF_safe( &dword_1008D6300,  "-[CBStackClassicScannerBTStack activate]",  90LL,  "### Scan start failed: %@",  v26);
    }

  v67 = v13;
  unint64_t v21 = [v13 length];
  unint64_t v22 = [v6 length];
  v23 = [v14 length];
  uint64_t v24 = 0LL;
  v65 = v14;
  if ((unint64_t)v21 <= 0x1C && v22 == (id)3 && v23 == (id)56)
  {
    v25 = 0LL;
    if (v16 - 32 >= 0xFFFFFFE1)
    {
      v63 = v20;
      obja = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v26 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v27 = v67;
      v28 = (char *)[v27 bytes];
      v70 = (char *)[v27 length] + (void)v28;
      v29 = v14;
      uint64_t v30 = (char *)[v29 bytes];
      v68 = (char *)[v29 length] + (void)v30;
      v31 = 1;
      do
      {
        v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithBytes:length:]( &OBJC_CLASS___NSMutableData,  "dataWithBytes:length:",  v30,  6LL));
        v33 = v30 + 6;
        v34 = v32;
        v35 = [v34 mutableBytes];
        v36 = *v35 & 0xC0;
        *v35 |= 0xC0u;
        -[NSMutableArray addObject:](obja, "addObject:", v34);
        v37 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
        v75 = v36 | v16;
        -[NSMutableData appendBytes:length:](v37, "appendBytes:length:", &v75, 1LL);
        v74 = (16 * v31) | 3;
        -[NSMutableData appendBytes:length:](v37, "appendBytes:length:", &v74, 1LL);
        -[NSMutableData appendBytes:length:]( v37, "appendBytes:length:", [v6 bytes], 3);
        else {
          v38 = ((_BYTE)v68 - (_BYTE)v33);
        }
        -[NSMutableData appendBytes:length:](v37, "appendBytes:length:", v33, v38);
        v39 = -[NSMutableData length](v37, "length");
        v40 = (_BYTE)v70 - (_BYTE)v28;
        uint64_t v30 = &v33[v38];
        v41 = v40;
        -[NSMutableData appendBytes:length:](v37, "appendBytes:length:", v28, v41);
        v28 += v41;
        -[NSMutableArray addObject:](v26, "addObject:", v37);
      }

      while (v31++ < 3);
      uint64_t v2 = v66;
      v20 = v63;
      v25 = v26;
      uint64_t v24 = obja;
    }
  }

  else
  {
    v25 = 0LL;
  }

  saAdvAddresses = v2->_saAdvAddresses;
  v44 = v24;
  v45 = saAdvAddresses;
  if (v44 == (NSMutableArray *)v45)
  {
  }

  else
  {
    v46 = v45;
    if ((v44 == 0LL) == (v45 != 0LL))
    {
      v49 = v44;
      goto LABEL_45;
    }

    v47 = -[NSMutableArray isEqual:](v44, "isEqual:", v45);

    if (!v47) {
      goto LABEL_51;
    }
  }

  saPayloadSegments = v2->_saPayloadSegments;
  v49 = v25;
  v50 = saPayloadSegments;
  if (v49 == (NSMutableArray *)v50)
  {

    goto LABEL_47;
  }

  v46 = v50;
  if ((v49 == 0LL) == (v50 != 0LL))
  {
LABEL_45:

LABEL_51:
    objb = v24;
    v52 = v65;
    v53 = CUPrintNSObjectOneLine(v2->_saAdvAddresses);
    v64 = (void *)objc_claimAutoreleasedReturnValue(v53);
    v54 = CUPrintNSObjectOneLine(v44);
    v69 = (void *)objc_claimAutoreleasedReturnValue(v54);
    v55 = CUPrintNSObjectOneLine(v2->_saPayloadSegments);
    v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
    v57 = CUPrintNSObjectOneLine(v25);
    v58 = objc_claimAutoreleasedReturnValue(v57);
    v59 = (void *)v58;
    saAdvertiseRate = v2->_saAdvertiseRate;
    if (saAdvertiseRate > 39)
    {
      if (saAdvertiseRate <= 44)
      {
        if (saAdvertiseRate == 40)
        {
          v61 = "Medium";
          goto LABEL_81;
        }

        if (saAdvertiseRate == 42)
        {
          v61 = "MediumMid";
          goto LABEL_81;
        }
      }

      else
      {
        switch(saAdvertiseRate)
        {
          case '-':
            v61 = "MediumHigh";
            goto LABEL_81;
          case '2':
            v61 = "High";
            goto LABEL_81;
          case '<':
            v61 = "Max";
            goto LABEL_81;
        }
      }
    }

    else if (saAdvertiseRate <= 14)
    {
      if (!saAdvertiseRate)
      {
        v61 = "Default";
        goto LABEL_81;
      }

      if (saAdvertiseRate == 10)
      {
        v61 = "Periodic";
        goto LABEL_81;
      }
    }

    else
    {
      switch(saAdvertiseRate)
      {
        case 15:
          v61 = "PeriodicHigh";
          goto LABEL_81;
        case 20:
          v61 = "Background";
          goto LABEL_81;
        case 30:
          v61 = "Low";
          goto LABEL_81;
      }
    }

    v61 = "?";
LABEL_81:
    if (v20 > 39)
    {
      if (v20 <= 44)
      {
        if (v20 == 40)
        {
          v62 = "Medium";
          goto LABEL_105;
        }

        if (v20 == 42)
        {
          v62 = "MediumMid";
          goto LABEL_105;
        }
      }

      else
      {
        switch(v20)
        {
          case '-':
            v62 = "MediumHigh";
            goto LABEL_105;
          case '2':
            v62 = "High";
            goto LABEL_105;
          case '<':
            v62 = "Max";
            goto LABEL_105;
        }
      }
    }

    else if (v20 <= 14)
    {
      if (!v20)
      {
        v62 = "Default";
        goto LABEL_105;
      }

      if (v20 == 10)
      {
        v62 = "Periodic";
        goto LABEL_105;
      }
    }

    else
    {
      switch(v20)
      {
        case 15:
          v62 = "PeriodicHigh";
          goto LABEL_105;
        case 20:
          v62 = "Background";
          goto LABEL_105;
        case 30:
          v62 = "Low";
LABEL_105:
          LogPrintF_safe( &dword_1008D6460,  "-[CBAdvertiserDaemon _updateSafetyAlertsPayload]",  30LL,  "Safety Alerts updated: saAD <%@> -> <%@>, saPD <%@> -> <%@>, rate %s -> %s",  v64,  v69,  v56,  v58,  v61,  v62);

LABEL_106:
          v2->_saAdvertiseRate = v20;
          objc_storeStrong((id *)&v2->_saAdvAddresses, objb);
          objc_storeStrong((id *)&v2->_saPayloadSegments, v25);
          v2->_saChanged = 1;
          goto LABEL_107;
      }
    }

    v62 = "?";
    goto LABEL_105;
  }

  v51 = -[NSMutableArray isEqual:](v49, "isEqual:", v50);

  if (!v51) {
    goto LABEL_51;
  }
LABEL_47:
  if (v20 != v2->_saAdvertiseRate) {
    goto LABEL_51;
  }
  v52 = v65;
  if (dword_1008D6460 <= 10 && (dword_1008D6460 != -1 || _LogCategory_Initialize(&dword_1008D6460, 10LL))) {
    LogPrintF_safe( &dword_1008D6460,  "-[CBAdvertiserDaemon _updateSafetyAlertsPayload]",  10LL,  "Safety Alerts unchanged");
  }
LABEL_107:
}

  if (!self->_addedController)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1008D9ED8);
    __int128 v14 = (void *)qword_1008D9EE0;
    if (!qword_1008D9EE0)
    {
      __int128 v14 = operator new(0x38uLL);
      *__int128 v14 = off_100880E70;
      v14[1] = off_100880F10;
      v14[2] = off_100880F38;
      v14[3] = &off_100880FE8;
      v14[4] = &off_100881000;
      v14[5] = 0LL;
      *((_BYTE *)v14 + 4_Block_object_dispose(&STACK[0x338], 8) = 0;
      qword_1008D9EE0 = (uint64_t)v14;
    }

    sub_100068480((uint64_t)v14, self);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1008D9ED8);
    self->_addedController = 1;
  }

  if (self->_powerStateNotifyToken == -1)
  {
    notify_register_check("com.apple.bluetooth.state", &self->_powerStateNotifyToken);
    notify_set_state(self->_powerStateNotifyToken, -[CBStackControllerBTStack powerState](self, "powerState"));
    notify_post("com.apple.bluetooth.state");
  }

  return v18;
}

        v23 = 0;
        goto LABEL_9;
      }

      if (!a7) {
        goto LABEL_21;
      }
      v29 = CBErrorF(4294960553LL, "Relay message too big: %zu vs %u", (size_t)v20, 998);
      v27 = (void *)objc_claimAutoreleasedReturnValue(v29);
    }
  }

  else
  {
    if (!a7) {
      goto LABEL_21;
    }
    v26 = CBErrorF(4294960591LL, "No destination address");
    v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
  }

  v112 = 72;
  getsockopt(dword_1008D6D08, 2, 1078490131, &v147, &v112);
  cfmakeraw(&v147);
  cfsetspeed(&v147, v5);
  if (a1 == 2 || a1 == 1)
  {
    v29 = v147.c_iflag | 0x10;
    uint64_t v30 = v147.c_cflag & 0xFFFFFFFFFFFCCFFFLL | 0x1000;
  }

  else
  {
    if (a1) {
      return 101LL;
    }
    v29 = v147.c_iflag | 4;
    uint64_t v30 = 232192LL;
  }

  v147.c_iflag = v29;
  v147.c_cflag = v30;
  setsockopt(dword_1008D6D08, 2, -2142735340, &v147, 0x48u);
  dword_1008DC2D8 = 0;
  dword_1008DC2DC = 0;
  sub_1000BC2FC(&stru_1008DC2E0);
  if (sub_1000BC170((pthread_t *)&qword_1008DC310, (void *(__cdecl *)(void *))sub_100087458, 0LL))
  {
    sub_1000BC20C((_opaque_pthread_t *)qword_1008DC310, 63);
    sub_1000FC0B8();
    return 0LL;
  }

  else
  {
    sub_1000AFE20(104LL);
    return sub_100087020();
  }

  v27 = v9;
  v28 = sub_1000B17F4(v9);
  if (!v28) {
    return;
  }
  v29 = v28;
  v107 = v27;
  v108 = v3;
  uint64_t v30 = v6;
  bzero(v28, v27);
  char *v29 = 1;
  if (!word_1008DD568)
  {
    *(void *)&v111 = 0LL;
    goto LABEL_41;
  }

  v33 = 0LL;
  *(void *)&v111 = 0LL;
  v34 = qword_1008DD570;
  *(void *)&v32 = 136446210LL;
  v110 = v32;
  while (1)
  {
    v35 = *((unsigned __int8 *)v34 + 8) >= 0x20u ? 32LL : *((unsigned __int8 *)v34 + 8);
    __chkstk_darwin(v31, (v35 + 1));
    v37 = (char *)&v106 - v36;
    bzero((char *)&v106 - v36, v38);
    memcpy(v37, (const void *)*v34, v35);
    v37[v35] = 0;
    v42 = "Skipping";
LABEL_32:
    v31 = sub_1000A86F0();
    if ((_DWORD)v31)
    {
      sub_1001EE134( (uint64_t)"%s service %s requiresEncryption=%d unpublishing=%d, pduCounter %d",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  (uint64_t)v42);
      v50 = (os_log_s *)sub_100086554(0x51u);
      v31 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v31)
      {
        v51 = sub_1001EDDCC();
        *(_DWORD *)buf = v110;
        v113 = v51;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    ++v33;
    v34 += 9;
  }

  if (!(_DWORD)v30 || v30 != v33)
  {
    v29[v5] = v35 + 5;
    v29[v5 + 1] = *((_BYTE *)v34 + 18);
    v29[v5 + 2] = *((_BYTE *)v34 + 19);
    v29[v5 + 3] = *((_DWORD *)v34 + 3);
    v39 = v5 + 4;
    v40 = (v5 + 5);
    v29[v39] = v35;
    memmove(&v29[v40], (const void *)*v34, v35);
    v29[(v40 + v35)] = 0;
    v41 = *((_BYTE *)v34 + 22);
    v29[(v40 + v35)] = v41;
    v29[(v40 + v35)] = v41 | (2 * *((_BYTE *)v34 + 23));
    uint64_t v5 = v40 + v35 + 1;
    *(void *)&v111 = (v111 + 1);
    v42 = "Sending";
    goto LABEL_32;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Exiting due to limit found for peerID %d, lNbServices %d, i %d, singleByteLengthIndex %d",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v3);
    v59 = (os_log_s *)sub_100086554(0x51u);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      v60 = sub_1001EDDCC();
      *(_DWORD *)buf = v110;
      v113 = v60;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  sub_10018C118((uint64_t)sub_1000AF944);
  v38 = sub_10012D7D4((unsigned __int16 *)v59);
  if (!v38)
  {
LABEL_5:
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Couldn't begin Bud Swap 2.0 procedure for %:, couldn't find the device",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)a1);
      uint64_t v17 = (os_log_s *)sub_100086554(0x59u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001EE2A0();
    return 120LL;
  }

  v39 = v38;
  if (sub_10018D99C())
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Failure in sending LMP Halt command to chipset for lmHandle %d with BT address %:",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v39);
      v47 = (os_log_s *)sub_100086554(0x59u);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    int8x16_t v18 = 114LL;
    sub_100081014(a1, 114);
  }

  else
  {
    int8x16_t v18 = 0LL;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Successfully sent LMP Halt command to chipset for lmHandle %d with BT address %:",  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v39);
      v55 = (os_log_s *)sub_100086554(0x59u);
      int8x16_t v18 = 0LL;
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        v56 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        v61 = v56;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        return 0LL;
      }
    }
  }

  return v18;
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Rejecting connect request %!", v38, v39, v40, v41, v42, v43, v44, 2901LL);
    v45 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  v46 = sub_100174B2C( (uint64_t)sub_1000DA9EC,  (uint64_t)sub_1000D9FA4,  (uint64_t)sub_1000DA244,  a3,  qword_1008DFDB0 + 32,  0,  (uint64_t)&unk_1008831A8);
  if ((_DWORD)v46)
  {
    v47 = v46;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_L2CAP_Accept (reject) failed %!", v48, v49, v50, v51, v52, v53, v54, v47);
      v55 = (os_log_s *)sub_100086554(3u);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
    }
  }

    v23 = 0;
    return sub_1000DC0F4(*(unsigned __int16 *)(v21 + (v20 << 6) + 38), a1, a2, a3, v23, a5);
  }

  if (!a3) {
    goto LABEL_21;
  }
  v25 = a3;
  v26 = a2;
  while (1)
  {
    v27 = *v26++;
    v28 = v27 - 1;
    if (!--v25) {
      goto LABEL_21;
    }
  }

  sub_1001EE2A0();
  if (MEMORY[0x86] == 3) {
    return 101LL;
  }
LABEL_24:
  sub_1001EE2A0();
  return 101LL;
}

  void *v5 = v2;
}

  v20 = (a2 >> 7) & 1;
  unint64_t v21 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  unint64_t v22 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v21;
  v23 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  if (v22 > 0x3F)
  {
    if (v12 < v23)
    {
      v25 = *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
      if (((*(_BYTE *)(sub_10017AB4C(a1) + 54) + (_BYTE)v25) & 0x3Fu) <= v12) {
        goto LABEL_41;
      }
    }
  }

  else
  {
    if (v23 > v12) {
      goto LABEL_41;
    }
    uint64_t v24 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  }

  v26 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
  v27 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  v28 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  if (v26 >= v27)
  {
    if (v28 > v12) {
      goto LABEL_41;
    }
LABEL_31:
    goto LABEL_32;
  }

  if (v28 > v12) {
    goto LABEL_31;
  }
LABEL_32:
  v29 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v29
    || v29 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
  {
    uint64_t v30 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    v31 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    if (v30 <= v29)
    {
      if (v29 - v31 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL)) {
        goto LABEL_41;
      }
    }

    else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
              + (_BYTE)v31) & 0x3Fu) < v29)
    }
    {
      goto LABEL_41;
    }
  }

  if ((!v20 || !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL))
    && !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 16LL))
  {
    v64 = sub_10017AB4C(a1);
    sub_10017B47C(*(unsigned __int16 **)(v64 + 112));
    v55 = (uint64_t)a1;
    v56 = (a2 >> 8) & 0x3F;
LABEL_96:
    sub_100181EEC(v55, v56, v20);
    return 0LL;
  }

  *(_WORD *)(v4 + 6) = a2;
  uint64_t result = sub_1001EC434(*(void *)(v4 + 176));
  if (!(_DWORD)result) {
    return sub_100181800(a1);
  }
  return result;
}

  *(_BYTE *)(a1 + 125) = 0;
  if (*(_BYTE *)(a1 + 316))
  {
    if (*(_DWORD *)(a1 + 132) == 5) {
      sub_1001B7AA0(a1, a2);
    }
LABEL_35:
    if (*(_DWORD *)(a1 + 132) == 5) {
      sub_1001B7AA0(a1, 0LL);
    }
    return;
  }

  if (*(_BYTE *)(a1 + 70))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"FastLEConnection:Skipping LE_GAP_ReadRemoteVersionInformation on encryptionStartedCb",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v39);
      v28 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v41 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    goto LABEL_35;
  }

  v29 = sub_1001B7A10(a1);
  if (!(_DWORD)v29)
  {
    *(_BYTE *)(a1 + 126) = 1;
    if (*(_DWORD *)(a1 + 132) != 6) {
      *(_DWORD *)(a1 + 132) = 1;
    }
    goto LABEL_35;
  }

  uint64_t v30 = v29;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"LE_GAP_ReadRemoteVersionInformation failed %!", v31, v32, v33, v34, v35, v36, v37, v30);
    v38 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

  *(_DWORD *)(a1 + 132) = 5;
}

    sub_100657858();
LABEL_22:
    v29 = a1;
    uint64_t v30 = 8;
LABEL_23:
    sub_1001CBE38(v29, v30, (char *)v7);
    return;
  }

  v301 = 0u;
  v302 = 0u;
  v299 = 0u;
  v300 = 0u;
  id v8 = (uint64_t *)sub_100184F2C((uint64_t)a1);
  uint64_t v7 = (uint64_t)v8;
  if (!v8)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v44, v45, v46, v47, v48, v49, v50, v297);
    v51 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  sub_100185340(v8);
  uint64_t v9 = *((unsigned __int8 *)a1 + 70);
  if (v9 != 1) {
    goto LABEL_8;
  }
  if (!sub_10018550C(v7, 36))
  {
    v60 = sub_100185414();
    sub_1001EE134( (uint64_t)"Initiator device was not in the proper state. State is %s.",  v61,  v62,  v63,  v64,  v65,  v66,  v67,  (uint64_t)v60);
    v68 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  uint64_t v9 = *((unsigned __int8 *)a1 + 70);
LABEL_8:
  if (v9) {
    goto LABEL_11;
  }
  if (!sub_10018550C(v7, 37))
  {
    v108 = sub_100185414();
    sub_1001EE134( (uint64_t)"Initiator device was not in the proper state. State is %s.",  v109,  v110,  v111,  v112,  v113,  v114,  v115,  (uint64_t)v108);
    v116 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v116, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  uint64_t v9 = *((unsigned __int8 *)a1 + 70);
LABEL_11:
  if (v9 == 1) {
    unint64_t v10 = (_OWORD *)(v7 + 457);
  }
  else {
    unint64_t v10 = (_OWORD *)(v7 + 473);
  }
  *unint64_t v10 = *a2;
  v303 = 0u;
  v304 = 0u;
  dispatch_source_t v11 = *(void *)v7 + 63LL;
  if (*(_BYTE *)(*(void *)v7 + 70LL))
  {
    uint64_t v12 = *(void *)v7 + 48LL;
  }

  else
  {
    uint64_t v12 = *(void *)v7 + 63LL;
    dispatch_source_t v11 = *(void *)v7 + 48LL;
  }

  v69 = sub_10011182C( (_OWORD *)(v7 + 376),  (_OWORD *)(v7 + 457),  (_OWORD *)(v7 + 473),  1651797093,  v12,  v11,  (char *)&v303,  32);
  if ((_DWORD)v69)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to generate LTK %!", v70, v71, v72, v73, v74, v75, v76, v69);
      v77 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001EE134((uint64_t)"smpCalculateLtkAndMacKey Failed %!", v78, v79, v80, v81, v82, v83, v84, v69);
    v85 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
LABEL_103:
    sub_100657F74();
    goto LABEL_22;
  }

  v86 = v304;
  *(_OWORD *)(v7 + 40_Block_object_dispose(&STACK[0x338], 8) = v303;
  *(_OWORD *)(v7 + 524) = v86;
  v87 = *(unsigned __int8 *)(v7 + 81);
  if (v87 != 16) {
    bzero((void *)(v7 + 524 + v87), 16 - v87);
  }
  *(_BYTE *)(v7 + 424) = 1;
  v88 = *(unsigned __int8 *)(v7 + 16);
  if (v88 != 6)
  {
    if (v88 == 5)
    {
      if (*((_BYTE *)a1 + 70) != 1)
      {
        sub_100185420(v7, 39);
        v165 = sub_1001CC484((__int128 **)v7);
        if ((_DWORD)v165)
        {
          v166 = v165;
          sub_1001EE134( (uint64_t)"Failed to send DHKey value with status %!",  v167,  v168,  v169,  v170,  v171,  v172,  v173,  v166);
          v174 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v174, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
          goto LABEL_103;
        }

        return;
      }

      v126 = sub_1001D4A70((uint64_t)a1, (__int128 *)(v7 + 473));
      if ((_DWORD)v126)
      {
        v127 = v126;
        sub_1001EE134( (uint64_t)"Failed to send Nb to central with status %!",  v128,  v129,  v130,  v131,  v132,  v133,  v134,  v127);
        v135 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v135, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        goto LABEL_103;
      }
    }

    else
    {
      if (v88 == 1) {
        goto LABEL_65;
      }
      if (!*((_BYTE *)a1 + 70))
      {
        v303 = 0uLL;
        v187 = *(unsigned __int8 *)(v7 + 441) | (*(unsigned __int8 *)(v7 + 426) << 8) | (*(unsigned __int8 *)(v7 + 427) << 16) | (*(unsigned __int8 *)(v7 + 428) << 24);
        v188 = *(_BYTE *)(v7 + 489);
        v189 = *(_OWORD *)(v7 + 328);
        v299 = *(_OWORD *)(v7 + 312);
        v300 = v189;
        v190 = *(_OWORD *)(v7 + 168);
        v301 = *(_OWORD *)(v7 + 152);
        v302 = v190;
        if (((v187 >> v188) & 1) != 0) {
          v191 = -127;
        }
        else {
          v191 = 0x80;
        }
        v192 = sub_1001116D0(&v299, &v301, (__int128 *)(v7 + 473), v191, &v303);
        if ((_DWORD)v192)
        {
          v193 = v192;
          sub_1001EE134( (uint64_t)"Failed to generate confirmation value %!",  v194,  v195,  v196,  v197,  v198,  v199,  v200,  v193);
          v201 = (os_log_s *)sub_100086554(0x43u);
          if (!os_log_type_enabled(v201, OS_LOG_TYPE_ERROR)) {
            goto LABEL_22;
          }
        }

        else
        {
          if ((void)v303 != *(void *)(v7 + 104) || *((void *)&v303 + 1) != *(void *)(v7 + 112))
          {
            sub_1001EE134( (uint64_t)"pairing confirmation does not match %!",  v222,  v223,  v224,  v225,  v226,  v227,  v228,  0LL);
            v229 = (os_log_s *)sub_100086554(0x43u);
            if (!os_log_type_enabled(v229, OS_LOG_TYPE_ERROR)) {
              goto LABEL_42;
            }
LABEL_143:
            sub_100657858();
            goto LABEL_42;
          }

          *(void *)(v7 + 104) = 0LL;
          *(void *)(v7 + 112) = 0LL;
          v263 = ++*(_BYTE *)(v7 + 489);
          if (v263 > 0x13)
          {
            sub_100185420(v7, 39);
            v287 = sub_1001CC484((__int128 **)v7);
            if (!(_DWORD)v287) {
              return;
            }
            v288 = v287;
            sub_1001EE134( (uint64_t)"Failed to send DHKey value with status %!",  v289,  v290,  v291,  v292,  v293,  v294,  v295,  v288);
            v296 = (os_log_s *)sub_100086554(0x43u);
            if (!os_log_type_enabled(v296, OS_LOG_TYPE_ERROR)) {
              goto LABEL_22;
            }
          }

          else
          {
            v264 = sub_1001CC98C(v7);
            if (!(_DWORD)v264)
            {
              v285 = v7;
              v286 = 35;
              goto LABEL_170;
            }

            v265 = v264;
            sub_1001EE134( (uint64_t)"smpDoOneLeSecuredConnectionPasskeyAuthItteration returned %!",  v266,  v267,  v268,  v269,  v270,  v271,  v272,  v265);
            v273 = (os_log_s *)sub_100086554(0x43u);
            if (!os_log_type_enabled(v273, OS_LOG_TYPE_ERROR)) {
              goto LABEL_22;
            }
          }
        }

    v33 = 8;
    goto LABEL_22;
  }

  sub_1001EE134((uint64_t)"Compromised device, dropping keys", v42, v43, v44, v45, v46, v47, v48, v86);
  v49 = (os_log_s *)sub_100086554(0x43u);
  if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
    goto LABEL_32;
  }
LABEL_13:
  sub_100657858();
LABEL_32:
  sub_1001D4D70((char *)v6);
}

  if ((v5[74] & 4) != 0)
  {
    v5[75] |= 4u;
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"We were not expecting CSRK...", v32, v33, v34, v35, v36, v37, v38, v48);
    v39 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  sub_1001D4D70(v5);
}

          int8x16_t v18 = -12;
          goto LABEL_28;
        }

        switch((_DWORD)v5)
        {
          case 1:
            int8x16_t v18 = -15;
            goto LABEL_28;
          case 0x11:
            goto LABEL_21;
          case 0x13:
            v19 = (os_log_s *)qword_1008F7730;
            if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = 19;
              _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Received power-off notice input report (ID %u)",  buf,  8u);
            }

            return;
        }

  v26 = *(unsigned int *)(a1 + 320);
  if ((_DWORD)v4 != (_DWORD)v26)
  {
    v27 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
    {
      v28 = *(void *)(a1 + 8LL * a2 + 296);
      v29 = *(void *)(a1 + 272 + 8 * v4);
      uint64_t v30 = *(void *)(a1 + 272 + 8 * v26);
      v31 = *(void *)(a1 + 8LL * *(unsigned int *)(a1 + 360) + 336);
      v32 = sub_10026FA80(*(void *)(a1 + 184));
      v33 = *(unsigned __int16 *)(a1 + 266);
      *(_DWORD *)buf = 136447490;
      v39 = v28;
      v40 = 2082;
      v41 = v29;
      v42 = 2082;
      v43 = v30;
      v44 = 2082;
      v45 = v31;
      v46 = 2048;
      v47 = v32;
      v48 = 1024;
      v49 = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "Input: %{public}s. State: %{public}s -> %{public}s. SendState %{public}s, %zu, %hu",  buf,  0x3Au);
    }
  }

  return sub_100242FAC((uint64_t)v37);
}

  unint64_t v10 = 150LL;
LABEL_22:
  __int128 v14 = &off_10087FAA8;
  if (v15) {
    sub_1002CD254(v15);
  }
  return v10;
}

  unint64_t v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFF08) {
      dispatch_source_t v11 = "enabled";
    }
    else {
      dispatch_source_t v11 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "support for Periodic Advertising Advertiser is %s",  buf,  0xCu);
  }

  unint64_t v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFF18) {
      dispatch_source_t v11 = "enabled";
    }
    else {
      dispatch_source_t v11 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "support for Periodic Advertising Synchronizer is %s",  buf,  0xCu);
  }

  unint64_t v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFF28) {
      dispatch_source_t v11 = "enabled";
    }
    else {
      dispatch_source_t v11 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "support for Periodic Advertising Sync Transfer Sender is %s",  buf,  0xCu);
  }

  unint64_t v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFF38) {
      dispatch_source_t v11 = "enabled";
    }
    else {
      dispatch_source_t v11 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "support for Periodic Advertising Sync Transfer Recipient is %s",  buf,  0xCu);
  }

  unint64_t v10 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F0080) {
      dispatch_source_t v11 = "enabled";
    }
    else {
      dispatch_source_t v11 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "support for Enhanced Connections V2 is %s",  buf,  0xCu);
  }

      v40 = 0LL;
      goto LABEL_26;
    }

    LOBYTE(v59) = 0;
    *(_DWORD *)buf = 0;
    *(_DWORD *)buf = *v25;
    LOBYTE(v59) = 0;
    v27 = v52;
    v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  (char *)[v27 bytes] + v23,  v25[1],  0));
    if (v28)
    {
      v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@, %s core",  v50,  buf));
      uint64_t v30 = sub_10035D744((uint64_t)v29, v28, v29, v51);
      v31 = (void *)objc_claimAutoreleasedReturnValue(v30);

      if (v31)
      {
        v32 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v51,  "objectForKeyedSubscript:",  @"crashlogs"));
        v56[0] = @"core";
        v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  buf,  4LL));
        v56[1] = @"crashlog";
        v57[0] = v33;
        v57[1] = v31;
        v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v57,  v56,  2LL));
        [v32 addObject:v34];
      }
    }

    else
    {
      v35 = (os_log_s *)qword_1008F7568;
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
        sub_100671AC4(&v54, v55, v35);
      }
    }

    v36 = v25[1];

    ++v22;
    v23 += v36;
  }

  while ((unint64_t)[v27 length] > v23);
  if ([v12 count] != (id)v22
    && os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
  {
    sub_100671A58();
  }

  v53 = 0LL;
  v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization dataWithJSONObject:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "dataWithJSONObject:options:error:",  v51,  1LL,  &v53));
  v38 = v53;
  v39 = v38;
  if (!v37 || v38)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
      sub_1006719E4();
    }
    v40 = 0LL;
  }

  else
  {
    v40 = v37;
  }

LABEL_26:
  return v40;
}

  sub_10036CFB0(a1, a3);
  uint64_t v24 = 1LL;
LABEL_39:
  sub_100242FAC((uint64_t)v29);
  return v24;
}

        id v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      uint64_t v6 = [v5 countByEnumeratingWithState:&v14 objects:v21 count:16];
    }

    while (v6);
  }

  [*(id *)(a1 + 224) removeAllObjects];
  [*(id *)(a1 + 80) removeAllObjects];
  [*(id *)(a1 + 304) removeAllObjects];
  sub_1003A0DAC(a1 + 280, *(void **)(a1 + 288));
  *(void *)(a1 + 28_Block_object_dispose(&STACK[0x338], 8) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 280) = a1 + 288;
  sub_1003A0DFC(a1 + 416, *(void **)(a1 + 424));
  *(void *)(a1 + 424) = 0LL;
  *(void *)(a1 + 432) = 0LL;
  *(void *)(a1 + 416) = a1 + 424;
  return sub_1003909B4(a1, a2);
}

  [*(id *)(a1 + 240) removeObject:v7];
}

      if (__p)
      {
        v19 = (char *)__p;
        operator delete(__p);
      }
    }

    else
    {
      return 7LL;
    }
  }

  return v4;
}

    sub_100242F54((uint64_t)__p);
    unint64_t v22 = sub_100404EB8();
    v23 = operator new(0x20uLL);
    v23[4] = 1;
    *(void *)v23 = &off_100895A18;
    *((void *)v23 + 2) = a2;
    *((_DWORD *)v23 + 6) = 0;
    *((_DWORD *)v23 + 7) = a6;
    sub_100405744(v22, v23);
    goto LABEL_22;
  }

  v19 = 0LL;
  while (1)
  {
    v20 = *(void *)&v18[v19];
    if (*(void *)(v20 + 8) == a2) {
      break;
    }
    v19 += 8LL;
    if (&v18[v19] == v17) {
      goto LABEL_18;
    }
  }

  if (a5) {
    goto LABEL_24;
  }
  v26 = *(_DWORD *)(v20 + 24) & ~a3;
  *(_DWORD *)(v20 + 24) = v26;
  if (!v26 && !*(_DWORD *)(v20 + 20))
  {
    v29 = &v18[v19];
    uint64_t v30 = &v18[v19 + 8];
    v31 = v17 - v30;
    if (v17 != v30) {
      memmove(&v18[v19], v30, v17 - v30);
    }
    *(void *)(a1 + 12_Block_object_dispose(&STACK[0x338], 8) = &v29[v31];
    operator delete((void *)v20);
    goto LABEL_21;
  }

  v27 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
  {
    v28 = *(_DWORD *)(v20 + 20);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v26;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v28;
    _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "There is at least one connected (0x%08x) or pending (0x%08x) service left",  (uint8_t *)&buf,  0xEu);
  }

  uint64_t v24 = 0LL;
LABEL_25:
  sub_100242FAC((uint64_t)__p);
  return v24;
}

  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_100898328);
  }
  uint64_t v6 = sub_100537F20();
  uint64_t v7 = sub_1001E689C(v6);
  if ((_DWORD)v7)
  {
    a1 = v7;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067F558();
    }
    goto LABEL_31;
  }

  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_100898328);
  }
  id v8 = sub_100537F2C();
  uint64_t v9 = sub_1001E6AEC(v8);
  if ((_DWORD)v9)
  {
    a1 = v9;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067F4F8();
    }
    goto LABEL_31;
  }

  dispatch_source_t v11 = (void (*)(void))off_1008F1018;
  if (off_1008F1018)
  {
    off_1008F1018 = 0LL;
    v11(0LL);
  }

  sub_100242CD8(&v21);
  return v12;
}

      int8x16_t v16 = sub_100404FE8();
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3321888768LL;
      v18[2] = sub_1004E81E4;
      v18[3] = &unk_10089D328;
      v18[4] = &v25;
      v18[5] = a1;
      v19 = &off_10087FAA8;
      v20 = v24;
      if (v24) {
        sub_1002CD1E0((uint64_t)v24);
      }
      sub_1004054B4(v16, v18);
      v19 = &off_10087FAA8;
      if (v20) {
        sub_1002CD254(v20);
      }
      goto LABEL_25;
    }

    __int128 v14 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Channel Classification data found", buf, 2u);
    }

    id v15 = sub_10025DBF4(v13, (uint64_t)&v23);
    *((_DWORD *)v26 + 6) = v15;
    if (!v15) {
      goto LABEL_21;
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
  {
    sub_100689118();
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_1006899C0();
  }
LABEL_23:
  reply = xpc_dictionary_create_reply(xdict);
  __int128 v13 = reply;
  if (reply)
  {
    xpc_dictionary_set_int64(reply, "kCBMsgArgResult", v10);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v13);
    xpc_release(v13);
  }
}

  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
    sub_1006899C0();
  }
LABEL_23:
  reply = xpc_dictionary_create_reply(xdict);
  __int128 v13 = reply;
  if (reply)
  {
    xpc_dictionary_set_int64(reply, "kCBMsgArgResult", v10);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v13);
    xpc_release(v13);
  }
}

        ++v16;
        int8x16_t v18 = v19;
        break;
      default:
LABEL_22:
        int8x16_t v18 = 3306LL;
        break;
    }

    v17 += 2;
    --v6;
  }

  while (v6);
  v26 = v16 == 0;
  a3 = v33;
  if (!v26)
  {
    v27 = sub_100403258(v32 + 344, (unint64_t *)&v34);
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(*v27 + 8LL) + 40LL))( *(void *)(*v27 + 8LL),  v15,  v14);
    v28 = sub_1000E93E8(a2, v33, 20, 0);
    if (v28)
    {
      v29 = v28;
      uint64_t v30 = (os_log_s *)qword_1008F75D0;
      if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR))
      {
        sub_1003CF00C(v34, buf);
        if (SBYTE3(v41) >= 0) {
          v31 = buf;
        }
        else {
          v31 = *(_BYTE **)buf;
        }
        *(_DWORD *)v35 = 136446466;
        *(void *)&v35[4] = v31;
        v36 = 1024;
        v37 = v29;
        _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Failed to respond to set attribute value request on device %{public}s - result was %{bluetooth:OI_STATUS}u",  v35,  0x12u);
        if (SBYTE3(v41) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }

    return;
  }

    unint64_t v10 = 1LL;
    goto LABEL_22;
  }

  uint64_t v6 = v14;
  uint64_t v7 = sub_10012D7D4(v14);
  id v8 = sub_1002E8D94();
  (*(void (**)(uint64_t, unsigned __int16 *, uint64_t))(*(void *)v8 + 560LL))(v8, v6, v7);
  uint64_t v9 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v9 + 1032LL))(v9, v7, 1LL, 0LL))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      sub_1005CC0D4((uint64_t)off_1008D5F28, v3, (uint64_t)buf);
      sub_1006978B4();
    }

    goto LABEL_21;
  }

  id v15 = *(_DWORD *)(a1 + 20);
  Current = CFAbsoluteTimeGetCurrent();
  uint64_t v17 = *(_DWORD *)(a1 + 28);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_1008A3078);
  }
  sub_10040F134((uint64_t)off_1008D6780);
  if (qword_1008D6788 != -1) {
    dispatch_once(&qword_1008D6788, &stru_1008A3078);
  }
  v20[0] = v15;
  v20[1] = 0;
  v20[2] = a3;
  v20[3] = 0;
  unint64_t v21 = Current;
  unint64_t v22 = v11;
  v23 = a4;
  uint64_t v24 = 0;
  v25 = 0;
  v26 = v17;
  v27 = 0;
  sub_10040EE8C((uint64_t)off_1008D6780, v20);

  return a1;
}

    uint64_t v12 = (os_log_s *)qword_1008F7668;
    if (os_log_type_enabled((os_log_t)qword_1008F7668, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v13 = sub_1005C37D0(v7);
      __int128 v14 = "disconnect";
      *(_DWORD *)__p = 138544130;
      *(void *)&__p[4] = v6;
      if ((_DWORD)a3) {
        __int128 v14 = "connect";
      }
      *(_WORD *)&__p[12] = 2080;
      *(void *)&__p[14] = v14;
      v26 = 2082;
      v27 = a2;
      v28 = 2080;
      v29 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "PowerLogger device %{public}@ %s for bundleIDs %{public}s peerType %s",  __p,  0x2Au);
    }

    id v15 = objc_autoreleasePoolPush();
    int8x16_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  a2,  @"BundleID"));
    v24[0] = v16;
    v23[1] = @"Connect";
    uint64_t v17 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a3));
    int8x16_t v18 = (void *)v17;
    if (v8) {
      v19 = v8;
    }
    else {
      v19 = @"Unknown";
    }
    v24[1] = v17;
    v24[2] = v19;
    v23[2] = @"CBUUID";
    v23[3] = @"Name";
    if (v10) {
      v20 = v10;
    }
    else {
      v20 = @"Unknown";
    }
    v24[3] = v20;
    v23[4] = @"PeerType";
    unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v7));
    v24[4] = v21;
    unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v24,  v23,  5LL));

    PLLogRegisteredEvent(35LL, @"LEConnectionStateEvent", v22, 0LL);
    objc_autoreleasePoolPop(v15);

    goto LABEL_32;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10069FECC();
  }
LABEL_32:
}

void *sub_100012440(void *result)
{
  if (result[4] == *(void *)(result[5] + 48LL))
  {
    uint64_t v1 = result;
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserEnsureStarted]_block_invoke_3",  30LL,  "BLE advertiser forced update fired: %@",  v1[6]);
    }

    uint64_t v2 = *(void **)(v1[5] + 48LL);
    if (v2)
    {
      id v3 = v2;
      dispatch_source_cancel(v3);
      uint64_t v4 = v1[5];
      uint64_t v5 = *(void **)(v4 + 48);
      *(void *)(v4 + 4_Block_object_dispose(&STACK[0x338], 8) = 0LL;
    }

    else {
      return [*(id *)(v1[5] + 424) forceNonConnectableAddressReadAndUpdate:2];
    }
  }

  return result;
}

LABEL_125:
                      v84->_bleAdvertiserSpatialValid = 1;
LABEL_126:

                      return v2;
                    }

                    if (-[NSMutableArray count](v93, "count") && !v84->_bleAdvertiserSpatialLingerTimer)
                    {
                      if (dword_1008D5FD8 <= 30
                        && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
                      {
                        LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserUpdateSpatialInteraction]",  30LL,  "BLE advertiser: spatial linger start: %d seconds",  4);
                      }

                      -[CBAdvertiserDaemon setSpatialInteractionIdentifiers:]( v4,  "setSpatialInteractionIdentifiers:",  &__NSArray0__struct);
                      v78 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)v84->_dispatchQueue);
                      v79 = v84->_bleAdvertiserSpatialLingerTimer;
                      v84->_bleAdvertiserSpatialLingerTimer = (OS_dispatch_source *)v78;
                      v80 = v78;

                      handler[0] = _NSConcreteStackBlock;
                      handler[1] = 3221225472LL;
                      handler[2] = sub_100013510;
                      handler[3] = &unk_10087EEC8;
                      handler[4] = v84;
                      dispatch_source_set_event_handler(v80, handler);
                      CUDispatchTimerSet(v80, 4.0, -1.0, 1.0);
                      dispatch_activate(v80);

                      v65 = v93;
                      goto LABEL_125;
                    }

                    if (!-[CBAdvertiserDaemon spatialInteractionFlags](v4, "spatialInteractionFlags"))
                    {
                      v74 = (void *)objc_claimAutoreleasedReturnValue( -[CBAdvertiserDaemon spatialInteractionIdentifiers]( v4,  "spatialInteractionIdentifiers"));
                      if (v74
                        || (v74 = (void *)objc_claimAutoreleasedReturnValue( -[CBAdvertiserDaemon spatialInteractionUWBConfigData]( v4,  "spatialInteractionUWBConfigData"))) != 0LL)
                      {
                      }

                      else
                      {
                        v82 = (void *)objc_claimAutoreleasedReturnValue( -[CBAdvertiserDaemon spatialInteractionPresenceConfigData]( v4,  "spatialInteractionPresenceConfigData"));

                        if (!v82) {
                          goto LABEL_125;
                        }
                      }
                    }

                    if (dword_1008D5FD8 <= 30
                      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
                    {
                      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserUpdateSpatialInteraction]",  30LL,  "BLE advertiser: spatial clear");
                    }

                    -[CBAdvertiserDaemon setSpatialInteractionFlags:](v4, "setSpatialInteractionFlags:", 0LL);
                    -[CBAdvertiserDaemon setSpatialInteractionIdentifiers:]( v4,  "setSpatialInteractionIdentifiers:",  0LL);
                    -[CBAdvertiserDaemon setSpatialInteractionUWBConfigData:]( v4,  "setSpatialInteractionUWBConfigData:",  0LL);
                    -[CBAdvertiserDaemon setSpatialInteractionPresenceConfigData:]( v4,  "setSpatialInteractionPresenceConfigData:",  0LL);
                    uint64_t v2 = 1;
                    goto LABEL_125;
                  }
                }

                else
                {
                }

                -[CBAdvertiserDaemon setSpatialInteractionPresenceConfigData:]( v4,  "setSpatialInteractionPresenceConfigData:",  v61);
                uint64_t v2 = 1;
                goto LABEL_93;
              }
            }

            else
            {
            }

            -[CBAdvertiserDaemon setSpatialInteractionUWBConfigData:](v4, "setSpatialInteractionUWBConfigData:", v56);
            uint64_t v2 = 1;
            goto LABEL_86;
          }
        }

        else
        {
        }

        -[CBAdvertiserDaemon setSpatialInteractionIdentifiers:](v4, "setSpatialInteractionIdentifiers:", v51);
        uint64_t v2 = 1;
        goto LABEL_79;
      }

      v88 = (NSMutableSet *)objc_claimAutoreleasedReturnValue( -[RPIdentity authTagForData:type:error:]( v84->_identitySelf,  "authTagForData:type:error:",  v8,  2LL,  0LL));
      if (v88)
      {
        if ((unint64_t)-[NSMutableArray count](v92, "count") >= 3)
        {
          do
            -[NSMutableArray removeLastObject](v92, "removeLastObject");
          while ((unint64_t)-[NSMutableArray count](v92, "count") > 2);
        }

        if ((unint64_t)-[NSMutableArray count](v89, "count") >= 3)
        {
          do
            -[NSMutableArray removeLastObject](v89, "removeLastObject");
          while ((unint64_t)-[NSMutableArray count](v89, "count") > 2);
        }

        v44 = v89;
        if (!v89) {
          v44 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        }
        v89 = v44;
        -[NSMutableArray insertObject:atIndex:](v44, "insertObject:atIndex:", v8, 0LL);
        v45 = v92;
        if (!v92) {
          v45 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        }
        v92 = v45;
        -[NSMutableArray insertObject:atIndex:](v45, "insertObject:atIndex:", v88, 0LL);
      }
    }

    else
    {
      v40 = 0LL;
      v41 = 0;
      BYTE4(v91) = 0;
      v42 = 0LL;
      v43 = 0LL;
      v89 = 0LL;
      v92 = 0LL;
    }

    goto LABEL_61;
  }

  return 0;
}

                LOBYTE(size[0]) = (16 * BYTE5(ptr[3]) - 80) | v77;
                v85 = *(unsigned __int8 *)(a1 + 14);
                if ((v59 & 2) != 0)
                {
                  if (v85 != 1) {
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  2406,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                  }
                  if (*v2)
                  {
                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                    v87 = *(unsigned __int8 *)(a1 + 14);
                    *(_BYTE *)(a1 + 15) = 1;
                    if (v87 != 1) {
                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  2407,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                    }
                    goto LABEL_146;
                  }

                  v92 = *(unsigned __int16 *)(a1 + 12);
                  if (*(unsigned __int16 *)(a1 + 10) <= v92)
                  {
                    *uint64_t v2 = 1;
LABEL_146:
                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                    goto LABEL_147;
                  }

                  v93 = *(void *)a1;
                  *(_WORD *)(a1 + 12) = v92 + 1;
                  BYTE3(v410) = *(_BYTE *)(v93 + v92);
                  if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v92 + 1) >= 6)
                  {
                    v90 = *(void *)a1 + (unsigned __int16)(v92 + 1);
                    v91 = (char *)&v410 + 4;
                    goto LABEL_142;
                  }
                }

                else
                {
                  if (v85 != 1) {
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  2409,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                  }
                  if (*v2)
                  {
                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                    v86 = *(unsigned __int8 *)(a1 + 14);
                    *(_BYTE *)(a1 + 15) = 1;
                    if (v86 != 1) {
                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  2410,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                    }
                    goto LABEL_146;
                  }

                  v88 = *(unsigned __int16 *)(a1 + 12);
                  if (*(unsigned __int16 *)(a1 + 10) <= v88)
                  {
                    *uint64_t v2 = 1;
                    goto LABEL_146;
                  }

                  v89 = *(void *)a1;
                  *(_WORD *)(a1 + 12) = v88 + 1;
                  BYTE1(size[0]) = *(_BYTE *)(v89 + v88);
                  if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v88 + 1) >= 6)
                  {
                    v90 = *(void *)a1 + (unsigned __int16)(v88 + 1);
                    v91 = (char *)size + 2;
LABEL_142:
                    sub_1001F0050((uint64_t)v91, v90, 6uLL);
                    *(_WORD *)(a1 + 12) += 6;
                    goto LABEL_148;
                  }
                }

      unint64_t v21 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(a1 + 64);
      if (!v21)
      {
        sub_1001EE2A0();
        unint64_t v21 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(a1 + 64);
LABEL_127:
        int8x16_t v18 = *(unsigned int *)(a1 + 16);
      }

                    *(_BYTE *)(a1 + 271) = 1;
                  }
                }

  sub_1005F39D8(v54, v187, (uint64_t)v168);
  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_1008A4018);
  }
  v197 = 0LL;
  v195 = 0u;
  memset(v196, 0, sizeof(v196));
  *(_OWORD *)v193 = 0u;
  v194 = 0u;
  v191 = 0u;
  v192 = 0u;
  v190 = 0u;
  memset(__p, 0, sizeof(__p));
  sub_1001FCFC8((uint64_t)__p);
  v58 = v165;
  v59 = sub_1001FD17C(&__p[2], (uint64_t)"Received 'start ", 16LL);
  v60 = sub_100610C44((uint64_t)v168);
  if (v60) {
    v61 = "active ";
  }
  else {
    v61 = "";
  }
  if (v60) {
    v62 = 7LL;
  }
  else {
    v62 = 0LL;
  }
  v63 = sub_1001FD17C(v59, (uint64_t)v61, v62);
  v64 = sub_1005E2B18(*(_DWORD *)(*((void *)v168 + 1) + 168LL));
  v65 = strlen(v64);
  v66 = sub_1001FD17C(v63, (uint64_t)v64, v65);
  v67 = *(id *)(*((void *)v168 + 1) + 176LL);
  if ([v67 count])
  {
    v68 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    v205 = 0u;
    v206 = 0u;
    *(_OWORD *)v203 = 0u;
    v204 = 0u;
    v69 = v67;
    v70 = [v69 countByEnumeratingWithState:v203 objects:&buf count:16];
    if (v70)
    {
      v71 = *(void *)v204;
      do
      {
        for (i = 0LL; i != v70; i = (char *)i + 1)
        {
          if (*(void *)v204 != v71) {
            objc_enumerationMutation(v69);
          }
          -[NSMutableString appendFormat:]( v68,  "appendFormat:",  @"%s ",  sub_1005E2B18((int)[*(id *)(*(void *)&v203[8] + 8 * (void)i) unsignedIntValue]));
        }

        v70 = [v69 countByEnumeratingWithState:v203 objects:&buf count:16];
      }

      while (v70);
    }

    v58 = v165;
    if (-[NSMutableString hasSuffix:](v68, "hasSuffix:", @" ")) {
      -[NSMutableString deleteCharactersInRange:]( v68,  "deleteCharactersInRange:",  (char *)-[NSMutableString length](v68, "length") - 1,  1LL);
    }
    v73 = v68;
    v74 = (const char *)-[NSMutableString UTF8String](v73, "UTF8String");
  }

  else
  {
    v74 = "";
  }

  v75 = strlen(v74);
  v76 = sub_1001FD17C(v66, (uint64_t)v74, v75);
  v77 = sub_1001FD17C(v76, (uint64_t)" scan' request ", 15LL);
  if (v58[8]) {
    v78 = "with usecase params";
  }
  else {
    v78 = " ";
  }
  if (v58[8]) {
    v79 = 19LL;
  }
  else {
    v79 = 1LL;
  }
  v80 = sub_1001FD17C(v77, (uint64_t)v78, v79);
  v81 = sub_1001FD17C(v80, (uint64_t)", with", 6LL);
  if (*v166) {
    v82 = " ";
  }
  else {
    v82 = "out ";
  }
  if (*v166) {
    v83 = 1LL;
  }
  else {
    v83 = 4LL;
  }
  v84 = sub_1001FD17C(v81, (uint64_t)v82, v83);
  sub_1001FD17C(v84, (uint64_t)"duplicates, duration:", 21LL);

  if (v58[8] && (v85 = *((void *)v58 + 2)) != 0)
  {
    v86 = (void **)std::ostream::operator<<(&__p[2], v85);
    v87 = v166;
    v88 = "ms, ";
    v89 = 4LL;
  }

  else
  {
    v88 = "unlimited, ";
    v89 = 11LL;
    v86 = &__p[2];
    v87 = v166;
  }

  sub_1001FD17C(v86, (uint64_t)v88, v89);
  if (v58[8])
  {
    v90 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      sub_100494958(v187, (uint64_t)v203);
      v91 = SBYTE7(v204);
      v92 = *(uint8_t **)v203;
      v93 = *(_DWORD *)(*((void *)v168 + 1) + 168LL);
      v94 = *(unsigned __int8 *)(a1 + 144);
      sub_1005E3244(v165, &v175);
      v95 = sub_1005E2B18(v93);
      v96 = v203;
      if (v91 < 0) {
        v96 = v92;
      }
      if ((v175.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        v97 = &v175;
      }
      else {
        v97 = (std::stringbuf::string_type *)v175.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v96;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v95;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      v200 = v94;
      v201 = 2080;
      v202 = v97;
      _os_log_impl( (void *)&_mh_execute_header,  v90,  OS_LOG_TYPE_INFO,  "session %s asked to scan with usecase %s screenOn:%d entry:%s",  (uint8_t *)&buf,  0x26u);
      v87 = v166;
      if (SBYTE7(v204) < 0) {
        operator delete(*(void **)v203);
      }
    }
  }

  if (v185 != v184)
  {
    v98 = 0xCCCCCCCCCCCCCCCDLL * ((v185 - (_BYTE *)v184) >> 2);
    if ((_DWORD)v98 == 1) {
      v99 = "UUID ";
    }
    else {
      v99 = "UUIDs ";
    }
    if ((_DWORD)v98 == 1) {
      v100 = 5LL;
    }
    else {
      v100 = 6LL;
    }
    v101 = sub_1001FD17C(&__p[2], (uint64_t)v99, v100);
    sub_1001FD17C(v101, (uint64_t)"[ ", 2LL);
    if ((_DWORD)v98)
    {
      v102 = 0LL;
      do
      {
        sub_1006344B4((uint64_t)v184 + v102, &buf);
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          v103 = &buf;
        }
        else {
          v103 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
        }
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          v104 = buf.__r_.__value_.__s.__size_;
        }
        else {
          v104 = buf.__r_.__value_.__l.__size_;
        }
        v105 = sub_1001FD17C(&__p[2], (uint64_t)v103, v104);
        sub_1001FD17C(v105, (uint64_t)" ", 1LL);
        v102 += 20LL;
      }

      while (20LL * v98 != v102);
    }

    sub_1001FD17C(&__p[2], (uint64_t)"] ", 2LL);
    v87 = v166;
  }

  v106 = v87[139];
  if (v106)
  {
    if ((v87[139] & 1) == 0)
    {
LABEL_199:
      if ((v106 & 4) != 0) {
        sub_1001FD17C(&__p[2], (uint64_t)"on CODED PHY ", 13LL);
      }
      goto LABEL_202;
    }
  }

  else
  {
    v87[139] = 1;
  }

  sub_1001FD17C(&__p[2], (uint64_t)"on 1M PHY ", 10LL);
  v106 = v87[139];
  if (v106) {
    goto LABEL_199;
  }
  v87[139] = 1;
LABEL_202:
  if (*(_BYTE *)(*((void *)v168 + 1) + 143LL)) {
    sub_1001FD17C(&__p[2], (uint64_t)" Exposure Notification ", 23LL);
  }
  if (*(_BYTE *)(*((void *)v168 + 1) + 144LL)) {
    sub_1001FD17C(&__p[2], (uint64_t)" retainDups ", 12LL);
  }
  if (v87[120])
  {
    v107 = *((unsigned int *)v87 + 32);
    v108 = *((unsigned int *)v87 + 33);
    v109 = v87[136];
    v110 = sub_1001FD17C(&__p[2], (uint64_t)"scan timing ", 12LL);
    v111 = (void *)std::ostream::operator<<(v110, v108);
    v112 = sub_1001FD17C(v111, (uint64_t)"/", 1LL);
    v113 = (void *)std::ostream::operator<<(v112, v107);
    if (v109) {
      v114 = "active ";
    }
    else {
      v114 = " ";
    }
    if (v109) {
      v115 = 7LL;
    }
    else {
      v115 = 1LL;
    }
    v116 = sub_1001FD17C(v113, (uint64_t)v114, v115);
    v117 = sub_1001FD17C(v116, (uint64_t)" scanLevel=", 11LL);
    v118 = (void *)std::ostream::operator<<(v117, *((unsigned int *)v168 + 24));
    sub_1001FD17C(v118, (uint64_t)" ", 1LL);
  }

  if (*((_DWORD *)v87 + 47) || *((_DWORD *)v87 + 48))
  {
    v119 = sub_1001FD17C(&__p[2], (uint64_t)"scan RX Threshold=", 18LL);
    v120 = (void *)std::ostream::operator<<(v119, *((unsigned int *)v87 + 47));
    v121 = sub_1001FD17C(v120, (uint64_t)"msec scan Timeout=", 18LL);
    v122 = *((unsigned int *)v87 + 48);
    if (!(_DWORD)v122)
    {
      if (*((_DWORD *)v87 + 47)) {
        v122 = 120000LL;
      }
      else {
        v122 = 0LL;
      }
    }

    v123 = (void *)std::ostream::operator<<(v121, v122);
    sub_1001FD17C(v123, (uint64_t)"msec ", 5LL);
  }

  v124 = (void *)sub_100610E3C((uint64_t)v168);
  v125 = (uint64_t)v168;
  v126 = *((void *)v168 + 1);
  if (*(_BYTE *)(v126 + 3))
  {
    *(_BYTE *)(a1 + 1840) = 0;
    v125 = sub_100616A44((uint64_t)v168);
    v168[81] = 16;
    v126 = *((void *)v168 + 1);
  }

  else
  {
    *(_BYTE *)(a1 + 1840) = 1;
  }

  v128 = *(void *)(v126 + 64);
  for (j = *(void *)(v126 + 72); v128 != j; v128 += 96LL)
  {
    if (*(_BYTE *)(v128 + 64))
    {
      v129 = *(unsigned __int8 *)(v128 + 8);
      v130 = sub_1001FD17C(&__p[2], (uint64_t)" ObjectLocatorResponse on type ", 31LL);
      std::ostream::operator<<(v130, v129);
      v125 = sub_1005F3AD0(a1, v129, *((unsigned __int16 *)v166 + 62));
      v131 = v125;
      v132 = v125 > 0xF || ((1 << v125) & 0x8005) == 0;
      if (v132)
      {
        v133 = (os_log_s *)qword_1008F75B8;
        v125 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v125)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v131;
          _os_log_error_impl( (void *)&_mh_execute_header,  v133,  OS_LOG_TYPE_ERROR,  "Failed to create a match table with error %d",  (uint8_t *)&buf,  8u);
        }

        if (v131 == 4) {
          break;
        }
      }
    }
  }

  LODWORD(v175.__r_.__value_.__l.__data_) = 0;
  if (sub_1005F3D88(v125, (uint64_t)v168, &v175))
  {
    v173[0] = _NSConcreteStackBlock;
    v173[1] = 3221225472LL;
    v173[2] = sub_1005F3F44;
    v173[3] = &unk_1008A3AB8;
    unint64_t data = (int)v175.__r_.__value_.__l.__data_;
    sub_1005EBB90((os_unfair_lock_s *)(a1 + 1872), v173);
  }

  if (sub_100611360((uint64_t)v168))
  {
    sub_1001FD17C(&__p[2], (uint64_t)" with Range Scan ", 17LL);
    ++*(_DWORD *)(a1 + 2736);
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069C7F8();
    }
  }

  if (sub_10061136C((uint64_t)v168))
  {
    sub_1001FD17C(&__p[2], (uint64_t)" with Priority Critical ", 24LL);
    ++*(_DWORD *)(a1 + 2740);
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069C798();
    }
  }

  if (*(_BYTE *)(a1 + 2352)) {
    sub_1001FD17C(&__p[2], (uint64_t)" with retain dups ", 18LL);
  }
  v134 = sub_100611384((uint64_t)v168);
  v135 = (void *)objc_claimAutoreleasedReturnValue(v134);
  v136 = (void *)objc_claimAutoreleasedReturnValue([v135 cuFilteredArrayUsingBlock:&stru_1008A3AD8]);
  v167 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](&OBJC_CLASS___NSMutableSet, "setWithArray:", v136));

  if (sub_100611378((uint64_t)v168))
  {
    v137 = sub_100611378((uint64_t)v168);
    v138 = sub_1005E2B18(v137);
    v139 = strlen(v138);
    v140 = sub_1001FD17C(&__p[2], (uint64_t)v138, v139);
    sub_1001FD17C(v140, (uint64_t)" ", 1LL);
    v141 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  sub_100611378((uint64_t)v168));
    v142 = (void *)objc_claimAutoreleasedReturnValue(v141);
    [v167 addObject:v142];
  }

  v171 = 0u;
  v172 = 0u;
  v169 = 0u;
  v170 = 0u;
  v143 = v167;
  v144 = [v143 countByEnumeratingWithState:&v169 objects:v188 count:16];
  if (v144)
  {
    v145 = *(void *)v170;
    do
    {
      v146 = 0LL;
      do
      {
        if (*(void *)v170 != v145) {
          objc_enumerationMutation(v143);
        }
        v147 = *(void **)(*((void *)&v169 + 1) + 8LL * (void)v146);
        if (qword_1008D6198 != -1) {
          dispatch_once(&qword_1008D6198, &stru_1008A4058);
        }
        sub_10044D668((uint64_t)off_1008D6190, [v147 longLongValue]);
        v146 = (char *)v146 + 1;
      }

      while (v144 != v146);
      v144 = [v143 countByEnumeratingWithState:&v169 objects:v188 count:16];
    }

    while (v144);
  }

  v148 = sub_1001FD17C(&__p[2], (uint64_t)"from session ", 14LL);
  sub_100494958(v187, (uint64_t)&buf);
  if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    v149 = &buf;
  }
  else {
    v149 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
  }
  if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    v150 = buf.__r_.__value_.__s.__size_;
  }
  else {
    v150 = buf.__r_.__value_.__l.__size_;
  }
  v151 = sub_1001FD17C(v148, (uint64_t)v149, v150);
  sub_1001FD17C(v151, (uint64_t)"", 1LL);
  v152 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str(&buf, (const std::stringbuf *)&__p[3]);
    v153 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
         ? &buf
         : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    *(_DWORD *)v203 = 136446210;
    *(void *)&v203[4] = v153;
    _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "%{public}s", v203, 0xCu);
  }

  if (*(_BYTE *)(*((void *)v168 + 1) + 3LL) || *(_DWORD *)(a1 + 1964) != 2)
  {
    sub_1005E3C94(a1, 1);
  }

  else
  {
    v154 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v154,  OS_LOG_TYPE_DEFAULT,  "Not updating state, new agent is not allowed in paused mode",  (uint8_t *)&buf,  2u);
    }
  }

  ++*(_DWORD *)(a1 + 2744);
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069C738();
  }

  *(void **)((char *)__p
  __p[2] = v155;
  if (SHIBYTE(v194) < 0) {
    operator delete(v193[1]);
  }
  std::streambuf::~streambuf(&__p[3]);
  std::ios::~ios(v196);
  if (SHIBYTE(v180) < 0) {
    operator delete(v179[1]);
  }
  uint64_t v7 = 0LL;
LABEL_303:
  if (v184)
  {
    v185 = v184;
    operator delete(v184);
  }

  return v7;
}

  sub_100242CD8(&v60);
  return sub_100242FAC((uint64_t)v61);
}

id sub_100013510(uint64_t a1)
{
  if (dword_1008D5FD8 <= 30 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserUpdateSpatialInteraction]_block_invoke",  30LL,  "BLE advertiser: spatial linger end");
  }
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 40LL);
  if (v2)
  {
    id v3 = v2;
    dispatch_source_cancel(v3);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = 0LL;
  }

  return [*(id *)(a1 + 32) scheduleSpatialUpdateImmediate:0];
}

LABEL_34:
            uint64_t v4 = v71;
            uint64_t v2 = v76;
            uint64_t v9 = v77;
            goto LABEL_35;
          }
        }

        else
        {
        }

        [v12 setNearbyInfoV2AuthTagData:v26];
        v68 = 1;
        goto LABEL_27;
      }

        LOBYTE(v10) = 0;
        *a4 = v16;
LABEL_20:

        goto LABEL_21;
      }

      if (a4)
      {
        v28 = CBErrorF(4294960534LL, "No pairing agent to continue");
        v27 = (id)objc_claimAutoreleasedReturnValue(v28);
        goto LABEL_29;
      }
    }

    else if (a4)
    {
      v26 = CBErrorF(4294960551LL, "No pairing agent handle to continue");
      v27 = (id)objc_claimAutoreleasedReturnValue(v26);
LABEL_29:
      LOBYTE(v10) = 0;
      *a4 = v27;
      goto LABEL_21;
    }

    LOBYTE(v10) = 0;
    goto LABEL_21;
  }

  if (a4)
  {
    v25 = CBErrorF(4294960591LL, "No pairing device");
    LOBYTE(v10) = 0;
    *a4 = (id)objc_claimAutoreleasedReturnValue(v25);
  }

  else
  {
    LOBYTE(v10) = 0;
  }

          v32 = 0LL;
          RandomBytes(&v32, 8LL);
          v32 &= 0xFFFFFFFFFFFFuLL;
          v28 = (NSData *)objc_claimAutoreleasedReturnValue(-[CBStackAddressMonitorBTStack _dataWithBTAddress:](self, "_dataWithBTAddress:"));
          fakeNonConnectableAddressData = self->_fakeNonConnectableAddressData;
          self->_fakeNonConnectableAddressData = v28;

LABEL_38:
          return;
        }
      }

      else
      {
      }

      unint64_t v21 = v16;
      v20 = self->_nonConnectableAddressData;
      self->_nonConnectableAddressData = v21;
      uint64_t v9 = 1;
    }

    goto LABEL_22;
  }

                            if (HIBYTE(v32))
                            {
                              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c");
                            }

                            else if (WORD1(v32) - WORD2(v32) > 3)
                            {
                              if (BYTE6(v32) == 2)
                              {
                                *(_BYTE *)(v31 + WORD2(v32)) = -1;
                                *(_BYTE *)(v31 + WORD2(v32) + 1) = -1;
                                *(_BYTE *)(v31 + WORD2(v32) + 2) = -1;
                                *(_BYTE *)(v31 + WORD2(v32) + 3) = -1;
                                unint64_t v22 = WORD2(v32) + 4;
                                WORD2(v32) += 4;
                                if (HIBYTE(v32))
                                {
                                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stac"
                                                         "k/vsc/aci/aci_vsc.c");
                                }

                                else if (WORD1(v32) - v22 > 3)
                                {
                                  if (BYTE6(v32) == 2)
                                  {
                                    *(_BYTE *)(v31 + v22) = -1;
                                    *(_BYTE *)(v31 + WORD2(v32) + 1) = -1;
                                    *(_BYTE *)(v31 + WORD2(v32) + 2) = -1;
                                    *(_BYTE *)(v31 + WORD2(v32) + 3) = -1;
                                    WORD2(v32) += 4;
                                    return sub_10018BD78( 64998,  v31,  BYTE4(v32),  a4,  (uint64_t)sub_1000BC408,  v9,  v10,  v11);
                                  }

                                  v27 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_61:
                                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1316,  v27);
                                }

                                v27 = "ByteStream_NumReadBytesAvail(bs) >= 4";
                                goto LABEL_61;
                              }

                              v26 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_57:
                              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1315,  v26);
                            }

                            v26 = "ByteStream_NumReadBytesAvail(bs) >= 4";
                            goto LABEL_57;
                          }

                          v25 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_53:
                          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1309,  v25);
                        }
                      }

                      v25 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                      goto LABEL_53;
                    }

                    uint64_t v24 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_49:
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1308,  v24);
                  }
                }

                uint64_t v24 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                goto LABEL_49;
              }
            }

            int8x16_t v16 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_64:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1303,  v16);
          }

          if (HIBYTE(v32))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c");
          }

          else
          {
            __int128 v14 = WORD2(v32);
            if (WORD1(v32) > WORD2(v32))
            {
              if (BYTE6(v32) == 2)
              {
                id v15 = 1;
                goto LABEL_22;
              }

              uint64_t v30 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_76:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1306,  v30);
            }
          }

          uint64_t v30 = "ByteStream_NumReadBytesAvail(bs) >= 1";
          goto LABEL_76;
        }

        v29 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_72:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c", 1298, v29);
      }
    }

    v29 = "ByteStream_NumReadBytesAvail(bs) >= 1";
    goto LABEL_72;
  }

  return result;
}

  if ((v18 & 0x10) != 0)
  {
    __int128 v13 = sub_1001F4A7C((uint64_t)v26, ",4");
    if ((_DWORD)v13) {
      goto LABEL_24;
    }
  }

  __int128 v13 = sub_1001F4A7C((uint64_t)v26, ")\r\n");
  if ((_DWORD)v13) {
    goto LABEL_24;
  }
  v19 = (char *)sub_1001F5F50((uint64_t)v26);
  v20 = strlen(v19);
  unint64_t v21 = sub_1000EF214(v3, 3, v19, v20, 1);
  if ((_DWORD)v21)
  {
    unint64_t v22 = v3;
    v23 = 3;
  }

  else
  {
    uint64_t v24 = sub_1000EF604(v3, 0, v21);
    if (!(_DWORD)v24)
    {
LABEL_9:
      if (*(_BYTE *)(qword_1008E1E50 + v4 + 12)) {
        sub_1000F4E80(v3);
      }
      return 412LL;
    }

    unint64_t v21 = v24;
    unint64_t v22 = v3;
    v23 = 1;
  }

  sub_1000F1FF0(v22, v23, v21);
  return 412LL;
}

          v40 = sub_1000EF604(a1, 0, 0LL);
          if ((_DWORD)v40) {
            sub_1000F1FF0(a1, 1u, v40);
          }
          return 412LL;
        }

        sub_1000EF214(a1, 27, "\r\n+BIND:1,1\r\n", 0xDuLL, 0);
        v37 = "\r\n+BIND:2,1\r\n";
        v38 = a1;
        v39 = 13LL;
      }

      else
      {
        v37 = "\r\n+BIND:(1,2)\r\n";
        v38 = a1;
        v39 = 15LL;
      }

      sub_1000EF214(v38, 27, v37, v39, 0);
      goto LABEL_34;
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Device not connected", v5, v6, v7, v8, v9, v10, v11, v41);
    uint64_t v12 = (os_log_s *)sub_100086554(0x10u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

  return 1802LL;
}

        *(_WORD *)(v13 + 14) = 0;
LABEL_35:
        *(_BYTE *)(v13 + 16) = 0;
        return;
      }
    }

    *(_BYTE *)(v13 + 16) = 1;
    goto LABEL_39;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Packet size of %d exceeds the expected payload length %d",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v9);
    v44 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
LABEL_17:
    }
      sub_100657858();
  }

  v27 = v26 + 1;
  if (v24 <= (unsigned __int16)(v26 + 1))
  {
    a2 = 0;
    goto LABEL_21;
  }

  while (1)
  {
    *(_WORD *)(i + 32) = *(_WORD *)(v25 + 2LL * v27);
    a2 = sub_1001A98C4( v7,  *(unsigned __int16 *)(v25 + 2LL * v27),  *(unsigned __int16 *)(v25 + 2LL * v27),  0LL,  0LL,  i,  0LL);
    if (a2) {
      break;
    }
    if (v24 <= ++v27) {
      goto LABEL_21;
    }
  }

        sub_1001C617C(0LL, v5, v6, v7, v8, v9, v10, v11);
        goto LABEL_35;
      }
    }

    else if (!WORD1(xmmword_1008ED8D8) || !WORD2(xmmword_1008ED8D8))
    {
      goto LABEL_34;
    }

    __int128 v14 = sub_10018E65C(v29[0], BYTE13(xmmword_1008ED8D8), 1LL, (uint64_t)&v28, (uint64_t)&v27, (uint64_t)&v26, v15, 1u);
    goto LABEL_29;
  }

  xmmword_1008ED8D8 = 0u;
  *(_OWORD *)&byte_1008ED8E8 = 0u;
  *(_OWORD *)&unk_1008ED8B8 = 0u;
  *(_OWORD *)&qword_1008ED8C8 = 0u;
  byte_1008ED900 = 0;
  if (v25) {
    v25(a1, v2);
  }
}

      v14 += 48LL;
    }

    while (v14 != v15);
  }

  uint64_t v24 = *(unsigned __int8 ***)(v13 + 32);
  v25 = *(unsigned __int8 ***)(v13 + 40);
  if (v24 == v25)
  {
LABEL_54:
    v35 = (os_log_s *)qword_1008F75C8;
    if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
    {
      v36 = a3[23];
      v37 = *(char **)a3;
      sub_100494958(a2, (uint64_t)__p);
      v38 = v36 >= 0 ? a3 : v37;
      v39 = v50 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446466;
      v53 = v38;
      v54 = 2082;
      v55 = v39;
      _os_log_error_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "Unable to unregister endpoint %{public}s on session %{public}s as it wasn't registered",  buf,  0x16u);
      if (v50 < 0) {
        operator delete(__p[0]);
      }
    }

    goto LABEL_14;
  }

  v26 = a3[23];
  if (v26 >= 0) {
    v27 = a3[23];
  }
  else {
    v27 = *((void *)a3 + 1);
  }
  if (v26 >= 0) {
    v28 = a3;
  }
  else {
    v28 = *(char **)a3;
  }
  while (1)
  {
    v29 = (char *)*v24;
    uint64_t v30 = (*v24)[23];
    if (v30 >= 0) {
      v31 = (*v24)[23];
    }
    else {
      v31 = *((void *)*v24 + 1);
    }
    if (v31 != v27) {
      goto LABEL_53;
    }
    if (((*v24)[23] & 0x80) != 0) {
      break;
    }
    if (!(*v24)[23]) {
      goto LABEL_76;
    }
    v32 = v28;
    v33 = *v24;
    v34 = (*v24)[23];
    while (*v33 == *v32)
    {
      ++v33;
      ++v32;
      if (!--v34) {
        goto LABEL_76;
      }
    }

    uint64_t v30 = (os_log_s *)qword_1008F75E0;
    if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v42 = a2;
      v43 = 1024;
      v44 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Failed to query keychain for device %{public}s with result %d",  buf,  0x12u);
    }

    v29 = 0LL;
    goto LABEL_37;
  }

  v38 = a1;
  TypeID = CFDictionaryGetTypeID();
  id v15 = TypeID == CFGetTypeID(result);
  a1 = v38;
  if (!v15) {
    goto LABEL_34;
  }
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)result, @"agrp");
  unint64_t data = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)result, @"v_Data");
  CStringPtr = CFStringGetCStringPtr(Value, 0x8000100u);
  uint64_t v17 = (os_log_s *)qword_1008F75E0;
  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446722;
    v42 = a2;
    v43 = 1024;
    v44 = 0;
    v45 = 2080;
    v46 = CStringPtr;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "_BTKCGetDataCopy found keychain item for device %{public}s with result %d with accessgroup=%s",  buf,  0x1Cu);
  }

  if (!Value
    || (v47.length = CFStringGetLength(Value),
        v47.location = 0LL,
        CFStringCompareWithOptions(Value, @"com.apple.bluetooth", v47, 1uLL) == kCFCompareEqualTo))
  {
    a1 = v38;
    v19 = v7;
LABEL_39:
    v28 = CFPropertyListCreateWithData(kCFAllocatorDefault, data, 2uLL, 0LL, 0LL);
LABEL_40:
    v29 = v28;
    if (v28)
    {
      v31 = CFDictionaryGetTypeID();
      if (v31 != CFGetTypeID(v29))
      {
        v32 = (os_log_s *)qword_1008F75E0;
        if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR)) {
          sub_100666FA8((uint64_t)a2, v29, v32);
        }
        CFRelease(v29);
        v29 = 0LL;
      }
    }

    __int128 v13 = 0;
    goto LABEL_46;
  }

  int8x16_t v18 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(v18, kSecClass, kSecClassGenericPassword);
  CFDictionaryAddValue(v18, kSecAttrService, v9);
  v19 = v7;
  CFDictionaryAddValue(v18, kSecAttrAccount, v7);
  CFDictionaryAddValue(v18, v10, kCFBooleanTrue);
  v20 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(v20, kSecAttrAccessGroup, @"com.apple.bluetooth");
  unint64_t v21 = SecItemUpdate(v18, v20);
  CFRelease(v20);
  unint64_t v22 = (os_log_s *)qword_1008F75E0;
  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446466;
    v42 = a2;
    v43 = 1024;
    v44 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "updating keychain access group for device %{public}s with result %d",  buf,  0x12u);
  }

  if (!v21)
  {
    a1 = v38;
    goto LABEL_39;
  }

  v23 = (os_log_s *)qword_1008F75E0;
  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446466;
    v42 = a2;
    v43 = 1024;
    v44 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "failed to update keychain access group for device %{public}s with result %d",  buf,  0x12u);
  }

  a1 = v38;
  if (v21 != -25299) {
    goto LABEL_39;
  }
  uint64_t v24 = SecItemDelete(v18);
  if (v18) {
    CFRelease(v18);
  }
  if (v24)
  {
    v25 = (os_log_s *)qword_1008F75E0;
    if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v42 = a2;
      v43 = 1024;
      v44 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "failed to delete duplicate keychain item for device %{public}s with result %d",  buf,  0x12u);
    }
  }

  if (result)
  {
    CFRelease(result);
    uint64_t result = 0LL;
  }

  CFDictionaryAddValue(Mutable, kSecAttrAccessGroup, @"com.apple.bluetooth");
  v26 = SecItemCopyMatching(Mutable, &result);
  __int128 v13 = v26;
  if (!result || v26)
  {
    if (v26 == -25300)
    {
      v29 = 0LL;
      __int128 v13 = -25300;
      goto LABEL_46;
    }
  }

  else
  {
    v27 = CFDictionaryGetTypeID();
    if (v27 == CFGetTypeID(result))
    {
      dataa = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)result, @"v_Data");
      v28 = CFPropertyListCreateWithData(kCFAllocatorDefault, dataa, 2uLL, 0LL, 0LL);
      goto LABEL_40;
    }
  }

  v34 = (os_log_s *)qword_1008F75E0;
  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v42 = a2;
    v43 = 1024;
    v44 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Failed to query keychain with access group com.apple.bluetooth for device %{public}s with result %d",  buf,  0x12u);
  }

  v29 = 0LL;
LABEL_46:
  if (result) {
    CFRelease(result);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (a1) {
    *a1 = v13;
  }
  return v29;
}

  CFDictionaryRemoveValue(v5, @"MagicAccEncKey");
  if ((a2 & 0x40) == 0)
  {
LABEL_19:
    if ((a2 & 0x80) == 0) {
      goto LABEL_20;
    }
    goto LABEL_36;
  }

  memset(&__p, 0, sizeof(__p));
  *(_DWORD *)(a1 + 104) = 0;
  sub_10002418C(&buf, "Diversity");
  sub_10002418C(&v29, "DiversityLogMode");
  *(_BYTE *)(a1 + 100) = (*(uint64_t (**)(uint64_t, std::string *, std::string *, std::string *))(*(void *)a1 + 56LL))( a1,  &buf,  &v29,  &__p);
  if (*(_BYTE *)(a1 + 100))
  {
    if (!std::string::compare(&__p, "LOG_DENIALS"))
    {
      *(_DWORD *)(a1 + 104) = 3;
      uint64_t v5 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      uint64_t v6 = "Diversity log mode override: Log Denials";
      goto LABEL_51;
    }

    if (!std::string::compare(&__p, "LOG_CHANNELS"))
    {
      *(_DWORD *)(a1 + 104) = 4;
      uint64_t v5 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      uint64_t v6 = "Diversity log mode override: Log Channels";
      goto LABEL_51;
    }

    if (!std::string::compare(&__p, "DISABLED"))
    {
      *(_DWORD *)(a1 + 104) = 0;
      uint64_t v5 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      uint64_t v6 = "Diversity log mode override: Log Disabled";
      goto LABEL_51;
    }

    if (std::string::compare(&__p, "LOG_DENIALS_3ANT"))
    {
      *(_BYTE *)(a1 + 100) = 0;
      uint64_t v5 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      uint64_t v6 = "Warning: Diversity log mode override: Invalid.  Override disabled.";
LABEL_51:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&buf, 2u);
      goto LABEL_52;
    }

    *(_DWORD *)(a1 + 104) = 5;
  }

        uint64_t v17 = 1;
        goto LABEL_36;
      }

      if (*(void *)(*(void *)(v14 + 96) + 8LL) == a2)
      {
        if (!a3)
        {
          uint64_t v17 = 1;
          __int128 v14 = *(void *)(v14 + 96);
          goto LABEL_36;
        }

        *a3 = v14;
        __int128 v13 = (char *)(*(void *)v13 + 96LL);
LABEL_33:
        __int128 v14 = *(void *)v13;
        goto LABEL_34;
      }

      v20 = 0LL;
      unint64_t v21 = 0LL;
      unint64_t v22 = 0LL;
      sub_100240540(&v20, *(void *)v13 + 104LL);
      id v15 = v20;
      int8x16_t v16 = v20;
      if (v20 == v21) {
        break;
      }
      while (*(void *)(*(void *)v16 + 8LL) != a2)
      {
        v16 += 8;
        if (v16 == v21) {
          goto LABEL_14;
        }
      }

      int8x16_t v18 = 0;
      if (!a3)
      {
        uint64_t v17 = 1;
        uint64_t v4 = *(void *)v16;
        if (!v20) {
          goto LABEL_19;
        }
LABEL_18:
        unint64_t v21 = v15;
        operator delete(v15);
        goto LABEL_19;
      }

      *a3 = *(void *)v13;
      uint64_t v4 = *(void *)v16;
      uint64_t v17 = 1;
      if (v15) {
        goto LABEL_18;
      }
LABEL_19:
      if (!v18) {
        goto LABEL_35;
      }
      v13 += 8;
      if (v13 == v24)
      {
        uint64_t v17 = 0;
LABEL_35:
        __int128 v14 = v4;
LABEL_36:
        __int128 v13 = v23;
        uint64_t v4 = v14;
        if (v23)
        {
LABEL_37:
          uint64_t v24 = v13;
          operator delete(v13);
        }

              unint64_t v21 = (os_log_s *)qword_1008F7558;
              if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v25 = 67109120;
                LODWORD(v26) = v17;
                _os_log_error_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "Found unknown Audio Codec ID %d",  v25,  8u);
              }

  sub_100242FAC((uint64_t)v23);
  return v7;
}

    v20 = 0LL;
    goto LABEL_35;
  }

  uint64_t v6 = (unsigned __int8 *)sub_10056AAF0(a1 + 496);
  if (sub_10011BCE4(v6, 255, &v26, &v27) || !v27 || !v26)
  {
    int8x16_t v18 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "Could not get the EIR manufacturer data",  (uint8_t *)__p,  2u);
    }

    goto LABEL_34;
  }

  uint64_t v7 = *v27;
  if (*v27 && v7 != 76 && v27[1] != 76)
  {
    id v15 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
    {
      sub_1003CF00C(a1, __p);
      if (v24 >= 0) {
        unint64_t v21 = __p;
      }
      else {
        unint64_t v21 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136446210;
      v29 = v21;
      uint64_t v17 = "Device %{public}s is not an Apple device";
      goto LABEL_21;
    }

    goto LABEL_34;
  }

  id v8 = 0LL;
  uint64_t v9 = v7 == 76;
  unint64_t v10 = 1LL;
  if (!v9) {
    unint64_t v10 = 2LL;
  }
  dispatch_source_t v11 = &v27[v10];
  v27 = v11;
  uint64_t v12 = *v11;
  while (v12 == 1)
  {
    __int128 v13 = v8;
    do
    {
      id v8 = v13;
      __int128 v14 = v11[v13];
      __int128 v13 = (v13 + 1);
    }

    while (v14);
    uint64_t v12 = 0;
  }

  if (v12 != 2) {
    goto LABEL_34;
  }
  v19 = v11[v8 + 1];
  v20 = sub_1004048CC((uint64_t)&v11[(v8 + 4)], (v19 - 4), a2, a3);
LABEL_35:
  sub_100242FAC((uint64_t)v25);
  return v20;
}
}

  sub_100242FAC((uint64_t)v34);
  return v17;
}

  if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR)) {
    sub_10068E7F8();
  }
}

  if (*(unsigned __int16 *)(a1 + 1082) < *(unsigned __int16 *)(a1 + 1080)
    && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    sub_10069710C();
  }

  __int128 v14 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyMediumMinInterval");
  id v15 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v14 + 88LL))(v14, buf, __p, &v96);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v15) {
      goto LABEL_48;
    }
  }

  else if (!v15)
  {
    goto LABEL_48;
  }

  int8x16_t v16 = v96;
  uint64_t v17 = (os_log_s *)qword_1008F7620;
  if ((v96 - 8) >= 0xF9A && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v16;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "Override rejected latency minInterval:%d LeConnectionLatencyMedium",  buf,  8u);
    LOWORD(v16) = v96;
    uint64_t v17 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 1086) = v16;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v16;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Override latency minInterval:%d LeConnectionLatencyMedium",  buf,  8u);
  }
}

LABEL_43:
        uint64_t v4 = v71;
        uint64_t v9 = v77;
      }

  uint64_t v24 = v30;
  if (v30)
  {
    v25 = (unint64_t *)&v30->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
}

    LOBYTE(v13) = 0;
    goto LABEL_44;
  }

  __int128 v13 = -[CBStackControllerBTStack _btDeviceWithID:error:](self, "_btDeviceWithID:error:", v12, 0LL);
  if (v13)
  {
    __int128 v14 = [v10 length];
    id v15 = v14;
    if (v14 >= 0x3E7)
    {
      if (a6)
      {
        uint64_t v24 = CBErrorF(4294960553LL, "AACP message too big: %u vs %u", (_DWORD)v14, 998);
        v20 = (void *)objc_claimAutoreleasedReturnValue(v24);
        goto LABEL_38;
      }

      goto LABEL_43;
    }

    if (dword_1008D66A0 <= 30
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      if (v8 > 6) {
        int8x16_t v16 = "?";
      }
      else {
        int8x16_t v16 = off_1008814B8[(char)v8];
      }
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryEventMessage:eventType:device:error:]",  30LL,  "SendAudioAccessoryEventMessage: type %s, device %@ with length %hu",  v16,  v12,  v15);
    }

    switch(v8)
    {
      case 2u:
        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v17 = sub_1002223BC( (uint64_t)off_1008D60D8, (uint64_t)v13, [v10 bytes], (unsigned __int16)v15);
        break;
      case 3u:
        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v17 = sub_1002221D8( (uint64_t)off_1008D60D8, (uint64_t)v13, [v10 bytes], (unsigned __int16)v15);
        break;
      case 4u:
        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v17 = sub_100222790( (uint64_t)off_1008D60D8, (uint64_t)v13, (unsigned __int16)v15, [v10 bytes]);
        break;
      case 5u:
        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v17 = sub_100222BA4( (uint64_t)off_1008D60D8, (uint64_t)v13, (unsigned __int16)v15, (unsigned __int8 *)[v10 bytes]);
        break;
      case 6u:
        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v17 = sub_10021B598((uint64_t)off_1008D60D8, (uint64_t)v13);
        break;
      default:
        if (!a6) {
          goto LABEL_43;
        }
        unint64_t v21 = "?";
        if (v8 == 1) {
          unint64_t v21 = "TipiChanged";
        }
        if (!v8) {
          unint64_t v21 = "Invalid";
        }
        unint64_t v22 = CBErrorF(4294960591LL, "bad accessory event type: %s", v21);
        v20 = (void *)objc_claimAutoreleasedReturnValue(v22);
        goto LABEL_38;
    }

    LOBYTE(v13) = 1;
    if (v17)
    {
      int8x16_t v18 = (v17 + 310000);
      if ((_DWORD)v18)
      {
        if (a6)
        {
          v19 = CBErrorF(v18, "SendAudioAccessoryEventMessage failed");
          v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
LABEL_38:
          LOBYTE(v13) = 0;
          *a6 = v20;
          goto LABEL_44;
        }

        goto LABEL_43;
      }
    }
  }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Unknown CL Opcode of 0x%x with data size %d", v45, v46, v47, v48, v49, v50, v51, v10);
      v52 = (os_log_s *)sub_100086554(0x51u);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    v53 = 264;
    v54 = 2;
    sub_10008DF98(a1, &v53, 3u, 0);
  }

  else
  {
    switch((int)v10)
    {
      case 1:
        sub_100093930((uint64_t)a1, &a2[v11], (unsigned __int16)v9);
        break;
      case 2:
        sub_1000942A4((uint64_t)a1, &a2[v11], (unsigned __int16)v9);
        break;
      case 3:
        sub_100094A98(a1, (unsigned __int16 *)&a2[v11], (unsigned __int16)v9);
        break;
      case 4:
        sub_100094DB4(a1, &a2[v11], (unsigned __int16)v9);
        break;
      case 5:
        sub_100095050(a1, (unsigned __int16 *)&a2[v11], (unsigned __int16)v9);
        break;
      case 6:
        sub_1000954A0(a1, (unsigned __int16 *)&a2[v11], (unsigned __int16)v9);
        break;
      case 7:
        sub_100095A70((uint64_t)a1, (unsigned __int16 *)&a2[v11], (unsigned __int16)v9);
        break;
      case 8:
        sub_1000962EC(a1, (uint64_t)&a2[v11]);
        break;
      case 9:
        sub_1000933F4((uint64_t)a1, &a2[v11], (unsigned __int16)v9);
        break;
      default:
        if ((_DWORD)v10 != 112) {
          goto LABEL_43;
        }
        sub_10009647C((unsigned __int16 *)a1);
        break;
    }
  }

  *(void *)(v4 + v5 + 1560) |= 2uLL;
  if ((v21 & 4) == 0)
  {
LABEL_36:
    if ((v21 & 0x10) == 0) {
      goto LABEL_37;
    }
    goto LABEL_45;
  }

  *(void *)(v9 + v4 + 88) |= 2uLL;
  if ((v10 & 4) == 0)
  {
LABEL_32:
    if ((v10 & 0x10) == 0) {
      goto LABEL_33;
    }
    goto LABEL_45;
  }

          if (!v26) {
            return;
          }
          v29 = a1;
          v28 = 0LL;
          uint64_t v30 = a3;
        }

        v37 = 0LL;
LABEL_49:
        v26(v29, v28, v30, v37);
        return;
      case 9:
        v31 = *(void (**)(uint64_t, uint64_t, void))(qword_1008E1E98 + 72);
        if (v31)
        {
          if (a2) {
            v32 = 15LL;
          }
          else {
            v32 = a3;
          }
          v33 = a1;
LABEL_53:
          v31(v33, v32, 0LL);
        }

        return;
      default:
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"No transactions outstanding, ignoring packet from device",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v38);
          v23 = (os_log_s *)sub_100086554(0x15u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        return;
    }
  }

        uint64_t v30 = *(char **)a2;
        *(_WORD *)(a2 + 12) = 1;
        *uint64_t v30 = v27;
        if (*(_BYTE *)(a2 + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/obex/obexcommon.c");
        }

        else
        {
          v31 = *(unsigned __int16 *)(a2 + 12);
          if (*(unsigned __int16 *)(a2 + 10) - (int)v31 > 1)
          {
            if (*(_BYTE *)(a2 + 14) == 2)
            {
              v32 = HIBYTE(v37);
              *(_BYTE *)(*(void *)a2 + v31 + 1) = v37;
              *(_BYTE *)(*(void *)a2 + *(unsigned __int16 *)(a2 + 12)) = v32;
              *(_WORD *)(a2 + 12) += 2;
              v33 = *(unsigned __int16 *)(a2 + 10);
              if (v24 > v33) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/obex/obexcommon.c",  408,  "(size_t)(pos) <= (size_t)((*pktHdr).__size)");
              }
              *(_WORD *)(a2 + 12) = v24;
              if (*(_BYTE *)(a2 + 14) == 2)
              {
                *(_WORD *)(a2 + 10) = v24;
                v33 = v24;
              }

              *(_BYTE *)(a2 + 14) = 15;
              v29 = sub_1001EF9BC(v19, *(char **)a2, v33, 0);
              if (!(_DWORD)v29)
              {
                sub_1001EFEB8((uint64_t)v19, *(unsigned __int16 *)(a1 + 72));
                *(void *)(a1 + 40) = v19;
                return v29;
              }

              goto LABEL_50;
            }

            v35 = "(*pktHdr).__RWFlag == BYTESTREAM_WRITE";
LABEL_56:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/obex/obexcommon.c",  407,  v35);
          }
        }

        v35 = "ByteStream_NumReadBytesAvail(*pktHdr) >= 2";
        goto LABEL_56;
      }

      v28 = "ByteStream_NumReadBytesAvail(*pktHdr) >= 1";
LABEL_60:
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/obex/obexcommon.c",  403,  v28);
    }

    if (*(_BYTE *)(a2 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/obex/obexcommon.c");
    }

    else if (*(_WORD *)(a2 + 10))
    {
      if (*(_BYTE *)(a2 + 14) == 2)
      {
        v27 = *(_BYTE *)(a1 + 78);
        goto LABEL_43;
      }

      v36 = "(*pktHdr).__RWFlag == BYTESTREAM_WRITE";
LABEL_64:
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/obex/obexcommon.c",  405,  v36);
    }

    v36 = "ByteStream_NumReadBytesAvail(*pktHdr) >= 1";
    goto LABEL_64;
  }

  return 106LL;
}

    if ((a4 & 1) != 0) {
      return 625LL;
    }
    uint64_t v9 = sub_1001EE6DC((uint64_t)sub_100134154, 0LL, 0LL);
    if ((_DWORD)v9) {
      return v9;
    }
    goto LABEL_42;
  }

  uint64_t v9 = 629LL;
LABEL_25:
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"OI_HCI_Send failed to write SCO data", v35, v36, v37, v38, v39, v40, v41, v63);
    v42 = (os_log_s *)sub_100086554(0x2Eu);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      sub_10065A878();
    }
  }

  return v9;
}

  v33 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v33
    || v33 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
  {
    v34 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    v35 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    if (v34 <= v33)
    {
      if (v33 - v35 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL)) {
        goto LABEL_52;
      }
    }

    else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
              + (_BYTE)v35) & 0x3Fu) < v33)
    }
    {
      goto LABEL_52;
    }
  }

  if (((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL))
  {
    v44 = (a2 >> 7) & 1;
    sub_100182D14(a1, a3);
    v45 = (*(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL) + 1) & 0x3F;
    *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL) = v45;
    v46 = (uint64_t)a1;
    v47 = v33;
    v48 = v44;
LABEL_125:
    sub_100181EEC(v46, v47, v48);
    return 0LL;
  }

    sub_1001E923C(0, a1, 0LL, 0LL, v12, v13, v14, v15);
  }

  v28 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v29 = __p;
    sub_1003CF00C((uint64_t)a2, __p);
    if (v73 < 0) {
      v29 = *(_BYTE **)__p;
    }
    uint64_t v30 = sub_100426610(&v71);
    else {
      v31 = "not paired";
    }
    else {
      v32 = "no";
    }
    v33 = sub_1003D2B2C((uint64_t)a2, 1);
    v34 = sub_1003D2B2C((uint64_t)a2, 3);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136448514;
    v35 = "not supported";
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    if (v33) {
      v36 = "supported";
    }
    else {
      v36 = "not supported";
    }
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v30;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    if (v34) {
      v35 = "supported";
    }
    v75 = a3;
    v76 = 1024;
    v77 = v65;
    v78 = 1024;
    v79 = v64;
    v80 = 1024;
    v81 = v66;
    v82 = 2080;
    v83 = v31;
    v84 = 2080;
    v85 = v32;
    v86 = 2080;
    v87 = v36;
    v88 = 2080;
    v89 = v35;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "ServiceManager disconnection result for device %{public}s with service %{public}s (%d), profile 0x%x, result %d, r eason %d, isPaired %s, bs %s, inear %s, unt %s",  (uint8_t *)&buf,  0x56u);
    if (v73 < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_100897E98);
  }
  if (!sub_1003C9FF4((uint64_t)off_1008D67E0, (uint64_t)a2))
  {
    if (*(_BYTE *)(a1 + 696))
    {
LABEL_63:
      v37 = a1 + 696;
      if (qword_1008D5F50 != -1) {
        dispatch_once(&qword_1008D5F50, &stru_100897E58);
      }
      v38 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, a1 + 696, 1);
      v39 = (uint64_t)v38;
      if (v38 && sub_1003CF350(v38))
      {
        v40 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003FE1B4((unsigned __int8 *)v37, &buf);
          v41 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &buf : (std::string *)buf.__r_.__value_.__r.__words[0];
          *(_DWORD *)__p = 136446210;
          *(void *)&__p[4] = v41;
          _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "quickDisconnect reconnection attempt for device %{public}s",  __p,  0xCu);
        }

        if (qword_1008D60D0 != -1) {
          dispatch_once(&qword_1008D60D0, &stru_100897EF8);
        }
        memset(&buf, 0, sizeof(buf));
        v42 = sub_100424360((int64x2_t *)off_1008D60C8, v39, -1, &buf, 2LL);
        if ((_DWORD)v42)
        {
          v43 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
            sub_10067DD90(v42, v43, v44, v45, v46, v47, v48, v49);
          }
        }
      }

      else
      {
        v50 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "QuickDisconnect device not found or not paired",  (uint8_t *)&buf,  2u);
        }
      }

      *(_WORD *)(v37 + 4) = 0;
      *(_DWORD *)v37 = 0;
    }

    else
    {
      v52 = 0LL;
      while (v52 != 5)
      {
        if (*(unsigned __int8 *)(a1 + 697 + v52++))
        {
          break;
        }
      }

      if (v66 == 10721
        && sub_1003CF350(a2)
        && sub_1003D2B2C((uint64_t)a2, 0)
        && sub_1003D2B2C((uint64_t)a2, 1)
        && sub_1003D2B2C((uint64_t)a2, 3))
      {
        v54 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)a2, &buf);
          v55 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &buf : (std::string *)buf.__r_.__value_.__r.__words[0];
          *(_DWORD *)__p = 136446210;
          *(void *)&__p[4] = v55;
          _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "Post-swap reconnection attempt for device %{public}s",  __p,  0xCu);
        }

        if (qword_1008D60D0 != -1) {
          dispatch_once(&qword_1008D60D0, &stru_100897EF8);
        }
        memset(&buf, 0, sizeof(buf));
        v56 = sub_100424360((int64x2_t *)off_1008D60C8, (uint64_t)a2, -1, &buf, 2LL);
        if ((_DWORD)v56)
        {
          v57 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
            sub_10067DD2C(v56, v57, v58, v59, v60, v61, v62, v63);
          }
        }
      }
    }
  }

  return sub_100242FAC((uint64_t)v70);
}

            id v15 = 0;
            __int128 v14 = 0;
            goto LABEL_48;
          }

          *(_BYTE *)(a1 + 530) = 1;
        }

        else
        {
          v29 = sub_1002E6E9C();
          if (((*(uint64_t (**)(uint64_t))(*(void *)v29 + 2736LL))(v29) & 1) == 0)
          {
            uint64_t v30 = (os_log_s *)qword_1008F75A0;
            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
            {
              v51 = *(void *)a1;
              sub_1005BFC20(v5, &buf);
              v52 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
                  ? &buf
                  : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
              LODWORD(__p.__r_.__value_.__l.__data_) = 138412546;
              *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v51;
              WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v52;
              _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "FastLEConnection:LeDevice::enableFastLEConnection device %@ (%s) No LTK provided but required",  (uint8_t *)&__p,  0x16u);
            }

            id v15 = 0;
            __int128 v14 = 0;
            LODWORD(v6) = 149;
            goto LABEL_48;
          }
        }
      }

      if (*(_BYTE *)(a1 + 529)) {
        return 0LL;
      }
      uint64_t v6 = sub_1002E6E9C();
      LODWORD(v6) = (*(uint64_t (**)(uint64_t, unint64_t, BOOL, void, void, id))(*(void *)v6 + 1856))( v6,  v5,  *(void *)(a1 + 24) != 0,  *(unsigned __int8 *)(a1 + 528),  [*(id *)(a1 + 520) length],  objc_msgSend(*(id *)(a1 + 520), "bytes"));
      if (!(_DWORD)v6)
      {
        id v15 = 0;
        __int128 v14 = 1;
        *(_BYTE *)(a1 + 529) = 1;
        goto LABEL_48;
      }

      v28 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
      {
        v47 = *(void *)a1;
        sub_1005BFC20(v5, &__p);
        v48 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &__p
            : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        v49 = *(void *)(a1 + 520);
        v50 = *(unsigned __int8 *)(a1 + 528);
        LODWORD(buf.__r_.__value_.__l.__data_) = 138413314;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v47;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v48;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2112;
        *(void *)v55 = v49;
        *(_WORD *)&v55[8] = 1024;
        *(_DWORD *)v56 = v50;
        *(_WORD *)&v56[4] = 1024;
        *(_DWORD *)v57 = v6;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "FastLEConnection:LeDevice::enableFastLEConnection Failed writePeerControllerCachedInfo for device %@ (%s) cach ed data:%@ version:%d returned %d, aborting",  (uint8_t *)&buf,  0x2Cu);
      }

      if (!*(_BYTE *)(a1 + 530)) {
        goto LABEL_43;
      }
    }

    else
    {
      if (*(_BYTE *)(a1 + 529))
      {
        uint64_t v7 = sub_1002E6E9C();
        id v8 = (*(uint64_t (**)(uint64_t, unint64_t, BOOL))(*(void *)v7 + 1864LL))( v7,  v5,  *(void *)(a1 + 24) != 0LL);
        *(_BYTE *)(a1 + 529) = 0;
        if (v8)
        {
          uint64_t v9 = v8;
          unint64_t v10 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
          {
            v44 = *(void *)a1;
            sub_1005BFC20(v5, &__p);
            v45 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
                ? &__p
                : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
            LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v44;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v45;
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
            *(_DWORD *)v55 = v9;
            _os_log_error_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "FastLEConnection:LeDevice::enableFastLEConnection FastLEConnection:removePeerControllerCachedInfo device % @ (%s) returned %d",  (uint8_t *)&buf,  0x1Cu);
          }
        }
      }

      if (!*(_BYTE *)(a1 + 530))
      {
        id v15 = 0;
        __int128 v14 = 0;
        LODWORD(v6) = 0;
LABEL_48:
        v53 = 0;
        sub_100242CA4(&v53);
        v31 = *(unsigned __int8 *)(a1 + 530);
        v32 = sub_1002E6E9C();
        v33 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 2736LL))(v32);
        v34 = sub_1001BF0CC(v5, v31 != 0, v14, v33 ^ 1u);
        v35 = v34;
        if (v14) {
          v36 = 1;
        }
        else {
          v36 = v6;
        }
        if (v34) {
          uint64_t v6 = v36;
        }
        else {
          uint64_t v6 = v6;
        }
        v37 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          v38 = *(void *)a1;
          sub_1005BFC20(v5, &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
          }
          v40 = *(unsigned __int8 *)(a1 + 544);
          LODWORD(buf.__r_.__value_.__l.__data_) = 138414082;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v38;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
          *(_DWORD *)v55 = a2;
          *(_WORD *)&v55[4] = 1024;
          *(_DWORD *)&v55[6] = v40;
          *(_WORD *)v56 = 1024;
          *(_DWORD *)&v56[2] = v35;
          *(_WORD *)v57 = 1024;
          *(_DWORD *)&v57[2] = v15;
          v58 = 1024;
          v59 = v14;
          v60 = 1024;
          v61 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "FastLEConnection:LeDevice::enableFastLEConnection device:%@ address:%s enable:%d fFastLeConnectionAllowed:%d LE_GAP_EnableFastLeConnectionForAddress:%d shouldRemoveLTKFromController:%d, shouldEnable:%d ret:%d",  (uint8_t *)&buf,  0x3Au);
        }

        sub_100242CD8(&v53);
        return v6;
      }

      LODWORD(v6) = 0;
    }

    dispatch_source_t v11 = sub_1002E6E9C();
    uint64_t v12 = (*(uint64_t (**)(uint64_t, unint64_t, BOOL))(*(void *)v11 + 1840LL))( v11,  v5,  *(void *)(a1 + 24) != 0LL);
    *(_BYTE *)(a1 + 530) = 0;
    if (v12)
    {
      __int128 v13 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
      {
        v42 = *(void *)a1;
        sub_1005BFC20(v5, &__p);
        v43 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &__p
            : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 138412802;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v42;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v43;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
        *(_DWORD *)v55 = v12;
        _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "FastLEConnection:LeDevice::enableFastLEConnection FastLEConnection:removeStoredLTKForDevice device %@ (%s) returned %d",  (uint8_t *)&buf,  0x1Cu);
      }
    }

    __int128 v14 = 0;
    id v15 = 1;
    goto LABEL_48;
  }

  int8x16_t v16 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
  {
    v46 = *(void *)a1;
    LODWORD(buf.__r_.__value_.__l.__data_) = 138412290;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v46;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "FastLEConnection: %@ Address cannot be 0",  (uint8_t *)&buf,  0xCu);
    int8x16_t v16 = (os_log_s *)qword_1008F75A0;
  }

  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
    sub_10069A948((uint64_t *)a1, v16, v17);
  }
  return 8LL;
}
}

LABEL_44:
      if (v78)
      {
        if (v9) {
          goto LABEL_46;
        }
      }

      else
      {
        v78 = [v12 nearbyInfoV2InvitationCounter];
        if (v9) {
          goto LABEL_46;
        }
      }

      uint64_t v9 = [v12 nearbyInfoV2InvitationRouteType];
LABEL_46:
      objc_autoreleasePoolPop(v13);
      dispatch_source_t v11 = (char *)v11 + 1;
    }

    while (v7 != v11);
    v38 = [obj countByEnumeratingWithState:&v89 objects:v95 count:16];
    uint64_t v7 = v38;
  }

  while (v38);

  if ((v68 & 1) == 0)
  {
    uint64_t v6 = 0;
    id v3 = v67;
    goto LABEL_98;
  }

  v39 = v9;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  id v3 = v67;
  id obj = (id)objc_claimAutoreleasedReturnValue(-[CBAdvertiserDaemon advertiserArray](v67, "advertiserArray"));
  v40 = [obj countByEnumeratingWithState:&v85 objects:v94 count:16];
  if (!v40) {
    goto LABEL_94;
  }
  v41 = v40;
  v42 = *(void *)v86;
  if (v78) {
    v43 = v39 == 0;
  }
  else {
    v43 = 1;
  }
  v44 = !v43;
  v79 = v44;
  while (2)
  {
    v45 = 0LL;
    while (2)
    {
      if (*(void *)v86 != v42) {
        objc_enumerationMutation(obj);
      }
      v46 = *(void **)(*((void *)&v85 + 1) + 8 * v45);
      v47 = objc_claimAutoreleasedReturnValue([v46 nearbyInfoV2AuthTagData]);
      if (v47)
      {
        v48 = (void *)v47;
        if ([v46 nearbyInfoV2Flags])
        {

LABEL_67:
          v50 = (void *)objc_claimAutoreleasedReturnValue([v46 nearbyInfoV2AuthTagData]);
          Current = CFAbsoluteTimeGetCurrent();
          v83 = 0xBFF0000000000000LL;
          v84 = 0xBFF0000000000000LL;
          v82 = -1;
          if (!v2->_prefSystemReferenceTimeDisabled && TMGetReferenceTime(&v84, &v83, &v82) && v82)
          {
            v53 = *(double *)&v84;
            if (dword_1008D5FD8 > 20)
            {
              v54 = *(double *)&v84;
            }

            else
            {
              v54 = *(double *)&v84;
              if (dword_1008D5FD8 != -1
                || (v63 = _LogCategory_Initialize(&dword_1008D5FD8, 20LL), v54 = *(double *)&v84, v63))
              {
                v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v54));
                v56 = objc_claimAutoreleasedReturnValue([v55 description]);
                v57 = [v56 UTF8String];
                LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserUpdateWithAuthTagNC]",  20LL,  "System reference time for advertising %f, (%s). delta: %f ±%f reliability %d for auth tag: %@",  *(void *)&v54,  v57,  v53 - Current,  v83,  v82,  v50);

                v54 = *(double *)&v84;
              }
            }
          }

          else
          {
            if (dword_1008D5FD8 <= 20
              && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 20LL)))
            {
              v52 = "disabled";
              if (!v2->_prefSystemReferenceTimeDisabled) {
                v52 = "not available";
              }
              LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserUpdateWithAuthTagNC]",  20LL,  "System reference time for advertising '%s' for auth tag: %@",  v52,  v50);
            }

            v54 = Current;
          }

          if ((v93 & 1) == 0) {
            v93 = v93 & 0xFE | v79;
          }
          v81 = (double)((v54 + kCFAbsoluteTimeIntervalSince1970) / 7200.0) * 7200.0
              - kCFAbsoluteTimeIntervalSince1970;
          v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData data](&OBJC_CLASS___NSMutableData, "data"));
          v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  "bleAdv22IauthTag",  16LL));
          [v58 appendData:v59];

          v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &v81, 8LL));
          [v58 appendData:v60];

          v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &v93, 1LL));
          [v58 appendData:v61];

          [v58 appendData:v50];
          v62 = (void *)objc_claimAutoreleasedReturnValue( -[RPIdentity authTagForData:type:error:]( v2->_identitySelf,  "authTagForData:type:error:",  v58,  2LL,  0LL));
          [v46 setNearbyInfoV2AuthIntegrityTagData:v62];
          if (dword_1008D5FD8 <= 20
            && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 20LL)))
          {
            LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _bleAdvertiserUpdateWithAuthTagNC]",  20LL,  "IntegrityTag parameters advertisting: AT %@, IT %@, CBIN %u, T: %f, F2: %u",  v50,  v62,  ((v54 + kCFAbsoluteTimeIntervalSince1970) / 7200.0),  *(void *)&v81,  v93);
          }

          uint64_t v2 = v76;
        }

        else
        {
          v49 = [v46 nearbyInfoV2DecryptedFlags];

          if (v49) {
            goto LABEL_67;
          }
        }
      }

      if (v41 != (id)++v45) {
        continue;
      }
      break;
    }

    v64 = [obj countByEnumeratingWithState:&v85 objects:v94 count:16];
    v41 = v64;
    if (v64) {
      continue;
    }
    break;
  }

  id v3 = v67;
  uint64_t v4 = v71;
LABEL_94:
  uint64_t v6 = v66;
LABEL_96:

LABEL_98:
LABEL_99:

  return v6;
}

  v258 = 0LL;
  v259 = 0LL;
  v236 = sub_1003D55EC((uint64_t)a3, (_DWORD *)&v259 + 1, &v259, (_DWORD *)&v258 + 1, &v258);
  v29 = sub_1003DFE78((uint64_t)a3);
  if ((_DWORD)v29 != -[CBDevice adaptiveVolumeConfig](self, "adaptiveVolumeConfig"))
  {
    -[CBDevice setAdaptiveVolumeConfig:](self, "setAdaptiveVolumeConfig:", v29);
    v23 = 0x80000000000LL;
  }

  uint64_t v30 = sub_1003E0230((uint64_t)a3, 144);
  v31 = sub_1002E6E9C();
  v32 = v30 & sub_1002CD53C(v31, 0);
  if ((_DWORD)v32 == 1 && -[CBDevice adaptiveVolumeCapability](self, "adaptiveVolumeCapability") != 1)
  {
    -[CBDevice setAdaptiveVolumeCapability:](self, "setAdaptiveVolumeCapability:", v32);
    v23 = 0x80000000000LL;
  }

  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_10087F780);
  }
  v33 = sub_10021B978((uint64_t)off_1008D60D8, (uint64_t)a3);
  if (v33 > 2) {
    v34 = 0LL;
  }
  else {
    v34 = dword_1006BA944[v33];
  }
  if ((_DWORD)v34 != -[CBDevice audioStreamState](self, "audioStreamState"))
  {
    -[CBDevice setAudioStreamState:](self, "setAudioStreamState:", v34);
    v23 |= 0x80000000000uLL;
  }

  v35 = sub_1003E0230((uint64_t)a3, 176);
  v36 = sub_1002E6E9C();
  v37 = v35 & sub_1002CD53C(v36, 3u);
  if ((_DWORD)v37 == 1 && -[CBDevice autoAncCapability](self, "autoAncCapability") != 1)
  {
    -[CBDevice setAutoAncCapability:](self, "setAutoAncCapability:", v37);
    v23 |= 0x80000000000uLL;
  }

  v256 = 0u;
  v257 = 0u;
  v237 = sub_1003D0670((uint64_t)a3);
  if (v237 || (v38 = *((unsigned __int8 *)a3 + 1296), *((_BYTE *)a3 + 1296)))
  {
    sub_1003D7CD8((uint64_t)a3, (uint64_t)&v256);
    v38 = v256;
    v39 = BYTE4(v256);
  }

  else
  {
    v39 = 0;
  }

  if (v38 >= 100) {
    v40 = 100;
  }
  else {
    v40 = v38;
  }
  if (-[CBDevice batteryInfoMain](self, "batteryInfoMain") != (unsigned __int16)(v40 & ~(unsigned __int16)(v40 >> 31) | (v39 << 8)))
  {
    -[CBDevice setBatteryInfoMain:]( self,  "setBatteryInfoMain:",  (unsigned __int16)(v40 & ~(unsigned __int16)(v40 >> 31) | (v39 << 8)));
    v23 |= 0x80000000000uLL;
  }

  v41 = BYTE12(v256);
  if (SDWORD2(v256) >= 100) {
    v42 = 100;
  }
  else {
    v42 = DWORD2(v256);
  }
  if (-[CBDevice batteryInfoLeft](self, "batteryInfoLeft") != (unsigned __int16)(v42 & ~(unsigned __int16)(v42 >> 31) | (v41 << 8)))
  {
    -[CBDevice setBatteryInfoLeft:]( self,  "setBatteryInfoLeft:",  (unsigned __int16)(v42 & ~(unsigned __int16)(v42 >> 31) | (v41 << 8)));
    v23 |= 0x80000000000uLL;
  }

  v43 = BYTE4(v257);
  else {
    v44 = v257;
  }
  if (-[CBDevice batteryInfoRight](self, "batteryInfoRight") != (unsigned __int16)(v44 & ~(unsigned __int16)(v44 >> 31) | (v43 << 8)))
  {
    -[CBDevice setBatteryInfoRight:]( self,  "setBatteryInfoRight:",  (unsigned __int16)(v44 & ~(unsigned __int16)(v44 >> 31) | (v43 << 8)));
    v23 |= 0x80000000000uLL;
  }

  v45 = BYTE12(v257);
  if (SDWORD2(v257) >= 100) {
    v46 = 100;
  }
  else {
    v46 = DWORD2(v257);
  }
  if (-[CBDevice batteryInfoCase](self, "batteryInfoCase") != (unsigned __int16)(v46 & ~(unsigned __int16)(v46 >> 31) | (v45 << 8)))
  {
    -[CBDevice setBatteryInfoCase:]( self,  "setBatteryInfoCase:",  (unsigned __int16)(v46 & ~(unsigned __int16)(v46 >> 31) | (v45 << 8)));
    v23 |= 0x80000000000uLL;
  }

  *(_DWORD *)v255 = *((_DWORD *)a3 + 32);
  *(_WORD *)&v255[4] = *((_WORD *)a3 + 66);
  if (((unint64_t)v255[0] << 40) | ((unint64_t)v255[1] << 32) | ((unint64_t)v255[2] << 24) | ((unint64_t)v255[3] << 16) | ((unint64_t)v255[4] << 8) | v255[5])
  {
    LOBYTE(v251) = v255[0];
    *(_DWORD *)((char *)&v251 + 1) = *(_DWORD *)&v255[1];
    BYTE5(v251) = v255[5];
    v47 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice btAddressData](self, "btAddressData"));
    if ([v47 length] != (id)6
      || ((v48 = (unsigned __int16 *)[v47 bytes], (_DWORD)v251 == *(_DWORD *)v48)
        ? (v49 = WORD2(v251) == v48[2])
        : (v49 = 0),
          !v49))
    {
      v50 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v251, 6LL);
      -[CBDevice setBtAddressData:](self, "setBtAddressData:", v50);

      v23 |= 0x80000000000uLL;
    }
  }

  v254 = 0LL;
  v252 = 0u;
  *(_OWORD *)v253 = 0u;
  v251 = 0u;
  sub_10002418C(v253, "");
  if (sub_1003D9724((uint64_t)a3, (uint64_t)&v251) && (void)v252)
  {
    v51 = v252 >> 4;
    if (v251 < 2u)
    {
      v52 = v252 & 0xF;
    }

    else
    {
      v52 = ((unint64_t)v252 >> 20) & 0xFFF0 | v252 & 0xF;
      v51 |= WORD2(v252) & 0xFFF0;
    }

    v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%u.%u.%u",  (unsigned __int16)(v252 >> 8),  v51,  v52));
    v54 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice caseVersion](self, "caseVersion"));

    if (v53 != v54)
    {
      -[CBDevice setCaseVersion:](self, "setCaseVersion:", v53);
      v23 |= 0x80000000000uLL;
    }
  }

  v55 = sub_1003D0578((uint64_t)a3);
  if ((_DWORD)v55 != -[CBDevice classicRSSI](self, "classicRSSI"))
  {
    -[CBDevice setClassicRSSI:](self, "setClassicRSSI:", v55);
    v23 |= 0x200000000uLL;
  }

  v56 = sub_1003DFBD0((uint64_t)a3);
  if (-[CBDevice clickHoldModeLeft](self, "clickHoldModeLeft") != HIBYTE(v56))
  {
    -[CBDevice setClickHoldModeLeft:](self, "setClickHoldModeLeft:", HIBYTE(v56));
    v23 |= 0x80000000000uLL;
  }

  if (-[CBDevice clickHoldModeRight](self, "clickHoldModeRight") != v56)
  {
    -[CBDevice setClickHoldModeRight:](self, "setClickHoldModeRight:", v56);
    v23 |= 0x80000000000uLL;
  }

  v57 = sub_1003DFE34((uint64_t)a3);
  v58 = v57;
  v59 = v57 & 0xF;
  v240 = v10;
  v234 = v17;
  v232 = v18;
  if ((_DWORD)v59 == 1)
  {
    v62 = v57 >> 4;
    v63 = (v57 >> 8) & 0xF;
    v60 = (unsigned __int16)v57 >> 12;
    v61 = HIWORD(v57) & 0xF;
  }

  else if ((v57 & 0xF) != 0)
  {
    v62 = 0;
    v63 = 0;
    v60 = 0LL;
    v61 = 0LL;
  }

  else
  {
    v60 = 0LL;
    v61 = 0LL;
    v62 = v57 >> 4;
    v63 = (v57 >> 8) & 0xF;
  }

  if (sub_1003E0230((uint64_t)a3, 80))
  {
    if (v58) {
      v64 = v63;
    }
    else {
      v64 = 2LL;
    }
    -[CBDevice setCallMgmtMsg:]( self,  "setCallMgmtMsg:",  (v60 << 24) | (v61 << 32) | (v64 << 16) | (v62 << 8) | v59);
    if (-[CBDevice callMgmtMsg](self, "callMgmtMsg") == 1LL)
    {
      -[CBDevice setMuteControlCapability:](self, "setMuteControlCapability:", 1LL);
    }

    else if (!-[CBDevice callMgmtMsg](self, "callMgmtMsg"))
    {
      -[CBDevice setEndCallCapability:](self, "setEndCallCapability:", 1LL);
    }

    if ((_DWORD)v64 != -[CBDevice endCallConfig](self, "endCallConfig")
      || (_DWORD)v61 != -[CBDevice muteControlConfig](self, "muteControlConfig"))
    {
      -[CBDevice setEndCallConfig:](self, "setEndCallConfig:", v64);
      -[CBDevice setMuteControlConfig:](self, "setMuteControlConfig:", v61);
      v23 |= 0x80000000000uLL;
    }
  }

  v65 = sub_1003E16E4((uint64_t)a3);
  if (!-[CBDevice colorInfo](self, "colorInfo")
    && -[CBDevice colorInfo](self, "colorInfo") != v65)
  {
    -[CBDevice setColorInfo:](self, "setColorInfo:", v65);
    v23 |= 0x80000000000uLL;
  }

  v66 = (char *)a3 + 392;
  if (*((char *)a3 + 415) < 0)
  {
    sub_100024238(__p, *((void **)a3 + 49), *((void *)a3 + 50));
  }

  else
  {
    *(_OWORD *)__p = *v66;
    v250 = *((void *)a3 + 51);
  }

  if (SHIBYTE(v250) < 0)
  {
    v67 = __p[1];
    operator delete(__p[0]);
    if (!v67) {
      goto LABEL_142;
    }
  }

  else if (!HIBYTE(v250))
  {
    goto LABEL_142;
  }

  if (*((char *)a3 + 415) < 0)
  {
    sub_100024238(__p, *((void **)a3 + 49), *((void *)a3 + 50));
  }

  else
  {
    *(_OWORD *)__p = *v66;
    v250 = *((void *)a3 + 51);
  }

  if (v250 >= 0) {
    v68 = __p;
  }
  else {
    v68 = (void **)__p[0];
  }
  v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v68));
  if (SHIBYTE(v250) < 0) {
    operator delete(__p[0]);
  }
  v70 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice model](self, "model"));

  if (v69 != v70)
  {
    -[CBDevice setModel:](self, "setModel:", v69);
    v23 |= 0x80000000000uLL;
  }

LABEL_142:
  v71 = sub_100425684((uint64_t)v8, (uint64_t)a3);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_10087F700);
  }
  if (*((_BYTE *)off_1008D60A8 + 76))
  {
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    v72 = sub_10012D890((uint64_t)v255);
    if (v72 && !*(_BYTE *)(v72 + 54)) {
      LODWORD(v71) = v71 | 0x800000;
    }
    v73 = sub_10012D8E8((uint64_t)v255);
    sub_100242CD0(__p);
    if (v73) {
      v71 = v71 | 0x1000000;
    }
    else {
      v71 = v71;
    }
    sub_100242CD8(__p);
  }

  if ((_DWORD)v71 != -[CBDevice connectedServices](self, "connectedServices"))
  {
    -[CBDevice setConnectedServices:](self, "setConnectedServices:", v71);
    v23 |= 0x80000200000uLL;
  }

  v74 = sub_1003DFF00((uint64_t)a3);
  if (v74 != -[CBDevice conversationDetectConfig](self, "conversationDetectConfig"))
  {
    -[CBDevice setConversationDetectConfig:](self, "setConversationDetectConfig:", v74);
    v23 |= 0x80000000000uLL;
  }

  v75 = sub_1003E0230((uint64_t)a3, 160);
  v76 = sub_1002E6E9C();
  v77 = v75 & sub_1002CD53C(v76, 2u);
  if ((_DWORD)v77 == 1
    && -[CBDevice conversationDetectCapability](self, "conversationDetectCapability") != 1)
  {
    -[CBDevice setConversationDetectCapability:](self, "setConversationDetectCapability:", v77);
    v23 |= 0x80000000000uLL;
  }

  v78 = sub_1003DFCE0((uint64_t)a3);
  if ((_DWORD)v78 != -[CBDevice crownRotationDirection](self, "crownRotationDirection"))
  {
    -[CBDevice setCrownRotationDirection:](self, "setCrownRotationDirection:", v78);
    v23 |= 0x80000000000uLL;
  }

  v79 = -[CBDevice deviceFlags](self, "deviceFlags");
  v80 = sub_1003D2B2C((uint64_t)a3, 12);
  v81 = sub_1003D2B2C((uint64_t)a3, 16);
  v82 = *((unsigned __int8 *)a3 + 960);
  v83 = *((unsigned __int8 *)a3 + 976);
  v84 = sub_1003EE52C(v235, (uint64_t)a3);
  v85 = sub_1003D2B2C((uint64_t)a3, 27);
  v86 = sub_1003D2B2C((uint64_t)a3, 26);
  v87 = v83 != 0;
  v88 = (v239 >> 19) & 1;
  if (v80) {
    v88 |= 0x1000000uLL;
  }
  if (v81) {
    v88 |= 0x4000000uLL;
  }
  if (v82) {
    v89 = v88 | 0x2000000;
  }
  else {
    v89 = v88;
  }
  if (v84) {
    v90 = 2LL;
  }
  else {
    v90 = 0LL;
  }
  if (v85) {
    v91 = 4LL;
  }
  else {
    v91 = 0LL;
  }
  if (v86) {
    v92 = 8LL;
  }
  else {
    v92 = 0LL;
  }
  v93 = v89 & 0xFFFFFFFFCF7FFFF1LL | (v87 << 29) | v90 | v91 | v92;
  if (!sub_1003E0230((uint64_t)a3, 64)
    || (v94 = sub_1002E6BF0(), !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v94 + 792LL))(v94, 1LL)))
  {
    v248 = 0;
LABEL_186:
    v98 = v93 & 0xFFFFFFFFBFFFFFFFLL;
    goto LABEL_187;
  }

  v248 = 0;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_10087F7A0);
  }
  sub_100400F20((uint64_t)off_1008D5F48, (uint64_t)a3, &v248);
  v95 = v248 == 1;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087F7C0);
  }
  v96 = sub_1004B39EC((uint64_t)off_1008D60E8, (uint64_t)a3);
  v97 = v93 | (v95 << 28);
  if (!v96)
  {
    v93 = v97 | 0x800000;
    goto LABEL_186;
  }

  v98 = v97 | 0x40800000;
LABEL_187:
  else {
    v99 = v98 & 0xFFFFFFFFFFFFFFEFLL;
  }
  v100 = sub_1003D2B2C((uint64_t)a3, 17);
  v101 = sub_1003D2B2C((uint64_t)a3, 33);
  v102 = sub_1003E0164((uint64_t)a3);
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_10087F7E0);
  }
  v103 = sub_10061C0F8(qword_1008D5F18, v243);
  v104 = sub_1003CF350((unsigned __int8 *)a3);
  sub_1005CF060(v233, v243, (uint64_t)__p);
  v105 = 0x8000000LL;
  if (!v100) {
    v105 = 0LL;
  }
  v106 = 32LL;
  if (!v101) {
    v106 = 0LL;
  }
  v107 = v105 | v106;
  v108 = 64LL;
  if (!v102) {
    v108 = 0LL;
  }
  v109 = v107 | v108;
  v110 = 0x2000LL;
  if (!v103) {
    v110 = 0LL;
  }
  v111 = v109 | v110 | v99 & 0xFFFFFFFFF7EB1F9FLL;
  if (v104) {
    v112 = 0x4000LL;
  }
  else {
    v112 = 0LL;
  }
  if (SHIBYTE(v250) < 0)
  {
    v113 = __p[1] == 0LL;
    operator delete(__p[0]);
  }

  else
  {
    v113 = SHIBYTE(v250) == 0;
  }

  v114 = 0x8000LL;
  if (v113) {
    v114 = 0LL;
  }
  v115 = v111 | v112 | v114 | ((unint64_t)*((unsigned __int8 *)a3 + 1435) << 18) | ((unint64_t)*((unsigned __int8 *)a3 + 1296) << 20);
  if (v237)
  {
    v116 = sub_1003E5998((uint64_t)a3);
    v117 = 0x200000LL;
    if (!v116) {
      v117 = 0LL;
    }
    v118 = v117 | v115 & 0xFFFFFFFFFFDFFFFFLL;
    if (*((_BYTE *)a3 + 1436))
    {
      v119 = v118 | 0x400000;
      goto LABEL_216;
    }
  }

  else
  {
    v118 = v115 & 0xFFFFFFFFFFDFFFFFLL;
  }

  v119 = v118 & 0xFFFFFFFFFFBFFFFFLL;
LABEL_216:
  v120 = sub_1003DFD24((uint64_t)a3) == 1;
  v121 = sub_1003E4588((uint64_t)a3);
  v122 = sub_1003D94C4((uint64_t)a3);
  v123 = sub_1003DD840((uint64_t)a3);
  v124 = v119 & 0xFFFFFBFF7FFFFFFFLL | (v120 << 31) | 0x40000001000LL;
  if (v113 | v104) {
    v124 = v119 & 0xFFFFFAFF7FF4EFFFLL | (v120 << 31) & 0xFFFFFAFFFFF4EFFFLL | 0x40000000000LL;
  }
  v125 = 0x20000LL;
  if (!v121) {
    v125 = 0LL;
  }
  v126 = 0x10000LL;
  if (v121) {
    v126 = 0LL;
  }
  v127 = 0x80000LL;
  if (!v122) {
    v127 = 0LL;
  }
  v128 = 0x10000000000LL;
  if (!v123) {
    v128 = 0LL;
  }
  v129 = v125 | v126 | v127 | v128 | v124 & 0xFFFFFEFFFFF4FFFFLL;
  if (v231) {
    v130 = v129 & 0xFFFFFF7FFFFFFFFFLL | ((unint64_t)(v231 == 1) << 39);
  }
  else {
    v130 = v129;
  }
  if ((id)v130 != v79)
  {
    -[CBDevice setDeviceFlags:](self, "setDeviceFlags:");
    v23 |= 0x80000000000uLL;
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_10087F700);
  }
  if (*((_BYTE *)off_1008D60A8 + 76))
  {
    LOBYTE(v244) = 0;
    LOWORD(__p[0]) = 0;
    LOWORD(v245) = 0;
    sub_1003D6EF4((uint64_t)a3, __p, &v244, &v245);
    if ((_BYTE)v244)
    {
      else {
        v131 = off_10087F800[(char)(v244 - 1)];
      }
      v132 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v131));
      v133 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice btVersion](self, "btVersion"));
      v134 = v132;
      v135 = v133;
      if (v134 == v135)
      {
      }

      else
      {
        v136 = v135;
        if ((v134 == 0LL) != (v135 != 0LL))
        {
          v137 = [v134 isEqual:v135];

          if ((v137 & 1) != 0) {
            goto LABEL_246;
          }
        }

        else
        {
        }

        -[CBDevice setBtVersion:](self, "setBtVersion:", v134);
        v23 |= 0x80000000000uLL;
      }

  return (char)v13;
}

      (*(void (**)(uint64_t, uint64_t, void, void, void))(*(void *)(qword_1008DFDB0 + 24) + 56LL))( a3,  v20,  0LL,  0LL,  a2);
      return a2;
    }
  }

  if (*(_BYTE *)(a2 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c",  4070,  "(*pBs).__RWFlag == BYTESTREAM_READ");
  }
  if (*(_BYTE *)(a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
  }

  else
  {
    unint64_t v21 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) > v21)
    {
      unint64_t v22 = *(void *)a2;
      *(_WORD *)(a2 + 12) = v21 + 1;
      v23 = *(unsigned __int8 *)(v22 + v21) >> 2;
      if (!*(_BYTE *)(qword_1008DFDB0 + 96)) {
        goto LABEL_47;
      }
      uint64_t v24 = 0LL;
      v25 = *(void *)qword_1008DFDB0;
      while (*(unsigned __int8 *)(v25 + 25) != v23)
      {
        ++v24;
        v25 += 40LL;
      }

      if (v24 != 255)
      {
        LODWORD(a2) = 0;
        v26 = 1;
      }

      else
      {
LABEL_47:
        v26 = 0;
        v25 = 0LL;
        LODWORD(a2) = 18;
      }

      goto LABEL_32;
    }
  }

  v23 = 0;
  v26 = 0;
  v25 = 0LL;
  *(_BYTE *)(a2 + 15) = 1;
  LODWORD(a2) = 17;
LABEL_32:
  if (sub_1000A86F0())
  {
    v27 = sub_1000E4C8C(v23, a1);
    sub_1000DB7D8(v27);
    sub_1001EE134( (uint64_t)"AVDT_GetConfiguration_Rsp\n\tTransaction=%d\n\tStreamHandle=%d\n\tError=0x%.2x\n\tConfigParams=\n",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  a3);
    v35 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      v36 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      v49 = v36;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (v26)
  {
    v37 = *(unsigned __int8 **)(v25 + 8);
    v38 = *(unsigned __int8 *)(v25 + 31);
    v39 = a1;
    v40 = a3;
    v41 = 0;
  }

  else
  {
    v39 = a1;
    v40 = a3;
    v37 = 0LL;
    v38 = 0;
    v41 = a2;
  }

  sub_1000E6010(v39, 4u, v40, v37, v38, v41);
  return a2;
}

  *(void *)(v4 + v5 + 1560) |= 8uLL;
  if ((v21 & 0x10) == 0)
  {
LABEL_37:
    if ((v21 & 0x200) == 0) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  *(void *)(v9 + v4 + 88) |= 8uLL;
  if ((v10 & 0x10) == 0)
  {
LABEL_33:
    if ((v10 & 0x200) == 0) {
      goto LABEL_34;
    }
LABEL_46:
    *(void *)(v9 + v4 + 88) |= 0x20uLL;
    if ((v10 & 0x400) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }

      v63[72] = v11;
      unint64_t v10 = sub_100184F74(*(__int128 **)v63, (char *)buf, 7uLL, 1);
      if ((_DWORD)v10)
      {
        sub_100184BB0(v63, v10, 1);
      }

      else
      {
        sub_100185420((uint64_t)v63, 17);
        *(_DWORD *)(v63 + 579) = *(_DWORD *)buf;
        *(_WORD *)(v63 + 583) = (_WORD)v83;
        v63[585] = BYTE2(v83);
      }

      return v10;
    }

    v63 = sub_100185244(a1);
    if (v63) {
      goto LABEL_44;
    }
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Could not allocate a pairing record for handle 0x%x",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  a1);
      v80 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
        sub_100657F08();
      }
    }

    return 104LL;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid connection handle.", v54, v55, v56, v57, v58, v59, v60, v81);
      v61 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4820LL;
  }

      if (*(_BYTE *)(sub_10017AB4C(a1) + 16) == 4) {
        sub_10017764C(a1);
      }
      v52 = *(_BYTE **)sub_10017AB4C(a1);
      v53 = sub_100196568();
      v54 = sub_10017AB4C(a1);
      sub_1001967F4("aamsfro", 4u, a1, v52, v53, v55, v56, v57, *(unsigned __int16 *)(v54 + 8));
      uint64_t v12 = 0LL;
      *(_BYTE *)(sub_10017AB4C(a1) + 26) = 2;
      return v12;
    }

  if ((sub_1001C2930(a5) & 1) == 0 && v11)
  {
    *(void *)(a5 + 16) = 0LL;
    v63 = *(void *)(a5 + 80);
    v64 = *(unsigned __int16 *)(a5 + 88);
    v62 = *(void *)(a5 + 24);
    goto LABEL_36;
  }

    sub_100657858();
    return 4823LL;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This command is only available to LE devices.", v15, v16, v17, v18, v19, v20, v21, v72);
    unint64_t v22 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 4820LL;
}

      if (!v38) {
        goto LABEL_48;
      }
      v28 = (char *)__p;
      if (v35 != __p) {
        break;
      }
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR))
      {
        sub_10065D08C(&v32, v33);
        uint64_t v30 = 0;
        uint64_t v1 = 112LL;
        goto LABEL_49;
      }

      uint64_t v30 = 0;
      uint64_t v1 = 112LL;
      if (v28) {
        goto LABEL_50;
      }
LABEL_51:
      if ((v30 & 1) != 0) {
        goto LABEL_52;
      }
      dispatch_source_t v11 = 0;
LABEL_53:
      if (SHIBYTE(v37[3]) < 0) {
        operator delete(v37[1]);
      }
      if ((v11 & 1) == 0) {
        return v1;
      }
      v4 += 40LL;
      if (v4 == v5) {
        return 0LL;
      }
    }

    v29 = v38(&__p);
    if ((_DWORD)v29)
    {
      uint64_t v30 = 0;
      uint64_t v1 = v29;
    }

    else
    {
LABEL_48:
      uint64_t v30 = 1;
    }

  v38 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10066BDA4(v38, v39, v40, v41, v42, v43, v44, v45);
  }
  return result;
}

    uint64_t v4 = 0LL;
    goto LABEL_45;
  }

  if (!(_DWORD)v14) {
    goto LABEL_24;
  }
LABEL_12:
  id v15 = (os_log_s *)qword_1008F75E0;
  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2, v32);
    int8x16_t v16 = v33 >= 0 ? v32 : (void **)v32[0];
    *(_DWORD *)buf = 136446722;
    *(void *)&buf[4] = v16;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v4;
    v41 = 1024;
    v42 = a3;
    _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Failed to write magicKey data for device %{public}s to keychain with result %d for keyType %d",  buf,  0x18u);
    if (v33 < 0) {
      operator delete(v32[0]);
    }
  }

    v23 = (os_log_s *)(id)qword_1008F7578;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = objc_claimAutoreleasedReturnValue( [@"/usr/share/firmware/bluetooth/" stringByAppendingString:v21]);
      v25 = [v24 UTF8String];
      *(_DWORD *)__p = 136315394;
      *(void *)&__p[4] = v25;
      *(_WORD *)&__p[12] = 2080;
      *(void *)&__p[14] = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Found file from HWIdentifiers: %s with extension: %s",  __p,  0x16u);
    }

    v26 = objc_claimAutoreleasedReturnValue( [@"/usr/share/firmware/bluetooth/" stringByAppendingString:v21]);
    sub_10002418C(v28, (char *)[v26 UTF8String]);

    uint64_t v17 = (void *)v18;
LABEL_52:

    goto LABEL_53;
  }

  int8x16_t v16 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10066E478((char *)v3 + 23, v3, v16);
  }
  sub_10002418C(v28, "");
LABEL_53:
}

          v29 = *(void (****)(void, void *, uint64_t, void, uint64_t, void, void))v12;
          uint64_t v30 = sub_100241F94(dst);
          v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
          (**v29)(v29, v31, a5, *(unsigned __int16 *)(v14 + 2), a2, 0LL, v39);

          if (v21)
          {
            sub_10036B95C(26 - v17, *(void *)(v14 + 128), -v17);
            *(void *)(v14 + 12_Block_object_dispose(&STACK[0x338], 8) = v32;
          }

          return;
        }

  sub_100242FAC((uint64_t)v21);
  return v11;
}

        __int128 v13 = (char *)__p;
LABEL_45:
        v37 = v13;
        ++v14;
      }

      while (v14 != v33);
    }

    if (a5) {
      a5 = *(_DWORD *)a5 != 0;
    }
    goto LABEL_77;
  }

  if (__p != v37)
  {
    do
    {
      v34 = *(_OWORD *)v13;
      sub_10025EB84(&v34);
      v13 += 16;
    }

    while (v13 != v37);
LABEL_74:
    a5 = 0LL;
LABEL_75:
    __int128 v13 = (char *)__p;
  }

  else
  {
LABEL_76:
    a5 = 0LL;
  }

  v25 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C((uint64_t)v10, &v29);
    v26 = (v29.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &v29 : (std::string *)v29.__r_.__value_.__r.__words[0];
    LODWORD(__p) = 136446210;
    *(void *)((char *)&__p + 4) = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Discovered device %{public}s",  (uint8_t *)&__p,  0xCu);
  }

  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_1008965B0);
  }
  sub_10042A100((uint64_t)off_1008D60C8, (uint64_t)v10);
  if (v11)
  {
    v27 = (sqlite3 **)sub_1002E6CF8();
    sub_1002D3D2C(v27, (uint64_t)v10);
  }

  sub_100242FAC((uint64_t)v31);
  return v10;
}

  if (__p)
  {
    v32 = __p;
    operator delete(__p);
  }

  if ((v22 & 1) != 0) {
    goto LABEL_47;
  }
}

      uint64_t v9 = (__int16)v9 - v13;
      unint64_t v10 = v9 << 16;
    }

    while (v9 << 16 > 0);
  }

  sub_100242FAC((uint64_t)v48);
  return v11;
}

  int8x16_t v18 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionVar2");
  v19 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t *))(*(void *)v18 + 88LL))(v18, buf, __p, &v60);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v19) {
      goto LABEL_52;
    }
  }

  else if (!v19)
  {
    goto LABEL_52;
  }

  v20 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v60;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionVar2 (%d)",  buf,  8u);
  }

  if (v26 && [*(id *)(a1 + 760) containsObject:v5])
  {
    [*(id *)(a1 + 760) removeObject:v5];
    if (*(_DWORD *)(a1 + 928))
    {
      v37 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__str = 138543362;
        *(void *)&__str[4] = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: Device %{public}@ setDeviceIntoConnectionPendingList ",  __str,  0xCu);
      }

      sub_100241F90(__str, v5);
      sub_100594AE4(a1, __str);
    }

    else
    {
      v38 = sub_100590B30(a1, 0);
      v39 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__str = 138543618;
        *(void *)&__str[4] = v5;
        *(_WORD *)&__str[12] = 1024;
        *(_DWORD *)&__str[14] = v38;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: Device %{public}@ cancelAllPendingConnections returned %d ",  __str,  0x12u);
      }

      if (v38)
      {
        sub_1005963D8(a1, v5);
        v40 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__str = 138543362;
          *(void *)&__str[4] = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: addToConnectingList %{public}@",  __str,  0xCu);
        }

        sub_10059EB5C(a1);
      }

      else
      {
        sub_100241F90(__str, v5);
        sub_100594AE4(a1, __str);
        v41 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__str = 138543362;
          *(void *)&__str[4] = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDenyList: setDeviceIntoConnectionPendingList %{public}@",  __str,  0xCu);
        }
      }
    }
  }

  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }

LABEL_65:
}

void sub_100013EA4(_Unwind_Exception *a1)
{
}

void sub_100014008(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) == *(void *)(v9 + 264))
  {
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    id v10 = *(id *)(v9 + 536);
    id v11 = [v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v19;
      do
      {
        for (i = 0LL; i != v12; i = (char *)i + 1)
        {
          if (*(void *)v19 != v13) {
            objc_enumerationMutation(v10);
          }
          id v15 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)i);
          int8x16_t v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "activatedController", (void)v18));
          unsigned __int16 v17 = (unsigned __int16)[v16 internalFlags];

          if ((v17 & 0x2000) != 0) {
            [v15 xpcReceivedAudioAccessoryEventType:a2 messageData:v7 sourceDevice:v8];
          }
        }

        id v12 = [v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
      }

      while (v12);
    }
  }
}

void sub_100014164(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) == *(void *)(v4 + 264))
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v5 = *(id *)(v4 + 536);
    id v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v14;
      do
      {
        for (i = 0LL; i != v7; i = (char *)i + 1)
        {
          if (*(void *)v14 != v8) {
            objc_enumerationMutation(v5);
          }
          id v10 = *(void **)(*((void *)&v13 + 1) + 8LL * (void)i);
          id v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "activatedController", (void)v13));
          unsigned __int16 v12 = (unsigned __int16)[v11 internalFlags];

          if ((v12 & 0x2000) != 0) {
            [v10 xpcReceivedAudioAccessoryDeviceInfoChange:v3];
          }
        }

        id v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }

      while (v7);
    }
  }
}

LABEL_45:
  v31 = *(id *)(v38 + 256);
  v32 = (void *)objc_claimAutoreleasedReturnValue(-[CBStackBLEScanner selfAuthTagNonConnectable](v18, "selfAuthTagNonConnectable"));
  v33 = v31;
  v34 = v32;
  if (v33 == v34)
  {

    goto LABEL_50;
  }

  v35 = v34;
  if ((v33 == 0LL) != (v34 != 0LL))
  {
    v36 = [v33 isEqual:v34];

    if ((v36 & 1) == 0) {
      goto LABEL_53;
    }
LABEL_50:
    if (!v23) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }

LABEL_53:
  -[CBStackBLEScanner setSelfAuthTagNonConnectable:](v18, "setSelfAuthTagNonConnectable:", v33);
LABEL_54:
  -[CBStackBLEScanner activate](v18, "activate");
LABEL_55:
}
}

      __src += (unsigned __int16)v18;
      v2 -= v18;
      uint64_t v24 = qword_1008DD350;
      if (!*(_WORD *)(qword_1008DD350 + 4))
      {
LABEL_46:
        if (*(_BYTE *)(v24 + 2048)) {
          sub_100088B34();
        }
        else {
          sub_100088BE4();
        }
      }
    }

    while ((_WORD)v2);
  }

      id v5 = v4 + v25;
      uint64_t v4 = (unsigned __int16)(v4 + v25);
      if (v4 >= v2) {
        return 0xFFFFLL;
      }
    }

    if ((byte_1008DDC74 & 7) != 0)
    {
      sub_100099568((uint64_t)"RX: invalid state ");
      goto LABEL_45;
    }

    uint64_t v9 = *v6;
    if ((v9 - 2) >= 3)
    {
      if (!*v6)
      {
        a1 = nullsub_63(a1, a2);
LABEL_30:
        v25 = 1;
        goto LABEL_45;
      }

      if (v9 != 64)
      {
        a1 = sub_10008CA04();
        if ((_DWORD)a1)
        {
          a1 = sub_10009899C();
          if (!(_DWORD)a1)
          {
            byte_1008DDC74 = byte_1008DDC74 & 0xF8 | 1;
            unsigned __int16 v12 = sub_1000A86F0();
            if ((_DWORD)v12)
            {
              sub_1001EE134( (uint64_t)"xh4ds_uart_deliverbytes: garbage received when searching for new packet identifier: %x\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  *v6);
              __int128 v20 = (os_log_s *)sub_100086554(0x3Au);
              unsigned __int16 v12 = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v12)
              {
                unint64_t v22 = sub_1001EDDCC();
                *(_DWORD *)buf = 136446466;
                v27 = v22;
                v28 = 1024;
                v29 = 0xFFFF;
                _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
              }
            }

            nullsub_63(v12, v13);
            sub_100099514(3);
          }
        }

        goto LABEL_30;
      }

      sub_100098DC4();
      id v10 = byte_1008DDC74 & 0xF8 | 2;
    }

    else
    {
      a1 = sub_10008CA04();
      if (!(_DWORD)a1) {
        goto LABEL_30;
      }
      a1 = sub_1000989B4();
      if ((_DWORD)a1) {
        goto LABEL_30;
      }
      id v10 = byte_1008DDC74 & 0xF8 | 1;
    }

    goto LABEL_14;
  }

  return 0xFFFFLL;
}

      v6 += v21;
      id v7 = qword_1008DDCA8;
      if (!*(_WORD *)(qword_1008DDCA8 + 4)) {
        break;
      }
      __src += (unsigned __int16)v21;
      v4 -= v21;
LABEL_47:
      if (!(_WORD)v4) {
        return (unsigned __int16)v6;
      }
    }

      uint64_t result = (char *)sub_1000B1814(4uLL);
      v28 = result;
      v29 = 16842912;
      if (result) {
        goto LABEL_55;
      }
      return result;
  }

  *(void *)(v4 + v5 + 1560) |= 0x10uLL;
  if ((v21 & 0x200) != 0) {
LABEL_38:
  }
    *(void *)(v4 + v5 + 1560) |= 0x20uLL;
LABEL_39:
  uint64_t result = 0LL;
  if ((v21 & 0x400) != 0) {
    *(void *)(v4 + v5 + 1560) |= 0x40uLL;
  }
  return result;
}

  *(void *)(v9 + v4 + 88) |= 0x10uLL;
  if ((v10 & 0x200) != 0) {
    goto LABEL_46;
  }
LABEL_34:
  if ((v10 & 0x400) != 0) {
LABEL_35:
  }
    *(void *)(v9 + v4 + 88) |= 0x40uLL;
LABEL_36:
  id v11 = sub_1000EF604(a1, 0, 0LL);
  if ((_DWORD)v11) {
    sub_1000F1FF0(a1, 1u, v11);
  }
  if (!*(_BYTE *)(qword_1008E1E50 + v4 + 12))
  {
    __int128 v14 = 0LL;
    v12[0] = 28;
    v12[1] = (unsigned __int16)a1;
    __int128 v13 = v10;
    (*(void (**)(_DWORD *))(qword_1008E1E50 + 1480))(v12);
  }

  return 412LL;
}

  if (*(_BYTE *)(a1 + 15))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"SignalMan_RecvCommandReject - %!", v54, v55, v56, v57, v58, v59, v60, 411LL);
      v61 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else if (sub_100172404(a4, a2, &v73))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"No channel found for identifier %d, ignoring command reject packet",  v62,  v63,  v64,  v65,  v66,  v67,  v68,  a2);
      v69 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  else if (*v73 == 2)
  {
    v70 = sub_10017AB4C(v73);
    if (*(_DWORD *)(a4 + 48) != *(_DWORD *)(v70 + 10)
      || *(unsigned __int16 *)(a4 + 52) != *(unsigned __int16 *)(v70 + 14))
    {
      sub_1001EE2A0();
    }

    sub_100173C90((uint64_t)v73, 445LL);
  }

  free(v9);
  return 0LL;
}

  if (v37) {
    sub_1002CD254(v37);
  }
  return v4;
}

  if ((v21 & 1) != 0 || v8 == v5)
  {
    if (v8 == v5) {
      v27 = v21;
    }
    else {
      v27 = 0;
    }
    if (v27 == 1 && os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
    {
      sub_100531170((void *)a2, &__p);
      sub_10067FD60();
    }
  }

  else
  {
    uint64_t v24 = (os_log_s *)qword_1008F75B0;
    v25 = os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT);
    v26 = *(_WORD **)(a2 + 8);
    if (v25)
    {
      v29 = (unsigned __int16)*v26;
      LODWORD(__p.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v29;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "Found orphaned handle 0x%04x in handle map",  (uint8_t *)&__p,  8u);
      v26 = *(_WORD **)(a2 + 8);
    }

    LOWORD(__p.__r_.__value_.__l.__data_) = *v26;
    sub_100329E44((uint64_t)v6, (unsigned __int16 *)&__p);
  }

  return sub_100242FAC((uint64_t)v35);
}

  if ((v21 & 1) != 0 || v8 == v5)
  {
    if (v8 == v5) {
      v27 = v21;
    }
    else {
      v27 = 0;
    }
    if (v27 == 1 && os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
    {
      sub_100531170((void *)a2, &__p);
      sub_10067FD60();
    }
  }

  else
  {
    uint64_t v24 = (os_log_s *)qword_1008F75B0;
    v25 = os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT);
    v26 = *(_WORD **)(a2 + 8);
    if (v25)
    {
      v29 = (unsigned __int16)*v26;
      LODWORD(__p.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v29;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "Found orphaned handle 0x%04x in handle map",  (uint8_t *)&__p,  8u);
      v26 = *(_WORD **)(a2 + 8);
    }

    LOWORD(__p.__r_.__value_.__l.__data_) = *v26;
    sub_100329E44((uint64_t)v6, (unsigned __int16 *)&__p);
  }

  return sub_100242FAC((uint64_t)v35);
}

                goto LABEL_46;
              }

              operator delete(__p[0]);
              if (!v25) {
                goto LABEL_43;
              }
            }

      uint64_t v30 = (void *)v17[1];
      if (v30)
      {
        do
        {
          v31 = (void **)v30;
          uint64_t v30 = (void *)*v30;
        }

        while (v30);
      }

      else
      {
        do
        {
          v31 = (void **)v17[2];
          v32 = *v31 == v17;
          unsigned __int16 v17 = v31;
        }

        while (!v32);
      }

      unsigned __int16 v17 = v31;
      if (v31 == v41) {
        goto LABEL_51;
      }
    }

    *(_DWORD *)((char *)v39 + 3) = 0;
    v39[0] = 0;
    v23 = sub_1001BCDB0(v18);
    v39[0] = v23;
    BYTE2(v39[1]) = BYTE6(v23);
    LOWORD(v39[1]) = WORD2(v23);
    if ((v15 & 4) == 0) {
      __int128 v15 = 0;
    }
    uint64_t v24 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      v25 = sub_1005BFB9C(v18);
      v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
      *(_DWORD *)buf = 138543875;
      v43 = v3;
      v44 = 2160;
      v45 = 1752392040LL;
      v46 = 2113;
      *(void *)v47 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Adding device %{public}@ with address %{private, mask.hash}@ to connection filter accept list with option",  buf,  0x20u);
    }

    v27 = sub_1002E6E9C();
    BYTE2(v35) = v14;
    BYTE1(v35) = v14;
    LOBYTE(v35) = v14;
    HIBYTE(v34) = v38;
    BYTE2(v34) = v15;
    BYTE1(v34) = v16;
    LOBYTE(v34) = 0;
    LOWORD(v33) = 0;
    v28 = (*(uint64_t (**)(uint64_t, _DWORD *, void, void, void, void, void, void, int, void, int, void, int, void))(*(void *)v27 + 3560LL))( v27,  v39,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  v33,  0LL,  v34,  0LL,  v35,  0LL);
    if (v28)
    {
      v29 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v43) = v28;
        _os_log_error_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "addFilterAcceptListWithOptions failed with error %d",  buf,  8u);
      }
    }

    goto LABEL_45;
  }

void *sub_10001489C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[59]) {
    return [result _stackBLEScannerDeviceFound:a2];
  }
  return result;
}

void *sub_1000148B8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[59]) {
    return [result _stackBLEScannerDeviceLost:a2];
  }
  return result;
}

void *sub_1000148D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[59]) {
    return [result _stackBLEScannerDevicesBuffered:a2];
  }
  return result;
}

id sub_100014D88(uint64_t a1)
{
  return [*(id *)(a1 + 32) _reportDeviceLostIfNeeded:*(void *)(a1 + 40)];
}

void *sub_100015930(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[37]) {
    return [result _stackClassicScannerDeviceFound:a2];
  }
  return result;
}

void *sub_10001594C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[37]) {
    return [result _stackClassicScannerDeviceLost:a2];
  }
  return result;
}

void *sub_100015F64(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v2 == result[60]) {
    return [result _updateUserControllerCloudDevices];
  }
  return result;
}

void *sub_100015F7C(void *result)
{
  uint64_t v1 = result[5];
  if (result[4] == *(void *)(v1 + 480))
  {
    uint64_t v2 = result;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    id v3 = *(id *)(v1 + 536);
    id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v11;
      do
      {
        id v7 = 0LL;
        do
        {
          if (*(void *)v11 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(*((void *)&v10 + 1) + 8 * (void)v7),  "activatedController",  (void)v10));
          uint64_t v9 = (void (**)(void))objc_claimAutoreleasedReturnValue([v8 discoverableStateChangedHandler]);

          if (v9) {
            v9[2](v9);
          }

          id v7 = (char *)v7 + 1;
        }

        while (v5 != v7);
        id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      }

      while (v5);
    }

    return [(id)v2[5] scheduleUpdateImmediate:0];
  }

  return result;
}

void *sub_1000160B8(void *result)
{
  uint64_t v1 = result[5];
  if (result[4] == *(void *)(v1 + 480))
  {
    uint64_t v2 = result;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    id v3 = *(id *)(v1 + 536);
    id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v11;
      do
      {
        id v7 = 0LL;
        do
        {
          if (*(void *)v11 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(*((void *)&v10 + 1) + 8 * (void)v7),  "activatedController",  (void)v10));
          uint64_t v9 = (void (**)(void))objc_claimAutoreleasedReturnValue([v8 inquiryStateChangedHandler]);

          if (v9) {
            v9[2](v9);
          }

          id v7 = (char *)v7 + 1;
        }

        while (v5 != v7);
        id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      }

      while (v5);
    }

    return [(id)v2[5] scheduleUpdateImmediate:0];
  }

  return result;
}

void *sub_1000161F4(void *result)
{
  uint64_t v1 = result[5];
  if (result[4] == *(void *)(v1 + 480))
  {
    uint64_t v2 = result;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    id v3 = *(id *)(v1 + 536);
    id v4 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v16;
      do
      {
        for (i = 0LL; i != v5; i = (char *)i + 1)
        {
          if (*(void *)v16 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void **)(*((void *)&v15 + 1) + 8LL * (void)i);
          uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "activatedController", (void)v15));
          __int128 v10 = (void (**)(void))objc_claimAutoreleasedReturnValue([v9 bluetoothStateChangedHandler]);

          if (v10) {
            v10[2](v10);
          }

          __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v8 activatedDiscovery]);
          __int128 v12 = (void (**)(void))objc_claimAutoreleasedReturnValue([v11 bluetoothStateChangedHandler]);

          if (v12) {
            v12[2](v12);
          }

          __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v8 activatedSpatialInteractionSession]);
          __int128 v14 = (void (**)(void))objc_claimAutoreleasedReturnValue([v13 bluetoothStateChangedHandler]);

          if (v14) {
            v14[2](v14);
          }
        }

        id v5 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
      }

      while (v5);
    }

    return [(id)v2[5] scheduleUpdateImmediate:0];
  }

  return result;
}

void sub_1000163A4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  uint64_t v12 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) == *(void *)(v12 + 480))
  {
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    id v13 = *(id *)(v12 + 536);
    id v14 = [v13 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v21;
      do
      {
        __int128 v17 = 0LL;
        do
        {
          if (*(void *)v21 != v16) {
            objc_enumerationMutation(v13);
          }
          __int128 v18 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(*((void *)&v20 + 1) + 8 * (void)v17),  "activatedController",  (void)v20));
          __int128 v19 = (void (**)(void, void, void, void, void))objc_claimAutoreleasedReturnValue([v18 relayMessageHandler]);

          if (v19) {
            ((void (**)(void, id, id, uint64_t, id))v19)[2](v19, v9, v10, a4, v11);
          }

          __int128 v17 = (char *)v17 + 1;
        }

        while (v15 != v17);
        id v15 = [v13 countByEnumeratingWithState:&v20 objects:v24 count:16];
      }

      while (v15);
    }
  }
}

void *sub_10001671C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[38]) {
    return [result _stackDeviceMonitorDeviceFound:a2];
  }
  return result;
}

void *sub_100016738(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[38]) {
    return [result _stackDeviceMonitorDeviceLost:a2];
  }
  return result;
}

void sub_100016D90(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100016E14;
  v3[3] = &unk_10087F2E8;
  uint64_t v2 = *(void **)(a1 + 40);
  id v4 = *(id *)(a1 + 32);
  id v5 = v2;
  __int16 v7 = *(_WORD *)(a1 + 52);
  int v6 = *(_DWORD *)(a1 + 48);
  [v4 _performUserControllerActionWithCompletion:v3];
}

void sub_100016E14(uint64_t a1, void *a2)
{
  id v6 = a2;
  id v3 = *(id *)(*(void *)(a1 + 32) + 512LL);
  if (v6 || !v3)
  {
    if (dword_1008D5FD8 <= 90
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
    {
      uint64_t v4 = CUPrintNSError(v6);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer recordEventWithDeviceIdentifier:initiator:starting:useCase:]_block_invoke_2",  90LL,  "Unable to report biome device event: %@",  v5);
    }
  }

  else
  {
    [v3 recordEventWithDeviceIdentifier:*(void *)(a1 + 40) initiator:*(unsigned __int8 *)(a1 + 52) starting:*(unsigned __int8 *)(a1 + 53) useCase:*(unsigned int *)(a1 + 48)];
  }
}

id sub_100016F48(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100016FB0;
  v3[3] = &unk_10087F338;
  void v3[4] = v1;
  char v5 = *(_BYTE *)(a1 + 44);
  int v4 = *(_DWORD *)(a1 + 40);
  return [v1 _performUserControllerActionWithCompletion:v3];
}

void sub_100016FB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = v3;
  if (!v3)
  {
    [*(id *)(*(void *)(a1 + 32) + 512) recordEventWithStarting:*(unsigned __int8 *)(a1 + 44) useCase:*(unsigned int *)(a1 + 40)];
LABEL_3:
    int v4 = v8;
    goto LABEL_4;
  }

  int v4 = v3;
  if (dword_1008D5FD8 <= 90)
  {
    if (dword_1008D5FD8 != -1 || (int v7 = _LogCategory_Initialize(&dword_1008D5FD8, 90LL), v4 = v8, v7))
    {
      uint64_t v5 = CUPrintNSError(v4);
      id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer recordEventWithStarting:useCase:]_block_invoke_2",  90LL,  "Unable to report biome event: %@",  v6);

      goto LABEL_3;
    }
  }

LABEL_4:
}
}

    id v8 = sub_1000A86F0();
    if (a3)
    {
      if (v8)
      {
        sub_1001EE134((uint64_t)"Incoming connection security failed", v9, v10, v11, v12, v13, v14, v15, v58);
        uint64_t v16 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      __int128 v17 = 3;
    }

    else
    {
      if (v8)
      {
        sub_1001EE134((uint64_t)"Incoming connection refused: %!", v9, v10, v11, v12, v13, v14, v15, a2);
        __int128 v18 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      __int128 v17 = 4;
    }

    __int128 v19 = *(unsigned __int16 *)(a1 + 4);
    sub_10017AB4C((unsigned int *)a1);
    __int128 v23 = sub_1001967F4("aaaa", 3u, 0LL, v6, v7, v20, v21, v22, v19);
    if ((_DWORD)v23)
    {
      uint64_t v24 = v23;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"SignalMan_ConnectRsp failed %!", v25, v26, v27, v28, v29, v30, v31, v24);
        v32 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    sub_100173C90(a1, (v17 + 450));
    return;
  }

  sub_10017764C((unsigned int *)a1);
  v47 = sub_10017AB4C((unsigned int *)a1);
  v48 = sub_1001EE978(*(_DWORD *)(v47 + 80), 1);
  if ((_DWORD)v48)
  {
    v49 = v48;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_Dispatch_SetFuncTimeout failed %!", v50, v51, v52, v53, v54, v55, v56, v49);
      v57 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  sub_10018A690(a1);
  sub_1001AA69C(a1);
  uint64_t v5 = sub_1000B1814(0x68uLL);
  if (!v5)
  {
    sub_1001EE134((uint64_t)"Failed to allocate the bearer", v17, v18, v19, v20, v21, v22, v23, v26);
    uint64_t v24 = (os_log_s *)sub_100086554(0x44u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    goto LABEL_13;
  }

  v5[66] = a2;
  id v6 = *(_DWORD *)(a1 + 49);
  *((_WORD *)v5 + 6) = *(_WORD *)(a1 + 53);
  *((_DWORD *)v5 + 2) = v6;
  LOBYTE(v6) = *(_BYTE *)(a1 + 48);
  *((void *)v5 + 10) = 0LL;
  v5[14] = v6;
  int v7 = *((void *)&xmmword_1008E8840 + 1);
  if (*((void *)&xmmword_1008E8840 + 1))
  {
    do
    {
      id v8 = v7;
      int v7 = *(void *)(v7 + 80);
    }

    while (v7);
    *((void *)v5 + 11) = v8;
    *(void *)(v8 + 80) = v5;
  }

  else
  {
    *((void *)&xmmword_1008E8840 + 1) = v5;
    *((void *)v5 + 10) = 0LL;
    *((void *)v5 + 11) = 0LL;
  }

  return sub_1001A20C0((uint64_t)v5, a1, 23);
}
}

  id v8 = (int)sub_1003BD428(uint64, v7, v14);
  id v9 = v14[0];
  if (LOBYTE(v14[0]) == 1)
  {
    id v11 = v14[0] | ((unint64_t)(LOWORD(v14[1]) | (BYTE2(v14[1]) << 16)) << 32);
    id v10 = (v14[0] >> 20) & 0xF0 | (v11 >> 24) & 0xF00 | (v11 >> 28) & 0xF000 | HIDWORD(v11) & 0xF0000 | 1;
    goto LABEL_12;
  }

  if (LOBYTE(v14[0]))
  {
    id v10 = 0;
    goto LABEL_12;
  }

id sub_100017140(uint64_t a1)
{
  if (dword_1008D5FD8 <= 30 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesEnsureStarted]_block_invoke",  30LL,  "Identities changed");
  }
  return [*(id *)(a1 + 32) _identitiesGet];
}

LABEL_18:
  return v13;
}

    if (v4) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  if (self->_remoteRequestRegistered) {
    goto LABEL_18;
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = sub_1000194FC;
  v17[3] = &unk_10087F4A0;
  v17[4] = self;
  -[RPCompanionLinkClient registerRequestID:options:handler:]( v5,  "registerRequestID:options:handler:",  @"com.apple.bluetooth.request",  0LL,  v17);
  self->_remoteRequestRegistered = 1;
  if (!v4)
  {
LABEL_19:
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = sub_100019510;
    v14[3] = &unk_10087EF38;
    id v15 = v5;
    uint64_t v16 = self;
    -[RPCompanionLinkClient activateWithCompletion:](v15, "activateWithCompletion:", v14);
  }

  uint64_t v12 = v9[128];
  id v13 = v9[129];
  id v14 = v9[130];
  id v15 = v9[131];
  uint64_t v16 = v9[132];
  __int128 v17 = v9[133];
  v22[0] = 0LL;
  v22[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_10087FC70);
  }
  sub_1005C8684( (uint64_t)off_1008D5F28,  (v12 << 40) | (v13 << 32) | (v14 << 24) | (v15 << 16) | (v16 << 8) | v17,  1u,  1u,  0LL,  0LL,  (unsigned __int8 *)v22);
  __int128 v18 = sub_100241F94((const unsigned __int8 *)v22);
  __int128 v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  if (v19)
  {
    if (!a3 || a3 == 2)
    {
      -[CBStackClassicScannerBTStack _deviceFound:deviceUUID:](self, "_deviceFound:deviceUUID:", v9, v19);
    }

    else if (a3 == 1)
    {
      -[CBStackClassicScannerBTStack _deviceLost:](self, "_deviceLost:", v19);
    }
  }

  else if (dword_1008D6300 <= 90 {
         && (dword_1008D6300 != -1 || _LogCategory_Initialize(&dword_1008D6300, 90LL)))
  }
  {
    LogPrintF_safe( &dword_1008D6300,  "-[CBStackClassicScannerBTStack _discoveryEvent:device:attributes:]",  90LL,  "### Get device UUID failed");
  }
}
}

      __int128 v20 = 0;
      goto LABEL_8;
    }

    if (!a7) {
      goto LABEL_18;
    }
    v25 = CBErrorF(4294960591LL, "Bad peer address: '%@'", v18, v27);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v25);
  }

  else
  {
    if (!a7) {
      goto LABEL_18;
    }
    __int128 v23 = CBErrorF(4294960591LL, "No peer address");
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  }

      ++v13;
    }

    while (v13 < (unsigned __int16)word_1008DD4E2);
  }

  else
  {
    v76 = &qword_1008DD570[9 * v9];
    v77 = (void (*)(const void *, size_t, uint64_t))v76[8];
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Unregistering service immediately because no peer is connected",  v78,  v79,  v80,  v81,  v82,  v83,  v84,  v87);
      v85 = (os_log_s *)sub_100086554(0x51u);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v92 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    sub_1000B1838((void *)*v76);
    v86 = &qword_1008DD570[9 * (unsigned __int16)--word_1008DD568];
    memmove(v76, v86, 0x48uLL);
    *(_OWORD *)v86 = 0u;
    *((_OWORD *)v86 + 1) = 0u;
    *((_OWORD *)v86 + 2) = 0u;
    *((_OWORD *)v86 + 3) = 0u;
    v86[8] = 0LL;
    if (v77) {
      v77(a1, v7, a3);
    }
  }

  sub_10009838C();
  return 0LL;
}

  if (a3 - 1 != 2 * (_DWORD)v16)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Service size mismatch, nbServices=%d, (dataSize-1)/2=%d capping to the lower value",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v16);
      v40 = (os_log_s *)sub_100086554(0x51u);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  v123 = (uint64_t *)sub_1000B17F4(8LL * v16);
  if (!v123) {
    goto LABEL_69;
  }
  v41 = v7;
  v42 = *(_DWORD *)(*((void *)&xmmword_1008DD4E8 + v7) + 16LL) + v16;
  if (v42 < 0x19) {
    goto LABEL_30;
  }
  if (sub_1000A86F0())
  {
    v42 = 24;
    sub_1001EE134( (uint64_t)"Too many services + channels, nbServices=%d nbChannels=%d newNbChannels=%d max %d",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v16);
    v50 = (os_log_s *)sub_100086554(0x51u);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    sub_100657858();
  }

  v42 = 24;
LABEL_30:
  v125 = v42;
  v51 = sub_1000B1814(88 * v42);
  if (!v51)
  {
LABEL_69:
    sub_100091EC4(a1);
    return;
  }

  v52 = v51;
  v53 = *((void *)&xmmword_1008DD4E8 + v41);
  v54 = *(_DWORD *)(v53 + 16);
  v55 = *(const void **)(v53 + 8);
  if (v55)
  {
    memmove(v51, v55, 88LL * v54);
    sub_1000B1838(*(void **)(*((void *)&xmmword_1008DD4E8 + v41) + 8LL));
    v53 = *((void *)&xmmword_1008DD4E8 + v41);
  }

  *(void *)(v53 + _Block_object_dispose(&STACK[0x338], 8) = v52;
  if (v54 >= v125)
  {
    v92 = 0;
    v93 = 0LL;
    goto LABEL_78;
  }

  v124 = 0;
  v122 = 0;
  v56 = a3;
  v57 = 1LL;
  v58 = v125;
  v126 = v56;
  do
  {
    v59 = v57 + 2;
    if (v57 + 2 > v56)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Size mismatch", v94, v95, v96, v97, v98, v99, v100, v121);
        v101 = (os_log_s *)sub_100086554(0x51u);
        v93 = v122;
        v92 = v124;
        if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
        goto LABEL_78;
      }

    ++v6;
    ++a1;
    int v7 = v10;
    if (v6 >= a2) {
      goto LABEL_19;
    }
  }

  id v11 = *a1;
  uint64_t v12 = qword_1008DDC80;
  id v13 = *(void *)qword_1008DDC80;
  id v10 = v7 & 0xFFFFFFF0 | ((_BYTE)v7 + 1) & 0xF;
  byte_1008DDC78 = v7 & 0xF0 | (v7 + 1) & 0xF;
  if (v11 == *(unsigned __int8 *)(v13 + (v7 & 0xF)))
  {
    if ((((_BYTE)v7 + 1) & 0xFu) >= 4)
    {
      *a3 = v6 + 1;
      byte_1008DDC78 = v7 & 0x80;
      return *(unsigned int *)(v12 + 8);
    }

    goto LABEL_18;
  }

    int v4 = 0LL;
    goto LABEL_19;
  }

  if (v3 != 4) {
    goto LABEL_18;
  }
  if (*((_BYTE *)v2 + 35) == 3)
  {
    int v4 = sub_10011976C(v2[1]);
    if (!(_DWORD)v4)
    {
      *((_BYTE *)v2 + 35) = 4;
      goto LABEL_19;
    }

    sub_1001EE134((uint64_t)"ScoDisconnect failed - %!, forcing disconnect!\n", v5, v6, v7, v8, v9, v10, v11, v4);
    uint64_t v12 = (os_log_s *)sub_100086554(0xFu);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
LABEL_16:
    sub_100657858();
LABEL_17:
    sub_1000AE368(*(unsigned __int16 *)v2);
    goto LABEL_19;
  }

  if (!*(_WORD *)v2) {
    goto LABEL_18;
  }
  int v4 = sub_1001DA5AC(*(unsigned __int16 *)v2, 935);
  if ((_DWORD)v4)
  {
    sub_1001EE134( (uint64_t)"RFCOMM_Disconnect failed - %!, forcing disconnect!\n",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v4);
    __int128 v20 = (os_log_s *)sub_100086554(0xFu);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  sub_1000AF574();
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"registerL2CAPListeners failed", v31, v32, v33, v34, v35, v36, v37, v39[0]);
    v38 = (os_log_s *)sub_100086554(0x52u);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      sub_10065A878();
    }
  }

  return v3;
}

    sub_1001EE134((uint64_t)"Invalid number of expected packets (0)", v19, v20, v21, v22, v23, v24, v25, v39);
    v26 = (os_log_s *)sub_100086554(2u);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_17:
    sub_100657858();
    return;
  }

  id v8 = a3[1];
  *((_BYTE *)a1 + 23) = v8;
  if (!v8) {
    goto LABEL_18;
  }
  int v7 = 2;
LABEL_8:
  if ((int)(a4 - v7) <= 1)
  {
LABEL_15:
    sub_1001EE134((uint64_t)"Invalid packet received", v11, v12, v13, v14, v15, v16, v17, v39);
    __int128 v18 = (os_log_s *)sub_100086554(2u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      return;
    }
    goto LABEL_17;
  }

  id v9 = __rev16(*(unsigned __int16 *)&a3[v7]);
  id v10 = qword_1008DFDA8;
  while (1)
  {
    id v10 = *(void *)v10;
    if (!v10) {
      break;
    }
  }

  if ((*a3 & 2) == 0)
  {
    v27 = (char *)sub_1000B17F4(3uLL);
    if (v27)
    {
      v28 = a3[2];
      v29 = *(_WORD *)a3;
      *(_WORD *)v27 = *(_WORD *)a3;
      v27[2] = v28;
      char *v27 = v29 | 3;
      sub_100172DA0((uint64_t)sub_1000D8694, *a1, 0LL, v27, 3uLL);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Out of memory\n", v30, v31, v32, v33, v34, v35, v36, v39);
        v37 = (os_log_s *)sub_100086554(2u);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      sub_1001759FC(*a1, 436LL);
    }
  }

    id v11 = 0;
    return sub_1000DCEB8(*(unsigned __int16 *)(v8 + (v7 << 6) + 38), a1, a2, a3, v11, a5);
  }

  if (!a3) {
    goto LABEL_18;
  }
  id v13 = a3;
  id v14 = a2;
  while (1)
  {
    id v15 = *v14++;
    uint64_t v16 = v15 - 1;
    if (v5 <= (unsigned __int16)(v15 - 1))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_AVDTP_SuspendRsp remote nil", v17, v18, v19, v20, v21, v22, v23, v33);
        uint64_t v24 = (os_log_s *)sub_100086554(3u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          goto LABEL_25;
        }
      }

      return 101LL;
    }

    if (*(_BYTE *)(v6 + 144LL * v16 + 134) != 4) {
      break;
    }
    if (!--v13) {
      goto LABEL_18;
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"OI_AVDTP_SuspendRsp after stopped, check race transaction",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v33);
    v32 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
LABEL_25:
    }
      sub_100657858();
  }

  return 101LL;
}

    id v3 = sub_1000EF604(a1, 0, 0LL);
  }

  else
  {
    id v3 = sub_1000EF578(a1, 2707LL);
  }

  if ((_DWORD)v3) {
    sub_1000F1FF0(a1, 1u, v3);
  }
  return 412LL;
}

      if ((sub_1000A86F0() & 1) != 0)
      {
        id v15 = sub_1000FFB28(*((_DWORD *)v4 + 12));
        sub_1001EE134( (uint64_t)"DOWNGRADE_REQ not downgrading, state is %s",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  (uint64_t)v15);
        __int128 v23 = (os_log_s *)sub_100086554(0x56u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v35 = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      uint64_t v5 = 0;
    }

    else
    {
      id v3 = 0LL;
      uint64_t v5 = 0;
    }

      v7 += 16;
      --v6;
    }

    while (v6);
    if ((v3 & 1) != 0)
    {
      int v7 = v4;
LABEL_21:
      sub_1000B1838(*((void **)v7 + 1));
      uint64_t v2 = 0;
      id v3 = 0;
      *int v7 = 0;
      int v4 = a1;
      uint64_t v5 = a1;
      continue;
    }

    break;
  }

  void *v4 = 0;
}

        sub_100657858();
        goto LABEL_19;
      }

      sub_1001EE134( (uint64_t)"Pairing response was received without a pairing request for handle %d.",  v74,  v75,  v76,  v77,  v78,  v79,  v80,  a1);
      v81 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
    }

    else
    {
      sub_1001EE134((uint64_t)"We're not in pairing yet.", v66, v67, v68, v69, v70, v71, v72, v90);
      v73 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
    }

          int v7 = v6;
          goto LABEL_26;
        }
      }

      while (v3);
      if (v1) {
        goto LABEL_14;
      }
    }

    v17[0] = (const void *)2;
    v17[1] = (const void *)(v1 + 24);
    sub_1001EE6E8((uint64_t)sub_100189A00, v17, 0, 0LL);
    return v7;
  }

  if (sub_1001EC434(*(void *)(a1 + 8)))
  {
    a1 = *(void *)(v1 + 8);
    return sub_1001EC324(a1, 0);
  }

  if (!sub_1001EC434(*(void *)v1))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Failed to dequeue packet, there is no SFrames or IFrames queued.",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  (uint64_t)v17[0]);
      uint64_t v16 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1001EE2A0();
    return 0LL;
  }

  id v8 = *(_DWORD *)(v1 + 20);
  if (v8) {
    *(_DWORD *)(v1 + 20) = v8 - 1;
  }
  int v7 = sub_1001EC324(*(void *)v1, 0);
  return v7;
}

    uint64_t v24 = (unsigned __int16)v22[6];
    if (v22[7])
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"SAR: Rcvd FIRST packet, previous packet incomplete.  Discarding previous packet.",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v60);
        v32 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      v22[7] = 0;
      *((_BYTE *)v22 + 16) = 0;
    }

    if (v10 <= 3)
    {
      memmove(v22 + 4, __src, v10);
      v22[7] += v10;
      return;
    }

    v34 = *(_DWORD *)__src;
    v33 = __src + 4;
    *((_DWORD *)v22 + 2) = v34;
    *((_BYTE *)v22 + 16) = a5;
    v35 = (unsigned __int16)v34;
    v36 = (unsigned __int16)(v10 - 4);
    if ((unsigned __int16)v34 < v36)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Packet size of %d exceeds the payload length %d",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  (unsigned __int16)(v10 - 4));
        v44 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
      }

      return;
    }

    if (v35 > v24)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Recv_FirstPacket, length in L2CAP header %d exceeds buffer size %d",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v35);
        v52 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
          goto LABEL_32;
        }
      }

      return;
    }

    v53 = (unsigned __int16)v22[5];
    v62 = 0LL;
    v61 = v53;
    if (sub_100171EC4(v53, &v62))
    {
      if ((_DWORD)v35 == v36) {
        goto LABEL_35;
      }
    }

    else
    {
      v59 = *(unsigned __int16 **)(v62 + 48);
      if ((_DWORD)v35 == v36)
      {
        if (v59)
        {
          memmove(*(void **)(v62 + 48), v33, (unsigned __int16)(v10 - 4));
          v54 = *((_BYTE *)v22 + 16) != 0;
          v55 = (_BYTE *)a3;
          v56 = v61;
          v57 = v59;
          v58 = (unsigned __int16)(v10 - 4);
          goto LABEL_39;
        }

        sub_100173C90((uint64_t)v1, 559LL);
        break;
      default:
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Timeout for unknown message type!", v26, v27, v28, v29, v30, v31, v32, v42);
          v33 = (os_log_s *)sub_100086554(0x2Fu);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            goto LABEL_8;
          }
        }

        break;
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Timer expired, but channel %p is not used any more.",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)v1);
    __int128 v17 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
LABEL_8:
    }
      sub_100657858();
  }

        id v6 = v4++ >= *(unsigned __int16 *)(a1 + 3);
        v8 += 16LL;
      }

      while (!v6 && v4 < (unsigned __int16)word_1008E88C0);
    }
  }

  if (*((_WORD *)a2 + 25) == 1) {
    return 10LL;
  }
  else {
    return 0LL;
  }
}

      v35 = (void *)a7[8];
      if (v35)
      {
        sub_1000B1838(v35);
        a7[8] = 0LL;
      }

      return;
    }

    return;
  }

  if (*((unsigned __int16 *)a7 + 26) != (_DWORD)a3)
  {
    if (sub_1000A86F0()
      && (sub_1001EE134((uint64_t)"Invalid handle, got 0x%x, expecting 0x%x", v58, v59, v60, v61, v62, v63, v64, a3),
          v65 = (os_log_s *)sub_100086554(0x45u),
          os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)))
    {
      sub_100657858();
      if (!v14)
      {
LABEL_34:
        v66 = (void *)a7[8];
        if (v66) {
          sub_1000B1838(v66);
        }
        return;
      }
    }

    else if (!v14)
    {
      goto LABEL_34;
    }

    a7[2] = 0LL;
    v14(1LL, a7[3]);
    goto LABEL_34;
  }

  v36 = *((unsigned __int16 *)a7 + 27);
  v37 = v36 + __n;
  v38 = *((unsigned __int16 *)a7 + 36);
  if ((int)v36 + (int)__n <= v38)
  {
    v39 = a7[8];
    if (!memcmp((const void *)(v39 + v36), __s2, __n))
    {
      *((_WORD *)a7 + 27) = v37;
      if (v37 == v38)
      {
        v67 = sub_1001A32B0(v13, (uint64_t)sub_1001C2F9C, 1, (uint64_t)a7);
        if (!(_DWORD)v67) {
          return;
        }
        v68 = v67;
        sub_1001EE134((uint64_t)"Failed to execute write request %!", v69, v70, v71, v72, v73, v74, v75, v68);
        v76 = (os_log_s *)sub_100086554(0x45u);
        if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
      }

      else
      {
        if (v37 <= v38)
        {
          v86 = *((_WORD *)a7 + 28);
          v99 = 22;
          v100 = a3;
          v101 = v86 + v37;
          v102 = v38 - v37;
          v103 = v39 + v37;
          v87 = sub_1001A2494(v13);
          v88 = sub_1001A31A8(*a7, (uint64_t)sub_1001C1EC4, (int *)&v99, (uint64_t)a7);
          if (!(_DWORD)v88) {
            return;
          }
          v68 = v88;
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Failed to prepare write request %!", v89, v90, v91, v92, v93, v94, v95, v68);
            v96 = (os_log_s *)sub_100086554(0x45u);
            if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

    id v15 = *(_BYTE *)(a2 + 1) + 1;
    *(_BYTE *)(a2 + 1) = v15;
    if (*(unsigned __int8 *)(a2 + 2) <= v15) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  567,  "src->currCell < src->usedCells");
    }
    uint64_t v5 = 0;
    v8 -= v12;
    v7 += 3;
    v4 += v12;
  }

  id v13 = *((unsigned __int16 *)v7 - 3);
  if (v13 < v5) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c",  553,  "cell->len >= currPos");
  }
  id v14 = (char *)v10 + v5;
  uint64_t v12 = v13 - v5;
  if ((unsigned __int16)(v13 - v5) < v8)
  {
    memmove(v4, v14, (unsigned __int16)(v13 - v5));
    goto LABEL_18;
  }

  memmove(v4, v14, v8);
  uint64_t v16 = v5 + v8;
LABEL_22:
  *(_WORD *)(a2 + 6) = v16;
  *(_WORD *)(a2 + 4) -= v6;
  return v6;
}

  id v10 = 0;
  uint64_t v12 = 0;
  v69 = 0x100000000LL;
  id v11 = 1;
LABEL_19:
  v68 = v70[493];
  __int128 v21 = (os_log_s *)qword_1008F7568;
  if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
  {
    __int128 v22 = *(id *)(v9 + 8);
    *(_DWORD *)buf = 138543874;
    *(void *)&buf[4] = v22;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v12;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "recvW1AppDiagnosticsHandler: DiagInfo received from %{public}@ %d bud, AWD = %d",  buf,  0x18u);
  }

  if (v11) {
    goto LABEL_22;
  }
  v25 = (unint64_t)v12 << 6;
  memcpy((void *)(a1 + 150), a4, v25);
  *(_BYTE *)(a1 + 406) = (_BYTE)v12 << 6;
  v26 = fopen(aPrivateVarMobi_14, "w");
  if (!v26)
  {
    v43 = (os_log_s *)qword_1008F7568;
    if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
      sub_100670D38(v43);
    }
    __int128 v20 = 1LL;
    goto LABEL_44;
  }

  v27 = *a4;
  v28 = a4[1];
  v107[0] = *(_OWORD *)(a4 + 2);
  *(_OWORD *)((char *)v107 + 15) = *(_OWORD *)((char *)a4 + 23);
  v93 = *(void *)((char *)a4 + 39);
  v94 = *(int *)((char *)a4 + 47);
  v91 = *(_WORD *)((char *)a4 + 51);
  v92 = *((_BYTE *)a4 + 53);
  v29 = *((unsigned __int8 *)a4 + 54);
  uint64_t v30 = *(void *)((char *)a4 + 55);
  v106 = *((_BYTE *)a4 + 63);
  v105 = v30;
  fwrite("App Diagnostics Info Collected from Accessory Device\n\n", 0x36uLL, 1uLL, v26);
  sub_1003D0100((uint64_t)v70, (uint64_t)buf);
  if ((buf[23] & 0x80u) == 0) {
    v31 = buf;
  }
  else {
    v31 = *(uint8_t **)buf;
  }
  fprintf(v26, "DeviceName : %s\n", (const char *)v31);
  v39 = (const char *)sub_1001EDE10(a2, v32, v33, v34, v35, v36, v37, v38);
  fprintf(v26, "Device Bluetooth Address : %s\n", v39);
  v40 = fwrite("\n======Primary Device======\n", 0x1CuLL, 1uLL, v26);
  v82[0] = v27;
  v82[1] = v28;
  *(_OWORD *)v83 = v107[0];
  *(_OWORD *)&v83[15] = *(_OWORD *)((char *)v107 + 15);
  v84 = v93;
  v85 = v94;
  v86 = v91;
  v87 = v92;
  v88 = v29;
  v90 = v106;
  v89 = v105;
  sub_1003593C0(v40, v26, (uint64_t)v82);
  memset(buf, 0, 32);
  sub_10040CB88((uint64_t)buf, 1, (uint64_t)v70);
  *(_DWORD *)&buf[24] = v27;
  *(_DWORD *)&buf[28] = v28;
  *(_WORD *)&buf[16] = WORD6(v107[1]);
  buf[18] = BYTE14(v107[1]);
  *(_WORD *)&buf[19] = *(_WORD *)((char *)&v94 + 1);
  buf[21] = HIBYTE(v94);
  v41 = sub_1002E8D94();
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v41 + 56LL))(v41, buf);
  if (v29 == 9)
  {
    v42 = "dev-fused";
LABEL_39:
    v44 = (os_log_s *)qword_1008F7568;
    if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
    {
      v45 = *(id *)(v9 + 8);
      v98[0] = 138543618;
      *(void *)&v98[1] = v45;
      v99 = 2082;
      v100 = v42;
      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "recvW1AppDiagnosticsHandler: %{public}@ fused status : %{public}s",  (uint8_t *)v98,  0x16u);
    }

    goto LABEL_41;
  }

  if (v29 == 1)
  {
    v42 = "prod-fused";
    goto LABEL_39;
  }

        if (!v15) {
          goto LABEL_28;
        }
        v11 += 8;
        if (v11 == v22)
        {
          uint64_t v16 = 0;
          goto LABEL_28;
        }
      }

      uint64_t v16 = 1;
      id v3 = v12;
LABEL_28:
      id v11 = v21;
      if (v21)
      {
LABEL_29:
        __int128 v22 = v11;
        operator delete(v11);
      }
    }

    id v9 = (char *)__p;
    if (__p) {
      goto LABEL_31;
    }
LABEL_32:
    if (v16) {
      goto LABEL_39;
    }
  }

  if (a3 && *a3)
  {
    id v3 = 0LL;
    *a3 = 0LL;
  }

  else
  {
    id v3 = 0LL;
  }

  std::string::operator=((std::string *)(a1 + 200), a2);
  if (v6 != a3) {
    *id v6 = *a3;
  }
  sub_100242F54((uint64_t)v15);
  if (sub_1003CF350((unsigned __int8 *)a1))
  {
    id v13 = sub_1002E6D7C();
    (*(void (**)(uint64_t, uint64_t, const std::string *))(*(void *)v13 + 232LL))(v13, a1, a2);
  }

  return sub_100242FAC((uint64_t)v15);
}

    __int128 v17 = -1LL;
    goto LABEL_19;
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100897EB8);
  }
  id v13 = off_1008D5F28;
  id v14 = sub_100241F94(uu);
  id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  uint64_t v16 = sub_1005D71D4((uint64_t)v13, v15);

  if (v16 <= 0.0) {
    goto LABEL_18;
  }
  __int128 v17 = (uint64_t)(CFAbsoluteTimeGetCurrent() - v16);
LABEL_19:
  __int128 v18 = sub_1002E8D94();
  sub_1003CF00C(a2, __p);
  (*(void (**)(uint64_t, void **, __CFString *, uint64_t, void, uint64_t))(*(void *)v18 + 392LL))( v18,  __p,  v11,  v17,  0LL,  a5);
  if (v82 < 0) {
    operator delete(__p[0]);
  }

LABEL_22:
  v80[0] = 0LL;
  v80[1] = 0LL;
  sub_100242F28((uint64_t)v80, (uint64_t)&a1[2].i64[1]);
  __int128 v19 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a2, buf);
    __int128 v20 = v89;
    __int128 v21 = *(_BYTE **)buf;
    __int128 v22 = sub_1003CF350((unsigned __int8 *)a2);
    __int128 v23 = buf;
    *(_DWORD *)uu = 67109634;
    if (v20 < 0) {
      __int128 v23 = v21;
    }
    *(_DWORD *)&uu[4] = a3;
    *(_WORD *)&uu[8] = 2082;
    *(void *)&uu[10] = v23;
    *(_WORD *)&uu[18] = 1024;
    *(_DWORD *)&uu[20] = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Connecting 0x%x services to device %{public}s, paired %d",  uu,  0x18u);
    if (v89 < 0) {
      operator delete(*(void **)buf);
    }
  }

  if (a1[7].i8[0])
  {
    sub_100242F54((uint64_t)v80);
    if (qword_1008D6788 != -1) {
      dispatch_once(&qword_1008D6788, &stru_100897F18);
    }
    if (sub_1002075B4((uint64_t)off_1008D6780) == 1)
    {
      if (*(_BYTE *)(a2 + 976))
      {
        a3 &= 0xFFEFFFFE;
        uint64_t v24 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uu = 67109120;
          *(_DWORD *)&uu[4] = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter Guest Not In Contacts connecting with services 0x%x",  uu,  8u);
        }
      }

      size = (char)a4->__r_.__value_.__s.__size_;
      if (size >= 0) {
        v26 = a4->__r_.__value_.__s.__size_;
      }
      else {
        v26 = a4->__r_.__value_.__l.__size_;
      }
      if (v26)
      {
        v27 = *(_BYTE *)(a2 + 1435) != 0;
        v28 = qword_1008F73C0;
        if ((_UNKNOWN *)qword_1008F73C0 != &unk_1008F73C8)
        {
          v74 = *(_BYTE *)(a2 + 1435) != 0;
          v76 = a5;
          v77 = (uint64_t)a1;
          v75 = a4;
          if (size >= 0) {
            v29 = a4;
          }
          else {
            v29 = (const std::string *)a4->__r_.__value_.__r.__words[0];
          }
          uint64_t v30 = (char *)v29 + v26;
          while (1)
          {
            v31 = *(char *)(v28 + 55);
            v32 = v31 >= 0 ? (unsigned __int8 *)(v28 + 32) : *(unsigned __int8 **)(v28 + 32);
            v33 = v31 >= 0 ? *(unsigned __int8 *)(v28 + 55) : *(void *)(v28 + 40);
            if (!v33) {
              break;
            }
            if (v26 >= v33)
            {
              v36 = *v32;
              v37 = v26;
              v38 = v29;
              do
              {
                v39 = v37 - v33;
                if (v39 == -1) {
                  break;
                }
                v40 = (char *)memchr(v38, v36, v39 + 1);
                if (!v40) {
                  break;
                }
                v41 = v40;
                if (!memcmp(v40, v32, v33))
                {
                  goto LABEL_66;
                }

                v38 = (const std::string *)(v41 + 1);
                v37 = v30 - (v41 + 1);
              }

              while (v37 >= v33);
            }

            v34 = *(void **)(v28 + 8);
            if (v34)
            {
              do
              {
                v35 = v34;
                v34 = (void *)*v34;
              }

              while (v34);
            }

            else
            {
              do
              {
                v35 = *(void **)(v28 + 16);
                v64 = *v35 == v28;
                v28 = (uint64_t)v35;
              }

              while (!v64);
            }

            v28 = (uint64_t)v35;
            if (v35 == (void *)&unk_1008F73C8)
            {
              a1 = (int64x2_t *)v77;
              LOBYTE(a5) = v76;
              a4 = v75;
              v27 = v74;
              goto LABEL_70;
            }
          }

  a1 = sub_100115744(v4, v5);
  if ((_DWORD)a1)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067F5B8();
    }
    goto LABEL_31;
  }

    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_100684A50();
    }
    uint64_t v12 = 0LL;
  }

  else
  {
    *((_BYTE *)v13 + 74) = a3;
    *((_DWORD *)v13 + 19) = a4;
    uint64_t v12 = 1LL;
    *((_BYTE *)v13 + 72) = 1;
    v13[11] = 0LL;
    v13[10] = (uint64_t)malloc(0LL);
    *((_BYTE *)v14 + 73) = 1;
  }

  id v11 = sub_1002E6E9C();
  if (*(_DWORD *)(v11 + 708) <= 0x13u) {
    sub_1004AFD64(v11, 1);
  }
  uint64_t v12 = sub_100361020();
  if ((_DWORD)v12 == 126 || (uint64_t v12 = sub_100361020(), (_DWORD)v12 == 128))
  {
    if (!sub_1004AF148(v12, 1LL, 0LL, 1LL))
    {
      id v13 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Global MRC enabled for this platform",  buf,  2u);
      }
    }
  }

  if (*(unsigned __int16 *)(a1 + 40) != *(unsigned __int16 *)(v2 + 40)
    || *(unsigned __int8 *)(a1 + 42) != *(unsigned __int8 *)(v2 + 42)
    || *(_BYTE *)(a1 + 42) && *(unsigned __int8 *)(a1 + 43) != *(unsigned __int8 *)(v2 + 43)
    || !sub_10056AF84(a1 + 48, v2 + 48)
    || !sub_10056AF84(a1 + 224, v2 + 224)
    || !sub_10056C0E0((unsigned __int8 **)(a1 + 64), v2 + 64)
    || !sub_10056C0E0((unsigned __int8 **)(a1 + 88), v2 + 88)
    || *(void *)(a1 + 128) != *(void *)(v2 + 128)
    || !sub_10056AF84(a1 + 136, v2 + 136)
    || !sub_10056AF84(a1 + 152, v2 + 152)
    || !sub_10056AF84(a1 + 448, v2 + 448))
  {
    return 0LL;
  }

  id v10 = *(unsigned __int8 **)(a1 + 112);
  id v11 = (unsigned __int8 *)(a1 + 120);
  uint64_t v12 = v2 + 112;
  id v13 = v2 + 120;
  LODWORD(v2) = 1;
  do
  {
    id v14 = sub_100051D00(v12, v10 + 32);
    id v15 = v13 != v14 && sub_10056AF84((uint64_t)(v10 + 56), v14 + 56);
    uint64_t v16 = (unsigned __int8 *)*((void *)v10 + 1);
    if (v16)
    {
      do
      {
        __int128 v17 = v16;
        uint64_t v16 = *(unsigned __int8 **)v16;
      }

      while (v16);
    }

    else
    {
      do
      {
        __int128 v17 = (unsigned __int8 *)*((void *)v10 + 2);
        __int128 v18 = *(void *)v17 == (void)v10;
        id v10 = v17;
      }

      while (!v18);
    }

    uint64_t v2 = v2 & v15;
    id v10 = v17;
  }

  while (v17 != v11);
  return v2;
}

    sub_10002418C(__p, "LEPhyDenylist");
    id v14 = sub_1005CE5A8(a1, v5, (uint64_t)__p);
    id v15 = v14;
    if (v21 < 0)
    {
      operator delete(__p[0]);
      if ((v15 & 1) != 0) {
        continue;
      }
    }

    else if ((v14 & 1) != 0)
    {
      continue;
    }

    sub_10002418C(v18, "LEPhyDenylist");
    sub_1005CCF08(a1, v5, (unsigned __int8 *)v18);
    if (v19 < 0) {
      operator delete(v18[0]);
    }
    uint64_t v16 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v17 = a3;
      *(_DWORD *)buf = 136315138;
      __int128 v23 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "LEPhyDenylist: set tag for %s", buf, 0xCu);
    }
  }
}
}

  return a4;
}

void sub_100017524(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  [*(id *)(a1 + 32) invalidate];
  if (*(_DWORD *)(*(void *)(a1 + 40) + 96LL) == -1) {
    goto LABEL_47;
  }
  if (v6)
  {
    if (dword_1008D5FD8 <= 90
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
    {
      uint64_t v7 = CUPrintNSError(v6);
      id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesGet]_block_invoke",  90LL,  "### Identities get failed: %@",  v8);
    }

    goto LABEL_47;
  }

  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  id v9 = v5;
  uint64_t v10 = (uint64_t)[v9 countByEnumeratingWithState:&v35 objects:v40 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v36;
    while (2)
    {
      for (uint64_t i = 0LL; i != v10; ++i)
      {
        if (*(void *)v36 != v11) {
          objc_enumerationMutation(v9);
        }
        id v13 = *(void **)(*((void *)&v35 + 1) + 8 * i);
        id v14 = objc_autoreleasePoolPush();
        if ([v13 type] == 1)
        {
          uint64_t v15 = *(void *)(a1 + 40);
          uint64_t v16 = *(void **)(v15 + 112);
          if (v16)
          {
            uint64_t v10 = (uint64_t)[v16 compareWithRPIdentity:v13];
            uint64_t v15 = *(void *)(a1 + 40);
          }

          else
          {
            uint64_t v10 = 2048LL;
          }

          objc_storeStrong((id *)(v15 + 112), v13);
          objc_autoreleasePoolPop(v14);
          goto LABEL_21;
        }

        objc_autoreleasePoolPop(v14);
      }

      uint64_t v10 = (uint64_t)[v9 countByEnumeratingWithState:&v35 objects:v40 count:16];
      if (v10) {
        continue;
      }
      break;
    }
  }

LABEL_31:
  if ((_DWORD)v10) {
    [*(id *)(a1 + 40) _updateSelfAuthTag];
  }
  __int128 v20 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  id v21 = v9;
  id v22 = [v21 countByEnumeratingWithState:&v31 objects:v39 count:16];
  if (v22)
  {
    id v23 = v22;
    uint64_t v24 = *(void *)v32;
    do
    {
      for (j = 0LL; j != v23; j = (char *)j + 1)
      {
        if (*(void *)v32 != v24) {
          objc_enumerationMutation(v21);
        }
        v26 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)j);
        v27 = objc_autoreleasePoolPush();
        objc_autoreleasePoolPop(v27);
      }

      id v23 = [v21 countByEnumeratingWithState:&v31 objects:v39 count:16];
    }

    while (v23);
  }

  id v28 = -[NSMutableArray copy](v20, "copy");
  uint64_t v29 = *(void *)(a1 + 40);
  uint64_t v30 = *(void **)(v29 + 448);
  *(void *)(v29 + 44_Block_object_dispose(&STACK[0x338], 8) = v28;

  if (dword_1008D5FD8 <= 30 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesGet]_block_invoke",  30,  "Identities get completed: %d total",  [v21 count]);
  }
  [*(id *)(a1 + 40) _identitiesReevaluateDevices];
  [*(id *)(a1 + 40) scheduleAdvertiserUpdateImmediate:0];
  [*(id *)(a1 + 40) scheduleSpatialUpdateImmediate:0];
  [*(id *)(a1 + 40) _updateUserControllerCloudDevices];

LABEL_47:
}

  v159 = &v162;
  LOWORD(v15_Block_object_dispose(&STACK[0x338], 8) = 2;
  v42 = sub_1001EE9D8(qword_1008F29F0[134 * v6 + 55]);
  v43 = (unsigned int *)&qword_1008F29F0[134 * v162 + 55];
  if (v42) {
    v44 = sub_1001EE978(*v43, 30);
  }
  else {
    v44 = sub_1001EE6E8((uint64_t)sub_10008C034, &v158, 30, (int *)v43);
  }
  v45 = v44;
  if ((_DWORD)v44)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Transport timer registration failed with status %!",  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v45);
      v53 = (os_log_s *)sub_100086554(0x57u);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1001EE2A0();
  }

  v54 = v162;
  if (LODWORD(qword_1008F29F0[134 * v162 + 6]) != 6) {
    goto LABEL_63;
  }
  if (HIDWORD(qword_1008F29F0[134 * v162 + 13]) < 0xB) {
    goto LABEL_44;
  }
  v55 = qword_1008F29F0[134 * v162 + 13];
  if (v55) {
    v56 = HIDWORD(qword_1008F29F0[134 * v162 + 12]) * (0x3E8 / v55) / 0x3E8;
  }
  else {
    v56 = HIDWORD(qword_1008F29F0[134 * v162 + 12]);
  }
  else {
    v57 = v12 + v11;
  }
  if (v10 >= v55) {
    v58 = qword_1008F29F0[134 * v162 + 13];
  }
  else {
    v58 = v10;
  }
  if (v10) {
    v59 = v58;
  }
  else {
    v59 = qword_1008F29F0[134 * v162 + 13];
  }
  id v21 = sub_10008BDA8(v162, v57, v59, v10, v20, &v161);
  v54 = v162;
  if ((a1 & 0xFFFFFFFD) == 1 || BYTE4(qword_1008F29F0[134 * v162 + 55])) {
    goto LABEL_57;
  }
  v131 = sub_1001F42A4((uint64_t)&v160);
  v132 = sub_1001F42A4((uint64_t)&qword_1008F29F0[134 * v162 + 16]);
  v133 = v162;
  v134 = v131 - v132;
  if (v131 == v132) {
    v135 = 0;
  }
  else {
    v135 = 8 * HIDWORD(qword_1008F29F0[134 * v162 + 11]) / v134;
  }
  if (HIDWORD(qword_1008F29F0[134 * v162 + 15]) == 1
    && (v134 < 0x1389
     || v134 <= 0x2710
     && v21 < v20
     && v135 > *(_DWORD *)(qword_1008F29F0[134 * v162 + 8] + ((unint64_t)v21 << 6) + 4)))
  {
    v161 = 8;
    id v21 = v20;
    goto LABEL_127;
  }

  if (v21 <= v20)
  {
    if (v21 < v20)
    {
      v149 = &qword_1008F29F0[134 * v162];
      v151 = *((_DWORD *)v149 + 30);
      v150 = v149 + 15;
      if (v151 == 1) {
        v152 = 0;
      }
      else {
        v152 = BYTE6(qword_1008F29F0[134 * v162 + 9]);
      }
      *v150 = 2;
      v148 = v152 + 1;
      BYTE6(qword_1008F29F0[134 * v133 + 9]) = v152 + 1;
      goto LABEL_130;
    }

  sub_1000A5E04(a1, 0LL);
LABEL_37:
  uint64_t v12 = 0LL;
  memset(v11, 0, sizeof(v11));
  LODWORD(v11[0]) = 26;
  DWORD2(v11[0]) = v7;
  WORD2(v11[0]) = a1;
  (*(void (**)(_OWORD *))(qword_1008DDE00 + 24))(v11);
  return 1LL;
}

    *((_WORD *)v56 + v53) = v28;
    v53 = ++v38;
  }

  if (!v38)
  {
    v51 = 0LL;
    return sub_1001887B0((uint64_t)a1, (unsigned __int16 *)v56, v51, 1);
  }

      sub_100103E38((__int128 *)a1, 1);
      return;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"UPGRADE_CFM not supposed to get a upgrade CFM from the central.",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v38);
      uint64_t v24 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v40 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }

  if (*(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 144LL)
    && *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 18LL) == (_DWORD)v10)
  {
    uint64_t v30 = (a2 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v30
      || v30 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
    {
      __int128 v31 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      __int128 v32 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      if (v31 <= v30)
      {
        if (v30 - v32 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL)) {
          goto LABEL_43;
        }
      }

      else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
                + (_BYTE)v32) & 0x3Fu) < v30)
      }
      {
        goto LABEL_43;
      }
    }

    if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL))
      && *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 144LL) >= 2u)
    {
      sub_100182D14(a1, a3);
      sub_10018332C(a1);
      sub_100181EEC((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
      sub_100183428(a1, a3, a4, a5);
      return 0LL;
    }
  }

    sub_100657858();
    goto LABEL_32;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"UUID length is not 0 (%d) !",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  *(unsigned __int8 *)(*(void *)(a5 + 80) + 28LL * v13 + 8));
    v26 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

              uint64_t v29 = (os_log_s *)qword_1008F7730;
              if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
                sub_10065DBC8(v5, v29, v30, v31, v32, v33, v34, v35);
              }
              return;
            }

            goto LABEL_25;
          }

    *a4 = 0;
    goto LABEL_32;
  }

  *a4 = 1;
LABEL_29:
  if (!*a3) {
    *a3 = 1;
  }
LABEL_32:
  if ((*(unsigned int (**)(_BYTE *))(*(void *)a1 + 24LL))(a1))
  {
    *a2 = 1;
    *a3 = 1;
  }

  sub_10002418C(buf, "HCITraces");
  sub_10002418C(__p, "HCILiveTraces");
  (*(void (**)(_BYTE *, _BYTE *, void **, BOOL *))(*(void *)a1 + 72LL))(a1, buf, __p, a2);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(*(void **)buf);
  }
  sub_10002418C(buf, "HCITraces");
  sub_10002418C(__p, "HCIFileTraces");
  (*(void (**)(_BYTE *, _BYTE *, void **, BOOL *))(*(void *)a1 + 72LL))(a1, buf, __p, a3);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v15 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = "enabled";
    if (*a2) {
      uint64_t v17 = "enabled";
    }
    else {
      uint64_t v17 = "disabled";
    }
    uint64_t v18 = *a4;
    if (*a3) {
      __int128 v19 = "enabled";
    }
    else {
      __int128 v19 = "disabled";
    }
    *(_DWORD *)buf = 136446722;
    if (!v18) {
      uint64_t v16 = "disabled";
    }
    *(void *)&buf[4] = v17;
    v25 = 2082;
    v26 = v19;
    v27 = 2082;
    id v28 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "liveTracing:%{public}s fileTracing:%{public}s hciLiteLogging:%{public}s",  buf,  0x20u);
  }

    if (*v16 && v15 != v7)
    {
      v26 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(void *)&buf[4] = CStringPtr;
        __int128 v31 = 2080;
        __int128 v32 = v16;
        __int128 v33 = 2048;
        __int128 v34 = v15;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "\t%s = %s(%lld)", buf, 0x20u);
      }

  v106 = 0;
  uint64_t v18 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENOverrideExtraScanTimeInMs");
  __int128 v19 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v18 + 88LL))(v18, buf, __p, &v106);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v19) {
      goto LABEL_39;
    }
  }

  else if (!v19)
  {
    goto LABEL_39;
  }

  __int128 v20 = v106;
  *(_WORD *)(a1 + 216) = v106;
  id v21 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Overriding fExtraScanTimeInMs = %d ", buf, 8u);
  }

              sub_100242CD0(buf);
              sub_100242CD8(buf);
LABEL_32:
              if (v16)
              {
                v27 = (os_log_s *)qword_1008F75D0;
                if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 67109632;
                  *(_DWORD *)&buf[4] = v15;
                  __int128 v37 = 1024;
                  __int128 v38 = v16;
                  v39 = 1024;
                  v40 = v13;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "parseAVRCPDescriptor Key:%d Dumped %d of %d bytes ",  buf,  0x14u);
                }

                sub_10040F8BC(a2, v16);
              }

              goto LABEL_36;
            }
          }

          else
          {
LABEL_23:
            id v23 = (os_log_s *)qword_1008F75D0;
            if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v15;
              _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "parseAVRCPDescriptor Key not recognized %d",  buf,  8u);
            }
          }

  (*((void (**)(void **))*a2 + 4))(a2);
LABEL_106:
  sub_100242FAC((uint64_t)v55);
  return sub_100242FAC((uint64_t)v56);
}

  (*(void (**)(__n128 *))(a2->n128_u64[0] + 32))(a2);
LABEL_73:
  sub_100242FAC((uint64_t)v44);
  return sub_100242FAC((uint64_t)v45);
}

    (*(void (**)(__n128 *))(a2->n128_u64[0] + 32))(a2);
    goto LABEL_41;
  }

  if (qword_1008D67E8 != -1) {
    dispatch_once(&qword_1008D67E8, &stru_1008A0068);
  }
  sub_1003CA40C((uint64_t)off_1008D67E0);
  sub_10052C448(a1, a2, 0LL);
  uint64_t v30 = 0;
  sub_100242CA4(&v30);
  id v23 = (*(uint64_t (**)(__n128 *))(a2->n128_u64[0] + 24))(a2);
  sub_1001E61F0((uint64_t)(v4 + 128), v23);
  sub_100242CD0(&v30);
  __p[0] = 0LL;
  __p[1] = 0LL;
  sub_100242F28((uint64_t)__p, a1 + 48);
  uint64_t v24 = *(void *)(a1 + 112);
  if (v24)
  {
    sub_100525ED4(v24, (uint64_t)v4);
    uint64_t v29 = a2->n128_u64[1];
    *(void *)buf = &v29;
    v25 = sub_100029574((uint64_t **)(a1 + 504), &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
    sub_10052904C(a1, (uint64_t *)v25[5]);
    v26 = *(void *)(a1 + 112);
    v27 = sub_1005346A4((uint64_t)a2);
    if (sub_1005268E0(v26, v27))
    {
      (*(void (**)(__n128 *))(a2->n128_u64[0] + 32))(a2);
      sub_10052A368(a1, v4, 0xA5u);
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR)) {
      sub_10068F728();
    }
    sub_10052A368(a1, v4, 0xA2u);
    (*(void (**)(__n128 *))(a2->n128_u64[0] + 32))(a2);
  }

  sub_100242FAC((uint64_t)__p);
  sub_100242CD8(&v30);
LABEL_41:
  sub_100242FAC((uint64_t)v33);
  return sub_100242FAC((uint64_t)v34);
}

  if (a3)
  {
    if (a3->n128_u64[0] != (void)xmmword_1008F1258 || a3->n128_u64[1] != *((void *)&xmmword_1008F1258 + 1))
    {
      uint64_t result = *a3;
      *(__n128 *)(a1 + 16) = *a3;
    }
  }

  if (a4)
  {
    if (*(void *)a4 != (void)xmmword_1008F1258 || *(void *)(a4 + 8) != *((void *)&xmmword_1008F1258 + 1))
    {
      uint64_t result = *(__n128 *)a4;
      *(_OWORD *)(a1 + 32) = *(_OWORD *)a4;
    }
  }

  if (a5)
  {
    if (*(void *)a5 != (void)xmmword_1008F1258 || *(void *)(a5 + 8) != *((void *)&xmmword_1008F1258 + 1))
    {
      uint64_t result = *(__n128 *)a5;
      *(_OWORD *)(a1 + 4_Block_object_dispose(&STACK[0x338], 8) = *(_OWORD *)a5;
    }
  }

  return result;
}

    return 0LL;
  }

  if (v2 != v3)
  {
    uint64_t v15 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
    {
      sub_1006344B4(v3 + 20LL * *(unsigned __int16 *)(a1 + 80), buf);
      if (v33 >= 0) {
        uint64_t v16 = buf;
      }
      else {
        uint64_t v16 = *(_BYTE **)buf;
      }
      uint64_t v17 = *(id *)(a1 + 16);
      *(_DWORD *)__int128 v34 = 136446466;
      __int128 v35 = v16;
      __int128 v36 = 2112;
      __int128 v37 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Attempting to discover services for first UUID %{public}s on device %@",  v34,  0x16u);
      if (v33 < 0) {
        operator delete(*(void **)buf);
      }

      id v3 = *(void *)(a1 + 56);
    }

    uint64_t v18 = *(unsigned __int16 *)(a1 + 80);
    __int128 v19 = operator new(0x40uLL);
    __int128 v20 = v3 + 20LL * v18;
    *(_OWORD *)buf = *(_OWORD *)v20;
    *(_DWORD *)&buf[16] = *(_DWORD *)(v20 + 16);
    id v21 = sub_10053CE50((uint64_t)v19, a1 + 48);
    *(void *)id v21 = off_1008A0818;
    *(_OWORD *)(v21 + 44) = *(_OWORD *)buf;
    *(_DWORD *)(v21 + 60) = *(_DWORD *)&buf[16];
    id v22 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = v19;
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
      __int128 v19 = *(void **)(a1 + 96);
    }

    ++*(_WORD *)(a1 + 80);
    id v8 = *(id *)(a1 + 16);
    id v23 = *(std::__shared_weak_count **)(a1 + 32);
    id v28 = *(void *)(a1 + 24);
    uint64_t v29 = v23;
    if (v23)
    {
      uint64_t v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
    }

    sub_10053CEB4((uint64_t)v19, v8, &v28, *(_WORD *)(a1 + 40));
    uint64_t v12 = v29;
    if (!v29) {
      goto LABEL_31;
    }
    v26 = (unint64_t *)&v29->__shared_owners_;
    do
      id v14 = __ldaxr(v26);
    while (__stlxr(v14 - 1, v26));
    goto LABEL_29;
  }

  return 0LL;
}

      uint64_t v2 = v9;
      uint64_t v17 = 0;
      if (v21 < 0) {
        goto LABEL_27;
      }
LABEL_28:
      if (!v17) {
        goto LABEL_35;
      }
      id v8 = (char *)v8 + 1;
    }

    while (v8 != v6);
    uint64_t v18 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
    id v6 = v18;
  }

  while (v18);
LABEL_34:
  uint64_t v2 = 0LL;
LABEL_35:

  sub_100242FAC((uint64_t)v26);
  return v2;
}

  sub_100242FAC((uint64_t)v26);
}

  free(*(void **)(a1 + 48));
}

LABEL_59:
            objc_autoreleasePoolPop(v17);
          }

          id v13 = -[NSArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v42,  v53,  16LL);
        }

        while (v13);
      }

      if (([v3 internalFlags] & 0x800) == 0)
      {
        identifyDevices = self->_identifyDevices;
        if (!identifyDevices)
        {
          __int128 v32 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          __int128 v33 = self->_identifyDevices;
          self->_identifyDevices = v32;

          identifyDevices = self->_identifyDevices;
        }

        -[NSMutableDictionary setObject:forKeyedSubscript:](identifyDevices, "setObject:forKeyedSubscript:", v3, v36);
        if (v40)
        {
          if (dword_1008D5FD8 <= 30
            && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
          {
            LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesResolveNearbyDevice:]",  30LL,  "Identities resolve added: Addr %@, AT %@, %@, matches %d",  v12,  (void)v41,  v3,  v39);
          }
        }

        else if (v35)
        {
          if (dword_1008D5FD8 <= 30
            && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
          {
            LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesResolveNearbyDevice:]",  30LL,  "Identities resolve added: Addr %@, ATNC %@, %@, matches %d",  v12,  *((void *)&v41 + 1),  v3,  v39);
          }
        }

        else if (dword_1008D5FD8 <= 30 {
               && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
        }
        {
          LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _identitiesResolveNearbyDevice:]",  30LL,  "Identities resolve added: Addr %@, AT %@, ATNC %@, %@, matches %d",  v12,  v41,  v3,  v39);
        }
      }
    }

    goto LABEL_83;
  }

  id v22 = (CBStackBLEAdvertiser *)objc_alloc_init((Class)objc_opt_class( -[CBStackAdaptor bleAdvertiserClass]( self->_stackAdaptor,  "bleAdvertiserClass")));
  if (v22)
  {
    id v9 = v22;
    objc_storeStrong((id *)&self->_appleTypeStackAdvertiser, v22);
    -[CBStackBLEAdvertiser setDispatchQueue:](v9, "setDispatchQueue:", self->_dispatchQueue);
    goto LABEL_61;
  }

  if (dword_1008D6460 <= 90 && (dword_1008D6460 != -1 || _LogCategory_Initialize(&dword_1008D6460, 90LL))) {
    LogPrintF_safe( &dword_1008D6460,  "-[CBAdvertiserDaemon _stackAppleTypeUpdateAdvertising:]",  90LL,  "### %@ advertiser SA create failed",  a3->var2);
  }
LABEL_66:
}

            id v8 = @"### Device not found";
            goto LABEL_53;
          }

  return v33;
}

        v39 = sub_1002E8D94();
        memset(buf, 0, 24);
        (*(void (**)(uint64_t, uint64_t, void, uint8_t *))(*(void *)v39 + 104LL))(v39, 6LL, 0LL, buf);
        if (qword_1008D60B0 != -1) {
          dispatch_once(&qword_1008D60B0, &stru_100892D38);
        }
        v40 = off_1008D60A8;
        sub_10002418C(&__p, "");
        sub_1004319D0((uint64_t)v40, 653, &__p);
      }

      if (v16 - 1 > 0x7CE)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
          sub_10066E1B8();
        }
      }

      else
      {
        WORD2(v4_Block_object_dispose(&STACK[0x338], 8) = 0;
        LOWORD(v4_Block_object_dispose(&STACK[0x338], 8) = 0;
        WORD2(v47) = 0;
        LOWORD(v47) = 0;
        if ((*(unsigned int (**)(uint64_t, void))(*(void *)a1 + 176LL))(a1, 0LL))
        {
          if (v16 < 0x13)
          {
            v27 = sub_1002E6E9C();
            uint64_t v24 = (*(uint64_t (**)(uint64_t, void, char *, uint64_t *, char *, uint64_t *))(*(void *)v27 + 1152LL))( v27,  0LL,  (char *)&v48 + 4,  &v48,  (char *)&v47 + 4,  &v47);
          }

          else
          {
            v61 = 0LL;
            v59 = 0u;
            v60 = 0u;
            v57 = 0u;
            v58 = 0u;
            v55 = 0u;
            v56 = 0u;
            v53 = 0u;
            v54 = 0u;
            v51 = 0u;
            v52 = 0u;
            v50 = 0u;
            memset(buf, 0, sizeof(buf));
            id v23 = sub_1002E6E9C();
            uint64_t v24 = (*(uint64_t (**)(uint64_t, void, uint8_t *))(*(void *)v23 + 1160LL))(v23, 0LL, buf);
            if (!v24)
            {
              WORD2(v4_Block_object_dispose(&STACK[0x338], 8) = *(_WORD *)&buf[4];
              WORD2(v47) = *(_WORD *)&buf[12];
            }
          }
        }

        else
        {
          uint64_t v24 = 205;
        }

        id v22 = 0;
        v25 = WORD2(v47) != 0;
        if (!v24) {
          goto LABEL_41;
        }
      }
    }
  }

    if (v14)
    {
      __int128 v34 = v14[24] != 0;
      __int128 v35 = *((_DWORD *)v14 - 16);
    }

    else
    {
      __int128 v34 = 0;
      __int128 v35 = 0;
    }

    __int128 v36 = sub_1004DEC38(v12, v34, v35);
    if (v15 == 2)
    {
      __int128 v37 = 1;
    }

    else
    {
      __int128 v38 = HIWORD(*(_DWORD *)(a1 + 352));
      __int128 v37 = v38 == 1 || v38 == 10;
    }

    v40 = sub_1004F24C4(v12, *(void **)(a1 + 88), a3, v48, a6, v37, v16, v47, v50, v49, v15 > 0);
    xpc_dictionary_set_value(v36, "kCBMsgArgAdvertisementData", v40);
    xpc_release(v40);
    v42 = *(void *)(a3 + 8);
    v41 = a3 + 8;
    xpc_dictionary_set_int64(v36, "kCBMsgArgRssi", *(char *)(v42 + 216));
    xpc_dictionary_set_int64(v36, "kCBMsgArgAdvertisingMoreAvailable", value[0]);
    v43 = (os_log_s *)qword_1008F7628;
    if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEBUG)) {
      sub_100675DAC(value[0], v41, v43);
    }
    xpc_dictionary_set_int64(v36, "kCBMsgArgAdvertisingIsFromADVBuff", *(unsigned __int8 *)(*(void *)v41 + 304LL));
    if (v15 >= 1)
    {
      xpc_dictionary_set_uint64(v36, "kCBScanOptionFilterIdentifier", (uint64_t)[v13 longLongValue]);
      xpc_dictionary_set_string( v36, "kCBScanOptionFilterIdentifierString", (const char *)[v13 UTF8String]);
    }

    v44 = sub_10043E46C(v36);
    v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
    sub_10038F4BC((void *)a1, 84LL, v45);

    xpc_release(v36);
    goto LABEL_75;
  }

  id v22 = (os_log_s *)qword_1008F7628;
  if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_ERROR))
  {
    id v23 = *(void *)(a1 + 88);
    uint64_t v24 = *(void *)(a1 + 104);
    *(_DWORD *)buf = 138412802;
    *(void *)&buf[4] = v23;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v24;
    *(_WORD *)&buf[22] = 2112;
    v54 = v12;
    _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "App %@ for user %@ is not allowed to access %@",  buf,  0x20u);
  }

  id v22 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyMediumSupervisionTimeout");
  id v23 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v22 + 88LL))(v22, buf, __p, &v94);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v23) {
      goto LABEL_70;
    }
  }

  else if (!v23)
  {
    goto LABEL_70;
  }

  uint64_t v24 = v94;
  v25 = (os_log_s *)qword_1008F7620;
  if ((v94 - 100) >= 0x7C9D && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v24;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_FAULT,  "Override rejected latency supervisionTimeout:%d LeConnectionLatencyMedium",  buf,  8u);
    LOWORD(v24) = v94;
    v25 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 1090) = v24;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v24;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Override latency supervisionTimeout:%d LeConnectionLatencyMedium",  buf,  8u);
  }

    *id v9 = 1;
    *(_WORD *)(a1 + 544LL * v15 + 170) = 0;
    return v4;
  }

  int v4 = (*(uint64_t (**)(void))(v23 + 2848))();
  __int128 v31 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543618;
    v39 = @"EN";
    v40 = 1024;
    v41 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): advBufRSSIBinsThreshold returned %d",  buf,  0x12u);
  }

  if ((_DWORD)v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069C9B8();
    }
  }

  else
  {
    __int128 v32 = sub_1002E6E9C();
    int v4 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v32 + 2856LL))(v32, a2, 0LL);
    __int128 v33 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138543618;
      v39 = @"EN";
      v40 = 1024;
      v41 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "ADVBUFF(%{public}@): advBufConfigTimeSlice returned %d",  buf,  0x12u);
    }

    if (!(_DWORD)v4) {
      goto LABEL_59;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
    sub_10069C9B8();
  }
  return v4;
}

LABEL_84:
}

          if (v13 != 3)
          {
            if (v13 != 2) {
              return 101LL;
            }
            *(void *)(a3 + 16) = v5;
            v45 = *(unsigned __int8 *)(a3 + 9);
            if (v45 < 0x81)
            {
              if (!*(_BYTE *)(a3 + 9)) {
                goto LABEL_147;
              }
            }

            else
            {
              *v101 = 1;
              v45 = 128LL;
            }

            v74 = 0LL;
            v75 = v6 - 2;
            while (1)
            {
              if (v10)
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrc"
                                       "p/avrcp_metadata.c");
              }

              else if (v75 > (unsigned __int16)v9)
              {
                uint64_t v10 = 0;
                v76 = (unsigned __int8 *)(v7 + (unsigned __int16)v9);
                HIDWORD(v77) = *v76;
                LODWORD(v77) = bswap32(*(unsigned __int16 *)(v76 + 1));
                *(_DWORD *)(*(void *)(a3 + 16) + 4 * v74) = v77 >> 16;
                LOWORD(v9) = v9 + 3;
                goto LABEL_158;
              }

              uint64_t v10 = 1;
LABEL_158:
              if (v45 == ++v74) {
                goto LABEL_147;
              }
            }
          }

          *(void *)(a3 + 16) = v5;
          v70 = *(unsigned __int8 *)(a3 + 9);
          v71 = v10;
          if ((v14 & 1) != 0)
          {
            v72 = v6 - v9;
          }

          else
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
            v72 = 0;
          }

          if (v72 >= *(unsigned __int8 *)(a3 + 9))
          {
            if ((_DWORD)v70)
            {
              v78 = (char *)(v7 + v9);
              v79 = &v5[v70];
              do
              {
                v80 = *v78++;
                *v5++ = v80;
              }

              while (v5 < v79);
            }

            uint64_t v10 = v71;
            goto LABEL_147;
          }

          return 134LL;
        }

        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
        id v14 = 0;
        id v13 = *(unsigned __int8 *)(a3 + 8);
        uint64_t v10 = 1;
        goto LABEL_84;
      case 17:
        *(void *)(a3 + 16) = a4;
        if (v6 <= 6)
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
          id v5 = *(_BYTE **)(a3 + 16);
        }

        else if (v6 != 7)
        {
          uint64_t v10 = 0;
          uint64_t v15 = *(unsigned __int8 *)(v7 + 7);
          *(_BYTE *)(a3 + _Block_object_dispose(&STACK[0x338], 8) = v15;
          uint64_t v16 = &a4[v15];
          uint64_t v17 = v6 - 8;
          id v9 = 8LL;
          goto LABEL_90;
        }

        uint64_t v16 = &v5[*(unsigned __int8 *)(a3 + 8)];
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
        uint64_t v17 = 0;
        LODWORD(v15) = *(unsigned __int8 *)(a3 + 8);
        uint64_t v10 = 1;
LABEL_90:
        if (v5 < v16)
        {
          v46 = (char *)(v7 + v9);
          v47 = v16 - v5;
          do
          {
            v48 = *v46++;
            *v5++ = v48;
            --v47;
          }

          while (v47);
        }

        goto LABEL_147;
      case 18:
        *(void *)(a3 + 16) = a4;
        if (v6 <= 6)
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
          id v5 = *(_BYTE **)(a3 + 16);
        }

        else if (v6 != 7)
        {
          uint64_t v10 = 0;
          uint64_t v18 = *(unsigned __int8 *)(v7 + 7);
          *(_BYTE *)(a3 + _Block_object_dispose(&STACK[0x338], 8) = v18;
          __int128 v19 = &a4[v18];
          __int128 v20 = v6 - 8;
          id v9 = 8LL;
          goto LABEL_97;
        }

        __int128 v19 = &v5[*(unsigned __int8 *)(a3 + 8)];
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
        __int128 v20 = 0;
        LODWORD(v1_Block_object_dispose(&STACK[0x338], 8) = *(unsigned __int8 *)(a3 + 8);
        uint64_t v10 = 1;
LABEL_97:
        if (v5 < v19)
        {
          v49 = (char *)(v7 + v9);
          v50 = v19 - v5;
          do
          {
            v51 = *v49++;
            *v5++ = v51;
            --v50;
          }

          while (v50);
        }

        goto LABEL_147;
      case 19:
        *(void *)(a3 + 16) = a4;
        if (v6 <= 6)
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
          id v5 = *(_BYTE **)(a3 + 16);
        }

        else if (v6 != 7)
        {
          uint64_t v10 = 0;
          id v21 = *(unsigned __int8 *)(v7 + 7);
          *(_BYTE *)(a3 + _Block_object_dispose(&STACK[0x338], 8) = v21;
          id v22 = &a4[2 * v21];
          id v23 = v6 - 8;
          id v9 = 8LL;
          goto LABEL_104;
        }

        id v22 = &v5[2 * *(unsigned __int8 *)(a3 + 8)];
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
        id v23 = 0;
        LODWORD(v21) = *(unsigned __int8 *)(a3 + 8);
        uint64_t v10 = 1;
LABEL_104:
        if (v5 < v22)
        {
          v52 = (char *)(v7 + v9);
          v53 = v22 - v5;
          do
          {
            v54 = *v52++;
            *v5++ = v54;
            --v53;
          }

          while (v53);
        }

        goto LABEL_147;
      case 21:
      case 22:
        *(void *)(a3 + 16) = a4;
        if (v6 <= 6)
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
        }

        else if (v6 != 7)
        {
          uint64_t v10 = 0;
          uint64_t v11 = *(unsigned __int8 *)(v7 + 7);
          *(_BYTE *)(a3 + _Block_object_dispose(&STACK[0x338], 8) = v11;
          id v9 = 8LL;
          goto LABEL_47;
        }

        uint64_t v11 = *(unsigned __int8 *)(a3 + 8);
        uint64_t v10 = 1;
LABEL_47:
        if (!v11) {
          goto LABEL_147;
        }
        v25 = 0LL;
        v26 = "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c";
        v27 = v101;
        while (2)
        {
          if (v10)
          {
            sub_1001ED1C4((uint64_t)v26);
LABEL_55:
            sub_1001ED1C4((uint64_t)v26);
            id v28 = v9;
            goto LABEL_56;
          }

          id v28 = (unsigned __int16)v9 + 1LL;
          *(_BYTE *)(*(void *)(a3 + 16) + 24 * v25) = *(_BYTE *)(v7 + (unsigned __int16)v9);
          if ((int)(v6 - 1) <= (unsigned __int16)(v9 + 1))
          {
LABEL_56:
            sub_1001ED1C4((uint64_t)v26);
            __int128 v31 = 0;
            uint64_t v30 = 0;
            uint64_t v10 = 1;
            id v9 = v28;
            goto LABEL_57;
          }

          *(_WORD *)(*(void *)(a3 + 16) + 24 * v25 + 2) = bswap32(*(unsigned __int16 *)(v7 + v28)) >> 16;
          uint64_t v29 = v9 + 3;
          if (v6 <= (unsigned __int16)(v9 + 3))
          {
            __int128 v31 = 0;
            uint64_t v30 = 0;
            uint64_t v10 = 1;
            id v9 = (v9 + 3);
          }

          else
          {
            uint64_t v10 = 0;
            id v9 = (v9 + 4);
            uint64_t v30 = *(unsigned __int8 *)(v7 + v29);
            __int128 v31 = 1;
          }

        sub_100657858();
        return;
      }

      v141 = "(*pBs).__RWFlag == BYTESTREAM_READ";
    }

    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  671,  v141);
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid enhanced connection complete event packet size : %d, expecting %d",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v6);
    id v14 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
LABEL_38:
    }
      sub_100657858();
  }

        __int128 v37 = (os_log_s *)qword_1008F7600;
        if (!v13)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_INFO))
          {
            sub_1003D0100((uint64_t)v8, (uint64_t)buf);
            v39 = buf;
            if (v76[9] < 0) {
              v39 = *(_BYTE **)buf;
            }
            *(_DWORD *)__p = 141558275;
            *(void *)&__p[4] = 1752392040LL;
            v79 = 2081;
            v80 = v39;
            _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_INFO,  "Successfully stored non-magic Enc Key to storage for device %{private, mask.hash}s ",  __p,  0x16u);
            if ((v76[9] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }

          id v13 = 0;
          goto LABEL_97;
        }

        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR))
        {
          sub_1003D0100((uint64_t)v8, (uint64_t)__p);
          __int128 v38 = __p;
          if (v81 < 0) {
            __int128 v38 = *(_BYTE **)__p;
          }
          *(_DWORD *)buf = 141558531;
          *(void *)&buf[4] = 1752392040LL;
          *(_WORD *)&buf[12] = 2081;
          *(void *)v76 = v38;
          *(_WORD *)&v76[8] = 1024;
          v77 = v13;
          _os_log_error_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "Failed to store non-magic Enc Key to storage for device %{private, mask.hash}s with error %d",  buf,  0x1Cu);
          if (v81 < 0)
          {
            __int128 v36 = *(void **)__p;
LABEL_90:
            operator delete(v36);
          }
        }

      v51 = (os_log_s *)qword_1008F7628;
      if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
      {
        if (a8) {
          v52 = "peripheral";
        }
        else {
          v52 = "central";
        }
        sub_100494958(v25, (uint64_t)v113);
        v53 = v116;
        v54 = *(_BYTE **)v113;
        sub_10027B47C((unsigned __int8 *)&v104, &__p);
        v55 = v113;
        v56 = "on";
        if (v53 < 0) {
          v55 = v54;
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&buf[4] = v52;
        if (v20) {
          v57 = "on";
        }
        else {
          v57 = "off";
        }
        if (!v48) {
          v56 = "off";
        }
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v55;
        p_p = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        }
        *(_WORD *)&buf[22] = 2082;
        *(void *)&buf[24] = v56;
        *(_WORD *)v108 = 2082;
        *(void *)&v108[2] = v57;
        v109 = 2114;
        v110 = v20;
        v111 = 2080;
        v112 = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "Registering %{public}s session %{public}s with backgrounding: %{public}s, persistence: %{public}s (CBSR) r estoreID: %{public}@ %s",  buf,  0x3Eu);
        if (v116 < 0) {
          operator delete(*(void **)v113);
        }
      }

      if (sub_10027B860(v100, v25, v19, a8, v48))
      {
        (*(void (**)(uint64_t, uint64_t, id))(*(void *)v98 + 8LL))(v98, v25, v19);
        if (qword_1008D61A8 == -1)
        {
LABEL_103:
          sub_1004966BC(qword_1008D61A0, v102);
LABEL_104:
          v25 = 0LL;
          goto LABEL_105;
        }

    sub_100242CD8(&v61);
    id v9 = 0LL;
    goto LABEL_85;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C((uint64_t)v7, __p);
    sub_1006731E0();
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100893E08);
  }
  id v8 = sub_1004317E0((uint64_t)off_1008D60A8, a4, 20000);
  sub_100410A5C(a1, (uint64_t)v7, v8);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100893E08);
  }
  id v9 = sub_1004317E0((uint64_t)off_1008D60A8, a4, 20000);
LABEL_85:
  sub_100242FAC((uint64_t)v62);
  return v9;
}

    if ((v41 & 1) != 0)
    {
      if (v17 != (char *)v28)
      {
        while (1)
        {
          v46 = *(void *)(*(void *)v17 + 8LL);
          v47 = *(_DWORD *)(v46 + 20);
          buf = *(__n128 *)(v46 + 4);
          v168 = v47;
          sub_100634334(&v164, &buf);
          v124 = xmmword_1006BD928;
          v125 = 0;
          v17 += 8;
          if (v17 == (char *)v28)
          {
            uint64_t v17 = (char *)v28;
            goto LABEL_89;
          }
        }
      }

      goto LABEL_89;
    }

        sub_1000B1838(v25);
        __p[1] = &off_10087FAA8;
        id v21 = a3 + 8;
        if ((void)v116) {
          sub_1002CD254((unsigned int *)v116);
        }
        v92 = &off_10087FAA8;
        if (v93) {
          sub_1002CD254(v93);
        }
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
      sub_1006962AC();
    }
LABEL_92:
    if (v82 != *(_DWORD *)(v86 + 20) && os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_FAULT)) {
      sub_100696248();
    }
    __int128 v36 = mach_absolute_time();
    __int128 v37 = (v36 - *(void *)(v86 + 176)) * dword_1008F1CE4 / *(unsigned int *)algn_1008F1CE8 / 0xF4240;
    *(_DWORD *)(v86 + 192) += v37;
    __int128 v38 = *(id *)(v86 + 200);
    v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v37));
    [v85 setObject:v39 forKeyedSubscript:@"ProfileSetupDuration"];

    v40 = (void *)objc_claimAutoreleasedReturnValue([v85 objectForKey:@"BasebandDurationTotal"]);
    v41 = v40 == 0LL;

    if (!v41)
    {
      v42 = (void *)objc_claimAutoreleasedReturnValue([v85 objectForKeyedSubscript:@"BasebandDurationTotal"]);
      *(_DWORD *)(v86 + 192) += [v42 intValue];
    }

    v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(v86 + 192)));
    [v85 setObject:v43 forKeyedSubscript:@"DurationWithRetries"];

    v44 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"EncryptionConnectionTimeMs"]);
    [v85 setObject:v44 forKeyedSubscript:@"EncryptionSetupDuration"];

    v45 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKey:@"BasebandConnectionTimeMs"]);
    v46 = v45 == 0LL;

    if (!v46)
    {
      v47 = *(void *)(v86 + 160);
      v49 = dword_1008F1CE4;
      v48 = *(unsigned int *)algn_1008F1CE8;
      v50 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"BasebandConnectionTimeMs"]);
      [v85 setObject:v50 forKeyedSubscript:@"BasebandDurationTotal"];

      v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v47 * v49 / v48 / 0xF4240));
      [v85 setObject:v51 forKeyedSubscript:@"BasebandDuration"];
    }

    v52 = sub_1002E8D94();
    v53 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, void *))(*(void *)v52 + 520LL))(v52, v83, v85);
    LODWORD(v92) = v82;
    sub_100581D1C(v53, (int *)&v92, (uint64_t)v83, v86);
    v54 = (int)v92;
    v89 = (int)v92;
    sub_1005821D4(v55, &v89, v83, v86);
    v56 = (os_log_s *)qword_1008F7748;
    if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__p[0]) = 67109632;
      HIDWORD(__p[0]) = v82;
      LOWORD(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 2) = v54;
      HIWORD(__p[1]) = 1024;
      LODWORD(v116) = v89;
      _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "Setup Complete with profiles: %x, profile attempts: %x, profile results: %x",  (uint8_t *)__p,  0x14u);
    }

    v57 = *(void **)(v86 + 200);
    v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v37));
    [v57 setObject:v58 forKey:@"ProfileConnectionTimeMs"];

    v59 = (os_log_s *)qword_1008F7748;
    if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_DEFAULT))
    {
      v60 = (v36 - *(void *)(v86 + 184)) * dword_1008F1CE4 / *(unsigned int *)algn_1008F1CE8 / 0xF4240;
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v60;
      _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "Configuration took %d ms",  (uint8_t *)__p,  8u);
      v59 = (os_log_s *)qword_1008F7748;
    }

    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v37;
      _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "Profile setup took %d ms",  (uint8_t *)__p,  8u);
    }

    v61 = *(void **)(v86 + 200);
    v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(v86 + 192)));
    [v61 setObject:v62 forKey:@"TotalConnectionTimeMs"];

    v63 = (os_log_s *)qword_1008F7748;
    if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_DEFAULT))
    {
      v64 = *(_DWORD *)(v86 + 192);
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v64;
      _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Total connection took %d ms!",  (uint8_t *)__p,  8u);
    }

    v65 = *(void **)(v86 + 200);
    sub_1003D930C((uint64_t)v83, 0xAu, __p);
    if ((SBYTE7(v116) & 0x80u) == 0) {
      v66 = __p;
    }
    else {
      v66 = (void **)__p[0];
    }
    v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v66));
    [v65 setObject:v67 forKey:@"FWVersion"];

    if (SBYTE7(v116) < 0) {
      operator delete(__p[0]);
    }
    global_queue = dispatch_get_global_queue(0LL, 0LL);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100583938;
    block[3] = &unk_10087EA48;
    v69 = v38;
    v88 = v69;
    dispatch_async(global_queue, block);
    sub_100242C98(&v96);
    v129 = 0u;
    v130 = 0u;
    v127 = 0u;
    v128 = 0u;
    v125 = 0u;
    v126 = 0u;
    v123 = 0u;
    v124 = 0u;
    v121 = 0u;
    v122 = 0u;
    v119 = 0u;
    v120 = 0u;
    v117 = 0u;
    v118 = 0u;
    *(_OWORD *)__p = 0u;
    v116 = 0u;
    sub_1001EE0BC((uint64_t)__p, 256, (uint64_t)"PFC Profile Setup took %d", v70, v71, v72, v73, v74, v37);
    sub_1000B9914((const char *)__p);
    v113 = 0u;
    v114 = 0u;
    v111 = 0u;
    v112 = 0u;
    v109 = 0u;
    v110 = 0u;
    v107 = 0u;
    v108 = 0u;
    v105 = 0u;
    v106 = 0u;
    v103 = 0u;
    v104 = 0u;
    v101 = 0u;
    v102 = 0u;
    *(_OWORD *)buf = 0u;
    v100 = 0u;
    sub_1001EE0BC( (uint64_t)buf,  256,  (uint64_t)"PFC Total connection took %d",  v75,  v76,  v77,  v78,  v79,  *(unsigned int *)(v86 + 192));
    sub_1000B9914((const char *)buf);
    sub_100242CD0(&v96);
    sub_10057E5E8(a1, (uint64_t)&v97, 0LL);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
  {
    sub_1003FE1B4((unsigned __int8 *)&v94, __p);
    sub_1006961F8();
  }

  return sub_100242CD8(&v96);
}

  __int128 v33 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyHighMaxInterval");
  __int128 v34 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v33 + 88LL))(v33, buf, __p, &v95);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v34) {
      goto LABEL_95;
    }
  }

  else if (!v34)
  {
    goto LABEL_95;
  }

  __int128 v35 = v95;
  __int128 v36 = (os_log_s *)qword_1008F7620;
  if ((v95 - 8) >= 0xF9A && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v35;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "Override rejected latency maxInterval:%d LeConnectionLatencyHigh",  buf,  8u);
    LOWORD(v35) = v95;
    __int128 v36 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 1094) = v35;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v35;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Override latency maxInterval:%d LeConnectionLatencyHigh",  buf,  8u);
  }

          v62 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            v63 = sub_1005BFB9C(v8);
            v64 = (void *)objc_claimAutoreleasedReturnValue(v63);
            *(_DWORD *)buf = 138543618;
            *(void *)&buf[4] = v64;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = a5;
            _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "Failed to connect to device %{public}@ with result %{bluetooth:OI_STATUS}u",  buf,  0x12u);
          }

          if (a3)
          {
            v65 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT)) {
              sub_100699180(v65, v66, v67, v68, v69, v70, v71, v72);
            }
          }

void sub_100018110( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

void sub_100018138(uint64_t a1, void *a2, void *a3)
{
  id v11 = a2;
  id v5 = a3;
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 identifier]);
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 544) objectForKeyedSubscript:v6]);

    if (!v7)
    {

      goto LABEL_8;
    }
  }

  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v9 = *(void **)(v8 + 40);
  if (!v9) {
    goto LABEL_6;
  }
  id v10 = [v9 lastSeenTicks];
  if (v10 > [v5 lastSeenTicks])
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
LABEL_6:
    objc_storeStrong((id *)(v8 + 40), a3);
  }

LABEL_8:
}

    id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    if ([v54 count])
    {
      v43 = 0uLL;
      v44 = 0uLL;
      v41 = 0uLL;
      v42 = 0uLL;
      id v10 = v54;
      id v11 = [v10 countByEnumeratingWithState:&v41 objects:v66 count:16];
      if (v11)
      {
        uint64_t v12 = *(void *)v42;
        do
        {
          for (uint64_t i = 0LL; i != v11; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v42 != v12) {
              objc_enumerationMutation(v10);
            }
            id v14 = *(void *)(*((void *)&v41 + 1) + 8LL * (void)i);
            v65[0] = @"disableCentralSkipSniff";
            v65[1] = @"enableSpecialSniffTransitions";
            v65[2] = @"move3PPLEMSToLegacyMode";
            v65[3] = @"move3PPLEMSToLegacyModeSerial";
            v65[4] = @"BluetoothAutoSeekKeyboard";
            v65[5] = @"BluetoothAutoSeekPointingDevice";
            uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v65,  6LL));
            else {
              uint64_t v16 = @"com.apple.bluetooth";
            }
            uint64_t v17 = v16;

            uint64_t v18 = (void *)CFPrefs_CopyTypedValue(v17, v14, 0LL, 0LL);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v9, "setObject:forKeyedSubscript:", v18, v14);
          }

          id v11 = [v10 countByEnumeratingWithState:&v41 objects:v66 count:16];
        }

        while (v11);
      }
    }

    else
    {
      v51 = 0uLL;
      v52 = 0uLL;
      v49 = 0uLL;
      v50 = 0uLL;
      __int128 v19 = (void *)CFPrefs_CopyKeys(@"com.apple.Bluetooth", 0LL);
      __int128 v20 = [v19 countByEnumeratingWithState:&v49 objects:v68 count:16];
      if (v20)
      {
        id v21 = *(void *)v50;
        do
        {
          for (j = 0LL; j != v20; j = (char *)j + 1)
          {
            if (*(void *)v50 != v21) {
              objc_enumerationMutation(v19);
            }
            id v23 = *(void *)(*((void *)&v49 + 1) + 8LL * (void)j);
            uint64_t v24 = (void *)CFPrefs_CopyTypedValue(@"com.apple.Bluetooth", v23, 0LL, 0LL);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v9, "setObject:forKeyedSubscript:", v24, v23);
          }

          __int128 v20 = [v19 countByEnumeratingWithState:&v49 objects:v68 count:16];
        }

        while (v20);
      }

      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      id v10 = (id)CFPrefs_CopyKeys(@"com.apple.bluetooth", 0LL);
      v25 = [v10 countByEnumeratingWithState:&v45 objects:v67 count:16];
      if (v25)
      {
        v26 = *(void *)v46;
        do
        {
          for (k = 0LL; k != v25; k = (char *)k + 1)
          {
            if (*(void *)v46 != v26) {
              objc_enumerationMutation(v10);
            }
            id v28 = *(void *)(*((void *)&v45 + 1) + 8LL * (void)k);
            uint64_t v29 = (void *)CFPrefs_CopyTypedValue(@"com.apple.bluetooth", v28, 0LL, 0LL);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v9, "setObject:forKeyedSubscript:", v29, v28);
          }

          v25 = [v10 countByEnumeratingWithState:&v45 objects:v67 count:16];
        }

        while (v25);
      }
    }

    Reply = CUXPCDictionaryCreateReply(v40);
    __int128 v31 = (void *)objc_claimAutoreleasedReturnValue(Reply);
    if (v31)
    {
      __int128 v32 = (void *)_CFXPCCreateXPCObjectFromCFObject(v9);
      if (v32)
      {
        xpc_dictionary_set_value(v31, "pfVs", v32);
        -[CBDaemonXPCConnection _xpcSendReply:](self, "_xpcSendReply:", v31);
      }

      else
      {
        __int128 v35 = CBErrorF(4294960596LL, "Convert pref values to XPC failed");
        __int128 v36 = objc_claimAutoreleasedReturnValue(v35);
        __int128 v37 = v60[5];
        v60[5] = (id)v36;
      }
    }

    else if (dword_1008D6630 <= 90 {
           && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
    }
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcReadPrefs:]",  90LL,  "### ReadPrefs create reply failed");
    }

    goto LABEL_39;
  }

    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer stackController](self->_daemon, "stackController"));
    uint64_t v16 = v35;
    v25 = v35[5];
    uint64_t v17 = [v15 sendSmartRoutingInformation:v27 device:v29 error:&v25];
    objc_storeStrong(v16 + 5, v25);

    if ((v17 & 1) == 0)
    {
LABEL_12:

LABEL_13:
      goto LABEL_14;
    }

    Reply = CUXPCDictionaryCreateReply(v4);
    __int128 v19 = (id)objc_claimAutoreleasedReturnValue(Reply);
    if (v19)
    {
      -[CBDaemonXPCConnection _xpcSendReply:](self, "_xpcSendReply:", v19);
    }

    else if (dword_1008D6630 <= 90 {
           && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
    }
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendSmartRoutingInformation:]",  90LL,  "### SendSmartRoutingInformation create reply failed");
    }

    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer stackController](self->_daemon, "stackController"));
    uint64_t v16 = v35;
    v25 = v35[5];
    uint64_t v17 = [v15 sendConversationDetectMessage:v27 device:v29 error:&v25];
    objc_storeStrong(v16 + 5, v25);

    if ((v17 & 1) == 0)
    {
LABEL_12:

LABEL_13:
      goto LABEL_14;
    }

    Reply = CUXPCDictionaryCreateReply(v4);
    __int128 v19 = (id)objc_claimAutoreleasedReturnValue(Reply);
    if (v19)
    {
      -[CBDaemonXPCConnection _xpcSendReply:](self, "_xpcSendReply:", v19);
    }

    else if (dword_1008D6630 <= 90 {
           && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
    }
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendConversationDetectMessage:]",  90LL,  "### SendConversationDetectMessage create reply failed");
    }

      uint64_t v15 = CBErrorF(4294960569LL, "Peer token not found");
      uint64_t v16 = objc_claimAutoreleasedReturnValue(v15);
    }

    else
    {
      __int128 v31 = CBErrorF(4294960551LL, "No session");
      uint64_t v16 = objc_claimAutoreleasedReturnValue(v31);
    }

    uint64_t v17 = v47[5];
    v47[5] = (id)v16;
LABEL_31:

    goto LABEL_32;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"No connection associated with handle (%d)!\n", v5, v6, v7, v8, v9, v10, v11, a1);
    uint64_t v12 = (os_log_s *)sub_100086554(0x53u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_18:
    }
      sub_100657858();
  }

    if (properties) {
      CFRelease(properties);
    }
    IOObjectRelease(v9);
    id v9 = IOIteratorNext(existing);
  }

  while (v9);
  sub_1001EE0E4("[bm3_usb][GetProductAndVendorID] -- Use internal Bluetooth USB Host Controller \n");
  if ((v71 & 1) == 0) {
    goto LABEL_132;
  }
  v78 = __PAIR64__(v69, v70);
  sub_1001EE0E4( "[bm3_usb][GetProductAndVendorID] -- Found internal Bluetooth USB Host Controller -- vendorID = 0x%04x, produceID = 0x%04x \n",  v69,  v70);
  IOObjectRelease(existing);
  CFRelease(v6);
  CFRelease(key);
  CFRelease(cf);
  CFRelease(v75);
  CFRelease(v7);
  CFRelease(v74);
  CFRelease(theString1);
  uint64_t v1 = kIOMainPortDefault;
  int v4 = v72;
  if (!v69 || !v70)
  {
    LODWORD(v7_Block_object_dispose(&STACK[0x338], 8) = (unsigned __int16)word_1008DE422;
    HIDWORD(v7_Block_object_dispose(&STACK[0x338], 8) = (unsigned __int16)word_1008DE420;
  }

      id v5 = (void **)v2;
      uint64_t v2 = (unsigned __int16 *)*v7;
    }

    while (*v7);
  }

  sub_100102438(a2);
  return 4LL;
}

  id v10 = byte_1008E2181;
  byte_1008E2181 = 0;
  if (v10 == 2) {
    sub_100114274();
  }
}

  if ((*(_BYTE *)(v6 + 74) & 2) != 0)
  {
    *(_BYTE *)(v6 + 75) |= 2u;
    buf[0] = *(_BYTE *)a2;
    *(_DWORD *)&buf[1] = *(_DWORD *)(a2 + 1);
    *(_WORD *)&buf[5] = *(_WORD *)(a2 + 5);
    sub_100184730(&buf[1], 6);
    if (buf[0])
    {
      sub_1001EE134( (uint64_t)"We got a remote address (%:) that is not public",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  (uint64_t)&buf[1]);
      v72 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      goto LABEL_66;
    }

    if (*(_DWORD *)&buf[1]) {
      v81 = 0;
    }
    else {
      v81 = *(unsigned __int16 *)&buf[5] == 0;
    }
    if (v81)
    {
      sub_1001EE134((uint64_t)"Identity address cannot be all 0.", v91, v92, v93, v94, v95, v96, v97, v99);
      v98 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v98, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      goto LABEL_66;
    }

    if (*(_DWORD *)&buf[1] == *(_DWORD *)(*(void *)v6 + 48LL)
      && *(unsigned __int16 *)&buf[5] == *(unsigned __int16 *)(*(void *)v6 + 52LL))
    {
      goto LABEL_12;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Identity address cannot be different than the classic address.",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  v99);
      v90 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
LABEL_66:
      }
        sub_100657858();
    }

  free(a3);
  return v4;
}

  id v3 = sub_1001EF520((uint64_t)v23, 1u);
  if (!(_DWORD)v3)
  {
    id v3 = sub_1001EFB10((unsigned __int8 *)v23, *(char **)(a1 + 48), *(unsigned __int16 *)(a1 + 40), 2u);
    if (!(_DWORD)v3)
    {
      int v4 = sub_1001A2530(*(__int128 **)a1, (uint64_t)v23, *(_BYTE *)(a1 + 56), 0LL);
      if ((_DWORD)v4 == 412 || (id v3 = v4, !(_DWORD)v4))
      {
        if (*(_BYTE *)(a1 + 56))
        {
          v22[1] = &v24;
          v22[0] = (const void *)8;
          sub_1001EE6E8((uint64_t)sub_1001A54FC, v22, (unsigned __int16)dword_1008D8EB0, (int *)(a1 + 60));
        }

        id v3 = 0LL;
      }
    }
  }

  sub_1001EF5E4((uint64_t)v23);
  return v3;
}

  if (!v10 && !sub_10018550C(v7, 35))
  {
    v90 = sub_100185414();
    sub_1001EE134( (uint64_t)"Device was not in the proper state. State is %s.",  v91,  v92,  v93,  v94,  v95,  v96,  v97,  (uint64_t)v90);
    v98 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v98, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  *(_OWORD *)(v7 + 104) = *a2;
  id v11 = *(unsigned __int8 *)(v7 + 16);
  switch(v11)
  {
    case 6:
      goto LABEL_13;
    case 5:
      sub_1001EE134((uint64_t)"Should not be here !", v62, v63, v64, v65, v66, v67, v68, v128);
      v69 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      goto LABEL_22;
    case 1:
LABEL_13:
      if (*(_BYTE *)(a1 + 70))
      {
        sub_1001EE134( (uint64_t)"At this point, peripheral should not get a confirmation value",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v128);
        __int128 v19 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      v99 = sub_1001D4A70(a1, (__int128 *)(v7 + 457));
      if ((_DWORD)v99)
      {
        v100 = v99;
        sub_1001EE134( (uint64_t)"Failed to send pairing random to peripheral %!",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  v100);
        v108 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
        goto LABEL_76;
      }

  id v6 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read State Notification", v7, v8, v9, v10, v11, v12, v13, v16);
    id v14 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v6;
}

  id v6 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read Bonding Status Response", v7, v8, v9, v10, v11, v12, v13, v16);
    id v14 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v6;
}

  id v6 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read Siri", v7, v8, v9, v10, v11, v12, v13, v16);
    id v14 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v6;
}

  sub_100029630(a1, (uint64_t)v3, v5, a2);
  return a2;
}

  sub_100029630(a1, (uint64_t)v6, v8, v4);
  return v4;
}

      __int128 v19 = (void *)v15[1];
      if (v19)
      {
        do
        {
          __int128 v20 = v19;
          __int128 v19 = (void *)*v19;
        }

        while (v19);
      }

      else
      {
        do
        {
          __int128 v20 = (void *)v15[2];
          id v21 = *v20 == (void)v15;
          uint64_t v15 = v20;
        }

        while (!v21);
      }

      uint64_t v15 = v20;
    }

    while (v20 != v16);
  }
}

  sub_100029630(a1, (uint64_t)v3, v5, (uint64_t *)a2);
  return a2;
}

  sub_100029630(a1, (uint64_t)v6, v8, (uint64_t *)v4);
  return v5;
}

    id v21 = 0LL;
    id v22 = 0LL;
    id v23 = 0LL;
    sub_100240540(&v21, *i + 136);
    id v11 = v21;
    if (v21 == v22)
    {
      uint64_t v16 = 0;
      if (v21) {
        goto LABEL_29;
      }
    }

    else
    {
      while (1)
      {
        uint64_t v12 = *(void *)v11;
        if (*(_DWORD *)(*(void *)v11 + 16LL) == a2) {
          break;
        }
        uint64_t v12 = *(void *)(v12 + 96);
        if (*(_DWORD *)(v12 + 16) == a2) {
          break;
        }
        uint64_t v18 = 0LL;
        __int128 v19 = 0LL;
        __int128 v20 = 0LL;
        sub_100240540(&v18, *(void *)v11 + 104LL);
        id v13 = v18;
        if (v18 == v19)
        {
          uint64_t v16 = 0;
          uint64_t v15 = 1;
          if (v18)
          {
LABEL_17:
            __int128 v19 = v18;
            operator delete(v18);
          }
        }

        else
        {
          while (1)
          {
            id v14 = *(_DWORD *)(*(void *)v13 + 16LL);
            uint64_t v15 = v14 != a2;
            if (v14 == a2) {
              break;
            }
            v13 += 8;
            if (v13 == v19)
            {
              uint64_t v16 = 0;
              if (v18) {
                goto LABEL_17;
              }
              goto LABEL_18;
            }
          }

          uint64_t v16 = 1;
          id v3 = *(void *)v13;
          if (v18) {
            goto LABEL_17;
          }
        }

  if (v6 != a2)
  {
    sub_100242F54((uint64_t)v13);
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100895B68);
    }
    sub_1003FFDA4((os_unfair_lock_s *)off_1008D5F48, a1, 9);
  }

  return sub_100242FAC((uint64_t)v13);
}

  sub_100029630(a1, (uint64_t)v3, v5, (uint64_t *)a2);
  return a2;
}

  sub_100029630(a1, (uint64_t)v6, v8, v4);
  return v4;
}

  id v5 = (const __CFString *)CFPreferencesCopyAppValue(@"CloudAccountID", @"com.apple.BTServer");
  id v6 = v5;
  if (v5)
  {
    uint64_t v7 = CFGetTypeID(v5);
    if (v7 == CFStringGetTypeID())
    {
      CStringPtr = (char *)CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        sub_10002418C(v13, CStringPtr);
        id v9 = (void **)(a1 + 216);
        *(_OWORD *)id v9 = *(_OWORD *)v13;
        *(void *)(a1 + 232) = *(void *)&v13[16];
      }

      goto LABEL_16;
    }
  }

  if ((*(char *)(a1 + 239) & 0x80000000) == 0)
  {
    *(_BYTE *)(a1 + 216) = 0;
    *(_BYTE *)(a1 + 239) = 0;
    if (!v6) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  **(_BYTE **)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0LL;
  if (v6) {
LABEL_16:
  }
    CFRelease(v6);
LABEL_17:
  id v10 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = *(unsigned __int8 *)(a1 + 241);
    uint64_t v12 = (void *)(a1 + 216);
    *(_DWORD *)id v13 = 67109635;
    *(_DWORD *)&v13[4] = v11;
    *(_WORD *)&v13[8] = 2160;
    *(void *)&v13[10] = 1752392040LL;
    *(_WORD *)&v13[18] = 2081;
    *(void *)&v13[20] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "statedump: MagicPairingManager: SignedIn: %d, loginID: %{private, mask.hash}s",  v13,  0x1Cu);
  }

  v34[0] = 0LL;
  v34[1] = 0LL;
  sub_100242F28((uint64_t)v34, (uint64_t)(a1 + 21));
  for (uint64_t i = a1[18]; i != a1[19]; i += 8LL)
  {
    uint64_t v17 = *(void **)i;
    if (*(_DWORD *)(*(void *)i + 128LL) == *(_DWORD *)a2
      && *(unsigned __int16 *)(*(void *)i + 132LL) == *(unsigned __int16 *)(a2 + 4))
    {
      goto LABEL_34;
    }
  }

  if (a3)
  {
    uint64_t v17 = operator new(0x5F0uLL);
    sub_1003CED40(v17, a2);
    __int128 v19 = a1[20];
    __int128 v20 = (void *)a1[19];
    if ((unint64_t)v20 >= v19)
    {
      id v22 = a1[18];
      id v23 = ((uint64_t)v20 - v22) >> 3;
      uint64_t v24 = v19 - v22;
      v25 = v24 >> 2;
      else {
        v26 = v25;
      }
      if (v26) {
        v27 = (char *)sub_100008BA0((uint64_t)(a1 + 20), v26);
      }
      else {
        v27 = 0LL;
      }
      id v28 = &v27[8 * v23];
      uint64_t v29 = &v27[8 * v26];
      *(void *)id v28 = v17;
      id v21 = v28 + 8;
      __int128 v31 = (char *)a1[18];
      uint64_t v30 = (char *)a1[19];
      if (v30 != v31)
      {
        do
        {
          __int128 v32 = *((void *)v30 - 1);
          v30 -= 8;
          *((void *)v28 - 1) = v32;
          v28 -= 8;
        }

        while (v30 != v31);
        uint64_t v30 = (char *)a1[18];
      }

      a1[18] = v28;
      a1[19] = v21;
      a1[20] = v29;
      if (v30) {
        operator delete(v30);
      }
    }

    else
    {
      NSMutableArray *v20 = v17;
      id v21 = v20 + 1;
    }

    a1[19] = v21;
  }

  else
  {
    uint64_t v17 = 0LL;
  }

  sub_10040D518(a1);
  if (!*(_BYTE *)(a1 + 116)) {
    goto LABEL_18;
  }
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896FC8);
  }
  if (sub_100435710((uint64_t)off_1008D60A8) == 2)
  {
    uint64_t v7 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Airplane mode is ON and airplane mode default grant list state is enabled on power init",  v11,  2u);
    }

    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896FC8);
    }
    uint64_t v8 = 1;
  }

  else
  {
LABEL_18:
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_100896FC8);
    }
    uint64_t v8 = 0;
  }

  sub_10042FC90((uint64_t)off_1008D60A8, v8);
  id v9 = sub_1002E6E00();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v9 + 8LL))(v9) & 1) == 0)
  {
    id v10 = sub_1002E8D94();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 152LL))(v10, 4LL);
  }

  id v11 = @"Unknown";
LABEL_9:
  *(void *)uu = 0LL;
  *(void *)&uu[8] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100897EB8);
  }
  sub_1005D0B84((uint64_t)off_1008D5F28, (unsigned __int8 *)(a2 + 128), uu);
  if (uuid_is_null(uu))
  {
    uint64_t v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_1003CF00C(a2, v83);
      sub_10067DCCC(v83, (uint64_t)v90, v12);
    }

  __int128 v20 = v15;
LABEL_15:

  return v20;
}

  sub_100029630(a1, (uint64_t)v6, v8, v4);
  return v4;
}

  reply = xpc_dictionary_create_reply(xdict);
  id v22 = reply;
  if (reply)
  {
    xpc_dictionary_set_int64(reply, "kCBMsgArgResult", *((int *)v33 + 6));
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v22);
    xpc_release(v22);
  }

  _Block_object_dispose(&v32, 8);
}

  id v23 = &off_10087FAA8;
  if (v24) {
    sub_1002CD254(v24);
  }
  _Block_object_dispose(&v25, 8);
}

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_uint64(v10, "kCBMsgArgBool", value);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_uint64(v10, "kCBMsgArgBool", value);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v11 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v9);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v11);
    xpc_release(v11);
  }

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v10 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_uint64(v10, "kCBMsgArgFeatureProxCardStatusMessage", value);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v10);
    xpc_release(v10);
  }

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v11 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v9);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v11);
    xpc_release(v11);
  }
}

  sub_100029630(a1, (uint64_t)v5, v6, (uint64_t *)a2);
  return a2;
}

  sub_100029630(a1, (uint64_t)v6, v7, (uint64_t *)v4);
  return v4;
}

  id v9 = *(void *)i;
  *(void *)(v9 + _Block_object_dispose(&STACK[0x338], 8) = *((void *)i + 1);
  **((void **)i + 1) = v9;
  --*(void *)(a1 + 208);
  operator delete(i);
  uint64_t result = sub_1005DCFE8(v4, 0LL, 0LL, uu2);
  id v11 = *(void **)(a1 + 200);
  uint64_t v12 = *(void *)(a1 + 208);
  void *result = v4;
  result[1] = v11;
  void *v11 = result;
  *(void *)(a1 + 200) = result;
  *(void *)(a1 + 20_Block_object_dispose(&STACK[0x338], 8) = v12 + 1;
  return result;
}

void sub_1000182F4(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  id v6 = objc_autoreleasePoolPush();
  objc_autoreleasePoolPop(v6);
}

LABEL_33:
    objc_autoreleasePoolPop(v18);
    uint64_t v29 = v17++ == 2;
    if (v29) {
      __int128 v33 = 1;
    }
    else {
      __int128 v33 = v27;
    }
  }

  while ((v33 & 1) == 0);
  if (!*((_BYTE *)v65 + 24))
  {
    if (self->_prefAuthTagIntegrityCheckEnabled) {
      [v6 resetNearbyInfoV2SensitiveProperties];
    }
    if (dword_1008D5FD8 <= 90
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
    {
      __int128 v34 = "yes";
      if (!*((_BYTE *)v65 + 24)) {
        __int128 v34 = "no";
      }
      __int128 v35 = *((char *)v49 + 24) + 1LL;
      else {
        __int128 v36 = off_10087F6A0[v35];
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _verifyNearbyInfoV2IntegrityTag:rapportIdentity:]",  90LL,  "IntegrityTag resolve mismatch: AT %@, IT valid %s, %s, CBIN %u, %@, %@",  v8,  v34,  v36,  v20,  v6,  v7);
    }
  }

  if (!self->_prefAuthTagIntegrityCheckEnabled)
  {
LABEL_58:
    __int128 v37 = 1;
    goto LABEL_59;
  }

  ((void (*)(void *))v36[2])(v36);

  _Block_object_dispose(&v46, 8);
}

      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"PutCommand error %!", v29, v30, v31, v32, v33, v34, v35, v16);
        __int128 v36 = (os_log_s *)sub_100086554(0x18u);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      if (ptr)
      {
        sub_1000B1838(ptr);
        ptr = 0LL;
      }

      __int128 v37 = *(_DWORD *)(a1 + 204);
      if (v37 > 9 || ((1 << v37) & 0x320) == 0) {
        goto LABEL_132;
      }
      __int128 v38 = *(void (**)(void, void, uint64_t))(*(void *)(*(void *)(a1 + 168) + 16LL) + 24LL);
      if (!v38) {
        goto LABEL_42;
      }
      goto LABEL_41;
    case 0x83:
      ptr = 0LL;
      v194 = 0LL;
      if (v7 == 5)
      {
        *(_DWORD *)(a1 + 204) = 6;
      }

      else if ((v7 & 0xFFFFFFFE) != 6)
      {
        uint64_t v16 = 1711LL;
        goto LABEL_101;
      }

      if (!*(void *)(*(void *)(*(void *)(a1 + 168) + 16LL) + 16LL))
      {
        uint64_t v16 = 1715LL;
        goto LABEL_101;
      }

      v45 = sub_1000FB804((uint64_t)&ptr, v17);
      if (!(_DWORD)v45)
      {
        if (v7 != 5)
        {
          if ((*(_BYTE *)(a1 + 80) & 0xFE) == 0x48)
          {
            uint64_t v16 = sub_1000B81AC(a1);
            if (!(_DWORD)v16) {
              goto LABEL_148;
            }
            goto LABEL_101;
          }

        __int128 v37 = 0;
        *(_BYTE *)(a2 + 15) = 1;
        v39 = 17;
        goto LABEL_34;
      }

      *(_BYTE *)(a2 + 15) = 1;
    }

    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
    goto LABEL_33;
  }

  __int128 v34 = 0LL;
  __int128 v31 = 1LL;
LABEL_40:
  v40 = qword_1008DFDB0;
  if (*(unsigned __int8 *)(qword_1008DFDB0 + 97) > (unsigned __int16)(v32 - 1))
  {
    v41 = *(void *)(qword_1008DFDB0 + 8);
    if (v41)
    {
      if (*(unsigned __int8 *)(v41 + 144LL * (unsigned __int16)(v32 - 1) + 136) != 255LL && *(void *)qword_1008DFDB0)
      {
        v42 = *(void *)qword_1008DFDB0 + 40LL * *(unsigned __int8 *)(v41 + 144LL * (unsigned __int16)(v32 - 1) + 136);
        sub_1000D88A0((void **)(v42 + 16), *(unsigned __int8 *)(v42 + 32));
        *(_BYTE *)(v42 + 32) = 0;
        v40 = qword_1008DFDB0;
      }
    }
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v40 + 24) + 48LL))(a3, v32, v34, v31);
  return v31;
}

  v41 = 1;
  do
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Stalling lmhandle 0x%4x with an exception for cid 0x%4x",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  *a1);
      v49 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        v50 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        v55 = v50;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    v51 = v53;
    id v22 = v53 > v41++;
  }

  while (v22);
  return sub_1001887B0((uint64_t)a1, (unsigned __int16 *)v56, v51, 1);
}

  CFDictionaryRemoveValue(v5, @"MagicAccIRK");
  if ((a2 & 0x20) == 0)
  {
LABEL_18:
    if ((a2 & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_35;
  }

  id v22 = (uint64_t *)v25;
  if (v25 != (char *)v26)
  {
    do
    {
      id v23 = *v22;
      *(_BYTE *)(v23 + 40) = 4;
      sub_100354C18(v3, v23);
      ++v22;
    }

    while (v22 != v26);
    id v22 = (uint64_t *)v25;
  }

  if (v22) {
    operator delete(v22);
  }
  sub_100242FAC((uint64_t)v28);
}

    id v11 = "unknown";
    goto LABEL_34;
  }

  if (v10 == 8)
  {
    id v11 = "background-running";
    goto LABEL_34;
  }

  if (v10 == 16)
  {
    id v11 = "foreground-running";
    goto LABEL_34;
  }

  if (v10 != 32) {
    goto LABEL_33;
  }
  id v11 = "daemon";
LABEL_34:
  -[NSMutableString appendFormat:](v2, "appendFormat:", @"Execution state: %s\n", v11);
  return v2;
}

  if (qword_1008D93F8 != -1) {
    dispatch_once(&qword_1008D93F8, &stru_10089ADA0);
  }
  id v21 = qword_1008D93F0;
  id v22 = v27;
  id v23 = sub_1004902D0(v20, a6, a3);
  sub_10048D660(v21, v22, (a3 | a6) == 0, v23);
  return sub_100242FAC((uint64_t)v26);
}

  id v22 = (os_log_s *)qword_1008F75D0;
  id v23 = os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_DEFAULT);
  v59 = v17;
  if (v23)
  {
    sub_1003CF00C(*v4, v60);
    uint64_t v24 = v59;
    if (v63 >= 0) {
      v25 = v60;
    }
    else {
      v25 = *(_BYTE **)v60;
    }
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = a2;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v16;
    *(_WORD *)&buf[14] = 1024;
    LODWORD(v65[0]) = (unsigned __int16)v59;
    WORD2(v65[0]) = 2082;
    *(void *)((char *)v65 + 6) = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Sending 'GetItemAttributes' response (result - %02x, nbAttributes - %u, length - %u) to device %{public}s",  buf,  0x1Eu);
    if (v63 < 0) {
      operator delete(*(void **)v60);
    }
    LOWORD(v17) = v59;
  }

  else
  {
    uint64_t v24 = v17;
  }

  v57[1] = v57;
  __chkstk_darwin(v23, (unsigned __int16)v17);
  v27 = (char *)v57 - v26;
  bzero((char *)v57 - v26, v28);
  void *v27 = 115;
  v27[2] = v24 - 3;
  v27[1] = (unsigned __int16)(v24 - 3) >> 8;
  v27[3] = a2;
  if (a2 == 4)
  {
    v27[4] = v16;
    uint64_t v30 = *(void *)(a3 + 8);
    __int128 v31 = 5;
    if (v30 != v19)
    {
      *(void *)&uint64_t v29 = 136315394LL;
      v58 = v29;
      do
      {
        __int128 v32 = *(void *)(v30 + 16);
        __int128 v33 = *(_DWORD *)(v32 + 4);
        if (v33 != 8 || *v4 == *(void *)(v3 + 528))
        {
          __int128 v34 = (os_log_s *)qword_1008F75D0;
          if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_DEFAULT))
          {
            __int128 v35 = v33 - 1;
            __int128 v36 = "Unknown";
            if (v35 <= 7) {
              __int128 v36 = off_10089F818[v35];
            }
            if (*(char *)(v32 + 31) < 0)
            {
              sub_100024238(buf, *(void **)(v32 + 8), *(void *)(v32 + 16));
            }

            else
            {
              __int128 v37 = *(_OWORD *)(v32 + 8);
              v65[0] = *(void *)(v32 + 24);
              *(_OWORD *)buf = v37;
            }

            __int128 v38 = buf;
            if (v65[0] < 0) {
              __int128 v38 = *(uint8_t **)buf;
            }
            *(_DWORD *)v60 = v58;
            *(void *)&v60[4] = v36;
            v61 = 2080;
            v62 = v38;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "Sending '%s' attribute: %s",  v60,  0x16u);
            if (SHIBYTE(v65[0]) < 0) {
              operator delete(*(void **)buf);
            }
            __int128 v32 = *(void *)(v30 + 16);
          }

          v39 = (unsigned __int16)v59 >= v31 ? (unsigned __int16)v59 - v31 : 0;
          v40 = sub_1002ED088(v32, (uint64_t)&v27[v31], v39);
          v31 += v40;
          if (!v40) {
            break;
          }
        }

        uint64_t v30 = *(void *)(v30 + 8);
      }

      while (v30 != v19);
    }
  }

  else
  {
    __int128 v31 = 4;
  }

  if (v31 > (unsigned __int16)v59)
  {
    v41 = (os_log_s *)qword_1008F75D0;
    if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_FAULT)) {
      sub_10068EB80(v41, v42, v43, v44, v45, v46, v47, v48);
    }
  }

  buf[0] = 0;
  sub_100242CA4(buf);
  if (sub_1000ECD8C(*(void *)(a1 + 40) + 128LL, *(unsigned __int8 *)(a1 + 48), v27, v31)
    && os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR))
  {
    sub_10068ECEC();
  }

  sub_100242CD8(buf);
}
}

  id v14 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionHomeDisconnectionDisabledToStageOneValue");
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v14 + 88LL))(v14, buf, __p, &v88);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v15) {
      goto LABEL_41;
    }
  }

  else if (!v15)
  {
    goto LABEL_41;
  }

  uint64_t v16 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v88;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "LeConnectionHomeDisconnectionDisabledToStageOneValue=%d (override)",  buf,  8u);
  }

  id v28 = sub_1002E9298();
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
  uint64_t v30 = v29;
  if (v29) {
    [v29 enableSystemWakesForUpdate:v21 & 1 completion:&stru_1008A23F8];
  }
  __int128 v31 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 344LL))(v31))
  {
    __int128 v32 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v32 + 952LL))(v32))
    {
      if (*(_BYTE *)(v1 + 633))
      {
        if (*(void *)(v1 + 520))
        {
          __int128 v33 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
          {
            v34[0] = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "Subrate Change Event not masked since connection subrating transactions are pending.",  (uint8_t *)v34,  2u);
          }
        }

        else
        {
          sub_1005921D4(v1, 0);
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG)) {
            sub_100697854();
          }
        }
      }
    }
  }
}

  if ((v19 - 1) >= 3u)
  {
    id v28 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)dst = 136446210;
      *(void *)&dst[4] = "(info.proximityLevel > 0) && (info.proximityLevel < kRSSIThresholdsSize)";
      _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", dst, 0xCu);
      LOBYTE(v19) = *((_BYTE *)v5 + 100);
    }
  }

  *(_BYTE *)(*(void *)(a3 + 8) + 218LL) = v19;
  return 1LL;
}

          goto LABEL_34;
        }
      }

      else
      {
      }

      [*(id *)(a1 + 32) cancelAppLaunchAlert:*(void *)(a1 + 40)];
    }

    if (*(_DWORD *)(a1 + 56) == 1) {
      id v10 = @"APP_LAUNCH_HEADER_DISCONNECTED";
    }
    else {
      id v10 = @"APP_LAUNCH_HEADER_GENERAL";
    }
    uint64_t v30 = v10;
    id v11 = sub_1002E95B8(v30, @"APP_LAUNCH_BODY");
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v11);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(-[UserNotification bundleID](v31, "bundleID"));
    id v13 = (void *)objc_claimAutoreleasedReturnValue( +[LSApplicationProxy applicationProxyForIdentifier:]( &OBJC_CLASS___LSApplicationProxy,  "applicationProxyForIdentifier:",  v12));

    v27 = v13;
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 localizedNameForContext:0]);
    uint64_t v15 = v14;
    if (!v14) {
      uint64_t v15 = *(void **)(a1 + 40);
    }
    uint64_t v16 = v15;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A4DC0);
    }
    sub_1005CC0D4((uint64_t)off_1008D5F28, *(void **)(a1 + 48), (uint64_t)buf);
    if (v38 >= 0) {
      uint64_t v17 = buf;
    }
    else {
      uint64_t v17 = *(_BYTE **)buf;
    }
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v17));
    if (v38 < 0) {
      operator delete(*(void **)buf);
    }
    __int128 v32 = 0LL;
    __int128 v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithValidatedFormat:validFormatSpecifiers:error:]( &OBJC_CLASS___NSString,  "stringWithValidatedFormat:validFormatSpecifiers:error:",  v29,  @"%@%@",  &v32,  v18,  v16));
    id v28 = v32;
    if (v19)
    {
      __int128 v20 = sub_1002E95B8(@"CLOSE", @"Close");
      v26 = (void *)objc_claimAutoreleasedReturnValue(v20);
      id v21 = sub_1002E95B8(@"VIEW", @"View");
      id v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      v35[0] = kCFUserNotificationAlertHeaderKey;
      v35[1] = kCFUserNotificationAlertMessageKey;
      v36[0] = v16;
      v36[1] = v19;
      v35[2] = kCFUserNotificationDefaultButtonTitleKey;
      v35[3] = kCFUserNotificationAlternateButtonTitleKey;
      v35[4] = kCFUserNotificationAlertTopMostKey;
      v35[5] = SBUserNotificationDontDismissOnUnlock;
      v36[4] = &__kCFBooleanTrue;
      v36[5] = &__kCFBooleanTrue;
      v35[6] = SBUserNotificationButtonTagForUnlockActionKey;
      v35[7] = SBUserNotificationSoundRepeatDurationKey;
      v36[2] = v22;
      v36[3] = v26;
      v36[6] = &off_1008C2C30;
      v36[7] = &off_1008C2C48;
      v35[8] = SBUserNotificationSystemSoundIDKey;
      v36[8] = &off_1008C2C60;
      id v23 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v36,  v35,  9LL));
      uint64_t v24 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0LL, 0LL, v23);
      if (v24)
      {
        -[UserNotification setNotification:](v31, "setNotification:", v24);
        CFRelease(v24);
        RunLoopSource = CFUserNotificationCreateRunLoopSource( kCFAllocatorDefault,  v24,  (CFUserNotificationCallBack)sub_10063D3FC,  0LL);
        if (RunLoopSource)
        {
          -[UserNotification setRunLoopSource:](v31, "setRunLoopSource:", RunLoopSource);
          CFRelease(RunLoopSource);
          [*(id *)(*(void *)(a1 + 32) + 72) addObject:v31];
        }

        else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          sub_1006A0498((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)buf);
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
      {
        sub_1006A0460((uint64_t)[*(id *)(a1 + 40) UTF8String], (uint64_t)buf);
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_1006A03FC();
    }

    goto LABEL_33;
  }

LABEL_54:
  __int128 v37 = *((_BYTE *)v65 + 24) != 0;
LABEL_59:
  ((void (*)(void *))v40[2])(v40);

  _Block_object_dispose(&v48, 8);
  _Block_object_dispose(&v52, 8);

  _Block_object_dispose(&v58, 8);
  _Block_object_dispose(&v64, 8);

  return v37;
}

    v84 = a1;
    v85 = v25;
    v86 = 5;
LABEL_59:
    sub_100097F2C(v84, v85, v86);
  }

    v105 = *(void **)(v8 + 16);
    if (v105)
    {
      sub_1000B1838(v105);
      *(void *)(v8 + 16) = 0LL;
    }

    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Packet received on invalid CID", v25, v26, v27, v28, v29, v30, v31, v106);
    __int128 v32 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
LABEL_13:
    }
      sub_100657858();
  }

  sub_1000D88A0(a5, *a6);
  *a5 = 0LL;
  *a6 = 0;
  return 106LL;
}

        uint64_t result = (char *)sub_1000B1814(4uLL);
        id v28 = result;
        uint64_t v29 = 50397344;
        if (!result) {
          return result;
        }
LABEL_55:
        *(_DWORD *)id v28 = v29;
        return (char *)sub_1000D7290(a1, 4366, v7, 2, v28, 4);
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Invalid length for search: %d (expecting more or equal to 4)",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  a4);
        uint64_t v18 = (os_log_s *)sub_100086554(4u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
LABEL_44:
        }
          sub_100657858();
      }

      if (!*((_DWORD *)v19 + 6))
      {
        v40 = *(void *)(a1 + 128);
        v41 = v40 - (8 - v17);
        if (v40 != 8 - v17) {
          memmove((void *)-v17, (const void *)(8 - v17), v40 - (8 - v17));
        }
        *(void *)(a1 + 12_Block_object_dispose(&STACK[0x338], 8) = v41 - v17;
        operator delete(v19);
        v42 = *(unsigned __int8 *)(a1 + 144);
        sub_100242F54((uint64_t)v53);
        if (v42)
        {
          if (qword_1008D67A8 != -1) {
            dispatch_once(&qword_1008D67A8, &stru_100895AC0);
          }
          sub_10052E4C0((uint64_t)off_1008D67A0, a2, a5);
        }

        sub_100242FAC((uint64_t)v45);
      }

      else
      {
        id v22 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          __int128 v37 = (void *)(a1 + 8);
          sub_1003CF00C((uint64_t)a2, &__p);
          if (v41 >= 0) {
            __int128 v38 = &__p;
          }
          else {
            __int128 v38 = __p;
          }
          *(_DWORD *)buf = 136446466;
          v47 = v37;
          v48 = 2082;
          v49 = v38;
          _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s is not available on device %{public}s",  buf,  0x16u);
          if (SHIBYTE(v41) < 0) {
            operator delete(__p);
          }
        }

        return 114LL;
      }
    }

    else
    {
      __int128 v19 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
      {
        __int128 v20 = (void *)(a1 + 8);
        sub_1003CF00C((uint64_t)a2, &__p);
        if (v41 >= 0) {
          id v21 = &__p;
        }
        else {
          id v21 = __p;
        }
        *(_DWORD *)buf = 136446466;
        v47 = v20;
        v48 = 2082;
        v49 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "%{public}s is not supported by device %{public}s",  buf,  0x16u);
        if (SHIBYTE(v41) < 0) {
          operator delete(__p);
        }
      }

      return 108LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_10067D518();
    }
    return 105LL;
  }

  return v18;
}

    __int128 v37 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      if (v7)
      {
        sub_1003CF00C(v7, __p);
        if (SHIBYTE(v125[0]) >= 0) {
          __int128 v38 = __p;
        }
        else {
          __int128 v38 = (void **)__p[0];
        }
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v8;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v38;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Received unhandled handsfree audio event from stack (%d) for device %{public}s",  buf,  0x12u);
        if (SHIBYTE(v125[0]) < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v8;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = "NULL";
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Received unhandled handsfree audio event from stack (%d) for device %{public}s",  buf,  0x12u);
      }
    }

  return v10;
}

  uint64_t result = sub_1002E6E9C();
  if (*(_DWORD *)(result + 708) >= 0x7D0u)
  {
    uint64_t result = sub_1002E6E9C();
    if (*(_DWORD *)(result + 708) <= 0xF9Fu)
    {
      v43 = sub_1002E6E9C();
      return (*(uint64_t (**)(uint64_t))(*(void *)v43 + 1224LL))(v43);
    }
  }

  return result;
}

      v44 = v137[1];
      *(_OWORD *)a3 = v137[0];
      *(_OWORD *)(a3 + 16) = v44;
      *(_OWORD *)(a3 + 2_Block_object_dispose(&STACK[0x338], 8) = *(_OWORD *)((char *)&v137[1] + 12);
      *(void *)(a3 + 4_Block_object_dispose(&STACK[0x338], 8) = 0LL;
      *(void *)(a3 + 56) = 0LL;
      *(void *)(a3 + 64) = 0LL;
      *(void *)(a3 + 72) = 0LL;
      memset(v138, 0, 24);
      *(void *)(a3 + 80) = 0LL;
      *(void *)(a3 + 8_Block_object_dispose(&STACK[0x338], 8) = 0LL;
      memset((char *)&v138[1] + 8, 0, 24);
LABEL_84:
      v25 = 1;
      goto LABEL_107;
    }

    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_1008A4058);
    }
    __int128 v20 = sub_10044C108((uint64_t)off_1008D6190, 111LL, 0);
    LOWORD(v137[2]) = 30;
    id v21 = sub_1002E6BF0();
    if (((*(uint64_t (**)(uint64_t))(*(void *)v21 + 328LL))(v21) & 1) != 0)
    {
      if ((~v20 & 6) != 0)
      {
LABEL_37:
        strcpy((char *)&v137[2] + 2, "(");
LABEL_38:
        LODWORD(v137[0]) = 16843009;
        *(void *)&v137[1] = 0LL;
        WORD4(v137[0]) = 257;
        BYTE10(v137[0]) = 1;
        DWORD2(v137[2]) = 1;
        uint64_t v24 = v137[1];
        *(_OWORD *)a3 = v137[0];
        *(_OWORD *)(a3 + 16) = v24;
        *(_OWORD *)(a3 + 2_Block_object_dispose(&STACK[0x338], 8) = *(_OWORD *)((char *)&v137[1] + 12);
        *(_OWORD *)(a3 + 4_Block_object_dispose(&STACK[0x338], 8) = v138[0];
        *(void *)(a3 + 64) = *(void *)&v138[1];
        memset(v138, 0, 24);
        *(_OWORD *)(a3 + 72) = *(_OWORD *)((char *)&v138[1] + 8);
        *(void *)(a3 + 8_Block_object_dispose(&STACK[0x338], 8) = *((void *)&v138[2] + 1);
        memset((char *)&v138[1] + 8, 0, 24);
LABEL_39:
        v25 = v139;
LABEL_107:
        *(_BYTE *)(a3 + 96) = v25;
        goto LABEL_108;
      }
    }

    else
    {
      id v22 = sub_1002E6BF0();
    }

    strcpy((char *)&v137[2] + 2, "<");
    id v23 = sub_1002E6BF0();
    goto LABEL_38;
  }

  if (!*(_BYTE *)(a1 + 144))
  {
LABEL_83:
    v56 = v140[1];
    *(_OWORD *)a3 = v140[0];
    *(_OWORD *)(a3 + 16) = v56;
    *(_OWORD *)(a3 + 2_Block_object_dispose(&STACK[0x338], 8) = *(_OWORD *)((char *)&v140[1] + 12);
    *(void *)(a3 + 4_Block_object_dispose(&STACK[0x338], 8) = 0LL;
    *(void *)(a3 + 56) = 0LL;
    *(void *)(a3 + 64) = 0LL;
    *(void *)(a3 + 72) = 0LL;
    memset(v141, 0, 24);
    *(void *)(a3 + 80) = 0LL;
    *(void *)(a3 + 8_Block_object_dispose(&STACK[0x338], 8) = 0LL;
    memset((char *)&v141[1] + 8, 0, 24);
    goto LABEL_84;
  }

  v209 = (unsigned __int128)0LL >> 112;
  v207 = 0uLL;
  *(_OWORD *)v208 = 0uLL;
  *(void *)&v208[1] = 0x101079C00010101LL;
  *(_WORD *)&v208[9] = 513;
  *(void *)&v208[12] = 0xFFFF0000FFFFLL;
  *(_DWORD *)&v208[20] = 0xFFFF;
  memset(&v208[24], 0, 54);
  *((void *)&v138[0] + 1) = sub_10060F3A8((uint64_t *)v138, (uint64_t)&v207);
  if (_os_feature_enabled_impl("CoreLocation", "StandardUT"))
  {
    LOBYTE(v139) = 0;
    v145 = xmmword_1006BDCB0;
    v146 = 0;
    sub_100634334((__n128 *)buf, (__n128 *)&v145);
    sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
    if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA"))
    {
      v143 = xmmword_1006BDCC4;
      v144 = 0;
      sub_100634334((__n128 *)buf, (__n128 *)&v143);
      sub_1005E38E0((void **)&v138[1] + 1, (__int128 *)buf);
    }
  }

void sub_100018C88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38)
{
}

void sub_100018D04(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(void *)(*(void *)(v2 + 8) + 40LL);
  if (v3 && dword_1008D5FD8 <= 90)
  {
    if (dword_1008D5FD8 == -1)
    {
      int v4 = _LogCategory_Initialize(&dword_1008D5FD8, 90LL);
      uint64_t v2 = a1[4];
      if (!v4) {
        goto LABEL_6;
      }
      uint64_t v3 = *(void *)(*(void *)(v2 + 8) + 40LL);
    }

    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _verifyNearbyInfoV2IntegrityTag:rapportIdentity:]_block_invoke",  90LL,  "IntegrityTag NearbyInfoV2 encrypted payload failed to decrypt with error: %@",  v3);
    uint64_t v2 = a1[4];
  }

LABEL_6:
  uint64_t v5 = *(void *)(*(void *)(v2 + 8) + 40LL);
  int v6 = *(unsigned __int8 *)(*(void *)(a1[5] + 8LL) + 24LL);
  if (dword_1008D5FD8 <= 20 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 20LL)))
  {
    id v7 = "ResolvedDecryptionFailed";
    uint64_t v8 = "Resolved";
    if (!v5) {
      id v7 = "Resolved";
    }
    if (!v6) {
      uint64_t v8 = "NotResolved";
    }
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _verifyNearbyInfoV2IntegrityTag:rapportIdentity:]_block_invoke",  20LL,  "IntegrityTag %@ NearbyInfoV2 ATag: %s iTag: %s",  *(void *)(*(void *)(a1[6] + 8LL) + 40LL),  v7,  v8);
  }

  id v9 = (void *)objc_claimAutoreleasedReturnValue(+[CBMetricsDaemon sharedCBMetricsDaemon](&OBJC_CLASS___CBMetricsDaemon, "sharedCBMetricsDaemon"));
  id v12 = v9;
  if (v5) {
    uint64_t v10 = 5LL;
  }
  else {
    uint64_t v10 = 1LL;
  }
  if (v6) {
    uint64_t v11 = 1LL;
  }
  else {
    uint64_t v11 = 10LL;
  }
  [v9 reportAuthTagType:2 authTagStatus:v10 integrityTagStatus:v11 resolutionWindow:*(char *)(*(void *)(a1[7] + 8) + 24)];
}

    int v4 = objc_retainBlock(self->_devicesBufferedHandler);
    uint64_t v5 = v4;
    if (v4) {
      (*((void (**)(id, NSMutableArray *))v4 + 2))(v4, self->_bufferedDevices);
    }

    int v6 = self->_bufferedDevices;
    self->_bufferedDevices = 0LL;

    return;
  }

  if (dword_1008D6530 <= 30 && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL))) {
    LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _aopBTBufferDrained]",  30LL,  "AOP BT buffer drained, but no devices buffered");
  }
}

  if (([*(id *)(*(void *)(a1 + 32) + 112) containsObject:v5] & 1) == 0)
  {
    uint64_t v24 = v8;
    id v21 = v7;
    id v22 = v5;
    uint64_t v15 = [v7 intValue];
    if (v15) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = 4294967169LL;
    }
    if (dword_1008D6530 <= 30
      && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
    {
      LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _sensorTrackingUpdate]_block_invoke_2",  30LL,  "SensorTracking start %@, RSSI %d",  v5,  v16);
    }

    uint64_t v18 = *(void *)(*(void *)(a1 + 32) + 120LL);
    __int128 v19 = sub_100404FE8();
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472LL;
    v25[2] = sub_10004E674;
    v25[3] = &unk_1008801E0;
    uint64_t v30 = v18;
    uint64_t v5 = v22;
    v26 = v22;
    __int128 v35 = *(_BYTE *)(a1 + 52);
    __int128 v20 = *(_DWORD *)(a1 + 48);
    __int128 v31 = v16;
    __int128 v32 = v20;
    __int128 v36 = v23;
    v27 = v24;
    __int128 v33 = v14;
    __int128 v34 = v13;
    id v28 = v11;
    uint64_t v29 = v12;
    sub_100405384(v19, v25);
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);

    id v7 = v21;
    uint64_t v8 = v24;
  }
}

  uint64_t v5 = pthread_mutex_destroy(&stru_1008DDF08);
  if (!v5)
  {
    sub_1001EE0E4("Done.\n");
    return;
  }

  strerror(v5);
  sub_1001EE0E4("Destroying idlerMutex failed with error: %s\n");
LABEL_11:
  sub_1000AFE20(148LL);
  sub_1000A8E24(v6);
}

  LODWORD(result) = sub_1000F15E4(a1, a2);
  if ((_DWORD)result == 8)
  {
    sub_1001EE2A0();
    LOBYTE(result) = -1;
    return result;
  }

  int v4 = qword_1008E1E50;
LABEL_9:
  id v7 = v4 + 184LL * result;
  *(_BYTE *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 4) = 0;
  return result;
}

  if (v8 == 1)
  {
    uint64_t result = sub_10018550C(v7, 38);
    if ((result & 1) == 0)
    {
      __int128 v34 = sub_100185414();
      sub_1001EE134( (uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MDHKEY to send this command, current state is %s.",  v35,  v36,  v37,  v38,  v39,  v40,  v41,  (uint64_t)v34);
      v42 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        return sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
      }
      goto LABEL_20;
    }
  }

  *(_OWORD *)(v7 + 492) = *a2;
  *(_BYTE *)(v7 + 491) = 1;
  if (*(_BYTE *)(*(void *)v7 + 70LL) != 1 || *(_BYTE *)(v7 + 16) != 6 || *(_BYTE *)(v7 + 490))
  {
    uint64_t result = sub_1001CC55C((__int128 *)a1);
    if ((_DWORD)result)
    {
      id v9 = result;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"recvdSMPDeferredDHKeyCheck Failed %! ", v10, v11, v12, v13, v14, v15, v16, v9);
        uint64_t v17 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100657F74();
        }
      }

      return sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
    }
  }

  return result;
}

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_10065FD44();
  }
  return sub_100242FAC((uint64_t)v81);
}

  id v9 = sub_100404FE8();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  v11[2] = sub_10024A8C0;
  v11[3] = &unk_100889658;
  v11[4] = a1;
  id v12 = a2;
  id v13 = a3;
  id v14 = a4;
  uint64_t v15 = v17;
  sub_100405384(v9, v11);
}

  if (a1[39] && (uint64_t v18 = (os_log_s *)qword_1008F7570, os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_FAULT)))
  {
    sub_100665698(v18, v19, v20, v21, v22, v23, v24, v25);
    if (!a4) {
      goto LABEL_14;
    }
  }

  else if (!a4)
  {
    goto LABEL_14;
  }

  if (a5)
  {
    a1[39] = a4;
    a1[40] = a5;
    sub_10025FF98((uint64_t)(a1 + 41), a4);
    return (*(uint64_t (**)(void *))(*a1 + 184LL))(a1);
  }

  LODWORD(uint64) = sub_1003C5324((unint64_t)uint64, v9, v12, v7);
  if (!(_DWORD)uint64)
  {
    uint64 = (char *)sandbox_extension_issue_file("com.apple.sandbox.pty", v12, 0LL);
    if (uint64)
    {
      strlcpy((char *)v15, uint64, 0x200uLL);
      HIBYTE(v16) = 0;
      free(uint64);
      LODWORD(uint64) = 0;
    }
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_100494958(a2, (uint64_t)__p);
    id v7 = v33 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 67109378;
    __int128 v35 = a3;
    __int128 v36 = 2082;
    __int128 v37 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "trying to unpublish psm:%d for session %{public}s",  buf,  0x12u);
    if (v33 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v8 = (void *)a1[3];
  if (v8)
  {
    id v9 = a1 + 3;
    do
    {
      uint64_t v10 = v8[4];
      uint64_t v11 = v10 >= a2;
      if (v10 >= a2) {
        id v12 = v8;
      }
      else {
        id v12 = v8 + 1;
      }
      if (v11) {
        id v9 = v8;
      }
      uint64_t v8 = (void *)*v12;
    }

    while (*v12);
    if (v9 != a1 + 3 && v9[4] <= a2)
    {
      id v13 = (void *)v9[5];
      id v14 = (char *)a1[5];
      uint64_t v15 = (char *)a1[6];
      if (v14 != v15)
      {
        uint64_t v16 = 0LL;
        while (*(void *)&v14[v16] != a2 || *(unsigned __int16 *)&v14[v16 + 8] != (_DWORD)a3)
        {
          v16 += 48LL;
          if (&v14[v16] == v15) {
            goto LABEL_28;
          }
        }

        uint64_t v24 = (os_log_s *)qword_1008F7610;
        if (os_log_type_enabled((os_log_t)qword_1008F7610, OS_LOG_TYPE_DEFAULT))
        {
          sub_100494958(a2, (uint64_t)__p);
          if (v33 >= 0) {
            v25 = __p;
          }
          else {
            v25 = (void **)__p[0];
          }
          *(_DWORD *)buf = 67109378;
          __int128 v35 = a3;
          __int128 v36 = 2082;
          __int128 v37 = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Unregistering pending L2CAP Channel 0x%04x for session %{public}s",  buf,  0x12u);
          if (v33 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v15 = (char *)a1[6];
        }

        v26 = &v14[v16 + 48];
        v27 = v15 - v26;
        if (v15 != v26) {
          memmove(&v14[v16], v26, v15 - v26);
        }
        id v21 = 0LL;
        a1[6] = &v14[v16 + v27];
        goto LABEL_50;
      }

  *(_OWORD *)a2 = *(_OWORD *)v4;
  *(void *)(a2 + 16) = *(void *)(v4 + 16);
  return sub_100242FAC((uint64_t)v7);
}

  sub_100242FAC((uint64_t)v9);
  return v2;
}

  sub_100242FAC((uint64_t)v9);
  return v2;
}
}

LABEL_20:
  p_remoteServer = &self->_remoteServer;
  remoteServer = self->_remoteServer;
  if (self->_prefRemoteServerEnabled)
  {
    uint64_t v8 = remoteServer;
    if (!v8)
    {
      if (dword_1008D5FD8 <= 30
        && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
      {
        LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _remoteEnsureStarted]", 30LL, "Remote server start");
      }

      id v9 = objc_alloc_init(&OBJC_CLASS___RPServer);
      objc_storeStrong((id *)&self->_remoteServer, v9);
      -[RPServer setDispatchQueue:](v9, "setDispatchQueue:", self->_dispatchQueue);
      -[RPServer setServiceType:](v9, "setServiceType:", @"com.apple.bluetooth.remote");
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      v11[2] = sub_100019638;
      v11[3] = &unk_10087EF38;
      uint64_t v8 = v9;
      id v12 = v8;
      id v13 = self;
      -[RPServer setErrorHandler:](v8, "setErrorHandler:", v11);
      -[RPServer activate](v8, "activate");
    }
  }

  else
  {
    if (!remoteServer) {
      goto LABEL_37;
    }
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      LogPrintF_safe(&dword_1008D5FD8, "-[CBDaemonServer _remoteEnsureStarted]", 30LL, "Remote server stop");
    }

    -[RPServer invalidate](*p_remoteServer, "invalidate");
    uint64_t v8 = *p_remoteServer;
    *p_remoteServer = 0LL;
  }

LABEL_37:
  if (!self->_coexNotificationSetup)
  {
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNotificationCenter defaultCenter](&OBJC_CLASS___NSNotificationCenter, "defaultCenter"));
    [v10 addObserver:self selector:"coexChangeNotification:" name:@"com.apple.bluetooth.leconnection" object:0];

    self->_coexNotificationSetup = 1;
  }
}

        goto LABEL_21;
      }

      __int128 v33 = NSErrorNestedF(CBErrorDomain, 4294960591LL, v49[5], "bad message type");
      __int128 v32 = objc_claimAutoreleasedReturnValue(v33);
    }

    else
    {
      __int128 v31 = NSErrorNestedF(CBErrorDomain, 4294960591LL, v49[5], "bad destination device");
      __int128 v32 = objc_claimAutoreleasedReturnValue(v31);
    }

    __int128 v34 = v49[5];
    v49[5] = (id)v32;

    goto LABEL_22;
  }

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v26, 8);
}

  id v23 = 0;
  *a7 = v27;
LABEL_9:

LABEL_10:
  return v23;
}

      LOBYTE(v11) = 0;
    }
  }

      LOBYTE(v11) = 0;
    }
  }

    sub_100088870(0x7FFFLL);
    return;
  }

  if (v1 - 2 < 2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Timed out while receiving a packet", v2, v3, v4, v5, v6, v7, v8, v28);
      id v9 = (os_log_s *)sub_100086554(0x3Au);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v10 = qword_1008DD350;
    *(_DWORD *)(qword_1008DD350 + 2044) = 4;
    *(_BYTE *)(v10 + 204_Block_object_dispose((const void *)(v38 - 152), 8) = 1;
    sub_100088870(5LL);
    return;
  }

  if (v1 == 4)
  {
    if (*(_BYTE *)(qword_1008DD350 + 2048))
    {
LABEL_14:
      sub_100088A64();
      return;
    }

    *(_DWORD *)(qword_1008DD350 + 2044) = 1;
    *(_WORD *)(v0 + 4) = 5;
    goto LABEL_20;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid receive state %d",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  *(unsigned int *)(qword_1008DD350 + 2044));
    v26 = (os_log_s *)sub_100086554(0x3Au);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  v27 = qword_1008DD350;
  *(_DWORD *)(qword_1008DD350 + 2044) = 4;
  *(_BYTE *)(v27 + 204_Block_object_dispose((const void *)(v38 - 152), 8) = 1;
  sub_100088870(5LL);
  sub_1001EE2A0();
}

  uint64_t v30 = sub_1000B17F4(size);
  if (!v30) {
    return 106LL;
  }
  __int128 v31 = (uint64_t)v30;
  memmove(v30, __s2, size);
  __int128 v32 = (unsigned __int16)v17[692];
  __int128 v33 = &qword_1008DD570[9 * v32];
  *__int128 v33 = v31;
  *((_BYTE *)v33 + _Block_object_dispose((const void *)(v38 - 152), 8) = size;
  *((_DWORD *)v33 + 3) = a3;
  __int128 v34 = 1;
  if (v32)
  {
    __int128 v35 = a8;
    __int128 v36 = a7;
    __int128 v37 = a5;
    while (1)
    {
      uint64_t v38 = 0;
      v39 = &word_1008DD582;
      v40 = v32;
      do
      {
        v41 = (unsigned __int16)*v39;
        v39 += 36;
        v38 |= v41 == v34;
        --v40;
      }

      while (v40);
      if ((v38 & 1) == 0) {
        break;
      }
      if (++v34 == 0xFFFF)
      {
        LOWORD(v34) = -1;
        break;
      }
    }
  }

  else
  {
    __int128 v35 = a8;
    __int128 v36 = a7;
    __int128 v37 = a5;
  }

  v42 = &qword_1008DD570[9 * v32];
  *((_WORD *)v42 + 9) = v34;
  *((_BYTE *)v42 + 20) = v13;
  v43 = *a9;
  v44 = a9[1];
  v42[8] = *((void *)a9 + 4);
  *((_OWORD *)v42 + 2) = v43;
  *((_OWORD *)v42 + 3) = v44;
  *((_BYTE *)v42 + 21) = 0;
  *((_BYTE *)v42 + 16) = v37;
  *((_BYTE *)v42 + 24) = a6;
  *((_BYTE *)v42 + 25) = v36;
  *((_BYTE *)v42 + 26) = v35;
  if (byte_1008DDC5D) {
    v45 = 0;
  }
  else {
    v45 = a6;
  }
  if ((_DWORD)v13 == 13 || v45)
  {
    if (v45)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Forcing ERTM enabled on a non-reliable pipe priority %d, disableReliable %d",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v13);
        v54 = (os_log_s *)sub_100086554(0x51u);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    v46 = 0;
    LODWORD(v32) = (unsigned __int16)v17[692];
  }

  else
  {
    v46 = 1;
  }

  v55 = &qword_1008DD570[9 * v32];
  *((_BYTE *)v55 + 22) = v46;
  *((_BYTE *)v55 + 23) = 0;
  v17[692] = v32 + 1;
  if (word_1008DD4E2)
  {
    v56 = 0LL;
    else {
      v57 = (unsigned __int16)size;
    }
    __na = v57;
    v79 = v13;
    do
    {
      if (sub_10008D950(**((void **)&xmmword_1008DD4E8 + v56)))
      {
        v58 = *((void *)&xmmword_1008DD4E8 + v56);
        if (!*(_BYTE *)(v58 + 74))
        {
          if (sub_10008D8B4(*(void *)v58))
          {
            if (v79 == 13)
            {
              if (sub_100089F30(**((void **)&xmmword_1008DD4E8 + v56), 1))
              {
                if (sub_1000A86F0())
                {
                  sub_1001EE134((uint64_t)"Force upgrade TS not ready C", v59, v60, v61, v62, v63, v64, v65, v74);
                  v66 = (os_log_s *)sub_100086554(0x51u);
                  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                  {
                    v67 = sub_1001EDDCC();
                    *(_DWORD *)buf = 136446210;
                    v82 = v67;
                    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                  }
                }
              }
            }

            sub_10008FEE4( **((__int128 ***)&xmmword_1008DD4E8 + v56),  *((unsigned __int16 *)&qword_1008DD570[9 * (unsigned __int16)word_1008DD568 - 6] - 3),  __s2,  (unsigned __int16)size,  a3,  (unsigned __int16)(word_1008DD568 - 1));
          }

          else
          {
            v68 = *((void *)&xmmword_1008DD4E8 + v56);
            v69 = *(_DWORD *)(v68 + 16);
            if (v69)
            {
              v70 = 0LL;
              v71 = (byte_1008DD4E0 | memcmp("com.apple.BT.TS", __s2, __na)) == 0;
              v72 = 88LL * v69;
              while (1)
              {
                if (!v71)
                {
                  v73 = *(void *)(v68 + 8) + v70;
                  if (sub_100090180((_DWORD *)v73, __s2, size, a3)) {
                    break;
                  }
                }

                v70 += 88LL;
                if (v72 == v70) {
                  goto LABEL_62;
                }
              }

              v80 = *(_DWORD *)(v73 + 40);
              *(_BYTE *)(v73 + 54) = *((_BYTE *)&qword_1008DD570[9 * (unsigned __int16)word_1008DD568 - 6] - 4);
              sub_1000901F4(*(void *)v68, 1u, (uint64_t)&v80);
            }
          }
        }
      }

  byte_1008DDC78 = v7 & 0x80;
  *a3 = v6;
  return 1LL;
}

    sub_10009A1E0(0x7FFFLL);
    return;
  }

  if (v1 - 2 < 2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Timed out while receiving a packet", v2, v3, v4, v5, v6, v7, v8, v28);
      id v9 = (os_log_s *)sub_100086554(0x3Au);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v10 = qword_1008DDCA8;
    *(_DWORD *)(qword_1008DDCA8 + 652) = 4;
    *(_BYTE *)(v10 + 656) = 1;
    sub_10009A1E0(5LL);
    return;
  }

  if (v1 == 4)
  {
    if (*(_BYTE *)(qword_1008DDCA8 + 656))
    {
LABEL_14:
      sub_10009A3D4();
      return;
    }

    *(_DWORD *)(qword_1008DDCA8 + 652) = 1;
    *(_WORD *)(v0 + 4) = 5;
    goto LABEL_20;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Invalid receive state %d",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  *(unsigned int *)(qword_1008DDCA8 + 652));
    v26 = (os_log_s *)sub_100086554(0x3Au);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  v27 = qword_1008DDCA8;
  *(_DWORD *)(qword_1008DDCA8 + 652) = 4;
  *(_BYTE *)(v27 + 656) = 1;
  sub_10009A1E0(5LL);
  sub_1001EE2A0();
}

  if (sub_1001DF894())
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"SDP Disconnect failed, clearing PSM", v29, v30, v31, v32, v33, v34, v35, v68);
      __int128 v36 = (os_log_s *)sub_100086554(0x52u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    word_1008DEBF0[v3 + 21] = 0;
  }

  uint64_t v15 = (char *)sub_1000B17F4(v13);
  if (!v15) {
    return 106LL;
  }
  if (!v13) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  876,  "(length) > 0");
  }
  uint64_t v16 = v15;
  __int128 v20 = v15;
  id v21 = v13;
  HIWORD(v21) = 2;
  WORD1(v21) = v13;
  if (a6) {
    uint64_t v17 = 3;
  }
  else {
    uint64_t v17 = 2;
  }
  *uint64_t v15 = v17 | (16 * a3);
  if (v13 == 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  883,  "ByteStream_NumReadBytesAvail(bs) >= 1");
  }
  WORD2(v21) = 2;
  v15[1] = a2;
  if (a6)
  {
    if (v13 <= 2u) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp_signal.c",  886,  "ByteStream_NumReadBytesAvail(bs) >= 1");
    }
    WORD2(v21) = 3;
    v15[2] = a6;
  }

  else
  {
    sub_1000E5784(&v20, a4, a5, a2 == 12);
    if (BYTE6(v21) != 2)
    {
      __int128 v19 = WORD1(v21);
      goto LABEL_32;
    }
  }

  __int128 v19 = WORD2(v21);
  WORD1(v21) = WORD2(v21);
LABEL_32:
  BYTE6(v21) = 15;
  return sub_1000E5170(a1, v16, v19);
}

      uint64_t v29 = &dword_1008F2A20;
      while (*((unsigned __int16 *)v29 - 20) != (_DWORD)v17)
      {
        v29 += 268;
        if (!--v2) {
          goto LABEL_34;
        }
      }

      if (*v29 == 11) {
        goto LABEL_25;
      }
LABEL_34:
      uint64_t v38 = dword_1008F29B4;
      if (dword_1008F29B4)
      {
        v39 = (unsigned int *)&dword_1008F2A20;
        while (*((unsigned __int16 *)v39 - 20) != (_DWORD)v17)
        {
          v39 += 268;
          if (!--v38) {
            goto LABEL_39;
          }
        }

        v40 = *v39;
      }

      else
      {
LABEL_39:
        v40 = 0;
      }

      v50 = sub_1000FFB28(v40);
      sub_1001EE134( (uint64_t)"Message should only be send when in IDLE/DOWNGRADE_STALL state. Current state is %s",  v51,  v52,  v53,  v54,  v55,  v56,  v57,  (uint64_t)v50);
      v58 = (os_log_s *)sub_100086554(0x56u);
      if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
        return 408LL;
      }
LABEL_50:
      sub_100657858();
      return 408LL;
    }
  }

      ++v23;
      v24 += 134;
      if (v23 == dword_1008F29B4) {
        goto LABEL_21;
      }
    }

    id v28 = LOWORD(qword_1008F29F0[134 * v23 + 1]);
  }

  else
  {
LABEL_21:
    id v28 = 0LL;
  }

    uint64_t result = 0LL;
    *a3 = v18;
    *a4 = v4;
  }

  return result;
}

                WORD2(v55) = v21 + 1;
                *(_BYTE *)(v54 + v21) = v22;
                if (HIBYTE(v55))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                }

                else if (WORD1(v55) - WORD2(v55) > 5)
                {
                  if (BYTE6(v55) == 2)
                  {
                    uint64_t v24 = v54 + WORD2(v55);
                    *(_WORD *)(v24 + 4) = 0;
                    *(_DWORD *)uint64_t v24 = 0;
                    v25 = WORD2(v55) + 6;
                    WORD2(v55) += 6;
                    v26 = v54;
                    if (HIBYTE(v55))
                    {
                      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                      v27 = 0;
                    }

                    else
                    {
                      v27 = WORD1(v55) - v25;
                    }

                    if (v27 < a2)
                    {
                      v45 = "ByteStream_NumReadBytesAvail(bs) >= (dataLen)";
                    }

                    else
                    {
                      if (BYTE6(v55) == 2)
                      {
                        memmove((void *)(v26 + v25), a1, a2);
                        id v28 = WORD2(v55) + a2;
                        WORD2(v55) += a2;
                        uint64_t v29 = v54;
                        if (HIBYTE(v55))
                        {
                          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                          uint64_t v30 = 0;
                        }

                        else
                        {
                          uint64_t v30 = WORD1(v55) - v28;
                        }

                        __int128 v31 = 22 - a2;
                        if (v30 < v31)
                        {
                          v46 = "ByteStream_NumReadBytesAvail(bs) >= (22 - dataLen)";
                        }

                        else
                        {
                          if (BYTE6(v55) == 2)
                          {
                            bzero((void *)(v29 + v28), v31);
                            __int128 v32 = WORD2(v55) + v31;
                            WORD2(v55) = v32;
                            __int128 v33 = v54;
                            if (HIBYTE(v55))
                            {
                              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                              __int128 v34 = 0;
                            }

                            else
                            {
                              __int128 v34 = WORD1(v55) - v32;
                            }

                            if (v34 < a4)
                            {
                              v47 = "ByteStream_NumReadBytesAvail(bs) >= (maskLen)";
                            }

                            else
                            {
                              if (BYTE6(v55) == 2)
                              {
                                memmove((void *)(v33 + v32), a3, a4);
                                __int128 v35 = WORD2(v55) + a4;
                                WORD2(v55) += a4;
                                __int128 v36 = v54;
                                if (HIBYTE(v55))
                                {
                                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stac"
                                                         "k/vsc/bcm/bcm_vsc.c");
                                  __int128 v37 = 0;
                                }

                                else
                                {
                                  __int128 v37 = WORD1(v55) - v35;
                                }

                                uint64_t v38 = 22 - a4;
                                if (v37 < v38)
                                {
                                  v48 = "ByteStream_NumReadBytesAvail(bs) >= (22 - maskLen)";
                                }

                                else
                                {
                                  if (BYTE6(v55) == 2)
                                  {
                                    bzero((void *)(v36 + v35), v38);
                                    v42 = WORD2(v55) + v38;
                                    WORD2(v55) += v38;
                                    if (HIBYTE(v55))
                                    {
                                      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/"
                                                             "Stack/vsc/bcm/bcm_vsc.c");
                                    }

                                    else if (WORD1(v55) > v42)
                                    {
                                      if (BYTE6(v55) == 2)
                                      {
                                        WORD2(v55) = v42 + 1;
                                        *(_BYTE *)(v54 + v42) = a5;
                                        if (HIBYTE(v55))
                                        {
                                          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_b"
                                                                 "ase/Stack/vsc/bcm/bcm_vsc.c");
                                        }

                                        else
                                        {
                                          v43 = WORD2(v55);
                                          if (WORD1(v55) > WORD2(v55))
                                          {
                                            if (BYTE6(v55) == 2)
                                            {
                                              ++WORD2(v55);
                                              *(_BYTE *)(v54 + v43) = a6;
                                              return sub_10018BD78( 233,  v54,  BYTE4(v55),  a10,  (uint64_t)sub_10013A594,  v39,  v40,  v41);
                                            }

                                            v50 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_74:
                                            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3425,  v50);
                                          }
                                        }

                                        v50 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                                        goto LABEL_74;
                                      }

                                      v49 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_70:
                                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3424,  v49);
                                    }

                                    v49 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                                    goto LABEL_70;
                                  }

                                  v48 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                                }

                                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3423,  v48);
                              }

                              v47 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                            }

                            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3422,  v47);
                          }

                          v46 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                        }

                        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3421,  v46);
                      }

                      v45 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                    }

                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3420,  v45);
                  }

                  v44 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_54:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3419,  v44);
                }

                v44 = "ByteStream_NumReadBytesAvail(bs) >= (6)";
                goto LABEL_54;
              }
            }

            id v23 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_85:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3414,  v23);
          }

          if (HIBYTE(v55))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
          }

          else
          {
            id v21 = WORD2(v55);
            if (WORD1(v55) > WORD2(v55))
            {
              if (BYTE6(v55) == 2)
              {
                id v22 = 3;
                goto LABEL_20;
              }

              v53 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_89:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3416,  v53);
            }
          }

          v53 = "ByteStream_NumReadBytesAvail(bs) >= 1";
          goto LABEL_89;
        }

        v52 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_82:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 3410, v52);
      }
    }

    v52 = "ByteStream_NumReadBytesAvail(bs) >= 1";
    goto LABEL_82;
  }

  return result;
}

    __int128 v35 = (_BYTE *)a1;
    __int128 v36 = a3;
    __int128 v37 = 4LL;
LABEL_21:
    sub_1001772F0(v35, v36, v37, a4, v21, v22, v23, v24);
    return;
  }

  if (sub_100172ECC(2u, (uint64_t *)&v68, 0))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to allocate channel, rejecting connection", v31, v32, v33, v21, v22, v23, v24, v67);
      __int128 v34 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_20;
  }

  uint64_t v38 = v68;
  *((_WORD *)v68 + 3) = v15;
  v39 = sub_10017AB4C(v38);
  v40 = *(_WORD *)(a1 + 52);
  *(_DWORD *)(v39 + 10) = *(_DWORD *)(a1 + 48);
  *(_WORD *)(v39 + 14) = v40;
  *(_BYTE *)(sub_10017AB4C(v68) + 24) = 1;
  *(void *)sub_10017AB4C(v6_Block_object_dispose((const void *)(v38 - 152), 8) = a1;
  *(_WORD *)(sub_10017AB4C(v68) + _Block_object_dispose((const void *)(v38 - 152), 8) = a3;
  *(_BYTE *)(sub_10017AB4C(v68) + 29) = a4;
  *(_BYTE *)(sub_10017AB4C(v68) + 16) = 2;
  if (sub_1000A86F0())
  {
    v41 = *((unsigned __int16 *)v68 + 2);
    sub_10017AB4C(v68);
    sub_1001EE134((uint64_t)"RecvConnectReq cid=%d psm=%d addr=%:", v42, v43, v44, v45, v46, v47, v48, v41);
    v49 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      v50 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      v70 = v50;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  v51 = sub_10017AB4C(v68);
  v52 = sub_10017ABF8(v51 + 10, *((unsigned __int16 *)v68 + 2), *((unsigned __int16 *)v68 + 3));
  v53 = v68;
  if (v52)
  {
    sub_1001734D8((uint64_t)v68);
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Connection refused - invalid PSM", v54, v55, v56, v21, v22, v23, v24, v67);
      v57 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    __int128 v35 = (_BYTE *)a1;
    __int128 v36 = a3;
    __int128 v37 = 2LL;
    goto LABEL_21;
  }

  if (*v68)
  {
    if (!*(_BYTE *)(a1 + 228))
    {
      *(_BYTE *)(a1 + 22_Block_object_dispose((const void *)(v38 - 152), 8) = 1;
      v58 = sub_10017AB4C(v53);
      if (sub_100198780((uint64_t)sub_100176BBC, 0LL, v58 + 10, 2))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Could not ask device for extended features.", v59, v60, v61, v62, v63, v64, v65, v67);
          v66 = (os_log_s *)sub_100086554(0x2Fu);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }
    }
  }

    sub_100182058(v0, 0);
    return 0LL;
  }

  if (((v1 >> 4) & 1) != 0)
  {
    uint64_t v2 = (v1 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL) <= v2
      && v2 <= *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 4LL))
    {
      goto LABEL_8;
    }

    uint64_t v3 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL);
    int v4 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL);
    if (v3 <= v2)
    {
    }

    else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 176LL) {
                                           + 32LL)
    }
              + (_BYTE)v4) & 0x3Fu) >= v2)
    {
LABEL_8:
      sub_100181EEC(v0, (v1 >> 8) & 0x3F, 0);
      sub_100182380((unsigned int *)v0);
      uint64_t v5 = 0LL;
      *(_BYTE *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 15LL) = 0;
      return v5;
    }

    if (sub_1000A86F0())
    {
      if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL) <= v2
        && v2 <= *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 4LL))
      {
        v45 = 1;
      }

      else
      {
        v43 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL);
        v44 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL);
        v45 = v43 <= v2
            ? v2 - v44 <= *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 176LL) + 32LL)
            : ((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 176LL)
                                           + 32LL)
              + (_BYTE)v44) & 0x3Fu) >= v2;
      }

      sub_1001EE134( (uint64_t)"S-Frame Receiver Ready Error: ValidReqSeq %d, ValidF-bit %d",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v45);
      v65 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
LABEL_62:
      }
        sub_100657F74();
    }
  }

    if (sub_1001EC434(qword_1008E2C40))
    {
      id v7 = qword_1008E2C40;
      v49 = sub_1001EC30C(qword_1008E2C40);
      if (!v7) {
        goto LABEL_90;
      }
      goto LABEL_26;
    }

    if (!v49) {
      break;
    }
    id v7 = qword_1008E2C38;
    if (!qword_1008E2C38) {
      goto LABEL_90;
    }
LABEL_26:
    sub_100134ECC(*(void *)(v49 + 8));
    uint64_t v8 = v49;
    id v9 = *(_DWORD *)(v49 + 4);
    if (v9 != 1)
    {
      if (v9)
      {
        sub_1001EE2A0();
        id v9 = 1;
      }

      else
      {
        *(_DWORD *)(v49 + 4) = 1;
        if (*(_BYTE *)(v8 + 1) && (byte_1008F6D2A & 0x40) != 0)
        {
          id v9 = 0;
        }

        else if (*(_WORD *)(v8 + 36) == 43)
        {
          id v9 = 3;
        }

        else
        {
          id v9 = 2;
        }
      }
    }

    uint64_t v10 = sub_100134F24(*(unsigned __int16 **)(v8 + 8), v9, *(_DWORD *)(v8 + 16), *(void *)(v8 + 24));
    uint64_t v11 = v10;
    if ((_DWORD)v10 == 613)
    {
    }

    else if (!(_DWORD)v10)
    {
      if (*(_WORD *)(*(void *)(v8 + 24) + 4LL)) {
        *(_DWORD *)(v8 + 4) = 1;
      }
      else {
        *(_DWORD *)(v8 + 4) = 2;
      }
      goto LABEL_50;
    }

    if (sub_1000A86F0()
      && (sub_1001EE134((uint64_t)"OI_HCIAPI_WriteAclData failed with %!", v12, v13, v14, v15, v16, v17, v18, v11),
          __int128 v19 = (os_log_s *)sub_100086554(0x2Fu),
          os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)))
    {
      sub_10065BAC0();
      if (!(_DWORD)v11) {
        goto LABEL_50;
      }
    }

    else if (!(_DWORD)v11)
    {
      goto LABEL_50;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Send packet fail with status %!", v20, v21, v22, v23, v24, v25, v26, v11);
      v27 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_10065BAC0();
      }
    }

    if ((_DWORD)v11 == 118 || (_DWORD)v11 == 613) {
      goto LABEL_94;
    }
    *(_DWORD *)(v49 + 4) = 2;
LABEL_50:
    id v28 = v49;
    if (*(_DWORD *)(v49 + 4) == 2)
    {
      *(void *)buf = 0LL;
      uint64_t v29 = sub_100171EC4(*(unsigned __int16 *)(v49 + 36), (uint64_t *)buf);
      uint64_t v30 = v49;
      if (!v29 && *(_BYTE *)v49 != 1) {
        *(_DWORD *)(*(void *)buf + 80LL) += *(unsigned __int16 *)(v49 + 34);
      }
      if (*(void *)(v30 + 56))
      {
        __int128 v31 = sub_100135FB0(*(void *)(v30 + 8));
        uint64_t v30 = v49;
        __int128 v32 = *(void *)(v49 + 8);
        *(_WORD *)(v32 + 1_Block_object_dispose((const void *)(v38 - 152), 8) = v31;
        *(void *)(v32 + _Block_object_dispose((const void *)(v38 - 152), 8) = *(void *)(v30 + 56);
      }

      if (v30 != sub_100189C94(v7))
      {
        sub_10018739C();
        sub_1001EE2A0();
      }

      if (v7 == qword_1008E2C38)
      {
        if (qword_1008E2C28)
        {
          id v7 = qword_1008E2C28;
          while (*(unsigned __int16 *)(v7 + 24) != *(unsigned __int16 *)(v49 + 36))
          {
            id v7 = *(void *)(v7 + 80);
            if (v7 == qword_1008E2C28 || v7 == 0) {
              goto LABEL_67;
            }
          }
        }

        else
        {
LABEL_67:
          sub_1001EE2A0();
          id v7 = 0LL;
        }
      }

      if (v7 == qword_1008E2C40)
      {
        if (qword_1008E2C28)
        {
          id v7 = qword_1008E2C28;
          while (*(unsigned __int16 *)(v7 + 24) != *(unsigned __int16 *)(v49 + 36))
          {
            id v7 = *(void *)(v7 + 80);
            if (v7 == qword_1008E2C28 || v7 == 0) {
              goto LABEL_77;
            }
          }
        }

        else
        {
LABEL_77:
          sub_1001EE2A0();
          id v7 = 0LL;
        }
      }

      if (*(void *)(v7 + 40)) {
        sub_1001EEB14(*(unsigned int *)(v7 + 32));
      }
      (*(void (**)(uint64_t, uint64_t))(v7 + 72))(v7, v49);
    }

    else if (qword_1008E2C38 != v7)
    {
      if (sub_100189C94(v7) != v28)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Wrong packet dequeued !!!", v35, v36, v37, v38, v39, v40, v41, v46);
          v42 = (os_log_s *)sub_100086554(0x2Fu);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            v43 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446466;
            *(void *)&buf[4] = v43;
            v51 = 1024;
            v52 = 0xFFFF;
            _os_log_error_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
          }
        }
      }

      sub_1001EC1DC(qword_1008E2C38, v28, 8LL);
    }
  }

  v49 = 0LL;
LABEL_90:
  v44 = qword_1008E2C28;
  if (sub_1001EC434(qword_1008E2C38) || sub_1001EC434(qword_1008E2C40))
  {
LABEL_92:
    v45 = 1;
  }

  else
  {
    do
    {
      if (!v44) {
        break;
      }
      if (*(_BYTE *)(v44 + 16) && sub_1001EC434(*(void *)(v44 + 8))
        || sub_1001EC434(*(void *)v44))
      {
        goto LABEL_92;
      }

      v44 = *(void *)(v44 + 80);
    }

    while (v44 != qword_1008E2C28);
    v45 = 0;
  }

  dword_1008E2C4C = v45;
LABEL_94:
  sub_1001EC070(ptr);
}

  if (v6 | v7 && !v8 && !v9) {
    return 5LL;
  }
  if ((v9 & 1) != 0)
  {
    if (v7 && !v19) {
      return 5LL;
    }
  }

  else if (v6 | v7)
  {
    return 15LL;
  }

  return 0LL;
}

  id v12 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read Central ID", v13, v14, v15, v16, v17, v18, v19, v22);
    __int128 v20 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v12;
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Error response to service search request: %!", v18, v19, v20, v21, v22, v23, v24, v10);
    v25 = (os_log_s *)sub_100086554(0x35u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  if (*(void *)a3) {
    sub_1000B1838(*(void **)a3);
  }
  sub_10010C410((unsigned __int8 *)&v35);
  sub_10010C410((unsigned __int8 *)v37);
  return sub_1001E4330(v10, a1, a3);
}

      sub_1001E7B60(0, a1, v16, v17, v18, v19, v20, v21);
      return;
    }

    id v23 = dword_1008EDD40;
    uint64_t v24 = sub_10010EEE0(a1, &v35);
    if (!(_DWORD)v24)
    {
      if (!sub_1001E631C(v35))
      {
        (*(void (**)(uint64_t, uint64_t, BOOL, void))(qword_1008EDD28 + 56))( a1,  a2,  v23 != 0,  BYTE2(dword_1008EDD40));
        return;
      }

      goto LABEL_20;
    }

    v25 = v24;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"No longer connected %!", v26, v27, v28, v29, v30, v31, v32, v25);
      __int128 v33 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }
  }
}

  uint64_t v11 = 0LL;
LABEL_21:
  id v12 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = "No";
    if ((_DWORD)v11) {
      id v13 = "Yes";
    }
    uint64_t v15 = 136315138;
    uint64_t v16 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Call Management: shouldSendDefault %s",  (uint8_t *)&v15,  0xCu);
  }

  return v11;
}

  uint64_t v16 = sub_1002E95B8(v6, v8);
  uint64_t v17 = objc_claimAutoreleasedReturnValue(v16);
  sub_10002418C(a3, (char *)[v17 UTF8String]);

  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
}

    uint64_t v3 = 1;
    goto LABEL_21;
  }

  if (a2 <= 761)
  {
    if (a2 == 722) {
      goto LABEL_21;
    }
    if (a2 == 761)
    {
      uint64_t v3 = 2503;
      goto LABEL_21;
    }

    goto LABEL_20;
  }

  if (a2 == 762)
  {
    uint64_t v3 = 2504;
    goto LABEL_21;
  }

  if (a2 == 5101)
  {
    uint64_t v3 = 2505;
    goto LABEL_21;
  }

  if (a2 != 5102) {
    goto LABEL_20;
  }
  uint64_t v3 = 2506;
LABEL_21:
  int v4 = sub_100404FE8();
  uint64_t v5 = operator new(0x10uLL);
  v5[4] = 1;
  *(void *)uint64_t v5 = &off_100889768;
  void v5[5] = a1;
  *((_DWORD *)v5 + 3) = v3;
  return sub_100405744(v4, v5);
}

      uint64_t v18 = (void *)v9[1];
      if (v18)
      {
        do
        {
          __int128 v19 = v18;
          uint64_t v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          __int128 v19 = (void *)v9[2];
          __int128 v20 = *v19 == (void)v9;
          id v9 = v19;
        }

        while (!v20);
      }

      id v9 = v19;
      if (v19 == (void *)(a1 + 232)) {
        goto LABEL_26;
      }
    }
  }

  int v4 = (os_log_s *)qword_1008F7680;
  if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v26 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Already attempting to resurrect %{public}@",  buf,  0xCu);
  }

  if (v26 >= a4) {
    __int128 v37 = a4;
  }
  else {
    __int128 v37 = v26;
  }
  *(void *)(a1 + 24_Block_object_dispose((const void *)(v38 - 152), 8) = v37;
  uint64_t v38 = sub_1002E6E00();
  sub_10002418C(buf, "HFP");
  sub_10002418C(__p, "Jitter");
  (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(void *)v38 + 88LL))(v38, buf, __p, a1 + 328);
  if (v47 < 0) {
    operator delete(__p[0]);
  }
  if (SBYTE3(v52) < 0) {
    operator delete(*(void **)buf);
  }
  v39 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    v40 = *(_DWORD *)(a1 + 240);
    v41 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
    v42 = *(void *)(a1 + 248);
    v43 = *(_DWORD *)(a1 + 328);
    sub_1002E6E9C();
    v44 = sub_1002CE214();
    *(_DWORD *)buf = 67110400;
    *(_DWORD *)&buf[4] = v40;
    v49 = 2048;
    v50 = v41;
    v51 = 2048;
    v52 = v42;
    v53 = 1024;
    v54 = v43;
    v55 = 1024;
    v56 = v44;
    v57 = 1024;
    v58 = a8;
    _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "SendThread with codec type %d, interval %llu, buffer size %zu, jitter %d, spec-ErroneousData %d, lowlatency %d",  buf,  0x2Eu);
  }

  *(_DWORD *)(a1 + 244) = a6;
  *(void *)(a1 + 200) = sub_1002073BC((uint64_t)(v17 + 50));
  *(_BYTE *)(a1 + 332) = sub_10020756C((uint64_t)(v17 + 50));
  *(_BYTE *)(a1 + 333) = sub_10020752C((uint64_t)(v17 + 50));
  return a1;
}

  if (SHIBYTE(v11) < 0) {
    operator delete(__s);
  }
}

    LODWORD(v1) = 32;
    goto LABEL_28;
  }

  if (v4 > 160)
  {
    goto LABEL_28;
  }

  if (v4 == 62)
  {
    LODWORD(v1) = 44;
    goto LABEL_28;
  }

  if (v4 == 88) {
LABEL_24:
  }
    LODWORD(v1) = 36;
LABEL_28:
  uint64_t v5 = sub_1002E6BF0();
  else {
    uint64_t v1 = v1;
  }
LABEL_31:
  int v6 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = v1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "ePA low Tx power is : %d", (uint8_t *)v8, 8u);
  }

  return v1;
}

  if (__p)
  {
    uint64_t v17 = __p;
    operator delete(__p);
  }
  }
}

    sub_100242F54((uint64_t)v23);
    strlcpy("iOS", (const char *)a2, 0x82uLL);
    id v22 = 0;
    sub_100242CA4(&v22);
    byte_1008F747D = 1;
    uint64_t v17 = sub_10011E9D8((uint64_t)sub_1004311B4, (uint64_t)"iOS", v11, v12, v13, v14, v15, v16);
    sub_100242CD0(&v22);
    if (v17)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10067EE40();
      }
    }

    else if (!sub_100431224(a1))
    {
      uint64_t v18 = sub_100404EB8();
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472LL;
      v21[2] = sub_1004364E0;
      v21[3] = &unk_10087EB20;
      v21[4] = a1;
      sub_100405384(v18, v21);
      sub_100242ECC((uint64_t)v23);
      std::string::assign((std::string *)(a1 + 296), "iOS");
      __int128 v19 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v26 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Local device name changed to %{public}s",  buf,  0xCu);
      }

      sub_100242F54((uint64_t)v23);
    }

    sub_100242CD8(&v22);
    goto LABEL_32;
  }

  *(_BYTE *)(a1 + 209) = 1;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067E824();
  }
  return sub_100242FAC((uint64_t)v24);
}

      sub_100242FAC((uint64_t)v55);
      return;
    }

    if (sub_1002075B4((uint64_t)(v11 + 50)) != 128
      && sub_1002075B4((uint64_t)(v11 + 50)) != 129
      && sub_1002075B4((uint64_t)(v11 + 50)) != 255
      && sub_1002075B4((uint64_t)(v11 + 50)) != 130)
    {
      v47 = (char *)sub_10056AAF0(a4);
      v48 = sub_10056AAD8(a4);
      sub_10026FBFC((uint64_t)v11, v47, v48, *(unsigned __int8 *)(a5 + 8));
      goto LABEL_20;
    }

    if ((unint64_t)sub_10056AAD8(a4) <= 1)
    {
      if (!os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      goto LABEL_10;
    }

    id v22 = sub_10056AAD8(a4);
    sub_100501F04((uint64_t)v11, v22);
    v53 = (unsigned __int8 *)sub_10056AAF0(a4);
    id v23 = sub_1002073AC((uint64_t)(v11 + 50));
    if (a3)
    {
      if (sub_1002073AC((uint64_t)(v11 + 50)))
      {
        uint64_t v24 = sub_1002073AC((uint64_t)(v11 + 50));
        if (sub_1003D2B2C(v24, 44))
        {
          v25 = (os_log_s *)qword_1008F7598;
          if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "Generate two PLC for mono UL in stereo config",  buf,  2u);
          }

          v53[1] = 0;
          sub_100501F88((uint64_t)v11);
          if ((unint64_t)sub_10056AAD8(a4) < 0x3C)
          {
            v49 = (os_log_s *)qword_1008F7598;
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
            {
              v50 = sub_10056AAD8(a4);
              sub_100680E08((uint64_t)buf, v50, v49);
            }
          }

          else
          {
            v26 = (char *)sub_10056AAF0(a4);
            sub_10026FF08((uint64_t)v11, v26, 0x3CuLL, *(unsigned __int8 *)(a5 + 8));
            v27 = (char *)sub_10056AAF0(a4);
            sub_10026FF08((uint64_t)v11, v27, 0x3CuLL, *(unsigned __int8 *)(a5 + 8));
          }
        }
      }

      goto LABEL_20;
    }

    id v28 = v23;
    uint64_t v29 = *v53;
    if (v23
      && sub_1003D2B2C(v23, 41)
      && (uint64_t v30 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v30 + 792LL))(v30, 11LL)))
    {
      v54 = 0;
      __int128 v31 = (unsigned __int8 *)sub_10056AAF0(a4);
      __int128 v32 = sub_10056AAD8(a4);
      if (!sub_10045D058(v32, v31, v32, (_WORD *)&v56 + 1, &v56, (_WORD *)&v54 + 1, &v54)) {
        goto LABEL_20;
      }
      __int128 v33 = v54;
      if ((_WORD)v54)
      {
        __int128 v34 = sub_10056AAF0(a4);
        *(void *)buf = _NSConcreteStackBlock;
        v58 = 3221225472LL;
        *(void *)&v59 = sub_100474D44;
        *((void *)&v59 + 1) = &unk_100899D30;
        *(void *)&v60 = v28;
        *((void *)&v60 + 1) = v34 + HIWORD(v54);
        v61 = v33;
        sub_100474C68(a1 + 82, buf);
      }

      __int128 v35 = sub_10056AAF0(a4);
      v52 = HIWORD(v56);
      v53 = (unsigned __int8 *)(v35 + HIWORD(v56));
      __int128 v36 = v56;
      if ((_WORD)v56)
      {
LABEL_46:
        __int128 v37 = 0;
        uint64_t v38 = v36;
        while (v38 > v37)
        {
          v39 = sub_10056AAD8(a4);
          v40 = v39;
          if (v39 < v37)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
              sub_100680C90(v40);
            }
            goto LABEL_20;
          }

          v41 = v39 - v37;
          if (v41 <= 1)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
              sub_100680D00();
            }
            goto LABEL_20;
          }

          v42 = v53[v37];
          v43 = v53[v37 + 1];
          if (v37 && v29 + 1 != v42) {
            goto LABEL_20;
          }
          v44 = v43 + 2;
          if (v41 < v43 + 2)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
              sub_100680D6C(v41);
            }
            goto LABEL_20;
          }

          v45 = sub_10056AAF0(a4);
          sub_10026FF08((uint64_t)v11, (char *)(v45 + v52 + v37), v44, *(unsigned __int8 *)(a5 + 8));
          v46 = v44 + v37;
          __int128 v37 = (unsigned __int16)(v44 + v37);
          uint64_t v29 = v42;
          if (v46 >= 0x10000)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEBUG)) {
              sub_100680DDC();
            }
            goto LABEL_20;
          }
        }

        goto LABEL_20;
      }
    }

    else
    {
      v52 = 0LL;
    }

    __int128 v36 = sub_1002075D4((uint64_t)(v11 + 50));
    goto LABEL_46;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100680BF4();
  }
}

    uint64_t v10 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      if (v4)
      {
        sub_1003CF00C(v4, __p);
        if (v22 >= 0) {
          uint64_t v11 = __p;
        }
        else {
          uint64_t v11 = (void **)__p[0];
        }
        *(_DWORD *)buf = 67109378;
        LODWORD(v24[0]) = v5;
        WORD2(v24[0]) = 2082;
        *(void *)((char *)v24 + 6) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received unhandled handsfree call control event from stack (%d) for device %{public}s",  buf,  0x12u);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)buf = 67109378;
        LODWORD(v24[0]) = v5;
        WORD2(v24[0]) = 2082;
        *(void *)((char *)v24 + 6) = "NULL";
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received unhandled handsfree call control event from stack (%d) for device %{public}s",  buf,  0x12u);
      }
    }

    return 4LL;
  }

  if (v5 == 8)
  {
    id v12 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      if (v4)
      {
        sub_1003CF00C(v4, __p);
        if (v22 >= 0) {
          id v13 = __p;
        }
        else {
          id v13 = (void **)__p[0];
        }
        *(_DWORD *)buf = 136446210;
        v24[0] = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received call answer event from device %{public}s",  buf,  0xCu);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        *(_DWORD *)buf = 136446210;
        v24[0] = "NULL";
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Received call answer event from device %{public}s",  buf,  0xCu);
      }
    }

    return sub_10046AA48(a1, *(unsigned __int16 *)(a2 + 4));
  }

  if (v5 != 9) {
    goto LABEL_20;
  }
  int v6 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    if (v4)
    {
      sub_1003CF00C(v4, __p);
      if (v22 >= 0) {
        id v7 = __p;
      }
      else {
        id v7 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136446210;
      v24[0] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received call hangup event (AT+CHUP) from device %{public}s",  buf,  0xCu);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      *(_DWORD *)buf = 136446210;
      v24[0] = "NULL";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Received call hangup event (AT+CHUP) from device %{public}s",  buf,  0xCu);
    }
  }

  if ((sub_100206670(a1 + 360) & 1) != 0)
  {
    uint64_t v16 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Ignoring call hangup event as we are transitioning from Virtual Call",  (uint8_t *)__p,  2u);
    }

    return 255LL;
  }

  uint64_t result = sub_10046AE6C(a1, *(unsigned __int16 *)(a2 + 4));
  if ((_DWORD)result == 255)
  {
    uint64_t v18 = sub_10045CF60(a1, *(unsigned __int16 *)(a2 + 4));
    if (sub_1002070AC((uint64_t)(v18 + 50)))
    {
      __int128 v19 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        if (v4)
        {
          sub_1003CF00C(v4, __p);
          if (v22 >= 0) {
            __int128 v20 = __p;
          }
          else {
            __int128 v20 = (void **)__p[0];
          }
          *(_DWORD *)buf = 136446210;
          v24[0] = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Disconnecting sco early w/o notifying audio layer as device %{public}s is a noisy carkit",  buf,  0xCu);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
        }

        else
        {
          *(_DWORD *)buf = 136446210;
          v24[0] = "NULL";
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Disconnecting sco early w/o notifying audio layer as device %{public}s is a noisy carkit",  buf,  0xCu);
        }
      }

      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      sub_1000F604C(*(unsigned __int16 *)(a2 + 4));
      sub_100242CD0(__p);
      sub_100242CD8(__p);
    }

    return 255LL;
  }

  return result;
}

  if ((v6 & 0x80u) == 0) {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 1087);
  }
  else {
    uint64_t v11 = *(void *)(a1 + 1072);
  }
  memset(&__p, 0, sizeof(__p));
  p_p = &__p;
  sub_100271C18((uint64_t)&__p, v11 + 1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (v11)
  {
    else {
      id v13 = *(const void **)(a1 + 1064);
    }
    memmove(p_p, v13, v11);
  }

  *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v11) = 32;
  id v14 = *(char *)(a2 + 23);
  if (v14 >= 0) {
    uint64_t v15 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v15 = *(const std::string::value_type **)a2;
  }
  if (v14 >= 0) {
    uint64_t v16 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v16 = *(void *)(a2 + 8);
  }
  uint64_t v17 = std::string::append(&__p, v15, v16);
  uint64_t v18 = v17->__r_.__value_.__r.__words[0];
  *(void *)&uint64_t v29 = v17->__r_.__value_.__l.__size_;
  *(void *)((char *)&v29 + 7) = *(std::string::size_type *)((char *)&v17->__r_.__value_.__r.__words[1] + 7);
  size = v17->__r_.__value_.__s.__size_;
  v17->__r_.__value_.__l.__size_ = 0LL;
  v17->__r_.__value_.__l.__cap_ = 0LL;
  v17->__r_.__value_.__r.__words[0] = 0LL;
  *(void *)a2 = v18;
  *(void *)(a2 + _Block_object_dispose((const void *)(v38 - 152), 8) = v29;
  *(void *)(a2 + 15) = *(void *)((char *)&v29 + 7);
  *(_BYTE *)(a2 + 23) = size;
LABEL_40:
  if (!*(_BYTE *)(*(void *)(a1 + 216) + 5LL)) {
    return;
  }
  memset(&__p, 0, sizeof(__p));
  sub_10002418C(&__p, "Game");
  __int128 v20 = *(char *)(a1 + 1087);
  if (v20 < 0)
  {
    if (*(void *)(a1 + 1072) != 3LL) {
      goto LABEL_50;
    }
    id v21 = *v5;
  }

  else
  {
    id v21 = (unsigned __int16 *)(a1 + 1064);
    if (v20 != 3) {
      goto LABEL_50;
    }
  }

  id v22 = *v21;
  id v23 = *((unsigned __int8 *)v21 + 2);
  if (v22 != 26191 || v23 != 102)
  {
LABEL_50:
    std::operator+<char>(&v29, " + ", a1 + 1064);
    if ((v30 & 0x80u) == 0) {
      v25 = (const std::string::value_type *)&v29;
    }
    else {
      v25 = (const std::string::value_type *)v29;
    }
    if ((v30 & 0x80u) == 0) {
      v26 = v30;
    }
    else {
      v26 = *((void *)&v29 + 1);
    }
    std::string::append(&__p, v25, v26);
  }

  v27 = *(_BYTE **)(a1 + 216);
  if (v27[7])
  {
    std::string::append(&__p, " + Audio");
    v27 = *(_BYTE **)(a1 + 216);
  }

  if (v27[8])
  {
    std::string::append(&__p, " + Video");
    v27 = *(_BYTE **)(a1 + 216);
  }

  if (v27[2])
  {
    std::string::append(&__p, " + GarageBand");
    v27 = *(_BYTE **)(a1 + 216);
  }

  if (v27[3]) {
    std::string::append(&__p, " + VoiceOver");
  }
  std::string::operator=((std::string *)a2, &__p);
}

  id v9 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionFurther");
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v9 + 88LL))(v9, buf, __p, &v62);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v10) {
      goto LABEL_28;
    }
  }

  else if (!v10)
  {
    goto LABEL_28;
  }

  uint64_t v11 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v62;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionFurther (%d)",  buf,  8u);
  }

  return v7;
}

    uint64_t v11 = *(unsigned __int8 **)a3;
    goto LABEL_21;
  }

  sub_100242FAC((uint64_t)buf);
  id v14 = 1LL;
LABEL_25:

  return v14;
}

  if (*(unsigned __int8 *)(v1 + 1260) == 255)
  {
    uint64_t v10 = sub_100404FE8();
    *(void *)id v23 = _NSConcreteStackBlock;
    *(void *)&v23[8] = 3221225472LL;
    *(void *)&v23[16] = sub_1006004B4;
    uint64_t v24 = &unk_10087EB20;
    v25 = v1;
    sub_100405384(v10, v23);
  }

void sub_100019328(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (dword_1008D5FD8 <= 40 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 40LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteEnsureStarted]_block_invoke",  40LL,  "Remote controller found: %@",  v3);
  }
  [*(id *)(*(void *)(a1 + 32) + 528) remoteControllersChanged];
}

void sub_1000193BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (dword_1008D5FD8 <= 40 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 40LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteEnsureStarted]_block_invoke_2",  40LL,  "Remote controller lost: %@",  v3);
  }
  [*(id *)(*(void *)(a1 + 32) + 528) remoteControllersChanged];
  [*(id *)(a1 + 32) _remoteInvalidateInactiveXPC];
}

void sub_100019458(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (dword_1008D5FD8 <= 40 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 40LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteEnsureStarted]_block_invoke_3",  40LL,  "Remote controller changed: %@",  v3);
  }
  [*(id *)(*(void *)(a1 + 32) + 528) remoteControllersChanged];
}

id sub_1000194EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _remoteReceivedEvent:a2 options:a3];
}

id sub_1000194FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [*(id *)(a1 + 32) _remoteReceivedRequest:a2 options:a3 responseHandler:a4];
}

void sub_100019510(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (*(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 184LL))
  {
    if (v3)
    {
      id v10 = v3;
      if (dword_1008D5FD8 <= 90
        && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
      {
        uint64_t v5 = CUPrintNSError(v10);
        int v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
        LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteEnsureStarted]_block_invoke_6",  90LL,  "### Remote client failed: %@",  v6);
      }

      [*(id *)(*(void *)(a1 + 40) + 184) invalidate];
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v8 = *(void **)(v7 + 184);
      *(void *)(v7 + 184) = 0LL;

      *(_BYTE *)(*(void *)(a1 + 40) + 200LL) = 0;
      goto LABEL_11;
    }

    if (dword_1008D5FD8 <= 30)
    {
      id v10 = 0LL;
      if (dword_1008D5FD8 != -1 || (int v9 = _LogCategory_Initialize(&dword_1008D5FD8, 30LL), v4 = 0LL, v9))
      {
        LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteEnsureStarted]_block_invoke_6",  30LL,  "Remote client started");
LABEL_11:
        int v4 = v10;
      }
    }
  }
}

void sub_100019638(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (*(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 208LL) && dword_1008D5FD8 <= 90)
  {
    id v8 = v3;
    if (dword_1008D5FD8 != -1 || (int v7 = _LogCategory_Initialize(&dword_1008D5FD8, 90LL), v4 = v8, v7))
    {
      uint64_t v5 = CUPrintNSError(v4);
      int v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteEnsureStarted]_block_invoke_7",  90LL,  "### Remote server error: %@",  v6);

      int v4 = v8;
    }
  }
}

void sub_100019890(uint64_t a1)
{
  if (dword_1008D5FD8 <= 30 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer coexChangeNotification:]_block_invoke",  30LL,  "Coex Notification received");
  }
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) name]);
  unsigned int v3 = [v2 isEqualToString:@"com.apple.bluetooth.leconnection"];

  if (v3)
  {
    int v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userInfo]);
    uint64_t Int64Ranged = CFDictionaryGetInt64Ranged( v4,  @"NUMBER_OF_LE_CONNECTIONS",  0xFFFFFFFF80000000LL,  0x7FFFFFFFLL,  0LL);

    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer coexChangeNotification:]_block_invoke",  30LL,  "Coex Notification Number of LE Connections:%d",  Int64Ranged);
    }

    id v8 = @"NUMBER_OF_LE_CONNECTIONS";
    int v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", Int64Ranged));
    int v9 = v6;
    int v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v9,  &v8,  1LL));

    [*(id *)(a1 + 40) sendCoexUpdate:v7];
  }

void sub_100019F48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100019F80(uint64_t a1)
{
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL)
    && dword_1008D5FD8 <= 90
    && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    id v3 = [*(id *)(a1 + 40) unsignedIntValue];
    uint64_t v4 = CUPrintNSError(*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
    id v5 = (id)objc_claimAutoreleasedReturnValue(v4);
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteReceivedEvent:options:]_block_invoke",  90LL,  "### Remote event receive failed: Sender %@, CID 0x%X, %@",  v2,  v3,  v5);
  }

void sub_10001A3FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_10001A438(uint64_t result)
{
  if (*(void *)(*(void *)(*(void *)(result + 56) + 8LL) + 40LL))
  {
    uint64_t v1 = result;
    if (dword_1008D5FD8 <= 90
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
    {
      uint64_t v2 = *(void *)(v1 + 32);
      id v3 = [*(id *)(v1 + 40) unsignedIntValue];
      uint64_t v4 = CUPrintNSError(*(void *)(*(void *)(*(void *)(v1 + 56) + 8LL) + 40LL));
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteReceivedRequest:options:responseHandler:]_block_invoke",  90LL,  "### Remote request receive failed: Sender %@, CID 0x%X, %@",  v2,  v3,  v5);
    }

    return (*(uint64_t (**)(void))(*(void *)(v1 + 48) + 16LL))();
  }

  return result;
}

LABEL_19:
      }

      id v3 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v36,  v42,  16LL);
    }

    while (v3);
  }

  else
  {
    uint64_t v24 = 0LL;
  }

  uint64_t v30 = 0u;
  __int128 v31 = 0u;
  id v28 = 0u;
  uint64_t v29 = 0u;
  uint64_t v16 = v24;
  uint64_t v17 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v16,  "countByEnumeratingWithState:objects:count:",  &v28,  v40,  16LL);
  if (v17)
  {
    uint64_t v18 = v17;
    __int128 v19 = *(void *)v29;
    do
    {
      for (k = 0LL; k != v18; k = (char *)k + 1)
      {
        if (*(void *)v29 != v19) {
          objc_enumerationMutation(v16);
        }
        id v21 = *(void **)(*((void *)&v28 + 1) + 8LL * (void)k);
        if (dword_1008D5FD8 <= 30
          && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
        {
          id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 remoteDevice]);
          id v23 = (void *)objc_claimAutoreleasedReturnValue([v22 identifier]);
          LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _remoteInvalidateInactiveXPC]",  30LL,  "Invalidating inactive XPC from Remote: %@",  v23);
        }

        [v21 invalidate];
      }

      uint64_t v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v16,  "countByEnumeratingWithState:objects:count:",  &v28,  v40,  16LL);
    }

    while (v18);
  }
}

      sub_1001EE0E4("PCIe default packet type: 0x%x\n", a1);
      off_1008D9F20("PCIe bad packet type", 1LL);
      return 101LL;
    }

    id v5 = &qword_1008D9F80;
  }

  else
  {
    if (a1 != 1)
    {
      if (a1 == 2)
      {
        id v5 = &qword_1008D9F68;
LABEL_8:
        int v6 = &dword_100000004;
        goto LABEL_12;
      }

      goto LABEL_19;
    }

    id v5 = &qword_1008D9F50;
  }

  int v6 = &_mh_execute_header.magic + 3;
LABEL_12:
  int v7 = &unk_1008DA000;
  if (byte_1008DAF98)
  {
    sub_1001EE2A0();
    return 118LL;
  }

  *((_BYTE *)&word_1008D9F98 + "alytics.framework/CoreAnalytics") = 1;
  word_1008D9F98 = a2;
  byte_1008D9F9A = a3;
  if (a1 == 243 || a1 == 2) {
    byte_1008D9F9B = BYTE1(a3);
  }
  if (a3) {
    sub_10011EF64((char *)&word_1008D9F98 + v6);
  }
  else {
    sub_1000BA1F0();
  }
  int v9 = *v5;
  if (!*v5 || (id v10 = *((_DWORD *)v5 + 2), v10 == -1))
  {
    sub_1001EE0E4("%s: invalid input parameter\n");
  }

  else
  {
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    uint64_t v17 = 0u;
    *(_OWORD *)__dst = 0u;
    uint64_t v11 = os_channel_ring_id(v9, 0LL);
    id v12 = os_channel_tx_ring(v9, v11);
    next_slot = os_channel_get_next_slot(v12, 0LL, &v17);
    if (next_slot)
    {
LABEL_28:
      uint64_t v15 = v6 + a3;
      if (v15 <= WORD1(v17))
      {
        memcpy(__dst[0], &word_1008D9F98, v15);
        WORD1(v17) = v15;
        os_channel_set_slot_properties(v12, next_slot, &v17);
        if (os_channel_advance_slot(v12, next_slot))
        {
          sub_1001EE0E4("%s: failed to advance slot - %d\n");
        }

        else
        {
          if (!os_channel_sync(v9, 0LL))
          {
            byte_1008DAF98 = 0;
            return 625LL;
          }

          sub_1001EE0E4("%s: os_channel_sync tx failed\n");
        }
      }

      else
      {
        sub_1001EE0E4("%s: slot_len: %u, size_in: %zu\n");
      }
    }

    else
    {
      while (1)
      {
        sub_1001EE0E4("%s: empty slot. waiting for slot to become available\n", "skywalk_write_channel");
        memset(&eventlist, 0, sizeof(eventlist));
        id v14 = os_channel_get_next_slot(v12, 0LL, &v17);
        if (v14)
        {
          next_slot = v14;
          int v7 = &unk_1008DA000;
          goto LABEL_28;
        }
      }

      sub_1001EE0E4("%s: kevent error on sw_kq_write\n", "skywalk_write_channel");
      int v7 = (_BYTE *)&unk_1008DA000;
    }
  }

  v7[3992] = 0;
  if (!byte_1008D9F19)
  {
    sub_1001EE0E4("PCIe Skywalk write failed: type %u\n", a1);
    off_1008D9F20("PCIe Skywalk write failed", 1LL);
  }

  return 1205LL;
}

  if (*((_BYTE *)v2 + 35) || *((_BYTE *)v2 + 34))
  {
    if (!*((_DWORD *)v2 + 6))
    {
      v32[1] = v2;
      v32[0] = (const void *)2;
      uint64_t v4 = sub_1001EE6E8((uint64_t)sub_1000AE414, v32, 100, (int *)v2 + 6);
      if ((_DWORD)v4)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Register disconnect timeout handler failed %!\n",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v4);
          id v28 = (os_log_s *)sub_100086554(0xFu);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }
    }
  }

  else
  {
    uint64_t v29 = *((unsigned int *)v2 + 6);
    if ((_DWORD)v29)
    {
      sub_1001EEB14(v29);
      *((_DWORD *)v2 + 6) = 0;
    }

    uint64_t v30 = sub_1000AD9D8(a1);
    if (v30) {
      *((_BYTE *)v30 + 34) = 0;
    }
    sub_100119668((uint64_t)v2 + 28);
    LODWORD(v33[0]) = 2;
    *((void *)&v33[0] + 1) = (char *)v2 + 28;
    DWORD2(v33[0]) = *((_DWORD *)v2 + 1);
    WORD2(v33[0]) = *(_WORD *)v2;
    (*(void (**)(_OWORD *))(qword_1008DE4A0 + 24))(v33);
    sub_1001EF1E4(v2 + 5);
    sub_1000B1838(v2);
    --*(_BYTE *)(qword_1008DE4A0 + 16);
  }

  return v4;
}

  if ((_DWORD)a2)
  {
    sub_1000DAC50(a2);
    if (!sub_100171EC4(a2, &v30))
    {
      if (v30)
      {
        sub_1001734D8(v30);
        if (v9) {
          sub_10011286C(v9);
        }
      }
    }
  }

  if (v8)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_AVDTP_cleanFastConnectA2DP Free Caps", v20, v21, v22, v23, v24, v25, v26, v29);
      v27 = (os_log_s *)sub_100086554(3u);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_1000D9CB4(v8);
  }

  return 0LL;
}

  if (v8 != 10)
  {
    id v12 = 0LL;
    goto LABEL_23;
  }

  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
  id v12 = 0LL;
LABEL_21:
  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avrcp/avrcp_metadata.c");
LABEL_23:
  uint64_t v15 = 0;
  id v14 = 1;
LABEL_24:
  if (v9 != 6488) {
    id v14 = 1;
  }
  if (v14) {
    uint64_t v16 = 134;
  }
  else {
    uint64_t v16 = v15;
  }
LABEL_29:
  if (*a3 == 8) {
    uint64_t v17 = 3301LL;
  }
  else {
    uint64_t v17 = v16;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, uint64_t, uint64_t, uint64_t))(*(void *)(qword_1008F29A0 + 8) + 8LL))( a1,  a2,  a3,  v11,  v12,  v17);
}

  if (a4) {
    sub_1000B1838(ptr);
  }
  *(_DWORD *)(qword_1008E1E50 + v8 - 4_Block_object_dispose(va, 8) = 0;
  do
  {
    uint64_t v18 = (void **)(qword_1008E1E50 + v8);
    if (v18 == *v18) {
      break;
    }
    __int128 v19 = sub_1001EF264(v18);
    if (!v19) {
      sub_1001EE2A0();
    }
    id v21 = *(_DWORD *)(v19 - 24);
    __int128 v20 = v19 - 24;
    id v22 = sub_1000EF214( *(unsigned __int16 *)(qword_1008E1E50 + v8 - 64),  v21,  *(void *)(v20 + 8),  *(unsigned __int16 *)(v20 + 16),  *(unsigned __int8 *)(v20 + 18));
    if ((_DWORD)v22)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"SendResponse failed from SendNext %!, type %d\n",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v22);
        uint64_t v30 = (os_log_s *)sub_100086554(0x10u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_100657EA4(v31, &v32, v30);
        }
      }

      sub_1000F1FF0(*(unsigned __int16 *)(qword_1008E1E50 + v8 - 64), *(_DWORD *)v20, v22);
    }

    if (*(_BYTE *)(qword_1008E1E50 + v8 - 8)) {
      --*(_BYTE *)(qword_1008E1E50 + v8 - 8);
    }
    sub_1000B1838((void *)v20);
  }

  while ((_DWORD)v22);
}

    uint64_t v4 = word_1008E2239;
LABEL_20:
    if (v4 == 4) {
      __int128 v31 = 29LL;
    }
    else {
      __int128 v31 = 9LL;
    }
    __int128 v32 = sub_100128D24(v31);
    if ((_DWORD)v32)
    {
      id v13 = v32;
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"OI_HCICMD to reject sco connect request failed %! (%:)",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v13);
        v40 = (os_log_s *)sub_100086554(0x3Eu);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      LOBYTE(word_1008E2239) = 0;
    }

    else
    {
      LOBYTE(word_1008E2239) = 2;
      if (a2) {
        return 1310LL;
      }
      else {
        return 0LL;
      }
    }

    return v13;
  }

  if (sub_10010EEE0(a1, &v70))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Cannot accept SCO connection, no ACL connection record for %:",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  a1);
      uint64_t v30 = (os_log_s *)sub_100086554(0x3Eu);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_19;
  }

  v42 = sub_10011AC98(v70, 3);
  if ((_DWORD)v42)
  {
    id v13 = v42;
    sub_1001EE134((uint64_t)"OI_DEVMGR_ScoConnectAccept failed: %! (%:)", v43, v44, v45, v46, v47, v48, v49, v13);
    v50 = (os_log_s *)sub_100086554(0x3Eu);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      return v13;
    }
LABEL_35:
    sub_100657858();
    return v13;
  }

  v51 = sub_10012DF44(a1);
  if (v51)
  {
    v52 = v51;
    id v13 = sub_10010C9D4(v70);
    if (!(_DWORD)v13)
    {
      *((void *)v52 + 6) = v70;
      return v13;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_LP_ConnectionAdded failed: %! (%:)", v53, v54, v55, v56, v57, v58, v59, v13);
      v60 = (os_log_s *)sub_100086554(0x3Eu);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
        goto LABEL_35;
      }
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not allocate sco connection handle", v61, v62, v63, v64, v65, v66, v67, v69);
      v68 = (os_log_s *)sub_100086554(0x3Eu);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 106LL;
  }

  return v13;
}

    uint64_t v11 = 0LL;
  }

  else
  {
    uint64_t v11 = 605LL;
  }

  a2(v11, v6, v10);
  sub_1000B1838(v10);
}

  id v22 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  id v23 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v22;
  uint64_t v24 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  if (v23 > 0x3F)
  {
    if (v12 < v24)
    {
      v26 = *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
      if (((*(_BYTE *)(sub_10017AB4C(a1) + 54) + (_BYTE)v26) & 0x3Fu) <= v12) {
        goto LABEL_38;
      }
    }
  }

  else
  {
    if (v24 > v12) {
      goto LABEL_38;
    }
    v25 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  }

  v27 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  id v28 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v27;
  uint64_t v29 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
  if (v28 > 0x3F)
  {
    if (v12 <= v29)
    {
      uint64_t v30 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
    }
  }

  else if (v12 <= v29)
  {
    goto LABEL_38;
  }

  __int128 v31 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v31
    || v31 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
  {
    __int128 v32 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    __int128 v33 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    if (v32 <= v31)
    {
      if (v31 - v33 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL))
      {
LABEL_38:
        __int128 v35 = sub_10017AB4C(a1);
        sub_10017B47C(*(unsigned __int16 **)(v35 + 112));
        return 544LL;
      }
    }

    else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
              + (_BYTE)v33) & 0x3Fu) < v31)
    }
    {
      goto LABEL_38;
    }
  }

  __int128 v34 = (a2 >> 7) & 1;
  if (v34 && *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL)) {
    goto LABEL_38;
  }
  sub_100181EEC((uint64_t)a1, v31, v34);
  return 0LL;
}

      v28[72] = a4;
      v28[73] = a3;
      uint64_t v17 = sub_100184F74(*(__int128 **)v28, (char *)&v47, 7uLL, 1);
      if ((_DWORD)v17)
      {
        sub_100184BB0(v28, v17, 1);
      }

      else
      {
        sub_100185420((uint64_t)v28, 17);
        *(_DWORD *)(v28 + 579) = v47;
        *(_WORD *)(v28 + 583) = v48;
        v28[585] = v49;
      }

      return v17;
    }

    id v28 = sub_100185244(a1);
    if (v28) {
      goto LABEL_19;
    }
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Could not allocate a pairing record for handle 0x%x",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  a1);
      v45 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    return 104LL;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid connection handle.", v18, v19, v20, v21, v22, v23, v24, v46);
      v25 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4820LL;
  }

  id v13 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read version", v17, v18, v19, v20, v21, v22, v23, v26);
    uint64_t v24 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v13;
}

        sub_1003DF588((uint64_t)v7, *((unsigned __int8 *)v16 - 1), v18 != 0);
LABEL_40:
        __int128 v19 = (os_log_s *)qword_1008F7560;
        uint64_t v11 = os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT);
        if (v11)
        {
          __int128 v20 = *((unsigned __int8 *)v16 - 1);
          *(_DWORD *)v50 = 67109632;
          *(_DWORD *)&v50[4] = v14;
          v51 = 1024;
          v52 = v20;
          v53 = 1024;
          v54 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "capabilitiesResponseEvent: index %d, capId %d, capInfo %d",  v50,  0x14u);
        }

        ++v14;
        uint64_t v16 = (int *)((char *)v16 + 5);
        if (v14 >= v15) {
          goto LABEL_114;
        }
      }
    }

    v45 = 0;
LABEL_114:
    sub_100224A20(v11, (uint64_t)v7);
    if ((v45 & 1) == 0)
    {
      else {
        __int128 v37 = 65533LL;
      }
      sub_10021C418(a1, (uint64_t)v7, 0xFFFFLL, v37);
    }

    uint64_t v38 = *(unsigned __int8 *)(v44 + 604);
    v39 = v38 & 1;
    v40 = (v38 >> 1) & 1;
    v41 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      if (v39) {
        v42 = v40;
      }
      else {
        v42 = 0;
      }
      *(_DWORD *)v50 = 67109376;
      *(_DWORD *)&v50[4] = v42;
      v51 = 1024;
      v52 = v39;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "GAPA capabilitiesResponseEvent newlyPaired=%d invokeNow=%d",  v50,  0xEu);
    }

    if (v39)
    {
      *(_BYTE *)(v44 + 604) = 0;
      sub_100224C5C(a1, v44, 1, v40);
    }
  }

  return sub_100242FAC((uint64_t)v48);
}

  *id v12 = &v9[v17];
  return result;
}

      uint64_t v18 = (void *)v4[1];
      if (v18)
      {
        do
        {
          __int128 v19 = v18;
          uint64_t v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          __int128 v19 = (void *)v4[2];
          __int128 v20 = *v19 == (void)v4;
          uint64_t v4 = v19;
        }

        while (!v20);
      }

      uint64_t v4 = v19;
    }

    while (v19 != v24);
  }

  id v21 = (void *)objc_claimAutoreleasedReturnValue([v23 allObjects]);
  sub_100242FAC((uint64_t)v32);

  return v21;
}

  *id v12 = &v9[v17];
  return result;
}

  uint64_t v24 = 0LL;
  *(_OWORD *)id v22 = 0u;
  id v23 = 0u;
  sub_100494958(v29, (uint64_t)__p);
  sub_10040CC24((uint64_t)v22, (__int128 *)__p, v10[129], v10[24]);
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  if (qword_1008D9298 != -1) {
    dispatch_once(&qword_1008D9298, &stru_10088BCC0);
  }
  sub_10040D074(qword_1008D9290, (uint64_t)v22);
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[1]);
  }

  __int128 v20 = 0LL;
LABEL_32:

  return v20;
}

              uint64_t v16 = (os_log_s *)qword_1008F75E0;
              if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                __int128 v31 = buffer;
                _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Read invalid address %{public}s from keychain, not creating a device",  buf,  0xCu);
              }

              goto LABEL_36;
            }

  if (__p)
  {
    __int128 v19 = (char *)__p;
    operator delete(__p);
  }

  return v9;
}

        __int128 v19 = 0LL;
        goto LABEL_64;
      }

      goto LABEL_63;
    }

    __int128 v33 = *((_DWORD *)v19 + 5);
    *((_DWORD *)v19 + 6) |= a3;
    if (v33)
    {
      if (v21) {
        goto LABEL_64;
      }
    }

    else if (!v21)
    {
LABEL_63:
      *(_DWORD *)__int128 v19 = 2;
LABEL_64:
      v44 = sub_100404EB8();
      v45 = operator new(0x20uLL);
      v45[4] = 1;
      *(void *)v45 = &off_1008959E0;
      *((void *)v45 + 2) = a2;
      *((_DWORD *)v45 + 6) = a5;
      sub_100405744(v44, v45);
      sub_1003CA1D0(a1);
      if (v19) {
        uint64_t v30 = *((_DWORD *)v19 + 5) == 0;
      }
      else {
        uint64_t v30 = 1LL;
      }
      goto LABEL_67;
    }

    v43 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT))
    {
      v52 = v33;
      sub_10042994C(&v52, &buf);
      v50 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      v51 = *((unsigned __int8 *)v19 + 17);
      *(_DWORD *)__p = 136446466;
      *(void *)&__p[4] = v50;
      v55 = 1024;
      v56 = v51;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_FAULT,  "Found mismatch between pending services(%{public}s) and pending attempts (%d)",  __p,  0x12u);
    }

    goto LABEL_63;
  }

  uint64_t v29 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
    sub_1006793E4(a3, v29);
  }
  uint64_t v30 = 0LL;
LABEL_67:
  sub_100242FAC((uint64_t)v53);
  return v30;
}

    sub_1002400EC(v17);
  }

  uint64_t v15 = 0LL;
LABEL_23:
  sub_100242FAC((uint64_t)v19);
  return v15;
}

          id v10 = (char *)v10 + 1;
        }

        while (v8 != v10);
        uint64_t v17 = [v7 countByEnumeratingWithState:&v23 objects:v29 count:16];
        id v8 = v17;
      }

      while (v17);
    }

    a2 = v20;
    int v6 = v21;
  }

  reply = xpc_dictionary_create_reply(a2);
  __int128 v19 = reply;
  if (reply)
  {
    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", xarray);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v19);
    xpc_release(v19);
  }

  xpc_release(xarray);
}

  uint64_t v18 = calloc(1uLL, 0x60uLL);
  v26 = v18;
  v18[6] = v6;
  v18[7] = uint64;
  v18[4] = sub_10050E5A4;
  v18[5] = v7;
  v18[8] = *(void *)(a1 + 72);
  v18[9] = a1;
  if (v8) {
    __int128 v19 = -1;
  }
  else {
    __int128 v19 = 0;
  }
  *((_DWORD *)v18 + 22) = (int)((_DWORD)v6 << 25) >> 31;
  *((_DWORD *)v18 + 23) = v19;
  sub_1002555B0((uint64_t **)(a1 + 80), (unint64_t *)&v26, (uint64_t *)&v26);
  __int128 v20 = (os_log_s *)qword_1008F75F0;
  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG))
  {
    v25 = *(void *)(a1 + 96);
    *(_DWORD *)buf = 134219008;
    uint64_t v29 = uint64;
    uint64_t v30 = 2048;
    *(void *)__int128 v31 = v26 + 4;
    *(_WORD *)&v31[8] = 2048;
    *(void *)&v31[10] = v7;
    __int128 v32 = 2048;
    __int128 v33 = v6;
    __int128 v34 = 2048;
    __int128 v35 = v25;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "BTAccessoryMsgHandler::handleBTAccessoryRegisterCustomMessageClientMsg accessoryManager:%llx callbacks:%p cbid:%ll u messageType:%llX fBTAccessoryCallbacks.size():%lu",  buf,  0x34u);
  }

  if (*(_BYTE *)(a1 + 104))
  {
    id v21 = 0;
  }

  else
  {
    id v21 = sub_1003B8A44(uint64, v26 + 4, -1, (uint64_t)(v26 + 9));
    if (v21)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_10068CAD4();
      }
    }

    else
    {
      *(_BYTE *)(a1 + 104) = 1;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)v2);
}

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
    sub_1006911C0(a1);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, 10LL);
}
}

void *sub_10001AC40(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[66]) {
    return [result _whbDiscoveryDeviceFound:a2];
  }
  return result;
}

void *sub_10001AC5C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v3 == result[66]) {
    return [result _whbDiscoveryDeviceLost:a2];
  }
  return result;
}

void sub_10001B780(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v6)
  {
    if (dword_1008D5FD8 <= 40
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 40LL)))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      unsigned int v11 = [v5 cloudSyncStatus];
      if (v11 > 3) {
        id v12 = "?";
      }
      else {
        id v12 = off_10087F6B8[(char)v11];
      }
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _userControllerCloudUpdateWithDevices:]_block_invoke",  40LL,  "FastLEConnection: self device %@ sync status %s",  v10,  v12);
    }

    id v13 = *(void **)(*(void *)(a1 + 40) + 480LL);
    id v17 = 0LL;
    unsigned __int8 v14 = [v13 updateControllerInfo:v5 error:&v17];
    id v9 = v17;
    if ((v14 & 1) == 0
      && dword_1008D5FD8 <= 90
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
    {
      uint64_t v15 = CUPrintNSError(v9);
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _userControllerCloudUpdateWithDevices:]_block_invoke",  90LL,  "FastLEConnection: error updating stack controller info: %@",  v16);
    }

    goto LABEL_16;
  }

  if (dword_1008D5FD8 <= 90 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 90LL)))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = CUPrintNSError(v6);
    id v9 = (id)objc_claimAutoreleasedReturnValue(v8);
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _userControllerCloudUpdateWithDevices:]_block_invoke",  90LL,  "FastLEConnection: self device %@ error %@",  v7,  v9);
LABEL_16:
  }
}

void sub_10001BA44(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = v3;
  if (!v3)
  {
    [*(id *)(*(void *)(a1 + 32) + 512) storeControllerInfo:*(void *)(a1 + 40) completion:&stru_10087F558];
LABEL_3:
    uint64_t v4 = v8;
    goto LABEL_4;
  }

  uint64_t v4 = v3;
  if (dword_1008D5FD8 <= 90)
  {
    if (dword_1008D5FD8 != -1 || (int v7 = _LogCategory_Initialize(&dword_1008D5FD8, 90LL), v4 = v8, v7))
    {
      uint64_t v5 = CUPrintNSError(v4);
      id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _userControllerUploadLocalControllerInfo]_block_invoke",  90LL,  "Error saving this device's controller info %@",  v6);

      goto LABEL_3;
    }
  }

void sub_10001BB00(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  id v3 = v2;
  if (v2)
  {
    if (dword_1008D5FD8 <= 90)
    {
      int v7 = v2;
      if (dword_1008D5FD8 != -1 || (int v6 = _LogCategory_Initialize(&dword_1008D5FD8, 90LL), v3 = v7, v6))
      {
        uint64_t v4 = CUPrintNSError(v3);
        uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
        LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _userControllerUploadLocalControllerInfo]_block_invoke_2",  90LL,  "Error saving this device's controller info due to %@",  v5);

        id v3 = v7;
      }
    }
  }
}

id sub_10001BC4C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _activateCBAdvertiser:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001BF6C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _invalidateCBAdvertiser:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001C1E0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _activateCBController:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001C510(uint64_t a1)
{
  return [*(id *)(a1 + 32) _invalidateCBController:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001C784(uint64_t a1)
{
  return [*(id *)(a1 + 32) _activateCBDiscovery:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001CB08(uint64_t a1)
{
  return [*(id *)(a1 + 32) _invalidateCBDiscovery:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001CDA8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _activateCBSpatialInteractionSession:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001D0D8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _invalidateCBSpatialInteractionSession:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_10001D320(uint64_t a1)
{
  return [*(id *)(a1 + 32) _aopMessageReceived:*(void *)(a1 + 40)];
}

id sub_10001D614(uint64_t a1)
{
  return [*(id *)(a1 + 32) _notifyConnectedDeviceUUID:*(void *)(a1 + 40) name:*(void *)(a1 + 48) servicesUUIDs:*(void *)(a1 + 56)];
}

LABEL_23:
                  __int128 v19 = v49;
                  __int128 v20 = v47;
                }

                v48 = [v49 countByEnumeratingWithState:&v54 objects:v63 count:16];
                if (v48) {
                  continue;
                }
                break;
              }

  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_airdropWiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_airplaySourceWiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_airplayTargetWiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_dsInfoWiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_heySiriWiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_nearbyActionV1WiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_nearbyActionV2WiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_nearbyInfoWiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_nearbyInfoV2WiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_nearbyActionNoWakeWiProxContext,  v4 < 0x1F);
  -[CBAdvertiserDaemon _wiproxAppendDescription:context:verbose:]( self,  "_wiproxAppendDescription:context:verbose:",  &location,  &self->_spatialInteractionWiProxContext,  v4 < 0x1F);
  saAdvAddresses = self->_saAdvAddresses;
  if (saAdvAddresses)
  {
    v55 = location;
    uint64_t v16 = saAdvAddresses;
    id v17 = CUPrintNSObjectOneLine(v16);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    NSAppendPrintF_safe(&v55, ", saAD %@,", v18);
    objc_storeStrong(&location, v55);
  }

  saPayloadSegments = self->_saPayloadSegments;
  if (saPayloadSegments)
  {
    id obj = location;
    __int128 v20 = saPayloadSegments;
    id v21 = CUPrintNSObjectOneLine(v20);
    id v22 = objc_claimAutoreleasedReturnValue(v21);
    id v23 = (void *)v22;
    saAdvertiseRate = self->_saAdvertiseRate;
    if (saAdvertiseRate <= 39)
    {
      if (saAdvertiseRate > 19)
      {
        if (saAdvertiseRate == 20)
        {
          v25 = "350 ms";
          goto LABEL_46;
        }
      }

      else
      {
        if (saAdvertiseRate == 10)
        {
          v25 = "2 seconds";
          goto LABEL_46;
        }

        if (saAdvertiseRate == 15)
        {
          v25 = "1022.5 ms";
          goto LABEL_46;
        }
      }
    }

    else if (saAdvertiseRate <= 44)
    {
      if (saAdvertiseRate == 40)
      {
        v25 = "181.25 ms";
        goto LABEL_46;
      }

      if (saAdvertiseRate == 42)
      {
        v25 = "120 ms";
        goto LABEL_46;
      }
    }

    else
    {
      switch(saAdvertiseRate)
      {
        case '-':
          v25 = "60 ms";
          goto LABEL_46;
        case '2':
          v25 = "30 ms";
          goto LABEL_46;
        case '<':
          v25 = "20 ms";
LABEL_46:
          NSAppendPrintF_safe(&obj, ", saPD %@, %s", v22, v25);
          objc_storeStrong(&location, obj);

          goto LABEL_47;
      }
    }

    v25 = "270 ms";
    goto LABEL_46;
  }
}
}
}

  return v15;
}

  id v21 = [v10 adaptiveVolumeConfig];
  if ((_DWORD)v21)
  {
    if (dword_1008D66A0 <= 30
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      id v22 = (void *)objc_claimAutoreleasedReturnValue([v9 name]);
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "adaptiveVolumeConfig sendControlCommand for %@: device %@, value 0x%04X",  v22,  v11,  v21);
    }

    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    id v23 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)a4, 38LL, (uint64_t)v21, 2u);
    if (v23)
    {
      uint64_t v24 = (v23 + 310000);
      if ((_DWORD)v24)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v132 = CBErrorF(v24, "set adaptiveVolumeConfig failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v132);
        goto LABEL_327;
      }
    }
  }

  v25 = [v10 allowsAutoRoute];
  if (v25)
  {
    if (dword_1008D66A0 <= 30
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      if (v25 > 2) {
        v26 = "?";
      }
      else {
        v26 = off_100881480[v25];
      }
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "allowsAutoRoute: device %@, allows %s",  v11,  v26);
    }

    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    v27 = sub_10023B8C4((uint64_t)off_1008D60D8, (uint64_t)a4, v25 == 1);
    if (v27)
    {
      id v28 = (v27 + 310000);
      if ((_DWORD)v28)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v133 = CBErrorF(v28, "setAllowsAutoRoute failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v133);
        goto LABEL_327;
      }
    }
  }

  uint64_t v29 = [v10 audioRouteHidden];
  if (v29)
  {
    if (dword_1008D66A0 <= 30
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      if (v29 > 2) {
        uint64_t v30 = "?";
      }
      else {
        uint64_t v30 = off_100881480[v29];
      }
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "audioRouteHidden: device %@, hidden %s",  v11,  v30);
    }

    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    __int128 v31 = sub_10023BAB8((uint64_t)off_1008D60D8, (uint64_t)a4, v29 == 1);
    if (v31)
    {
      __int128 v32 = (v31 + 310000);
      if ((_DWORD)v32)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v134 = CBErrorF(v32, "setAudioRouteHidden failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v134);
        goto LABEL_327;
      }
    }
  }

  __int128 v33 = [v10 endCallConfig];
  __int128 v34 = [v10 muteControlConfig];
  if (v33 | v34)
  {
    __int128 v35 = sub_1003DFE34((uint64_t)a4) & 0xF0FF | ((v33 & 0xF) << 8) | ((v34 & 0xF) << 16);
    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    __int128 v36 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)a4, 36LL, v35, 2u);
    if (v36)
    {
      __int128 v37 = (v36 + 310000);
      if ((_DWORD)v37)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v141 = CBErrorF(v37, "set callMgmtConfig failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v141);
        goto LABEL_327;
      }
    }
  }

  uint64_t v38 = [v10 conversationDetectConfig];
  if ((_DWORD)v38)
  {
    if (dword_1008D66A0 <= 30
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      v39 = (void *)objc_claimAutoreleasedReturnValue([v9 name]);
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "conversationDetectConfig sendControlCommand for %@: device %@, value 0x%04X",  v39,  v11,  v38);
    }

    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    v40 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)a4, 40LL, (uint64_t)v38, 2u);
    if (v40)
    {
      v41 = (v40 + 310000);
      if ((_DWORD)v41)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v135 = CBErrorF(v41, "set conversationDetectConfig failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v135);
        goto LABEL_327;
      }
    }
  }

  v42 = [v10 clickHoldModeLeft];
  v43 = [v10 clickHoldModeRight];
  if (v42 | v43)
  {
    v44 = sub_1003DFBD0((uint64_t)a4);
    if (v42) {
      v45 = v42;
    }
    else {
      v45 = HIBYTE(v44);
    }
    if (!v43) {
      LOBYTE(v43) = v44;
    }
    if (dword_1008D66A0 < 31
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      if (v45 > 7u) {
        v46 = @"?";
      }
      else {
        v46 = (const __CFString *)*((void *)&off_1008813B8 + (char)v45);
      }
      else {
        v47 = (const __CFString *)*((void *)&off_1008813B8 + (char)v43);
      }
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "clickHoldMode: device %@, left %@, right %@, value 0x%04X",  v11,  v46,  v47,  v43 | (v45 << 8));
    }

    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    v48 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)a4, 22LL, v43 | (v45 << 8), 2u);
    if (v48)
    {
      v49 = (v48 + 310000);
      if ((_DWORD)v49)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v142 = CBErrorF(v49, "set clickHoldMode failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v142);
        goto LABEL_327;
      }
    }
  }

  v50 = [v10 crownRotationDirection];
  if ((_DWORD)v50)
  {
    if (dword_1008D66A0 <= 30
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      v51 = @"?";
      if ((_DWORD)v50 == 1) {
        v51 = @"BackToFront";
      }
      if ((_DWORD)v50 == 2) {
        v51 = @"FrontToBack";
      }
      v52 = v51;
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "crownRotationDirection: device %@, %@",  v11,  v52);
    }

    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    v53 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)a4, 28LL, (uint64_t)v50, 2u);
    if (v53)
    {
      v54 = (v53 + 310000);
      if ((_DWORD)v54)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v136 = CBErrorF(v54, "set crownRotationDirection failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v136);
        goto LABEL_327;
      }
    }
  }

  v55 = [v10 deviceFlagsMask];
  v56 = (unint64_t)[v10 deviceFlagsValue];
  v57 = v56;
  if ((v55 & 0x400000) != 0)
  {
    v58 = *((unsigned __int8 *)a4 + 1436);
    if (((v56 >> 22) & 1) != v58)
    {
      v59 = v56 & 0x400000;
      if (dword_1008D66A0 <= 30
        && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
      {
        v60 = "yes";
        if (v58) {
          v61 = "yes";
        }
        else {
          v61 = "no";
        }
        if (!v59) {
          v60 = "no";
        }
        LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "userRouted: device %@, %s -> %s",  v11,  v61,  v60);
      }

      sub_1003D1BD4((uint64_t)a4, v59 != 0LL);
    }
  }

  if ((v55 & 0x80000000) != 0)
  {
    if (dword_1008D66A0 <= 30
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
    {
      v62 = "yes";
      if (v57 >= 0) {
        v62 = "no";
      }
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "autoAnswerCalls: device %@, %s",  v11,  v62);
    }

    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
    }
    v63 = v57 < 0 ? 1LL : 2LL;
    v64 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)a4, 30LL, v63, 2u);
    if (v64)
    {
      v65 = (v64 + 310000);
      if ((_DWORD)v65)
      {
        if (!a6) {
          goto LABEL_328;
        }
        v143 = CBErrorF(v65, "set autoAnswerCalls failed");
        v128 = (void *)objc_claimAutoreleasedReturnValue(v143);
        goto LABEL_327;
      }
    }
  }

  v66 = sub_1003D635C((uint64_t)a4);
  v67 = [v10 doubleTapActionLeft];
  v68 = [v10 doubleTapActionRight];
  v69 = v68;
  v70 = HIBYTE(v66);
  v71 = v66;
  v72 = v67 - 1;
  if (v67 - 1 >= 5) {
    v72 = 0xFFFF;
  }
  if (v67) {
    v73 = v72;
  }
  else {
    v73 = HIBYTE(v66);
  }
  if (v68)
  {
    if (v68 > 5)
    {
      v74 = 0xFFFFLL;
      goto LABEL_145;
    }

    v74 = v68 - 1;
  }

  else
  {
    v74 = v71;
  }

  if ((_DWORD)v73 == v70 && (_DWORD)v74 == (_DWORD)v71) {
    goto LABEL_158;
  }
LABEL_145:
  if (dword_1008D66A0 <= 30 && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
  {
    if (v67 > 5) {
      v75 = "?";
    }
    else {
      v75 = off_1008813F8[v67];
    }
    if (v69 > 5) {
      v76 = "?";
    }
    else {
      v76 = off_1008813F8[v69];
    }
    LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack modifyDevice:btDevice:settings:error:]",  30LL,  "setDoubleTapActionEx: device %@, left %d (%s), right %d (%s)",  v11,  v73,  v75,  v74,  v76);
  }

  v77 = sub_1003B27F4((uint64_t)v150, (uint64_t)a4, v73, v74);
  if (v77)
  {
    v78 = (v77 + 310000);
    if ((_DWORD)v78)
    {
      if (!a6) {
        goto LABEL_328;
      }
      v129 = CBErrorF(v78, "setDoubleTapActionEx failed");
      v128 = (void *)objc_claimAutoreleasedReturnValue(v129);
      goto LABEL_327;
    }
  }

      IOObjectRelease(v4);
      uint64_t v4 = IOIteratorNext(a2);
    }

    while (v4);
  }

  sub_1001EE0E4("[bm3_usb][DeviceFoundCB] exited\n");
}

  if (!*(void *)qword_1008DFDA8)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"No AVCTP profiles registered", v29, v30, v31, v32, v33, v34, v35, v47);
      __int128 v36 = (os_log_s *)sub_100086554(2u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_31;
  }

  if ((v17 & 1) != 0 || (uint64_t result = sub_1000D660C(&v48), (_DWORD)result))
  {
LABEL_31:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Rejecting incoming AVCTP connection request", v37, v38, v39, v40, v41, v42, v43, v47);
      v44 = (os_log_s *)sub_100086554(2u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    id v23 = 0LL;
    uint64_t v24 = 0LL;
    v25 = 0LL;
    v27 = a3;
    id v28 = 0;
    v26 = 0LL;
    return sub_100174B2C((uint64_t)v23, (uint64_t)v24, (uint64_t)v25, v27, 0LL, v28, (uint64_t)v26);
  }

  id v21 = v48;
  id v22 = *(_WORD *)(a2 + 4);
  *(_DWORD *)(v48 + _Block_object_dispose(va, 8) = *(_DWORD *)a2;
  *(_WORD *)(v21 + 12) = v22;
  *(_WORD *)(v21 + 24) = a3;
  *(_DWORD *)(v21 + 14) = 16777217;
  *(void *)(v21 + 56) = 0LL;
  *(_DWORD *)(v21 + 64) = 0;
  *(_BYTE *)(v21 + 72) = 0;
  if ((v5 & 1) != 0)
  {
    id v23 = sub_1000D66A4;
    uint64_t v24 = sub_1000D67D0;
    v25 = sub_1000D685C;
    v26 = &unk_1006BBFD8;
    v27 = a3;
    id v28 = 1;
    return sub_100174B2C((uint64_t)v23, (uint64_t)v24, (uint64_t)v25, v27, 0LL, v28, (uint64_t)v26);
  }

  v45 = *(uint64_t ***)qword_1008DFDA8;
  if (*(void *)qword_1008DFDA8)
  {
    do
    {
      v46 = *v45;
      uint64_t result = ((uint64_t (*)(uint64_t))v45[1])(a2);
      v45 = (uint64_t **)v46;
    }

    while (v46);
  }

  return result;
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"stallL2CAPForHandle lTsPeers cid 0x%4x", v29, v30, v31, v32, v33, v34, v35, v28);
    __int128 v36 = (os_log_s *)sub_100086554(0x56u);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v37 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      v55 = v37;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v38 = v53;
  if ((_DWORD)v28)
  {
    if (v53)
    {
      v39 = 0LL;
      v40 = 1;
      while (*((unsigned __int16 *)v56 + v39) != (_DWORD)v28)
      {
        v39 = v40;
        id v22 = v53 > v40++;
        if (!v22) {
          goto LABEL_31;
        }
      }

      goto LABEL_33;
    }

    sub_1000AFE20((uint64_t)v6);
LABEL_24:
    if (v7)
    {
      id v8 = 136446210;
      id v9 = "SDP Server initialization failed\n";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&v8, 0xCu);
    }

    sub_1000AFE20((uint64_t)v5);
  }

  uint64_t v5 = (os_log_s *)sub_1001E3874(0LL);
  int v6 = (os_log_s *)sub_100086554(0x5Cu);
  int v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v5) {
    goto LABEL_24;
  }
  if (v7)
  {
    id v8 = 136446210;
    id v9 = "Stack initialization complete\n";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&v8, 0xCu);
  }

  if (off_1008F6CF0) {
    off_1008F6CF0(0LL);
  }
}

    if (v3 == 1 && (byte_1008E2210 & 2) != 0 && v1 == 1)
    {
      byte_1008E2210 &= ~2u;
      byte_1008E21ED = 0;
      off_1008E21F0(v2, byte_1008E2211 != 0);
    }

    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"writeScanEnableCb - orphan callback", v6, v7, v8, v9, v10, v11, v12, v22);
    id v13 = (os_log_s *)sub_100086554(0x2Cu);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

      __int128 v19 = sub_1001EFCEC(v6, v53, v15);
      if (v19 != v15)
      {
        __int128 v20 = v19;
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to get the full payload size (%d), only got %d bytes",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v15);
          id v28 = (os_log_s *)sub_100086554(0x2Fu);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            __int128 v33 = sub_1001EDDCC();
            *(_DWORD *)buf = v51;
            v65 = v33;
            v66 = 1024;
            v67 = 0xFFFF;
            _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
          }
        }

        uint64_t v15 = v20;
      }

      sub_1001EF520((uint64_t)&v57, 1u);
      sub_1001EFB10((unsigned __int8 *)&v57, v6, v15, 2u);
      BYTE8(v55) = *(_BYTE *)(sub_10017AB4C((unsigned int *)a1) + 77);
      WORD5(v55) = v3;
      LOBYTE(v54) = *(__int16 *)(sub_10017AB4C((unsigned int *)a1) + 38) == -1;
      *(_OWORD *)&v56[1] = v57;
      *(_OWORD *)&v56[3] = v58;
      *(_OWORD *)&v56[11] = v62;
      *(_OWORD *)&v56[13] = v63;
      *(_OWORD *)&v56[5] = v59;
      *(_OWORD *)&v56[7] = v60;
      *(_OWORD *)&v56[9] = v61;
      uint64_t v29 = *(void *)(a1 + 128);
      v56[2] = a1;
      v56[0] = v29;
      *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
      uint64_t v30 = (_BYTE **)sub_10017AB4C((unsigned int *)a1);
      __int128 v31 = sub_10018A8DC((uint64_t)&v54, *v30, 0, *(_WORD *)(a1 + 4));
      __int128 v32 = v31;
      if ((_DWORD)v31 != 412)
      {
        if ((_DWORD)v31)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Failed to send packet. Bailing. result %!", v34, v35, v36, v37, v38, v39, v40, v32);
            v41 = (os_log_s *)sub_100086554(0x2Fu);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }
        }

        return v32;
      }

      id v12 = (unsigned __int16)(v15 + v12);
      if (v12 == v3) {
        return v32;
      }
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Error, packet too large (exceeds MaxPDUSize * window)",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v51);
    v49 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 472LL;
}

  if (*(_BYTE *)a1)
  {
    sub_1001214B4(165, (uint64_t)sub_1001BFD2C, v44, v45, v46, v47, v48, v49, (uint64_t)a1 + 1);
  }

  else
  {
    v50 = sub_1001EE6E8((uint64_t)sub_1001BFD0C, 0LL, 0, 0LL);
    if ((_DWORD)v50)
    {
      v51 = v50;
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Failed to register a fake GAPAddressTypeChangedCB status:%!",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v51);
        v59 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      sub_1001BCCC4();
      sub_1001BFD4C();
      byte_1008ECCB9 = 0;
      sub_1001B9F20();
    }
  }

  sub_10012F300();
}

      *(_DWORD *)(a1 + 52) = 0;
      goto LABEL_35;
    }

    return 4824LL;
  }

  *(_BYTE *)(a1 + 77) |= 1u;
  *(_BYTE *)(a1 + 75) |= 1u;
  if ((*(_BYTE *)(a1 + 76) & 8) != 0)
  {
    id v8 = *(_BYTE *)(a1 + 74);
    *(_BYTE *)(a1 + 594) = (v8 & 8) != 0;
    if ((v3 & 0x20) != 0 && (v8 & 8) != 0)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Both sides set CT2=1, will use H7", v9, v10, v11, v12, v13, v14, v15, v31);
        uint64_t v16 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__buf = 136446210;
          *(void *)&__buf[4] = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", __buf, 0xCu);
        }
      }

      *(_BYTE *)(a1 + 593) = 1;
    }
  }

  else
  {
    *(_BYTE *)(a1 + 594) = 0;
  }

  if (*(_BYTE *)(*(void *)a1 + 70LL) == 1) {
    sub_100185420(a1, 32);
  }
  id v17 = *(unsigned __int8 *)(a1 + 16);
  if (v17 == 1) {
    goto LABEL_23;
  }
  if (v17 == 5)
  {
    if (off_1008F6EB0)
    {
      uint64_t v18 = 5;
      goto LABEL_34;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Cannot do OOB if there is no PAIRING_DISPLAY callback registered",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v31);
      id v28 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4824LL;
  }

  if (*(_BYTE *)(*(void *)a1 + 70LL) == 1) {
    return 0LL;
  }
  __int128 v19 = (_OWORD *)(a1 + 152);
  uint64_t result = sub_1001120DC((_OWORD *)(a1 + 152), (_OWORD *)(a1 + 216));
  if ((_DWORD)result)
  {
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    void *v19 = 0u;
    *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a1 + 216) = 0u;
    *(_OWORD *)(a1 + 232) = 0u;
    *(_OWORD *)(a1 + 24_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a1 + 264) = 0u;
    *(_OWORD *)(a1 + 280) = 0u;
    *(_OWORD *)(a1 + 296) = 0u;
  }

  else
  {
    sub_100185420(a1, 33);
    __buf[0] = 12;
    uint64_t v29 = *(_OWORD *)(a1 + 168);
    *(_OWORD *)&__buf[1] = *v19;
    __int128 v33 = v29;
    uint64_t v30 = *(_OWORD *)(a1 + 200);
    __int128 v34 = *(_OWORD *)(a1 + 184);
    __int128 v35 = v30;
    return sub_100184F74(*(__int128 **)a1, __buf, 0x41uLL, 1);
  }

  return result;
}

          __dst = *(_OWORD *)v6;
          id v23 = *((void *)v6 + 2);
        }

        sub_1001FFF44(v8, 1LL, (void **)&__dst, 2LL);
        if (SHIBYTE(v23) < 0)
        {
          p_dst = (void **)&__dst;
          goto LABEL_34;
        }

      v74[0] = 0;
      *(_DWORD *)&v74[1] = *(_DWORD *)a2;
      *(_WORD *)&v74[5] = *(_WORD *)(a2 + 4);
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_100888CB0);
      }
      id v12 = sub_10062D738(qword_1008D5F18, v74, &v84);
      id v13 = 0;
      unsigned __int8 v14 = v5;
      for (k = (uint64_t *)(a4 + 8); ; k += 2)
      {
        uint64_t v16 = (os_log_s *)qword_1008F7600;
        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
        {
          id v17 = *((unsigned __int16 *)k - 4);
          uint64_t v18 = *((unsigned __int16 *)k - 3);
          sub_1003D0100((uint64_t)v8, (uint64_t)__p);
          __int128 v19 = __p;
          if (v81 < 0) {
            __int128 v19 = *(_BYTE **)__p;
          }
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&buf[4] = v17;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v18;
          *(_WORD *)v76 = 2080;
          *(void *)&v76[2] = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Device received non-magic Key update with keyType = %x, keyLength = %d from device%s ",  buf,  0x18u);
          if (v81 < 0) {
            operator delete(*(void **)__p);
          }
        }

        __int128 v20 = *((unsigned __int16 *)k - 4);
        id v21 = v20 == 1 ? v12 : 1;
        if ((v21 & 1) == 0) {
          break;
        }
LABEL_66:
        if (v20 != 4) {
          goto LABEL_97;
        }
        if (v85 == *(void *)*k && v86 == *(void *)(*k + 8))
        {
          __int128 v34 = (os_log_s *)qword_1008F7600;
          if (!os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
            goto LABEL_97;
          }
          sub_1003D0100((uint64_t)v8, (uint64_t)buf);
          __int128 v35 = buf;
          if (v76[9] < 0) {
            __int128 v35 = *(_BYTE **)buf;
          }
          *(_DWORD *)__p = 136315138;
          *(void *)&__p[4] = v35;
          _os_log_error_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "Receive invalid non-magic Enc Key from %s",  __p,  0xCu);
          if ((v76[9] & 0x80000000) == 0) {
            goto LABEL_97;
          }
          __int128 v36 = *(void **)buf;
          goto LABEL_90;
        }

        if (qword_1008D6608 != -1) {
          dispatch_once(&qword_1008D6608, &stru_100888CF0);
        }
        sub_1005E459C((uint64_t)off_1008D6600, v74, *k);
        if (v10)
        {
          __int128 v32 = (void *)sub_1002E6C74();
          __int128 v33 = 14LL;
LABEL_83:
          id v13 = (*(uint64_t (**)(void))(*v32 + 8 * v33))();
          goto LABEL_84;
        }

        if (!v72 || v8[989]) {
          goto LABEL_82;
        }
        if (v8[988])
        {
          if (qword_1008D60C0 != -1) {
            dispatch_once(&qword_1008D60C0, &stru_100888BD0);
          }
          if ((sub_1003EE52C((uint64_t)off_1008D60B8, (uint64_t)v8) & 1) == 0)
          {
LABEL_82:
            __int128 v32 = (void *)sub_1002E6C74();
            __int128 v33 = 11LL;
            goto LABEL_83;
          }
        }

            id v12 = v10;
            id v13 = v10;
LABEL_24:
            if (v13)
            {
              id v17 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109632;
                v27 = v11;
                id v28 = 1024;
                uint64_t v29 = v12;
                uint64_t v30 = 1024;
                __int128 v31 = v10;
                _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "parseAACPDescriptor Key:%d Dumped %d of %d bytes ",  buf,  0x14u);
              }

              sub_10040F8BC(a2, v13);
            }

            goto LABEL_28;
          }

          if (v10 != 2) {
            goto LABEL_23;
          }
          __int128 v20 = sub_10040F7FC(a2);
        }
      }

      else
      {
        if (v11 == 1)
        {
          id v12 = v10;
          id v13 = v10;
          if (v10 >= 7)
          {
            unsigned __int8 v14 = sub_10040F7FC(a2);
            sub_10040F7FC(a2);
            int v7 = sub_10040F7FC(a2);
            sub_10040F7B0(a2);
            buf[0] = 0;
            sub_100242CA4(buf);
            if (sub_100171EC4(a4, (uint64_t *)&v25) || !sub_10017AB4C(v25))
            {
              uint64_t v15 = (os_log_s *)qword_1008F7560;
              if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
                sub_100662524(&v23, v24, v15);
              }
            }

            else
            {
              *(_WORD *)(sub_10017AB4C(v25) + _Block_object_dispose(va, 8) = v14;
              *(_WORD *)(sub_10017AB4C(v25) + 32) = v7;
              v7 -= 4;
              sub_1000B4B2C(v7, v20, a4);
            }

            sub_100242CD0(buf);
            sub_100242CD8(buf);
            id v12 = (unsigned __int16)(v10 - 7);
            id v13 = v10 - 7;
          }

          goto LABEL_24;
        }

        if (v11 != 3) {
          goto LABEL_21;
        }
        if (v10 != 2) {
          goto LABEL_23;
        }
        id v22 = sub_10040F7FC(a2);
      }

    if (v13 == v16) {
      *(_DWORD *)(v3 + 96) = -1;
    }
    __int128 v19 = sub_100404EB8();
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = sub_10025A730;
    *(void *)&buf[24] = &unk_10087EB68;
    v25 = v3;
    v26 = 19;
    sub_100405384(v19, buf);
  }

      CFRelease(v7);
      return v15;
    }

    return 4294902292LL;
  }

  switch(a1)
  {
    case 1:
      int v6 = "Encryption Root";
      goto LABEL_10;
    case 2:
      int v6 = "Identity Root";
      goto LABEL_10;
    case 19:
      int v6 = "Non Connectable identity address";
      goto LABEL_10;
  }

  return 4294902295LL;
}

    id v9 = v23;
    goto LABEL_24;
  }

  __int128 v32 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
  {
    __int128 v33 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", 1LL);
    *(_DWORD *)buf = 136446210;
    v40 = v33;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "Ignoring read as '%{public}s' cache has not been loaded yet",  buf,  0xCu);
  }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v387[0])));
          [v4 setObject:v40 forKeyedSubscript:@"cycleCount"];

          v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD4(v388)));
          [v4 setObject:v41 forKeyedSubscript:@"timeChargingTotal"];

          v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v388)));
          [v4 setObject:v42 forKeyedSubscript:@"timeChargingWirelessTotal"];

          v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD6(v388)));
          [v4 setObject:v43 forKeyedSubscript:@"timeChargingTopOff"];

          v44 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  HIWORD(v388)));
          [v4 setObject:v44 forKeyedSubscript:@"timeChargingTopOffWireless"];

          v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  (unsigned __int16)v389));
          [v4 setObject:v45 forKeyedSubscript:@"timeChargingTopOffWired"];

          v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD1(v389)));
          [v4 setObject:v46 forKeyedSubscript:@"tempBattMax"];

          v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD2(v389)));
          [v4 setObject:v47 forKeyedSubscript:@"tempBattAvg"];

          v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD3(v389)));
          [v4 setObject:v48 forKeyedSubscript:@"tempBattMin"];

          v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD4(v389)));
          [v4 setObject:v49 forKeyedSubscript:@"tempMlbMax"];

          v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v389)));
          [v4 setObject:v50 forKeyedSubscript:@"voltageMax"];

          v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD6(v389)));
          [v4 setObject:v51 forKeyedSubscript:@"voltageMin"];

          v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  HIWORD(v389)));
          [v4 setObject:v52 forKeyedSubscript:@"capacity"];

          v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  LOWORD(v390[0])));
          [v4 setObject:v53 forKeyedSubscript:@"cycleAtCapacity"];

          v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD1(v390[0])));
          [v4 setObject:v54 forKeyedSubscript:@"resistance"];

          v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD2(v390[0])));
          [v4 setObject:v55 forKeyedSubscript:@"tempSiPMax"];

          v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD3(v390[0])));
          [v4 setObject:v56 forKeyedSubscript:@"currentDischargeMax"];

          v57 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD4(v390[0])));
          [v4 setObject:v57 forKeyedSubscript:@"batteryVendor"];

          v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE10(v390[0])));
          [v4 setObject:v58 forKeyedSubscript:@"capacityMilestone_0"];

          v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE11(v390[0])));
          [v4 setObject:v59 forKeyedSubscript:@"capacityMilestone_1"];

          v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE12(v390[0])));
          [v4 setObject:v60 forKeyedSubscript:@"capacityMilestone_2"];

          v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE13(v390[0])));
          [v4 setObject:v61 forKeyedSubscript:@"capacityMilestone_3"];

          v62 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v391));
          [v4 setObject:v62 forKeyedSubscript:@"capacityMilestone_4"];

          v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE1(v391)));
          [v4 setObject:v63 forKeyedSubscript:@"capacityMilestone_5"];

          v64 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE14(v391)));
          [v4 setObject:v64 forKeyedSubscript:@"timeInField"];

          v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  HIBYTE(v391)));
          [v4 setObject:v65 forKeyedSubscript:@"timeInFieldAtCapacity"];

          sub_1002F34F8(v66, @"timeAVoltageTempMatrix", 30, 2u, (uint64_t)v387 + 12, v4, 0);
          sub_1002F34F8(v67, @"cycleCountAtCapacityMilestone", 6, 1u, (uint64_t)&v391 + 2, v4, 0);
          sub_1002F34F8(v68, @"timeInFieldMilestone", 6, 1u, (uint64_t)&v391 + 8, v4, 0);
          break;
        case 12:
          if (v10 >= 0xA1)
          {
            v69 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B588(v69, v70, v71, v72, v73, v74, v75, v76);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          if (BYTE14(v387[0]) == 3)
          {
            if (*(_DWORD *)(v6 + 138))
            {
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
                sub_10066B4BC();
              }
            }

            else
            {
              v325 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v6 + 130) / 0x3CuLL));
              [v4 setObject:v325 forKeyedSubscript:@"budMileage"];

              v326 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)v387 + 10) / 0xE10uLL));
              [v4 setObject:v326 forKeyedSubscript:@"duration"];

              v327 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  3LL));
              [v4 setObject:v327 forKeyedSubscript:@"metricVersion"];

              v328 = BYTE3(v387[1]);
              v329 = BYTE4(v387[1]);
              v330 = BYTE3(v387[1]) + (unint64_t)BYTE4(v387[1]);
              v331 = BYTE5(v387[1]);
              v332 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  v330 + BYTE5(v387[1]) != 0));
              [v4 setObject:v332 forKeyedSubscript:@"hasSuccess"];

              v333 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v328));
              [v4 setObject:v333 forKeyedSubscript:@"successTableTop"];

              v334 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v329));
              [v4 setObject:v334 forKeyedSubscript:@"successWired"];

              v335 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v331));
              [v4 setObject:v335 forKeyedSubscript:@"successWireless"];

              v336 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE6(v387[1])));
              [v4 setObject:v336 forKeyedSubscript:@"failureStaticTableTop"];

              v337 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE11(v387[1])));
              [v4 setObject:v337 forKeyedSubscript:@"failureStaticWired"];

              v338 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  LOBYTE(v387[2])));
              [v4 setObject:v338 forKeyedSubscript:@"failureStaticWireless"];

              v339 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE7(v387[1])));
              [v4 setObject:v339 forKeyedSubscript:@"failureGyroTableTop"];

              v340 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE12(v387[1])));
              [v4 setObject:v340 forKeyedSubscript:@"failureGyroWired"];

              v341 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE1(v387[2])));
              [v4 setObject:v341 forKeyedSubscript:@"failureGyroWireless"];

              v342 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE8(v387[1])));
              [v4 setObject:v342 forKeyedSubscript:@"failureFlushTableTop"];

              v343 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE13(v387[1])));
              [v4 setObject:v343 forKeyedSubscript:@"failureFlushWired"];

              v344 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE2(v387[2])));
              [v4 setObject:v344 forKeyedSubscript:@"failureFlushWireless"];

              v345 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE9(v387[1])));
              [v4 setObject:v345 forKeyedSubscript:@"failureJammedTableTop"];

              v346 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE14(v387[1])));
              [v4 setObject:v346 forKeyedSubscript:@"failureJammedWired"];

              v347 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE3(v387[2])));
              [v4 setObject:v347 forKeyedSubscript:@"failureJammedWireless"];

              v348 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE10(v387[1])));
              [v4 setObject:v348 forKeyedSubscript:@"failureUserTableTop"];

              v349 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  HIBYTE(v387[1])));
              [v4 setObject:v349 forKeyedSubscript:@"failureUserWired"];

              v350 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE4(v387[2])));
              [v4 setObject:v350 forKeyedSubscript:@"failureUserWireless"];

              v351 = fabs((double)*(__int16 *)((char *)&v387[2] + 5) * 0.00390625);
              v352 = fabs((double)*(__int16 *)((char *)&v387[2] + 11) * 0.00390625);
              if (v351 < v352) {
                v351 = v352;
              }
              v353 = fabs((double)*(__int16 *)((char *)&v387[2] + 7) * 0.00390625);
              v354 = fabs((double)*(__int16 *)((char *)&v387[2] + 13) * 0.00390625);
              if (v353 >= v354) {
                v355 = v353;
              }
              else {
                v355 = v354;
              }
              v356 = fabs((double)*(__int16 *)((char *)&v387[2] + 9) * 0.00390625);
              v357 = fabs((double)*(__int16 *)((char *)&v387[2] + 15) * 0.00390625);
              if (v356 >= v357) {
                v358 = v356;
              }
              else {
                v358 = v357;
              }
              v359 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v351));
              [v4 setObject:v359 forKeyedSubscript:@"deltaGyttX"];

              v360 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v355));
              [v4 setObject:v360 forKeyedSubscript:@"deltaGyttY"];

              v361 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v358));
              [v4 setObject:v361 forKeyedSubscript:@"deltaGyttZ"];

              if (v330 == -v331) {
                v362 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", BYTE3(v387[3])));
              }
              else {
                v362 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", BYTE1(v387[3])));
              }
              v363 = (void *)v362;
              [v4 setObject:v362 forKeyedSubscript:@"maxCalibrationTemperature"];

              if (v330 == -v331) {
                v364 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", BYTE4(v387[3])));
              }
              else {
                v364 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", BYTE2(v387[3])));
              }
              v365 = (void *)v364;
              [v4 setObject:v364 forKeyedSubscript:@"minCalibrationTemperature"];

              v366 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", BYTE5(v387[3])));
              [v4 setObject:v366 forKeyedSubscript:@"maxSessionTemperature"];

              v367 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", BYTE6(v387[3])));
              [v4 setObject:v367 forKeyedSubscript:@"minSessionTemperature"];

              v368 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (SDWORD2(v387[3]) / 3600)));
              [v4 setObject:v368 forKeyedSubscript:@"calibrationInterval"];

              v369 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  HIDWORD(v387[3])));
              [v4 setObject:v369 forKeyedSubscript:@"numberOfInEarSessionFirstCal"];

              v370 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v388));
              [v4 setObject:v370 forKeyedSubscript:@"numberOfInEarSessionFirstJam"];

              v371 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  DWORD1(v388)));
              [v4 setObject:v371 forKeyedSubscript:@"numberOfJams"];

              v372 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  DWORD2(v388) / 0xE10uLL));
              [v4 setObject:v372 forKeyedSubscript:@"durationLastJam"];

              v373 = WORD6(v388);
              v374 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", BYTE12(v388) & 1));
              [v4 setObject:v374 forKeyedSubscript:@"isFirstCalibration"];

              v375 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (v373 >> 1) & 1));
              [v4 setObject:v375 forKeyedSubscript:@"hasDMSession"];

              v376 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (v373 >> 2) & 1));
              [v4 setObject:v376 forKeyedSubscript:@"hasGyroJammedSession"];

              v377 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (v373 >> 3) & 1));
              [v4 setObject:v377 forKeyedSubscript:@"isFirstGyroJammed"];

              v378 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (v373 >> 8) & 1));
              [v4 setObject:v378 forKeyedSubscript:@"isCalibrated"];

              v379 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (v373 >> 9) & 1));
              [v4 setObject:v379 forKeyedSubscript:@"hasBeenGyroJammed"];

              v380 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (v373 >> 10) & 1));
              [v4 setObject:v380 forKeyedSubscript:@"isCurrentlyJammed"];

              v381 = @"Unknown";
              if (v373 >> 12 == 2) {
                v381 = @"Sovereign2";
              }
              if (v373 >> 12 == 1) {
                v382 = @"Sovereign";
              }
              else {
                v382 = v381;
              }
              [v4 setObject:v382 forKeyedSubscript:@"sensorModel"];
              v383 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v373 & 0x8F0));
              [v4 setObject:v383 forKeyedSubscript:@"status_unused"];

              sub_1002F34F8(v384, @"unused_bytes_1", 32, 1u, (uint64_t)&v388 + 14, v4, 0);
              sub_1002F34F8(v385, @"unused_bytes_2", 4, 4u, (uint64_t)&v391, v4, 0);
            }
          }

          else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
          {
            sub_10066B524();
          }

          break;
        case 13:
          if (v10 >= 0xA1)
          {
            v77 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B5F8(v77, v78, v79, v80, v81, v82, v83, v84);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v387[0])));
          [v4 setObject:v85 forKeyedSubscript:@"swipe_prediction_duration"];

          v86 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD6(v387[0])));
          [v4 setObject:v86 forKeyedSubscript:@"swipe_start"];

          v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SHIWORD(v387[0])));
          [v4 setObject:v87 forKeyedSubscript:@"swipe_end"];

          v88 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SLOWORD(v387[1])));
          [v4 setObject:v88 forKeyedSubscript:@"touch_baseline_1"];

          v89 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD1(v387[1])));
          [v4 setObject:v89 forKeyedSubscript:@"touch_baseline_2"];

          v90 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD2(v387[1])));
          [v4 setObject:v90 forKeyedSubscript:@"touch_baseline_3"];

          v91 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD3(v387[1])));
          [v4 setObject:v91 forKeyedSubscript:@"force_peak"];

          v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD4(v387[1])));
          [v4 setObject:v92 forKeyedSubscript:@"touch_peak_1"];

          v93 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD5(v387[1])));
          [v4 setObject:v93 forKeyedSubscript:@"touch_peak_2"];

          v94 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD6(v387[1])));
          [v4 setObject:v94 forKeyedSubscript:@"touch_peak_3"];

          v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[1] + 14)));
          [v4 setObject:v95 forKeyedSubscript:@"volume_feature_enabled"];

          v96 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[2] + 2)));
          [v4 setObject:v96 forKeyedSubscript:@"consecutive_swipe_prediction_interval"];

          v97 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[2] + 6)));
          [v4 setObject:v97 forKeyedSubscript:@"num_consecutive_swipes"];

          v98 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[2] + 10)));
          [v4 setObject:v98 forKeyedSubscript:@"consecutive_swipe_pattern"];

          v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[2] + 14)));
          [v4 setObject:v99 forKeyedSubscript:@"num_freq_hops"];

          v100 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[3] + 2)));
          [v4 setObject:v100 forKeyedSubscript:@"percentage_time_on_high_freq"];

          v101 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)((char *)&v387[3] + 6)));
          [v4 setObject:v101 forKeyedSubscript:@"max_noise_low_freq"];

          v102 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)((char *)&v387[3] + 10)));
          [v4 setObject:v102 forKeyedSubscript:@"max_noise_high_freq"];

          sub_1002F34F8(v103, @"unused_bytes_1", 12, 4u, (uint64_t)&v387[3] + 14, v4, 0);
          sub_1002F34F8(v104, @"unused_bytes_2", 4, 4u, (uint64_t)&v391, v4, 0);
          break;
        case 14:
          if (v10 >= 0xA1)
          {
            v230 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B668(v230, v231, v232, v233, v234, v235, v236, v237);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v238 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD5(v387[0])));
          [v4 setObject:v238 forKeyedSubscript:@"force_cap_c2_delta"];

          v239 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD6(v387[0])));
          [v4 setObject:v239 forKeyedSubscript:@"force_cap_c2"];

          v240 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SHIWORD(v387[0])));
          [v4 setObject:v240 forKeyedSubscript:@"force_cap_c1_delta"];

          v241 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SLOWORD(v387[1])));
          [v4 setObject:v241 forKeyedSubscript:@"force_cap_c1"];

          v242 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD1(v387[1])));
          [v4 setObject:v242 forKeyedSubscript:@"water_ingress_count_high_cap"];

          v243 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithShort:]( &OBJC_CLASS___NSNumber,  "numberWithShort:",  SWORD2(v387[1])));
          [v4 setObject:v243 forKeyedSubscript:@"water_ingress_count_low_cap"];

          sub_1002F34F8(v244, @"unused_bytes_1", 4, 2u, (uint64_t)&v387[1] + 6, v4, 0);
          sub_1002F34F8(v245, @"unused_bytes_2", 20, 4u, (uint64_t)&v387[1] + 14, v4, 0);
          sub_1002F34F8(v246, @"unused_bytes_3", 4, 4u, (uint64_t)&v391, v4, 0);
          break;
        case 15:
          if (v10 >= 0xA1)
          {
            v105 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B6D8(v105, v106, v107, v108, v109, v110, v111, v112);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v113 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v387[0])));
          [v4 setObject:v113 forKeyedSubscript:@"timeSpentAtLowerSoC"];

          v114 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD6(v387[0])));
          [v4 setObject:v114 forKeyedSubscript:@"timeSpentAtHigherSoC"];

          v115 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE14(v387[0])));
          [v4 setObject:v115 forKeyedSubscript:@"engagementEvents"];

          v116 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  HIBYTE(v387[0])));
          [v4 setObject:v116 forKeyedSubscript:@"underchargeEvents"];

          v117 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  LOBYTE(v387[1])));
          [v4 setObject:v117 forKeyedSubscript:@"chargingEvents"];

          v118 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE1(v387[1])));
          [v4 setObject:v118 forKeyedSubscript:@"budSocAtLastEngagement"];

          v119 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD1(v387[1])));
          [v4 setObject:v119 forKeyedSubscript:@"medianTimeBetweenUses"];

          v120 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD2(v387[1])));
          [v4 setObject:v120 forKeyedSubscript:@"stdDevTimeBetweenUses"];

          v121 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD3(v387[1])));
          [v4 setObject:v121 forKeyedSubscript:@"featureEnabledStatus"];

          sub_1002F34F8(v122, @"unused_bytes_1", 3, 2u, (uint64_t)&v387[1] + 8, v4, 0);
          sub_1002F34F8(v123, @"unused_bytes_2", 20, 4u, (uint64_t)&v387[1] + 14, v4, 0);
          sub_1002F34F8(v124, @"unused_bytes_3", 4, 4u, (uint64_t)&v391, v4, 0);
          break;
        case 16:
          if (v10 >= 0xA1)
          {
            v247 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B748(v247, v248, v249, v250, v251, v252, v253, v254);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v255 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)v387 + 10)));
          [v4 setObject:v255 forKeyedSubscript:@"nvram_erase_count"];

          v256 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)v387 + 14)));
          [v4 setObject:v256 forKeyedSubscript:@"nvram_corruption_single_bank"];

          v257 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[1] + 2)));
          [v4 setObject:v257 forKeyedSubscript:@"nvram_corruption_both_banks"];

          v258 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[1] + 6)));
          [v4 setObject:v258 forKeyedSubscript:@"syscfg_corruption_count"];

          if (BYTE1(v386) >= 0xAu)
          {
            v260 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  HIBYTE(v387[1])));
            [v4 setObject:v260 forKeyedSubscript:@"has_limited_logging_ever_on"];

            v261 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE14(v387[1])));
            [v4 setObject:v261 forKeyedSubscript:@"vendor_id"];
          }

          sub_1002F34F8(v259, @"unused_bytes_1", 2, 2u, (uint64_t)&v387[1] + 10, v4, 0);
          sub_1002F34F8(v262, @"unused_bytes_2", 20, 4u, (uint64_t)&v387[2], v4, 0);
          sub_1002F34F8(v263, @"unused_bytes_3", 4, 4u, (uint64_t)&v391, v4, 0);
          break;
        case 17:
          if (v10 >= 0xA1)
          {
            v125 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B7B8(v125, v126, v127, v128, v129, v130, v131, v132);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v133 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v387[0])));
          [v4 setObject:v133 forKeyedSubscript:@"start_unloaded_vbat_mv"];

          v134 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD6(v387[0])));
          [v4 setObject:v134 forKeyedSubscript:@"start_loaded_vbat_mv"];

          v135 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  HIWORD(v387[0])));
          [v4 setObject:v135 forKeyedSubscript:@"unloaded_vbat_mv"];

          v136 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  LOWORD(v387[1])));
          [v4 setObject:v136 forKeyedSubscript:@"loaded_vbat_mv"];

          v137 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)((char *)&v387[1] + 2)));
          [v4 setObject:v137 forKeyedSubscript:@"time_elapsed_us"];

          sub_1002F34F8(v138, @"unused_bytes_1", 2, 2u, (uint64_t)&v387[1] + 10, v4, 0);
          sub_1002F34F8(v139, @"unused_bytes_2", 20, 4u, (uint64_t)&v387[1] + 14, v4, 0);
          sub_1002F34F8(v140, @"unused_bytes_3", 4, 4u, (uint64_t)&v391, v4, 0);
          break;
        case 18:
          if (v10 >= 0xA1)
          {
            v264 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B828(v264, v265, v266, v267, v268, v269, v270, v271);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v272 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)((char *)v387 + 11)));
          [v4 setObject:v272 forKeyedSubscript:@"duration"];

          v273 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE10(v387[0])));
          [v4 setObject:v273 forKeyedSubscript:@"user_awake"];

          v274 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE13(v387[0])));
          [v4 setObject:v274 forKeyedSubscript:@"hour"];

          sub_1002F34F8(v275, @"unused_bytes_1", 48, 2u, (uint64_t)v387 + 14, v4, 0);
          sub_1002F34F8(v276, @"unused_bytes_2", 4, 4u, (uint64_t)&v391, v4, 0);
          break;
        case 19:
          if (v10 >= 0xA1)
          {
            v277 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
              sub_10066B898(v277, v278, v279, v280, v281, v282, v283, v284);
            }
            int v6 = *v5;
          }

          v391 = 0u;
          v389 = 0u;
          memset(v390, 0, sizeof(v390));
          v388 = 0u;
          v386 = 0u;
          memset(v387, 0, sizeof(v387));
          memcpy(&v386, (const void *)v6, v10);
          v285 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v387[0])));
          [v4 setObject:v285 forKeyedSubscript:@"num_cd_trigger"];

          v286 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD6(v387[0])));
          [v4 setObject:v286 forKeyedSubscript:@"num_false_start"];

          v287 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  HIWORD(v387[0])));
          [v4 setObject:v287 forKeyedSubscript:@"num_false_transition"];

          v288 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  LOBYTE(v387[1])));
          [v4 setObject:v288 forKeyedSubscript:@"num_cd_user_setting_off"];

          v289 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE1(v387[1])));
          [v4 setObject:v289 forKeyedSubscript:@"num_cd_user_setting_on"];

          v290 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD1(v387[1])));
          [v4 setObject:v290 forKeyedSubscript:@"num_cd_reset"];

          v291 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD2(v387[1])));
          [v4 setObject:v291 forKeyedSubscript:@"num_cd_pause"];

          v292 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD3(v387[1])));
          [v4 setObject:v292 forKeyedSubscript:@"num_cd_unpause"];

          v293 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD4(v387[1])));
          [v4 setObject:v293 forKeyedSubscript:@"num_cd_pause_siri"];

          v294 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD5(v387[1])));
          [v4 setObject:v294 forKeyedSubscript:@"num_cd_pause_hfp"];

          v295 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  WORD6(v387[1])));
          [v4 setObject:v295 forKeyedSubscript:@"num_cd_pause_sourcepause"];

          v296 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[1] + 14)));
          [v4 setObject:v296 forKeyedSubscript:@"total_cd_pause_duration_s"];

          v297 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[2] + 2)));
          [v4 setObject:v297 forKeyedSubscript:@"total_cd_user_setting_on_duration_s"];

          v298 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[2] + 6)));
          [v4 setObject:v298 forKeyedSubscript:@"total_cd_session_duration_s"];

          v299 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v387[2] + 10)));
          [v4 setObject:v299 forKeyedSubscript:@"total_primary_use_duration_s"];

          v300 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE14(v387[2])));
          [v4 setObject:v300 forKeyedSubscript:@"qad_sh_600_1200_ms"];

          v301 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  HIBYTE(v387[2])));
          [v4 setObject:v301 forKeyedSubscript:@"qad_sh_1200_1800_ms"];

          v302 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  LOBYTE(v387[3])));
          [v4 setObject:v302 forKeyedSubscript:@"qad_sh_1800_2400_ms"];

          v303 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE1(v387[3])));
          [v4 setObject:v303 forKeyedSubscript:@"qad_sh_2400_3000_ms"];

          v304 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE2(v387[3])));
          [v4 setObject:v304 forKeyedSubscript:@"qad_sh_3200_3600_ms"];

          v305 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE3(v387[3])));
          [v4 setObject:v305 forKeyedSubscript:@"qad_sh_3600_4200_ms"];

          v306 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE4(v387[3])));
          [v4 setObject:v306 forKeyedSubscript:@"qad_md_600_1200_ms"];

          v307 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE5(v387[3])));
          [v4 setObject:v307 forKeyedSubscript:@"qad_md_1200_1800_ms"];

          v308 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE6(v387[3])));
          [v4 setObject:v308 forKeyedSubscript:@"qad_md_1800_2400_ms"];

          v309 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE7(v387[3])));
          [v4 setObject:v309 forKeyedSubscript:@"qad_md_2400_3000_ms"];

          v310 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE8(v387[3])));
          [v4 setObject:v310 forKeyedSubscript:@"qad_md_3200_3600_ms"];

          v311 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE9(v387[3])));
          [v4 setObject:v311 forKeyedSubscript:@"qad_md_3600_4200_ms"];

          v312 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE10(v387[3])));
          [v4 setObject:v312 forKeyedSubscript:@"qad_lg_600_1200_ms"];

          v313 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE11(v387[3])));
          [v4 setObject:v313 forKeyedSubscript:@"qad_lg_1200_1800_ms"];

          v314 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE12(v387[3])));
          [v4 setObject:v314 forKeyedSubscript:@"qad_lg_1800_2400_ms"];

          v315 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE13(v387[3])));
          [v4 setObject:v315 forKeyedSubscript:@"qad_lg_2400_3000_ms"];

          v316 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE14(v387[3])));
          [v4 setObject:v316 forKeyedSubscript:@"qad_lg_3200_3600_ms"];

          v317 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  HIBYTE(v387[3])));
          [v4 setObject:v317 forKeyedSubscript:@"qad_lg_3600_4200_ms"];

          v318 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)v390 + 14)));
          [v4 setObject:v318 forKeyedSubscript:@"sw_version_ext"];

          v319 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v390[1] + 2)));
          [v4 setObject:v319 forKeyedSubscript:@"bud_mileage"];

          v320 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v390[1] + 6)));
          [v4 setObject:v320 forKeyedSubscript:@"feature_flags"];

          v321 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)((char *)&v390[1] + 10)));
          [v4 setObject:v321 forKeyedSubscript:@"error_code_ext"];

          v322 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  HIWORD(v390[1])));
          [v4 setObject:v322 forKeyedSubscript:@"hw_version"];

          sub_1002F34F8(v323, @"unused_bytes_1", 23, 2u, (uint64_t)&v388, v4, 0);
          sub_1002F34F8(v324, @"unused_bytes_2", 4, 2u, (uint64_t)&v391, v4, 0);
          break;
        default:
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
            sub_10066B22C();
          }
          break;
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_10066B908();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10066B96C();
  }
}

  reply = xpc_dictionary_create_reply(xdict);
  __int128 v19 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v17);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v19);
    xpc_release(v19);
  }

  return sub_100242FAC((uint64_t)v21);
}

  reply = xpc_dictionary_create_reply(xdict);
  __int128 v19 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v17);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v19);
    xpc_release(v19);
  }

  return sub_100242FAC((uint64_t)v21);
}

  reply = xpc_dictionary_create_reply(xdict);
  __int128 v19 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v17);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v19);
    xpc_release(v19);
  }

  return sub_100242FAC((uint64_t)v21);
}

  unsigned int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFFB8) {
      id v12 = "enabled";
    }
    else {
      id v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for Low Power Scan with Limited RSSI Reading %s",  buf,  0xCu);
  }

  id v8 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = "disabled";
    if (v3) {
      id v9 = "enabled";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "BT chip support for Scan Core : %s",  (uint8_t *)&buf,  0xCu);
  }

  __int128 v19 = 0;
  uint64_t v10 = sub_1002E6E00();
  sub_10002418C(&buf, "ScanCore");
  sub_10002418C(__p, "EnableScanCore");
  unsigned int v11 = (*(uint64_t (**)(uint64_t, __int128 *, void **, char *))(*(void *)v10 + 72LL))(v10, &buf, __p, &v19);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0)
  {
    operator delete((void *)buf);
    if (!v11) {
      goto LABEL_42;
    }
  }

  else if (!v11)
  {
    goto LABEL_42;
  }

  id v12 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (v19) {
      id v13 = "Enabled";
    }
    else {
      id v13 = "Disabled";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Overriding EnableScanCore with %s",  (uint8_t *)&buf,  0xCu);
  }

  if (v19) {
    unsigned __int8 v14 = v3;
  }
  else {
    unsigned __int8 v14 = 0;
  }
  byte_1008EFFD8 = v14;
LABEL_42:
  uint64_t v15 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFFD8) {
      uint64_t v16 = "enabled";
    }
    else {
      uint64_t v16 = "disabled";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Support for Scan Core is %s",  (uint8_t *)&buf,  0xCu);
  }

  unsigned int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFFE8) {
      id v12 = "enabled";
    }
    else {
      id v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for new LE non-Connection Stats V1 scan is %s",  buf,  0xCu);
  }

  unsigned int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F01A8) {
      id v12 = "enabled";
    }
    else {
      id v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "support for Get Scan Stats is %s", buf, 0xCu);
  }

  sub_100242FAC((uint64_t)v31);
}

  __int128 v20 = (os_log_s *)qword_1008F7628;
  if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
  {
    id v21 = *(void *)(a1 + 88);
    id v22 = *(void *)(a1 + 360);
    v46 = 138412546;
    v47 = v21;
    v48 = 2112;
    v49 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice session:%@ Fast LE Connection devices:%@",  (uint8_t *)&v46,  0x16u);
  }

  return v12;
}

  uint64_t v16 = *(_DWORD *)(a1 + 256);
  id v17 = *(double *)(a1 + 272);
  uint64_t v18 = vcvtpd_u64_f64((double)(1000 * v16) * 1024.0 / v17 * 0.125);
  *(_DWORD *)(a1 + 252) = v18;
  __int128 v19 = *(_DWORD *)(a1 + 248);
  __int128 v20 = v19 - 12;
  if (v19 - 12 < v18)
  {
    uint64_t v16 = vcvtmd_u64_f64(v17 * (double)(8 * v20) * 0.0009765625 / 1000.0);
    *(_DWORD *)(a1 + 252) = v20;
    *(_DWORD *)(a1 + 256) = v16;
    uint64_t v18 = v19 - 12;
  }

  *(_DWORD *)(a1 + 260) = v18 + 12 <= v19;
  id v21 = 0.0;
  if (v18 + 12 <= v19) {
    id v21 = 1.0;
  }
  id v22 = (float)((float)(v21 * 1000000.0) * 1024.0) / v17;
  *(double *)(a1 + 280) = v22;
  *(_DWORD *)(a1 + 28_Block_object_dispose(va, 8) = (v22 * 6.0);
  id v23 = (os_log_s *)qword_1008F7558;
  if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134219776;
    if (v18 + 12 > v19) {
      uint64_t v24 = 0;
    }
    else {
      uint64_t v24 = v18 + 12;
    }
    *(double *)&buf[4] = v17 / 1000.0;
    uint64_t v29 = 1024;
    uint64_t v30 = v16;
    __int128 v31 = 1024;
    __int128 v32 = v18 + 12 <= v19;
    __int128 v33 = 1024;
    __int128 v34 = 12;
    __int128 v35 = 1024;
    __int128 v36 = v18;
    __int128 v37 = 1024;
    uint64_t v38 = v24;
    v39 = 1024;
    v40 = v19;
    v41 = 2048;
    v42 = v22 / 1000.0;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "A2DP configured at %2.1f KHz. Codec: AAC-LC, VBR max: %d kbps. %d frames * (%d+%d) bytes = %d per RTP (max=%d) every %.2f ms",  buf,  0x3Au);
  }

  v107 = 0;
  unsigned __int8 v14 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENOverrideScanWithDuplicatesDurationInMS");
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v14 + 88LL))(v14, buf, __p, &v107);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v15) {
      goto LABEL_31;
    }
  }

  else if (!v15)
  {
    goto LABEL_31;
  }

  uint64_t v16 = v107;
  *(_WORD *)(a1 + 214) = v107;
  id v17 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Overriding fNextScanWithDuplicatesDurationInMs = %d ",  buf,  8u);
  }

      if (__p)
      {
        __int128 v19 = (char *)__p;
        operator delete(__p);
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
        sub_100677AE0();
      }
      return 7LL;
    }
  }

  return v4;
}

  *(_BYTE *)(a1 + 579) = 0;
  sub_100242FAC((uint64_t)v20);
  return 0LL;
}

  sub_100242FAC((uint64_t)v16);
  return v6;
}

  sub_100242FAC((uint64_t)v26);
  return v12;
}

      ++v17;
    }

    while (v17 != v16);
LABEL_31:
    if (v18 != v16)
    {
      id v13 = v18 - v14;
      if (v18 - v14 != -1) {
        goto LABEL_63;
      }
    }

    goto LABEL_33;
  }

  unsigned __int8 v14 = *(_BYTE **)(a1 + 80);
  uint64_t v15 = *(void *)(a1 + 88);
  if (v15) {
    goto LABEL_21;
  }
LABEL_33:
  if ((v4 & 0x80) != 0)
  {
    id v22 = *(_BYTE **)(a1 + 80);
    id v23 = *(void *)(a1 + 88);
    if (!v23)
    {
LABEL_49:
      if ((v4 & 0x80) != 0)
      {
        uint64_t v30 = *(void *)(a1 + 80);
        __int128 v31 = *(void *)(a1 + 88);
      }

      else
      {
        uint64_t v30 = a1 + 80;
        __int128 v31 = *(unsigned __int8 *)(a1 + 103);
      }

      if (v31 >= 1)
      {
        __int128 v32 = (_BYTE *)(v30 + v31);
        __int128 v33 = (const void *)v30;
        do
        {
          __int128 v34 = memchr(v33, 45, v31);
          if (!v34) {
            break;
          }
          if (*v34 == 45)
          {
            if (v34 != v32)
            {
              id v13 = (std::string::size_type)&v34[-v30];
              if (&v34[-v30] != (_BYTE *)-1LL) {
                goto LABEL_63;
              }
            }

            break;
          }

          __int128 v33 = v34 + 1;
          __int128 v31 = v32 - (_BYTE *)v33;
        }

        while (v32 - (_BYTE *)v33 >= 1);
      }

      if ((v4 & 0x80) != 0) {
        id v13 = *(void *)(a1 + 88);
      }
      else {
        id v13 = v4;
      }
      goto LABEL_63;
    }
  }

  else
  {
    id v22 = (_BYTE *)(a1 + 80);
    id v23 = *(unsigned __int8 *)(a1 + 103);
    if (!*(_BYTE *)(a1 + 103)) {
      goto LABEL_49;
    }
  }

  uint64_t v24 = &v22[v23];
  v25 = v22;
  v26 = v24;
  do
  {
    if (*v25 == 45)
    {
      v27 = &_mh_execute_header.magic + 1;
      while (v27 != 13)
      {
        if (&v25[v27] == v24) {
          goto LABEL_47;
        }
        id v28 = v25[v27];
        uint64_t v29 = aScalablepipe[v27++];
        if (v28 != v29) {
          goto LABEL_39;
        }
      }

      v26 = v25;
    }

        int v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      uint64_t v16 = [v4 countByEnumeratingWithState:&v17 objects:v25 count:16];
      uint64_t v5 = v16;
    }

    while (v16);
  }
}

  if (a1[14] && v7 == (void *)a1[23])
  {
    unsigned __int8 v14 = sub_1002E6E00();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 8LL))(v14))
    {
      uint64_t v15 = (os_log_s *)qword_1008F75E0;
      if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        id v21 = "destroyAgent";
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "%s - deleting fAgent as fHandleList size is 0",  buf,  0xCu);
      }
    }

    uint64_t v16 = a1[14];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    a1[14] = 0LL;
  }

  sub_100242F54((uint64_t)__p);
  return sub_100242FAC((uint64_t)__p);
}

  uint64_t v10 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyLowSupervisionTimeout");
  unsigned int v11 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v10 + 88LL))(v10, buf, __p, &v94);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v11) {
      goto LABEL_34;
    }
  }

  else if (!v11)
  {
    goto LABEL_34;
  }

  id v12 = v94;
  id v13 = (os_log_s *)qword_1008F7620;
  if ((v94 - 100) >= 0x7C9D && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v12;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "Override rejected latency supervisionTimeout:%d LeConnectionLatencyLow",  buf,  8u);
    LOWORD(v12) = v94;
    id v13 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 1084) = v12;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v12;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Override latency supervisionTimeout:%d LeConnectionLatencyLow",  buf,  8u);
  }

  __int128 v34 = *(void **)(a1 + 536);
  if (v34)
  {
    __int128 v35 = (uint64_t *)(a1 + 536);
    do
    {
      __int128 v36 = v34[4];
      __int128 v37 = v36 >= a3;
      if (v36 >= a3) {
        uint64_t v38 = v34;
      }
      else {
        uint64_t v38 = v34 + 1;
      }
      if (v37) {
        __int128 v35 = v34;
      }
      __int128 v34 = (void *)*v38;
    }

    while (*v38);
    if (v35 != (uint64_t *)(a1 + 536) && v35[4] <= a3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
      {
        v39 = sub_1005BFB9C(a2);
        v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
        sub_1006997C4(v40);
      }

      sub_1001FDBCC((uint64_t **)(a1 + 528), v35);
      operator delete(v35);
    }
  }

  v41 = *(void **)(a1 + 512);
  if (v41)
  {
    v42 = (uint64_t *)(a1 + 512);
    do
    {
      v43 = v41[4];
      v44 = v43 >= a3;
      if (v43 >= a3) {
        v45 = v41;
      }
      else {
        v45 = v41 + 1;
      }
      if (v44) {
        v42 = v41;
      }
      v41 = (void *)*v45;
    }

    while (*v45);
    if (v42 != (uint64_t *)(a1 + 512) && v42[4] <= a3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
      {
        v46 = sub_1005BFB9C(a2);
        v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
        sub_100699778(v47);
      }

      sub_1001FDBCC((uint64_t **)(a1 + 504), v42);
      operator delete(v42);
    }
  }

  if (uuid_is_null(uu))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10069974C();
    }
    goto LABEL_318;
  }

  if (a5 == 1) {
    sub_1005A9E84(a1, v200, a6, 0);
  }
  else {
    sub_1005A9F5C(a1, v200, a6, 0);
  }
  v48 = sub_100241F94(uu);
  v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
  v50 = sub_10058E250(a1, v49);

  if (v50)
  {
    memset(buf, 0, 37);
    uuid_unparse_upper(uu, (char *)buf);
    sub_10002418C(__p, (char *)buf);
    Current = CFAbsoluteTimeGetCurrent();
    sub_1005AA138(a1, (char *)__p, a6, Current - (double)(a9 / 0x3E8));
    if (v212 < 0) {
      operator delete(__p[0]);
    }
  }

  v52 = sub_100241F94(uu);
  v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
  sub_100591D60(a1, v53);

  v54 = sub_1005BD2B0(a1 + 456, uu);
  if (a1 + 464 != v54)
  {
    v55 = *(_DWORD *)(v54 + 44);
    v56 = (os_log_s *)qword_1008F7620;
    v57 = os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT);
    if (v55 == 8)
    {
      if (v57)
      {
        memset(buf, 0, 37);
        uuid_unparse_upper(uu, (char *)buf);
        sub_10002418C(v214, (char *)buf);
        v58 = SBYTE1(v215) >= 0 ? v214 : *(_BYTE **)v214;
        *(_DWORD *)v219 = 136446210;
        *(void *)v220 = v58;
        _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "Disconnected device %{public}s because we have too many paired devices",  v219,  0xCu);
        if (SBYTE1(v215) < 0) {
          operator delete(*(void **)v214);
        }
      }

      a6 = 4835LL;
    }

    else if (v57)
    {
      memset(buf, 0, 37);
      uuid_unparse_upper(uu, (char *)buf);
      sub_10002418C(v214, (char *)buf);
      v59 = SBYTE1(v215) >= 0 ? v214 : *(_BYTE **)v214;
      *(_DWORD *)v219 = 67109378;
      *(_DWORD *)v220 = v55;
      *(_WORD *)&v220[4] = 2082;
      *(void *)&v220[6] = v59;
      _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "Found override reason %d for device %{public}s ",  v219,  0x12u);
      if (SBYTE1(v215) < 0) {
        operator delete(*(void **)v214);
      }
    }

    sub_1005BE0C0((uint64_t **)(a1 + 456), uu);
  }

  v60 = *(void **)(a1 + 744);
  v61 = sub_100241F94(uu);
  v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
  v198 = [v60 containsObject:v62];

  v63 = *(void **)(a1 + 744);
  v64 = sub_100241F94(uu);
  v65 = (void *)objc_claimAutoreleasedReturnValue(v64);
  [v63 removeObject:v65];

  sub_10055CC88((uint64_t **)(a1 + 936), uu);
  v66 = *(uint64_t **)(a1 + 408);
  if (v66 == (uint64_t *)(a1 + 416))
  {
LABEL_86:
    v69 = 0;
  }

  else
  {
    while (v66[6] != a3)
    {
      v67 = (uint64_t *)v66[1];
      if (v67)
      {
        do
        {
          v68 = v67;
          v67 = (uint64_t *)*v67;
        }

        while (v67);
      }

      else
      {
        do
        {
          v68 = (uint64_t *)v66[2];
          uint64_t v29 = *v68 == (void)v66;
          v66 = v68;
        }

        while (!v29);
      }

      v66 = v68;
    }

    sub_1001FDBCC((uint64_t **)(a1 + 408), v66);
    operator delete(v66);
    v70 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "Found link-ready device calling disconnection notification",  buf,  2u);
    }

    v69 = 1;
  }

  v71 = *(uint64_t **)(a1 + 432);
  if (v71 != (uint64_t *)(a1 + 440))
  {
    while (v71[6] != a3)
    {
      v72 = (uint64_t *)v71[1];
      if (v72)
      {
        do
        {
          v73 = v72;
          v72 = (uint64_t *)*v72;
        }

        while (v72);
      }

      else
      {
        do
        {
          v73 = (uint64_t *)v71[2];
          uint64_t v29 = *v73 == (void)v71;
          v71 = v73;
        }

        while (!v29);
      }

      v71 = v73;
    }

    sub_1001FDBCC((uint64_t **)(a1 + 432), v71);
    operator delete(v71);
  }

  id v12 = sub_1002E6E00();
  sub_10002418C(buf, "ADVBUFF");
  sub_10002418C(__p, "UseDebugTypes");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(void *)v12 + 72LL))( v12,  buf,  __p,  a1 + 2104))
  {
    id v13 = *(unsigned __int8 *)(a1 + 2104);
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    if (v13)
    {
      unsigned __int8 v14 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Warning: Using debug types for ADV buffer",  buf,  2u);
      }
    }
  }

  else
  {
    if (v140 < 0) {
      operator delete(__p[0]);
    }
    if ((v142[3] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  v138 = 0;
  uint64_t v15 = sub_1002E6E00();
  sub_10002418C(buf, "ADVBUFF");
  sub_10002418C(__p, "DisableENADVBuffers");
  uint64_t v16 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v15 + 72LL))(v15, buf, __p, &v138);
  if (v138) {
    id v17 = v16;
  }
  else {
    id v17 = 0;
  }
  if (v140 < 0) {
    operator delete(__p[0]);
  }
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v17) {
      goto LABEL_46;
    }
  }

  else if (!v17)
  {
    goto LABEL_46;
  }

  *(_BYTE *)(a1 + 1792) = 0;
  uint64_t v18 = (os_log_s *)qword_1008F76D8;
  if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Disabling EN ADV Buffers for this platform",  buf,  2u);
  }
    }

    else
    {
      int v6 = 0LL;
    }
  }

  return v6;
}
    }

    else
    {
      int v6 = 0LL;
    }
  }

  return v6;
}
    }

    else
    {
      uint64_t v5 = 0LL;
    }
  }

  return v5;
}

  id v17 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1005BFC20((uint64_t)v4, (std::stringbuf::string_type *)dst);
    uint64_t v18 = (SBYTE7(v97) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
    *(_DWORD *)buf = 136446210;
    v87 = (std::stringbuf::string_type *)v18;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Could not find keys for device %{public}s",  buf,  0xCu);
    if (SBYTE7(v97) < 0) {
      operator delete(*(void **)dst);
    }
  }

LABEL_32:
              id v8 = v42;
              uint64_t v10 = v43;
              unsigned int v11 = v41;
            }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008810C8);
  }
  if (*((_BYTE *)off_1008D60A8 + 76))
  {
    WORD2(__s1) = 0;
    LODWORD(__s1) = 0;
    sub_100431644((uint64_t)off_1008D60A8, (uint64_t)&__s1);
    id v23 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &__s1, 6LL);
    -[CBControllerInfo setHardwareAddressData:](v3, "setHardwareAddressData:", v23);
  }

  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(-[CBStackControllerBTStack fastLEConnectionInfoData](self, "fastLEConnectionInfoData"));
  -[CBControllerInfo setFastLEConnectionInfoData:](v3, "setFastLEConnectionInfoData:", v24);

  -[CBControllerInfo setFastLEConnectionInfoVersion:]( v3,  "setFastLEConnectionInfoVersion:",  -[CBStackControllerBTStack fastLEConnectionInfoVersion](self, "fastLEConnectionInfoVersion"));
  v25 = sub_1000FCD0C();
  if (v25 >= 8)
  {
    v26 = 0;
    v27 = 0;
    LOBYTE(v2_Block_object_dispose(va, 8) = 0;
  }

  else
  {
    v26 = (0x3Eu >> v25) & 1;
    v27 = v25 == 0;
    id v28 = 0x201030303030304uLL >> (8 * v25);
  }

  -[CBControllerInfo setHciTransportType:](v3, "setHciTransportType:", (char)v28);
  -[CBControllerInfo setInquiryState:]( v3,  "setInquiryState:",  -[CBStackControllerBTStack inquiryState](self, "inquiryState"));
  uint64_t v29 = sub_1002E6E9C();
  -[CBControllerInfo setLeaVersion:](v3, "setLeaVersion:", sub_1002D0F8C(v29));
  -[CBControllerInfo setLmpVersion:](v3, "setLmpVersion:", byte_1008F6D20);
  -[CBControllerInfo setProductID:](v3, "setProductID:", sub_100360FE8());
  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100881108);
  }
  -[CBControllerInfo setSupportedServices:](v3, "setSupportedServices:", sub_1004293D0((uint64_t)off_1008D60C8));
  -[CBControllerInfo setVendorID:](v3, "setVendorID:", (unsigned __int16)sub_100360FE0());
  -[CBControllerInfo setVendorIDSource:](v3, "setVendorIDSource:", sub_1000A86F0());
  if (!v7)
  {
    __int128 v31 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v30 = -[NSString initWithFormat:]( v31,  "initWithFormat:",  @"v%u c%u",  (unsigned __int16)word_1008F6D22,  (unsigned __int16)word_1008F6D1E);
    -[CBControllerInfo setFirmwareVersion:](v3, "setFirmwareVersion:", v30);
    goto LABEL_45;
  }

  if (v7 - 2000 <= 0x7CF)
  {
    uint64_t v30 = (NSString *)objc_claimAutoreleasedReturnValue(-[CBControllerInfo firmwareName](v3, "firmwareName"));
    -[CBControllerInfo setFirmwareVersion:](v3, "setFirmwareVersion:", v30);
LABEL_45:

    return v3;
  }

  if (v7 <= 0x7CF)
  {
    __int128 v33 = sub_1002E6BF0();
    if (((v26 | v27) & (*(unsigned int (**)(uint64_t))(*(void *)v33 + 384LL))(v33)) == 1)
    {
      __int128 v34 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v30 = -[NSString initWithFormat:]( v34,  "initWithFormat:",  @"v%u c%u",  word_1008F6D22,  (unsigned __int16)word_1008F6D1E);
      -[CBControllerInfo setFirmwareVersion:](v3, "setFirmwareVersion:", v30);
      goto LABEL_45;
    }
  }

  __int128 v35 = objc_claimAutoreleasedReturnValue(-[CBControllerInfo firmwareName](v3, "firmwareName"));
  __int128 v36 = (const char *)[v35 UTF8String];
  if (v36) {
    __int128 v37 = v36;
  }
  else {
    __int128 v37 = "";
  }

  while (1)
  {
    uint64_t v38 = *(unsigned __int8 *)v37;
    if (!*v37 || v38 == 95) {
      break;
    }
    ++v37;
  }

  v39 = 0LL;
  v40 = v38 == 95;
  v41 = v38 == 95;
  if (v40) {
    v42 = v37 + 1;
  }
  else {
    v42 = v37;
  }
  while (1)
  {
    v43 = v37[v41 + v39];
    if (!v37[v41 + v39] || v43 == 95) {
      break;
    }
    ++v39;
  }

  if (v39 && v43 == 95)
  {
    v44 = -[NSString initWithBytes:length:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithBytes:length:encoding:",  v42,  v39,  4LL);
    -[CBControllerInfo setFirmwareVersion:](v3, "setFirmwareVersion:", v44);
  }

  v45 = (void *)objc_claimAutoreleasedReturnValue(-[CBControllerInfo firmwareVersion](v3, "firmwareVersion"));

  if (!v45)
  {
    v46 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v30 = -[NSString initWithFormat:](v46, "initWithFormat:", @"v%u", (unsigned __int16)word_1008F6D22);
    -[CBControllerInfo setFirmwareVersion:](v3, "setFirmwareVersion:", v30);
    goto LABEL_45;
  }

  return v3;
}

    sub_1000A5E04(a1, 0LL);
    if (!v7) {
      return 1LL;
    }
    goto LABEL_37;
  }

  if ((*(_BYTE *)(qword_1008DDE00 + 44) & 1) != 0)
  {
    id v8 = "AT+BCS=1\r";
    goto LABEL_25;
  }

              __int128 v19 = v46;
            }

            if (v19 != 64)
            {
              uint64_t v24 = *(void **)(v13 + 24);
              if (v24)
              {
                sub_1000B1838(v24);
                *(void *)(v13 + 24) = 0LL;
              }
            }

            if ((v20 - 3301) <= 7 && ((1 << (v20 + 27)) & 0x91) != 0)
            {
LABEL_98:
              sub_1000E93E8(a1, a2, v46, v20);
              return 0LL;
            }

            if (v20)
            {
              v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(qword_1008F29A0 + 16) + 8LL);
              if (v26) {
                v26(a1, a2, a3);
              }
              return 0LL;
            }

            __int128 v20 = 3301;
            if (v46 <= 0x2Fu)
            {
              switch((char)v46)
              {
                case 16:
                  v25 = *(void (**)(uint64_t, uint64_t, uint64_t))v6;
                  if (!*(void *)v6) {
                    goto LABEL_98;
                  }
                  goto LABEL_92;
                case 17:
                  uint64_t v30 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
                  if (!v30) {
                    goto LABEL_98;
                  }
                  goto LABEL_90;
                case 18:
                  v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16);
                  if (!v25) {
                    goto LABEL_98;
                  }
                  id v28 = v47;
                  goto LABEL_93;
                case 19:
                  __int128 v31 = *(void (**)(uint64_t, uint64_t, void, void))(v6 + 24);
                  if (!v31) {
                    goto LABEL_98;
                  }
                  goto LABEL_84;
                case 20:
                  __int128 v31 = *(void (**)(uint64_t, uint64_t, void, void))(v6 + 32);
                  if (!v31) {
                    goto LABEL_98;
                  }
                  goto LABEL_84;
                case 21:
                  __int128 v31 = *(void (**)(uint64_t, uint64_t, void, void))(v6 + 40);
                  if (!v31) {
                    goto LABEL_98;
                  }
                  goto LABEL_84;
                case 22:
                  __int128 v32 = *(void (**)(uint64_t, uint64_t, void, void, void))(v6 + 48);
                  if (!v32) {
                    goto LABEL_98;
                  }
                  v32(a1, a2, BYTE8(v46), BYTE9(v46), v47);
                  return 0LL;
                case 23:
                  __int128 v31 = *(void (**)(uint64_t, uint64_t, void, void))(v6 + 56);
                  if (!v31) {
                    goto LABEL_98;
                  }
LABEL_84:
                  v31(a1, a2, BYTE8(v46), v47);
                  break;
                case 24:
                  v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 64);
                  if (!v25) {
                    goto LABEL_98;
                  }
                  goto LABEL_92;
                case 32:
                  __int128 v33 = *(void (**)(uint64_t, uint64_t, void, void, void))(v6 + 72);
                  if (!v33) {
                    goto LABEL_98;
                  }
                  v33(a1, a2, *((void *)&v46 + 1), v47, *((void *)&v47 + 1));
                  break;
                default:
                  goto LABEL_98;
              }

              return 0LL;
            }

            if (v46 > 0x4Fu)
            {
              if (v46 > 0x73u)
              {
                if (v46 == 116)
                {
                  uint64_t v29 = *(void (**)(uint64_t, uint64_t, void, unint64_t, void))(v6 + 176);
                  if (!v29) {
                    goto LABEL_98;
                  }
                }

                else
                {
                  uint64_t v29 = *(void (**)(uint64_t, uint64_t, void, unint64_t, void))(v6 + 184);
                  if (!v29) {
                    goto LABEL_98;
                  }
                }

                v29(a1, a2, BYTE8(v46), (unint64_t)&v46 | 9, WORD1(v47));
                return 0LL;
              }

              if (v46 != 80)
              {
                v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 120);
                if (!v25) {
                  goto LABEL_98;
                }
                id v28 = WORD4(v46);
LABEL_93:
                v25(a1, a2, v28);
                return 0LL;
              }

              v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 192);
              if (!v25)
              {
                __int128 v20 = 3305;
                goto LABEL_98;
              }

      sub_100198640(v6, v17);
      return;
    }

    id v17 = sub_100197DE0(&v41, *(_WORD *)(v6 + 216) + 2, 8, *(_BYTE *)(v6 + 153));
    if ((_DWORD)v17) {
      goto LABEL_27;
    }
    if (HIBYTE(v42))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    }

    else
    {
      id v21 = WORD1(v42);
      id v22 = WORD2(v42);
      if (WORD1(v42) - WORD2(v42) > 1)
      {
        if (BYTE6(v42) == 2)
        {
          id v23 = v41;
          uint64_t v24 = (_BYTE *)(v41 + WORD2(v42));
          *uint64_t v24 = *(_BYTE *)(v6 + 216);
          v24[1] = *(_BYTE *)(v6 + 217);
          v25 = v22 + 2;
          v26 = *(unsigned __int16 *)(v6 + 216);
          if (v21 - (unsigned __int16)(v22 + 2) < (int)v26) {
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  880,  "ByteStream_NumReadBytesAvail(bs) >= (tracker->data.echoData.len)");
          }
          memmove((void *)(v23 + v25), *(const void **)(v6 + 208), v26);
          __int128 v20 = *(_WORD *)(v6 + 216) + v25;
LABEL_26:
          WORD2(v42) = v20;
          WORD1(v42) = v20;
          BYTE6(v42) = 15;
          id v17 = sub_1001980CC(a3, (uint64_t)&v41);
          if ((_DWORD)v17) {
            goto LABEL_27;
          }
LABEL_30:
          v40[1] = &v43;
          v40[0] = (const void *)8;
          __int128 v35 = sub_1001EDBA0(0x2Fu);
          __int128 v36 = sub_1001EE6E8((uint64_t)sub_100198E20, v40, *(unsigned __int16 *)(v35 + 6), (int *)(v43 + 176));
          if (!(_DWORD)v36) {
            return;
          }
          id v17 = v36;
          int v6 = v43;
          goto LABEL_32;
        }

        uint64_t v38 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_43:
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  879,  v38);
      }
    }

    uint64_t v38 = "ByteStream_NumReadBytesAvail(bs) >= 2";
    goto LABEL_43;
  }

      id v8 = "unknown";
      break;
    case 26:
      id v8 = (char *)sub_1002354F8(a1, a3);
      return sub_10002418C(a4, v8);
    case 28:
      uint64_t v5 = "unknown";
      unsigned __int8 v14 = a3;
      uint64_t v15 = "Front-to-Back";
      uint64_t v16 = a3 == 2;
      int v6 = "Back-to-Front";
LABEL_35:
      if (v16) {
        uint64_t v5 = v15;
      }
      int v7 = v14 == 1;
LABEL_5:
      if (v7) {
        id v8 = (char *)v6;
      }
      else {
        id v8 = (char *)v5;
      }
      return sub_10002418C(a4, v8);
    case 34:
      if (a3 > 2)
      {
        id v8 = "Invalid";
      }

      else
      {
        id v17 = off_100889170;
LABEL_40:
        id v8 = v17[a3];
      }

      break;
    case 36:
      if ((a3 & 0xF) != 0) {
        snprintf(__str, 0x100uLL, "Version: %u, endCallStatus: %s, endCall: %s, muteControlStatus: %s, muteControl: %s");
      }
      else {
        snprintf(__str, 0x100uLL, "Version: %u, endCallStatus: %s, endCall: %s");
      }
      return sub_10002418C(a4, __str);
    case 44:
      snprintf(__str, 0x100uLL, "Hearing aid enrolled: %s, enabled: %s");
      return sub_10002418C(a4, __str);
    case 46:
      snprintf(__str, 0x100uLL, "%u");
      return sub_10002418C(a4, __str);
    default:
      snprintf(__str, 0x100uLL, "0x%08X");
      return sub_10002418C(a4, __str);
  }

  return sub_10002418C(a4, v8);
}

    ++v8;
    uint64_t v5 = *a2;
    int v6 = a2[1];
    id v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v6 - (char *)*a2) >> 3);
    if (v9 <= v8) {
      return 1LL;
    }
  }

  while (*v14 == *v20)
  {
    ++v14;
    ++v20;
    if (!--v16) {
      goto LABEL_32;
    }
  }

  return 0LL;
}
        }

        uint64_t v24 = v86;
        v25 = (void *)v86[1];
        if (v25)
        {
          do
          {
            v26 = v25;
            v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            v26 = (void *)v24[2];
            v27 = *v26 == (void)v24;
            uint64_t v24 = v26;
          }

          while (!v27);
        }

        uint64_t v2 = v26;
        if (v26 == (void *)(a1 + 232)) {
          goto LABEL_39;
        }
      }

      id v17 = v4[27];
      v122 = 0u;
      v123 = 0u;
      v124 = 0u;
      v125 = 0u;
      int v6 = v17;
      uint64_t v18 = [v6 countByEnumeratingWithState:&v122 objects:v143 count:16];
      if (v18)
      {
        __int128 v19 = *(void *)v123;
        do
        {
          for (k = 0LL; k != v18; k = (char *)k + 1)
          {
            if (*(void *)v123 != v19) {
              objc_enumerationMutation(v6);
            }
            id v21 = *(void *)(*((void *)&v122 + 1) + 8LL * (void)k);
            id v22 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v21]);
            id v23 = [v22 opportunistic];

            if ((v23 & 1) == 0) {
              [v1 addObject:v21];
            }
          }

          uint64_t v18 = [v6 countByEnumeratingWithState:&v122 objects:v143 count:16];
        }

        while (v18);
      }

      goto LABEL_32;
    }

  CFDictionaryRemoveValue(v5, @"LinkKeyType");
  if ((a2 & 0x10) == 0)
  {
LABEL_17:
    if ((a2 & 0x20) == 0) {
      goto LABEL_18;
    }
    goto LABEL_34;
  }

  sub_100242FAC((uint64_t)v30);
  return v15;
}

      id v21 = 0LL;
      goto LABEL_50;
    }
  }

    sub_10036CFB0(a1, v9);
    goto LABEL_33;
  }

  *(_DWORD *)(v13 + 72_Block_object_dispose(va, 8) = 3;
  if (sub_1003D2B2C((uint64_t)v10, 13)
    && (uint64_t v15 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t, void))(*(void *)v15 + 792LL))(v15, 0LL))
    && sub_1003A46D4(v13 + 400) == 33023)
  {
    uint64_t v16 = 1;
    *(_BYTE *)(v13 + 704) = 1;
    *(_BYTE *)(v13 + 706) = 0;
  }

  else
  {
    uint64_t v16 = 0;
  }

  id v17 = (os_log_s *)qword_1008F7558;
  if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(v13 + 704)) {
      uint64_t v18 = "supported";
    }
    else {
      uint64_t v18 = "not supported";
    }
    *(_DWORD *)__p = 136315138;
    *(void *)&__p[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Dynamic Latency is %s", __p, 0xCu);
  }

  if (*(_BYTE *)(v13 + 704))
  {
    __int128 v19 = sub_1003A6D9C(v13 + 400);
    sub_10054F434(v13, v19);
  }

  if ((v16 & 1) != 0
    || (__int128 v20 = sub_1002E6E00(), ((*(uint64_t (**)(uint64_t))(*(void *)v20 + 528LL))(v20) & 1) == 0))
  {
    *(_BYTE *)(v13 + 712) = 1;
  }

  sub_1003747BC(a1, (uint64_t)v10);
  sub_10036F80C((uint64_t)a1, 0LL, v9, a4, v10);
LABEL_33:
  sub_100242FAC((uint64_t)v22);
  return 0LL;
}

      uint64_t v30 = *(void *)(a3 + 8);
      if (*(char *)(v30 + 39) < 0)
      {
        sub_100024238(&value[1], *(void **)(v30 + 16), *(void *)(v30 + 24));
      }

      else
      {
        *(_OWORD *)&value[1] = *(_OWORD *)(v30 + 16);
        v52 = *(void *)(v30 + 32);
      }

      if (SHIBYTE(v52) < 0)
      {
        __int128 v32 = *(void *)&value[3] == 15LL
           && **(void **)&value[1] == 0x20636972656E6547LL
           && *(void *)(*(void *)&value[1] + 7LL) == 0x72656B6361725420LL;
        operator delete(*(void **)&value[1]);
      }

      else
      {
        __int128 v32 = SHIBYTE(v52) == 15
           && *(void *)&value[1] == 0x20636972656E6547LL
           && *(void *)((char *)&value[2] + 3) == 0x72656B6361725420LL;
      }

      v25 = buf[23];
LABEL_55:
      if (v25 < 0)
      {
        operator delete(*(void **)buf);
        if (v32) {
          goto LABEL_75;
        }
      }

      else if (v32)
      {
        goto LABEL_75;
      }
    }

        id v22 = [v54 mutableCopy];
        id v23 = v22;
        if (v22) {
          uint64_t v24 = (NSMutableSet *)v22;
        }
        else {
          uint64_t v24 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        }
        v25 = *(void **)(a1 + 312);
        *(void *)(a1 + 312) = v24;

        *(_BYTE *)(a1 + 272) = -[NSKeyedUnarchiver decodeBoolForKey:](v56, "decodeBoolForKey:", @"isScanning");
        if ([*(id *)(a1 + 312) count] && !*(_BYTE *)(a1 + 272))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_ERROR)) {
            sub_100675F7C();
          }
          uint64_t v15 = 0LL;
        }

        else
        {
          *(_BYTE *)(a1 + 274) = -[NSKeyedUnarchiver decodeBoolForKey:]( v56,  "decodeBoolForKey:",  @"isContactTracingScan");
          v26 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
          v27 = *(void **)(a1 + 304);
          *(void *)(a1 + 304) = v26;

          sub_1003A0DAC(a1 + 280, *(void **)(a1 + 288));
          *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
          *(void *)(a1 + 296) = 0LL;
          *(void *)(a1 + 280) = a1 + 288;
          v79[0] = objc_opt_class(&OBJC_CLASS___NSSet);
          v79[1] = objc_opt_class(&OBJC_CLASS___NSData);
          id v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v79, 2LL));
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v28));
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( -[NSKeyedUnarchiver decodeObjectOfClasses:forKey:]( v56,  "decodeObjectOfClasses:forKey:",  v29,  @"peripherals"));

          sub_1003A0DFC(a1 + 416, *(void **)(a1 + 424));
          *(void *)(a1 + 424) = 0LL;
          *(void *)(a1 + 432) = 0LL;
          *(void *)(a1 + 416) = a1 + 424;
          if (v30)
          {
            __int128 v31 = objc_opt_class(&OBJC_CLASS___NSSet);
            if ((objc_opt_isKindOfClass(v30, v31) & 1) == 0)
            {
              if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_ERROR)) {
                sub_100675F50();
              }

              uint64_t v30 = 0LL;
            }
          }

          v60 = 0u;
          v61 = 0u;
          v58 = 0u;
          v59 = 0u;
          __int128 v32 = v30;
          __int128 v33 = [v32 countByEnumeratingWithState:&v58 objects:v78 count:16];
          if (v33)
          {
            __int128 v34 = *(void *)v59;
            while (2)
            {
              __int128 v35 = 0LL;
              do
              {
                if (*(void *)v59 != v34) {
                  objc_enumerationMutation(v32);
                }
                __int128 v36 = *(void **)(*((void *)&v58 + 1) + 8LL * (void)v35);
                __int128 v37 = objc_opt_class(&OBJC_CLASS___NSData);
                if ((objc_opt_isKindOfClass(v36, v37) & 1) == 0)
                {
                  if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_ERROR)) {
                    sub_100675F24();
                  }
                  goto LABEL_67;
                }

                if ([v36 length] == (id)16)
                {
                  uint64_t v38 = -[NSUUID initWithUUIDBytes:]( [NSUUID alloc], "initWithUUIDBytes:", [v36 bytes]);
                  if (qword_1008D67C8 != -1) {
                    dispatch_once(&qword_1008D67C8, &stru_100894590);
                  }
                  v39 = sub_1000B6578();
                  if (qword_1008D5F20 != -1) {
                    dispatch_once(&qword_1008D5F20, &stru_1008946D0);
                  }
                  v40 = sub_10061C0F8(qword_1008D5F18, v38);
                  v41 = (os_log_s *)qword_1008F7680;
                  if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT))
                  {
                    v42 = *(NSKeyedUnarchiver **)(a1 + 88);
                    *(_DWORD *)buf = 138544130;
                    v68 = v42;
                    v69 = 1024;
                    *(_DWORD *)v70 = v39;
                    *(_WORD *)&v70[4] = 1024;
                    *(_DWORD *)&v70[6] = v40;
                    LOWORD(v71) = 1024;
                    *(_DWORD *)((char *)&v71 + 2) = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Restoring data for app %{public}@ isAppAuthorized: %d, isLeDevicePaired %d isDeviceForDA %d",  buf,  0x1Eu);
                  }

                  if ((v39 | v40) == 1)
                  {
                    [*(id *)(a1 + 304) addObject:v38];
                  }

                  else
                  {
                    if (qword_1008D5F30 != -1) {
                      dispatch_once(&qword_1008D5F30, &stru_100894630);
                    }
                    v43 = sub_1005CC198((uint64_t)off_1008D5F28, v38, 0);
                    v44 = (os_log_s *)qword_1008F7680;
                    if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_INFO))
                    {
                      v45 = *(NSKeyedUnarchiver **)(a1 + 88);
                      *(_DWORD *)buf = 138543618;
                      v68 = v45;
                      v69 = 2048;
                      *(void *)v70 = v43;
                      _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_INFO,  "Not adding app %{public}@ peripheral device %llu ",  buf,  0x16u);
                    }
                  }
                }

                __int128 v35 = (char *)v35 + 1;
              }

              while (v33 != v35);
              __int128 v33 = [v32 countByEnumeratingWithState:&v58 objects:v78 count:16];
              if (v33) {
                continue;
              }
              break;
            }
          }

      id v8 = (uint64_t)sub_1003A4CBC(v8, (uint64_t)v10);
      ++v9;
    }

    while (v9 != v23);
  }

  return 0LL;
}

        sub_100242FAC((uint64_t)v23);
        return sub_100242FAC((uint64_t)v24);
      }
    }

  sub_1002075AC(a4 + 400, a3);
  buf.__r_.__value_.__s.__data_[0] = 0;
  sub_100242CA4(&buf);
  id v17 = a2 + 128;
  uint64_t v18 = sub_100119508((uint64_t)off_100899CC8, v17, a4);
  if (v18 && v18 != 1327 && os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
    sub_100682AF0();
  }
  if (sub_100119598((uint64_t)v10, (uint64_t)v11, v17))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR)) {
      sub_100682A90();
    }
  }

  sub_100242CD0(&buf);
  sub_100242CD8(&buf);
  return sub_100242FAC((uint64_t)v20);
}

      id v28 = (void *)v2[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          id v28 = (void *)*v28;
        }

        while (v28);
      }

      else
      {
        do
        {
          uint64_t v29 = (void *)v2[2];
          uint64_t v30 = *v29 == (void)v2;
          uint64_t v2 = v29;
        }

        while (!v30);
      }

      uint64_t v2 = v29;
    }

    while (v29 != v3);
  }
            }

            if (uuid_is_null(uu))
            {
              memset(v118, 0, sizeof(v118));
              uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v98 longTermKeyMap]);
              if ([v29 countByEnumeratingWithState:v118 objects:v140 count:16])
              {
                uint64_t v30 = sub_1005C04DC(**((void ***)&v118[0] + 1));
                sub_1005C8684(v102, v30, 1u, 1u, 0LL, 0LL, (unsigned __int8 *)&buf);
                uuid_copy(uu, (const unsigned __int8 *)&buf);
              }

              else
              {
                uint64_t v30 = 0LL;
              }
            }

            else
            {
              uint64_t v30 = 0LL;
            }

            if (uuid_is_null(uu))
            {
              __int128 v31 = (os_log_s *)qword_1008F75A0;
              if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
              {
                __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v98 beaconIdentifier]);
                sub_1005BF8CC(v30, &__p);
                p_p = &__p;
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
                }
                LODWORD(buf.__r_.__value_.__l.__data_) = v91;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = 1752392040LL;
                WORD2(buf.__r_.__value_.__r.__words[1]) = 2113;
                *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v32;
                HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
                v139 = p_p;
                _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "Failed to retrieve/create FindMy peripheral %{private, mask.hash}@ with address %{public}s, ignoring this device",  (uint8_t *)&buf,  0x20u);
              }
            }

            else
            {
LABEL_46:
              v99 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
              v116 = 0u;
              v117 = 0u;
              v114 = 0u;
              v115 = 0u;
              v100 = v96;
              __int128 v34 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v100,  "countByEnumeratingWithState:objects:count:",  &v114,  v136,  16LL);
              if (v34)
              {
                v101 = *(void *)v115;
                do
                {
                  for (k = 0LL; k != v34; k = (char *)k + 1)
                  {
                    if (*(void *)v115 != v101) {
                      objc_enumerationMutation(v100);
                    }
                    __int128 v36 = sub_1005C04DC(*(void **)(*((void *)&v114 + 1) + 8LL * (void)k));
                    __int128 v37 = v36;
                    uint64_t v38 = (void *)*v5;
                    v39 = v102 + 176;
                    if (*v5)
                    {
                      v40 = v102 + 176;
                      do
                      {
                        v41 = v38[4];
                        v42 = v41 >= v36;
                        if (v41 >= v36) {
                          v43 = v38;
                        }
                        else {
                          v43 = v38 + 1;
                        }
                        if (v42) {
                          v40 = (uint64_t)v38;
                        }
                        uint64_t v38 = (void *)*v43;
                      }

                      while (*v43);
                      v39 = v102 + 176;
                      if ((void *)v40 != v5)
                      {
                        v39 = v102 + 176;
                        if (v36 >= *(void *)(v40 + 32))
                        {
                          v44 = sub_100241F94(uu);
                          v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
                          v46 = sub_100241F94((const unsigned __int8 *)(v40 + 40));
                          v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
                          v48 = [v45 isEqual:v47];

                          if ((v48 & 1) == 0)
                          {
                            v49 = (os_log_s *)qword_1008F75A0;
                            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                            {
                              v50 = sub_100241F94((const unsigned __int8 *)(v40 + 40));
                              v51 = (id)objc_claimAutoreleasedReturnValue(v50);
                              sub_1005BFC20(v37, &buf);
                              p_buf = &buf;
                              if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                p_buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
                              }
                              LODWORD(__p.__r_.__value_.__l.__data_) = 138543618;
                              *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v51;
                              WORD2(__p.__r_.__value_.__r.__words[1]) = 2082;
                              *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_buf;
                              _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Previous device %{public}@ with address %{public}s pending removal",  (uint8_t *)&__p,  0x16u);
                            }

                            v53 = sub_100241F94((const unsigned __int8 *)(v40 + 40));
                            v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
                            -[NSMutableSet addObject:](v99, "addObject:", v54);
                          }

                          v39 = v40;
                        }
                      }
                    }

                    if (*(_BYTE *)(v102 + 156))
                    {
                      v55 = (id *)sub_1002DCC34(*(void *)(v102 + 240), v37);
                      if (v55)
                      {
                        v56 = sub_100241F94(uu);
                        v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
                        v58 = *v55;
                        v59 = [v57 isEqual:v58];

                        if ((v59 & 1) == 0)
                        {
                          v60 = (os_log_s *)qword_1008F75A0;
                          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                          {
                            v61 = sub_100241F94((const unsigned __int8 *)(v39 + 40));
                            v62 = (id)objc_claimAutoreleasedReturnValue(v61);
                            sub_1005BFC20(v37, &buf);
                            v63 = &buf;
                            if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                              v63 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
                            }
                            LODWORD(__p.__r_.__value_.__l.__data_) = 138543618;
                            *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v62;
                            WORD2(__p.__r_.__value_.__r.__words[1]) = 2082;
                            *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v63;
                            _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Previous device %{public}@ with address %{public}s pending removal",  (uint8_t *)&__p,  0x16u);
                          }

                          v64 = *v55;
                          -[NSMutableSet addObject:](v99, "addObject:", v64);
                        }
                      }
                    }
                  }

                  __int128 v34 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v100,  "countByEnumeratingWithState:objects:count:",  &v114,  v136,  16LL);
                }

                while (v34);
              }

              v112 = 0u;
              v113 = 0u;
              v110 = 0u;
              v111 = 0u;
              v65 = v99;
              v66 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v110,  v135,  16LL);
              if (v66)
              {
                v67 = *(void *)v111;
                do
                {
                  v68 = 0LL;
                  do
                  {
                    if (*(void *)v111 != v67) {
                      objc_enumerationMutation(v65);
                    }
                    v69 = *(void **)(*((void *)&v110 + 1) + 8LL * (void)v68);
                    v70 = (os_log_s *)qword_1008F75A0;
                    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                    {
                      LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v69;
                      _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "Removing previous device %{public}@ with same address, disconnecting if already connecting/connected",  (uint8_t *)&buf,  0xCu);
                    }

                    if (qword_1008D67C8 != -1) {
                      dispatch_once(&qword_1008D67C8, &stru_1008A3458);
                    }
                    sub_100281F2C((uint64_t)off_1008D67C0, v69, 8u);
                    sub_1005C91A4(v102, v69);
                    v68 = (char *)v68 + 1;
                  }

                  while (v66 != v68);
                  v66 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v110,  v135,  16LL);
                }

                while (v66);
              }

              v71 = sub_100241F94(uu);
              v72 = (void *)objc_claimAutoreleasedReturnValue(v71);
              v73 = sub_1005C69FC(v102, v72, v98);

              if (v73)
              {
                v74 = (os_log_s *)qword_1008F75A0;
                if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
                {
                  v82 = sub_100241F94(uu);
                  v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
                  LODWORD(buf.__r_.__value_.__l.__data_) = 138543618;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v83;
                  WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
                  *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v73;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_ERROR,  "Failed to set FindMy info for device %{public}@ with result %d, skipping",  (uint8_t *)&buf,  0x12u);
                }

                v75 = sub_100241F94(uu);
                v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
                sub_1005C91A4(v102, v76);
              }

              else
              {
                v77 = objc_claimAutoreleasedReturnValue([v98 name]);
                sub_10002418C(v108, (char *)[v77 UTF8String]);
                sub_1005C9550(v102, uu, (uint64_t)v108, 4);
                if (v109 < 0) {
                  operator delete(v108[0]);
                }

                v78 = (os_log_s *)qword_1008F75A0;
                if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
                {
                  v79 = sub_100241F94(uu);
                  v80 = (void *)objc_claimAutoreleasedReturnValue(v79);
                  LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v80;
                  _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_DEFAULT,  "new addresses for device %{public}@ changed",  (uint8_t *)&buf,  0xCu);
                }

                sub_1005BCCEC(&v131, uu, uu);
                v81 = sub_100241F94(uu);
                v76 = (void *)objc_claimAutoreleasedReturnValue(v81);
                [v92 removeObject:v76];
              }
            }
          }

          else
          {
            id v28 = (os_log_s *)qword_1008F75A0;
            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR)) {
              sub_10069ACE0(&v123, v124, v28);
            }
          }
        }
      }

      v95 = [obj countByEnumeratingWithState:&v127 objects:v144 count:16];
    }

    while (v95);
  }

  if (v133)
  {
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_1008A3478);
    }
    v84 = off_1008D5F08;
    sub_1005DC968((uint64_t *)v107, (uint64_t)&v131);
    sub_100592720((uint64_t)v84, v107);
    sub_10023BF24((uint64_t)v107, (void *)v107[1]);
    if (qword_1008D67C8 != -1) {
      dispatch_once(&qword_1008D67C8, &stru_1008A3458);
    }
    sub_10028E260((uint64_t)off_1008D67C0);
  }

  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v85 = v92;
  v86 = [v85 countByEnumeratingWithState:&v103 objects:v134 count:16];
  if (v86)
  {
    v87 = *(void *)v104;
    do
    {
      v88 = 0LL;
      do
      {
        if (*(void *)v104 != v87) {
          objc_enumerationMutation(v85);
        }
        v89 = *(void **)(*((void *)&v103 + 1) + 8LL * (void)v88);
        v90 = (os_log_s *)qword_1008F75A0;
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v89;
          _os_log_impl( (void *)&_mh_execute_header,  v90,  OS_LOG_TYPE_DEFAULT,  "removing FindMy %{public}@, disconnecting if already connecting/connected",  (uint8_t *)&buf,  0xCu);
        }

        if (qword_1008D67C8 != -1) {
          dispatch_once(&qword_1008D67C8, &stru_1008A3458);
        }
        sub_100281F2C((uint64_t)off_1008D67C0, v89, 8u);
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A3498);
        }
        sub_1005C91A4((uint64_t)off_1008D5F28, v89);
        v88 = (char *)v88 + 1;
      }

      while (v86 != v88);
      v86 = [v85 countByEnumeratingWithState:&v103 objects:v134 count:16];
    }

    while (v86);
  }

  sub_10023BF24((uint64_t)&v131, v132);
}

    __int128 v19 = (void *)v4[1];
    if (v19)
    {
      do
      {
        __int128 v20 = v19;
        __int128 v19 = (void *)*v19;
      }

      while (v19);
    }

    else
    {
      do
      {
        __int128 v20 = (void *)v4[2];
        uint64_t v16 = *v20 == (void)v4;
        uint64_t v4 = v20;
      }

      while (!v16);
    }

    uint64_t v4 = v20;
    if (v20 == v5)
    {
      id v21 = (unsigned __int16)*a4;
      goto LABEL_41;
    }
  }

  id v17 = *((unsigned __int16 *)v4 + 17);
  *(_DWORD *)buf = 67110144;
  v45 = v12;
  v46 = 1024;
  v47 = v11;
  v48 = 1024;
  v49 = v14;
  v50 = 1024;
  v51 = v13 != 0;
  v52 = 1024;
  v53 = v17 != 0;
  _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "MATCH TABLE handle:%d type:%d length:%d isCreated:%d isEnabled:%d",  buf,  0x20u);
  if (v13) {
    goto LABEL_14;
  }
LABEL_24:
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069D7A0(&v38, v39);
  }
  if (v11 != a2)
  {
    if (v11 == 255 && !*a4)
    {
      uint64_t v18 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
        sub_10069D764(v42, v43, v18);
      }
      *a4 = v12;
    }

    goto LABEL_32;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
    sub_10069D704();
  }
  __int128 v34 = (os_log_s *)qword_1008F75B8;
  __int128 v35 = os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG);
  if (v14 != a3)
  {
    if (v35)
    {
      *(_DWORD *)buf = 67109632;
      v45 = a2;
      v46 = 1024;
      v47 = v12;
      v48 = 1024;
      v49 = v14;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "MATCH TABLE so close! table for type:%d is already registered with handle %d and size:%d",  buf,  0x14u);
    }

    *a4 = 0;
    return 15LL;
  }

  if (v35) {
    sub_10069D694();
  }
  uint64_t result = 0LL;
  *a4 = v12;
  return result;
}

    __int128 v19 = (void **)&v16;
    sub_100024304(&v19);
  }

void sub_10001DB64(void *a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([*(id *)(a1[4] + 528) localDeviceForStableId:a1[5]]);
  uint64_t v3 = *(void *)(a1[6] + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_10001DC48(void *a1)
{
  int v4 = 0;
  uint64_t v2 = *(void **)(a1[4] + 528LL);
  if (v2)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 optimalHostIdForStableId:a1[5] result:&v4]);
  }

  else
  {
    uint64_t v3 = 0LL;
    int v4 = 1702;
  }

  (*(void (**)(void))(a1[6] + 16LL))();
}

void sub_10001DE14(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 512);
  *(void *)(v1 + 512) = 0LL;
}

void sub_10001DE24(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (v6)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void **)(v4 + 512);
    *(void *)(v4 + 512) = 0LL;

    uint64_t v3 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
  }

  else
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _performUserControllerActionWithCompletion:]_block_invoke_2",  30LL,  "Stack user controller started");
    }

    uint64_t v3 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
  }

  v3();
}

id sub_10001E19C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) xpcReceivedMessage:a2];
}

LABEL_12:
  if (dword_1008D5FD8 <= 30 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _xpcPublisherConnectionsRemoveToken:reason:]",  30LL,  "XPC subscriber remove: connections, reason %s, token %llu, %@",  a4,  a3,  v8);
  }
  if (v8)
  {
    -[NSMutableSet removeObject:](self->_xpcConnections, "removeObject:", v8);
    [v8 invalidate];
  }
}

  if (dword_1008D5FD8 <= 30 && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))) {
    LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _xpcPublisherDiscoveryRemoveToken:reason:]",  30LL,  "XPC subscriber remove: discovery, reason %s, token %llu, %@",  a4,  a3,  v8);
  }
  if (v8)
  {
    -[NSMutableSet removeObject:](self->_xpcConnections, "removeObject:", v8);
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v8 activatedDiscovery]);
    if (v13)
    {
      unsigned __int8 v14 = (void *)objc_claimAutoreleasedReturnValue(+[CBMetricsDaemon sharedCBMetricsDaemon](&OBJC_CLASS___CBMetricsDaemon, "sharedCBMetricsDaemon"));
      [v14 reportCBDiscovery:v13 daemonCnx:v8 action:@"stop"];
    }

    [v8 invalidate];
    -[CBDaemonServer scheduleDiscoveryUpdateImmediate:](self, "scheduleDiscoveryUpdateImmediate:", 0LL);
  }
}
}

    goto LABEL_13;
  }

LABEL_13:
        goto LABEL_14;
      }

      id v22 = CBErrorF(4294960591LL, "No service flags");
      id v21 = objc_claimAutoreleasedReturnValue(v22);
    }

    else
    {
      __int128 v20 = CBErrorF(4294960591LL, "No device");
      id v21 = objc_claimAutoreleasedReturnValue(v20);
    }

    __int128 v19 = (void *)v30[5];
    v30[5] = v21;
    goto LABEL_12;
  }
  }

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v27, 8);
}

    unsigned int v11 = 0LL;
    goto LABEL_9;
  }

  __int128 v19 = 0;
  uint64_t v5 = (void *)OPACKDecodeData(v20, 8LL, &v19);
  if (!v5)
  {
    if (a4)
    {
      unsigned __int8 v14 = CUPrintErrorCode(v19);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
      uint64_t v16 = CBErrorF(312900LL, "Decode token failed: %@", v15);
      *a4 = (id)objc_claimAutoreleasedReturnValue(v16);
    }

  return (char)v11;
}

  return (char)v11;
}

  if (!dword_1008F29B4)
  {
    sub_10008B5D8();
    uint64_t v1 = (unsigned __int16)word_1008DD4E2;
  }

  if (v1 >= 0x10) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/cl/BT_CL_Signaling.c",  783,  "lNbPeers < MAX_PEERS");
  }
}

  sub_1000B7DCC((uint64_t)a1);
LABEL_13:
  *((_DWORD *)a1 + 51) = 0;
  return v6;
}

  if (!sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"AdvBufConfig sub-opcode incorrect: %d, %!", v16, v17, v18, v19, v20, v21, v22, v13),
        id v23 = (os_log_s *)sub_100086554(0x54u),
        !os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_15;
  }

  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v13);
}

  if (!sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"MatchTableConfig sub-opcode incorrect %d, %!", v16, v17, v18, v19, v20, v21, v22, v13),
        id v23 = (os_log_s *)sub_100086554(0x54u),
        !os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_15;
  }

  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v13);
}

  if (!sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"MatchTableConfigV2 sub-opcode incorrect %d, %!", v16, v17, v18, v19, v20, v21, v22, v13),
        id v23 = (os_log_s *)sub_100086554(0x54u),
        !os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_15;
  }

  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v13);
}

  if (!sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"MatchTableConfigV3 sub-opcode incorrect %d, %!", v16, v17, v18, v19, v20, v21, v22, v13),
        id v23 = (os_log_s *)sub_100086554(0x54u),
        !os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_15;
  }

  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v13);
}

  if (!sub_1000A86F0()
    || (sub_1001EE134( (uint64_t)"AdvBufMatchControl sub-opcode incorrect: %d, %!",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v13),  id v23 = (os_log_s *)sub_100086554(0x54u),  !os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_15;
  }

  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v13);
}

  if (!sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"MatchTableParams sub-opcode incorrect: %d, %!", v16, v17, v18, v19, v20, v21, v22, v13),
        id v23 = (os_log_s *)sub_100086554(0x54u),
        !os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_15;
  }

  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v13);
}

  if (!sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"MatchBufferConfig sub-opcode incorrect: %d, %!", v16, v17, v18, v19, v20, v21, v22, v13),
        id v23 = (os_log_s *)sub_100086554(0x54u),
        !os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_15;
  }

  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v13);
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"VERSION_IND not tracking this device.", v18, v19, v20, v21, v22, v23, v24, v154);
    v25 = (os_log_s *)sub_100086554(0x56u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

    sub_100100FE8(v5, v14, a3, 1);
  }

        if ((int)a2 <= (int)v12)
        {
          switch((int)v12)
          {
            case 1:
              if (v6 < 2u) {
                goto LABEL_5;
              }
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
LABEL_136:
                v72 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 1";
LABEL_138:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  201,  v72);
              }

              if (*(_BYTE *)(a1 + 14) != 2)
              {
                v72 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_138;
              }

              __int128 v20 = *(void *)a1;
              *(_WORD *)(a1 + 12) = v5 + 1;
              *(_BYTE *)(v20 + (unsigned __int16)v5) = 8 * v11;
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
LABEL_140:
                v73 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 1";
LABEL_142:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  202,  v73);
              }

              id v21 = *(unsigned __int16 *)(a1 + 12);
              if (*(_BYTE *)(a1 + 14) != 2)
              {
                v73 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_142;
              }

              id v22 = *((_DWORD *)a3 + 2);
              id v23 = *(void *)a1;
              *(_WORD *)(a1 + 12) = v21 + 1;
              *(_BYTE *)(v23 + v21) = v22;
              break;
            case 2:
              if (v6 < 3u) {
                goto LABEL_5;
              }
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
LABEL_152:
                v76 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 1";
LABEL_154:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  208,  v76);
              }

              if (*(_BYTE *)(a1 + 14) != 2)
              {
                v76 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_154;
              }

              v42 = *(void *)a1;
              *(_WORD *)(a1 + 12) = v5 + 1;
              *(_BYTE *)(v42 + (unsigned __int16)v5) = (8 * v11) | 1;
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
LABEL_156:
                v77 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 2";
LABEL_158:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  209,  v77);
              }

              v43 = *(unsigned __int16 *)(a1 + 12);
              if (*(_BYTE *)(a1 + 14) != 2)
              {
                v77 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_158;
              }

              *(_BYTE *)(*(void *)a1 + v43 + 1) = *((_DWORD *)a3 + 2);
              *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12)) = BYTE1(*((_DWORD *)a3 + 2));
              v40 = *(_WORD *)(a1 + 12) + 2;
              goto LABEL_86;
            case 3:
            case 5:
            case 6:
            case 7:
              goto LABEL_67;
            case 4:
              if (v6 < 5u) {
                goto LABEL_5;
              }
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
LABEL_144:
                v74 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 1";
LABEL_146:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  215,  v74);
              }

              if (*(_BYTE *)(a1 + 14) != 2)
              {
                v74 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_146;
              }

              uint64_t v38 = *(void *)a1;
              *(_WORD *)(a1 + 12) = v5 + 1;
              *(_BYTE *)(v38 + (unsigned __int16)v5) = (8 * v11) | 2;
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
LABEL_148:
                v75 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 4";
LABEL_150:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  216,  v75);
              }

              v39 = *(unsigned __int16 *)(a1 + 12);
              if (*(_BYTE *)(a1 + 14) != 2)
              {
                v75 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                goto LABEL_150;
              }

              *(_BYTE *)(*(void *)a1 + v39 + 3) = *((_DWORD *)a3 + 2);
              *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 2LL) = BYTE1(*((_DWORD *)a3 + 2));
              *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12) + 1LL) = *((_WORD *)a3 + 5);
              *(_BYTE *)(*(void *)a1 + *(unsigned __int16 *)(a1 + 12)) = a3[11];
              v40 = *(_WORD *)(a1 + 12) + 4;
LABEL_86:
              *(_WORD *)(a1 + 12) = v40;
              goto LABEL_106;
            case 8:
              if ((_DWORD)a2)
              {
                v41 = (a2 - 1);
              }

              else
              {
                if (*(_BYTE *)(a1 + 15))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/data"
                                         "elem/marshaller.c");
LABEL_164:
                  v79 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 1";
LABEL_166:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  222,  v79);
                }

                if (*(_BYTE *)(a1 + 14) != 2)
                {
                  v79 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_166;
                }

                v41 = 0LL;
                v45 = *(void *)a1;
                *(_WORD *)(a1 + 12) = v5 + 1;
                *(_BYTE *)(v45 + (unsigned __int16)v5) = (8 * v11) | 3;
              }

              v46 = sub_10010AAD0(a1, v41, **((_DWORD **)a3 + 1));
              v47 = *(_DWORD *)(*((void *)a3 + 1) + 4LL);
LABEL_105:
              a2 = sub_10010AAD0(a1, v46, v47);
              if ((_DWORD)a2 == -1) {
                goto LABEL_5;
              }
              goto LABEL_106;
            default:
              if ((_DWORD)v12 != 16) {
                goto LABEL_67;
              }
              if ((_DWORD)a2)
              {
                __int128 v37 = (a2 - 1);
              }

              else
              {
                if (*(_BYTE *)(a1 + 15))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/data"
                                         "elem/marshaller.c");
LABEL_171:
                  v81 = "ByteStream_NumReadBytesAvail(*ByteStream) >= 1";
LABEL_173:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  234,  v81);
                }

                if (*(_BYTE *)(a1 + 14) != 2)
                {
                  v81 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
                  goto LABEL_173;
                }

                __int128 v37 = 0LL;
                v48 = *(void *)a1;
                *(_WORD *)(a1 + 12) = v5 + 1;
                *(_BYTE *)(v48 + (unsigned __int16)v5) = (8 * v11) | 4;
                unsigned int v11 = *a3;
              }

              v49 = (int *)*((void *)a3 + 1);
              if (v11 != 3)
              {
                v56 = sub_10010AAD0(a1, v37, *v49);
                v57 = sub_10010AAD0(a1, v56, *(_DWORD *)(*((void *)a3 + 1) + 4LL));
                v46 = sub_10010AAD0(a1, v57, *(_DWORD *)(*((void *)a3 + 1) + 8LL));
                v47 = *(_DWORD *)(*((void *)a3 + 1) + 12LL);
                goto LABEL_105;
              }

              v50 = sub_10010AAD0(a1, v37, *v49);
              if (v50 == -1) {
                goto LABEL_5;
              }
              v51 = v50;
              v52 = *(unsigned __int16 *)(a1 + 12);
              LOWORD(v53) = *(_WORD *)(a1 + 10) - v52;
              v54 = *((void *)a3 + 1);
              v82 = *(void *)a1;
              if (*(_BYTE *)(a1 + 15))
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
                v55 = 0;
              }

              else
              {
                v55 = *(unsigned __int16 *)(a1 + 10) - (_DWORD)v52;
              }

              v59 = (unsigned __int16)(12 - v51);
              v60 = (unsigned __int16)v53;
              else {
                v53 = (unsigned __int16)(12 - v51);
              }
              if (v55 < (int)v53)
              {
                v80 = "ByteStream_NumReadBytesAvail(*ByteStream) >= ((((size) > (bytesAllowed)) ? (bytesAllowed) : (size)))";
                goto LABEL_169;
              }

              if (*(_BYTE *)(a1 + 14) != 2)
              {
                v80 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_169:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  246,  v80);
              }

              memmove((void *)(v82 + v52), (const void *)(v54 + v51 + 4), v53);
              *(_WORD *)(a1 + 12) += v53;
              if (v59 > v60) {
                goto LABEL_5;
              }
              a2 = 0LL;
              goto LABEL_106;
          }
        }

        else
        {
          a2 = (a2 + ~(_DWORD)v12);
        }

        goto LABEL_106;
      case 4:
      case 8:
      case 17:
      case 18:
        id v13 = sub_10010ABC8((uint64_t *)a1, a2, *((unsigned __int16 *)a3 + 1), v11);
        if (v13 == -1) {
          goto LABEL_5;
        }
        unsigned __int8 v14 = v13;
        a2 = v13 - v12;
        uint64_t v15 = *(unsigned __int16 *)(a1 + 12);
        LOWORD(v16) = *(_WORD *)(a1 + 10) - v15;
        id v17 = *(void *)a1;
        uint64_t v18 = *((void *)a3 + 1);
        if (*(_BYTE *)(a1 + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c");
          __int128 v19 = 0;
        }

        else
        {
          __int128 v19 = *(unsigned __int16 *)(a1 + 10) - (_DWORD)v15;
        }

        __int128 v34 = v12 - v14;
        __int128 v35 = (unsigned __int16)(v12 - v14);
        __int128 v36 = (unsigned __int16)v16;
        else {
          uint64_t v16 = (unsigned __int16)v16;
        }
        if (v19 < (int)v16)
        {
          v71 = "ByteStream_NumReadBytesAvail(*ByteStream) >= ((((size) > (bytesAllowed)) ? (bytesAllowed) : (size)))";
          goto LABEL_134;
        }

        if (*(_BYTE *)(a1 + 14) != 2)
        {
          v71 = "(*ByteStream).__RWFlag == BYTESTREAM_WRITE";
LABEL_134:
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/dataelem/marshaller.c",  278,  v71);
        }

        memmove((void *)(v17 + v15), (const void *)(v18 + v14), v16);
        *(_WORD *)(a1 + 12) += v16;
        if (v36 < v35) {
          goto LABEL_5;
        }
        a2 = 0LL;
        goto LABEL_106;
      case 6:
      case 7:
        uint64_t v24 = sub_10010AE3C(a3);
        if (!v24) {
          goto LABEL_5;
        }
        v25 = v24 - 2;
        if (((v24 - 2) & 0xFF00) != 0) {
          v25 = v24 - 3;
        }
        v26 = v25;
        v27 = sub_10010ABC8((uint64_t *)a1, a2, v25, *a3);
        if ((_DWORD)v27 == -1) {
          goto LABEL_5;
        }
        a2 = v27;
        if (v27 < v26)
        {
          if (!*((void *)a3 + 1) || !*((_WORD *)a3 + 1)) {
            goto LABEL_106;
          }
          id v28 = (__int128 *)sub_1000B17F4(0x18uLL);
          if (!v28)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"MarshalElement: %!", v62, v63, v64, v65, v66, v67, v68, 106LL);
              v69 = (os_log_s *)sub_100086554(0x2Bu);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                sub_10065B7B4();
              }
            }

  uint64_t v15 = (*(_BYTE *)(v6 + 74) & 0xFE) == (*(_BYTE *)(v6 + 75) & 0xFE) || (*(_BYTE *)(v6 + 74) & 0xFE) == 0;
  if (*(_BYTE *)(a1 + 144))
  {
    if (v15)
    {
      sub_100185420(v6, 65);
LABEL_52:
      sub_100184BB0((char *)v6, 0LL, 1);
    }
  }

  else if (v15)
  {
    sub_100185420(v6, 67);
    sub_10011D9AC(v6);
    sub_10011DB24(v6);
    goto LABEL_52;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"SubOpcode Incorrect %x!", v17, v18, v19, v20, v21, v22, v23, v13);
    uint64_t v24 = (os_log_s *)sub_100086554(0x54u);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

  uint64_t result = 101LL;
  if (a2) {
    return a2(result);
  }
  return result;
}

  sub_1001EE134((uint64_t)"SubOpcode Incorrect %!", v22, v23, v24, v25, v26, v27, v28, a1);
  uint64_t v29 = (os_log_s *)sub_100086554(0x54u);
  if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
    goto LABEL_14;
  }
  sub_100657F74();
  if (a2) {
LABEL_15:
  }
    a2(a1, v15, v14, v13);
}

  uint64_t result = sub_1000A86F0();
  if ((_DWORD)result)
  {
    sub_1001EE134( (uint64_t)"Why is this called with a channel where retransmission isn't enabled ?",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v12);
    unsigned int v11 = (os_log_s *)sub_100086554(0x2Fu);
    uint64_t result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100657858();
      return 0LL;
    }
  }

  return result;
}

  if (v9 >= v8)
  {
    uint64_t v10 = sub_1000B1814(v8);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = v10;
    if (v10)
    {
      unsigned int v11 = *a3;
      v10[4] = *((_BYTE *)a3 + 4);
      *(_DWORD *)uint64_t v10 = v11;
      memmove( (void *)(*(void *)(a1 + 48) + 5LL),  *(const void **)((char *)a3 + 7),  *(unsigned __int16 *)((char *)a3 + 5));
      id v6 = sub_1001A2950(a1);
      if (!(_DWORD)v6) {
        return v6;
      }
    }

    else
    {
      id v6 = 106LL;
    }
  }

  else
  {
    id v6 = 142LL;
  }

  id v12 = *(void **)(a1 + 48);
  if (v12) {
    sub_1000B1838(v12);
  }
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)uint64_t v5 = 0LL;
  *(void *)(v5 + _Block_object_dispose(va, 8) = 0LL;
  *(_WORD *)(v5 + 16) = 0;
  return v6;
}

  uint64_t v10 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read LinkQuality Notification", v11, v12, v13, v14, v15, v16, v17, v20);
    uint64_t v18 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v10;
}

  a5[v8] = a4;
  return result;
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  sub_100242FAC((uint64_t)v11);
  return v6;
}

      uint64_t v10 = 1LL;
LABEL_21:
      sub_10025A3A8(a1, a2, v10);
      return 1LL;
    }

    goto LABEL_16;
  }

  uint64_t v5 = *(unsigned __int8 *)(v4 + 1373);
  if ((sub_100257524(a1) & 1) == 0)
  {
    if (v5)
    {
      unsigned int v11 = (os_log_s *)qword_1008F76F8;
      id v12 = os_log_type_enabled((os_log_t)qword_1008F76F8, OS_LOG_TYPE_DEFAULT);
      uint64_t v10 = 0LL;
      if (!v12) {
        goto LABEL_21;
      }
      id v17 = 0;
      id v13 = "BandSwitchManager: ---------- Switch from HRB to ISM ----------";
      unsigned __int8 v14 = (uint8_t *)&v17;
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, v14, 2u);
      uint64_t v10 = 0LL;
      goto LABEL_21;
    }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  objc_destroyWeak(&location);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

        id v9 = (char *)v9 + 1;
      }

      while (v9 != v7);
      __int128 v19 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
      int v7 = v19;
    }

    while (v19);
  }
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  uint64_t v5 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F00B0) {
      id v6 = "enabled";
    }
    else {
      id v6 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "support for Magnet Timeout ABC Log is %s",  buf,  0xCu);
  }

    IOAllowPowerChange(*(_DWORD *)(a1 + 1308), a3);
    goto LABEL_15;
  }

  if (a2 == -536870288)
  {
    if (!*(_BYTE *)(a1 + 1324))
    {
      id v8 = sub_100268F24((os_unfair_lock_s *)a1, 0, 0);
      *(_BYTE *)(a1 + 1324) = 1;
      if ((v8 & 1) == 0) {
        goto LABEL_8;
      }
    }

    goto LABEL_12;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  id v9 = 0LL;
LABEL_13:
  sub_10023BF24((uint64_t)&v16, v17);
  return v9;
}

  return v10;
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  sub_100242FAC((uint64_t)v10);
  return v4;
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  buf[0] = 0;
  sub_100242CA4(buf);
  if (sub_10011EA10((uint64_t)sub_10043B848, 0x2000u, v11, v12, v13, v14, v15, v16)
    && os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_ERROR))
  {
    sub_10067F94C();
  }

  sub_100242CD8(buf);
  sub_100242F54((uint64_t)v18);
  sub_10043B88C(a1, 0LL);
  return sub_100242FAC((uint64_t)v18);
}

          id v17 = sub_10043C110(v9, a2, a3);
          if ((v18 & 1) == 0) {
            goto LABEL_15;
          }
          __int128 v19 = sub_10043C228(v9, v17, (unsigned int (**)(void))a3);
          id v9 = v17 + 1;
          uint64_t result = sub_10043C228(v17 + 1, a2, (unsigned int (**)(void))a3);
          if (!(_DWORD)result)
          {
            uint64_t v10 = v11 + 1;
            if (v19) {
              continue;
            }
LABEL_15:
            uint64_t result = sub_10043BA84(v8, v17, a3, -v11, a5 & 1);
            id v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }

          a4 = -v11;
          a2 = v17;
          if (v19) {
            return result;
          }
          goto LABEL_2;
        }

        if (v9 != a2) {
          return (uint64_t)sub_10043C554((char *)v9, (char *)a2, a2, a3);
        }
        return result;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  sub_100242FAC((uint64_t)v17);
}

  id v22 = 1;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_10089D810);
  }
  if ((sub_1005D79C0((uint64_t)off_1008D5F28, v8, *(void **)(a1 + 96), *(void **)(a1 + 48)) & 1) == 0)
  {
    id v12 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 96);
      id v17 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138412802;
      *(void *)&buf[4] = v16;
      uint64_t v24 = 2112;
      v25 = v17;
      v26 = 2112;
      v27 = v8;
      _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "App %@ for user %@ is not allowed to access %@",  buf,  0x20u);
    }

    goto LABEL_20;
  }

  if (*(_BYTE *)(a1 + 183))
  {
    if (!v6)
    {
LABEL_20:
      id v13 = 0;
      goto LABEL_21;
    }
  }

  else
  {
    id v13 = 0;
    if (!v22 || !v6) {
      goto LABEL_21;
    }
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_10089D810);
  }
  uint64_t v15 = off_1008D5F28;
  sub_10002418C(v18, (char *)[v6 UTF8String]);
  id v13 = sub_1005CE5A8((uint64_t)v15, v8, (uint64_t)v18);
  if (v19 < 0) {
    operator delete(v18[0]);
  }
LABEL_21:
  reply = xpc_dictionary_create_reply(xdict);
  xpc_dictionary_set_BOOL(reply, "kCBMsgArgData", v13);
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), reply);
  xpc_release(reply);
}

  std::stringbuf::str(a2, (const std::stringbuf *)((char *)v14 + 8));
  *(void *)((char *)&v14[-1]
  *(void *)&v14[0] = v11;
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf((char *)v14 + 8);
  return std::ios::~ios(v18);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  id v6 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyLowMaxInterval");
  int v7 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v6 + 88LL))(v6, buf, __p, &v95);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v7) {
      goto LABEL_23;
    }
  }

  else if (!v7)
  {
    goto LABEL_23;
  }

  id v8 = v95;
  id v9 = (os_log_s *)qword_1008F7620;
  if ((v95 - 8) >= 0xF9A && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v8;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Override rejected latency maxInterval:%d LeConnectionLatencyLow",  buf,  8u);
    LOWORD(v_Block_object_dispose(va, 8) = v95;
    id v9 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 1082) = v8;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Override latency maxInterval:%d LeConnectionLatencyLow",  buf,  8u);
  }

    sub_10069C368();
    goto LABEL_13;
  }

  if (!a1[167] && !a1[711])
  {
    if (!os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  if (a1[1853] || a1[171] && a1[167] || a1[715] && a1[711])
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069C394();
    }
    return 12LL;
  }

  uint64_t v4 = sub_100404FE8();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_1005ED760;
  v6[3] = &unk_10087EB68;
  v6[4] = a1;
  int v7 = 4;
  sub_100405384(v4, v6);
  return 0LL;
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

    id v6 = v38;
    *(void *)buf = &dword_1008D9D60[i];
    *((_WORD *)sub_1005BC550( (uint64_t **)(a1 + 80),  (unsigned int *)&dword_1008D9D60[i],  (uint64_t)&unk_1006C2518,  (_DWORD **)buf)
    + 16) = v6;
  }

  LOBYTE(v3_Block_object_dispose(va, 8) = 0;
  int v7 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DoNotEnforceAllowedList");
  id v8 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v7 + 72LL))(v7, buf, __p, &v38);
  if ((_BYTE)v38) {
    id v9 = v8;
  }
  else {
    id v9 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v9) {
      goto LABEL_24;
    }
  }

  else if (!v9)
  {
    goto LABEL_24;
  }

  *(_BYTE *)(a1 + 152) = 0;
  uint64_t v10 = (os_log_s *)qword_1008F7698;
  if (os_log_type_enabled((os_log_t)qword_1008F7698, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding - Do Not Enforce Allowed List.",  buf,  2u);
  }

LABEL_10:
  _Block_object_dispose(&v14, 8);
LABEL_11:

LABEL_12:
  return (char)v9;
}

      ++v10;
      v11 += 134;
      if (v10 == dword_1008F29B4) {
        goto LABEL_11;
      }
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Disconnecting peer %d",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  LOWORD(qword_1008F29F0[134 * v10 + 1]));
      v39 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
LABEL_17:
      }
        sub_100657858();
    }

    return sub_1001B7974(*v12);
  }

  else
  {
LABEL_11:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Unknown lmhandle 0x%4x", v15, v16, v17, v18, v19, v20, v21, *a1);
      id v22 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 122LL;
  }

  if ((*(_BYTE *)(v6 + 74) & 2) == 0)
  {
    sub_1001EE134((uint64_t)"We were not expecting address info...", v8, v9, v10, v11, v12, v13, v14, v86);
    uint64_t v15 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    goto LABEL_13;
  }

  *(_BYTE *)(v6 + 75) |= 2u;
  if (!*(_BYTE *)(v6 + 612))
  {
    if (!unk_1008F6E98 || (*(_BYTE *)(v6 + 80) & 1) == 0) {
      goto LABEL_32;
    }
    v87[0] = *(_BYTE *)a2;
    *(_DWORD *)&v87[1] = *(_DWORD *)(a2 + 1);
    *(_WORD *)&v87[5] = *(_WORD *)(a2 + 5);
    sub_100184730(&v87[1], 6);
    if (v87[0] && (v87[0] != 1 || v87[1] <= 0xBFu))
    {
      sub_1001EE134( (uint64_t)"We got a remote address (%:) that is neither public nor static!",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  (uint64_t)&v87[1]);
      v76 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
        goto LABEL_21;
      }
      goto LABEL_54;
    }

    if (*(_DWORD *)v87) {
      v58 = 0;
    }
    else {
      v58 = *(unsigned __int16 *)&v87[4] == 0;
    }
    if (!v58)
    {
      *(_BYTE *)(a1 + 55) = 1;
      *(_DWORD *)(a1 + 56) = *(_DWORD *)v87;
      *(_DWORD *)(a1 + 59) = *(_DWORD *)&v87[3];
      v59 = (void *)sub_1001C92D4(v87);
      if (!v59 || (*v59 == *(void *)(v6 + 562) ? (v60 = v59[1] == *(void *)(v6 + 570)) : (v60 = 0), v60))
      {
        v77 = a1 + 48;
        unk_1008F6E98(v77, 10LL, v6 + 562, 16LL, 0LL);
        unk_1008F6E98(v77, 11LL, v87, 7LL, 0LL);
        goto LABEL_32;
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"device %: is already paired, with a different irk (old:%@ new %@). Unpair first and then restart pairing.",  v61,  v62,  v63,  v64,  v65,  v66,  v67,  a1 + 57);
        v68 = (os_log_s *)sub_100086554(0x43u);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      __int128 v33 = 240;
LABEL_22:
      sub_1001CBE38((__int128 *)a1, v33, (char *)v6);
      return;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Identity address cannot be all 0.", v78, v79, v80, v81, v82, v83, v84, v86);
      v85 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
LABEL_54:
      }
        sub_100657858();
    }

  *((_BYTE *)a2 + 15) = 1;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read error", v8, v9, v10, v11, v12, v13, v14, v16);
    uint64_t v15 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  *((_BYTE *)a2 + 15) = 1;
  id v8 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to read capabilities", v9, v10, v11, v12, v13, v14, v15, v18);
    uint64_t v16 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
    return 2LL;
  }

  return v8;
}

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

  *a2 = v8;
  return v5;
}

  v26 = 0LL;
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100889868);
  }
  if (sub_100496120(qword_1008D61A0, a4, &v26, 4LL))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR)) {
      sub_1006629CC();
    }
    return 0LL;
  }

  __p[0] = 0LL;
  __p[1] = 0LL;
  sub_100242F28((uint64_t)__p, a1 + 80);
  __int128 v19 = (os_log_s *)qword_1008F75C8;
  if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      __int128 v20 = *(void *)a4;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Registering scalable pipe session %{public}s",  buf,  0xCu);
  }

  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100889868);
  }
  v25 = sub_100496954((void *)qword_1008D61A0, v26);
  id v21 = (char *)operator new(0x40uLL);
  *(void *)id v21 = a2;
  id v22 = v21 + 8;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_100024238(v22, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)id v22 = *(_OWORD *)a3;
    *((void *)v21 + 3) = *(void *)(a3 + 16);
  }

  *((void *)v21 + 4) = 0LL;
  *((void *)v21 + 5) = 0LL;
  v21[56] = 0;
  *((void *)v21 + 6) = 0LL;
  *((_DWORD *)v21 + 15) = a5;
  *(void *)buf = &v25;
  sub_100029574(v11, (unint64_t *)&v25, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] = (uint64_t)v21;
  id v17 = v25;
  sub_100242FAC((uint64_t)__p);
  return v17;
}

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

            if (qword_1008D5F50 != -1) {
              dispatch_once(&qword_1008D5F50, &stru_10088C1D8);
            }
            uint64_t v10 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v27, 1);
            if (!sub_1003FE254((uint64_t)a1, (uint64_t)v10))
            {
              id v12 = a1[1];
              unsigned int v11 = (unint64_t)a1[2];
              if ((unint64_t)v12 >= v11)
              {
                id v17 = ((char *)v12 - (_BYTE *)*a1) >> 3;
                uint64_t v18 = v11 - (void)*a1;
                __int128 v19 = v18 >> 2;
                else {
                  __int128 v20 = v19;
                }
                if (v20) {
                  id v21 = (char *)sub_100008BA0((uint64_t)(a1 + 2), v20);
                }
                else {
                  id v21 = 0LL;
                }
                id v22 = &v21[8 * v17];
                *(void *)id v22 = v10;
                id v13 = v22 + 8;
                uint64_t v24 = (char *)*a1;
                id v23 = (char *)a1[1];
                if (v23 != *a1)
                {
                  do
                  {
                    v25 = *((void *)v23 - 1);
                    v23 -= 8;
                    *((void *)v22 - 1) = v25;
                    v22 -= 8;
                  }

                  while (v23 != v24);
                  id v23 = (char *)*a1;
                }

                *a1 = v22;
                a1[1] = v13;
                a1[2] = &v21[8 * v20];
                if (v23) {
                  operator delete(v23);
                }
              }

              else
              {
                *id v12 = v10;
                id v13 = v12 + 1;
              }

              a1[1] = v13;
            }
          }
        }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

        ;
      }

      uint64_t v18 = (void *)v11[1];
      if (v18)
      {
        do
        {
          __int128 v19 = v18;
          uint64_t v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          __int128 v19 = (void *)v11[2];
          __int128 v20 = *v19 == (void)v11;
          unsigned int v11 = v19;
        }

        while (!v20);
      }

      unsigned int v11 = v19;
    }

    while (v19 != (void *)(a1 + 24));
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7610, OS_LOG_TYPE_ERROR)) {
    sub_1006724B4();
  }
  sub_10036A534(a1, a2);
}

        ;
      }

      uint64_t v18 = (void *)v11[1];
      if (v18)
      {
        do
        {
          __int128 v19 = v18;
          uint64_t v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          __int128 v19 = (void *)v11[2];
          __int128 v20 = *v19 == (void)v11;
          unsigned int v11 = v19;
        }

        while (!v20);
      }

      unsigned int v11 = v19;
      if (v19 != (void *)(a1 + 24)) {
        continue;
      }
      break;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7610, OS_LOG_TYPE_ERROR)) {
    sub_1006724B4();
  }
  sub_10036A534(a1, a2);
}

  uint64_t v10 = *(void **)(a1 + 408);
  unsigned int v11 = (void *)(a1 + 416);
  if (v10 != (void *)(a1 + 416))
  {
    do
    {
      id v12 = (const unsigned __int8 *)v10[5];
      if (v12 != (const unsigned __int8 *)v10[6])
      {
        id v13 = -(uint64_t)v12;
        while (1)
        {
          unsigned __int8 v14 = sub_100241F94(v12);
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
          uint64_t v16 = [v3 isEqual:v15];

          if (v16) {
            break;
          }
          v12 += 18;
          v13 -= 18LL;
        }

        sub_10038E284((unsigned __int8 *)(18 - v13), (unsigned __int8 *)v10[6], (unsigned __int8 *)-v13);
        v10[6] = v17;
      }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    ++v6;
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

  sub_100242FAC((uint64_t)v10);
  return v4;
}

  id v6 = (os_log_s *)qword_1008F7578;
  int v7 = os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT);
  uint64_t v2 = *(unsigned int *)(a1 + 552);
  if (v7)
  {
    *(_DWORD *)buf = 67109120;
    unsigned int v11 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Read from CFPRefs. Default airplane mode grant list state is %d",  buf,  8u);
    uint64_t v2 = *(unsigned int *)(a1 + 552);
  }

LABEL_13:
  sub_100242FAC((uint64_t)v9);
  return v2;
}

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    if (sub_10043D5D0(a1)) {
      return sub_100242FAC((uint64_t)v8);
    }
    goto LABEL_11;
  }

  if (v4)
  {
    if (v4 != 1) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }

  uint64_t v5 = sub_10043DBC8(a1);
  if ((_DWORD)v5)
  {
    sub_100242F54((uint64_t)v8);
    sub_10043B88C(a1, v5);
  }

  return sub_100242FAC((uint64_t)v8);
}

  sub_100242CD8(&v3);
  return v0;
}

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

  std::to_string(&v15, __val[0]);
  unsigned int v11 = *(void *)(a1 + 1112);
  id v12 = (void **)(v11 + 104);
  if (*(char *)(v11 + 127) < 0) {
LABEL_11:
  }
    operator delete(*v12);
LABEL_12:
  uint64_t result = *(double *)&v15.__r_.__value_.__l.__data_;
  *(std::string *)id v12 = v15;
  return result;
}

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

  return 0LL;
}

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v12 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v10);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v12);
    xpc_release(v12);
  }

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    id v12 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v10);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v12);
    xpc_release(v12);
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

  *(_BYTE *)(v5 + 41) = 1;
  sub_100242F54((uint64_t)v20);
  uint64_t v15 = *(void *)(v5 + 48);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  v18[2] = sub_10057AEF0;
  v18[3] = &unk_10087EB20;
  v18[4] = v5;
  sub_100405384(v15, v18);
  uint64_t v16 = (os_log_s *)qword_1008F7648;
  if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
  {
    else {
      id v17 = 1;
    }
    *(_DWORD *)buf = 67109120;
    id v22 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Stack supports %d advertising instances",  buf,  8u);
  }

  sub_100242CD8(&v19);
  return sub_100242FAC((uint64_t)v20);
}

  sub_100242F54((uint64_t)v34);
  if (([v11 isEqualToString:@"HasBuiltinServices"] & 1) != 0
    || [v11 isEqualToString:@"DoNotAutoConnect"])
  {
    sub_1005CB544(a1, 1);
  }

  if ([v11 isEqualToString:@"IsAppleWatch"])
  {
    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_1008A34D8);
    }
    sub_100626C8C(qword_1008D5F18, v5);
  }

  if ([v11 isEqualToString:@"BluetoothTVRemote"])
  {
    sub_10002418C(v28, "DoNotStopAutoConnecting");
    sub_1002EE40C(v12, (const void **)v28);
    if (v29 < 0) {
      operator delete(v28[0]);
    }
  }

  memset(buf, 0, 32);
  *(_DWORD *)buf = *(_DWORD *)(a1 + 256);
  sub_100240540(&buf[8], a1 + 264);
  v24._os_unfair_lock_opaque = *(_DWORD *)buf;
  __dst = 0LL;
  v27 = 0LL;
  v25 = 0LL;
  uint64_t v15 = *(const void **)&buf[8];
  uint64_t v16 = *(void *)&buf[16] - *(void *)&buf[8];
  if (*(void *)&buf[16] != *(void *)&buf[8])
  {
    sub_10023DBC8(&v25, v16 >> 3);
    id v17 = (char *)__dst;
    memmove(__dst, v15, v16);
    __dst = &v17[8 * (v16 >> 3)];
  }

  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  v22[2] = sub_1005CE6F8;
  v22[3] = &unk_1008A33D0;
  id v23 = v5;
  sub_1005DC3A4(&v24, v22);
  if (v25)
  {
    __dst = v25;
    operator delete(v25);
  }

  int v7 = *(void **)&buf[8];
  if (*(void *)&buf[8])
  {
    *(void *)&buf[16] = *(void *)&buf[8];
    operator delete(*(void **)&buf[8]);
  }

  id v12 = sub_1002E8D54();
  sub_1001FC8A8(v12 + 368, v1 + 40);
  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_1008A4038);
  }
  sub_100431644((uint64_t)off_1008D60A8, v1 + 2216);
  sub_1005E4988(v1);
  *(_BYTE *)(v1 + 4383) = 0;
  if (v15)
  {
    uint64_t v16 = (uint64_t *)v15;
    operator delete(v15);
  }

      int v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          id v8 = v7;
          int v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          id v8 = (void *)v4[2];
          id v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != (void *)(a1 + 2048));
  }

  sub_1002CD254(v3);
}

    uint64_t v5 = (uint64_t *)((char *)v5 + 1);
  }

  while (v5 != v4);
  return (v6 == v4 || v6 != a2) && a3 != 32;
}

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

  *a2 = v8;
  return v5;
}

    (***(void (****)(void, uint64_t))(a1 + 32))(*(void *)(a1 + 32), a1);
    goto LABEL_11;
  }

  return v8;
}

void sub_10001E954( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_10001E970(uint64_t a1, int a2, xpc_object_t xstring)
{
  string_ptr = xpc_string_get_string_ptr(xstring);
  if (!string_ptr) {
    return 1LL;
  }
  int v5 = strcasecmp(string_ptr, *(const char **)(a1 + 40));
  uint64_t result = 1LL;
  if (!v5)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

BOOL sub_10001E9C4(uint64_t a1, int a2, xpc_object_t xstring)
{
  string_ptr = xpc_string_get_string_ptr(xstring);
  if (!string_ptr) {
    return 1LL;
  }
  BOOL result = strcasecmp(string_ptr, *(const char **)(a1 + 40)) != 0;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void sub_10001EF28(uint64_t a1, void *a2)
{
  id v21 = a2;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) activatedDiscovery]);

  int v5 = v21;
  if (v3 == v4)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v21 identifier]);
    if (v6)
    {
      int v7 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) deviceMap]);
      if (!v7)
      {
        int v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        [*(id *)(a1 + 40) setDeviceMap:v7];
      }

      -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v21, v6);
      id v8 = *(id *)(*(void *)(a1 + 48) + 392LL);
      if (v8)
      {
        if ([*(id *)(a1 + 32) keepAlive])
        {
          int v9 = *(_DWORD *)(*(void *)(a1 + 48) + 140LL);
          BOOL v10 = (v9 & ~[*(id *)(a1 + 32) memoryPressureFlags]) == 0;
        }

        else
        {
          BOOL v10 = 0LL;
        }

        unsigned int v11 = xpc_event_publisher_set_subscriber_keepalive(v8, *(void *)(a1 + 56), v10);
        xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_string(v12, "eventType", "deviceFound");
        id v13 = (void *)objc_claimAutoreleasedReturnValue([v21 xpcEventRepresentation]);
        xpc_dictionary_set_value(v12, "device", v13);

        unsigned int v14 = xpc_event_publisher_fire(v8, *(void *)(a1 + 56), v12);
        if (dword_1008D5FD8 <= 30)
        {
          unsigned int v15 = v14;
          if (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))
          {
            uint64_t v16 = *(void *)(a1 + 56);
            if (v10) {
              id v17 = "yes";
            }
            else {
              id v17 = "no";
            }
            if (v11) {
              uint64_t v18 = v11;
            }
            else {
              uint64_t v18 = v15;
            }
            uint64_t v19 = CUPrintErrorCode(v18);
            __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
            LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _xpcPublisherDiscoveryAddToken:info:]_block_invoke",  30LL,  "XPC subscriber found device: token %llu, keepAlive %s, %@, %@",  v16,  v17,  v20,  v21);
          }
        }
      }
    }

    int v5 = v21;
  }
}

void sub_10001F140(uint64_t a1, void *a2)
{
  id v21 = a2;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) activatedDiscovery]);

  int v5 = v21;
  if (v3 == v4)
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v21 identifier]);
    if (v6)
    {
      int v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) deviceMap]);
      [v7 setObject:0 forKeyedSubscript:v6];
      id v8 = *(id *)(*(void *)(a1 + 48) + 392LL);
      if (v8)
      {
        xpc_object_t v9 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_string(v9, "eventType", "deviceLost");
        BOOL v10 = (void *)objc_claimAutoreleasedReturnValue([v21 xpcEventRepresentation]);
        xpc_dictionary_set_value(v9, "device", v10);

        unsigned int v11 = xpc_event_publisher_fire(v8, *(void *)(a1 + 56), v9);
        if ([*(id *)(a1 + 32) keepAlive] && objc_msgSend(v7, "count"))
        {
          int v12 = *(_DWORD *)(*(void *)(a1 + 48) + 140LL);
          BOOL v13 = (v12 & ~[*(id *)(a1 + 32) memoryPressureFlags]) == 0;
        }

        else
        {
          BOOL v13 = 0LL;
        }

        unsigned int v14 = xpc_event_publisher_set_subscriber_keepalive(v8, *(void *)(a1 + 56), v13);
        if (dword_1008D5FD8 <= 30)
        {
          unsigned int v15 = v14;
          if (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL))
          {
            uint64_t v16 = *(void *)(a1 + 56);
            if (v13) {
              id v17 = "yes";
            }
            else {
              id v17 = "no";
            }
            if (v11) {
              uint64_t v18 = v11;
            }
            else {
              uint64_t v18 = v15;
            }
            uint64_t v19 = CUPrintErrorCode(v18);
            __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
            LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer _xpcPublisherDiscoveryAddToken:info:]_block_invoke_2",  30LL,  "XPC subscriber lost device: token %llu, keepAlive %s, %@, %@",  v16,  v17,  v20,  v21);
          }
        }
      }
    }

    int v5 = v21;
  }
}

void sub_10001F578(id a1)
{
  unsigned int DeviceClass = GestaltGetDeviceClass(a1);
  byte_1008D9E20 = (DeviceClass < 0xE) & (0x20C2u >> DeviceClass);
}

void sub_10001F5FC(id a1)
{
  byte_1008D9E21 = GestaltGetDeviceClass(a1) == 13;
}

void sub_10001F69C(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 120LL);
  if (!v2)
  {
    uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSMutableOrderedSet);
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = *(void **)(v4 + 120);
    *(void *)(v4 + 120) = v3;

    uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 120LL);
  }

  [*(id *)(*(void *)(a1 + 32) + 120) addObject:*(void *)(a1 + 40)];
  uint64_t v6 = *(void *)(a1 + 32);
  if (!*(void *)(v6 + 128))
  {
    dispatch_source_t v7 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v6 + 88));
    uint64_t v8 = *(void *)(a1 + 32);
    xpc_object_t v9 = *(void **)(v8 + 128);
    *(void *)(v8 + 12_Block_object_dispose(va, 8) = v7;
    BOOL v10 = v7;

    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_10001F7C0;
    v12[3] = &unk_10087EFC8;
    uint64_t v11 = *(void *)(a1 + 32);
    v12[4] = v10;
    v12[5] = v11;
    dispatch_source_set_event_handler(v10, v12);
    CUDispatchTimerSet(v10, 900.0, -1.0, 1.0);
    dispatch_activate(v10);
  }

void sub_10001F7C0(uint64_t a1)
{
  if (*(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 128LL))
  {
    if (dword_1008D5FD8 <= 30
      && (dword_1008D5FD8 != -1 || _LogCategory_Initialize(&dword_1008D5FD8, 30LL)))
    {
      LogPrintF_safe( &dword_1008D5FD8,  "-[CBDaemonServer addLostDeviceToLostCBSpatialDevicesIfNeeded:]_block_invoke_2",  30LL,  "Wipe Lost Spatial Devices Array Fired: ");
    }

    uint64_t v2 = *(void **)(*(void *)(a1 + 40) + 128LL);
    if (v2)
    {
      uint64_t v3 = v2;
      dispatch_source_cancel(v3);
      uint64_t v4 = *(void *)(a1 + 40);
      int v5 = *(void **)(v4 + 128);
      *(void *)(v4 + 12_Block_object_dispose(va, 8) = 0LL;
    }

    uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableOrderedSet);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = *(void **)(v7 + 120);
    *(void *)(v7 + 120) = v6;
  }

void sub_10001FC24(id a1)
{
  os_log_t v1 = os_log_create("com.apple.bluetooth", "CBDaemonServerStatedump");
  uint64_t v2 = (void *)qword_1008D9E10;
  qword_1008D9E10 = (uint64_t)v1;
}

LABEL_13:
    uint64_t v18 = 0LL;
    goto LABEL_8;
  }

  v25[0] = v7;
  v25[1] = v8;
  v25[2] = v9;
  v25[3] = v10;
  v25[4] = BYTE1(v12);
  v25[5] = v11;
  unsigned int v14 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v25, 6LL);
  -[CBDevice setBtAddressData:](v6, "setBtAddressData:", v14);

  v27[0] = 0LL;
  v27[1] = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_10087F720);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, v13, 1u, 1u, 0LL, 0LL, (unsigned __int8 *)v27);
  unsigned int v15 = sub_100241F94((const unsigned __int8 *)v27);
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
  id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 UUIDString]);
  if (v17)
  {
    -[CBDevice setIdentifier:](v6, "setIdentifier:", v17);
    uint64_t v18 = v6;
  }

  else if (a4)
  {
    uint64_t v24 = CBErrorF(4294960588LL, "Get device identifier failed");
    uint64_t v18 = 0LL;
    *a4 = (id)objc_claimAutoreleasedReturnValue(v24);
  }

  else
  {
    uint64_t v18 = 0LL;
  }

LABEL_8:
  return v18;
}

  uint64_t v18 = 0LL;
  id v17 = 0LL;
  v16[0] = (int)v11;
  v16[1] = (int)v20;
  v16[2] = v19;
  if (v7 == 1)
  {
    WORD1(v17) = 1;
    switch(v6)
    {
      case -1:
        WORD1(v1_Block_object_dispose(va, 8) = 1;
        break;
      case 1:
        WORD2(v1_Block_object_dispose(va, 8) = 1;
        break;
      case 0:
        LOWORD(v1_Block_object_dispose(va, 8) = 1;
        break;
    }
  }

  else if (v8 == 5)
  {
    HIWORD(v17) = 1;
  }

  else if (v8 == 1)
  {
    WORD2(v17) = 1;
  }

  LOWORD(v17) = 1;
  unsigned int v15 = sub_1002E8D94();
  (*(void (**)(uint64_t, _DWORD *))(*(void *)v15 + 32LL))(v15, v16);
}

  BOOL result = sub_10007EC44();
  if (!result)
  {
    sub_1001EE134((uint64_t)"No free AACP connection slot ", v25, v26, v27, v28, v29, v30, v31, v33);
    __int128 v32 = (os_log_s *)sub_100086554(0x53u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return sub_1001759FC(a2, 436LL);
    }
    goto LABEL_6;
  }

  unsigned int v15 = (uint64_t (**)(int *))qword_1008F1F70;
  *(void *)(result + 24) = qword_1008F1F70;
  *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v16 = *(_DWORD *)a1;
  *(_WORD *)(result + 5) = *((_WORD *)a1 + 2);
  *(_DWORD *)(result + 1) = v16;
  *(_DWORD *)(result + 32) = 0;
  if (v15 && *v15) {
    return (*v15)((int *)a1);
  }
  return result;
}

  if (!sub_1000A86F0()
    || (sub_1001EE134((uint64_t)"MatchBufferRead sub-opcode incorrect: %d, %!", v18, v19, v20, v21, v22, v23, v24, v14),
        v25 = (os_log_s *)sub_100086554(0x54u),
        !os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)))
  {
    if (!a2) {
      return;
    }
    goto LABEL_16;
  }

  sub_100657F74();
  if (a2) {
LABEL_16:
  }
    a2(a1, v14, v13);
}

  if (!a4 && a6)
  {
    unsigned int v14 = 0LL;
LABEL_19:
    BOOL v13 = sub_1000E570C(v14, a5) + 3;
    goto LABEL_20;
  }

  BOOL v13 = v12 + 2;
  if (a4 && a6)
  {
    unsigned int v14 = (uint64_t)a4;
    goto LABEL_19;
  }

          int v5 = 1744LL;
        }
      }

      else if (!*v7)
      {
        if (v9 != 16) {
          goto LABEL_13;
        }
        *(_OWORD *)(v3 + 77) = *(_OWORD *)(v6 + v8);
      }
  }

  BOOL v10 = &qword_1008F29F0[134 * v8];
  while (*((_BYTE *)v10 + 24) != 2 || !v10[2])
  {
    uint64_t v11 = *((unsigned __int8 *)v10 + 1082);
    v10 += 134;
    if (++v9 >= v11)
    {
      uint64_t v8 = v9;
      goto LABEL_13;
    }
  }

  unsigned int v14 = (858993460 * (unint64_t)(8 * a2)) >> 32;
  int v12 = sub_1001214B4(85, 0LL, a3, a4, a5, a6, a7, a8, v10[2]);
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"TS setting flush timeout to %d ms with status %!", v15, v16, v17, v18, v19, v20, v21, v14);
    id v22 = (os_log_s *)sub_100086554(0x56u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v24 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  return v12;
}

    ++v3;
  }

  while (v3 != 8);
  if ((v4 & 1) != 0) {
    return sub_100114274();
  }
  else {
    return 0LL;
  }
}

  uint64_t v6 = byte_1008F6E7E;
  if (*(_WORD *)(a1 + 16)) {
    sub_100136534(a1, *(unsigned __int16 *)(a1 + 16));
  }
  switch(*(_BYTE *)(a1 + 2))
  {
    case 0:
      if (BYTE14(xmmword_1008F6E30[0])) {
        uint64_t v7 = v3;
      }
      else {
        uint64_t v7 = 1;
      }
      if ((v7 & 1) != 0) {
        goto LABEL_46;
      }
      if (!WORD3(xmmword_1008F6E30[0]))
      {
        if (!WORD5(xmmword_1008F6E30[0])) {
          goto LABEL_46;
        }
        goto LABEL_40;
      }

      if (WORD5(xmmword_1008F6E30[0]) > 2u) {
LABEL_40:
      }
        (*(void (**)(void, uint64_t))(qword_1008F6D90 + 16))(0LL, 1LL);
LABEL_46:
      if (!sub_10012EB98())
      {
        if (word_1008E22E8) {
          sub_100136534((uint64_t)&xmmword_1008E22D8, (unsigned __int16)word_1008E22E8);
        }
        if (word_1008E2438) {
          sub_100136534((uint64_t)&xmmword_1008E2428, (unsigned __int16)word_1008E2438);
        }
        if (!LOBYTE(xmmword_1008F6E30[0]) || !sub_10012EC68())
        {
          id v17 = WORD5(xmmword_1008F6E30[0]);
          if (WORD5(xmmword_1008F6E30[0]) != WORD4(xmmword_1008F6E30[0]))
          {
            sub_1001EE2A0();
            id v17 = WORD4(xmmword_1008F6E30[0]);
          }

          WORD5(xmmword_1008F6E30[0]) = v17;
          BYTE14(xmmword_1008F6E30[0]) = 1;
          uint64_t v18 = v17 > 2;
          uint64_t v19 = v17 != 0;
          if (WORD3(xmmword_1008F6E30[0])) {
            uint64_t v19 = v18;
          }
          byte_1008F6E91 = v19;
        }

        sub_100137518();
      }

      if (!sub_10012EC68())
      {
        id v23 = 0LL;
        word_1008F6E5A = word_1008F6E58;
        byte_1008F6E5E = 1;
        if (LOBYTE(xmmword_1008F6E30[0]))
        {
          __int128 v20 = BYTE14(xmmword_1008F6E30[0]);
          if (BYTE14(xmmword_1008F6E30[0]))
          {
            __int128 v20 = WORD5(xmmword_1008F6E30[0]) != 0;
            if (WORD3(xmmword_1008F6E30[0])) {
              __int128 v20 = WORD5(xmmword_1008F6E30[0]) > 2u;
            }
          }
        }

        else
        {
          __int128 v20 = word_1008F6E58 != 0;
        }

        byte_1008F6E92 = v20;
        while (sub_10012ECBC(&v23))
        {
          if (*(_BYTE *)(v23 + 124) == 7) {
            *(_WORD *)(v23 + 16) = 0;
          }
        }
      }

      if (!sub_10012ED88())
      {
        id v21 = word_1008F6E7A;
        if (word_1008F6E7A != word_1008F6E78)
        {
          sub_1001EE2A0();
          id v21 = word_1008F6E78;
        }

        word_1008F6E7A = v21;
        byte_1008F6E7E = 1;
        byte_1008F6E90 = 1;
      }

      if (!sub_10012EB98() && !sub_10012EC68() && !sub_10012ED88())
      {
        if (byte_1008E2653 == 1)
        {
          if (WORD1(xmmword_1008F6E30[0])) {
            sub_1001EE2A0();
          }
        }

        WORD1(xmmword_1008F6E30[0]) = 0;
      }

      return;
    case 1:
      if (*(_WORD *)(a1 + 16)) {
        sub_10011B2C0(a1, *(unsigned __int16 *)(a1 + 16));
      }
      goto LABEL_46;
    case 4:
      if ((v4 & 1) != 0) {
        goto LABEL_46;
      }
      if (LOBYTE(xmmword_1008F6E30[0]))
      {
        if (!BYTE14(xmmword_1008F6E30[0])) {
          goto LABEL_44;
        }
        uint64_t v16 = WORD5(xmmword_1008F6E30[0]);
        if (WORD3(xmmword_1008F6E30[0]))
        {
          if (WORD5(xmmword_1008F6E30[0]) > 2u) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }
      }

      else
      {
        if (!byte_1008F6E5E) {
          goto LABEL_44;
        }
        uint64_t v16 = (unsigned __int16)word_1008F6E5A;
      }

      if (v16) {
        goto LABEL_45;
      }
LABEL_44:
      if (!*(_BYTE *)(a1 + 129)) {
        goto LABEL_46;
      }
LABEL_45:
      (*(void (**)(void, uint64_t))(qword_1008F6D90 + 16))(0LL, 3LL);
      goto LABEL_46;
    case 8:
      if (!v6 && byte_1008F6E7E) {
        (*(void (**)(void, uint64_t))(qword_1008F6D90 + 16))(0LL, 5LL);
      }
      goto LABEL_46;
    default:
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Unknown connection type.", v8, v9, v10, v11, v12, v13, v14, v22);
        unsigned int v15 = (os_log_s *)sub_100086554(0x2Eu);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      goto LABEL_46;
  }

  sub_1001EE134((uint64_t)"SubOpcode Incorrect %!", v20, v21, v22, v23, v24, v25, v26, a1);
  v27 = (os_log_s *)sub_100086554(0x54u);
  if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
    goto LABEL_15;
  }
  sub_100657F74();
  if (a2) {
LABEL_16:
  }
    a2(a1, v16, v15, v14, v13);
}

  sub_1001EE134((uint64_t)"SubOpcode Incorrect %!", v20, v21, v22, v23, v24, v25, v26, a1);
  v27 = (os_log_s *)sub_100086554(0x54u);
  if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
    goto LABEL_15;
  }
  sub_100657F74();
  if (a2) {
LABEL_16:
  }
    a2(a1, v16, v15, v14, v13);
}

    v9[0] = (const void *)2;
    v9[1] = (const void *)(v2 + 24);
    sub_1001EE6E8((uint64_t)sub_100189A00, v9, 0, 0LL);
    goto LABEL_14;
  }

  if (sub_1001EC434(*(void *)v2))
  {
    uint64_t v4 = sub_1001EC434(*(void *)v2);
  }

  sub_1001EE2A0();
  uint64_t v6 = 0LL;
LABEL_14:
  uint64_t v7 = *(void **)v6;
  if (!*(_WORD *)(v6 + 14))
  {
    sub_1000B1838(*(void **)v6);
    uint64_t v18 = sub_1000B17F4(v3);
    *(void *)uint64_t v6 = v18;
    if (v18)
    {
LABEL_35:
      BOOL result = 0LL;
      *(_WORD *)(v6 + 12) = v3;
      return result;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Could not allocate new reassembly buffer", v19, v20, v21, v22, v23, v24, v25, v38);
      v26 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    v27 = sub_1000B17F4(*(unsigned __int16 *)(v6 + 12));
    *(void *)uint64_t v6 = v27;
    if (!v27) {
      sub_1001EE2A0();
    }
    return 106LL;
  }

  uint64_t v8 = sub_1000B17F4(v3);
  *(void *)uint64_t v6 = v8;
  if (v8)
  {
    xpc_object_t v9 = *(unsigned __int16 *)(v6 + 14);
    if (v9 <= v3)
    {
      memmove(v8, v7, v9);
    }

    else
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"The new MTU is smaller than the current data size we have in the buffer ... dropping the current data (curRecvCount == %d, newBufsize=%d)",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  *(unsigned __int16 *)(v6 + 14));
        id v17 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      *(_WORD *)(v6 + 14) = 0;
      *(_BYTE *)(v6 + 16) = 0;
    }

    sub_1000B1838(v7);
    goto LABEL_35;
  }

  *(void *)uint64_t v6 = v7;
  id v28 = *(unsigned __int16 *)(v6 + 12);
  BOOL result = sub_1000A86F0();
  if (v3 >= v28)
  {
    if ((_DWORD)result)
    {
      sub_1001EE134((uint64_t)"No resources for larger reassembly buffer", v29, v30, v31, v32, v33, v34, v35, v38);
      __int128 v37 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 106LL;
  }

  if ((_DWORD)result)
  {
    sub_1001EE134( (uint64_t)"Could not allocate new reassembly buffer - continuing with existing buffer",  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v38);
    __int128 v36 = (os_log_s *)sub_100086554(0x2Fu);
    BOOL result = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_100657858();
      return 0LL;
    }
  }

  return result;
}

  if (v16 >= (unsigned __int16)(a7 + 7))
  {
    uint64_t v18 = (char *)sub_1000B1814((unsigned __int16)(a7 + 7));
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = v18;
    if (v18)
    {
      *uint64_t v18 = 6;
      *(_WORD *)(v18 + 1) = a4;
      *(_WORD *)(v18 + 3) = v11;
      *(_WORD *)(v18 + 5) = a3;
      memmove((void *)(*(void *)(a1 + 48) + 7LL), a6, a7);
      BOOL v10 = sub_1001A2950(a1);
      if (!(_DWORD)v10) {
        return v10;
      }
    }

    else
    {
      BOOL v10 = 106LL;
    }
  }

  else
  {
    BOOL v10 = 142LL;
  }

  uint64_t v19 = *(void **)(a1 + 48);
  if (v19) {
    sub_1000B1838(v19);
  }
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)xpc_object_t v9 = 0LL;
  *(void *)(v9 + _Block_object_dispose(va, 8) = 0LL;
  *(_WORD *)(v9 + 16) = 0;
  return v10;
}

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Encryption failed due to %!, aborting connection notifications, waiting for disconnection event",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  a2);
      uint64_t v19 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    return;
  }

  uint64_t v18 = (char *)sub_1000B17F4(24LL * v6 + 24);
  uint64_t v19 = (uint64_t)v18;
  __int128 v20 = (unsigned __int16)word_1008EDAE8;
  if (word_1008EDAE8)
  {
    id v21 = qword_1008EDAE0;
    id v22 = (unsigned __int16)word_1008EDAE8;
    id v23 = v18;
    do
    {
      uint64_t v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = *(void *)(v21 + 16);
      *(_OWORD *)id v23 = v24;
      v23 += 24;
      v21 += 24LL;
      --v22;
    }

    while (v22);
  }

  v25 = &v18[24 * v20];
  *(_OWORD *)(v25 + 7) = *a2;
  v26 = *a1;
  v27 = *((_WORD *)a1 + 2);
  v25[6] = *((_BYTE *)a1 + 6);
  *((_WORD *)v25 + 2) = v27;
  *(_DWORD *)v25 = v26;
  v25[23] = a3;
  if (qword_1008EDAE0) {
    sub_1000B1838((void *)qword_1008EDAE0);
  }
  qword_1008EDAE0 = v19;
  word_1008EDAE8 = v20 + 1;
  return 0LL;
}

      ++v10;
      v9 += 24LL;
    }

    v12[16] = 0;
    unsigned int v14 = (char *)sub_1000B17F4(*(unsigned __int16 *)(v11 + 18));
    *((void *)v12 + 3) = v14;
    if (!v14)
    {
      *((_WORD *)v12 + 9) = 0;
      goto LABEL_13;
    }

    unsigned int v15 = *(const void **)(a2 + v9 + 24);
    goto LABEL_10;
  }

  if ([v4 isAdvToBrowserConnection])
  {
    id v17 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained advToBrowserNwToSFendpoints]);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteEndpoint]);
    [v17 removeObjectForKey:v18];

    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteUniqueIDString]);
    __int128 v20 = v19 == 0LL;

    if (!v20)
    {
      id v21 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained advToBrowserUuidToSFendpoints]);
      id v22 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteUniqueIDString]);
      [v21 removeObjectForKey:v22];
    }

    [WeakRetained _updateAdvertiserState];
  }

  else
  {
    id v23 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained browserToAdvNwToSFendpoints]);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteEndpoint]);
    [v23 removeObjectForKey:v24];

    v25 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteUniqueIDString]);
    v26 = v25 == 0LL;

    if (!v26)
    {
      v27 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained browserToAdvUuidToSFendpoints]);
      id v28 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteUniqueIDString]);
      [v27 removeObjectForKey:v28];
    }

    [WeakRetained _updateBrowserState];
  }

    uint64_t v11 = 2;
    goto LABEL_14;
  }

  if (*((_BYTE *)off_1008D6190 + 198)) {
    uint64_t v11 = 2;
  }
  else {
    uint64_t v11 = *(_DWORD *)(a1 + 164);
  }
LABEL_14:
  int v12 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v13 = *(_DWORD *)(a1 + 164);
    unsigned int v14 = "true";
    *(_DWORD *)buf = 67109634;
    if (!v8) {
      unsigned int v14 = "false";
    }
    *(_DWORD *)&buf[4] = a3;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v13;
    *(_WORD *)v54 = 2080;
    *(void *)&v54[2] = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Audio Timesync: Trigger updateReferenceTimeStampHardWareTrigger %d Accuracy %d, HfpStreaming %s",  buf,  0x18u);
  }

  *(void *)(a1 + 192) = a2;
  unsigned int v15 = a4 - 1;
  if ((a4 - 1) < 2)
  {
    uint64_t v16 = 3;
    if (v11 != 2)
    {
      if (v11 != 1)
      {
LABEL_84:
        v43 = (os_log_s *)qword_1008F7570;
        if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
        {
          v44 = (uint64_t **)(a1 + 200);
          v52 = 1;
          *(void *)buf = &v52;
          v45 = *((_DWORD *)sub_100275FD4(v44, &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8);
          v51 = 2;
          *(void *)buf = &v51;
          v46 = *((_DWORD *)sub_100275FD4(v44, &v51, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8);
          v50 = 3;
          *(void *)buf = &v50;
          v47 = *((_DWORD *)sub_100275FD4(v44, &v50, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8);
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&buf[4] = v45;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v46;
          *(_WORD *)v54 = 1024;
          *(_DWORD *)&v54[2] = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Audio Timesync: States: SpatialHigh: %d, SpatialLow: %d, SensorLow: %d",  buf,  0x14u);
        }

        return;
      }

      goto LABEL_51;
    }

    uint64_t v11 = 3;
    goto LABEL_29;
  }

  if (!a4)
  {
    if (v11 == 1)
    {
      uint64_t v16 = 1;
LABEL_51:
      if (a3)
      {
        v52 = 3;
        *(void *)buf = &v52;
        if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) > 0
          || (v52 = 2,
              *(void *)buf = &v52,
              *((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) >= 1))
        {
          __int128 v31 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Audio Timesync: Start Spatial High, Low is running, stop it first",  buf,  2u);
          }

          sub_100274BCC(a1, a2, 0, 2);
        }

        v52 = 1;
        *(void *)buf = &v52;
        if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) < 1)
        {
          sub_100274BCC(a1, a2, 1, 1);
        }

        else
        {
          __int128 v32 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "Audio Timesync: Start Spatial High, High is running, do nothing",  buf,  2u);
          }
        }

        __int128 v35 = a1;
        __int128 v36 = v16;
LABEL_78:
        sub_100274ED4(v35, v36, 1);
        goto LABEL_84;
      }

      v52 = 1;
      *(void *)buf = &v52;
      if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) <= 0)
      {
        __int128 v33 = qword_1008F7570;
        if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_84;
        }
        *(_WORD *)buf = 0;
        __int128 v34 = "Audio Timesync: Stop Spatial High, No High is running, do nothing";
        goto LABEL_68;
      }

      sub_100274ED4(a1, v16, 0);
      v52 = 1;
      *(void *)buf = &v52;
      if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) >= 1)
      {
        __int128 v33 = qword_1008F7570;
        if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_84;
        }
        *(_WORD *)buf = 0;
        __int128 v34 = "Audio Timesync: Stop Spatial High, High is still running, do nothing";
LABEL_68:
        __int128 v37 = (os_log_s *)v33;
        uint64_t v38 = 2;
        goto LABEL_83;
      }

      sub_100274BCC(a1, a2, 0, 1);
      v52 = 3;
      *(void *)buf = &v52;
      v39 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Audio Timesync: After Stop Spatial High, Sensor Low exists, resume it",  buf,  2u);
      }

      v40 = a1;
      v41 = a2;
      v42 = 1;
LABEL_93:
      sub_100274BCC(v40, v41, v42, 2);
      goto LABEL_84;
    }

    if (v11 == 2)
    {
LABEL_29:
      if (a3)
      {
        v52 = 1;
        *(void *)buf = &v52;
        if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) <= 0
          && (v52 = 2,
              *(void *)buf = &v52,
              *((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) <= 0)
          && (v52 = 3,
              *(void *)buf = &v52,
              *((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) < 1))
        {
          sub_100274BCC(a1, a2, 1, 2);
        }

        else
        {
          v25 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            if (v15 >= 2) {
              v26 = "Spatial Low";
            }
            else {
              v26 = "Sensor Low";
            }
            v52 = 1;
            *(void *)buf = &v52;
            if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) <= 0)
            {
              v52 = 2;
              *(void *)buf = &v52;
              if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf)
                   + 8) <= 0)
                v27 = "Sensor Low";
              else {
                v27 = "Spatial Low";
              }
            }

            else
            {
              v27 = "Spatial High";
            }

            *(_DWORD *)buf = 136315394;
            *(void *)&buf[4] = v26;
            *(_WORD *)&buf[12] = 2080;
            *(void *)v54 = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Audio Timesync: Start %s, %s is running, do nothing",  buf,  0x16u);
          }
        }

        __int128 v35 = a1;
        __int128 v36 = v11;
        goto LABEL_78;
      }

      v52 = 2;
      *(void *)buf = &v52;
      if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) <= 0)
      {
        v52 = 3;
        *(void *)buf = &v52;
        if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) <= 0)
        {
          v48 = qword_1008F7570;
          if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_84;
          }
          v49 = "Spatial Low";
          if (v15 < 2) {
            v49 = "Sensor Low";
          }
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v49;
          __int128 v34 = "Audio Timesync: Stop %s, not running, do nothing";
          __int128 v37 = (os_log_s *)v48;
          uint64_t v38 = 12;
LABEL_83:
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v34, buf, v38);
          goto LABEL_84;
        }
      }

      sub_100274ED4(a1, v11, 0);
      v52 = 1;
      *(void *)buf = &v52;
      if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) > 0
        || (v52 = 2,
            *(void *)buf = &v52,
            *((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) > 0)
        || (v52 = 3,
            *(void *)buf = &v52,
            *((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) >= 1))
      {
        id v28 = qword_1008F7570;
        if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_84;
        }
        if (v15 >= 2) {
          uint64_t v29 = "Spatial Low";
        }
        else {
          uint64_t v29 = "Sensor Low";
        }
        v52 = 1;
        *(void *)buf = &v52;
        if (*((int *)sub_100275FD4((uint64_t **)(a1 + 200), &v52, (uint64_t)&unk_1006C2518, (unsigned int **)buf) + 8) <= 0)
        {
          if (sub_100274B7C(a1)) {
            uint64_t v30 = "Spatial Low";
          }
          else {
            uint64_t v30 = "Sensor Low";
          }
        }

        else
        {
          uint64_t v30 = "Spatial High";
        }

        *(_DWORD *)buf = 136315394;
        *(void *)&buf[4] = v29;
        *(_WORD *)&buf[12] = 2080;
        *(void *)v54 = v30;
        __int128 v34 = "Audio Timesync: Stop %s, %s is running, do nothing";
        __int128 v37 = (os_log_s *)v28;
        uint64_t v38 = 22;
        goto LABEL_83;
      }

      v40 = a1;
      v41 = a2;
      v42 = 0;
      goto LABEL_93;
    }
  }

  id v17 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
    sub_100665848(v17, v18, v19, v20, v21, v22, v23, v24);
  }
}

  uint64_t v7 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  uint64_t v8 = *(void **)(v2 + 64);
  *(void *)(v2 + 64) = v7;

  xpc_object_t v9 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  BOOL v10 = *(void **)(a1 + 304);
  *(void *)(a1 + 304) = v9;

  uint64_t v11 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  int v12 = *(void **)(a1 + 328);
  *(void *)(a1 + 32_Block_object_dispose(va, 8) = v11;

  mach_timebase_info((mach_timebase_info_t)(a1 + 184));
  BOOL v13 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  unsigned int v14 = *(void **)(a1 + 336);
  *(void *)(a1 + 336) = v13;

  unsigned int v15 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  uint64_t v16 = *(void **)(a1 + 344);
  *(void *)(a1 + 344) = v15;

  return a1;
}

    uint64_t v7 = 114;
    goto LABEL_14;
  }

  if (!a3)
  {
    BOOL v13 = qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v1_Block_object_dispose(va, 8) = 0;
      BOOL v10 = "Error sending SensorIncreaseScanParams, rssiIncreaseScanThreshold is disabled : %d ";
      uint64_t v11 = (os_log_s *)v13;
      int v12 = 8;
      goto LABEL_12;
    }

    goto LABEL_13;
  }

  uint64_t v7 = sub_10018F444();
LABEL_14:
  sub_100242CD0(&v15);
  if (!v7)
  {
    if (qword_1008D60B0 != -1) {
      dispatch_once(&qword_1008D60B0, &stru_10088DAE8);
    }
    uint64_t v7 = sub_1004336D8((uint64_t)off_1008D60A8, 202LL);
  }

  sub_1002D06F4(a1, 0xCAu);
  uint64_t v8 = v7 != 0;
  sub_100242CD8(&v15);
LABEL_19:
  sub_100242FAC((uint64_t)v16);
  return v8;
}

      uint64_t v7 = *(unsigned __int8 *)(a1 + 401);
LABEL_15:
      BOOL result = v7 != 0;
      break;
  }

  return result;
}

  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
}

  uint64_t v7 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F0198) {
      uint64_t v8 = "enabled";
    }
    else {
      uint64_t v8 = "disabled";
    }
    xpc_object_t v9 = sub_1002E6E9C();
    BOOL v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 2672LL))(v9);
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = v8;
    unsigned int v15 = 1024;
    uint64_t v16 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Support for LE Connection Prioritization is %s (hw capability %{BOOL}d)",  buf,  0x12u);
  }

  sub_100242FAC((uint64_t)v22);
  return v6;
}

      ++v8;
    }

    while (v8 != v9);
  }

  __int128 v20 = (uint64_t *)a1[9];
  for (j = (uint64_t *)a1[10]; v20 != j; ++v20)
  {
    id v22 = *v20;
  }

  return sub_100242FAC((uint64_t)v24);
}

    a6(a2);
    return 1LL;
  }

  uint64_t v18 = (void (*)(void *, unsigned __int16 *, uint64_t, uint64_t, uint64_t))v16;
  uint64_t v19 = (void *)(a1 + (v17 >> 1));
  if ((v17 & 1) != 0) {
    uint64_t v18 = *(void (**)(void *, unsigned __int16 *, uint64_t, uint64_t, uint64_t))(*v19 + v18);
  }
  v18(v19, a2, a3, a4, a5);
  if (a6) {
    goto LABEL_13;
  }
  return 1LL;
}

  objc_destroyWeak(&location);
}

    *(void *)buf = &v23;
    unsigned int v14 = v7;
LABEL_14:
    BOOL result = sub_100029574(v14, &v23, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
    *(_WORD *)(result[5] + 6_Block_object_dispose(va, 8) = 0;
    return result;
  }

  *(void *)buf = &v23;
  BOOL result = sub_100029574(v7, &v23, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
  if (!*(_BYTE *)(result[5] + 71))
  {
    unsigned int v15 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = "No";
      if (a4) {
        uint64_t v16 = "Yes";
      }
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = a3;
      v25 = 2082;
      v26 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "A2DP Link Adaptive Packet Type: Scaling back to 2Mbps Packets support (%d%%) Purged %{public}s",  buf,  0x12u);
    }

    id v17 = sub_1004ABA48(a1, v23);
    uint64_t v18 = sub_1004050C8();
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    v21[2] = sub_1004ABBB8;
    v21[3] = &unk_100893D28;
    id v22 = v17;
    sub_100405384(v18, v21);
    *(void *)buf = &v23;
    *(_BYTE *)(sub_100029574(v7, &v23, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 71) = 1;
    goto LABEL_22;
  }

  return result;
}

    uint64_t v6 = 902LL;
    goto LABEL_14;
  }

  uint64_t v16 = xmmword_1006BDBD0;
  id v17 = 0;
  uint64_t v6 = 0LL;
LABEL_14:

  return v6;
}

    if (v5 != *(_DWORD *)(a1 + 28))
    {
      *(_BYTE *)(a1 + 24) = 0;
      if (os_log_type_enabled((os_log_t)qword_1008F7618, OS_LOG_TYPE_ERROR)) {
        sub_10068BEF0();
      }
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7618, OS_LOG_TYPE_ERROR)) {
      sub_10068BE90();
    }
    *(_BYTE *)(a1 + 24) = 0;
  }

  return a1;
}

    if (v5 != *(_DWORD *)(a1 + 28))
    {
      *(_BYTE *)(a1 + 24) = 0;
      if (os_log_type_enabled((os_log_t)qword_1008F7618, OS_LOG_TYPE_ERROR)) {
        sub_10068C0EC();
      }
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7618, OS_LOG_TYPE_ERROR)) {
      sub_10068C08C();
    }
    *(_BYTE *)(a1 + 24) = 0;
  }

  return a1;
}

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
    sub_1006910D0((uint64_t)a1);
  }
  return (*(uint64_t (**)(void *, uint64_t))(*a1 + 24LL))(a1, 10LL);
}

  id v23 = 0;
  BOOL v13 = sub_1002E6E00();
  sub_10002418C(buf, "GATT");
  sub_10002418C(&__p, "MTU");
  unsigned int v14 = (*(uint64_t (**)(uint64_t, uint8_t *, __n128 *, int *))(*(void *)v13 + 88LL))(v13, buf, &__p, &v23);
  if (v26 < 0) {
    operator delete((void *)__p.n128_u64[0]);
  }
  if (v28 < 0) {
    operator delete(*(void **)buf);
  }
  unsigned int v15 = v23;
  if (v23) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = 0;
  }
  if (v16 == 1)
  {
    id v17 = (os_log_s *)qword_1008F75B0;
    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v15;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Using Gatt MTU override of %d", buf, 8u);
      LOWORD(v15) = v23;
    }

    *(_WORD *)(a1 + 242) = v15;
  }

  *(_BYTE *)(a1 + 244) = 0;
  uint64_t v18 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v18 + 8LL))(v18))
  {
    uint64_t v19 = sub_1002E6E00();
    sub_10002418C(buf, "GATT");
    sub_10002418C(&__p, "StartInitSequenceOnConnectionComplete");
    if ((*(unsigned int (**)(uint64_t, uint8_t *, __n128 *, uint64_t))(*(void *)v19 + 72LL))( v19,  buf,  &__p,  a1 + 244))
    {
      __int128 v20 = *(_BYTE *)(a1 + 244) != 0;
    }

    else
    {
      __int128 v20 = 0;
    }

    if (v26 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
    if (v28 < 0)
    {
      operator delete(*(void **)buf);
      if (!v20) {
        goto LABEL_36;
      }
    }

    else if (!v20)
    {
      goto LABEL_36;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
      sub_1006919A0();
    }
  }

  BOOL v10 = 0LL;
LABEL_22:

  return v10;
}

  uint64_t v7 = operator new(0x10uLL);
  sub_1002DC4AC(v7);
  *(void *)(a1 + 240) = v7;
  uint64_t v8 = -[NSMapTable initWithKeyOptions:valueOptions:capacity:]( objc_alloc(&OBJC_CLASS___NSMapTable),  "initWithKeyOptions:valueOptions:capacity:",  0x10000LL,  256LL,  0LL);
  xpc_object_t v9 = *(void **)(a1 + 160);
  *(void *)(a1 + 160) = v8;

  BOOL v10 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
  uint64_t v11 = *(void **)(a1 + 248);
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = v10;

  int v12 = atomic_load((unsigned __int8 *)&qword_1008F1DF0);
  if ((v12 & 1) == 0 && __cxa_guard_acquire(&qword_1008F1DF0))
  {
    *(_OWORD *)buf = xmmword_1006C44D5;
    v52 = -1797173107;
    qword_1008F1DE8 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
    __cxa_guard_release(&qword_1008F1DF0);
  }

  BOOL v13 = atomic_load((unsigned __int8 *)&qword_1008F1E00);
  if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_1008F1E00))
  {
    *(_OWORD *)buf = xmmword_1006C44E9;
    v52 = -1093463289;
    qword_1008F1DF8 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
    __cxa_guard_release(&qword_1008F1E00);
  }

  v49[0] = @"CORSAIR HARPOON";
  v49[1] = @"Arc Touch BT Mouse";
  v50[0] = qword_1008F1DE8;
  v50[1] = qword_1008F1DF8;
  unsigned int v14 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v50,  v49,  2LL));
  unsigned int v15 = (void *)qword_1008F79B0;
  qword_1008F79B0 = v14;

  uint64_t v16 = atomic_load((unsigned __int8 *)&qword_1008F1E10);
  if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_1008F1E10))
  {
    *(_OWORD *)buf = xmmword_1006C44FD;
    v52 = 1762191246;
    qword_1008F1E08 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
    __cxa_guard_release(&qword_1008F1E10);
  }

  id v17 = atomic_load((unsigned __int8 *)&qword_1008F1E20);
  uint64_t v18 = &unk_1008F1000;
  if ((v17 & 1) == 0)
  {
    uint64_t v38 = __cxa_guard_acquire(&qword_1008F1E20);
    uint64_t v18 = (void *)&unk_1008F1000;
    if (v38)
    {
      *(_OWORD *)buf = xmmword_1006C4511;
      v52 = 1125422200;
      qword_1008F1E18 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
      __cxa_guard_release(&qword_1008F1E20);
      uint64_t v18 = &unk_1008F1000;
    }
  }

  uint64_t v19 = atomic_load((unsigned __int8 *)&qword_1008F1E30);
  __int128 v20 = &unk_1008F1000;
  if ((v19 & 1) == 0)
  {
    v39 = __cxa_guard_acquire(&qword_1008F1E30);
    __int128 v20 = (void *)&unk_1008F1000;
    uint64_t v18 = (void *)&unk_1008F1000;
    if (v39)
    {
      *(_OWORD *)buf = xmmword_1006C4525;
      v52 = -1523135769;
      qword_1008F1E28 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
      __cxa_guard_release(&qword_1008F1E30);
      __int128 v20 = &unk_1008F1000;
      uint64_t v18 = (void *)&unk_1008F1000;
    }
  }

  id v21 = atomic_load((unsigned __int8 *)&qword_1008F1E40);
  id v22 = &unk_1008F1000;
  if ((v21 & 1) == 0)
  {
    v40 = __cxa_guard_acquire(&qword_1008F1E40);
    id v22 = (void *)&unk_1008F1000;
    __int128 v20 = (void *)&unk_1008F1000;
    uint64_t v18 = (void *)&unk_1008F1000;
    if (v40)
    {
      *(_OWORD *)buf = xmmword_1006C4539;
      v52 = -397349432;
      qword_1008F1E38 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
      __cxa_guard_release(&qword_1008F1E40);
      id v22 = &unk_1008F1000;
      uint64_t v18 = (void *)&unk_1008F1000;
      __int128 v20 = (void *)&unk_1008F1000;
    }
  }

  id v23 = atomic_load((unsigned __int8 *)&qword_1008F1E50);
  uint64_t v24 = &unk_1008F1000;
  if ((v23 & 1) == 0)
  {
    v41 = __cxa_guard_acquire(&qword_1008F1E50);
    uint64_t v24 = (void *)&unk_1008F1000;
    id v22 = (void *)&unk_1008F1000;
    __int128 v20 = (void *)&unk_1008F1000;
    uint64_t v18 = (void *)&unk_1008F1000;
    if (v41)
    {
      *(_OWORD *)buf = xmmword_1006C454D;
      v52 = -467746198;
      qword_1008F1E48 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
      __cxa_guard_release(&qword_1008F1E50);
      uint64_t v24 = &unk_1008F1000;
      uint64_t v18 = (void *)&unk_1008F1000;
      __int128 v20 = (void *)&unk_1008F1000;
      id v22 = (void *)&unk_1008F1000;
    }
  }

  v25 = atomic_load((unsigned __int8 *)&qword_1008F1E60);
  v26 = &unk_1008F1000;
  if ((v25 & 1) == 0)
  {
    v42 = __cxa_guard_acquire(&qword_1008F1E60);
    v26 = (void *)&unk_1008F1000;
    uint64_t v24 = (void *)&unk_1008F1000;
    id v22 = (void *)&unk_1008F1000;
    __int128 v20 = (void *)&unk_1008F1000;
    uint64_t v18 = (void *)&unk_1008F1000;
    if (v42)
    {
      *(_OWORD *)buf = xmmword_1006C4561;
      v52 = 255034232;
      qword_1008F1E58 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
      __cxa_guard_release(&qword_1008F1E60);
      v26 = &unk_1008F1000;
      uint64_t v18 = (void *)&unk_1008F1000;
      __int128 v20 = (void *)&unk_1008F1000;
      id v22 = (void *)&unk_1008F1000;
      uint64_t v24 = (void *)&unk_1008F1000;
    }
  }

  v27 = atomic_load((unsigned __int8 *)&qword_1008F1E70);
  id v28 = &unk_1008F1000;
  if ((v27 & 1) == 0)
  {
    v43 = __cxa_guard_acquire(&qword_1008F1E70);
    id v28 = (void *)&unk_1008F1000;
    v26 = (void *)&unk_1008F1000;
    uint64_t v24 = (void *)&unk_1008F1000;
    id v22 = (void *)&unk_1008F1000;
    __int128 v20 = (void *)&unk_1008F1000;
    uint64_t v18 = (void *)&unk_1008F1000;
    if (v43)
    {
      *(_OWORD *)buf = xmmword_1006C4575;
      v52 = -1437420489;
      qword_1008F1E68 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 20LL));
      __cxa_guard_release(&qword_1008F1E70);
      id v28 = &unk_1008F1000;
      uint64_t v18 = (void *)&unk_1008F1000;
      __int128 v20 = (void *)&unk_1008F1000;
      id v22 = (void *)&unk_1008F1000;
      uint64_t v24 = (void *)&unk_1008F1000;
      v26 = (void *)&unk_1008F1000;
    }
  }

  v47[0] = @"MX Anywhere 2";
  v47[1] = @"MX Master 3";
  uint64_t v29 = v18[451];
  v48[0] = qword_1008F1E08;
  v48[1] = v29;
  uint64_t v30 = v20[453];
  v47[2] = @"Surface Mouse";
  v47[3] = @"BluetoothMouse3600";
  __int128 v31 = v22[455];
  v48[2] = v30;
  v48[3] = v31;
  __int128 v32 = v24[457];
  v47[4] = @"Razer Atheris";
  v47[5] = @"Designer Mouse";
  __int128 v33 = v26[459];
  v48[4] = v32;
  v48[5] = v33;
  v47[6] = @"Keyboard K600 TV";
  v48[6] = v28[461];
  __int128 v34 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v48,  v47,  7LL));
  __int128 v35 = (void *)qword_1008F79B8;
  qword_1008F79B8 = v34;

  __int128 v36 = (void *)qword_1008F79C0;
  qword_1008F79C0 = (uint64_t)&off_1008C3240;

  return a1;
}

  sub_100242FAC((uint64_t)v10);
  return v5;
}

      uint64_t v16 = 0LL;
      id v17 = 0LL;
      uint64_t v18 = 0LL;
      goto LABEL_22;
    }
  }

  else if (v14)
  {
    goto LABEL_9;
  }

  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[CBAccessoryLogging getProductNameFromProductID:]( &OBJC_CLASS___CBAccessoryLogging,  "getProductNameFromProductID:",  a5));
  if (v8)
  {
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ Crash Detected",  v16));
    __int128 v20 = sub_1002E95B8(@"TITLE", v19);
    id v17 = (id)objc_claimAutoreleasedReturnValue(v20);

    id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Do you want to use Tap-to-Radar to report the failure found on %@?",  v11));
  }

  else
  {
    id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ Log Collection Done",  v16));
    uint64_t v24 = sub_1002E95B8(@"TITLE", v23);
    id v17 = (id)objc_claimAutoreleasedReturnValue(v24);

    id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Do you want to use Tap-to-Radar and attach the log from %@?",  v11));
  }

  id v22 = sub_1002E95B8(@"CONTENT", v21);
  uint64_t v18 = (id)objc_claimAutoreleasedReturnValue(v22);

  if ((_DWORD)a5)
  {
    loggingQueue = self->_loggingQueue;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100640B4C;
    block[3] = &unk_1008A4CF0;
    id v17 = v17;
    v27 = v17;
    uint64_t v18 = v18;
    id v28 = v18;
    uint64_t v29 = self;
    __int128 v32 = v8;
    uint64_t v30 = v10;
    __int128 v31 = a5;
    dispatch_async(loggingQueue, block);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_1006A0928();
  }

  return v11;
}

void sub_10001FE8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_29:
LABEL_30:
  v26 = -[CBDevice connectedServices](self, "connectedServices");
  if ((v26 & 0xFFBFFFFF | (*((unsigned __int8 *)v151 + 24) << 22)) != v26)
  {
    -[CBDevice setConnectedServices:](self, "setConnectedServices:");
    v9 |= 0x80000200000uLL;
  }

  if (*((_WORD *)v147 + 12))
  {
    v27 = *((unsigned __int16 *)v147 + 12);
    if (v27 != -[CBDevice interval](self, "interval"))
    {
      -[CBDevice setInterval:](self, "setInterval:", *((unsigned __int16 *)v147 + 12));
      v9 |= 0x80000000000uLL;
    }
  }

  id v28 = -[CBDevice deviceFlags](self, "deviceFlags");
  uint64_t v29 = *((unsigned __int8 *)v133 + 24);
  uint64_t v30 = v29 << 41;
  if (*((_BYTE *)v107 + 24)) {
    uint64_t v30 = ((unint64_t)*((unsigned __int8 *)v133 + 24) << 41) | 0x2000;
  }
  if (*((_BYTE *)v159 + 24)) {
    __int128 v31 = v30 | 0x200000;
  }
  else {
    __int128 v31 = v30;
  }
  if (*((_BYTE *)v155 + 24)) {
    v31 |= 0x8000uLL;
  }
  if (!*((_BYTE *)v107 + 24) || *((_BYTE *)v93 + 24) || ((unsigned __int16)v28 & 0x4000) != 0)
  {
    __int128 v32 = v31 | 0x40000000000LL;
    if (!*((_BYTE *)v155 + 24)) {
      goto LABEL_48;
    }
LABEL_49:
    __int128 v33 = v32 | 0x1000;
    goto LABEL_50;
  }

  __int128 v32 = v31 & 0xFFFFFBFFFFFFFFFFLL;
  if (*((_BYTE *)v155 + 24)) {
    goto LABEL_49;
  }
LABEL_48:
  __int128 v33 = v32 & 0xFFFFFFFFFFFFEFFFLL;
LABEL_50:
  if ((id)(v33 & 0xFFFFFFFFFFFCFFFFLL | ((unint64_t)*((unsigned __int8 *)v129 + 24) << 17) | ((unint64_t)(*((_BYTE *)v129 + 24) == 0) << 16)) != v28)
  {
    -[CBDevice setDeviceFlags:](self, "setDeviceFlags:");
    v9 |= 0x80000000000uLL;
  }

  if (*((_BYTE *)v143 + 24))
  {
    __int128 v34 = *((unsigned __int8 *)v143 + 24);
    if (v34 != -[CBDevice deviceType](self, "deviceType"))
    {
      -[CBDevice setDeviceType:](self, "setDeviceType:", *((unsigned __int8 *)v143 + 24));
      v9 |= 0x80000000000uLL;
    }
  }

  __int128 v35 = (void *)v137[5];
  if (v35)
  {
    __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice idsDeviceID](self, "idsDeviceID"));

    if (v35 != v36)
    {
      -[CBDevice setIdsDeviceID:](self, "setIdsDeviceID:", v137[5]);
      v9 |= 0x80000000000uLL;
    }
  }

  if ([(id)v121[5] length])
  {
    __int128 v37 = (void *)v121[5];
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice firmwareVersion](self, "firmwareVersion"));
    v39 = v37;
    v40 = v38;
    if (v39 == v40)
    {

      goto LABEL_66;
    }

    v41 = v40;
    if ((v39 == 0LL) == (v40 != 0LL))
    {
    }

    else
    {
      v42 = [v39 isEqual:v40];

      if ((v42 & 1) != 0) {
        goto LABEL_66;
      }
    }

    -[CBDevice setFirmwareVersion:](self, "setFirmwareVersion:", v121[5]);
    v9 |= 0x80000000000uLL;
  }

  if (dword_1008D66A0 <= 90 && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 90LL))) {
    LogPrintF_safe( &dword_1008D66A0,  "void _pairingStatusCallback(BTPairingAgent _Nonnull, BTPairingEvent, BTDevice _Nonnull, BTResult, void * _Nonnull)",  90LL,  "### No device for status callback");
  }
}

  __int128 v34 = sub_1000B1814(88LL * (v31 + 1));
  if (v34)
  {
    __int128 v35 = v34;
    __int128 v36 = *((void *)&xmmword_1008DD4E8 + v7);
    __int128 v37 = *(const void **)(v36 + 8);
    if (v37)
    {
      memmove(v34, v37, 88LL * *(unsigned int *)(v36 + 16));
      sub_1000B1838(*(void **)(*((void *)&xmmword_1008DD4E8 + v7) + 8LL));
      __int128 v36 = *((void *)&xmmword_1008DD4E8 + v7);
    }

    uint64_t v38 = &v35[88 * *(unsigned int *)(v36 + 16)];
    *((_DWORD *)v38 + _Block_object_dispose(va, 8) = v10;
    *((_DWORD *)v38 + 9) = v21;
    *((_DWORD *)v38 + 10) = v9;
    *(void *)(v38 + 44) = 0x100000001LL;
    memmove(v38, v19, v10);
    v39 = *((void *)&xmmword_1008DD4E8 + v7);
    v40 = *(_DWORD *)(v39 + 16);
    v41 = &v35[88 * v40];
    *((void *)v41 + _Block_object_dispose(va, 8) = 0LL;
    v41[56] = v20 & 1;
    v41[57] = (v20 & 2) != 0;
    *((_WORD *)v41 + 26) = 0;
    *(void *)(v39 + _Block_object_dispose(va, 8) = v35;
    *(_DWORD *)(v39 + 16) = v40 + 1;
    v42 = (unsigned __int16)word_1008DD568;
    if (word_1008DD568)
    {
      else {
        v43 = v10;
      }
      v44 = memcmp("com.apple.BT.TS", v19, v43);
      v45 = 0;
      v46 = (byte_1008DD4E0 | v44) == 0;
      v47 = &byte_1008DD584;
      while (v46 || !sub_100090D5C((uint64_t)&v35[88 * v40], v45))
      {
        ++v45;
        v47 += 72;
        if (v42 == v45) {
          return;
        }
      }

      v35[88 * v40 + 54] = *v47;
      sub_1000901F4((uint64_t)a1, 1u, (uint64_t)&v73);
    }
  }

            v25 = a2;
            v26 = 1335LL;
LABEL_36:
            sub_100118720(v25, v26);
          }

          else
          {
            if (*(unsigned __int8 *)(a2 + 144) == v6[1])
            {
              uint64_t v7 = sub_100128D24(16LL);
              if ((_DWORD)v7)
              {
                uint64_t v8 = v7;
                sub_1001EE134( (uint64_t)"OI_HCICMD_SetConnectionEncryption failed %!",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v8);
                uint64_t v16 = (os_log_s *)sub_100086554(0x2Cu);
                if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
                goto LABEL_34;
              }

              v53 = *(char **)(a2 + 120);
              v54 = 3;
            }

            else
            {
              v44 = sub_100128D24(47LL);
              if ((_DWORD)v44)
              {
                uint64_t v8 = v44;
                sub_1001EE134((uint64_t)"OI_HCICMD_SwitchRole failed %!", v45, v46, v47, v48, v49, v50, v51, v8);
                v52 = (os_log_s *)sub_100086554(0x2Cu);
                if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
LABEL_34:
                sub_100657858();
LABEL_35:
                v25 = a2;
                v26 = v8;
                goto LABEL_36;
              }

              v53 = *(char **)(a2 + 120);
              v54 = 2;
            }

            *v53 = v54;
          }

          break;
        case 3:
          v27 = *(unsigned int *)(a2 + 244);
          if ((_DWORD)v27)
          {
            sub_1001EEB14(v27);
            *(_DWORD *)(a2 + 244) = 0;
          }

          if ((_DWORD)a1 || a3)
          {
            sub_100118720(a2, a1);
            return;
          }

          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Failed to re-enable encryption after role switch",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v55);
            __int128 v35 = (os_log_s *)sub_100086554(0x2Cu);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
              goto LABEL_28;
            }
          }

          goto LABEL_29;
        default:
          sub_1001EE2A0();
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"OI_HCIEventHandler_RoleChange %!", v17, v18, v19, v20, v21, v22, v23, 105LL);
            uint64_t v24 = (os_log_s *)sub_100086554(0x2Cu);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          v25 = a2;
          v26 = 105LL;
          goto LABEL_36;
      }
    }

    else if (!a3)
    {
      v56[1] = &v57;
      v56[0] = (const void *)8;
      sub_1001EE6E8((uint64_t)sub_100118AFC, v56, 10, (int *)(a2 + 244));
    }
  }

    if (!a6)
    {
      uint64_t v24 = 4;
      goto LABEL_40;
    }

    v26 = 0;
    __int128 v32 = 0LL;
LABEL_30:
    v27 = v24;
    v25 = *((_WORD *)a1 + 6) + v24;
    *((_WORD *)a1 + 6) = v25;
    uint64_t v24 = v32;
    goto LABEL_31;
  }

  *((_BYTE *)a1 + 15) = 1;
  v25 = *((_WORD *)a1 + 6);
  v26 = v24;
  v27 = v24;
LABEL_31:
  if (*((_BYTE *)a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1540,  "(*pBs).__RWFlag == BYTESTREAM_READ");
  }
  __int128 v33 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    __int128 v34 = 0;
  }

  else
  {
    __int128 v34 = *((unsigned __int16 *)a1 + 5) - v25;
  }

  if (v34 >= v26)
  {
    if ((_DWORD)v27)
    {
      __int128 v36 = (char *)(v33 + v25);
      __int128 v37 = v62;
      do
      {
        uint64_t v38 = *v36++;
        *v37++ = v38;
      }

      while (v37 < (_BYTE *)v62 + v24);
    }

    __int128 v35 = *((_WORD *)a1 + 6) + v27;
    *((_WORD *)a1 + 6) = v35;
  }

  else
  {
    *((_BYTE *)a1 + 15) = 1;
    __int128 v35 = *((_WORD *)a1 + 6);
  }

  if (*((_BYTE *)a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1541,  "(*pBs).__RWFlag == BYTESTREAM_READ");
  }
  v39 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v40 = 0;
  }

  else
  {
    v40 = *((unsigned __int16 *)a1 + 5) - v35;
  }

  if (v40 >= v26)
  {
    if ((_DWORD)v27)
    {
      v42 = (char *)(v39 + v35);
      v43 = v61;
      do
      {
        v44 = *v42++;
        *v43++ = v44;
      }

      while (v43 < (_BYTE *)v61 + v24);
    }

    v41 = *((_WORD *)a1 + 6) + v27;
    *((_WORD *)a1 + 6) = v41;
  }

  else
  {
    *((_BYTE *)a1 + 15) = 1;
    v41 = *((_WORD *)a1 + 6);
  }

  if (*((_BYTE *)a1 + 14) != 1) {
    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1542,  "(*pBs).__RWFlag == BYTESTREAM_READ");
  }
  v45 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v46 = 0;
  }

  else
  {
    v46 = *((unsigned __int16 *)a1 + 5) - v41;
  }

  if (v46 >= v26)
  {
    v47 = (uint64_t)v5;
    v48 = v17;
    v49 = v19;
    v50 = v21;
    v51 = v59;
    if ((_DWORD)v27)
    {
      v52 = (char *)(v45 + v41);
      v53 = v60;
      do
      {
        v54 = *v52++;
        *v53++ = v54;
      }

      while (v53 < (_BYTE *)v60 + v24);
    }

    *((_WORD *)a1 + 6) += v27;
  }

  else
  {
    *((_BYTE *)a1 + 15) = 1;
    v47 = (uint64_t)v5;
    v48 = v17;
    v49 = v19;
    v50 = v21;
    v51 = v59;
  }

  sub_1001B98C4(v47, v48, v49, v50, v51, v27, (uint64_t)v63, (uint64_t)v62, (uint64_t)v61, (uint64_t)v60);
}

        __int128 v32 = qword_1008EDD80;
        if (!qword_1008EDD80 || !*(void *)(qword_1008EDD80 + 8))
        {
          sub_1001EE2A0();
          __int128 v32 = qword_1008EDD80;
        }

        __int128 v33 = *(_DWORD *)a2;
        word_1008EDD34 = *(_WORD *)(a2 + 4);
        dword_1008EDD30 = v33;
        qword_1008EDD38 = v63;
        LOBYTE(dword_1008EDD40) = 0;
        HIBYTE(dword_1008EDD40) = *(_BYTE *)(v63 + 277) & (byte_1008F6D20 > 3u);
        xmmword_1008EDD48 = v64;
        dword_1008EDD58 = a5;
        byte_1008EDD5C = a6;
        dword_1008EDD60 = (*(uint64_t (**)(void, void, uint64_t))(v32 + 8))(v64, *((void *)&v64 + 1), a2);
        off_1008EDD68 = a1;
        __int128 v20 = sub_1001EE6DC((uint64_t)sub_1001EA7DC, 0LL, 0LL);
        if (!(_DWORD)v20)
        {
          dword_1008EDD24 = 5;
          dword_1008EDD70 = 0;
          return v20;
        }

        goto LABEL_53;
      }

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }

  uint64_t v11 = a2[1];
  if (v11)
  {
    int v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      int v12 = (void *)*v12;
    }

    while (v12);
  }

  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      unsigned int v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= a4[4])
  {
    __int128 v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          id v21 = v20;
          id v22 = v20[4];
          if (v6 >= v22) {
            break;
          }
          __int128 v20 = (void *)*v21;
          int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        int v5 = v21 + 1;
        __int128 v20 = (void *)v21[1];
      }

      while (v20);
    }

    else
    {
      id v21 = a1 + 1;
    }

  __int128 v20 = (os_log_s *)qword_1008F7628;
  if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_INFO))
  {
    std::stringbuf::str(&__p, (const std::stringbuf *)((char *)v26 + 8));
    id v21 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &__p
        : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315138;
    __int128 v33 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "desired latencies:%s", buf, 0xCu);
  }

  *(void *)((char *)&v26[-1]
  *(void *)&v26[0] = v22;
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[1]);
  }
  std::streambuf::~streambuf((char *)v26 + 8);
  std::ios::~ios(v30);

  return v4;
}

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }

  uint64_t v11 = a2[1];
  if (v11)
  {
    int v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      int v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      unsigned int v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    __int128 v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          id v21 = (uint64_t *)v20;
          id v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          __int128 v20 = *v21;
          int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        int v5 = v21 + 1;
        __int128 v20 = v21[1];
      }

      while (v20);
    }

    else
    {
      id v21 = a1 + 1;
    }

  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F0188) {
      int v12 = "enabled";
    }
    else {
      int v12 = "disabled";
    }
    BOOL v13 = sub_1002E6E9C();
    unsigned int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 2640LL))(v13);
    unsigned int v15 = "N";
    if (v14) {
      unsigned int v15 = "Y";
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = v12;
    __int128 v20 = 2080;
    id v21 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Support for Discovery Scan Prioritization is %s (hw capability %s)",  buf,  0x16u);
  }

    if (a3 <= 2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
        sub_100671030(v9);
      }
      return 3LL;
    }

    if (a3 == 3)
    {
      v25 = (os_log_s *)qword_1008F7568;
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
      {
        v26 = *(id *)(v9 + 8);
        v27 = *a4;
        id v28 = a4[1];
        uint64_t v29 = a4[2];
        buf.tm_sec = 138544130;
        *(void *)&buf.tm_min = v26;
        LOWORD(buf.tm_mday) = 1024;
        *(int *)((char *)&buf.tm_mday + 2) = v27;
        HIWORD(buf.tm_mon) = 1024;
        buf.tm_year = v28;
        LOWORD(buf.tm_wday) = 1024;
        *(int *)((char *)&buf.tm_wday + 2) = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Warning: recvLogHandler: Ignoring data for %{public}@ shorter with only header: %02x %02x %02x",  (uint8_t *)&buf,  0x1Eu);
      }

      return 3LL;
    }

    if (v11 == 4) {
      return sub_10035B270(a1, (uint64_t)a2, a3, a4);
    }
    uint64_t v30 = a4[1];
    __int128 v31 = v30 & 0x7F;
    __int128 v32 = v31;
    if (*(void *)(v9 + 64))
    {
LABEL_43:
      __int128 v33 = *(unsigned __int8 *)(v9 + 72);
      if (v31 != v33)
      {
        __int128 v34 = (os_log_s *)qword_1008F7568;
        if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
        {
          v61 = *(void *)(v9 + 48);
          buf.tm_sec = 138412802;
          *(void *)&buf.tm_min = v61;
          LOWORD(buf.tm_mday) = 1024;
          *(int *)((char *)&buf.tm_mday + 2) = v32;
          HIWORD(buf.tm_mon) = 1024;
          buf.tm_year = v33;
          _os_log_error_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "recvLogHandler: File %@ seq num mismatch rcvd %d expected %d",  (uint8_t *)&buf,  0x18u);
          LOBYTE(v33) = *(_BYTE *)(v9 + 72);
        }

        *(_BYTE *)(v9 + 56) = 1;
        LOBYTE(v31) = v33;
      }

      *(_BYTE *)(v9 + 72) = (v31 + 1) & 0x7F;
      __int128 v35 = *a4;
      __int128 v36 = *(unsigned __int8 *)(v9 + 73);
      if (v35 != v36)
      {
        __int128 v37 = (os_log_s *)qword_1008F7568;
        if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
        {
          v62 = *(void *)(v9 + 48);
          buf.tm_sec = 138412802;
          *(void *)&buf.tm_min = v62;
          LOWORD(buf.tm_mday) = 1024;
          *(int *)((char *)&buf.tm_mday + 2) = v35;
          HIWORD(buf.tm_mon) = 1024;
          buf.tm_year = v36;
          _os_log_error_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "recvLogHandler: File %@ log type mismatch rcvd %d expected %d",  (uint8_t *)&buf,  0x18u);
        }

        *(_BYTE *)(v9 + 56) = 1;
      }

      uint64_t v38 = a4[2];
      v39 = *(unsigned __int8 *)(v9 + 74);
      if (v38 != v39)
      {
        v40 = (os_log_s *)qword_1008F7568;
        if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
        {
          v63 = *(void *)(v9 + 48);
          buf.tm_sec = 138412802;
          *(void *)&buf.tm_min = v63;
          LOWORD(buf.tm_mday) = 1024;
          *(int *)((char *)&buf.tm_mday + 2) = v38;
          HIWORD(buf.tm_mon) = 1024;
          buf.tm_year = v39;
          _os_log_error_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "recvLogHandler: File %@ log device mismatch rcvd %d expected %d",  (uint8_t *)&buf,  0x18u);
        }

        *(_BYTE *)(v9 + 56) = 1;
      }

      fwrite(a4 + 3, 1uLL, a3 - 3LL, *(FILE **)(v9 + 64));
      if (v30 >= 0)
      {
        v41 = (os_log_s *)qword_1008F7568;
        if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
        {
          v42 = *(void *)(v9 + 48);
          buf.tm_sec = 138412290;
          *(void *)&buf.tm_min = v42;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "recvLogHandler: Completed writing file %@",  (uint8_t *)&buf,  0xCu);
        }

        sub_10035C04C(v9);
      }

      return 0LL;
    }

    v43 = *(unsigned __int8 *)(v9 + 40);
    if (v43 > 8 || ((1 << v43) & 0x182) == 0)
    {
      v45 = (os_log_s *)qword_1008F7568;
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
      {
        v46 = *(id *)(v9 + 8);
        v47 = *(unsigned __int8 *)(v9 + 40);
        v48 = *a4;
        v49 = a4[1];
        v50 = a4[2];
        buf.tm_sec = 138544386;
        *(void *)&buf.tm_min = v46;
        LOWORD(buf.tm_mday) = 1024;
        *(int *)((char *)&buf.tm_mday + 2) = v47;
        HIWORD(buf.tm_mon) = 1024;
        buf.tm_year = v48;
        LOWORD(buf.tm_wday) = 1024;
        *(int *)((char *)&buf.tm_wday + 2) = v49;
        HIWORD(buf.tm_yday) = 1024;
        buf.tm_isdst = v50;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Warning: recvLogHandler: Refusing non-AWD log data from %{public}@ (status %d), header %02x %02x %02x",  (uint8_t *)&buf,  0x24u);
      }

      return 6LL;
    }

    if ((v30 & 0x7F) != 0)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
        sub_100671134();
      }
    }

    else
    {
      *(_BYTE *)(v9 + 73) = v11;
      if (v11 == 1)
      {
        *(_BYTE *)(a1 + 34) = 1;
        v44 = 7;
      }

      else
      {
        v44 = 8;
      }

      *(_BYTE *)(v9 + 40) = v44;
      *(_BYTE *)(v9 + 74) = a4[2];
      memset(&buf, 0, sizeof(buf));
      v51 = sub_10035978C(v8, &buf);
      v65 = sub_10035BE80((uint64_t)v51, *(unsigned __int8 *)(v9 + 73));
      v64 = sub_10035BEFC((uint64_t)v65, *(unsigned __int8 *)(v9 + 74));
      if (qword_1008D60E0 != -1) {
        dispatch_once(&qword_1008D60E0, &stru_100892EF0);
      }
      v52 = sub_100221ED8((uint64_t)off_1008D60D8, v9 + 16);
      v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
      v54 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"/private/var/mobile/Library/Logs/Bluetooth/Accessory%s_%s_%@_%04d-%02d-%02d-%02d-%02d-%02d.%s",  v65,  v64,  v53,  (buf.tm_year + 1900),  (buf.tm_mon + 1),  buf.tm_mday,  buf.tm_hour,  buf.tm_min,  buf.tm_sec,  sub_10035BFD0((uint64_t)v53, *(unsigned __int8 *)(v9 + 73)));
      v55 = objc_claimAutoreleasedReturnValue(v54);
      v56 = *(void **)(v9 + 48);
      *(void *)(v9 + 4_Block_object_dispose(va, 8) = v55;

      *(void *)(v9 + 64) = fopen((const char *)[*(id *)(v9 + 48) UTF8String], "ab");
      *(_BYTE *)(v9 + 72) = 0;
      v57 = *(void *)(v9 + 96);
      if (v57)
      {
        [*(id *)(v9 + 104) setObject:v57 forKey:*(void *)(v9 + 48)];
        v58 = *(void **)(v9 + 96);
        *(void *)(v9 + 96) = 0LL;
      }

      v59 = (os_log_s *)qword_1008F7568;
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
      {
        v60 = *(void *)(v9 + 48);
        *(_DWORD *)v68 = 138412290;
        *(void *)&v68[4] = v60;
        _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "recvLogHandler: Opening file %@",  v68,  0xCu);
      }

      if (*(void *)(v9 + 64))
      {
        __int128 v32 = 0;
        goto LABEL_43;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
        sub_1006710AC();
      }
    }

    return 1LL;
  }

  uint64_t v18 = qword_1008F7568;
  if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
    sub_100670FC8((uint64_t)a2, v18, v19, v20, v21, v22, v23, v24);
  }
  return 8LL;
}

      operator delete(__p[0]);
      if ((v34 & 0x80) == 0)
      {
LABEL_26:
        if (v20) {
          goto LABEL_31;
        }
        goto LABEL_39;
      }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100894630);
  }
  sub_1005D2A18((uint64_t)off_1008D5F28, v7, v10);
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100894630);
  }
  int v12 = off_1008D5F28;
  BOOL v13 = (void *)objc_claimAutoreleasedReturnValue([v8 useCaseList]);
  sub_1005D2AA0((uint64_t)v12, v7, v13);

  sub_100494958(a2, (uint64_t)v31);
  unsigned int v14 = v32;
  unsigned int v15 = (void **)v31[0];
  uint64_t v16 = +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding");
  if (v14 >= 0) {
    id v17 = v31;
  }
  else {
    id v17 = v15;
  }
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  v17,  v16));
  if (v32 < 0) {
    operator delete(v31[0]);
  }
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v8 useCaseList]);
  if (v19
    && (__int128 v20 = (void *)objc_claimAutoreleasedReturnValue([v8 useCaseList]),
        id v21 = [v20 count],
        v20,
        v19,
        v21))
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100894630);
    }
    id v22 = off_1008D5F28;
    id v23 = (void *)objc_claimAutoreleasedReturnValue([v8 useCaseList]);
    sub_1005D35EC((uint64_t)v22, v7, v18, v23);
  }

  else
  {
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v10));
    id v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:](&OBJC_CLASS___NSArray, "arrayWithObjects:", v24, 0LL));

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100894630);
    }
    sub_1005D35EC((uint64_t)off_1008D5F28, v7, v18, v23);
  }
}

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }

  uint64_t v11 = a2[1];
  if (v11)
  {
    int v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      int v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      unsigned int v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    __int128 v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          id v21 = (uint64_t *)v20;
          id v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22) {
            break;
          }
          __int128 v20 = *v21;
          int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        int v5 = v21 + 1;
        __int128 v20 = v21[1];
      }

      while (v20);
    }

    else
    {
      id v21 = a1 + 1;
    }

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }

  uint64_t v11 = a2[1];
  if (v11)
  {
    int v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      int v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      unsigned int v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    __int128 v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          id v21 = (uint64_t *)v20;
          id v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22) {
            break;
          }
          __int128 v20 = *v21;
          int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        int v5 = v21 + 1;
        __int128 v20 = v21[1];
      }

      while (v20);
    }

    else
    {
      id v21 = a1 + 1;
    }

  uint64_t v24 = (int *)a1[43];
  if (v24 && a1[44] == *a2)
  {
    v26 = (os_log_s *)qword_1008F7590;
    if (!os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_DEFAULT))
    {
LABEL_43:
      (*(void (**)(int *))(*(void *)v24 + 24LL))(v24);
      v25 = 400LL;
      goto LABEL_44;
    }

    v27 = v24[19];
    if (v27 > 3)
    {
      id v28 = 0LL;
      if (v9) {
        goto LABEL_35;
      }
    }

    else
    {
      id v28 = off_1008996B8[v27];
      if (v9)
      {
LABEL_35:
        sub_100494958(v9, (uint64_t)&__p);
        if (SHIBYTE(v33) >= 0) {
          p_p = (const char *)&__p;
        }
        else {
          p_p = (const char *)__p;
        }
        *(_DWORD *)buf = 136446466;
        __int128 v37 = v28;
        uint64_t v38 = 2082;
        v39 = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Stopping current %{public}s scan on behalf of %{public}s",  buf,  0x16u);
        if (SHIBYTE(v33) < 0) {
          operator delete(__p);
        }
        goto LABEL_42;
      }
    }

    *(_DWORD *)buf = 136446466;
    __int128 v37 = v28;
    uint64_t v38 = 2082;
    v39 = "(NULL)";
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Stopping current %{public}s scan on behalf of %{public}s",  buf,  0x16u);
LABEL_42:
    uint64_t v24 = (int *)a1[43];
    goto LABEL_43;
  }

  v25 = 0LL;
LABEL_44:
  sub_100242FAC((uint64_t)v34);
  return v25;
}

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }

  uint64_t v11 = a2[1];
  if (v11)
  {
    int v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      int v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      unsigned int v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= *((unsigned __int16 *)a4 + 16))
  {
    __int128 v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          id v21 = (uint64_t *)v20;
          id v22 = *(unsigned __int16 *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          __int128 v20 = *v21;
          int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        int v5 = v21 + 1;
        __int128 v20 = v21[1];
      }

      while (v20);
    }

    else
    {
      id v21 = a1 + 1;
    }

      uint64_t v6 = v8 + 2;
    }

    while (v8 + 2 != a2);
  }

  return v5;
}
    }

    else
    {
      uint64_t v6 = 0LL;
    }
  }

  return v6;
}

  return v11;
}

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }

  uint64_t v11 = a2[1];
  if (v11)
  {
    int v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      int v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      unsigned int v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= *((unsigned __int8 *)a4 + 25))
  {
    __int128 v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          id v21 = (uint64_t *)v20;
          id v22 = *(unsigned __int8 *)(v20 + 25);
          if (v6 >= v22) {
            break;
          }
          __int128 v20 = *v21;
          int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        int v5 = v21 + 1;
        __int128 v20 = v21[1];
      }

      while (v20);
    }

    else
    {
      id v21 = a1 + 1;
    }

    sub_100242FAC((uint64_t)v33);
  }

  else
  {
    uint64_t v18 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = sub_1005BFB9C(a2);
      __int128 v20 = objc_claimAutoreleasedReturnValue(v19);
      *(_DWORD *)__int128 v33 = 136446210;
      *(void *)&v33[4] = [v20 UTF8String];
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "address %{public}s is not resolvable.",  v33,  0xCu);
    }

    return 114LL;
  }

  return v17;
}

LABEL_78:
  v49 = *((_DWORD *)v97 + 6);
  if (v49 && v49 != -[CBDevice bleRSSI](self, "bleRSSI"))
  {
    -[CBDevice setBleRSSI:](self, "setBleRSSI:", *((unsigned int *)v97 + 6));
    v9 |= 0x200000000uLL;
  }

  if (v12 && -[CBDevice vendorID](self, "vendorID") != v12)
  {
    -[CBDevice setVendorID:](self, "setVendorID:", v12);
    v9 |= 0x80000000000uLL;
  }

  if (!(_DWORD)v11) {
    goto LABEL_90;
  }
  if ((_DWORD)v11 != -[CBDevice vendorIDSource](self, "vendorIDSource"))
  {
    -[CBDevice setVendorIDSource:](self, "setVendorIDSource:", v11);
    v9 |= 0x80000000000uLL;
  }

  if ((_DWORD)v11 == 1 && v12 == 76) {
    v50 = 1;
  }
  else {
LABEL_90:
  }
    v50 = (_DWORD)v11 == 2 && v12 == 1452;
  v52 = -[CBDevice productID](self, "productID");
  if (!(_DWORD)v52) {
    v52 = -[CBDevice proximityPairingProductID](self, "proximityPairingProductID");
  }
  if ((_DWORD)v52) {
    v53 = v50;
  }
  else {
    v53 = 0;
  }
  if (v53)
  {
    v54 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( &OBJC_CLASS___CBProductInfo,  "productInfoWithProductID:",  v52));
    v55 = (void *)objc_claimAutoreleasedReturnValue([v54 productName]);

    if (v55)
    {
      v56 = (id)objc_claimAutoreleasedReturnValue(-[CBDevice productName](self, "productName"));
      v57 = v55;
      v58 = v57;
      if (v56 == v57)
      {
      }

      else
      {
        if (v56)
        {
          v59 = [v56 isEqual:v57];

          if ((v59 & 1) != 0) {
            goto LABEL_111;
          }
        }

        else
        {
        }

        -[CBDevice setProductName:](self, "setProductName:", v58);
        v9 |= 0x80000000000uLL;
      }
    }
}

            v72 = (uint64_t *)*v34;
            v73 = *a3 + v35;
            v74 = *v72;
            *(_WORD *)(v73 + _Block_object_dispose(va, 8) = *((_WORD *)v72 + 4);
            *(void *)v73 = v74;
            v61 = *((_WORD *)a3 + 6) + 10;
LABEL_109:
            *((_WORD *)a3 + 6) = v61;
            goto LABEL_110;
          case 'd':
            __int128 v36 = a1++;
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c");
LABEL_161:
              v111 = "ByteStream_NumReadBytesAvail(*pBs) >= (16)";
LABEL_162:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcicmdapi.c",  2732,  v111);
            }

            __int128 v37 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 2)
            {
              v111 = "(*pBs).__RWFlag == BYTESTREAM_WRITE";
              goto LABEL_162;
            }

    if ((v35 & 0x80) != 0)
    {
      operator delete(v55.__r_.__value_.__l.__data_);
      if (!v37)
      {
LABEL_85:
        if ([v28 requiresLowLatency])
        {
          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_100894610);
          }
          v44 = off_1008D5F08;
          sub_100241F90(&v55, v11);
          sub_100599B60((uint64_t)v44, (const unsigned __int8 *)&v55);
        }

        v45 = (os_log_s *)qword_1008F7658;
        if (os_log_type_enabled((os_log_t)qword_1008F7658, OS_LOG_TYPE_DEFAULT))
        {
          v46 = *(void *)(a1 + 88);
          LODWORD(v55.__r_.__value_.__l.__data_) = 138543618;
          *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
          WORD2(v55.__r_.__value_.__r.__words[1]) = 2114;
          *(std::string::size_type *)((char *)&v55.__r_.__value_.__r.__words[1] + 6) = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "App disconnecting - {cbuuid: %{public}@, bundle: %{public}@}",  (uint8_t *)&v55,  0x16u);
        }

        if (qword_1008D67C8 != -1) {
          dispatch_once(&qword_1008D67C8, &stru_100894590);
        }
        sub_100285740((uint64_t)off_1008D67C0, a2, a1, v11, v51, 0LL);
        if (a4)
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_ERROR)) {
            sub_100675D20();
          }
          if (v50)
          {
            v47 = (os_log_s *)qword_1008F7628;
            if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v55.__r_.__value_.__l.__data_) = 138543362;
              *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
              _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Disconnecting Do Not Autoconnect device %{public}@ if with builtInServices",  (uint8_t *)&v55,  0xCu);
            }

            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_100894630);
            }
            sub_1005D47EC((uint64_t)off_1008D5F28, v11);
          }

          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_100894610);
          }
          v48 = off_1008D5F08;
          sub_100241F90(&v55, v11);
          sub_100597F98((uint64_t)v48, (unsigned __int8 *)&v55, 2u);
        }

        else
        {
          if (qword_1008D67C8 != -1) {
            dispatch_once(&qword_1008D67C8, &stru_100894590);
          }
          sub_100278BE4((uint64_t)off_1008D67C0);
        }

        if (SHIBYTE(v57) < 0) {
          operator delete(*(void **)&buf[8]);
        }
LABEL_110:
        [*(id *)(a1 + 304) removeObject:v11];

        goto LABEL_111;
      }
    }

    else if (!v37)
    {
      goto LABEL_85;
    }

    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_100894610);
    }
    v43 = off_1008D5F08;
    sub_100241F90(&v55, v11);
    sub_100599B60((uint64_t)v43, (const unsigned __int8 *)&v55);
    goto LABEL_85;
  }

  __int128 v20 = (os_log_s *)qword_1008F7628;
  if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    *(void *)&buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Removing delayed connection to device %{public}@",  buf,  0xCu);
  }

  if (qword_1008D67C8 != -1) {
    dispatch_once(&qword_1008D67C8, &stru_100894590);
  }
  sub_100285740((uint64_t)off_1008D67C0, a2, a1, v11, 0LL, 0LL);
  id v21 = *(void **)(a1 + 384);
  if (v21 != (void *)(a1 + 392))
  {
    while ([v11 compare:v21[4]])
    {
      id v22 = (void *)v21[1];
      if (v22)
      {
        do
        {
          id v23 = v22;
          id v22 = (void *)*v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          id v23 = (void *)v21[2];
          v41 = *v23 == (void)v21;
          id v21 = v23;
        }

        while (!v41);
      }

      id v21 = v23;
      if (v23 == (void *)(a1 + 392)) {
        goto LABEL_66;
      }
    }

    sub_1003A0FD8(a1 + 384, v21 + 4);
    uint64_t v11 = v52;
  }

    id v22 = 0;
    return v22 & 1;
  }

  id v23 = *(__int128 **)(a1 + 16976);
  v43 = *(__int128 **)(a1 + 16984);
  if (v23 == v43) {
    goto LABEL_78;
  }
  do
  {
    __p[1] = 0LL;
    v48 = 0LL;
    __p[0] = 0LL;
    if (*((char *)v23 + 23) < 0)
    {
      sub_100024238(__p, *(void **)v23, *((void *)v23 + 1));
    }

    else
    {
      uint64_t v24 = *v23;
      v48 = *((void *)v23 + 2);
      *(_OWORD *)__p = v24;
    }

    sub_100494958(v2, (uint64_t)&v44);
    v25 = v46;
    v26 = v44;
    if ((v46 & 0x80u) == 0) {
      v27 = (char *)&v44;
    }
    else {
      v27 = (char *)v44;
    }
    id v28 = HIBYTE(v48);
    if (v48 >= 0) {
      uint64_t v29 = __p;
    }
    else {
      uint64_t v29 = (void **)__p[0];
    }
    if (v48 >= 0) {
      uint64_t v30 = HIBYTE(v48);
    }
    else {
      uint64_t v30 = (int64_t)__p[1];
    }
    if (v30)
    {
      if ((v46 & 0x80u) == 0) {
        __int128 v31 = v46;
      }
      else {
        __int128 v31 = v45;
      }
      __int128 v32 = &v27[v31];
      if (v31 >= v30)
      {
        __int128 v35 = *(unsigned __int8 *)v29;
        __int128 v36 = v27;
        do
        {
          __int128 v37 = v31 - v30;
          if (v37 == -1) {
            break;
          }
          uint64_t v38 = (char *)memchr(v36, v35, v37 + 1);
          if (!v38) {
            break;
          }
          __int128 v33 = v38;
          if (!memcmp(v38, v29, v30)) {
            goto LABEL_67;
          }
          __int128 v36 = v33 + 1;
          __int128 v31 = v32 - (v33 + 1);
        }

        while (v31 >= v30);
        __int128 v33 = v32;
LABEL_67:
        uint64_t v2 = a2;
      }

      else
      {
        __int128 v33 = &v27[v31];
      }

      if (v33 == v32) {
        __int128 v34 = -1LL;
      }
      else {
        __int128 v34 = v33 - v27;
      }
    }

    else
    {
      __int128 v34 = 0LL;
    }

    id v22 = v34 != -1;
    if ((v25 & 0x80) != 0)
    {
      operator delete(v26);
      if (v48 < 0) {
LABEL_77:
      }
        operator delete(__p[0]);
    }

    else if (v28 < 0)
    {
      goto LABEL_77;
    }

    if (v34 != -1) {
      break;
    }
    id v23 = (__int128 *)((char *)v23 + 24);
  }

  while (v23 != v43);
  return v22 & 1;
}

            v44 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
            {
              else {
                v45 = off_1008A4258[(char)v4];
              }
              *(_DWORD *)buf = 138412546;
              v51 = v45;
              v52 = 1024;
              *(_DWORD *)v53 = v4;
              _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): waiting for buffer %d events",  buf,  0x12u);
            }

            return;
          }
        }

        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          unsigned int v15 = @"UNKNOWN";
          *(_DWORD *)buf = 138412290;
          v51 = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): Pausing ADV Buffers",  buf,  0xCu);
        }

        if (sub_1005E9E20(a1, v4, 0))
        {
          uint64_t v16 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            id v17 = @"UNKNOWN";
            *(_DWORD *)buf = 138412290;
            v51 = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): could not disable ADV buffering",  buf,  0xCu);
          }
        }

        else
        {
          v5[2] = 1;
          sub_1005EBFB4(a1);
          sub_1005EC048(a1);
          uint64_t v18 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            uint64_t v19 = @"UNKNOWN";
            *(_DWORD *)buf = 138412290;
            v51 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "ADVBUFF(%@): Trying to read", buf, 0xCu);
          }

          *(_BYTE *)(a1 + 1796) = v4;
          __int128 v20 = sub_1005EC18C(a1, v4);
          if (v4 == 1) {
            id v21 = @"NearOwner";
          }
          else {
            id v21 = @"Wild";
          }
          objc_msgSend(*(id *)(a1 + 152), "setObject:forKeyedSubscript:", v21, @"AdvertisementBufferType", v46);
          if (v5[3] == 255) {
            id v22 = 0LL;
          }
          else {
            id v22 = v5[3];
          }
          id v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v22));
          [*(id *)(a1 + 152) setObject:v23 forKeyedSubscript:@"CurrentCapacityAtDrain"];

          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", 100LL));
          [*(id *)(a1 + 152) setObject:v24 forKeyedSubscript:@"MaxCapacity"];

          v25 = mach_continuous_time() * dword_1008F1ED8 / *(unsigned int *)algn_1008F1EDC / 0x3B9ACA00;
          v26 = *(void *)(v5 + 15);
          if (v26) {
            v27 = v25 - v26;
          }
          else {
            v27 = 0LL;
          }
          id v28 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v38 = @"UNKNOWN";
            v39 = *(void *)(v5 + 15);
            *(_DWORD *)buf = v46;
            v51 = v38;
            v52 = 2048;
            *(void *)v53 = v39;
            *(_WORD *)&v53[8] = 2048;
            v54 = v25;
            v55 = 2048;
            v56 = v27;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "ADVBUFF(%@): lastReadTimeStamp:%llu now:%llu delta:%llu",  buf,  0x2Au);
          }

          *(void *)(v5 + 15) = v25;
          uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v27));
          [*(id *)(a1 + 152) setObject:v29 forKeyedSubscript:@"TimeSinceLastDrainInSeconds"];

          uint64_t v30 = sub_1002E8D94();
          (*(void (**)(uint64_t, void))(*(void *)v30 + 376LL))(v30, *(void *)(a1 + 152));
          if (v4 < 2)
          {
            if (v4) {
              __int128 v31 = 74LL;
            }
            else {
              __int128 v31 = 75LL;
            }
            __int128 v32 = (void *)sub_1002E8D94();
            (*(void (**)(void))(*v32 + 8 * v31))();
          }

          __int128 v33 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
          {
            __int128 v34 = @"UNKNOWN";
            __int128 v35 = v5[3];
            *(_DWORD *)buf = 138412802;
            v51 = v34;
            v52 = 1024;
            *(_DWORD *)v53 = v20;
            *(_WORD *)&v53[4] = 1024;
            *(_DWORD *)&v53[6] = v35;
            _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): ReadADVBuffer returned %d, fADVBufferExpectedEntries:%d",  buf,  0x18u);
          }

          if (v20 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_FAULT)) {
            sub_10069BFDC(&v48, v49);
          }
          if (v5[3] != 255) {
            goto LABEL_78;
          }
          v5[2] = 0;
        }

        if ((_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures") & 1) == 0) {
          sub_1005EB8B0(a1);
        }
        __int128 v36 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          __int128 v37 = @"UNKNOWN";
          *(_DWORD *)buf = 138412290;
          v51 = v37;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "ADVBUFF(%@): trying to read the next buffer",  buf,  0xCu);
        }
      }

      ++v4;
      v5 += 544;
    }

    while (v4 != 3);
    if (_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures"))
    {
      v41 = sub_100404FE8();
      v47[0] = _NSConcreteStackBlock;
      v47[1] = 3221225472LL;
      v47[2] = sub_1005EC5D0;
      v47[3] = &unk_10087EB20;
      v47[4] = a1;
      sub_100405384(v41, v47);
    }

    sub_1005EC5D8(a1);
  }

    id v22 = 0;
    return v22 & 1;
  }

  id v23 = *(__int128 **)(a1 + 2176);
  v43 = *(__int128 **)(a1 + 2184);
  if (v23 == v43) {
    goto LABEL_78;
  }
  do
  {
    __p[1] = 0LL;
    v48 = 0LL;
    __p[0] = 0LL;
    if (*((char *)v23 + 23) < 0)
    {
      sub_100024238(__p, *(void **)v23, *((void *)v23 + 1));
    }

    else
    {
      uint64_t v24 = *v23;
      v48 = *((void *)v23 + 2);
      *(_OWORD *)__p = v24;
    }

    sub_100494958(v2, (uint64_t)&v44);
    v25 = v46;
    v26 = v44;
    if ((v46 & 0x80u) == 0) {
      v27 = (char *)&v44;
    }
    else {
      v27 = (char *)v44;
    }
    id v28 = HIBYTE(v48);
    if (v48 >= 0) {
      uint64_t v29 = __p;
    }
    else {
      uint64_t v29 = (void **)__p[0];
    }
    if (v48 >= 0) {
      uint64_t v30 = HIBYTE(v48);
    }
    else {
      uint64_t v30 = (int64_t)__p[1];
    }
    if (v30)
    {
      if ((v46 & 0x80u) == 0) {
        __int128 v31 = v46;
      }
      else {
        __int128 v31 = v45;
      }
      __int128 v32 = &v27[v31];
      if (v31 >= v30)
      {
        __int128 v35 = *(unsigned __int8 *)v29;
        __int128 v36 = v27;
        do
        {
          __int128 v37 = v31 - v30;
          if (v37 == -1) {
            break;
          }
          uint64_t v38 = (char *)memchr(v36, v35, v37 + 1);
          if (!v38) {
            break;
          }
          __int128 v33 = v38;
          if (!memcmp(v38, v29, v30)) {
            goto LABEL_67;
          }
          __int128 v36 = v33 + 1;
          __int128 v31 = v32 - (v33 + 1);
        }

        while (v31 >= v30);
        __int128 v33 = v32;
LABEL_67:
        uint64_t v2 = a2;
      }

      else
      {
        __int128 v33 = &v27[v31];
      }

      if (v33 == v32) {
        __int128 v34 = -1LL;
      }
      else {
        __int128 v34 = v33 - v27;
      }
    }

    else
    {
      __int128 v34 = 0LL;
    }

    id v22 = v34 != -1;
    if ((v25 & 0x80) != 0)
    {
      operator delete(v26);
      if (v48 < 0) {
LABEL_77:
      }
        operator delete(__p[0]);
    }

    else if (v28 < 0)
    {
      goto LABEL_77;
    }

    if (v34 != -1) {
      break;
    }
    id v23 = (__int128 *)((char *)v23 + 24);
  }

  while (v23 != v43);
  return v22 & 1;
}

LABEL_111:
  }

  v60 = CBDeviceTypeToNSLocalizedString(-[CBDevice deviceType](self, "deviceType"));
  v61 = (void *)objc_claimAutoreleasedReturnValue(v60);
  if (v50)
  {
    v62 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name"));
    if (!v62
      || (v63 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name")),
          v64 = [v63 isEqualToString:v61],
          v63,
          v62,
          (v64 & 1) != 0))
    {
      v65 = sub_1000213C8((uint64_t)v52);
      v66 = (void *)objc_claimAutoreleasedReturnValue(v65);
      if (v66)
      {
        -[CBDevice setName:](self, "setName:", v66);
        v9 |= 0x80000000000uLL;
      }
    }
  }

  v67 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name"));

  if (!v67)
  {
    -[CBDevice setName:](self, "setName:", v61);
    v9 |= 0x80000000000uLL;
  }

  _Block_object_dispose(&v92, 8);
  _Block_object_dispose(&v96, 8);
  _Block_object_dispose(&v100, 8);

  _Block_object_dispose(&v106, 8);
  _Block_object_dispose(&v110, 8);

  _Block_object_dispose(&v116, 8);
  _Block_object_dispose(&v120, 8);

  _Block_object_dispose(v126, 8);
  _Block_object_dispose(&v128, 8);
  _Block_object_dispose(&v132, 8);
  _Block_object_dispose(&v136, 8);

  _Block_object_dispose(&v142, 8);
  _Block_object_dispose(&v146, 8);
  _Block_object_dispose(&v150, 8);
  _Block_object_dispose(&v154, 8);
  _Block_object_dispose(&v158, 8);
  _Block_object_dispose(&v162, 8);
  _Block_object_dispose(&v166, 8);

  return v9;
}

      v82 = obja;
      objc_autoreleasePoolPop(v90);
      if (v86 != (id)++v88) {
        continue;
      }
      break;
    }

    v86 = [v84 countByEnumeratingWithState:&v158 objects:v174 count:16];
    if (v86) {
      continue;
    }
    break;
  }

  v102 = v157;
  __int128 v37 = v138;
  v81 = v139;
  if (v157 == v83)
  {
LABEL_118:
    spatialDeviceMapMatched = self->_spatialDeviceMapMatched;
    if (!spatialDeviceMapMatched)
    {
      v104 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      v105 = self->_spatialDeviceMapMatched;
      self->_spatialDeviceMapMatched = v104;

      spatialDeviceMapMatched = self->_spatialDeviceMapMatched;
    }

    -[NSMutableDictionary setObject:forKeyedSubscript:]( spatialDeviceMapMatched,  "setObject:forKeyedSubscript:",  v83,  v134);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( self->_spatialDeviceMapUnmatched,  "setObject:forKeyedSubscript:",  0LL,  v134);
    if (self->_isHomePod)
    {
      v106 = sub_100064028();
      v107 = (os_log_s *)objc_claimAutoreleasedReturnValue(v106);
      if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG)) {
        sub_1006576B4((uint64_t)v83, v107, v108, v109, v110, v111, v112, v113);
      }

      v82 = obja;
    }

    else
    {
      v82 = obja;
      if (dword_1008D6630 <= 30
        && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
      {
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _spatialInteractionDeviceFound:checkOnly:]",  30LL,  "Spatial found device: %@",  v83);
      }
    }

    v125 = objc_claimAutoreleasedReturnValue(-[CBSpatialInteractionSession deviceFoundHandler](v135, "deviceFoundHandler"));
    v126 = (void *)v125;
    if (v125) {
      (*(void (**)(uint64_t, id))(v125 + 16))(v125, v83);
    }

    v102 = v83;
  }

  v96 = (os_log_s *)sub_100086554(0x3Au);
  if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v144[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "applebt_rx_main: Exiting rx thread\n",  (uint8_t *)v144,  2u);
  }

  return 0LL;
}

              return 1LL;
            }
          }

          if (v18)
          {
            memset(&v81, 0, sizeof(v81));
            sub_10002418C(&__str, v18);
            sub_1002D257C(&__str, 44, (uint64_t)&v81);
            v39 = v81.__r_.__value_.__l.__size_;
            v70 = v81.__r_.__value_.__l.__size_;
            v40 = v81.__r_.__value_.__r.__words[0];
            if (v81.__r_.__value_.__r.__words[0] != v81.__r_.__value_.__l.__size_)
            {
              while (1)
              {
                sub_1003D01A0(a4, (uint64_t)&__str);
                v41 = __str.__r_.__value_.__s.__size_;
                v42 = (void *)__str.__r_.__value_.__r.__words[0];
                v43 = (__str.__r_.__value_.__s.__size_ & 0x80u) == 0
                    ? &__str
                    : (std::string *)__str.__r_.__value_.__r.__words[0];
                v44 = *(char *)(v40 + 23);
                v45 = v44 >= 0 ? (unsigned __int8 *)v40 : *(unsigned __int8 **)v40;
                v46 = v44 >= 0 ? *(unsigned __int8 *)(v40 + 23) : *(void *)(v40 + 8);
                if (!v46) {
                  break;
                }
                if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  v47 = __str.__r_.__value_.__s.__size_;
                }
                else {
                  v47 = __str.__r_.__value_.__l.__size_;
                }
                v48 = (char *)v43 + v47;
                if (v47 >= v46)
                {
                  __pa = (void *)__str.__r_.__value_.__r.__words[0];
                  v51 = *v45;
                  v52 = v43;
                  do
                  {
                    v53 = v47 - v46;
                    if (v53 == -1) {
                      break;
                    }
                    v54 = (char *)memchr(v52, v51, v53 + 1);
                    if (!v54) {
                      break;
                    }
                    v49 = v54;
                    if (!memcmp(v54, v45, v46)) {
                      goto LABEL_90;
                    }
                    v52 = (std::string *)(v49 + 1);
                    v47 = v48 - (v49 + 1);
                  }

                  while (v47 >= v46);
                  v49 = v48;
LABEL_90:
                  v39 = v70;
                  v42 = __pa;
                }

                else
                {
                  v49 = (char *)v43 + v47;
                }

                if (v49 == v48) {
                  v50 = -1LL;
                }
                else {
                  v50 = v49 - (char *)v43;
                }
                if ((v41 & 0x80) != 0) {
                  goto LABEL_95;
                }
LABEL_96:
                if (v50 != -1)
                {
                  sub_10002418C(&__str, __s);
                  std::string::operator=(v67, &__str);
                  *(_BYTE *)(a3 + 80) = 1;
                  v58 = (os_log_s *)qword_1008F75E0;
                  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEBUG))
                  {
                    sub_1003D01A0(a4, (uint64_t)&__str);
                    if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                      v66 = &__str;
                    }
                    else {
                      v66 = (std::string *)__str.__r_.__value_.__r.__words[0];
                    }
                    *(_DWORD *)buf = 136446466;
                    v78 = v66;
                    v79 = 2082;
                    v80 = v40;
                    _os_log_debug_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEBUG,  "Friendly Name: %{public}s to Make Abbreviation matched: %{public}s",  buf,  0x16u);
                  }

                  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v81;
                  sub_100024304((void ***)&__str);
                  goto LABEL_111;
                }

                v40 += 24LL;
                if (v40 == v39) {
                  goto LABEL_98;
                }
              }

              v50 = 0LL;
              if ((__str.__r_.__value_.__s.__size_ & 0x80) == 0) {
                goto LABEL_96;
              }
LABEL_95:
              operator delete(v42);
              goto LABEL_96;
            }

        v27 = *(unsigned __int16 *)(a1 + 418);
        if (v27 >> 1 <= 0xFDA) {
          goto LABEL_118;
        }
        goto LABEL_112;
      default:
        goto LABEL_109;
    }
  }

  unsigned int v15 = qword_1008F7568;
  if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
    sub_100671428(a2, v15, v16, v17, v18, v19, v20, v21);
  }
  return 8LL;
}

  sub_100242FAC((uint64_t)v63);
  return v8;
}

void sub_1000209E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, char a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose(&a40, 8);
  _Block_object_dispose(&a44, 8);

  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a54, 8);

  _Block_object_dispose(&a60, 8);
  _Block_object_dispose(&a64, 8);

  _Block_object_dispose(&a70, 8);
  _Block_object_dispose(&STACK[0x208], 8);
  _Block_object_dispose(&STACK[0x228], 8);
  _Block_object_dispose(&STACK[0x248], 8);

  _Block_object_dispose(&STACK[0x278], 8);
  _Block_object_dispose(&STACK[0x298], 8);
  _Block_object_dispose((const void *)(v74 - 248), 8);
  _Block_object_dispose((const void *)(v74 - 216), 8);
  _Block_object_dispose((const void *)(v74 - 184), 8);
  _Block_object_dispose((const void *)(v74 - 152), 8);
  _Block_object_dispose((const void *)(v74 - 120), 8);

  _Unwind_Resume(a1);
}

uint64_t sub_100020BC4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100020BD4(uint64_t a1)
{
}

void sub_100020BDC(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = *(_WORD *)(a2 + 392);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = *(_BYTE *)(a2 + 164);
  *(_WORD *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = *(_WORD *)(a2 + 32);
  char v4 = *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  if (v4) {
    char v4 = *(_BYTE *)(a2 + 232) != 0;
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v4;
  int v5 = (_OWORD *)(a2 + 208);
  if (*(char *)(a2 + 231) < 0)
  {
    sub_100024238(__p, *(void **)(a2 + 208), *(void *)(a2 + 216));
  }

  else
  {
    *(_OWORD *)__p = *v5;
    uint64_t v52 = *(void *)(a2 + 224);
  }

  if (SHIBYTE(v52) < 0)
  {
    uint64_t v7 = __p[0];
    uint64_t v6 = a1 + 72;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = __p[1] != 0LL;
    operator delete(v7);
  }

  else
  {
    uint64_t v6 = a1 + 72;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = SHIBYTE(v52) != 0;
  }

  uint64_t v8 = *(void *)(*(void *)v6 + 8LL);
  int v9 = *(unsigned __int8 *)(v8 + 24);
  if (*(_BYTE *)(v8 + 24))
  {
    if (*(char *)(a2 + 231) < 0)
    {
      sub_100024238(__p, *(void **)(a2 + 208), *(void *)(a2 + 216));
    }

    else
    {
      *(_OWORD *)__p = *v5;
      uint64_t v52 = *(void *)(a2 + 224);
    }

    if (v52 >= 0) {
      uint64_t v11 = __p;
    }
    else {
      uint64_t v11 = (void **)__p[0];
    }
    BOOL v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
  }

  else
  {
    BOOL v10 = 0LL;
  }

  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL), v10);
  if (v9)
  {

    if (SHIBYTE(v52) < 0) {
      operator delete(__p[0]);
    }
  }

  sub_10002418C(v49, "IsHearingAid");
  int v12 = (void *)(a2 + 176);
  BOOL v13 = (void *)(a2 + 184);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL) = a2 + 184 != sub_100024098(a2 + 176, (const void **)v49);
  if (v50 < 0) {
    operator delete(v49[0]);
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 24LL) = sub_1005C4788(a2);
  sub_10002418C(v47, "IsPrimaryHearingAid");
  *(_BYTE *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL) = v13 != (void *)sub_100024098( a2 + 176,  (const void **)v47);
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 112) + 8LL) + 40LL), *(id *)(a2 + 304));
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_10087F720);
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 120) + 8LL) + 24LL) = sub_1005D4EDC( (uint64_t)off_1008D5F28,  *(void **)(a1 + 32));
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_10087F720);
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 128) + 8LL) + 24LL) = sub_1005D982C( (uint64_t)off_1008D5F28,  *(void **)(a1 + 32));
  if (*(char *)(a2 + 127) < 0)
  {
    sub_100024238(__dst, *(void **)(a2 + 104), *(void *)(a2 + 112));
  }

  else
  {
    *(_OWORD *)__dst = *(_OWORD *)(a2 + 104);
    __dst[2] = *(void **)(a2 + 120);
  }

  if (SHIBYTE(__dst[2]) >= 0) {
    unsigned int v14 = __dst;
  }
  else {
    unsigned int v14 = (void **)__dst[0];
  }
  uint64_t v15 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14));
  uint64_t v16 = *(void *)(*(void *)(a1 + 136) + 8LL);
  id v17 = *(void **)(v16 + 40);
  *(void *)(v16 + 40) = v15;

  if (SHIBYTE(__dst[2]) < 0) {
    operator delete(__dst[0]);
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 144) + 8LL) + 24LL) = *(_BYTE *)(a2 + 160);
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 152) + 8LL) + 40LL), *(id *)(a2 + 336));
  int v18 = *(_DWORD *)(a2 + 464);
  if (v18) {
    int v18 = *(_DWORD *)(a2 + 468) / v18;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 160) + 8LL) + 24LL) = v18;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_10087F720);
  }
  uint64_t v19 = off_1008D5F28;
  __int128 v20 = *(void **)(a1 + 32);
  sub_10002418C(v44, "_CTKD_");
  *(_BYTE *)(*(void *)(*(void *)(a1 + 168) + 8LL) + 24LL) = sub_1005CE5A8((uint64_t)v19, v20, (uint64_t)v44);
  if (v45 < 0) {
    operator delete(v44[0]);
  }
  id v21 = (void *)*v12;
  if ((void *)*v12 == v13) {
    return;
  }
  while (1)
  {
    memset(__dst, 0, 24);
    if (*((char *)v21 + 55) < 0)
    {
      sub_100024238(__dst, (void *)v21[4], v21[5]);
    }

    else
    {
      *(_OWORD *)__dst = *((_OWORD *)v21 + 2);
      __dst[2] = *((void **)v21 + 6);
    }

    char v22 = HIBYTE(__dst[2]);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0)
    {
      id v23 = __dst;
      switch(HIBYTE(__dst[2]))
      {
        case 9:
          goto LABEL_104;
        case 0xC:
          goto LABEL_120;
        case 0x10:
          goto LABEL_114;
        case 0x12:
          BOOL v24 = __dst[0] == (void *)0x4E41524145505041LL && __dst[1] == (void *)0x50454D41475F4543LL;
          if (!v24 || LOWORD(__dst[2]) != 17473) {
            goto LABEL_134;
          }
          goto LABEL_144;
        case 0x13:
          if (__dst[0] == (void *)0x4E41524145505041LL
            && __dst[1] == (void *)0x5453594F4A5F4543LL
            && *(void **)((char *)&__dst[1] + 3) == (void *)0x4B43495453594F4ALL)
          {
            goto LABEL_143;
          }

          if (__dst[0] == (void *)0x4E41524145505041LL
            && __dst[1] == (void *)0x4F4259454B5F4543LL
            && *(void **)((char *)&__dst[1] + 3) == (void *)0x4452414F4259454BLL)
          {
            goto LABEL_145;
          }

          if ((HIBYTE(__dst[2]) & 0x80) != 0) {
            goto LABEL_102;
          }
          id v23 = __dst;
          if (HIBYTE(__dst[2]) == 16) {
            goto LABEL_114;
          }
          if (HIBYTE(__dst[2]) == 12) {
            goto LABEL_120;
          }
          if (HIBYTE(__dst[2]) != 9) {
            goto LABEL_134;
          }
          goto LABEL_104;
        default:
          goto LABEL_134;
      }
    }

    id v23 = (void **)__dst[0];
    v26 = __dst[1];
    if (__dst[1] == (void *)18)
    {
      BOOL v27 = *(void *)__dst[0] == 0x4E41524145505041LL && *((void *)__dst[0] + 1) == 0x50454D41475F4543LL;
      if (v27 && *((_WORD *)__dst[0] + 8) == 17473)
      {
LABEL_144:
        char v43 = 26;
        goto LABEL_146;
      }
    }

LABEL_103:
LABEL_104:
    if (*v23 == (void *)0x73756F4D454C7349LL && *((_BYTE *)v23 + 8) == 101)
    {
LABEL_141:
      char v43 = 25;
      goto LABEL_146;
    }

    if ((HIBYTE(__dst[2]) & 0x80) != 0)
    {
      id v23 = (void **)__dst[0];
      v26 = __dst[1];
LABEL_113:
      goto LABEL_114;
    }

    if (HIBYTE(__dst[2]) == 12) {
      goto LABEL_120;
    }
    if (HIBYTE(__dst[2]) != 16) {
      goto LABEL_134;
    }
    id v23 = __dst;
LABEL_114:
    if ((HIBYTE(__dst[2]) & 0x80) == 0)
    {
      if (HIBYTE(__dst[2]) != 12) {
        goto LABEL_134;
      }
LABEL_120:
      goto LABEL_134;
    }

    id v23 = (void **)__dst[0];
    v26 = __dst[1];
LABEL_127:
    if (*v23 == (void *)0x6E69726165487349LL && *((_DWORD *)v23 + 2) == 1684619623LL)
    {
LABEL_142:
      char v43 = 51;
      goto LABEL_146;
    }

    if ((HIBYTE(__dst[2]) & 0x80) != 0) {
LABEL_133:
    }
      operator delete(v23);
LABEL_134:
    v41 = (void *)v21[1];
    if (v41)
    {
      do
      {
        v42 = v41;
        v41 = (void *)*v41;
      }

      while (v41);
    }

    else
    {
      do
      {
        v42 = (void *)v21[2];
        BOOL v24 = *v42 == (void)v21;
        id v21 = v42;
      }

      while (!v24);
    }

    id v21 = v42;
    if (v42 == v13) {
      return;
    }
  }

  if (*(void *)__dst[0] == 0x4E41524145505041LL
    && *((void *)__dst[0] + 1) == 0x5453594F4A5F4543LL
    && *(void *)((char *)__dst[0] + 11) == 0x4B43495453594F4ALL)
  {
LABEL_143:
    char v43 = 50;
    goto LABEL_146;
  }

  if (*(void *)__dst[0] != 0x4E41524145505041LL
    || *((void *)__dst[0] + 1) != 0x4F4259454B5F4543LL
    || *(void *)((char *)__dst[0] + 11) != 0x4452414F4259454BLL)
  {
LABEL_102:
    id v23 = (void **)__dst[0];
    v26 = __dst[1];
    goto LABEL_103;
  }

        char v43 = 6;
        goto LABEL_104;
      }

      if (*(_DWORD *)(sub_100037B04(v42, v57) + 20) == 6)
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        *(void *)buf = &v57;
        if (*(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v57, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5]
                       + 76) == 2)
        {
          if (qword_1008D6458 != -1) {
            dispatch_once(&qword_1008D6458, &stru_10087FF40);
          }
        }

        v55 = (os_log_s *)qword_1008F7570;
        v56 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
        if (v56)
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency start with valid link",  buf,  2u);
        }

        *(_WORD *)(sub_100037B04(v56, v57) + 44) = -1;
        *((_WORD *)v5 + _Block_object_dispose(va, 8) = 60;
        char v43 = 1;
LABEL_104:
        v44 = (os_log_s *)qword_1008F7570;
        if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
        {
          char v45 = v5[1];
          v46 = v5[3];
          v47 = v5[5];
          char v48 = v5[2];
          v49 = v5[8];
          char v50 = v5[7];
          v51 = *v5;
          uint64_t v52 = v5[6];
          v53 = v5[9];
          v54 = v5[4];
          *(_DWORD *)buf = 67111680;
          *(_DWORD *)&buf[4] = v45;
          v59 = 1024;
          v60 = v46;
          v61 = 1024;
          v62 = v47;
          v63 = 1024;
          v64 = v48;
          v65 = 1024;
          v66 = v49;
          v67 = 1024;
          v68 = v50;
          v69 = 1024;
          v70 = v13 != v37;
          v71 = 1024;
          v72 = v51;
          v73 = 1024;
          uint64_t v74 = v52;
          v75 = 1024;
          v76 = v53;
          v77 = 1024;
          v78 = v54;
          _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency Trigger fKeyboardOn =%d, fVoiceOverOn=%d, fGameModeOn=%d, fGarageBandOn=%d, fSpatialVideoOn= %d, fSpatialMusicOn=%d, aggregated = %d, fScreenOn =%d, fExpanseOn =%d, fAudioInputAggregateOn =%d, fConsoleGameModeOn=%d",  buf,  0x44u);
        }

        sub_100038EA0((uint64_t)v5, a3, v43);
        goto LABEL_40;
      }
    }

    else if (*(_DWORD *)(sub_100037B04(v40, v57) + 20) == 6)
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      *(void *)buf = &v57;
      if (*(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v57, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5]
                     + 76) == 2)
      {
        if (qword_1008D6458 != -1) {
          dispatch_once(&qword_1008D6458, &stru_10087FF40);
        }
      }

      char v43 = 7;
      goto LABEL_104;
    }

    sub_100038EA0((uint64_t)v5, a3, 6);
    uint64_t v38 = 2000;
    goto LABEL_56;
  }

  __int128 v35 = qword_1008F7570;
  if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
    return;
  }
  *(_WORD *)buf = 0;
  __int128 v32 = "Dynamic Latency defaults writes enabled don't allow screen off dynamic latency transition.";
  __int128 v33 = (os_log_s *)v35;
  __int128 v34 = 2;
LABEL_44:
  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, v32, buf, v34);
}

        v49 = (void *)v22[1];
        if (v49)
        {
          do
          {
            char v50 = v49;
            v49 = (void *)*v49;
          }

          while (v49);
        }

        else
        {
          do
          {
            char v50 = (void *)v22[2];
            v51 = *v50 == (void)v22;
            char v22 = v50;
          }

          while (!v51);
        }

        char v22 = v50;
        if (v50 == (void *)(a1 + 232)) {
          goto LABEL_116;
        }
      }

      __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v28 + 216) objectForKeyedSubscript:v7]);
      if (sub_100390D94(v28))
      {
        *(void *)v87 = 0LL;
        if (qword_1008D5F10 != -1) {
          dispatch_once(&qword_1008D5F10, &stru_10088BB00);
        }
        __int128 v36 = off_1008D5F08;
        sub_100241F90(buf, v7);
        if (sub_100599890((uint64_t)v36, buf, v87))
        {
          __int128 v37 = sub_10024F00C();
          if (v71) {
            sub_100252400(v37, *(unint64_t *)v87, v64);
          }
          else {
            sub_1002524D8(v37, *(unint64_t *)v87, v64);
          }
        }
      }

      if (v35)
      {
        uint64_t v38 = (os_log_s *)qword_1008F7628;
        if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
        {
          sub_100494958(v27, (uint64_t)buf);
          v39 = buf;
          if (buf[23] < 0) {
            v39 = *(_BYTE **)buf;
          }
          *(_DWORD *)v87 = 138543618;
          *(void *)&v87[4] = v7;
          v88 = 2082;
          v89 = v39;
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "Dispatching connection status update for device %{public}@ to session %{public}s",  v87,  0x16u);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }

        if (v65)
        {
          memset(buf, 0, 24);
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10088BB80);
          }
          sub_1005CE910((uint64_t)off_1008D5F28, v7, (uint64_t *)buf);
          v40 = sub_1002E8D94();
          sub_100291924(v79, (const void ***)buf);
          (*(void (**)(uint64_t, id, uint64_t *, void))(*(void *)v40 + 672LL))(v40, v7, v79, 0LL);
          sub_10023E78C((uint64_t)v79, (char *)v79[1]);
          sub_1002809BC(v41, v27, v28, v7, 0, 0);
          sub_10023E78C((uint64_t)buf, *(char **)&buf[8]);
        }

        else
        {
          v44 = [*(id *)(v28 + 80) removeObjectForKey:v7];
          if (v71)
          {
            sub_1002809BC((uint64_t)v44, v27, v28, v7, a4, 0);
LABEL_102:

            goto LABEL_103;
          }

          char v45 = [v35 enableAutoReconnect];
          sub_100285740((uint64_t)v45, v27, v28, v7, a4, (uint64_t)v45);
          if ([v35 enableAutoReconnect])
          {
            v46 = sub_100404FE8();
            v72[0] = _NSConcreteStackBlock;
            v72[1] = 3221225472LL;
            v72[2] = sub_1002859C8;
            v72[3] = &unk_10088B9F0;
            v75 = a1;
            v76 = v27;
            v77 = v28;
            v73 = v7;
            v78 = v67;
            uint64_t v74 = v35;
            sub_100405384(v46, v72);
          }

          else
          {
            [*(id *)(v28 + 216) removeObjectForKey:v7];
          }
        }

        if (!*(_BYTE *)(v28 + 24) && *(_BYTE *)(v28 + 129) == 4)
        {
          if (v71)
          {
          }

          else if (![v35 disconnectionAlerts])
          {
LABEL_83:
            v42 = (os_log_s *)qword_1008F7628;
            if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_INFO))
            {
              sub_100494958(v27, (uint64_t)v87);
              char v43 = v87;
              if (v90 < 0) {
                char v43 = *(_BYTE **)v87;
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&buf[4] = v62;
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v43;
              *(_WORD *)&buf[22] = 2114;
              *(void *)&buf[24] = v7;
              _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_INFO,  "Suppressing %{public}s alert on session %{public}s for device %{public}@",  buf,  0x20u);
              if (v90 < 0) {
                operator delete(*(void **)v87);
              }
            }

            goto LABEL_95;
          }

          v47 = sub_1002E8E64();
          (*(void (**)(uint64_t, unint64_t, id, void))(*(void *)v47 + 96LL))(v47, v27, v7, v63);
        }
      }

  *(_BYTE *)(a1 + 1435) = 0;
  *(_WORD *)(a1 + 143_Block_object_dispose(va, 8) = 0;
  return a1;
}

LABEL_145:
  char v43 = 24;
LABEL_146:
  *(_BYTE *)(*(void *)(*(void *)(a1 + 176) + 8LL) + 24LL) = v43;
  if (v22 < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100021330( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, void *__p, uint64_t a36, int a37, __int16 a38, char a39, char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1000213C8(uint64_t a1)
{
  if ((int)a1 <= 665)
  {
    if ((int)a1 > 570)
    {
      if ((int)a1 > 598)
      {
        switch((int)a1)
        {
          case 613:
            goto LABEL_25;
          case 614:
          case 616:
          case 618:
          case 619:
            goto LABEL_50;
          case 615:
            goto LABEL_11;
          case 617:
            goto LABEL_51;
          case 620:
            os_log_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
            uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_magic_keyboard_keypad" value:&stru_1008A57D8 table:@"CBLocalizable"]);
            break;
          default:
            if ((_DWORD)a1 == 599) {
              goto LABEL_49;
            }
            goto LABEL_50;
        }

        goto LABEL_53;
      }

      if ((_DWORD)a1 == 571 || (_DWORD)a1 == 597 || (_DWORD)a1 == 598) {
        goto LABEL_49;
      }
    }

    else if ((int)a1 <= 555)
    {
      if ((int)a1 > 520)
      {
        if ((_DWORD)a1 == 521 || (_DWORD)a1 == 522) {
          goto LABEL_49;
        }
      }

      else
      {
        if (!(_DWORD)a1) {
          return 0LL;
        }
        if ((_DWORD)a1 == 520) {
          goto LABEL_49;
        }
      }
    }

    else if ((int)a1 <= 558 || (_DWORD)a1 == 569 || (_DWORD)a1 == 570)
    {
LABEL_49:
      os_log_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSBundle bundleWithIdentifier:]( &OBJC_CLASS___NSBundle,  "bundleWithIdentifier:",  @"com.apple.CoreBluetooth"));
      uint64_t v2 = objc_claimAutoreleasedReturnValue( [v1 localizedStringForKey:@"apple_wireless_keyboard" value:&stru_1008A57D8 table:@"CBLocalizable"]);
      goto LABEL_53;
    }

void sub_100021D2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_246:
    }
  }

  v138 = sub_1003D0268((uint64_t)a3);
  if (-[CBDevice deviceType](self, "deviceType") != v138)
  {
    -[CBDevice setDeviceType:](self, "setDeviceType:", v138);
    v23 |= 0x80000000000uLL;
  }

  v139 = sub_1003D635C((uint64_t)a3);
  if (HIBYTE(v139) < 5u) {
    v140 = HIBYTE(v139) + 1;
  }
  else {
    v140 = 0;
  }
  if (v140 != -[CBDevice doubleTapActionLeft](self, "doubleTapActionLeft"))
  {
    -[CBDevice setDoubleTapActionLeft:](self, "setDoubleTapActionLeft:", (char)v140);
    v23 |= 0x80000000000uLL;
  }

  else {
    v141 = 0;
  }
  if (v141 != -[CBDevice doubleTapActionRight](self, "doubleTapActionRight"))
  {
    -[CBDevice setDoubleTapActionRight:](self, "setDoubleTapActionRight:", (char)v141);
    v23 |= 0x80000000000uLL;
  }

  v142 = -[CBDevice doubleTapCapability](self, "doubleTapCapability");
  if (sub_1003D0070((uint64_t)a3, 0x80000u) == 4)
  {
    v143 = sub_1003D2B2C((uint64_t)a3, 14) ? 2 : 1;
    if (v143 != v142)
    {
      -[CBDevice setDoubleTapCapability:](self, "setDoubleTapCapability:", (char)v143);
      v23 |= 0x80000000000uLL;
    }
  }

  v144 = sub_1003D8484((uint64_t)a3);
  if ((_DWORD)v144 != -[CBDevice gapaFlags](self, "gapaFlags"))
  {
    -[CBDevice setGapaFlags:](self, "setGapaFlags:", v144);
    v23 |= 0x80000000000uLL;
  }

  if (0xAAAAAAAAAAAAAAABLL * ((v261 - (uint64_t)v260) >> 3) < 0xB)
  {
    if (!v236) {
      goto LABEL_283;
    }
    v152 = NSPrintF_safe("%u.%u.%u", BYTE1(v258), v258 >> 4, v258 & 0xF);
    v148 = (id)objc_claimAutoreleasedReturnValue(v152);
    v153 = (id)objc_claimAutoreleasedReturnValue(-[CBDevice firmwareVersion](self, "firmwareVersion"));

    if (v148 != v153)
    {
LABEL_281:
      -[CBDevice setFirmwareVersion:](self, "setFirmwareVersion:", v148);
      v23 |= 0x80000000000uLL;
    }
  }

  else
  {
    v145 = v260 + 240;
    if (v260[263] < 0) {
      v145 = (void *)*v145;
    }
    v146 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v145));
    if ([v146 length])
    {
      v147 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice firmwareVersion](self, "firmwareVersion"));
      v148 = v146;
      v149 = v147;
      if (v148 != v149)
      {
        v150 = v149;
        if ((v148 == 0LL) == (v149 != 0LL))
        {
        }

        else
        {
          v151 = [v148 isEqual:v149];

          if ((v151 & 1) != 0) {
            goto LABEL_282;
          }
        }

        goto LABEL_281;
      }
    }

    else
    {
      v148 = v146;
    }
  }

LABEL_282:
LABEL_283:
  if (*((_BYTE *)a3 + 1373)) {
    v154 = 2;
  }
  else {
    v154 = 1;
  }
  if (-[CBDevice frequencyBand](self, "frequencyBand") != v154)
  {
    -[CBDevice setFrequencyBand:](self, "setFrequencyBand:", v154);
    v23 |= 0x80000000000uLL;
  }

  else {
    v155 = 2;
  }
  if (v155 != -[CBDevice hearingAidSupport](self, "hearingAidSupport"))
  {
    -[CBDevice setHearingAidSupport:](self, "setHearingAidSupport:", v155);
    v23 |= 0x80000000000uLL;
  }

  else {
    v156 = 2;
  }
  if (v156 != -[CBDevice hearingTestSupport](self, "hearingTestSupport"))
  {
    -[CBDevice setHearingTestSupport:](self, "setHearingTestSupport:", v156);
    v23 |= 0x80000000000uLL;
  }

  v157 = sub_1003DFA38((uint64_t)a3);
  if ((_DWORD)v157 != -[CBDevice listeningMode](self, "listeningMode"))
  {
    -[CBDevice setListeningMode:](self, "setListeningMode:", v157);
    v23 |= 0x80000000000uLL;
  }

  v158 = sub_1003DFA7C((uint64_t)a3);
  if ((_DWORD)v158 != -[CBDevice listeningModeConfigs](self, "listeningModeConfigs"))
  {
    -[CBDevice setListeningModeConfigs:](self, "setListeningModeConfigs:", v158);
    v23 |= 0x80000000000uLL;
  }

  v159 = sub_1003DF900((uint64_t)a3);
  if (v159 >= 3) {
    v160 = 0;
  }
  else {
    v160 = 0x20301u >> (8 * v159);
  }
  if (v160 != -[CBDevice microphoneMode](self, "microphoneMode"))
  {
    -[CBDevice setMicrophoneMode:](self, "setMicrophoneMode:", (char)v160);
    v23 |= 0x80000000000uLL;
  }

  if (0xAAAAAAAAAAAAAAABLL * ((v261 - (uint64_t)v260) >> 3) >= 2)
  {
    v161 = v260 + 24;
    if (v260[47] < 0) {
      v161 = (void *)*v161;
    }
    v162 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v161));
    if (![v162 length]) {
      goto LABEL_318;
    }
    v163 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice modelUser](self, "modelUser"));
    v164 = v162;
    v165 = v163;
    if (v164 == v165)
    {
    }

    else
    {
      v166 = v165;
      if ((v164 == 0LL) == (v165 != 0LL))
      {
      }

      else
      {
        v167 = [v164 isEqual:v165];

        if ((v167 & 1) != 0) {
          goto LABEL_318;
        }
      }

      -[CBDevice setModelUser:](self, "setModelUser:", v164);
      v23 |= 0x80000000000uLL;
    }

  v132 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ConnRSSIStageOneThirdPartyApp");
  v133 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v132 + 88LL))(v132, buf, __p, &v163);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v133) {
      goto LABEL_290;
    }
  }

  else if (!v133)
  {
    goto LABEL_290;
  }

  v134 = v163;
  *(_BYTE *)(a1 + 1349) = v163;
  v135 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v134;
    _os_log_impl( (void *)&_mh_execute_header,  v135,  OS_LOG_TYPE_DEFAULT,  "LEConnectionThirdPartyAppStageOneThresholdRssi %d overridden",  buf,  8u);
  }

LABEL_318:
  }

  sub_1003D0100((uint64_t)a3, (uint64_t)__p);
  if (v250 >= 0) {
    v168 = __p;
  }
  else {
    v168 = (void **)__p[0];
  }
  v169 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v168));
  if (SHIBYTE(v250) < 0) {
    operator delete(__p[0]);
  }
  if ([v169 length])
  {
    v170 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name"));
    v171 = v169;
    v172 = v170;
    if (v171 == v172)
    {

      goto LABEL_332;
    }

    v173 = v172;
    if ((v171 == 0LL) == (v172 != 0LL))
    {
    }

    else
    {
      v174 = [v171 isEqual:v172];

      if ((v174 & 1) != 0) {
        goto LABEL_332;
      }
    }

    -[CBDevice setName:](self, "setName:", v171);
    v23 |= 0x80000000000uLL;
  }

                operator delete(v118);
                goto LABEL_102;
              }

              memset(buf, 0, 24);
              v180 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
              sub_10002418C(buf, v180);
              memset(&dst, 0, sizeof(dst));
              v181 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceIdentifier");
              sub_10002418C(&dst, v181);
              v182 = xpc_dictionary_get_value(a3, "kLeaDeviceTags");
              v183 = sub_1002E6E9C();
              if (sub_1002D0F8C(v183) <= 1)
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_100024238(&v317, *(void **)buf, *(unint64_t *)&buf[8]);
                }

                else
                {
                  v317 = *(_OWORD *)buf;
                  v318 = *(void *)&buf[16];
                }

                sub_100644220(a1, (const char *)&v317, 3u);
                if ((SHIBYTE(v318) & 0x80000000) == 0) {
                  goto LABEL_102;
                }
                v118 = (void *)v317;
                goto LABEL_318;
              }

              *(_WORD *)&v340[4] = 0;
              *(_DWORD *)v340 = 0;
              if (buf[23] >= 0) {
                v190 = buf;
              }
              else {
                v190 = *(unsigned __int8 **)buf;
              }
              if (!sub_1003FE1A4((uint64_t)v340, v190))
              {
                if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
                  sub_1006A0E24();
                }
                goto LABEL_102;
              }

              v191 = ((unint64_t)v340[0] << 40) | ((unint64_t)v340[1] << 32) | ((unint64_t)v340[2] << 24) | ((unint64_t)v340[3] << 16) | ((unint64_t)v340[4] << 8) | v340[5];
              *(_OWORD *)&v342.__r_.__value_.__l.__data_ = 0uLL;
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_1008A4F88);
              }
              sub_1005C8684((uint64_t)off_1008D5F28, v191, 1u, 0, 0LL, 0LL, (unsigned __int8 *)&v342);
              if (qword_1008D5F20 != -1) {
                dispatch_once(&qword_1008D5F20, &stru_1008A5128);
              }
              v192 = qword_1008D5F18;
              v193 = sub_100241F94((const unsigned __int8 *)&v342);
              v194 = (void *)objc_claimAutoreleasedReturnValue(v193);
              v195 = sub_10061C0F8(v192, v194);

              if (v182)
              {
                v196 = sub_10043E7E4(v182);
                v182 = (xpc_object_t)objc_claimAutoreleasedReturnValue(v196);
              }

              v197 = (void *)objc_claimAutoreleasedReturnValue([v182 objectEnumerator]);
              if (v197)
              {
                v198 = 0LL;
                while (1)
                {
                  v199 = objc_claimAutoreleasedReturnValue([v197 nextObject]);

                  if (!v199) {
                    break;
                  }
                  v200 = (void *)v199;
                  if (qword_1008D5F30 != -1) {
                    dispatch_once(&qword_1008D5F30, &stru_1008A4F88);
                  }
                  v201 = off_1008D5F28;
                  v202 = sub_100241F94((const unsigned __int8 *)&v342);
                  v203 = (void *)objc_claimAutoreleasedReturnValue(v202);
                  v198 = v200;
                  sub_10002418C(v315, (char *)[v198 UTF8String]);
                  sub_1005CCF08((uint64_t)v201, v203, (unsigned __int8 *)v315);
                  if (v316 < 0) {
                    operator delete(v315[0]);
                  }
                }
              }

              if (v195)
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_100024238(&v313, *(void **)buf, *(unint64_t *)&buf[8]);
                }

                else
                {
                  v313 = *(_OWORD *)buf;
                  v314 = *(void *)&buf[16];
                }

                sub_100644220(a1, (const char *)&v313, 2u);
                if ((SHIBYTE(v314) & 0x80000000) == 0) {
                  goto LABEL_642;
                }
                v260 = (void **)&v313;
              }

              else
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_100024238(&v311, *(void **)buf, *(unint64_t *)&buf[8]);
                }

                else
                {
                  v311 = *(_OWORD *)buf;
                  v312 = *(void *)&buf[16];
                }

                sub_100644220(a1, (const char *)&v311, 1u);
                if ((SHIBYTE(v312) & 0x80000000) == 0) {
                  goto LABEL_642;
                }
                v260 = (void **)&v311;
              }

              operator delete(*v260);
LABEL_642:

              goto LABEL_102;
            }

            memset(&dst, 0, sizeof(dst));
            v129 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
            sub_10002418C(&dst, v129);
            v130 = xpc_dictionary_get_int64(a3, "kQuickDisconnectEnabled");
            WORD2(v345) = 0;
            LODWORD(v345) = 0;
            if ((dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              v131 = &dst;
            }
            else {
              v131 = (std::string *)dst.__r_.__value_.__r.__words[0];
            }
            if (!sub_1003FE1A4((uint64_t)&v345, (unsigned __int8 *)v131))
            {
              if ((_BYTE)v345)
              {
LABEL_333:
                if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
                  sub_1006A0DF8();
                }
                goto LABEL_338;
              }

              v204 = 1LL;
              while (v204 != 6)
              {
                if (*((unsigned __int8 *)&v345 + v204++))
                {
                  goto LABEL_333;
                }
              }
            }

            if (qword_1008D5F50 != -1) {
              dispatch_once(&qword_1008D5F50, &stru_1008A4FA8);
            }
            v132 = (unsigned __int8 *)sub_1003FFEB0(off_1008D5F48, (uint64_t)&v345, 0);
            v133 = (uint64_t)v132;
            if (v132 && sub_1003CF350(v132))
            {
              v134 = (os_log_s *)qword_1008F7600;
              if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
              {
                sub_1003CF00C(v133, &v342);
                v135 = (char)v342.__r_.__value_.__s.__size_;
                v136 = v342.__r_.__value_.__r.__words[0];
                v137 = sub_1003D0670(v133);
                v138 = &v342;
                if (v135 < 0) {
                  v138 = (std::string *)v136;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&buf[4] = v138;
                if (v137) {
                  v139 = "is";
                }
                else {
                  v139 = "not";
                }
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = v139;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v130 != 0;
                _os_log_impl( (void *)&_mh_execute_header,  v134,  OS_LOG_TYPE_DEFAULT,  "ConnectClassicDevice: device %{public}s %s connected with QuickDisconnectEnabled %d",  buf,  0x1Cu);
              }

              if (sub_1003D0670(v133))
              {
                if (v130)
                {
                  if (qword_1008D60D0 != -1) {
                    dispatch_once(&qword_1008D60D0, &stru_1008A5008);
                  }
                  sub_1004271D4((uint64_t)off_1008D60C8, (unsigned __int8 *)&v345);
                }

                else
                {
                  v251 = sub_1002E6BF0();
                  if ((*(unsigned int (**)(uint64_t))(*(void *)v251 + 352LL))(v251))
                  {
                    v252 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 16) firstObject]);
                    if (v252)
                    {
                      if (qword_1008D5F30 != -1) {
                        dispatch_once(&qword_1008D5F30, &stru_1008A4F88);
                      }
                      v253 = sub_1005CC198((uint64_t)off_1008D5F28, v252, 0);
                      LOBYTE(v343) = BYTE5(v253);
                      BYTE1(v343) = BYTE4(v253);
                      BYTE2(v343) = BYTE3(v253);
                      BYTE3(v343) = BYTE2(v253);
                      BYTE4(v343) = BYTE1(v253);
                      BYTE5(v343) = v253;
                      v254 = (os_log_s *)qword_1008F7600;
                      if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
                      {
                        sub_1003CF00C(v133, &v342);
                        v255 = (char)v342.__r_.__value_.__s.__size_;
                        v256 = v342.__r_.__value_.__r.__words[0];
                        sub_1003FE1B4((unsigned __int8 *)&v343, v340);
                        v257 = &v342;
                        if (v255 < 0) {
                          v257 = (std::string *)v256;
                        }
                        if (v341 >= 0) {
                          v258 = v340;
                        }
                        else {
                          v258 = *(_BYTE **)v340;
                        }
                        *(_DWORD *)buf = 136446723;
                        *(void *)&buf[4] = v257;
                        *(_WORD *)&buf[12] = 2160;
                        *(void *)&buf[14] = 1752392040LL;
                        *(_WORD *)&buf[22] = 2081;
                        *(void *)&buf[24] = v258;
                        _os_log_impl( (void *)&_mh_execute_header,  v254,  OS_LOG_TYPE_DEFAULT,  "ConnectClassicDevice: already in triangle, device %{public}s, peerSource %{private, mask.hash}s",  buf,  0x20u);
                        if (v341 < 0) {
                          operator delete(*(void **)v340);
                        }
                      }

                      if (qword_1008D60E0 != -1) {
                        dispatch_once(&qword_1008D60E0, &stru_1008A5048);
                      }
                      sub_10021B398((uint64_t)off_1008D60D8, v133, 0);
                    }

                    else if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR))
                    {
                      sub_1006A0DCC();
                    }
                  }

                  else
                  {
                    v259 = (os_log_s *)qword_1008F7600;
                    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v259,  OS_LOG_TYPE_DEFAULT,  "Device already connected ignoring connect classic request",  buf,  2u);
                    }
                  }
                }
              }

              else
              {
                if (qword_1008D5F00 != -1) {
                  dispatch_once(&qword_1008D5F00, &stru_1008A5108);
                }
                if ((sub_1004099B8() & 1) != 0)
                {
                  v236 = (os_log_s *)qword_1008F7600;
                  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_1003CF00C(v133, buf);
                    v237 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
                    LODWORD(v342.__r_.__value_.__l.__data_) = 136446466;
                    *(std::string::size_type *)((char *)v342.__r_.__value_.__r.__words + 4) = (std::string::size_type)v237;
                    WORD2(v342.__r_.__value_.__r.__words[1]) = 2080;
                    *(std::string::size_type *)((char *)&v342.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"enabled";
                    _os_log_impl( (void *)&_mh_execute_header,  v236,  OS_LOG_TYPE_DEFAULT,  "Ignoring ConnectClassicDevice msg for %{public}s, Denylist is %s",  (uint8_t *)&v342,  0x16u);
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                }

                else
                {
                  if (qword_1008D60D0 != -1) {
                    dispatch_once(&qword_1008D60D0, &stru_1008A5008);
                  }
                  memset(buf, 0, 24);
                  sub_100424360((int64x2_t *)off_1008D60C8, v133, -1, (const std::string *)buf, 2LL);
                  if ((buf[23] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                  v338 = @"wxAddress";
                  v245 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  sub_1003A2940((unsigned __int8 *)(v133 + 128)));
                  v246 = (void *)objc_claimAutoreleasedReturnValue(v245);
                  v339 = v246;
                  v247 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v339,  &v338,  1LL));

                  v248 = (os_log_s *)qword_1008F7600;
                  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_1003CF00C(v133, buf);
                    v249 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
                    LODWORD(v342.__r_.__value_.__l.__data_) = 136446210;
                    *(std::string::size_type *)((char *)v342.__r_.__value_.__r.__words + 4) = (std::string::size_type)v249;
                    _os_log_impl( (void *)&_mh_execute_header,  v248,  OS_LOG_TYPE_DEFAULT,  "ConnectClassicDevice: Sending notification to AAD for device %{public}s,",  (uint8_t *)&v342,  0xCu);
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                  }

                  v250 = (void *)objc_claimAutoreleasedReturnValue( +[NSDistributedNotificationCenter defaultCenter]( &OBJC_CLASS___NSDistributedNotificationCenter,  "defaultCenter"));
                  [v250 postNotificationName:@"com.apple.BTServer.TriangleRecoveryInitiated" object:0 userInfo:v247];
                }
              }
            }

            else if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR))
            {
              sub_1006A0D74();
            }

LABEL_332:
  if ([v169 length])
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_10087F720);
    }
    v175 = off_1008D5F28;
    sub_1003D0100((uint64_t)a3, (uint64_t)v246);
    sub_1005D1A28((uint64_t)v175, v243, (unsigned __int8 *)v246);
    if (v247 < 0) {
      operator delete(v246[0]);
    }
  }

  v176 = -[CBDevice primaryPlacement](self, "primaryPlacement");
  v177 = -[CBDevice secondaryPlacement](self, "secondaryPlacement");
  v178 = -[CBDevice primaryBudSide](self, "primaryBudSide");
  if (sub_1003D0070((uint64_t)a3, 0x80000u) == 4)
  {
    v179 = sub_1003DF944((uint64_t)a3);
    LODWORD(__p[0]) = 3;
    v244 = 3;
    v245 = 3;
    if (v237)
    {
      if (qword_1008D60E0 != -1) {
        dispatch_once(&qword_1008D60E0, &stru_10087F780);
      }
      sub_10021F164((uint64_t)off_1008D60D8, (uint64_t)a3, (int *)__p, &v245);
      if (qword_1008D60E0 != -1) {
        dispatch_once(&qword_1008D60E0, &stru_10087F780);
      }
      sub_10021F3F4((uint64_t)off_1008D60D8, (uint64_t)a3, &v244);
    }

    if (v179)
    {
      if (LODWORD(__p[0]) > 0xC) {
        v180 = 0;
      }
      else {
        v180 = dword_1006BA950[SLODWORD(__p[0])];
      }
      v181 = 1LL;
      switch(v245)
      {
        case 0:
          break;
        case 1:
          v181 = 2LL;
          break;
        case 2:
          v181 = 3LL;
          break;
        case 10:
          v181 = 4LL;
          break;
        case 11:
          v181 = 5LL;
          break;
        case 12:
          v181 = 6LL;
          break;
        default:
          v181 = 0LL;
          break;
      }
    }

    else
    {
      v180 = 7;
      v181 = 7LL;
    }

    if (v244 == 2) {
      v183 = 2;
    }
    else {
      v183 = 3;
    }
    if (v244 == 1) {
      v182 = 1;
    }
    else {
      v182 = v183;
    }
  }

  else
  {
    v180 = 0;
    v181 = 0LL;
    v182 = 3;
  }

  if (v180 != v176)
  {
    -[CBDevice setPrimaryPlacement:](self, "setPrimaryPlacement:");
    v23 |= 0x80000000000uLL;
  }

  if ((_DWORD)v181 != v177)
  {
    -[CBDevice setSecondaryPlacement:](self, "setSecondaryPlacement:", v181);
    v23 |= 0x80000000000uLL;
  }

  if (v178 != v182)
  {
    -[CBDevice setPrimaryBudSide:](self, "setPrimaryBudSide:", v182);
    v23 |= 0x80000000000uLL;
  }

  else {
    v184 = 2;
  }
  if (v184 != -[CBDevice placementMode](self, "placementMode"))
  {
    -[CBDevice setPlacementMode:](self, "setPlacementMode:", v184);
    v23 |= 0x80000000000uLL;
  }

  v185 = sub_1003DFF44((uint64_t)a3);
  if (v185 != -[CBDevice selectiveSpeechListeningConfig](self, "selectiveSpeechListeningConfig"))
  {
    -[CBDevice setSelectiveSpeechListeningConfig:](self, "setSelectiveSpeechListeningConfig:", v185);
    v23 |= 0x80000000000uLL;
  }

  v186 = sub_1003E0350((uint64_t)a3, 6u);
  v187 = sub_1002E6E9C();
  v188 = sub_1002CD53C(v187, 4u);
  if (v186 == 3) {
    v189 = v188;
  }
  else {
    v189 = 0LL;
  }
  if ((_DWORD)v189
    && -[CBDevice selectiveSpeechListeningCapability](self, "selectiveSpeechListeningCapability") != 1)
  {
    -[CBDevice setSelectiveSpeechListeningCapability:](self, "setSelectiveSpeechListeningCapability:", v189);
    v23 |= 0x80000000000uLL;
  }

  if ([v240 length])
  {
    v190 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice serialNumber](self, "serialNumber"));
    v191 = v240;
    v192 = v190;
    if (v191 == v192)
    {

      goto LABEL_382;
    }

    v193 = v192;
    if ((v191 == 0LL) == (v192 != 0LL))
    {
    }

    else
    {
      v194 = [v191 isEqual:v192];

      if ((v194 & 1) != 0) {
        goto LABEL_382;
      }
    }

    -[CBDevice setSerialNumber:](self, "setSerialNumber:", v191);
    v23 |= 0x80000000000uLL;
  }

LABEL_382:
  if (![v242 length]) {
    goto LABEL_390;
  }
  v195 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice serialNumberLeft](self, "serialNumberLeft"));
  v196 = v242;
  v197 = v195;
  if (v196 == v197)
  {

    goto LABEL_390;
  }

  v198 = v197;
  if ((v196 == 0LL) == (v197 != 0LL))
  {

    goto LABEL_389;
  }

  v199 = [v196 isEqual:v197];

  if ((v199 & 1) == 0)
  {
LABEL_389:
    -[CBDevice setSerialNumberLeft:](self, "setSerialNumberLeft:", v196);
    v23 |= 0x80000000000uLL;
  }

LABEL_390:
  if (![v241 length]) {
    goto LABEL_398;
  }
  v200 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice serialNumberRight](self, "serialNumberRight"));
  v201 = v241;
  v202 = v200;
  if (v201 == v202)
  {

    goto LABEL_398;
  }

  v203 = v202;
  if ((v201 == 0LL) == (v202 != 0LL))
  {

    goto LABEL_397;
  }

  v204 = [v201 isEqual:v202];

  if ((v204 & 1) == 0)
  {
LABEL_397:
    -[CBDevice setSerialNumberRight:](self, "setSerialNumberRight:", v201);
    v23 |= 0x80000000000uLL;
  }

LABEL_398:
  v205 = sub_1003DF988((uint64_t)a3);
  if (v205 == 1) {
    v206 = 1LL;
  }
  else {
    v206 = 2 * (v205 == 2);
  }
  if ((_DWORD)v206 != -[CBDevice smartRoutingMode](self, "smartRoutingMode"))
  {
    -[CBDevice setSmartRoutingMode:](self, "setSmartRoutingMode:", v206);
    v23 |= 0x80000000000uLL;
  }

  v207 = sub_1003E01A8((uint64_t)a3);
  if ((_DWORD)v207 && (_DWORD)v207 != -[CBDevice interval](self, "interval"))
  {
    -[CBDevice setInterval:](self, "setInterval:", v207);
    v23 |= 0x80000000000uLL;
  }

  LODWORD(__p[0]) = 0;
  LOBYTE(v245) = 0;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_10087F7A0);
  }
  sub_100401438((uint64_t)off_1008D5F48, (uint64_t)a3, @"global", (int *)__p, &v245);
  v208 = (int)__p[0];
  if (v208 != -[CBDevice spatialAudioMode](self, "spatialAudioMode"))
  {
    -[CBDevice setSpatialAudioMode:](self, "setSpatialAudioMode:", LODWORD(__p[0]));
    v23 |= 0x80000000000uLL;
  }

  if (v239 != -[CBDevice supportedServices](self, "supportedServices"))
  {
    -[CBDevice setSupportedServices:](self, "setSupportedServices:");
    v23 |= 0x80000200000uLL;
  }

  else {
    v209 = v236;
  }
  if (v209 && HIDWORD(v258))
  {
    -[CBDevice setProductID:](self, "setProductID:");
    v23 |= 0x80000000000uLL;
  }

  else {
    v210 = v236;
  }
  if (v210 && (_DWORD)v259)
  {
    -[CBDevice setVendorID:](self, "setVendorID:", (unsigned __int16)v259);
    v23 |= 0x80000000000uLL;
  }

  else {
    v211 = v236;
  }
  if (v211 && HIDWORD(v259))
  {
    -[CBDevice setVendorIDSource:](self, "setVendorIDSource:", BYTE4(v259));
    v23 |= 0x80000000000uLL;
  }

  if (-[CBDevice vendorIDSource](self, "vendorIDSource") == 1
    && -[CBDevice vendorID](self, "vendorID") == 76)
  {
    v212 = 1;
  }

  else
  {
    v212 = -[CBDevice vendorIDSource](self, "vendorIDSource") == 2
        && -[CBDevice vendorID](self, "vendorID") == 1452;
  }

  v213 = -[CBDevice productID](self, "productID");
  if (!(_DWORD)v213) {
    v213 = -[CBDevice proximityPairingProductID](self, "proximityPairingProductID");
  }
  if ((_DWORD)v213) {
    v214 = v212;
  }
  else {
    v214 = 0;
  }
  if (v214)
  {
    v215 = (void *)objc_claimAutoreleasedReturnValue( +[CBProductInfo productInfoWithProductID:]( &OBJC_CLASS___CBProductInfo,  "productInfoWithProductID:",  v213));
    v216 = (void *)objc_claimAutoreleasedReturnValue([v215 productName]);

    if (v216)
    {
      v217 = (id)objc_claimAutoreleasedReturnValue(-[CBDevice productName](self, "productName"));
      v218 = v216;
      v219 = v218;
      if (v217 == v218)
      {
      }

      else
      {
        if (v217)
        {
          v220 = [v217 isEqual:v218];

          if ((v220 & 1) != 0) {
            goto LABEL_453;
          }
        }

        else
        {
        }

        -[CBDevice setProductName:](self, "setProductName:", v219);
        v23 |= 0x80000000000uLL;
      }
    }

LABEL_453:
  }

  v221 = CBDeviceTypeToNSLocalizedString(-[CBDevice deviceType](self, "deviceType"));
  v222 = (void *)objc_claimAutoreleasedReturnValue(v221);
  if (v212)
  {
    v223 = v234;
    v224 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name"));
    if (!v224
      || (v225 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name")),
          v226 = [v225 isEqualToString:v222],
          v225,
          v224,
          (v226 & 1) != 0))
    {
      v227 = sub_1000213C8((uint64_t)v213);
      v228 = (void *)objc_claimAutoreleasedReturnValue(v227);
      if (v228)
      {
        -[CBDevice setName:](self, "setName:", v228);
        v23 |= 0x80000000000uLL;
      }
    }
  }

  else
  {
    v223 = v234;
  }

  v229 = (void *)objc_claimAutoreleasedReturnValue(-[CBDevice name](self, "name"));

  if (!v229)
  {
    -[CBDevice setName:](self, "setName:", v222);
    v23 |= 0x80000000000uLL;
  }

  if (SHIBYTE(v254) < 0) {
    operator delete(v253[0]);
  }

  *(void *)&v251 = &v260;
  sub_100024304((void ***)&v251);

  return v23;
}

void sub_100023CB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, void *a22, void *a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *__p, uint64_t a44, int a45, __int16 a46, char a47, char a48)
{
  a39 = v52 - 120;
  sub_100024304((void ***)&a39);

  _Unwind_Resume(a1);
}

uint64_t sub_100024098(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = sub_100024124(v5, (const void **)(v3 + 32), a2);
    uint64_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      uint64_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }

    uint64_t v3 = *v8;
  }

  while (*v8);
  return v6;
}

BOOL sub_100024124(uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

void *sub_10002418C(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000LL;
    *a1 = v6;
  }

  else
  {
    *((_BYTE *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }

  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void *sub_100024238(_BYTE *__dst, void *__src, unint64_t a3)
{
  size_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000LL;
    void *v5 = v8;
    size_t v5 = v8;
  }

  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

void sub_1000242C0(id a1)
{
  os_log_t v1 = operator new(0x230uLL);
  sub_10042BC28();
  off_1008D60A8 = v1;
}

void sub_1000242F0(_Unwind_Exception *a1)
{
}

void sub_100024304(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100024344((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_100024344(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24LL)
  {
  }

  a1[1] = v2;
}

void sub_100024390(id a1)
{
  os_log_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_1000243C0(_Unwind_Exception *a1)
{
}

void sub_1000243D4(id a1)
{
  os_log_t v1 = operator new(0xF8uLL);
  sub_1003EC784((uint64_t)v1);
  off_1008D60B8 = v1;
}

void sub_100024404(_Unwind_Exception *a1)
{
}

void sub_100024418(id a1)
{
  os_log_t v1 = operator new(0x2C0uLL);
  sub_1004219F0();
  off_1008D60C8 = v1;
}

void sub_100024448(_Unwind_Exception *a1)
{
}

void sub_10002445C(id a1)
{
  os_log_t v1 = operator new(0x2C8uLL);
  sub_100213DA8();
  off_1008D60D8 = v1;
}

void sub_10002448C(_Unwind_Exception *a1)
{
}

void sub_1000244A0(id a1)
{
  os_log_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_1000244D0(_Unwind_Exception *a1)
{
}

void sub_1000244E4(id a1)
{
  os_log_t v1 = operator new(0x4A8uLL);
  sub_100499870();
  off_1008D60E8 = v1;
}

void sub_100024514(_Unwind_Exception *a1)
{
}

void sub_100024528(id a1)
{
  os_log_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_100024558(_Unwind_Exception *a1)
{
}

uint64_t sub_10002508C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = [*(id *)(a1 + 32) calculateMetricforDevice:*(void *)(a1 + 40) onHost:a2];
  id v7 = [*(id *)(a1 + 32) calculateMetricforDevice:*(void *)(a1 + 40) onHost:v5];
  if (v6 == v7)
  {
    uint64_t v8 = [v5 isEqual:@"CBLocalHostID"];
  }

  else if (v6 < v7)
  {
    uint64_t v8 = 1LL;
  }

  else
  {
    uint64_t v8 = -1LL;
  }

  return v8;
}

void sub_10002522C(uint64_t a1)
{
  if (dword_1008D60F8 <= 30 && (dword_1008D60F8 != -1 || _LogCategory_Initialize(&dword_1008D60F8, 30LL))) {
    LogPrintF_safe( &dword_1008D60F8,  "-[CBWHBRouter coexChangeNotification:]_block_invoke",  30LL,  "Coex Notification received");
  }
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) name]);
  unsigned int v3 = [v2 isEqualToString:@"com.apple.bluetooth.leconnection"];

  if (v3)
  {
    size_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userInfo]);
    uint64_t Int64Ranged = CFDictionaryGetInt64Ranged( v4,  @"NUMBER_OF_LE_CONNECTIONS",  0xFFFFFFFF80000000LL,  0x7FFFFFFFLL,  0LL);

    if (dword_1008D60F8 <= 30
      && (dword_1008D60F8 != -1 || _LogCategory_Initialize(&dword_1008D60F8, 30LL)))
    {
      LogPrintF_safe( &dword_1008D60F8,  "-[CBWHBRouter coexChangeNotification:]_block_invoke",  30LL,  "Coex Notification Number of LE Connections:%d",  Int64Ranged);
    }

    uint64_t v8 = @"NUMBER_OF_LE_CONNECTIONS";
    id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", Int64Ranged));
    size_t v9 = v6;
    id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v9,  &v8,  1LL));

    [*(id *)(a1 + 40) updateCoexUpdate:v7 whbHost:@"CBLocalHostID"];
  }

id sub_100025E44(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) removeDeviceFromDeviceTable:a2 value:*(void *)(a1 + 40)];
}

void sub_1000268F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_10002690C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10002691C(uint64_t a1)
{
}

void sub_100026924(uint64_t a1, uint64_t a2, void *a3, _BYTE *a4)
{
  id v10 = a3;
  unsigned int v8 = [*(id *)(a1 + 32) isEqual:a2];
  size_t v9 = v10;
  if (v8)
  {
    if (dword_1008D60F8 <= 30
      && (dword_1008D60F8 != -1 || _LogCategory_Initialize(&dword_1008D60F8, 30LL)))
    {
      LogPrintF_safe( &dword_1008D60F8,  "-[CBWHBRouter getCBDeviceForStableId:onHost:]_block_invoke",  30LL,  "Found CBDevice:%@ for stableIdentifier:%@ on WHBHost: %@",  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
    }

    *a4 = 1;
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), a3);
    size_t v9 = v10;
  }
}

_WORD *sub_100026EC0(_WORD *result)
{
  void *result = 256;
  return result;
}

void sub_100026ECC(_BYTE *a1, uint64_t a2)
{
  uint64_t v2 = (const mach_header_64 *)(a2 & 0xFFFFFFFF00000000LL);
  int v3 = (a2 & 0xFFFFFFFF00000000LL) == (void)&_mh_execute_header;
  if (*a1 != v3)
  {
    *a1 = v3;
    size_t v4 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = "not associated";
      if (v2 == &_mh_execute_header) {
        id v5 = "associated";
      }
      int v12 = 136315138;
      BOOL v13 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency WiFi is %s to 2.4GHz band",  (uint8_t *)&v12,  0xCu);
    }

    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087F920);
    }
    if (*((void *)off_1008D60E8 + 26))
    {
      id v6 = (char *)*((void *)off_1008D60E8 + 24);
      id v7 = (char *)off_1008D60E8 + 200;
      if (v6 != (char *)off_1008D60E8 + 200)
      {
        do
        {
          uint64_t v8 = *((void *)v6 + 5);
          if (*(_WORD *)(v8 + 84))
          {
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087F920);
            }
            sub_1000352CC(*((void *)off_1008D60E8 + 27), 0LL, *(unsigned __int16 *)(v8 + 84));
          }

          size_t v9 = (char *)*((void *)v6 + 1);
          if (v9)
          {
            do
            {
              id v10 = v9;
              size_t v9 = *(char **)v9;
            }

            while (v9);
          }

          else
          {
            do
            {
              id v10 = (char *)*((void *)v6 + 2);
              BOOL v11 = *(void *)v10 == (void)v6;
              id v6 = v10;
            }

            while (!v11);
          }

          id v6 = v10;
        }

        while (v10 != v7);
      }
    }
  }

uint64_t sub_100027090(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming");
  if (a3)
  {
    if ((_DWORD)result)
    {
      uint64_t result = sub_100027194(a1, a3);
      if ((_DWORD)result)
      {
        uint64_t v7 = sub_1002E6BF0();
        if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 328LL))(v7))
        {
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087F920);
          }
          (*(void (**)(void *, uint64_t))(*(void *)off_1008D60E8 + 88LL))(off_1008D60E8, a2);
        }

        uint64_t v8 = sub_1002E6BF0();
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 384LL))(v8);
        if ((_DWORD)result)
        {
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087F920);
          }
          return (*(uint64_t (**)(void *, uint64_t))(*(void *)off_1008D60E8 + 88LL))(off_1008D60E8, a2);
        }
      }
    }
  }

  return result;
}

uint64_t sub_100027194(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 240LL))(v4)
    && *(_BYTE *)(a1 + 1)
    && (sub_1003D2B2C(a2, 49) & 1) != 0)
  {
    return 1LL;
  }

  id v6 = (os_log_s *)qword_1008F7570;
  BOOL v7 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v7)
  {
    uint64_t v8 = sub_1002E6BF0();
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 240LL))(v8);
    int v10 = *(unsigned __int8 *)(a1 + 1);
    v11[0] = 67109632;
    v11[1] = v9;
    __int16 v12 = 1024;
    int v13 = v10;
    __int16 v14 = 1024;
    int v15 = sub_1003D2B2C(a2, 49);
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff not allowed %d %d %d",  (uint8_t *)v11,  0x14u);
    return 0LL;
  }

  return result;
}

void sub_1000272B8(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = sub_1000273C4(a1, a2);
  if (v3)
  {
    uint64_t v4 = sub_1000273C4(v3, a2);
    ++*(_BYTE *)(v4 + 2);
    uint64_t v5 = qword_1008F7570;
    BOOL v6 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
    if (!v6) {
      return;
    }
    int v7 = *(unsigned __int8 *)(sub_1000273C4(v6, a2) + 2);
    v12[0] = 67109120;
    v12[1] = v7;
    uint64_t v8 = "Advanced Sniff increased pending count %d";
    int v9 = (os_log_s *)v5;
    uint32_t v10 = 8;
  }

  else
  {
    uint64_t v11 = qword_1008F7570;
    if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v12[0]) = 0;
    uint64_t v8 = "Advanced Sniff increase pending count for invalid device";
    int v9 = (os_log_s *)v11;
    uint32_t v10 = 2;
  }

  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)v12, v10);
}

uint64_t sub_1000273C4(uint64_t a1, unint64_t a2)
{
  unint64_t v9 = a2;
  if (!a2) {
    return 0LL;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087F920);
  }
  uint64_t v3 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v3) {
    goto LABEL_15;
  }
  uint64_t v4 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= a2;
    if (v5 >= a2) {
      int v7 = v3;
    }
    else {
      int v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (char *)v3;
    }
    uint64_t v3 = (void *)*v7;
  }

  while (*v7);
  if (v4 == (char *)off_1008D60E8 + 200 || *((void *)v4 + 4) > a2) {
LABEL_15:
  }
    uint64_t v4 = (char *)off_1008D60E8 + 200;
  uint32_t v10 = &v9;
  return *(void *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v9, (uint64_t)&unk_1006BA9BC, (uint64_t **)&v10)[5]
                   + 48);
}

void sub_1000274A8(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = sub_1000273C4(a1, a2);
  if (v3)
  {
    uint64_t v4 = sub_1000273C4(v3, a2);
    int v5 = *(unsigned __int8 *)(v4 + 2);
    uint64_t v6 = sub_1000273C4(v4, a2);
    if (v5)
    {
      --*(_BYTE *)(v6 + 2);
      uint64_t v7 = qword_1008F7570;
      BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if (!v8) {
        return;
      }
      int v9 = *(unsigned __int8 *)(sub_1000273C4(v8, a2) + 2);
      v14[0] = 67109120;
      v14[1] = v9;
      uint32_t v10 = "Advanced Sniff decreased pending count %d";
      uint64_t v11 = (os_log_s *)v7;
      uint32_t v12 = 8;
      goto LABEL_10;
    }

    *(_BYTE *)(v6 + 2) = 0;
    uint64_t v13 = qword_1008F7570;
    if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v14[0]) = 0;
    uint32_t v10 = "Advanced Sniff pending count 0";
  }

  else
  {
    uint64_t v13 = qword_1008F7570;
    if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v14[0]) = 0;
    uint32_t v10 = "Advanced Sniff decrease pending count for invalid device";
  }

  uint64_t v11 = (os_log_s *)v13;
  uint32_t v12 = 2;
LABEL_10:
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)v14, v12);
}

void sub_1000275FC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (_os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming"))
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_10087F940);
    }
    uint64_t v7 = sub_10040007C(off_1008D5F48, a3, 1);
    if (!v7) {
      goto LABEL_29;
    }
    unint64_t v8 = (unint64_t)v7;
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087F920);
    }
    int v9 = (void *)*((void *)off_1008D60E8 + 25);
    if (!v9) {
      goto LABEL_18;
    }
    uint32_t v10 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v11 = v9[4];
      BOOL v12 = v11 >= v8;
      if (v11 >= v8) {
        uint64_t v13 = v9;
      }
      else {
        uint64_t v13 = v9 + 1;
      }
      if (v12) {
        uint32_t v10 = (char *)v9;
      }
      int v9 = (void *)*v13;
    }

    while (*v13);
    if (v10 == (char *)off_1008D60E8 + 200 || v8 < *((void *)v10 + 4)) {
LABEL_18:
    }
      uint32_t v10 = (char *)off_1008D60E8 + 200;
    if (v10 == (char *)off_1008D60E8 + 200)
    {
LABEL_29:
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
        sub_100656D8C();
      }
    }

    else
    {
      __int16 v14 = (os_log_s *)qword_1008F7570;
      BOOL v15 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if (v15)
      {
        int v16 = *(unsigned __int8 *)sub_1000273C4(v15, v8);
        *(_DWORD *)buf = 67109376;
        int v23 = v16;
        __int16 v24 = 1024;
        int v25 = a4;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Sniff/Active mode change: %d->%d",  buf,  0xEu);
      }

      id v17 = (_BYTE *)sub_1000273C4(v15, v8);
      *id v17 = a4;
      int v18 = (_BYTE *)sub_1000273C4((uint64_t)v17, v8);
      if (!*v18)
      {
        uint64_t v19 = sub_1000273C4((uint64_t)v18, v8);
        if (*(_BYTE *)(v19 + 1))
        {
          *(_BYTE *)(sub_1000273C4(v19, v8) + 1) = 0;
          uint64_t v20 = sub_1004050C8();
          v21[0] = _NSConcreteStackBlock;
          v21[1] = 3221225472LL;
          v21[2] = sub_100027840;
          v21[3] = &unk_10087F8E0;
          v21[4] = a1;
          v21[5] = v8;
          sub_100405384(v20, v21);
        }
      }
    }
  }

_BYTE *sub_100027840(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v15 = 0;
  sub_100242CA4(&v15);
  uint64_t v3 = (unsigned __int16 *)sub_10012D890(*(void *)(a1 + 40) + 128LL);
  sub_100242CD0(&v15);
  uint64_t v4 = (os_log_s *)qword_1008F7570;
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Enter Advanced Sniff after unsniff", buf, 2u);
    }

    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087F920);
    }
    int v5 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100027A3C;
    block[3] = &unk_10087F8E0;
    uint64_t v6 = *(void *)(a1 + 40);
    block[4] = v2;
    void block[5] = v6;
    dispatch_async(v5, block);
    uint64_t v7 = sub_1002E6E9C();
    BYTE2(v11) = 1;
    LOWORD(v11) = 2;
    if ((*(unsigned int (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, void, void, uint64_t, int))(*(void *)v7 + 1520LL))( v7,  *v3,  24LL,  20LL,  8LL,  1LL,  0LL,  0LL,  0xFFFF00000001LL,  v11))
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087F920);
      }
      unint64_t v8 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472LL;
      _DWORD v12[2] = sub_100027A48;
      v12[3] = &unk_10087F8E0;
      uint64_t v9 = *(void *)(a1 + 40);
      v12[4] = v2;
      v12[5] = v9;
      dispatch_async(v8, v12);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR))
  {
    sub_100656DB8();
  }

  return sub_100242CD8(&v15);
}

void sub_100027A24(_Unwind_Exception *a1)
{
}

void sub_100027A3C(uint64_t a1)
{
}

void sub_100027A48(uint64_t a1)
{
}

id sub_100027A50(uint64_t a1, int a2)
{
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableString stringWithFormat:]( &OBJC_CLASS___NSMutableString,  "stringWithFormat:",  &stru_1008A57D8));
  uint64_t v4 = v3;
  if (a2 > 239)
  {
    if (a2 == 240)
    {
      int v5 = @"ADVANCEDSNIFF";
      goto LABEL_10;
    }

    if (a2 == 241)
    {
      int v5 = @"SEMI-ADVANCEDSNIFF";
      goto LABEL_10;
    }
  }

  else
  {
    if (!a2)
    {
      int v5 = @"ACTIVE";
      goto LABEL_10;
    }

    if (a2 == 2)
    {
      int v5 = @"CLASSICSNIFF";
LABEL_10:
      [v3 appendString:v5];
      return v4;
    }
  }

  [v3 appendString:@"UNKNOWN"];
  uint64_t v7 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unknown Advanced Sniff mode", v8, 2u);
  }

  return v4;
}

void sub_100027B44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100027B54( uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, uint64_t a5, uint64_t a6, int a7, int a8)
{
  unint64_t v11 = ((unint64_t)*a3 << 40) | ((unint64_t)a3[1] << 32) | ((unint64_t)a3[2] << 24) | ((unint64_t)a3[3] << 16) | ((unint64_t)a3[4] << 8) | a3[5];
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_10087F940);
  }
  BOOL v12 = sub_10040007C(off_1008D5F48, v11, 1);
  if (v12)
  {
    unint64_t v13 = (unint64_t)v12;
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087F920);
    }
    __int16 v14 = (void *)*((void *)off_1008D60E8 + 25);
    if (!v14) {
      goto LABEL_17;
    }
    char v15 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v16 = v14[4];
      BOOL v17 = v16 >= v13;
      if (v16 >= v13) {
        int v18 = v14;
      }
      else {
        int v18 = v14 + 1;
      }
      if (v17) {
        char v15 = (char *)v14;
      }
      __int16 v14 = (void *)*v18;
    }

    while (*v18);
    if (v15 == (char *)off_1008D60E8 + 200 || v13 < *((void *)v15 + 4)) {
LABEL_17:
    }
      char v15 = (char *)off_1008D60E8 + 200;
    if (v15 != (char *)off_1008D60E8 + 200)
    {
      char v37 = 0;
      sub_100242CA4(&v37);
      uint64_t v19 = sub_10012D890(v13 + 128);
      uint64_t v20 = sub_100242CD0(&v37);
      if (!v19)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
          sub_100656DE4();
        }
        goto LABEL_60;
      }

      id v21 = (unsigned __int8 *)sub_1000273C4(v20, v13);
      if (a7 && *v21 == a4)
      {
        char v22 = (os_log_s *)qword_1008F7570;
        if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
          sub_100656E10(a7, a4, v22);
        }
LABEL_60:
        sub_100242CD8(&v37);
        return;
      }

      uint64_t v24 = sub_1000273C4((uint64_t)v21, v13);
      if (!*(_BYTE *)(v24 + 2))
      {
        __int128 v35 = (os_log_s *)qword_1008F7570;
        if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff mode change ignored, not for media",  buf,  2u);
        }

        goto LABEL_60;
      }

      sub_1000274A8(v24, v13);
      if (a7) {
        BOOL v25 = 0;
      }
      else {
        BOOL v25 = a4 == 240;
      }
      if (v25) {
        unsigned __int8 v26 = -15;
      }
      else {
        unsigned __int8 v26 = a4;
      }
      BOOL v27 = (os_log_s *)qword_1008F7570;
      BOOL v28 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if (v28)
      {
        uint64_t v29 = (unsigned __int8 *)sub_1000273C4(v28, v13);
        id v30 = sub_100027A50((uint64_t)v29, *v29);
        __int128 v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
        id v32 = sub_100027A50((uint64_t)v31, v26);
        __int128 v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
        *(_DWORD *)buf = 138413058;
        v39 = v31;
        __int16 v40 = 2112;
        v41 = v33;
        __int16 v42 = 1024;
        int v43 = a7;
        __int16 v44 = 1024;
        int v45 = a8;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game Advanced Sniff changed %@->%@, max_age:%d, maxRetry:%d",  buf,  0x22u);
      }

      if (a7 || v26 != 241)
      {
        if (!a7 || v26 != 240)
        {
          if (!v26)
          {
            *(_BYTE *)sub_1000273C4(v28, v13) = 0;
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087F920);
            }
            sub_1004A52FC((uint64_t)off_1008D60E8, 0, v13);
          }

          int v36 = 1;
          goto LABEL_55;
        }

        *(_BYTE *)sub_1000273C4(v28, v13) = -16;
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087F920);
        }
        unsigned int v34 = 4;
      }

      else
      {
        *(_BYTE *)sub_1000273C4(v28, v13) = -15;
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087F920);
        }
        unsigned int v34 = 3;
      }

      sub_1004A52FC((uint64_t)off_1008D60E8, v34, v13);
      int v36 = 2;
LABEL_55:
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087F920);
      }
      sub_1004B4480((uint64_t)off_1008D60E8, v13, v36);
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087F920);
      }
      sub_1004B42AC((uint64_t)off_1008D60E8, v13, v26);
      goto LABEL_60;
    }
  }

  int v23 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff mode change ignored: couldn't find the device",  buf,  2u);
  }

void sub_100028014( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100242CD8(&a13);
  _Unwind_Resume(a1);
}

void sub_100028040( uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, uint64_t a5, uint64_t a6, int a7, int a8)
{
  uint64_t v12 = _os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming");
  if ((_DWORD)v12) {
    sub_100027B54(v12, 0LL, a3, a4, v13, v14, a7, a8);
  }
}

void sub_1000280AC(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = "True";
    if (*(_BYTE *)(a1 + 1)) {
      uint64_t v6 = "True";
    }
    else {
      uint64_t v6 = "false";
    }
    if (!a2) {
      int v5 = "false";
    }
    int v7 = 136315394;
    unint64_t v8 = v6;
    __int16 v9 = 2080;
    uint32_t v10 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff State changed %s->%s",  (uint8_t *)&v7,  0x16u);
  }

  *(_BYTE *)(a1 + 1) = a2;
}

void sub_10002818C(uint64_t a1, unint64_t a2)
{
  char v4 = _os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming");
  if (!a2 || (v4 & 1) == 0)
  {
    uint64_t v13 = (os_log_s *)qword_1008F7570;
    if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v14 = "Exit Advanced Sniff but feature flag off";
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, buf, 2u);
    return;
  }

  uint64_t v5 = sub_100027194(a1, a2);
  if ((v5 & 1) == 0)
  {
    uint64_t v13 = (os_log_s *)qword_1008F7570;
    if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v14 = "Exit Advanced Sniff but not allowed";
    goto LABEL_26;
  }

  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087F920);
  }
  uint64_t v6 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v6) {
    goto LABEL_17;
  }
  int v7 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint32_t v10 = v6;
    }
    else {
      uint32_t v10 = v6 + 1;
    }
    if (v9) {
      int v7 = (char *)v6;
    }
    uint64_t v6 = (void *)*v10;
  }

  while (*v10);
  if (v7 == (char *)off_1008D60E8 + 200 || *((void *)v7 + 4) > a2) {
LABEL_17:
  }
    int v7 = (char *)off_1008D60E8 + 200;
  if (v7 == (char *)off_1008D60E8 + 200)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
      sub_100656E98();
    }
  }

  else
  {
    unint64_t v11 = (unsigned __int8 *)sub_1000273C4(v5, a2);
    if (*v11 == 240 || *(unsigned __int8 *)sub_1000273C4((uint64_t)v11, a2) == 241)
    {
      uint64_t v12 = sub_1004050C8();
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      v16[2] = sub_100028394;
      v16[3] = &unk_10087F8E0;
      v16[4] = a1;
      v16[5] = a2;
      sub_100405384(v12, v16);
    }

    else
    {
      char v15 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
        sub_100656EC4(a2, v15);
      }
    }
  }

_BYTE *sub_100028394(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Exit Advanced Sniff...", buf, 2u);
  }

  buf[0] = 0;
  sub_100242CA4(buf);
  char v4 = (unsigned __int16 *)sub_10012D890(*(void *)(a1 + 40) + 128LL);
  sub_100242CD0(buf);
  if (v4)
  {
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087F920);
    }
    uint64_t v5 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10002858C;
    block[3] = &unk_10087F8E0;
    uint64_t v6 = *(void *)(a1 + 40);
    block[4] = v2;
    void block[5] = v6;
    dispatch_async(v5, block);
    uint64_t v7 = sub_1002E6E9C();
    if ((*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v7 + 1528LL))(v7, *v4, 1LL))
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087F920);
      }
      unint64_t v8 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      _DWORD v11[2] = sub_100028598;
      v11[3] = &unk_10087F8E0;
      uint64_t v9 = *(void *)(a1 + 40);
      v11[4] = v2;
      v11[5] = v9;
      dispatch_async(v8, v11);
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
        sub_100656F68();
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR))
  {
    sub_100656F3C();
  }

  return sub_100242CD8(buf);
}

void sub_100028574( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_10002858C(uint64_t a1)
{
}

void sub_100028598(uint64_t a1)
{
}

void sub_1000285A0(uint64_t a1, unint64_t a2, int a3)
{
  if (!a2) {
    goto LABEL_34;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087F920);
  }
  uint64_t v6 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v6) {
    goto LABEL_15;
  }
  uint64_t v7 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint32_t v10 = v6;
    }
    else {
      uint32_t v10 = v6 + 1;
    }
    if (v9) {
      uint64_t v7 = (char *)v6;
    }
    uint64_t v6 = (void *)*v10;
  }

  while (*v10);
  if (v7 == (char *)off_1008D60E8 + 200 || *((void *)v7 + 4) > a2) {
LABEL_15:
  }
    uint64_t v7 = (char *)off_1008D60E8 + 200;
  if (v7 == (char *)off_1008D60E8 + 200)
  {
LABEL_34:
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
      sub_100656FCC();
    }
  }

  else
  {
    unint64_t v11 = (unsigned __int8 *)sub_1000273C4(a1, a2);
    int v12 = *v11;
    uint64_t v13 = (_BYTE *)sub_1000273C4((uint64_t)v11, a2);
    if (v12 == 2)
    {
      v13[1] = 1;
      uint64_t v14 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Enter Advanced Sniff on sniff link",  buf,  2u);
      }

      uint64_t v15 = sub_1004050C8();
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 3221225472LL;
      v22[2] = sub_1000287C0;
      v22[3] = &unk_10087EB20;
      v22[4] = a2;
      unint64_t v16 = v22;
      goto LABEL_28;
    }

    if (*v13 != 2)
    {
      uint64_t v15 = sub_1004050C8();
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472LL;
      v20[2] = sub_100028864;
      v20[3] = &unk_10087F900;
      int v21 = a3;
      v20[4] = a1;
      v20[5] = a2;
      unint64_t v16 = v20;
LABEL_28:
      sub_100405384(v15, v16);
      return;
    }

    int v17 = *(unsigned __int8 *)sub_1000273C4((uint64_t)v13, a2);
    int v18 = (os_log_s *)qword_1008F7570;
    BOOL v19 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR);
    if (v17 == 240)
    {
      if (v19) {
        sub_100656FF8();
      }
    }

    else if (v19)
    {
      sub_100657024(a2, v18);
    }
  }

_BYTE *sub_1000287C0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Unsniffing for Advanced Sniff", buf, 2u);
  }

  char v4 = 0;
  sub_100242CA4(&v4);
  sub_100113CA0(*(void *)(a1 + 32) + 128LL);
  sub_100242CD0(&v4);
  return sub_100242CD8(&v4);
}

void sub_100028850( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

_BYTE *sub_100028864(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)buf = 67109120;
    int v24 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Enter Advanced Sniff, send command for config: %d",  buf,  8u);
  }

  buf[0] = 0;
  sub_100242CA4(buf);
  uint64_t v5 = (unsigned __int16 *)sub_10012D890(*(void *)(a1 + 40) + 128LL);
  sub_100242CD0(buf);
  if (v5)
  {
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087F920);
    }
    uint64_t v6 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100028C14;
    block[3] = &unk_10087F8E0;
    uint64_t v7 = *(void *)(a1 + 40);
    block[4] = v2;
    void block[5] = v7;
    dispatch_async(v6, block);
    int v8 = *(_DWORD *)(a1 + 48);
    switch(v8)
    {
      case 3:
        uint64_t v15 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t, void, void, uint64_t, void, void, void, uint64_t))(*(void *)v15 + 1536LL))( v15,  *v5,  0LL,  0xFFFFLL,  0LL,  0LL,  0LL,  1LL))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
            sub_1006570C8();
          }
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087F920);
          }
          uint32_t v10 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472LL;
          v20[2] = sub_100028C2C;
          v20[3] = &unk_10087F8E0;
          uint64_t v16 = *(void *)(a1 + 40);
          v20[4] = v2;
          v20[5] = v16;
          int v12 = v20;
          goto LABEL_27;
        }

        break;
      case 2:
        uint64_t v13 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t, void, void, uint64_t, void, uint64_t, void, uint64_t))(*(void *)v13 + 1536LL))( v13,  *v5,  0LL,  0xFFFFLL,  0LL,  20LL,  0LL,  1LL))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
            sub_10065712C();
          }
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087F920);
          }
          uint32_t v10 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
          v19[0] = _NSConcreteStackBlock;
          v19[1] = 3221225472LL;
          v19[2] = sub_100028CD8;
          v19[3] = &unk_10087F8E0;
          uint64_t v14 = *(void *)(a1 + 40);
          v19[4] = v2;
          v19[5] = v14;
          int v12 = v19;
          goto LABEL_27;
        }

        break;
      case 1:
        uint64_t v9 = sub_1002E6E9C();
        BYTE2(v1_Block_object_dispose(va, 8) = 1;
        LOWORD(v1_Block_object_dispose(va, 8) = 2;
        if ((*(unsigned int (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, void, void, uint64_t, int))(*(void *)v9 + 1520LL))( v9,  *v5,  24LL,  0LL,  8LL,  1LL,  0LL,  0LL,  0xFFFF00000001LL,  v18))
        {
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087F920);
          }
          uint32_t v10 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
          v21[0] = _NSConcreteStackBlock;
          v21[1] = 3221225472LL;
          v21[2] = sub_100028C20;
          v21[3] = &unk_10087F8E0;
          uint64_t v11 = *(void *)(a1 + 40);
          v21[4] = v2;
          v21[5] = v11;
          int v12 = v21;
LABEL_27:
          dispatch_async(v10, v12);
        }

        break;
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR))
  {
    sub_10065709C();
  }

  return sub_100242CD8(buf);
}

void sub_100028BF4(_Unwind_Exception *a1)
{
}

void sub_100028C14(uint64_t a1)
{
}

void sub_100028C20(uint64_t a1)
{
}

uint64_t sub_100028C2C(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7570;
  BOOL v3 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Reconfig failed, back to FTO",  v5,  2u);
  }

  sub_1000274A8(v3, *(void *)(a1 + 40));
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087F920);
  }
  return sub_1004A52FC(off_1008D60E8, 3LL, *(void *)(a1 + 40));
}

uint64_t sub_100028CD8(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008F7570;
  BOOL v3 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Reconfig failed, back to FTO",  v5,  2u);
  }

  sub_1000274A8(v3, *(void *)(a1 + 40));
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087F920);
  }
  return sub_1004A52FC(off_1008D60E8, 3LL, *(void *)(a1 + 40));
}

uint64_t sub_100028D84(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1);
}

void sub_100028D8C(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = sub_1000273C4(a1, a2);
    int v4 = (os_log_s *)qword_1008F7570;
    if (v3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(unsigned __int8 *)(a2 + 1373);
        v8[0] = 67109120;
        v8[1] = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff band switched %d",  (uint8_t *)v8,  8u);
      }

      if (*(_BYTE *)(a2 + 1373))
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087F920);
        }
        uint64_t v6 = off_1008D60E8;
        unsigned int v7 = 6;
      }

      else
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087F920);
        }
        uint64_t v6 = off_1008D60E8;
        unsigned int v7 = 5;
      }

      sub_1004A52FC((uint64_t)v6, v7, a2);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR))
    {
      sub_1006571BC();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR))
  {
    sub_100657190();
  }

void sub_100028EF0(uint64_t a1, int a2, uint64_t a3)
{
  if (sub_1003DD998(a3))
  {
    if (a2 == 2)
    {
      if (qword_1008D6170 != -1) {
        dispatch_once(&qword_1008D6170, &stru_10087F960);
      }
      char v5 = 1;
      goto LABEL_11;
    }

    if (a2 == 1)
    {
      if (qword_1008D6170 != -1) {
        dispatch_once(&qword_1008D6170, &stru_10087F960);
      }
      char v5 = 0;
LABEL_11:
      sub_100258A9C(qword_1008D6168, v5, a3);
    }
  }

void sub_100028FA4(uint64_t a1, int a2, unint64_t a3)
{
  switch(a2)
  {
    case 0:
      sub_10002818C(a1, a3);
      return;
    case 1:
      unint64_t v3 = a3;
      int v4 = 1;
      goto LABEL_4;
    case 2:
      unint64_t v3 = a3;
      int v4 = 2;
      goto LABEL_4;
    case 3:
      unint64_t v3 = a3;
      int v4 = 3;
LABEL_4:
      sub_1000285A0(a1, v3, v4);
      break;
    default:
      return;
  }

void sub_100028FF8(uint64_t a1, int a2, unint64_t a3)
{
  char v5 = (os_log_s *)qword_1008F7570;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    unsigned int v7 = "stopped";
    if (a2) {
      unsigned int v7 = "started";
    }
    int v12 = 136315138;
    uint64_t v13 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Bi StreamState %s",  (uint8_t *)&v12,  0xCu);
  }

  if (a3 && (uint64_t v8 = sub_1000273C4(v6, a3)) != 0)
  {
    uint64_t v9 = sub_1000273C4(v8, a3);
    *(_BYTE *)(v9 + 3) = a2;
    if (a2) {
      int v10 = 2;
    }
    else {
      int v10 = 1;
    }
    sub_100028EF0(v9, v10, a3);
  }

  else
  {
    uint64_t v11 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Bi StreamState update skipped, device gone",  (uint8_t *)&v12,  2u);
    }
  }

uint64_t sub_10002912C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = sub_1000273C4(a1, a2);
  *(_WORD *)(v3 + 4) = 0;
  uint64_t result = sub_1000273C4(v3, a2);
  *(_WORD *)(result + 6) = 0;
  return result;
}

void sub_10002915C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 && *(_BYTE *)(sub_1000273C4(a1, a2) + 3))
  {
    uint64_t v5 = sub_1002E6E00();
    int v29 = 0;
    uint64_t v6 = sub_1002E6E00();
    sub_10002418C(buf, "BiAoS");
    sub_10002418C(__p, "bypassHAoSMonitor");
    (*(void (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v6 + 88LL))(v6, buf, __p, &v29);
    if (v28 < 0) {
      operator delete(__p[0]);
    }
    if (v31 < 0) {
      operator delete(*(void **)buf);
    }
    if (!v29)
    {
LABEL_9:
      unsigned int v7 = (os_log_s *)qword_1008F7570;
      BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if (v8)
      {
        if (*(_BYTE *)(a2 + 1373)) {
          uint64_t v9 = "UBO";
        }
        else {
          uint64_t v9 = "ISM";
        }
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Bi monitor band: %s",  buf,  0xCu);
      }

      BOOL v10 = *(_BYTE *)(a2 + 1373) == 0;
      int v11 = *(char *)(a3 + 6);
      uint64_t v12 = sub_1000273C4(v8, a2);
      if (v10)
      {
        if (v11 < -74)
        {
          *(_WORD *)(v12 + 6) = 0;
        }

        else
        {
          ++*(_WORD *)(v12 + 6);
          uint64_t v20 = (os_log_s *)qword_1008F7570;
          BOOL v21 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
          if (v21)
          {
            int v22 = *(char *)(a3 + 6);
            int v23 = *(__int16 *)(sub_1000273C4(v21, a2) + 6);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v22;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = v23;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Bi ISM RSSI %d over threshold %d times",  buf,  0xEu);
          }

          if (*(__int16 *)(sub_1000273C4(v21, a2) + 6) >= 20)
          {
            int v24 = (os_log_s *)qword_1008F7570;
            BOOL v25 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
            if (v25)
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Bi request UBO band",  buf,  2u);
            }

            uint64_t v26 = sub_1000273C4(v25, a2);
            *(_WORD *)(v26 + 6) = 0;
            sub_100028EF0(v26, 2, a2);
          }
        }
      }

      else if (v11 > -80)
      {
        *(_WORD *)(v12 + 4) = 0;
      }

      else
      {
        ++*(_WORD *)(v12 + 4);
        uint64_t v13 = (os_log_s *)qword_1008F7570;
        BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
        if (v14)
        {
          int v15 = *(char *)(a3 + 6);
          int v16 = *(__int16 *)(sub_1000273C4(v14, a2) + 4);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v15;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Bi UBO RSSI %d under threshold %d times",  buf,  0xEu);
        }

        if (*(__int16 *)(sub_1000273C4(v14, a2) + 4) >= 2)
        {
          int v17 = (os_log_s *)qword_1008F7570;
          BOOL v18 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
          if (v18)
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Advanced Sniff Bi request ISM band",  buf,  2u);
          }

          uint64_t v19 = sub_1000273C4(v18, a2);
          *(_WORD *)(v19 + 4) = 0;
          sub_100028EF0(v19, 1, a2);
        }
      }
    }
  }

void sub_1000294B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000294EC(id a1)
{
  uint64_t v1 = operator new(0x4A8uLL);
  sub_100499870();
  off_1008D60E8 = v1;
}

void sub_10002951C(_Unwind_Exception *a1)
{
}

void sub_100029530(id a1)
{
  uint64_t v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100029560(_Unwind_Exception *a1)
{
}

uint64_t *sub_100029574(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unsigned int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        unsigned int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        unsigned int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0LL;
    sub_100029630(a1, (uint64_t)v9, v7, v11);
    return v11;
  }

  return (uint64_t *)v9;
}

uint64_t *sub_100029630(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }

  uint64_t result = sub_100029684(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_100029684(uint64_t *result, uint64_t *a2)
{
  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      int v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }

          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            unint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }

            v9[2] = v3;
            *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }

          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }

      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }

          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }

        else
        {
          a2 = (uint64_t *)a2[2];
        }

        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }

      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      _BYTE *v5 = 1;
    }

    while (v3 != result);
  }

  return result;
}

void sub_10002981C(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100256C70();
  qword_1008D6168 = (uint64_t)v1;
}

void sub_10002984C(_Unwind_Exception *a1)
{
}

void sub_100029860( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void sub_100029878(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

  ;
}

uint64_t sub_10002989C(unint64_t a1)
{
  return sub_1000273C4(a1, a1);
}

  ;
}

CFPropertyListRef sub_1000298B4()
{
  return (id)CFPreferencesCopyAppValue( @"SelfGeneratedLocalAddress",  @"com.apple.BTServer");
}

void sub_1000298D8(void *a1)
{
  id v1 = a1;
  CFPreferencesSetAppValue(@"SelfGeneratedLocalAddress", v1, @"com.apple.BTServer");
  CFPreferencesAppSynchronize(@"com.apple.BTServer");
}

void sub_100029928( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_10002993C()
{
  v0 = objc_autoreleasePoolPush();
  id v1 = (void *)CFPreferencesCopyAppValue(@"Daemon", @"com.apple.MobileBluetooth.debug");
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 objectForKey:@"DisableReadAddressFromIOREGForDebugging"]);
    uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
    {
      id v5 = v3;
      if (([v5 isEqualToString:@"TRUE"] & 1) != 0
        || ([v5 isEqualToString:@"YES"] & 1) != 0)
      {
        uint64_t v6 = 1LL;
      }

      else
      {
        uint64_t v6 = 0LL;
      }
    }

    else
    {
      uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSNumber);
      if ((objc_opt_isKindOfClass(v3, v7) & 1) != 0) {
        uint64_t v6 = (uint64_t)[v3 BOOLValue];
      }
      else {
        uint64_t v6 = 0LL;
      }
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  objc_autoreleasePoolPop(v0);
  return v6;
}

void sub_100029A84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t start()
{
  context = objc_autoreleasePoolPush();
  uint64_t v0 = getpid();
  proc_disable_wakemon(v0);
  pthread_set_qos_class_self_np(QOS_CLASS_USER_INITIATED, 0);
  id v1 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "com.apple.server.bluetooth";
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "%s: Bluetooth Super Server Robot Destroyer\n",  buf,  0xCu);
  }

  fprintf(__stderrp, "%s: Bluetooth Super Server Robot Destroyer\n", "com.apple.server.bluetooth");
  if ((_set_user_dir_suffix("com.apple.bluetoothd") & 1) == 0)
  {
    uint64_t v2 = (os_log_s *)(id)qword_1008F7578;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = __error();
      sub_100657364(v3, (uint64_t)v63, v2);
    }

    uint64_t v4 = __stderrp;
    id v5 = __error();
    fprintf(v4, "### _set_user_dir_suffix failed: %d", *v5);
  }

  bzero(v62, 0x400uLL);
  if (!confstr(65537, v62, 0x400uLL))
  {
    uint64_t v6 = (os_log_s *)(id)qword_1008F7578;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = __error();
      sub_100657328(v7, (uint64_t)v61, v6);
    }

    int v8 = __stderrp;
    uint64_t v9 = __error();
    fprintf(v8, "### _CS_DARWIN_USER_TEMP_DIR failed: %d", *v9);
  }

  qword_1008D9E60 = (uint64_t)SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.BTServer", 0LL, 0LL);
  SCDynamicStoreSetDispatchQueue((SCDynamicStoreRef)qword_1008D9E60, &_dispatch_main_q);
  SCDynamicStoreSetDisconnectCallBack(qword_1008D9E60, sub_10002ABA8);
  SCDynamicStoreRemoveValue((SCDynamicStoreRef)qword_1008D9E60, @"com.apple.MobileBluetooth");
  word_1008D9E4C = 0;
  dword_1008D9E48 = 0;
  unint64_t v10 = getenv("BT_DEVICE_ADDRESS");
  if (v10 && (uint64_t v11 = v10, strlen(v10) == 17))
  {
    sscanf( v11,  "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",  &dword_1008D9E48,  (char *)&dword_1008D9E48 + 1,  (char *)&dword_1008D9E48 + 2,  (char *)&dword_1008D9E48 + 3,  &word_1008D9E4C,  (char *)&word_1008D9E4C + 1);
    dword_1008D9E48 = 0;
    word_1008D9E4C = 0;
    uint64_t v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Local address from ENV:%s\n", buf, 0xCu);
    }

    fprintf(__stderrp, "Local address from ENV:%s\n");
  }

  else
  {
    uint64_t v13 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "could not find BT_DEVICE_ADDRESS env variable\n",  buf,  2u);
    }

    fwrite("could not find BT_DEVICE_ADDRESS env variable\n", 0x2EuLL, 1uLL, __stderrp);
    if (sub_10002AF24("marconi-bt") || sub_10002AF24("bluetooth"))
    {
      BOOL v14 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress Deleting local address from plist\n",  buf,  2u);
      }

      fwrite("FindLocalMacAddress Deleting local address from plist\n", 0x36uLL, 1uLL, __stderrp);
      CFPreferencesSetAppValue(@"SelfGeneratedLocalAddress", 0LL, @"com.apple.BTServer");
      CFPreferencesAppSynchronize(@"com.apple.BTServer");
    }

    else
    {
      bzero(buf, 0x400uLL);
      size_t v60 = 1024LL;
      int v15 = sysctlbyname("kern.bootargs", buf, &v60, 0LL, 0LL);
      if (v15)
      {
        int v16 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(handler) = 67109120;
          DWORD1(handler) = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress did not find bootargs, sysctlbyname returned %d",  (uint8_t *)&handler,  8u);
        }

        fprintf(__stderrp, "FindLocalMacAddress did not find bootargs, sysctlbyname returned %d");
      }

      else
      {
        v39 = strtok(buf, " ");
        if (v39)
        {
          __int16 v40 = v39;
          while (!strstr(v40, "wlan.debug.generate-mac"))
          {
            if (strstr(v40, "wlan.factory"))
            {
              v41 = strchr(v40, 61);
              __int16 v42 = (os_log_s *)qword_1008F7578;
              if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(handler) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress found wlan.factory\n",  (uint8_t *)&handler,  2u);
              }

              fwrite("FindLocalMacAddress found wlan.factory\n", 0x27uLL, 1uLL, __stderrp);
              uint64_t v43 = strtol(v41 + 1, 0LL, 16);
              if ((v43 & 4) != 0)
              {
                v47 = (os_log_s *)qword_1008F7578;
                if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(handler) = 134217984;
                  *(void *)((char *)&handler + 4) = v43;
                  _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress found wlan.factory with a value of %llu\n",  (uint8_t *)&handler,  0xCu);
                }

                fprintf(__stderrp, "FindLocalMacAddress found wlan.factory with a value of %llu\n", v43);
                goto LABEL_82;
              }
            }

            __int16 v40 = strtok(0LL, " ");
            if (!v40) {
              goto LABEL_67;
            }
          }

          v46 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(handler) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress found wlan.debug.generate-mac\n",  (uint8_t *)&handler,  2u);
          }

          fwrite("FindLocalMacAddress found wlan.debug.generate-mac\n", 0x32uLL, 1uLL, __stderrp);
LABEL_82:
          CFPropertyListRef v48 = sub_1000298B4();
          v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
          char v50 = v49;
          if (v49 && [v49 length])
          {
            id v51 = v50;
            sscanf( (const char *)[v51 UTF8String],  "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",  &dword_1008D9E48,  (char *)&dword_1008D9E48 + 1,  (char *)&dword_1008D9E48 + 2,  (char *)&dword_1008D9E48 + 3,  &word_1008D9E4C,  (char *)&word_1008D9E4C + 1);
            uint64_t v52 = (os_log_s *)(id)qword_1008F7578;
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              id v53 = [v51 UTF8String];
              LODWORD(handler) = 136315138;
              *(void *)((char *)&handler + 4) = v53;
              _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress Local address from plist:%s.\n",  (uint8_t *)&handler,  0xCu);
            }

            v54 = __stderrp;
            id v55 = v51;
            fprintf( v54,  "FindLocalMacAddress Local address from plist:%s.\n",  (const char *)[v55 UTF8String]);
            setenv("BT_DEVICE_ADDRESS", (const char *)[v55 UTF8String], 1);
          }

          else
          {
            for (uint64_t i = 0LL; i != 6; ++i)
              *((_BYTE *)&dword_1008D9E48 + i) = arc4random_uniform(0xFFu);
            __int128 handler = 0uLL;
            LOWORD(v70) = 0;
            snprintf( (char *)&handler,  0x12uLL,  "%02x:%02x:%02x:%02x:%02x:%02x",  dword_1008D9E48,  BYTE1(dword_1008D9E48),  BYTE2(dword_1008D9E48),  HIBYTE(dword_1008D9E48),  word_1008D9E4C,  HIBYTE(word_1008D9E4C));
            v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", &handler));
            sub_1000298D8(v57);

            v58 = (os_log_s *)qword_1008F7578;
            if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v64 = 136315138;
              p___int128 handler = &handler;
              _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress Storing local address to plist:%s.\n",  v64,  0xCu);
            }

            fprintf(__stderrp, "FindLocalMacAddress Storing local address to plist:%s.\n", (const char *)&handler);
            setenv("BT_DEVICE_ADDRESS", (const char *)&handler, 1);
          }
        }

        else
        {
LABEL_67:
          __int16 v44 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(handler) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "FindLocalMacAddress did not find bootargs for random address generation",  (uint8_t *)&handler,  2u);
          }

          fwrite("FindLocalMacAddress did not find bootargs for random address generation", 0x47uLL, 1uLL, __stderrp);
          CFPreferencesSetAppValue(@"SelfGeneratedLocalAddress", 0LL, @"com.apple.BTServer");
          CFPreferencesAppSynchronize(@"com.apple.BTServer");
        }
      }
    }
  }

  uint64_t v17 = sub_1002E8D54();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v17 + 264LL))(v17))
  {
    WORD2(handler) = 0;
    LODWORD(handler) = 0;
    if (dword_1008D9E48 | (unsigned __int16)word_1008D9E4C)
    {
      if (access("/dev/cu.bluetooth", 0) != -1 || access("/dev/uart.bluetooth", 0) != -1) {
        goto LABEL_38;
      }
      uint64_t v19 = IOServiceNameMatching("marconi-bt");
      if (v19 && (io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v19)) != 0
        || (BOOL v21 = IOServiceNameMatching("bluetooth")) != 0LL
        && (io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v21)) != 0)
      {
        IOObjectRelease(MatchingService);
        goto LABEL_38;
      }

      sub_100657200(buf);
    }

    else
    {
      sub_100657294(buf);
    }

    fprintf(__stderrp, *(const char **)buf, "com.apple.server.bluetooth");
    errx(0, "No bluetooth on this device.\n");
  }

  BOOL v18 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Bluetooth is running inside a Virtual Machine, so skipping check for Bluetooth available",  buf,  2u);
  }

LABEL_38:
  for (uint64_t j = 0LL; j != 3; ++j)
  {
    int v23 = dword_1006BA9C8[j];
    signal(v23, (void (__cdecl *)(int))1);
    dispatch_source_t v24 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, v23, 0LL, &_dispatch_main_q);
    BOOL v25 = (dispatch_object_t *)((char *)&unk_1008D9E68 + 8 * j);
    dispatch_object_t v26 = *v25;
    *BOOL v25 = v24;

    BOOL v27 = (dispatch_source_s *)*v25;
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_10002B230;
    v67 = &unk_10087F980;
    int v68 = v23;
    dispatch_source_set_event_handler(v27, buf);
    dispatch_resume(*v25);
  }

  uint64_t v28 = sub_1002E6E00();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v28 + 8LL))(v28) & 1) != 0)
  {
    uint64_t v29 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 408LL))(v29))
    {
      qword_1008D9E80 = (uint64_t)signal(6, (void (__cdecl *)(int))1);
      unsigned __int8 v30 = atomic_load((unsigned __int8 *)&qword_1008D9E90);
      if ((v30 & 1) == 0 && __cxa_guard_acquire(&qword_1008D9E90))
      {
        qword_1008D9E88 = (uint64_t)dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_signal,  6uLL,  0LL,  &_dispatch_main_q);
        __cxa_guard_release(&qword_1008D9E90);
      }

      *(void *)&__int128 handler = _NSConcreteStackBlock;
      *((void *)&handler + 1) = 3221225472LL;
      v70 = sub_10002B3D8;
      v71 = &unk_10087F980;
      int v72 = 6;
      dispatch_source_set_event_handler((dispatch_source_t)qword_1008D9E88, &handler);
      dispatch_resume((dispatch_object_t)qword_1008D9E88);
    }
  }

  os_state_add_handler(&_dispatch_main_q, &stru_10087F9C0);
  LODWORD(handler) = dword_1008D9E48;
  WORD2(handler) = word_1008D9E4C;
  uint64_t v31 = sub_1002E6B38();
  (*(void (**)(uint64_t, __int128 *))(*(void *)v31 + 40LL))(v31, &handler);
  int v32 = sub_100494178("com.apple.bluetoothd", (unint64_t *)&qword_1008D9E50);
  if (v32)
  {
    __int128 v33 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "com.apple.server.bluetooth";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&_BYTE buf[14] = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "%s: Unable to attach local bluetooth session: %d\n",  buf,  0x12u);
    }

    fprintf(__stderrp, "%s: Unable to attach local bluetooth session: %d\n");
LABEL_58:
    objc_autoreleasePoolPop(context);
    return 1LL;
  }

  int v34 = sub_1003C657C(qword_1008D9E50, (unint64_t *)&qword_1008D9E58);
  if (v34)
  {
    __int128 v35 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "com.apple.server.bluetooth";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&_BYTE buf[14] = v34;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "%s: Unable to get local device: %d\n",  buf,  0x12u);
    }

    fprintf(__stderrp, "%s: Unable to get local device: %d\n");
    goto LABEL_58;
  }

  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_10087FA00);
  }
  sub_1004983C0(qword_1008D61A0, qword_1008D9E58);
  int v36 = sub_1003C66A4(qword_1008D9E58, (__int128 *)off_1008D6178, 0LL);
  if (v36)
  {
    char v37 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "com.apple.server.bluetooth";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&_BYTE buf[14] = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "%s: Unable to attach local device callbacks: %d\n",  buf,  0x12u);
    }

    fprintf(__stderrp, "%s: Unable to attach local device callbacks: %d\n");
    goto LABEL_58;
  }

  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_10087F9E0);
  }
  int v45 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "com.apple.server.bluetooth";
    _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "%s: Server attached, going into msg loop.\n",  buf,  0xCu);
  }

  fprintf(__stderrp, "%s: Server attached, going into msg loop.\n", "com.apple.server.bluetooth");
  objc_autoreleasePoolPop(context);
  CFRunLoopRun();
  sub_10049422C((unint64_t *)&qword_1008D9E50);
  return 0LL;
}

                    Reply = CUXPCDictionaryCreateReply(v4);
                    dispatch_source_t v24 = (void *)objc_claimAutoreleasedReturnValue(Reply);
                    BOOL v25 = v24;
                    if (v24)
                    {
                      if (v19) {
                        dispatch_object_t v26 = v19;
                      }
                      else {
                        dispatch_object_t v26 = @"None\n";
                      }
                      BOOL v27 = v24;
                      uint64_t v28 = (const char *)-[__CFString UTF8String](v26, "UTF8String");
                      if (v28) {
                        xpc_dictionary_set_string(v27, "oStr", v28);
                      }

                      -[CBDaemonXPCConnection _xpcSendReply:](self, "_xpcSendReply:", v27);
                    }

                    else if (dword_1008D6630 <= 90 {
                           && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
                    }
                    {
                      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticControl:]",  90LL,  "### DiagnosticControl create reply failed");
                    }

                    goto LABEL_46;
                  }

                  if (dword_1008D6630 <= 30
                    && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
                  {
                    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticControl:]",  30LL,  "Diags: WHBEvent");
                  }

                  v77 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer whbDiscoveryDaemon](self->_daemon, "whbDiscoveryDaemon"));
                  [v77 diagnosticControl:&off_1008C2F58];

                  v147 = 0LL;
                  NSAppendPrintF_safe(&v147, "");
                  BOOL v18 = v147;
                }

                else
                {
                  -[CBDaemonXPCConnection _xpcDiagnosticTipiChanged](self, "_xpcDiagnosticTipiChanged");
                  v148 = 0LL;
                  NSAppendPrintF_safe(&v148, "");
                  BOOL v18 = v148;
                }
              }

              else
              {
                if (dword_1008D6630 <= 30
                  && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
                {
                  LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticControl:]",  30LL,  "Diags: evaluate");
                }

                v161 = 0u;
                v162 = 0u;
                v159 = 0u;
                v160 = 0u;
                id v53 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer xpcConnections](self->_daemon, "xpcConnections"));
                v54 = [v53 countByEnumeratingWithState:&v159 objects:v181 count:16];
                if (v54)
                {
                  id v55 = *(void *)v160;
                  do
                  {
                    for (uint64_t j = 0LL; j != v54; uint64_t j = (char *)j + 1)
                    {
                      if (*(void *)v160 != v55) {
                        objc_enumerationMutation(v53);
                      }
                      [*(id *)(*((void *)&v159 + 1) + 8 * (void)j) _spatialInteractionReevaluateDevices];
                    }

                    v54 = [v53 countByEnumeratingWithState:&v159 objects:v181 count:16];
                  }

                  while (v54);
                }

                v158 = 0LL;
                NSAppendPrintF_safe(&v158, "");
                BOOL v18 = v158;
              }
            }

            else
            {
              -[CBDaemonXPCConnection _xpcDiagnosticDiscovery](self, "_xpcDiagnosticDiscovery");
              v163 = 0LL;
              NSAppendPrintF_safe(&v163, "");
              BOOL v18 = v163;
            }
          }

          else
          {
            -[CBDaemonXPCConnection _xpcDiagnosticAssertion](self, "_xpcDiagnosticAssertion");
            v166 = 0LL;
            NSAppendPrintF_safe(&v166, "");
            BOOL v18 = v166;
          }
        }

        else
        {
          -[CBDaemonXPCConnection _xpcDiagnosticAdvertiser](self, "_xpcDiagnosticAdvertiser");
          v167 = 0LL;
          NSAppendPrintF_safe(&v167, "");
          BOOL v18 = v167;
        }

        uint64_t v19 = v18;
        goto LABEL_38;
      }

      uint64_t v13 = (void *)CUXPCCreateCFObjectFromXPCObject(xdict);
      if (v13)
      {
        BOOL v14 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer accessoryDaemon](self->_daemon, "accessoryDaemon"));
        int v15 = v14 == 0LL;

        if (!v15)
        {
          if (dword_1008D6630 <= 30
            && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
          {
            int v16 = CUPrintNSObjectOneLine(v13);
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
            LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticControl:]",  30LL,  "Diags: %s, %@",  v9,  v17);
          }

          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer accessoryDaemon](self->_daemon, "accessoryDaemon"));
          BOOL v21 = v175 + 5;
          v169 = v175[5];
          int v22 = (void *)objc_claimAutoreleasedReturnValue([v20 diagnosticControl:v13 error:&v169]);
          objc_storeStrong(v21, v169);

          if (!v22)
          {

            goto LABEL_131;
          }

          v168 = 0LL;
          NSAppendPrintF_safe(&v168, "%@", v22);
          uint64_t v19 = (__CFString *)v168;

          goto LABEL_38;
        }

        v75 = CBErrorF(4294960561LL, "AccessoryDaemon disabled");
        uint64_t v74 = objc_claimAutoreleasedReturnValue(v75);
      }

      else
      {
        v73 = CBErrorF(4294960591LL, "Convert params failed");
        uint64_t v74 = objc_claimAutoreleasedReturnValue(v73);
      }

      v76 = v175[5];
      v175[5] = (id)v74;

      goto LABEL_131;
    }

    v67 = CBErrorF(4294960591LL, "Non-dict input params");
    v66 = objc_claimAutoreleasedReturnValue(v67);
  }

  else
  {
    v65 = CBErrorF(4294960591LL, "No input params");
    v66 = objc_claimAutoreleasedReturnValue(v65);
  }

  uint64_t v19 = (__CFString *)v175[5];
  v175[5] = (id)v66;
LABEL_46:

LABEL_47:
  ((void (*)(void *))v118[2])(v118);

  _Block_object_dispose(&v174, 8);
}

            LOBYTE(v6) = 0;
          }
        }
      }

      break;
    case 5LL:
      if (qword_1008D5F00 != -1) {
        dispatch_once(&qword_1008D5F00, &stru_100881128);
      }
      sub_100409094((uint64_t)off_1008D5EF8, 0LL, 0);
      if (qword_1008D6788 != -1) {
        dispatch_once(&qword_1008D6788, &stru_100881148);
      }
      id v5 = sub_10040D3E4((uint64_t)off_1008D6780);
      LOBYTE(v6) = 1;
      if (v5)
      {
        uint64_t v7 = (v5 + 310000);
        if ((_DWORD)v7)
        {
          if (a4)
          {
            int v8 = "Power on failed";
LABEL_31:
            uint64_t v13 = v7;
LABEL_34:
            BOOL v14 = CBErrorF(v13, v8, v17);
LABEL_35:
            int v15 = (id)objc_claimAutoreleasedReturnValue(v14);
            LOBYTE(v6) = 0;
            *a4 = v15;
            return v6;
          }

          goto LABEL_38;
        }
      }

      break;
    default:
      if (a4)
      {
        uint64_t v17 = a3;
        int v8 = "Unsupported power state: %d";
        uint64_t v13 = 4294960561LL;
        goto LABEL_34;
      }

      goto LABEL_38;
  }

  return v6;
}

  return v20;
}

    int v16 = v18;
    if (v18)
    {
LABEL_39:
      CFDictionaryAddValue(Mutable, v11, v16);
      CFRelease(v16);
      unint64_t v10 = 1;
    }

      uint64_t v29 = v21;
LABEL_50:
      sub_1001EF69C(v19);
      return v29;
    }

                      int v22 = 0;
                      *((_BYTE *)a1 + 15) = 1;
                      goto LABEL_39;
                    }

                    v39 = v6;
                    *((_BYTE *)a1 + 15) = 1;
LABEL_37:
                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
                    uint64_t v20 = 0;
                    uint64_t v6 = v39;
                    goto LABEL_38;
                  }

                  v39 = v6;
                  *((_BYTE *)a1 + 15) = 1;
LABEL_35:
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
                  int v45 = *((unsigned __int8 *)a1 + 14);
                  *((_BYTE *)a1 + 15) = 1;
                  if (v45 != 1) {
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1462,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                  }
                  v49 = v16;
                  BOOL v18 = 0;
                  goto LABEL_37;
                }

                v39 = v6;
                *((_BYTE *)a1 + 15) = 1;
LABEL_33:
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
                __int16 v44 = *((unsigned __int8 *)a1 + 14);
                *((_BYTE *)a1 + 15) = 1;
                if (v44 != 1) {
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1461,  "(*pBs).__RWFlag == BYTESTREAM_READ");
                }
                int v16 = 0;
                goto LABEL_35;
              }

              v39 = v6;
              *((_BYTE *)a1 + 15) = 1;
LABEL_31:
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
              uint64_t v43 = *((unsigned __int8 *)a1 + 14);
              *((_BYTE *)a1 + 15) = 1;
              if (v43 != 1) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1460,  "(*pBs).__RWFlag == BYTESTREAM_READ");
              }
              BOOL v14 = 0;
              goto LABEL_33;
            }

            v39 = v6;
            *((_BYTE *)a1 + 15) = 1;
LABEL_29:
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
            __int16 v42 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v42 != 1) {
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1459,  "(*pBs).__RWFlag == BYTESTREAM_READ");
            }
            uint64_t v12 = 0;
            goto LABEL_31;
          }

          v39 = v6;
          *((_BYTE *)a1 + 15) = 1;
        }

        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v41 = *((unsigned __int8 *)a1 + 14);
        *((_BYTE *)a1 + 15) = 1;
        if (v41 != 1) {
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  1458,  "(*pBs).__RWFlag == BYTESTREAM_READ");
        }
        unint64_t v10 = 0LL;
        goto LABEL_29;
      }
    }

    *((_BYTE *)a1 + 15) = 1;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Could not get the status of the read remote used features event",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v47);
      uint64_t v38 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
    }

    return;
  }

  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  id v1 = 0LL;
LABEL_16:
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Not enough data in the capabilites packet : %d expecting at least %d",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v1);
    unsigned __int8 v30 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
LABEL_18:
    }
      sub_100657858();
  }

  sub_1001D4D70((char *)v6);
}

    sub_100657858();
    return 4823LL;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"This command is only available to LE devices.", v15, v16, v17, v18, v19, v20, v21, v61);
    int v22 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 4820LL;
}

              BOOL v18 = *(unsigned __int8 *)v16;
            }

  *(void *)buf = dst;
  BOOL v27 = sub_100255238( (uint64_t **)(v2 + 88),  dst,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)buf);
  v27[6] = v25;
  *((_WORD *)v27 + 2_Block_object_dispose(va, 8) = v26 + 1;
  uint64_t v28 = (os_log_s *)qword_1008F75F8;
  if (os_log_type_enabled((os_log_t)qword_1008F75F8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)buf = 134218240;
    *(void *)&uint8_t buf[4] = v25;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&_BYTE buf[14] = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "created networkrelay parser (%p) for pipe priority: %u",  buf,  0x12u);
  }

  v80 = 0;
  unsigned __int8 v30 = *(_DWORD *)(a1 + 72);
  if (v30 >= 4) {
    LOBYTE(v30) = 0;
  }
  NRBluetoothPacketParserGetSlotCount(v25, v30, (char *)&v80 + 2, &v80);
  *(void *)src = 0LL;
  v88 = 0LL;
  memset(v86, 0, sizeof(v86));
  uuid_copy(v86, src);
  uint64_t v31 = *(void *)(a1 + 56);
  int v32 = (char *)operator new(0x1A0uLL);
  uuid_copy(v85, v86);
  sub_100254A98( (uint64_t)v32,  0,  v31,  v85,  0LL,  v82,  0LL,  0LL,  (uint64_t)v23,  HIWORD(v80),  (unsigned __int16)v80,  *(_DWORD *)(a1 + 72),  *(_BYTE *)(a1 + 78));
  *(void *)buf = v3;
  sub_1002550B8((uint64_t **)(v2 + 16), v3, (uint64_t)&unk_1006C2518, (_WORD **)buf)[5] = (uint64_t *)v32;
  __int128 v33 = *v3;
  *(void *)buf = &v82;
  *((_WORD *)sub_100255178((uint64_t **)(v2 + 64), &v82, (uint64_t)&unk_1006C2518, (_DWORD **)buf) + 16) = v33;
  else {
    int v34 = 0;
  }
  v79 = 0;
  __int128 v35 = sub_1002E6E00();
  sub_10002418C(buf, "Pipe");
  sub_10002418C(__p, "overrideMTUSize");
  int v36 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(void *)v35 + 128LL))( v35,  buf,  __p,  &v79);
  char v37 = v79;
  if (v79) {
    uint64_t v38 = v36;
  }
  else {
    uint64_t v38 = 0;
  }
  if (v38 != 1)
  {
    if (v78 < 0) {
      operator delete(__p[0]);
    }
    if (v84 < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_60;
  }

  if (v78 < 0) {
    operator delete(__p[0]);
  }
  if (v84 < 0) {
    operator delete(*(void **)buf);
  }
  if (HIWORD(v37))
  {
LABEL_60:
    if (*(_DWORD *)(a1 + 72) == 3)
    {
      LOWORD(v39) = 675;
    }

    else if (v34)
    {
      LOWORD(v39) = 2570;
    }

    else
    {
      LOWORD(v39) = 2031;
    }

    **(_WORD **)(a1 + 64) = v39;
    goto LABEL_71;
  }

  v39 = v79;
  **(_WORD **)(a1 + 64) = v79;
  __int16 v40 = (os_log_s *)qword_1008F75F8;
  if (os_log_type_enabled((os_log_t)qword_1008F75F8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v39;
    _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Setting custom MTU size of  %u", buf, 8u);
    LOWORD(v39) = **(_WORD **)(a1 + 64);
  }
}

  CFDictionaryRemoveValue(v5, @"GuestAccIRK");
  if ((a2 & 0x400) != 0) {
LABEL_23:
  }
    CFDictionaryRemoveValue(v5, @"GuestAccEncKey");
LABEL_24:
  if (CFDictionaryGetCount(v5) == 1 && CFDictionaryContainsKey(v5, @"LocalAddress")) {
    CFDictionaryRemoveValue(v5, @"LocalAddress");
  }
  if (CFDictionaryGetCount(v5)) {
    int v16 = sub_1002961E4(a1, 0LL, v5, 0LL, 0, 0, 1);
  }
  else {
    int v16 = sub_100296CF0(a1, 0LL, 0);
  }
  uint64_t v17 = v16;
LABEL_42:
  CFRelease(v5);
  return v17;
}

      CFRelease(v11);
      return valuePtr;
    }

  v136 = @"Unknown";
LABEL_39:
  uint64_t v20 = *(_DWORD *)(a2 + 104);
  uint64_t v19 = *(_DWORD *)(a2 + 108);
  if (v20)
  {
    if (v19)
    {
      if (*(_BYTE *)(a2 + 237))
      {
        BOOL v21 = (double)*(unint64_t *)(a2 + 248);
        int v22 = (double)*(unint64_t *)(a2 + 280);
      }

      else
      {
        BOOL v21 = (double)(*(_DWORD *)(a2 + 132) + *(_DWORD *)(a2 + 128));
        int v22 = (double)(v19 + v20);
      }

      uint64_t v6 = v21 / v22 * 100.0;
      v118 = v6;
    }

    else
    {
      v118 = 0;
    }

    LODWORD(v6) = *(_DWORD *)(a2 + 128);
    *(double *)&dispatch_source_t v24 = (double)*(unint64_t *)&v6 / (double)v20 * 100.0;
    v120 = *(double *)&v24;
    LODWORD(v24) = *(_DWORD *)(a2 + 96);
    *(double *)&BOOL v25 = (double)v24 / (double)v20 * 100.0;
    int v23 = *(double *)&v25;
    LODWORD(v25) = *(_DWORD *)(a2 + 112);
    *(double *)&dispatch_object_t v26 = (double)v25 / (double)v20 * 100.0;
    v100 = *(double *)&v26;
    LODWORD(v26) = *(_DWORD *)(a2 + 120);
    uint64_t v6 = (double)v26 / (double)v20 * 100.0;
    v104 = v6;
    if (v19) {
      goto LABEL_50;
    }
LABEL_44:
    v98 = 0;
    v102 = 0;
    goto LABEL_51;
  }

  v118 = 0;
  v120 = 0;
  int v23 = 0LL;
  v100 = 0;
  v104 = 0;
  if (!v19) {
    goto LABEL_44;
  }
LABEL_50:
  LODWORD(v6) = *(_DWORD *)(a2 + 116);
  *(double *)&BOOL v27 = (double)*(unint64_t *)&v6 / (double)v19 * 100.0;
  v98 = *(double *)&v27;
  LODWORD(v27) = *(_DWORD *)(a2 + 124);
  v102 = ((double)v27 / (double)v19 * 100.0);
LABEL_51:
  uint64_t v28 = *(_DWORD *)(a2 + 24);
  if (v28)
  {
    v116 = *(_DWORD *)a2 / (int)v28;
    v114 = *(_DWORD *)(a2 + 16) / (int)v28;
    v112 = *(_DWORD *)(a2 + 28) / v28;
  }

  else
  {
    v116 = 0;
    v114 = 0;
    v112 = 0;
  }

  uint64_t v29 = sub_1002E6BF0();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v29 + 136LL))(v29))
  {
    __int128 v33 = 0LL;
    int v34 = 0LL;
    v110 = 0;
    v108 = 0;
    __int128 v35 = 0LL;
    goto LABEL_67;
  }

  uint64_t v31 = *(_DWORD *)(a2 + 36);
  if (!v31)
  {
    v110 = 0;
    int v32 = *(_DWORD *)(a2 + 40);
    if (v32) {
      goto LABEL_57;
    }
LABEL_60:
    v108 = 0;
    goto LABEL_61;
  }

  int v32 = *(_DWORD *)(a2 + 40);
  v110 = vcvtas_u32_f32((float)((float)v31 * 100.0) / (float)(v32 + v31 + *(_DWORD *)(a2 + 60)));
  if (!v32) {
    goto LABEL_60;
  }
LABEL_57:
  v108 = vcvtas_u32_f32((float)((float)v32 * 100.0) / (float)(v32 + v31 + *(_DWORD *)(a2 + 60)));
LABEL_61:
  int v36 = *(_DWORD *)(a2 + 44);
  char v37 = *(_DWORD *)(a2 + 48);
  *(float *)v30.i32 = (float)v37;
  uint64_t v38 = vcvtps_u32_f32((float)v37 / (float)v36);
  if (v36) {
    __int128 v33 = v38;
  }
  else {
    __int128 v33 = 0LL;
  }
  int v34 = v32 + v31;
  if (v37)
  {
    LODWORD(v34) = vcvtps_u32_f32((float)v34 / *(float *)v30.i32);
    __int128 v35 = vcvt_u32_f32(vrndp_f32(vdiv_f32(vcvt_f32_u32(*(uint32x2_t *)(a2 + 52)), (float32x2_t)vdup_lane_s32(v30, 0))));
  }

  else
  {
    __int128 v35 = *(uint32x2_t *)(a2 + 52);
  }

            uint64_t v19 = (uint8_t *)*((void *)v2 + 1);
            if (v19)
            {
              do
              {
                uint64_t v20 = v19;
                uint64_t v19 = *(uint8_t **)v19;
              }

              while (v19);
            }

            else
            {
              do
              {
                uint64_t v20 = (uint8_t *)*((void *)v2 + 2);
                BOOL v21 = *(void *)v20 == (void)v2;
                uint64_t v2 = v20;
              }

              while (!v21);
            }

            uint64_t v2 = v20;
            if (v20 == v1) {
              goto LABEL_24;
            }
          }

          uint64_t v28 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__p = 136315138;
            *(void *)&__p[4] = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Targetted WatchDog Stall signature found, filing ABC Snapshot for %s",  __p,  0xCu);
          }

          if (qword_1008D9060 != -1) {
            dispatch_once(&qword_1008D9060, &stru_1008919C0);
          }
          uint64_t v29 = qword_1008D9058;
          sub_10002418C(__p, "Watchdog");
          sub_10040C784(60.0, v29, (uint64_t *)__p, (uint64_t *)v2 + 4);
          if (v34 < 0) {
            operator delete(*(void **)__p);
          }
LABEL_24:
          sub_10023E78C((uint64_t)buf, *(char **)&buf[8]);
        }
      }
    }

    memset(buf, 0, sizeof(buf));
    sub_10002418C(__p, "com.apple.homed");
    sub_100329294((uint64_t)buf, (const void **)__p, 1LL);
    if (v34 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v2 = *(uint8_t **)buf;
    id v1 = &buf[8];
    goto LABEL_24;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

        uint64_t v11 = (char *)__p;
LABEL_39:
        if (v11)
        {
          BOOL v27 = v11;
          operator delete(v11);
        }

        if (v17) {
          goto LABEL_53;
        }
        goto LABEL_2;
      }
    }

    if (a5)
    {
      int v32 = *((_DWORD *)v19 + 5);
      if (v32)
      {
        if (v21) {
          goto LABEL_64;
        }
      }

      else if (!v21)
      {
        goto LABEL_54;
      }

      v39 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT))
      {
        uint64_t v52 = v32;
        sub_10042994C(&v52, &buf);
        CFPropertyListRef v48 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &buf
            : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
        v49 = *((unsigned __int8 *)v19 + 17);
        *(_DWORD *)__p = 136446466;
        *(void *)&__p[4] = v48;
        id v55 = 1024;
        v56 = v49;
        _os_log_fault_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_FAULT,  "Found mismatch between pending services(%{public}s) and pending attempts (%d)",  __p,  0x12u);
      }

          goto LABEL_24;
        }

        if (v25)
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "MIDI: The device %@ supports MIDI",  buf,  0xCu);
        }

        if (qword_1008D5F20 != -1) {
          dispatch_once(&qword_1008D5F20, &stru_1008A1818);
        }
        if (sub_10061C0F8(qword_1008D5F18, v5))
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A1838);
          }
          dispatch_object_t v26 = off_1008D5F28;
          sub_10002418C(__p, "_MIDI_DEVICE_");
          sub_1005CCF08((uint64_t)v26, v5, (unsigned __int8 *)__p);
          if (v37 < 0) {
            operator delete(__p[0]);
          }
          BOOL v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  (char *)&xmmword_1006BDC38 + 4,  16LL));
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[CBUUID UUIDWithData:](&OBJC_CLASS___CBUUID, "UUIDWithData:", v27));

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A1838);
          }
          sub_1005CC0D4((uint64_t)off_1008D5F28, v5, (uint64_t)buf);
          if (v41 >= 0) {
            uint64_t v29 = buf;
          }
          else {
            uint64_t v29 = *(_BYTE **)buf;
          }
          unsigned __int8 v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v29));
          if (v41 < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v31 = (os_log_s *)qword_1008F75B0;
          if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            *(void *)&uint8_t buf[4] = v28;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&_BYTE buf[14] = v30;
            _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "MIDI: Starting MIDI service %@ on paired device %@",  buf,  0x16u);
          }

          int v32 = sub_1002E8F6C();
          (*(void (**)(uint64_t, void *))(*(void *)v32 + 24LL))(v32, v5);
          __int128 v33 = (void *)gCBDaemonServer;
          int v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObject:](&OBJC_CLASS___NSArray, "arrayWithObject:", v28));
          [v33 notifyConnectedDeviceUUID:v5 name:v30 servicesUUIDs:v34];

          sub_100559070(a1, (__n128 *)&xmmword_1006BDC38, a2);
        }

        else
        {
          __int128 v35 = (os_log_s *)qword_1008F75B0;
          if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            *(void *)&uint8_t buf[4] = v5;
            _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "MIDI: %@ is not paired - No AutoConnect",  buf,  0xCu);
          }
        }
      }

      else
      {
        int v15 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
        {
          int v16 = _os_feature_enabled_impl("BluetoothFeatures", "LEMIDIAutoConnect");
          sub_100691C30(v16, v8, buf, v15);
        }
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
    {
      sub_100691C88();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
  {
    sub_100691BA4();
  }

    int v8 = 0;
    goto LABEL_39;
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  uint64_t v17 = off_1008D5F28;
  BOOL v18 = sub_100241F94(uu);
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  LODWORD(v17) = sub_1005D733C((uint64_t)v17, v19);

  uint64_t v20 = (_DWORD)v17 == 0;
  if ((_DWORD)v17) {
    int v8 = 2;
  }
  else {
    int v8 = 0;
  }
  if (v20) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = 16LL;
  }
LABEL_5:
  unint64_t v10 = sub_1001BCDB0(a2);
  LODWORD(v25) = v10;
  BYTE6(v25) = BYTE6(v10);
  WORD2(v25) = WORD2(v10);
  LOBYTE(v23) = 0;
  sub_100242CA4(&v23);
  sub_1001C7A18(&v25, a3, a4, v9, v8);
  sub_100242CD8(&v23);
  return sub_100242FAC((uint64_t)v27);
}

void sub_10002AA08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002AA58()
{
  uint64_t v0 = objc_alloc_init(&OBJC_CLASS___CBStackAdaptorBTStack);
  id v1 = -[CBDaemonServer initWithCBStackAdaptor:]( objc_alloc(&OBJC_CLASS___CBDaemonServer),  "initWithCBStackAdaptor:",  v0);
  -[CBDaemonServer activate](v1, "activate");
  uint64_t v2 = objc_opt_new(&OBJC_CLASS___WPDaemonServer);
  uint64_t v3 = (void *)qword_1008F1F50;
  qword_1008F1F50 = v2;

  [(id)qword_1008F1F50 startListening];
  id v4 = (id)qword_1008F1F50;
  signal(31, (void (__cdecl *)(int))1);
  dispatch_source_t v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0x1FuLL, 0LL, &_dispatch_main_q);
  uint64_t v6 = (void *)qword_1008D9E98;
  qword_1008D9E98 = (uint64_t)v5;

  uint64_t v7 = (dispatch_source_s *)qword_1008D9E98;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10002B514;
  handler[3] = &unk_10087EA48;
  id v10 = v4;
  id v8 = v4;
  dispatch_source_set_event_handler(v7, handler);
  dispatch_resume((dispatch_object_t)qword_1008D9E98);
}

void sub_10002AB80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002ABA8()
{
  int v4 = 0;
  if (sub_1003C6B0C(qword_1008D9E58, 1LL, &v4))
  {
    uint64_t v0 = (os_log_s *)(id)qword_1008F7578;
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      int v1 = sub_1003C6B0C(qword_1008D9E58, 1LL, &v4);
      sub_1006573A0((uint64_t)v5, v1, v0);
    }

    uint64_t v2 = __stderrp;
    int v3 = sub_1003C6B0C(qword_1008D9E58, 1LL, &v4);
    fprintf(v2, "Failed to update Dynamic Store. BTLocalDeviceGetModulePower returned %d", v3);
  }

  else
  {
    sub_10002ACA8(v4);
  }

void sub_10002AC90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002ACA8(int a1)
{
  keys = @"Powered";
  uint64_t v2 = (void **)&kCFBooleanTrue;
  if (a1 != -1) {
    uint64_t v2 = (void **)&kCFBooleanFalse;
  }
  values = *v2;
  int v3 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    switch(a1)
    {
      case -1:
        int v4 = "On";
        break;
      case -889275714:
        int v4 = "Transitioning";
        break;
      case -559038737:
        int v4 = "Unknown";
        break;
      default:
        int v4 = "Off";
        if (a1 == -1122640211) {
          int v4 = "Terminated";
        }
        break;
    }

    *(_DWORD *)buf = 136315394;
    uint64_t v17 = v4;
    __int16 v18 = 1024;
    BOOL v19 = a1 == -1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Update Dynamic Store with state %s\t value %d",  buf,  0x12u);
  }

  switch(a1)
  {
    case -1:
      dispatch_source_t v5 = "On";
      break;
    case -889275714:
      dispatch_source_t v5 = "Transitioning";
      break;
    case -559038737:
      dispatch_source_t v5 = "Unknown";
      break;
    default:
      dispatch_source_t v5 = "Off";
      if (a1 == -1122640211) {
        dispatch_source_t v5 = "Terminated";
      }
      break;
  }

  fprintf(__stderrp, "Update Dynamic Store with state %s\t value %d", v5, a1 == -1);
  CFDictionaryRef v6 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!SCDynamicStoreSetValue((SCDynamicStoreRef)qword_1008D9E60, @"com.apple.MobileBluetooth", v6))
  {
    int v7 = SCError();
    id v8 = SCErrorString(v7);
    uint64_t v9 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_1006573D8((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15);
    }
    fprintf(__stderrp, "Update Dynamic Store failed with error %s", v8);
  }

  CFRelease(v6);
}

BOOL sub_10002AF24(const char *a1)
{
  if (sub_10002993C())
  {
    uint64_t v2 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v20 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "%s: read from IOREG is disabled for debugging\n",  buf,  0xCu);
    }

    fprintf(__stderrp, "%s: read from IOREG is disabled for debugging\n");
    return 0LL;
  }

  int v3 = IOServiceNameMatching(a1);
  if (!v3) {
    goto LABEL_15;
  }
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  if (!MatchingService)
  {
    uint64_t v10 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_100657440((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
    }
    fprintf(__stderrp, "%s: Unable to match bluetooth service in device tree.\n", a1);
LABEL_15:
    BOOL v7 = 0LL;
    goto LABEL_16;
  }

  io_object_t v5 = MatchingService;
  CFDictionaryRef v6 = (const __CFData *)IORegistryEntrySearchCFProperty( MatchingService,  "IODeviceTree",  @"local-mac-address",  kCFAllocatorDefault,  1u);
  BOOL v7 = v6 != 0LL;
  if (v6)
  {
    id v8 = v6;
    *(void *)__str = 0LL;
    uint64_t v24 = 0LL;
    __int16 v25 = 0;
    v26.location = 0LL;
    v26.length = 6LL;
    CFDataGetBytes(v6, v26, (UInt8 *)&dword_1008D9E48);
    snprintf( __str,  0x12uLL,  "%02x:%02x:%02x:%02x:%02x:%02x",  dword_1008D9E48,  BYTE1(dword_1008D9E48),  BYTE2(dword_1008D9E48),  HIBYTE(dword_1008D9E48),  word_1008D9E4C,  HIBYTE(word_1008D9E4C));
    uint64_t v9 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v20 = a1;
      __int16 v21 = 2080;
      int v22 = __str;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s: Got local-mac-address: %s\n", buf, 0x16u);
    }

    fprintf(__stderrp, "%s: Got local-mac-address: %s\n", a1, __str);
    setenv("BT_DEVICE_ADDRESS", __str, 1);
    CFRelease(v8);
  }

  IOObjectRelease(v5);
LABEL_16:
  *(_WORD *)&__str[4] = 0;
  *(_DWORD *)__str = 0;
  if (!(dword_1008D9E48 | (unsigned __int16)word_1008D9E4C))
  {
    uint64_t v17 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v20 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "%s: Not a valid MAC address (all 00s).\n",  buf,  0xCu);
    }

    fprintf(__stderrp, "%s: Not a valid MAC address (all 00s).\n");
    return 0LL;
  }

  return v7;
}

void (__cdecl *sub_10002B230(uint64_t a1))(int)
{
  return sub_10002B238((void (__cdecl *)(int))*(unsigned int *)(a1 + 32));
}

void (__cdecl *sub_10002B238(void (__cdecl *result)(int)))(int)
{
  if ((int)result > 29)
  {
    if ((_DWORD)result == 30)
    {
      return (void (__cdecl *)(int))sub_1003C0AA0(qword_1008D9E50);
    }

    else if ((_DWORD)result == 31)
    {
      int v1 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "-SIGUSR2 received -- triggering our statedump.",  buf,  2u);
      }

      return (void (__cdecl *)(int))sub_1003C0B14(qword_1008D9E50);
    }
  }

  else if ((_DWORD)result == 6)
  {
    uint64_t v2 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 984LL))(v2))
    {
      int v3 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v4 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "-SIGABRT received -- triggering ABC.",  v4,  2u);
      }

      sub_10040CA80("AppleTVInternal", "parseAppleMfgData", 60.0);
    }

    signal(6, (void (__cdecl *)(int))qword_1008D9E80);
    raise(6);
    return signal(6, (void (__cdecl *)(int))sub_10002B238);
  }

  else if ((_DWORD)result == 15)
  {
    if (qword_1008D6198 != -1) {
      dispatch_once(&qword_1008D6198, &stru_10087F9E0);
    }
    sub_10044905C((uint64_t)off_1008D6190, 1);
    return (void (__cdecl *)(int))sub_1003C6C40(qword_1008D9E58);
  }

  return result;
}

void (__cdecl *sub_10002B3D8(uint64_t a1))(int)
{
  return sub_10002B238((void (__cdecl *)(int))*(unsigned int *)(a1 + 32));
}

os_state_data_s *__cdecl sub_10002B3E0(id a1, os_state_hints_s *a2)
{
  if (a2->var2 == 3)
  {
    uint64_t v2 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v4 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "bluetoothd received OS_STATE_API_REQUEST (from sysdiagnose?) -- triggering our statedump.",  v4,  2u);
    }

    sub_1003C0B14(qword_1008D9E50);
  }

  return 0LL;
}

void sub_10002B460(uint64_t a1, int a2, int a3)
{
  if (!(a3 | a2))
  {
    int v5 = 0;
    if (!sub_1003C6B0C(qword_1008D9E58, 1LL, &v5))
    {
      sub_10002ACA8(v5);
      if (v5 == -1)
      {
        if (qword_1008D9E38) {
          return;
        }
        uint64_t v3 = os_transaction_create("PowerTransaction");
        int v4 = (void *)qword_1008D9E38;
      }

      else
      {
        if (v5)
        {
          if (v5 == -1122640211) {
            _exit(0);
          }
          return;
        }

        int v4 = (void *)qword_1008D9E38;
        if (!qword_1008D9E38) {
          return;
        }
        uint64_t v3 = 0LL;
      }

      qword_1008D9E38 = v3;
    }
  }

void sub_10002B514(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  id v2 = v1;
  if (v1) {
    [v1 dumpDaemonState];
  }
  else {
    fwrite("Invalid WPDaemonServer", 0x16uLL, 1uLL, __stderrp);
  }
}

void sub_10002B570( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10002B584(id a1)
{
  id v1 = (char *)operator new(0x200uLL);
  *(void *)id v1 = off_100898F60;
  *((void *)v1 + 1) = &off_100898FF0;
  *((void *)v1 + 2) = off_100899008;
  *((void *)v1 + 3) = &off_100899060;
  *((void *)v1 + 4) = &off_100899078;
  sub_100242DC4(v1 + 40);
  *((void *)v1 + 14) = 0LL;
  *((_DWORD *)v1 + 30) = 0;
  *((void *)v1 + 17) = 0LL;
  *((void *)v1 + 1_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 16) = 0LL;
  *(_OWORD *)(v1 + 155) = 0u;
  *(_OWORD *)(v1 + 171) = 0u;
  *(_OWORD *)(v1 + 187) = 0u;
  *(_WORD *)(v1 + 203) = 1;
  *((void *)v1 + 26) = 0LL;
  *((_WORD *)v1 + 10_Block_object_dispose(va, 8) = 256;
  *((void *)v1 + 29) = 0LL;
  *((void *)v1 + 2_Block_object_dispose(va, 8) = v1 + 232;
  *((void *)v1 + 32) = 0LL;
  *((void *)v1 + 33) = 0LL;
  *((void *)v1 + 30) = 0LL;
  *((void *)v1 + 31) = v1 + 256;
  v1[272] = 0;
  *((_DWORD *)v1 + 69) = 0;
  v1[280] = 0;
  *((_WORD *)v1 + 189) = 0;
  *(void *)(v1 + 313) = 0LL;
  *(_OWORD *)(v1 + 300) = 0u;
  *(_OWORD *)(v1 + 284) = 0u;
  *(_OWORD *)(v1 + 32_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  v1[376] = 0;
  *((void *)v1 + 51) = v1 + 416;
  *((void *)v1 + 52) = 0LL;
  *((void *)v1 + 55) = 0LL;
  *((void *)v1 + 56) = 0LL;
  *((void *)v1 + 53) = 0LL;
  *((void *)v1 + 54) = v1 + 440;
  *((void *)v1 + 57) = v1 + 464;
  *((void *)v1 + 5_Block_object_dispose(va, 8) = 0LL;
  *((void *)v1 + 59) = 0LL;
  *((void *)v1 + 60) = @"XZ";
  *((void *)v1 + 62) = 0LL;
  *((_DWORD *)v1 + 126) = 0;
  off_1008D6190 = v1;
}

void sub_10002B68C(_Unwind_Exception *a1)
{
}

void sub_10002B6A0(id a1)
{
  id v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_10002B6D0(_Unwind_Exception *a1)
{
}

void sub_10002B6E4(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
}

void sub_10002B6F4( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_10002B708( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

BOOL sub_10002B718()
{
  return os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT);
}

  ;
}

void sub_10002B7A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_27:
  CUAppendF(&v75, &v79, "Rate: %s", v10);
  uint64_t v11 = v75;

  uint64_t v12 = v52->_nearbyActionData;
  uint64_t v13 = v12;
  if (v12)
  {
    uint64_t v74 = v11;
    uint64_t v14 = CUPrintNSDataHex(v12, 100LL, 1LL);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    CUAppendF(&v74, &v79, "naPD <%@>", v15);
    uint64_t v16 = v74;
  }

  else
  {
    uint64_t v16 = v11;
  }

  uint64_t v17 = v52;
  if (-[NSArray count](v52->_saAddressDataArray, "count"))
  {
    v73 = v16;
    CUAppendF(&v73, &v79, "saAddrD: ");
    __int16 v18 = v73;

    int v72 = 8;
    int v68 = 0u;
    v69 = 0u;
    v70 = 0u;
    v71 = 0u;
    BOOL v19 = v52->_saAddressDataArray;
    uint64_t v20 = -[NSArray countByEnumeratingWithState:objects:count:]( v19,  "countByEnumeratingWithState:objects:count:",  &v68,  v82,  16LL);
    if (v20)
    {
      __int16 v21 = *(void *)v69;
      do
      {
        int v22 = 0LL;
        int v23 = v18;
        do
        {
          if (*(void *)v69 != v21) {
            objc_enumerationMutation(v19);
          }
          uint64_t v24 = *(void *)(*((void *)&v68 + 1) + 8LL * (void)v22);
          v67 = v23;
          __int16 v25 = v24;
          if (!v24)
          {
            __int16 v25 = objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
            uint64_t v13 = (void *)v25;
          }

          CFRange v26 = CUPrintNSDataHex(v25, 100LL, 1LL);
          BOOL v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
          CUAppendF(&v67, &v72, "{<%@>}", v27);
          uint64_t v28 = v24 == 0;
          __int16 v18 = v67;

          if (v28) {
          int v22 = (char *)v22 + 1;
          }
          int v23 = v18;
        }

        while (v20 != v22);
        uint64_t v20 = -[NSArray countByEnumeratingWithState:objects:count:]( v19,  "countByEnumeratingWithState:objects:count:",  &v68,  v82,  16LL);
      }

      while (v20);
    }

    uint64_t v16 = v18;
    uint64_t v17 = v52;
  }

  if (-[NSArray count](v17->_saServiceDataArray, "count"))
  {
    v66 = v16;
    CUAppendF(&v66, &v79, "saSvcD: ");
    uint64_t v29 = v66;

    int v72 = 8;
    v62 = 0u;
    v63 = 0u;
    v64 = 0u;
    v65 = 0u;
    id obj = v52->_saServiceDataArray;
    unsigned __int8 v30 = -[NSArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v62,  v81,  16LL);
    if (v30)
    {
      uint64_t v31 = *(void *)v63;
      do
      {
        int v32 = 0LL;
        __int128 v33 = v29;
        do
        {
          if (*(void *)v63 != v31) {
            objc_enumerationMutation(obj);
          }
          int v34 = *(void **)(*((void *)&v62 + 1) + 8LL * (void)v32);
          v61 = v33;
          __int128 v35 = [v34 serviceUUID16];
          int v36 = objc_claimAutoreleasedReturnValue([v34 serviceData]);
          char v37 = (void *)v36;
          if (!v36)
          {
            int v36 = objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
            uint64_t v13 = (void *)v36;
          }

          uint64_t v38 = CUPrintNSDataHex(v36, 100LL, 1LL);
          v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
          CUAppendF(&v61, &v72, "{UUUID 0x%04X, Data <%@>}", v35, v39);
          uint64_t v29 = v61;

          if (!v37) {
          int v32 = (char *)v32 + 1;
          }
          __int128 v33 = v29;
        }

        while (v30 != v32);
        unsigned __int8 v30 = -[NSArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v62,  v81,  16LL);
      }

      while (v30);
    }

    uint64_t v16 = v29;
    uint64_t v17 = v52;
  }

  if (-[NSArray count](v17->_serviceDataArray, "count"))
  {
    size_t v60 = v16;
    CUAppendF(&v60, &v79, "SvcD: ");
    __int16 v40 = v60;

    int v72 = 8;
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    v59 = 0u;
    obja = v52->_serviceDataArray;
    v41 = -[NSArray countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v56,  v80,  16LL);
    if (v41)
    {
      __int16 v42 = *(void *)v57;
      do
      {
        uint64_t v43 = 0LL;
        __int16 v44 = v40;
        do
        {
          if (*(void *)v57 != v42) {
            objc_enumerationMutation(obja);
          }
          int v45 = *(void **)(*((void *)&v56 + 1) + 8LL * (void)v43);
          id v55 = v44;
          v46 = [v45 serviceUUID16];
          v47 = objc_claimAutoreleasedReturnValue([v45 serviceData]);
          CFPropertyListRef v48 = (void *)v47;
          if (!v47)
          {
            v47 = objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
            uint64_t v16 = (id)v47;
          }

          v49 = CUPrintNSDataHex(v47, 100LL, 1LL);
          char v50 = (void *)objc_claimAutoreleasedReturnValue(v49);
          CUAppendF(&v55, &v72, "{UUUID 0x%04X, Data <%@>}", v46, v50);
          __int16 v40 = v55;

          if (!v48) {
          uint64_t v43 = (char *)v43 + 1;
          }
          __int16 v44 = v40;
        }

        while (v41 != v43);
        v41 = -[NSArray countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v56,  v80,  16LL);
      }

      while (v41);
    }
  }

  else
  {
    __int16 v40 = v16;
  }

  return v40;
}

          self->_objectDiscoveryFlags |= 1u;
          if ((v12 & 0x10000000000LL) == 0)
          {
LABEL_18:
            uint64_t v14 = [v10 bleRSSIThresholdHint];
            if ((v14 & (v14 >> 31)) <= -90) {
              uint64_t v15 = -90;
            }
            else {
              uint64_t v15 = v14 & (v14 >> 31);
            }
            uint64_t v16 = [v10 bleScanRateOverride];
            if (!v16 && (self->_screenOn || (uint64_t v16 = [v10 bleScanRateScreenOff]) == 0))
            {
              uint64_t v16 = [v10 bleScanRate];
              if (!v16) {
                self->_scanRateAnyDefault = 1;
              }
            }

            if (v16 > self->_scanRateHighest) {
              self->_scanRateHighest = v16;
            }
            v33 |= (v12 >> 18) & 1;
            if ((v33 & 1) != 0)
            {
              uint64_t v17 = sub_1002E6E9C();
              int v36 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 2328LL))(v17);
            }

            else
            {
              int v36 = 0;
            }

            __int16 v18 = (void *)objc_claimAutoreleasedReturnValue([v10 deviceFilter]);
            BOOL v19 = (void *)objc_claimAutoreleasedReturnValue(-[CBStackBLEScannerBTStack _deviceFilterUUIDs:](self, "_deviceFilterUUIDs:", v18));

            if ([v19 count]) {
              uint64_t v20 = 3;
            }
            else {
              uint64_t v20 = 2;
            }
            __int128 v35 = v20;
            bzero(&v51, 0x16uLL);
            bzero(&v49, 0x16uLL);
            if (v32 == 21)
            {
              if ((v12 & 0x400020108LL) == 0)
              {
                uint64_t v24 = [v10 discoveryTypesContainTypes:CBDiscoveryTypesNearbyActionV2(v21)];
                if (!(_DWORD)v24) {
                  goto LABEL_98;
                }
                uint64_t v24 = [v10 discoveryTypesContainTypes:CBDiscoveryTypesNeedsIdentify()];
                if (!(_DWORD)v24) {
                  goto LABEL_98;
                }
              }

              if ((id)-[NSData length](self->_selfAuthTag, "length") != (id)3)
              {
                if (dword_1008D6530 <= 90
                  && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 90LL)))
                {
                  LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _addTypeWithParamsIfNeeded:matchFlags:matchTypes:scanRequest:]",  90LL,  "Authtag length doesn't match set: %lu, required: %d",  -[NSData length](self->_selfAuthTag, "length"),  3);
                }

                goto LABEL_95;
              }

              int v22 = self->_selfAuthTag;

              LOBYTE(v51) = 1;
              LOBYTE(v49) = 1;
              int v23 = -[NSData length](v22, "length");
              unsigned __int8 v30 = v22;
              uint64_t v24 = memcpy((char *)&v51 + 2, -[NSData bytes](v30, "bytes"), v23);
              if (v23) {
                uint64_t v24 = memset((char *)&v49 + 2, 255, v23);
              }
              if ((v12 & 0x400020108LL) == 0)
              {
LABEL_98:
                if (![v10 discoveryTypesContainTypes:CBDiscoveryTypesNearbyActionV2(v24)]) {
                  goto LABEL_85;
                }
              }

              if ((v12 & 0x400000000LL) != 0)
              {
                BYTE1(v51) = 38;
                BYTE1(v49) = 38;
                __int16 v42 = 0LL;
                uint64_t v43 = 0LL;
                sub_10056AB04(&v42, &v51, 0x16uLL);
                __int16 v40 = 0LL;
                v41 = 0LL;
                sub_10056AB04(&v40, &v49, 0x16uLL);
                if (v15) {
                  CFRange v26 = v15;
                }
                else {
                  CFRange v26 = -90;
                }
                sub_10004A304( (uint64_t)a6,  @"Ensemble",  0x15u,  v35,  (uint64_t)&v42,  (uint64_t)&v40,  v26,  0,  (v12 & 0x200000000LL) != 0,  self->_targetCore,  1,  v19,  v36,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
                __int16 v40 = &off_10087FAA8;
                if (v41) {
                  sub_1002CD254(v41);
                }
                __int16 v42 = &off_10087FAA8;
                if (v43) {
                  sub_1002CD254(v43);
                }
              }

              if ((v12 & 8) != 0)
              {
                BYTE1(v51) = 51;
                BYTE1(v49) = 51;
                __int16 v42 = 0LL;
                uint64_t v43 = 0LL;
                sub_10056AB04(&v42, &v51, 0x16uLL);
                __int16 v40 = 0LL;
                v41 = 0LL;
                sub_10056AB04(&v40, &v49, 0x16uLL);
                if (v15) {
                  BOOL v27 = v15;
                }
                else {
                  BOOL v27 = -90;
                }
                sub_10004A304( (uint64_t)a6,  @"CLink",  0x15u,  v35,  (uint64_t)&v42,  (uint64_t)&v40,  v27,  0,  (v12 & 0x200000000LL) != 0,  self->_targetCore,  1,  v19,  v36,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
                __int16 v40 = &off_10087FAA8;
                if (v41) {
                  sub_1002CD254(v41);
                }
                __int16 v42 = &off_10087FAA8;
                if (v43) {
                  sub_1002CD254(v43);
                }
              }

              if ((v12 & 0x100) != 0)
              {
                BYTE1(v51) = 50;
                BYTE1(v49) = 50;
                __int16 v42 = 0LL;
                uint64_t v43 = 0LL;
                sub_10056AB04(&v42, &v51, 0x16uLL);
                __int16 v40 = 0LL;
                v41 = 0LL;
                sub_10056AB04(&v40, &v49, 0x16uLL);
                if (v15) {
                  uint64_t v28 = v15;
                }
                else {
                  uint64_t v28 = -90;
                }
                sub_10004A304( (uint64_t)a6,  @"RDisplay",  0x15u,  v35,  (uint64_t)&v42,  (uint64_t)&v40,  v28,  0,  (v12 & 0x200000000LL) != 0,  self->_targetCore,  1,  v19,  v36,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
                __int16 v40 = &off_10087FAA8;
                if (v41) {
                  sub_1002CD254(v41);
                }
                __int16 v42 = &off_10087FAA8;
                if (v43) {
                  sub_1002CD254(v43);
                }
              }

              if ((v12 & 0x20000) == 0) {
                goto LABEL_85;
              }
              BYTE1(v51) = 41;
              BYTE1(v49) = 41;
              __int16 v42 = 0LL;
              uint64_t v43 = 0LL;
              sub_10056AB04(&v42, &v51, 0x16uLL);
              __int16 v40 = 0LL;
              v41 = 0LL;
              sub_10056AB04(&v40, &v49, 0x16uLL);
              if (v15) {
                uint64_t v29 = v15;
              }
              else {
                uint64_t v29 = -90;
              }
              sub_10004A304( (uint64_t)a6,  @"RemotePairing",  0x15u,  v35,  (uint64_t)&v42,  (uint64_t)&v40,  v29,  0,  (v12 & 0x200000000LL) != 0,  self->_targetCore,  1,  v19,  v36,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
            }

            else
            {
              __int16 v42 = 0LL;
              uint64_t v43 = 0LL;
              sub_10056AB04(&v42, &v51, 0x16uLL);
              __int16 v40 = 0LL;
              v41 = 0LL;
              sub_10056AB04(&v40, &v49, 0x16uLL);
              if (v15) {
                __int16 v25 = v15;
              }
              else {
                __int16 v25 = -90;
              }
              sub_10004A304( (uint64_t)a6,  @"Placeholder",  v32,  v35,  (uint64_t)&v42,  (uint64_t)&v40,  v25,  0,  (v12 & 0x200000000LL) != 0,  self->_targetCore,  1,  v19,  v36,  0,  0,  0,  1,  0LL,  0xFFFF,  0xFFFF,  0xFFFF);
            }

            __int16 v40 = &off_10087FAA8;
            if (v41) {
              sub_1002CD254(v41);
            }
            __int16 v42 = &off_10087FAA8;
            if (v43) {
              sub_1002CD254(v43);
            }
LABEL_85:

            continue;
          }

          sub_1000BADF8(v36, (unsigned __int16)v9);
          id v1 = 0;
        }

        else
        {
          sub_1001EE0E4("\t\tNo Channels\n");
        }
      }

      ++v0;
    }

    while (v0 < (unsigned __int16)word_1008DD4E2);
  }

    if (!(_DWORD)v5) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }

  uint64_t v28 = sub_1000E4B00(a3, a1);
  uint64_t v29 = v28;
  if ((_DWORD)v28)
  {
    if (*(unsigned __int8 *)(qword_1008DFDB0 + 97) > (unsigned __int16)(v28 - 1))
    {
      unsigned __int8 v30 = *(void *)(qword_1008DFDB0 + 8);
      if (v30)
      {
        uint64_t v31 = (unsigned __int16)(v28 - 1);
        sub_1000DD6D8(v30 + 144LL * (unsigned __int16)(v28 - 1), 6);
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Disconnecting media transport", v32, v33, v34, v35, v36, v37, v38, v79);
          v39 = (os_log_s *)sub_100086554(3u);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v40 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446210;
            v81 = v40;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        v41 = v30 + 144LL * v31;
        uint64_t v43 = *(unsigned __int16 *)(v41 + 128);
        __int16 v42 = (_WORD *)(v41 + 128);
        __int16 v44 = sub_1001759FC(v43, 436LL);
        if (!(_DWORD)v44)
        {
          v54 = 0LL;
          *(_BYTE *)(v30 + 144LL * v31 + 133) = a3;
          return v54;
        }

        if (*v42)
        {
          int v45 = v44;
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Error disconnecting media transport - %!", v46, v47, v48, v49, v50, v51, v52, v45);
            id v53 = (os_log_s *)sub_100086554(3u);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          os_log_s *v42 = 0;
          sub_1000B90AC(0LL);
        }

        sub_1000DC6BC(v30 + 144LL * v31);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)(qword_1008DFDB0 + 24) + 176LL))(a3, v29, 0LL);
        return 0LL;
      }
    }

    v54 = 18LL;
  }

  else
  {
    v54 = 1LL;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Abort Accept RXed for unknown endpoint. transaction: %d",  v55,  v56,  v57,  v58,  v59,  v60,  v61,  a3);
    v62 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  (*(void (**)(uint64_t, uint64_t, void))(*(void *)(qword_1008DFDB0 + 24) + 176LL))(a3, v29, 0LL);
  return v54;
}

    uint64_t v24 = *(unsigned __int16 *)(a2 + 12);
    *(_WORD *)(a2 + 12) = 0;
    if ((*(_BYTE *)(a1 + 80) & 0xFE) == 0x48)
    {
      __int16 v25 = *(unsigned __int8 *)(a1 + 78);
      CFRange v26 = v25 & 0x7F;
      if (v25 == 160) {
        CFRange v26 = -112;
      }
      if (v25 == 144) {
        BOOL v27 = -112;
      }
      else {
        BOOL v27 = v26;
      }
      if (*(_BYTE *)(a2 + 15))
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/obex/obexcommon.c");
      }

      else if (*(_WORD *)(a2 + 10))
      {
        if (*(_BYTE *)(a2 + 14) != 2)
        {
          uint64_t v28 = "(*pktHdr).__RWFlag == BYTESTREAM_WRITE";
          goto LABEL_60;
        }

  v46 = v4 + 1;
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Moving channels from %p (0x%2x) to %p (0x%2x) with an exception:",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v3);
    int v22 = (os_log_s *)sub_100086554(0x56u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      CFPropertyListRef v48 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (v46)
  {
    for (uint64_t i = 0LL; i < v46; ++i)
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"\tCID:0x%4x", v25, v26, v27, v28, v29, v30, v31, *((unsigned __int16 *)v49 + i));
        int v32 = (os_log_s *)sub_100086554(0x56u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v33 = sub_1001EDDCC();
          *(_DWORD *)buf = 136446210;
          CFPropertyListRef v48 = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      int v34 = v46;
    }
  }

  else
  {
    int v34 = 0LL;
  }

  sub_100188888(v3, a2, (unsigned __int16 *)v49, v34);
  sub_10018A690(v3);
  sub_10018A690(a2);
  if (!*(_BYTE *)(a2 + 2))
  {
    if (!*(_BYTE *)(a2 + 144))
    {
      int v36 = sub_100173B8C(a2);
      if ((_DWORD)v36)
      {
        char v37 = v36;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"TS setting LSTO error %!", v38, v39, v40, v41, v42, v43, v44, v37);
          int v45 = (os_log_s *)sub_100086554(0x56u);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }
    }

    if (!*(_BYTE *)(a2 + 2))
    {
      *(_WORD *)(a2 + 25) = *(_WORD *)(v3 + 25);
      *(_WORD *)(a2 + 2_Block_object_dispose(va, 8) = *(_WORD *)(v3 + 28);
    }
  }

  return 0LL;
}

      ;
    }

    return 120LL;
  }

  return v4;
}

        sub_1001EE2A0();
      }
    }
  }

  uint64_t v29 = *a3;
  if (v29 == 44)
  {
    unsigned __int8 v30 = 2;
    uint64_t v31 = 3LL;
    goto LABEL_32;
  }

  if (v29 == 20 && sub_10012D514(a4[1]))
  {
    unsigned __int8 v30 = *(_BYTE *)(a4[1] + 152) & 0x7F;
    uint64_t v31 = 2LL;
LABEL_32:
    LODWORD(a4[v31]) = v30;
  }

  WORD5(xmmword_1008F6E30[0]) = WORD4(xmmword_1008F6E30[0]);
  word_1008F6E5A = word_1008F6E58;
  WORD1(xmmword_1008F6E30[0]) = 0;
  if (LOBYTE(xmmword_1008F6E30[0]))
  {
    id v8 = 0;
    uint64_t v9 = 1;
    BYTE14(xmmword_1008F6E30[0]) = 1;
    uint64_t v10 = 1;
  }

  else
  {
    id v8 = WORD4(xmmword_1008F6E30[0]) == 0;
    BYTE14(xmmword_1008F6E30[0]) = WORD4(xmmword_1008F6E30[0]) != 0;
    uint64_t v9 = word_1008F6E48 != 0;
    uint64_t v10 = word_1008F6E58 != 0;
  }

  byte_1008F6E4E = v9;
  byte_1008F6E5E = v10;
  WORD3(xmmword_1008F6E30[0]) = 0;
  byte_1008F6E91 = (WORD4(xmmword_1008F6E30[0]) != 0) & ~v8;
  if (LOBYTE(xmmword_1008F6E30[0]))
  {
    if (WORD4(xmmword_1008F6E30[0])) {
      uint64_t v11 = v8;
    }
    else {
      uint64_t v11 = 1;
    }
    if ((v11 & 1) != 0) {
      goto LABEL_39;
    }
  }

  else if (!v10 || !word_1008F6E58)
  {
LABEL_39:
    uint64_t v12 = sub_10012ED2C() != 0;
    goto LABEL_40;
  }

  uint64_t v12 = 1;
LABEL_40:
  byte_1008F6E92 = v12;
  byte_1008F6E90 = byte_1008F6E88 != 0;
  sub_100137518();
}

      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to send command", v27, v28, v29, v30, v31, v32, v33, v39);
        int v34 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
          sub_10065B898();
        }
      }
}
}

          Value = (const __CFString *)CFDictionaryGetValue(v12, v13);
          if (Value)
          {
            uint64_t v16 = Value;
            TypeID = CFStringGetTypeID();
            if (TypeID == CFGetTypeID(v16))
            {
              CFStringGetCString(v16, a3, *a4, 0x8000100u);
              *a4 = strlen(a3);
              return v18;
            }
          }

          goto LABEL_30;
        }

        if (a1 > 127)
        {
          if (a1 == 128)
          {
            uint64_t v13 = @"MagicAccHint";
            goto LABEL_27;
          }

          if (a1 == 256)
          {
            uint64_t v13 = @"MagicAccRachet";
            goto LABEL_27;
          }
        }

        else
        {
          if (a1 == 32)
          {
            uint64_t v13 = @"MagicAccEncKey";
            goto LABEL_27;
          }

          if (a1 == 64)
          {
            uint64_t v13 = @"MagicAccKey";
            goto LABEL_27;
          }
        }

    uint64_t v9 = 1;
    a4 = 151LL;
    goto LABEL_46;
  }

  sub_10032BA60(*(void *)(v8 + 64), 4, &v50);
  sub_10002EAC8((uint64_t)&v44, (uint64_t)&v50);
  v50.n128_u64[0] = (unint64_t)&off_10087FAA8;
  if (v50.n128_u64[1]) {
    sub_1002CD254((unsigned int *)v50.n128_u64[1]);
  }
  if (!sub_10056AAC8((uint64_t)&v44))
  {
    uint64_t v12 = (const char *)sub_10056AAF0((uint64_t)&v44);
    if (!strcmp(v12, "Combo"))
    {
      BOOL v27 = 0;
    }

    else
    {
      uint64_t v13 = (const char *)sub_10056AAF0((uint64_t)&v44);
      if (!strcmp(v13, "Local"))
      {
        BOOL v27 = 1;
      }

      else
      {
        uint64_t v14 = (const char *)sub_10056AAF0((uint64_t)&v44);
        if (!strcmp(v14, "Remote"))
        {
          BOOL v27 = 2;
        }

        else
        {
          uint64_t v15 = (const char *)sub_10056AAF0((uint64_t)&v44);
          if (!strcmp(v15, "DebugCombo"))
          {
            BOOL v27 = 3;
          }

          else
          {
            uint64_t v16 = (const char *)sub_10056AAF0((uint64_t)&v44);
            if (!strcmp(v16, "UnAuthenticated"))
            {
              BOOL v27 = 4;
            }

            else
            {
              uint64_t v17 = (const char *)sub_10056AAF0((uint64_t)&v44);
              if (!strcmp(v17, "Authenticated"))
              {
                BOOL v27 = 5;
              }

              else
              {
                __int16 v18 = (const char *)sub_10056AAF0((uint64_t)&v44);
                if (!strcmp(v18, "ChangedCombo"))
                {
                  BOOL v27 = 6;
                }

                else
                {
                  BOOL v19 = (const char *)sub_10056AAF0((uint64_t)&v44);
                  if (!strcmp(v19, "UnAuthComboP256"))
                  {
                    BOOL v27 = 7;
                  }

                  else
                  {
                    uint64_t v20 = (const char *)sub_10056AAF0((uint64_t)&v44);
                    if (strcmp(v20, "AuthComboP256"))
                    {
                      __int16 v21 = (os_log_s *)qword_1008F75E0;
                      if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
                      {
                        sub_1003CF00C(a3, &v50);
                        int v22 = v51;
                        int v23 = v50.n128_u64[0];
                        uint64_t v24 = sub_10056AAF0((uint64_t)&v44);
                        __int16 v25 = &v50;
                        if (v22 < 0) {
                          __int16 v25 = (__n128 *)v23;
                        }
                        *(_DWORD *)buf = 136446466;
                        id v53 = v25;
                        v54 = 2080;
                        id v55 = v24;
                        CFRange v26 = "Invalid link key type for device %{public}s - %s";
LABEL_34:
                        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v26, buf, 0x16u);
                        if (v51 < 0) {
                          operator delete((void *)v50.n128_u64[0]);
                        }
                        goto LABEL_27;
                      }

                      goto LABEL_27;
                    }

                    BOOL v27 = 8;
                  }
                }
              }
            }
          }
        }
      }
    }

    sub_10032BA60(*(void *)(v8 + 64), 8, &v50);
    sub_10002EAC8((uint64_t)&v44, (uint64_t)&v50);
    v50.n128_u64[0] = (unint64_t)&off_10087FAA8;
    if (v50.n128_u64[1]) {
      sub_1002CD254((unsigned int *)v50.n128_u64[1]);
    }
    if (!sub_10056AAC8((uint64_t)&v44))
    {
      sub_1003FE1B4(a2, &v50);
      __int128 v33 = v51;
      int v34 = v50.n128_u64[0];
      __int128 v35 = (const char *)sub_10056AAF0((uint64_t)&v44);
      if (v33 >= 0) {
        int v36 = &v50;
      }
      else {
        int v36 = (__n128 *)v34;
      }
      char v37 = strcmp((const char *)v36, v35);
      if (v51 < 0) {
        operator delete((void *)v50.n128_u64[0]);
      }
      if (v37)
      {
        uint64_t v38 = (os_log_s *)qword_1008F75E0;
        if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
        {
          sub_1003FE1B4(a2, &v50);
          __int16 v40 = v51;
          v41 = v50.n128_u64[0];
          __int16 v42 = sub_10056AAF0((uint64_t)&v44);
          uint64_t v43 = &v50;
          if (v40 < 0) {
            uint64_t v43 = (__n128 *)v41;
          }
          *(_DWORD *)buf = 136315394;
          id v53 = v43;
          v54 = 2080;
          id v55 = v42;
          _os_log_error_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "We have a link key for the wrong local device : %s != %s.",  buf,  0x16u);
          if (v51 < 0) {
            operator delete((void *)v50.n128_u64[0]);
          }
        }

        uint64_t v9 = 1;
        a4 = 150LL;
      }

      else
      {
        sub_10052525C((uint64_t)&v50, &v56, v27);
        sub_100525248((__n128 *)a4, &v50);
        nullsub_63(&v50, v39);
        a4 = 0LL;
        uint64_t v9 = 1;
      }

      goto LABEL_46;
    }
  }

  uint64_t v9 = 2;
LABEL_46:
  if (SHIBYTE(v47) < 0) {
    operator delete(__p[0]);
  }
LABEL_48:
  __int16 v44 = &off_10087FAA8;
  if (v45) {
    sub_1002CD254(v45);
  }
  if (v9 == 2) {
    return 150LL;
  }
  return a4;
}

  int v4 = 150LL;
LABEL_28:
  BOOL v19 = &off_10087FAA8;
  if (v20) {
    sub_1002CD254(v20);
  }
  return v4;
}

  sub_100242FAC((uint64_t)v33);
  return v24;
}

    *a2 = 0;
    uint64_t v9 = 408LL;
    if ((v7 & 0x80) == 0) {
      return v9;
    }
    goto LABEL_25;
  }

  if (__source[1] + 1 > (char *)a3)
  {
    uint64_t v9 = 5LL;
LABEL_25:
    operator delete(__source[0]);
    return v9;
  }

  if (!__source[1]) {
    goto LABEL_27;
  }
  id v8 = __source[0];
LABEL_24:
  strlcpy(a2, v8, a3);
  uint64_t v9 = 0LL;
  if (v17 < 0) {
    goto LABEL_25;
  }
  return v9;
}

    *a2 = 0;
    uint64_t v9 = 408LL;
    if ((v7 & 0x80) == 0) {
      return v9;
    }
    goto LABEL_25;
  }

  if (__source[1] + 1 > (char *)a3)
  {
    uint64_t v9 = 5LL;
LABEL_25:
    operator delete(__source[0]);
    return v9;
  }

  if (!__source[1]) {
    goto LABEL_27;
  }
  id v8 = __source[0];
LABEL_24:
  strlcpy(a2, v8, a3);
  uint64_t v9 = 0LL;
  if (v17 < 0) {
    goto LABEL_25;
  }
  return v9;
}

  sub_100242FAC((uint64_t)v32);
  return v15;
}

    uint64_t v13 = 0LL;
    goto LABEL_28;
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_100897448);
  }
  uint64_t v9 = sub_1005CC198((uint64_t)off_1008D5F28, v5, 0);
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100897468);
  }
  uint64_t v10 = sub_10040007C(off_1008D5F48, v9, 0);
  uint64_t v11 = (os_log_s *)qword_1008F75B0;
  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C((uint64_t)v10, __p);
    uint64_t v12 = v21 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)buf = 136446466;
    int v23 = v12;
    uint64_t v24 = 2114;
    __int16 v25 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Disconnecting classic device %{public}s because LE GATT connected for device %{public}@",  buf,  0x16u);
    if (SHIBYTE(v21) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_100897488);
  }
  sub_1004287C4((int64x2_t *)off_1008D60C8, (uint64_t)v10, 0x100000);
  uint64_t v13 = 1LL;
LABEL_28:

  return v13;
}

          CFDictionaryRef v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        int v4 = [v3 countByEnumeratingWithState:&v18 objects:v26 count:16];
      }

      while (v4);
    }
  }

    uint64_t v10 = (_UNKNOWN **)&unk_1008D9AC0;
    uint64_t v11 = &unk_1008D9AD8;
    goto LABEL_28;
  }

  uint64_t v10 = (_UNKNOWN **)&unk_1008D99D0;
  uint64_t v11 = &unk_1008D99E8;
LABEL_14:
  memset(&buf, 0, sizeof(buf));
  sub_10002418C(&buf, "4-EV5");
  uint64_t v12 = sub_10020759C(a4 + 400);
  if ((v12 & 1) == 0)
  {
    *((_WORD *)v10 + 11) = 16064;
    std::string::assign(&buf, "2-EV5");
  }

  uint64_t v13 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    p_buf = &buf;
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    uint64_t v15 = "";
    if (!v12) {
      uint64_t v15 = " not";
    }
    *(_DWORD *)__int16 v21 = 136315394;
    int v22 = p_buf;
    int v23 = 2080;
    uint64_t v24 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Setting up call using %s packets as HDR eSCO is%s supported",  v21,  0x16u);
  }

  if ((a3 - 129) >= 2 && a3 != 255)
  {
LABEL_28:
    if (sub_100206568(a4 + 400) == 2)
    {
      v11[4] = 28;
      uint64_t v16 = 1;
    }

    else
    {
      v11[4] = -1;
      uint64_t v16 = -1;
    }

    *((_BYTE *)v11 + 12) = v16;
  }

    __int16 v21 = 1;
    goto LABEL_28;
  }

    uint64_t v24 = (os_log_s *)qword_1008F75D0;
    __int16 v25 = os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_DEFAULT);
    if (v25)
    {
      sub_1003CF00C(*v5, v57);
      CFRange v26 = v20;
      if (v58 >= 0) {
        BOOL v27 = v57;
      }
      else {
        BOOL v27 = *(_BYTE **)v57;
      }
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = a2;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v19;
      *(_WORD *)&_BYTE buf[14] = 1024;
      LODWORD(v60[0]) = (unsigned __int16)v20;
      WORD2(v60[0]) = 2082;
      *(void *)((char *)v60 + 6) = v27;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Sending 'GetFolderItems' response (result - %02x, nbItems - %u, length - %u) to device %{public}s",  buf,  0x1Eu);
      if (v58 < 0) {
        operator delete(*(void **)v57);
      }
    }

    else
    {
      CFRange v26 = v20;
    }

    v55[1] = v55;
    __chkstk_darwin(v25, (unsigned __int16)v20);
    uint64_t v29 = (char *)v55 - v28;
    bzero((char *)v55 - v28, v30);
    unsigned __int8 *v29 = 113;
    v29[2] = v26 - 3;
    v29[1] = (unsigned __int16)(v26 - 3) >> 8;
    v29[3] = a2;
    if (a2 == 4)
    {
      v29[5] = a3;
      v29[4] = HIBYTE(a3);
      v29[7] = v19;
      v29[6] = HIBYTE(v19);
      int v32 = 8;
      *(void *)&uint64_t v31 = 136315138LL;
      v56 = v31;
      do
      {
        BOOL v7 = *(void *)(v7 + 8);
        if (v7 == v18) {
          break;
        }
        __int128 v33 = (os_log_s *)qword_1008F75D0;
        if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_DEFAULT))
        {
          int v34 = *(void *)(v7 + 16);
          if (*(char *)(v34 + 47) < 0)
          {
            sub_100024238(buf, *(void **)(v34 + 24), *(void *)(v34 + 32));
          }

          else
          {
            *(_OWORD *)buf = *(_OWORD *)(v34 + 24);
            v60[0] = *(void *)(v34 + 40);
          }

          __int128 v35 = buf;
          if (v60[0] < 0) {
            __int128 v35 = *(uint8_t **)buf;
          }
          *(_DWORD *)v57 = v56;
          *(void *)&v57[4] = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Sending item %s", v57, 0xCu);
          if (SHIBYTE(v60[0]) < 0) {
            operator delete(*(void **)buf);
          }
        }

        int v36 = *(void *)(v7 + 16);
        char v37 = (unsigned __int16)v20 >= v32 ? v20 - v32 : 0;
        uint64_t v38 = (*(uint64_t (**)(uint64_t, char *, void))(*(void *)v36 + 32LL))(v36, &v29[v32], v37);
        v32 += v38;
      }

      while (v38);
    }

    else
    {
      int v32 = 4;
    }

    if (v32 > (unsigned __int16)v20)
    {
      v39 = (os_log_s *)qword_1008F75D0;
      if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_FAULT)) {
        sub_10068EB80(v39, v40, v41, v42, v43, v44, v45, v46);
      }
    }

    buf[0] = 0;
    sub_100242CA4(buf);
    if (sub_1000ECD8C(*(void *)(a1 + 40) + 128LL, *(unsigned __int8 *)(a1 + 48), v29, v32)
      && os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR))
    {
      sub_10068EB20();
    }

    sub_100242CD8(buf);
  }

  else
  {
LABEL_12:
    uint64_t v17 = (os_log_s *)qword_1008F75D0;
    if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR)) {
      sub_10068EA94(v5, v17);
    }
  }

  uint64_t v11 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DataLength");
  uint64_t v12 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v11 + 88LL))(v11, buf, __p, &v172);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v12) {
      goto LABEL_39;
    }
  }

  else if (!v12)
  {
    goto LABEL_39;
  }

  uint64_t v13 = v172;
  uint64_t v14 = (os_log_s *)qword_1008F7620;
  if (v172)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Warning: Using override value %d ms for LE data length",  buf,  8u);
      LOWORD(v13) = v172;
    }

    *(_WORD *)(a1 + 836) = v13;
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
  {
    sub_100696E88();
  }

      v70 = 0;
      __int16 v21 = sub_100241F94(v6 + 25);
      int v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      sub_1005ABDE4(a1, v22, &v71, &v70, &v72);

      int v23 = sub_1001FD17C(v83, (uint64_t)" | ", 3LL);
      memset(v89, 0, 37);
      uuid_unparse_upper(v6 + 25, (char *)v89);
      sub_10002418C(&v69, (char *)v89);
      if ((v69.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v24 = &v69;
      }
      else {
        uint64_t v24 = (std::stringbuf::string_type *)v69.__r_.__value_.__r.__words[0];
      }
      if ((v69.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size = v69.__r_.__value_.__s.__size_;
      }
      else {
        size = v69.__r_.__value_.__l.__size_;
      }
      CFRange v26 = sub_1001FD17C(v23, (uint64_t)v24, size);
      BOOL v27 = sub_1001FD17C(v26, (uint64_t)",exp:", 5LL);
      v90 = 0u;
      memset(v89, 0, sizeof(v89));
      snprintf((char *)v89, 0x3FuLL, "%0llu.%0llu", (void)v72, *((void *)&v72 + 1));
      sub_10002418C(&__p, (char *)v89);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      uint64_t v29 = strlen((const char *)p_p);
      unsigned __int8 v30 = sub_1001FD17C(v27, (uint64_t)p_p, v29);
      uint64_t v31 = sub_1001FD17C(v30, (uint64_t)",reached:", 9LL);
      *(_WORD *)&v89[6] = 0;
      *(_DWORD *)v89 = v72;
      *(_WORD *)&v89[4] = WORD4(v72);
      int v32 = sub_1001F4468((uint64_t)v89);
      std::ostream::operator<<(v31, v32);
      *(_WORD *)&v89[6] = 0;
      *(_DWORD *)v89 = v72;
      *(_WORD *)&v89[4] = WORD4(v72);
      if (!sub_1001F4468((uint64_t)v89))
      {
        __int128 v33 = *((void *)&v72 + 1) - v66 + 1000 * (v72 - v67);
        int v34 = v33 / 0x3E8;
        __int128 v35 = (double)(v33 % 0x3E8) / 1000.0;
        int v36 = v35 + (double)(v33 / 0x3E8);
        if (v8 >= v36) {
          char v37 = v35 + (double)v34;
        }
        else {
          char v37 = v8;
        }
        if (v8 == 0.0) {
          id v8 = v35 + (double)v34;
        }
        else {
          id v8 = v37;
        }
        uint64_t v38 = sub_1001FD17C(v83, (uint64_t)",interval:", 10LL);
        v89[0] = 48;
        v39 = sub_100361614(v38, v89);
        *(void *)((char *)v39 + *(void *)(*v39 - 24LL) + 16) = 3LL;
        __int16 v40 = (void *)std::ostream::operator<<(v36);
        sub_1001FD17C(v40, (uint64_t)"sec", 3LL);
        v65 = 1;
      }

  return v11;
}

    goto LABEL_24;
  }

  if ((a4 - 11) < 2)
  {
    sub_100653404(a1, (unint64_t)a2, a3, a4, a5);
    if (v8 && a3 == 32)
    {
      uint64_t v15 = sub_1003E01A8(v8);
      (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL))(*(void *)a1 + 72LL))(a1, v8, v15, a4 == 11);
      return;
    }

    goto LABEL_24;
  }

  if (a4 == 101)
  {
    uint64_t v10 = 1LL;
    uint64_t v11 = a3;
    uint64_t v12 = 101;
    goto LABEL_22;
  }

  if (a4 != 102) {
    goto LABEL_27;
  }
  uint64_t v10 = 1LL;
  uint64_t v11 = a3;
  uint64_t v12 = 102;
LABEL_15:
  uint64_t v13 = a5;
  uint64_t v14 = 0;
LABEL_23:
  sub_100653804(a1, (uint64_t)a2, v10, v11, v12, v13, v14);
LABEL_24:
  if (a3 == 16 || a3 == 1) {
    sub_100654368(a1, v8, a3, a4, a5);
  }
}

void sub_10002BE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002C04C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002C254(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_BYTE *sub_10002C26C(uint64_t a1)
{
  if (*(void *)(a1 + 40) && *(_BYTE *)(a1 + 72))
  {
    if (qword_1008D6288 != -1) {
      dispatch_once(&qword_1008D6288, &stru_10087FAF8);
    }
    int v2 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 40));
    if (v2)
    {
      uint64_t v3 = (v2 + 310000);
      if (v2 != -310000
        && dword_1008D61B0 <= 90
        && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
      {
        uint64_t v4 = CUPrintErrorCode(v3);
        int v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
        LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke",  90LL,  "### Advertising CA stop failed: %@",  v5);
      }
    }
  }

  if (*(void *)(a1 + 48) && *(_BYTE *)(a1 + 73))
  {
    if (qword_1008D6288 != -1) {
      dispatch_once(&qword_1008D6288, &stru_10087FAF8);
    }
    int v6 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 48));
    if (v6)
    {
      uint64_t v7 = (v6 + 310000);
      if (v6 != -310000
        && dword_1008D61B0 <= 90
        && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
      {
        uint64_t v8 = CUPrintErrorCode(v7);
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
        LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke",  90LL,  "### Advertising NC stop failed: %@",  v9);
      }
    }
  }

  if (*(void *)(a1 + 56) && *(_BYTE *)(a1 + 74))
  {
    if (qword_1008D6288 != -1) {
      dispatch_once(&qword_1008D6288, &stru_10087FAF8);
    }
    int v10 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 56));
    if (v10)
    {
      uint64_t v11 = (v10 + 310000);
      if (v10 != -310000
        && dword_1008D61B0 <= 90
        && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
      {
        uint64_t v12 = CUPrintErrorCode(v11);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
        LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke",  90LL,  "### Advertising NC 1 stop failed: %@",  v13);
      }
    }
  }

  if (*(void *)(a1 + 64) && *(_BYTE *)(a1 + 75))
  {
    if (qword_1008D6288 != -1) {
      dispatch_once(&qword_1008D6288, &stru_10087FAF8);
    }
    int v14 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 64));
    if (v14)
    {
      uint64_t v15 = (v14 + 310000);
      if (v14 != -310000
        && dword_1008D61B0 <= 90
        && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
      {
        uint64_t v16 = CUPrintErrorCode(v15);
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
        LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke",  90LL,  "### Advertising NC Object Discovery stop failed: %@",  v17);
      }
    }
  }

  uint64_t result = [*(id *)(*(void *)(a1 + 32) + 136) count];
  if (result)
  {
    char v19 = 0;
    sub_100242CA4(&v19);
    sub_1001BDD20(0);
    sub_100242CD0(&v19);
    return sub_100242CD8(&v19);
  }

  return result;
}

void sub_10002C5C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002C5F0(unint64_t *a1)
{
  if (a1[4])
  {
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_10087FAB8);
    }
    int v2 = sub_1004966BC(qword_1008D61A0, a1[4]);
    uint64_t v3 = (v2 + 310000);
    if (v2) {
      BOOL v4 = (_DWORD)v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4
      && dword_1008D61B0 <= 90
      && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
    {
      uint64_t v5 = CUPrintErrorCode(v3);
      id v15 = (id)objc_claimAutoreleasedReturnValue(v5);
      LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke_2",  90LL,  "### Detach session CA failed: %@",  v15);
    }
  }

  if (a1[5])
  {
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_10087FAB8);
    }
    int v6 = sub_1004966BC(qword_1008D61A0, a1[5]);
    if (v6)
    {
      uint64_t v7 = (v6 + 310000);
      if (v6 != -310000
        && dword_1008D61B0 <= 90
        && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
      {
        uint64_t v8 = CUPrintErrorCode(v7);
        id v16 = (id)objc_claimAutoreleasedReturnValue(v8);
        LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke_2",  90LL,  "### Detach session NC failed: %@",  v16);
      }
    }
  }

  if (a1[6])
  {
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_10087FAB8);
    }
    int v9 = sub_1004966BC(qword_1008D61A0, a1[6]);
    if (v9)
    {
      uint64_t v10 = (v9 + 310000);
      if (v9 != -310000
        && dword_1008D61B0 <= 90
        && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
      {
        uint64_t v11 = CUPrintErrorCode(v10);
        id v17 = (id)objc_claimAutoreleasedReturnValue(v11);
        LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke_2",  90LL,  "### Detach session NC 1 failed: %@",  v17);
      }
    }
  }

  if (a1[7])
  {
    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_10087FAB8);
    }
    int v12 = sub_1004966BC(qword_1008D61A0, a1[7]);
    if (v12)
    {
      uint64_t v13 = (v12 + 310000);
      if (v12 != -310000
        && dword_1008D61B0 <= 90
        && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
      {
        uint64_t v14 = CUPrintErrorCode(v13);
        id v18 = (id)objc_claimAutoreleasedReturnValue(v14);
        LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack invalidate]_block_invoke_2",  90LL,  "### Detach session NC ObjectDiscovery failed: %@",  v18);
      }
    }
  }

void sub_10002C8F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_10002CD30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, unsigned int *a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a21) {
    sub_1002CD254(a21);
  }

  _Unwind_Resume(a1);
}

void sub_10002D3B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  _Unwind_Resume(a1);
}

void sub_10002D4B4(uint64_t a1)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_10087FAF8);
  }
  int v2 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 32));
  uint64_t v3 = (v2 + 310000);
  if (v2) {
    BOOL v4 = (_DWORD)v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4
    && dword_1008D61B0 <= 90
    && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
  {
    uint64_t v5 = CUPrintErrorCode(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack _updateConnectable]_block_invoke",  90LL,  "### Advertising stop failed: %@",  v6);
  }

void sub_10002D594( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10002D5A8(uint64_t a1)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_10087FAF8);
  }
  int v2 = sub_100572984((uint64_t)off_1008D6280, *(void *)(a1 + 32), a1 + 40, 1);
  uint64_t v3 = (v2 + 310000);
  if (v2) {
    BOOL v4 = (_DWORD)v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4
    && dword_1008D61B0 <= 90
    && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
  {
    uint64_t v5 = CUPrintErrorCode(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack _updateConnectable]_block_invoke_2",  90LL,  "### Advertising start failed: %@",  v6);
  }

void sub_10002D690( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10002D6A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = &off_10087FAE8;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v3;
  if (v3) {
    sub_1002CD1E0(v3);
  }
}

void sub_10002D6C4(uint64_t a1)
{
  *(void *)(a1 + 40) = &off_10087FAE8;
  id v1 = *(unsigned int **)(a1 + 48);
  if (v1) {
    sub_1002CD254(v1);
  }
}

void *sub_10002D6E0(void *a1)
{
  *a1 = &off_10087FAE8;
  int v2 = (unsigned int *)a1[1];
  if (v2) {
    sub_1002CD254(v2);
  }
  return a1;
}

LABEL_64:
  uint64_t v43 = &off_10087FAE8;
  if (v44) {
    sub_1002CD254(v44);
  }
}

              int v2 = (char **)qword_1008DDD08;
              *(_DWORD *)(qword_1008DDD08 + 12) = 0;
              goto LABEL_65;
            }

            __int16 v21 = (unsigned __int8 *)*v2;
            int v22 = **v2;
            int v23 = (*v2)[1];
            uint64_t v24 = (*v2)[2];
            if ((*v2)[3] == ~(v23 + **v2 + v24))
            {
              if ((v22 & 0x40) != 0)
              {
                LOWORD(v_Block_object_dispose(va, 8) = v8 - 2;
                *((_WORD *)v2 + 4) = v8;
                __int16 v25 = &v21[(unsigned __int16)v8];
                CFRange v26 = v21[1];
                uint64_t v24 = v21[2];
              }

              else
              {
                __int16 v25 = 0LL;
                CFRange v26 = (*v2)[1];
              }

              __int128 v35 = (v26 >> 4) | (16 * v24);
              if ((unsigned __int16)v8 - 4 == (_DWORD)v35)
              {
                int v36 = v23 & 0xF;
                if ((_DWORD)v36 == 15)
                {
                  sub_10009A5F0(v21 + 4, (v26 >> 4) | (16 * v24));
                  goto LABEL_64;
                }

                if (dword_1008F1F7C != 2) {
                  goto LABEL_64;
                }
                sub_10009A58C();
                if ((v22 & 0x40) == 0)
                {
LABEL_42:
                  sub_10009C0E0((v22 >> 3) & 7);
                  switch((int)v36)
                  {
                    case 0:
                      goto LABEL_64;
                    case 1:
                    case 2:
                    case 4:
                      if ((v22 & 0x80000000) == 0)
                      {
                        if (sub_1000A86F0())
                        {
                          sub_1001EE134( (uint64_t)"Data packets expected to have reliable flag set",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v84);
                          uint64_t v52 = (os_log_s *)sub_100086554(0x3Au);
                          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                          {
                            v82 = sub_1001EDDCC();
                            *(_DWORD *)buf = 136446466;
                            *(void *)&uint8_t buf[4] = v82;
                            *(_WORD *)&buf[12] = 1024;
                            *(_DWORD *)&_BYTE buf[14] = 0xFFFF;
                            _os_log_error_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
                          }
                        }
                      }

                      id v53 = v22 & 7;
                      if ((v22 & 7) == byte_1008DDD10)
                      {
                        byte_1008DDD10 = (v22 + 1) & 7;
                        sub_10009C1EC(v53);
                        goto LABEL_63;
                      }

                      break;
                    case 3:
                      if ((v22 & 0x80000000) != 0)
                      {
                        if (sub_1000A86F0())
                        {
                          sub_1001EE134( (uint64_t)"Reliable flag not expected on SCO data packet",  v75,  v76,  v77,  v78,  v79,  v80,  v81,  v84);
                          id v16 = (os_log_s *)sub_100086554(0x3Au);
                          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_39;
                          }
                        }
                      }

                      else
                      {
LABEL_63:
                        *(void *)&buf[8] = 0LL;
                        *(void *)buf = mach_continuous_time();
                        buf[8] = 0;
                        sub_10012F73C(v36, (unsigned __int8 *)*v2 + 4, v35, (uint64_t)buf);
                      }

                      break;
                    default:
                      if (sub_1000A86F0())
                      {
                        sub_1001EE134((uint64_t)"Unknown packet type", v68, v69, v70, v71, v72, v73, v74, v84);
                        id v16 = (os_log_s *)sub_100086554(0x3Au);
                        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_39;
                        }
                      }

                      break;
                  }

                  goto LABEL_64;
                }

                if (HIBYTE(word_1008F1F78))
                {
                  v85 = -1;
                  sub_1001EDCD4(*v2, *((unsigned __int16 *)v2 + 4), &v85);
                  sub_1001EDD10(v85, &v86);
                  sub_1001EE134( (uint64_t)"Data integrity error - discarding packet\n%@",  v54,  v55,  v56,  v57,  v58,  v59,  v60,  (uint64_t)*v2);
                  id v16 = (os_log_s *)sub_100086554(0x3Au);
                  if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_64;
                  }
                }

                else
                {
                  sub_1001EE134((uint64_t)"Data integrity bit not allowed", v61, v62, v63, v64, v65, v66, v67, v84);
                  id v16 = (os_log_s *)sub_100086554(0x3Au);
                  if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_64;
                  }
                }
              }

              else
              {
                sub_1001EE134( (uint64_t)"Wrong packet length header says %d read %d bytes",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v35);
                id v16 = (os_log_s *)sub_100086554(0x3Au);
                if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_64;
                }
              }
            }

            else
            {
              sub_1001EE134((uint64_t)"Header checksum error", v28, v29, v30, v31, v32, v33, v34, v84);
              id v16 = (os_log_s *)sub_100086554(0x3Au);
              if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                goto LABEL_64;
              }
            }

  uint64_t v31 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__p = 136315394;
    *(void *)&__p[4] = v10;
    v39 = 2080;
    __int16 v40 = p_str;
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "Did not change user defined name from %s updated to %s",  __p,  0x16u);
  }

  byte_1008F0F20[v33] = v44 + ~(_BYTE)v33;
  if (v44 >= 240)
  {
    v46 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_FAULT)) {
      sub_10067E9D4(v46);
    }
  }

            unsigned __int8 v30 = v7;
            char v37 = &v5[24 * v7];
            *(_DWORD *)char v37 = v8;
            *((_WORD *)v37 + 2) = 106;
            if (v9)
            {
              uint64_t v38 = strlen(v9);
              v39 = 256LL;
              if (v38 < 0x100) {
                v39 = v38;
              }
              __int16 v40 = v39 + 1;
              v41 = (char *)malloc(v39 + 1);
              *(void *)&v5[24 * v7 + 8] = v41;
              strlcpy(v41, v9, v40);
            }

            else
            {
              char v19 = 0;
LABEL_69:
              __int16 v42 = (char *)malloc(0xBuLL);
              *(void *)&v5[24 * v30 + 8] = v42;
              if (v19) {
                snprintf(v42, 0xBuLL, "%u", v19);
              }
              else {
                os_log_s *v42 = 0;
              }
            }

            *(_DWORD *)&v5[24 * v30 + 16] = strlen(*(const char **)&v5[24 * v30 + 8]);
            ++v7;
          }

          else
          {
            __int128 v33 = (os_log_s *)qword_1008F75D0;
            if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR))
            {
              sub_1003CF00C(v32, buf);
              int v34 = buf;
              if (v50 < 0) {
                int v34 = *(uint8_t **)buf;
              }
              *(_DWORD *)id v51 = 136446210;
              *(void *)uint64_t v52 = v34;
              _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "Ignoring 'image handle' attribute request as device %{public}s did not establish BIP",  v51,  0xCu);
              if (v50 < 0) {
                operator delete(*(void **)buf);
              }
            }
          }

  int v23 = sub_1002E6E00();
  sub_10002418C(buf, "CoexConnectionScanParameters");
  sub_10002418C(__p, "CoexConnectionScanIntervalWithAudio");
  uint64_t v24 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v23 + 88LL))(v23, buf, __p, &v172);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v24) {
      goto LABEL_76;
    }
  }

  else if (!v24)
  {
    goto LABEL_76;
  }

  __int16 v25 = v172;
  CFRange v26 = (os_log_s *)qword_1008F7620;
  if (v172)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(double *)&uint8_t buf[4] = (double)v25 * 0.625;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Warning: Override fFastConnectionScanIntervalMsCoexCarPlayWithAudio=%fms",  buf,  0xCu);
      LOWORD(v25) = v172;
    }

    *(_WORD *)(a1 + 272) = v25;
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
  {
    sub_100696DC0();
  }

  CFRange v26 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionMaskDecisionLogic");
  BOOL v27 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t *))(*(void *)v26 + 88LL))(v26, buf, __p, &v59);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v27) {
      goto LABEL_72;
    }
  }

  else if (!v27)
  {
    goto LABEL_72;
  }

  uint64_t v28 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v59;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionMaskDecisionLogic (%d)",  buf,  8u);
  }

void sub_10002DC40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002DD10(uint64_t a1)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_10087FAF8);
  }
  int v2 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 32));
  uint64_t v3 = (v2 + 310000);
  if (v2) {
    BOOL v4 = (_DWORD)v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4
    && dword_1008D61B0 <= 90
    && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
  {
    uint64_t v5 = CUPrintErrorCode(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack _updateNonConnectable]_block_invoke",  90LL,  "### Advertising NC stop failed: %@",  v6);
  }

void sub_10002DDF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10002DE04(uint64_t a1)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_10087FAF8);
  }
  int v2 = sub_100572984((uint64_t)off_1008D6280, *(void *)(a1 + 32), a1 + 40, 1);
  uint64_t v3 = (v2 + 310000);
  if (v2) {
    BOOL v4 = (_DWORD)v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4
    && dword_1008D61B0 <= 90
    && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
  {
    uint64_t v5 = CUPrintErrorCode(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack _updateNonConnectable]_block_invoke_2",  90LL,  "### Advertising NC start failed: %@",  v6);
  }

void sub_10002DEEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

LABEL_46:
  __int16 v25 = &off_10087FAE8;
  if (v26) {
    sub_1002CD254(v26);
  }
}

  BOOL v27 = v34;
  if (v34)
  {
    uint64_t v28 = (unint64_t *)&v34->__shared_owners_;
    do
      uint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
}

    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __p));
    id v17 = (id)qword_1008D9ED0;
    id v18 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v17 dispatchQueue]);
    char v19 = v18;
    if (v18)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100076274;
      block[3] = &unk_100881038;
      void block[5] = v14;
      void block[6] = v4;
      __int16 v21 = v9;
      block[4] = v17;
      dispatch_async(v18, block);
    }

    goto LABEL_49;
  }

  if (dword_1008D66A0 <= 50 && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 50LL))) {
    LogPrintF_safe( &dword_1008D66A0,  "void _pairingPincodeCallback(BTPairingAgent _Nonnull, BTDevice _Nonnull, uint8_t, void * _Nonnull)",  50LL,  "Pairing agent pincode callback: overriding pincode to 0000");
  }
  strcpy((char *)__p, "0000");
  sub_100532E28((char *)&v25, (char *)__p);
  id v15 = sub_100526EC0(v7, v4, &v25);
  nullsub_63(&v25, v16);
  if (!v15) {
    goto LABEL_46;
  }
  int v12 = (v15 + 310000);
  if (!(_DWORD)v12) {
    goto LABEL_46;
  }
  if (dword_1008D66A0 <= 90 && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 90LL)))
  {
LABEL_33:
    uint64_t v13 = CUPrintErrorCode(v12);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    LogPrintF_safe( &dword_1008D66A0,  "void _pairingPincodeCallback(BTPairingAgent _Nonnull, BTDevice _Nonnull, uint8_t, void * _Nonnull)",  90LL,  "### Set pincode failed: %@",  v14);
LABEL_49:
  }

                sub_100102510((unsigned __int16 *)*v1, 0, (uint64_t)v7);
              }
            }

            continue;
          }

          if (off_1008F29E0) {
            off_1008F29E0(v7, 81LL, 779LL, 408LL);
          }
          void *v5 = 6;
          sub_1001EE2A0();
          BOOL v4 = *v5;
        }

        if (v4 == 6)
        {
          if (BYTE2(qword_1008F29F0[134 * i + 1]) && (uint64_t v11 = *v2, (_DWORD)v11))
          {
            int v12 = 0LL;
            uint64_t v13 = &qword_1008F29F0[134 * i];
            uint64_t v14 = v13[8];
            id v15 = *((unsigned __int8 *)v13 + 76);
            id v16 = (unsigned __int8 *)(v14 + 1);
            while (1)
            {
              id v17 = *v16;
              v16 += 64;
              if (v17 == v15) {
                break;
              }
              if (v11 == ++v12) {
                goto LABEL_29;
              }
            }
          }

          else
          {
LABEL_29:
            LODWORD(v12) = 0;
          }

          id v18 = &qword_1008F29F0[134 * i];
          uint64_t v20 = *((_DWORD *)v18 + 20);
          char v19 = v18 + 10;
          __int16 v21 = v19[9];
          int v22 = v19 - 4;
          int v23 = *(unsigned __int8 *)(*((void *)v19 - 2) + (v21 << 6) + 1);
          if (v20 == v23)
          {
            if (!sub_10008D8B4(*v1)) {
              continue;
            }
          }

          else
          {
            CFDictionaryRef v19 = v23;
          }

          if (sub_10008D8B4(*v1))
          {
            uint64_t v24 = *(unsigned __int8 *)(*v22 + (v21 << 6) + 1);
            __int16 v25 = HIDWORD(qword_1008F29F0[134 * i + 10]);
            if (v25 != v24)
            {
              CFRange v26 = *v2;
              if ((_DWORD)v26)
              {
                BOOL v27 = 0LL;
                uint64_t v28 = 0;
                uint64_t v29 = 0;
                unsigned __int8 v30 = (unsigned __int8 *)(*v22 + 1LL);
                do
                {
                  int v32 = *v30;
                  v30 += 64;
                  uint64_t v31 = v32;
                  if (v32 == v24) {
                    uint64_t v29 = v27;
                  }
                  if (v25 == v31) {
                    uint64_t v28 = v27;
                  }
                  ++v27;
                }

                while (v26 != v27);
              }

              else
              {
                uint64_t v29 = 0;
                uint64_t v28 = 0;
              }

              if (v29 <= v28) {
                int v34 = v28;
              }
              else {
                int v34 = v29;
              }
            }
          }

          if ((_DWORD)v12 != (_DWORD)v21)
          {
            if (*(_BYTE *)(*v22 + ((unint64_t)v12 << 6) + 1) == 1)
            {
              if ((sub_1000A86F0() & 1) != 0)
              {
                __int128 v35 = v21;
                v46 = sub_100100080(*(unsigned __int8 *)(*v22 + ((unint64_t)v21 << 6) + 1));
                sub_1001EE134((uint64_t)"Upgrade requested to tech %s", v47, v48, v49, v50, v51, v52, v53, (uint64_t)v46);
                v54 = (os_log_s *)sub_100086554(0x57u);
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_70;
                }
              }

              else
              {
                __int128 v35 = v21;
              }

                                          else {
                                            uint64_t v11 = v11;
                                          }
                                          if (HIBYTE(v61))
                                          {
                                            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth"
                                                                   "_base/Stack/vsc/aci/aci_vsc.c");
                                          }

                                          else if (WORD1(v61) - WORD2(v61) > 1)
                                          {
                                            if (BYTE6(v61) == 2)
                                            {
                                              *(_WORD *)(v60 + WORD2(v61)) = v11;
                                              v41 = WORD2(v61) + 2;
                                              WORD2(v61) += 2;
                                              __int16 v42 = v60;
                                              if (HIBYTE(v61))
                                              {
                                                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluet"
                                                                       "ooth_base/Stack/vsc/aci/aci_vsc.c");
                                                uint64_t v43 = 0;
                                              }

                                              else
                                              {
                                                uint64_t v43 = WORD1(v61) - v41;
                                              }

                                              if (v43 < (int)v11)
                                              {
                                                v58 = "ByteStream_NumReadBytesAvail(bs) >= (blobLen)";
                                              }

                                              else
                                              {
                                                if (BYTE6(v61) == 2)
                                                {
                                                  memmove((void *)(v42 + v41), a8, v11);
                                                  __int16 v44 = WORD2(v61) + v11;
                                                  WORD2(v61) += v11;
                                                  int v45 = v60;
                                                  if (HIBYTE(v61))
                                                  {
                                                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileB"
                                                                           "luetooth_base/Stack/vsc/aci/aci_vsc.c");
                                                    v46 = 0;
                                                  }

                                                  else
                                                  {
                                                    v46 = WORD1(v61) - v44;
                                                  }

                                                  if (v46 < (int)v11)
                                                  {
                                                    v59 = "ByteStream_NumReadBytesAvail(bs) >= (blobLen)";
                                                  }

                                                  else
                                                  {
                                                    if (BYTE6(v61) == 2)
                                                    {
                                                      memmove((void *)(v45 + v44), __src, v11);
                                                      char v37 = BYTE4(v61) + v11;
                                                      WORD2(v61) += v11;
                                                      return sub_10018BD78( 64985,  v60,  v37,  a10,  (uint64_t)sub_1000BC408,  v20,  v21,  v22);
                                                    }

                                                    v59 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                                                  }

                                                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1410,  v59);
                                                }

                                                v58 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                                              }

                                              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1409,  v58);
                                            }

                                            v57 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_108:
                                            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1408,  v57);
                                          }

                                          v57 = "ByteStream_NumReadBytesAvail(bs) >= 2";
                                          goto LABEL_108;
                                        }

                                        v56 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_104:
                                        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1386,  v56);
                                      }
                                    }

                                    v56 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                                    goto LABEL_104;
                                  }

                                  id v55 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_100:
                                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1385,  v55);
                                }
                              }

                              id v55 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                              goto LABEL_100;
                            }

                            v54 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_96:
                            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1384,  v54);
                          }
                        }

                        v54 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                        goto LABEL_96;
                      }

                      id v53 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_92:
                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1382,  v53);
                    }
                  }

                  id v53 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                  goto LABEL_92;
                }

                uint64_t v52 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_88:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1381,  v52);
              }

              uint64_t v52 = "ByteStream_NumReadBytesAvail(bs) >= 1";
              goto LABEL_88;
            }

            id v51 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_84:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1380,  v51);
          }

          id v51 = "ByteStream_NumReadBytesAvail(bs) >= (6)";
          goto LABEL_84;
        }

        char v50 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_80:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c", 1379, v50);
      }
    }

    char v50 = "ByteStream_NumReadBytesAvail(bs) >= 1";
    goto LABEL_80;
  }

  return result;
}

      __src += (unsigned __int16)v27;
      v2 -= v27;
      int v34 = qword_1008E2BF0;
      if (!*(_WORD *)(qword_1008E2BF0 + 2042))
      {
LABEL_47:
        if (*(_BYTE *)(v34 + 2040))
        {
          sub_1001845F8();
        }

        else
        {
          sub_100184674();
        }
      }
    }

    while ((_WORD)v2);
  }

    *(_BYTE *)(a4 + 10) = 0;
    goto LABEL_3;
  }

  if (!v23)
  {
    if (!sub_100185B88(a1))
    {
      uint64_t v24 = 2LL;
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Remote device doesn't support our mandatory mode, can't negotiate.",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  v100);
        v80 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
          goto LABEL_57;
        }
        return 2LL;
      }

      return v24;
    }

    goto LABEL_45;
  }

  uint64_t v24 = 2LL;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to negotiate mode.", v25, v26, v27, v28, v29, v30, v31, v100);
    int v32 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    return 2LL;
  }

  return v24;
}

  v63 = (unsigned __int16 *)sub_10012E08C((int *)a4);
  if (!v63)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Could not create connection for address %:",  v66,  v67,  v68,  v69,  v70,  v71,  v72,  (uint64_t)(a4 + 1));
      v73 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return;
  }

  v64 = v63;
  sub_1000B0400((uint64_t)(v63 + 160));
  *v64 = a2;
  *((_BYTE *)v64 + 124) = 3;
  v64[40] = a6;
  v64[41] = a7;
  v64[42] = a8;
  *((_BYTE *)v64 + 11_Block_object_dispose(va, 8) = a9;
  *((_BYTE *)v64 + 70) = v25;
  *((void *)v64 + 13) = 0x148001B0148001BLL;
  *((_DWORD *)v64 + 33) = 0;
  *((void *)v64 + 1_Block_object_dispose(va, 8) = 0x100000001LL;
  if ((v130 & 1) != 0)
  {
    v65 = (unsigned __int16)word_1008E8960;
    v64[43] = word_1008E8960;
    if (!v65) {
      goto LABEL_54;
    }
  }

  else
  {
    LOWORD(v65) = v64[43];
    if (!(_WORD)v65)
    {
LABEL_54:
      LOWORD(v65) = 10;
      v64[43] = 10;
    }
  }

  uint64_t v74 = 8 * sub_1001ACFFC(27, 27, (unsigned __int16)(625 * v65), 1, 1);
  if (v74) {
    uint64_t v74 = v74 * (0x3E8u / (int)((double)a6 * 1.25)) / 0x3E8;
  }
  *((_DWORD *)v64 + 53) = v74;
  *((_DWORD *)v64 + 54) = sub_1001ACFFC( v64[54],  v64[52],  (unsigned __int16)(625 * v64[43]),  *((_DWORD *)v64 + 36),  *((_DWORD *)v64 + 37));
  *((_BYTE *)v64 + 24) = 0;
  *((_DWORD *)v64 + 5) = 0;
  v75 = (_DWORD *)((char *)v64 + 63);
  if (*((_BYTE *)v64 + 70))
  {
    sub_1001BDFB4((uint64_t)v75);
    if (v54) {
      goto LABEL_59;
    }
  }

  else
  {
    *v75 = dword_1008E8943;
    *(unsigned __int16 *)((char *)v64 + 67) = word_1008E8947;
    *((_BYTE *)v64 + 69) = byte_1008E8949;
    if (v54)
    {
LABEL_59:
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Disconnecting duplicate lmHandle=0x%x", v76, v77, v78, v79, v80, v81, v82, *v64);
        v83 = (os_log_s *)sub_100086554(0x42u);
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
        {
          v84 = sub_1001EDDCC();
          *(_DWORD *)buf = 136446210;
          v134 = v84;
          _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      *((_BYTE *)v64 + 124) = 0;
      v85 = sub_100128D24(5LL);
      v86 = sub_100136C78((uint64_t)v64, v85);
      if ((_DWORD)v86)
      {
        v87 = v86;
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Could not disconnect LE device %!", v88, v89, v90, v91, v92, v93, v94, v87);
          v95 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }
      }

      else
      {
        *((_BYTE *)v64 + 124) = 7;
      }

      int v34 = (unsigned __int8 *)(v64 + 24);
      __int128 v35 = (uint64_t)v64;
      int v36 = 157LL;
      goto LABEL_72;
    }
  }

  *((_BYTE *)v64 + 55) = v53;
  if (v53)
  {
    *((_DWORD *)v64 + 14) = v132[0];
    v64[30] = v132[1];
    *((_BYTE *)v64 + 62) = BYTE2(v132[1]);
  }

  sub_1001B7E30((unsigned __int8 *)v64 + 48, (uint64_t)v64, 0LL, a11);
  *((_BYTE *)v64 + 124) = 0;
  sub_10012F008((uint64_t)v64, v96);
}
}

  if ((v16 & 1) == 0 && v8 == v5 && os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
  {
    sub_100531170((void *)a2, &v42);
    sub_10067FCD8();
  }

  return sub_100242FAC((uint64_t)v40);
}

        id v17 = (char *)v17 + 1;
      }

      while (v15 != v17);
      id v15 = [obj countByEnumeratingWithState:&v38 objects:v45 count:16];
    }

    while (v15);
  }

  return v33;
}

  uint64_t v3 = 0LL;
LABEL_47:
  uint64_t v31 = &off_10087FAA8;
  if (v32) {
    sub_1002CD254(v32);
  }
  return v3;
}

  if (a3 >= 0x308) {
    char v37 = 0.35;
  }
  else {
    char v37 = 0.75;
  }
  uint64_t v38 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v38 + 424LL))(v38))
  {
    v39 = sub_100241F94(uu);
    __int16 v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    if (sub_1005D4FEC((uint64_t)off_1008D5F28, v40))
    {
      if (a3 > 0xB)
      {
        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        __int16 v44 = off_1008D5F28;
        sub_10002418C(v79, "HIDDevicePoorBehavior");
        int v45 = sub_1005CE5A8((uint64_t)v44, v40, (uint64_t)v79);
        if (v80 < 0) {
          operator delete(v79[0]);
        }
        if (v45)
        {
          v46 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
          {
            sub_100366664(uu, buf);
            v47 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
            *(_DWORD *)__p = 136446210;
            *(void *)&__p[4] = v47;
            _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_INFO,  "Connection Update: Unsetting tag for LE_HID %{public}s.",  __p,  0xCu);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
          }
          sub_1005C9A38((uint64_t)off_1008D5F28, v40, @"HIDDevicePoorBehavior");
        }
      }

      else
      {
        v41 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, 37);
          uuid_unparse_upper(uu, buf);
          sub_10002418C(__p, buf);
          __int16 v42 = v100 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)v92 = 136446466;
          *(void *)&v92[4] = v42;
          v93 = 1024;
          v94 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Connection Update: LE HID %{public}s has interval less than 15ms: %d. Setting tag.",  v92,  0x12u);
          if (SHIBYTE(v100) < 0) {
            operator delete(*(void **)__p);
          }
        }

        if (qword_1008D5F30 != -1) {
          dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
        }
        uint64_t v43 = off_1008D5F28;
        sub_10002418C(v81, "HIDDevicePoorBehavior");
        sub_1005CCF08((uint64_t)v43, v40, (unsigned __int8 *)v81);
        if (v82 < 0) {
          operator delete(v81[0]);
        }
      }
    }
  }

  CFPropertyListRef v48 = (int)(v37 * (double)(10 * a5) / ((double)a3 * 1.25));
  v49 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    memset(buf, 0, 37);
    uuid_unparse_upper(uu, buf);
    sub_10002418C(v92, buf);
    char v50 = v95 >= 0 ? v92 : *(_BYTE **)v92;
    *(_DWORD *)__p = 136446978;
    *(void *)&__p[4] = v50;
    v97 = 1024;
    v98 = (int)(v37 * (double)(10 * a5) / ((double)a3 * 1.25));
    v99 = 1024;
    v100 = a3;
    v101 = 1024;
    v102 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Connection Update: setting LE device %{public}s connection threshold to %d events with interval %d, LSTO %d",  __p,  0x1Eu);
    if (v95 < 0) {
      operator delete(*(void **)v92);
    }
  }

  id v51 = sub_1002E6BF0();
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  uint64_t v52 = (uint64_t)off_1008D5F28;
  id v53 = sub_100241F94(uu);
  v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
  LOBYTE(v52) = sub_1005D2760(v52, v54);

  if ((v52 & 1) != 0)
  {
LABEL_89:
    id v55 = sub_1002E6E9C();
    if (v48 >= 0xFF) {
      v56 = 255LL;
    }
    else {
      v56 = v48;
    }
    if ((*(unsigned int (**)(uint64_t, unint64_t, uint64_t))(*(void *)v55 + 1056LL))(v55, v84, v56)
      && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      sub_1006990D4();
    }
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
  }
  v57 = off_1008D5F28;
  v58 = sub_100241F94(uu);
  v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
  sub_1005D46CC((uint64_t)v57, v59, a3);

  v85[0] = _NSConcreteStackBlock;
  v85[1] = 3321888768LL;
  v85[2] = sub_1005AF08C;
  v85[3] = &unk_1008A2710;
  uuid_copy(v91, uu);
  v86 = a3;
  v87 = a4;
  v88 = a5;
  v89 = v76;
  v90 = v77;
  sub_10058C72C((os_unfair_lock_s *)a1, v85);
  return sub_100242FAC((uint64_t)v83);
}

  for (uint64_t i = 256; i != 262; ++i)
  {
    v137[0] = i;
    *(void *)buf = v137;
    uint64_t v20 = sub_10060F298((uint64_t **)(a1 + 1816), v137, (uint64_t)&unk_1006C2518, (char **)buf);
    *((_WORD *)v20 + 14) = 255;
    *((_WORD *)v20 + 15) = i;
    v20[4] = 0LL;
    __int16 v21 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67110144;
      *(_DWORD *)&uint8_t buf[4] = i;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = 255;
      *(_WORD *)&_BYTE buf[14] = 1024;
      *(_DWORD *)&uint8_t buf[16] = 0;
      *(_WORD *)v142 = 1024;
      *(_DWORD *)&v142[2] = 0;
      *(_WORD *)v143 = 1024;
      *(_DWORD *)&v143[2] = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "MATCH TABLE Setting up table entry handle:%d type:%d length:%d created:%d enabled:%d",  buf,  0x20u);
    }
  }

  *(void *)v137 = 0LL;
  int v22 = sub_1002E6E00();
  sub_10002418C(buf, "ADVBUFF");
  sub_10002418C(__p, "OverrideAPWakeDebounceTimerSeconds");
  int v23 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned __int8 *))(*(void *)v22 + 144LL))( v22,  buf,  __p,  v137);
  if (*(void *)v137) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = 0;
  }
  if (v140 < 0) {
    operator delete(__p[0]);
  }
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v24) {
      goto LABEL_61;
    }
  }

  else if (!v24)
  {
    goto LABEL_61;
  }

  __int16 v25 = 1000LL * *(void *)v137;
  *(void *)(a1 + 212_Block_object_dispose(va, 8) = 1000LL * *(void *)v137;
  CFRange v26 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding fApWakeReadADVBuffersDebounceDelta with %llu seconds",  buf,  0xCu);
  }

  *(_DWORD *)__s = 0;
  *(_WORD *)(a1 + 156) = 94;
  uint64_t v20 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "MaxConnPerBundleIDFromFindMyClient");
  __int16 v21 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v20 + 88LL))(v20, buf, __p, __s);
  if (*(_DWORD *)__s) {
    int v22 = v21;
  }
  else {
    int v22 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v22) {
      goto LABEL_57;
    }
  }

  else if (!v22)
  {
    goto LABEL_57;
  }

  int v23 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 156) = *(_WORD *)__s;
  uint64_t v24 = (os_log_s *)qword_1008F7698;
  if (os_log_type_enabled((os_log_t)qword_1008F7698, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding - MaxConnPerBundleIDFromFindMyClient %d",  buf,  8u);
  }

void sub_10002E260(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002E2DC(uint64_t a1)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_10087FAF8);
  }
  int v2 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 32));
  uint64_t v3 = (v2 + 310000);
  if (v2) {
    BOOL v4 = (_DWORD)v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4
    && dword_1008D61B0 <= 90
    && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
  {
    uint64_t v5 = CUPrintErrorCode(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack _updateNonConnectableContact]_block_invoke",  90LL,  "### Advertising NC 1 stop failed: %@",  v6);
  }

void sub_10002E3BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10002E3D0(uint64_t a1)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_10087FAF8);
  }
  int v2 = sub_100572984((uint64_t)off_1008D6280, *(void *)(a1 + 32), a1 + 40, 1);
  uint64_t v3 = (v2 + 310000);
  if (v2) {
    BOOL v4 = (_DWORD)v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4
    && dword_1008D61B0 <= 90
    && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
  {
    uint64_t v5 = CUPrintErrorCode(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack _updateNonConnectableContact]_block_invoke_2",  90LL,  "### Advertising NC 1 start failed: %@",  v6);
  }

void sub_10002E4B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10002E6F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  _Unwind_Resume(a1);
}

void sub_10002E754(uint64_t a1)
{
  if (qword_1008D6288 != -1) {
    dispatch_once(&qword_1008D6288, &stru_10087FAF8);
  }
  int v2 = sub_100575180((uint64_t)off_1008D6280, *(void *)(a1 + 32));
  uint64_t v3 = (v2 + 310000);
  if (v2) {
    BOOL v4 = (_DWORD)v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4
    && dword_1008D61B0 <= 90
    && (dword_1008D61B0 != -1 || _LogCategory_Initialize(&dword_1008D61B0, 90LL)))
  {
    uint64_t v5 = CUPrintErrorCode(v3);
    id v6 = (id)objc_claimAutoreleasedReturnValue(v5);
    LogPrintF_safe( &dword_1008D61B0,  "-[CBStackBLEAdvertiserBTStack _updateNonConnectableObjectDiscovery]_block_invoke",  90LL,  "### Advertising NC Object Discovery stop failed: %@",  v6);
  }

void sub_10002E834( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

_OWORD *sub_10002E92C(uint64_t **a1, unsigned __int8 *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v11 = 0LL;
  id v6 = (void **)sub_10002E9C8((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x48uLL);
    int v9 = *((_DWORD *)*a4 + 4);
    v7[2] = **a4;
    *((_DWORD *)v7 + 12) = v9;
    *((void *)v7 + 7) = &off_10087FAA8;
    *((void *)v7 + _Block_object_dispose(va, 8) = 0LL;
    sub_100029630(a1, v11, v8, (uint64_t *)v7);
  }

  return v7;
}

void *sub_10002E9C8(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (void *)v4;
        uint64_t v8 = (unsigned __int8 *)(v4 + 32);
        uint64_t v4 = *v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      if (!sub_10063447C(v8, a3)) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }

    while (v4);
  }

  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }

LABEL_9:
  *a2 = v7;
  return v5;
}

  uint64_t v11 = 0LL;
  int v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  id v15 = 0LL;
  id v16 = 0LL;
LABEL_31:

  if (-[CBAdvertiserDaemon _wiProxUpdateLinger:active:](self, "_wiProxUpdateLinger:active:", a3, v11))
  {
    uint64_t v31 = 13312;
    BOOL v27 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v31, 2LL);

    id v15 = 50LL;
    id v16 = (NSMutableData *)v27;
  }

  -[CBAdvertiserDaemon _wiProxUpdatePayload:payloadData:advertiseRate:advertiseEnableEPA:]( self,  "_wiProxUpdatePayload:payloadData:advertiseRate:advertiseEnableEPA:",  a3,  v16,  v15,  0LL);
}

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v28, 8);
}

      uint64_t v3 = v5 + 1;
      if (v5 + 1 == dword_1008F29B4) {
        return;
      }
    }

    if (!a1) {
      return;
    }
LABEL_12:
    int v9 = &qword_1008F29F0[134 * v5 + 12];
    if (a3) {
      uint64_t v10 = *(_DWORD *)v9 + 1;
    }
    else {
      uint64_t v10 = 0;
    }
    *(_DWORD *)int v9 = v10;
    if (a2) {
      qword_1008F29F0[134 * v5 + 11] = (uint64_t)vadd_s32((int32x2_t)qword_1008F29F0[134 * v5 + 11], vdup_n_s32(a2));
    }
    sub_100089F9C(0LL, a2, (unsigned __int16)v5);
  }

      id v1 = v3 + 1;
      if ((_DWORD)v3 + 1 == dword_1008F29B4) {
        return;
      }
    }

    if (!a1) {
      return;
    }
LABEL_12:
    if (LODWORD(qword_1008F29F0[134 * v3 + 9]))
    {
      uint64_t v8 = &qword_1008F29F0[134 * v3];
      uint64_t v10 = v8[8];
      int v9 = v8 + 8;
      if (!v10)
      {
        sub_1001EE2A0();
        uint64_t v5 = *v4;
      }

      if (!v5) {
        sub_1001EE2A0();
      }
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Updating TS LE throughput: index %d handle 0x%x throughput %d -> %d",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v3);
        id v18 = (os_log_s *)sub_100086554(0x57u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = sub_1001EDDCC();
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      *(_DWORD *)(*v9 + 4) = *(_DWORD *)(*v4 + 212);
    }
  }

      if (++v2 == dword_1008F29B4) {
        return;
      }
    }

    if (!a1) {
      return;
    }
LABEL_14:
    if (LODWORD(qword_1008F29F0[134 * v2 + 9]))
    {
      uint64_t v8 = &qword_1008F29F0[134 * v2];
      uint64_t v10 = v8[8];
      int v9 = v8 + 8;
      if (!v10)
      {
        sub_1001EE2A0();
        uint64_t v5 = *v4;
      }

      if (!v5) {
        sub_1001EE2A0();
      }
      if (sub_1000913F0(v1))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Updating TS HDR throughput: index %d throughput %d -> 4500",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  dword_1008F29B4);
          id v18 = (os_log_s *)sub_100086554(0x57u);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v20 = sub_1001EDDCC();
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        *(_DWORD *)(*v9 + 6_Block_object_dispose(va, 8) = 4500;
      }
    }
  }

  uint64_t v14 = *((unsigned __int8 *)v5 + 95);
  if (v14 == 4)
  {
    sub_1000A5F94(*(unsigned __int16 *)v5);
  }

  else if (v14 == 1)
  {
    id v15 = sub_1000A76A0(*(unsigned __int16 *)v5);
    if (v15) {
      sub_1000A5EC0(*(unsigned __int16 *)v5, v15);
    }
  }

  sub_1000A5EC0(a1, v3);
}

  sub_1000A5EC0(a1, v3);
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"DisconnectTransport failed with %! for transport %!", v7, v8, v9, v10, v11, v12, v13, v6);
    uint64_t v14 = (os_log_s *)sub_100086554(0x18u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"AVDTP_CONNECT_CFM(addr=%:,result=%!)", v10, v11, v12, v13, v14, v15, v16, (uint64_t)&v32);
    id v17 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      id v18 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      __int128 v35 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  *(_WORD *)buf = 0;
  char v19 = sub_1000D8A50(v4, buf);
  if (v19)
  {
    uint64_t v20 = v19;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"AVDTP did not find a2dp handle from CID with result %!",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v7);
      uint64_t v28 = (os_log_s *)sub_100086554(3u);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    if ((_DWORD)v7) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = v20;
    }
  }

  return (*(uint64_t (**)(int *, void, uint64_t))(*(void *)(qword_1008DFDB0 + 24) + 8LL))( &v32,  *(unsigned __int16 *)buf,  v7);
}
  }

  *((_DWORD *)i + 16_Block_object_dispose(va, 8) = a3;
  *((_DWORD *)i + 169) += a4;
  *((_DWORD *)i + 170) += a5;
  *((_WORD *)i + 344) += a7;
  int v32 = (-a13 / 0xAu - 2);
  if (a13 > -30) {
    int v32 = 0LL;
  }
  ++*((_BYTE *)i + 10 * (a11 / 0xAu) + v32 + 690);
  __int128 v33 = (char *)i + 10 * (a12 / 0xAu) + v32 + 790;
  int v34 = a6;
  __int128 v35 = a10;
LABEL_21:
  ++*v33;
  if (a15 == 2)
  {
    v47 = *((unsigned __int8 *)i + 1062);
    CFPropertyListRef v48 = (char *)i + 4 * v47;
    *((_WORD *)v48 + 446) = v34;
    v48[894] = v35;
    *((_BYTE *)i + 1062) = v47 + 1;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Disconnect BT_TS_SetTransportMetrics. leCoexDenials = %u; leRSSI = %u",
        v49,
        v50,
        v51,
        v52,
        v53,
        v54,
        v55,
        v34);
      v46 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
LABEL_28:
        *(_DWORD *)buf = 136446210;
        size_t v60 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }

  else if (a15 == 1)
  {
    char v37 = *((unsigned __int8 *)i + 1063);
    uint64_t v38 = (char *)i + 4 * v37;
    *((_WORD *)v38 + 486) = a7;
    v38[974] = a13;
    *((_BYTE *)i + 1063) = v37 + 1;
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Disconnect BT_TS_SetTransportMetrics. coexDenials = %u; classicRSSI = %u",
        v39,
        v40,
        v41,
        v42,
        v43,
        v44,
        v45,
        a7);
      v46 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_28;
      }
    }
  }

  *((_BYTE *)i + 1062) %= 0x14u;
  *((_BYTE *)i + 1063) %= 0x14u;
}
  }

  else {
    id v18 = 3;
  }
  *((_DWORD *)i + 16_Block_object_dispose(va, 8) = v18;
  *((_DWORD *)i + 169) += a2;
  *((_DWORD *)i + 170) += a3;
}

    sub_1001B9328(a1, v7, (char *)(v7 + 170));
    return;
  }

  if (a3)
  {
    if (v6) {
      goto LABEL_7;
    }
  }

  else
  {
    sub_1001EE2A0();
    if (v7)
    {
LABEL_7:
      *(void *)(v7 + 170) = *a3;
      goto LABEL_9;
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Invaid LM handle %x from LE_RemoteUsedFeatures", v16, v17, v18, v19, v20, v21, v22, a2);
    int v23 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

    sub_100657858();
    goto LABEL_10;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"There is already a pairing request for this connection. Ignoring request.",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v59);
    uint64_t v13 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
LABEL_6:
    }
      sub_100657858();
  }

  *a2 = v7;
  return v5;
}

  sub_100242FAC((uint64_t)v21);
  return v6;
}

  sub_100242FAC((uint64_t)v16);
  return 0LL;
}

    sub_10040F938(a3, 26);
    sub_10040F938(a3, 8);
    sub_10040FA14(a3, *(void *)(a1 + 528));
    return v7;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_1006624F8();
  }
  if ((_os_feature_enabled_impl("BluetoothFeatures", "ConnectionSetup") & 1) != 0) {
    goto LABEL_9;
  }
  return v7;
}

        uint64_t v8 = 0LL;
        goto LABEL_10;
      }

      return a1;
    }

    uint64_t v10 = "(dataLen) > 0";
LABEL_14:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm", 7472, v10);
  }

  if (*(_WORD *)(a1 + 16) == 30)
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/aacp/AACPClient.mm");
    goto LABEL_9;
  }

  return a1;
}

  uint64_t v7 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    if (*(_BYTE *)(a1 + 42)) {
      int v9 = "enable";
    }
    else {
      int v9 = "disable";
    }
    sub_1005BFC20(*(void *)(a1 + 32), &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315650;
    id v15 = v9;
    id v16 = 2080;
    id v17 = p_p;
    id v18 = 1024;
    char v19 = v5;
    _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Could not %s phy statistics for address %s result %d",  buf,  0x1Cu);
  }

  return v5;
}

  uint64_t v7 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_1005BFC20(*(void *)(a1 + 32), &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    uint64_t v10 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)buf = 136315650;
    id v15 = p_p;
    id v16 = 1024;
    id v17 = v10;
    id v18 = 1024;
    char v19 = v5;
    _os_log_error_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Could not config dual core phy statistics for address %s, config %d, result %d",  buf,  0x18u);
  }

  return v5;
}

  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    var0 = a5;
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = var0;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&_BYTE buf[14] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "[AudioDeviceManager publishAndRegisterDevice:] Register audio device %{public}s with XpcAudioPluginDevice: %p",  buf,  0x16u);
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = 0LL;
  sub_100242F28((uint64_t)buf, (uint64_t)&self->audioDeviceMapMutex);
  id v16 = a5;
  sub_1002EE2BC((uint64_t **)&self->audioDevices, (const void **)a5, (uint64_t)&unk_1006C2518, (__int128 **)&v16)[7] = v6;
  if (*((char *)&a5->var0.var0.var0.var1 + 23) < 0)
  {
    sub_100024238(__p, a5->var0.var0.var0.var1.var0, a5->var0.var0.var0.var1.var1);
  }

  else
  {
    *(_OWORD *)__p = *(_OWORD *)a5->var0.var0.var0.var0.var0;
    id v15 = *((void *)&a5->var0.var0.var0.var1 + 2);
  }

  -[AudioDeviceManager sendMsg:withArgs:uid:](self, "sendMsg:withArgs:uid:", v9, a4, __p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  sub_100242FAC((uint64_t)buf);
}

  uint64_t v4 = 7;
LABEL_10:
  *(_BYTE *)(a1 + 680) = v4;
LABEL_11:
  uint64_t v5 = (os_log_s *)(id)qword_1008F7578;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = *(unsigned __int8 *)(a1 + 680);
    sub_10032524C(v6, v8);
    if (v9 >= 0) {
      uint64_t v7 = v8;
    }
    else {
      uint64_t v7 = (void **)v8[0];
    }
    LODWORD(__p) = 67109378;
    HIDWORD(__p) = v6;
    int v12 = 2080;
    uint64_t v13 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "HID latency anomaly threshold bin index is %d for %s",  (uint8_t *)&__p,  0x12u);
    if (v9 < 0) {
      operator delete(v8[0]);
    }
  }
}
}

  *a2 = v7;
  return v5;
}

    ++v6;
    v5 += 32LL;
    if (v6 >= v2) {
      return 0LL;
    }
  }

  LOBYTE(a1) = sub_1003A47B8(a1, v8);
  if ((a1 & 1) == 0)
  {
    int v2 = *(unsigned int *)(v4 + 344);
    goto LABEL_9;
  }

  return *(void *)(v4 + 360) + v5;
}

  id v6 = sub_1002E6E00();
  sub_10002418C(buf, "ENForceCustomPayloadData");
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint8_t *, uint64_t))(*(void *)v6 + 120LL))(v6, buf, a1 + 120);
  uint64_t v8 = v7;
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v8) {
      goto LABEL_15;
    }
  }

  else if (!v7)
  {
    goto LABEL_15;
  }

  *(_BYTE *)(a1 + 113) = 1;
  int v9 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)buf = 67109120LL;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Overriding ENForceCustomPayload = %d ", buf, 8u);
  }

  *a2 = v5;
  return result;
}

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008950E8);
  }
  LODWORD(__p.__r_.__value_.__l.__data_) = *a2;
  WORD2(__p.__r_.__value_.__r.__words[0]) = *((_WORD *)a2 + 2);
  uint64_t v13 = (std::string *)sub_1003FFEB0(off_1008D5F48, (uint64_t)&__p, 1);
  if (!v13)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
    {
      sub_1003FE1B4((unsigned __int8 *)&v25, &__p);
      sub_100677B54();
    }

  if (*(_OWORD *)(a1 + 49) == 0LL || !*(_BYTE *)(a1 + 241))
  {
    id v16 = (os_log_s *)qword_1008F7600;
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
    {
      id v17 = *(unsigned __int8 *)(a1 + 241);
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Device not signed in / master key not available. signed in = %d",  (uint8_t *)__p,  8u);
    }

    return 1LL;
  }

  if (*(_BYTE *)(a1 + 240))
  {
    buf = 0uLL;
    sub_100242F28((uint64_t)&buf, a1 + 104);
    uint64_t v8 = *(unsigned __int8 ****)(a1 + 176);
    int v9 = *(unsigned __int8 ****)(a1 + 184);
    if (v8 == v9)
    {
LABEL_16:
      uint64_t v11 = (char *)operator new(0x78uLL);
      int v12 = v11;
      *((void *)v11 + 11) = 0LL;
      uint64_t v13 = (void **)(v11 + 88);
      *((void *)v11 + 12) = 0LL;
      *((void *)v11 + 13) = 0LL;
      v11[112] = -1;
      *(void *)uint64_t v11 = a2;
      *((_DWORD *)v11 + 21) = 0;
      *(_OWORD *)(v11 + _Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(v11 + 24) = 0u;
      *(_OWORD *)(v11 + 40) = 0u;
      *(_OWORD *)(v11 + 56) = 0u;
      *((_DWORD *)v11 + 1_Block_object_dispose(va, 8) = 0;
      BOOL v27 = (unsigned __int8 **)v11;
      if (a3) {
        *(_OWORD *)(v11 + 24) = *(_OWORD *)a3;
      }
      if (sub_1003F01F0((uint64_t *)v11, a1 + 49, a1 + 65))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
          sub_10067A628();
        }
        if (v12[111] < 0) {
          operator delete(*v13);
        }
        operator delete(v12);
        uint64_t v14 = 1LL;
        goto LABEL_62;
      }

      sub_100381E90((void **)(a1 + 176), &v27);
      if (qword_1008D67B8 != -1) {
        dispatch_once(&qword_1008D67B8, &stru_100896238);
      }
      sub_10053645C((uint64_t)off_1008D67B0, a2);
    }

    else
    {
      uint64_t v10 = *(unsigned __int8 ****)(a1 + 176);
      while (**v10 != a2)
      {
        if (++v10 == v9) {
          goto LABEL_16;
        }
      }

      while (1)
      {
        id v15 = *v8;
        if (**v8 == a2) {
          break;
        }
        if (++v8 == v9)
        {
          id v15 = 0LL;
          break;
        }
      }

      int v23 = v15[3];
      BOOL v27 = v15;
      uint64_t v24 = v23 == *(unsigned __int8 **)a3 && v15[4] == *(unsigned __int8 **)(a3 + 8);
      if (v24 && *((_DWORD *)v15 + 21) == 1)
      {
        __int16 v25 = (os_log_s *)(id)qword_1008F7600;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C((uint64_t)a2, __p);
          CFRange v26 = v32 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)uint64_t v28 = 136446210;
          uint64_t v29 = v26;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Encryption key for device %{public}s is already up to date",  v28,  0xCu);
          if (v32 < 0) {
            operator delete(__p[0]);
          }
        }

        goto LABEL_61;
      }

      if (a3) {
        *(_OWORD *)(v15 + 3) = *(_OWORD *)a3;
      }
    }

    sub_1003EF380(a1);
LABEL_61:
    uint64_t v14 = 0LL;
LABEL_62:
    sub_100242FAC((uint64_t)&buf);
    return v14;
  }

  int v22 = (os_log_s *)qword_1008F7600;
  if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "updateDeviceEncryptionKey, Magic Pairing Layer not initialized",  (uint8_t *)__p,  2u);
  }

  return 17LL;
}

  sub_100242FAC((uint64_t)v10);
  return v4;
}

  sub_100242F54((uint64_t)v18);
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100896D08);
  }
  uint64_t v10 = sub_100496954((void *)qword_1008D61A0, v19);
  if (v10)
  {
    uint64_t v11 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(v10, (uint64_t)__p);
      int v12 = (void **)__p[0];
      uint64_t v13 = "off";
      if (v17 >= 0) {
        int v12 = __p;
      }
      if (a3) {
        uint64_t v13 = "on";
      }
      *(_DWORD *)buf = 136446466;
      __int16 v21 = v12;
      int v22 = 2082;
      int v23 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s wants connectability %{public}s",  buf,  0x16u);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  uint64_t v14 = sub_1004306EC((uint64_t)off_1008D60A8);
  sub_100242FAC((uint64_t)v18);
  return v14;
}

  sub_100242F54((uint64_t)v18);
  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_100896D08);
  }
  uint64_t v10 = sub_100496954((void *)qword_1008D61A0, v19);
  if (v10)
  {
    uint64_t v11 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_100494958(v10, (uint64_t)__p);
      int v12 = (void **)__p[0];
      uint64_t v13 = "off";
      if (v17 >= 0) {
        int v12 = __p;
      }
      if (a3) {
        uint64_t v13 = "on";
      }
      *(_DWORD *)buf = 136446466;
      __int16 v21 = v12;
      int v22 = 2082;
      int v23 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Session %{public}s wants discoverability %{public}s",  buf,  0x16u);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  if (qword_1008D60B0 != -1) {
    dispatch_once(&qword_1008D60B0, &stru_100896D28);
  }
  uint64_t v14 = sub_10043153C(off_1008D60A8);
  sub_100242FAC((uint64_t)v18);
  return v14;
}

  sub_10023DF50(&__len[1]);
  sub_100242FAC((uint64_t)v14);
  return 1LL;
}

  if (sub_10010F2C0())
  {
    if (v8) {
      goto LABEL_16;
    }
    *(void *)buf = *(void *)((char *)&xmmword_1008F6D38 + 4);
    uint8_t buf[4] = BYTE8(xmmword_1008F6D38) & 0xF9;
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    sub_10010F098(buf);
    sub_100242CD0(__p);
    goto LABEL_15;
  }

  if (v8)
  {
    uint64_t v3 = sub_1002E6E9C();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 2288LL))(v3))
    {
      *(void *)buf = *(void *)((char *)&xmmword_1008F6D38 + 4);
      uint8_t buf[4] = BYTE8(xmmword_1008F6D38) | 6;
      LOBYTE(__p[0]) = 0;
      sub_100242CA4(__p);
      sub_10010F098(buf);
      sub_100242CD0(__p);
LABEL_15:
      sub_100242CD8(__p);
    }
  }

  uint64_t v8 = 131LL;
  if (!a2) {
    goto LABEL_12;
  }
LABEL_10:
  if (v10) {
    *a2 = v10;
  }
LABEL_12:
  if (v6) {
    CFRelease(v6);
  }
  return v8;
}

  *a2 = v7;
  return v5;
}

  reply = xpc_dictionary_create_reply(a2);
  if (reply)
  {
    id v16 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgStatus", v13);
    xpc_dictionary_set_uint64(v16, "kCBMsgArgHRBBand", uint64);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v16);
    xpc_release(v16);
  }

  uint64_t v5 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionDCKTimeDurationFromDisabledToStageOneValue");
  id v6 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v5 + 88LL))(v5, buf, __p, &v91);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v6) {
      goto LABEL_17;
    }
  }

  else if (!v6)
  {
    goto LABEL_17;
  }

  uint64_t v7 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v91;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDCKTimeDurationFromDisabledToStageOneValue=%d (override)",  buf,  8u);
  }

  uint64_t v5 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionWindow");
  id v6 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, unsigned int *))(*(void *)v5 + 88LL))( v5,  buf,  __p,  &v63);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v6) {
      goto LABEL_20;
    }
  }

  else if (!v6)
  {
    goto LABEL_20;
  }

  uint64_t v7 = v63;
  uint64_t v8 = (os_log_s *)qword_1008F7620;
  if (v63 >= 3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698FBC();
    }
    return 3LL;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionWindow (%d)",  buf,  8u);
  }

  *a2 = v7;
  return v5;
}

  *a2 = v7;
  return v5;
}

  *a2 = v7;
  return v5;
}

void *sub_10002EA58(void *a1)
{
  *a1 = &off_10087FAA8;
  int v2 = (unsigned int *)a1[1];
  if (v2) {
    sub_1002CD254(v2);
  }
  return a1;
}

void sub_10002EA90(void *__p)
{
  void *__p = &off_10087FAA8;
  int v2 = (unsigned int *)__p[1];
  if (v2) {
    sub_1002CD254(v2);
  }
  operator delete(__p);
}

uint64_t sub_10002EAC8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int **)(a1 + 8);
  uint64_t v4 = *(void *)(a2 + 8);
  if (v3 != (unsigned int *)v4)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = v4;
    if (v4) {
      sub_1002CD1E0(v4);
    }
    if (v3) {
      sub_1002CD254(v3);
    }
  }

  return a1;
}

void sub_10002EB10(id a1)
{
  id v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_10002EB40(_Unwind_Exception *a1)
{
}

void sub_10002EB54(void *__p)
{
  void *__p = &off_10087FAE8;
  int v2 = (unsigned int *)__p[1];
  if (v2) {
    sub_1002CD254(v2);
  }
  operator delete(__p);
}

void sub_10002EB8C(id a1)
{
  id v1 = operator new(0x42C0uLL);
  sub_10056DFB4();
  off_1008D6280 = v1;
}

void sub_10002EBBC(_Unwind_Exception *a1)
{
}

void sub_10002ED28(id a1)
{
  id v1 = objc_alloc_init(&OBJC_CLASS___CBMetricsDaemon);
  int v2 = (void *)qword_1008D9EA0;
  qword_1008D9EA0 = (uint64_t)v1;
}

void sub_10002EE74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002F294( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, void *a21)
{
  _Unwind_Resume(a1);
}

id sub_10002F3D0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _reportEvents];
}

void sub_10002F450(uint64_t a1)
{
  if (dword_1008D6290 <= 30 && (dword_1008D6290 != -1 || _LogCategory_Initialize(&dword_1008D6290, 30LL)))
  {
    uint64_t v2 = CUPrintDuration64(XPC_ACTIVITY_INTERVAL_15_MIN);
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    LogPrintF_safe( &dword_1008D6290,  "-[CBMetricsDaemon _startIfNeeded]_block_invoke",  30LL,  "XPC activity register: ID '%s', interval %@",  "com.apple.bluetooth.CBMetrics",  v3);
  }

  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_BOOL(v4, XPC_ACTIVITY_ALLOW_BATTERY, 1);
  xpc_dictionary_set_BOOL(v4, XPC_ACTIVITY_REPEATING, 1);
  xpc_dictionary_set_int64(v4, XPC_ACTIVITY_INTERVAL, XPC_ACTIVITY_INTERVAL_15_MIN);
  xpc_dictionary_set_string(v4, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10002F5D0;
  handler[3] = &unk_10087FB40;
  void handler[4] = *(void *)(a1 + 32);
  xpc_activity_register("com.apple.bluetooth.CBMetrics", v4, handler);
}

void sub_10002F5B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002F5D0(uint64_t a1, void *a2)
{
  activity = a2;
  if (xpc_activity_should_defer(activity))
  {
    if (!xpc_activity_set_state(activity, 3LL)
      && dword_1008D6290 <= 90
      && (dword_1008D6290 != -1 || _LogCategory_Initialize(&dword_1008D6290, 90LL)))
    {
      LogPrintF_safe( &dword_1008D6290,  "-[CBMetricsDaemon _startIfNeeded]_block_invoke_2",  90LL,  "XPC activity defer failed");
    }
  }

  else
  {
    [*(id *)(a1 + 32) _reportEvents];
  }
}

void sub_10002F674( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_10002F6F4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _reportAuthTagType:*(unsigned __int8 *)(a1 + 40) authTagStatus:*(unsigned __int8 *)(a1 + 41) integrityTagStatus:*(unsigned __int8 *)(a1 + 42) resolutionWindow:*(char *)(a1 + 43)];
}

void sub_10002F948(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002FC88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10002FCD0(uint64_t a1)
{
  v14[0] = @"actn";
  uint64_t v2 = (id *)(a1 + 32);
  uint64_t v3 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) action]);
  xpc_object_t v4 = (void *)v3;
  if (v3) {
    uint64_t v5 = (const __CFString *)v3;
  }
  else {
    uint64_t v5 = &stru_1008A57D8;
  }
  v15[0] = v5;
  v14[1] = @"apID";
  uint64_t v6 = objc_claimAutoreleasedReturnValue([*v2 appID]);
  uint64_t v7 = (void *)v6;
  if (v6) {
    uint64_t v8 = (const __CFString *)v6;
  }
  else {
    uint64_t v8 = &stru_1008A57D8;
  }
  v15[1] = v8;
  _DWORD v14[2] = @"cid";
  int v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [*(id *)(a1 + 32) clientID]));
  v15[2] = v9;
  v14[3] = @"dsFl";
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  [*(id *)(a1 + 32) discoveryFlags]));
  v15[3] = v10;
  v14[4] = @"scnR";
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  [*(id *)(a1 + 32) scanRate]));
  v15[4] = v11;
  int v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v15,  v14,  5LL));

  uint64_t v13 = sub_1002E8D94();
  (*(void (**)(uint64_t, void *))(*(void *)v13 + 232LL))(v13, v12);
}

void sub_10002FE6C(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1000300D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10003012C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10003013C(uint64_t a1)
{
}

id sub_100030144(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 56LL);
  if (!v2)
  {
    uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void **)(v4 + 56);
    *(void *)(v4 + 56) = v3;

    uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 56LL);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKey:*(void *)(a1 + 40)]);

  if (!v6)
  {
    char v19 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    [*(id *)(*(void *)(a1 + 32) + 56) setObject:v19 forKeyedSubscript:*(void *)(a1 + 40)];

    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 56) objectForKeyedSubscript:*(void *)(a1 + 40)]);
    [v20 addObject:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40)];

    goto LABEL_29;
  }

  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 56) objectForKeyedSubscript:*(void *)(a1 + 40)]);
  id v8 = [v7 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (!v8)
  {

LABEL_28:
    __int16 v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 56) objectForKeyedSubscript:*(void *)(a1 + 40)]);
    [v21 addObject:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40)];

    goto LABEL_29;
  }

  char v9 = 0;
  uint64_t v10 = *(void *)v24;
  do
  {
    for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v24 != v10) {
        objc_enumerationMutation(v7);
      }
      int v12 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)i);
      id v13 = [v12 discoveryFlags];
      if (v13 == [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) discoveryFlags])
      {
        uint64_t v14 = (unsigned __int8 *)[v12 discoveryTypesPtr];
        id v15 = (unsigned __int8 *)[*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) discoveryTypesPtr];
        if (*(_DWORD *)v14 == *(_DWORD *)v15 && v14[4] == v15[4])
        {
          unsigned int v17 = [v12 scanRateScreenOn];
          if (v17 == [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) scanRateScreenOn])
          {
            unsigned int v18 = [v12 scanRateScreenOff];
            if (v18 == [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) scanRateScreenOff])
            {
              if ([*(id *)(a1 + 48) isEqual:@"agsN"])
              {
                objc_msgSend(v12, "setScanScreenOnCount:", (char *)objc_msgSend(v12, "scanScreenOnCount") + 1);
              }

              else if ([*(id *)(a1 + 48) isEqual:@"agsF"])
              {
                objc_msgSend(v12, "setScanScreenOffCount:", (char *)objc_msgSend(v12, "scanScreenOffCount") + 1);
              }

              objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL), v12);
              char v9 = 1;
            }
          }
        }
      }
    }

    id v8 = [v7 countByEnumeratingWithState:&v23 objects:v27 count:16];
  }

  while (v8);

  if ((v9 & 1) == 0) {
    goto LABEL_28;
  }
LABEL_29:
  id result = [*(id *)(a1 + 32) _setupAggressiveScanMetricExportTimer];
  if (dword_1008D6290 <= 20)
  {
    if (dword_1008D6290 != -1) {
      return (id)LogPrintF_safe( &dword_1008D6290,  "-[CBMetricsDaemon reportAggressiveScan:action:]_block_invoke",  20,  "Aggressive Scan Metrics Event reported: appID %@, action %@, screenOnCount %llu, screenOffCount %llu, client %@",  *(void *)(a1 + 40),  *(void *)(a1 + 48),  [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) scanScreenOnCount],  objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), "scanScreenOffCount"),  *(void *)(a1 + 56));
    }
    id result = (id)_LogCategory_Initialize(&dword_1008D6290, 20LL);
    if ((_DWORD)result) {
      return (id)LogPrintF_safe( &dword_1008D6290,  "-[CBMetricsDaemon reportAggressiveScan:action:]_block_invoke",  20,  "Aggressive Scan Metrics Event reported: appID %@, action %@, screenOnCount %llu, screenOffCount %llu, client %@",  *(void *)(a1 + 40),  *(void *)(a1 + 48),  [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) scanScreenOnCount],  objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), "scanScreenOffCount"),  *(void *)(a1 + 56));
    }
  }

  return result;
}

void sub_1000304C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100030620( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void *sub_100030638(void *result)
{
  id v1 = (void *)result[4];
  if (v1 == *(void **)(result[5] + 64LL))
  {
    uint64_t v2 = result;
    if (v1)
    {
      uint64_t v3 = v1;
      dispatch_source_cancel(v3);
      uint64_t v4 = v2[5];
      uint64_t v5 = *(void **)(v4 + 64);
      *(void *)(v4 + 64) = 0LL;
    }

    return [(id)v2[5] _reportAggressiveScanMetricEvents];
  }

  return result;
}

void sub_100030810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100030838(uint64_t a1, void *a2, void *a3)
{
  id v21 = a2;
  id v16 = a3;
  unint64_t v20 = +[CBDaemonXPCConnection indexForCBApprovedAppID:]( &OBJC_CLASS___CBDaemonXPCConnection,  "indexForCBApprovedAppID:",  v21);
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  id obj = v16;
  id v4 = [obj countByEnumeratingWithState:&v23 objects:v29 count:16];
  if (v4)
  {
    uint64_t v18 = *(void *)v24;
    do
    {
      id v22 = v4;
      for (uint64_t i = 0LL; i != v22; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v18) {
          objc_enumerationMutation(obj);
        }
        uint64_t v6 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)i);
        v28[0] = v21;
        v27[0] = @"apID";
        v27[1] = @"apIX";
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v20));
        v28[1] = v7;
        v27[2] = @"dsFl";
        id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  [v6 discoveryFlags]));
        v28[2] = v8;
        v27[3] = @"dsTy";
        uint64_t v9 = CBDiscoveryTypesEnumToString([v6 discoveryTypesPtr]);
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        v28[3] = v10;
        v27[4] = @"scnR";
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  [v6 scanRateScreenOn]));
        v28[4] = v11;
        v27[5] = @"sonC";
        int v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  [v6 scanScreenOnCount]));
        v28[5] = v12;
        v27[6] = @"srsO";
        id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  [v6 scanRateScreenOff]));
        v28[6] = v13;
        v27[7] = @"sofC";
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  [v6 scanScreenOffCount]));
        v28[7] = v14;
        id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v28,  v27,  8LL));

        [*(id *)(a1 + 32) addObject:v15];
      }

      id v4 = [obj countByEnumeratingWithState:&v23 objects:v29 count:16];
    }

    while (v4);
  }
}

void sub_100030B10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
}

id sub_100030C2C(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) nearbyActionNoWakeType];
  if ((_DWORD)result)
  {
    uint64_t v3 = sub_1002E8D94();
    return (id)(*(uint64_t (**)(uint64_t, id))(*(void *)v3 + 408))( v3,  [*(id *)(a1 + 32) nearbyActionNoWakeType]);
  }

  return result;
}

id sub_100030CFC(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) isEqual:@"RSSILevelNoChange"];
  uint64_t v3 = 80LL;
  if (v2) {
    uint64_t v3 = 72LL;
  }
  ++*(void *)(*(void *)(a1 + 40) + v3);
  return [*(id *)(a1 + 40) _setupMetricExportTimer];
}

void sub_100030E70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void *sub_100030E88(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v2 == result[11]) {
    return [result _whbMetricExportTimerFired];
  }
  return result;
}

void sub_100031024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100031144(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100031160(uint64_t a1)
{
  uint64_t v2 = sub_1002E8D94();
  return (*(uint64_t (**)(uint64_t, void))(*(void *)v2 + 240LL))(v2, *(void *)(a1 + 32));
}

void sub_1000313C4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100031410(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100031420(uint64_t a1)
{
}

void sub_100031428(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v6 + 40);
  uint64_t v7 = CUDescriptionWithLevel(a3, 30LL);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  NSAppendPrintF_safe(&obj, "%@\n", v8);
  objc_storeStrong((id *)(v6 + 40), obj);

  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
}

void sub_1000314DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_42:
    if (dword_1008D6300 <= 30
      && (dword_1008D6300 != -1 || _LogCategory_Initialize(&dword_1008D6300, 30LL)))
    {
      LogPrintF_safe(&dword_1008D6300, "-[CBStackClassicScannerBTStack activate]", 30LL, "Scan started: initial");
    }
  }

      CFPropertyListRef v48 = sub_100138554(6, inputStruct, outputStruct);
      __int128 v33 = 0;
      uint64_t v43 = 0LL;
      if (v48)
      {
        int v32 = v48;
        goto LABEL_5;
      }
    }

    v49 = 0LL;
    while (1)
    {
      v131 = v49;
      char v50 = (unint64_t)&outputStruct[v49];
      if (*(_BYTE *)(v50 + 4)) {
        break;
      }
LABEL_96:
      v49 = v131 + 1;
      if (v131 == 5) {
        goto LABEL_42;
      }
    }

    id v51 = 0;
    uint64_t v52 = v50 | 4;
    id v53 = (unsigned __int8 *)&inputStruct[4 * v131];
    v54 = (char *)*v53;
    id v55 = (unsigned __int16 *)*((void *)v53 + 1);
    v133 = v52;
    v134 = (unint64_t)v54;
    v56 = &v54[(void)v34 + 8];
    while (1)
    {
      v58 = v55 + 1;
      v57 = *((unsigned __int8 *)v55 + 2);
      v59 = *v56;
      *v56 = v59 + 1;
      if (v57 != v59)
      {
        sub_1001EE2A0();
        size_t v60 = (os_log_s *)sub_100086554(0x3Au);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
        {
          v89 = *v56 - 1;
          v90 = *v58;
          *(void *)&v144[0] = __PAIR64__(v134, 67109888);
          WORD4(v144[0]) = 1024;
          *(_DWORD *)((char *)v144 + 10) = v51;
          HIWORD(v144[0]) = 1024;
          LODWORD(v144[1]) = v89;
          WORD2(v144[1]) = 1024;
          *(_DWORD *)((char *)&v144[1] + 6) = v90;
          _os_log_error_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_ERROR,  "applebt_rx_main: seq_num[pipe=%d,item=%d] mismatch, expected %d received %d\n",  (uint8_t *)v144,  0x1Au);
        }

        sub_1001EE2A0();
        v61 = (os_log_s *)sub_100086554(0x3Au);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
          sub_100657D30(v136, (unsigned __int8 *)v55 + 2, (int *)v129, v61);
        }
        *v56 = *v58 + 1;
      }

      v62 = *v55;
      sub_1000A85A0();
      if (!v34[19]) {
        goto LABEL_110;
      }
      if ((_DWORD)v134 == 10)
      {
        v63 = *v55;
        if (*v55)
        {
          v64 = 0;
          v65 = (unsigned __int8 *)(v55 + 2);
          do
          {
            v66 = *(unsigned int *)v65;
            v67 = v65 + 4;
            int v68 = *((_WORD *)v65 + 3);
            v69 = v68 + 4;
            v64 += v68 + 8;
            v144[0] = 0uLL;
            v70 = mach_continuous_time();
            v71 = v70 & 0xFFFFFFF000000000LL | (16 * v66);
            if (v70 - v71 > 0x800000000LL) {
              v71 -= 0x1000000000LL;
            }
            *(void *)&v144[0] = v71;
            int v72 = v69;
            if (v63 - v64 == 1)
            {
              sub_100085EB8(&v67[v69], 1u, (uint64_t)v144);
              v80 = v144;
              v81 = 6LL;
              v82 = v67;
              v83 = v69;
              goto LABEL_94;
            }

            v73 = v64;
            sub_10012F73C(6LL, v67, v72, (uint64_t)v144);
            v65 = &v67[v72];
          }

          while (v64 < v63);
          int v34 = v132;
          if (v73 != v63)
          {
            sub_1001EE2A0();
            uint64_t v74 = (os_log_s *)sub_100086554(0x3Au);
            if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
            {
              *(void *)&v144[0] = __PAIR64__(v73, v128);
              WORD4(v144[0]) = 1024;
              *(_DWORD *)((char *)v144 + 10) = v63;
              _os_log_error_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_ERROR,  "packet buffering: current_item_size != packet_len current_item_size: %u, packet_len: %u",  (uint8_t *)v144,  0xEu);
            }
          }
        }

        goto LABEL_95;
      }

      v75 = v62 - 1;
      v76 = *((unsigned __int8 *)v55 + 4);
      v77 = (unsigned __int8 *)v55 + 5;
      if (v76 == 7)
      {
        v78 = *v77 + 1;
        v140 = 0uLL;
        *(void *)&v140 = mach_continuous_time();
        BYTE8(v140) = 0;
        if ((int)v75 <= v78)
        {
          if (v62 <= v78)
          {
            sub_1001EE2A0();
            v84 = (os_log_s *)sub_100086554(0x3Au);
            if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v144[0]) = v128;
              DWORD1(v144[0]) = v78;
              WORD4(v144[0]) = 1024;
              *(_DWORD *)((char *)v144 + 10) = v75;
              _os_log_error_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_ERROR,  "applebt_rx_main: WARNING! LMP packet length(%d) is larger than actual packet length(%d) - truncating!",  (uint8_t *)v144,  0xEu);
            }

            v78 = v75;
          }
        }

        else
        {
          sub_100085EB8((_BYTE *)v55 + v78 + 5, v75 - v78, (uint64_t)&v140);
        }

        v85 = sub_10016F400();
        v83 = v78;
        if (!v85)
        {
          sub_1000BA78C();
          int v34 = v132;
          if (BYTE8(v140))
          {
            memset(v144, 0, 100);
            snprintf((char *)v144, 0x64uLL, "BT Controller HCI_LMP wakeupCause (len=0x%hhX)", *v77);
            sub_1001EE0E4("applebt_rx_main: %s", (const char *)v144);
            sub_1000BA160((const char *)v144);
          }

          goto LABEL_95;
        }

        v81 = *((unsigned __int8 *)v55 + 4);
        v80 = &v140;
        v82 = (unsigned __int8 *)v55 + 5;
      }

      else
      {
        switch(v76)
        {
          case 4u:
            v79 = v62 - 1;
            if (v75 >= 2) {
              v79 = *((unsigned __int8 *)v55 + 6) + 2;
            }
            break;
          case 3u:
            v79 = v62 - 1;
            if (v75 >= 3) {
              v79 = *((unsigned __int8 *)v55 + 7) + 3;
            }
            break;
          case 2u:
            v79 = v62 - 1;
            if (v75 >= 4) {
              v79 = *(unsigned __int16 *)((char *)v55 + 7) + 4;
            }
            break;
          default:
            sub_1001EE2A0();
            v86 = (os_log_s *)sub_100086554(0x3Au);
            v79 = v75;
            if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
            {
              *(void *)&v144[0] = __PAIR64__(v76, v128);
              WORD4(v144[0]) = 1024;
              *(_DWORD *)((char *)v144 + 10) = v75;
              _os_log_error_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_ERROR,  "applebt_get_hci_packet_length: Unknown HCI packet type=%d, length=%d",  (uint8_t *)v144,  0xEu);
              v79 = v75;
            }

            break;
        }

        if (v75 >= v79)
        {
          v88 = v79;
        }

        else
        {
          sub_1001EE2A0();
          v87 = (os_log_s *)sub_100086554(0x3Au);
          v88 = v75;
          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
          {
            *(void *)&v144[0] = __PAIR64__(v76, v127);
            WORD4(v144[0]) = 1024;
            *(_DWORD *)((char *)v144 + 10) = v79;
            HIWORD(v144[0]) = 1024;
            LODWORD(v144[1]) = v75;
            _os_log_error_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_ERROR,  "applebt_get_hci_packet_length: WARNING! HCI packet length (type=%d, length=%d) is larger than actual packe t length(%d) - truncating!",  (uint8_t *)v144,  0x14u);
            v88 = v75;
          }
        }

        v144[0] = 0uLL;
        *(void *)&v144[0] = mach_continuous_time();
        BYTE8(v144[0]) = 0;
        v81 = *((unsigned __int8 *)v55 + 4);
        v80 = v144;
        v82 = (unsigned __int8 *)v55 + 5;
        v83 = v88;
      }

          uint64_t v7 = 2LL;
LABEL_43:
          sub_10009BDCC(v6, v7, 15);
        }

        break;
      case 2:
        switch(v4)
        {
          case 1:
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"Transport resynching", v8, v9, v10, v11, v12, v13, v14, v27);
              id v15 = (os_log_s *)sub_100086554(0x3Au);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
                sub_100657858();
              }
            }

            dword_1008F1F7C = 0;
            sub_10009B570();
            sub_10009AB9C();
            byte_1008DDCFF = 1;
            goto LABEL_54;
          case 3:
            goto LABEL_41;
          case 5:
            goto LABEL_38;
          case 7:
            id v16 = 3;
            goto LABEL_56;
          default:
            return;
        }

        return;
      case 3:
        if (!v2) {
          return;
        }
        dword_1008F1F7C = 2;
LABEL_38:
        uint64_t v6 = (__int16 *)&unk_1006BB99F;
        goto LABEL_42;
      case 4:
        if (v3)
        {
          id v16 = 2;
LABEL_56:
          dword_1008F1F7C = v16;
        }

        return;
      default:
        return;
    }
  }

        id v8 = sub_1000D5904((uint64_t)a1, a2, a3, &v53);
        if (v8 != 0x7FFFFFFF) {
          continue;
        }
        return 0LL;
      }

      break;
    }

    if (v8 != 10)
    {
      if (v8 == 13)
      {
        unint64_t v20 = *((unsigned __int16 *)a1 + 9);
        if (!*((_BYTE *)a1 + 21))
        {
          if (v20 < *((unsigned __int16 *)a1 + 8))
          {
            id v21 = a1[1];
            *((_WORD *)a1 + 9) = v20 + 1;
            *((_BYTE *)v21 + v20) = 13;
            goto LABEL_42;
          }

    char v19 = v5++;
  }

  while (v19 < 7);
  id result = 120LL;
  if (v3 == 3 && !v6)
  {
LABEL_47:
    id v21 = 1;
LABEL_48:
    *a3 = v21;
  }

  return result;
}

                        if (HIBYTE(v61))
                        {
                          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                        }

                        else
                        {
                          v41 = WORD2(v61);
                          if (WORD1(v61) > WORD2(v61))
                          {
                            if (BYTE6(v61) == 2)
                            {
                              ++WORD2(v61);
                              *(_BYTE *)(v60 + v41) = a6;
                              if (HIBYTE(v61))
                              {
                                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/"
                                                       "vsc/bcm/bcm_vsc.c");
                              }

                              else
                              {
                                __int16 v42 = WORD2(v61);
                                if (WORD1(v61) > WORD2(v61))
                                {
                                  if (BYTE6(v61) == 2)
                                  {
                                    ++WORD2(v61);
                                    *(_BYTE *)(v60 + v42) = a7;
                                    if (HIBYTE(v61))
                                    {
                                      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/"
                                                             "Stack/vsc/bcm/bcm_vsc.c");
                                    }

                                    else if (WORD1(v61) - WORD2(v61) > 1)
                                    {
                                      if (BYTE6(v61) == 2)
                                      {
                                        *(_WORD *)(v60 + WORD2(v61)) = a9;
                                        uint64_t v43 = WORD2(v61) + 2;
                                        WORD2(v61) += 2;
                                        if (HIBYTE(v61))
                                        {
                                          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_b"
                                                                 "ase/Stack/vsc/bcm/bcm_vsc.c");
                                        }

                                        else if (WORD1(v61) - v43 > 1)
                                        {
                                          if (BYTE6(v61) == 2)
                                          {
                                            *(_BYTE *)(v60 + v43) = a8;
                                            *(_BYTE *)(v60 + WORD2(v61) + 1) = HIBYTE(a8);
                                            __int16 v44 = WORD2(v61);
                                            int v45 = WORD2(v61) + 2;
                                            WORD2(v61) += 2;
                                            if (HIBYTE(v61))
                                            {
                                              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetoo"
                                                                     "th_base/Stack/vsc/bcm/bcm_vsc.c");
                                            }

                                            else if (WORD1(v61) > v45)
                                            {
                                              if (BYTE6(v61) == 2)
                                              {
                                                WORD2(v61) = v44 + 3;
                                                *(_BYTE *)(v60 + v45) = a10;
                                                if (HIBYTE(v61))
                                                {
                                                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBlu"
                                                                         "etooth_base/Stack/vsc/bcm/bcm_vsc.c");
                                                }

                                                else if (WORD1(v61) - WORD2(v61) > 1)
                                                {
                                                  if (BYTE6(v61) == 2)
                                                  {
                                                    *(_WORD *)(v60 + WORD2(v61)) = a14;
                                                    v46 = WORD2(v61) + 2;
                                                    WORD2(v61) += 2;
                                                    if (HIBYTE(v61))
                                                    {
                                                      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/Mobil"
                                                                             "eBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                                                    }

                                                    else if (WORD1(v61) - v46 > 1)
                                                    {
                                                      if (BYTE6(v61) == 2)
                                                      {
                                                        *(_BYTE *)(v60 + v46) = a12;
                                                        *(_BYTE *)(v60 + WORD2(v61) + 1) = a13;
                                                        WORD2(v61) += 2;
                                                        return sub_10018BD78( 291,  v60,  BYTE4(v61),  a15,  (uint64_t)sub_10013A594,  v24,  v25,  v26);
                                                      }

                                                      v59 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_116:
                                                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack /vsc/bcm/bcm_vsc.c",  3673,  v59);
                                                    }

                                                    v59 = "ByteStream_NumReadBytesAvail(bs) >= 2";
                                                    goto LABEL_116;
                                                  }

                                                  v58 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_112:
                                                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3672,  v58);
                                                }

                                                v58 = "ByteStream_NumReadBytesAvail(bs) >= 2";
                                                goto LABEL_112;
                                              }

                                              v57 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_108:
                                              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3671,  v57);
                                            }

                                            v57 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                                            goto LABEL_108;
                                          }

                                          v56 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_104:
                                          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3670,  v56);
                                        }

                                        v56 = "ByteStream_NumReadBytesAvail(bs) >= 2";
                                        goto LABEL_104;
                                      }

                                      id v55 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_100:
                                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3669,  v55);
                                    }

                                    id v55 = "ByteStream_NumReadBytesAvail(bs) >= 2";
                                    goto LABEL_100;
                                  }

                                  v54 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_96:
                                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3668,  v54);
                                }
                              }

                              v54 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                              goto LABEL_96;
                            }

                            id v53 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_92:
                            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3667,  v53);
                          }
                        }

                        id v53 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                        goto LABEL_92;
                      }

                      uint64_t v52 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_88:
                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3640,  v52);
                    }
                  }

                  uint64_t v52 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                  goto LABEL_88;
                }

                id v51 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_84:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3639,  v51);
              }

              id v51 = "ByteStream_NumReadBytesAvail(bs) >= 1";
              goto LABEL_84;
            }

            char v50 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_80:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  3638,  v50);
          }

          char v50 = "ByteStream_NumReadBytesAvail(bs) >= 2";
          goto LABEL_80;
        }

        v49 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_76:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 3637, v49);
      }
    }

    v49 = "ByteStream_NumReadBytesAvail(bs) >= 1";
    goto LABEL_76;
  }

  return result;
}

        uint64_t v29 = a1;
        unsigned __int8 v30 = 4;
        goto LABEL_23;
      }

      v117 = sub_100185414();
      sub_1001EE134( (uint64_t)"Responder device was not in the proper state. State is %s.",  v118,  v119,  v120,  v121,  v122,  v123,  v124,  (uint64_t)v117);
      v125 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v125, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
    }

    else
    {
      sub_1001EE134((uint64_t)"Could not find associated pairing data.", v52, v53, v54, v55, v56, v57, v58, v297);
      v59 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
        goto LABEL_22;
      }
    }

            sub_1001EE2A0();
            goto LABEL_43;
        }

              if (v13 < 0)
              {
                id v8 = (uint64_t)sub_100024238(&__dst, *v6, v15);
              }

              else
              {
                __dst = *(_OWORD *)v6;
                __int128 v24 = *(void *)(a1 + 48);
              }

              sub_1001FFF44(v8, 1LL, (void **)&__dst, 1LL);
              if ((SHIBYTE(v24) & 0x80000000) == 0) {
                goto LABEL_53;
              }
              p_dst = (void **)&__dst;
              goto LABEL_52;
            }
          }

          else if (*(_BYTE *)(a1 + 55))
          {
            goto LABEL_18;
          }
        }

        char v19 = 3;
LABEL_54:
        *(_DWORD *)(a1 + 60) = v19;
        return;
      }
    }

    else if (v3->__r_.__value_.__s.__size_)
    {
      goto LABEL_15;
    }

    if (*(char *)(a1 + 55) < 0)
    {
      id v8 = (uint64_t)sub_100024238(&v21, *(void **)(a1 + 32), *(void *)(a1 + 40));
    }

    else
    {
      id v21 = *(_OWORD *)v6;
      id v22 = *(void *)(a1 + 48);
    }

    sub_1001FFF44(v8, 1LL, (void **)&v21, 2LL);
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      goto LABEL_53;
    }
    p_dst = (void **)&v21;
    goto LABEL_52;
  }

      BOOL v27 = *(unsigned __int16 *)(a1 + 418);
      uint64_t v28 = *(unsigned __int8 *)(a1 + 420);
LABEL_43:
      sub_10035FFF0(a1, a2, 3, a3, v27, 246, v28);
      id result = 0LL;
      uint64_t v29 = *(_WORD *)(a1 + 418) + 246;
      goto LABEL_44;
    }

    if (v10 == 121 && v11 == 1)
    {
      if (!*(_BYTE *)(a1 + 407) && *(_BYTE *)(v13 + 40) == 8 && *(_BYTE *)(a1 + 408))
      {
LABEL_15:
        __int128 v24 = 0;
        goto LABEL_18;
      }

  sub_100242CD0(&v47);
  uint64_t v43 = v45;
  __int16 v44 = v46;
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008A1F68);
  }
  unint64_t v20 = (uint64_t *)sub_1003FFEB0(off_1008D5F48, (uint64_t)&v43, 1);
  id v21 = 0;
  int v34 = (unsigned __int16 *)(v7 + 74);
  __int128 v33 = (unsigned __int16 *)(v7 + 140);
  while ((unint64_t)(sub_10056AAD8(a3 + 8) - *(void *)(a3 + 24)) >= 9)
  {
    id v22 = sub_10040F860(a3);
    __int128 v23 = sub_10040F7FC(a3);
    if (sub_10056AAD8(a3 + 8) - *(void *)(a3 + 24) < (unint64_t)v23)
    {
      uint64_t v28 = (os_log_s *)qword_1008F7748;
      if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
      {
        int v32 = sub_10056AAD8(a3 + 8) - *(_DWORD *)(a3 + 24);
        *(_DWORD *)CFPropertyListRef v48 = 67109376;
        *(_DWORD *)&v48[4] = v23;
        *(_WORD *)&v48[8] = 1024;
        *(_DWORD *)&v48[10] = v32;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "fastConnectParseProfileDescriptorMessage Length Error Descriptor length %u remaining %u",  v48,  0xEu);
      }

      break;
    }

    __int128 v24 = v23;
    __int128 v25 = sub_1000B17F4(v23);
    if (!v25) {
      break;
    }
    sub_10040F778(a3, v25, v24);
    buf = 0uLL;
    sub_10056AB04(&buf, v25, v24);
    *(_OWORD *)CFPropertyListRef v48 = 0u;
    v49 = 0u;
    __int128 v26 = sub_10040F738((uint64_t)v48, 0, (uint64_t)&buf);
    if (v22 <= 15)
    {
      if (v22 == 1)
      {
        if (qword_1008D9030 != -1) {
          dispatch_once(&qword_1008D9030, &stru_1008A1FC8);
        }
        if (sub_100474304( (uint64_t)off_1008D9028,  (uint64_t)v48,  (uint64_t)v20,  *v34,  v33,  (_BYTE *)(v7 + 142),  (_BYTE *)(v7 + 143),  (_BYTE *)(v7 + 144)))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
            sub_100695B00(&v39, v40);
          }
          *(_DWORD *)(v7 + 20) &= ~1u;
          if (qword_1008D9030 != -1) {
            dispatch_once(&qword_1008D9030, &stru_1008A1FC8);
          }
          sub_100473F04((uint64_t)off_1008D9028, *(void *)v7 + 128LL, v34, v33);
          if (*(_BYTE *)(v7 + 145))
          {
            sub_1001F7554(*(void *)v7 + 128LL, *(unsigned __int16 *)(v7 + 124));
            *(_WORD *)(v7 + 124) = 0;
          }
        }
      }

      else if (v22 == 8)
      {
        if (qword_1008D9250 != -1) {
          dispatch_once(&qword_1008D9250, &stru_1008A2008);
        }
        if (sub_100521048( (uint64_t)off_1008D9248,  (uint64_t)v48,  (unint64_t)v20,  *(unsigned __int16 *)(v7 + 94),  *(unsigned __int16 *)(v7 + 104)))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
            sub_100695B58(&v35, v36);
          }
          *(_DWORD *)(v7 + 20) &= ~8u;
          if (qword_1008D9250 != -1) {
            dispatch_once(&qword_1008D9250, &stru_1008A2008);
          }
          sub_1005216D8( (uint64_t)off_1008D9248,  *(void *)v7,  *(unsigned __int16 *)(v7 + 94),  *(unsigned __int16 *)(v7 + 104),  0);
        }
      }
    }

    else
    {
      switch(v22)
      {
        case 0x10:
          if (qword_1008D6458 != -1) {
            dispatch_once(&qword_1008D6458, &stru_1008A1FA8);
          }
          if (sub_10037C0F4( qword_1008D6450,  (uint64_t)v48,  v20,  *(unsigned __int16 *)(v7 + 54),  *(unsigned __int16 *)(v7 + 64),  (_WORD *)(v7 + 136)))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
              sub_100695AD4(&v41, v42);
            }
            *(_DWORD *)(v7 + 20) &= ~0x10u;
            if (qword_1008D6458 != -1) {
              dispatch_once(&qword_1008D6458, &stru_1008A1FA8);
            }
            sub_10037D41C( qword_1008D6450,  (uint64_t)v20,  (void *)*(unsigned __int16 *)(v7 + 54),  *(unsigned __int16 *)(v7 + 64),  *(unsigned __int16 *)(v7 + 136),  *(unsigned __int8 *)(v7 + 135));
          }

          else
          {
            if (qword_1008D6458 != -1) {
              dispatch_once(&qword_1008D6458, &stru_1008A1FA8);
            }
            sub_10037CD44( qword_1008D6450,  *(unsigned __int16 *)(v7 + 136),  (_BYTE *)(v7 + 135),  (_BYTE *)(v7 + 134),  (unsigned __int16 *)(v7 + 138),  *(unsigned __int16 *)(v7 + 64));
          }

          break;
        case 0x80000:
          if (qword_1008D60E0 != -1) {
            dispatch_once(&qword_1008D60E0, &stru_1008A1FE8);
          }
          if (sub_100238E64( (uint64_t)off_1008D60D8,  (uint64_t)v48,  (uint64_t)v20,  *(unsigned __int16 *)(v7 + 84)))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
              sub_100695B2C(&v37, v38);
            }
            *(_DWORD *)(v7 + 20) &= ~0x80000u;
            if (qword_1008D60E0 != -1) {
              dispatch_once(&qword_1008D60E0, &stru_1008A1FE8);
            }
            sub_10023B40C(off_1008D60D8, *(void *)v7, *(unsigned __int16 *)(v7 + 84), 114);
          }

          break;
        case 0x100000:
          sub_1005812D0(v26, (uint64_t)v48, v27, *(unsigned __int16 *)(v7 + 114));
          break;
      }
    }

    sub_1000B1838(v25);
    *(void *)&v48[8] = &off_10087FAA8;
    if ((void)v49) {
      sub_1002CD254((unsigned int *)v49);
    }
    *(void *)&buf = &off_10087FAA8;
    if (*((void *)&buf + 1)) {
      sub_1002CD254(*((unsigned int **)&buf + 1));
    }
    v21 |= v22;
  }

  uint64_t v29 = *(_DWORD *)(v7 + 20);
  if (v29 != v21)
  {
    unsigned __int8 v30 = (os_log_s *)qword_1008F7748;
    if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)CFPropertyListRef v48 = 67109376;
      *(_DWORD *)&v48[4] = v21;
      *(_WORD *)&v48[8] = 1024;
      *(_DWORD *)&v48[10] = v29;
      _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Profile mismatch error expected 0x%x received 0x%x",  v48,  0xEu);
      uint64_t v29 = *(_DWORD *)(v7 + 20);
    }

    *(_DWORD *)(v7 + 20) = v29 & v21;
  }

  return sub_100242CD8(&v47);
}

            id v13 = (__int16)(v13 + v17 - v16);
            if (v13 <= 0) {
              goto LABEL_49;
            }
            break;
        }
      }
    }

    v82 = 0;
    id v16 = 0;
LABEL_49:
    sub_100242CD0(&v96);
    if (sub_10040F7FC(a3) == 2)
    {
      id v21 = a3 + 8;
      while (1)
      {
        id v22 = sub_10040F860(a3);
        __int128 v23 = sub_10040F7FC(a3);
        LOWORD(v24) = v23;
        if (sub_10056AAD8(v21) - *(void *)(a3 + 24) < (unint64_t)v23)
        {
          __int128 v35 = (os_log_s *)qword_1008F7748;
          if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
          {
            v81 = sub_10056AAD8(v21) - *(_DWORD *)(a3 + 24);
            LODWORD(__p[0]) = 67109376;
            HIDWORD(__p[0]) = v23;
            LOWORD(__p[1]) = 1024;
            *(_DWORD *)((char *)&__p[1] + 2) = v81;
            _os_log_error_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "fastConnectParseSetupCompleteMessage Length Error Descriptor length %u remaining %u",  (uint8_t *)__p,  0xEu);
          }

          goto LABEL_92;
        }

        __int128 v25 = sub_1000B17F4(v23);
        if (!v25) {
          goto LABEL_92;
        }
        sub_10040F778(a3, v25, v23);
        v92 = 0LL;
        v93 = 0LL;
        sub_10056AB04(&v92, v25, v23);
        *(_OWORD *)__p = 0u;
        v116 = 0u;
        sub_10040F738((uint64_t)__p, 0, (uint64_t)&v92);
        if (v22 > 0x10 || ((1 << v22) & 0x10102) == 0)
        {
          if (v22 == 0x80000)
          {
            if (qword_1008D60E0 != -1) {
              dispatch_once(&qword_1008D60E0, &stru_1008A1FE8);
            }
            if (sub_100239230((uint64_t)off_1008D60D8, (uint64_t)__p, (uint64_t)v83, v85)
              && os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
            {
              sub_100696280(&v90, v91);
            }

            goto LABEL_84;
          }

          if (v22 != 0x100000) {
            goto LABEL_84;
          }
        }

        if (v23 >= 1)
        {
          do
          {
            __int128 v26 = (char)sub_10040F7B0((uint64_t)__p);
            if (v26 < 0)
            {
              BOOL v27 = sub_10040F7FC((uint64_t)__p);
              uint64_t v28 = -3;
            }

            else
            {
              BOOL v27 = sub_10040F7B0((uint64_t)__p);
              uint64_t v28 = -2;
            }

            uint64_t v29 = v26 & 0x7F;
            if (v29 == 4)
            {
              if (v27 == 2)
              {
                unsigned __int8 v30 = sub_10040F7FC((uint64_t)__p);
                if (v30)
                {
                  uint64_t v31 = (os_log_s *)qword_1008F7748;
                  if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 67109376;
                    *(_DWORD *)&uint8_t buf[4] = v22;
                    *(_WORD *)&buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v30;
                    _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "fastConnectParseSetupCompleteMessage Service 0x%x status %u",  buf,  0xEu);
                  }
                }
              }

              else
              {
                __int128 v33 = (os_log_s *)qword_1008F7748;
                if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)&uint8_t buf[4] = v27;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "fastConnectParseSetupCompleteMessage Error FC_COMMON_STATUS size wrong %d",  buf,  8u);
                  if (v27) {
                    goto LABEL_72;
                  }
                }

                else if (v27)
                {
                  goto LABEL_72;
                }
              }
            }

            else if (v27)
            {
              int v32 = (os_log_s *)qword_1008F7748;
              if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109632;
                *(_DWORD *)&uint8_t buf[4] = v29;
                *(_WORD *)&buf[8] = 1024;
                *(_DWORD *)&buf[10] = v27;
                *(_WORD *)&_BYTE buf[14] = 1024;
                LODWORD(v100) = v16;
                _os_log_error_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "Key not recognized :%d Dumped %d of %d bytes ",  buf,  0x14u);
              }

  sub_100242FAC((uint64_t)v25);
}

void sub_1000319D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
}

void sub_100031A44(uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v9 = (void *)qword_1008D9EB0;
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLong:](&OBJC_CLASS___NSNumber, "numberWithLong:", a5));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:v10]);

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1008D9EB8);
  if (v11)
  {
    int v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v11 dispatchQueue]);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100032B3C;
    block[3] = &unk_10087FBF0;
    block[4] = v11;
    void block[5] = a3;
    unsigned int v15 = a2;
    int v16 = a4;
    dispatch_async(v12, block);
  }

  else if (dword_1008D6300 <= 90 {
         && (dword_1008D6300 != -1 || _LogCategory_Initialize(&dword_1008D6300, 90LL)))
  }
  {
    if (a2 > 3) {
      id v13 = "?";
    }
    else {
      id v13 = off_10087FCA8[a2];
    }
    LogPrintF_safe( &dword_1008D6300,  "void _statusCallback(BTDiscoveryAgent _Nonnull, BTDiscoveryStatus, BTDevice _Nonnull, BTResult, void * _Nonnull)",  90LL,  "### Ignoring status callback after remove: %s",  v13);
  }
}

void sub_100031BA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100031BC0(uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v9 = (void *)qword_1008D9EB0;
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLong:](&OBJC_CLASS___NSNumber, "numberWithLong:", a5));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:v10]);

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1008D9EB8);
  if (v11)
  {
    int v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v11 dispatchQueue]);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100032B2C;
    block[3] = &unk_10087FBF0;
    block[4] = v11;
    void block[5] = a3;
    unsigned int v15 = a2;
    int v16 = a4;
    dispatch_async(v12, block);
  }

  else if (dword_1008D6300 <= 90 {
         && (dword_1008D6300 != -1 || _LogCategory_Initialize(&dword_1008D6300, 90LL)))
  }
  {
    if (a2 > 2) {
      id v13 = "?";
    }
    else {
      id v13 = off_10087FC90[a2];
    }
    LogPrintF_safe( &dword_1008D6300,  "void _discoveryCallback(BTDiscoveryAgent _Nonnull, BTDiscoveryEvent, BTDevice _Nonnull, BTDeviceAttributes, void * _Nonnull)",  90LL,  "### Ignoring discovery callback after remove: %s",  v13);
  }
}

void sub_100031D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100031EFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100031FE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100032230( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000323B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  id v13 = v12;

  _Unwind_Resume(a1);
}

void sub_10003267C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v13) {
    sub_1006574A8((uint64_t)&a13);
  }
  _Unwind_Resume(exception_object);
}

LABEL_39:
    if (dword_1008D6300 <= 30
      && (dword_1008D6300 != -1 || _LogCategory_Initialize(&dword_1008D6300, 30LL)))
    {
      LogPrintF_safe( &dword_1008D6300,  "-[CBStackClassicScannerBTStack _statusEvent:device:result:]",  30LL,  "Scan started: rescan");
    }
  }

    BOOL v27 = 0LL;
    goto LABEL_11;
  }

  __int128 v26 = ccecb_context_size(v22);
  cc_clear(v26, v24);
  BOOL v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &v34, a4));
LABEL_10:
  uint64_t v14 = v31;
LABEL_11:

  return v27;
}

  ++*(void *)(a1 + 24);
  return v11;
}

            __int16 v44 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = v44;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&_BYTE buf[14] = 0xFFFF;
            _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
            goto LABEL_64;
          }

          *((_DWORD *)v2 + 3) = 3;
          goto LABEL_65;
        case 2:
          if (v5 == 192) {
LABEL_22:
          }
            *((_DWORD *)v2 + 3) = 0;
          goto LABEL_65;
        case 3:
          *((_DWORD *)v2 + 3) = 1;
          if (v5 == 221)
          {
            unsigned int v17 = (uint64_t)*v2;
            uint64_t v18 = *((unsigned __int16 *)v2 + 4);
            *((_WORD *)v2 + 4) = v18 + 1;
            char v19 = -37;
          }

          else
          {
            if (v5 != 220)
            {
              *((_DWORD *)v2 + 3) = 0;
              uint64_t v3 = a1;
              id v4 = a2;
              goto LABEL_65;
            }

            unsigned int v17 = (uint64_t)*v2;
            uint64_t v18 = *((unsigned __int16 *)v2 + 4);
            *((_WORD *)v2 + 4) = v18 + 1;
            char v19 = -64;
          }

          *(_BYTE *)(v17 + v1_Block_object_dispose(va, 8) = v19;
LABEL_65:
          a2 = v4;
          a1 = v3;
          if (!(_WORD)v4)
          {
            uint64_t v2 = (char **)qword_1008DDD08;
            return (unsigned __int16)word_1008DDD12 - *((unsigned __int16 *)v2 + 4);
          }

          break;
        default:
          sub_1001EE2A0();
          uint64_t v2 = (char **)qword_1008DDD08;
          goto LABEL_65;
      }
    }
  }

  return (unsigned __int16)word_1008DDD12 - *((unsigned __int16 *)v2 + 4);
}

      if ((int)v20 + 2 <= *((unsigned __int16 *)a1 + 8))
      {
        __int128 v23 = a1[1];
        *((_WORD *)a1 + 9) = v20 + 1;
        *((_BYTE *)v23 + v20) = 13;
        __int128 v24 = a1[1];
        __int128 v25 = *((unsigned __int16 *)a1 + 9);
        *((_WORD *)a1 + 9) = v25 + 1;
        *((_BYTE *)v24 + v25) = v8;
        goto LABEL_41;
      }

      goto LABEL_71;
    }

    unint64_t v20 = *((unsigned __int16 *)a1 + 9);
    if (*((_BYTE *)a1 + 21)) {
      goto LABEL_39;
    }
    *((_BYTE *)a1 + 20) = 5;
    if ((_DWORD)v20)
    {
      __int128 v26 = 0LL;
      BOOL v27 = (unsigned __int8 *)a1[1];
      memset((char *)buf + 4, 0, 20);
      uint8_t buf[4] = a1;
      LODWORD(buf[0]) = 3;
      while (1)
      {
        uint64_t v28 = v27[v26];
        if (v28 == 58 || v28 == 61) {
          break;
        }
        if (v20 == ++v26)
        {
          LOWORD(v26) = v20;
          goto LABEL_52;
        }
      }

        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Get caps received for unknown seid %d", v28, v29, v30, v31, v32, v33, v34, v25);
          __int128 v35 = (os_log_s *)sub_100086554(3u);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        LODWORD(v6) = 18;
LABEL_37:
        sub_1000E6010(a1, 0xCu, a3, 0LL, 0, v6);
        return v6;
      }
    }

    *(_BYTE *)(v6 + 15) = 1;
    LODWORD(v6) = 17;
    goto LABEL_37;
  }

  if (a4 != 3)
  {
    if (a4 == 2)
    {
      *(void *)buf = 0LL;
      v64 = 0;
      uint64_t v6 = sub_1000DDDFC((uint64_t *)v6, (void **)buf, &v64);
      uint64_t v18 = v64;
      if (v17) {
        v17(a3, v63, *(unsigned __int8 *)(qword_1008DFDB0 + 99), *(void *)buf, v64, v6);
      }
      sub_1000D88A0((void **)buf, v18);
      return v6;
    }

      sub_1001EE134((uint64_t)"Unknown PDU opcode %d, dataSize %d", v20, v21, v22, v23, v24, v25, v26, *a2);
      BOOL v27 = (os_log_s *)sub_100086554(0x56u);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_19;
    }

    sub_1001EE134((uint64_t)"Wrong packet : %@", v11, v12, v13, v14, v15, v16, v17, (uint64_t)a2);
    uint64_t v18 = (os_log_s *)sub_100086554(0x56u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      return;
    }
LABEL_19:
    sub_100657858();
    return;
  }

  id v8 = &word_1008F29F8;
  while ((unsigned __int16)*v8 != (_DWORD)a1)
  {
    v8 += 536;
    if (!--v7) {
      goto LABEL_5;
    }
  }

  uint64_t v9 = (unsigned __int16 *)*((void *)v8 - 1);
  if (a2) {
    goto LABEL_8;
  }
}

    sub_100131480(v3, qword_1008E22D0 + 16);
    goto LABEL_40;
  }

  memset(v40, 0, sizeof(v40));
  id v22 = *(_BYTE **)v0;
  if (**(_BYTE **)v0 != 1)
  {
    sub_1001EE2A0();
    id v22 = *(_BYTE **)v0;
  }

  __int128 v23 = *(_WORD *)(v22 + 1);
  __int128 v24 = (unsigned __int16)v0[10];
  if (v24 != 64512 && v24 != v23) {
    sub_1001EE2A0();
  }
  sub_1001EF520((uint64_t)v40, 1u);
  sub_1001EFB10((unsigned __int8 *)v40, (char *)(*(void *)v0 + 4LL), (unsigned __int16)(v0[4] - 4), 2u);
  __int128 v25 = sub_10011EE68(1, v23, (uint64_t)v40, (unsigned __int16)(v0[4] - 4));
  uint64_t v3 = v25;
  if ((_DWORD)v25 != 625 && (_DWORD)v25 != 0) {
    goto LABEL_14;
  }
  if (v0[10] != 3125)
  {
    BOOL v27 = byte_1008F6E19;
    if (!byte_1008F6E19)
    {
      sub_1001EE2A0();
      BOOL v27 = byte_1008F6E19;
    }

    byte_1008F6E19 = v27 - 1;
  }

  if ((_DWORD)v3 != 625)
  {
    if (!(_DWORD)v3)
    {
      byte_1008E22C0 = 0;
      goto LABEL_40;
    }

    goto LABEL_39;
  }

  if (dword_1008E22C4 && byte_1008E22C0 && byte_1008F6E19) {
    sub_1001EE6DC((uint64_t)sub_10012CEC4, 0LL, 0LL);
  }
LABEL_40:
  sub_1000B1838(*(void **)qword_1008E22D0);
  uint64_t v28 = dword_1008E22C4 - 1;
  dword_1008E22C4 = v28;
  if (v28) {
    memmove((void *)qword_1008E22D0, (const void *)(qword_1008E22D0 + 48), 48LL * v28);
  }
}

    sub_1001EC444((uint64_t)&v42);
    unint64_t v20 = v42;
    if (!v42) {
      goto LABEL_40;
    }
  }

  *(void *)a2 = v21;
LABEL_44:
  if (!qword_1008E2C28)
  {
LABEL_52:
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Unstallable packet with cid 0x%4x available, but no queue with corresponding CID exists",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  *(unsigned __int16 *)(*(void *)a2 + 36LL));
      char v37 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

  ++*(void *)(a1 + 24);
  return v11;
}

            sub_1003DF7D8((uint64_t)v7, *((unsigned __int8 *)v16 - 1), v18);
            goto LABEL_40;
          }

          if (v17 != 160)
          {
            if (v17 == 176)
            {
              uint64_t v18 = *(unsigned __int8 *)v16;
              if (v18 == 1)
              {
                *(_DWORD *)buf = 4;
                if (qword_1008D6458 != -1) {
                  dispatch_once(&qword_1008D6458, &stru_100888B90);
                }
                sub_100378548((void *)qword_1008D6450, (uint64_t)v7, (int *)buf);
                BOOL v27 = (os_log_s *)qword_1008F7560;
                if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)char v50 = 67109120;
                  *(_DWORD *)&v50[4] = *(_DWORD *)buf;
                  _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "capabilitiesResponseEvent: supportedListening modes: %u",  v50,  8u);
                }

                uint64_t v28 = *((unsigned __int8 *)v16 - 1);
              }

              else
              {
                uint64_t v28 = 176;
              }

              sub_1003DF588((uint64_t)v7, v28, v18 != 0);
            }

            else
            {
              if (v17 != 192) {
                goto LABEL_104;
              }
              uint64_t v18 = *(unsigned __int8 *)v16;
              sub_1003DF588((uint64_t)v7, 192, *(_BYTE *)v16 != 0);
            }

            goto LABEL_39;
          }

          uint64_t v18 = *(unsigned __int8 *)v16;
          if (v18 == 1)
          {
            if (qword_1008D6458 != -1) {
              dispatch_once(&qword_1008D6458, &stru_100888B90);
            }
            uint64_t v18 = 1;
            sub_1003784E0((void *)qword_1008D6450, (uint64_t)v7, 1);
          }
        }

    if (qword_1008D9268 != -1) {
      dispatch_once(&qword_1008D9268, &stru_10088BB40);
    }
    uint64_t v28 = sub_10038785C(qword_1008D9260);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
    [v1 addObjectsFromArray:v29];

    v112 = 0u;
    v113 = 0u;
    v110 = 0u;
    v111 = 0u;
    if (qword_1008D9050 != -1) {
      dispatch_once(&qword_1008D9050, &stru_10088BDA0);
    }
    unsigned __int8 v30 = sub_100367444(qword_1008D9048);
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
    int v32 = [v31 countByEnumeratingWithState:&v110 objects:v140 count:16];
    if (v32)
    {
      __int128 v33 = *(void *)v111;
      do
      {
        int v34 = 0LL;
        do
        {
          if (*(void *)v111 != v33) {
            objc_enumerationMutation(v31);
          }
          __int128 v35 = *(void **)(*((void *)&v110 + 1) + 8LL * (void)v34);
          v109 = 0LL;
          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_10088BB00);
          }
          int v36 = off_1008D5F08;
          sub_100241F90(buf, v35);
          if (sub_100599890((uint64_t)v36, buf, &v109))
          {
            LOBYTE(v96) = 0;
            sub_100242CA4(&v96);
            if (sub_1001B9B0C(v109))
            {
              char v37 = (os_log_s *)qword_1008F7628;
              if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 138543362;
                v128 = v35;
                _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_INFO,  "Skipping LE L2CAP device %{public}@",  buf,  0xCu);
              }

              [v1 addObject:v35];
            }

            sub_100242CD8(&v96);
          }

          int v34 = (char *)v34 + 1;
        }

        while (v32 != v34);
        int v32 = [v31 countByEnumeratingWithState:&v110 objects:v140 count:16];
      }

      while (v32);
    }

    v107 = 0u;
    v108 = 0u;
    v105 = 0u;
    v106 = 0u;
    if (qword_1008D9158 != -1) {
      dispatch_once(&qword_1008D9158, &stru_10088BDC0);
    }
    uint64_t v38 = sub_1002479BC(qword_1008D9150);
    v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
    __int16 v40 = [v39 countByEnumeratingWithState:&v105 objects:v139 count:16];
    if (v40)
    {
      v41 = *(void *)v106;
      do
      {
        __int16 v42 = 0LL;
        do
        {
          if (*(void *)v106 != v41) {
            objc_enumerationMutation(v39);
          }
          uint64_t v43 = *(void **)(*((void *)&v105 + 1) + 8LL * (void)v42);
          v109 = 0LL;
          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_10088BB00);
          }
          __int16 v44 = off_1008D5F08;
          sub_100241F90(buf, v43);
          if (sub_100599890((uint64_t)v44, buf, &v109))
          {
            LOBYTE(v96) = 0;
            sub_100242CA4(&v96);
            if (sub_1001B9B0C(v109))
            {
              int v45 = sub_10008E614(v109);
              v46 = (os_log_s *)qword_1008F7628;
              v47 = os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_INFO);
              if (v45)
              {
                if (v47)
                {
                  *(_DWORD *)buf = 138543362;
                  v128 = v43;
                  _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_INFO,  "disconnecting device device %{public}@ since its scalable pipes are idle",  buf,  0xCu);
                }
              }

              else
              {
                if (v47)
                {
                  *(_DWORD *)buf = 138543362;
                  v128 = v43;
                  _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_INFO,  "Skipping scalable pipe device %{public}@ since it is still active",  buf,  0xCu);
                }

                [v1 addObject:v43];
              }
            }

            sub_100242CD8(&v96);
          }

          __int16 v42 = (char *)v42 + 1;
        }

        while (v40 != v42);
        __int16 v40 = [v39 countByEnumeratingWithState:&v105 objects:v139 count:16];
      }

      while (v40);
    }

    if (qword_1008D9278 != -1) {
      dispatch_once(&qword_1008D9278, &stru_10088BBC0);
    }
    CFPropertyListRef v48 = sub_1004138B0(qword_1008D9270);
    v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
    [v1 addObjectsFromArray:v49];

    v103 = 0u;
    v104 = 0u;
    v101 = 0u;
    v102 = 0u;
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_10088BB00);
    }
    char v50 = sub_10059A440((uint64_t)off_1008D5F08);
    id v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
    uint64_t v52 = [v51 countByEnumeratingWithState:&v101 objects:v138 count:16];
    if (v52)
    {
      id v53 = *(void *)v102;
      do
      {
        v54 = 0LL;
        do
        {
          if (*(void *)v102 != v53) {
            objc_enumerationMutation(v51);
          }
          id v55 = *(void *)(*((void *)&v101 + 1) + 8LL * (void)v54);
          if (([v1 containsObject:v55] & 1) == 0)
          {
            if (qword_1008D5F10 != -1) {
              dispatch_once(&qword_1008D5F10, &stru_10088BB00);
            }
            v56 = off_1008D5F08;
            sub_100241F90(buf, v55);
            sub_100597F98((uint64_t)v56, buf, 0);
          }

          v54 = (char *)v54 + 1;
        }

        while (v52 != v54);
        uint64_t v52 = [v51 countByEnumeratingWithState:&v101 objects:v138 count:16];
      }

      while (v52);
    }

    v99 = 0u;
    v100 = 0u;
    v97 = 0u;
    v98 = 0u;
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_10088BB00);
    }
    v57 = sub_10059A34C((uint64_t)off_1008D5F08);
    v58 = (void *)objc_claimAutoreleasedReturnValue(v57);
    v59 = [v58 countByEnumeratingWithState:&v97 objects:v137 count:16];
    if (v59)
    {
      size_t v60 = *(void *)v98;
      v89 = v58;
      do
      {
        v61 = 0LL;
        do
        {
          if (*(void *)v98 != v60) {
            objc_enumerationMutation(v58);
          }
          v62 = *(void **)(*((void *)&v97 + 1) + 8LL * (void)v61);
          if (([v1 containsObject:v62] & 1) == 0)
          {
            if (qword_1008D5F10 != -1) {
              dispatch_once(&qword_1008D5F10, &stru_10088BB00);
            }
            v63 = off_1008D5F08;
            sub_100241F90(buf, v62);
            if (sub_10059A15C((uint64_t)v63, buf) == 1)
            {
              v96 = 0;
              sub_1000B0740(&v96, 0LL);
              if (qword_1008D5F30 != -1) {
                dispatch_once(&qword_1008D5F30, &stru_10088BB80);
              }
              v64 = sub_1005CC368((uint64_t)off_1008D5F28, v62) + (unsigned __int16)word_1008D9258;
              v65 = (os_log_s *)qword_1008F7628;
              if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
              {
                v66 = v96;
                if (qword_1008D5F30 != -1) {
                  dispatch_once(&qword_1008D5F30, &stru_10088BB80);
                }
                v67 = sub_1005CC368((uint64_t)off_1008D5F28, v62);
                *(_DWORD *)buf = 138544386;
                v128 = v62;
                v129 = 1024;
                v130 = v64;
                v131 = 1024;
                v132 = v66;
                v133 = 1024;
                v134 = v67;
                v135 = 1024;
                v136 = (unsigned __int16)word_1008D9258;
                _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "Device %{public}@ is unused, graceTime=%d curSecs=%d lastConnected=%d fConnectionGracePeriod=%d",  buf,  0x24u);
              }

              int v68 = v64 - v96;
              if (v64 >= v96)
              {
                int v72 = qword_1008F7628;
                v58 = v89;
                if (!os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_INFO)) {
                  goto LABEL_134;
                }
                *(_DWORD *)buf = 138543618;
                v128 = v62;
                v129 = 1024;
                v130 = v68;
                v73 = (os_log_s *)v72;
                uint64_t v74 = "Device %{public}@ is unused, but is within the grace period for %d more seconds - skipping";
                v75 = 18;
LABEL_130:
                _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_INFO, v74, buf, v75);
                goto LABEL_134;
              }

              v69 = sub_1002E6BF0();
              v58 = v89;
              if ((*(unsigned int (**)(uint64_t))(*(void *)v69 + 344LL))(v69))
              {
                v109 = 0LL;
                if (qword_1008D5F10 != -1) {
                  dispatch_once(&qword_1008D5F10, &stru_10088BB00);
                }
                v70 = off_1008D5F08;
                sub_100241F90(buf, v62);
                if (sub_100599890((uint64_t)v70, buf, &v109))
                {
                  v95 = 0;
                  sub_100242CA4(&v95);
                  if (sub_100090E10(v109))
                  {
                    if (qword_1008D5F20 != -1) {
                      dispatch_once(&qword_1008D5F20, &stru_10088BB60);
                    }
                    if (sub_10061C0F8(qword_1008D5F18, v62))
                    {
                      v71 = (os_log_s *)qword_1008F7628;
                      if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_INFO))
                      {
                        *(_DWORD *)buf = 138543362;
                        v128 = v62;
                        _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_INFO,  "Device %{public}@ is unused, but is in the middle of pipe negotiaion - skipping",  buf,  0xCu);
                      }

                      sub_100242CD8(&v95);
                      goto LABEL_134;
                    }
                  }

                  sub_100242CD8(&v95);
                }
              }
            }

            if (qword_1008D5F20 != -1) {
              dispatch_once(&qword_1008D5F20, &stru_10088BB60);
            }
            if (sub_100626260(qword_1008D5F18, v62))
            {
              v76 = qword_1008F7628;
              if (!os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_INFO)) {
                goto LABEL_134;
              }
              *(_DWORD *)buf = 138543362;
              v128 = v62;
              v73 = (os_log_s *)v76;
              uint64_t v74 = "Device %{public}@ is unused, but is in the middle of pairing - skipping";
              v75 = 12;
              goto LABEL_130;
            }

            if (qword_1008D5F10 != -1) {
              dispatch_once(&qword_1008D5F10, &stru_10088BB00);
            }
            v77 = off_1008D5F08;
            sub_100241F90(buf, v62);
            sub_100597F98((uint64_t)v77, buf, 1u);
          }

  ++*(void *)(a1 + 24);
  return v11;
}

  ++*(void *)(a1 + 24);
  return v11;
}

      __int128 v26 = (void *)v2[1];
      if (v26)
      {
        do
        {
          BOOL v27 = v26;
          __int128 v26 = (void *)*v26;
        }

        while (v26);
      }

      else
      {
        do
        {
          BOOL v27 = (void *)v2[2];
          uint64_t v28 = *v27 == (void)v2;
          uint64_t v2 = v27;
        }

        while (!v28);
      }

      uint64_t v2 = v27;
      if (v27 == v3) {
        return v6;
      }
    }

    unint64_t v20 = memcmp(__s1, v11, __n) == 0;
    goto LABEL_24;
  }

  return 0;
}

        int v16 = 0LL;
        goto LABEL_40;
      }

      if (*(_DWORD *)(v11 + 728) == 5)
      {
        unsigned int v17 = (os_log_s *)qword_1008F7558;
        if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_DEFAULT))
        {
          sub_1003CF00C(v12, __p);
          uint64_t v18 = v27 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          unsigned __int8 v30 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Device %{public}s was already in streaming state",  buf,  0xCu);
          if (v27 < 0) {
            operator delete(__p[0]);
          }
        }
      }

      *(_DWORD *)(v11 + 72_Block_object_dispose(va, 8) = 5;
      sub_10036DC64(a1, v10);
      goto LABEL_39;
    }

    int v16 = 1LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_ERROR)) {
      sub_100673AA0();
    }
    int v16 = 7LL;
  }

          sub_10040F8BC(a2, v12);
          goto LABEL_49;
        }

        __int128 v23 = sub_10040F7FC(a2);
        sub_10040F7FC(a2);
        __int128 v24 = sub_10040F7FC(a2);
        sub_10040F7B0(a2);
        *(void *)buf = 0LL;
        v50[0] = 0;
        sub_100242CA4(v50);
        if (sub_100171EC4(a4, (uint64_t *)buf) || !sub_10017AB4C(*(unsigned int **)buf))
        {
          if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_ERROR)) {
            sub_10067456C(&v43, v44);
          }
        }

        else
        {
          *(_WORD *)(sub_10017AB4C(*(unsigned int **)buf) + _Block_object_dispose(va, 8) = v23;
          *(_WORD *)(sub_10017AB4C(*(unsigned int **)buf) + 32) = v24;
        }

        sub_100242CD0(v50);
        if (v12 >= 8) {
LABEL_47:
        }
          sub_10040F8BC(a2, v12 - 7);
LABEL_48:
        sub_100242CD8(v50);
LABEL_49:
        id v8 = (__int16)v13 - v12;
        uint64_t v9 = v8 << 16;
        __int128 v33 = v45;
        if (v45)
        {
          int v34 = sub_1003A6D9C((uint64_t)(v45 + 50));
          sub_1002701AC((uint64_t)v33, v34);
          if (*((_BYTE *)v33 + 704))
          {
            __int128 v35 = sub_1003A6D9C((uint64_t)(v33 + 50));
            sub_10054F434((uint64_t)v33, v35);
          }
        }

  sub_100242FAC((uint64_t)v27);
  return v3;
}
}

  v105 = 0;
  id v22 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENOverrideNumOfSightingsHighThreshold");
  __int128 v23 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v22 + 88LL))(v22, buf, __p, &v105);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v23) {
      goto LABEL_47;
    }
  }

  else if (!v23)
  {
    goto LABEL_47;
  }

  __int128 v24 = v105;
  *(_WORD *)(a1 + 21_Block_object_dispose(va, 8) = v105;
  __int128 v25 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Overriding fNumOfSightingsHighThreshold = %d ",  buf,  8u);
  }

    if (sub_1003D6054(a1))
    {
      LOWORD(v22_Block_object_dispose(va, 8) = -1;
      id v21 = -1;
    }

    else
    {
      LOWORD(v22_Block_object_dispose(va, 8) = *(_WORD *)(a1 + 128);
      id v21 = *(_BYTE *)(a1 + 130);
    }

    goto LABEL_42;
  }

  uint64_t v14 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C(a1, &v217);
    unsigned int v15 = v218;
    int v16 = (__int128 *)v217;
    unsigned int v17 = *(unsigned __int8 *)(a1 + 1369);
    uint64_t v18 = *(unsigned __int8 *)(a1 + 1370);
    char v19 = sub_1003CF350((unsigned __int8 *)a1);
    unint64_t v20 = &v217;
    *(_DWORD *)buf = 136446978;
    if (v15 < 0) {
      unint64_t v20 = v16;
    }
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&_BYTE buf[14] = v17;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v18;
    v139 = 1024;
    LODWORD(v140) = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Identification - 3rd Party Device  %{public}s. Waiting until all criteria is met. Product Name Update:%d SDP Query Complete:%d Paired:%d",  buf,  0x1Eu);
    if (v218 < 0)
    {
      uint64_t v13 = (void *)v217;
      goto LABEL_35;
    }
  }

  ++*(void *)(a1 + 24);
  return v10;
}

  return v7;
}

          unsigned int v15 = v13;
          break;
      }

      if (v15)
      {
        uint64_t v31 = (os_log_s *)qword_1008F7598;
        if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v14;
          char v50 = 1024;
          id v51 = v15;
          uint64_t v52 = 1024;
          id v53 = v13;
          _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "parseHFPDescriptor Key:%d Dumped %d of %d bytes ",  buf,  0x14u);
        }

        sub_10040F8BC(a2, v15);
      }

  ++*(void *)(a1 + 24);
  return v10;
}

    ++v25;
  }

  while (v25 != v24);
LABEL_47:
  if (v26 == v24) {
    goto LABEL_49;
  }
  uint64_t v13 = v26 - v22;
  if (v26 - v22 == -1) {
    goto LABEL_49;
  }
LABEL_63:
  std::string::basic_string(a2, (const std::string *)(a1 + 80), 0LL, v13, (std::allocator<char> *)&v37);
  return sub_100242FAC((uint64_t)v36);
}

  if ([v74 length])
  {
    v57 = sub_1002E8F6C();
    v111 = @"collectForTypes";
    v112 = v74;
    v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v112,  &v111,  1LL));
    (*(void (**)(uint64_t, void *))(*(void *)v57 + 184LL))(v57, v58);
  }

  if ((v10 & 1) == 0) {
    goto LABEL_47;
  }
  if (*(int *)(a1 + 80) >= 2)
  {
    __int128 v25 = xpc_dictionary_get_value(xdict, "KCBPeriodicAdvDataRandomData");
    if (v25)
    {
      __int128 v26 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_INFO))
      {
        LOWORD(__p) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "Raw bytes advertising data found",  (uint8_t *)&__p,  2u);
      }

      uint64_t v3 = sub_10025DBF4(v25, (uint64_t)&v31);
      if ((_DWORD)v3) {
        goto LABEL_47;
      }
      sub_10002EAC8(a3 + 48, (uint64_t)&v31);
    }
  }

  if (a2[4] != a2[3])
  {
    sub_100240540(v35, (uint64_t)(a2 + 3));
    __int128 v26 = sub_10032F26C((uint64_t **)v35);
    if (v35[0])
    {
      v35[1] = v35[0];
      operator delete(v35[0]);
    }

    xpc_dictionary_set_value(v34, "kCBMsgArgServices", v26);
    xpc_release(v26);
  }

  if (a2[7] != a2[6])
  {
    BOOL v27 = xpc_array_create(0LL, 0LL);
    uint64_t v29 = a2[6];
    for (uint64_t i = a2[7]; v29 != i; v29 += 18LL)
    {
      __p[0] = 0LL;
      __p[1] = 0LL;
      LOWORD(value) = 0;
      uuid_copy((unsigned __int8 *)__p, (const unsigned __int8 *)v29);
      LOWORD(value) = *(_WORD *)(v29 + 16);
      unsigned __int8 v30 = xpc_dictionary_create(0LL, 0LL, 0LL);
      uint64_t v31 = sub_100241F94((const unsigned __int8 *)__p);
      int v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
      sub_10043F7DC(a1, v30, v32);

      xpc_dictionary_set_int64(v30, "kCBMsgArgAttributeID", (unsigned __int16)value);
      xpc_array_append_value(v27, v30);
      xpc_release(v30);
    }

    xpc_dictionary_set_value(v34, "kCBMsgArgSubscribedHandles", v27);
    xpc_release(v27);
  }

  sub_10043F1F4(a1, 57LL, v34, 1);
}

  unsigned int v15 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "AllowAllConnectionParameterUpdates");
  int v16 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v15 + 88LL))(v15, buf, __p, &v172);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v16) {
      goto LABEL_52;
    }
  }

  else if (!v16)
  {
    goto LABEL_52;
  }

  unsigned int v17 = (os_log_s *)qword_1008F7620;
  if (v172)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Warning: Allow all connection parameters from remote request",  buf,  2u);
      uint64_t v18 = v172;
    }

    else
    {
      uint64_t v18 = 1;
    }

    byte_1008F1CF0 = v18 != 0;
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
  {
    sub_100696E24();
  }

      uint64_t v9 = 0LL;
LABEL_40:
      id v21 = &off_10087FAA8;
      if (v22) {
        sub_1002CD254(v22);
      }
      __int128 v23 = &off_10087FAA8;
      if (v24) {
        sub_1002CD254(v24);
      }
      __int128 v25 = &off_10087FAA8;
      if (v26) {
        sub_1002CD254(v26);
      }
      if (v13) {
        sub_1002CD254(v13);
      }
      goto LABEL_5;
    }

void sub_100032A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

id sub_100032B2C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _discoveryEvent:*(unsigned int *)(a1 + 48) device:*(void *)(a1 + 40) attributes:*(unsigned int *)(a1 + 52)];
}

id sub_100032B3C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _statusEvent:*(unsigned int *)(a1 + 48) device:*(void *)(a1 + 40) result:*(unsigned int *)(a1 + 52)];
}

void sub_100032B4C(id a1)
{
  id v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_100032B7C(_Unwind_Exception *a1)
{
}

void sub_100032B90(id a1)
{
  id v1 = operator new(0x260uLL);
  sub_100451734((uint64_t)v1);
  off_1008D63D0 = v1;
}

void sub_100032BC0(_Unwind_Exception *a1)
{
}

uint64_t sub_100032BD4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  return a1;
}

void sub_100032C2C(id a1)
{
  id v1 = operator new(0x138uLL);
  sub_1003FE3E0((uint64_t)v1);
  off_1008D5F48 = v1;
}

void sub_100032C5C(_Unwind_Exception *a1)
{
}

void sub_100032C70(id a1)
{
  id v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_100032CA0(_Unwind_Exception *a1)
{
}

void sub_100032F28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

uint64_t sub_100032F54(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100032F64(uint64_t a1)
{
}

void sub_100032F6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v3 + 40);
  NSAppendPrintF_safe(&obj, "%@\n", a3);
  objc_storeStrong((id *)(v3 + 40), obj);
}

void sub_100032FB8(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v6 + 40);
  NSAppendPrintF_safe(&obj, "%@\n", a3);
  objc_storeStrong((id *)(v6 + 40), obj);
  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
}

void *sub_1000333E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v4 == result[11]) {
    return [result _receivedWHBUpdateEvent:a2 options:a3];
  }
  return result;
}

void sub_100033404(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 32) == *(void *)(*(void *)(a1 + 40) + 24LL))
  {
    id v3 = a2;
    uint64_t v4 = objc_alloc_init(&OBJC_CLASS___CBDevice);
    -[CBDevice updateWithCBDevice:](v4, "updateWithCBDevice:", v3);

    [*(id *)(a1 + 40) deviceFound:v4 remoteController:0];
  }

void *sub_100033490(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[3]) {
    return [result deviceLost:a2 remoteController:0];
  }
  return result;
}

void sub_1000334B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5 == *(void *)(*(void *)(a1 + 40) + 24LL))
  {
    if (v3)
    {
      id v11 = v3;
      if (dword_1008D63E0 <= 30
        && (dword_1008D63E0 != -1 || _LogCategory_Initialize(&dword_1008D63E0, 30LL)))
      {
        uint64_t v6 = CUPrintNSError(v11);
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        LogPrintF_safe( &dword_1008D63E0,  "-[CBWHBDiscoveryDaemon activate]_block_invoke_4",  30LL,  "### Local discovery activate failed: %@",  v7);
      }

      [*(id *)(a1 + 32) invalidate];
      uint64_t v8 = *(void *)(a1 + 40);
      uint64_t v9 = *(void **)(v8 + 24);
      *(void *)(v8 + 24) = 0LL;

LABEL_11:
      uint64_t v4 = v11;
      goto LABEL_12;
    }

    if (dword_1008D63E0 <= 30)
    {
      id v11 = 0LL;
      if (dword_1008D63E0 == -1)
      {
        int v10 = _LogCategory_Initialize(&dword_1008D63E0, 30LL);
        uint64_t v4 = 0LL;
        if (!v10) {
          goto LABEL_12;
        }
        uint64_t v5 = *(void *)(a1 + 32);
      }

      LogPrintF_safe( &dword_1008D63E0,  "-[CBWHBDiscoveryDaemon activate]_block_invoke_4",  30LL,  "Local discovery activated: %@",  v5);
      goto LABEL_11;
    }
  }

void sub_1000336B4(id a1, NSString *a2, CBWHBRemoteController *a3, BOOL *a4)
{
}

void sub_100033BCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

id sub_100033BEC(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 setDiscoveryFlags:*(void *)(*(void *)(a1 + 32) + 16)];
}

void sub_100033C00(uint64_t a1, void *a2, void *a3)
{
  id v12 = a2;
  id v5 = a3;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 32) objectForKeyedSubscript:v12]);

  if (!v6)
  {
    uint64_t v7 = objc_alloc_init(&OBJC_CLASS___CBWHBRemoteController);
    -[CBWHBRemoteController setControllerID:](v7, "setControllerID:", v12);
    -[CBWHBRemoteController setDaemonServer:](v7, "setDaemonServer:", *(void *)(*(void *)(a1 + 32) + 48LL));
    -[CBWHBRemoteController setDiscoveryFlags:](v7, "setDiscoveryFlags:", *(void *)(*(void *)(a1 + 32) + 16LL));
    -[CBWHBRemoteController setDispatchQueue:](v7, "setDispatchQueue:", *(void *)(*(void *)(a1 + 32) + 80LL));
    -[CBWHBRemoteController setRemoteDevice:](v7, "setRemoteDevice:", v5);
    -[CBWHBRemoteController setWhbDaemon:](v7, "setWhbDaemon:", *(void *)(a1 + 32));
    -[CBWHBRemoteController activate](v7, "activate");
    uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 32LL);
    if (!v8)
    {
      uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v10 = *(void *)(a1 + 32);
      id v11 = *(void **)(v10 + 32);
      *(void *)(v10 + 32) = v9;

      uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 32LL);
    }

    [v8 setObject:v7 forKeyedSubscript:v12];
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  }
}

void sub_10003421C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100034240(uint64_t a1, uint64_t a2, void *a3)
{
  id v9 = a3;
  id v5 = [v9 lastSeenTicks];
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v8 = *(void *)(v6 + 40);
  uint64_t v7 = (id *)(v6 + 40);
  if (!v8 || (unint64_t)v5 >= *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
  {
    objc_storeStrong(v7, a3);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v5;
  }
}

id sub_1000348F4(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 idsDeviceIdentifier]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 name]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v1 roomName]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 model]);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v1 sourceVersion]);

  uint64_t v7 = NSPrintF_safe("ID %@, Name '%@', Room '%@', Model %@, Version %@", v2, v3, v4, v5, v6);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  return v8;
}

void *sub_100034C38(void *result, uint64_t a2)
{
  uint64_t v2 = result[5];
  if (result[4] == *(void *)(v2 + 16)) {
    return objc_msgSend(*(id *)(v2 + 64), "deviceFound:remoteController:", a2);
  }
  return result;
}

void *sub_100034C58(void *result, uint64_t a2)
{
  uint64_t v2 = result[5];
  if (result[4] == *(void *)(v2 + 16)) {
    return objc_msgSend(*(id *)(v2 + 64), "deviceLost:remoteController:", a2);
  }
  return result;
}

void sub_100034C78(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5 != *(void *)(*(void *)(a1 + 40) + 16LL)) {
    goto LABEL_2;
  }
  if (!v3)
  {
    if (dword_1008D63E0 <= 40)
    {
      if (dword_1008D63E0 == -1)
      {
        uint64_t v5 = *(void *)(a1 + 32);
      }

      LogPrintF_safe( &dword_1008D63E0,  "-[CBWHBRemoteController activate]_block_invoke_3",  40LL,  "Remote controller activated: %@",  v5);
    }

LABEL_24:
    *(void *)(*(void *)(a1 + 40) + 72LL) = 0LL;
    goto LABEL_2;
  }

  if (dword_1008D63E0 <= 40 && (dword_1008D63E0 != -1 || _LogCategory_Initialize(&dword_1008D63E0, 40LL)))
  {
    uint64_t v6 = CUPrintNSError(v4);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    LogPrintF_safe( &dword_1008D63E0,  "-[CBWHBRemoteController activate]_block_invoke_3",  40LL,  "### Remote controller activate failed: %@",  v7);
  }

  ++*(void *)(*(void *)(a1 + 40) + 72LL);
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) discoveredDevices]);
  id v9 = [v8 countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v25;
    do
    {
      for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v11) {
          objc_enumerationMutation(v8);
        }
        uint64_t v13 = *(void *)(*((void *)&v24 + 1) + 8LL * (void)i);
        uint64_t v14 = (void (**)(void, void))objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deviceLostHandler]);
        v14[2](v14, v13);
      }

      id v10 = [v8 countByEnumeratingWithState:&v24 objects:v28 count:16];
    }

    while (v10);
  }

  [*(id *)(a1 + 32) invalidate];
  uint64_t v15 = *(void *)(a1 + 40);
  int v16 = *(void **)(v15 + 16);
  *(void *)(v15 + 16) = 0LL;

  unint64_t v17 = *(void *)(*(void *)(a1 + 40) + 72LL);
  if (v17 > 5)
  {
    if (dword_1008D63E0 <= 40
      && (dword_1008D63E0 != -1 || _LogCategory_Initialize(&dword_1008D63E0, 40LL)))
    {
      uint64_t v21 = CUPrintNSError(v4);
      id v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      LogPrintF_safe( &dword_1008D63E0,  "-[CBWHBRemoteController activate]_block_invoke_3",  40LL,  "### Remote controller activate failed completely: %@",  v22);
    }
  }

  else
  {
    dispatch_time_t v18 = dispatch_time(0LL, 5000000000LL * v17);
    uint64_t v19 = *(void *)(a1 + 40);
    unint64_t v20 = *(dispatch_queue_s **)(v19 + 48);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100034F74;
    block[3] = &unk_10087EEC8;
    block[4] = v19;
    dispatch_after(v18, v20, block);
  }

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v48, 8);
}

  __int128 v27 = 3;
LABEL_25:
  uint64_t v15 = a1;
  uint64_t v6 = v47;
  uint64_t v12 = &qword_1008F29F0[134 * a1];
  LODWORD(a5) = v46;
LABEL_26:
  uint64_t v28 = qword_1008F29F0[134 * v15 + 12];
  if (v28)
  {
    else {
      a5 = v16;
    }
    if (v28 >= 5)
    {
      uint64_t v29 = v16 + 1;
      if (v29 < *v14)
      {
        unsigned __int8 v30 = v12;
        uint64_t v31 = sub_10008C384(a1, v29);
        uint64_t v12 = v30;
        if (v31) {
          a5 = v29;
        }
        else {
          a5 = a5;
        }
      }
    }

    v27 |= 4u;
    int v16 = a5;
  }

  if (sub_10008D8B4(*v12))
  {
    int v32 = *v14;
    if ((_DWORD)v32)
    {
      __int128 v33 = qword_1008F29F0[134 * v15 + 8];
      if (v33)
      {
        int v34 = *(unsigned __int8 *)(v33 + ((unint64_t)v16 << 6) + 1);
        __int128 v35 = HIDWORD(qword_1008F29F0[134 * v15 + 10]);
        if (v35 != v34)
        {
          int v36 = v15;
          char v37 = 0LL;
          uint64_t v38 = 0;
          v39 = 0;
          __int16 v40 = (unsigned __int8 *)(v33 + 1);
          do
          {
            __int16 v42 = *v40;
            v40 += 64;
            v41 = v42;
            if (v42 == v34) {
              v39 = v37;
            }
            if (v35 == v41) {
              uint64_t v38 = v37;
            }
            ++v37;
          }

          while (v32 != v37);
          if (v39 <= v38) {
            uint64_t v43 = v38;
          }
          else {
            uint64_t v43 = v39;
          }
          if (v43 > v16)
          {
            __int16 v44 = sub_10008C384(a1, v43);
            if (v44) {
              int v16 = v43;
            }
            else {
              int v16 = v16;
            }
            if (v44) {
              __int128 v27 = 32;
            }
          }

          uint64_t v15 = v36;
        }
      }
    }
  }

  HIDWORD(qword_1008F29F0[134 * v15 + 14]) = v16;
  *uint64_t v6 = v27;
  return v16;
}

  if ((dword_1008DDC54 & 0x10) != 0 && (*(_BYTE *)(v17 + 52) & 0x10) != 0) {
    __int128 v27 = 2576;
  }
  else {
    __int128 v27 = 2042;
  }
  if (sub_100092B20((uint64_t)a1, v16, *(void *)(v17 + 8) + v20 - 80, 1, v27))
  {
    uint64_t v21 = a1;
    id v22 = 6;
    return sub_100097CE4(v21, v22, v6, v5, 0);
  }

  *(_WORD *)(sub_10017AB4C(*(unsigned int **)(*(void *)(*((void *)&xmmword_1008DD4E8 + v31) + 8LL) + v20 - 16)) + _Block_object_dispose(va, 8) = v5;
  uint64_t v28 = sub_100097CE4( a1,  0,  v6,  v5,  *(_WORD *)(*(void *)(*(void *)(*((void *)&xmmword_1008DD4E8 + v31) + 8LL) + v20 - 16) + 4LL));
  uint64_t v29 = (_BYTE *)(*(void *)(*((void *)&xmmword_1008DD4E8 + v31) + 8LL) + v20);
  id result = *((void *)v29 - 2);
  if (v28)
  {
    id result = sub_1001734D8(result);
    *(void *)(*(void *)(*((void *)&xmmword_1008DD4E8 + v31) + 8LL) + v20 - 16) = 0LL;
  }

  else
  {
    *((_WORD *)v29 - 14) = *(_WORD *)(result + 4);
    void *v29 = v26[5];
    unsigned __int8 v30 = *(uint64_t (**)(__int128 *))(v26 + 20);
    if (v30) {
      return v30(a1);
    }
  }

  return result;
}

    uint64_t v5 = v13;
    sub_1001F4914((uint64_t)v26);
    return v5;
  }

  if (!*(_WORD *)(a2 + 1))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Invalid handle (0x%04x) for %s", v36, v37, v38, v39, v40, v41, v42, 0LL);
      uint64_t v43 = (os_log_s *)sub_100086554(0x44u);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    if ((v6 | 4) == 0x16)
    {
      __int128 v26 = 1;
      LOBYTE(v92[0]) = 1;
      BYTE1(v92[0]) = v6;
      WORD1(v92[0]) = 0;
      goto LABEL_38;
    }

    return 4021LL;
  }

  v91 = *(unsigned __int16 *)(a2 + 1);
  if (v6 == 22)
  {
    int v16 = *(unsigned __int16 *)(i + 8);
    unint64_t v17 = a3 - v15;
    if ((int)(v16 - 5) < (unsigned __int16)(a3 - v15))
    {
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Prepare Write sent with ValueLength=%d which is larger than allowed (ATT_MTU-5=%d)",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v17);
        __int128 v25 = (os_log_s *)sub_100086554(0x44u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      LOWORD(v92[0]) = 5633;
      WORD1(v92[0]) = v91;
      __int128 v26 = 13;
      goto LABEL_38;
    }
  }

  else
  {
    if (v6 != 18)
    {
      CFPropertyListRef v48 = 0LL;
      v46 = 0;
      int v45 = 0LL;
      v59 = 0;
      goto LABEL_60;
    }

    int v16 = *(unsigned __int16 *)(i + 8);
  }

  __int16 v44 = (char *)sub_1000B1814(v16);
  if (!v44)
  {
    LOBYTE(v92[0]) = 1;
    BYTE1(v92[0]) = v6;
    WORD1(v92[0]) = v91;
    __int128 v26 = 17;
    goto LABEL_38;
  }

  int v45 = v44;
  v46 = *(_WORD *)(i + 8);
  if (*a2 == 18) {
    v47 = 19;
  }
  else {
    v47 = 23;
  }
  *__int16 v44 = v47;
  uint64_t v8 = dword_1008E8938;
  CFPropertyListRef v48 = 1LL;
  uint64_t v14 = v91;
  if (v6 == 22 && !(void)xmmword_1008E8920)
  {
    v49 = v44;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"No callback provided to handle Prepare Writes!", v50, v51, v52, v53, v54, v55, v56, v83);
      v57 = (os_log_s *)sub_100086554(0x44u);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    v58 = 6;
    LOWORD(v14) = v91;
LABEL_81:
    LOBYTE(v92[0]) = 1;
    BYTE1(v92[0]) = v6;
    WORD1(v92[0]) = v14;
    BYTE4(v92[0]) = v58;
    v70 = sub_1001A6168(a1, (char *)v92, 5uLL, 0LL);
    int v45 = v49;
    goto LABEL_85;
  }

  v59 = v91;
LABEL_60:
  if (v14 < (unsigned __int16)word_1008E88C0
    && *(_BYTE *)(*((void *)&xmmword_1008E88B0 + 1) + 16 * v14) == 2
    && (size_t v60 = *(void *)(*((void *)&xmmword_1008E88B0 + 1) + 16 * v14 + 8)) != 0)
  {
    v85 = v59;
    v86 = v46;
    v87 = v48;
    ptr = v45;
    if (*((void *)&xmmword_1008E8920 + 1))
    {
      v84 = (unsigned __int8 *)(v60 + 4);
      v61 = *(void *)(*((void *)&xmmword_1008E88B0 + 1) + 16 * v14 + 8);
      v62 = sub_1001BEC7C((unsigned __int8 *)(v60 + 4), (unsigned __int8 *)&xmmword_1006BD89C);
      size_t v60 = v61;
      if (!v62)
      {
        v63 = sub_1001BEC7C(v84, (unsigned __int8 *)&xmmword_1006BD8B0);
        size_t v60 = v61;
        if (!v63)
        {
          v64 = sub_1001BEC7C(v84, (unsigned __int8 *)&xmmword_1006BD8C4);
          size_t v60 = v61;
          if (!v64)
          {
            (*((void (**)(uint64_t, uint64_t))&xmmword_1008E8920 + 1))(v61, i);
            size_t v60 = v61;
          }
        }
      }
    }

    v65 = v60;
    v66 = sub_1001A9E88(*(void *)i, *(unsigned __int8 *)(v60 + 26), 0);
    LOWORD(v14) = v91;
    int v45 = ptr;
    v46 = v86;
    CFPropertyListRef v48 = v87;
    v59 = v85;
    if (!v66)
    {
      v67 = *(uint64_t (**)(uint64_t))(v65 + 40);
      if (v67)
      {
        v66 = v67(v65);
        v59 = v85;
        v46 = v86;
        CFPropertyListRef v48 = v87;
        int v45 = ptr;
        LOWORD(v14) = v91;
      }

      else
      {
        v66 = 3;
      }
    }
  }

  else
  {
    v66 = 1;
  }

  if ((v6 | 4) == 0x16)
  {
    if (v66 != 240)
    {
      v58 = v66;
      if (!v66)
      {
        int v68 = v45;
        v58 = sub_1001A6168(a1, v45, v48, 0LL);
        if (v58)
        {
          LOBYTE(v92[0]) = 1;
          BYTE1(v92[0]) = v6;
          WORD1(v92[0]) = v91;
          BYTE4(v92[0]) = 17;
          v69 = sub_1001A6168(a1, (char *)v92, 5uLL, 0LL);
          v70 = 0LL;
          v58 = v69;
        }

        else
        {
          v70 = 0LL;
        }

        int v45 = v68;
        goto LABEL_85;
      }

      v49 = v45;
      goto LABEL_81;
    }

    v71 = v59;
    v88 = v48;
    int v72 = v46;
    ptra = v45;
    v73 = sub_1000B17F4(a3);
    if (v73)
    {
      uint64_t v74 = v73;
      memmove(v73, a2, a3);
      v92[0] = v8;
      v92[1] = sub_1001AA1A4;
      v92[2] = 0LL;
      v92[3] = i;
      v93 = v71;
      v94 = 0;
      v95 = 0;
      v96 = ptra;
      v97 = v72;
      v98 = v88;
      v99 = 0;
      v100 = v74;
      v101 = a3;
      v102 = 0;
      v103 = 0;
      sub_1001A96E8(v92);
      return 4540LL;
    }

    LOBYTE(v92[0]) = 1;
    BYTE1(v92[0]) = v6;
    WORD1(v92[0]) = v91;
    BYTE4(v92[0]) = 17;
    v70 = sub_1001A6168(a1, (char *)v92, 5uLL, 0LL);
    v58 = 240;
    int v45 = ptra;
  }

  else
  {
    v70 = 0LL;
    v58 = v66;
  }

    uint64_t v6 = (void *)*v5;
    uint64_t v7 = (void *)(a1 + 16);
  }

  while ((void *)*v5 != v5);
  if ((v32 & 1) == 0) {
    goto LABEL_30;
  }
LABEL_29:
  ++*(_BYTE *)(a1 + 82);
  *(_BYTE *)a1 = 1;
  sub_1001D9350(a1, *(unsigned __int16 *)(a1 + 4));
}

    sub_1001EE2A0();
    goto LABEL_25;
  }

  if (!a3 && a1) {
    goto LABEL_24;
  }
  if (dword_1008EDD24 == 4) {
    sub_1001E6A10(1);
  }
  if (a1) {
    __int128 v23 = sub_1001214B4(12, (uint64_t)sub_1001E93E4, a3, a4, a5, a6, a7, a8, a2);
  }
  else {
    __int128 v23 = sub_1001214B4(13, (uint64_t)sub_1001E93E4, a3, a4, a5, a6, a7, a8, a2);
  }
  int v32 = v23;
  if ((_DWORD)v23)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_SECMGR_PinCode %!", v33, v34, v35, v36, v37, v38, v39, v32);
      __int16 v40 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        goto LABEL_32;
      }
    }
  }

  if (*(_BYTE *)(a1 + 27))
  {
    if (!std::string::compare((const std::string *)(a1 + 72), "Alisha")
      || !std::string::compare((const std::string *)(a1 + 72), "All"))
    {
      uint64_t v19 = (os_log_s *)qword_1008F7750;
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Fake alisha device", buf, 2u);
      }

      unint64_t v20 = -[NSUUID initWithUUIDString:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDString:",  @"4DA4C51F-95BF-4550-82B7-F1CC159E0DB7");
      v69 = 0LL;
      memset(&buf[8], 0, 32);
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_100886D30);
      }
      sub_10056AB04(&buf[8], (const void *)(qword_1008D5F18 + 184), 0x10uLL);
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_100886D30);
      }
      sub_10056AB04(&buf[24], (const void *)(qword_1008D5F18 + 184), 0x10uLL);
      LODWORD(v69) = 0;
      BYTE4(v69) = 1;
      sub_100241F90(&valuePtr, v20);
      p_valuePtr = (const unsigned __int8 *)&valuePtr;
      uint64_t v21 = sub_1001FD770((uint64_t **)(a1 + 160), (unsigned __int8 *)&valuePtr, (uint64_t)&unk_1006C2518, &p_valuePtr);
      *((void *)v21 + 6) = *(void *)buf;
      sub_10002EAC8((uint64_t)(v21 + 56), (uint64_t)&buf[8]);
      sub_10002EAC8((uint64_t)(v21 + 72), (uint64_t)&buf[24]);
      *((_DWORD *)v21 + 22) = v69;
      v21[92] = BYTE4(v69);
      *(void *)&_BYTE buf[24] = &off_10087FAA8;
      if (*(void *)&buf[32]) {
        sub_1002CD254(*(unsigned int **)&buf[32]);
      }
      *(void *)&buf[8] = &off_10087FAA8;
      if (*(void *)&buf[16]) {
        sub_1002CD254(*(unsigned int **)&buf[16]);
      }
    }

    if (!std::string::compare((const std::string *)(a1 + 72), "FindMy")
      || !std::string::compare((const std::string *)(a1 + 72), "All"))
    {
      id v22 = (os_log_s *)qword_1008F7750;
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Fake FindMy keys", buf, 2u);
      }

      __int128 v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
      if (*(_DWORD *)(a1 + 232))
      {
        __int128 v24 = 0;
        do
        {
          memset(buf, 0, 37);
          arc4random_buf(buf, 0x25uLL);
          __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 36LL));
          [v23 addObject:v25];

          ++v24;
        }

        while (v24 < *(_DWORD *)(a1 + 232));
      }

      objc_storeStrong((id *)(a1 + 192), v23);
      *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = 15;
    }
  }

  if (*(_BYTE *)(a1 + 28))
  {
    __int128 v26 = (os_log_s *)qword_1008F7750;
    if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "LPM Factory Test mode: set flags.", buf, 2u);
    }
  }

  __int128 v27 = sub_1002E6E9C();
  (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v27 + 2896LL))(v27, 20LL, 0LL, 1LL);
  v62 = 0;
  sub_1001F91DC(1LL, &v62);
  v61 = 0;
  sub_1001F91DC(0LL, &v61);
  if (a2 != 1 || !v62)
  {
    if (!v61)
    {
      if (!v62)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
          sub_10065CF4C();
        }
        return 1400LL;
      }

      goto LABEL_61;
    }

    goto LABEL_54;
  }

  *(_BYTE *)(a1 + 64) |= 1u;
  if (v61)
  {
LABEL_54:
    if ((_os_feature_enabled_impl("FindMy", "BA_LPEM") & 1) == 0)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7750, OS_LOG_TYPE_ERROR)) {
        sub_10065CF20();
      }
      return 1405LL;
    }
  }

      if ((*(_BYTE *)(a1 + 55) & 0x80) == 0)
      {
        unint64_t v20 = *(_OWORD *)v6;
        uint64_t v21 = *((void *)v6 + 2);
        goto LABEL_29;
      }

      unint64_t v17 = *(void **)v6;
LABEL_28:
      uint64_t v8 = (uint64_t)sub_100024238(&v20, v17, v10);
LABEL_29:
      sub_1001FFF44(v8, 1LL, (void **)&v20, 1LL);
      if (SHIBYTE(v21) < 0)
      {
        p_dst = (void **)&v20;
LABEL_34:
        operator delete(*p_dst);
        goto LABEL_35;
      }

      goto LABEL_35;
    }
  }
}

    __int128 v27 = *(char **)(a1 + 680);
    if (a4)
    {
      uint64_t v28 = 0LL;
      uint64_t v29 = (void *)(a1 + 696);
      do
      {
        unsigned __int8 v30 = (os_log_s *)qword_1008F7560;
        if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = sub_1001EDE10((uint64_t)a3 + 6 * v28, v31, v32, v33, v34, v35, v36, v37);
          LODWORD(__p) = 67109378;
          HIDWORD(__p) = v28;
          v59 = 2080;
          size_t v60 = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Address of source [%d] in connection priority list update is %s",  (uint8_t *)&__p,  0x12u);
          __int128 v27 = *(char **)(a1 + 688);
        }

        v39 = (int *)((char *)a3 + 6 * v28);
        LODWORD(__p) = *v39;
        WORD2(__p) = *((_WORD *)v39 + 2);
        if ((unint64_t)v27 >= *v29)
        {
          v41 = *(void *)(a1 + 680);
          __int16 v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v27[-v41] >> 1);
          uint64_t v43 = v42 + 1;
          if (v42 + 1 > 0x2AAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556LL * ((*v29 - v41) >> 1) > v43) {
            uint64_t v43 = 0x5555555555555556LL * ((*v29 - v41) >> 1);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((*v29 - v41) >> 1) >= 0x1555555555555555LL) {
            __int16 v44 = 0x2AAAAAAAAAAAAAAALL;
          }
          else {
            __int16 v44 = v43;
          }
          if (v44) {
            int v45 = (char *)sub_100240848(a1 + 696, v44);
          }
          else {
            int v45 = 0LL;
          }
          v46 = &v45[6 * v42];
          *(_DWORD *)v46 = (_DWORD)__p;
          *((_WORD *)v46 + 2) = WORD2(__p);
          v47 = *(_WORD **)(a1 + 688);
          CFPropertyListRef v48 = *(_WORD **)(a1 + 680);
          v49 = v46;
          if (v47 != v48)
          {
            do
            {
              char v50 = *(_DWORD *)(v47 - 3);
              v47 -= 3;
              id v51 = v47[2];
              *(_DWORD *)(v49 - 6) = v50;
              v49 -= 6;
              *((_WORD *)v49 + 2) = v51;
            }

            while (v47 != v48);
            v47 = *(_WORD **)(a1 + 680);
          }

          *(void *)(a1 + 680) = v49;
          __int128 v27 = v46 + 6;
          *(void *)(a1 + 68_Block_object_dispose(va, 8) = v46 + 6;
          *(void *)(a1 + 696) = &v45[6 * v44];
          if (v47) {
            operator delete(v47);
          }
        }

        else
        {
          __int16 v40 = *v39;
          *((_WORD *)v27 + 2) = *((_WORD *)v39 + 2);
          *(_DWORD *)__int128 v27 = v40;
          v27 += 6;
        }

        *(void *)(a1 + 68_Block_object_dispose(va, 8) = v27;
        ++v28;
      }

      while (v28 != a4);
    }

    sub_10024088C((void *)(a1 + 632), &v57);
    return 0LL;
  }

  if (a2 == 1)
  {
    uint64_t v7 = (os_log_s *)qword_1008F7560;
    if (*(_BYTE *)(a1 + 618))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
        sub_10065FB2C();
      }
      return 17LL;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(*(void *)a1, &__p);
      uint64_t v11 = v61;
      uint64_t v12 = (void **)__p;
      unint64_t v20 = sub_1001EDE10((uint64_t)a3 + 6, v13, v14, v15, v16, v17, v18, v19);
      p_p = &__p;
      if (v11 < 0) {
        p_p = v12;
      }
      *(_DWORD *)buf = 136446466;
      v63 = p_p;
      v64 = 2080;
      v65 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Request TiPi connection priority list update for device %{public}s, TiPi source addr = %s",  buf,  0x16u);
      if (v61 < 0) {
        operator delete(__p);
      }
    }

    id v55 = *a3;
    v56 = *((_WORD *)a3 + 2);
    id v53 = *(int *)((char *)a3 + 6);
    v54 = *((_WORD *)a3 + 5);
    *(_BYTE *)(a1 + 61_Block_object_dispose(va, 8) = 1;
    sub_10021B218(a1, (uint64_t)&v55, (uint64_t)&v53);
    if (qword_1008D60E0 != -1) {
      dispatch_once(&qword_1008D60E0, &stru_100888C10);
    }
    id v22 = *(void *)a1;
    __int128 v23 = sub_10021B43C(a1);
    sub_10021B398(v23, v22, v23);
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472LL;
    v52[2] = sub_100236138;
    v52[3] = &unk_100888180;
    v52[4] = a1;
    __int128 v24 = objc_claimAutoreleasedReturnValue( +[NSTimer timerWithTimeInterval:repeats:block:]( &OBJC_CLASS___NSTimer,  "timerWithTimeInterval:repeats:block:",  0LL,  v52,  2.0));
    __int128 v25 = *(void **)(a1 + 624);
    *(void *)(a1 + 624) = v24;

    __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSRunLoop mainRunLoop](&OBJC_CLASS___NSRunLoop, "mainRunLoop"));
    [v26 addTimer:*(void *)(a1 + 624) forMode:NSDefaultRunLoopMode];

    goto LABEL_24;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_10065FACC();
  }
  return 3LL;
}

  sub_100242FAC((uint64_t)v43);
  return v27;
}

    uint64_t v7 = sub_100404EB8();
    __p = _NSConcreteStackBlock;
    id v10 = 3221225472LL;
    uint64_t v11 = sub_10025A730;
    uint64_t v12 = &unk_10087EB68;
    uint64_t v13 = v2;
    uint64_t v8 = 4;
    goto LABEL_25;
  }

  if (*(_BYTE *)(v3 + 1372))
  {
    if (*(_BYTE *)(a1 + 48))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F76F8, OS_LOG_TYPE_ERROR)) {
        sub_100664124();
      }
      return;
    }

    goto LABEL_22;
  }

  if (*(_BYTE *)(a1 + 48)) {
    goto LABEL_24;
  }
  if (os_log_type_enabled((os_log_t)qword_1008F76F8, OS_LOG_TYPE_ERROR)) {
    sub_1006640F8();
  }
}
}
}

  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithContentsOfFile:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithContentsOfFile:",  @"/var/mobile/Library/Preferences/com.apple.MobileBluetooth.ledevices.plist"));
  v92 = v29 != 0LL;
  memset(&buf, 0, sizeof(buf));
  if (!stat(v8, &buf))
  {
    if (v92 == 1 && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT)) {
      sub_10066A4B8();
    }
    unsigned __int8 v30 = sqlite3_open_v2(v8, p_otherDatabase, v11, 0LL);
    if (v30)
    {
      uint64_t v31 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
      {
        int v32 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
        *(_DWORD *)v95 = 136446722;
        *(void *)&v95[4] = v32;
        *(_WORD *)&v95[12] = 2080;
        *(void *)&v95[14] = v8;
        *(_WORD *)&v95[22] = 1024;
        *(_DWORD *)&v95[24] = v30;
        _os_log_error_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "Failed to open '%{public}s' cache at %s, result is %d",  v95,  0x1Cu);
      }
    }

    else
    {
      v85 = objc_opt_new(&OBJC_CLASS___NSDateFormatter);
      -[NSDateFormatter setDateFormat:](v85, "setDateFormat:", @"HH:mm:ss_MM-dd-yyyy");
      if (-[LeDeviceCache readIntFromDatabase:statement:value:]( self,  "readIntFromDatabase:statement:value:",  *p_otherDatabase,  @"SELECT value FROM _SqliteDatabaseProperties WHERE key = '_ClientVersion'",  &v92))
      {
        __int128 v33 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"SELECT COUNT() FROM sqlite_master WHERE type='table' AND name='%s';",
                  -[LeDeviceCache tableNameForType:](self, "tableNameForType:", a3)));
        v98[0] = 0;
        v84 = (void *)v33;
        int v34 = -[LeDeviceCache readIntFromDatabase:statement:value:]( self,  "readIntFromDatabase:statement:value:",  *p_otherDatabase,  v33,  v98);
        if (v98[0]) {
          __int128 v35 = v34;
        }
        else {
          __int128 v35 = 0;
        }
        if ((v35 & 1) != 0)
        {
          int v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"CREATE INDEX IF NOT EXISTS UuidIndex ON %s(Uuid);",
                            -[LeDeviceCache tableNameForType:](self, "tableNameForType:", a3)));
          char v37 = *p_otherDatabase;
          v83 = v36;
          uint64_t v38 = sqlite3_exec(v37, (const char *)[v83 UTF8String], 0, 0, 0);
          v39 = (os_log_s *)qword_1008F75A0;
          if (v38)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
            {
              __int16 v40 = sqlite3_errmsg(*p_otherDatabase);
              v41 = sqlite3_extended_errcode(*p_otherDatabase);
              *(_DWORD *)v95 = 67109634;
              *(_DWORD *)&v95[4] = v38;
              *(_WORD *)&v95[8] = 2080;
              *(void *)&v95[10] = v40;
              *(_WORD *)&v95[18] = 1024;
              *(_DWORD *)&v95[20] = v41;
              _os_log_error_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "Failed to create Uuid index with error %d (%s, %d)",  v95,  0x18u);
            }
          }

          else
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
            {
              CFPropertyListRef v48 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
              *(_DWORD *)v95 = 136446210;
              *(void *)&v95[4] = v48;
              _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_INFO,  "Created index for '%{public}s'",  v95,  0xCu);
            }

            v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"CREATE TABLE IF NOT EXISTS %s (%s TEXT, %s TEXT, UNIQUE(%s));CREATE INDEX IF NOT EXISTS %s ON %s (%s);",
                              "CustomProperties",
                              "Uuid",
                              "JSON",
                              "Uuid",
                              "CustomPropertiesIndex",
                              "CustomProperties",
                              "Uuid"));
            char v50 = *p_otherDatabase;
            v82 = v49;
            id v51 = v82;
            uint64_t v52 = sqlite3_exec(v50, (const char *)[v82 UTF8String], 0, 0, 0);
            id v53 = (os_log_s *)qword_1008F75A0;
            if (v52)
            {
              if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
              {
                v54 = sqlite3_errmsg(*p_otherDatabase);
                id v55 = sqlite3_extended_errcode(*p_otherDatabase);
                *(_DWORD *)v95 = 67109634;
                *(_DWORD *)&v95[4] = v52;
                *(_WORD *)&v95[8] = 2080;
                *(void *)&v95[10] = v54;
                *(_WORD *)&v95[18] = 1024;
                *(_DWORD *)&v95[20] = v55;
                _os_log_error_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "Failed to create CustomProperties table and index with error %d (%s, %d)",  v95,  0x18u);
                id v51 = v82;
              }
            }

            else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_INFO))
            {
              v56 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
              *(_DWORD *)v95 = 136446210;
              *(void *)&v95[4] = v56;
              _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_INFO,  "Verified CustomProperties table is ready and indexed for '%{public}s'",  v95,  0xCu);
            }
          }
        }

        else
        {
          int v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
          v46 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateFormatter stringFromDate:](v85, "stringFromDate:", v45));
          v47 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s.%@.corrupt", v8, v46));
          rename(v8, (const char *)[v47 UTF8String]);

          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
          {
            -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
            sub_10066A450();
          }

          v92 = 0;
          sqlite3_close_v2(*p_otherDatabase);
          *p_otherDatabase = 0LL;
        }
      }

      else
      {
        __int16 v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateFormatter stringFromDate:](v85, "stringFromDate:", v42));
        __int16 v44 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%s.%@.corrupt", v8, v43));
        rename(v8, (const char *)[v44 UTF8String]);

        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
        {
          -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
          sub_10066A484();
        }

        sqlite3_close_v2(*p_otherDatabase);
        *p_otherDatabase = 0LL;
      }
    }
  }

  if (!v92)
  {
    v61 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      v62 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
      *(_DWORD *)v95 = 136446210;
      *(void *)&v95[4] = v62;
      _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "Current '%{public}s' cache version is: none",  v95,  0xCu);
    }

    if (-[LeDeviceCache createDatabase:type:path:flags:]( self,  "createDatabase:type:path:flags:",  p_otherDatabase,  a3,  v8,  v11))
    {
      goto LABEL_71;
    }

    goto LABEL_68;
  }

  if (v92 != 1)
  {
    if (v92 == 2)
    {
      v57 = (os_log_s *)qword_1008F75A0;
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
      {
        v58 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
        *(_DWORD *)v95 = 136446466;
        *(void *)&v95[4] = v58;
        *(_WORD *)&v95[12] = 1024;
        *(_DWORD *)&v95[14] = v92;
        _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "Current '%{public}s' cache version is: up-to-date (v%d)",  v95,  0x12u);
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
    {
      -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
      sub_10066A3F0();
    }

    goto LABEL_71;
  }

  v59 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    size_t v60 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
    *(_DWORD *)v95 = 136446210;
    *(void *)&v95[4] = v60;
    _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "Current '%{public}s' cache version is: legacy plist",  v95,  0xCu);
  }

  if (!-[LeDeviceCache createDatabase:type:path:flags:]( self,  "createDatabase:type:path:flags:",  p_otherDatabase,  a3,  v8,  v11))
  {
LABEL_68:
    v63 = 0;
    goto LABEL_92;
  }

  -[LeDeviceCache migratePlistData:database:type:](self, "migratePlistData:database:type:", v29, *p_otherDatabase, a3);
LABEL_71:
  if (*p_otherDatabase)
  {
    sqlite3_extended_result_codes(*p_otherDatabase, 1);
    sqlite3_exec(*p_otherDatabase, "PRAGMA journal_mode = 'wal'", 0LL, 0LL, 0LL);
  }

  v64 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    v65 = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
    *(_DWORD *)v95 = 136446210;
    *(void *)&v95[4] = v65;
    _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEFAULT,  "Successfully loaded '%{public}s' cache from disk",  v95,  0xCu);
  }

  v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"INSERT INTO %s (Uuid, Name, NameOrigin, Address, ResolvedAddress, LastSeenTime, LastConnectionTime, GATTServiceChangeConfig, Tags, iCloudIdentifier) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)",  -[LeDeviceCache tableNameForType:](self, "tableNameForType:", a3)));
  v67 = *p_otherDatabase;
  int v68 = v66;
  v69 = sqlite3_prepare_v2(v67, (const char *)[v68 UTF8String], -1, ppStmt, 0);
  if (v69)
  {
    v70 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
    {
      ppStmta = -[LeDeviceCache friendlyNameForType:](self, "friendlyNameForType:", a3);
      v76 = sqlite3_errmsg(*p_otherDatabase);
      v77 = sqlite3_extended_errcode(*p_otherDatabase);
      *(_DWORD *)v95 = 136446978;
      *(void *)&v95[4] = ppStmta;
      *(_WORD *)&v95[12] = 1024;
      *(_DWORD *)&v95[14] = v69;
      *(_WORD *)&v95[18] = 2082;
      *(void *)&v95[20] = v76;
      v96 = 1024;
      v97 = v77;
      _os_log_error_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_ERROR,  "Failed to create prepared write statement for '%{public}s' cache with error %d (%{public}s, %d)",  v95,  0x22u);
    }
  }

  v91 = 0;
  v71 = sub_1002E6E00();
  sub_10002418C(v95, "LeDeviceCache");
  sub_10002418C(__p, "WipeNameOrigin");
  (*(void (**)(uint64_t, _BYTE *, void **, char *))(*(void *)v71 + 72LL))(v71, v95, __p, &v91);
  if (v90 < 0) {
    operator delete(__p[0]);
  }
  if ((v95[23] & 0x80000000) != 0) {
    operator delete(*(void **)v95);
  }
  if (qword_1008D6198 != -1) {
    dispatch_once(&qword_1008D6198, &stru_10088FF58);
  }
  int v72 = sub_100447F0C((uint64_t)off_1008D6190);
  if (v91) {
    v73 = 1;
  }
  else {
    v73 = v72;
  }
  if (v73 == 1)
  {
    uint64_t v74 = (os_log_s *)qword_1008F75A0;
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v95 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "LeDeviceCache Wipe Name Origin for all LE devices",  v95,  2u);
    }

    -[LeDeviceCache wipeDatabaseNameOrigin:](self, "wipeDatabaseNameOrigin:", a3);
  }

  v63 = 1;
LABEL_92:

  return v63;
}

        uint64_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_BOOL(v12, XPC_ACTIVITY_REPEATING, 1);
        xpc_dictionary_set_int64(v12, XPC_ACTIVITY_DELAY, XPC_ACTIVITY_INTERVAL_1_DAY);
        xpc_dictionary_set_int64(v12, XPC_ACTIVITY_GRACE_PERIOD, XPC_ACTIVITY_INTERVAL_1_MIN);
        xpc_dictionary_set_string(v12, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_10031C15C;
        handler[3] = &unk_100890BA8;
        void handler[4] = v2;
        xpc_activity_register("com.apple.Bluetooth.PowerStateMonitor", v12, handler);
        v2[681] = 1;
        v2[684] = 1;
      }

      break;
    default:
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
        sub_10066BA60();
      }
      break;
  }

  uint64_t v6 = 2LL;
LABEL_25:
  uint64_t v12 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_INFO))
  {
    uint64_t v14 = 67109120;
    uint64_t v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "selected input caps : %d", (uint8_t *)&v14, 8u);
  }

  return v6;
}

  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFEE8) {
      uint64_t v12 = "enabled";
    }
    else {
      uint64_t v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for Extended Scanning is %s",  buf,  0xCu);
  }

  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008EFEF8) {
      uint64_t v12 = "enabled";
    }
    else {
      uint64_t v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for Extended Advertising is %s",  buf,  0xCu);
  }

  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F0060) {
      uint64_t v12 = "enabled";
    }
    else {
      uint64_t v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for BT 5.0 advertising sets is %s",  buf,  0xCu);
  }

  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F0070) {
      uint64_t v12 = "enabled";
    }
    else {
      uint64_t v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for Enhanced Connections is %s",  buf,  0xCu);
  }

    uint64_t v13 = (void *)v5[1];
    if (v13)
    {
      do
      {
        uint64_t v14 = v13;
        uint64_t v13 = (void *)*v13;
      }

      while (v13);
    }

    else
    {
      do
      {
        uint64_t v14 = (void *)v5[2];
        uint64_t v12 = *v14 == (void)v5;
        uint64_t v5 = v14;
      }

      while (!v12);
    }

    uint64_t v5 = v14;
    if (v14 == a1 + 64) {
      return 0LL;
    }
  }

  dispatch_time_t v18 = (os_log_s *)qword_1008F7558;
  if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Wireless Splitter enabled using defaults writes with device with handle=%d",  buf,  8u);
  }

  return v7;
}

  if (v3 - 8202 > 0x15 || ((1 << (v3 - 10)) & 0x20033F) == 0) {
    goto LABEL_26;
  }
LABEL_4:
  if (((1LL << a2) & 0x3800C01000LL) != 0) {
    return 1LL;
  }
  if (a2 != 1LL)
  {
    if (a2 != 32LL) {
      goto LABEL_29;
    }
LABEL_27:
    uint64_t v6 = *(_BYTE *)(a1 + 1100);
    return v6 & 1;
  }

  if (v3 >> 1 == 4103) {
    return 1LL;
  }
LABEL_29:
  if (!*(_BYTE *)(a1 + 1069)) {
    return 0LL;
  }
  id result = 0LL;
  switch(a2)
  {
    case 0:
      uint64_t v6 = *(_BYTE *)(a1 + 1088);
      return v6 & 1;
    case 1:
      uint64_t v8 = *(unsigned __int8 *)(a1 + 1088);
      goto LABEL_76;
    case 2:
      id v9 = *(unsigned __int8 *)(a1 + 1088);
      goto LABEL_78;
    case 3:
      id v10 = *(unsigned __int8 *)(a1 + 1088);
      goto LABEL_80;
    case 4:
      uint64_t v11 = *(unsigned __int8 *)(a1 + 1088);
      goto LABEL_82;
    case 5:
    case 6:
      uint64_t v7 = *(unsigned __int8 *)(a1 + 1088);
      goto LABEL_84;
    case 7:
      uint64_t v12 = *(unsigned __int8 *)(a1 + 1088);
      return v12 >> 7;
    case 8:
      uint64_t v6 = *(_BYTE *)(a1 + 1089);
      return v6 & 1;
    case 9:
      uint64_t v8 = *(unsigned __int8 *)(a1 + 1089);
      goto LABEL_76;
    case 10:
      id v9 = *(unsigned __int8 *)(a1 + 1089);
      goto LABEL_78;
    case 11:
      id v10 = *(unsigned __int8 *)(a1 + 1089);
      goto LABEL_80;
    case 12:
      uint64_t v11 = *(unsigned __int8 *)(a1 + 1089);
      goto LABEL_82;
    case 13:
      uint64_t v7 = *(unsigned __int8 *)(a1 + 1089);
      goto LABEL_84;
    case 14:
      uint64_t v13 = *(unsigned __int8 *)(a1 + 1089);
      goto LABEL_86;
    case 15:
      uint64_t v12 = *(unsigned __int8 *)(a1 + 1089);
      return v12 >> 7;
    case 16:
      uint64_t v6 = *(_BYTE *)(a1 + 1090);
      return v6 & 1;
    case 17:
      uint64_t v8 = *(unsigned __int8 *)(a1 + 1090);
      goto LABEL_76;
    case 19:
      id v10 = *(unsigned __int8 *)(a1 + 1090);
      goto LABEL_80;
    case 20:
      uint64_t v11 = *(unsigned __int8 *)(a1 + 1090);
      goto LABEL_82;
    case 21:
      uint64_t v7 = *(unsigned __int8 *)(a1 + 1090);
      goto LABEL_84;
    case 22:
      uint64_t v13 = *(unsigned __int8 *)(a1 + 1090);
      goto LABEL_86;
    case 23:
      uint64_t v12 = *(unsigned __int8 *)(a1 + 1090);
      return v12 >> 7;
    case 24:
      uint64_t v6 = *(_BYTE *)(a1 + 1091);
      return v6 & 1;
    case 25:
      uint64_t v8 = *(unsigned __int8 *)(a1 + 1091);
      goto LABEL_76;
    case 27:
      id v10 = *(unsigned __int8 *)(a1 + 1091);
      goto LABEL_80;
    case 28:
      uint64_t v11 = *(unsigned __int8 *)(a1 + 1091);
      goto LABEL_82;
    case 29:
      uint64_t v7 = *(unsigned __int8 *)(a1 + 1091);
      goto LABEL_84;
    case 30:
      uint64_t v13 = *(unsigned __int8 *)(a1 + 1091);
      goto LABEL_86;
    case 31:
      return *(_DWORD *)(a1 + 1088) >> 31;
    case 33:
      uint64_t v8 = *(unsigned __int8 *)(a1 + 1100);
      goto LABEL_76;
    case 34:
      id v9 = *(unsigned __int8 *)(a1 + 1100);
      goto LABEL_78;
    case 35:
      uint64_t v7 = *(unsigned __int8 *)(a1 + 1100);
      goto LABEL_84;
    case 36:
      uint64_t v13 = *(unsigned __int8 *)(a1 + 1100);
      goto LABEL_86;
    case 37:
      uint64_t v12 = *(unsigned __int8 *)(a1 + 1100);
      return v12 >> 7;
    case 38:
      uint64_t v6 = *(_BYTE *)(a1 + 1101);
      return v6 & 1;
    case 39:
      uint64_t v8 = *(unsigned __int8 *)(a1 + 1101);
      goto LABEL_76;
    case 40:
      id v9 = *(unsigned __int8 *)(a1 + 1101);
      goto LABEL_78;
    case 41:
      id v10 = *(unsigned __int8 *)(a1 + 1101);
      goto LABEL_80;
    case 42:
      uint64_t v11 = *(unsigned __int8 *)(a1 + 1101);
      goto LABEL_82;
    case 43:
      uint64_t v7 = *(unsigned __int8 *)(a1 + 1101);
      goto LABEL_84;
    case 44:
      uint64_t v13 = *(unsigned __int8 *)(a1 + 1101);
      goto LABEL_86;
    case 45:
      uint64_t v6 = *(_BYTE *)(a1 + 1102);
      return v6 & 1;
    case 46:
      uint64_t v8 = *(unsigned __int8 *)(a1 + 1102);
LABEL_76:
      id result = (v8 >> 1) & 1;
      break;
    case 47:
      id v9 = *(unsigned __int8 *)(a1 + 1102);
LABEL_78:
      id result = (v9 >> 2) & 1;
      break;
    case 48:
      id v10 = *(unsigned __int8 *)(a1 + 1102);
LABEL_80:
      id result = (v10 >> 3) & 1;
      break;
    case 49:
      uint64_t v11 = *(unsigned __int8 *)(a1 + 1102);
LABEL_82:
      id result = (v11 >> 4) & 1;
      break;
    case 50:
      uint64_t v7 = *(unsigned __int8 *)(a1 + 1102);
LABEL_84:
      id result = (v7 >> 5) & 1;
      break;
    case 51:
      uint64_t v13 = *(unsigned __int8 *)(a1 + 1102);
LABEL_86:
      id result = (v13 >> 6) & 1;
      break;
    default:
      return result;
  }

  return result;
}

  __p = 0LL;
  v39 = 0LL;
  __int16 v40 = 0LL;
  sub_10002418C(&__p, "\n|>> ServiceClass: ");
  memset(&buf, 0, sizeof(buf));
  if (*(_BYTE *)a2 == 3)
  {
    else {
      uint64_t v15 = sub_1001EBA4C(*(unsigned int *)(a2 + 8));
    }
    std::string::assign(&buf, v15);
  }

  __int128 v35 = 0LL;
  int v36 = 0LL;
  char v37 = 0LL;
  sub_10002418C(&v35, "\n");
  sub_1003D4034((const void **)&__p, (const void **)&buf.__r_.__value_.__l.__data_, &v34);
  if (v37 >= 0) {
    int v16 = (const std::string::value_type *)&v35;
  }
  else {
    int v16 = (const std::string::value_type *)v35;
  }
  if (v37 >= 0) {
    unint64_t v17 = HIBYTE(v37);
  }
  else {
    unint64_t v17 = v36;
  }
  dispatch_time_t v18 = std::string::append(&v34, v16, v17);
  uint64_t v19 = (void *)v18->__r_.__value_.__r.__words[0];
  size = (char)v18->__r_.__value_.__s.__size_;
  v18->__r_.__value_.__r.__words[0] = 0LL;
  v18->__r_.__value_.__l.__size_ = 0LL;
  v18->__r_.__value_.__l.__cap_ = 0LL;
  *(_OWORD *)&v34.__r_.__value_.__r.__words[1] = 0uLL;
  v34.__r_.__value_.__r.__words[0] = (std::string::size_type)&v34.__r_.__value_.__l.__size_;
  __int128 v23 = (void *)*a3;
  uint64_t v21 = a3 + 1;
  id v22 = v23;
  if (v23 != v21)
  {
    do
    {
      __int128 v33 = *((_DWORD *)v22 + 8);
      int v32 = *(_OWORD *)(v22 + 5);
      uint64_t v31 = 0uLL;
      if (sub_10025FD88(&v31, (uint64_t)&v32))
      {
        __int16 v42 = &v33;
        __int128 v24 = sub_1002DBC4C((uint64_t **)&v34, &v33, (uint64_t)&unk_1006C2518, &v42);
        *(_OWORD *)(v24 + 5) = v31;
      }

      __int128 v25 = (void *)v22[1];
      if (v25)
      {
        do
        {
          __int128 v26 = v25;
          __int128 v25 = (void *)*v25;
        }

        while (v25);
      }

      else
      {
        do
        {
          __int128 v26 = (void *)v22[2];
          uint64_t v11 = *v26 == (void)v22;
          id v22 = v26;
        }

        while (!v11);
      }

      id v22 = v26;
    }

    while (v26 != v21);
  }

  *(void *)&uint64_t v31 = calloc(1uLL, 0x10uLL);
  sub_10025FD88((_BYTE *)v31, a2);
  *(void *)&int v32 = &v31;
  __int128 v27 = (uint64_t **)(sub_1002554E8( (uint64_t **)(a1 + 584),  (unint64_t *)&v31,  (uint64_t)&unk_1006C2518,  (uint64_t **)&v32)
                   + 5);
  sub_100242F54((uint64_t)v41);
  sub_1003D463C((_BYTE *)a1);
  uint64_t v28 = sub_100404EB8();
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472LL;
  v30[2] = sub_1003D4C48;
  v30[3] = &unk_10087EB20;
  v30[4] = a1;
  sub_100405384(v28, v30);
  sub_10023BF24((uint64_t)&v34, (void *)v34.__r_.__value_.__l.__size_);
  if (size < 0) {
    operator delete(v19);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(v35);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete(__p);
  }
  return sub_100242FAC((uint64_t)v41);
}

  uint64_t v21 = 0LL;
LABEL_25:
  sub_100242FAC((uint64_t)v53);
  return v21;
}
}

    uint64_t v7 = v11;
    goto LABEL_25;
  }

  uint64_t v5 = sub_1002E6E9C();
  id result = (*(uint64_t (**)(uint64_t, uint64_t, __int16 *, uint64_t))(*(void *)v5 + 584LL))( v5,  146LL,  &v17,  a1 + 650);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v7 = v17;
LABEL_25:
  *(_WORD *)(a1 + 814) = v7;
  return result;
}

  if (*a4)
  {
    *a6 &= ~2u;
    uint64_t v19 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Warning: Disabling ePA for retransmission policy through defaults write",  buf,  2u);
    }
  }

  if (*a5)
  {
    *a6 &= ~1u;
    unint64_t v20 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Warning: Disabling threshold based ePA policy through defaults write",  buf,  2u);
    }
  }

LABEL_25:
      return;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
      sub_100689E98();
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
    sub_100690988(a1);
  }
  return 10LL;
}

      std::string::push_back(this, v4);
LABEL_25:
      uint64_t v8 = *v5++;
      LOBYTE(v4) = v8;
    }

    while (v8);
  }

  unint64_t v17 = v39;
  if (v39)
  {
    p_shared_owners = (unint64_t *)&v39->__shared_owners_;
    do
      uint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

      int v32 = sub_1002E6E9C();
      HIWORD(v4_Block_object_dispose(va, 8) = v25;
      BYTE4(v4_Block_object_dispose(va, 8) = v27;
      WORD1(v4_Block_object_dispose(va, 8) = v28;
      LOWORD(v4_Block_object_dispose(va, 8) = v28;
      (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, __int16))(*(void *)v32 + 1736LL))( v32,  *v60,  a3,  a4,  v23,  &v62,  v21,  v18,  v48,  v26);
      return 0LL;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100698F38();
    }
    return 11LL;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
    sub_100698F64();
  }
  return 7LL;
}

  if ((size & 1) != 0 || (a4 & 1) != 0) {
    goto LABEL_4;
  }
  return 0LL;
}
}

  HIWORD(v137[0]) = 0;
  LOWORD(v137[0]) = 257;
  *(void *)&v137[1] = 0LL;
  BYTE4(v137[0]) = 1;
  BYTE8(v137[0]) = 1;
  LODWORD(v137[2]) = 19660830;
  DWORD2(v137[2]) = 1;
  uint64_t v19 = v137[1];
  *(_OWORD *)a3 = v137[0];
  *(_OWORD *)(a3 + 16) = v19;
  *(_OWORD *)(a3 + 2_Block_object_dispose(va, 8) = *(_OWORD *)((char *)&v137[1] + 12);
  *(_OWORD *)(a3 + 4_Block_object_dispose(va, 8) = v138[0];
  *(void *)(a3 + 64) = *(void *)&v138[1];
  memset(v138, 0, 24);
  *(_OWORD *)(a3 + 72) = *(_OWORD *)((char *)&v138[1] + 8);
  *(void *)(a3 + 8_Block_object_dispose(va, 8) = *((void *)&v138[2] + 1);
  memset((char *)&v138[1] + 8, 0, 24);
  *(_BYTE *)(a3 + 96) = v139;

LABEL_108:
  if (*((void *)&v138[1] + 1))
  {
    *(void *)&v138[2] = *((void *)&v138[1] + 1);
    operator delete(*((void **)&v138[1] + 1));
  }

  v207.n128_u64[0] = (unint64_t)v138;
  sub_10004FEA4((void ***)&v207);
  if (*((void *)&v141[1] + 1))
  {
    *(void *)&v141[2] = *((void *)&v141[1] + 1);
    operator delete(*((void **)&v141[1] + 1));
  }

  *(void *)&v137[0] = v141;
  sub_10004FEA4((void ***)v137);
}

    uint64_t v4 = 0;
LABEL_25:
    uint64_t v11 = v4 & 1;
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  uint64_t v12 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    v14[0] = 67109120;
    v14[1] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "overrideEnableGlobalDupFilter:%d",  (uint8_t *)v14,  8u);
  }

  return v11;
}

  uint64_t v11 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "DebugAllowedList");
  uint64_t v12 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v11 + 72LL))(v11, buf, __p, &v38);
  if ((_BYTE)v38) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v13) {
      goto LABEL_35;
    }
  }

  else if (!v13)
  {
    goto LABEL_35;
  }

  *(_BYTE *)(a1 + 153) = 1;
  uint64_t v14 = (os_log_s *)qword_1008F7698;
  if (os_log_type_enabled((os_log_t)qword_1008F7698, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding - Enable Debugging Allowed List.",  buf,  2u);
  }

LABEL_2:
}
}

        sub_1001EE2A0();
      }

      return;
  }

  if ((sub_1000A86F0() & 1) != 0)
  {
    sub_1001EE134((uint64_t)"Rejecting connection with status %!", v4, v5, v6, v7, v8, v9, v10, 1709LL);
    uint64_t v11 = (os_log_s *)sub_100086554(6u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return sub_1000B82E0(a1, 0, 1709);
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Could not start LE scan (leScanParamsLPCoreCb): %!", v13, v14, v15, v16, v17, v18, v19, v8);
    unint64_t v20 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  xmmword_1008ED8D8 = 0u;
  *(_OWORD *)&byte_1008ED8E8 = 0u;
  *(_OWORD *)&unk_1008ED8B8 = 0u;
  *(_OWORD *)&qword_1008ED8C8 = 0u;
  byte_1008ED902 = 0;
  if (v10) {
    v10(v8, v9);
  }
  else {
    sub_1001EE2A0();
  }
}

  if (a4) {
    *a4 = *v9;
  }
  id v10 = *v9;
  if (*(void *)(*v9 + 8) != a2)
  {
    __p = 0LL;
    __int128 v27 = 0LL;
    uint64_t v28 = 0LL;
    sub_100240540(&__p, v10 + 104);
    uint64_t v11 = (char *)__p;
    uint64_t v12 = (char *)__p;
    if (__p != v27)
    {
      do
      {
        if (*(void *)(*(void *)v12 + 8LL) == a2)
        {
          if (a3)
          {
            *a3 = *v9;
            uint64_t v4 = *(void *)v12;
            unint64_t v17 = 1;
          }

          else
          {
            unint64_t v17 = 1;
            uint64_t v4 = *(void *)v12;
          }

          goto LABEL_39;
        }

        v12 += 8;
      }

      while (v12 != v27);
    }

    __int128 v23 = 0LL;
    __int128 v24 = 0LL;
    __int128 v25 = 0LL;
    sub_100240540(&v23, *v9 + 136);
    uint64_t v13 = v23;
    if (v23 == v24)
    {
      unint64_t v17 = 0;
      if (v23) {
        goto LABEL_37;
      }
      goto LABEL_38;
    }

    while (1)
    {
      uint64_t v14 = *(void *)v13;
      if (*(void *)(*(void *)v13 + 8LL) == a2)
      {
        if (a3)
        {
          *a3 = *v9;
          goto LABEL_33;
        }

  if (*(_OWORD *)(a1 + 49) == 0LL || !*(_BYTE *)(a1 + 241))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
      sub_10067A5FC();
    }
    return 1LL;
  }

  v36[0] = 0LL;
  v36[1] = 0LL;
  sub_100242F28((uint64_t)v36, a1 + 104);
  uint64_t v8 = *(unsigned __int8 ****)(a1 + 176);
  id v9 = *(unsigned __int8 ****)(a1 + 184);
  if (v8 != v9)
  {
    id v10 = *(unsigned __int8 ****)(a1 + 176);
    do
    {
      if (**v10 == a2) {
        goto LABEL_50;
      }
      ++v10;
    }

    while (v10 != v9);
  }

  uint64_t v11 = (os_log_s *)(id)qword_1008F7600;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003CF00C((uint64_t)a2, __p);
    uint64_t v12 = v35 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136446210;
    uint64_t v38 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "creating new Magic pairing device for device %{public}s",  buf,  0xCu);
    if (v35 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v13 = operator new(0x78uLL);
  *((void *)v13 + 11) = 0LL;
  *((void *)v13 + 12) = 0LL;
  *((void *)v13 + 13) = 0LL;
  *((_BYTE *)v13 + 112) = -1;
  *(void *)uint64_t v13 = a2;
  v13[21] = 0;
  *(_OWORD *)(v13 + 2) = 0u;
  *(_OWORD *)(v13 + 6) = 0u;
  *(_OWORD *)(v13 + 10) = 0u;
  *(_OWORD *)(v13 + 14) = 0u;
  v13[18] = 0;
  if (sub_1003F01F0((uint64_t *)v13, a1 + 49, a1 + 65))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7600, OS_LOG_TYPE_ERROR)) {
      sub_10067A628();
    }
    operator delete(v13);
    uint64_t v14 = 1LL;
  }

  else
  {
    v13[18] = 1;
    dispatch_time_t v18 = *(void *)(a1 + 192);
    uint64_t v19 = *(void **)(a1 + 184);
    if ((unint64_t)v19 >= v18)
    {
      uint64_t v21 = *(void *)(a1 + 176);
      id v22 = ((uint64_t)v19 - v21) >> 3;
      __int128 v23 = v18 - v21;
      __int128 v24 = v23 >> 2;
      else {
        __int128 v25 = v24;
      }
      if (v25) {
        __int128 v26 = (char *)sub_100008BA0(a1 + 192, v25);
      }
      else {
        __int128 v26 = 0LL;
      }
      __int128 v27 = &v26[8 * v22];
      uint64_t v28 = &v26[8 * v25];
      *(void *)__int128 v27 = v13;
      unint64_t v20 = v27 + 8;
      unsigned __int8 v30 = *(char **)(a1 + 176);
      uint64_t v29 = *(char **)(a1 + 184);
      if (v29 != v30)
      {
        do
        {
          uint64_t v31 = *((void *)v29 - 1);
          v29 -= 8;
          *((void *)v27 - 1) = v31;
          v27 -= 8;
        }

        while (v29 != v30);
        uint64_t v29 = *(char **)(a1 + 176);
      }

      *(void *)(a1 + 176) = v27;
      *(void *)(a1 + 184) = v20;
      *(void *)(a1 + 192) = v28;
      if (v29) {
        operator delete(v29);
      }
    }

    else
    {
      NSMutableArray *v19 = v13;
      unint64_t v20 = v19 + 1;
    }

    *(void *)(a1 + 184) = v20;
    if (qword_1008D67B8 != -1) {
      dispatch_once(&qword_1008D67B8, &stru_100896238);
    }
    sub_10053645C((uint64_t)off_1008D67B0, a2);
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    sub_1003EDDE0((void *)a1);
    sub_1003F0354(a1, (uint64_t)a2);
    sub_100242CD8(__p);
    uint64_t v8 = *(unsigned __int8 ****)(a1 + 176);
    id v9 = *(unsigned __int8 ****)(a1 + 184);
LABEL_50:
    while (v8 != v9)
    {
      int v32 = *v8;
      if (**v8 == a2) {
        goto LABEL_52;
      }
      ++v8;
    }

    int v32 = 0LL;
LABEL_52:
    uint64_t v14 = 0LL;
    *a3 = *(_OWORD *)(v32 + 5);
    *a4 = *(_OWORD *)(v32 + 7);
  }

  sub_100242FAC((uint64_t)v36);
  return v14;
}

  sub_10053CFAC(a1, v4, (uint64_t)&__p);
  if (__p)
  {
    __int128 v33 = __p;
    operator delete(__p);
  }

  uint64_t v8 = *a4;
  *(void *)uu = 0LL;
  __int128 v35 = 0LL;
  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684((uint64_t)off_1008D5F28, a2, 0, 1u, 0LL, 0LL, uu);
  if (uuid_is_null(uu))
  {
    id v9 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_FAULT)) {
      sub_10069F818(a2, v9);
    }
  }

  if (uuid_is_null(uu)) {
    goto LABEL_8;
  }
  uint64_t v14 = *(uint64_t (****)(void, void *, void))(a1 + 560);
  if (!v14
    || (uint64_t v15 = sub_100241F94(uu),
        int v16 = (void *)objc_claimAutoreleasedReturnValue(v15),
        unint64_t v17 = (**v14)(v14, v16, 0LL),
        v16,
        !v17))
  {
    unint64_t v20 = (os_log_s *)qword_1008F75A8;
    if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR)) {
      sub_10069F76C(uu, v20);
    }
LABEL_8:
    LOBYTE(__p[0]) = 0;
    sub_100242CA4(__p);
    id v10 = sub_1001BCDB0(a2);
    LODWORD(v28[0]) = v10;
    BYTE6(v28[0]) = BYTE6(v10);
    WORD2(v28[0]) = WORD2(v10);
    uint64_t v11 = sub_1001CBD38(v28);
    sub_100242CD0(__p);
    if (v11)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = sub_1005BFB9C(a2);
        objc_claimAutoreleasedReturnValue(v12);
        sub_10069F71C();
      }
    }

    sub_100242CD8(__p);
    return;
  }

  dispatch_time_t v18 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    if (a3 >= 3)
    {
      if ((_DWORD)a3 == 4) {
        uint64_t v19 = "Numeric Comparison";
      }
      else {
        uint64_t v19 = "Out-of-band";
      }
    }

    else
    {
      uint64_t v19 = off_1008A4698[(int)a3];
    }

    uint64_t v21 = v28;
    sub_10002418C(v28, v19);
    if (v29 < 0) {
      uint64_t v21 = (void **)v28[0];
    }
    *(_OWORD *)buf = 0u;
    memset(v37, 0, sizeof(v37));
    uuid_unparse_upper(uu, (char *)buf);
    sub_10002418C(__p, (char *)buf);
    if (v27 >= 0) {
      id v22 = __p;
    }
    else {
      id v22 = (void **)__p[0];
    }
    *(_DWORD *)unsigned __int8 v30 = 136446466;
    uint64_t v31 = v21;
    int v32 = 2082;
    __int128 v33 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Received %{public}s pairing request for device %{public}s",  v30,  0x16u);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    if (v29 < 0) {
      operator delete(v28[0]);
    }
  }

  __int128 v23 = *(void *)(a1 + 560);
  __int128 v24 = sub_100241F94(uu);
  __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
  (*(void (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v23 + 8LL))(v23, v25, a3, v8);
}

void *sub_100034F74(uint64_t a1)
{
  id result = *(void **)(a1 + 32);
  if (!*((_BYTE *)result + 8))
  {
    if (dword_1008D63E0 <= 40)
    {
      if (dword_1008D63E0 != -1
        || (int v3 = _LogCategory_Initialize(&dword_1008D63E0, 40LL), result = *(void **)(a1 + 32), v3))
      {
        LogPrintF_safe( &dword_1008D63E0,  "-[CBWHBRemoteController activate]_block_invoke_4",  40LL,  "### Remote controller activate retry attempt %llu:",  result[9]);
        id result = *(void **)(a1 + 32);
      }
    }

    return [result activate];
  }

  return result;
}

uint64_t sub_1000351C4(uint64_t result)
{
  uint64_t v1 = 0LL;
  *(void *)(result + 160) = "kLatencyStateMax";
  *(_OWORD *)(result + 112) = *(_OWORD *)off_10087FE38;
  *(_OWORD *)(result + 12_Block_object_dispose(va, 8) = *(_OWORD *)off_10087FE48;
  *(_OWORD *)(result + 144) = *(_OWORD *)off_10087FE58;
  *(_OWORD *)(result + 4_Block_object_dispose(va, 8) = *(_OWORD *)off_10087FDF8;
  *(_OWORD *)(result + 64) = *(_OWORD *)off_10087FE08;
  *(_OWORD *)(result + 80) = *(_OWORD *)off_10087FE18;
  *(_OWORD *)(result + 96) = *(_OWORD *)off_10087FE28;
  *(_OWORD *)(result + 200) = *(_OWORD *)off_10087FE90;
  *(_OWORD *)(result + 184) = *(_OWORD *)off_10087FE80;
  *(_OWORD *)(result + 16_Block_object_dispose(va, 8) = *(_OWORD *)off_10087FE70;
  *(void *)(result + 264) = "kTriggerMax";
  *(_OWORD *)(result + 24_Block_object_dispose(va, 8) = *(_OWORD *)off_10087FEC0;
  *(_OWORD *)(result + 232) = *(_OWORD *)off_10087FEB0;
  *(_OWORD *)(result + 216) = *(_OWORD *)off_10087FEA0;
  *(_DWORD *)(result + 5) = 0;
  *(_BYTE *)(result + 4) = 0;
  *(_DWORD *)id result = 1;
  *(_DWORD *)(result + 12) = 100;
  *(_WORD *)(result + 16) = 150;
  *(_DWORD *)(result + 20) = 0;
  *(_BYTE *)(result + 9) = 0;
  do
  {
    *(_WORD *)(result + v1 + 24) = -25444;
    v1 += 6LL;
  }

  while (v1 != 18);
  return result;
}

void sub_100035274(unint64_t a1, unsigned int a2)
{
  *(_WORD *)(a1 + 7) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_BYTE *)(a1 + 9) = 0;
  if (!*(_BYTE *)a1)
  {
    uint64_t v4 = sub_1002E8D54();
    (*(void (**)(uint64_t, unint64_t))(*(void *)v4 + 152LL))(v4, a1);
  }

  sub_1000352CC(a1, 0LL, a2);
}

void sub_1000352CC(unint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v4 = a2;
  uint64_t v5 = (unsigned __int8 *)a1;
  unint64_t v57 = a2;
  if (!a2)
  {
    a1 = sub_100036124(a1, a3);
    unint64_t v4 = a1;
    unint64_t v57 = a1;
    if (!a1) {
      goto LABEL_39;
    }
  }

  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v6 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v6) {
    goto LABEL_16;
  }
  uint64_t v7 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= v4;
    if (v8 >= v4) {
      id v10 = v6;
    }
    else {
      id v10 = v6 + 1;
    }
    if (v9) {
      uint64_t v7 = (char *)v6;
    }
    uint64_t v6 = (void *)*v10;
  }

  while (*v10);
  if (v7 == (char *)off_1008D60E8 + 200 || v4 < *((void *)v7 + 4)) {
LABEL_16:
  }
    uint64_t v7 = (char *)off_1008D60E8 + 200;
  if (v7 == (char *)off_1008D60E8 + 200)
  {
LABEL_39:
    sub_1000391F8(v5, v4, a3);
    goto LABEL_40;
  }

  uint64_t v11 = (_BYTE *)sub_100037B04(a1, v4);
  if (*v11)
  {
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    uint64_t v12 = (char **)*((void *)off_1008D60E8 + 137);
    if (!v12) {
      goto LABEL_32;
    }
    uint64_t v13 = (char *)off_1008D60E8 + 1096;
    do
    {
      unsigned int v14 = *((unsigned __int16 *)v12 + 16);
      BOOL v15 = v14 >= a3;
      if (v14 >= a3) {
        int v16 = v12;
      }
      else {
        int v16 = v12 + 1;
      }
      if (v15) {
        uint64_t v13 = (char *)v12;
      }
      uint64_t v12 = (char **)*v16;
    }

    while (*v16);
    if (v13 == (char *)off_1008D60E8 + 1096 || *((unsigned __int16 *)v13 + 16) > a3) {
LABEL_32:
    }
      uint64_t v13 = (char *)off_1008D60E8 + 1096;
    unint64_t v17 = (char *)off_1008D60E8;
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    BOOL v18 = sub_1004AB7F8((uint64_t)off_1008D60E8);
    if (v18)
    {
LABEL_37:
      uint64_t v19 = (uint64_t)v5;
      int v20 = 1000;
LABEL_38:
      sub_100038B94(v19, v20, a3);
      return;
    }

    uint64_t v36 = sub_100038CD4(v18, a3);
    if ((_DWORD)v36)
    {
      int v20 = v36;
      uint64_t v19 = (uint64_t)v5;
      goto LABEL_38;
    }

    char v37 = v17 + 1096;
    if (v13 != v37)
    {
      if (*(_DWORD *)(sub_100037B04(v36, v4) + 20) != 6)
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        *(void *)buf = &v57;
        if (*(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v57, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5]
                       + 76) == 2)
        {
          if (qword_1008D6458 == -1) {
            goto LABEL_54;
          }
          goto LABEL_119;
        }

        goto LABEL_103;
      }

LABEL_40:
      uint64_t v21 = qword_1008F7570;
      if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v22 = v5[1];
      int v23 = v5[3];
      int v24 = v5[5];
      int v25 = v5[2];
      int v26 = v5[8];
      int v27 = v5[7];
      int v28 = *v5;
      int v29 = v5[6];
      int v30 = v5[9];
      int v31 = v5[4];
      *(_DWORD *)buf = 67111424;
      *(_DWORD *)&uint8_t buf[4] = v22;
      __int16 v59 = 1024;
      int v60 = v23;
      __int16 v61 = 1024;
      int v62 = v24;
      __int16 v63 = 1024;
      int v64 = v25;
      __int16 v65 = 1024;
      int v66 = v26;
      __int16 v67 = 1024;
      int v68 = v27;
      __int16 v69 = 1024;
      BOOL v70 = v28;
      __int16 v71 = 1024;
      int v72 = v29;
      __int16 v73 = 1024;
      int v74 = v30;
      __int16 v75 = 1024;
      int v76 = v31;
      int v32 = "Dynamic Latency Trigger fKeyboardOn =%d, fVoiceOverOn=%d, fGameModeOn=%d, fGarageBandOn=%d, fSpatialVideoOn="
            "%d, fSpatialMusicOn=%d, fScreenOn =%d, fExpanseOn =%d, fAudioInputAggregateOn=%d, fConsoleGameModeOn=%d";
      __int128 v33 = (os_log_s *)v21;
      uint32_t v34 = 62;
      goto LABEL_44;
    }

    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    *(void *)buf = &v57;
    if (**(unsigned __int8 **)(sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v57,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 48) == 240) {
      goto LABEL_63;
    }
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    *(void *)buf = &v57;
    v39 = sub_100029574((uint64_t **)off_1008D60E8 + 24, &v57, (uint64_t)&unk_1006BADB0, (uint64_t **)buf);
    if (**(unsigned __int8 **)(v39[5] + 48) == 241)
    {
LABEL_63:
      sub_100038DD4((uint64_t)v5, v57, a3);
      goto LABEL_40;
    }

    if (*v5
      || *(_DWORD *)(sub_100037B04((uint64_t)v39, v57) + 20) == 7
      || (uint64_t v40 = sub_100037F60(v5, 0), (v40 & 1) != 0)
      || v5[8]
      || v5[7]
      || v5[6]
      || v5[9]
      || v5[4]
      || v5[5])
    {
      uint64_t v41 = sub_1002E6BF0();
      uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v41 + 792LL))(v41, 5LL);
      if ((v42 & 1) == 0 && !v5[1] && !v5[3] && !v5[5] && !v5[2] && !v5[8] && !v5[7] && !v5[4]
        || !*v5
        || v5[6]
        || v5[9]
        || (uint64_t v42 = sub_10003914C(v42, v57), (v42 & 1) != 0))
      {
        if ((v5[1] || v5[3] || v5[5] || v5[2] || v5[8] || v5[7] || v5[4] || !*v5) && !v5[6] && !v5[9]
          || *(_DWORD *)(sub_100037B04(v42, v57) + 20) == 6)
        {
          goto LABEL_40;
        }

        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        *(void *)buf = &v57;
        if (*(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v57, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5]
                       + 76) != 2)
          goto LABEL_40;
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        *(void *)buf = &v57;
        if (*(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v57, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5]
                       + 76) == 2)
        {
          if (qword_1008D6458 == -1)
          {
LABEL_54:
            if (sub_10037BD00(qword_1008D6450, a3) < 8)
            {
LABEL_55:
              int v38 = 150;
LABEL_56:
              sub_100038B94((uint64_t)v5, v38, a3);
              goto LABEL_40;
            }

            goto LABEL_103;
          }

  ((void (*)(void *))v36[2])(v36);
  _Block_object_dispose(&v44, 8);
}

    if (v11) {
      CFRelease(v11);
    }
    a2 += 256;
    ++a3;
    --v4;
  }

  while (v4);
  if ((v10 & 1) != 0) {
    off_1008DE638(35LL, v8, Mutable, 0LL);
  }
LABEL_45:
  if (v8) {
    CFRelease(v8);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

  if (sub_1000A86F0())
  {
    sub_1000DB7D8(v26);
    sub_1001EE134( (uint64_t)"AVDT_Security_Control_Rsp\n\tTransaction=%d\n\tStream Handle=%d\n\tData Length=0\n\tError=%d\n",  v38,  v39,  v40,  v41,  v42,  v43,  v44,  a3);
    int v45 = (os_log_s *)sub_100086554(3u);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      int v46 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      int v49 = v46;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  sub_1000E6454(a1, a3, 0LL, 0, v18);
  return v18;
}

    if ((_DWORD)v9 != 625)
    {
      if ((_DWORD)v9) {
        goto LABEL_25;
      }
LABEL_42:
      byte_1008F6E4E = 0;
      return v9;
    }

              *(_WORD *)(*(void *)a1 + v_Block_object_dispose(va, 8) = v11;
              int v3 = (uint64_t *)*v3;
              if (!v3)
              {
                int v22 = HIBYTE(v4);
                goto LABEL_45;
              }

              goto LABEL_7;
            }
          }
        }

        int v27 = "(*sdpDataRecord).__RWFlag == BYTESTREAM_WRITE";
LABEL_66:
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c",  1629,  v27);
      }
    }

    int v27 = "ByteStream_NumReadBytesAvail(*sdpDataRecord) >= 2";
    goto LABEL_66;
  }

  return result;
}

          CFRelease(Mutable);
          goto LABEL_41;
        }

        return 4294902295LL;
      }
    }
  }

  return result;
}

  sub_100242FAC((uint64_t)v28);
  return v16;
}

        if ((v17 & 0x80) != 0)
        {
          operator delete(*(void **)__p);
          if (v19) {
            goto LABEL_44;
          }
        }

        else
        {
          if (!v19) {
            goto LABEL_47;
          }
LABEL_44:
          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_100894610);
          }
          int v26 = off_1008D5F08;
          sub_100241F90(__p, v9);
          sub_100599B60((uint64_t)v26, __p);
        }

  int v20 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
  {
    sub_1003D0100(v7, (uint64_t)&__p);
    if (SBYTE3(v31) >= 0) {
      int v22 = &__p;
    }
    else {
      int v22 = (void **)__p;
    }
    *(_DWORD *)int v23 = 141558275;
    *(void *)&v23[4] = 1752392040LL;
    int v24 = 2081;
    int v25 = v22;
    _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Unknown SCO data source selected for device %{private, mask.hash}s",  v23,  0x16u);
    if (SBYTE3(v31) < 0) {
      operator delete(__p);
    }
    int v20 = (os_log_s *)qword_1008F7598;
  }

  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    sub_1003D0100(v7, (uint64_t)v23);
    uint64_t v21 = v26 >= 0 ? v23 : *(_BYTE **)v23;
    LODWORD(__p) = 67109635;
    HIDWORD(__p) = a3;
    int v28 = 2160;
    int v29 = 1752392040LL;
    int v30 = 2081;
    int v31 = v21;
    _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Sco route and audio channel not set because an unknown datasource of %d selected for device %{private, mask.hash}s",  (uint8_t *)&__p,  0x1Cu);
    if (v26 < 0) {
      operator delete(*(void **)v23);
    }
  }

      int v23 = sub_1006125B0(a1, a2, a3, v16, v11);
LABEL_41:
      if (v17) {

      }
      if ((v23 & 1) == 0) {
        goto LABEL_17;
      }
      goto LABEL_44;
    }

LABEL_119:
          dispatch_once(&qword_1008D6458, &stru_10087FF40);
          goto LABEL_54;
        }

        *(_BYTE *)(a1 + 80) = 0;
        goto LABEL_143;
      }

      int v16 = v45;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_OBEXCOMMON_ParseHeaderList failed %!", v46, v47, v48, v49, v50, v51, v52, v16);
        int v53 = (os_log_s *)sub_100086554(0x18u);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
LABEL_62:
        }
          sub_100657858();
      }

  sub_100242FAC((uint64_t)v91);
LABEL_120:
}

  int v74 = *(void *)(a1 + 72);
  __int16 v75 = *(void *)(a1 + 80);
  int v76 = *(_DWORD *)(a1 + 148);
  __int16 v77 = v75 - v74;
  if (v75 != v74)
  {
    int v78 = 0LL;
    v79 = 0;
    v80 = v77 >> 2;
    while (1)
    {
      v81 = *(_DWORD *)(v74 + 4 * v78);
      if (v76 != v81) {
        break;
      }
      if (!*(_BYTE *)(a1 + 146))
      {
        v81 = *(_DWORD *)(a1 + 148);
        break;
      }

      int v78 = ++v79;
      if (v80 <= v79) {
        goto LABEL_127;
      }
    }

    *(_BYTE *)(a1 + 69) = v81;
    *(_DWORD *)(a1 + 96) = v79;
  }

      __int16 v69 = (os_log_s *)qword_1008F7748;
      if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 711;
        _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "Cleaning up PFC because status is %d",  buf,  8u);
      }

      sub_10057E5E8(a1, (uint64_t)&v74, 711LL);
      return;
    }

    int v25 = v24;
    int v26 = (mach_absolute_time() - *(void *)(v24 + 152))
        * dword_1008F1CE4
        / *(unsigned int *)algn_1008F1CE8
        / 0xF4240;
    if ((_DWORD)a6 == 716 || (_DWORD)a6 == 704)
    {
      int v27 = *(unsigned __int8 *)(v25 + 52);
      int v28 = *(unsigned __int8 *)(v25 + 53);
      int v29 = (os_log_s *)qword_1008F7748;
      if (v27 >= v28)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
          sub_1006965D0();
        }
        sub_10057E5E8(a1, (uint64_t)&v74, a6);
      }

      else
      {
        int v30 = os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_DEFAULT);
        if (v30)
        {
          *(_DWORD *)buf = 67109888;
          *(_DWORD *)&uint8_t buf[4] = a6;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v26;
          *(_WORD *)&_BYTE buf[14] = 1024;
          LODWORD(v77) = v27;
          WORD2(v77) = 1024;
          *(_DWORD *)((char *)&v77 + 6) = v28;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Status: %d, took %d ms. Retrying echo request since retries %d < %d",  buf,  0x1Au);
        }

        sub_10057E2D0(v30, v25, 1u);
        int v31 = *(void **)(v25 + 200);
        *(void *)(v25 + 200) = 0LL;

        *(void *)(v25 + 160) = 0LL;
        ++*(_BYTE *)(v25 + 52);
        if (qword_1008D60D0 != -1) {
          dispatch_once(&qword_1008D60D0, &stru_1008A1F88);
        }
        sub_100426A10((uint64_t)off_1008D60C8, (uint64_t)v15, 1, 2);
        if (sub_1003D2B2C((uint64_t)v15, 12))
        {
          memset(buf, 0, sizeof(buf));
          *(void *)&__int16 v77 = 0LL;
          if (v15[1503] < 0)
          {
            sub_100024238(buf, *((void **)v15 + 185), *((void *)v15 + 186));
          }

          else
          {
            *(_OWORD *)buf = *(_OWORD *)(v15 + 1480);
            *(void *)&__int16 v77 = *((void *)v15 + 187);
          }

          if (SBYTE7(v77) < 0)
          {
            if (*(void *)&buf[8])
            {
              v58 = *(uint8_t **)buf;
              goto LABEL_89;
            }
          }

          else if (BYTE7(v77))
          {
            v58 = buf;
LABEL_89:
            __int16 v59 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v58));
            goto LABEL_91;
          }

          __int16 v59 = @"Unknown";
LABEL_91:
          *(void *)uu = 0LL;
          v97 = 0LL;
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_1008A2068);
          }
          sub_1005D0B84((uint64_t)off_1008D5F28, (unsigned __int8 *)v15 + 128, uu);
          if (uuid_is_null(uu))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
            {
              sub_1003CF00C((uint64_t)v15, v92);
              sub_100696580();
            }
          }

          else
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_1008A2068);
            }
            int v60 = off_1008D5F28;
            __int16 v61 = sub_100241F94(uu);
            int v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
            __int16 v63 = sub_1005D71D4((uint64_t)v60, v62);

            if (v63 > 0.0)
            {
              int v64 = (uint64_t)(CFAbsoluteTimeGetCurrent() - v63);
LABEL_101:
              __int16 v65 = sub_1002E8D94();
              sub_1003CF00C((uint64_t)v15, __p);
              (*(void (**)(uint64_t, void **, __CFString *, uint64_t, void, void))(*(void *)v65 + 392LL))( v65,  __p,  v59,  v64,  *(unsigned __int8 *)(v25 + 52),  *(unsigned __int8 *)(v25 + 53));
              if (v71 < 0) {
                operator delete(__p[0]);
              }

              if (SBYTE7(v77) < 0) {
                operator delete(*(void **)buf);
              }
              goto LABEL_105;
            }
          }

          int v64 = -1LL;
          goto LABEL_101;
        }
      }
    }

    else
    {
      unint64_t v57 = (os_log_s *)qword_1008F7748;
      if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v26;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "PFC failed, took %d ms", buf, 8u);
      }
    }

void sub_100035C9C(_BYTE *a1, unsigned int a2, int a3)
{
  char v6 = sub_100036044((uint64_t)a1, a2);
  uint64_t v7 = (os_log_s *)qword_1008F7570;
  BOOL v8 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if ((v6 & 1) != 0)
  {
    if (v8)
    {
      int v9 = a1[7];
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v9;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency a2dpSpatialMusicStateChanged:%d, %d",  buf,  0xEu);
    }

    if (a1[7] != a3)
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      sub_1004A6F68(off_1008D60E8, a3);
      a1[7] = a3;
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      sub_1004B3180((uint64_t)off_1008D60E8);
      unint64_t v11 = sub_100036124(v10, a2);
      unint64_t v20 = v11;
      if (v11)
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        uint64_t v12 = (void *)*((void *)off_1008D60E8 + 25);
        if (!v12) {
          goto LABEL_23;
        }
        uint64_t v13 = (char *)off_1008D60E8 + 200;
        do
        {
          unint64_t v14 = v12[4];
          BOOL v15 = v14 >= v11;
          if (v14 >= v11) {
            int v16 = v12;
          }
          else {
            int v16 = v12 + 1;
          }
          if (v15) {
            uint64_t v13 = (char *)v12;
          }
          uint64_t v12 = (void *)*v16;
        }

        while (*v16);
        if (v13 == (char *)off_1008D60E8 + 200 || v11 < *((void *)v13 + 4)) {
LABEL_23:
        }
          uint64_t v13 = (char *)off_1008D60E8 + 200;
        if (v13 != (char *)off_1008D60E8 + 200)
        {
          *(void *)buf = &v20;
          if (*(void *)sub_100029574((uint64_t **)off_1008D60E8 + 24, &v20, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5])
          {
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087FF60);
            }
            sub_1004AA160((uint64_t)off_1008D60E8, (uint64_t)buf);
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087FF60);
            }
            uint64_t v21 = &v20;
            uint64_t v17 = *(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v20,  (uint64_t)&unk_1006BADB0,  (uint64_t **)&v21)[5];
            uint64_t v18 = v17 + 472;
            *(_OWORD *)uint64_t v18 = *(_OWORD *)buf;
            *(void *)(v18 + 16) = v23;
            if (a1[7] && a1[5])
            {
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              *(void *)buf = &v20;
              *(_BYTE *)(*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v20,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 161LL) = 1;
            }
          }
        }
      }

      if (!*a1)
      {
        uint64_t v19 = sub_1002E8D54();
        (*(void (**)(uint64_t, _BYTE *))(*(void *)v19 + 152LL))(v19, a1);
      }

      sub_1000352CC((unint64_t)a1, 0LL, a2);
    }
  }

  else if (v8)
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency a2dpSpatialMusicStateChanged return a2dpHandle:%d",  buf,  8u);
  }

void sub_100036020( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100036044(uint64_t a1, int a2)
{
  uint64_t v3 = sub_1002E6BF0();
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 792LL))(v3, 5LL);
  if (!(_DWORD)v4) {
    return 1LL;
  }
  uint64_t v5 = sub_100036124(v4, a2);
  if (!v5) {
    return 1LL;
  }
  unint64_t v6 = v5;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v7 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v7) {
    goto LABEL_16;
  }
  BOOL v8 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v9 = v7[4];
    BOOL v10 = v9 >= v6;
    if (v9 >= v6) {
      unint64_t v11 = v7;
    }
    else {
      unint64_t v11 = v7 + 1;
    }
    if (v10) {
      BOOL v8 = (char *)v7;
    }
    uint64_t v7 = (void *)*v11;
  }

  while (*v11);
  if (v8 == (char *)off_1008D60E8 + 200 || v6 < *((void *)v8 + 4)) {
LABEL_16:
  }
    BOOL v8 = (char *)off_1008D60E8 + 200;
  uint64_t v12 = (_BYTE *)sub_100037B04(v5, v6);
  uint64_t result = 0LL;
  *uint64_t v12 = 0;
  return result;
}

uint64_t sub_100036124(uint64_t a1, int a2)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v3 = (void *)*((void *)off_1008D60E8 + 24);
  uint64_t result = 0LL;
  do
  {
    int v5 = *(unsigned __int16 *)(v3[5] + 84LL);
    BOOL v6 = v5 != a2 || v5 == 0;
    if (!v6) {
      uint64_t result = v3[4];
    }
    uint64_t v7 = (void *)v3[1];
    if (v7)
    {
      do
      {
        BOOL v8 = v7;
        uint64_t v7 = (void *)*v7;
      }

      while (v7);
    }

    else
    {
      do
      {
        BOOL v8 = (void *)v3[2];
        BOOL v6 = *v8 == (void)v3;
        uint64_t v3 = v8;
      }

      while (!v6);
    }

    uint64_t v3 = v8;
  }

  while (v8 != (void *)((char *)off_1008D60E8 + 200));
  return result;
}

void sub_1000361D8(unint64_t a1)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  if (*((void *)off_1008D60E8 + 26))
  {
    uint64_t v2 = (char *)*((void *)off_1008D60E8 + 24);
    uint64_t v3 = (char *)off_1008D60E8 + 200;
    if (v2 != (char *)off_1008D60E8 + 200)
    {
      do
      {
        uint64_t v4 = *((void *)v2 + 5);
        if (*(_WORD *)(v4 + 84) && sub_100036044(a1, *(unsigned __int16 *)(v4 + 84)))
        {
          int v5 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)unint64_t v9 = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency screen call decision for default logic",  v9,  2u);
          }

          sub_1000352CC(a1, 0LL, *(unsigned __int16 *)(v4 + 84));
        }

        BOOL v6 = (char *)*((void *)v2 + 1);
        if (v6)
        {
          do
          {
            uint64_t v7 = v6;
            BOOL v6 = *(char **)v6;
          }

          while (v6);
        }

        else
        {
          do
          {
            uint64_t v7 = (char *)*((void *)v2 + 2);
            BOOL v8 = *(void *)v7 == (void)v2;
            uint64_t v2 = v7;
          }

          while (!v8);
        }

        uint64_t v2 = v7;
      }

      while (v7 != v3);
    }
  }

void sub_10003630C(_BYTE *a1, unsigned int a2, int a3)
{
  if (sub_100036044((uint64_t)a1, a2))
  {
    BOOL v6 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = "on";
      if (a1[8]) {
        BOOL v8 = "on";
      }
      else {
        BOOL v8 = "off";
      }
      if (!a3) {
        uint64_t v7 = "off";
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&_BYTE buf[14] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency fSpatialVideoOn from %s -> %s",  buf,  0x16u);
    }

    if (a1[8] != a3)
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      sub_1004A6F68(off_1008D60E8, a3);
      a1[8] = a3;
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      sub_1004B3180((uint64_t)off_1008D60E8);
      unint64_t v10 = sub_100036124(v9, a2);
      unint64_t v19 = v10;
      if (v10)
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        unint64_t v11 = (void *)*((void *)off_1008D60E8 + 25);
        if (!v11) {
          goto LABEL_28;
        }
        uint64_t v12 = (char *)off_1008D60E8 + 200;
        do
        {
          unint64_t v13 = v11[4];
          BOOL v14 = v13 >= v10;
          if (v13 >= v10) {
            BOOL v15 = v11;
          }
          else {
            BOOL v15 = v11 + 1;
          }
          if (v14) {
            uint64_t v12 = (char *)v11;
          }
          unint64_t v11 = (void *)*v15;
        }

        while (*v15);
        if (v12 == (char *)off_1008D60E8 + 200 || v10 < *((void *)v12 + 4)) {
LABEL_28:
        }
          uint64_t v12 = (char *)off_1008D60E8 + 200;
        if (v12 != (char *)off_1008D60E8 + 200)
        {
          *(void *)buf = &v19;
          if (*(void *)sub_100029574((uint64_t **)off_1008D60E8 + 24, &v19, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5])
          {
            if (a1[8])
            {
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              sub_1004AA160((uint64_t)off_1008D60E8, (uint64_t)buf);
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              unint64_t v20 = &v19;
              uint64_t v16 = *(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v19,  (uint64_t)&unk_1006BADB0,  (uint64_t **)&v20)[5];
              uint64_t v17 = v16 + 472;
              *(_OWORD *)uint64_t v17 = *(_OWORD *)buf;
              *(void *)(v17 + 16) = *(void *)&buf[16];
              if (a1[8] && a1[5])
              {
                if (qword_1008D60F0 != -1) {
                  dispatch_once(&qword_1008D60F0, &stru_10087FF60);
                }
                *(void *)buf = &v19;
                *(_BYTE *)(*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v19,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 162LL) = 1;
              }
            }
          }
        }
      }

      if (!*a1)
      {
        uint64_t v18 = sub_1002E8D54();
        (*(void (**)(uint64_t, _BYTE *))(*(void *)v18 + 152LL))(v18, a1);
      }

      sub_1000352CC((unint64_t)a1, 0LL, a2);
    }
  }

void sub_100036678( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10003669C(_BYTE *a1, unsigned int a2, int a3)
{
  BOOL v6 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "on";
    if (a1[3]) {
      BOOL v8 = "on";
    }
    else {
      BOOL v8 = "off";
    }
    if (!a3) {
      uint64_t v7 = "off";
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    __int16 v20 = 2080;
    uint64_t v21 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency fVoiceOverOn from %s -> %s",  buf,  0x16u);
  }

  uint64_t v9 = sub_100036044((uint64_t)a1, a2);
  if ((_DWORD)v9)
  {
    a1[3] = a3;
    if (a3)
    {
      if (a1[5])
      {
        uint64_t v10 = sub_100036124(v9, a2);
        unint64_t v18 = v10;
        if (v10)
        {
          unint64_t v11 = v10;
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087FF60);
          }
          uint64_t v12 = (void *)*((void *)off_1008D60E8 + 25);
          if (!v12) {
            goto LABEL_25;
          }
          unint64_t v13 = (char *)off_1008D60E8 + 200;
          do
          {
            unint64_t v14 = v12[4];
            BOOL v15 = v14 >= v11;
            if (v14 >= v11) {
              uint64_t v16 = v12;
            }
            else {
              uint64_t v16 = v12 + 1;
            }
            if (v15) {
              unint64_t v13 = (char *)v12;
            }
            uint64_t v12 = (void *)*v16;
          }

          while (*v16);
          if (v13 == (char *)off_1008D60E8 + 200 || v11 < *((void *)v13 + 4)) {
LABEL_25:
          }
            unint64_t v13 = (char *)off_1008D60E8 + 200;
          if (v13 != (char *)off_1008D60E8 + 200)
          {
            *(void *)buf = &v18;
            if (*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v18,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5])
            {
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              *(void *)buf = &v18;
              *(_BYTE *)(*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v18,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 164LL) = 1;
            }
          }
        }
      }
    }

    if (!*a1)
    {
      uint64_t v17 = sub_1002E8D54();
      (*(void (**)(uint64_t, _BYTE *))(*(void *)v17 + 152LL))(v17, a1);
    }

    sub_1000352CC((unint64_t)a1, 0LL, a2);
  }

void sub_1000368F4(_BYTE *a1, unsigned int a2, int a3)
{
  BOOL v6 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "on";
    if (a1[9]) {
      BOOL v8 = "on";
    }
    else {
      BOOL v8 = "off";
    }
    if (!a3) {
      uint64_t v7 = "off";
    }
    int v10 = 136315394;
    unint64_t v11 = v8;
    __int16 v12 = 2080;
    unint64_t v13 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency A2dpAudioAndInputAggregationChanged from %s -> %s",  (uint8_t *)&v10,  0x16u);
  }

  if (sub_100036044((uint64_t)a1, a2))
  {
    a1[9] = a3;
    if (!*a1)
    {
      uint64_t v9 = sub_1002E8D54();
      (*(void (**)(uint64_t, _BYTE *))(*(void *)v9 + 152LL))(v9, a1);
    }

    sub_1000352CC((unint64_t)a1, 0LL, a2);
  }

void sub_100036A14(unint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 1) != a2)
  {
    *(_BYTE *)(a1 + 1) = a2;
    uint64_t v4 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "disabled";
      if (a2) {
        int v5 = "enabled";
      }
      int v12 = 136315138;
      unint64_t v13 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency keyboard %s",  (uint8_t *)&v12,  0xCu);
    }

    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    if (*((void *)off_1008D60E8 + 26))
    {
      BOOL v6 = (char *)*((void *)off_1008D60E8 + 24);
      uint64_t v7 = (char *)off_1008D60E8 + 200;
      if (v6 != (char *)off_1008D60E8 + 200)
      {
        do
        {
          uint64_t v8 = *((void *)v6 + 5);
          if (*(_WORD *)(v8 + 84)) {
            sub_1000352CC(a1, 0LL, *(unsigned __int16 *)(v8 + 84));
          }
          uint64_t v9 = (char *)*((void *)v6 + 1);
          if (v9)
          {
            do
            {
              int v10 = v9;
              uint64_t v9 = *(char **)v9;
            }

            while (v9);
          }

          else
          {
            do
            {
              int v10 = (char *)*((void *)v6 + 2);
              BOOL v11 = *(void *)v10 == (void)v6;
              BOOL v6 = v10;
            }

            while (!v11);
          }

          BOOL v6 = v10;
        }

        while (v10 != v7);
      }
    }
  }

void sub_100036B84(unint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 2) != a2)
  {
    *(_BYTE *)(a1 + 2) = a2;
    uint64_t v4 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "disabled";
      if (a2) {
        int v5 = "enabled";
      }
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Dynamic Latency GarageBand %s", buf, 0xCu);
    }

    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    if (*((void *)off_1008D60E8 + 26))
    {
      BOOL v6 = (char *)*((void *)off_1008D60E8 + 24);
      uint64_t v7 = (char *)off_1008D60E8 + 200;
      if (v6 != (char *)off_1008D60E8 + 200)
      {
        do
        {
          uint64_t v8 = *((void *)v6 + 5);
          unsigned int v9 = *(unsigned __int16 *)(v8 + 84);
          if (*(_WORD *)(v8 + 84))
          {
            if (*(_BYTE *)(a1 + 2) && *(_BYTE *)(a1 + 5))
            {
              unint64_t v18 = 0LL;
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              unint64_t v18 = sub_1004A8FC0((uint64_t)off_1008D60E8, *(unsigned __int16 *)(v8 + 84));
              if (v18)
              {
                if (qword_1008D60F0 != -1) {
                  dispatch_once(&qword_1008D60F0, &stru_10087FF60);
                }
                int v10 = (void *)*((void *)off_1008D60E8 + 25);
                if (!v10) {
                  goto LABEL_29;
                }
                BOOL v11 = (char *)off_1008D60E8 + 200;
                do
                {
                  unint64_t v12 = v10[4];
                  BOOL v13 = v12 >= v18;
                  if (v12 >= v18) {
                    unint64_t v14 = v10;
                  }
                  else {
                    unint64_t v14 = v10 + 1;
                  }
                  if (v13) {
                    BOOL v11 = (char *)v10;
                  }
                  int v10 = (void *)*v14;
                }

                while (*v14);
                if (v11 == (char *)off_1008D60E8 + 200 || v18 < *((void *)v11 + 4)) {
LABEL_29:
                }
                  BOOL v11 = (char *)off_1008D60E8 + 200;
                if (v11 != (char *)off_1008D60E8 + 200)
                {
                  *(void *)buf = &v18;
                  if (*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v18,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5])
                  {
                    if (qword_1008D60F0 != -1) {
                      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
                    }
                    *(void *)buf = &v18;
                    *(_BYTE *)(*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v18,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 165LL) = 1;
                  }
                }
              }

              unsigned int v9 = *(unsigned __int16 *)(v8 + 84);
            }

            sub_1000352CC(a1, 0LL, v9);
          }

          BOOL v15 = (char *)*((void *)v6 + 1);
          if (v15)
          {
            do
            {
              uint64_t v16 = v15;
              BOOL v15 = *(char **)v15;
            }

            while (v15);
          }

          else
          {
            do
            {
              uint64_t v16 = (char *)*((void *)v6 + 2);
              BOOL v17 = *(void *)v16 == (void)v6;
              BOOL v6 = v16;
            }

            while (!v17);
          }

          BOOL v6 = v16;
        }

        while (v16 != v7);
      }
    }
  }

void sub_100036E64(unint64_t a1, int a2)
{
  int v2 = a2;
  if (*(_BYTE *)(a1 + 4)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = *(_BYTE *)(a1 + 5) != 0;
  }
  *(_BYTE *)(a1 + 4) = a2;
  int v5 = (os_log_s *)qword_1008F7570;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    uint64_t v7 = "disabled";
    int v8 = *(unsigned __int8 *)(a1 + 5);
    unsigned int v9 = "enabled";
    *(_DWORD *)buf = 136316162;
    if (v2) {
      int v10 = "enabled";
    }
    else {
      int v10 = "disabled";
    }
    *(void *)int v25 = v10;
    if (v4) {
      BOOL v11 = "enabled";
    }
    else {
      BOOL v11 = "disabled";
    }
    *(_WORD *)&v25[8] = 2080;
    int v26 = v10;
    if (v8) {
      uint64_t v7 = "enabled";
    }
    else {
      unsigned int v9 = v10;
    }
    __int16 v27 = 2080;
    int v28 = v7;
    __int16 v29 = 2080;
    int v30 = v11;
    __int16 v31 = 2080;
    int v32 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game console mode update, new mode: %s, fConsoleGameModeOn: %s, fGameModeOn: %s, fCombinedGameOn: %s->%s",  buf,  0x34u);
    int v2 = *(unsigned __int8 *)(a1 + 4);
  }

  if (v2)
  {
    if (v4) {
      return;
    }
  }

  else if (v4 == (*(_BYTE *)(a1 + 5) != 0))
  {
    return;
  }

  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  if (*((void *)off_1008D60E8 + 26))
  {
    unint64_t v12 = (char *)*((void *)off_1008D60E8 + 24);
    BOOL v13 = (char *)off_1008D60E8 + 200;
    if (v12 != (char *)off_1008D60E8 + 200)
    {
      do
      {
        uint64_t v14 = *((void *)v12 + 5);
        if (*(_WORD *)(v14 + 84))
        {
          uint64_t v15 = *((void *)v12 + 4);
          uint64_t v16 = sub_100036124(v6, *(unsigned __int16 *)(v14 + 84));
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087FF60);
          }
          if (*((void *)off_1008D60E8 + 28)
            && sub_100027194(*((void *)off_1008D60E8 + 28), v16)
            && !*(_BYTE *)(a1 + 4)
            && !*(_BYTE *)(a1 + 5))
          {
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087FF60);
            }
            sub_1004A52FC((uint64_t)off_1008D60E8, 8u, v16);
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087FF60);
            }
            sub_1004B257C((uint64_t)off_1008D60E8, v16, 0);
          }

          else
          {
LABEL_31:
            sub_1000352CC(a1, 0LL, *(unsigned __int16 *)(v14 + 84));
          }

          if (*(_BYTE *)(a1 + 4)) {
            BOOL v17 = 1;
          }
          else {
            BOOL v17 = *(_BYTE *)(a1 + 5) != 0;
          }
          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087FF60);
          }
          int v18 = sub_100028D84(*((void *)off_1008D60E8 + 28));
          unint64_t v19 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            if (*(_BYTE *)(a1 + 4)) {
              BOOL v20 = 1;
            }
            else {
              BOOL v20 = *(_BYTE *)(a1 + 5) != 0;
            }
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)int v25 = v20;
            *(_WORD *)&v25[4] = 1024;
            *(_DWORD *)&v25[6] = v18;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game console mode change, notify BTHAL low Latency Game: %d, HID: %d",  buf,  0xEu);
          }

          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087FF60);
          }
          sub_1004B439C((uint64_t)off_1008D60E8, v15, *(unsigned __int16 *)(v14 + 84), v17 & v18);
        }

        uint64_t v21 = (char *)*((void *)v12 + 1);
        if (v21)
        {
          do
          {
            int v22 = v21;
            uint64_t v21 = *(char **)v21;
          }

          while (v21);
        }

        else
        {
          do
          {
            int v22 = (char *)*((void *)v12 + 2);
            BOOL v23 = *(void *)v22 == (void)v12;
            unint64_t v12 = v22;
          }

          while (!v23);
        }

        unint64_t v12 = v22;
      }

      while (v22 != v13);
    }
  }

void sub_100037250(_BYTE *a1, unsigned int a2, int a3)
{
  BOOL v6 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "a2dpExpanseStateChanged:%d", (uint8_t *)v8, 8u);
  }

  if (sub_100036044((uint64_t)a1, a2))
  {
    a1[6] = a3;
    if (!*a1)
    {
      uint64_t v7 = sub_1002E8D54();
      (*(void (**)(uint64_t, _BYTE *))(*(void *)v7 + 152LL))(v7, a1);
    }

    sub_1000352CC((unint64_t)a1, 0LL, a2);
  }

void sub_100037340(_BYTE *a1, uint64_t a2, int a3)
{
  if (a1[4]) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = a1[5] != 0;
  }
  if (sub_100036044((uint64_t)a1, a2))
  {
    a1[5] = a3;
    uint64_t v7 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = a1[4];
      if (a3) {
        unsigned int v9 = "enabled";
      }
      else {
        unsigned int v9 = "disabled";
      }
      *(_DWORD *)buf = 136315906;
      if (v6) {
        int v10 = "enabled";
      }
      else {
        int v10 = "disabled";
      }
      BOOL v11 = v8 == 0;
      if (v8) {
        unint64_t v12 = "enabled";
      }
      else {
        unint64_t v12 = "disabled";
      }
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&_BYTE buf[12] = 2080;
      __int16 v29 = v9;
      if (v11) {
        BOOL v13 = v9;
      }
      else {
        BOOL v13 = "enabled";
      }
      __int16 v30 = 2080;
      __int16 v31 = v10;
      __int16 v32 = 2080;
      __int128 v33 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Game State (Ambience) Changed, fConsoleGameModeOn: %s, fGameModeOn: %s, fCombinedGameOn: %s->%s",  buf,  0x2Au);
    }

    if (a1[4])
    {
      if (v6) {
        return;
      }
    }

    else if (v6 == (a1[5] != 0))
    {
      return;
    }

    unint64_t v27 = 0LL;
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    unint64_t v27 = sub_1004A8FC0((uint64_t)off_1008D60E8, a2);
    if (v27)
    {
      if (a1[4] || a1[5])
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        uint64_t v14 = (void *)*((void *)off_1008D60E8 + 25);
        if (!v14) {
          goto LABEL_41;
        }
        uint64_t v15 = (char *)off_1008D60E8 + 200;
        do
        {
          unint64_t v16 = v14[4];
          BOOL v17 = v16 >= v27;
          if (v16 >= v27) {
            int v18 = v14;
          }
          else {
            int v18 = v14 + 1;
          }
          if (v17) {
            uint64_t v15 = (char *)v14;
          }
          uint64_t v14 = (void *)*v18;
        }

        while (*v18);
        if (v15 == (char *)off_1008D60E8 + 200 || v27 < *((void *)v15 + 4)) {
LABEL_41:
        }
          uint64_t v15 = (char *)off_1008D60E8 + 200;
        if (v15 != (char *)off_1008D60E8 + 200)
        {
          *(void *)buf = &v27;
          if (*(void *)sub_100029574((uint64_t **)off_1008D60E8 + 24, &v27, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5])
          {
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087FF60);
            }
            *(void *)buf = &v27;
            *(_BYTE *)(*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v27,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 160LL) = 1;
            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087FF60);
            }
            *(void *)buf = &v27;
            if (*(_BYTE *)(sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v27,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 72))
            {
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              *(void *)buf = &v27;
              *(_BYTE *)(*(void *)sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v27,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 163LL) = 1;
            }
          }
        }
      }

      if (!*a1)
      {
        uint64_t v19 = sub_1002E8D54();
        (*(void (**)(uint64_t, _BYTE *))(*(void *)v19 + 152LL))(v19, a1);
      }

      if (!_os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming") || a1[4] || a1[5])
      {
        sub_1000352CC((unint64_t)a1, 0LL, a2);
      }

      else
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        sub_1004A52FC((uint64_t)off_1008D60E8, 8u, v27);
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        sub_1004B257C((uint64_t)off_1008D60E8, v27, 0);
      }

      if (a1[4]) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = a1[5] != 0;
      }
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      int v23 = sub_100028D84(*((void *)off_1008D60E8 + 28));
      int v24 = v20 & v23;
      int v25 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        if (a1[4]) {
          int v26 = 1;
        }
        else {
          int v26 = a1[5];
        }
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v26;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v23;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Game State (Ambience) notify BTHAL low Latency Game: %d, HID: %d",  buf,  0xEu);
      }

      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      sub_1004B439C((uint64_t)off_1008D60E8, v27, a2, v24);
    }

    else
    {
      uint64_t v21 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        if (a1[5]) {
          int v22 = "true";
        }
        else {
          int v22 = "false";
        }
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Couldn't trigger Game State change (%s) - couldn't find the device",  buf,  0xCu);
      }
    }
  }

void sub_1000378D0(uint64_t a1, int a2, int a3)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  if (*((void *)off_1008D60E8 + 26))
  {
    int v5 = (char *)*((void *)off_1008D60E8 + 24);
    BOOL v6 = (char *)off_1008D60E8 + 200;
    if (v5 != (char *)off_1008D60E8 + 200)
    {
      do
      {
        uint64_t v7 = *((void *)v5 + 5);
        if (*(unsigned __int16 *)(v7 + 84) == a2)
        {
          unint64_t v8 = *((void *)v5 + 4);
          uint64_t v9 = a3 ? mach_absolute_time() : 0LL;
          uint64_t v10 = *(void *)(v7 + 40);
          *(void *)(v10 + _Block_object_dispose(va, 8) = v9;
          *(_BYTE *)(v10 + 1) = 0;
          if (_os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming"))
          {
            BOOL v11 = (os_log_s *)qword_1008F7570;
            BOOL v12 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
            if (v12)
            {
              int v13 = *(_DWORD *)(sub_100037B04(v12, v8) + 20);
              *(_DWORD *)buf = 67109120;
              int v21 = v13;
              _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game a2dpDynamicLatencyTransitionCompleted new latencymode: %d",  buf,  8u);
            }

            uint64_t v14 = sub_100037B04(v12, v8);
            if (*(_DWORD *)(v14 + 20) == 1
              || (uint64_t v15 = sub_100037B04(v14, v8), *(_DWORD *)(v15 + 20) == 2)
              || (uint64_t v16 = sub_100037B04(v15, v8), *(_DWORD *)(v16 + 20) == 3)
              || *(_DWORD *)(sub_100037B04(v16, v8) + 20) == 10)
            {
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              sub_1004A52FC((uint64_t)off_1008D60E8, 0xAu, v8);
            }
          }
        }

        BOOL v17 = (char *)*((void *)v5 + 1);
        if (v17)
        {
          do
          {
            int v18 = v17;
            BOOL v17 = *(char **)v17;
          }

          while (v17);
        }

        else
        {
          do
          {
            int v18 = (char *)*((void *)v5 + 2);
            BOOL v19 = *(void *)v18 == (void)v5;
            int v5 = v18;
          }

          while (!v19);
        }

        int v5 = v18;
      }

      while (v18 != v6);
    }
  }

uint64_t sub_100037B04(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = a2;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  BOOL v4 = &v3;
  return *(void *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v3, (uint64_t)&unk_1006BADB0, (uint64_t **)&v4)[5] + 40);
}

uint64_t sub_100037B7C(uint64_t a1, int a2)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  if (!*((void *)off_1008D60E8 + 26)) {
    return 0LL;
  }
  unint64_t v3 = (void *)*((void *)off_1008D60E8 + 24);
  if (v3 == (void *)((char *)off_1008D60E8 + 200))
  {
    char v4 = 0;
  }

  else
  {
    char v4 = 0;
    do
    {
      uint64_t v5 = v3[5];
      BOOL v6 = (void *)v3[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          BOOL v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          uint64_t v7 = (void *)v3[2];
          BOOL v8 = *v7 == (void)v3;
          unint64_t v3 = v7;
        }

        while (!v8);
      }

      unint64_t v3 = v7;
    }

    while (v7 != (void *)((char *)off_1008D60E8 + 200));
  }

  return v4 & 1;
}

uint64_t sub_100037C54(uint64_t a1, int a2)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  if (!*((void *)off_1008D60E8 + 26)) {
    return 0LL;
  }
  unint64_t v3 = (void *)*((void *)off_1008D60E8 + 24);
  if (v3 == (void *)((char *)off_1008D60E8 + 200))
  {
    char v4 = 0;
  }

  else
  {
    char v4 = 0;
    do
    {
      uint64_t v5 = v3[5];
      if (*(unsigned __int16 *)(v5 + 84) == a2)
      {
        uint64_t v6 = *(void *)(v5 + 40);
      }

      uint64_t v7 = (void *)v3[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          uint64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          BOOL v8 = (void *)v3[2];
          BOOL v9 = *v8 == (void)v3;
          unint64_t v3 = v8;
        }

        while (!v9);
      }

      unint64_t v3 = v8;
    }

    while (v8 != (void *)((char *)off_1008D60E8 + 200));
  }

  return v4 & 1;
}

BOOL sub_100037D3C(uint64_t a1, unint64_t a2)
{
  int v2 = *(unsigned __int16 *)(sub_100037B04(a1, a2) + 44);
  unint64_t v3 = (os_log_s *)qword_1008F7570;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if (v2 == 0xFFFF)
  {
    if (v4)
    {
      *(_WORD *)buf = 0;
      uint64_t v5 = "Adaptive Latency Streaming stopped";
      uint64_t v6 = buf;
      goto LABEL_6;
    }
  }

  else if (v4)
  {
    __int16 v8 = 0;
    uint64_t v5 = "Adaptive Latency Streaming started";
    uint64_t v6 = (uint8_t *)&v8;
LABEL_6:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
  }

  return v2 != 0xFFFF;
}

uint64_t sub_100037DE0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v6 = sub_1002E6BF0();
  if (((*(uint64_t (**)(uint64_t))(*(void *)v6 + 328LL))(v6) & 1) != 0)
  {
    if (!a4) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v8 = sub_1002E6BF0();
    char v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 384LL))(v8);
    uint64_t result = 0LL;
    if (!a4 || (v9 & 1) == 0) {
      return result;
    }
  }

  uint64_t v10 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    v12[0] = 67109376;
    v12[1] = a3;
    __int16 v13 = 1024;
    int v14 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency Coex notify check LLM enter or exit curr=%d,new=%d",  (uint8_t *)v12,  0xEu);
  }

  if ((a4 - 1) > 4 || (uint64_t result = 1LL, a3 <= 5) && a3)
  {
    if ((a4 & 0xFFFFFFFE) == 6 && a3 < 6) {
      return 2LL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void sub_100037F08(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  sub_1004A5914((uint64_t)off_1008D60E8, a2, a3);
}

uint64_t sub_100037F60(_BYTE *a1, int a2)
{
  uint64_t v4 = sub_1002E6BF0();
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 792LL))(v4, 2LL);
  if ((_DWORD)result)
  {
    uint64_t v6 = sub_1002E6BF0();
    BOOL v7 = (*(unsigned int (**)(uint64_t))(*(void *)v6 + 328LL))(v6)
      && a1[7]
      && !a1[6]
      && !a1[9]
      && !a1[4]
      && !a1[5];
    uint64_t v8 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 384LL))(v8)
      && (a1[7] || a1[8])
      && !a1[6]
      && !a1[9]
      && !a1[4]
      && !a1[5])
    {
      BOOL v7 = 1;
    }

    uint64_t v9 = sub_1002E6BF0();
    uint64_t v10 = sub_1002E6BF0();
    unsigned int v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 792LL))(v10, 5LL) ^ 1;
    if (v7) {
      uint64_t result = v11;
    }
    else {
      uint64_t result = 0LL;
    }
    if ((_DWORD)result == 1 && a2 != 0)
    {
      __int16 v13 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = a1[7];
        int v15 = a1[8];
        uint64_t v16 = sub_1002E6E00();
        int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 592LL))(v16);
        int v18 = a1[6];
        uint64_t v19 = sub_1002E6E00();
        int v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
        uint64_t v21 = sub_1002E6BF0();
        int v22 = (*(uint64_t (**)(uint64_t, void))(*(void *)v21 + 792LL))(v21, 0LL);
        v23[0] = 67110400;
        v23[1] = v14;
        __int16 v24 = 1024;
        int v25 = v15;
        __int16 v26 = 1024;
        int v27 = v17;
        __int16 v28 = 1024;
        int v29 = v18;
        __int16 v30 = 1024;
        int v31 = v20;
        __int16 v32 = 1024;
        int v33 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency Spatial:%d,%d,%d,%d,%d,%d",  (uint8_t *)v23,  0x26u);
      }

      return 1LL;
    }
  }

  return result;
}

uint64_t sub_100038198(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 16) = a2;
  return result;
}

void sub_1000381A0(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  uint64_t v10 = sub_1002E6BF0();
  if (a4) {
    unsigned int v11 = *(unsigned __int8 *)(a4 + 6);
  }
  else {
    unsigned int v11 = 0;
  }
  unsigned int v63 = 0;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v12 = sub_1004B3B20((uint64_t)off_1008D60E8, a2);
  if (!(_DWORD)v12) {
    return;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  __int16 v13 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v13) {
    goto LABEL_21;
  }
  int v14 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v15 = v13[4];
    BOOL v16 = v15 >= a2;
    if (v15 >= a2) {
      int v17 = v13;
    }
    else {
      int v17 = v13 + 1;
    }
    if (v16) {
      int v14 = (char *)v13;
    }
    __int16 v13 = (void *)*v17;
  }

  while (*v17);
  if (v14 == (char *)off_1008D60E8 + 200 || *((void *)v14 + 4) > a2) {
LABEL_21:
  }
    int v14 = (char *)off_1008D60E8 + 200;
  if (v14 == (char *)off_1008D60E8 + 200)
  {
    __int16 v28 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
      sub_1006574C8(v28, v29, v30, v31, v32, v33, v34, v35);
    }
    return;
  }

  unsigned int v18 = sub_1000386F0(v12, a2);
  uint64_t v19 = sub_100038834(a1, v18, &v63, 1);
  if (!(_DWORD)v19) {
    return;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  int v20 = (char **)*((void *)off_1008D60E8 + 137);
  if (!v20) {
    goto LABEL_37;
  }
  uint64_t v21 = (char **)((char *)off_1008D60E8 + 1096);
  do
  {
    unsigned int v22 = *((unsigned __int16 *)v20 + 16);
    BOOL v23 = v22 >= v18;
    if (v22 >= v18) {
      __int16 v24 = v20;
    }
    else {
      __int16 v24 = v20 + 1;
    }
    if (v23) {
      uint64_t v21 = v20;
    }
    int v20 = (char **)*v24;
  }

  while (*v24);
  if (v21 == (char **)((char *)off_1008D60E8 + 1096) || v18 < *((unsigned __int16 *)v21 + 16)) {
LABEL_37:
  }
    uint64_t v21 = (char **)((char *)off_1008D60E8 + 1096);
  uint64_t v25 = sub_100037B04(v19, a2);
  if (*(__int16 *)(v25 + 44) != -1)
  {
    int v26 = (char)v11;
    if ((char)v11 <= -70)
    {
      if (v11 <= 0xB5)
      {
        if (v11 <= 0xB0) {
          unsigned int v27 = 34;
        }
        else {
          unsigned int v27 = 36;
        }
      }

      else
      {
        unsigned int v27 = 38;
      }
    }

    else
    {
      unsigned int v27 = 40;
    }

    uint64_t v40 = sub_100037B04(v25, a2);
    if (v27 <= a3 || (char)v11 <= -80)
    {
      ++*(_WORD *)(v40 + 46);
      uint64_t v41 = sub_100037B04(v40, a2);
      *(_WORD *)(v41 + 44) = 0;
    }

    else
    {
      ++*(_WORD *)(v40 + 44);
      uint64_t v41 = sub_100037B04(v40, a2);
      *(_WORD *)(v41 + 46) = 0;
    }

    if ((a5 & 1) != 0 || (uint64_t v41 = sub_100037B04(v41, a2), *(__int16 *)(v41 + 46) > 2))
    {
      int v42 = 6;
      unsigned int v43 = v63;
      if (v63 && v63 != 6)
      {
        __int16 v44 = sub_100038AC8(v41, 6, a2);
        sub_100038A24(a1, a2, v44);
        uint64_t v46 = sub_100037B04(v45, a2);
        *(_WORD *)(v46 + 44) = 0;
        *(_WORD *)(sub_100037B04(v46, a2) + 46) = 0;
        int v47 = (os_log_s *)qword_1008F7570;
        if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_72;
        }
        *(_DWORD *)buf = 67109120;
        int v65 = 6;
        int v48 = "Adaptive Latency switch to medium latency :%d";
        goto LABEL_71;
      }
    }

    else
    {
      unsigned int v43 = v63;
      if (v63 >= 2)
      {
        uint64_t v49 = sub_100037B04(v41, a2);
        int v42 = 1;
        if (*(__int16 *)(v49 + 44) >= 3)
        {
          __int16 v50 = sub_100038AC8(v49, 1, a2);
          sub_100038A24(a1, a2, v50);
          uint64_t v52 = sub_100037B04(v51, a2);
          *(_WORD *)(v52 + 44) = 0;
          *(_WORD *)(sub_100037B04(v52, a2) + 46) = 0;
          int v47 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            int v65 = 1;
            int v48 = "Adaptive Latency switch to low latency :%d";
LABEL_71:
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, v48, buf, 8u);
          }
        }

LABEL_72:
        uint64_t v53 = qword_1008F7570;
        BOOL v54 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
        if (v54)
        {
          uint64_t v55 = sub_100038AC8(v54, v63, a2);
          int v56 = v55;
          uint64_t v57 = sub_100038AC8(v55, v42, a2);
          int v58 = v57;
          uint64_t v59 = sub_100037B04(v57, a2);
          int v60 = *(__int16 *)(v59 + 46);
          int v61 = *(__int16 *)(sub_100037B04(v59, a2) + 44);
          int v62 = "no";
          *(_DWORD *)buf = 67110658;
          int v65 = v26;
          if (a5) {
            int v62 = "yes";
          }
          __int16 v66 = 1024;
          unsigned int v67 = a3;
          __int16 v68 = 1024;
          int v69 = v56;
          __int16 v70 = 1024;
          int v71 = v58;
          __int16 v72 = 1024;
          int v73 = v60;
          __int16 v74 = 1024;
          int v75 = v61;
          __int16 v76 = 2080;
          __int16 v77 = v62;
          char v37 = "Adaptive Latency RSSI: %4d, reTx: %d, current latency: %d, new latency: %d, medium latency Count: %d, lo"
                "w latency count:%d, flush: %s\n";
          int v38 = (os_log_s *)v53;
          uint32_t v39 = 48;
          goto LABEL_76;
        }

        return;
      }

      int v42 = 1;
    }

    if (v43 == 6)
    {
      *(_WORD *)(sub_100037B04(v41, a2) + 46) = 0;
    }

    else if (v43 == 1)
    {
      *(_WORD *)(sub_100037B04(v41, a2) + 44) = 0;
    }

    goto LABEL_72;
  }

  sub_1000389D0(a1, a2);
  uint64_t v36 = qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    char v37 = "Adaptive Latency ignore first stats";
    int v38 = (os_log_s *)v36;
    uint32_t v39 = 2;
LABEL_76:
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
  }

            uint64_t v41 = sub_100037B04(v52, a2);
            if (*(_DWORD *)(v41 + 28) >= 0x14u)
            {
              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              uint64_t v59 = sub_1004A52FC((uint64_t)off_1008D60E8, 8u, a2);
              if ((_DWORD)v59)
              {
                *(_DWORD *)(sub_100037B04(v59, a2) + 2_Block_object_dispose(va, 8) = 20;
                if (qword_1008D60F0 != -1) {
                  dispatch_once(&qword_1008D60F0, &stru_10087FF60);
                }
                sub_1004B257C((uint64_t)off_1008D60E8, a2, 1);
                int v60 = sub_1003DD998(a2);
                if (!v60 || !*(_BYTE *)(a2 + 1373))
                {
                  int v61 = v75;
                  *(_DWORD *)(sub_100037B04(v60, a2) + 2_Block_object_dispose(va, 8) = 20 * v61;
                }

                int v62 = qword_1008F7570;
                uint64_t v41 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
                if (!(_DWORD)v41) {
                  goto LABEL_86;
                }
                unsigned int v63 = *(_DWORD *)(sub_100037B04(v41, a2) + 28);
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = v63;
                v79 = 1024;
                v80 = v75;
                int v64 = "Low Latency Game, AoS demoted to LLM on ISM, score %u, ISM factor %d";
                int v65 = (os_log_s *)v62;
                __int16 v66 = 14;
                goto LABEL_85;
              }

              unsigned int v67 = qword_1008F7570;
              uint64_t v41 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v41)
              {
                *(_WORD *)buf = 0;
                int v64 = "In Low Latency Game, transition busy delay 1 second";
                int v65 = (os_log_s *)v67;
                __int16 v66 = 2;
LABEL_85:
                _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, v64, buf, v66);
              }
            }

              sub_1000FE424( (unsigned __int16 *)*v1,  *(unsigned __int8 *)(*v22 + (v35 << 6) + 1),  qword_1008F29F0[134 * i + 14]);
              continue;
            }

            uint64_t v55 = *(unsigned __int8 *)(*v22 + ((unint64_t)v21 << 6) + 1);
            int v56 = sub_1000A86F0();
            if (v55 != 1)
            {
              if (v56)
              {
                unsigned int v67 = sub_100100080(*(unsigned __int8 *)(*v22 + ((unint64_t)v21 << 6) + 1));
                sub_1001EE134( (uint64_t)"Downgrade to upgrade requested to tech %s",  v68,  v69,  v70,  v71,  v72,  v73,  v74,  (uint64_t)v67);
                int v75 = (os_log_s *)sub_100086554(0x57u);
                if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                {
                  __int16 v76 = sub_1001EDDCC();
                  *(_DWORD *)buf = 136446210;
                  int v78 = v76;
                  _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                }
              }

              sub_1000FF49C( (unsigned __int16 *)*v1,  *(_BYTE *)(*v22 + ((unint64_t)v21 << 6) + 1),  qword_1008F29F0[134 * i + 14]);
              continue;
            }

            if (v56)
            {
              uint64_t v57 = sub_100100080(*(unsigned __int8 *)(*v22 + ((unint64_t)v21 << 6) + 1));
              sub_1001EE134((uint64_t)"Downgrade requested to tech %s", v58, v59, v60, v61, v62, v63, v64, (uint64_t)v57);
              uint64_t v45 = (os_log_s *)sub_100086554(0x57u);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
              {
LABEL_66:
                int v65 = sub_1001EDDCC();
                *(_DWORD *)buf = 136446210;
                int v78 = v65;
                _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }

            char v37 = 0LL;
            int v38 = 1;
LABEL_73:
            v111 = a1 | ((_DWORD)v18 << 16);
            sub_1000B553C(v111);
            v112 = *(void *)&word_1008DEBF0[v15 + 8];
            if (v112)
            {
              v113 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void, void, __int16 *))(v112 + 8);
              if (v113)
              {
                v114 = sub_10017AB4C(v116);
                v113( v114 + 10,  v37,  v111,  (unsigned __int16)word_1008DEBF0[v15 + 22],  (unsigned __int16)word_1008DEBF0[v15 + 24],  (unsigned __int16)word_1008DEBF0[v15 + 25],  &word_1008DEBF0[v15 + 26]);
              }
            }

            if ((v38 & 1) == 0) {
              goto LABEL_77;
            }
            return result;
          }

          *((_BYTE *)v82 + 24) = 4;
          v82[22] = *(_WORD *)(sub_10017AB4C(v116) + 32) - 4;
          if (v3 <= 5)
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aap/aap_client.c");
          }

          else if ((int)(v3 - v81) >= 2)
          {
            v83 = &word_1008DEBF0[v15];
            word_1008DEBF0[v15 + 24] = a2[v81 / 2];
            v84 = v81 + 2LL;
            if ((int)v3 - (int)v84 > 1)
            {
              v83[25] = *(unsigned __int16 *)((char *)a2 + v84);
              LODWORD(v84) = v81 + 4;
              else {
                v85 = v3;
              }
              v86 = v83 + 26;
              v87 = (unsigned __int16)(v85 - 10);
              v88 = (__int16 *)((char *)v83 + v87 + 52);
              v89 = v3 - v84;
              LODWORD(v3) = v87;
LABEL_65:
              if (v89 >= (int)v3 && v86 < v88)
              {
                v99 = (char *)a2 + v84;
                v100 = (__int16 *)((char *)&word_1008DEBF0[v15 + 26] + (char *)v88 - (char *)v86);
                do
                {
                  v101 = *v99++;
                  *(_BYTE *)v86 = v101;
                  v86 = (__int16 *)((char *)v86 + 1);
                }

                while (v100 != v86);
              }

              if (sub_1000A86F0())
              {
                sub_1001EE134( (uint64_t)"l2capRecvDataInd: BT_AAP_CONNECT_RSP connection accepted sid=%u cid=%u",  v102,  v103,  v104,  v105,  v106,  v107,  v108,  v18);
                v109 = (os_log_s *)sub_100086554(0x52u);
                if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
                {
                  v110 = sub_1001EDDCC();
                  *(_DWORD *)buf = 136446210;
                  v118 = v110;
                  _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                }
              }

              goto LABEL_72;
            }

        if ((v12 & 1) == 0) {
          goto LABEL_86;
        }
        int v20 = 0LL;
        *(void *)a1 = v13;
        goto LABEL_74;
      case 's':
        if (v14)
        {
          if (*((_BYTE *)a3 + 15))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcievents.c");
LABEL_95:
            uint64_t v46 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_97:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcievents.c",  426,  v46);
          }

          __int16 v28 = *((unsigned __int16 *)a3 + 6);
          if (*((_BYTE *)a3 + 14) != 1)
          {
            uint64_t v46 = "(*pBs).__RWFlag == BYTESTREAM_READ";
            goto LABEL_97;
          }

          uint64_t v29 = *a3;
          *((_WORD *)a3 + 6) = v28 + 1;
          uint64_t v30 = sub_10016F5B0(*(unsigned __int8 *)(v29 + v28));
          int v20 = 0LL;
          *(_DWORD *)a1 = v30;
          v12 |= v30 != 0;
LABEL_80:
          uint64_t v36 = (_DWORD)v20 == 0;
          if ((_DWORD)v20) {
            goto LABEL_87;
          }
          ++v11;
          a1 += 8LL;
          continue;
        }

        if ((v12 & 1) != 0)
        {
          int v20 = 0LL;
          *(_DWORD *)a1 = 638;
LABEL_74:
          uint64_t v12 = 1;
          goto LABEL_80;
        }

            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"Unimplemented command requested", v42, v43, v44, v45, v46, v47, v48, v58);
              uint64_t v49 = (os_log_s *)sub_100086554(6u);
              if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR)) {
                sub_100657858();
              }
            }

            return 1717LL;
          }

          switch(v38)
          {
            case 1:
LABEL_61:
              uint64_t v40 = (void *)(v12 + 56);
              break;
            case 4:
LABEL_62:
              uint64_t v40 = (void *)(v12 + 104);
              break;
            case 8:
LABEL_59:
              uint64_t v40 = (void *)(v12 + 64);
              break;
            case 9:
LABEL_63:
              uint64_t v40 = (void *)(v12 + 72);
              break;
            case 10:
LABEL_64:
              uint64_t v40 = (void *)(v12 + 80);
              break;
            case 11:
LABEL_65:
              uint64_t v40 = (void *)(v12 + 88);
              break;
            case 12:
LABEL_66:
              uint64_t v40 = (void *)(v12 + 96);
              break;
            default:
              goto LABEL_72;
          }

      sub_1001B7E30(v34, v35, v36, a11);
      sub_10012F300();
      return;
    }
  }

  v130 = v23;
  if (sub_10012D6D8(a2))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"We already have that LM handle(%x).... This is bad.",  v114,  v115,  v116,  v117,  v118,  v119,  v120,  a2);
      v121 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    sub_10012F300();
    sub_1000AFE20(133LL);
LABEL_90:
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Unexpected status %! in LE Connection Complete",  v122,  v123,  v124,  v125,  v126,  v127,  v128,  a1);
      v129 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    sub_1000AFE20(a1);
    sub_1001AE638();
    return;
  }

  if (a5)
  {
    v132[0] = *a5;
    *(_DWORD *)((char *)v132 + 3) = *(_DWORD *)((char *)a5 + 3);
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Using controller resolved address device %: to %:",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  (uint64_t)(a4 + 1));
      __int16 v44 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v134 = sub_1001EDDCC();
LABEL_31:
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }

  else
  {
    if (*a4 != 1
      || (a4[1] & 0xC0) != 0x40
      || (v131 = 0, sub_1001C9328(a4, (uint64_t)v132, &v131))
      || !v131)
    {
      uint64_t v53 = 0;
      BOOL v54 = 0;
      goto LABEL_46;
    }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Resolved device %: to %:", v55, v56, v57, v58, v59, v60, v61, (uint64_t)(a4 + 1));
      __int16 v44 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        int v62 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        v134 = v62;
        goto LABEL_31;
      }
    }
  }

  if (sub_10012D98C(v132))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"%: is already connected (previous handle=%p lmHandle=%x randomAddress=%:)",  v45,  v46,  v47,  v48,  v49,  v50,  v51,  (uint64_t)v132 + 1);
      uint64_t v52 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v53 = 1;
    BOOL v54 = 1;
  }

  else
  {
    BOOL v54 = 0;
    uint64_t v53 = 1;
  }

      v17 += 8;
    }

    while (v17 != (char *)v28);
    uint64_t v41 = *(_BYTE *)(v104 + 72);
    if ((v41 & 0x80000000) == 0)
    {
      int v17 = v102;
      goto LABEL_84;
    }

    int v17 = v102;
    if (v102 != (char *)v28)
    {
      while (1)
      {
        int v42 = *(void *)(*(void *)v17 + 8LL);
        unsigned int v43 = *(_DWORD *)(v42 + 20);
        buf = *(__n128 *)(v42 + 4);
        v168 = v43;
        sub_100634334(&v164, &buf);
        v126 = xmmword_1006BD8EC;
        v127 = 0;
        v17 += 8;
        if (v17 == (char *)v28)
        {
          int v17 = (char *)v28;
          break;
        }
      }
    }

    [v21 addObject:v25];
    goto LABEL_73;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v51 = "indication";
    if (v48) {
      uint64_t v51 = "notification";
    }
    v98 = v51;
    v99 = 2114;
    v100 = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "Sending %{public}s to device %{public}@",  buf,  0x16u);
  }

  v89 = 0;
  sub_100242CA4(&v89);
  uint64_t v52 = *(void *)(v49 + 48);
  uint64_t v53 = (unsigned __int8 *)*((void *)__p[1] + 1);
  BOOL v54 = (const void *)sub_10056AAF0(v82);
  uint64_t v55 = sub_10056AAD8(v82);
  int v56 = sub_1001C5450(v52, v53, v48, v54, v55);
  sub_100242CD0(&v89);
  if (!v56)
  {
    if ((v48 & 1) == 0)
    {
      if (v77)
      {
        int v58 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 504) objectForKey:v25]);
        uint64_t v59 = v58 == 0LL;

        if (!v59)
        {
          int v60 = (os_log_s *)qword_1008F75B0;
          if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138543362;
            v98 = v25;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_FAULT,  "Already tracking indication for device %{public}@",  buf,  0xCu);
          }
        }

        [*(id *)(a1 + 504) setObject:v77 forKey:v25];
      }

      else
      {
        if ([*(id *)(a1 + 496) containsObject:v25])
        {
          unsigned int v63 = (os_log_s *)qword_1008F75B0;
          if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138543362;
            v98 = v25;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_FAULT,  "Already tracking services changed for device %{public}@",  buf,  0xCu);
          }
        }

        [*(id *)(a1 + 496) addObject:v25];
      }

      v79 = 1;
    }

              uint64_t v34 = (os_log_s *)qword_1008F7748;
              if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = v27;
                *(_WORD *)&uint8_t buf[8] = 1024;
                *(_DWORD *)&buf[10] = v29;
                _os_log_error_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "fastConnectParseSetupCompleteMessage dumping %d for Key:%d ",  buf,  0xEu);
              }

              sub_10040F8BC(a3, v27);
            }

            __int16 v24 = (__int16)(v24 + v28 - v27);
          }

          while (v24 > 0);
        }

  uint64_t v29 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionCMCheckLogic");
  uint64_t v30 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v29 + 88LL))( v29,  buf,  __p,  (char *)&v58 + 4);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v30) {
      goto LABEL_80;
    }
  }

  else if (!v30)
  {
    goto LABEL_80;
  }

  uint64_t v31 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = HIDWORD(v58);
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionMCMCheckLogic (%d)",  buf,  8u);
  }

uint64_t sub_1000386F0(uint64_t a1, unint64_t a2)
{
  unint64_t v9 = a2;
  if (!a2) {
    return 0LL;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  unint64_t v3 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v3) {
    goto LABEL_15;
  }
  uint64_t v4 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= a2;
    if (v5 >= a2) {
      BOOL v7 = v3;
    }
    else {
      BOOL v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (char *)v3;
    }
    unint64_t v3 = (void *)*v7;
  }

  while (*v7);
  if (v4 == (char *)off_1008D60E8 + 200 || *((void *)v4 + 4) > a2) {
LABEL_15:
  }
    uint64_t v4 = (char *)off_1008D60E8 + 200;
  uint64_t v10 = &v9;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v10 = &v9;
  return *(unsigned __int16 *)(sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v9,  (uint64_t)&unk_1006BADB0,  (uint64_t **)&v10)[5] + 84);
}

uint64_t sub_100038834(uint64_t a1, int a2, _DWORD *a3, int a4)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  if (!*((void *)off_1008D60E8 + 26)) {
    return 0LL;
  }
  BOOL v7 = (void *)*((void *)off_1008D60E8 + 24);
  while (1)
  {
    uint64_t v8 = v7[5];
    unint64_t v9 = (void *)v7[1];
    if (v9)
    {
      do
      {
        uint64_t v10 = v9;
        unint64_t v9 = (void *)*v9;
      }

      while (v9);
    }

    else
    {
      do
      {
        uint64_t v10 = (void *)v7[2];
        BOOL v11 = *v10 == (void)v7;
        BOOL v7 = v10;
      }

      while (!v11);
    }

    BOOL v7 = v10;
  }

  unint64_t v12 = v7[4];
  if (v12)
  {
    if (sub_10003A0F8(a1, v12)) {
      return 0LL;
    }
  }

  __int16 v13 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(v8 + 40);
    int v15 = *(_DWORD *)(v14 + 20);
    LODWORD(v14) = *(unsigned __int8 *)(v14 + 1);
    v17[0] = 67109376;
    v17[1] = v15;
    __int16 v18 = 1024;
    int v19 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency mode:%d, inTransition:%d",  (uint8_t *)v17,  0xEu);
  }

  if (a4 && *(_BYTE *)(*(void *)(v8 + 40) + 1LL)) {
    return 0LL;
  }
  if (a3) {
    *a3 = *(_DWORD *)(*(void *)(v8 + 40) + 20LL);
  }
  return 1LL;
}

uint64_t sub_1000389D0(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = sub_100037B04(a1, a2);
  *(_WORD *)(v4 + 44) = 0;
  uint64_t result = sub_100037B04(v4, a2);
  uint64_t v6 = 0LL;
  *(_WORD *)(result + 46) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  do
  {
    *(_WORD *)(a1 + v6 + 24) = -25444;
    v6 += 6LL;
  }

  while (v6 != 18);
  return result;
}

void sub_100038A24(uint64_t a1, uint64_t a2, __int16 a3)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v6 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10003BAFC;
  block[3] = &unk_10087FF20;
  block[4] = a1;
  void block[5] = a2;
  __int16 v8 = a3;
  dispatch_async(v6, block);
}

uint64_t sub_100038AC8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  sub_1003D55EC(a3, (_DWORD *)&v6 + 1, &v6, (_DWORD *)&v5 + 1, &v5);
  else {
    return dword_1006BADB4[a2 - 1];
  }
}

uint64_t sub_100038B28(uint64_t a1, int a2)
{
  if (a2 == 300) {
    int v2 = 7;
  }
  else {
    int v2 = 6;
  }
  if (a2 == 100) {
    unsigned int v3 = 3;
  }
  else {
    unsigned int v3 = v2;
  }
  if (a2 == 80) {
    int v4 = 2;
  }
  else {
    int v4 = 6;
  }
  if (a2 == 60) {
    int v5 = 1;
  }
  else {
    int v5 = v4;
  }
  if (a2 <= 99) {
    unsigned int v3 = v5;
  }
  if (a2 == 30) {
    unsigned int v6 = 10;
  }
  else {
    unsigned int v6 = 6;
  }
  if (a2 == 5) {
    unsigned int v6 = 5;
  }
  if (a2 == 4) {
    unsigned int v6 = 4;
  }
  if (a2 <= 59) {
    return v6;
  }
  else {
    return v3;
  }
}

void sub_100038B94(uint64_t a1, int a2, __int16 a3)
{
  unsigned int v6 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    int v13 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency: Delay Latency State Decision by %d ",  buf,  8u);
  }

  dispatch_time_t v7 = dispatch_time(0LL, 1000000LL * a2);
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  __int16 v8 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  v9[2] = sub_10003B99C;
  v9[3] = &unk_10087EB68;
  v9[4] = a1;
  __int16 v10 = a3;
  __int16 v11 = a3;
  dispatch_after(v7, v8, v9);
}

uint64_t sub_100038CD4(uint64_t a1, int a2)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  unsigned int v3 = (void *)*((void *)off_1008D60E8 + 24);
  while (1)
  {
    uint64_t v4 = v3[5];
    int v5 = (void *)v3[1];
    if (v5)
    {
      do
      {
        unsigned int v6 = v5;
        int v5 = (void *)*v5;
      }

      while (v5);
    }

    else
    {
      do
      {
        unsigned int v6 = (void *)v3[2];
        BOOL v7 = *v6 == (void)v3;
        unsigned int v3 = v6;
      }

      while (!v7);
    }

    unsigned int v3 = v6;
  }

  if (!*(void *)(*(void *)(v4 + 40) + 8LL)) {
    return 0LL;
  }
  __int16 v8 = off_1008D60E8;
  uint64_t v9 = mach_absolute_time();
  float v10 = sub_1004AA0F0((uint64_t)v8, v9 - *(void *)(*(void *)(v4 + 40) + 8LL), 1);
  unsigned int v11 = (float)(1000.0 - v10);
  if (v11 <= 0xA) {
    unsigned int v11 = 10;
  }
  if (v10 >= 1000.0) {
    return 0LL;
  }
  else {
    return v11;
  }
}

void sub_100038DD4(uint64_t a1, unint64_t a2, unsigned int a3)
{
  int v6 = _os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming");
  if (!a2 || !v6) {
    goto LABEL_7;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  if (sub_100027194(*((void *)off_1008D60E8 + 28), a2))
  {
    sub_10003A490(a1, a2, a3);
  }

  else
  {
LABEL_7:
    BOOL v7 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
      sub_1006574F8(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }

void sub_100038EA0(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = sub_100036124(a1, a2);
  uint64_t v27 = v6;
  if (v6)
  {
    unint64_t v7 = v6;
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    uint64_t v8 = (void *)*((void *)off_1008D60E8 + 25);
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v10 = v8[4];
      BOOL v11 = v10 >= v7;
      if (v10 >= v7) {
        uint64_t v12 = v8;
      }
      else {
        uint64_t v12 = v8 + 1;
      }
      if (v11) {
        uint64_t v9 = (char *)v8;
      }
      uint64_t v8 = (void *)*v12;
    }

    while (*v12);
    if (v9 == (char *)off_1008D60E8 + 200 || v7 < *((void *)v9 + 4)) {
LABEL_15:
    }
      uint64_t v9 = (char *)off_1008D60E8 + 200;
    if (v9 != (char *)off_1008D60E8 + 200)
    {
      uint64_t v13 = (os_log_s *)qword_1008F7570;
      BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if (v14)
      {
        int v15 = *(_DWORD *)(sub_100037B04(v14, v7) + 20);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v15;
        __int16 v29 = 1024;
        int v30 = a3;
        __int16 v31 = 1024;
        int v32 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency trying to change jitter buffer from = 0x%x to = 0x%x on handle = %x",  buf,  0x14u);
      }

      uint64_t v16 = sub_100037B04(v14, v7);
      uint64_t v18 = sub_100037DE0(v16, v17, *(_DWORD *)(v16 + 20), a3);
      sub_100037F08(v18, v7, v18);
      *(_DWORD *)(sub_100037B04(v19, v7) + 20) = a3;
      uint64_t v20 = sub_1002E6BF0();
      uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v20 + 792LL))(v20, 2LL);
      if ((_DWORD)v21)
      {
        __int16 v22 = sub_100038AC8(v21, a3, v7);
        sub_100038A24(a1, v7, v22);
      }

      *(_BYTE *)(sub_100037B04(v21, v7) + 1) = 1;
      uint64_t v23 = sub_1004050C8();
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472LL;
      v24[2] = sub_10003BAA8;
      v24[3] = &unk_10087FF00;
      __int16 v26 = a2;
      int v25 = a3;
      sub_100405384(v23, v24);
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      *(void *)buf = &v27;
      if (*(_DWORD *)(sub_100029574( (uint64_t **)off_1008D60E8 + 24,  (unint64_t *)&v27,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 76) == 2)
      {
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        sub_1004ACD54((uint64_t *)off_1008D60E8, v27);
      }
    }
  }

BOOL sub_10003914C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = sub_1002E6BF0();
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 792LL))(v3, 2LL);
  int v5 = v4;
  int v6 = *(_DWORD *)(sub_100037B04(v4, a2) + 20);
  BOOL result = v6 == 1;
  if (v5) {
    BOOL result = v6 == 1
  }
          || (uint64_t v8 = sub_100037B04(result, a2), *(_DWORD *)(v8 + 20) == 2)
          || (uint64_t v9 = sub_100037B04(v8, a2), *(_DWORD *)(v9 + 20) == 3)
          || (uint64_t v10 = sub_100037B04(v9, a2), *(_DWORD *)(v10 + 20) == 4)
          || *(_DWORD *)(sub_100037B04(v10, a2) + 20) == 5;
  return result;
}

void sub_1000391F8(_BYTE *a1, unint64_t a2, unsigned int a3)
{
  unint64_t v4 = a2;
  unint64_t v47 = a2;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  int v6 = (char **)*((void *)off_1008D60E8 + 137);
  if (!v6) {
    goto LABEL_14;
  }
  unint64_t v7 = (char **)((char *)off_1008D60E8 + 1096);
  do
  {
    unsigned int v8 = *((unsigned __int16 *)v6 + 16);
    BOOL v9 = v8 >= a3;
    if (v8 >= a3) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v6 + 1;
    }
    if (v9) {
      unint64_t v7 = v6;
    }
    int v6 = (char **)*v10;
  }

  while (*v10);
  if (v7 == (char **)((char *)off_1008D60E8 + 1096) || *((unsigned __int16 *)v7 + 16) > a3) {
LABEL_14:
  }
    unint64_t v7 = (char **)((char *)off_1008D60E8 + 1096);
  BOOL v11 = (char **)((char *)off_1008D60E8 + 1096);
  if (v7 == (char **)((char *)off_1008D60E8 + 1096))
  {
    if (a1[6] || a1[9])
    {
      int v12 = 6;
    }

    else if (*a1)
    {
      if (a1[1] || a1[3] || a1[5] || a1[2] || a1[8] || a1[7])
      {
        int v12 = 1;
      }

      else if (a1[4])
      {
        int v12 = 1;
      }

      else
      {
        int v12 = 6;
      }
    }

    else
    {
      int v12 = 7;
    }
  }

  else
  {
    int v12 = 0;
  }

  uint64_t v13 = sub_100036124((uint64_t)a1, a3);
  if (v13 | v4)
  {
    if (!v13 && v4)
    {
      BOOL v14 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency creating AudioLinkManager device for handle %d, ",  buf,  8u);
      }

      int v15 = operator new(0x70uLL);
      sub_10003BCE8((uint64_t)v15, 0, 256, 0);
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      *(void *)buf = &v47;
      sub_100029574((uint64_t **)off_1008D60E8 + 24, &v47, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5] = (uint64_t)v15;
      unint64_t v4 = v47;
    }

    if (v4)
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      uint64_t v16 = (void *)*((void *)off_1008D60E8 + 25);
      if (!v16) {
        goto LABEL_42;
      }
      uint64_t v17 = (char *)off_1008D60E8 + 200;
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= v47;
        if (v18 >= v47) {
          uint64_t v20 = v16;
        }
        else {
          uint64_t v20 = v16 + 1;
        }
        if (v19) {
          uint64_t v17 = (char *)v16;
        }
        uint64_t v16 = (void *)*v20;
      }

      while (*v20);
      if (v17 == (char *)off_1008D60E8 + 200 || v47 < *((void *)v17 + 4)) {
LABEL_42:
      }
        uint64_t v17 = (char *)off_1008D60E8 + 200;
      if (v17 != (char *)off_1008D60E8 + 200)
      {
        uint64_t v21 = sub_100037F60(a1, 0);
        if ((_DWORD)v21)
        {
          *(_BYTE *)sub_100037B04(v21, v47) = 1;
        }

        else
        {
          uint64_t v23 = sub_1002E6BF0();
          uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v23 + 792LL))(v23, 5LL);
          if ((_DWORD)v24)
          {
            *(_BYTE *)sub_100037B04(v24, v47) = 0;
            int v12 = 1;
LABEL_51:
            int v25 = (os_log_s *)qword_1008F7570;
            if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
            {
              int v26 = a1[1];
              unsigned int v27 = a1[3];
              int v28 = a1[5];
              int v29 = a1[2];
              int v30 = a1[8];
              int v31 = a1[7];
              int v32 = a1[6];
              int v33 = a1[4];
              *(_DWORD *)buf = 67111168;
              *(_DWORD *)&uint8_t buf[4] = v26;
              __int16 v49 = 1024;
              unsigned int v50 = v27;
              __int16 v51 = 1024;
              int v52 = v28;
              __int16 v53 = 1024;
              int v54 = v29;
              __int16 v55 = 1024;
              int v56 = v30;
              __int16 v57 = 1024;
              int v58 = v31;
              __int16 v59 = 1024;
              int v60 = v32;
              __int16 v61 = 1024;
              BOOL v62 = v7 != v11;
              __int16 v63 = 1024;
              int v64 = v33;
              _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency Non streaming Trigger fKeyboardOn = %d, fVoiceOverOn=%d, fGameModeOn=%d, fGarageBandOn=% d, fSpatialVideoOn=%d, fSpatialMusicOn=%d, fExpanseOn =%d, aggregated=%d fConsoleGameModeOn=%d",  buf,  0x38u);
              int v25 = (os_log_s *)qword_1008F7570;
            }

            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v12;
              __int16 v49 = 1024;
              unsigned int v50 = a3;
              _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency trying to initialize jitter buffer to = 0x%x on handle = %x",  buf,  0xEu);
            }

            uint64_t v34 = sub_1002E6BF0();
            uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v34 + 792LL))(v34, 2LL);
            if ((_DWORD)v35)
            {
              uint64_t v36 = v47;
              __int16 v37 = sub_100038AC8(v35, v12, v47);
              sub_100038A24((uint64_t)a1, v36, v37);
            }

            if (qword_1008D60F0 != -1) {
              dispatch_once(&qword_1008D60F0, &stru_10087FF60);
            }
            *(void *)buf = &v47;
            int v38 = sub_100029574((uint64_t **)off_1008D60E8 + 24, &v47, (uint64_t)&unk_1006BADB0, (uint64_t **)buf);
            if (v38[5])
            {
              uint64_t v39 = v47;
              uint64_t v40 = sub_100037B04((uint64_t)v38, v47);
              uint64_t v42 = sub_100037DE0(v40, v41, *(_DWORD *)(v40 + 20), v12);
              sub_100037F08(v42, v39, v42);
            }

            uint64_t v43 = sub_1004050C8();
            v44[0] = _NSConcreteStackBlock;
            v44[1] = 3221225472LL;
            v44[2] = sub_10003B948;
            v44[3] = &unk_10087FF00;
            __int16 v46 = a3;
            int v45 = v12;
            sub_100405384(v43, v44);
            return;
          }
        }

        if (v7 != v11) {
          return;
        }
        goto LABEL_51;
      }
    }
  }

  else
  {
    __int16 v22 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Dynamic Latency no valid device object passed / found",  buf,  2u);
    }
  }

void sub_100039768(_Unwind_Exception *a1)
{
}

void sub_100039784(unint64_t a1, unint64_t a2)
{
  unint64_t v25 = a2;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  *(void *)buf = &v25;
  uint64_t v3 = sub_100029574((uint64_t **)off_1008D60E8 + 24, &v25, (uint64_t)&unk_1006BADB0, (uint64_t **)buf);
  unsigned int v4 = *(unsigned __int16 *)(v3[5] + 84);
  int v5 = *(_DWORD *)(sub_100037B04((uint64_t)v3, v25) + 20);
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  *(void *)buf = &v25;
  int v6 = *(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v25, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5] + 76);
  if (v6 == 2)
  {
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    *(void *)buf = &v25;
    if (**(unsigned __int8 **)(sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v25,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 48) == 240) {
      goto LABEL_12;
    }
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    *(void *)buf = &v25;
    if (**(unsigned __int8 **)(sub_100029574( (uint64_t **)off_1008D60E8 + 24,  &v25,  (uint64_t)&unk_1006BADB0,  (uint64_t **)buf)[5] + 48) == 241)
    {
LABEL_12:
      sub_100038DD4(a1, v25, v4);
      return;
    }
  }

  uint64_t v7 = sub_1002E6BF0();
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 792LL))(v7, 5LL);
  if ((_DWORD)v8)
  {
    if (v4)
    {
      *(_BYTE *)sub_100037B04(v8, v25) = 0;
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      *(void *)buf = &v25;
      if (*(__int16 *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v25, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5]
                      + 62) == -1
        || v5 != 1)
      {
        if (v6 == 2)
        {
          if (qword_1008D6458 != -1) {
            dispatch_once(&qword_1008D6458, &stru_10087FF40);
          }
          if (sub_10037BD00(qword_1008D6450, v4) <= 7)
          {
            *(_BYTE *)a1 = 1;
            BOOL v9 = (os_log_s *)qword_1008F7570;
            if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Constant Low Latency delay latency decision",  buf,  2u);
            }

LABEL_51:
            sub_100038B94(a1, 150, v4);
            return;
          }
        }

        uint64_t v21 = (os_log_s *)qword_1008F7570;
        if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Constant Low Latency overwrite latency with 60",  buf,  2u);
        }

        goto LABEL_57;
      }
    }
  }

  else
  {
    uint64_t v10 = sub_1002E6BF0();
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 328LL))(v10);
    if ((_DWORD)v11 && (uint64_t v11 = sub_100037F60((_BYTE *)a1, 0), (_DWORD)v11))
    {
      int v12 = *(unsigned __int16 *)(a1 + 16);
      uint64_t v13 = (os_log_s *)qword_1008F7570;
      BOOL v14 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if (v14)
      {
        uint64_t v15 = sub_1002E6BF0();
        int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 792LL))(v15, 5LL);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v12;
        __int16 v27 = 1024;
        int v28 = v5;
        __int16 v29 = 1024;
        int v30 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "check default latency %d, %d, %d",  buf,  0x14u);
      }

      if (v4)
      {
        *(_BYTE *)sub_100037B04(v14, v25) = 1;
        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        *(void *)buf = &v25;
        if (*(__int16 *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v25, (uint64_t)&unk_1006BADB0, (uint64_t **)buf)[5]
                        + 62) == -1
          || (v12 != 60 || v5 != 1)
          && (v12 != 80 || v5 != 2)
          && (v12 != 100 || v5 != 3)
          && (v12 != 120 || v5 != 4)
          && (v12 != 140 || v5 != 5)
          && (v12 != 150 || v5 != 6))
        {
          uint64_t v17 = (os_log_s *)qword_1008F7570;
          uint64_t v18 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v18)
          {
            int v19 = *(unsigned __int8 *)(sub_100037B04(v18, v25) + 1);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v12;
            __int16 v27 = 1024;
            int v28 = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Adaptive Latency overwritting with LLM JBL %d, tran:%d",  buf,  0xEu);
          }

          if (v6 == 2)
          {
            if (qword_1008D6458 != -1) {
              dispatch_once(&qword_1008D6458, &stru_10087FF40);
            }
            uint64_t v18 = sub_10037BD00(qword_1008D6450, v4);
          }

          if (!*(_BYTE *)(sub_100037B04(v18, v25) + 1))
          {
            if (v12 <= 99)
            {
              if (v12 == 60)
              {
LABEL_57:
                uint64_t v22 = a1;
                int v23 = v4;
                int v24 = 1;
LABEL_58:
                sub_100038EA0(v22, v23, v24);
                return;
              }

              if (v12 == 80)
              {
                uint64_t v22 = a1;
                int v23 = v4;
                int v24 = 2;
                goto LABEL_58;
              }
            }

            else
            {
              switch(v12)
              {
                case 100:
                  uint64_t v22 = a1;
                  int v23 = v4;
                  int v24 = 3;
                  goto LABEL_58;
                case 120:
                  uint64_t v22 = a1;
                  int v23 = v4;
                  int v24 = 4;
                  goto LABEL_58;
                case 140:
                  uint64_t v22 = a1;
                  int v23 = v4;
                  int v24 = 5;
                  goto LABEL_58;
              }
            }
          }
        }
      }
    }

    else if (v4)
    {
      uint64_t v20 = (_BYTE *)sub_100037B04(v11, v25);
      if (!*v20)
      {
        *(_BYTE *)sub_100037B04((uint64_t)v20, v25) = 1;
        sub_1000352CC(a1, v25, v4);
      }
    }
  }

    *a3 = 1;
    if (*(_BYTE *)(v7 + 656)) {
      sub_100099B10();
    }
    else {
      sub_100099BC0();
    }
  }

  else
  {
    LOWORD(v6) = 0;
  }

  return (unsigned __int16)v6;
}

  if (((v76 | v75) & 4) != 0) {
    v87 = sub_1001CD768( byte_1008D8ED3,  *(unsigned __int8 *)(v7 + 78),  (v75 & v76 & 8) != 0);
  }
  else {
    v87 = 1;
  }
LABEL_54:
  *(_BYTE *)(v7 + 16) = v87;
  *(_BYTE *)(v7 + 586) = 2;
  v88 = *a2;
  *(_WORD *)(v7 + 591) = *((_WORD *)a2 + 2);
  *(_DWORD *)(v7 + 587) = v88;
  BOOL result = sub_1001CD880(v7, 1);
  if ((_DWORD)result) {
    goto LABEL_46;
  }
  return result;
}

  sub_10023BF24((uint64_t)&v40, v41[0]);
LABEL_52:
}

        sub_10056AB04(&buf, (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL), v7);
        sub_10002EAC8(v23 + 48, (uint64_t)&buf);
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
        if (buf.__r_.__value_.__l.__size_) {
          sub_1002CD254((unsigned int *)buf.__r_.__value_.__l.__size_);
        }
        goto LABEL_53;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
      {
        sub_1005BF8CC(a2, &buf);
        sub_10069D334();
      }
    }
  }

uint64_t sub_100039DEC(uint64_t a1, int a2)
{
  uint64_t result = sub_100036124(a1, a2);
  if (result)
  {
    unint64_t v3 = result;
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    unsigned int v4 = (void *)*((void *)off_1008D60E8 + 25);
    if (!v4) {
      goto LABEL_15;
    }
    int v5 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= v3;
      if (v6 >= v3) {
        uint64_t v8 = v4;
      }
      else {
        uint64_t v8 = v4 + 1;
      }
      if (v7) {
        int v5 = (char *)v4;
      }
      unsigned int v4 = (void *)*v8;
    }

    while (*v8);
    if (v5 == (char *)off_1008D60E8 + 200 || v3 < *((void *)v5 + 4)) {
LABEL_15:
    }
      int v5 = (char *)off_1008D60E8 + 200;
    return v5 != (char *)off_1008D60E8 + 200 && *(_BYTE *)(sub_100037B04(result, v3) + 2) != 0;
  }

  return result;
}

uint64_t sub_100039EAC(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0LL;
  BOOL v9 = &v8;
  uint64_t v10 = 0x2020000000LL;
  uint64_t v11 = 0LL;
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  unsigned int v4 = (dispatch_queue_s *)*((void *)off_1008D60E8 + 30);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100039F78;
  block[3] = &unk_10087FEE0;
  void block[5] = a1;
  void block[6] = a2;
  block[4] = &v8;
  dispatch_sync(v4, block);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_100039F78(uint64_t a1)
{
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  int v2 = (char *)*((void *)off_1008D60E8 + 24);
  unint64_t v3 = (char *)off_1008D60E8 + 200;
  if (v2 != (char *)off_1008D60E8 + 200)
  {
    do
    {
      uint64_t v4 = *((void *)v2 + 5);
      if (*(_DWORD *)(v4 + 76) == 2)
      {
        uint64_t v5 = *(void *)(v4 + 40);
        if (*(_BYTE *)(v5 + 2))
        {
          uint64_t v6 = *((void *)v2 + 4);
          int v7 = *(unsigned __int16 *)(v5 + 48);
          **(_WORD **)(a1 + 4_Block_object_dispose(va, 8) = v7;
          uint64_t v8 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            int v13 = v7;
            _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Returning currentJitterBuffer %u",  buf,  8u);
          }

          *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v6;
        }
      }

      BOOL v9 = (char *)*((void *)v2 + 1);
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = *(char **)v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          uint64_t v10 = (char *)*((void *)v2 + 2);
          BOOL v11 = *(void *)v10 == (void)v2;
          int v2 = v10;
        }

        while (!v11);
      }

      int v2 = v10;
    }

    while (v10 != v3);
  }

BOOL sub_10003A0F8(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = sub_100037B04(a1, a2);
  BOOL result = 0;
  if (v3)
  {
    uint64_t v4 = sub_100037B04(v3, a2);
  }

  return result;
}

void sub_10003A150(_BYTE *a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    goto LABEL_24;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v6 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v6) {
    goto LABEL_15;
  }
  int v7 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v6 + 1;
    }
    if (v9) {
      int v7 = (char *)v6;
    }
    uint64_t v6 = (void *)*v10;
  }

  while (*v10);
  if (v7 == (char *)off_1008D60E8 + 200 || *((void *)v7 + 4) > a2) {
LABEL_15:
  }
    int v7 = (char *)off_1008D60E8 + 200;
  if (v7 == (char *)off_1008D60E8 + 200)
  {
LABEL_24:
    int v16 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
      sub_100657528(v16, v17, v18, v19, v20, v21, v22, v23);
    }
  }

  else if (!a1[4] && !a1[5] && !sub_10003A0F8((uint64_t)a1, a2))
  {
    if (sub_100037F60(a1, 0))
    {
      uint64_t v11 = sub_1002E6BF0();
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 328LL))(v11);
      if ((_DWORD)v12)
      {
        uint64_t v13 = sub_100037B04(v12, a2);
        *(_WORD *)(v13 + 50) = a3;
        if (a3 <= 0x32)
        {
          __int16 v14 = sub_1000386F0(v13, a2);
          uint64_t v15 = sub_1004050C8();
          v24[0] = _NSConcreteStackBlock;
          v24[1] = 3221225472LL;
          v24[2] = sub_10003A2D4;
          v24[3] = &unk_10087F980;
          __int16 v25 = a3;
          __int16 v26 = v14;
          sub_100405384(v15, v24);
        }
      }
    }
  }

void sub_10003A2D4(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008F7570;
  if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
    sub_100657558(a1, v2);
  }
  if (qword_1008D6458 != -1) {
    dispatch_once(&qword_1008D6458, &stru_10087FF40);
  }
  sub_10037BBBC(qword_1008D6450, *(unsigned __int16 *)(a1 + 34), 0x28u);
}

void sub_10003A358(uint64_t a1, unint64_t a2, char a3)
{
  unint64_t v9 = a2;
  if ((a3 & 1) == 0)
  {
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    uint64_t v4 = (void *)*((void *)off_1008D60E8 + 25);
    if (!v4) {
      goto LABEL_15;
    }
    uint64_t v5 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= a2;
      if (v6 >= a2) {
        unint64_t v8 = v4;
      }
      else {
        unint64_t v8 = v4 + 1;
      }
      if (v7) {
        uint64_t v5 = (char *)v4;
      }
      uint64_t v4 = (void *)*v8;
    }

    while (*v8);
    if (v5 == (char *)off_1008D60E8 + 200 || *((void *)v5 + 4) > a2) {
LABEL_15:
    }
      uint64_t v5 = (char *)off_1008D60E8 + 200;
    if (v5 != (char *)off_1008D60E8 + 200)
    {
      uint64_t v10 = &v9;
      *(_BYTE *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v9, (uint64_t)&unk_1006BADB0, (uint64_t **)&v10)[5] + 72) = 0;
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      uint64_t v10 = &v9;
      *(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v9, (uint64_t)&unk_1006BADB0, (uint64_t **)&v10)[5] + 76) = 0;
    }
  }

void sub_10003A490(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v38 = a2;
  if (!a2) {
    goto LABEL_23;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  unint64_t v6 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v6) {
    goto LABEL_15;
  }
  BOOL v7 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v6 + 1;
    }
    if (v9) {
      BOOL v7 = (char *)v6;
    }
    unint64_t v6 = (void *)*v10;
  }

  while (*v10);
  if (v7 == (char *)off_1008D60E8 + 200 || *((void *)v7 + 4) > a2) {
LABEL_15:
  }
    BOOL v7 = (char *)off_1008D60E8 + 200;
  if (v7 == (char *)off_1008D60E8 + 200)
  {
LABEL_23:
    uint64_t v14 = qword_1008F7570;
    if (!os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
    uint64_t v15 = "Low Latency Game, LatencyHubDevice object doesn't exist";
    int v16 = (os_log_s *)v14;
    uint32_t v17 = 2;
    goto LABEL_25;
  }

  if (*(_BYTE *)(sub_100037B04(a1, a2) + 1)) {
    goto LABEL_21;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  BOOL v11 = sub_1004AB7F8((uint64_t)off_1008D60E8);
  if (v11)
  {
LABEL_21:
    uint64_t v12 = a1;
    int v13 = 1000;
LABEL_22:
    sub_100038B94(v12, v13, a3);
    return;
  }

  int v13 = sub_100038CD4(v11, a3);
  if (v13)
  {
    uint64_t v12 = a1;
    goto LABEL_22;
  }

  uint64_t v18 = (os_log_s *)qword_1008F7570;
  BOOL v19 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    uint64_t v20 = sub_100037B04(v19, a2);
    int v21 = *(_DWORD *)(v20 + 24);
    int v22 = *(_DWORD *)(sub_100037B04(v20, a2) + 20);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v21;
    __int16 v40 = 1024;
    int v41 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game, decideLowLatencyGameStateTransition %d, %d",  buf,  0xEu);
  }

  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  *(void *)buf = &v38;
  uint64_t v23 = (uint64_t)sub_100029574((uint64_t **)off_1008D60E8 + 24, &v38, (uint64_t)&unk_1006BADB0, (uint64_t **)buf);
  if (*(_DWORD *)(*(void *)(v23 + 40) + 76LL) == 2)
  {
    if (qword_1008D6458 != -1) {
      dispatch_once(&qword_1008D6458, &stru_10087FF40);
    }
    uint64_t v23 = sub_10037BD00(qword_1008D6450, a3);
    if (v23 <= 7)
    {
      int v24 = (os_log_s *)qword_1008F7570;
      uint64_t v25 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v25)
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game, Sink JBL not filled, wait 150ms",  buf,  2u);
      }

      char v26 = 0;
      int v27 = 0;
      char v28 = 1;
      int v29 = 150;
      goto LABEL_60;
    }
  }

  uint64_t v30 = sub_100037B04(v23, v38);
  if (*(_DWORD *)(v30 + 20) != 1
    && (uint64_t v30 = sub_100037B04(v30, v38), *(_DWORD *)(v30 + 20) != 2)
    && (uint64_t v30 = sub_100037B04(v30, v38), *(_DWORD *)(v30 + 20) != 3)
    || (uint64_t v30 = sub_100037B04(v30, v38), *(_DWORD *)(v30 + 24) != 4))
  {
    if (*(_BYTE *)(a1 + 5)
      || *(_BYTE *)(a1 + 4)
      || (uint64_t v30 = sub_100037B04(v30, v38), *(_DWORD *)(v30 + 24) != 7)
      || (uint64_t v30 = sub_100037B04(v30, v38), *(_DWORD *)(v30 + 20) != 10))
    {
      uint64_t v25 = sub_100037B04(v30, v38);
      if (*(_DWORD *)(v25 + 24) != 7 || (uint64_t v25 = sub_100037B04(v25, v38), *(_DWORD *)(v25 + 20) != 10))
      {
        int v29 = 0;
        int v27 = 0;
        char v26 = 1;
        char v28 = 1;
        goto LABEL_60;
      }

      int v32 = (os_log_s *)qword_1008F7570;
      uint64_t v25 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v25)
      {
        *(_WORD *)buf = 0;
        int v33 = "Low Latency Game, Jitter T -> 60ms";
        goto LABEL_57;
      }
    }

    else
    {
      int v32 = (os_log_s *)qword_1008F7570;
      uint64_t v25 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v25)
      {
        *(_WORD *)buf = 0;
        int v33 = "Low Latency Game, Jitter -> 60ms";
LABEL_57:
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, buf, 2u);
      }
    }

    int v29 = 0;
    char v28 = 0;
    char v26 = 1;
    int v27 = 1;
    goto LABEL_60;
  }

  int v31 = (os_log_s *)qword_1008F7570;
  uint64_t v25 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
  if ((_DWORD)v25)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Low Latency Game, Jitter -> 30ms", buf, 2u);
  }

  int v29 = 0;
  char v28 = 0;
  int v27 = 10;
  char v26 = 1;
LABEL_60:
  if (*(_DWORD *)(sub_100037B04(v25, v38) + 20) == v27)
  {
    uint64_t v34 = qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = 30;
      uint64_t v15 = "Low Latency Game, Latency is already set to %d";
      int v16 = (os_log_s *)v34;
      uint32_t v17 = 8;
LABEL_25:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
    }
  }

  else if ((v26 & 1) != 0)
  {
    if ((v28 & 1) == 0)
    {
      uint64_t v35 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
      {
        int v36 = *(unsigned __int8 *)(a1 + 5);
        int v37 = *(unsigned __int8 *)(a1 + 4);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v27;
        __int16 v40 = 1024;
        int v41 = v36;
        __int16 v42 = 1024;
        int v43 = v37;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game, Dynamic Latency for AoS %u, fGameModeOn %d, fConsoleGameModeOn %d",  buf,  0x14u);
      }

      sub_100038EA0(a1, a3, v27);
    }
  }

  else
  {
    sub_100038B94(a1, v29, a3);
  }

void sub_10003AA5C(uint64_t a1, unint64_t a2)
{
  if (_os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming"))
  {
    if (*(_BYTE *)(a1 + 4))
    {
      BOOL v4 = 1;
      if (!a2) {
        return;
      }
    }

    else
    {
      BOOL v4 = *(_BYTE *)(a1 + 5) != 0;
      if (!a2) {
        return;
      }
    }

    if (v4)
    {
      uint64_t v5 = sub_1002E6E00();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 8LL))(v5))
      {
        int v27 = 0;
        uint64_t v6 = sub_1002E6E00();
        sub_10002418C(buf, "UniAoS");
        sub_10002418C(__p, "ignoreFlush");
        uint64_t v7 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v6 + 88LL))(v6, buf, __p, &v27);
        if (v26 < 0) {
          operator delete(__p[0]);
        }
        if (v31 < 0) {
          operator delete(*(void **)buf);
        }
        if (v27)
        {
          *(_BYTE *)(sub_100037B04(v7, a2) + 32) = 0;
          return;
        }
      }

      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      uint64_t v8 = sub_100027194(*((void *)off_1008D60E8 + 28), a2);
      if ((_DWORD)v8)
      {
        uint64_t v9 = sub_100037B04(v8, a2);
        if (*(int *)(v9 + 24) > 9 || *(int *)(sub_100037B04(v9, a2) + 24) <= 13)
        {
          uint64_t v10 = mach_absolute_time();
          uint64_t v11 = sub_100037B04(v10, a2);
          ++*(_BYTE *)(v11 + 32);
          BOOL v12 = sub_1003DD998(a2);
          if (!v12 || !*(_BYTE *)(a2 + 1373))
          {
            uint64_t v15 = (os_log_s *)qword_1008F7570;
            BOOL v16 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
            if (v16)
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game 2G flush, score->20",  buf,  2u);
            }

            goto LABEL_26;
          }

          uint64_t v13 = sub_100037B04(v12, a2);
          if (*(float *)(v13 + 40) == 0.0)
          {
            *(float *)(sub_100037B04(v13, a2) + 40) = (float)v10;
            uint64_t v14 = (os_log_s *)qword_1008F7570;
            if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game 1st flush in one second",  buf,  2u);
            }

            return;
          }

          if (qword_1008D60F0 != -1) {
            dispatch_once(&qword_1008D60F0, &stru_10087FF60);
          }
          uint32_t v17 = off_1008D60E8;
          uint64_t v18 = sub_100037B04(v13, a2);
          float v19 = sub_1004AA0F0((uint64_t)v17, (unint64_t)(float)((float)v10 - *(float *)(v18 + 40)), 1);
          *(float *)(sub_100037B04(v20, a2) + 40) = (float)v10;
          int v21 = (os_log_s *)qword_1008F7570;
          BOOL v22 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
          if (v22)
          {
            int v23 = *(unsigned __int8 *)(sub_100037B04(v22, a2) + 32);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v23;
            __int16 v29 = 2048;
            double v30 = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game flush %d in a second, delta: %f",  buf,  0x12u);
          }

          if (v19 <= 20.0)
          {
            *(_DWORD *)(sub_100037B04(v22, a2) + 2_Block_object_dispose(va, 8) = 20;
            int v24 = (os_log_s *)qword_1008F7570;
            BOOL v16 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
            if (v16)
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Low Latency Game, 2inrow flush, score->20",  buf,  2u);
            }

LABEL_26:
            *(_BYTE *)(sub_100037B04(v16, a2) + 32) = 4;
          }
        }
      }
    }
  }

    char v26 = v15 - (char *)result;
    goto LABEL_27;
  }

  uint64_t v18 = (_DWORD *)a1[1];
  uint64_t v13 = (_DWORD **)(a1 + 1);
  uint32_t v17 = v18;
  float v19 = 0xCCCCCCCCCCCCCCCDLL * (v18 - result);
  if (v19 >= a4)
  {
    uint64_t v15 = (char *)result;
    if (a2 != a3)
    {
      int v27 = result;
      do
      {
        char v28 = *v6;
        v27[4] = *((_DWORD *)v6 + 4);
        *(_OWORD *)int v27 = v28;
        v27 += 5;
        uint64_t v6 = (__int128 *)((char *)v6 + 20);
        v15 += 20;
      }

      while (v6 != a3);
    }

    goto LABEL_26;
  }

  uint64_t v20 = (__int128 *)((char *)a2 + 20 * v19);
  if (v17 != result)
  {
    int v21 = 20 * v19;
    do
    {
      BOOL v22 = *v6;
      result[4] = *((_DWORD *)v6 + 4);
      *(_OWORD *)BOOL result = v22;
      result += 5;
      uint64_t v6 = (__int128 *)((char *)v6 + 20);
      v21 -= 20LL;
    }

    while (v21);
    BOOL result = *v13;
  }

  int v23 = (char *)result;
  if (v20 != a3)
  {
    int v23 = (char *)result;
    int v24 = result;
    do
    {
      uint64_t v25 = *v20;
      void v24[4] = *((_DWORD *)v20 + 4);
      *(_OWORD *)int v24 = v25;
      v24 += 5;
      uint64_t v20 = (__int128 *)((char *)v20 + 20);
      v23 += 20;
    }

    while (v20 != a3);
  }

  char v26 = v23 - (char *)result;
LABEL_27:
  *uint64_t v13 = (_DWORD *)((char *)result + v26);
  return result;
}

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v49, 8);
}

          char v26 = 1;
        }

        ++v25;
      }

      while (v25 < *v23);
      int v21 = v45;
      if ((v26 & 1) != 0) {
        goto LABEL_37;
      }
    }

    if (v21[48])
    {
      if (!v21[55] || v21[56]) {
        goto LABEL_37;
      }
      int v37 = (uint64_t)(v21 + 57);
    }

    else
    {
      int v37 = (uint64_t)(v21 + 49);
    }

    sub_10011EA6C(0LL, v37, v31, v32, v33, v34, v35, v36);
LABEL_37:
    unint64_t v38 = HIDWORD(qword_1008F29F0[134 * v10 + 6]);
    if ((_DWORD)v38) {
      sub_1001EEB14(v38);
    }
    uint64_t v39 = &qword_1008F29F0[134 * v10];
    if (sub_1001EE9D8(*((_DWORD *)v39 + 110))) {
      sub_1001EEB14(*((unsigned int *)v39 + 110));
    }
    __int16 v40 = &qword_1008F29F0[134 * v10];
    int v43 = (void *)v40[8];
    __int16 v42 = v40 + 8;
    int v41 = v43;
    if (v43)
    {
      sub_1000B1838(v41);
      os_log_s *v42 = 0LL;
      LODWORD(qword_1008F29F0[134 * v10 + 9]) = 0;
    }

    v48[0] = xmmword_1006BC748;
    v48[1] = unk_1006BC758;
    memcpy(buf, "state", sizeof(buf));
    sub_1000B142C("Magnet Operation", (const char *)buf, v48, 2);
    __int16 v44 = &qword_1008F29F0[134 * --dword_1008F29B4];
    memcpy(&qword_1008F29F0[134 * v10], v44, 0x430uLL);
    bzero(v44, 0x430uLL);
  }

    if (sub_1000A86F0())
    {
      char v26 = dword_1008F29B4;
      if (dword_1008F29B4)
      {
        int v27 = (unsigned int *)&dword_1008F2A20;
        while (*((unsigned __int16 *)v27 - 20) != (_DWORD)v16)
        {
          v27 += 268;
          if (!--v26) {
            goto LABEL_31;
          }
        }

        char v28 = *v27;
      }

      else
      {
LABEL_31:
        char v28 = 0;
      }

      __int16 v29 = sub_1000FFB28(v28);
      sub_1001EE134( (uint64_t)"Message should only be send when in ##state state. Current state is %s",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  (uint64_t)v29);
      int v37 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 408LL;
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Link is not encrypted, can't send upgrade", v5, v6, v7, v8, v9, v10, v11, v38);
      BOOL v12 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    return 4802LL;
  }

  if (a2 == 1)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Detected error in upgrade, past tech is LE", v34, v35, v36, v37, v38, v39, v40, v52);
      int v41 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v42 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = v42;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }

  else if (*((void *)&xmmword_1008F29B8 + 1) && (a3 & 1) == 0)
  {
    (*((void (**)(uint64_t, uint64_t, uint64_t))&xmmword_1008F29B8 + 1))(*v5, 1LL, v8);
    goto LABEL_36;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Skipping scalable pipe downCb due to upgrade error %x",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  *((uint64_t *)&xmmword_1008F29B8 + 1));
    unsigned int v50 = (os_log_s *)sub_100086554(0x56u);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v51 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v51;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  int v32 = *(void **)(a2 + 120);
  if (v32) {
    sub_1000B1838(v32);
  }
  return v7;
}

              char v28 = sub_1001EDDCC();
              *(_DWORD *)buf = 136446466;
              uint64_t v34 = v28;
              uint64_t v35 = 1024;
              int v36 = 0xFFFF;
              _os_log_error_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
              goto LABEL_24;
            }

            BOOL v12 = sub_10012D890((uint64_t)v9);
            if (!v12) {
              goto LABEL_22;
            }
          }

          else
          {
            if (v11 != 6)
            {
              sub_1001EE134( (uint64_t)"Unable to recover handle from failed status event - no event context",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v32);
              uint64_t v20 = (os_log_s *)sub_100086554(0x2Eu);
              if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                goto LABEL_24;
              }
              goto LABEL_26;
            }

            BOOL v12 = (uint64_t)sub_10012D6D8(*v9);
          }
    }

    if (*((_BYTE *)v13 + 55)) {
      uint64_t v6 = v13 + 28;
    }
    else {
      uint64_t v6 = 0LL;
    }
    sub_1001ADE74(129LL, 0, 0, (unsigned __int8 *)v13 + 48, v6, 0, 0, 0, 0, 0xFFFF, 0);
LABEL_25:
    uint64_t v13 = 0LL;
    goto LABEL_26;
  }

    sub_1001EC444((uint64_t)&v11);
    uint64_t v3 = v11;
    if (!v11) {
      return 0LL;
    }
  }

  *(void *)a1 = v4;
  return 1LL;
}

  if (*a1 != qword_1008E8870)
  {
LABEL_29:
    sub_1000B1838(a1);
    return 0LL;
  }

  BOOL v22 = 0LL;
  uint64_t v10 = sub_100171EC4(4u, &v22);
  if (!(_DWORD)v10)
  {
    uint64_t v11 = v22;
    *(void *)(v22 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(v11 + 16) = 0LL;
    *(_WORD *)(v11 + 24) = 0;
    sub_1001A1F2C();
    goto LABEL_29;
  }

  uint64_t v13 = v10;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"_LE_ATT_RemoveATTSession %!", v14, v15, v16, v17, v18, v19, v20, v13);
    int v21 = (os_log_s *)sub_100086554(0x44u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

  sub_1000AFE20(v13);
  return sub_1001A1ED4();
}

    sub_1001EE2A0();
    return;
  }

  sub_100657858();
  if (!v2) {
    goto LABEL_22;
  }
LABEL_9:
  if (!*(_BYTE *)(v2 + 2))
  {
    BOOL v12 = sub_1000B29F0(((unint64_t)*(unsigned __int8 *)(v2 + 48) << 40) | ((unint64_t)*(unsigned __int8 *)(v2 + 49) << 32) | ((unint64_t)*(unsigned __int8 *)(v2 + 50) << 24) | ((unint64_t)*(unsigned __int8 *)(v2 + 51) << 16) | ((unint64_t)*(unsigned __int8 *)(v2 + 52) << 8) | *(unsigned __int8 *)(v2 + 53));
    goto LABEL_14;
  }

  if (*(_BYTE *)(v2 + 2) != 4)
  {
    if (sub_1000A86F0())
    {
      char v28 = *(unsigned __int8 *)(v2 + 2) == 4;
      goto LABEL_24;
    }

    goto LABEL_26;
  }

  *(_DWORD *)((char *)v31 + 3) = 0;
  v31[0] = 0;
  uint64_t v11 = 0LL;
  if (!sub_1001B9A58(v2, (uint64_t)v31, 0LL))
  {
    *(_DWORD *)(v2 + 132) = 6;
    *(_DWORD *)(v2 + 140) = 4541;
    BOOL v12 = sub_1001BD774(v31);
LABEL_14:
    uint64_t v11 = v12;
  }

  if ((_DWORD)v11 && sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"ATT disconnect failure during Indication response with status %!",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v11);
    uint64_t v20 = (os_log_s *)sub_100086554(0x44u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

        sub_1000B1838(v15);
        qword_1008E88E0 = (uint64_t)v13;
        word_1008E88E8 = v9;
        return;
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Failed to allocate room for updated stall queue",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v39);
        double v30 = (os_log_s *)sub_100086554(0x44u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }
  }

          int v32 = sub_100184F74(*(__int128 **)v4, &v73, 0x11uLL, 1);
          if ((_DWORD)v32)
          {
            int v23 = v32;
            sub_100184BB0((char *)v4, v32, 1);
            return v23;
          }

          if ((*(_BYTE *)(v4 + 72) & *(_BYTE *)(v4 + 80) & 8) != 0)
          {
            int v33 = *(unsigned __int8 *)(v4 + 16);
            switch(v33)
            {
              case 6:
                goto LABEL_32;
              case 5:
                if (sub_1000A86F0())
                {
                  sub_1001EE134((uint64_t)"Should not be here !", v64, v65, v66, v67, v68, v69, v70, v72);
                  int v71 = (os_log_s *)sub_100086554(0x43u);
                  if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
                    sub_100657858();
                  }
                }

                sub_100184BB0((char *)v4, 408LL, 1);
                return 0LL;
              case 1:
LABEL_32:
                uint64_t v34 = v4;
                uint64_t v35 = 36;
LABEL_55:
                sub_100185420(v34, v35);
                return 0LL;
            }

            if (*(_BYTE *)(*(void *)v4 + 70LL) == 1) {
              uint64_t v35 = 36;
            }
            else {
              uint64_t v35 = 35;
            }
          }

          else if (*(_BYTE *)(a1 + 70))
          {
            uint64_t v35 = 35;
          }

          else
          {
            uint64_t v35 = 34;
          }

          uint64_t v34 = v4;
          goto LABEL_55;
        }

        if (sub_10018550C(v3, 34))
        {
          uint64_t v5 = *(unsigned __int8 *)(a1 + 70);
          goto LABEL_9;
        }

        int v36 = sub_100185414();
        sub_1001EE134( (uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MPUBLICK to send this command, current state is %s.",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  (uint64_t)v36);
        __int16 v44 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
          return 4823LL;
        }
      }

      else
      {
        if (!*(_BYTE *)(a1 + 70))
        {
          if (!sub_10018550C(v3, 18))
          {
            int v54 = sub_100185414();
            sub_1001EE134( (uint64_t)"Central connection should be in SMP_STATE_PAIRING_RESP to send this command, current state is %s.",  v55,  v56,  v57,  v58,  v59,  v60,  v61,  (uint64_t)v54);
            BOOL v62 = (os_log_s *)sub_100086554(0x43u);
            if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
              return 4823LL;
            }
            goto LABEL_44;
          }

          uint64_t v5 = *(unsigned __int8 *)(a1 + 70);
        }

        if (v5 != 1 || sub_10018550C(v4, 34)) {
          goto LABEL_26;
        }
        int v45 = sub_100185414();
        sub_1001EE134( (uint64_t)"Peripheral connection should be in SMP_STATE_PAIRING_MCONFIRM to send this command, current state is %s.",  v46,  v47,  v48,  v49,  v50,  v51,  v52,  (uint64_t)v45);
        __int16 v53 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR)) {
          return 4823LL;
        }
      }
    }

    else
    {
      sub_1001EE134((uint64_t)"This device is not in a pairing state.", v24, v25, v26, v27, v28, v29, v30, v72);
      char v31 = (os_log_s *)sub_100086554(0x43u);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return 4823LL;
      }
    }

  uint64_t v13 = (os_log_s *)qword_1008F76F8;
  if (os_log_type_enabled((os_log_t)qword_1008F76F8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(unsigned __int8 *)(a1 + 52);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Stack State                : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 53);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Location Update Complete   : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v16 = *(unsigned __int8 *)(a1 + 54);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Band Update Pending        : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint32_t v17 = *(unsigned __int8 *)(a1 + 136);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Debounce Enabled           : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = *(_DWORD *)(a1 + 64);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Debounce Retry Value       : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    float v19 = *(unsigned __int8 *)(a1 + 68);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Allowed Band               : 0x%X",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = *(unsigned __int8 *)(a1 + 69);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Current Band               : 0x%X",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = *(unsigned __int8 *)(a1 + 137);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "AWDL State                 : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v22 = *(unsigned __int8 *)(a1 + 138);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Low Wi-Fi Rate             : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = *(unsigned __int8 *)(a1 + 139);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "AWDL RTG State             : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = *(unsigned __int8 *)(a1 + 141);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Nan State                  : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = *(unsigned __int8 *)(a1 + 142);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Host 5GHz AP State         : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    char v26 = *(unsigned __int8 *)(a1 + 140);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "UWB 5Ghz                   : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_1001F9F74(a1 + 160, &buf);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v27 = &buf;
    }
    else {
      int v27 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int16 v46 = 136315138;
    unint64_t v47 = v27;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "WiFiState                  : %s", v46, 0xCu);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    char v28 = *(unsigned __int8 *)(a1 + 143);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v28;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "HRB Requested              : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v29 = *(unsigned __int8 *)(a1 + 145);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v29;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Suffucient BW for BT       : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    double v30 = *(unsigned __int8 *)(a1 + 146);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v30;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Wi-Fi BW GT Max            : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    char v31 = *(int *)(a1 + 148);
    else {
      int v32 = off_10088A020[v31];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Wi-Fi Current Band         : %s",  (uint8_t *)&buf,  0xCu);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v33 = ((*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 2) + 1;
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v33;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Num Bands Available        : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = *(char *)(a1 + 69);
    if (v34 > 8) {
      uint64_t v35 = "Unknown BSM Band Code";
    }
    else {
      uint64_t v35 = off_10088A020[v34];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v35;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Current Selected HRB Band  : %s",  (uint8_t *)&buf,  0xCu);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v36 = *(_DWORD *)(a1 + 96);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v36;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Current HRB Band Idx       : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  int v37 = *(void *)(a1 + 72);
  unint64_t v38 = *(void *)(a1 + 80);
  if (v38 != v37)
  {
    uint64_t v39 = 0LL;
    do
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v40 = *(int *)(v37 + 4 * v39);
        int v41 = "Unknown BSM Band Code";
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "           %s ", (uint8_t *)&buf, 0xCu);
        uint64_t v13 = (os_log_s *)qword_1008F76F8;
        int v37 = *(void *)(a1 + 72);
        unint64_t v38 = *(void *)(a1 + 80);
      }

      ++v39;
    }

    while (v39 < (v38 - v37) >> 2);
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"BSM_BAND_CODE_ISM24";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "           %s ", (uint8_t *)&buf, 0xCu);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v42 = _os_feature_enabled_impl("CoreWiFi", "Figaro5GTDD");
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v42;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "HRBTDD Allowed             : %d",  (uint8_t *)&buf,  8u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (*(_BYTE *)(a1 + 144) && os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "ForceHRB                   : On",  (uint8_t *)&buf,  2u);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  int v43 = *(int *)(a1 + 152);
  if ((_DWORD)v43 != 8 && os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    else {
      __int16 v44 = off_100889F80[v43];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v44;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Force UNII for band        : %s",  (uint8_t *)&buf,  0xCu);
    uint64_t v13 = (os_log_s *)qword_1008F76F8;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "---------- BandSwitchManager END DUMP STATE ----------",  (uint8_t *)&buf,  2u);
  }

  int v24 = *(unsigned int *)(a1 + 296);
  if ((_DWORD)v4 != (_DWORD)v24)
  {
    uint64_t v25 = (os_log_s *)qword_1008F7598;
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_INFO))
    {
      char v26 = *(void *)(a1 + 8LL * a2 + 272);
      int v27 = *(void *)(a1 + 248 + 8 * v4);
      char v28 = *(void *)(a1 + 248 + 8 * v24);
      __int16 v29 = *(void *)(a1 + 8LL * *(unsigned int *)(a1 + 336) + 312);
      double v30 = sub_10026FA80(*(void *)(a1 + 160));
      char v31 = *(unsigned __int16 *)(a1 + 242);
      *(_DWORD *)buf = 136447490;
      uint64_t v35 = v26;
      int v36 = 2082;
      int v37 = v27;
      unint64_t v38 = 2082;
      uint64_t v39 = v28;
      __int16 v40 = 2082;
      int v41 = v29;
      __int16 v42 = 2048;
      int v43 = v30;
      __int16 v44 = 1024;
      int v45 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "Input: %{public}s. State: %{public}s -> %{public}s. SendState %{public}s, %zu, %hu",  buf,  0x3Au);
    }
  }

  return sub_100242FAC((uint64_t)v33);
}

              float v19 = (os_log_s *)qword_1008F7558;
              uint64_t v8 = os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v8)
              {
                p_buf = &buf;
                if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)uint64_t v25 = 136446466;
                char v26 = p_buf;
                int v27 = 1024;
                char v28 = a4;
                _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Audio Codec ID %{public}s for remote SEID %d",  v25,  0x12u);
              }

              goto LABEL_32;
            }

            sub_1003A4868(a1, (uint64_t)v10, a4);
            uint64_t v18 = "SBC";
          }

    uint64_t v14 = -1;
LABEL_27:
    BOOL result = 0LL;
    *a3 = v14;
    return result;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
    sub_100677CF4();
  }
  return 212LL;
}

    __p = v13;
    uint64_t v25 = v9;
    char v26 = (unint64_t)v17;
    if (v14) {
      operator delete(v14);
    }
    goto LABEL_28;
  }

  if ((unint64_t)__p >= v26)
  {
    uint64_t v11 = (uint64_t)(v26 - (void)__p) >> 1;
    if (v11 <= 1) {
      uint64_t v11 = 1LL;
    }
    else {
      BOOL v12 = v11;
    }
    uint64_t v13 = (char *)sub_10024E33C((uint64_t)&v26, v12);
    uint64_t v14 = (char *)__p;
    uint64_t v15 = v25;
    uint32_t v17 = &v13[4 * v16];
    *(_DWORD *)uint64_t v13 = a2;
    uint64_t v9 = v13 + 4;
    while (v15 != v14)
    {
      uint64_t v18 = *((_DWORD *)v15 - 1);
      v15 -= 4;
      *((_DWORD *)v13 - 1) = v18;
      v13 -= 4;
    }

    goto LABEL_26;
  }

  *(_DWORD *)__p = a2;
  uint64_t v9 = v8 + 4;
LABEL_28:
  uint64_t v25 = v9;
  sub_1003D8C54(v7, (_DWORD **)&__p);
  sub_1003D70B0((uint64_t)v7);
  if (__p)
  {
    uint64_t v25 = (char *)__p;
    operator delete(__p);
  }

  return 0LL;
}

  BOOL v12 = *(_DWORD *)(a1 + 1076);
  if (v12 != 76
    || ((uint64_t v13 = *(_DWORD *)(a1 + 1080) - 8202, v14 = v13 > 0x15, v15 = (1 << v13) & 0x20033F, !v14)
      ? (BOOL v16 = v15 == 0)
      : (BOOL v16 = 1),
        v16))
  {
    if (!*(_BYTE *)(a1 + 1069) || (*(_BYTE *)(a1 + 1090) & 0x80) == 0)
    {
      uint32_t v17 = 0;
      goto LABEL_42;
    }
  }

  uint64_t v18 = *(_DWORD *)(a1 + 1072);
  if (v18 == 2)
  {
    float v19 = 1452;
  }

  else
  {
    if (v18 != 1)
    {
      uint64_t v20 = 0;
      goto LABEL_41;
    }

    float v19 = 76;
  }

  uint64_t v20 = v12 == v19;
LABEL_41:
  uint32_t v17 = (*(unsigned int *)(a1 + 176) < 0x30uLL) & (0x8000001B0000uLL >> *(_DWORD *)(a1 + 176)) & v20;
LABEL_42:
  int v36 = xmmword_1006C28A0;
  int v21 = *(_DWORD *)(a1 + 1072);
  if (v21 == 2)
  {
    BOOL v22 = 1452;
  }

  else
  {
    if (v21 != 1) {
      goto LABEL_48;
    }
    BOOL v22 = 76;
  }

  if (v12 == v22)
  {
    int v23 = 0;
    goto LABEL_49;
  }

  sub_100242FAC((uint64_t)v20);
  return v12;
}

  uint32_t v17 = (os_log_s *)qword_1008F7648;
  if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = *(_DWORD *)(v3 + 264);
    LODWORD(__p[0]) = 67109120;
    HIDWORD(__p[0]) = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "statedump:       instance:%d",  (uint8_t *)__p,  8u);
  }

  float v19 = *(void *)(v3 + 256);
  if (v19)
  {
    uint64_t v20 = (os_log_s *)qword_1008F7648;
    if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = sub_1005BFB9C(v19);
      BOOL v22 = (id)objc_claimAutoreleasedReturnValue(v21);
      LODWORD(__p[0]) = 138543362;
      *(void **)((char *)__p + 4) = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "statedump:       instanceAddress: %{public}@",  (uint8_t *)__p,  0xCu);
    }
  }

  __int16 v77 = v8;
  if (v4 != v5)
  {
    v97 = 0LL;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    v91 = 0u;
    v92 = 0u;
    v89 = 0u;
    v90 = 0u;
    v87 = 0u;
    v88 = 0u;
    *(_OWORD *)v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v81 = 0u;
    v82 = 0u;
    *(_OWORD *)__p = 0u;
    sub_1001FCFC8((uint64_t)__p);
    sub_1001FD17C(&v81, (uint64_t)"      16-bit UUID(s): ", 22LL);
    else {
      int v23 = (v4 - v5) / 20;
    }
    int v24 = (uint64_t)v5;
    do
    {
      sub_1006344B4(v24, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_buf = &buf;
      }
      else {
        p_buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size = buf.__r_.__value_.__s.__size_;
      }
      else {
        size = buf.__r_.__value_.__l.__size_;
      }
      int v27 = sub_1001FD17C(&v81, (uint64_t)p_buf, size);
      sub_1001FD17C(v27, (uint64_t)" ", 1LL);
      v24 += 20LL;
      --v23;
    }

    while (v23);
    char v28 = (os_log_s *)qword_1008F7648;
    if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
    {
      std::stringbuf::str(&buf, (const std::stringbuf *)((char *)&v81 + 8));
      __int16 v29 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v78.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v78.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)&v78,  0xCu);
    }

    *(void **)((char *)__p
    *(void *)&v81 = v30;
    if (SHIBYTE(v86) < 0) {
      operator delete(v85[1]);
    }
    std::streambuf::~streambuf((char *)&v81 + 8);
    std::ios::~ios(&v88);
  }

  char v31 = v76;
  int v32 = v6 - (_BYTE *)v76;
  if (v32)
  {
    v97 = 0LL;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    v91 = 0u;
    v92 = 0u;
    v89 = 0u;
    v90 = 0u;
    v87 = 0u;
    v88 = 0u;
    *(_OWORD *)v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v81 = 0u;
    v82 = 0u;
    *(_OWORD *)__p = 0u;
    sub_1001FCFC8((uint64_t)__p);
    sub_1001FD17C(&v81, (uint64_t)"      32-bit UUID(s): ", 22LL);
    else {
      int v33 = v32 / 20;
    }
    char v31 = v76;
    uint64_t v34 = (uint64_t)v76;
    do
    {
      sub_1006344B4(v34, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v35 = &buf;
      }
      else {
        uint64_t v35 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v36 = buf.__r_.__value_.__s.__size_;
      }
      else {
        int v36 = buf.__r_.__value_.__l.__size_;
      }
      int v37 = sub_1001FD17C(&v81, (uint64_t)v35, v36);
      sub_1001FD17C(v37, (uint64_t)" ", 1LL);
      v34 += 20LL;
      --v33;
    }

    while (v33);
    unint64_t v38 = (os_log_s *)qword_1008F7648;
    if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
    {
      std::stringbuf::str(&buf, (const std::stringbuf *)((char *)&v81 + 8));
      uint64_t v39 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v78.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v78.__r_.__value_.__r.__words + 4) = (std::string::size_type)v39;
      _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)&v78,  0xCu);
    }

    *(void **)((char *)__p
    *(void *)&v81 = v40;
    if (SHIBYTE(v86) < 0) {
      operator delete(v85[1]);
    }
    std::streambuf::~streambuf((char *)&v81 + 8);
    std::ios::~ios(&v88);
  }

  int v41 = v9 - v8;
  if (v9 != v8)
  {
    v97 = 0LL;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    v91 = 0u;
    v92 = 0u;
    v89 = 0u;
    v90 = 0u;
    v87 = 0u;
    v88 = 0u;
    *(_OWORD *)v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v81 = 0u;
    v82 = 0u;
    *(_OWORD *)__p = 0u;
    sub_1001FCFC8((uint64_t)__p);
    sub_1001FD17C(&v81, (uint64_t)"      128-bit UUID(s): ", 23LL);
    else {
      __int16 v42 = v41 / 20;
    }
    int v43 = (uint64_t)v8;
    do
    {
      sub_1006344B4(v43, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v44 = &buf;
      }
      else {
        __int16 v44 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v45 = buf.__r_.__value_.__s.__size_;
      }
      else {
        int v45 = buf.__r_.__value_.__l.__size_;
      }
      __int16 v46 = sub_1001FD17C(&v81, (uint64_t)v44, v45);
      sub_1001FD17C(v46, (uint64_t)" ", 1LL);
      v43 += 20LL;
      --v42;
    }

    while (v42);
    unint64_t v47 = (os_log_s *)qword_1008F7648;
    if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
    {
      std::stringbuf::str(&buf, (const std::stringbuf *)((char *)&v81 + 8));
      int v48 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v78.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v78.__r_.__value_.__r.__words + 4) = (std::string::size_type)v48;
      _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)&v78,  0xCu);
    }

    *(void **)((char *)__p
    *(void *)&v81 = v49;
    if (SHIBYTE(v86) < 0) {
      operator delete(v85[1]);
    }
    std::streambuf::~streambuf((char *)&v81 + 8);
    std::ios::~ios(&v88);
  }

  if (*(_BYTE *)(v3 + 308))
  {
    v97 = 0LL;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    v91 = 0u;
    v92 = 0u;
    v89 = 0u;
    v90 = 0u;
    v87 = 0u;
    v88 = 0u;
    *(_OWORD *)v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v81 = 0u;
    v82 = 0u;
    *(_OWORD *)__p = 0u;
    sub_1001FCFC8((uint64_t)__p);
    unsigned int v50 = sub_1001FD17C(&v81, (uint64_t)"      ObjectLocatorOnThisInstance(", 34LL);
    __int16 v51 = (void *)std::ostream::operator<<(v50, *(unsigned int *)(v3 + 264));
    sub_1001FD17C(v51, (uint64_t)")", 1LL);
    int v52 = (os_log_s *)qword_1008F7648;
    if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
    {
      std::stringbuf::str(&buf, (const std::stringbuf *)((char *)&v81 + 8));
      __int16 v53 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v78.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v78.__r_.__value_.__r.__words + 4) = (std::string::size_type)v53;
      _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)&v78,  0xCu);
    }

    *(void **)((char *)__p
    *(void *)&v81 = v54;
    if (SHIBYTE(v86) < 0) {
      operator delete(v85[1]);
    }
    std::streambuf::~streambuf((char *)&v81 + 8);
    std::ios::~ios(&v88);
  }

  if (*(_BYTE *)(v3 + 360))
  {
    v97 = 0LL;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    v91 = 0u;
    v92 = 0u;
    v89 = 0u;
    v90 = 0u;
    v87 = 0u;
    v88 = 0u;
    *(_OWORD *)v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v81 = 0u;
    v82 = 0u;
    *(_OWORD *)__p = 0u;
    sub_1001FCFC8((uint64_t)__p);
    sub_1001FD17C(&v81, (uint64_t)"      PowerAssertion", 20LL);
    __int16 v55 = (os_log_s *)qword_1008F7648;
    if (os_log_type_enabled((os_log_t)qword_1008F7648, OS_LOG_TYPE_DEFAULT))
    {
      std::stringbuf::str(&buf, (const std::stringbuf *)((char *)&v81 + 8));
      int v56 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v78.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v78.__r_.__value_.__r.__words + 4) = (std::string::size_type)v56;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)&v78,  0xCu);
    }

    *(void **)((char *)__p
    *(void *)&v81 = v57;
    if (SHIBYTE(v86) < 0) {
      operator delete(v85[1]);
    }
    std::streambuf::~streambuf((char *)&v81 + 8);
    std::ios::~ios(&v88);
  }

  if (*(_DWORD *)(v3 + 264) == 2)
  {
    v97 = 0LL;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    v91 = 0u;
    v92 = 0u;
    v89 = 0u;
    v90 = 0u;
    v87 = 0u;
    v88 = 0u;
    *(_OWORD *)v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v81 = 0u;
    v82 = 0u;
    *(_OWORD *)__p = 0u;
    sub_1001FCFC8((uint64_t)__p);
    sub_1001FD17C(&v81, (uint64_t)"      Exposure Notification", 27LL);
    int v58 = (os_log_s *)qword_1008F76E0;
    if (os_log_type_enabled((os_log_t)qword_1008F76E0, OS_LOG_TYPE_DEFAULT))
    {
      std::stringbuf::str(&buf, (const std::stringbuf *)((char *)&v81 + 8));
      __int16 v59 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v78.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v78.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
      _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)&v78,  0xCu);
    }

    *(void **)((char *)__p
    *(void *)&v81 = v60;
    if (SHIBYTE(v86) < 0) {
      operator delete(v85[1]);
    }
    std::streambuf::~streambuf((char *)&v81 + 8);
    std::ios::~ios(&v88);
  }

  if (!*(void *)(v3 + 128)) {
    goto LABEL_164;
  }
  v97 = 0LL;
  v95 = 0u;
  v96 = 0u;
  v93 = 0u;
  v94 = 0u;
  v91 = 0u;
  v92 = 0u;
  v89 = 0u;
  v90 = 0u;
  v87 = 0u;
  v88 = 0u;
  *(_OWORD *)v85 = 0u;
  v86 = 0u;
  v83 = 0u;
  v84 = 0u;
  v81 = 0u;
  v82 = 0u;
  *(_OWORD *)__p = 0u;
  sub_1001FCFC8((uint64_t)__p);
  sub_1001FD17C(&v81, (uint64_t)"      serviceData(", 18LL);
  __int16 v61 = *(void **)(v3 + 112);
  if (v61 != (void *)(v3 + 120))
  {
    do
    {
      sub_1006344B4((uint64_t)(v61 + 4), &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        BOOL v62 = &buf;
      }
      else {
        BOOL v62 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v63 = buf.__r_.__value_.__s.__size_;
      }
      else {
        __int16 v63 = buf.__r_.__value_.__l.__size_;
      }
      int v64 = sub_1001FD17C(&v81, (uint64_t)v62, v63);
      int v65 = sub_1001FD17C(v64, (uint64_t)"<", 1LL);
      sub_10056B0A4((uint64_t)(v61 + 7), &v78);
      if ((v78.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v66 = &v78;
      }
      else {
        __int16 v66 = (std::stringbuf::string_type *)v78.__r_.__value_.__r.__words[0];
      }
      if ((v78.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unsigned int v67 = v78.__r_.__value_.__s.__size_;
      }
      else {
        unsigned int v67 = v78.__r_.__value_.__l.__size_;
      }
      __int16 v68 = sub_1001FD17C(v65, (uint64_t)v66, v67);
      sub_1001FD17C(v68, (uint64_t)">", 1LL);
      int v69 = (void *)v61[1];
      if (v69)
      {
        do
        {
          __int16 v70 = v69;
          int v69 = (void *)*v69;
        }

        while (v69);
      }

      else
      {
        do
        {
          __int16 v70 = (void *)v61[2];
          int v71 = *v70 == (void)v61;
          __int16 v61 = v70;
        }

        while (!v71);
      }

      __int16 v61 = v70;
    }

    while (v70 != (void *)(v3 + 120));
  }

  char v31 = v76;
  sub_1001FD17C(&v81, (uint64_t)")", 1LL);
  __int16 v72 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v72 + 176LL))(v72))
  {
    int v73 = (os_log_s *)qword_1008F76E0;
    if (os_log_type_enabled((os_log_t)qword_1008F76E0, OS_LOG_TYPE_DEFAULT))
    {
      std::stringbuf::str(&buf, (const std::stringbuf *)((char *)&v81 + 8));
      __int16 v74 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v78.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v78.__r_.__value_.__r.__words + 4) = (std::string::size_type)v74;
      _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEFAULT,  "statedump: %{public}s",  (uint8_t *)&v78,  0xCu);
    }
  }

  *(void **)((char *)__p
  *(void *)&v81 = v75;
  if (SHIBYTE(v86) < 0) {
    operator delete(v85[1]);
  }
  std::streambuf::~streambuf((char *)&v81 + 8);
  std::ios::~ios(&v88);
  if (v3) {
LABEL_164:
  }
    sub_1002CD254((unsigned int *)v3);
  if (v77) {
    operator delete(v77);
  }
  if (v31) {
    operator delete(v31);
  }
  if (v5) {
    operator delete(v5);
  }
}

  sub_100242FAC((uint64_t)v51);

  return v5;
}

  uint64_t v18 = sub_1005CE3A0((uint64_t)v7, v5);
  if (v18)
  {
    float v19 = sub_1002E6D7C();
    sub_10002418C(buf, (char *)[v6 UTF8String]);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void *, uint8_t *))(*(void *)v19 + 800LL))(v19, v18, buf);
    if (v20)
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
      {
        sub_1003CF00C((uint64_t)v18, buf);
        sub_10069AF80();
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
      {
        sub_1003CF00C((uint64_t)v18, buf);
        sub_10069AF3C();
      }

      uint64_t v8 = 1LL;
    }
  }

  sub_100242FAC((uint64_t)v34);

  return v8;
}

        uint32_t v17 = 1;
        if ((v11 & 0x80) == 0) {
          goto LABEL_28;
        }
LABEL_27:
        operator delete(__p[0]);
        goto LABEL_28;
      }

  return v8;
}

  if (v12 && __p) {
    operator delete[](__p);
  }
  if ((_DWORD)v21 && v22) {
    operator delete[](v22);
  }
  return sub_100242FAC((uint64_t)v24);
}

    int v2 = 0LL;
    return v2;
  }

  uint64_t v5 = sub_1001BCDB0(a2);
  int v27 = v5;
  __int16 v29 = BYTE6(v5);
  char v28 = WORD2(v5);
  uint64_t v6 = *(const unsigned __int8 **)(a1 + 440);
  if (v6 != (const unsigned __int8 *)(a1 + 448))
  {
    do
    {
      *(_OWORD *)buf = 0uLL;
      sub_10032BA60(*((void *)v6 + 7), 10, buf);
      if (sub_10056AAC8((uint64_t)buf)
        || (uint64_t v7 = (__int128 *)sub_10056AAF0((uint64_t)buf), !sub_1001C924C((uint64_t)&v27, v7)))
      {
        uint64_t v9 = 1;
      }

      else
      {
        uint64_t v8 = sub_100241F94(v6 + 32);
        int v2 = (void *)objc_claimAutoreleasedReturnValue(v8);
        uint64_t v9 = 0;
      }

      *(void *)buf = &off_10087FAA8;
      if (*(void *)&buf[8]) {
        sub_1002CD254(*(unsigned int **)&buf[8]);
      }
      if (!v9) {
        return v2;
      }
      uint64_t v10 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v10)
      {
        do
        {
          uint64_t v11 = (const unsigned __int8 **)v10;
          uint64_t v10 = *(unsigned __int8 **)v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          uint64_t v11 = (const unsigned __int8 **)*((void *)v6 + 2);
          BOOL v12 = *v11 == v6;
          uint64_t v6 = (const unsigned __int8 *)v11;
        }

        while (!v12);
      }

      uint64_t v6 = (const unsigned __int8 *)v11;
    }

    while (v11 != (const unsigned __int8 **)(a1 + 448));
  }

  uint64_t v13 = (os_log_s *)qword_1008F75A8;
  if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = sub_1005BFB9C(a2);
    uint64_t v15 = objc_claimAutoreleasedReturnValue(v14);
    BOOL v16 = [v15 UTF8String];
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "address %{public}s is not tracked by LeDeviceManager, trying other devices now.",  buf,  0xCu);
  }

  uint32_t v17 = 0LL;
  while (!*(_BYTE *)(a1 + v17 + 620) || !sub_1001C924C((uint64_t)&v27, (__int128 *)(a1 + v17 + 597)))
  {
    v17 += 24LL;
    if (v17 == 3120)
    {
      uint64_t v18 = (os_log_s *)qword_1008F75A8;
      if (os_log_type_enabled((os_log_t)qword_1008F75A8, OS_LOG_TYPE_DEFAULT))
      {
        float v19 = sub_1005BFB9C(a2);
        uint64_t v20 = objc_claimAutoreleasedReturnValue(v19);
        int v21 = [v20 UTF8String];
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "address %{public}s could not be resolved.",  buf,  0xCu);
      }

      goto LABEL_26;
    }
  }

  if (qword_1008D5F30 != -1) {
    dispatch_once(&qword_1008D5F30, &stru_1008A45D8);
  }
  sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 614) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 615) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 616) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 617) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 618) << 8) | *(unsigned __int8 *)(a1 + v17 + 619) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 613) << 48),  1u,  1u,  0LL,  0LL,  buf);
  char v26 = sub_100241F94(buf);
  return (id)objc_claimAutoreleasedReturnValue(v26);
}

void sub_10003AE18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10003AE54(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  int v76 = 20;
  int v77 = 40;
  int v75 = 15;
  uint64_t result = _os_feature_enabled_impl("AudioAccessoryFeatures", "AoSGaming");
  if ((_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 4))
    {
      BOOL v9 = 1;
      if (!a2) {
        return result;
      }
    }

    else
    {
      BOOL v9 = *(_BYTE *)(a1 + 5) != 0;
      if (!a2) {
        return result;
      }
    }

    if (v9)
    {
      if (qword_1008D60F0 != -1) {
        dispatch_once(&qword_1008D60F0, &stru_10087FF60);
      }
      uint64_t result = sub_100027194(*((void *)off_1008D60E8 + 28), a2);
      if ((_DWORD)result)
      {
        uint64_t v10 = sub_1002E6E00();
        uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
        if ((_DWORD)v11)
        {
          uint64_t v12 = sub_1002E6E00();
          sub_10002418C(buf, "UniAoS");
          sub_10002418C(__p, "ReTxThreshold");
          (*(void (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v12 + 88LL))(v12, buf, __p, &v77);
          if (v74 < 0) {
            operator delete(__p[0]);
          }
          if (SBYTE1(v84) < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v13 = sub_1002E6E00();
          sub_10002418C(buf, "UniAoS");
          sub_10002418C(__p, "NakThreshold");
          (*(void (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v13 + 88LL))(v13, buf, __p, &v76);
          if (v74 < 0) {
            operator delete(__p[0]);
          }
          if (SBYTE1(v84) < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v14 = sub_1002E6E00();
          sub_10002418C(buf, "UniAoS");
          sub_10002418C(__p, "IsmBandFactor");
          uint64_t v11 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v14 + 88LL))( v14,  buf,  __p,  &v75);
          if (v74 < 0) {
            operator delete(__p[0]);
          }
          if (SBYTE1(v84) < 0) {
            operator delete(*(void **)buf);
          }
          if (!v77) {
            int v77 = 40;
          }
          if (!v76) {
            int v76 = 20;
          }
          if (!v75) {
            int v75 = 15;
          }
        }

        if (*(_WORD *)(a4 + 16)) {
          unsigned int v15 = 100 * *(unsigned __int16 *)(a4 + 179) / *(unsigned __int16 *)(a4 + 16);
        }
        else {
          LOBYTE(v15) = 0;
        }
        uint64_t v16 = sub_100037B04(v11, a2);
        if (*(_DWORD *)(v16 + 24) == 1)
        {
          uint32_t v17 = (os_log_s *)qword_1008F7570;
          BOOL v18 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
          if (v18)
          {
            int v19 = v76;
            int v20 = v77;
            int v21 = *(_DWORD *)(sub_100037B04(v18, a2) + 28);
            *(_DWORD *)buf = 67110144;
            *(_DWORD *)&uint8_t buf[4] = a3;
            __int16 v79 = 1024;
            int v80 = v20;
            __int16 v81 = 1024;
            int v82 = v15;
            __int16 v83 = 1024;
            int v84 = v19;
            __int16 v85 = 1024;
            int v86 = v21;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "pre Low Latency Game, reTx:%u / %u, nak:%u / %u, score:%u",  buf,  0x20u);
          }

          if (v77 >= a3 && v76 >= v15)
          {
            uint64_t v30 = sub_100037B04(v18, a2);
            if (*(_DWORD *)(v30 + 28))
            {
              uint64_t v31 = sub_100037B04(v30, a2);
              --*(_DWORD *)(v31 + 28);
              int v32 = (os_log_s *)qword_1008F7570;
              uint64_t v30 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v30)
              {
                int v33 = *(_DWORD *)(sub_100037B04(v30, a2) + 28);
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v33;
                _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "pre Low Latency Game(out), decreased score %u",  buf,  8u);
              }
            }

            uint64_t v16 = sub_100037B04(v30, a2);
            if (!*(_DWORD *)(v16 + 28))
            {
              uint64_t v34 = (os_log_s *)qword_1008F7570;
              if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "pre Low Latency Game, LLM promote to AoS, request UBO",  buf,  2u);
              }

              if (qword_1008D60F0 != -1) {
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
              }
              uint64_t v35 = sub_1004A52FC((uint64_t)off_1008D60E8, 2u, a2);
              if (!(_DWORD)v35)
              {
                uint64_t v39 = qword_1008F7570;
                uint64_t v16 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
                if (!(_DWORD)v16) {
                  goto LABEL_58;
                }
                *(_WORD *)buf = 0;
                int v27 = "pre Low Latency Game, transition busy delay 1 second";
                char v28 = (os_log_s *)v39;
                uint32_t v29 = 2;
                goto LABEL_40;
              }

              uint64_t v36 = sub_100037B04(v35, a2);
              *(_DWORD *)(v36 + 36) = 20;
              *(_DWORD *)(sub_100037B04(v36, a2) + 2_Block_object_dispose(va, 8) = 0;
              if (*(_WORD *)(a4 + 16))
              {
                LOWORD(v37) = *(_WORD *)(a4 + 18);
                int v38 = (int)(float)((float)((float)v37 * 100.0) / (float)*(unsigned __int16 *)(a4 + 16));
              }

              else
              {
                int v38 = 0;
              }

              int v40 = *(char *)(a4 + 6);
              if (qword_1008D60F0 != -1)
              {
                int v72 = *(char *)(a4 + 6);
                dispatch_once(&qword_1008D60F0, &stru_10087FF60);
                int v40 = v72;
              }

              sub_1004B22E4((uint64_t)off_1008D60E8, a2, v38, v40, 0);
            }
          }

          else
          {
            uint64_t v22 = sub_100037B04(v18, a2);
            unsigned int v23 = *(_DWORD *)(v22 + 28);
            uint64_t v16 = sub_100037B04(v22, a2);
            if (v23 < *(_DWORD *)(v16 + 36))
            {
              uint64_t v24 = sub_100037B04(v16, a2);
              ++*(_DWORD *)(v24 + 28);
              uint64_t v25 = qword_1008F7570;
              uint64_t v16 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v16)
              {
                int v26 = *(_DWORD *)(sub_100037B04(v16, a2) + 28);
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v26;
                int v27 = "pre Low Latency Game, increased score %u";
                char v28 = (os_log_s *)v25;
                uint32_t v29 = 8;
LABEL_40:
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
              }
            }
          }
        }

LABEL_58:
        uint64_t v41 = sub_100037B04(v16, a2);
        uint64_t v41 = sub_100037B04(v41, a2);
        __int16 v42 = (os_log_s *)qword_1008F7570;
        BOOL v43 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
        if (v43)
        {
          uint64_t v44 = sub_100037B04(v43, a2);
          int v45 = *(_DWORD *)(v44 + 24);
          int v46 = v76;
          int v47 = v77;
          int v48 = *(_DWORD *)(sub_100037B04(v44, a2) + 28);
          *(_DWORD *)buf = 67110400;
          *(_DWORD *)&uint8_t buf[4] = v45;
          __int16 v79 = 1024;
          int v80 = a3;
          __int16 v81 = 1024;
          int v82 = v47;
          __int16 v83 = 1024;
          int v84 = v15;
          __int16 v85 = 1024;
          int v86 = v46;
          __int16 v87 = 1024;
          int v88 = v48;
          _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "In Low Latency Game, State:%u, reTx:%u / %u, nak:%u / %u, score:%u",  buf,  0x26u);
        }

        if (qword_1008D60F0 != -1) {
          dispatch_once(&qword_1008D60F0, &stru_10087FF60);
        }
        sub_1004B2104((uint64_t)off_1008D60E8, a2, a3, *(_BYTE *)(a4 + 6));
        uint64_t v50 = sub_100037B04(v49, a2);
        if (*(unsigned __int8 *)(v50 + 32) < 4u)
        {
          if (v77 >= a3 && v76 >= v15)
          {
            uint64_t v52 = sub_100037B04(v50, a2);
            if (*(_DWORD *)(v52 + 28) >= 0xAu)
            {
              int v69 = (os_log_s *)qword_1008F7570;
              BOOL v70 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
              if (v70)
              {
                int v71 = *(_DWORD *)(sub_100037B04(v70, a2) + 28);
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v71;
                _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "In Low Latency Game, decreased score %u",  buf,  8u);
              }

              uint64_t v52 = sub_100037B04(v70, a2);
              *(_DWORD *)(v52 + 28) -= 10;
            }

          uint64_t v8 = @"### No device ID";
          goto LABEL_53;
        }
      }

      else if (!strcasecmp(v6, "mp-error"))
      {
        uint64_t v16 = (void *)CUXPCCreateCFObjectFromXPCObject(v4);
        if (v16)
        {
          uint64_t v24 = CFStringGetTypeID();
          uint64_t v25 = CFDictionaryGetTypedValue(v16, @"deviceID", v24, 0LL);
          int v19 = (void *)objc_claimAutoreleasedReturnValue(v25);
          if (v19)
          {
            int v26 = -[CBStackControllerBTStack _btDeviceWithID:error:](self, "_btDeviceWithID:error:", v19, 0LL);
            if (v26)
            {
              int v27 = CFDictionaryGetInt64Ranged(v16, @"status", 0LL, 255LL, 0LL);
              if ((v27 - 8) < 0xFFFFFFF9)
              {
                uint64_t v8 = @"### Invalid status";
                goto LABEL_53;
              }

              if (qword_1008D60C0 != -1)
              {
                uint64_t v35 = v27;
                dispatch_once(&qword_1008D60C0, &stru_1008811E8);
                int v27 = v35;
              }

              sub_1003F0B7C((uint64_t)off_1008D60B8, (uint64_t)v26, v27);
              goto LABEL_52;
            }

            goto LABEL_59;
          }

          goto LABEL_58;
        }
      }

      else
      {
        if (strcasecmp(v6, "mp-keys-reset"))
        {
          if (stricmp_prefix(v6, "writeStackshot"))
          {
            uint64_t v7 = NSPrintF_safe("### Unsupported command: '%s'\n", v6);
            uint64_t v8 = (__CFString *)objc_claimAutoreleasedReturnValue(v7);
LABEL_42:

            return v8;
          }

          uint64_t v34 = sub_1002E6E00();
          sub_10002418C(v42, "btutil manual stackshot");
          sub_1004FC14C(v34, (uint64_t *)v42, 3172327085LL);
          if (v43 < 0) {
            operator delete(v42[0]);
          }
LABEL_41:
          uint64_t v8 = &stru_1008A57D8;
          goto LABEL_42;
        }

        uint64_t v16 = (void *)CUXPCCreateCFObjectFromXPCObject(v4);
        if (v16)
        {
          uint64_t v30 = CFStringGetTypeID();
          uint64_t v31 = CFDictionaryGetTypedValue(v16, @"deviceID", v30, 0LL);
          int v19 = (void *)objc_claimAutoreleasedReturnValue(v31);
          if (v19)
          {
            int v32 = -[CBStackControllerBTStack _btDeviceWithID:error:](self, "_btDeviceWithID:error:", v19, 0LL);
            if (v32)
            {
              if (qword_1008D60C0 != -1) {
                dispatch_once(&qword_1008D60C0, &stru_1008811E8);
              }
              int v33 = sub_1003EE4A0((uint64_t)off_1008D60B8, (uint64_t)v32);
              if (!v33)
              {
                uint64_t v8 = @"### Magic Paired Device not found";
                goto LABEL_53;
              }

              if (qword_1008D60C0 != -1) {
                dispatch_once(&qword_1008D60C0, &stru_1008811E8);
              }
              sub_1003EFF78((uint64_t)off_1008D60B8, (uint64_t)v33);
              goto LABEL_52;
            }

            goto LABEL_59;
          }

          goto LABEL_58;
        }
      }

      uint64_t v8 = @"### Convert params failed";
      goto LABEL_54;
    }

    uint64_t v36 = _os_log_pack_size(12LL);
    unsigned int v37 = (char *)v42 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v38 = __error();
    uint64_t v39 = _os_log_pack_fill(v37, v36, *v38, &_mh_execute_header, "Diag crash: '%s'", (const char *)v42[0]);
    *(_DWORD *)uint64_t v39 = 136315138;
    *(void *)(v39 + 4) = v6;
    int v40 = os_log_create("com.apple.bluetooth", "CBCrash");
    if (v40) {
      uint64_t v41 = v40;
    }
    else {
      uint64_t v41 = (os_log_t)&_os_log_default;
    }
    qword_1008D9DB8 = os_log_pack_send_and_compose(v37, v41, 16LL, 0LL, 0LL);
    uint64_t result = (id)abort_with_payload(18LL, 2LL, v37, v36, qword_1008D9DB8, 0LL);
  }

  __break(1u);
  return result;
}

          v97 = (void *)a7[8];
          if (v97)
          {
            sub_1000B1838(v97);
            a7[8] = 0LL;
          }

          if (v14)
          {
            a7[2] = 0LL;
            v14(v68, a7[3]);
          }

          return;
        }

        *(_BYTE *)(v13 + 96) = 13;
        int v77 = sub_1001A32B0(v13, (uint64_t)sub_1001C2F34, 0, (uint64_t)a7);
        if (!(_DWORD)v77) {
          return;
        }
        uint64_t v68 = v77;
        sub_1001EE134((uint64_t)"Failed to execute write request %!", v78, v79, v80, v81, v82, v83, v84, v68);
        __int16 v85 = (os_log_s *)sub_100086554(0x45u);
        if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
          goto LABEL_58;
        }
      }

      sub_100657858();
      goto LABEL_58;
    }
  }

  *(_BYTE *)(v13 + 96) = 4;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Data doesn't match.", v40, v41, v42, v43, v44, v45, v46, v98);
    int v47 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  int v48 = sub_1001A32B0(*a7, (uint64_t)sub_1001C2F34, 0, (uint64_t)a7);
  if (!(_DWORD)v48)
  {
    if (v14)
    {
      a7[2] = 0LL;
      int v33 = a7[3];
      uint64_t v34 = 0LL;
      goto LABEL_17;
    }

    goto LABEL_18;
  }

  uint64_t v49 = v48;
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Failed to execute write request %!", v50, v51, v52, v53, v54, v55, v56, v49);
    uint64_t v57 = (os_log_s *)sub_100086554(0x45u);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

      memmove((void *)(v18 + v9), v19, v37);
      *((_WORD *)a1 + 6) += *((_WORD *)a2 + 1);
      return 1LL;
    default:
      char v28 = (os_log_s *)qword_1008F75D8;
      if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR))
      {
        v64[0] = 67109376;
        v64[1] = v10;
        int v65 = 1024;
        uint32_t v66 = v9;
        _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "Serialization: invalid SDP element type of 0x%x, bytestream pos %d",  (uint8_t *)v64,  0xEu);
        char v28 = (os_log_s *)qword_1008F75D8;
      }

      uint64_t result = os_log_type_enabled(v28, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
      sub_100664898(v28, v29, v30, v31, v32, v33, v34, v35);
      return 0LL;
  }

      *(void *)buf = &v46;
      int v38 = (uint64_t **)(sub_1002554E8( (uint64_t **)a3,  (unint64_t *)&v46,  (uint64_t)&unk_1006C2518,  (uint64_t **)buf)
                       + 5);
      sub_10023BF24((uint64_t)&v52, *((void **)&v52 + 1));
      ++v29;
      uint64_t v6 = v33;
      a1 = v32;
      a2 = v42;
    }

    while (v29 != v43);
    if (!v30)
    {
LABEL_74:
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR)) {
        sub_100669C98();
      }
      int v21 = objc_autoreleasePoolPush();
      sub_1002D80EC((uint64_t)v21, a2, (uint64_t)"SdpCacheSize");
      objc_autoreleasePoolPop(v21);
      uint64_t v22 = objc_autoreleasePoolPush();
      sub_1002D80EC((uint64_t)v22, a2, (uint64_t)"SdpCache");
      objc_autoreleasePoolPop(v22);
      unsigned int v23 = objc_autoreleasePoolPush();
      sub_1002D80EC((uint64_t)v23, a2, (uint64_t)"SdpCacheVersion");
      objc_autoreleasePoolPop(v23);
    }

    else
    {
LABEL_62:
      sub_1002D6A1C(a1, a2, "SdpCacheVersion", 1LL);
      uint64_t v39 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v52) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "SDP cache read complete, writing version",  (uint8_t *)&v52,  2u);
      }
    }

    BOOL v18 = 0LL;
    uint32_t v17 = 1;
  }

  *(_DWORD *)(a2 + 60_Block_object_dispose(va, 8) = v17;
  free(v44);
  return v18;
}

  int v40 = *a4;
  uint64_t v41 = a4[1];
  if (*a4 != v41)
  {
    __int16 v42 = 0;
    while (1)
    {
      BOOL v43 = *(_OWORD *)v40;
      __int16 v83 = *((_DWORD *)v40 + 4);
      int v82 = v43;
      uint64_t v44 = (os_log_s *)qword_1008F7628;
      if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
      {
        sub_1006344B4((uint64_t)&v82, buf);
        int v45 = buf;
        if (v87 < 0) {
          int v45 = *(_BYTE **)buf;
        }
        *(_DWORD *)int v80 = 136446210;
        __int16 v81 = v45;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Parsing %{public}s", v80, 0xCu);
        if (v87 < 0) {
          operator delete(*(void **)buf);
        }
      }

      if (v42 > 3) {
        break;
      }
      int v46 = objc_claimAutoreleasedReturnValue( +[ConnectOptions alertOptionsWithConnectionAlerts:disconnectionAlerts:notificationAlerts:delay:bridgeTransport:]( &OBJC_CLASS___ConnectOptions,  "alertOptionsWithConnectionAlerts:disconnectionAlerts:notificationAlerts:delay:bridgeTransport:",  1LL,  0LL,  0LL,  0LL,  0LL));
      *(void *)buf = &v82;
      int v47 = sub_1003A1360((uint64_t **)(a1 + 240), (unsigned __int8 *)&v82, (uint64_t)&unk_1006C2518, (_OWORD **)buf);
      int v48 = (void *)*((void *)v47 + 7);
      *((void *)v47 + 7) = v46;

      ++v42;
      v40 += 20;
      if (v40 == v41) {
        goto LABEL_70;
      }
    }

    uint64_t v49 = (os_log_s *)qword_1008F7628;
    if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = 4;
      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Exceeded the number of allowed services (%d)",  buf,  8u);
    }
  }

    uint64_t v30 = HIWORD(v43);
LABEL_66:
    HIWORD(v43) = v30;
    goto LABEL_67;
  }

  if (sub_10020755C(a2 + 400) == 128)
  {
    char v28 = HIWORD(v43);
    else {
      uint32_t v29 = 240;
    }
    if (v29 <= v28)
    {
      if (!sub_1002075D4(a2 + 400))
      {
        uint64_t v30 = 240;
        goto LABEL_66;
      }

        int v33 = *(void *)(a1 + 112);
        uint64_t v34 = sub_1005346A4((uint64_t)a2);
        uint64_t v35 = sub_10053469C((uint64_t)a2);
        if (sub_100526498(v33, v34, v35))
        {
          (*(void (**)(__n128 *))(a2->n128_u64[0] + 32))(a2);
          sub_10052A368(a1, v4, 0xA5u);
        }

        goto LABEL_72;
      }

      uint64_t v39 = (os_log_s *)qword_1008F75E0;
      if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Auto accepting outgoing SSP request.",  (uint8_t *)__p,  2u);
      }

      uint64_t v36 = 5LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR)) {
        sub_10068F728();
      }
      sub_10052A368(a1, v4, 0xA2u);
      uint64_t v36 = 4LL;
    }

    (*(void (**)(__n128 *))(a2->n128_u64[0] + 8 * v36))(a2);
LABEL_72:
    sub_100242FAC((uint64_t)buf);
    sub_100242CD8(&v41);
    goto LABEL_73;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
  {
    sub_1003CF00C(a2->n128_i64[1], __p);
    sub_10068F79C();
  }

      if (*(_BYTE *)(a1 + 1504))
      {
        for (uint64_t i = 16LL; i != 336; i += 20LL)
        {
          if (*(_DWORD *)(a3 + i)) {
            *(_DWORD *)(a3 + i) = *(_DWORD *)(a1 + 1508);
          }
        }
      }

      uint64_t v44 = *(_BYTE *)(a3 + 2) || *(_BYTE *)(a3 + 1) || *(_BYTE *)(a3 + 3) != 0;
      *(_BYTE *)a3 = v44;
      uint64_t result = 1LL;
      break;
    default:
      return result;
  }

  return result;
}

LABEL_86:
            uint64_t v68 = sub_100037B04(v41, a2);
            *(_BYTE *)(v68 + 32) = 0;
            uint64_t result = sub_100037B04(v68, a2);
            *(_DWORD *)(result + 40) = 0;
            return result;
          }

          uint64_t v56 = sub_100037B04(v50, a2);
          *(_DWORD *)(v56 + 28) += 10;
          uint64_t v57 = qword_1008F7570;
          uint64_t v52 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
          if (!(_DWORD)v52) {
            goto LABEL_72;
          }
          int v58 = *(_DWORD *)(sub_100037B04(v52, a2) + 28);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v58;
          __int16 v53 = "In Low Latency Game, increased score %u";
          int v54 = (os_log_s *)v57;
          uint32_t v55 = 8;
        }

        else
        {
          *(_DWORD *)(sub_100037B04(v50, a2) + 2_Block_object_dispose(va, 8) = 20;
          uint64_t v51 = qword_1008F7570;
          uint64_t v52 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
          if (!(_DWORD)v52) {
            goto LABEL_72;
          }
          *(_WORD *)buf = 0;
          __int16 v53 = "In Low Latency Game, per second flush count exceed";
          int v54 = (os_log_s *)v51;
          uint32_t v55 = 2;
        }

        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v53, buf, v55);
        goto LABEL_72;
      }
    }
  }

  return result;
}

            int v76 = 0;
            ++v72;
            v75 -= 6LL;
            if (v70 == v72)
            {
              sub_1001EE134( (uint64_t)"AACP_MSG_DEV_LIST error initializing device list",  v242,  v243,  v244,  v245,  v246,  v247,  v248,  v401);
              v249 = (os_log_s *)sub_100086554(0x53u);
              if (!os_log_type_enabled(v249, OS_LOG_TYPE_ERROR)) {
                goto LABEL_503;
              }
              goto LABEL_564;
            }
          }

          sub_1001F0050((uint64_t)v71 - v75, (uint64_t)v405 + v74, 6uLL);
          int v73 = v74 + 6;
          if (v70 - 1 == v72++)
          {
            int v69 = v408;
            goto LABEL_468;
          }
        }
      }

      int v71 = 0LL;
LABEL_468:
      v315 = *(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)(v4 + v7 + 32) + 64LL);
      if (v315) {
        v315(v4 + v7 + 9, v69, v70, v71);
      }
      if (!v71) {
        return;
      }
      goto LABEL_471;
    case 0xCu:
      LOWORD(buf[1]) = 0;
      buf[0] = 0;
      if (a3 <= 7) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  652,  "ByteStream_NumReadBytesAvail(bs) >= OI_BD_ADDR_BYTE_SIZE");
      }
      sub_1001F0050((uint64_t)buf, (uint64_t)(a2 + 1), 6uLL);
      if ((_DWORD)a3 == 8)
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c");
        int v78 = 0LL;
      }

      else
      {
        int v78 = *((unsigned __int8 *)a2 + 8);
        if (a3 >= 0xA)
        {
          v284 = *((unsigned __int8 *)a2 + 9);
          goto LABEL_427;
        }
      }

      v284 = 0LL;
LABEL_427:
      v285 = *(void (**)(uint64_t, _DWORD *, uint64_t, uint64_t))(*(void *)(v4 + v7 + 32) + 72LL);
      if (v285) {
        v285(v4 + v7 + 9, buf, v78, v284);
      }
      return;
    case 0xEu:
      LOWORD(buf[1]) = 0;
      buf[0] = 0;
      if (a3 <= 7) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  664,  "ByteStream_NumReadBytesAvail(bs) >= OI_BD_ADDR_BYTE_SIZE");
      }
      sub_1001F0050((uint64_t)buf, (uint64_t)(a2 + 1), 6uLL);
      if ((_DWORD)a3 == 8) {
        __int16 v79 = 0LL;
      }
      else {
        __int16 v79 = *((unsigned __int8 *)a2 + 8);
      }
      v91 = v4 + v7;
      v92 = *(void (**)(uint64_t, _DWORD *, uint64_t))(*(void *)(v4 + v7 + 32) + 80LL);
      if (v92) {
        goto LABEL_431;
      }
      return;
    case 0x11u:
      LOWORD(buf[1]) = 0;
      buf[0] = 0;
      if (a3 <= 7) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  687,  "ByteStream_NumReadBytesAvail(bs) >= OI_BD_ADDR_BYTE_SIZE");
      }
      sub_1001F0050((uint64_t)buf, (uint64_t)(a2 + 1), 6uLL);
      if (a3 <= 9) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  688,  "ByteStream_NumReadBytesAvail(bs) >= 2");
      }
      int v80 = a2;
      __int16 v81 = a2[4];
      int v82 = (void **)sub_1000B1814(v81);
      int v71 = v82;
      if (!v82 || !(_DWORD)v81) {
        goto LABEL_500;
      }
      if ((int)a3 - 10 < (int)v81)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"AACP_MSG_RELAY_MSG_INDICATION, error initializing relayData",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  v401);
          v90 = (os_log_s *)sub_100086554(0x53u);
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        goto LABEL_503;
      }

      v335 = (char *)(v80 + 5);
      v336 = (char *)v82;
      do
      {
        v337 = *v335++;
        *v336++ = v337;
      }

      while (v336 < (char *)v82 + v81);
LABEL_500:
      v338 = *(void (**)(uint64_t, _DWORD *, size_t, void **))(*(void *)(v4 + v7 + 32) + 88LL);
      if (v338) {
        v338(v4 + v7 + 9, buf, v81, v82);
      }
      goto LABEL_502;
    case 0x13u:
      LOWORD(buf[1]) = 0;
      buf[0] = 0;
      if (a3 <= 7) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  675,  "ByteStream_NumReadBytesAvail(bs) >= OI_BD_ADDR_BYTE_SIZE");
      }
      sub_1001F0050((uint64_t)buf, (uint64_t)(a2 + 1), 6uLL);
      if ((_DWORD)a3 == 8) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  676,  "ByteStream_NumReadBytesAvail(bs) >= 1");
      }
      v91 = v4 + v7;
      v92 = *(void (**)(uint64_t, _DWORD *, uint64_t))(*(void *)(v4 + v7 + 32) + 96LL);
      if (!v92) {
        return;
      }
      goto LABEL_115;
    case 0x15u:
      LOWORD(buf[1]) = 0;
      buf[0] = 0;
      if (a3 <= 7) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  710,  "ByteStream_NumReadBytesAvail(bs) >= OI_BD_ADDR_BYTE_SIZE");
      }
      sub_1001F0050((uint64_t)buf, (uint64_t)(a2 + 1), 6uLL);
      uint32_t v66 = v4 + v7;
      uint64_t v67 = *(void (**)(uint64_t, _DWORD *))(*(void *)(v4 + v7 + 32) + 104LL);
      if (!v67) {
        return;
      }
      goto LABEL_373;
    case 0x16u:
      LOWORD(buf[1]) = 0;
      buf[0] = 0;
      if (a3 <= 7) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  721,  "ByteStream_NumReadBytesAvail(bs) >= OI_BD_ADDR_BYTE_SIZE");
      }
      sub_1001F0050((uint64_t)buf, (uint64_t)(a2 + 1), 6uLL);
      if ((_DWORD)a3 == 8) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/aacp/aacp_client.c",  722,  "ByteStream_NumReadBytesAvail(bs) >= 1");
      }
      v91 = v4 + v7;
      v92 = *(void (**)(uint64_t, _DWORD *, uint64_t))(*(void *)(v4 + v7 + 32) + 112LL);
      if (v92)
      {
LABEL_115:
        __int16 v79 = *((unsigned __int8 *)a2 + 8);
LABEL_431:
        v92(v91 + 9, buf, v79);
      }

      return;
    case 0x17u:
      if (*(_DWORD *)(qword_1008DAFA0 + v7 + 24) > 0x10001u)
      {
        if (a3 >= 6)
        {
          v93 = *(unsigned int *)(a2 + 1);
          v94 = 3;
LABEL_376:
          if ((int)(a3 - v94 * 2) > 1)
          {
            v256 = a3;
            v97 = a2[v94];
            v258 = v94 * 2 + 2LL;
            v259 = (char *)sub_1000B1814(v97);
            v99 = v259;
            if (v256 - (int)v258 >= (int)v97 && (_DWORD)v97)
            {
              v260 = 0LL;
              do
              {
                v259[v260] = *((_BYTE *)a2 + v258 + v260);
                ++v260;
              }

              while (&v259[v260] < &v259[v97]);
            }

        uint64_t v36 = 0;
        int v20 = 608LL;
LABEL_87:
        if (!v36)
        {
LABEL_88:
          if (*(unsigned __int16 *)(a2 + 2) != a4)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"missing parameters, expected %d, got %d",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  *(unsigned __int16 *)(a2 + 2));
              uint64_t v44 = (os_log_s *)sub_100086554(0x2Eu);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
                sub_100657858();
              }
            }
          }
        }

        return v20;
      case 't':
        if (!v14)
        {
LABEL_64:
          if ((v12 & 1) != 0) {
            int v20 = 0LL;
          }
          else {
            int v20 = 608LL;
          }
          goto LABEL_80;
        }

        if (*((_BYTE *)a3 + 15))
        {
          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcievents.c");
LABEL_99:
          int v47 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_101:
          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcievents.c",  523,  v47);
        }

        int v21 = *((unsigned __int16 *)a3 + 6);
        if (*((_BYTE *)a3 + 14) != 1)
        {
          int v47 = "(*pBs).__RWFlag == BYTESTREAM_READ";
          goto LABEL_101;
        }

        goto LABEL_48;
      default:
        switch(*(_BYTE *)(*(void *)(a2 + 8) + v11))
        {
          case '1':
            if (!v14) {
              goto LABEL_64;
            }
            if (*((_BYTE *)a3 + 15))
            {
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcievents.c");
LABEL_103:
              int v48 = "ByteStream_NumReadBytesAvail(*pBs) >= 1";
LABEL_104:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/hci/hcievents.c",  364,  v48);
            }

            int v21 = *((unsigned __int16 *)a3 + 6);
            if (*((_BYTE *)a3 + 14) != 1)
            {
              int v48 = "(*pBs).__RWFlag == BYTESTREAM_READ";
              goto LABEL_104;
            }

    sub_100518158(v43, v5);
    return sub_100242CD8(&v48);
  }

  uint64_t v44 = (os_log_s *)qword_1008F75D0;
  if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_INFO,  "Message too big, sent only the first chunk of data. Wait for next request from CT",  buf,  2u);
  }

  *(void *)buf = a1 + 56;
  int v45 = sub_1002554E8((uint64_t **)(v47 + 480), (unint64_t *)(a1 + 56), (uint64_t)&unk_1006C2518, (uint64_t **)buf);
  v51[0] = *(_BYTE *)(a1 + 65);
  v51[1] = 32;
  *(void *)buf = v51;
  *((void *)sub_100522E10((uint64_t **)v45 + 5, v51, (uint64_t)&unk_1006C2518, (_WORD **)buf) + 5) = v5;
  return sub_100242CD8(&v48);
}

        if ((v67 & 1) == 0)
        {
          if ((_DWORD)v32 == 4500) {
            goto LABEL_88;
          }
LABEL_94:
          byte_1008F7822 = 7;
          byte_1008F7823 = v66;
          word_1008F7824 = *(_WORD *)(a1 + 680);
          byte_1008F7826 = v32;
          byte_1008F7827 = 17;
          goto LABEL_95;
        }

    uuid_clear(uu);
    goto LABEL_15;
  }

  if (v45)
  {
    int v46 = sub_1005BFB9C(v73);
    int v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
    LODWORD(__p.__r_.__value_.__l.__data_) = 138543362;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
    _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "Warning: Diagnostics mode detected, ignoring non-paired device cached, creating a new identifier for device addres s %{public}@ as the protected cache has not been loaded",  (uint8_t *)&__p,  0xCu);
  }

void sub_10003B7F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10003B840(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = sub_100037B04(a1, a2);
  *(_BYTE *)(v3 + 32) = 0;
  uint64_t v4 = sub_100037B04(v3, a2);
  *(_DWORD *)(v4 + 40) = 0;
  uint64_t v5 = sub_100037B04(v4, a2);
  *(_DWORD *)(v5 + 2_Block_object_dispose(va, 8) = 2;
  uint64_t result = sub_100037B04(v5, a2);
  *(_DWORD *)(result + 36) = 2;
  return result;
}

_BYTE *sub_10003B88C(uint64_t a1, uint64_t a2)
{
  uint64_t result = (_BYTE *)sub_1003D2B2C(a2, 13);
  if ((_DWORD)result)
  {
    uint64_t v4 = sub_1002E6BF0();
    uint64_t result = (_BYTE *)(*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 792LL))(v4, 0LL);
    if ((_DWORD)result)
    {
      char v7 = 0;
      sub_100242CA4(&v7);
      int v5 = sub_10010F334(a2 + 128);
      sub_100242CD0(&v7);
      if (v5)
      {
        uint64_t v6 = (os_log_s *)qword_1008F7570;
        if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
          sub_1006575CC(v5, v6);
        }
      }

      return sub_100242CD8(&v7);
    }
  }

  return result;
}

void sub_10003B934( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

uint64_t sub_10003B948(uint64_t a1)
{
  if (qword_1008D6458 != -1) {
    dispatch_once(&qword_1008D6458, &stru_10087FF40);
  }
  return sub_10037B7AC(qword_1008D6450, *(unsigned __int16 *)(a1 + 36), *(_DWORD *)(a1 + 32));
}

void sub_10003B99C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = sub_100036124(a1, *(unsigned __int16 *)(a1 + 40));
  unint64_t v10 = v3;
  if (v3)
  {
    unint64_t v4 = v3;
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    int v5 = (void *)*((void *)off_1008D60E8 + 25);
    if (!v5) {
      goto LABEL_15;
    }
    uint64_t v6 = (char *)off_1008D60E8 + 200;
    do
    {
      unint64_t v7 = v5[4];
      BOOL v8 = v7 >= v4;
      if (v7 >= v4) {
        BOOL v9 = v5;
      }
      else {
        BOOL v9 = v5 + 1;
      }
      if (v8) {
        uint64_t v6 = (char *)v5;
      }
      int v5 = (void *)*v9;
    }

    while (*v9);
    if (v6 == (char *)off_1008D60E8 + 200 || v4 < *((void *)v6 + 4)) {
LABEL_15:
    }
      uint64_t v6 = (char *)off_1008D60E8 + 200;
    if (v6 != (char *)off_1008D60E8 + 200)
    {
      uint64_t v11 = &v10;
      if (*(_DWORD *)(sub_100029574((uint64_t **)off_1008D60E8 + 24, &v10, (uint64_t)&unk_1006BADB0, (uint64_t **)&v11)[5]
                     + 76) == 2)
        sub_1000352CC(v2, 0LL, *(unsigned __int16 *)(a1 + 42));
    }
  }

uint64_t sub_10003BAA8(uint64_t a1)
{
  if (qword_1008D6458 != -1) {
    dispatch_once(&qword_1008D6458, &stru_10087FF40);
  }
  return sub_10037B7AC(qword_1008D6450, *(unsigned __int16 *)(a1 + 36), *(_DWORD *)(a1 + 32));
}

void sub_10003BAFC(uint64_t a1)
{
  uint64_t v1 = (unint64_t *)(a1 + 40);
  if (!*(void *)(a1 + 40)) {
    goto LABEL_24;
  }
  if (qword_1008D60F0 != -1) {
    dispatch_once(&qword_1008D60F0, &stru_10087FF60);
  }
  uint64_t v3 = (void *)*((void *)off_1008D60E8 + 25);
  if (!v3) {
    goto LABEL_15;
  }
  unint64_t v4 = *v1;
  int v5 = (char *)off_1008D60E8 + 200;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= v4;
    if (v6 >= v4) {
      BOOL v8 = v3;
    }
    else {
      BOOL v8 = v3 + 1;
    }
    if (v7) {
      int v5 = (char *)v3;
    }
    uint64_t v3 = (void *)*v8;
  }

  while (*v8);
  if (v5 == (char *)off_1008D60E8 + 200 || v4 < *((void *)v5 + 4)) {
LABEL_15:
  }
    int v5 = (char *)off_1008D60E8 + 200;
  if (v5 == (char *)off_1008D60E8 + 200)
  {
LABEL_24:
    uint64_t v14 = (os_log_s *)qword_1008F7570;
    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
      sub_10065764C((uint64_t)v1, v14, v15, v16, v17, v18, v19, v20);
    }
  }

  else if (*(unsigned __int16 *)(sub_100037B04(a1, *(void *)(a1 + 40)) + 48) != *(unsigned __int16 *)(a1 + 48))
  {
    if (qword_1008D60F0 != -1) {
      dispatch_once(&qword_1008D60F0, &stru_10087FF60);
    }
    if (sub_1004B3B20((uint64_t)off_1008D60E8, *v1))
    {
      BOOL v9 = (os_log_s *)qword_1008F7570;
      BOOL v10 = os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        int v11 = *(unsigned __int16 *)(sub_100037B04(v10, *(void *)(a1 + 40)) + 48);
        int v12 = *(unsigned __int16 *)(a1 + 48);
        v21[0] = 67109376;
        v21[1] = v11;
        __int16 v22 = 1024;
        int v23 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Updated targetJitterBuffer from %u to %u",  (uint8_t *)v21,  0xEu);
      }

      __int16 v13 = *(_WORD *)(a1 + 48);
      *(_WORD *)(sub_100037B04(v10, *(void *)(a1 + 40)) + 4_Block_object_dispose(va, 8) = v13;
      notify_post("com.apple.bluetooth.AdaptiveJitterBufferChanged");
    }
  }

uint64_t sub_10003BCE8(uint64_t a1, char a2, __int16 a3, int a4)
{
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 5_Block_object_dispose(va, 8) = a3;
  *(_WORD *)(a1 + 60) = a3;
  *(_WORD *)(a1 + 62) = -1;
  *(void *)(a1 + 64) = 0xFFFF00000000LL;
  *(_BYTE *)(a1 + 72) = a2;
  *(_DWORD *)(a1 + 76) = a4;
  *(_WORD *)(a1 + 86) = 0;
  *(_BYTE *)(a1 + 8_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 100) = 0LL;
  *(void *)(a1 + 92) = 0LL;
  int v5 = operator new(0x38uLL);
  *(_WORD *)int v5 = 1;
  v5[1] = 0LL;
  *((_WORD *)v5 + _Block_object_dispose(va, 8) = 150;
  *(void *)((char *)v5 + 20) = 6LL;
  *((_DWORD *)v5 + 7) = 2;
  *((_BYTE *)v5 + 32) = 0;
  *(void *)((char *)v5 + 36) = 2LL;
  *((_DWORD *)v5 + 12) = 150;
  *(void *)(a1 + 40) = v5;
  unint64_t v6 = operator new(8uLL);
  *unint64_t v6 = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v6;
  return a1;
}

void sub_10003BD98(id a1)
{
  uint64_t v1 = operator new(0x310uLL);
  sub_10036BB90();
  qword_1008D6450 = (uint64_t)v1;
}

void sub_10003BDC8(_Unwind_Exception *a1)
{
}

void sub_10003BDDC(id a1)
{
  uint64_t v1 = operator new(0x4A8uLL);
  sub_100499870();
  off_1008D60E8 = v1;
}

void sub_10003BE0C(_Unwind_Exception *a1)
{
}

  ;
}

LABEL_47:
  spatialInteractionFlags = self->_spatialInteractionFlags;
  if (self->_spatialInteractionFlags)
  {
    __int16 v53 = location;
    int v27 = CUPrintFlags32(spatialInteractionFlags, &unk_1006BADDC);
    char v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    NSAppendPrintF_safe(&v53, ", siFl %@", v28);
    objc_storeStrong(&location, v53);
  }

  spatialInteractionIdentifiers = self->_spatialInteractionIdentifiers;
  if (spatialInteractionIdentifiers)
  {
    uint64_t v52 = location;
    uint64_t v30 = spatialInteractionIdentifiers;
    uint64_t v31 = CUPrintNSObjectOneLine(v30);
    int v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
    NSAppendPrintF_safe(&v52, ", siID %@", v32);
    objc_storeStrong(&location, v52);
  }

  spatialInteractionPayloadData = self->_spatialInteractionPayloadData;
  if (spatialInteractionPayloadData)
  {
    uint64_t v51 = location;
    uint64_t v34 = spatialInteractionPayloadData;
    NSAppendPrintF_safe(&v51, ", siPD <%@>", v34);
    objc_storeStrong(&location, v51);
  }

  spatialInteractionUWBConfigData = self->_spatialInteractionUWBConfigData;
  if (spatialInteractionUWBConfigData)
  {
    uint64_t v50 = location;
    uint64_t v36 = spatialInteractionUWBConfigData;
    NSAppendPrintF_safe(&v50, ", siUC <%@>", v36);
    objc_storeStrong(&location, v50);
  }

  if (v4 <= 0x1E)
  {
    spatialInteractionWiProxUUID = self->_spatialInteractionWiProxUUID;
    if (spatialInteractionWiProxUUID)
    {
      uint64_t v49 = location;
      int v38 = spatialInteractionWiProxUUID;
      NSAppendPrintF_safe(&v49, ", siWU <%@>", v38);
      objc_storeStrong(&location, v49);
    }
  }

  watchSetupPayloadData = self->_watchSetupPayloadData;
  if (watchSetupPayloadData)
  {
    int v48 = location;
    int v40 = watchSetupPayloadData;
    uint64_t v41 = CUPrintNSDataHex(v40, 100LL, 1LL);
    __int16 v42 = objc_claimAutoreleasedReturnValue(v41);
    BOOL v43 = (void *)v42;
    watchSetupAdvertiseRate = self->_watchSetupAdvertiseRate;
    if (watchSetupAdvertiseRate <= 39)
    {
      if (watchSetupAdvertiseRate > 19)
      {
        if (watchSetupAdvertiseRate == 20)
        {
          int v45 = "350 ms";
          goto LABEL_79;
        }
      }

      else
      {
        if (watchSetupAdvertiseRate == 10)
        {
          int v45 = "2 seconds";
          goto LABEL_79;
        }

        if (watchSetupAdvertiseRate == 15)
        {
          int v45 = "1022.5 ms";
          goto LABEL_79;
        }
      }
    }

    else if (watchSetupAdvertiseRate <= 44)
    {
      if (watchSetupAdvertiseRate == 40)
      {
        int v45 = "181.25 ms";
        goto LABEL_79;
      }

      if (watchSetupAdvertiseRate == 42)
      {
        int v45 = "120 ms";
        goto LABEL_79;
      }
    }

    else
    {
      switch(watchSetupAdvertiseRate)
      {
        case '-':
          int v45 = "60 ms";
          goto LABEL_79;
        case '2':
          int v45 = "30 ms";
          goto LABEL_79;
        case '<':
          int v45 = "20 ms";
LABEL_79:
          NSAppendPrintF_safe(&v48, ", wsPD <%@>, %s", v42, v45);
          objc_storeStrong(&location, v48);

          goto LABEL_80;
      }
    }

    int v45 = "270 ms";
    goto LABEL_79;
  }

        CFRelease(v19);
        if (!v13) {
          goto LABEL_28;
        }
        goto LABEL_27;
      }

      sub_1001EE0E4("ACIPCInterface found, ACIPCInterfaceTransport property not found");
    }

    else
    {
      sub_1001EE0E4("ACIPCInterface not found after 5 second -- runLoopResult = 0x%02x");
    }

    if (!v13) {
      goto LABEL_28;
    }
LABEL_27:
    IOObjectRelease(v13);
    goto LABEL_28;
  }

  sub_1001EE0E4("IOServiceAddMatchingNotification returned 0x%08x", v11);
  CFRunLoopRemoveSource(Current, RunLoopSource, kCFRunLoopDefaultMode);
  IONotificationPortDestroy(v4);
LABEL_28:
  uint64_t v20 = os_channel_create(uu, 0LL);
  if (v20)
  {
    int v21 = v20;
    *(void *)a2 = v20;
    __int16 v22 = os_channel_attr_create();
    if (v22)
    {
      int v23 = v22;
      if (!os_channel_read_attr(v21, v22))
      {
        *(void *)in = 0LL;
        *(void *)buffer = 0LL;
        *(void *)notification = 0LL;
        os_channel_attr_get(v23, 4LL, in);
        os_channel_attr_get(v23, 3LL, buffer);
        os_channel_attr_get(v23, 2LL, notification);
        sub_1001EE0E4( "(%s) skywalk channel slotlen: %llu, rxslots: %llu, txslots: %llu\n",  a1,  *(void *)in,  *(void *)buffer,  *(void *)notification);
      }

      os_channel_attr_destroy(v23);
    }

    uint64_t v24 = kqueue();
    if (v24 == -1)
    {
      sub_1001EE0E4("(%s) failed to create write kqueue\n");
    }

    else
    {
      uint64_t v25 = v24;
      *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v24;
      changelist.ident = (int)os_channel_get_fd(v21);
      *(_DWORD *)&changelist.filter = 393214;
      memset(&changelist.fflags, 0, 20);
      if (kevent(v25, &changelist, 1, 0LL, 0, 0LL) == -1)
      {
        sub_1001EE0E4("(%s) write kevent registration failed\n");
      }

      else
      {
        int v26 = kqueue();
        if (v26 == -1)
        {
          sub_1001EE0E4("(%s) failed to create read kqueue\n");
        }

        else
        {
          int v27 = v26;
          char v28 = (unint64_t)&changelist | 0xC;
          *(_DWORD *)(a2 + 12) = v26;
          changelist.ident = (int)os_channel_get_fd(v21);
          *(_DWORD *)&changelist.filter = 393215;
          *(void *)char v28 = 0LL;
          *(void *)(v28 + _Block_object_dispose(va, 8) = 0LL;
          *(_DWORD *)(v28 + 16) = 0;
          if (kevent(v27, &changelist, 1, 0LL, 0, 0LL) != -1)
          {
            sub_1001EE0E4("(%s) channel created successfully\n", a1);
            return 0LL;
          }

          sub_1001EE0E4("(%s) read kevent registration failed\n");
        }
      }
    }
  }

  else
  {
    sub_1001EE0E4("(%s) failed to create channel\n");
  }

  sub_1001EE0E4("(%s) failed to create channel\n");
  return 0xFFFFFFFFLL;
}

    uint64_t v49 = 0LL;
    int v47 = 0LL;
LABEL_48:
    uint64_t v16 = 106LL;
    goto LABEL_49;
  }

  int v47 = v46;
  int v48 = (char *)sub_1000B17F4(24 * v45);
  if (!v48)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Device Identification Record: out of memory", v63, v64, v65, v66, v67, v68, v69, 512LL);
      BOOL v70 = (os_log_s *)sub_100086554(0x3Du);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    uint64_t v49 = 0LL;
    goto LABEL_48;
  }

  uint64_t v49 = v48;
  *(_BYTE *)int v47 = 1;
  v47[1] = 2;
  *((_DWORD *)v47 + 2) = (unsigned __int16)*a1;
  *((_BYTE *)v47 + 16) = 1;
  v47[9] = 2;
  *((_DWORD *)v47 + 6) = (unsigned __int16)a1[1];
  *((_BYTE *)v47 + 32) = 1;
  v47[17] = 2;
  *((_DWORD *)v47 + 10) = (unsigned __int16)a1[2];
  *((_BYTE *)v47 + 4_Block_object_dispose(va, 8) = 5;
  v47[25] = 1;
  *((_BYTE *)v47 + 56) = *((_BYTE *)a1 + 6);
  *((_BYTE *)v47 + 64) = 1;
  v47[33] = 2;
  *((_DWORD *)v47 + 1_Block_object_dispose(va, 8) = (unsigned __int16)a1[4];
  *((_BYTE *)v47 + 12_Block_object_dispose(va, 8) = 1;
  v47[65] = 4;
  *((_DWORD *)v47 + 34) = *((_DWORD *)a1 + 3);
  *((_BYTE *)v47 + 144) = 1;
  v47[73] = 2;
  *((_DWORD *)v47 + 3_Block_object_dispose(va, 8) = (unsigned __int16)a1[5];
  *(_OWORD *)int v48 = xmmword_100883B50;
  *((void *)v48 + 2) = &unk_1006BC268;
  *((void *)v48 + 5) = 258LL;
  *(_OWORD *)(v48 + 24) = *(_OWORD *)&qword_100883B68;
  *((_WORD *)v48 + 24) = 513;
  *(_OWORD *)(v48 + 56) = *(_OWORD *)v47;
  *((_WORD *)v48 + 36) = 514;
  *((_OWORD *)v48 + 5) = *((_OWORD *)v47 + 1);
  *((_WORD *)v48 + 4_Block_object_dispose(va, 8) = 515;
  *(_OWORD *)(v48 + 104) = *((_OWORD *)v47 + 2);
  *((_WORD *)v48 + 60) = 516;
  *((_OWORD *)v48 + _Block_object_dispose(va, 8) = *((_OWORD *)v47 + 3);
  *((_WORD *)v48 + 72) = 517;
  *(_OWORD *)(v48 + 152) = *((_OWORD *)v47 + 4);
  *((_WORD *)v48 + 84) = -24576;
  *((_OWORD *)v48 + 11) = *((_OWORD *)v47 + 8);
  *((_WORD *)v48 + 96) = -20481;
  *(_OWORD *)(v48 + 200) = *((_OWORD *)v47 + 9);
  uint64_t v50 = (const char *)*((void *)a1 + 3);
  if (v50)
  {
    *((_BYTE *)v47 + 80) = 8;
    v47[41] = strlen(v50);
    *((void *)v47 + 11) = v50;
    v49[108] = 11;
    *((_OWORD *)v49 + 14) = *((_OWORD *)v47 + 5);
  }

  uint64_t v51 = (const char *)*((void *)a1 + 4);
  if (v51)
  {
    *((_BYTE *)v47 + 96) = 4;
    v47[49] = strlen(v51);
    *((void *)v47 + 13) = v51;
    v49[108] = 257;
    *((_OWORD *)v49 + 14) = *((_OWORD *)v47 + 6);
  }

  uint64_t v52 = (const char *)*((void *)a1 + 5);
  if (v52)
  {
    *((_BYTE *)v47 + 112) = 8;
    v47[57] = strlen(v52);
    *((void *)v47 + 15) = v52;
    v49[108] = 10;
    *((_OWORD *)v49 + 14) = *((_OWORD *)v47 + 7);
  }

  *(void *)&__int16 v83 = v49;
  WORD4(v83) = 9;
  *(void *)&int v84 = v49 + 108;
  WORD4(v84) = v6;
  __int16 v53 = sub_1001E1634(v85, (uint64_t)&v83);
  if ((_DWORD)v53)
  {
    uint64_t v16 = v53;
LABEL_49:
    sub_1000B1838(v9);
    sub_1000B1838(v11);
    if (v13) {
      sub_1000B1838(v13);
    }
    if (v49) {
      sub_1000B1838(v49);
    }
    if (v47) {
      sub_1000B1838(v47);
    }
    return v16;
  }

  int v71 = sub_1000B17F4(0x30uLL);
  if (!v71)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Device Identification Record: out of memory", v74, v75, v76, v77, v78, v79, v80, 512LL);
      __int16 v81 = (os_log_s *)sub_100086554(0x3Du);
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_48;
  }

  *(void *)int v71 = 0LL;
  int v72 = v85;
  v71[2] = v85;
  *((void *)v71 + 2) = v9;
  *((void *)v71 + 3) = v11;
  *((void *)v71 + 4) = v47;
  *((void *)v71 + 5) = v49;
  if (v4)
  {
    do
    {
      int v73 = v4;
      unint64_t v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  else
  {
    int v73 = &qword_1008E1E48;
  }

  id *v73 = (uint64_t)v71;
  uint64_t v16 = 0LL;
  if (a2) {
    *a2 = v72;
  }
  return v16;
}

  if (off_1008F29D8) {
    off_1008F29D8( a2,  a3,  *(void *)(a1 + 208),  v48,  v14 / 0x3E8uLL,  (v15 / 8),  *(unsigned int *)(a1 + 92) / 0x3E8uLL,  v10 | ((unint64_t)(unsigned __int16)v11 << 32));
  }
  if (a3 != 1) {
    *(_DWORD *)(a1 + 204) += v14 / 0x3E8;
  }
  *(_WORD *)(a1 + 212) = WORD2(v48);
  *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = v48;
  *(_DWORD *)(a1 + 92) = 0;
}

  if (!v10)
  {
    int v27 = (__int128 *)a1;
    char v28 = 4;
LABEL_52:
    sub_1001081C8(v27, 16, v28);
    return;
  }

  int v48 = &qword_1008F29F0[134 * v8];
  *((_DWORD *)v48 + 21) = v10;
  if (v10 == *((unsigned __int8 *)v48 + 76))
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"UPGRADE_REQ lmhandle 0x%4x already using tech %s", v49, v50, v51, v52, v53, v54, v55, *a1);
      int v73 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
LABEL_76:
        v91 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        v106 = v91;
        goto LABEL_77;
      }
    }
  }

  else
  {
    uint64_t v56 = dword_1008F29B4;
    if (!dword_1008F29B4) {
      goto LABEL_68;
    }
    uint64_t v57 = &dword_1008F2A20;
    while (*((unsigned __int16 *)v57 - 20) != LOWORD(qword_1008F29F0[134 * v8 + 1]))
    {
      v57 += 268;
      if (!--v56) {
        goto LABEL_68;
      }
    }

    if (*v57 == 6)
    {
      int v58 = &qword_1008F29F0[134 * v8];
      BOOL v60 = *((_DWORD *)v58 + 40);
      uint64_t v59 = v58 + 20;
      if (v60 == v59[8]
        || (int v61 = &qword_1008F29F0[134 * v8],
            int v63 = *((unsigned __int16 *)v61 + 98),
            uint64_t v62 = (__int16 *)v61 + 98,
            int v64 = v62 - 16,
            (unsigned __int16)*(v62 - 16) == v63))
      {
        int v65 = 0;
      }

      else
      {
        v104 = 0LL;
        sub_1000B080C((uint64_t)&v104);
        v92 = (1000 * (v104 - *v59) - *v64 + SWORD2(v104)) >> 2;
        int v65 = v92 < 0x465;
        if (v92 >= 0x465)
        {
          log = (1000 * (v104 - *v59) - *v64 + SWORD2(v104));
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"TS connection timeout detected %d mseconds ago, allow remote transport switch request",  v93,  v94,  v95,  v96,  v97,  v98,  v99,  log);
            loga = (os_log_s *)sub_100086554(0x56u);
            if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
            {
              v100 = sub_1001EDDCC();
              *(_DWORD *)buf = 136446210;
              v106 = v100;
              _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
            }
          }

          *uint64_t v59 = v59[8];
          *int v64 = *v62;
        }
      }

      if (v10 == 2 && (v65 | !sub_10008B640(v8, 1u)) == 1)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Received UPGRADE_REQ to tech BT but RSSI was not sufficient or uncertainty was %d, ignoring",  v66,  v67,  v68,  v69,  v70,  v71,  v72,  v65);
          int v73 = (os_log_s *)sub_100086554(0x56u);
          if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
          {
            char v74 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446210;
            v106 = v74;
LABEL_77:
            _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
      }

      else
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Received UPGRADE_REQ to tech BT. RSSI:  %d: %d",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  HIDWORD(qword_1008F29F0[134 * v8 + 23]));
          v89 = (os_log_s *)sub_100086554(0x56u);
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          {
            v90 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446210;
            v106 = v90;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }

        sub_1000FE4E0(a1, v10, 32);
      }
    }

    else
    {
LABEL_68:
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"UPGRADE_REQ got a request when already switching (state %d) !",  v75,  v76,  v77,  v78,  v79,  v80,  v81,  LODWORD(qword_1008F29F0[134 * v8 + 6]));
        int v73 = (os_log_s *)sub_100086554(0x56u);
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_76;
        }
      }
    }
  }

      *(_BYTE *)(a4 + 10) = v9;
LABEL_3:
      BOOL v10 = sub_10017AB4C(a1);
      int v11 = *(unsigned __int8 *)(a2 + 10);
      int v12 = *(unsigned __int8 *)(a4 + 10);
      if ((_DWORD)v12 != (_DWORD)v11)
      {
        if ((_DWORD)v12 == *(unsigned __int8 *)(v10 + 64))
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Mode negotiation resulted in using our mode -> using our params.",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v100);
            int v40 = (os_log_s *)sub_100086554(0x2Fu);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }
        }

        ((void (*)(unsigned int *, uint64_t, uint64_t))off_100885DA0[v12])(a1, a3, a4);
        return 1LL;
      }

      if (*(_BYTE *)(a2 + 10))
      {
        if ((_DWORD)v11 != 3) {
          goto LABEL_55;
        }
        if (*(unsigned __int8 *)(a2 + 11) - 64 <= 0xFFFFFFC0)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Invalid parameter %s:%d=%d",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  (uint64_t)"checkParams");
            uint64_t v20 = (os_log_s *)sub_100086554(0x2Fu);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
LABEL_54:
            }
              sub_100657858();
          }

  if (!v16) {
    goto LABEL_62;
  }
  if (!v2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Error : got a found event when scan is stopped", v42, v43, v44, v45, v46, v47, v48, v50);
      uint64_t v49 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        sub_100657858();
        if (!v28) {
          return;
        }
        goto LABEL_63;
      }
    }

  LODWORD(v1) = 34;
LABEL_39:
  int v5 = sub_1002E6BF0();
  else {
    uint64_t v1 = v1;
  }
LABEL_42:
  unint64_t v6 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = v1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "ePA high Tx power is : %d", (uint8_t *)v8, 8u);
  }

  return v1;
}

      uint64_t v30 = *(unsigned __int8 *)(v13 + 40);
      if (v30 == 8)
      {
        if (*(_BYTE *)(a1 + 407))
        {
          sub_10035FFF0(a1, a2, 5, a3, 0, 0, 0);
          uint64_t result = 0LL;
          if (*(_DWORD *)(v23 + 24) != 8194) {
            return result;
          }
          sleep(1u);
          if (a3 == 1) {
            uint64_t v34 = 2;
          }
          else {
            uint64_t v34 = 1;
          }
          uint64_t v31 = a1;
          int v32 = a2;
          int v33 = 5;
          goto LABEL_71;
        }
      }

      else if (v30 == 7)
      {
        if (*(_BYTE *)(a1 + 141) != 8)
        {
          uint64_t v31 = a1;
          int v32 = a2;
          int v33 = 6;
LABEL_70:
          uint64_t v34 = a3;
LABEL_71:
          sub_10035FFF0(v31, v32, v33, v34, 0, 0, 0);
          return 0LL;
        }

        goto LABEL_67;
      }

      return 0LL;
    }

    if (v10 == 121)
    {
      if (v11 == 1) {
        goto LABEL_47;
      }
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
        sub_100671384();
      }
      return 1LL;
    }

    uint64_t result = 0LL;
    if (v10 > 134)
    {
      if (v10 == 139)
      {
LABEL_68:
        uint64_t v31 = a1;
        int v32 = a2;
        int v33 = 2;
        goto LABEL_70;
      }

      if (v10 != 135) {
        return result;
      }
LABEL_67:
      if (*(_DWORD *)(a1 + 142) != 100000)
      {
        uint64_t v31 = a1;
        int v32 = a2;
        int v33 = 7;
        goto LABEL_70;
      }

      goto LABEL_68;
    }

    if (v10 != 123)
    {
      if (v10 != 131) {
        return result;
      }
      usleep(0x7A120u);
      return 0LL;
    }

    if (v11 != 1) {
      return 1LL;
    }
    usleep(0x186A0u);
    uint64_t v35 = *(unsigned __int16 *)(a1 + 420) - 1;
    if (v35 <= 8
      && ((0x187u >> v35) & 1) != 0
      && (uint64_t v36 = fopen((const char *)*(&off_100892F58 + (__int16)v35), "ab")) != 0LL)
    {
      unsigned int v37 = v36;
      fwrite(a4 + 4, 1uLL, a5 - 4LL, v36);
      fclose(v37);
    }

    else
    {
      int v38 = (os_log_s *)qword_1008F7568;
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR)) {
        sub_1006713B0(v38);
      }
    }

    uint64_t v39 = *(unsigned __int16 *)(a1 + 420);
    switch(*(_WORD *)(a1 + 420))
    {
      case 1:
        if (*(_WORD *)(a1 + 418) == 0x2000)
        {
          LOWORD(v39) = 2;
          goto LABEL_87;
        }

        uint64_t v39 = 1;
        goto LABEL_111;
      case 2:
        if (*(_WORD *)(a1 + 418) != 4096)
        {
          LOBYTE(v39) = 2;
          goto LABEL_117;
        }

        sub_100360628(a1, (uint64_t)&unk_1008F049A);
        sub_100360628(a1, (uint64_t)&unk_1008F059A);
        if (*(_BYTE *)(v23 + 40) == 7)
        {
          LOWORD(v39) = 3;
LABEL_87:
          int v27 = 0;
          *(_WORD *)(a1 + 420) = v39;
          *(_WORD *)(a1 + 41_Block_object_dispose(va, 8) = 0;
          goto LABEL_118;
        }

        if (*(_DWORD *)(v23 + 24) != 8201) {
          goto LABEL_107;
        }
        goto LABEL_105;
      case 3:
        if (*(_WORD *)(a1 + 418) != 4096)
        {
          LOBYTE(v39) = 3;
          goto LABEL_117;
        }

        sub_100360628(a1, (uint64_t)&unk_1008F069A);
        if (*(_DWORD *)(v23 + 24) != 8201) {
          goto LABEL_107;
        }
        int v40 = (os_log_s *)qword_1008F7568;
        if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v43[0]) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Start logging for MCU1",  (uint8_t *)v43,  2u);
        }

        int v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 216) objectForKeyedSubscript:v9]);
        char v28 = v27;
        if (v27 && [v27 requiresLowLatency])
        {
          if (qword_1008D5F10 != -1) {
            dispatch_once(&qword_1008D5F10, &stru_100894610);
          }
          uint32_t v29 = off_1008D5F08;
          sub_100241F90(__p, v9);
          sub_100599B60((uint64_t)v29, __p);
        }

        uint64_t v30 = (os_log_s *)qword_1008F7658;
        if (os_log_type_enabled((os_log_t)qword_1008F7658, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v31 = *(void *)(a1 + 88);
          *(_DWORD *)__p = v35;
          *(void *)&__p[4] = v9;
          *(_WORD *)&__p[12] = 2114;
          *(void *)&__p[14] = v31;
          _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "App disconnecting - {cbuuid: %{public}@, bundle: %{public}@}",  __p,  0x16u);
        }

        if (SHIBYTE(v47) < 0) {
          operator delete(*(void **)&buf[8]);
        }
        BOOL v8 = (char *)v8 + 1;
      }

      while (v8 != v6);
      int v33 = [obj countByEnumeratingWithState:&v40 objects:v49 count:16];
      unint64_t v6 = v33;
    }

    while (v33);
  }

  [*(id *)(a1 + 216) removeAllObjects];
  [*(id *)(a1 + 224) removeAllObjects];
  [*(id *)(a1 + 80) removeAllObjects];
  [*(id *)(a1 + 376) removeAllObjects];
  sub_100390F24(a1);
  sub_100291CA0(a1 + 384, *(void **)(a1 + 392));
  *(void *)(a1 + 392) = 0LL;
  *(void *)(a1 + 400) = 0LL;
  *(void *)(a1 + 384) = a1 + 392;
  [*(id *)(a1 + 304) removeAllObjects];
  sub_1003A0DAC(a1 + 280, *(void **)(a1 + 288));
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 280) = a1 + 288;
  sub_1003A0DFC(a1 + 416, *(void **)(a1 + 424));
  *(void *)(a1 + 424) = 0LL;
  *(void *)(a1 + 432) = 0LL;
  *(void *)(a1 + 416) = a1 + 424;
  return sub_1003909B4(a1, a2);
}

  v104 = 0;
  int v26 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENOverrideRSSIHighThreshold");
  int v27 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v26 + 88LL))(v26, buf, __p, &v104);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v27) {
      goto LABEL_55;
    }
  }

  else if (!v27)
  {
    goto LABEL_55;
  }

  char v28 = v104;
  *(_WORD *)(a1 + 220) = v104;
  uint32_t v29 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Overriding fHighRSSIThreshold = %d ", buf, 8u);
  }

          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/core/Device.mm");
          char v28 = 0;
          goto LABEL_48;
        }
      }

      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Server/core/Device.mm");
      int v27 = 0;
      goto LABEL_47;
    }

    uint64_t v30 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v25;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = a3;
      *(_WORD *)&_BYTE buf[14] = 1024;
      *(_DWORD *)&uint8_t buf[16] = v42;
      *(_WORD *)int v45 = 1024;
      *(_DWORD *)&v45[2] = __n[0];
      _os_log_error_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Invalid newDeviceIdDataLength:%d, dataLength:%d, oldManufacturerDataLength:%d, newManufacturerDataLength:%d skip ping setDeviceId",  buf,  0x1Au);
    }
  }

  int v26 = v37;
  uint64_t v25 = v38;
  while (v26 != v25)
  {
    if (!*(_DWORD *)(v26 + 8))
    {
      *(_DWORD *)(v26 + _Block_object_dispose(va, 8) = sub_10053C644(&v37);
      uint64_t v25 = v38;
    }

    v26 += 104LL;
  }

  int v27 = (os_log_s *)(id)qword_1008F75E8;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    sub_10053C68C(&v37, (std::string *)buf);
    char v28 = (SBYTE7(v45[0]) & 0x80u) == 0 ? buf : *(uint8_t **)buf;
    LODWORD(__str.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Updated call(s): %s", (uint8_t *)&__str, 0xCu);
    if (SBYTE7(v45[0]) < 0) {
      operator delete(*(void **)buf);
    }
  }

  sub_10053C460((int)v31);
  -[Communicator setCalls:](self, "setCalls:", v31);
  *(void *)buf = v31;
  sub_1002077E0((void ***)buf);
  *(void *)buf = &v37;
  sub_1002077E0((void ***)buf);
  *(void *)buf = &v40;
  sub_1002077E0((void ***)buf);
}

  if (v15)
  {
    if (v15 == 1807)
    {
      uint64_t v17 = (os_log_s *)qword_1008F7598;
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Audio was already disconnected", buf, 2u);
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
      {
        if (v8)
        {
          sub_1003CF00C(v8, buf);
          sub_100682174();
        }

        else
        {
          sub_100682130((uint64_t)v31, v15);
        }
      }

      sub_100242C98(&v23);
      sub_1000F5D14(a2, v15);
      sub_100242CD0(&v23);
    }
  }

  if (v9) {
    sub_1001FFA38(v9 + 400, 0);
  }
  sub_100242CD8(&v23);
  uint64_t v18 = 1LL;
LABEL_59:
  sub_100242FAC((uint64_t)v26);
  return v18;
}

      uint32_t v29 = v33;
      if (!v26) {
        uint32_t v29 = 1;
      }
      if ((v29 & 1) == 0) {
        operator delete[](v26);
      }
LABEL_51:
      uint64_t v30 = (os_log_s *)qword_1008F7730;
      if (v18)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
          sub_1006840CC();
        }
      }

      else if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = "get";
        *(_DWORD *)buf = 136316674;
        if (!v13) {
          uint64_t v31 = "set";
        }
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&_BYTE buf[14] = v42;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v14;
        *(_WORD *)&_BYTE buf[24] = 1024;
        *(_DWORD *)&buf[26] = v15;
        *(_WORD *)&buf[30] = 2048;
        uint64_t v44 = v17;
        int v45 = 1040;
        int v46 = v17;
        int v47 = 2098;
        int v48 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Sent queued %s report {handle: 0x%x, type: %d, ID: %d, size: %zu, {%{public}.*P}",  buf,  0x38u);
      }

      *((_BYTE *)v12 + 72) = 0;
      int v32 = (void *)v12[10];
      if (v32) {
        free(v32);
      }
      v12[10] = 0LL;
    }

    else
    {
      uint64_t v19 = (os_log_s *)qword_1008F7730;
      if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "sendControlOpCfm No pending reports",  buf,  2u);
      }
    }
  }

  uint64_t v20 = sub_1002E6BF0();
  *(_BYTE *)(a1 + 1379) = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 832LL))(v20);
  int v21 = sub_1002E8D94();
  (*(void (**)(uint64_t, void))(*(void *)v21 + 608LL))(v21, *(unsigned __int8 *)(a1 + 1379));
  __p[0] = buf;
  sub_100024304((void ***)__p);
}
}

const char *sub_10003C63C(int a1)
{
  if (a1 <= 39)
  {
    if (a1 > 19)
    {
      if (a1 != 20) {
        return "270 ms";
      }
      return "350 ms";
    }

    else
    {
      if (a1 != 10)
      {
        if (a1 == 15) {
          return "1022.5 ms";
        }
        return "270 ms";
      }

      return "2 seconds";
    }
  }

  else if (a1 <= 44)
  {
    if (a1 != 40)
    {
      if (a1 == 42) {
        return "120 ms";
      }
      return "270 ms";
    }

    return "181.25 ms";
  }

  else
  {
    switch(a1)
    {
      case '-':
        return "60 ms";
      case '2':
        return "30 ms";
      case '<':
        return "20 ms";
      default:
        return "270 ms";
    }
  }

BOOL sub_10003C784(id a1)
{
  return 1;
}

BOOL sub_10003C808(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 40) + 880LL);
  id v3 = *(id *)(a1 + 32);
  id v4 = v2;
  BOOL v5 = v3 != v4;
  if (v3 == v4)
  {

LABEL_8:
    return v5;
  }

  unint64_t v6 = v4;
  if ((v3 == 0LL) == (v4 != 0LL))
  {

    goto LABEL_7;
  }

  unsigned __int8 v7 = [v3 isEqual:v4];

  if ((v7 & 1) == 0)
  {
LABEL_7:
    BOOL v8 = *(void **)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    id v10 = v8;
    id v3 = *(id *)(v9 + 880);
    *(void *)(v9 + 880) = v10;
    goto LABEL_8;
  }

  return 0LL;
}

BOOL sub_10003C910(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 860);
  if (v1 != v3)
  {
    *(_DWORD *)(v2 + 860) = v1;
    *(_BYTE *)(*(void *)(a1 + 32) + 808LL) = 1;
  }

  return v1 != v3;
}

BOOL sub_10003C994(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(v2 + 858);
  if (v1 != v3) {
    *(_BYTE *)(v2 + 85_Block_object_dispose(va, 8) = v1;
  }
  return v1 != v3;
}

BOOL sub_10003CA34(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 40) + 920LL);
  id v3 = *(id *)(a1 + 32);
  id v4 = v2;
  BOOL v5 = v3 != v4;
  if (v3 == v4)
  {

LABEL_8:
    return v5;
  }

  unint64_t v6 = v4;
  if ((v3 == 0LL) == (v4 != 0LL))
  {

    goto LABEL_7;
  }

  unsigned __int8 v7 = [v3 isEqual:v4];

  if ((v7 & 1) == 0)
  {
LABEL_7:
    BOOL v8 = *(void **)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    id v10 = v8;
    id v3 = *(id *)(v9 + 920);
    *(void *)(v9 + 920) = v10;
    goto LABEL_8;
  }

  return 0LL;
}

BOOL sub_10003CB64(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 40) + 936LL);
  id v3 = *(id *)(a1 + 32);
  id v4 = v2;
  BOOL v5 = v3 != v4;
  if (v3 == v4)
  {

LABEL_8:
    return v5;
  }

  unint64_t v6 = v4;
  if ((v3 == 0LL) == (v4 != 0LL))
  {

    goto LABEL_7;
  }

  unsigned __int8 v7 = [v3 isEqual:v4];

  if ((v7 & 1) == 0)
  {
LABEL_7:
    BOOL v8 = *(void **)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    id v10 = v8;
    id v3 = *(id *)(v9 + 936);
    *(void *)(v9 + 936) = v10;
    goto LABEL_8;
  }

  return 0LL;
}

BOOL sub_10003CC94(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 40) + 928LL);
  id v3 = *(id *)(a1 + 32);
  id v4 = v2;
  BOOL v5 = v3 != v4;
  if (v3 == v4)
  {

LABEL_8:
    return v5;
  }

  unint64_t v6 = v4;
  if ((v3 == 0LL) == (v4 != 0LL))
  {

    goto LABEL_7;
  }

  unsigned __int8 v7 = [v3 isEqual:v4];

  if ((v7 & 1) == 0)
  {
LABEL_7:
    BOOL v8 = *(void **)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    id v10 = v8;
    id v3 = *(id *)(v9 + 928);
    *(void *)(v9 + 92_Block_object_dispose(va, 8) = v10;
    goto LABEL_8;
  }

  return 0LL;
}

id sub_10003CDE0(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 24LL) = 1;
  return [*(id *)(a1 + 32) _activateWithCompletion:*(void *)(a1 + 40)];
}

void *sub_10003CFE4(void *result)
{
  uint64_t v1 = result[4];
  if (!*(_BYTE *)(v1 + 32))
  {
    uint64_t v2 = result;
    *(_BYTE *)(v1 + 32) = 1;
    if (dword_1008D6460 <= 30
      && (dword_1008D6460 != -1 || _LogCategory_Initialize(&dword_1008D6460, 30LL)))
    {
      LogPrintF_safe( &dword_1008D6460,  "-[CBAdvertiserDaemon invalidate]_block_invoke",  30LL,  "Invalidate: CID 0x%X",  *(_DWORD *)(v2[4] + 28LL));
    }

    return [(id)v2[4] _invalidate];
  }

  return result;
}

id sub_10003D458(uint64_t a1)
{
  return [*(id *)(a1 + 32) _update];
}

LABEL_22:
  NSAppendPrintF_safe(&v22, ", %@ <%@>, %s", var2, v12, v15);
  uint64_t v16 = v22;

  if (v5)
  {
    var11 = a4->var11;
    if (var11)
    {
      int v21 = v16;
      uint64_t v18 = var11;
      NSAppendPrintF_safe(&v21, ", WPID <%@>", v18);
      uint64_t v19 = v21;

      uint64_t v16 = v19;
    }
  }

  uint64_t v20 = *a3;
  *a3 = v16;

LABEL_26:
}

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v38, 8);
}

  return (char)v10;
}

    ;
  }

      sub_1000B7BB8((unsigned __int16 *)a1, 0);
    }

    else
    {
      if (*(_DWORD *)(a1 + 32) == 2) {
        sub_1000B6DFC(a1);
      }
      switch(*(_DWORD *)(a1 + 204))
      {
        case 4:
          int v21 = *(void **)(a1 + 64);
          if (v21)
          {
            sub_1000B1838(v21);
            *(void *)(a1 + 64) = 0LL;
          }

          *(_DWORD *)(a1 + 204) = 5;
          __int16 v22 = *(unsigned int *)(a1 + 176);
          if ((_DWORD)v22)
          {
            sub_1001EEB14(v22);
            *(_DWORD *)(a1 + 176) = 0;
          }

          break;
        case 7:
          if ((*(_BYTE *)(a1 + 80) & 0xFE) == 0x48)
          {
            int v23 = *(void (**)(uint64_t, void, uint64_t))(*(void *)(*(void *)(a1 + 168) + 16LL) + 16LL);
            uint64_t v24 = *(unsigned __int16 *)(a1 + 208);
            uint64_t v25 = 1701LL;
            goto LABEL_25;
          }

          *(_DWORD *)(a1 + 204) = 5;
          int v23 = *(void (**)(uint64_t, void, uint64_t))(*(void *)(*(void *)(a1 + 168) + 16LL) + 16LL);
          goto LABEL_24;
        case 9:
          *(_DWORD *)(a1 + 204) = 5;
          int v23 = *(void (**)(uint64_t, void, uint64_t))(*(void *)(*(void *)(a1 + 168) + 16LL) + 24LL);
LABEL_24:
          uint64_t v24 = *(unsigned __int16 *)(a1 + 208);
          uint64_t v25 = 0LL;
LABEL_25:
          v23(v24, 0LL, v25);
          break;
        case 0xB:
          if (*(_BYTE *)(a1 + 192)) {
            goto LABEL_22;
          }
          *(_DWORD *)(a1 + 204) = 2;
          *(_BYTE *)(a1 + 201) = 0;
          (*(void (**)(void))(*(void *)(*(void *)(a1 + 168) + 16LL) + 8LL))(*(unsigned __int16 *)(a1 + 208));
          break;
        default:
          return;
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Write confirmation for bogus link %x %!", v13, v14, v15, v16, v17, v18, v19, (uint64_t)&link);
    uint64_t v20 = (os_log_s *)sub_100086554(0x18u);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

                WORD2(v32) = v14 + 1;
                *(_BYTE *)(v31 + v14) = v15;
                if (HIBYTE(v32))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c");
                }

                else
                {
                  uint64_t v17 = WORD2(v32);
                  if (WORD1(v32) > WORD2(v32))
                  {
                    if (BYTE6(v32) == 2)
                    {
                      ++WORD2(v32);
                      *(_BYTE *)(v31 + v17) = 2;
                      if (HIBYTE(v32))
                      {
                        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c");
                      }

                      else
                      {
                        uint64_t v18 = WORD2(v32);
                        if (WORD1(v32) > WORD2(v32))
                        {
                          if (BYTE6(v32) == 2)
                          {
                            ++WORD2(v32);
                            *(_BYTE *)(v31 + v1_Block_object_dispose(va, 8) = 0;
                            if (a2)
                            {
                              uint64_t v19 = a2;
                              while (!HIBYTE(v32))
                              {
                                uint64_t v20 = WORD2(v32);
                                if (BYTE6(v32) != 2)
                                {
                                  int v23 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                                  goto LABEL_45;
                                }

                                int v21 = *(_BYTE *)(a1 - 1 + v19--);
                                ++WORD2(v32);
                                *(_BYTE *)(v31 + v20) = v21;
                              }

                              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c");
LABEL_43:
                              int v23 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_45:
                              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/aci/aci_vsc.c",  1312,  v23);
                            }

    if (sub_1000A86F0())
    {
      int v26 = dword_1008F29B4;
      if (dword_1008F29B4)
      {
        int v27 = (unsigned int *)&dword_1008F2A20;
        while (*((unsigned __int16 *)v27 - 20) != (_DWORD)v4)
        {
          v27 += 268;
          if (!--v26) {
            goto LABEL_27;
          }
        }

        char v28 = *v27;
      }

      else
      {
LABEL_27:
        char v28 = 0;
      }

      uint32_t v29 = sub_1000FFB28(v28);
      sub_1001EE134( (uint64_t)"VERSION should only be send when in ENCRYPTED state. Current state is %s",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  (uint64_t)v29);
      unsigned int v37 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Link is not encrypted, can't send version", v7, v8, v9, v10, v11, v12, v13, v46);
    uint64_t v14 = (os_log_s *)sub_100086554(0x56u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Received DOWNGRADE_REQ from peer %d, %s", v24, v25, v26, v27, v28, v29, v30, v3);
      uint64_t v31 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        int v32 = sub_1001EDDCC();
        *(_DWORD *)buf = 136446210;
        uint64_t v35 = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    if (v5)
    {
      sub_1000FF06C(a1, 32);
    }

    else if ((_DWORD)v3 == dword_1008F29B4)
    {
      sub_1001EE2A0();
    }

    else
    {
      sub_10008B5D4(3LL, 0, (unsigned __int16)v3);
    }
  }

  else
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"DOWNGRADE_REQ not supposed to get a downgrade request from the central.",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v33);
      __int16 v13 = (os_log_s *)sub_100086554(0x56u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v35 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    sub_1001081C8((__int128 *)a1, 34, 2);
  }

  if (*(_BYTE *)(qword_1008F6D80 + 8)) {
    sub_1001346DC((unsigned __int16 *)&dword_1008E264C, v19, v20, v21, v22, v23, v24, v25);
  }
}

        sub_1001EE134((uint64_t)"Unknown request type", v18, v19, v20, v21, v22, v23, v24, v58);
        uint64_t v25 = (os_log_s *)sub_100086554(6u);
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          return 1721LL;
        }
      }

      else
      {
        sub_1001EE134((uint64_t)"Type header missing in request", v29, v30, v31, v32, v33, v34, v35, v58);
        uint64_t v36 = (os_log_s *)sub_100086554(6u);
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          return 1721LL;
        }
      }

      sub_100657858();
      return 1721LL;
    }
  }

  else
  {
    __int16 v13 = v10 == 2;
    if (a2)
    {
      uint64_t v15 = a4 == &off_100885C48;
      sub_1001EE2A0();
      goto LABEL_15;
    }
  }

  if ((_DWORD)a3 == 1701) {
    int v11 = 0LL;
  }
  else {
    int v11 = a3;
  }
  if ((_DWORD)a3 != 1701 && !v13)
  {
    *(_DWORD *)(v9 + 16) = 2;
    if (*(void *)(v9 + 240))
    {
      *(_DWORD *)(v9 + 12) = 3;
      sub_100171094(v9, a3);
    }

    *(_DWORD *)(v12 + 12) = 2;
    int v26 = *(void **)(v12 + 232);
    if (v26)
    {
      sub_1000B1838(v26);
      *(void *)(v12 + 232) = 0LL;
    }

    return a3;
  }

  return v11;
}

  id v10 = 0;
  *((_BYTE *)a1 + 15) = 1;
LABEL_23:
  if (sub_10012D6D8(v6))
  {
    sub_1001ADE1C(v5, v6, v7, v8, v9, v10);
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"LE_HCIEventHandler_RemoteConnectionParameterRequest: Invalid connectionHandle for lmHandle 0x%2x",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v6);
    __int16 v22 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

    sub_1001ADE74(a2, 0, 0, a3, 0LL, 0, 0, 0, 0, 0xFFFF, 0);
    return;
  }

  if ((int)a1 > 8213)
  {
    if ((_DWORD)a1 == 8214)
    {
      if ((_DWORD)a2)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to send remote used features: %!", v21, v22, v23, v24, v25, v26, v27, a2);
          char v28 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
            goto LABEL_34;
          }
        }
      }

      return;
    }

    if ((_DWORD)a1 == 8242)
    {
      if ((_DWORD)a2)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Failed to send set phy: %!", v13, v14, v15, v16, v17, v18, v19, a2);
          uint64_t v20 = (os_log_s *)sub_100086554(0x42u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            goto LABEL_34;
          }
        }
      }

      return;
    }

    goto LABEL_32;
  }

  if ((_DWORD)a1 == 8205) {
    goto LABEL_22;
  }
  if ((_DWORD)a1 != 8211)
  {
LABEL_32:
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Unknown LE event code 0x%x", v37, v38, v39, v40, v41, v42, v43, a1);
      uint64_t v44 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_34;
      }
    }

    return;
  }

  if ((_DWORD)a2)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Failed to send connection update : %!", v5, v6, v7, v8, v9, v10, v11, a2);
      int v12 = (os_log_s *)sub_100086554(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
LABEL_34:
      }
        sub_100657F74();
    }
  }

  int v23 = *(unsigned __int16 *)(a1 + 1656);
  if (*(_WORD *)(a1 + 1656))
  {
    if (a6 == 4) {
      uint64_t v24 = 1650;
    }
    else {
      uint64_t v24 = 31;
    }
    if (v23 + v11 > v24)
    {
      sub_1001EE134( (uint64_t)"Not enough room in ADV packet. (currently length=%d)",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  *(unsigned __int16 *)(a1 + 1656));
      int v32 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        goto LABEL_39;
      }
      goto LABEL_38;
    }

    memmove((void *)(a2 + v11), (const void *)(a1 + 5), v23);
    LOWORD(v11) = *(_WORD *)(a1 + 1656) + v11;
  }

  int v33 = *(unsigned __int16 *)(a1 + 3308);
  if (*(_WORD *)(a1 + 3308))
  {
    if (a6 == 4) {
      uint64_t v34 = 1650;
    }
    else {
      uint64_t v34 = 31;
    }
    if (v34 < v33)
    {
      sub_1001EE134((uint64_t)"Not enough room in SCN_RSP packet.", v35, v36, v37, v38, v39, v40, v41, v45);
      __int16 v42 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        goto LABEL_39;
      }
LABEL_38:
      sub_100657858();
LABEL_39:
      sub_1001EE2A0();
      return 101LL;
    }

    memmove(__dst, (const void *)(a1 + 1658), v33);
    uint64_t v44 = *(_WORD *)(a1 + 3308);
  }

  else
  {
    uint64_t v44 = 0;
  }

  uint64_t result = 0LL;
  *a3 = v11;
  *a5 = v44;
  return result;
}

    sub_100657858();
LABEL_23:
    sub_1001CBE38((__int128 *)a1, 8, (char *)v7);
    return;
  }

  if (!v9)
  {
    sub_1001EE134((uint64_t)"Could not find associated pairing data.", v37, v38, v39, v40, v41, v42, v43, v128);
    uint64_t v44 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

  sub_100185340(v9);
  id v10 = *(unsigned __int8 *)(a1 + 70);
  if (v10 == 1)
  {
    if (sub_10018550C(v7, 34))
    {
      id v10 = *(unsigned __int8 *)(a1 + 70);
      goto LABEL_8;
    }

    __int16 v53 = sub_100185414();
    sub_1001EE134( (uint64_t)"Device was not in the proper state. State is %s.",  v54,  v55,  v56,  v57,  v58,  v59,  v60,  (uint64_t)v53);
    int v61 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }

        if (a3 == 734 || a3 == 708)
        {
          __int16 v13 = sub_100404EB8();
          v14[0] = _NSConcreteStackBlock;
          v14[1] = 3221225472LL;
          _DWORD v14[2] = sub_100223878;
          v14[3] = &unk_100888050;
          v14[4] = a1;
          void v14[5] = v7;
          v14[6] = v5;
          sub_100405460(v13, 5000LL, v14);
        }

        sub_100242FAC((uint64_t)v17);
        return;
      }
    }

    else if (v9)
    {
      goto LABEL_15;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR))
    {
      sub_1003D0100(v7, (uint64_t)__p);
      sub_100660418();
    }

    goto LABEL_22;
  }

  int v12 = (os_log_s *)qword_1008F7560;
  if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_ERROR)) {
    sub_10066038C(v5, v12);
  }
}

        int v21 = a2 + 152 * v12;
        if ((unint64_t)v11 >= *v13)
        {
          uint32_t v29 = *(void *)(a1 + 24);
          uint64_t v30 = 0x86BCA1AF286BCA1BLL * ((uint64_t)&v11[-v29] >> 3);
          uint64_t v31 = v30 + 1;
          if (v30 + 1 > 0x1AF286BCA1AF286LL) {
            abort();
          }
          if (0xD79435E50D79436LL * ((*v13 - v29) >> 3) > v31) {
            uint64_t v31 = 0xD79435E50D79436LL * ((*v13 - v29) >> 3);
          }
          if (0x86BCA1AF286BCA1BLL * ((*v13 - v29) >> 3) >= 0xD79435E50D7943LL) {
            int v32 = 0x1AF286BCA1AF286LL;
          }
          else {
            int v32 = v31;
          }
          if (v32) {
            int v33 = (char *)sub_100266944(a1 + 40, v32);
          }
          else {
            int v33 = 0LL;
          }
          uint64_t v34 = &v33[152 * v30];
          uint64_t v35 = *(_OWORD *)(v21 + 16);
          *(_OWORD *)uint64_t v34 = *(_OWORD *)v21;
          *((_OWORD *)v34 + 1) = v35;
          uint64_t v36 = *(_OWORD *)(v21 + 32);
          unsigned int v37 = *(_OWORD *)(v21 + 48);
          int v38 = *(_OWORD *)(v21 + 80);
          *((_OWORD *)v34 + 4) = *(_OWORD *)(v21 + 64);
          *((_OWORD *)v34 + 5) = v38;
          *((_OWORD *)v34 + 2) = v36;
          *((_OWORD *)v34 + 3) = v37;
          uint64_t v39 = *(_OWORD *)(v21 + 96);
          int v40 = *(_OWORD *)(v21 + 112);
          uint64_t v41 = *(_OWORD *)(v21 + 128);
          *((void *)v34 + 1_Block_object_dispose(va, 8) = *(void *)(v21 + 144);
          *((_OWORD *)v34 + 7) = v40;
          *((_OWORD *)v34 + _Block_object_dispose(va, 8) = v41;
          *((_OWORD *)v34 + 6) = v39;
          BOOL v43 = *(char **)(a1 + 24);
          __int16 v42 = *(char **)(a1 + 32);
          uint64_t v44 = v34;
          if (v42 != v43)
          {
            do
            {
              int v45 = *(_OWORD *)(v42 - 152);
              *(_OWORD *)(v44 - 136) = *(_OWORD *)(v42 - 136);
              *(_OWORD *)(v44 - 152) = v45;
              int v46 = *(_OWORD *)(v42 - 120);
              int v47 = *(_OWORD *)(v42 - 104);
              int v48 = *(_OWORD *)(v42 - 88);
              *(_OWORD *)(v44 - 72) = *(_OWORD *)(v42 - 72);
              *(_OWORD *)(v44 - 8_Block_object_dispose(va, 8) = v48;
              *(_OWORD *)(v44 - 104) = v47;
              *(_OWORD *)(v44 - 120) = v46;
              uint64_t v49 = *(_OWORD *)(v42 - 56);
              uint64_t v50 = *(_OWORD *)(v42 - 40);
              uint64_t v51 = *(_OWORD *)(v42 - 24);
              *((void *)v44 - 1) = *((void *)v42 - 1);
              *(_OWORD *)(v44 - 24) = v51;
              *(_OWORD *)(v44 - 40) = v50;
              *(_OWORD *)(v44 - 56) = v49;
              v44 -= 152;
              v42 -= 152;
            }

            while (v42 != v43);
            __int16 v42 = *(char **)(a1 + 24);
          }

          int v11 = v34 + 152;
          *(void *)(a1 + 24) = v44;
          *(void *)(a1 + 32) = v34 + 152;
          *(void *)(a1 + 40) = &v33[152 * v32];
          if (v42) {
            operator delete(v42);
          }
        }

        else
        {
          __int16 v22 = *(_OWORD *)(v21 + 16);
          *(_OWORD *)int v11 = *(_OWORD *)v21;
          *((_OWORD *)v11 + 1) = v22;
          int v23 = *(_OWORD *)(v21 + 32);
          uint64_t v24 = *(_OWORD *)(v21 + 48);
          uint64_t v25 = *(_OWORD *)(v21 + 80);
          *((_OWORD *)v11 + 4) = *(_OWORD *)(v21 + 64);
          *((_OWORD *)v11 + 5) = v25;
          *((_OWORD *)v11 + 2) = v23;
          *((_OWORD *)v11 + 3) = v24;
          int v26 = *(_OWORD *)(v21 + 96);
          int v27 = *(_OWORD *)(v21 + 112);
          char v28 = *(_OWORD *)(v21 + 128);
          *((void *)v11 + 1_Block_object_dispose(va, 8) = *(void *)(v21 + 144);
          *((_OWORD *)v11 + 7) = v27;
          *((_OWORD *)v11 + _Block_object_dispose(va, 8) = v28;
          *((_OWORD *)v11 + 6) = v26;
          v11 += 152;
        }

        *(void *)(a1 + 32) = v11;
        ++v12;
      }

      while (v12 != v14);
      uint64_t v52 = *(void *)(a1 + 24);
    }

    else
    {
      LODWORD(v52) = (_DWORD)v11;
    }

    uint32_t v55 = (_DWORD)v11 - v52;
    uint64_t v56 = -13797 * (v55 >> 3);
    uint64_t v57 = v55 & 0xFFF8 | 2;
    int v58 = malloc(v57);
    os_log_s *v58 = bswap32(v56) >> 16;
    (*(void (**)(uint64_t))(*(void *)a1 + 128LL))(a1);
    uint64_t v59 = (os_log_s *)qword_1008F7588;
    if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v60 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v57 - 2;
      *(_WORD *)&uint8_t buf[8] = 2048;
      *(void *)&buf[10] = v60;
      _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "upgradeDeviceToManatee Size deviceinfo Blob is %d for %lu of devices",  buf,  0x12u);
    }

    uint64_t v62 = *(char **)(a1 + 24);
    int v61 = *(char **)(a1 + 32);
    if (v62 != v61)
    {
      int v63 = 2;
      do
      {
        memmove((char *)v58 + (unsigned __int16)v63, v62, 0x98uLL);
        v63 += 152;
        v62 += 152;
      }

      while (v62 != v61);
    }

    xpc_dictionary_set_data(xdict, "kDeviceInfoBlob", v58, v57);
    buf[0] = 2;
    int v64 = *a4;
    *int v65 = *a4;
    void *v67 = *a5;
    *(_OWORD *)&buf[1] = v64;
    *(_OWORD *)&buf[17] = *a5;
    xpc_dictionary_set_data(xdict, "kMasterKeyBlob", buf, 0x21uLL);
    if (*(_BYTE *)(a1 + 80)) {
      sub_100208104(a1 + 88, "upgradeToManatee", xdict, 0LL);
    }
    free(v58);
  }
}

            ++v17;
          }

          while (v17 < sqlite3_column_count(a2));
        }
      }
    }

    if (v14 == 1 || v14 == 21) {
      break;
    }
    if (v14 == 101) {
      return v13;
    }
  }

  __int16 v22 = (os_log_s *)qword_1008F75E0;
  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR)) {
    sub_1006695D8(a1, v22);
  }
  return v13;
}

  int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F0090) {
      int v12 = "enabled";
    }
    else {
      int v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for new Controller BT clock capture is %s",  buf,  0xCu);
  }

  int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F00A0) {
      int v12 = "enabled";
    }
    else {
      int v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for new RSSI Connection statistics and detection is %s",  buf,  0xCu);
  }

  int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F00D0) {
      int v12 = "enabled";
    }
    else {
      int v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for Bluetooth usage notification is %s",  buf,  0xCu);
  }

  int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F00E0) {
      int v12 = "enabled";
    }
    else {
      int v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "support for Phy Statistics Bluetooth notification is %s",  buf,  0xCu);
  }

  int v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1008F0100) {
      int v12 = "enabled";
    }
    else {
      int v12 = "disabled";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "support for Match Buffering is %s", buf, 0xCu);
  }

  *a2 = v7;
  return result;
}

        if (v6 != a3) {
          *unint64_t v6 = *a3;
        }
        return sub_100242FAC((uint64_t)v15);
      }

      if (!memcmp(*v11, v12, *(void *)(a1 + 208))) {
        goto LABEL_22;
      }
    }
  }

  __int16 v13 = (os_log_s *)qword_1008F7598;
  if ((int)v6 >= 2501)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v6;
      uint64_t v19 = 1024;
      uint64_t v20 = 2500;
      _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Sco delay is too large %d, set max delay to %dms",  buf,  0xEu);
      __int16 v13 = (os_log_s *)qword_1008F7598;
    }

    unint64_t v6 = 2500LL;
  }

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Delay between sco and audio activation is %dms",  buf,  8u);
  }

  return v6;
}

      return sub_100242CD8(&v22);
    }

    if (qword_1008D9730 != -1) {
      dispatch_once(&qword_1008D9730, &stru_10089AD80);
    }
    (*(void (**)(void *, unint64_t))(*(void *)off_1008D9728 + 40LL))(off_1008D9728, a2);
    if (sub_10048D8CC(a1, a2, v6))
    {
      int v11 = (os_log_s *)qword_1008F7730;
      if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
        sub_100684858(v11, v12, v13, v14, v15, v16, v17, v18);
      }
      sub_1000F93B0(v6);
    }
  }

  else
  {
    BOOL v8 = (os_log_s *)(id)qword_1008F7730;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C(a2, __p);
      uint64_t v9 = v21 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = v9;
      uint64_t v25 = 1024;
      int v26 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "HID Host handle for device %{public}s is %d. Responding to delayed incoming connection request",  buf,  0x12u);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
    }

    id v10 = sub_1000F73D8(a2 + 128);
    if (!v10)
    {
      unsigned __int8 v7 = (os_log_s *)(id)qword_1008F7730;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        sub_1003CF00C(a2, __p);
        sub_100684808();
      }

      goto LABEL_22;
    }

    sub_10048DCD0((uint64_t)a1, a2, *(unsigned __int16 *)(v10 + 192), a3, 1);
    if (a3) {
      sub_100410A5C((uint64_t)a1, a2, a3);
    }
  }

  return sub_100242CD8(&v22);
}

  if ((v4 & 1) == 0 && a1[44] - a1[43] == 16LL && v3 != 0)
  {
    uint64_t v14 = (os_log_s *)qword_1008F7728;
    if (os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(id *)(v3 + 8);
      *(_DWORD *)buf = 138412290;
      uint64_t v17 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Both devices set to Bidirectional, set head session(%@) to output",  buf,  0xCu);
    }

    *(_DWORD *)(v3 + 24) = 0;
  }
}

          BOOL v8 = (char *)v8 + 1;
        }

        while (v6 != v8);
        uint64_t v17 = [v5 countByEnumeratingWithState:&v43 objects:v53 count:16];
        unint64_t v6 = v17;
        if (!v17) {
          goto LABEL_44;
        }
      }
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_10089D810);
    }
    uint64_t v18 = sub_1005C6C74((uint64_t)off_1008D5F28);
    uint64_t v41 = 0u;
    __int16 v42 = 0u;
    uint64_t v39 = 0u;
    int v40 = 0u;
    BOOL v5 = (id)objc_claimAutoreleasedReturnValue(v18);
    uint64_t v19 = [v5 countByEnumeratingWithState:&v39 objects:v48 count:16];
    if (v19)
    {
      uint64_t v20 = *(void *)v40;
      do
      {
        int v21 = 0LL;
        do
        {
          if (*(void *)v40 != v20) {
            objc_enumerationMutation(v5);
          }
          __int16 v22 = *(void **)(*((void *)&v39 + 1) + 8LL * (void)v21);
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089D810);
          }
          if ((sub_1005D79C0((uint64_t)off_1008D5F28, v22, *(void **)(a1 + 96), *(void **)(a1 + 48)) & 1) != 0)
          {
            [v34 addObject:v22];
          }

          else
          {
            int v23 = (os_log_s *)qword_1008F75F0;
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
            {
              uint64_t v24 = *(void *)(a1 + 96);
              *(_DWORD *)buf = 138543618;
              uint64_t v50 = v24;
              uint64_t v51 = 2114;
              uint64_t v52 = v22;
              _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Bundle %{public}@ is not allowed to access device %{public}@",  buf,  0x16u);
            }
          }

          int v21 = (char *)v21 + 1;
        }

        while (v19 != v21);
        uint64_t v19 = [v5 countByEnumeratingWithState:&v39 objects:v48 count:16];
      }

      while (v19);
    }

LABEL_44:
  }

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    int v26 = xpc_array_create(0LL, 0LL);
    unsigned int v37 = 0u;
    int v38 = 0u;
    uint64_t v35 = 0u;
    uint64_t v36 = 0u;
    int v27 = v34;
    char v28 = [v27 countByEnumeratingWithState:&v35 objects:v47 count:16];
    if (v28)
    {
      uint32_t v29 = *(void *)v36;
      do
      {
        for (uint64_t i = 0LL; i != v28; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v36 != v29) {
            objc_enumerationMutation(v27);
          }
          uint64_t v31 = sub_1004DEC38( *(void **)(*((void *)&v35 + 1) + 8LL * (void)i),  *(unsigned __int8 *)(a1 + 168),  *(_DWORD *)(a1 + 80));
          xpc_array_append_value(v26, v31);
          xpc_release(v31);
        }

        char v28 = [v27 countByEnumeratingWithState:&v35 objects:v47 count:16];
      }

      while (v28);
    }

    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v26);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), reply);
    xpc_release(reply);
    xpc_release(v26);
  }
}

          BOOL v8 = (char *)v8 + 1;
        }

        while (v6 != v8);
        uint64_t v17 = [v5 countByEnumeratingWithState:&v43 objects:v53 count:16];
        unint64_t v6 = v17;
        if (!v17) {
          goto LABEL_44;
        }
      }
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_10089D810);
    }
    uint64_t v18 = sub_1005C6C74((uint64_t)off_1008D5F28);
    uint64_t v41 = 0u;
    __int16 v42 = 0u;
    uint64_t v39 = 0u;
    int v40 = 0u;
    BOOL v5 = (id)objc_claimAutoreleasedReturnValue(v18);
    uint64_t v19 = [v5 countByEnumeratingWithState:&v39 objects:v48 count:16];
    if (v19)
    {
      uint64_t v20 = *(void *)v40;
      do
      {
        int v21 = 0LL;
        do
        {
          if (*(void *)v40 != v20) {
            objc_enumerationMutation(v5);
          }
          __int16 v22 = *(void **)(*((void *)&v39 + 1) + 8LL * (void)v21);
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089D810);
          }
          if ((sub_1005D79C0((uint64_t)off_1008D5F28, v22, *(void **)(a1 + 96), *(void **)(a1 + 48)) & 1) != 0)
          {
            [v34 addObject:v22];
          }

          else
          {
            int v23 = (os_log_s *)qword_1008F75F0;
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
            {
              uint64_t v24 = *(void *)(a1 + 96);
              *(_DWORD *)buf = 138543618;
              uint64_t v50 = v24;
              uint64_t v51 = 2114;
              uint64_t v52 = v22;
              _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "Bundle %{public}@ is not allowed to access device %{public}@",  buf,  0x16u);
            }
          }

          int v21 = (char *)v21 + 1;
        }

        while (v19 != v21);
        uint64_t v19 = [v5 countByEnumeratingWithState:&v39 objects:v48 count:16];
      }

      while (v19);
    }

LABEL_44:
  }

  reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    int v26 = xpc_array_create(0LL, 0LL);
    unsigned int v37 = 0u;
    int v38 = 0u;
    uint64_t v35 = 0u;
    uint64_t v36 = 0u;
    int v27 = v34;
    char v28 = [v27 countByEnumeratingWithState:&v35 objects:v47 count:16];
    if (v28)
    {
      uint32_t v29 = *(void *)v36;
      do
      {
        for (uint64_t i = 0LL; i != v28; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v36 != v29) {
            objc_enumerationMutation(v27);
          }
          uint64_t v31 = sub_1004DEC38( *(void **)(*((void *)&v35 + 1) + 8LL * (void)i),  *(unsigned __int8 *)(a1 + 168),  *(_DWORD *)(a1 + 80));
          xpc_array_append_value(v26, v31);
          xpc_release(v31);
        }

        char v28 = [v27 countByEnumeratingWithState:&v35 objects:v47 count:16];
      }

      while (v28);
    }

    xpc_dictionary_set_value(reply, "kCBMsgArgDevices", v26);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), reply);
    xpc_release(reply);
    xpc_release(v26);
  }
}

          if (v13)
          {
            uint64_t v17 = (os_log_s *)qword_1008F7748;
            if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109632;
              int v23 = v11;
              uint64_t v24 = 1024;
              uint64_t v25 = v12;
              int v26 = 1024;
              int v27 = v9;
              _os_log_error_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "parseGATTDescriptor Key:%d Dumped %d of %d bytes ",  buf,  0x14u);
            }

            sub_10040F8BC(a2, v13);
          }

          goto LABEL_26;
        }

        int v12 = v9;
        __int16 v13 = v9;
        if (v9 != 2) {
          goto LABEL_22;
        }
      }

      sub_10040F7FC(a2);
LABEL_26:
      unint64_t v6 = (__int16)v10 - v9;
      unsigned __int8 v7 = v6 << 16;
    }

    while ((int)(v6 << 16) > 0);
  }

  return 0LL;
}

  uint64_t v16 = 1LL;
LABEL_26:

  return v16;
}

  if ((v8 & 0x80) == 0) {
    goto LABEL_23;
  }
LABEL_24:
  sub_100024238(__p, *(void **)a3, *((void *)a3 + 1));
LABEL_25:
  uint64_t v18 = sub_1005C0684(v7, (uint64_t)__p);
  int v12 = v18;
  if (SHIBYTE(v96) < 0)
  {
    operator delete(__p[0]);
    if (!(_DWORD)v12) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }

  if ((_DWORD)v18)
  {
LABEL_29:
    sub_100241F90(buf, v5);
    sub_1005CB37C(a1, buf);
  }

        BOOL v8 = 0LL;
        goto LABEL_26;
      }

      if (!v11)
      {
        __int16 v13 = (os_log_s *)qword_1008F75B8;
        if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
        {
          LOWORD(v17) = 0;
          uint64_t v14 = "Match buffer read started";
LABEL_21:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v14, (uint8_t *)&v17, 2u);
          goto LABEL_22;
        }

        goto LABEL_22;
      }

      uint64_t v15 = (os_log_s *)qword_1008F75B8;
      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
      {
        LOWORD(v17) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "we need to reconfigure now",  (uint8_t *)&v17,  2u);
      }

      BOOL v8 = sub_1005EADD8(a1);
    }
  }

  else
  {
    unsigned __int8 v7 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
    {
      LOWORD(v17) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "This hardware does not support MatchActioRules",  (uint8_t *)&v17,  2u);
    }

    BOOL v8 = 11LL;
  }
  }
}

      uint64_t v15 = 0LL;
      goto LABEL_23;
    }
  }

  else if (v14)
  {
    goto LABEL_15;
  }

  uint64_t v15 = (id)objc_claimAutoreleasedReturnValue( +[CBAccessoryLogging getProductNameFromProductID:]( &OBJC_CLASS___CBAccessoryLogging,  "getProductNameFromProductID:",  a5));
  if (a4 == 5)
  {
    __int16 v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ In-Ear Anomaly",  v15));
    int v23 = sub_1002E95B8(@"TITLE", v22);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v23);

    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"An in-ear detection anomaly has been detected on your %@.  Would you like to file a radar?  (If you do, please keep the buds in their current state while filing.)",  v15));
    uint64_t v24 = sub_1002E95B8(@"CONTENT", v19);
    int v21 = objc_claimAutoreleasedReturnValue(v24);
    goto LABEL_29;
  }

  if (a4 == 4)
  {
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ Audio Stream Failure",  v15));
    uint64_t v17 = sub_1002E95B8(@"TITLE", v16);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);

    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"The audio stream to your %@ failed to properly start.  Would you like to file a radar?",  v15));
    uint64_t v20 = sub_1002E95B8(@"CONTENT", v19);
    int v21 = objc_claimAutoreleasedReturnValue(v20);
LABEL_29:
    uint64_t v25 = (void *)v21;

    loggingQueue = self->_loggingQueue;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1006410B4;
    block[3] = &unk_1008A4D18;
    block[4] = self;
    uint64_t v30 = v18;
    uint64_t v31 = v25;
    uint64_t v35 = v9;
    uint64_t v36 = WORD2(v9);
    uint64_t v15 = v15;
    uint64_t v34 = a4;
    int v32 = v15;
    int v33 = a5;
    int v27 = v25;
    char v28 = v18;
    dispatch_async(loggingQueue, block);

    goto LABEL_23;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_1006A098C();
  }
LABEL_23:
}

id sub_10003E0E8(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 128LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 192LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 256LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 320LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 384LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 448LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 512LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 576LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 640LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 808LL) = 1;
  *(_BYTE *)(*(void *)(a1 + 32) + 704LL) = 1;
  return [*(id *)(a1 + 32) _update];
}

void *sub_10003E8C8(void *result)
{
  uint64_t v1 = (void *)result[4];
  if (v1 == *(void **)(result[6] + 40LL))
  {
    uint64_t v2 = result;
    if (v1)
    {
      id v3 = v1;
      dispatch_source_cancel(v3);
      uint64_t v4 = v2[6];
      BOOL v5 = *(void **)(v4 + 40);
      *(void *)(v4 + 40) = 0LL;
    }

    *(_BYTE *)(v2[5] + 24LL) = 1;
    return [(id)v2[5] _update];
  }

  return result;
}

LABEL_67:
}
            }

            __int16 v13 = v63;
            uint64_t v14 = [v63 countByEnumeratingWithState:&v69 objects:v83 count:16];
          }

          while (v14);
        }
      }

      uint32_t v55 = -[NSArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v73,  v84,  16LL);
    }

    while (v55);
  }
}

            sub_1000FED78((unsigned __int16 *)*v1, qword_1008F29F0[134 * i + 14]);
            continue;
          }

          if (!sub_10008D8B4(*v1))
          {
            uint64_t v35 = v12;
            uint64_t v36 = *(unsigned __int8 *)(*v22 + ((unint64_t)v12 << 6) + 1);
            unsigned int v37 = sub_1000A86F0();
            if (v36 != 1)
            {
              if (v37)
              {
                sub_1001EE134((uint64_t)"Peripheral %i send central wish upgrade", v38, v39, v40, v41, v42, v43, v44, i);
                int v54 = (os_log_s *)sub_100086554(0x57u);
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                {
LABEL_70:
                  uint32_t v66 = sub_1001EDDCC();
                  *(_DWORD *)buf = 136446210;
                  int v78 = v66;
                  _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                }
              }

              goto LABEL_72;
            }

            if (v37)
            {
              sub_1001EE134((uint64_t)"Peripheral %i send central wish downgrade", v38, v39, v40, v41, v42, v43, v44, i);
              int v45 = (os_log_s *)sub_100086554(0x57u);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_66;
              }
            }

            goto LABEL_67;
          }
        }
      }
    }
  }

          if (!*v40) {
            goto LABEL_72;
          }
          if ((*((unsigned __int16 *)a4 + 6) & ~*(_DWORD *)(v12 + 248)) != 0)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"Incomplete request", v50, v51, v52, v53, v54, v55, v56, v58);
              uint64_t v57 = (os_log_s *)sub_100086554(6u);
              if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
                sub_100657858();
              }
            }

            return 1741LL;
          }

          if (*(void *)(v12 + 232)) {
            sub_1001EE2A0();
          }
          uint64_t v41 = sub_1000B1814(0x30uLL);
          int v27 = 0;
          *(void *)(v12 + 232) = v41;
          *(_DWORD *)(v12 + 12) = 3;
LABEL_38:
          *(_DWORD *)(v12 + 16) = v27;
          int v11 = sub_100171094(v12, a3);
          if ((_DWORD)v11)
          {
            char v28 = *(void **)(v12 + 232);
            if (v28)
            {
              sub_1000B1838(v28);
              *(void *)(v12 + 232) = 0LL;
            }

            *(_DWORD *)(v12 + 12) = 2;
          }

          return v11;
        }

LABEL_69:
  id v10 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 152LL))(v10))
  {
    memset(&buf, 0, sizeof(buf));
    int v26 = 0;
    sub_10002418C(&v29, "Diversity");
    sub_10002418C(v27, "Diversity2GThresholOverride");
    *(_BYTE *)(a1 + 172) = (*(uint64_t (**)(uint64_t, std::string *, void **, std::string *))(*(void *)a1 + 56LL))( a1,  &v29,  v27,  &buf);
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    if (*(_BYTE *)(a1 + 172))
    {
      sub_10002418C(&v29, "Diversity");
      sub_10002418C(v27, "Diversity2GRSSIThreshold");
      int v11 = (*(uint64_t (**)(uint64_t, std::string *, void **, int *))(*(void *)a1 + 88LL))( a1,  &v29,  v27,  &v26);
      if (v28 < 0) {
        operator delete(v27[0]);
      }
      if (v11) {
        *(_BYTE *)(a1 + 173) = v26;
      }
    }

    sub_10002418C(&v29, "Diversity");
    sub_10002418C(v27, "Diversity5GThresholdOverride");
    *(_BYTE *)(a1 + 174) = (*(uint64_t (**)(uint64_t, std::string *, void **, std::string *))(*(void *)a1 + 56LL))( a1,  &v29,  v27,  &buf);
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    if (*(_BYTE *)(a1 + 174))
    {
      sub_10002418C(&v29, "Diversity");
      sub_10002418C(v27, "Diversity5GRSSIThreshold");
      int v12 = (*(uint64_t (**)(uint64_t, std::string *, void **, int *))(*(void *)a1 + 88LL))( a1,  &v29,  v27,  &v26);
      if (v28 < 0) {
        operator delete(v27[0]);
      }
      if (v12) {
        *(_BYTE *)(a1 + 175) = v26;
      }
    }
  }

  __int16 v13 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 160LL))(v13))
  {
    memset(&buf, 0, sizeof(buf));
    *(_DWORD *)(a1 + 232) = 0;
    sub_10002418C(&v29, "Diversity");
    sub_10002418C(v27, "BeamformingLogMode");
    *(_BYTE *)(a1 + 22_Block_object_dispose(va, 8) = (*(uint64_t (**)(uint64_t, std::string *, void **, std::string *))(*(void *)a1 + 56LL))( a1,  &v29,  v27,  &buf);
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    if (!*(_BYTE *)(a1 + 228)) {
      goto LABEL_109;
    }
    if (!std::string::compare(&buf, "BF_MRC_LOG_ENABLED"))
    {
      *(_DWORD *)(a1 + 232) = 1;
      uint64_t v14 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_109;
      }
      LOWORD(v29.__r_.__value_.__l.__data_) = 0;
      uint64_t v15 = "Beamforming log mode override: Log enabled";
    }

    else if (!std::string::compare(&buf, "BF_MRC_LOG_DISABLED"))
    {
      *(_DWORD *)(a1 + 232) = 0;
      uint64_t v14 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_109;
      }
      LOWORD(v29.__r_.__value_.__l.__data_) = 0;
      uint64_t v15 = "Beamforming log mode override: Log disabled";
    }

    else
    {
      *(_BYTE *)(a1 + 22_Block_object_dispose(va, 8) = 0;
      uint64_t v14 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_109;
      }
      LOWORD(v29.__r_.__value_.__l.__data_) = 0;
      uint64_t v15 = "Warning: Beamforming log mode override: Invalid. VSE Logging disabled.";
    }

    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v29, 2u);
LABEL_109:
  }

  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 0;
  sub_10002418C(&buf, "Diversity");
  sub_10002418C(&v29, "DiversityPeripheralOverride");
  (*(void (**)(uint64_t, std::string *, std::string *, uint64_t))(*(void *)a1 + 72LL))( a1,  &buf,  &v29,  a1 + 108);
  if (*(_BYTE *)(a1 + 108))
  {
    uint64_t v16 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Diversity peripheral override: Enabled.  Diversity can now be enabled when role is peripheral.",  (uint8_t *)&buf,  2u);
    }
  }

  *(_BYTE *)(a1 + 109) = 0;
  sub_10002418C(&buf, "Diversity");
  sub_10002418C(&v29, "DiversityCoexLogEnabled");
  (*(void (**)(uint64_t, std::string *, std::string *, uint64_t))(*(void *)a1 + 72LL))( a1,  &buf,  &v29,  a1 + 109);
  if (*(_BYTE *)(a1 + 109))
  {
    uint64_t v17 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Diversity coex log: Enabled",  (uint8_t *)&buf,  2u);
    }
  }

  memset(&v29, 0, sizeof(v29));
  *(_DWORD *)(a1 + 112) = 3;
  sub_10002418C(&buf, "Diversity");
  sub_10002418C(v27, "DiversityCoexCellOverride");
  *(_BYTE *)(a1 + 110) = (*(uint64_t (**)(uint64_t, std::string *, void **, std::string *))(*(void *)a1 + 56LL))( a1,  &buf,  v27,  &v29);
  if (v28 < 0) {
    operator delete(v27[0]);
  }
  if (*(_BYTE *)(a1 + 110))
  {
    if (!std::string::compare(&v29, "CELL_OFF"))
    {
      *(_DWORD *)(a1 + 112) = 0;
      uint64_t v18 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v19 = "Diversity coex cell override: Cell off";
        goto LABEL_145;
      }
    }

    else if (!std::string::compare(&v29, "CELL_ON_ANT_0"))
    {
      *(_DWORD *)(a1 + 112) = 1;
      uint64_t v18 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v19 = "Diversity coex cell override: Cell on antenna 0";
        goto LABEL_145;
      }
    }

    else if (!std::string::compare(&v29, "CELL_ON_ANT_1"))
    {
      *(_DWORD *)(a1 + 112) = 2;
      uint64_t v18 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v19 = "Diversity coex cell override: Cell on antenna 1";
        goto LABEL_145;
      }
    }

    else if (!std::string::compare(&v29, "DISABLED"))
    {
      *(_DWORD *)(a1 + 112) = 3;
      uint64_t v18 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v19 = "Diversity coex cell override: Disabled";
        goto LABEL_145;
      }
    }

    else
    {
      *(_BYTE *)(a1 + 110) = 0;
      uint64_t v18 = (os_log_s *)qword_1008F7578;
      if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v19 = "Warning: Diversity coex cell override: Invalid.  Override disabled.";
LABEL_145:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&buf, 2u);
      }
    }
  }

  sub_1002C9734(a1, "DiversityCoexAFHMapOverride", (_BYTE *)(a1 + 116), a1 + 117, (uint64_t)"AFH map");
  sub_1002C9734(a1, "DiversityCoexHAAMapC0B0Override", (_BYTE *)(a1 + 128), a1 + 129, (uint64_t)"HAA map C0B0");
  sub_1002C9734(a1, "DiversityCoexHAAMapC0B1Override", (_BYTE *)(a1 + 139), a1 + 140, (uint64_t)"HAA map C0B1");
  uint64_t v20 = (_BYTE *)(a1 + 150);
  sub_1002C9734(a1, "DiversityCoexHAAMapC1B0Override", (_BYTE *)(a1 + 150), a1 + 151, (uint64_t)"HAA map C1B0");
  sub_1002C9734(a1, "DiversityCoexHAAMapC1B1Override", (_BYTE *)(a1 + 161), a1 + 162, (uint64_t)"HAA map C1B1");
  int v21 = sub_1002E6E9C();
  if ((*(unsigned int (**)(uint64_t, void, void, void, uint64_t))(*(void *)v21 + 920LL))( v21,  *(unsigned __int8 *)(a1 + 109),  *(unsigned int *)(a1 + 112),  *(unsigned __int8 *)(a1 + 116),  a1 + 117)
    && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_100668D54();
  }

  if (*(_BYTE *)(a1 + 128))
  {
    if (*(_BYTE *)(a1 + 139) && *v20)
    {
      __int16 v22 = *(unsigned __int8 *)(a1 + 161);
      *(_BYTE *)(a1 + 127) = v22;
      if (v22)
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 2) = *(void *)(a1 + 129);
        WORD1(buf.__r_.__value_.__r.__words[1]) = *(_WORD *)(a1 + 137);
        WORD2(buf.__r_.__value_.__r.__words[1]) = 256;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = *(void *)(a1 + 140);
        HIWORD(buf.__r_.__value_.__r.__words[2]) = *(_WORD *)(a1 + 148);
        int v33 = 512;
        uint64_t v34 = *(void *)(a1 + 151);
        uint64_t v35 = *(_WORD *)(a1 + 159);
        uint64_t v36 = 768;
        int v23 = *(void *)(a1 + 162);
        int v38 = *(_WORD *)(a1 + 170);
        unsigned int v37 = v23;
        uint64_t v24 = sub_1002E6E9C();
        if ((*(unsigned int (**)(uint64_t, uint64_t, std::string *))(*(void *)v24 + 912LL))(v24, 4LL, &buf)
          && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
        {
          sub_100668D28();
        }

        goto LABEL_162;
      }
    }

    else
    {
      *(_BYTE *)(a1 + 127) = 0;
    }

  v134 = v35;
  uint64_t v39 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v39 + 160LL))(v39) && (int v40 = *(_DWORD *)(a2 + 60)) != 0)
  {
    LODWORD(v2) = vcvtas_u32_f32((float)((float)v40 * 100.0) / (float)(*(_DWORD *)(a2 + 36) + v40 + *(_DWORD *)(a2 + 40)));
    if (!v4) {
      goto LABEL_79;
    }
  }

  else
  {
    uint64_t v2 = 0LL;
    if (!v4)
    {
LABEL_79:
      BOOL v43 = 0LL;
      v138 = @"Unknown";
      goto LABEL_80;
    }
  }

  sub_1003D930C(v4, 0xAu, buf);
  if (v150[7] >= 0) {
    uint64_t v41 = buf;
  }
  else {
    uint64_t v41 = *(uint8_t **)buf;
  }
  __int16 v42 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v41));
  if ((v150[7] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  v138 = (__CFString *)v42;
  BOOL v43 = 1LL;
LABEL_80:
  v133 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%dms",  *(void *)(a2 + 224)));
  int v45 = *(_DWORD *)(a2 + 240);
  uint64_t v44 = *(_DWORD *)(a2 + 244);
  if (*(void *)(a2 + 240))
  {
    int v46 = (double)(v44 + v45);
    LODWORD(v97) = ((double)v44 / v46 * 100.0);
    HIDWORD(v97) = ((double)v45 / v46 * 100.0);
  }

  else
  {
    v97 = 0LL;
  }

  int v47 = *(void *)(a2 + 280);
  if (v47) {
    int v48 = vmovn_s64((int64x2_t)vcvtq_u64_f64( vmulq_f64( vdivq_f64( vcvtq_f64_u64(*(uint64x2_t *)(a2 + 264)),  (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v47), 0)),  (float64x2_t)vdupq_n_s64(0x4059000000000000uLL))));
  }
  else {
    int v48 = 0LL;
  }
  v132 = v48;
  uint64_t v49 = *(void *)(a2 + 296);
  if (v49) {
    v96 = ((double)*(unint64_t *)(a2 + 288) / (double)v49 * 100.0);
  }
  else {
    v96 = 0;
  }
  uint64_t v50 = *(unsigned int *)(a2 + 232);
  sub_1002F6A2C(a1);
  uint64_t v51 = (os_log_s *)(id)qword_1008F7578;
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v52 = *(_DWORD *)(a2 + 172);
    __int16 v53 = *(int *)(a2 + 200);
    if ((_DWORD)v53) {
      __int16 v53 = *(void *)(a2 + 192) / v53;
    }
    uint32_t v55 = *(_DWORD *)(a2 + 216);
    int v54 = *(_DWORD *)(a2 + 220);
    uint64_t v56 = *(_DWORD *)(a2 + 240);
    uint64_t v57 = *(_DWORD *)(a2 + 244);
    *(_DWORD *)buf = 67112192;
    *(_DWORD *)&uint8_t buf[4] = v52;
    v147 = 1024;
    v148 = v128;
    v149 = 1024;
    *(_DWORD *)v150 = v130;
    *(_WORD *)&v150[4] = 1024;
    *(_DWORD *)&v150[6] = v126;
    *(_WORD *)v151 = 1024;
    *(_DWORD *)&v151[2] = 0;
    v152 = 1024;
    v153 = v5;
    v154 = 1024;
    v155 = v124;
    v156 = 1024;
    v157 = v94;
    v158 = 1024;
    v159 = v53;
    v160 = 1024;
    v161 = v54;
    v162 = 1024;
    v163 = v55;
    v164 = 1024;
    v165 = v56;
    v166 = 1024;
    v167 = v57;
    _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "Sending HFPLinkQuality stats: Codec = %u, DurationInMinutes = %u, PlcUsage = %u, MissingSCORate = %u, SilenceCycle Rate = %u,[TotalFrameCount = %u, ExpectedSCOCount = %u, MissingSCOCount = %u] RssiAverage = %d, ReTransmission_RX = %u, ReTransmission_TX = %u 2GDurationSecs = %u 5GDurationSecs = %u",  buf,  0x50u);
  }

  v144[0] = @"AvgMaxGoodPcktsPerSwitch";
  v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v134.u32[0]));
  v145[0] = v95;
  v144[1] = @"AvgMinGoodPcktsPerSwitch";
  v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v134.u32[1]));
  v145[1] = v93;
  v144[2] = @"AvgPacketsPerSwitch";
  v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v34));
  v145[2] = v92;
  v144[3] = @"AvgSwitchesPerSecond";
  v135 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v33));
  v145[3] = v135;
  v144[4] = @"BtRole";
  v91 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *(unsigned __int8 *)(a2 + 161)));
  v145[4] = v91;
  v144[5] = @"CallCreationTime";
  v90 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a2 + 224)));
  v145[5] = v90;
  v145[6] = v122;
  v144[6] = @"CallType";
  v144[7] = @"Codec";
  v89 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a2 + 172)));
  v145[7] = v89;
  v144[8] = @"CpuNorm";
  int v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v23));
  v145[8] = v88;
  v144[9] = @"Desense";
  v125 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 0LL));
  v145[9] = v125;
  v144[10] = @"DurationInMinutes";
  __int16 v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v128));
  v145[10] = v87;
  v144[11] = @"EpaCallTimeRatio";
  int v86 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v120));
  v145[11] = v86;
  v144[12] = @"EpaPacketRatio";
  __int16 v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v118));
  v145[12] = v85;
  v145[13] = v133;
  v144[13] = @"eSCOCreationTime";
  v144[14] = @"eSCOSetupFailure";
  int v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v50));
  v145[14] = v84;
  v145[15] = v138;
  v144[15] = @"FWVersion";
  v144[16] = @"HDRSession";
  v129 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(a2 + 236)));
  v145[16] = v129;
  v144[17] = @"IsAppleAudioDevice";
  __int16 v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v43));
  v145[17] = v83;
  v144[18] = @"MissingSCORate";
  int v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v126));
  v145[18] = v82;
  v144[19] = @"NoiseFloor50Max";
  __int16 v81 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 4)));
  v145[19] = v81;
  v144[20] = @"NoiseFloor50Percentile";
  v117 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v116));
  v145[20] = v117;
  v144[21] = @"NoiseFloor90Max";
  v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 20)));
  v145[21] = v127;
  v144[22] = @"NoiseFloor90Percentile";
  v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v114));
  v145[22] = v115;
  v144[23] = @"NoiseFloorAverageGoodChannels";
  v113 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v112));
  v145[23] = v113;
  v144[24] = @"PercentPacketsAnt0";
  v111 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v110));
  v145[24] = v111;
  v144[25] = @"PercentPacketsAnt1";
  v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v108));
  v145[25] = v109;
  v144[26] = @"PercentPacketsTxBF";
  v123 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v2));
  v145[26] = v123;
  v144[27] = @"PlcUsage";
  int v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v130));
  v145[27] = v80;
  v144[28] = @"ProductID";
  __int16 v79 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v142));
  v145[28] = v79;
  v144[29] = @"RssiAverage";
  int v58 = *(int *)(a2 + 200);
  if ((_DWORD)v58) {
    uint64_t v59 = *(void *)(a2 + 192) / v58;
  }
  else {
    uint64_t v59 = 0LL;
  }
  int v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v59));
  v145[29] = v78;
  v144[30] = @"RssiMax";
  int v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 208)));
  v145[30] = v77;
  v144[31] = @"RssiMin";
  v131 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a2 + 204)));
  v145[31] = v131;
  v144[32] = @"ReTransmission_RX";
  int v76 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a2 + 220)));
  v145[32] = v76;
  v144[33] = @"ReTransmission_TX";
  int v75 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a2 + 216)));
  v145[33] = v75;
  v144[34] = @"RxNormFirstRXWindow";
  v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v104));
  v145[34] = v105;
  v144[35] = @"RxNormSecondRXWindow";
  v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v102));
  v145[35] = v103;
  v145[36] = v136;
  v144[36] = @"SanitizedDeviceName";
  v144[37] = @"SessionType";
  v145[37] = v106;
  v144[38] = @"SilenceCycleRate";
  v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 0LL));
  v145[38] = v121;
  v144[39] = @"TxNormFirstTXWindow";
  v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v100));
  v145[39] = v107;
  v144[40] = @"TxNormSecondTXWindow";
  v101 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v98));
  v145[40] = v101;
  v144[41] = @"VendorID";
  v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v143));
  v145[41] = v99;
  v144[42] = @"VersionIDSource";
  char v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", HIDWORD(v143)));
  v145[42] = v74;
  v144[43] = @"Version";
  v119 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", HIDWORD(v142)));
  v145[43] = v119;
  v144[44] = @"Interval_Bin_00_7point5ms";
  int v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a1[532]));
  v145[44] = v73;
  v144[45] = @"Interval_Bin_01_11point25ms";
  int v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a1[533]));
  v145[45] = v72;
  v144[46] = @"Interval_Bin_02_15ms";
  int v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a1[534]));
  v145[46] = v71;
  v144[47] = @"Interval_Bin_Other";
  BOOL v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  a1[530] + a1[531] - (a1[532] + a1[533] + a1[534])));
  v145[47] = v60;
  v144[48] = @"BTBand";
  else {
    int v61 = *(void *)(a2 + 136);
  }
  uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v61));
  v145[48] = v62;
  v144[49] = @"TipiConnected";
  int v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a2 + 160)));
  v145[49] = v63;
  v144[50] = @"IsAoSCall";
  int v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a2 + 237)));
  v145[50] = v64;
  v144[51] = @"2GDurationPercentage";
  int v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", HIDWORD(v97)));
  v145[51] = v65;
  v144[52] = @"5GDurationPercentage";
  uint32_t v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v97));
  v145[52] = v66;
  v144[53] = @"TxFlushPercentage";
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v132.u32[0]));
  v145[53] = v67;
  v144[54] = @"TxConsecFlushPercentage";
  uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v132.u32[1]));
  v145[54] = v68;
  v144[55] = @"RxCRCErrorPercentage";
  int v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v96));
  v145[55] = v69;
  BOOL v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v145,  v144,  56LL));

  sub_1002EFD68((uint64_t)a1, 0x57u, v70);
}

          int v46 = (os_log_s *)qword_1008F7680;
          if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_INFO))
          {
            int v47 = *(NSKeyedUnarchiver **)(a1 + 88);
            int v48 = *(void *)(a1 + 96);
            uint64_t v49 = *(void *)(a1 + 312);
            if (*(_BYTE *)(a1 + 272)) {
              uint64_t v50 = "True";
            }
            else {
              uint64_t v50 = "False";
            }
            if (*(_BYTE *)(a1 + 274)) {
              uint64_t v51 = "YES";
            }
            else {
              uint64_t v51 = "NO";
            }
            *(_DWORD *)buf = 138544642;
            uint64_t v68 = v47;
            int v69 = 2114;
            *(void *)BOOL v70 = v48;
            *(_WORD *)&v70[8] = 2114;
            int v71 = v49;
            int v72 = 2114;
            int v73 = v32;
            char v74 = 2082;
            int v75 = v50;
            int v76 = 2082;
            int v77 = v51;
            _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_INFO,  "Central Restoring - bundleId %{public}@, restorationId: %{public}@, servicesToScan: %{public}@, peripheral s: %{public}@, isScanning: %{public}s, fIsContactTracingScanning:%{public}s",  buf,  0x3Eu);
          }

          *(_BYTE *)(a1 + 209) = 1;

          uint64_t v15 = 1LL;
        }
      }

      else
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_ERROR)) {
          sub_100675EF8();
        }
        uint64_t v15 = 0LL;
      }

      id v3 = v56;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_ERROR)) {
        sub_100675E98();
      }
      uint64_t v15 = 0LL;
    }
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  return v15;
}

  uint64_t v31 = (os_log_s *)qword_1008F7598;
  if (os_log_type_enabled((os_log_t)qword_1008F7598, OS_LOG_TYPE_DEFAULT))
  {
    int v32 = HIWORD(v43);
    int v33 = sub_1002075F4(a2 + 400);
    uint64_t v34 = sub_1002075D4(a2 + 400);
    uint64_t v35 = sub_10020761C(a2 + 400);
    *(_DWORD *)buf = 67110144;
    int v46 = v32;
    int v47 = 1024;
    int v48 = 625 * v33;
    uint64_t v49 = 1024;
    *(_DWORD *)uint64_t v50 = v34;
    *(_WORD *)&v50[4] = 1024;
    *(_DWORD *)&v50[6] = v35;
    uint64_t v51 = 1024;
    uint64_t v52 = (unsigned __int16)v43;
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "Creating HF SendThread: HCI %d length, OTA interval %d us, %d bytes, and bt clk 0x%x numScoBuffers %d",  buf,  0x20u);
  }

  uint64_t v36 = sub_1002073A4(a2 + 400);
  unsigned int v37 = HIWORD(v43);
  int v38 = sub_1002075D4(a2 + 400);
  uint64_t v39 = (unsigned __int16)v43;
  int v40 = sub_10020755C(a2 + 400);
  sub_100502414(a2, a1, v36, v37, v38, v39, v40);
  sub_100242CD8(&v42);
  return sub_100242FAC((uint64_t)v44);
}

  return v20;
}

LABEL_77:
}

      v93 = v122;
      v92 = v124;
      goto LABEL_78;
    }

    BOOL v60 = *(unsigned __int16 *)&a2[v57];
    if (v54)
    {
      int v61 = *(void *)(v53 + 8);
      if (*(_DWORD *)(v61 + 40) == (_DWORD)v60)
      {
        uint64_t v62 = 0;
LABEL_43:
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"serviceID:%d already registered", v66, v67, v68, v69, v70, v71, v72, v60);
          int v73 = (os_log_s *)sub_100086554(0x51u);
          if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
          {
            v90 = sub_1001EDDCC();
            *(_DWORD *)buf = 136446466;
            v128 = v90;
            v129 = 1024;
            v130 = 0xFFFF;
            _os_log_error_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
          }
        }

        uint64_t v56 = v126;
        if (!v62) {
          goto LABEL_66;
        }
      }

      else
      {
        int v63 = 0LL;
        int v64 = (int *)(v61 + 128);
        while (v54 - 1LL != v63)
        {
          int v65 = *v64;
          v64 += 22;
          ++v63;
          if (v65 == (_DWORD)v60)
          {
            uint64_t v62 = v63 >= v54;
            goto LABEL_43;
          }
        }
      }
    }

    if (word_1008DD568)
    {
      char v74 = 0LL;
      int v75 = &byte_1008DD587;
      while (*(unsigned __int16 *)(v75 - 5) != (_DWORD)v60)
      {
        ++v74;
        v75 += 72;
      }

      int v76 = *(v75 - 7) | v124;
      v124 = v76 != 0;
      int v77 = *(void *)(*((void *)&xmmword_1008DD4E8 + v41) + 8LL) + 88LL * v54;
      *(_DWORD *)(v77 + 40) = v60;
      int v78 = *(v75 - 15);
      else {
        __int16 v79 = *(v75 - 15);
      }
      *(_DWORD *)(v77 + 32) = v79;
      *(_DWORD *)(v77 + 36) = *(_DWORD *)(v75 - 11);
      *(void *)(v77 + 44) = 0x100000001LL;
      memmove((void *)v77, *(const void **)(v75 - 23), v78);
      int v80 = *(void *)(*((void *)&xmmword_1008DD4E8 + v41) + 8LL);
      __int16 v81 = v80 + 88LL * v54;
      *(_BYTE *)(v81 + 54) = *(v75 - 3);
      *(_BYTE *)(v81 + 55) = *(v75 - 7);
      *(_WORD *)(v81 + 56) = *(_WORD *)(v75 - 1);
      if (v76)
      {
        if (!sub_10008D900(a1) || (sub_1001CBF3C((_DWORD *)(a1 + 48)) & 1) != 0)
        {
          int v58 = v125;
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"We require encryption on a common service - delaying connection to this service.",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  v121);
            v89 = (os_log_s *)sub_100086554(0x51u);
            if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
            {
              v91 = sub_1001EDDCC();
              *(_DWORD *)buf = 136446466;
              v128 = v91;
              v129 = 1024;
              v130 = 0xFFFF;
              _os_log_error_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
            }
          }

          uint64_t v56 = v126;
          goto LABEL_65;
        }

        int v80 = *(void *)(*((void *)&xmmword_1008DD4E8 + v41) + 8LL);
      }

      int v58 = v125;
      uint64_t v56 = v126;
      v123[v122++] = v80 + 88LL * v54;
LABEL_65:
      ++v54;
    }

          *((void *)v36 + _Block_object_dispose(va, 8) = 0LL;
          uint64_t result = 0.0;
          *((_OWORD *)v36 + 2) = 0u;
          *((_OWORD *)v36 + 3) = 0u;
          *(_OWORD *)uint64_t v36 = 0u;
          *((_OWORD *)v36 + 1) = 0u;
          return result;
        case 2:
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"BT_AAP_DISCONNECT_RSP from l2capRecvDataInd for cid=%d",  v68,  v69,  v70,  v71,  v72,  v73,  v74,  a1);
            int v75 = (os_log_s *)sub_100086554(0x52u);
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
            {
              int v76 = sub_1001EDDCC();
              *(_DWORD *)buf = 136446210;
              v118 = v76;
              _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
            }
          }

          sub_1000B553C(a1 | ((_DWORD)v18 << 16));
          else {
            int v77 = a2[2];
          }
          sub_1000B55E0(v18, a1, v77);
          return result;
        case 3:
          int v78 = (unsigned __int16)v36[1];
          if (__PAIR64__(v78, (unsigned __int16)*v36) == __PAIR64__(a1, v18))
          {
            __int16 v79 = *(void *)&word_1008DEBF0[v15 + 8];
            if (v79)
            {
              int v80 = *(void (**)(void, unsigned __int16 *, void))(v79 + 32);
              if (v80) {
                v80(v78 | ((_DWORD)v18 << 16), a2 + 2, v16);
              }
            }
          }

          return result;
        default:
          if (sub_1000A86F0())
          {
            sub_1001EE134((uint64_t)"Should not be here", v39, v40, v41, v42, v43, v44, v45, v115);
            int v46 = (os_log_s *)sub_100086554(0x52u);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
              goto LABEL_15;
            }
          }

          return result;
      }
    }

    v15 += 36LL;
  }

  while (v15 != 1080);
  sub_1001EE134((uint64_t)"Incoming message to invalid cid/sid (%d/%d)", v19, v20, v21, v22, v23, v24, v25, v18);
  int v26 = (os_log_s *)sub_100086554(0x52u);
  if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
    return result;
  }
LABEL_4:
  sub_100657858();
  return result;
}

      sub_100185420(v7, 37);
      return;
  }

  *(_OWORD *)(v7 + 104) = *a2;
  if (!*(_BYTE *)(a1 + 70))
  {
    v118 = sub_1001D4A70(*(void *)v7, (__int128 *)(v7 + 457));
    if (!(_DWORD)v118) {
      goto LABEL_77;
    }
    v119 = v118;
    sub_1001EE134((uint64_t)"smpSendPairingRandom failed %!", v120, v121, v122, v123, v124, v125, v126, v119);
    v127 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v127, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
LABEL_76:
    sub_100657F74();
    goto LABEL_23;
  }

  if (*(_BYTE *)(v7 + 490))
  {
    if (*(void *)(v7 + 104) || *(void *)(v7 + 112) != 0LL)
    {
      int v71 = sub_1001D4718((uint64_t *)v7);
      if ((_DWORD)v71)
      {
        int v72 = v71;
        sub_1001EE134( (uint64_t)"recvdSMPDoSecuredConnectionPasskeySendCai failed %!",  v73,  v74,  v75,  v76,  v77,  v78,  v79,  v72);
        int v80 = (os_log_s *)sub_100086554(0x43u);
        if (!os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
          goto LABEL_23;
        }
        goto LABEL_76;
      }
    }
  }

      uint64_t v49 = read(*(_DWORD *)(a3 + 200), *(void **)buf, v94);
      uint64_t v50 = v49;
      if (v49 < 1)
      {
        if (v49)
        {
          if (*__error() == 35)
          {
            if (v39)
            {
              LOBYTE(v96) = 0;
              sub_100242CA4(&v96);
              sub_1001031D4(*(void **)buf);
              sub_100242CD0(&v96);
              sub_100242CD8(&v96);
            }

            return 1LL;
          }

          if (os_log_type_enabled((os_log_t)qword_1008F75F8, OS_LOG_TYPE_ERROR)) {
            sub_100663DB4();
          }
        }

        else
        {
          int v58 = (os_log_s *)qword_1008F75F8;
          if (os_log_type_enabled((os_log_t)qword_1008F75F8, OS_LOG_TYPE_ERROR)) {
            sub_100663D50(a2, v58, v59, v60, v61, v62, v63, v64);
          }
        }

        if (v39)
        {
          LOBYTE(v96) = 0;
          sub_100242CA4(&v96);
          sub_1001031D4(*(void **)buf);
          sub_100242CD0(&v96);
          sub_100242CD8(&v96);
        }

        return 0LL;
      }

      if (a1[139])
      {
        uint64_t v51 = *(unsigned __int8 **)buf;
        uint64_t v52 = v94;
        __int16 v53 = sub_1001859B4(a2);
        sub_100253658(v53, v51, v52, v53, 0, a1[140]);
      }

      int v76 = 0;
      sub_100242CA4(&v76);
      int v54 = *(_DWORD *)(a3 + 372);
      if (v54 == 2)
      {
        uint32_t v55 = sub_1001D9F64((uint64_t)sub_10025399C, a2, *(char **)buf, v50);
      }

      else if (v54 == 1)
      {
        uint32_t v55 = sub_100172DA0((uint64_t)sub_10025399C, a2, 0LL, *(char **)buf, v50);
      }

      else
      {
        if (v54) {
          goto LABEL_87;
        }
        uint32_t v55 = sub_10008F3E4((uint64_t)sub_10025399C, *(__int128 **)(a3 + 112), a2, *(char **)buf, v50, v39);
      }

      int v38 = v55;
LABEL_87:
      sub_100242CD0(&v76);
      if (v38)
      {
        if (v38 != 412)
        {
          uint64_t v56 = (os_log_s *)qword_1008F75F8;
          if (os_log_type_enabled((os_log_t)qword_1008F75F8, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v96) = 67109376;
            DWORD1(v96) = a2;
            WORD4(v96) = 1024;
            *(_DWORD *)((char *)&v96 + 10) = v38;
            _os_log_error_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_ERROR,  "Failed to transmit data from socket on pipe 0x%04x with result %{bluetooth:OI_STATUS}u",  (uint8_t *)&v96,  0xEu);
          }
        }
      }

      sub_100242CD8(&v76);
      if (v38 != 412) {
        return 0LL;
      }
    }

    else {
      uint64_t v41 = *(unsigned __int16 *)(a3 + 376);
    }
    LODWORD(v94) = v41;
    __int16 v42 = qword_1008F75F8;
    if (os_log_type_enabled((os_log_t)qword_1008F75F8, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v43 = *(_DWORD *)(a3 + 364);
      LODWORD(v96) = 67109376;
      DWORD1(v96) = v41;
      WORD4(v96) = 1024;
      *(_DWORD *)((char *)&v96 + 10) = v43;
      uint64_t v44 = (os_log_s *)v42;
      int v45 = "MAX buffer size for the RFCOMM Channel is %d getWriteBufferUsed=%d";
      goto LABEL_74;
    }

      v11 += 32;
      v10 += 2LL;
      if (v10 >= v9)
      {
        unint64_t v6 = *((void *)&v92 + 1);
        goto LABEL_79;
      }
    }

    uint64_t v19 = *v11;
    uint64_t v20 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v90 = 67109120;
      *(_DWORD *)&v90[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RFCOMM CID: %d", v90, 8u);
    }

    memset(v90, 0, sizeof(v90));
    v91 = 0LL;
    sub_10002418C(v90, "RFCOMM ServiceClass: ");
    memset(&v73, 0, sizeof(v73));
    if (v74 == 3)
    {
      if (WORD1(v74) > 4u)
      {
        int v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  *((void *)&v74 + 1)));
        int v33 = (os_log_s *)qword_1008F7578;
        if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v32;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "service long UUID: %@", buf, 0xCu);
        }

        uint64_t v34 = *(void **)(a1 + 1304);
        v76[0] = @"kCBMsgArgServiceUUID";
        v76[1] = @"kCBMsgArgRFCOMMChannelID";
        v77[0] = v32;
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v19, v68));
        v77[1] = v35;
        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v77,  v76,  2LL));
        [v34 addObject:v36];

        unsigned int v37 = sub_1001EB74C(*((unsigned int **)&v74 + 1));
        std::string::assign(&v73, v37);
      }

      else
      {
        if (WORD1(v74) == 2)
        {
          LOWORD(__p[0]) = bswap32(WORD4(v74)) >> 16;
          int v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", __p, 2LL));
          __int16 v22 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)&uint8_t buf[4] = DWORD2(v74);
            *(_WORD *)&uint8_t buf[8] = 2112;
            *(void *)&buf[10] = v21;
            _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "service short UUID: (0x%x) %@",  buf,  0x12u);
          }

          int v23 = *(void **)(a1 + 1304);
          v80[0] = @"kCBMsgArgServiceUUID";
          v80[1] = @"kCBMsgArgRFCOMMChannelID";
          v81[0] = v21;
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v19,  v68));
          v81[1] = v24;
          uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v81,  v80,  2LL));
          [v23 addObject:v25];
        }

        else
        {
          LODWORD(__p[0]) = bswap32(DWORD2(v74));
          uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", __p));
          uint64_t v51 = (os_log_s *)qword_1008F7578;
          if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)&uint8_t buf[4] = DWORD2(v74);
            *(_WORD *)&uint8_t buf[8] = 2112;
            *(void *)&buf[10] = v50;
            _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "service short UUID: (0x%x) %@",  buf,  0x12u);
          }

          uint64_t v52 = *(void **)(a1 + 1304);
          v78[0] = @"kCBMsgArgServiceUUID";
          v78[1] = @"kCBMsgArgRFCOMMChannelID";
          v79[0] = v50;
          __int16 v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v19,  v68));
          v79[1] = v53;
          int v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v79,  v78,  2LL));
          [v52 addObject:v54];
        }

        uint32_t v55 = sub_1001EBA4C(DWORD2(v74));
        std::string::assign(&v73, v55);
      }

      uint64_t v4 = (v4 + 1);
    }

    memset(buf, 0, 24);
    sub_10002418C(buf, "\n");
    __p[0] = 0LL;
    __p[1] = 0LL;
    cap = 0LL;
    sub_1003D4034((const void **)v90, (const void **)&v73.__r_.__value_.__l.__data_, &v82);
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v56 = buf;
    }
    else {
      uint64_t v56 = *(uint8_t **)buf;
    }
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v57 = buf[23];
    }
    else {
      uint64_t v57 = *(void *)&buf[8];
    }
    int v58 = std::string::append(&v82, (const std::string::value_type *)v56, v57);
    uint64_t v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    cap = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)__p = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    int v48 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v49 = __p;
      if (cap < 0) {
        uint64_t v49 = (void **)__p[0];
      }
LABEL_68:
      LODWORD(v82.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v82.__r_.__value_.__r.__words + 4) = (std::string::size_type)v49;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v82, 0xCu);
    }

  if (v13)
  {
    unsigned int v37 = v13;
    operator delete(v13);
  }

  if (v39)
  {
    int v40 = (__int128 *)v39;
    operator delete(v39);
  }

      int v73 = (os_log_s *)qword_1008F76E8;
      uint64_t v41 = 0LL;
      if (os_log_type_enabled((os_log_t)qword_1008F76E8, OS_LOG_TYPE_DEFAULT))
      {
        char v74 = *(void *)(a1 + 48);
        int v75 = *(void *)(a1 + 56);
        *(_DWORD *)__p = 138543618;
        *(void *)&__p[4] = v74;
        *(_WORD *)&__p[12] = 2114;
        *(void *)__int16 v83 = v75;
        _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_DEFAULT,  "Now tracking requests: %{public}@ with currently tracking devices: %{public}@",  __p,  0x16u);
        uint64_t v41 = 0LL;
      }

      goto LABEL_79;
    }

    uint64_t v50 = (os_log_s *)qword_1008F76E8;
    if (os_log_type_enabled((os_log_t)qword_1008F76E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__p = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "New session or new device to add in trackign list",  __p,  2u);
    }

    *(_DWORD *)((char *)&v76 + 10) = a16;
    *(_DWORD *)((char *)&v76 + 6) = a15;
    BYTE5(v76) = a14;
    BYTE4(v76) = a12;
    BYTE3(v76) = a11;
    BYTE2(v76) = a10;
    LOWORD(v76) = a9;
    uint64_t v51 = -[TrackingDevice initWithDevice:type:timeoutValue:targetCore:rssiThreshold:rssiThresholdGone:invalidRssiHandling:rssiPrecision:rssiPrecisionGone:eventConfiguration:vseBuffering:rssiIncreaseScanThreshold:rssiIncreaseScanWindowThreshold:rssiIncreaseScanIntervalThreshold:rssiIncreaseScanTimeoutThreshold:sensorTimeoutBetweenIncreaseScan:]( objc_alloc(&OBJC_CLASS___TrackingDevice),  "initWithDevice:type:timeoutValue:targetCore:rssiThreshold:rssiThresholdGone:invalidRssiHandling:rssiPrecisio n:rssiPrecisionGone:eventConfiguration:vseBuffering:rssiIncreaseScanThreshold:rssiIncreaseScanWindowThreshol d:rssiIncreaseScanIntervalThreshold:rssiIncreaseScanTimeoutThreshold:sensorTimeoutBetweenIncreaseScan:",  v24,  a4,  a5,  a6,  a7,  a8,  v76);
    uint64_t v52 = sub_100504038(a1, v24);
    __int16 v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
    int v54 = (os_log_s *)qword_1008F76E8;
    uint32_t v55 = os_log_type_enabled((os_log_t)qword_1008F76E8, OS_LOG_TYPE_DEFAULT);
    int v77 = v53;
    if (v53)
    {
      if (v55)
      {
        uint64_t v56 = [v53 currentState] - 1;
        if (v56 > 2) {
          uint64_t v57 = @"Not Set";
        }
        else {
          uint64_t v57 = off_10089EB30[(char)v56];
        }
        *(_DWORD *)__p = 138543362;
        *(void *)&__p[4] = v57;
        _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "Some other sesssion is tracking this device with state: %{public}@",  __p,  0xCu);
      }

      -[TrackingDevice setCurrentState:](v51, "setCurrentState:", [v53 currentState]);
      if (-[TrackingDevice currentState](v51, "currentState") == 1
        || -[TrackingDevice currentState](v51, "currentState") == 3)
      {
        if (qword_1008D67C8 != -1) {
          dispatch_once(&qword_1008D67C8, &stru_10089EAF0);
        }
        sub_100286F38((uint64_t)off_1008D67C0, a2, v24, -[TrackingDevice currentState](v51, "currentState"), a4);
      }
    }

    else
    {
      if (v55)
      {
        int v65 = -[TrackingDevice timeoutValue](v51, "timeoutValue");
        uint32_t v66 = -[TrackingDevice rssiThreshold](v51, "rssiThreshold");
        uint64_t v67 = -[TrackingDevice rssiPrecision](v51, "rssiPrecision");
        uint64_t v68 = -[TrackingDevice invalidRssiHandling](v51, "invalidRssiHandling");
        int v69 = -[TrackingDevice eventConfiguration](v51, "eventConfiguration");
        BOOL v70 = -[TrackingDevice vseBuffering](v51, "vseBuffering");
        *(_DWORD *)__p = 67110400;
        *(_DWORD *)&__p[4] = v65;
        *(_WORD *)&__p[8] = 1024;
        *(_DWORD *)&__p[10] = v66;
        *(_WORD *)__int16 v83 = 1024;
        *(_DWORD *)&v83[2] = v67;
        *(_WORD *)&v83[6] = 1024;
        *(_DWORD *)&v83[8] = v68;
        *(_WORD *)&v83[12] = 1024;
        *(_DWORD *)&v83[14] = v69;
        *(_WORD *)&v83[18] = 1024;
        *(_DWORD *)int v84 = v70;
        _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "No other session is tracking this device - start tracking with timeout: %d rssi:%d:%d handling:%d eventCfg:%d vseBuf:%d",  __p,  0x26u);
      }

      uint64_t v41 = sub_1005041D8( a1,  v24,  -[TrackingDevice timeoutValue](v51, "timeoutValue"),  -[TrackingDevice targetCore](v51, "targetCore"),  -[TrackingDevice rssiThreshold](v51, "rssiThreshold"),  -[TrackingDevice rssiThresholdGone](v51, "rssiThresholdGone"),  -[TrackingDevice invalidRssiHandling](v51, "invalidRssiHandling"),  -[TrackingDevice rssiPrecision](v51, "rssiPrecision"),  -[TrackingDevice rssiPrecisionGone](v51, "rssiPrecisionGone"),  -[TrackingDevice eventConfiguration](v51, "eventConfiguration"),  -[TrackingDevice vseBuffering](v51, "vseBuffering"));
      if ((_DWORD)v41)
      {
        if (os_log_type_enabled((os_log_t)qword_1008F76E8, OS_LOG_TYPE_ERROR)) {
          sub_10068BAD8();
        }
        goto LABEL_75;
      }
    }

    if (v78)
    {
      [v78 addObject:v51];
    }

    else
    {
      int v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithObject:](&OBJC_CLASS___NSMutableSet, "setWithObject:", v51));
      [*(id *)(a1 + 48) setObject:v72 forKeyedSubscript:v79];

      sub_100504458((void *)a1, a2);
    }

    if (!sub_100503CA4(a1, v51)
      || (uint64_t v41 = sub_100503EC0( a1,  0LL,  -[TrackingDevice rssiIncreaseScanThreshold](v51, "rssiIncreaseScanThreshold"),  -[TrackingDevice rssiIncreaseScanWindowThreshold](v51, "rssiIncreaseScanWindowThreshold"),  -[TrackingDevice rssiIncreaseScanIntervalThreshold](v51, "rssiIncreaseScanIntervalThreshold"),  -[TrackingDevice rssiIncreaseScanTimeoutThreshold](v51, "rssiIncreaseScanTimeoutThreshold"),  -[TrackingDevice sensorTimeoutBetweenIncreaseScan](v51, "sensorTimeoutBetweenIncreaseScan")),  !(_DWORD)v41))
    {

      goto LABEL_77;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F76E8, OS_LOG_TYPE_ERROR)) {
      sub_10068BA78();
    }
LABEL_75:

LABEL_79:
LABEL_80:

    goto LABEL_33;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F76E8, OS_LOG_TYPE_ERROR)) {
    sub_10068B900();
  }
  uint64_t v41 = 11LL;
LABEL_33:

  return v41;
}

  sub_100242CD8(&v50);
  return 0LL;
}

LABEL_56:
}

        int v48 = 0LL;
        *(_BYTE *)(a2 + 15) = 1;
LABEL_57:
        __int16 v79 = 0LL;
        int v78 = 0;
        uint64_t v49 = sub_1000DDDFC((uint64_t *)a2, &v79, &v78);
        if (v49)
        {
          if (v49 == 17) {
            uint64_t v31 = 35LL;
          }
          else {
            uint64_t v31 = v49;
          }
        }

        else
        {
          if (!*(_BYTE *)(qword_1008DFDB0 + 96)) {
            goto LABEL_67;
          }
          uint64_t v50 = 0LL;
          uint64_t v51 = *(void *)qword_1008DFDB0 + 32LL;
          while (*(unsigned __int8 *)(v51 - 7) != (_DWORD)v46)
          {
            ++v50;
            v51 += 40LL;
          }

          if (v50 != 255)
          {
            if (*(unsigned __int8 *)(v51 - 3) >= *(unsigned __int8 *)(v51 - 4))
            {
              uint64_t v31 = 19LL;
            }

            else
            {
              if (*(void *)(v51 - 16)) {
                goto LABEL_71;
              }
              if (sub_1000A86F0())
              {
                sub_1001EE134((uint64_t)"In Recv_SetConfig, allocating endpoint", v52, v53, v54, v55, v56, v57, v58, v76);
                uint64_t v59 = (os_log_s *)sub_100086554(3u);
                if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
                {
                  BOOL v60 = sub_1001EDDCC();
                  *(_DWORD *)buf = 136446210;
                  __int16 v81 = v60;
                  _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                }
              }

              int v61 = sub_1000DB674(v48);
              if (!v61)
              {
LABEL_71:
                uint64_t v31 = 129LL;
              }

              else
              {
                uint64_t v62 = v61;
                int v63 = qword_1008DFDB0;
                if (qword_1008DFDB0 && *(_BYTE *)(qword_1008DFDB0 + 98))
                {
                  int v64 = 0LL;
                  int v65 = (unsigned __int16 *)(*(void *)(qword_1008DFDB0 + 16) + 38LL);
                  while (1)
                  {
                    uint32_t v66 = *v65;
                    v65 += 32;
                    if (v66 == a1) {
                      break;
                    }
                  }

                  *(_BYTE *)(v61 + 135) = v64;
                  if ((_BYTE)v64 != 0xFF)
                  {
                    uint64_t v67 = *(unsigned __int8 *)(v63 + 96);
                    if (*(_BYTE *)(v63 + 96))
                    {
                      uint64_t v68 = 0LL;
                      int v69 = (unsigned __int8 *)(*(void *)v63 + 25LL);
                      while (1)
                      {
                        BOOL v70 = *v69;
                        v69 += 40;
                        if (v70 == (_DWORD)v46) {
                          break;
                        }
                        if (v67 == ++v68) {
                          goto LABEL_89;
                        }
                      }
                    }

                    else
                    {
LABEL_89:
                      LOBYTE(v6_Block_object_dispose(va, 8) = -1;
                    }

                    *(_BYTE *)(v61 + 136) = v68;
                    int v71 = v79;
                    *(void *)(v51 - 16) = v79;
                    int v72 = (_BYTE *)v51;
                    int v73 = v78;
                    void *v72 = v78;
                    char v74 = sub_1000DB7D8(v61);
                    (*(void (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, void *, uint64_t))(*(void *)(qword_1008DFDB0 + 24) + 40LL))( a3,  v77,  v46,  v48,  v74,  v71,  v73);
                    return 0LL;
                  }
                }

                else
                {
LABEL_82:
                  *(_BYTE *)(v61 + 135) = -1;
                }

                *(_BYTE *)(v61 + 132) = 0;
                *(_DWORD *)int v61 = 0;
                *(_WORD *)(v61 + 12_Block_object_dispose(va, 8) = 0;
                sub_1000B90AC(0LL);
                *(_BYTE *)(v62 + 137) = -1;
                *(_DWORD *)(v62 + 133) = -65281;
                uint64_t v31 = 128LL;
              }
            }
          }

          else
          {
LABEL_67:
            uint64_t v31 = 18LL;
          }
        }

        sub_1000D88A0(&v79, v78);
        sub_1000E63A0(a1, 3, a3, 0, v31);
        return v31;
      }

      *(_BYTE *)(a2 + 15) = 1;
    }

    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
    int v46 = 0LL;
    goto LABEL_56;
  }

  sub_100657F74();
  if (!a4) {
    goto LABEL_47;
  }
LABEL_13:
  if (a4 != 3)
  {
    if (a4 == 2)
    {
      uint64_t v25 = sub_1000E4B00(a3, a1);
      int v26 = qword_1008DFDB0;
      if (*(unsigned __int8 *)(qword_1008DFDB0 + 97) > (unsigned __int16)(v25 - 1)
        && (int v27 = *(void *)(qword_1008DFDB0 + 8)) != 0
        && (char v28 = *(unsigned __int8 *)(v27 + 144LL * (unsigned __int16)(v25 - 1) + 136), v28 != 255)
        && (uint32_t v29 = *(void *)qword_1008DFDB0) != 0)
      {
        sub_1000DD6D8(v27 + 144LL * (unsigned __int16)(v25 - 1), 1);
        uint64_t v30 = v29 + 40LL * v28;
        sub_1000D88A0((void **)(v30 + 8), *(unsigned __int8 *)(v30 + 31));
        uint64_t v31 = 0LL;
        *(_BYTE *)(v30 + 31) = *(_BYTE *)(v30 + 32);
        *(void *)(v30 + _Block_object_dispose(va, 8) = *(void *)(v30 + 16);
        *(void *)(v30 + 16) = 0LL;
        *(_BYTE *)(v30 + 32) = 0;
        ++*(_BYTE *)(v30 + 29);
        *(_BYTE *)(v27 + 144LL * (unsigned __int16)(v25 - 1) + 137) = *(_BYTE *)(v30 + 24);
        *(_BYTE *)(v30 + 24) = v25 - 1;
        int v26 = qword_1008DFDB0;
      }

      else
      {
        uint64_t v31 = 1LL;
      }

      (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)(v26 + 24) + 48LL))(a3, v25, 0LL, v31);
      return v31;
    }

    return 0LL;
  }

  int v32 = sub_1000E4B00(a3, a1);
  if ((_DWORD)v32)
  {
    if (*(_BYTE *)(a2 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c",  3777,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    if (*(_BYTE *)(a2 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
      int v33 = *(unsigned __int8 *)(a2 + 14);
      *(_BYTE *)(a2 + 15) = 1;
      if (v33 != 1) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c",  3778,  "(*pBs).__RWFlag == BYTESTREAM_READ");
      }
    }

    else
    {
      uint64_t v35 = *(unsigned __int16 *)(a2 + 12);
      if (*(unsigned __int16 *)(a2 + 10) > v35)
      {
        uint64_t v36 = *(void *)a2;
        *(_WORD *)(a2 + 12) = v35 + 1;
        if (*(unsigned __int16 *)(a2 + 10) > (v35 + 1))
        {
          unsigned int v37 = *(unsigned __int8 *)(v36 + v35);
          int v38 = *(void *)a2;
          *(_WORD *)(a2 + 12) = v35 + 2;
          uint64_t v39 = *(unsigned __int8 *)(v38 + v35 + 1);
LABEL_34:
          if (v39) {
            uint64_t v31 = v39;
          }
          else {
            uint64_t v31 = 24LL;
          }
          if (v39) {
            uint64_t v34 = v37;
          }
          else {
            uint64_t v34 = 0LL;
          }
          goto LABEL_40;
        }

      int v76 = ccaes_ecb_encrypt_mode(v11);
      memset(&buf[32], 0, 68);
      qmemcpy(buf, "bt_aessivauthentbt_aessivencrypt", 32);
      if (ccecb_one_shot(v76, 16LL, &v144[6], 2LL, buf, v14 + 302))
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Error generating AES_SIV", v77, v78, v79, v80, v81, v82, v83, v137);
          int v84 = (os_log_s *)sub_100086554(0x55u);
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
            goto LABEL_69;
          }
        }

    sub_100242FAC((uint64_t)buf);
  }

      int v21 = sub_100353ED0(a1, a2, 6, 1u);
      goto LABEL_28;
    }

    uint64_t v44 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    int v45 = (void *)qword_1008F0480;
    qword_1008F0480 = v44;

    int v47 = sub_10035C258(v46, a3, a4);
    int v48 = objc_claimAutoreleasedReturnValue(v47);
    uint64_t v49 = *(void **)(v8 + 96);
    *(void *)(v8 + 96) = v48;

    uint64_t v50 = (os_log_s *)qword_1008F7568;
    if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v51 = *(id *)(v8 + 8);
      *(_DWORD *)buf = 138543362;
      *(void *)&uint8_t buf[4] = v51;
      _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "recvCrashAvailableHandler: Crash log from %{public}@ available, informing user",  buf,  0xCu);
    }

    sub_1003D930C((uint64_t)v9, 0xAu, buf);
    if (v67 >= 0) {
      uint64_t v52 = buf;
    }
    else {
      uint64_t v52 = *(_BYTE **)buf;
    }
    __int16 v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v52));
    if (SHIBYTE(v67) < 0) {
      operator delete(*(void **)buf);
    }
    int v54 = sub_1002E8E64();
    (*(void (**)(uint64_t, unint64_t, void, void, void *))(*(void *)v54 + 144LL))( v54,  *(unsigned int *)(v8 + 16) | ((unint64_t)*(unsigned __int16 *)(v8 + 20) << 32),  *(unsigned int *)(v8 + 24),  *(void *)v8,  v53);

    int v21 = 0LL;
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
    {
      uint32_t v29 = sub_1001EDE10(a2, v22, v23, v24, v25, v26, v27, v28);
      sub_100671490(v29, (uint64_t)buf);
    }

    int v21 = 8LL;
  }

        uint64_t v30 = (char *)v30 + 1;
      }

      while (v28 != v30);
      char v28 = [v22 countByEnumeratingWithState:&v69 objects:v84 count:16];
      if (!v28) {
        goto LABEL_58;
      }
    }
  }

  int v75 = 0uLL;
  int v76 = 0uLL;
  int v73 = 0uLL;
  char v74 = 0uLL;
  if (qword_1008D5F60 != -1) {
    dispatch_once(&qword_1008D5F60, &stru_100894690);
  }
  int v21 = sub_100556F78(qword_1008D5F58);
  __int16 v22 = (id)objc_claimAutoreleasedReturnValue(v21);
  int v23 = [v22 countByEnumeratingWithState:&v73 objects:v85 count:16];
  if (v23)
  {
    uint64_t v24 = *(void *)v74;
    do
    {
      uint64_t v25 = 0LL;
      do
      {
        if (*(void *)v74 != v24) {
          objc_enumerationMutation(v22);
        }
        int v26 = *(void **)(*((void *)&v73 + 1) + 8LL * (void)v25);
        if (qword_1008D9278 != -1) {
          dispatch_once(&qword_1008D9278, &stru_100894670);
        }
        if (sub_100413550(qword_1008D9270, v26))
        {
          int v27 = (os_log_s *)qword_1008F7628;
          if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            *(void *)&uint8_t buf[4] = v26;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "registerForConnectionEventsWithOptionsforApp - notifyConnectionEventDidOccur - Device:%{public}@",  buf,  0xCu);
          }

          if (qword_1008D67C8 != -1) {
            dispatch_once(&qword_1008D67C8, &stru_100894590);
          }
          sub_100287E84((uint64_t)off_1008D67C0, a2, a1, v26, 1u);
        }

        uint64_t v25 = (char *)v25 + 1;
      }

      while (v23 != v25);
      int v23 = [v22 countByEnumeratingWithState:&v73 objects:v85 count:16];
    }

    while (v23);
  }

          sub_100242F54((uint64_t)v49);
          if (a3 == 2)
          {
            uint64_t v36 = sub_1000F9AF8(v50, 2, (char *)a5, (unsigned __int16)a6);
          }

          else
          {
            if (a3 != 3)
            {
              sub_100242FAC((uint64_t)v49);
              goto LABEL_63;
            }

            uint64_t v36 = sub_1000F997C(v50, 3, (char *)a5, (unsigned __int16)a6);
          }

          unsigned int v37 = v36;
          sub_100242FAC((uint64_t)v49);
          if (!v37)
          {
            uint64_t v31 = 1LL;
            goto LABEL_66;
          }

void sub_100042EFC(id *a1)
{
}

void sub_1000431EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100043220(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100043230(uint64_t a1)
{
}

void sub_100043238(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v6 + 40);
  uint64_t v7 = CUDescriptionWithLevel(a3, 30LL);
  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  NSAppendPrintF_safe(&obj, "%@\n", v8);
  objc_storeStrong((id *)(v6 + 40), obj);

  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
}

void sub_1000432EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100043614( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  _Unwind_Resume(a1);
}

void sub_10004364C(uint64_t a1)
{
  if (*(void *)(a1 + 40))
  {
    if (dword_1008D6530 <= 30
      && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
    {
      if (*(_BYTE *)(a1 + 56))
      {
        if (*(_BYTE *)(a1 + 57)) {
          uint64_t v2 = "rescan";
        }
        else {
          uint64_t v2 = "update";
        }
      }

      else
      {
        uint64_t v2 = "initial";
      }

      LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _activate:]_block_invoke",  30LL,  "Scan start: %s, %@",  v2,  *(void *)(a1 + 32));
    }
  }

  else if (*(_BYTE *)(a1 + 56) {
         && dword_1008D6530 <= 30
  }
         && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
  {
    LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _activate:]_block_invoke",  30LL,  "Scan stop: %@",  *(void *)(a1 + 32));
  }

  if (*(_BYTE *)(a1 + 56))
  {
    if (qword_1008D6608 != -1) {
      dispatch_once(&qword_1008D6608, &stru_1008802D0);
    }
    int v3 = sub_1005F24EC((uint64_t)off_1008D6600, *(void *)(a1 + 48), 1, 1, 0);
    if (v3)
    {
      if (dword_1008D6530 <= 90)
      {
        int v4 = v3;
        if (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 90LL))
        {
          uint64_t v5 = CUPrintErrorCode((v4 + 310000));
          uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
          LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _activate:]_block_invoke",  90LL,  "### Stop scan failed: %@",  v6);
        }
      }
    }
  }

  if (*(void *)(a1 + 40))
  {
    if (qword_1008D6608 != -1) {
      dispatch_once(&qword_1008D6608, &stru_1008802D0);
    }
    int v7 = sub_1005F08F8((uint64_t)off_1008D6600, *(void *)(a1 + 48), *(unsigned __int8 **)(a1 + 40));
    if (v7)
    {
      if (dword_1008D6530 <= 90)
      {
        int v8 = v7;
        if (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 90LL))
        {
          uint64_t v9 = CUPrintErrorCode((v8 + 310000));
          id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
          LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _activate:]_block_invoke",  90LL,  "### Scan start failed: %@, %@",  v10,  *(void *)(a1 + 32));
        }
      }

      uint64_t v11 = *(void *)(a1 + 40);
      if (v11)
      {
        int v12 = (void *)sub_10004FD94(v11);
        operator delete(v12);
      }
    }
  }

void sub_1000438F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100043AA0(_Unwind_Exception *exception_object)
{
}

void sub_100043AC0(uint64_t a1)
{
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008802D0);
  }
  sub_1005F24EC((uint64_t)off_1008D6600, *(void *)(a1 + 40), 1, 1, 0);
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(dispatch_queue_s **)(v2 + 240);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100043BB8;
  block[3] = &unk_10087EA48;
  block[4] = v2;
  dispatch_async(v3, block);
}

id sub_100043BB8(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 96LL) = 0;
  return [*(id *)(a1 + 32) _invalidated];
}

void sub_100043D28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100043D38(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    if (dword_1008D6530 <= 30
      && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
    {
      LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _invalidated]_block_invoke",  30LL,  "SensorTracking stop all");
    }

    if (qword_1008D6618 != -1) {
      dispatch_once(&qword_1008D6618, &stru_1008802F0);
    }
    sub_100504EB0(qword_1008D6610, *(void *)(a1 + 32));
  }

  if (qword_1008D61A8 != -1) {
    dispatch_once(&qword_1008D61A8, &stru_1008802B0);
  }
  return sub_1004966BC(qword_1008D61A0, *(void *)(a1 + 40));
}

void sub_100044210(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000443A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  __int16 v13 = v12;

  _Unwind_Resume(a1);
}

void sub_10004449C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10004489C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100044A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100044B00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100044E0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100044FAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100044FE4(uint64_t a1)
{
  if (dword_1008D6530 <= 30 && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL))) {
    LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack clearDuplicateFilterCache:]_block_invoke",  30LL,  "clearDuplicateFilterCache for type %d ",  *(unsigned __int8 *)(a1 + 40));
  }
  if (qword_1008D6608 != -1) {
    dispatch_once(&qword_1008D6608, &stru_1008802D0);
  }
  return sub_1005F4984((uint64_t)off_1008D6600, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void sub_10004520C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100045C48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, void *a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, id a45, uint64_t a46, char a47)
{
  _Block_object_dispose(&a47, 8);
  _Unwind_Resume(a1);
}

void sub_100045E28(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v5]);
  id v8 = v6;
  uint64_t v9 = v8;
  if (v7 == v8)
  {
  }

  else
  {
    if ((v8 != 0LL) != (v7 == 0LL))
    {
      unsigned __int8 v10 = [v7 isEqual:v8];

      if ((v10 & 1) != 0) {
        goto LABEL_23;
      }
    }

    else
    {
    }

    if ([v5 length] == (id)7) {
      id v11 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "subdataWithRange:", 1, 6));
    }
    else {
      id v11 = v5;
    }
    int v12 = v11;
    if ([v5 length] == (id)7) {
      int v13 = *(unsigned __int8 *)[v5 bytes];
    }
    else {
      int v13 = 0;
    }
    if (dword_1008D6530 <= 30
      && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
    {
      uint64_t v14 = "?";
      if (v13 == 1) {
        uint64_t v14 = "Random";
      }
      if (v13) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = "Public";
      }
      uint64_t v16 = CUPrintNSDataAddress(v12);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      uint64_t v18 = CUPrintNSObjectMasked(v9);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
      LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _oobKeysUpdate]_block_invoke",  30LL,  "OOB key remove: Addr %s %@, IRK %@",  v15,  v17,  v19);
    }

    uint64_t v20 = sub_100404FE8();
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    _DWORD v21[2] = sub_1000460E8;
    v21[3] = &unk_100880100;
    char v25 = v13;
    id v22 = v5;
    int v23 = v12;
    id v24 = v9;
    sub_100405384(v20, v21);
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  }

void sub_10004607C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000460E8(uint64_t a1)
{
  if ([*(id *)(a1 + 32) length] == (id)6 || objc_msgSend(*(id *)(a1 + 32), "length") == (id)7)
  {
    if ([*(id *)(a1 + 32) length] == (id)6)
    {
      *(_DWORD *)&v15[3] = 0;
      *(_DWORD *)uint64_t v15 = 0;
      uint64_t v2 = [*(id *)(a1 + 32) bytes];
      unint64_t v3 = 0LL;
      __int16 v4 = v2[2];
      *(_DWORD *)&v15[1] = *(_DWORD *)v2;
      *(_WORD *)&void v15[5] = v4;
    }

    else
    {
      unint64_t v5 = sub_1005C04DC(*(void **)(a1 + 32));
      uint64_t v6 = sub_1001BCDB0(v5);
      *(_DWORD *)uint64_t v15 = v6;
      v15[6] = BYTE6(v6);
      *(_WORD *)&v15[4] = WORD2(v6);
      unint64_t v3 = (unint64_t)v6 << 48;
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100880310);
    }
    sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v15[1] << 40) | ((unint64_t)v15[2] << 32) | ((unint64_t)v15[3] << 24) | ((unint64_t)v15[4] << 16) | ((unint64_t)v15[5] << 8) | v15[6] | v3,  0,  1u,  0LL,  0LL,  v16);
    id v7 = sub_100241F94(v16);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_100880330);
    }
    if (sub_10061C0F8(qword_1008D5F18, v8))
    {
      if (dword_1008D6530 <= 30
        && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
      {
        uint64_t v9 = "?";
        if (*(_BYTE *)(a1 + 56) == 1) {
          uint64_t v9 = "Random";
        }
        if (*(_BYTE *)(a1 + 56)) {
          unsigned __int8 v10 = v9;
        }
        else {
          unsigned __int8 v10 = "Public";
        }
        uint64_t v11 = CUPrintNSDataAddress(*(void *)(a1 + 40));
        int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        uint64_t v13 = CUPrintNSObjectMasked(*(void *)(a1 + 48));
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _oobKeysUpdate]_block_invoke_2",  30LL,  "OOB key failed to remove(it was already paired): Addr %s %@, IRK %@",  v10,  v12,  v14);
      }
    }

    else
    {
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_100880330);
      }
      sub_10062AC58(qword_1008D5F18, v15);
    }
  }

void sub_10004636C(_Unwind_Exception *a1)
{
  __int16 v4 = v1;

  _Unwind_Resume(a1);
}

void sub_1000463A0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (id)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 72) objectForKeyedSubscript:v5]);
  id v8 = v6;
  uint64_t v9 = v8;
  if (v7 == v8)
  {
  }

  else
  {
    if ((v8 != 0LL) != (v7 == 0LL))
    {
      unsigned __int8 v10 = [v7 isEqual:v8];

      if ((v10 & 1) != 0) {
        goto LABEL_23;
      }
    }

    else
    {
    }

    if ([v5 length] == (id)7) {
      id v11 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "subdataWithRange:", 1, 6));
    }
    else {
      id v11 = v5;
    }
    int v12 = v11;
    if ([v5 length] == (id)7) {
      int v13 = *(unsigned __int8 *)[v5 bytes];
    }
    else {
      int v13 = 0;
    }
    if (dword_1008D6530 <= 30
      && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
    {
      uint64_t v14 = "?";
      if (v13 == 1) {
        uint64_t v14 = "Random";
      }
      if (v13) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = "Public";
      }
      uint64_t v16 = CUPrintNSDataAddress(v12);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      uint64_t v18 = CUPrintNSObjectMasked(v9);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
      LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _oobKeysUpdate]_block_invoke_3",  30LL,  "OOB key add: Addr %s %@, IRK %@",  v15,  v17,  v19);
    }

    uint64_t v20 = sub_100404FE8();
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    _DWORD v21[2] = sub_100046664;
    v21[3] = &unk_100880100;
    id v22 = v5;
    char v25 = v13;
    id v23 = v9;
    id v24 = v12;
    sub_100405384(v20, v21);
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  }

void sub_1000465F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100046664(uint64_t a1)
{
  if ([*(id *)(a1 + 32) length] == (id)6 || objc_msgSend(*(id *)(a1 + 32), "length") == (id)7)
  {
    if ([*(id *)(a1 + 32) length] == (id)6)
    {
      *(_DWORD *)&v15[3] = 0;
      *(_DWORD *)uint64_t v15 = 0;
      uint64_t v2 = [*(id *)(a1 + 32) bytes];
      unint64_t v3 = 0LL;
      __int16 v4 = v2[2];
      *(_DWORD *)&v15[1] = *(_DWORD *)v2;
      *(_WORD *)&void v15[5] = v4;
    }

    else
    {
      unint64_t v5 = sub_1005C04DC(*(void **)(a1 + 32));
      uint64_t v6 = sub_1001BCDB0(v5);
      *(_DWORD *)uint64_t v15 = v6;
      v15[6] = BYTE6(v6);
      *(_WORD *)&v15[4] = WORD2(v6);
      unint64_t v3 = (unint64_t)v6 << 48;
    }

    if ([*(id *)(a1 + 40) length] == (id)16)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_100880310);
      }
      sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v15[1] << 40) | ((unint64_t)v15[2] << 32) | ((unint64_t)v15[3] << 24) | ((unint64_t)v15[4] << 16) | ((unint64_t)v15[5] << 8) | v15[6] | v3,  0,  1u,  0LL,  0LL,  v16);
      id v7 = sub_100241F94(v16);
      id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_100880330);
      }
      if (sub_10061C0F8(qword_1008D5F18, v8))
      {
        if (dword_1008D6530 <= 30
          && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
        {
          uint64_t v9 = "?";
          if (*(_BYTE *)(a1 + 56) == 1) {
            uint64_t v9 = "Random";
          }
          if (*(_BYTE *)(a1 + 56)) {
            unsigned __int8 v10 = v9;
          }
          else {
            unsigned __int8 v10 = "Public";
          }
          uint64_t v11 = CUPrintNSDataAddress(*(void *)(a1 + 48));
          int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
          uint64_t v13 = CUPrintNSObjectMasked(*(void *)(a1 + 40));
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
          LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _oobKeysUpdate]_block_invoke_4",  30LL,  "OOB key failed to add(it was already paired): Addr %s %@, IRK %@",  v10,  v12,  v14);
        }
      }

      else
      {
        if (qword_1008D5F20 != -1) {
          dispatch_once(&qword_1008D5F20, &stru_100880330);
        }
        sub_100621334(qword_1008D5F18, v15, (uint64_t)[*(id *)(a1 + 40) bytes]);
      }
    }
  }

void sub_10004690C(_Unwind_Exception *a1)
{
  __int16 v4 = v1;

  _Unwind_Resume(a1);
}

void sub_100046940(uint64_t a1)
{
  if (qword_1008D6628 != -1) {
    dispatch_once(&qword_1008D6628, &stru_100880350);
  }
  sub_100333834(qword_1008D6620, *(void **)(a1 + 32));
}

void sub_100046A24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100046A34(id a1, NSData *a2, NSData *a3, BOOL *a4)
{
  unint64_t v5 = a2;
  uint64_t v6 = a3;
  if ((id)-[NSData length](v5, "length") == (id)7) {
    id v7 = (NSData *)objc_claimAutoreleasedReturnValue(-[NSData subdataWithRange:](v5, "subdataWithRange:", 1LL, 6LL));
  }
  else {
    id v7 = v5;
  }
  id v8 = v7;
  if ((id)-[NSData length](v5, "length") == (id)7) {
    int v9 = *(unsigned __int8 *)-[NSData bytes](v5, "bytes");
  }
  else {
    int v9 = 0;
  }
  if (dword_1008D6530 <= 30 && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
  {
    unsigned __int8 v10 = "?";
    if (v9 == 1) {
      unsigned __int8 v10 = "Random";
    }
    if (v9) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = "Public";
    }
    uint64_t v12 = CUPrintNSDataAddress(v8);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    uint64_t v14 = CUPrintNSObjectMasked(v6);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _oobKeysRemoveAll]_block_invoke",  30LL,  "OOB key remove: Addr %s %@, IRK %@",  v11,  v13,  v15);
  }

  uint64_t v16 = sub_100404FE8();
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472LL;
  v19[2] = sub_100046C40;
  v19[3] = &unk_10087FB90;
  uint64_t v17 = v5;
  uint64_t v20 = v17;
  uint64_t v18 = v6;
  int v21 = v18;
  sub_100405384(v16, v19);
}

void sub_100046BEC(_Unwind_Exception *a1)
{
  uint64_t v6 = v5;

  _Unwind_Resume(a1);
}

void sub_100046C40(uint64_t a1)
{
  if ([*(id *)(a1 + 32) length] == (id)6)
  {
    unsigned __int8 v10 = 0;
    uint64_t v2 = [*(id *)(a1 + 32) bytes];
    __int16 v3 = v2[2];
    int v11 = *(_DWORD *)v2;
    __int16 v12 = v3;
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100880310);
    }
    sub_1005C8684( (uint64_t)off_1008D5F28,  ((unint64_t)v11 << 40) | ((unint64_t)BYTE1(v11) << 32) | ((unint64_t)BYTE2(v11) << 24) | ((unint64_t)HIBYTE(v11) << 16) | ((unint64_t)v12 << 8) | HIBYTE(v12),  0,  1u,  0LL,  0LL,  v13);
    __int16 v4 = sub_100241F94(v13);
    unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_100880330);
    }
    if (sub_10061C0F8(qword_1008D5F18, v5))
    {
      if (dword_1008D6530 <= 30
        && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
      {
        uint64_t v6 = CUPrintNSDataAddress(*(void *)(a1 + 32));
        id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        uint64_t v8 = CUPrintNSObjectMasked(*(void *)(a1 + 40));
        int v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
        LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _oobKeysRemoveAll]_block_invoke_2",  30LL,  "OOB key failed to remove(it was already paired): Addr %@, IRK %@",  v7,  v9);
      }
    }

    else
    {
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_100880330);
      }
      sub_10062AC58(qword_1008D5F18, &v10);
    }
  }

void sub_100046E40(_Unwind_Exception *a1)
{
  __int16 v4 = v2;

  _Unwind_Resume(a1);
}

void sub_100047148( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, id a43)
{
  _Unwind_Resume(a1);
}

void sub_1000471E8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 irkData]);
  id v7 = [v6 length];

  if (v7 == (id)16 && [v5 keyType])
  {
    uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    int v9 = (void *)objc_claimAutoreleasedReturnValue([v5 irkData]);
    id v10 = (id)objc_claimAutoreleasedReturnValue([v8 objectForKey:v9]);

    if (!v10)
    {
      __int128 v37 = 0uLL;
      id v19 = objc_claimAutoreleasedReturnValue([v5 irkData]);
      __int128 v37 = *(_OWORD *)[v19 bytes];

      uint64_t v20 = SipHash(&v37, [*(id *)(a1 + 32) bytes], 6);
      __int16 v35 = v20;
      char v36 = BYTE2(v20);
      int v21 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v35, 3LL);
      if (([*(id *)(a1 + 40) isEqualToData:v21] & 1) == 0)
      {

        id v10 = 0LL;
LABEL_17:

        goto LABEL_18;
      }

      id v10 = *(id *)(a1 + 40);
      id v22 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
      if (!v22)
      {
        id v23 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        uint64_t v24 = *(void *)(*(void *)(a1 + 56) + 8LL);
        char v25 = *(void **)(v24 + 40);
        *(void *)(v24 + 40) = v23;

        id v22 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
      }

      uint64_t v26 = *(void *)(a1 + 40);
      int v27 = (void *)objc_claimAutoreleasedReturnValue([v5 irkData]);
      [v22 setObject:v26 forKeyedSubscript:v27];

      if (!v10) {
        goto LABEL_17;
      }
    }

    if (dword_1008D6530 <= 20
      && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 20LL)))
    {
      int v11 = (void *)objc_claimAutoreleasedReturnValue([v5 irkData]);
      uint64_t v12 = CUPrintNSObjectMasked(v11);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v5 btAddressData]);
      uint64_t v15 = CUPrintNSDataAddress(v14);
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
      uint64_t v17 = CUPrintNSDataAddress(*(void *)(a1 + 32));
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
      LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _proxyOOBKeysUpdateOnDeviceFound:]_block_invoke",  20LL,  "ProxyAuthTag matched %@, changing oobKey's stored address from: %@ to %@",  v13,  v16,  v18);
    }

    char v28 = -[NSData initWithData:](objc_alloc(&OBJC_CLASS___NSData), "initWithData:", *(void *)(a1 + 32));
    [v5 setBtAddressData:v28];

    uint32_t v29 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
    if (!v29)
    {
      uint64_t v30 = objc_alloc(&OBJC_CLASS___NSMutableArray);
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) oobKeys]);
      int v32 = -[NSMutableArray initWithArray:](v30, "initWithArray:", v31);
      uint64_t v33 = *(void *)(*(void *)(a1 + 64) + 8LL);
      uint64_t v34 = *(void **)(v33 + 40);
      *(void *)(v33 + 40) = v32;

      uint32_t v29 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
    }

    [v29 replaceObjectAtIndex:a3 withObject:v5];
    goto LABEL_17;
  }

void sub_100047528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10004793C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100047AD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100047AF0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 40);
  if (v2 == result[11]) {
    return [result _rescanTimerFired];
  }
  return result;
}

void sub_100048388( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100048810( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1000488B4(uint64_t a1)
{
  if (qword_1008D6628 != -1) {
    dispatch_once(&qword_1008D6628, &stru_100880350);
  }
  sub_100333DE0(qword_1008D6620, *(void **)(a1 + 32));
}

void sub_100048A3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_92:
                  if ((v17 & 0x2000000000LL) != 0) {
                    self->_anyActiveScan = 1;
                  }
                  if (v127)
                  {
                    v127 = ((unint64_t)[v19 discoveryFlags] & 0x200000000) == 0;
                    if ((v17 & 0x40000) != 0) {
                      goto LABEL_99;
                    }
                  }

                  else
                  {
                    v127 = 0;
                    if ((v17 & 0x40000) != 0) {
                      goto LABEL_99;
                    }
                  }

                  if (![v19 discoveryTypesContainTypes:CBDiscoveryTypesNeedsObjectLocator()]) {
                    goto LABEL_106;
                  }
LABEL_99:
                  if (v124 != 26)
                  {
                    if (!v114) {
                      BYTE4(v121) |= (int)[v19 bleRSSIThresholdHint] < 0;
                    }
                    goto LABEL_105;
                  }

                  BOOL v70 = sub_1002E6E00();
                  BYTE4(v121) = (*(uint64_t (**)(uint64_t))(*(void *)v70 + 880LL))(v70);
                  int v71 = sub_1002E6E00();
                  v119 = (*(uint64_t (**)(uint64_t))(*(void *)v71 + 880LL))(v71);
                  int v72 = [v19 discoveryTypesInternalPtr];
                  LOBYTE(v121) = 1;
                  if ((v17 & 0x200000000LL) != 0 && (v72[1] & 1) != 0)
                  {
                    self->_aopBTTypes |= 0x100u;
LABEL_105:
                    LOBYTE(v121) = 1;
                  }

              char v28 = BYTE8(v46);
              goto LABEL_93;
            }

            if (v46 <= 0x3Fu)
            {
              if (v46 == 48)
              {
                uint64_t v30 = *(void (**)(uint64_t, uint64_t))(v6 + 80);
                if (v30)
                {
LABEL_90:
                  v30(a1, a2);
                  return 0LL;
                }
              }

              else if (v46 == 49)
              {
                int v27 = *(void (**)(uint64_t, uint64_t, void, void))(v6 + 88);
                if (v27)
                {
                  v27(a1, a2, BYTE8(v46), HIDWORD(v46));
                  return 0LL;
                }
              }

              goto LABEL_98;
            }

            if (v46 != 64)
            {
              char v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 104);
              if (!v25) {
                goto LABEL_98;
              }
              goto LABEL_92;
            }

            uint64_t v34 = *(void (**)(uint64_t, uint64_t, void, void, void))(v6 + 96);
            if (!v34) {
              goto LABEL_98;
            }
            __int16 v35 = *(void *)(v13 + 24);
            if (v35)
            {
              v34(a1, a2, BYTE8(v46), *(unsigned __int16 *)(v35 + 16), *(unsigned __int16 *)(v35 + 18));
              return 0LL;
            }

                        WORD2(v82) = v37 + 1;
                        *(_BYTE *)(v81 + v37) = a8;
                        return sub_10018BD78(501, v81, BYTE4(v82), a13, (uint64_t)sub_10013A594, v22, v23, v24);
                      }
                    }

                    int v38 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_132:
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5836,  v38);
                  }

                  uint64_t v62 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_129:
                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5835,  v62);
                }

                uint64_t v62 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                goto LABEL_129;
              }

              int v61 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_125:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5834,  v61);
            }

            int v61 = "ByteStream_NumReadBytesAvail(bs) >= (6)";
            goto LABEL_125;
          }

          if (HIBYTE(v82))
          {
            sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
          }

          else
          {
            int v48 = WORD2(v82);
            if (WORD1(v82) > WORD2(v82))
            {
              if (BYTE6(v82) == 2)
              {
                ++WORD2(v82);
                *(_BYTE *)(v81 + v4_Block_object_dispose((const void *)(v15 - 96), 8) = a10;
                if (HIBYTE(v82))
                {
                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                }

                else
                {
                  uint64_t v49 = WORD2(v82);
                  if (WORD1(v82) > WORD2(v82))
                  {
                    if (BYTE6(v82) == 2)
                    {
                      ++WORD2(v82);
                      *(_BYTE *)(v81 + v49) = a3;
                      if (HIBYTE(v82))
                      {
                        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                      }

                      else
                      {
                        uint64_t v50 = WORD2(v82);
                        if (WORD1(v82) > WORD2(v82))
                        {
                          if (BYTE6(v82) == 2)
                          {
                            ++WORD2(v82);
                            *(_BYTE *)(v81 + v50) = a4;
                            if (HIBYTE(v82))
                            {
                              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
                            }

                            else
                            {
                              uint64_t v51 = WORD2(v82);
                              if (WORD1(v82) > WORD2(v82))
                              {
                                if (BYTE6(v82) == 2)
                                {
                                  ++WORD2(v82);
                                  *(_BYTE *)(v81 + v51) = a5;
                                  if (HIBYTE(v82))
                                  {
                                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/St"
                                                           "ack/vsc/bcm/bcm_vsc.c");
                                  }

                                  else
                                  {
                                    uint64_t v52 = WORD2(v82);
                                    if (WORD1(v82) > WORD2(v82))
                                    {
                                      if (BYTE6(v82) == 2)
                                      {
                                        ++WORD2(v82);
                                        *(_BYTE *)(v81 + v52) = a6;
                                        if (HIBYTE(v82))
                                        {
                                          sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_b"
                                                                 "ase/Stack/vsc/bcm/bcm_vsc.c");
                                        }

                                        else if (WORD1(v82) > WORD2(v82))
                                        {
                                          if (BYTE6(v82) == 2)
                                          {
                                            *(_BYTE *)(v81 + WORD2(v82)) = 0;
                                            __int16 v53 = WORD2(v82);
                                            int v54 = ++WORD2(v82);
                                            if (HIBYTE(v82))
                                            {
                                              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetoo"
                                                                     "th_base/Stack/vsc/bcm/bcm_vsc.c");
                                            }

                                            else if (WORD1(v82) > v54)
                                            {
                                              if (BYTE6(v82) == 2)
                                              {
                                                WORD2(v82) = v53 + 2;
                                                *(_BYTE *)(v81 + v54) = a7;
                                                if (HIBYTE(v82))
                                                {
                                                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBlu"
                                                                         "etooth_base/Stack/vsc/bcm/bcm_vsc.c");
                                                }

                                                else
                                                {
                                                  __int128 v37 = WORD2(v82);
                                                  if (WORD1(v82) > WORD2(v82))
                                                  {
                                                    if (BYTE6(v82) == 2) {
                                                      goto LABEL_92;
                                                    }
                                                    int v80 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_204:
                                                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/v sc/bcm/bcm_vsc.c",  5846,  v80);
                                                  }
                                                }

                                                int v80 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                                                goto LABEL_204;
                                              }

                                              __int16 v79 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_200:
                                              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5845,  v79);
                                            }

                                            __int16 v79 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                                            goto LABEL_200;
                                          }

                                          int v78 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_196:
                                          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5844,  v78);
                                        }

                                        int v78 = "ByteStream_NumReadBytesAvail(bs) >= (1)";
                                        goto LABEL_196;
                                      }

                                      int v77 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_192:
                                      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5843,  v77);
                                    }
                                  }

                                  int v77 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                                  goto LABEL_192;
                                }

                                int v76 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_188:
                                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5842,  v76);
                              }
                            }

                            int v76 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                            goto LABEL_188;
                          }

                          int v75 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_184:
                          sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5841,  v75);
                        }
                      }

                      int v75 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                      goto LABEL_184;
                    }

                    char v74 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_180:
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5840,  v74);
                  }
                }

                char v74 = "ByteStream_NumReadBytesAvail(bs) >= 1";
                goto LABEL_180;
              }

              int v73 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_176:
              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  5839,  v73);
            }
          }

          int v73 = "ByteStream_NumReadBytesAvail(bs) >= 1";
          goto LABEL_176;
        }

        BOOL v60 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_121:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 5831, v60);
      }
    }

    BOOL v60 = "ByteStream_NumReadBytesAvail(bs) >= 1";
    goto LABEL_121;
  }

  return result;
}

  if ((v33 & 1) != 0 || v8 == v5)
  {
    if (v8 == v5) {
      int v54 = v33;
    }
    else {
      int v54 = 0;
    }
    if (v54 == 1 && os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT))
    {
      sub_100531170((void *)a2, &buf);
      sub_10067FF08();
    }
  }

  else
  {
    uint64_t v51 = (os_log_s *)qword_1008F75B0;
    uint64_t v52 = os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_FAULT);
    __int16 v53 = *(_WORD **)(a2 + 8);
    if (v52)
    {
      uint64_t v56 = (unsigned __int16)*v53;
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v56;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_FAULT,  "Found orphaned handle 0x%04x in handle map",  (uint8_t *)&buf,  8u);
      __int16 v53 = *(_WORD **)(a2 + 8);
    }

    LOWORD(buf.__r_.__value_.__l.__data_) = *v53;
    sub_100329E44((uint64_t)v6, (unsigned __int16 *)&buf);
  }

  return sub_100242FAC((uint64_t)v59);
}

        if ([v139 containsObject:@"IdentityKeys"])
        {
          *(_DWORD *)((char *)v169 + 3) = 0;
          LODWORD(v169[0]) = 0;
          if ((([v138 isEqualToString:@"Version 3"] & 1) != 0
             || [v138 isEqualToString:@"CloudKit_v2"])
            && (int v77 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"RandomAddress"]),
                int v78 = v77 == 0LL,
                v77,
                !v78))
          {
            __int16 v79 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"RandomAddress"]);
            int v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Random %@",  v79));
            v133 = sub_1005C02B0(v80);

            __int16 v81 = sub_1001BCDB0(v133);
          }

          else
          {
            __int16 v81 = sub_1001BCDB0(v15);
          }

          LODWORD(v169[0]) = v81;
          BYTE6(v169[0]) = BYTE6(v81);
          WORD2(v169[0]) = WORD2(v81);
          int v82 = v161;
          sub_10056AB04(buf, v169, 7uLL);
          sub_10032B1F8((uint64_t)v82, 11, (uint64_t)buf);
          *(void *)buf = &off_10087FAA8;
          if (*(void *)&buf[8]) {
            sub_1002CD254(*(unsigned int **)&buf[8]);
          }
          __int16 v83 = v161;
          int v84 = objc_claimAutoreleasedReturnValue([v140 objectForKeyedSubscript:@"IRK"]);
          sub_10056AB04(buf, [v84 bytes], 0x10uLL);
          sub_10032B1F8((uint64_t)v83, 10, (uint64_t)buf);
          *(void *)buf = &off_10087FAA8;
          if (*(void *)&buf[8]) {
            sub_1002CD254(*(unsigned int **)&buf[8]);
          }
        }

        __int16 v85 = (os_log_s *)(id)qword_1008F7588;
        if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
        {
          int v86 = [v134 UTF8String];
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = v86;
          _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "Associated name %s ", buf, 0xCu);
        }

        if (v132)
        {
          __int16 v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Random %@",  v135));
          int v88 = sub_1005C02B0(v87);
        }

        else
        {
          int v88 = 0LL;
        }

        v89 = (os_log_s *)(id)qword_1008F7588;
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          v90 = sub_1005BFB9C(v88);
          v91 = (id)objc_claimAutoreleasedReturnValue(v90);
          *(_DWORD *)buf = 134218242;
          *(void *)&uint8_t buf[4] = v88;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&_BYTE buf[14] = v91;
          _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEFAULT,  "MUC - pairing with local host address (0x%llx), %@",  buf,  0x16u);
        }

        if (v133)
        {
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089A518);
          }
          v92 = off_1008D5F28;
          v93 = v136;
          sub_10002418C(__p, (char *)[v93 UTF8String]);
          v94 = sub_1005CF29C((uint64_t)v92, (unsigned __int8 *)__p);
          v95 = (void *)objc_claimAutoreleasedReturnValue(v94);
          if (v154 < 0) {
            operator delete(__p[0]);
          }
          if (v95)
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_10089A518);
            }
            v96 = sub_1005CC198((uint64_t)off_1008D5F28, v95, 0);
            v97 = (os_log_s *)(id)qword_1008F7588;
            v98 = os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT);
            if (!v96 || (v96 & 0xFF000000000000LL) != 0)
            {
              if (v98)
              {
                v105 = sub_1005BFB9C(v96);
                v106 = (id)objc_claimAutoreleasedReturnValue(v105);
                *(_DWORD *)buf = 138412802;
                *(void *)&uint8_t buf[4] = v106;
                *(_WORD *)&_BYTE buf[12] = 2112;
                *(void *)&_BYTE buf[14] = v95;
                *(_WORD *)&buf[22] = 2112;
                *(void *)&_BYTE buf[24] = v93;
                _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEFAULT,  "MUC - %@ - %@ cloudID: %@ was NOT paired using public address",  buf,  0x20u);
              }
            }

            else
            {
              if (v98)
              {
                v99 = sub_1005BFB9C(v96);
                v100 = (id)objc_claimAutoreleasedReturnValue(v99);
                *(_DWORD *)buf = 138412802;
                *(void *)&uint8_t buf[4] = v100;
                *(_WORD *)&_BYTE buf[12] = 2112;
                *(void *)&_BYTE buf[14] = v95;
                *(_WORD *)&buf[22] = 2112;
                *(void *)&_BYTE buf[24] = v93;
                _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEFAULT,  "MUC - %@ - %@ cloudID: %@ was paired using public address - remove first",  buf,  0x20u);
              }

              if (qword_1008D5F20 != -1) {
                dispatch_once(&qword_1008D5F20, &stru_10089A478);
              }
              v101 = qword_1008D5F18;
              sub_10002418C(v151, (char *)[v93 UTF8String]);
              sub_100625934(v101, (unsigned __int8 *)v151);
              if (v152 < 0) {
                operator delete(v151[0]);
              }
            }
          }

          if (qword_1008D5F20 != -1) {
            dispatch_once(&qword_1008D5F20, &stru_10089A478);
          }
          v107 = qword_1008D5F18;
          sub_10002418C(v149, (char *)[v134 UTF8String]);
          sub_10002418C(&v148, (char *)[v93 UTF8String]);
          v108 = sub_10062411C(v107, v133, (uint64_t)v149, (uint64_t)&v160, &v148);
          v104 = (void *)objc_claimAutoreleasedReturnValue(v108);
          if (v150 < 0) {
            operator delete(v149[0]);
          }
        }

        else
        {
          if (qword_1008D5F20 != -1) {
            dispatch_once(&qword_1008D5F20, &stru_10089A478);
          }
          v102 = qword_1008D5F18;
          sub_10002418C(v146, (char *)[v134 UTF8String]);
          sub_10002418C(&v145, (char *)[v136 UTF8String]);
          v103 = sub_10062411C(v102, v15, (uint64_t)v146, (uint64_t)&v160, &v145);
          v104 = (void *)objc_claimAutoreleasedReturnValue(v103);
          if (v147 < 0) {
            operator delete(v146[0]);
          }
        }

        if (v104)
        {
          if (v132)
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_10089A518);
            }
            v109 = off_1008D5F28;
            sub_10002418C(v143, "PairedUsingRSA");
            sub_1005CCF08((uint64_t)v109, v104, (unsigned __int8 *)v143);
            if (v144 < 0) {
              operator delete(v143[0]);
            }
          }

          if (v135)
          {
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_10089A518);
            }
            v110 = off_1008D5F28;
            sub_10002418C(v141, "PairingAttemptedUsingRSA");
            sub_1005CCF08((uint64_t)v110, v104, (unsigned __int8 *)v141);
            if (v142 < 0) {
              operator delete(v141[0]);
            }
          }
        }

        v111 = (os_log_s *)(id)qword_1008F7588;
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
        {
          v112 = [v136 UTF8String];
          *(_DWORD *)buf = 138412803;
          *(void *)&uint8_t buf[4] = v104;
          *(_WORD *)&_BYTE buf[12] = 2160;
          *(void *)&_BYTE buf[14] = 1752392040LL;
          *(_WORD *)&buf[22] = 2081;
          *(void *)&_BYTE buf[24] = v112;
          _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_DEFAULT,  "Generated for local device %@ with IDS device %{private, mask.hash}s",  buf,  0x20u);
        }

        int v27 = v104;
        goto LABEL_156;
      }

      int v75 = (os_log_s *)(id)qword_1008F7588;
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v162) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "SMP_Crypto_f5 failed",  (uint8_t *)&v162,  2u);
      }
    }

    int v76 = 1;
    goto LABEL_90;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_ERROR)) {
    sub_100683AB0();
  }
  int v27 = 0LL;
LABEL_159:

  return v27;
}

                  sub_100241F90(buf, v3);
                  sub_100594AE4(a1, buf);
                  goto LABEL_93;
                default:
LABEL_93:
                  id v5 = 0LL;
LABEL_94:
                  uint64_t v41 = sub_100404FE8();
                  sub_100405384(v41, &stru_1008A2458);
                  break;
              }
            }
          }
        }
      }

      else
      {
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
          sub_100697E3C();
        }
        id v5 = 149LL;
      }
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
        sub_100697EA0();
      }
      id v5 = 8LL;
    }
  }

          sub_1005911F0(a1, 0);
LABEL_93:
          uint64_t v49 = 1;
LABEL_415:
          v280 = sub_100241F94(uu);
          v281 = (void *)objc_claimAutoreleasedReturnValue(v280);
          sub_1005A2C94((uint64_t)v281, v281, 3u, a3, a6);

          v282 = *(_DWORD *)(a1 + 928);
          if (v282)
          {
            uint64_t v44 = qword_1008F7620;
            if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_423;
            }
            if (v282 > 3) {
              v283 = "UNKNOWN";
            }
            else {
              v283 = off_1008A2CB8[v282 - 1];
            }
            *(_DWORD *)v327 = 136446210;
            v328 = v283;
            uint64_t v17 = "Skipping processConnectingDevices, current LE Connection Manager State is %{public}s";
            uint64_t v18 = v327;
            goto LABEL_426;
          }

          if (!v49)
          {
            v284 = qword_1008F7620;
            if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_423;
            }
            *(_DWORD *)v327 = 67109120;
            LODWORD(v32_Block_object_dispose((const void *)(v15 - 96), 8) = 0;
            uint64_t v17 = "Skipping processConnectingDevices, reissueConnections=%d";
            uint64_t v18 = v327;
            id v19 = (os_log_s *)v284;
            uint64_t v20 = 8;
            goto LABEL_22;
          }

void sub_100049F70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, unsigned int *a46)
{
  if (a46) {
    sub_1002CD254(a46);
  }

  _Unwind_Resume(a1);
}

void sub_10004A304( uint64_t a1, void *a2, unsigned int a3, char a4, uint64_t a5, uint64_t a6, char a7, char a8, char a9, char a10, char a11, void *a12, char a13, char a14, char a15, char a16, char a17, void *a18, int a19, int a20, int a21)
{
  id v22 = a2;
  sub_100050850( (uint64_t)v36,  v22,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10,  a11,  a12,  a13,  a14,  a15,  a16,  a17,  a18,  a19,  a20,  a21);
  unint64_t v23 = *(void *)(a1 + 72);
  if (v23 >= *(void *)(a1 + 80))
  {
    uint64_t v24 = sub_1000504C4((uint64_t *)(a1 + 64), (uint64_t *)v36);
  }

  else
  {
    sub_1000505CC(a1 + 80, *(void *)(a1 + 72), (uint64_t *)v36);
    uint64_t v24 = v23 + 96;
    *(void *)(a1 + 72) = v23 + 96;
  }

  *(void *)(a1 + 72) = v24;

  int v38 = &off_10087FAA8;
  if (v39) {
    sub_1002CD254(v39);
  }
  v36[2] = &off_10087FAA8;
  if (v37) {
    sub_1002CD254(v37);
  }

  id v25 = *(id *)(a1 + 152);
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithSet:](&OBJC_CLASS___NSMutableSet, "setWithSet:", v25));

  [v26 addObject:v22];
  int v27 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v26;

  if (a9 == 1)
  {
    unint64_t v28 = (unint64_t)a3 >> 6;
    uint64_t v29 = 1LL << a3;
    *(void *)(a1 + 8 * v28 + 208) |= 1LL << a3;
  }

  else
  {
    *(_BYTE *)(a1 + 272) = 1;
    unint64_t v28 = (unint64_t)a3 >> 6;
    uint64_t v29 = 1LL << a3;
  }

  *(void *)(a1 + 8 * v28 + 240) |= v29;
}

void sub_10004A50C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  _Unwind_Resume(a1);
}

LABEL_17:
          self->_anyRangeScan = 1;
          goto LABEL_18;
        }
      }
    }

    uint64_t v8 = -[NSArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v44,  v48,  16LL);
    if (v8) {
      continue;
    }
    break;
  }

        unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer stackController](self->_daemon, "stackController"));
        uint64_t v24 = v49;
        __int128 v37 = v49[5];
        id v25 = [v23 sendRelayMessageType:v14 messageData:v54 conduitDevice:v43 destinationDevice:v41 error:&v37];
        objc_storeStrong(v24 + 5, v37);

        if (!v25)
        {
LABEL_21:

LABEL_22:
LABEL_23:

          goto LABEL_24;
        }

        Reply = CUXPCDictionaryCreateReply(v4);
        int v27 = (id)objc_claimAutoreleasedReturnValue(Reply);
        if (v27)
        {
          -[CBDaemonXPCConnection _xpcSendReply:](self, "_xpcSendReply:", v27);
        }

        else if (dword_1008D6630 <= 90 {
               && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
        }
        {
          LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendRelayMessage:]",  90LL,  "### SendRelayMessage create reply failed");
        }

    int v11 = 0LL;
    goto LABEL_8;
  }

  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  if ((objc_opt_isKindOfClass(v5, v6) & 1) != 0)
  {
    CFDataOfLength = CFDictionaryGetCFDataOfLength(v5, &off_1008C28D0, 3LL, 0LL);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(CFDataOfLength);
    int v9 = CFDictionaryGetCFDataOfLength(v5, &off_1008C28B8, 16LL, 0LL);
    id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    if (v10)
    {
      int v11 = objc_alloc_init(&OBJC_CLASS___CBSpatialInteractionPeerInfoDaemon);
      -[CBSpatialInteractionPeerInfoDaemon setIdentifierData:](v11, "setIdentifierData:", v8);
      -[CBSpatialInteractionPeerInfoDaemon setIrkData:](v11, "setIrkData:", v10);
      -[CBSpatialInteractionPeerInfoDaemon setTokenData:](v11, "setTokenData:", v20);
    }

    else if (a4)
    {
      uint64_t v18 = CBErrorF(312900LL, "Bad IRK length");
      int v11 = 0LL;
      *a4 = (id)objc_claimAutoreleasedReturnValue(v18);
    }

    else
    {
      int v11 = 0LL;
    }

    goto LABEL_8;
  }

  if (!a4) {
    goto LABEL_17;
  }
  uint64_t v17 = CBErrorF(312900LL, "Non-dict token");
  int v11 = 0LL;
  *a4 = (id)objc_claimAutoreleasedReturnValue(v17);
LABEL_8:

LABEL_9:
  return v11;
}

  uint64_t v20 = 0;
  *a7 = v24;
LABEL_8:

LABEL_9:
  return v20;
}

    v6 += 36LL;
  }

  while (v6 != 1080);
  id v22 = 0LL;
  while (!*(void *)&word_1008DEBF0[v22 + 8] || (unsigned __int16)word_1008DEBF0[v22 + 1] != (_DWORD)a2)
  {
    v22 += 36LL;
    if (v22 == 1080)
    {
      sub_1000B5834();
      return;
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"scheduleIdleChannelCleanup from disconnectRspCleanup for cid=%d result=%d",  v23,  v24,  v25,  v26,  v27,  v28,  v29,  a2);
    uint64_t v30 = (os_log_s *)sub_100086554(0x52u);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      uint64_t v33 = v31;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  sub_1000B5B20();
}

  if (*(_DWORD *)(v4 + 48LL * a1 + 32) || *(_BYTE *)(v4 + 48LL * a1 + 28))
  {
    uint64_t v17 = v4 + 48LL * a1;
    id v19 = *(_DWORD *)(v17 + 24);
    uint64_t v18 = (int *)(v17 + 24);
    if (!v19)
    {
      v41[1] = (const void *)(v4 + 48LL * a1);
      v41[0] = (const void *)2;
      uint64_t v6 = sub_1001EE6E8((uint64_t)sub_1000F6D58, v41, 50, v18);
      if ((_DWORD)v6)
      {
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Register disconnect timeout handler failed %!\n",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v6);
          int v27 = (os_log_s *)sub_100086554(0x10u);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            sub_100657F74();
          }
        }
      }
    }
  }

  else
  {
    __int128 v37 = *(unsigned int *)(v4 + 48LL * a1 + 24);
    if ((_DWORD)v37)
    {
      sub_1001EEB14(v37);
      __int16 v4 = qword_1008E1E58;
      *(_DWORD *)(qword_1008E1E58 + 48LL * a1 + 24) = 0;
    }

    int v38 = *(void (**)(uint64_t *))(v4 + 392);
    if (v38)
    {
      uint64_t v39 = v4 + 48LL * a1;
      WORD2(v42) = *(_WORD *)v39;
      LODWORD(v42) = 2;
      LODWORD(v43) = *(_DWORD *)(v39 + 4);
      v38(&v42);
    }

    sub_1000F5A88(a1);
  }

  return v6;
}

  id v22 = 1737LL;
LABEL_18:
  if (*(_DWORD *)(a1 + 32) == 1) {
    *(_DWORD *)(a1 + 32) = 0;
  }
  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"OBEXCOMMON Received Packet error %!", v23, v24, v25, v26, v27, v28, v29, v22);
    uint64_t v30 = (os_log_s *)sub_100086554(0x18u);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return v22;
}

  sub_1000B1838(v5);
  *a2 = 0LL;
  if (v7) {
    return 0LL;
  }
  return 1318LL;
}

  if (a2)
  {
    v22[2] = v25;
    v22[3] = v26;
    v22[4] = v27;
    v22[0] = v23;
    v22[1] = v24;
    a2(a1, v22);
  }

  uint64_t v62 = 0;
  uint64_t v13 = 1;
  *((_BYTE *)a1 + 15) = 1;
LABEL_18:
  uint64_t v15 = v9 + a3;
  if ((int)v9 + a3 > (unsigned __int16)v12)
  {
    uint64_t v16 = 0LL;
    uint64_t v67 = 0LL;
    uint64_t v68 = 0LL;
    int v69 = 0LL;
    BOOL v70 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v18 = 0;
    while (2)
    {
      if (*((_BYTE *)a1 + 15)) {
        goto LABEL_97;
      }
      if (*((_BYTE *)a1 + 14) != 1) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1338,  "(*pBs).__RWFlag == BYTESTREAM_READ");
      }
      id v19 = *((unsigned __int16 *)a1 + 5);
      if (v19 <= (unsigned __int16)v12)
      {
        *((_BYTE *)a1 + 15) = 1;
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      }

      else
      {
        uint64_t v20 = *a1;
        *((_WORD *)a1 + 6) = v12 + 1;
        uint64_t v17 = *(unsigned __int8 *)(v20 + (unsigned __int16)v12);
        if (v19 > (unsigned __int16)(v12 + 1))
        {
          int v21 = *a1;
          *((_WORD *)a1 + 6) = v12 + 2;
          uint64_t v18 = *(unsigned __int8 *)(v21 + (unsigned __int16)v12 + 1LL);
          id v22 = 1;
LABEL_27:
          switch((int)v17)
          {
            case 1:
              if (*((_BYTE *)a1 + 14) != 1) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1342,  "(*pBs).__RWFlag == BYTESTREAM_READ");
              }
              if ((v22 & 1) == 0)
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_59:
                *((_BYTE *)a1 + 15) = 1;
                goto LABEL_60;
              }

              unint64_t v23 = *((unsigned __int16 *)a1 + 6);
              HIWORD(v73) = *(_WORD *)(*a1 + v23);
              *((_WORD *)a1 + 6) = v23 + 2;
LABEL_60:
              int v69 = (char *)&v73 + 2;
LABEL_90:
              uint64_t v12 = *((unsigned __int16 *)a1 + 6);
              if (v15 <= v12)
              {
                if (*((_BYTE *)a1 + 15)) {
                  goto LABEL_97;
                }
                goto LABEL_101;
              }

              continue;
            case 2:
              if (*((_BYTE *)a1 + 14) != 1) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1346,  "(*pBs).__RWFlag == BYTESTREAM_READ");
              }
              if ((v22 & 1) != 0)
              {
                uint64_t v33 = *((unsigned __int16 *)a1 + 6);
                if (*((unsigned __int16 *)a1 + 5) - (int)v33 >= 2)
                {
                  LOWORD(v73) = *(_WORD *)(*a1 + v33);
                  *((_WORD *)a1 + 6) = v33 + 2;
LABEL_63:
                  BOOL v70 = &v73;
                  goto LABEL_90;
                }
              }

              else
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              }

              *((_BYTE *)a1 + 15) = 1;
              goto LABEL_63;
            case 3:
              if (*((_BYTE *)a1 + 14) != 1) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1361,  "(*pBs).__RWFlag == BYTESTREAM_READ");
              }
              if ((v22 & 1) != 0)
              {
                uint64_t v34 = *((unsigned __int16 *)a1 + 5);
                __int16 v35 = *((unsigned __int16 *)a1 + 6);
                if (v34 > v35)
                {
                  char v36 = *a1;
                  *((_WORD *)a1 + 6) = v35 + 1;
                  HIBYTE(v72) = *(_BYTE *)(v36 + v35);
                  __int128 v37 = v34 - (v35 + 1);
LABEL_66:
                  if (v37 >= v18 - 1) {
                    *((_WORD *)a1 + 6) += v18 - 1;
                  }
                  else {
                    *((_BYTE *)a1 + 15) = 1;
                  }
                  uint64_t v68 = (char *)&v72 + 1;
                  goto LABEL_90;
                }
              }

              else
              {
                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              }

              *((_BYTE *)a1 + 15) = 1;
              sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              __int128 v37 = 0;
              goto LABEL_66;
            case 4:
              if (*((_BYTE *)a1 + 14) != 1) {
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1351,  "(*pBs).__RWFlag == BYTESTREAM_READ");
              }
              if (v22)
              {
                int v38 = *((unsigned __int16 *)a1 + 6);
                if (*((unsigned __int16 *)a1 + 5) > v38)
                {
                  uint64_t v39 = *a1;
                  *((_WORD *)a1 + 6) = v38 + 1;
                  BYTE10(v71[0]) = *(_BYTE *)(v39 + v38);
                  if (*((unsigned __int16 *)a1 + 5) > (v38 + 1))
                  {
                    id v40 = *a1;
                    id v41 = v38 + 2;
                    *((_WORD *)a1 + 6) = v38 + 2;
                    BYTE11(v71[0]) = *(_BYTE *)(v40 + v38 + 1);
                    if (*((unsigned __int16 *)a1 + 5) > (v38 + 2))
                    {
                      __int16 v42 = *a1;
                      BOOL v43 = v38 + 3;
                      *((_WORD *)a1 + 6) = v43;
                      BYTE12(v71[0]) = *(_BYTE *)(v42 + v41);
                      if (*((unsigned __int16 *)a1 + 5) - v43 > 1)
                      {
                        HIWORD(v71[0]) = *(_WORD *)(*a1 + v43);
                        *((_WORD *)a1 + 6) = v43 + 2;
                        if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v43 + 2) > 1)
                        {
                          LOWORD(v71[1]) = *(_WORD *)(*a1 + (unsigned __int16)(v43 + 2));
                          *((_WORD *)a1 + 6) = v43 + 4;
                          if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v43 + 4) >= 2)
                          {
                            WORD1(v71[1]) = *(_WORD *)(*a1 + (unsigned __int16)(v43 + 4));
                            *((_WORD *)a1 + 6) = v43 + 6;
LABEL_89:
                            uint64_t v16 = v71;
                            goto LABEL_90;
                          }

  *(_DWORD *)(a1 + 132) = 7;
  *(_BYTE *)(a1 + 316) = 0;
}

        sub_1001E737C(105, v19, v20, v21, v22, v23, v24, v25);
        sub_1001EE2A0();
        break;
    }
  }

  else if (((sub_1001C3170(a1, (uint64_t)v49) & 1) != 0 {
          || (*(unsigned int (**)(uint64_t, void *))(qword_1008EDD28 + 32))(a1, v49))
  }
         && (dword_1008EDD24 != 5
          || dword_1008EDD70 != 1
          || sub_1001E9A5C(HIBYTE(dword_1008EDD40), dword_1008EDD60, v50)))
  {
    int v27 = sub_1001214B4(10, (uint64_t)sub_1001E9CC4, a3, a4, a5, a6, a7, a8, a1);
    if ((_DWORD)v27)
    {
      unint64_t v28 = v27;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_HCICMD_LinkKeyRequestReply %!", v29, v30, v31, v32, v33, v34, v35, v28);
        char v36 = (os_log_s *)sub_100086554(0x37u);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
          goto LABEL_34;
        }
      }
    }

    return;
  }

  int v38 = sub_1001214B4(11, (uint64_t)sub_1001E9CC4, a3, a4, a5, a6, a7, a8, a1);
  if ((_DWORD)v38)
  {
    uint64_t v39 = v38;
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"OI_HCICMD_LinkKeyRequestNegativeReply %!", v40, v41, v42, v43, v44, v45, v46, v39);
      int v47 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
LABEL_34:
      }
        sub_100657F74();
    }
  }

  uint64_t v14 = BYTE1(a3);
  if (BYTE1(a3) < 5u)
  {
    uint64_t v6 = a3 >> 8;
  }

  else
  {
    uint64_t v15 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = "Siri";
      if (a4) {
        uint64_t v16 = "Next Track";
      }
      LODWORD(__p) = 67109378;
      HIDWORD(__p) = v14;
      id v19 = 2082;
      uint64_t v20 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Left double tap was %d, now %{public}s",  (uint8_t *)&__p,  0x12u);
    }
  }

  return v11 | (v6 << 8);
}

  reply = xpc_dictionary_create_reply(a2);
  uint64_t v16 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v14);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v16);
    xpc_release(v16);
  }

  return sub_100242FAC((uint64_t)v19);
}

      uint64_t v18 = (void *)v10[1];
      if (v18)
      {
        do
        {
          id v19 = v18;
          uint64_t v18 = (void *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          id v19 = (void *)v10[2];
          uint64_t v20 = *v19 == (void)v10;
          id v10 = v19;
        }

        while (!v20);
      }

      id v10 = v19;
    }

    while (v19 != v11);
  }

  sub_100242FAC((uint64_t)v21);
}

  return v14;
}

    int v9 = 0LL;
    goto LABEL_36;
  }

  LODWORD(v16.__r_.__value_.__l.__data_) = 0;
  LODWORD(v15.__r_.__value_.__l.__data_) = 0;
  LODWORD(v14.__r_.__value_.__l.__data_) = 0;
  LODWORD(v13.__r_.__value_.__l.__data_) = 0;
  sub_1003D55EC(a2, &v16, &v15, &v14, &v13);
  id v5 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v16.__r_.__value_.__l.__data_;
    LOWORD(v1_Block_object_dispose((const void *)(v15 - 96), 8) = 1024;
    *(_DWORD *)((char *)&v18 + 2) = v15.__r_.__value_.__l.__data_;
    HIWORD(v1_Block_object_dispose((const void *)(v15 - 96), 8) = 1024;
    unint64_t data = (int)v14.__r_.__value_.__l.__data_;
    uint64_t v20 = 1024;
    int v21 = (int)v13.__r_.__value_.__l.__data_;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Car Stereo Type override due to VID/PID. [VidSrc 0x%x, VID 0x%x, PID 0x%x, version 0x%x]",  buf,  0x1Au);
  }

      int v9 = sub_1003D04BC(a2);
      sub_10045035C(a1, 2u, (uint64_t)a2, v9);
      return sub_100242FAC((uint64_t)v13);
    }

    LODWORD(__p[0]) = 0;
  }

  else
  {
    if (v4) {
      goto LABEL_17;
    }
    uint64_t v8 = (os_log_s *)qword_1008F7590;
    if (os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "Got a device changed call for one we haven't found yet...",  (uint8_t *)__p,  2u);
    }
  }

  id v7 = 4LL;
LABEL_16:
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 8 * v7))(a1, a2);
  return sub_100242FAC((uint64_t)v13);
}

  sub_100242CD8(&v11);
  return v9;
}

  if ((v4 & 0x80) == 0)
  {
    uint64_t v14 = (_BYTE *)(a1 + 80);
    uint64_t v15 = *(unsigned __int8 *)(a1 + 103);
    if (!*(_BYTE *)(a1 + 103)) {
      goto LABEL_33;
    }
LABEL_21:
    uint64_t v16 = &v14[v15];
    uint64_t v17 = v14;
    uint64_t v18 = v16;
    do
    {
      if (*v17 == 45)
      {
        id v19 = &_mh_execute_header.magic + 1;
        while (v19 != 11)
        {
          if (&v17[v19] == v16) {
            goto LABEL_31;
          }
          uint64_t v20 = v17[v19];
          int v21 = aPeripheral_1[v19++];
          if (v20 != v21) {
            goto LABEL_23;
          }
        }

        uint64_t v18 = v17;
      }

      id v5 = (os_log_s *)qword_1008F7728;
      if (os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = 134217984;
        uint64_t v14 = v2;
        _os_log_error_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Invalid LEA packet size %lu",  (uint8_t *)&v13,  0xCu);
        id v5 = (os_log_s *)qword_1008F7728;
      }

      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT)) {
        sub_100667470(v5, v6, v7, v8, v9, v10, v11, v12);
      }
      return 0LL;
    }

    uint64_t result = &byte_1006C3664;
  }

  if (SHIBYTE(v18[0]) < 0) {
    operator delete(v17[1]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[1]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[1]);
  }
  nullsub_63((char *)&v12 + 1, v6);
  return v2;
}

  if (os_log_type_enabled((os_log_t)qword_1008F7748, OS_LOG_TYPE_ERROR)) {
    sub_100696B1C();
  }
  sub_1001734D8((uint64_t)v65);
  sub_100242CD0(&v66);
LABEL_22:
  sub_100583F1C(a1, 0, 0, 0, 0LL, a8, 0, *a2 | ((unint64_t)*((unsigned __int16 *)a2 + 2) << 32));
  return sub_100242CD8(&v66);
}

  uint64_t v8 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionDCKDisconnectionStageOneToDisabledValue");
  int v9 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v8 + 88LL))(v8, buf, __p, &v90);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v9) {
      goto LABEL_25;
    }
  }

  else if (!v9)
  {
    goto LABEL_25;
  }

  id v10 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v90;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDCKDisconnectionStageOneToDisabledValue=%d (override)",  buf,  8u);
  }

  sub_10008CB98((uint64_t)sub_10058EBFC);
  *(void *)buf = 0LL;
  uint64_t v39 = 0LL;
  id v40 = 0LL;
  uint64_t v8 = sub_1002E6E00();
  sub_10002418C(__p, "BTUCMCustomConnectionSegments");
  if (!(*(unsigned int (**)(uint64_t, void **, uint8_t *))(*(void *)v8 + 120LL))(v8, __p, buf)
    || v39 == *(const char **)buf)
  {
    if (v36 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_24;
  }

  int v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v39[-*(void *)buf] >> 3);
  if ((v36 & 0x80000000) == 0)
  {
    if ((v9 & 1) == 0) {
      goto LABEL_49;
    }
LABEL_24:
    *(_WORD *)(a1 + 112) = 5;
    id v10 = malloc(0x28uLL);
    *(void *)(a1 + 104) = v10;
    *id v10 = xmmword_1006C41C0;
    v10[1] = xmmword_1006C41C0;
    *((void *)v10 + 4) = 500LL;
    goto LABEL_25;
  }

  operator delete(__p[0]);
  if ((v9 & 1) != 0) {
    goto LABEL_24;
  }
LABEL_49:
  id v22 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Overriding connection schedule segments with user defined",  (uint8_t *)__p,  2u);
  }

  uint64_t v24 = *(const char **)buf;
  unint64_t v23 = v39;
  id v25 = malloc(0x5555555555555558LL * ((unint64_t)&v39[-*(void *)buf] >> 3));
  *(void *)(a1 + 104) = v25;
  if (v23 == v24)
  {
    int v27 = 0;
  }

  else
  {
    uint64_t v26 = v25;
    int v27 = 0;
    do
    {
      unint64_t v28 = v27;
      uint64_t v29 = v24[23];
      uint64_t v30 = v24;
      if ((v27 & 1) != 0)
      {
        if (v29 < 0) {
          uint64_t v30 = *(const char **)v24;
        }
        v26[2 * (v27 >> 1) + 1] = atoi(v30);
      }

      else
      {
        if (v29 < 0) {
          uint64_t v30 = *(const char **)v24;
        }
        v26[2 * (v27 >> 1)] = atoi(v30);
      }

      int v27 = v28 + 1;
      v24 += 24;
    }

    while (v24 != v23);
  }

  *(_WORD *)(a1 + 112) = v27 >> 1;
LABEL_25:
  sub_10058C84C(a1);
  uint64_t v34 = 0;
  int v11 = sub_1002E6E00();
  sub_10002418C(__p, "Sentinel");
  sub_10002418C(v32, "IsFindMyWatchCoexHandled");
  uint64_t v12 = (*(uint64_t (**)(uint64_t, void **, void **, char *))(*(void *)v11 + 72LL))(v11, __p, v32, &v34);
  if (v34) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v33 < 0) {
    operator delete(v32[0]);
  }
  if (v36 < 0)
  {
    operator delete(__p[0]);
    if (!v13) {
      goto LABEL_36;
    }
  }

  else if (!v13)
  {
    goto LABEL_36;
  }

  uint64_t v14 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Overriding to handle Coex on watchOS for FindMy.",  (uint8_t *)__p,  2u);
  }

      uint64_t v20 = 0LL;
      goto LABEL_67;
    }

    uint64_t v17 = [*(id *)(*(void *)(a1 + 8) + 56) count];
    if (v17)
    {
      int v21 = sub_100241F94(a2);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v21);
      if ((sub_100612014(a1, v5) & 1) == 0)
      {
LABEL_22:

        goto LABEL_17;
      }
    }

    uint64_t v24 = *(void *)(a1 + 8);
    if (*(_BYTE *)(v24 + 137))
    {
      uint64_t v24 = *(void *)(a1 + 8);
    }

    if (*(void *)(v24 + 64) == *(void *)(v24 + 72)) {
      goto LABEL_35;
    }
    if (sub_100612580(a1, v14, v13, a4, &v48))
    {
      uint64_t v24 = *(void *)(a1 + 8);
LABEL_35:
      if (*(void *)(v24 + 96) == *(void *)(v24 + 104))
      {
        if (!v17) {
          goto LABEL_44;
        }
        goto LABEL_14;
      }

  sub_100242FAC((uint64_t)v21);
}

        uint64_t v18 = objc_autoreleasePoolPush();
        id v19 = sub_10056AAF0(a1);
        uint64_t v20 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v19, sub_10056AAD8(a1));
        int v21 = objc_claimAutoreleasedReturnValue(v20);
        id v22 = (void *)v21;
        unint64_t v23 = &stru_1008A57D8;
        if (v21) {
          unint64_t v23 = (const __CFString *)v21;
        }
        v32[0] = v23;
        v31[0] = @"HostWakeReport";
        v31[1] = @"WakeEventType";
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
        v32[1] = v24;
        v31[2] = @"BundleID";
        if (a3) {
          id v25 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
        }
        else {
          id v25 = @"Unknown";
        }
        v32[2] = v25;
        v31[3] = @"CBUUID";
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a4));
        v32[3] = v26;
        v31[4] = @"DeviceName";
        int v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a5));
        v32[4] = v27;
        v31[5] = @"PeerType";
        unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a6));
        v32[5] = v28;
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v32,  v31,  6LL));

        if (a3) {
        PLLogRegisteredEvent(35LL, @"HostWakeReport", v29, 0LL);
        }

        objc_autoreleasePoolPop(v18);
        break;
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10069FECC();
  }

    uint64_t v14 = 0LL;
    goto LABEL_18;
  }

  if (!a1)
  {
    uint64_t v17 = (os_log_s *)qword_1008F7698;
    if (os_log_type_enabled((os_log_t)qword_1008F7698, OS_LOG_TYPE_ERROR)) {
      sub_1006A0F84(v17);
    }
    a4 = 0LL;
    goto LABEL_17;
  }

  sub_100494958(a1, (uint64_t)__p);
  id v10 = v23;
  int v11 = *(_BYTE **)__p;
  uint64_t v12 = +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding");
  if (v10 >= 0) {
    uint64_t v13 = __p;
  }
  else {
    uint64_t v13 = v11;
  }
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  v13,  v12));
  if (v23 < 0) {
    operator delete(*(void **)__p);
  }
  if ((sub_10064BD04(v14) & 1) == 0)
  {
    uint64_t v16 = sub_10064BBB8(v14);
    goto LABEL_20;
  }

  uint64_t v15 = v7;
  if (v7 || (uint64_t v15 = v8) != 0LL)
  {
    uint64_t v16 = sub_10064BBB8(v15);
LABEL_20:
    a4 = v16;
    goto LABEL_21;
  }

  a4 = 0LL;
LABEL_21:
  id v19 = (os_log_s *)qword_1008F7698;
  if (os_log_type_enabled((os_log_t)qword_1008F7698, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__p = 138543618;
    *(void *)&__p[4] = v14;
    int v21 = 2048;
    id v22 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "getConnectionUseCase directConnectionClientString %{public}@ connectionUseCase %ld",  __p,  0x16u);
  }

LABEL_95:
}

        LOBYTE(v11) = 0;
        goto LABEL_86;
      }

      if (-[AudioAccessoryDeviceConfig allowOffListeningMode](v12, "allowOffListeningMode"))
      {
        if (-[AudioAccessoryDeviceConfig allowOffListeningMode](v12, "allowOffListeningMode") == 1) {
          uint64_t v14 = 1LL;
        }
        else {
          uint64_t v14 = 2LL;
        }
        if (dword_1008D66A0 <= 30
          && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
        {
          LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ allowOffListeningMode: %d",  v10,  v14);
        }

        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v15 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)v11, 52LL, v14, 2u);
      }

      else
      {
        uint64_t v15 = 0;
      }

      if (-[AudioAccessoryDeviceConfig autoANCStrength](v12, "autoANCStrength"))
      {
        uint64_t v16 = -[AudioAccessoryDeviceConfig autoANCStrength](v12, "autoANCStrength") - 1000;
        if (dword_1008D66A0 <= 30
          && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
        {
          LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ autoANCStrength: %d",  v10,  v16);
        }

        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v15 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)v11, 46LL, v16, 2u);
      }

      if (-[AudioAccessoryDeviceConfig enableSiriMultitone](v12, "enableSiriMultitone"))
      {
        if (-[AudioAccessoryDeviceConfig enableSiriMultitone](v12, "enableSiriMultitone") == 1) {
          uint64_t v17 = 1LL;
        }
        else {
          uint64_t v17 = 2LL;
        }
        if (dword_1008D66A0 <= 30
          && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
        {
          LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ enableSiriMultitone: %d",  v10,  v17);
        }

        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v15 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)v11, 50LL, v17, 2u);
      }

      if (-[AudioAccessoryDeviceConfig enableHearingAidGainSwipe](v12, "enableHearingAidGainSwipe"))
      {
        if (-[AudioAccessoryDeviceConfig enableHearingAidGainSwipe](v12, "enableHearingAidGainSwipe") == 1) {
          uint64_t v18 = 1LL;
        }
        else {
          uint64_t v18 = 2LL;
        }
        if (dword_1008D66A0 <= 30
          && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
        {
          LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ enableHearingAidGainSwipe: %d",  v10,  v18);
        }

        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v15 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)v11, 47LL, v18, 2u);
      }

      if (-[AudioAccessoryDeviceConfig enableHearingAssist](v12, "enableHearingAssist"))
      {
        if (-[AudioAccessoryDeviceConfig enableHearingAssist](v12, "enableHearingAssist") == 1) {
          id v19 = 1LL;
        }
        else {
          id v19 = 2LL;
        }
        if (dword_1008D66A0 <= 30
          && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
        {
          LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ enableHearingAssist: %d",  v10,  v19);
        }

        if (qword_1008D60E0 != -1) {
          dispatch_once(&qword_1008D60E0, &stru_1008811C8);
        }
        uint64_t v15 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)v11, 51LL, v19, 2u);
      }

      if (-[AudioAccessoryDeviceConfig hearingAidToggle](v12, "hearingAidToggle")
        && !-[AudioAccessoryDeviceConfig hearingAidEnrolled](v12, "hearingAidEnrolled"))
      {
        id v22 = -[AudioAccessoryDeviceConfig hearingAidToggle](v12, "hearingAidToggle");
        unint64_t v23 = sub_1003E5D28((uint64_t)v11);
        if (dword_1008D66A0 <= 30
          && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
        {
          LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ hearingAidToggle: %d",  v10,  -[AudioAccessoryDeviceConfig hearingAidToggle](v12, "hearingAidToggle"));
        }

        uint64_t v24 = v23 | (v22 << 8);
        if (qword_1008D60E0 == -1) {
          goto LABEL_72;
        }
      }

      else
      {
        if (-[AudioAccessoryDeviceConfig hearingAidToggle](v12, "hearingAidToggle")
          || !-[AudioAccessoryDeviceConfig hearingAidEnrolled](v12, "hearingAidEnrolled"))
        {
LABEL_73:
          if (-[AudioAccessoryDeviceConfig enableHeartRateMonitor](v12, "enableHeartRateMonitor"))
          {
            if (-[AudioAccessoryDeviceConfig enableHeartRateMonitor](v12, "enableHeartRateMonitor") == 1) {
              id v25 = 1LL;
            }
            else {
              id v25 = 2LL;
            }
            if (dword_1008D66A0 <= 30
              && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
            {
              LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ enableHeartRateMonitor: %d",  v10,  v25);
            }

            if (qword_1008D60E0 != -1) {
              dispatch_once(&qword_1008D60E0, &stru_1008811C8);
            }
            uint64_t v15 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)v11, 48LL, v25, 2u);
          }

          LOBYTE(v11) = 1;
          if (!v15 || v15 == -310000) {
            goto LABEL_86;
          }
          if (a5)
          {
            uint64_t v30 = CBErrorF((v15 + 310000), "SendAudioAccessoryConfig failed");
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v30);
            goto LABEL_94;
          }

          goto LABEL_95;
        }

        uint64_t v20 = sub_1003E5E08((uint64_t)v11);
        int v21 = -[AudioAccessoryDeviceConfig hearingAidEnrolled](v12, "hearingAidEnrolled");
        if (dword_1008D66A0 <= 30
          && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL)))
        {
          LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack sendAudioAccessoryConfig:device:error:]",  30LL,  "SendAudioAccessoryConfig sendControlCommand for device %@ hearingAidEnrolled: %d",  v10,  -[AudioAccessoryDeviceConfig hearingAidEnrolled](v12, "hearingAidEnrolled"));
        }

        uint64_t v24 = v21 | (v20 << 8);
        if (qword_1008D60E0 == -1)
        {
LABEL_72:
          uint64_t v15 = sub_100215778((uint64_t)off_1008D60D8, (uint64_t)v11, 44LL, v24, 2u);
          goto LABEL_73;
        }
      }

      dispatch_once(&qword_1008D60E0, &stru_1008811C8);
      goto LABEL_72;
    }
  }

  else if (a5)
  {
    int v27 = CBErrorF(4294960588LL, "No device ID");
    LOBYTE(v11) = 0;
    *a5 = (id)objc_claimAutoreleasedReturnValue(v27);
  }

  else
  {
    LOBYTE(v11) = 0;
  }

      if (*(_BYTE *)(v28 + 45))
      {
        if (qword_1008D5F20 != -1) {
          dispatch_once(&qword_1008D5F20, &stru_10088BB60);
        }
        sub_100622B64(qword_1008D5F18, v7, 1);
      }

      if ((v66 & 1) == 0)
      {
        int v48 = *(void *)(v28 + 120);
        if (v48) {
          (*(void (**)(uint64_t, void, id, void))(*(void *)v48 + 24LL))(v48, 0LL, v7, v71);
        }
      }

      goto LABEL_102;
    }
  }

  *(_WORD *)(a1 + 1452) = 2048;
  __int16 v42 = 0;
  __int128 v37 = sub_1002E6E00();
  sub_10002418C(buf, "AoS");
  sub_10002418C(__p, "MaxRetryInFrames");
  int v38 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v37 + 128LL))(v37, buf, __p, &v42);
  if (v47 < 0) {
    operator delete(__p[0]);
  }
  if (v50 < 0)
  {
    operator delete(*(void **)buf);
    if (!v38) {
      goto LABEL_103;
    }
  }

  else if (!v38)
  {
    goto LABEL_103;
  }

  *(_BYTE *)(a1 + 1452) = 1;
  uint64_t v39 = v42;
  *(_BYTE *)(a1 + 1453) = v42;
  id v40 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = 1;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v39;
    _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Override Advanced sniff mode Parameters %d, MaxRetryInFrames= %d ",  buf,  0xEu);
  }

      int v45 = v17 == (char *)v28;
      uint64_t v17 = v102;
      if (v45)
      {
        v97 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR)) {
          sub_100674D54(v41, v97, v98);
        }
        sub_1001C4E78(*(unsigned __int16 **)(a2 + 8));
        uint64_t v14 = 909LL;
        goto LABEL_29;
      }
    }

  v98 = 0;
  uint64_t v50 = sub_1002E6E00();
  sub_10002418C(buf, "LeObserver");
  sub_10002418C(__p, "OverrideContactTracingScanDurationSeconds");
  uint64_t v51 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v50 + 88LL))(v50, buf, __p, &v98);
  if (v98) {
    uint64_t v52 = v51;
  }
  else {
    uint64_t v52 = 0;
  }
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v52) {
      goto LABEL_107;
    }
  }

  else if (!v52)
  {
    goto LABEL_107;
  }

  *(_DWORD *)(a1 + 252) = v98;
  __int16 v53 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v53 + 176LL))(v53))
  {
    int v54 = (os_log_s *)qword_1008F76C8;
    if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
    {
      uint32_t v55 = *(_DWORD *)(a1 + 252);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v55;
      _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "Overriding fContactTracingScanDuration with %d seconds",  buf,  8u);
    }
  }

  __int128 v37 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "LeConnectionLatencyHighSupervisionTimeout");
  int v38 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v37 + 88LL))(v37, buf, __p, &v94);
  if (v93 < 0) {
    operator delete(__p[0]);
  }
  if (v100 < 0)
  {
    operator delete(*(void **)buf);
    if (!v38) {
      goto LABEL_106;
    }
  }

  else if (!v38)
  {
    goto LABEL_106;
  }

  uint64_t v39 = v94;
  id v40 = (os_log_s *)qword_1008F7620;
  if ((v94 - 100) >= 0x7C9D && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v39;
    _os_log_fault_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_FAULT,  "Override rejected latency supervisionTimeout:%d LeConnectionLatencyHigh",  buf,  8u);
    LOWORD(v39) = v94;
    id v40 = (os_log_s *)qword_1008F7620;
  }

  *(_WORD *)(a1 + 1096) = v39;
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = (unsigned __int16)v39;
    _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "Override latency supervisionTimeout:%d LeConnectionLatencyHigh",  buf,  8u);
  }

      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_10087FAA8;
      if (__p.__r_.__value_.__l.__size_) {
        sub_1002CD254((unsigned int *)__p.__r_.__value_.__l.__size_);
      }
      ++v38;
      uint64_t v39 = (__n128 *)((char *)v39 + 56);
      if (v38 >= v79[5632]) {
        goto LABEL_101;
      }
    }
  }

  int v77 = 0;
LABEL_101:
  *((_DWORD *)v2 + 7_Block_object_dispose((const void *)(v15 - 96), 8) = v76;
  *((_BYTE *)v2 + 316) = v77;
  int v47 = *(_BYTE *)(v78 + 313);
  if (*(_BYTE *)(v78 + 345))
  {
    *((_BYTE *)v2 + 219) = v47;
    int v48 = v79;
  }

  else
  {
    uint64_t v49 = (v47 & 7) + 37;
    *((_BYTE *)v2 + 219) = v49;
    *((_BYTE *)v2 + 220) = (v49 & 8) != 0;
    int v48 = v79;
    if (*(_BYTE *)(v78 + 341)) {
      *((_BYTE *)v2 + 219) = *(_BYTE *)(v78 + 349);
    }
  }

  if (*(_BYTE *)(v78 + 273))
  {
    sub_10056AB04(buf, v48 + 5907, 7uLL);
    sub_10002EAC8((uint64_t)(v2 + 17), (uint64_t)buf);
    *(void *)buf = &off_10087FAA8;
    if (*(void *)&buf[8]) {
      sub_1002CD254(*(unsigned int **)&buf[8]);
    }
  }

  uint64_t v50 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v50 + 520LL))(v50)
    && (uint64_t v51 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v51 + 648LL))(v51)))
  {
    *((_BYTE *)v2 + 365) = *(_BYTE *)(v78 + 348) != 0;
    uint64_t v52 = *(_BYTE *)(v78 + 353) != 0;
  }

  else
  {
    uint64_t v52 = 0;
    *((_BYTE *)v2 + 365) = 0;
  }

  *((_BYTE *)v2 + 36_Block_object_dispose((const void *)(v15 - 96), 8) = v52;
  __int16 v53 = sub_1002E6BF0();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v53 + 536LL))(v53))
  {
    int v54 = *(_BYTE *)(v78 + 351) != 0;
  }

  else
  {
    uint32_t v55 = sub_1002E6BF0();
    else {
      int v54 = 1;
    }
  }

  *((_BYTE *)v2 + 366) = v54;
  uint64_t v56 = sub_1002E6BF0();
  else {
    uint64_t v57 = 0;
  }
  *((_BYTE *)v2 + 367) = v57;
  int v58 = sub_1002E6E9C();
  else {
    uint64_t v59 = 0;
  }
  *((_BYTE *)v2 + 369) = v59;
  BOOL v60 = (unsigned __int8 *)*((void *)v48 + 1);
  int v61 = *v60;
  uint64_t v62 = ((unint64_t)v60[1] << 40) | ((unint64_t)v60[2] << 32) | ((unint64_t)v60[3] << 24) | ((unint64_t)v60[4] << 16) | ((unint64_t)v60[5] << 8) | v60[6];
  int v63 = *v48;
  int v64 = v48[2555];
  int v65 = *(unsigned __int8 *)(v78 + 341);
  uint32_t v66 = v48[16];
  uint64_t v67 = *(unsigned __int8 *)(v78 + 342);
  uint64_t v68 = *(unsigned __int8 *)(v78 + 343);
  *((_BYTE *)v2 + 304) = v68;
  *((_BYTE *)v2 + 370) = *(_BYTE *)(v78 + 344);
  int v69 = *(unsigned __int8 *)(v78 + 345);
  *((_BYTE *)v2 + 305) = v69;
  *((_BYTE *)v2 + 14) = v48[2556];
  BOOL v70 = *(unsigned __int8 *)(v78 + 346);
  *((_BYTE *)v2 + 306) = v70;
  *((_WORD *)v2 + 236) = *((_WORD *)v48 + 2984);
  *((_WORD *)v2 + 237) = *((_WORD *)v48 + 3011);
  if (v70)
  {
    int v71 = ((unint64_t)v60[2] << 32) | ((unint64_t)v60[1] << 40) | ((unint64_t)v60[3] << 24) | ((unint64_t)v60[4] << 16) | ((unint64_t)v60[5] << 8) | v60[6] | (unint64_t)(v61 << 48);
  }

  else
  {
    int v72 = (unsigned __int8 *)*((void *)v48 + 749);
    int v73 = *v72;
    if (v73 > 1) {
      int v71 = 0LL;
    }
    else {
      int v71 = (v73 << 48) | ((unint64_t)v72[1] << 40) | ((unint64_t)v72[2] << 32) | ((unint64_t)v72[3] << 24) | ((unint64_t)v72[4] << 16) | ((unint64_t)v72[5] << 8) | v72[6];
    }
  }

  char v74 = v62 | (v61 << 48);
  v2[26] = v71;
  if (v69 | v68 | v70)
  {
    if (qword_1008D6608 != -1) {
      dispatch_once(&qword_1008D6608, &stru_1008A3FF8);
    }
    sub_1005F65B4((uint64_t)off_1008D6600, v74, v63, (uint64_t)&v104, v64, v65 != 0, v67 != 0, v66);
  }

  else
  {
    int v75 = sub_100404FE8();
    v80[0] = _NSConcreteStackBlock;
    v80[1] = 3321888768LL;
    v80[2] = sub_1005FB0D0;
    v80[3] = &unk_1008A3C60;
    __int16 v83 = v63;
    v80[4] = v74;
    __int16 v81 = &off_10087FAE8;
    int v82 = (unsigned int *)v2;
    sub_1002CD1E0((uint64_t)v2);
    int v84 = v64;
    __int16 v85 = v65;
    int v86 = v67;
    __int16 v87 = v66;
    sub_100405384(v75, v80);
    __int16 v81 = &off_10087FAE8;
    if (v82) {
      sub_1002CD254(v82);
    }
  }

  v104 = &off_10087FAE8;
  if (v105) {
    sub_1002CD254(v105);
  }
}

void sub_10004ADA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22)
{
  _Unwind_Resume(a1);
}

void sub_10004B170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10004B510( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void sub_10004B5A8( void *a1, void *a2, void *a3, __int128 *a4, uint64_t a5, uint64_t a6, char a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14)
{
  id v17 = a2;
  id v18 = a3;
  __int128 v42 = *a4;
  int v43 = *((_DWORD *)a4 + 4);
  id v19 = v18;
  sub_100050CDC((uint64_t)v44, v17, v18, (uint64_t)&v42, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, 1);
  unint64_t v20 = a1[13];
  if (v20 >= a1[14])
  {
    uint64_t v21 = sub_1000509A0(a1 + 12, v44);
  }

  else
  {
    sub_100050AC0((uint64_t)(a1 + 14), a1[13], v44);
    uint64_t v21 = v20 + 112;
    a1[13] = v20 + 112;
  }

  a1[13] = v21;

  int v47 = &off_10087FAA8;
  if (v48) {
    sub_1002CD254(v48);
  }
  int v45 = &off_10087FAA8;
  if (v46) {
    sub_1002CD254(v46);
  }

  unint64_t v22 = a1[3];
  unint64_t v23 = a1[2];
  if (v23 >= v22)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v23 - v26) >> 2);
    unint64_t v28 = v27 + 1;
    if (v27 + 1 > 0xCCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v29 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22 - v26) >> 2);
    if (2 * v29 > v28) {
      unint64_t v28 = 2 * v29;
    }
    if (v29 >= 0x666666666666666LL) {
      unint64_t v30 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30) {
      uint64_t v31 = (char *)sub_100050420((uint64_t)(a1 + 3), v30);
    }
    else {
      uint64_t v31 = 0LL;
    }
    int v32 = &v31[20 * v27];
    uint64_t v33 = &v31[20 * v30];
    __int128 v34 = *a4;
    *((_DWORD *)v32 + 4) = *((_DWORD *)a4 + 4);
    *(_OWORD *)int v32 = v34;
    id v25 = v32 + 20;
    char v36 = (char *)a1[1];
    __int16 v35 = (char *)a1[2];
    if (v35 != v36)
    {
      do
      {
        __int128 v37 = *(_OWORD *)(v35 - 20);
        *((_DWORD *)v32 - 1) = *((_DWORD *)v35 - 1);
        *(_OWORD *)(v32 - 20) = v37;
        v32 -= 20;
        v35 -= 20;
      }

      while (v35 != v36);
      __int16 v35 = (char *)a1[1];
    }

    a1[1] = v32;
    a1[2] = v25;
    a1[3] = v33;
    if (v35) {
      operator delete(v35);
    }
  }

  else
  {
    __int128 v24 = *a4;
    *(_DWORD *)(v23 + 16) = *((_DWORD *)a4 + 4);
    *(_OWORD *)unint64_t v23 = v24;
    id v25 = (char *)(v23 + 20);
  }

  a1[2] = v25;
}

void sub_10004B824( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  _Unwind_Resume(a1);
}

void sub_10004BF20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
}

void sub_10004C288(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10004C45C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_10004C678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_234:
      NSAppendPrintF_safe(&v91, ", usecase %s", v84);
      objc_storeStrong(v82, v91);
    }

    if (v97)
    {
      v98 = (unsigned int *)v97;
      operator delete(v97);
    }

    v97 = &v124;
    sub_100050E64((void ***)&v97);
  }

  __int16 v85 = (id)v139[5];
  _Block_object_dispose(&v138, 8);

  return v85;
}

      v134 = 0x80000000 >> -(char)v7;
      do
      {
        if ((v134 & v111) != 0) {
          v135 = "1";
        }
        else {
          v135 = "0";
        }
        sub_1001F4A7C(a1, v135);
        unint64_t v27 = v134 >= 2;
        v134 >>= 1;
      }

      while (v27);
      v146 = 0;
      goto LABEL_240;
    case 0x42u:
      uint64_t v8 = 0;
      v113 = a3++;
      LODWORD(v113) = *(_DWORD *)v113;
      v114 = *(void *)(a1 + 8);
      v115 = *(unsigned __int16 *)(a1 + 4);
      *(_WORD *)(a1 + 4) = v115 + 1;
      *(_BYTE *)(v114 + v115) = (_BYTE)v113;
      goto LABEL_273;
    case 0x43u:
      v116 = (int *)a3++;
      v117 = *v116;
      v118 = "+";
      if ((v6 & 1) == 0) {
        v118 = 0LL;
      }
      if (v117 >= 0) {
        v119 = (char *)v118;
      }
      else {
        v119 = "-";
      }
      if (v117 >= 0) {
        v120 = v117;
      }
      else {
        v120 = -v117;
      }
      LOWORD(v7) = v7 - ((v117 < 0) | v6 & 1);
      v121 = v120;
      do
      {
        id v7 = (__int16)(v7 - 1);
        v122 = v7 >= 1 && v121 > 9;
        v121 /= 0xAu;
      }

      while (v122);
      if (v7 < 1) {
        goto LABEL_224;
      }
      if ((v144 & 1) != 0)
      {
        sub_1001F4A7C(a1, v119);
        sub_1001F494C(a1, "000000000000000", (unsigned __int16)v7);
      }

      else
      {
        sub_1001F4CCC(a1, v7);
LABEL_224:
        sub_1001F4A7C(a1, v119);
      }

      v102 = a1;
      v101 = v120;
LABEL_226:
      sub_1001F5DD4(v102, v101);
      goto LABEL_240;
    default:
      return result;
  }

  return result;
}

  v163 = -93;
  v108 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ConnRSSIStageOneFindMy");
  v109 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v108 + 88LL))(v108, buf, __p, &v163);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v109) {
      goto LABEL_242;
    }
  }

  else if (!v109)
  {
    goto LABEL_242;
  }

  v110 = v163;
  *(_BYTE *)(a1 + 1344) = v163;
  v111 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v110;
    _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_DEFAULT,  "ConnRSSIStageOneFindMy %d overridden",  buf,  8u);
  }

void sub_10004D8E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Unwind_Resume(a1);
}

void sub_10004DA34(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if ([v5 length] == (id)7) {
    id v7 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "subdataWithRange:", 1, 6));
  }
  else {
    id v7 = v5;
  }
  uint64_t v8 = v7;
  if ([v5 length] == (id)7) {
    char v9 = *(_BYTE *)[v5 bytes];
  }
  else {
    char v9 = 0;
  }
  id v10 = "?";
  if (v9 == 1) {
    id v10 = "Random";
  }
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v14 = *(void **)(v12 + 40);
  uint64_t v13 = (id *)(v12 + 40);
  id obj = v14;
  if (v9) {
    uint64_t v15 = v10;
  }
  else {
    uint64_t v15 = "Public";
  }
  if (*(_BYTE *)(*(void *)(v11 + 8) + 24LL)) {
    uint64_t v16 = "";
  }
  else {
    uint64_t v16 = ", ";
  }
  uint64_t v17 = CUPrintNSDataAddress(v8);
  id v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
  uint64_t v19 = CUPrintNSObjectMasked(v6);
  unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  NSAppendPrintF_safe(&obj, "%s{Addr %s %@, IRK %@}", v16, v15, v18, v20);
  objc_storeStrong(v13, obj);

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
}

void sub_10004DBA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10004E1DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  _Block_object_dispose(&a62, 8);
  _Unwind_Resume(a1);
}

void sub_10004E284(uint64_t a1)
{
  if (qword_1008D6618 != -1) {
    dispatch_once(&qword_1008D6618, &stru_1008802F0);
  }
  sub_100504648(qword_1008D6610, *(void *)(a1 + 40), *(void **)(a1 + 32), 0LL);
}

void sub_10004E2D8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithChar:]( NSNumber,  "numberWithChar:",  [v6 bleRSSIThresholdHint]));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithChar:]( NSNumber,  "numberWithChar:",  [v6 bleSensorRssiIncreaseScanThreshold]));
  char v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v6 bleSensorIncreaseScanRate]));
  unsigned __int8 v10 = [v6 bleSensorEnableRssiIncreaseScan];
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v6 bleSensorIncreaseScanTimeout]));
  unsigned __int8 v23 = v10;
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v6 bleSensorTimeoutBetweenIncreaseScan]));
  if ([v9 intValue] == 75)
  {
    __int16 v13 = 40;
LABEL_5:
    __int16 v14 = 30;
    goto LABEL_6;
  }

  if ([v9 intValue] == 50)
  {
    __int16 v13 = 60;
    goto LABEL_5;
  }

  if ([v9 intValue] == 10)
  {
    __int16 v13 = 30;
    __int16 v14 = 300;
  }

  else
  {
    unsigned int v17 = [v9 intValue];
    if (v17 == 3) {
      __int16 v14 = 966;
    }
    else {
      __int16 v14 = 0;
    }
    if (v17 == 3) {
      __int16 v13 = 30;
    }
    else {
      __int16 v13 = 0;
    }
  }

void sub_10004E5BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, void *a22, void *a23)
{
  _Unwind_Resume(a1);
}

void sub_10004E674(uint64_t a1)
{
  if (qword_1008D6618 != -1) {
    dispatch_once(&qword_1008D6618, &stru_1008802F0);
  }
  uint64_t v2 = qword_1008D6610;
  unint64_t v3 = *(void *)(a1 + 64);
  unsigned int v16 = *(unsigned __int8 *)(a1 + 84);
  int v4 = *(char *)(a1 + 72);
  unsigned __int8 v5 = *(_BYTE *)(a1 + 76);
  char v6 = *(_BYTE *)(a1 + 85);
  id v7 = *(void **)(a1 + 32);
  char v8 = [*(id *)(a1 + 40) intValue];
  int v9 = *(_DWORD *)(a1 + 80);
  unsigned __int16 v10 = (unsigned __int16)[*(id *)(a1 + 48) intValue];
  HIWORD(v15) = (unsigned __int16)[*(id *)(a1 + 56) intValue];
  LOWORD(v15) = v10;
  int v11 = sub_100502EE8(v2, v3, v7, 0LL, 0LL, v16, v4, v5, 0, 0, 0, 0, v6, v8, v9, v15);
  if (v11)
  {
    if (dword_1008D6530 <= 90)
    {
      int v12 = v11;
      if (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 90LL))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = CUPrintErrorCode((v12 + 310000));
        id v17 = (id)objc_claimAutoreleasedReturnValue(v14);
        LogPrintF_safe( &dword_1008D6530,  "-[CBStackBLEScannerBTStack _sensorTrackingUpdate]_block_invoke_3",  90LL,  "### SensorTracking start failed: %@, %@",  v13,  v17);
      }
    }
  }

void sub_10004E7F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
}

void sub_10004EA6C(uint64_t a1, id a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  id v12 = a3;
  id v13 = a8;
  id v14 = *(id *)(a1 + 8);
  int v15 = v14;
  if (!a2 || [v14 sessionHandle] == a2)
  {
    if (v12)
    {
      *(_BYTE *)(a1 + 24) = 1;
      sub_10004EB7C(a1, v12, a4);
    }

    else
    {
      char v16 = *(_BYTE *)(*(void *)(a4 + 8) + 305LL);
      id v17 = *(dispatch_queue_s **)(a1 + 16);
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472LL;
      v18[2] = sub_10004EB68;
      v18[3] = &unk_100880230;
      char v19 = v16;
      v18[4] = v15;
      dispatch_async(v17, v18);
    }
  }
}

void sub_10004EB50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10004EB68(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v2 = *(void **)(a1 + 32);
  if (v1) {
    return [v2 _aopBTBufferDrained];
  }
  else {
    return [v2 _advBufferDrained];
  }
}

void sub_10004EB7C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  char v6 = objc_alloc_init(&OBJC_CLASS___CBDevice);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 UUIDString]);
  -[CBDevice setIdentifier:](v6, "setIdentifier:", v7);

  if (*(_BYTE *)(*(void *)(a3 + 8) + 305LL)) {
    uint64_t v8 = 2048LL;
  }
  else {
    uint64_t v8 = 2LL;
  }
  -[CBDevice setInternalFlags:](v6, "setInternalFlags:", v8);
  uint64_t v9 = *(void *)(a3 + 8);
  if (*(_BYTE *)(v9 + 306))
  {
    -[CBDevice setInternalFlags:]( v6,  "setInternalFlags:",  -[CBDevice internalFlags](v6, "internalFlags") | 0x1000);
    uint64_t v9 = *(void *)(a3 + 8);
  }

  if (*(_WORD *)(v9 + 40))
  {
    -[CBDevice setAppearanceValue:](v6, "setAppearanceValue:");
    uint64_t v9 = *(void *)(a3 + 8);
  }

  unsigned __int16 v10 = *(unsigned int **)(v9 + 144);
  int v71 = &off_10087FAA8;
  int v72 = v10;
  if (v10) {
    sub_1002CD1E0((uint64_t)v10);
  }
  uint64_t v11 = sub_10056AAF0((uint64_t)&v71);
  if (sub_10056AAD8((uint64_t)&v71) == 7)
  {
    id v12 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v11 + 1, 6LL);
    -[CBDevice setBleAddressData:](v6, "setBleAddressData:", v12);
  }

  -[CBDevice setBleAdvertisementTimestamp:]( v6,  "setBleAdvertisementTimestamp:",  *(double *)(*(void *)(a3 + 8) + 240LL));
  -[CBDevice setBleAdvertisementTimestampMachContinuous:]( v6,  "setBleAdvertisementTimestampMachContinuous:",  *(void *)(*(void *)(a3 + 8) + 248LL));
  id v13 = *(unsigned int **)(*(void *)(a3 + 8) + 56LL);
  int v69 = &off_10087FAA8;
  BOOL v70 = v13;
  if (v13) {
    sub_1002CD1E0((uint64_t)v13);
  }
  uint64_t v14 = sub_10056AAF0((uint64_t)&v69);
  if (v14)
  {
    int v15 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v14,  sub_10056AAD8((uint64_t)&v69));
    -[CBDevice setBleAppleManufacturerData:](v6, "setBleAppleManufacturerData:", v15);
  }

  -[CBDevice setBleChannel:](v6, "setBleChannel:", *(unsigned __int8 *)(*(void *)(a3 + 8) + 219LL));
  int v16 = *(unsigned __int8 *)(*(void *)(a3 + 8) + 216LL);
  if (v16 == 127) {
    LOBYTE(v16) = 0;
  }
  -[CBDevice setBleRSSI:](v6, "setBleRSSI:", (char)v16);
  uint64_t v17 = *(void *)(*(void *)(a3 + 8) + 200LL);
  if (v17)
  {
    LOBYTE(v65) = (unsigned __int16)WORD2(*(void *)(*(void *)(a3 + 8) + 200LL)) >> 8;
    BYTE1(v65) = BYTE4(v17);
    BYTE2(v65) = BYTE3(v17);
    BYTE3(v65) = BYTE2(v17);
    BYTE4(v65) = BYTE1(v17);
    BYTE5(v65) = v17;
    uint64_t v18 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v65, 6LL);
    -[CBDevice setBtAddressData:](v6, "setBtAddressData:", v18);
  }

  id v19 = -[CBDevice deviceFlags](v6, "deviceFlags");
  if (qword_1008D5F20 != -1) {
    dispatch_once(&qword_1008D5F20, &stru_100880330);
  }
  if (sub_10061C0F8(qword_1008D5F18, v5))
  {
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100880310);
    }
    int v20 = off_1008D5F28;
    sub_10002418C(__p, "_CTKD_");
    else {
      uint64_t v21 = 0LL;
    }
    if (v68 < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    uint64_t v21 = 0x40000000000LL;
  }

  if (v19 != (id)v21) {
    -[CBDevice setDeviceFlags:](v6, "setDeviceFlags:", v21);
  }
  uint64_t v65 = 0LL;
  v66[0] = 0LL;
  v66[1] = 0LL;
  sub_1000518C4(&v65, *(void *)(a3 + 8) + 112LL);
  __int128 v86 = xmmword_1006BDC88;
  int v87 = -815610143;
  sub_100634334(&v82, (__n128 *)&v86);
  uint64_t v22 = sub_100051D00((uint64_t)&v65, (unsigned __int8 *)&v82);
  if (v66 != (void **)v22)
  {
    uint64_t v23 = *(void *)(v22 + 64);
    v82.n128_u64[0] = (unint64_t)&off_10087FAA8;
    v82.n128_u64[1] = v23;
    if (v23) {
      sub_1002CD1E0(v23);
    }
    __int128 v24 = objc_alloc(&OBJC_CLASS___NSData);
    uint64_t v25 = sub_10056AAF0((uint64_t)&v82);
    id v26 = -[NSData initWithBytes:length:](v24, "initWithBytes:length:", v25, sub_10056AAD8((uint64_t)&v82));
    -[CBDevice setDockKitAccessoryPayloadData:](v6, "setDockKitAccessoryPayloadData:", v26);

    v82.n128_u64[0] = (unint64_t)&off_10087FAA8;
    if (v82.n128_u64[1]) {
      sub_1002CD254((unsigned int *)v82.n128_u64[1]);
    }
  }

  int v85 = 0;
  __int128 v84 = xmmword_1006BB2B4;
  sub_100634334(&v82, (__n128 *)&v84);
  uint64_t v27 = sub_100051D00((uint64_t)&v65, (unsigned __int8 *)&v82);
  if (v66 != (void **)v27)
  {
    uint64_t v28 = *(void *)(v27 + 64);
    v82.n128_u64[0] = (unint64_t)&off_10087FAA8;
    v82.n128_u64[1] = v28;
    if (v28) {
      sub_1002CD1E0(v28);
    }
    id v29 = objc_alloc(&OBJC_CLASS___NSData);
    uint64_t v30 = sub_10056AAF0((uint64_t)&v82);
    int v31 = -[NSData initWithBytes:length:](v29, "initWithBytes:length:", v30, sub_10056AAD8((uint64_t)&v82));
    -[CBDevice setFidoPayloadData:](v6, "setFidoPayloadData:", v31);

    v82.n128_u64[0] = (unint64_t)&off_10087FAA8;
    if (v82.n128_u64[1]) {
      sub_1002CD254((unsigned int *)v82.n128_u64[1]);
    }
  }

  uint64_t v32 = *(void *)(a3 + 8);
  uint64_t v83 = 0LL;
  __n128 v82 = 0uLL;
  sub_100050EE8( (char *)&v82,  *(__int128 **)(v32 + 64),  *(__int128 **)(v32 + 72),  0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v32 + 72) - *(void *)(v32 + 64)) >> 2));
  int v81 = 0;
  __int128 v80 = xmmword_1006BB2C8;
  sub_100634334((__n128 *)__dst, (__n128 *)&v80);
  uint64_t v33 = sub_100051D00((uint64_t)&v65, (unsigned __int8 *)__dst);
  if (v66 == (void **)v33)
  {
    unint64_t v39 = v82.n128_u64[1];
    int v38 = (unsigned __int8 *)v82.n128_u64[0];
    if (v82.n128_u64[0] == v82.n128_u64[1])
    {
      unint64_t v40 = v82.n128_u64[0];
    }

    else
    {
      while (1)
      {
        LODWORD(v79) = 0;
        *(_OWORD *)__dst = xmmword_1006BB2C8;
        v38 += 20;
        if (v38 == (unsigned __int8 *)v39)
        {
          int v38 = (unsigned __int8 *)v39;
          break;
        }
      }

      unint64_t v40 = (unint64_t)v38;
      int v38 = (unsigned __int8 *)v82.n128_u64[1];
    }

    if ((unsigned __int8 *)v40 != v38)
    {
      id v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
      -[CBDevice setGfpPayloadData:](v6, "setGfpPayloadData:", v41);
    }
  }

  else
  {
    __int16 v34 = *(void **)(v33 + 64);
    __dst[0] = &off_10087FAA8;
    __dst[1] = v34;
    if (v34) {
      sub_1002CD1E0((uint64_t)v34);
    }
    char v35 = objc_alloc(&OBJC_CLASS___NSData);
    uint64_t v36 = sub_10056AAF0((uint64_t)__dst);
    __int128 v37 = -[NSData initWithBytes:length:](v35, "initWithBytes:length:", v36, sub_10056AAD8((uint64_t)__dst));
    -[CBDevice setGfpPayloadData:](v6, "setGfpPayloadData:", v37);

    __dst[0] = &off_10087FAA8;
    if (__dst[1]) {
      sub_1002CD254((unsigned int *)__dst[1]);
    }
  }

  unint64_t v43 = v82.n128_u64[1];
  __int128 v42 = (unsigned __int8 *)v82.n128_u64[0];
  if (v82.n128_u64[0] == v82.n128_u64[1])
  {
    unint64_t v44 = v82.n128_u64[0];
  }

  else
  {
    while (1)
    {
      *(_OWORD *)__dst = xmmword_1006BDAF4;
      LODWORD(v79) = 0;
      v42 += 20;
      if (v42 == (unsigned __int8 *)v43)
      {
        __int128 v42 = (unsigned __int8 *)v43;
        break;
      }
    }

    unint64_t v44 = (unint64_t)v42;
    __int128 v42 = (unsigned __int8 *)v82.n128_u64[1];
  }

  if ((unsigned __int8 *)v44 != v42) {
    -[CBDevice setDiscoveryFlags:]( v6,  "setDiscoveryFlags:",  (unint64_t)-[CBDevice discoveryFlags](v6, "discoveryFlags") | 0x2000000000000LL);
  }
  __dst[0] = 0LL;
  __dst[1] = 0LL;
  uint64_t v79 = 0LL;
  uint64_t v45 = *(void *)(a3 + 8);
  if (*(char *)(v45 + 39) < 0)
  {
    sub_100024238(__dst, *(void **)(v45 + 16), *(void *)(v45 + 24));
  }

  else
  {
    *(_OWORD *)__dst = *(_OWORD *)(v45 + 16);
    uint64_t v79 = *(void *)(v45 + 32);
  }

  int v46 = (void *)HIBYTE(v79);
  if (v79 < 0) {
    int v46 = __dst[1];
  }
  if (v46)
  {
    int v47 = objc_alloc(&OBJC_CLASS___NSString);
    if (v79 >= 0) {
      int v48 = __dst;
    }
    else {
      int v48 = (void **)__dst[0];
    }
    id v49 = -[NSString initWithUTF8String:](v47, "initWithUTF8String:", v48, 0xFE2C00000002LL, 0LL);
    -[CBDevice setLeAdvName:](v6, "setLeAdvName:", v49);
  }

  __int128 v75 = xmmword_1006BDBBC;
  int v76 = 0;
  sub_100634334(&v77, (__n128 *)&v75);
  uint64_t v50 = sub_100051D00((uint64_t)&v65, (unsigned __int8 *)&v77);
  if (v66 != (void **)v50)
  {
    uint64_t v51 = *(void *)(v50 + 64);
    v77.n128_u64[0] = (unint64_t)&off_10087FAA8;
    v77.n128_u64[1] = v51;
    if (v51) {
      sub_1002CD1E0(v51);
    }
    uint64_t v52 = objc_alloc(&OBJC_CLASS___NSData);
    uint64_t v53 = sub_10056AAF0((uint64_t)&v77);
    int v54 = -[NSData initWithBytes:length:](v52, "initWithBytes:length:", v53, sub_10056AAD8((uint64_t)&v77));
    -[CBDevice setProximityServiceData:](v6, "setProximityServiceData:", v54);

    v77.n128_u64[0] = (unint64_t)&off_10087FAA8;
    if (v77.n128_u64[1]) {
      sub_1002CD254((unsigned int *)v77.n128_u64[1]);
    }
  }

  int v74 = 0;
  __int128 v73 = xmmword_1006BB2DC;
  sub_100634334(&v77, (__n128 *)&v73);
  uint64_t v55 = sub_100051D00((uint64_t)&v65, (unsigned __int8 *)&v77);
  if (v66 != (void **)v55)
  {
    uint64_t v56 = *(void *)(v55 + 64);
    v77.n128_u64[0] = (unint64_t)&off_10087FAA8;
    v77.n128_u64[1] = v56;
    if (v56) {
      sub_1002CD1E0(v56);
    }
    uint64_t v57 = objc_alloc(&OBJC_CLASS___NSData);
    uint64_t v58 = sub_10056AAF0((uint64_t)&v77);
    uint64_t v59 = -[NSData initWithBytes:length:](v57, "initWithBytes:length:", v58, sub_10056AAD8((uint64_t)&v77));
    -[CBDevice setSafetyAlertsSegmentServiceData:](v6, "setSafetyAlertsSegmentServiceData:", v59);

    -[CBDevice setInternalFlags:]( v6,  "setInternalFlags:",  -[CBDevice internalFlags](v6, "internalFlags") | 0x4000);
    v77.n128_u64[0] = (unint64_t)&off_10087FAA8;
    if (v77.n128_u64[1]) {
      sub_1002CD254((unsigned int *)v77.n128_u64[1]);
    }
  }

  uint64_t v60 = *(void *)(*(void *)(a3 + 8) + 208LL);
  if (v60)
  {
    v77.n128_u8[0] = (unsigned __int16)WORD2(*(void *)(*(void *)(a3 + 8) + 208LL)) >> 8;
    v77.n128_u8[1] = BYTE4(v60);
    v77.n128_u8[2] = BYTE3(v60);
    v77.n128_u8[3] = BYTE2(v60);
    v77.n128_u8[4] = BYTE1(v60);
    v77.n128_u8[5] = v60;
    int v61 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v77, 6LL);
    -[CBDevice setTxAddressData:](v6, "setTxAddressData:", v61);
  }

  id v62 = *(id *)(a1 + 8);
  int v63 = *(dispatch_queue_s **)(a1 + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10004F6D8;
  block[3] = &unk_10087FB90;
  block[4] = v6;
  void block[5] = v62;
  dispatch_async(v63, block);

  if (SHIBYTE(v79) < 0) {
    operator delete(__dst[0]);
  }
  if (v82.n128_u64[0])
  {
    v82.n128_u64[1] = v82.n128_u64[0];
    operator delete((void *)v82.n128_u64[0]);
  }

  sub_100051CA8((uint64_t)&v65, v66[0]);
  int v69 = &off_10087FAA8;
  if (v70) {
    sub_1002CD254(v70);
  }
  int v71 = &off_10087FAA8;
  if (v72) {
    sub_1002CD254(v72);
  }
}

void sub_10004F484( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, unsigned int *a27, uint64_t a28, unsigned int *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, void *__p, uint64_t a41, int a42, __int16 a43, char a44, char a45)
{
  uint64_t v50 = *(void **)(v48 - 184);
  if (v50)
  {
    *(void *)(v48 - 176) = v50;
    operator delete(v50);
  }

  sub_100051CA8((uint64_t)&a17, a18);
  if (a27) {
    sub_1002CD254(a27);
  }
  if (a29) {
    sub_1002CD254(a29);
  }

  _Unwind_Resume(a1);
}

void sub_10004F670(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = v5;
  if (*(_BYTE *)(a1 + 24)) {
    *(_BYTE *)(a1 + 24) = 0;
  }
  else {
    sub_10004EB7C(a1, v5, a3);
  }
}

void sub_10004F6C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_10004F6D8(uint64_t a1)
{
  unsigned __int16 v2 = (unsigned __int16)[*(id *)(a1 + 32) internalFlags];
  uint64_t v4 = *(void *)(a1 + 32);
  unint64_t v3 = *(void **)(a1 + 40);
  if ((v2 & 0x800) != 0) {
    return [v3 deviceBuffered:v4];
  }
  else {
    return [v3 deviceFound:v4];
  }
}

void sub_10004F714()
{
  if (dword_1008D6530 <= 30 && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL))) {
    LogPrintF_safe( &dword_1008D6530,  "virtual void CBStackBLEScannerCPP::leZoneLost(const BT::ByteBuffer &, const BT::ByteBuffer &)",  30LL,  "Zone lost");
  }
}

void sub_10004F774()
{
}

void sub_10004F7D4()
{
}

void sub_10004F834(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  if (dword_1008D6530 <= 30 && (dword_1008D6530 != -1 || _LogCategory_Initialize(&dword_1008D6530, 30LL)))
  {
    else {
      id v6 = off_100880390[(char)(a3 - 1)];
    }
    LogPrintF_safe( &dword_1008D6530,  "virtual void CBStackBLEScannerCPP::leSensorStateChanged(NSUUID * _Nonnull __strong, LESensorState, BOOL)",  30LL,  "SensorTracking state changed: device %@, state %s",  v5,  v6);
  }

  if ((a3 & 0xFFFFFFFD) == 1)
  {
    id v7 = objc_alloc_init(&OBJC_CLASS___CBDevice);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 UUIDString]);
    -[CBDevice setIdentifier:](v7, "setIdentifier:", v8);

    -[CBDevice setDiscoveryFlags:](v7, "setDiscoveryFlags:", 0x20000000LL);
    -[CBDevice setInternalFlags:](v7, "setInternalFlags:", 2LL);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_100880310);
    }
    uint64_t v9 = sub_1005CC198((uint64_t)off_1008D5F28, v5, 0);
    if (v9)
    {
      v17[0] = BYTE5(v9);
      v17[1] = BYTE4(v9);
      _DWORD v17[2] = BYTE3(v9);
      v17[3] = BYTE2(v9);
      v17[4] = BYTE1(v9);
      v17[5] = v9;
      unsigned __int16 v10 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v17, 6LL);
      -[CBDevice setBtAddressData:](v7, "setBtAddressData:", v10);
    }

    uint64_t v11 = *(dispatch_queue_s **)(a1 + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10004FAA8;
    block[3] = &unk_1008800B8;
    block[4] = v7;
    void block[5] = a1;
    dispatch_async(v11, block);
    goto LABEL_17;
  }

  if (a3 == 2)
  {
    id v12 = *(dispatch_queue_s **)(a1 + 16);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472LL;
    v13[2] = sub_10004FAB4;
    v13[3] = &unk_1008800B8;
    uint64_t v15 = a1;
    uint64_t v14 = (CBDevice *)v5;
    dispatch_async(v12, v13);
    id v7 = v14;
LABEL_17:
  }
}

void sub_10004FA70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10004FAA8(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 40) + 8) deviceFound:*(void *)(a1 + 32)];
}

id sub_10004FAB4(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 40) + 8) deviceLost:*(void *)(a1 + 32)];
}

void sub_10004FAD0(uint64_t a1, uint64_t a2)
{
  id v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        id v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }

  if (v5 == v4)
  {
    uint64_t v6 = a2;
    sub_10004FB58(a1 + 8, v4, (char *)&v6);
    sub_100008A30(a1 + 8);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_10004FB58(uint64_t a1, char *__src, char *a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    id v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      id v19 = (char *)sub_100008BA0(a1 + 16, v18);
    }
    else {
      id v19 = 0LL;
    }
    int v20 = &v19[8 * v16];
    __p = v19;
    uint64_t v27 = v20;
    uint64_t v28 = v20;
    id v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1LL;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)sub_100008BA0(v8, v22);
        int v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        uint64_t v27 = v20;
        id v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }

      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        uint64_t v27 = v20;
      }
    }

    *(void *)int v20 = *(void *)v3;
    uint64_t v28 = v20 + 8;
    uint64_t v4 = sub_100008ADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = __src + 8;
  }

  else
  {
    uint64_t v9 = __src + 8;
    unsigned __int16 v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }

    *(void *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }

  return v4;
}

void sub_10004FD5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10004FD94(uint64_t a1)
{
  unsigned __int16 v2 = *(void **)(a1 + 88);
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;

  unint64_t v3 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = 0LL;

  uint64_t v4 = *(void **)(a1 + 352);
  if (v4)
  {
    *(void *)(a1 + 360) = v4;
    operator delete(v4);
  }

  uint64_t v8 = (void **)(a1 + 328);
  sub_10004FEA4(&v8);

  uint64_t v8 = (void **)(a1 + 96);
  sub_10004FF34(&v8);

  uint64_t v8 = (void **)(a1 + 64);
  sub_100050E64(&v8);

  id v5 = *(void **)(a1 + 32);
  if (v5)
  {
    *(void *)(a1 + 40) = v5;
    operator delete(v5);
  }

  uint64_t v6 = *(void **)(a1 + 8);
  if (v6)
  {
    *(void *)(a1 + 16) = v6;
    operator delete(v6);
  }

  return a1;
}

uint64_t sub_10004FE5C(uint64_t a1)
{
  unsigned __int16 v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }

  uint64_t v4 = (void **)(a1 + 48);
  sub_10004FEA4(&v4);
  return a1;
}

void sub_10004FEA4(void ***a1)
{
  unsigned __int16 v2 = *a1;
  if (*v2)
  {
    sub_10004FEE4((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }

void sub_10004FEE4(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 96LL)
  {

    id v5 = *(void **)(i - 96);
  }

  *(void *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = a2;
}

void sub_10004FF34(void ***a1)
{
  int v1 = *a1;
  unsigned __int16 v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 112LL;
        sub_10004FFB8((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_10004FFB8(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 56) = &off_10087FAA8;
  unint64_t v3 = *(unsigned int **)(a2 + 64);
  if (v3) {
    sub_1002CD254(v3);
  }
  *(void *)(a2 + 40) = &off_10087FAA8;
  uint64_t v4 = *(unsigned int **)(a2 + 48);
  if (v4) {
    sub_1002CD254(v4);
  }
}

uint64_t sub_100050010(uint64_t a1)
{
  *(void *)(a1 + 56) = &off_10087FAA8;
  unsigned __int16 v2 = *(unsigned int **)(a1 + 64);
  if (v2) {
    sub_1002CD254(v2);
  }
  *(void *)(a1 + 40) = &off_10087FAA8;
  unint64_t v3 = *(unsigned int **)(a1 + 48);
  if (v3) {
    sub_1002CD254(v3);
  }

  return a1;
}

uint64_t sub_100050070(uint64_t a1)
{
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = 0u;
  *(_WORD *)(a1 + 124) = 0;
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 119) = 0;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
  *(_WORD *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 139) = 1;
  *(void *)(a1 + 176) = 0LL;
  *(_BYTE *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 140) = 0;
  *(_WORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 16_Block_object_dispose((const void *)(v15 - 96), 8) = 0;
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  *(_BYTE *)(a1 + 196) = 0;
  *(void *)(a1 + 18_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
  *(_WORD *)(a1 + 197) = 257;
  *(_DWORD *)(a1 + 199) = 0;
  *(_BYTE *)(a1 + 203) = 8;
  *(_WORD *)(a1 + 280) = 256;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v15 - 96), 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_WORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 282) = 0;
  *(_BYTE *)(a1 + 286) = 1;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 287) = 0;
  *(_WORD *)(a1 + 291) = 0;
  *(void *)(a1 + 309) = 0LL;
  *(void *)(a1 + 294) = 0LL;
  *(void *)(a1 + 302) = 0LL;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v15 - 96), 8) = 0u;
  *(_BYTE *)(a1 + 376) = 1;
  *(_DWORD *)(a1 + 384) = 0;
  uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  unint64_t v3 = *(void **)(a1 + 88);
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = v2;

  *(_BYTE *)(a1 + 4) = 0;
  uint64_t v4 = objc_claimAutoreleasedReturnValue(+[NSSet set](&OBJC_CLASS___NSSet, "set"));
  id v5 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v4;

  return a1;
}

void sub_1000501A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v14 = v13;
  uint64_t v15 = v11;
  sub_10004FE5C(v14);

  sub_10004FF34(&a10);
  a10 = v15;
  sub_100050E64(&a10);

  uint64_t v17 = *(void **)(v10 + 32);
  if (v17)
  {
    *(void *)(v10 + 40) = v17;
    operator delete(v17);
  }

  unint64_t v18 = *v12;
  if (*v12)
  {
    *(void *)(v10 + 16) = v18;
    operator delete(v18);
  }

  _Unwind_Resume(a1);
}

_DWORD *sub_100050224(void *a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  uint64_t result = (_DWORD *)*a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((v8 - (uint64_t)result) >> 2) < a4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }

    if (a4 > 0xCCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 2);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x666666666666666LL) {
      unint64_t v12 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v12 = v11;
    }
    sub_1000503D4(a1, v12);
    uint64_t v14 = (_DWORD *)a1[1];
    uint64_t v13 = (_DWORD **)(a1 + 1);
    uint64_t result = v14;
    uint64_t v15 = (char *)v14;
    if (v6 != a3)
    {
      uint64_t v15 = (char *)result;
      do
      {
        __int128 v16 = *v6;
        *((_DWORD *)v15 + 4) = *((_DWORD *)v6 + 4);
        *(_OWORD *)uint64_t v15 = v16;
        v15 += 20;
        uint64_t v6 = (__int128 *)((char *)v6 + 20);
      }

      while (v6 != a3);
    }

char *sub_1000503D4(void *a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL) {
    abort();
  }
  uint64_t result = (char *)sub_100050420((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[20 * v4];
  return result;
}

void *sub_100050420(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL) {
    sub_100008BD4();
  }
  return operator new(20 * a2);
}

uint64_t sub_100050464(uint64_t a1)
{
  *(void *)(a1 + 32) = &off_10087FAA8;
  uint64_t v2 = *(unsigned int **)(a1 + 40);
  if (v2) {
    sub_1002CD254(v2);
  }
  *(void *)(a1 + 16) = &off_10087FAA8;
  unint64_t v3 = *(unsigned int **)(a1 + 24);
  if (v3) {
    sub_1002CD254(v3);
  }

  return a1;
}

uint64_t sub_1000504C4(uint64_t *a1, uint64_t *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  uint64_t v6 = (uint64_t)(a1 + 2);
  if (0x5555555555555556LL * ((a1[2] - *a1) >> 5) > v3) {
    unint64_t v3 = 0x5555555555555556LL * ((a1[2] - *a1) >> 5);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) >= 0x155555555555555LL) {
    unint64_t v7 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v15 = a1 + 2;
  if (v7) {
    uint64_t v8 = (char *)sub_100050740((uint64_t)(a1 + 2), v7);
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t v11 = v8;
  unint64_t v12 = &v8[96 * v2];
  uint64_t v14 = &v8[96 * v7];
  sub_1000505CC(v6, (uint64_t)v12, a2);
  uint64_t v13 = v12 + 96;
  sub_1000506A4(a1, &v11);
  uint64_t v9 = a1[1];
  sub_100050784(&v11);
  return v9;
}

void sub_1000505B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1000505CC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  *a3 = 0LL;
  *(void *)a2 = v5;
  *(_WORD *)(a2 + _Block_object_dispose((const void *)(v15 - 96), 8) = *((_WORD *)a3 + 4);
  uint64_t v6 = a3[3];
  *(void *)(a2 + 16) = &off_10087FAA8;
  *(void *)(a2 + 24) = v6;
  if (v6) {
    sub_1002CD1E0(v6);
  }
  uint64_t v7 = a3[5];
  *(void *)(a2 + 32) = &off_10087FAA8;
  *(void *)(a2 + 40) = v7;
  if (v7) {
    sub_1002CD1E0(v7);
  }
  int v8 = *((_DWORD *)a3 + 12);
  *(_BYTE *)(a2 + 52) = *((_BYTE *)a3 + 52);
  *(_DWORD *)(a2 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = v8;
  uint64_t v9 = a3[7];
  a3[7] = 0LL;
  *(void *)(a2 + 56) = v9;
  LODWORD(v9) = *((_DWORD *)a3 + 16);
  *(_BYTE *)(a2 + 6_Block_object_dispose((const void *)(v15 - 96), 8) = *((_BYTE *)a3 + 68);
  *(_DWORD *)(a2 + 64) = v9;
  uint64_t v10 = a3[9];
  a3[9] = 0LL;
  *(void *)(a2 + 72) = v10;
  uint64_t v11 = a3[10];
  *(_DWORD *)(a2 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = *((_DWORD *)a3 + 22);
  *(void *)(a2 + 80) = v11;
}

void sub_100050678(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  uint64_t v4 = *(unsigned int **)(v1 + 24);
  if (v4) {
    sub_1002CD254(v4);
  }

  _Unwind_Resume(a1);
}

void sub_1000506A4(uint64_t *a1, void *a2)
{
  uint64_t v5 = (uint64_t *)*a1;
  uint64_t v4 = (uint64_t *)a1[1];
  uint64_t v6 = a2[1];
  if (v4 != (uint64_t *)*a1)
  {
    do
    {
      v6 -= 96LL;
      v4 -= 12;
      sub_1000505CC((uint64_t)(a1 + 2), v6, v4);
    }

    while (v4 != v5);
  }

  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *sub_100050740(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    sub_100008BD4();
  }
  return operator new(96 * a2);
}

void **sub_100050784(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1000507B4(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 96;
    sub_1000507F8(v4, i - 96);
  }

void sub_1000507F8(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = &off_10087FAA8;
  unint64_t v3 = *(unsigned int **)(a2 + 40);
  if (v3) {
    sub_1002CD254(v3);
  }
  *(void *)(a2 + 16) = &off_10087FAA8;
  uint64_t v4 = *(unsigned int **)(a2 + 24);
  if (v4) {
    sub_1002CD254(v4);
  }
}

uint64_t sub_100050850( uint64_t a1, void *a2, char a3, char a4, uint64_t a5, uint64_t a6, char a7, char a8, char a9, char a10, char a11, void *a12, char a13, char a14, char a15, char a16, char a17, void *a18, int a19, int a20, int a21)
{
  id v28 = a2;
  id v29 = a12;
  id v30 = a18;
  id v31 = v28;
  *(void *)a1 = v31;
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = a3;
  *(_BYTE *)(a1 + 9) = a4;
  uint64_t v32 = *(void *)(a5 + 8);
  *(void *)(a1 + 16) = &off_10087FAA8;
  *(void *)(a1 + 24) = v32;
  if (v32) {
    sub_1002CD1E0(v32);
  }
  uint64_t v33 = *(void *)(a6 + 8);
  *(void *)(a1 + 32) = &off_10087FAA8;
  *(void *)(a1 + 40) = v33;
  if (v33) {
    sub_1002CD1E0(v33);
  }
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = a7;
  *(_BYTE *)(a1 + 49) = a8;
  *(_BYTE *)(a1 + 50) = a9;
  *(_BYTE *)(a1 + 51) = a10;
  *(_BYTE *)(a1 + 52) = a11;
  *(void *)(a1 + 56) = v29;
  *(_BYTE *)(a1 + 64) = a13;
  *(_BYTE *)(a1 + 65) = a14;
  *(_BYTE *)(a1 + 66) = a15;
  *(_BYTE *)(a1 + 67) = a16;
  *(_BYTE *)(a1 + 6_Block_object_dispose((const void *)(v15 - 96), 8) = a17;
  *(void *)(a1 + 72) = v30;
  *(_DWORD *)(a1 + 80) = a19;
  *(_DWORD *)(a1 + 84) = a20;
  *(_DWORD *)(a1 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = a21;

  return a1;
}

void sub_100050968(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v5;
  uint64_t v7 = *(unsigned int **)(v1 + 24);
  if (v7) {
    sub_1002CD254(v7);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1000509A0(uint64_t *a1, __int128 *a2)
{
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 4);
  unint64_t v3 = v2 + 1;
  uint64_t v6 = (uint64_t)(a1 + 2);
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4) > v3) {
    unint64_t v3 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4);
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v15 = a1 + 2;
  if (v7) {
    uint64_t v8 = (char *)sub_100050C20((uint64_t)(a1 + 2), v7);
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t v11 = v8;
  unint64_t v12 = &v8[112 * v2];
  uint64_t v14 = &v8[112 * v7];
  sub_100050AC0(v6, (uint64_t)v12, a2);
  uint64_t v13 = v12 + 112;
  sub_100050B84(a1, &v11);
  uint64_t v9 = a1[1];
  sub_100050C68(&v11);
  return v9;
}

void sub_100050AAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

__n128 sub_100050AC0(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  *(_OWORD *)a2 = v5;
  uint64_t v6 = *((void *)a3 + 4);
  *(_OWORD *)(a2 + 16) = a3[1];
  *(void *)(a2 + 32) = v6;
  *(void *)(a2 + 40) = &off_10087FAA8;
  uint64_t v7 = *((void *)a3 + 6);
  *(void *)(a2 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = v7;
  if (v7) {
    sub_1002CD1E0(v7);
  }
  uint64_t v8 = *((void *)a3 + 8);
  *(void *)(a2 + 56) = &off_10087FAA8;
  *(void *)(a2 + 64) = v8;
  if (v8) {
    sub_1002CD1E0(v8);
  }
  __n128 result = *(__n128 *)((char *)a3 + 72);
  *(void *)(a2 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = *((void *)a3 + 11);
  *(__n128 *)(a2 + 72) = result;
  uint64_t v10 = *((void *)a3 + 12);
  *((void *)a3 + 12) = 0LL;
  *(void *)(a2 + 96) = v10;
  *(_DWORD *)(a2 + 104) = *((_DWORD *)a3 + 26);
  return result;
}

void sub_100050B50(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v2;
  uint64_t v4 = *(unsigned int **)(v1 + 48);
  if (v4) {
    sub_1002CD254(v4);
  }

  _Unwind_Resume(a1);
}

void sub_100050B84(uint64_t *a1, void *a2)
{
  __int128 v5 = (__int128 *)*a1;
  uint64_t v4 = (__int128 *)a1[1];
  uint64_t v6 = a2[1];
  if (v4 != (__int128 *)*a1)
  {
    do
    {
      v6 -= 112LL;
      v4 -= 7;
      sub_100050AC0((uint64_t)(a1 + 2), v6, v4);
    }

    while (v4 != v5);
  }

  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *sub_100050C20(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    sub_100008BD4();
  }
  return operator new(112 * a2);
}

void **sub_100050C68(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_100050C98(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 112;
    sub_10004FFB8(v4, i - 112);
  }

uint64_t sub_100050CDC( uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, char a8, char a9, char a10, char a11, char a12, char a13, char a14, char a15)
{
  id v22 = a2;
  id v23 = a3;
  id v24 = v22;
  *(void *)a1 = v24;
  id v25 = v23;
  *(void *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = v25;
  *(_WORD *)(a1 + 16) = 0;
  int v26 = *(_DWORD *)(a4 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a4;
  *(_DWORD *)(a1 + 36) = v26;
  uint64_t v27 = *(void *)(a5 + 8);
  *(void *)(a1 + 40) = &off_10087FAA8;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = v27;
  if (v27) {
    sub_1002CD1E0(v27);
  }
  uint64_t v28 = *(void *)(a6 + 8);
  *(void *)(a1 + 56) = &off_10087FAA8;
  *(void *)(a1 + 64) = v28;
  if (v28) {
    sub_1002CD1E0(v28);
  }
  *(_BYTE *)(a1 + 72) = a7;
  *(_BYTE *)(a1 + 73) = a8;
  *(_BYTE *)(a1 + 74) = a9;
  *(_BYTE *)(a1 + 75) = a10;
  *(_BYTE *)(a1 + 76) = a11;
  *(_BYTE *)(a1 + 77) = a13;
  *(_BYTE *)(a1 + 7_Block_object_dispose((const void *)(v15 - 96), 8) = a14;
  *(_BYTE *)(a1 + 79) = a15;
  *(void *)(a1 + 96) = 0LL;
  *(_DWORD *)(a1 + 104) = 1;

  return a1;
}

void sub_100050DE4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v4;
  uint64_t v6 = *(unsigned int **)(v1 + 48);
  if (v6) {
    sub_1002CD254(v6);
  }

  _Unwind_Resume(a1);
}

void sub_100050E20(id a1)
{
  uint64_t v1 = operator new(0x120uLL);
  sub_100495250();
  qword_1008D61A0 = (uint64_t)v1;
}

void sub_100050E50(_Unwind_Exception *a1)
{
}

void sub_100050E64(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 96LL;
        sub_1000507F8((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

char *sub_100050EE8(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = sub_1000503D4(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      __int128 v8 = *a2;
      *(_DWORD *)(v7 + 16) = *((_DWORD *)a2 + 4);
      *(_OWORD *)uint64_t v7 = v8;
      v7 += 20LL;
      a2 = (__int128 *)((char *)a2 + 20);
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_100050F48(id a1)
{
  uint64_t v1 = operator new(0x1128uLL);
  sub_1005DDADC();
  off_1008D6600 = v1;
}

void sub_100050F78(_Unwind_Exception *a1)
{
}

void sub_100050F8C(id a1)
{
  uint64_t v1 = operator new(0x48uLL);
  sub_100502AF0((uint64_t)v1);
  qword_1008D6610 = (uint64_t)v1;
}

void sub_100050FBC(_Unwind_Exception *a1)
{
}

void sub_100050FD0(id a1)
{
  uint64_t v1 = operator new(0x128uLL);
  sub_1005C69F8();
  off_1008D5F28 = v1;
}

void sub_100051000(_Unwind_Exception *a1)
{
}

void sub_100051014(id a1)
{
  uint64_t v1 = operator new(0xEB0uLL);
  sub_10061991C();
  qword_1008D5F18 = (uint64_t)v1;
}

void sub_100051044(_Unwind_Exception *a1)
{
}

void sub_100051058(id a1)
{
  uint64_t v1 = operator new(0xA8uLL);
  sub_10005109C((uint64_t)v1);
  qword_1008D6620 = (uint64_t)v1;
}

void sub_100051088(_Unwind_Exception *a1)
{
}

uint64_t sub_10005109C(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v15 - 96), 8) = 0u;
  uint64_t v2 = a1 + 128;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_DWORD *)(a1 + 160) = 1065353216;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 104) = 0LL;
  unint64_t v3 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = 0LL;

  atomic_store(0, (unsigned __int8 *)(a1 + 96));
  unsigned __int8 v7 = 7;
  __int128 v8 = &v7;
  uint64_t v4 = sub_1000511EC(v2, &v7, (uint64_t)&unk_1006BB2F0, &v8);
  *(void *)((char *)v4 + 20) = 3263299584LL;
  *((_BYTE *)v4 + 2_Block_object_dispose((const void *)(v15 - 96), 8) = 0;
  v4[4] = 0xC2340000C2820000LL;
  unsigned __int8 v7 = 22;
  __int128 v8 = &v7;
  __int128 v5 = sub_1000511EC(v2, &v7, (uint64_t)&unk_1006BB2F0, &v8);
  *(void *)((char *)v5 + 20) = 3264217088LL;
  *((_BYTE *)v5 + 2_Block_object_dispose((const void *)(v15 - 96), 8) = 0;
  v5[4] = 0xC2700000C2A00000LL;
  return a1;
}

void sub_1000511A4(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 8);
  if (v4)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(a1);
}

void *sub_1000511EC(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _BYTE **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
    }

    else
    {
      unint64_t v9 = ((_DWORD)v7 - 1) & v6;
    }

    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v9);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v6)
          {
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= v7) {
                v12 %= v7;
              }
            }

            else
            {
              v12 &= v7 - 1;
            }

            if (v12 != v9) {
              break;
            }
          }

          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  else
  {
    unint64_t v9 = 0LL;
  }

  uint64_t v11 = operator new(0x28uLL);
  void *v11 = 0LL;
  v11[1] = v6;
  *((_BYTE *)v11 + 16) = **a4;
  *((_DWORD *)v11 + 9) = 0;
  *(void *)((char *)v11 + 20) = 0LL;
  *(void *)((char *)v11 + 2_Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_10005141C(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
      else {
        unint64_t v9 = v6;
      }
    }

    else
    {
      unint64_t v9 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v19 = *(void *)a1;
  int v20 = *(void **)(*(void *)a1 + 8 * v9);
  if (v20)
  {
    void *v11 = *v20;
LABEL_38:
    void *v20 = v11;
    goto LABEL_39;
  }

  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v9) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_100051408(_Unwind_Exception *a1)
{
}

void sub_10005141C(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2LL;
  }

  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }

  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }

    else
    {
      uint64_t v7 = 1LL << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }

    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4) {
LABEL_16:
    }
      sub_1000514F8(a1, prime);
  }

void sub_1000514F8(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_100008BD4();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0LL;
    *(void *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0LL;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }

      else
      {
        v8 &= a2 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v_Block_object_dispose((const void *)(v15 - 96), 8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }

          else
          {
            v12 &= a2 - 1;
          }

          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }

            *uint64_t v7 = *v11;
            void *v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }

          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }

        while (v11);
      }
    }
  }

  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = 0LL;
  }

uint64_t sub_100051650(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  int8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void sub_100051698(id a1)
{
  uint64_t v1 = operator new(0x618uLL);
  sub_10058B0A4();
  off_1008D5F08 = v1;
}

void sub_1000516C8(_Unwind_Exception *a1)
{
}

void *sub_1000516DC(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = (uint64_t)result;
    sub_10005172C(result, a4);
    return (void *)sub_100051778(v6, a2, a3);
  }

  return result;
}

char *sub_10005172C(void *a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    abort();
  }
  __n128 result = (char *)sub_100050740((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[96 * v4];
  return result;
}

uint64_t sub_100051778(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      __n128 result = sub_1000517E8(v4 + v7, a2 + v7);
      v7 += 96LL;
    }

    while (a2 + v7 != a3);
    v4 += v7;
  }

  *(void *)(v3 + _Block_object_dispose((const void *)(v15 - 96), 8) = v4;
  return result;
}

void sub_1000517E0(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v15 - 96), 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1000517E8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(id *)a2;
  *(_WORD *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = *(_WORD *)(a2 + 8);
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = &off_10087FAA8;
  *(void *)(a1 + 24) = v4;
  if (v4) {
    sub_1002CD1E0(v4);
  }
  uint64_t v5 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = &off_10087FAA8;
  *(void *)(a1 + 40) = v5;
  if (v5) {
    sub_1002CD1E0(v5);
  }
  int v6 = *(_DWORD *)(a2 + 48);
  *(_BYTE *)(a1 + 52) = *(_BYTE *)(a2 + 52);
  *(_DWORD *)(a1 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = v6;
  *(void *)(a1 + 56) = *(id *)(a2 + 56);
  int v7 = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 6_Block_object_dispose((const void *)(v15 - 96), 8) = *(_BYTE *)(a2 + 68);
  *(_DWORD *)(a1 + 64) = v7;
  *(void *)(a1 + 72) = *(id *)(a2 + 72);
  int v8 = *(_DWORD *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_DWORD *)(a1 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = v8;
  return a1;
}

void sub_100051898(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  uint64_t v4 = *(unsigned int **)(v1 + 24);
  if (v4) {
    sub_1002CD254(v4);
  }

  _Unwind_Resume(a1);
}

uint64_t *sub_1000518C4(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100051918(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_100051900(_Unwind_Exception *a1)
{
}

uint64_t *sub_100051918(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    int v6 = result + 1;
    do
    {
      __n128 result = sub_10005199C(v5, v6, v4 + 32, (uint64_t)(v4 + 32));
      int v7 = (unsigned __int8 *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          int v7 = *(unsigned __int8 **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          int v8 = (unsigned __int8 *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_10005199C(uint64_t **a1, uint64_t *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  int v6 = (uint64_t **)sub_100051A28(a1, a2, &v10, &v9, a3);
  __n128 result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100051BAC((uint64_t)a1, a4, v8);
    sub_100029630(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }

  return result;
}

unsigned __int8 *sub_100051A28( void *a1, uint64_t *a2, unsigned __int8 **a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t v9 = (unsigned __int8 *)(a1 + 1);
  if (a1 + 1 == a2 || sub_10063447C(a5, (unsigned __int8 *)a2 + 32))
  {
    if ((uint64_t *)*a1 == a2)
    {
      unint64_t v12 = (unsigned __int8 *)a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 8;
      }

      else
      {
        *a3 = (unsigned __int8 *)a2;
        return (unsigned __int8 *)a2;
      }
    }

    uint64_t v11 = (unsigned __int8 *)*a2;
    if (*a2)
    {
      do
      {
        unint64_t v12 = v11;
        uint64_t v11 = (unsigned __int8 *)*((void *)v11 + 1);
      }

      while (v11);
    }

    else
    {
      unint64_t v16 = a2;
      do
      {
        unint64_t v12 = (unsigned __int8 *)v16[2];
        BOOL v17 = *(void *)v12 == (void)v16;
        unint64_t v16 = (uint64_t *)v12;
      }

      while (v17);
    }

    if (sub_10063447C(v12 + 32, a5)) {
      goto LABEL_16;
    }
    return (unsigned __int8 *)sub_10002E9C8((uint64_t)a1, a3, a5);
  }

  if (sub_10063447C((unsigned __int8 *)a2 + 32, a5))
  {
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      float v14 = (unsigned __int8 *)a2[1];
      do
      {
        BOOL v15 = v14;
        float v14 = *(unsigned __int8 **)v14;
      }

      while (v14);
    }

    else
    {
      size_t v18 = (unsigned __int8 *)a2;
      do
      {
        BOOL v15 = (unsigned __int8 *)*((void *)v18 + 2);
        BOOL v17 = *(void *)v15 == (void)v18;
        size_t v18 = v15;
      }

      while (!v17);
    }

    if (v15 != v9)
    {
      if (!sub_10063447C(a5, v15 + 32)) {
        return (unsigned __int8 *)sub_10002E9C8((uint64_t)a1, a3, a5);
      }
      uint64_t v13 = *a4;
    }

    if (v13)
    {
      *a3 = v15;
      return v15;
    }

    else
    {
      *a3 = (unsigned __int8 *)a2;
    }

    return (unsigned __int8 *)a4;
  }

  *a3 = (unsigned __int8 *)a2;
  *a4 = (uint64_t)a2;
  return (unsigned __int8 *)a4;
}

void sub_100051BAC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0LL;
  a3[2] = 0LL;
  a3[1] = 0LL;
  int v6 = a3 + 1;
  int v7 = operator new(0x48uLL);
  *a3 = v7;
  *int v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  v7[2] = *(_OWORD *)a2;
  *((_DWORD *)v7 + 12) = *(_DWORD *)(a2 + 16);
  uint64_t v8 = *(void *)(a2 + 32);
  *((void *)v7 + 7) = &off_10087FAA8;
  *((void *)v7 + _Block_object_dispose((const void *)(v15 - 96), 8) = v8;
  if (v8) {
    sub_1002CD1E0(v8);
  }
  *((_BYTE *)a3 + 16) = 1;
}

void sub_100051C38(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_100051C54(v2, v3);
  _Unwind_Resume(a1);
}

void sub_100051C54(uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    __p[7] = &off_10087FAA8;
    uint64_t v3 = (unsigned int *)__p[8];
    if (v3) {
      sub_1002CD254(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_100051CA8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100051CA8(a1, *a2);
    sub_100051CA8(a1, a2[1]);
    a2[7] = &off_10087FAA8;
    uint64_t v4 = (unsigned int *)a2[8];
    if (v4) {
      sub_1002CD254(v4);
    }
    operator delete(a2);
  }

uint64_t sub_100051D00(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    BOOL v6 = sub_10063447C((unsigned __int8 *)(v3 + 32), a2);
    int v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      int v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }

    uint64_t v3 = *v7;
  }

  while (*v7);
  return v5;
}

LABEL_55:
      spatialDeviceMapMatched = v28->_spatialDeviceMapMatched;
      v78[0] = _NSConcreteStackBlock;
      v78[1] = 3221225472LL;
      v78[2] = sub_1000526E8;
      v78[3] = &unk_1008808E0;
      v78[4] = &v102;
      -[NSMutableDictionary enumerateKeysAndObjectsUsingBlock:]( spatialDeviceMapMatched,  "enumerateKeysAndObjectsUsingBlock:",  v78);
LABEL_56:
      int v69 = 1;
      goto LABEL_57;
    }
  }

  else if (v68 == 0)
  {
    goto LABEL_63;
  }

  int v46 = (id *)(v103 + 5);
  __int128 v86 = (id)v103[5];
  NSAppendPrintF_safe(&v86, ", Matched %d/%d", DWORD2(v68), (_DWORD)v68);
  objc_storeStrong(v46, v86);
  uint64_t v28 = self;
  if (v67) {
    goto LABEL_42;
  }
  if (*((void *)&v68 + 1))
  {
    uint64_t v57 = (id *)(v103 + 5);
    uint64_t v79 = (id)v103[5];
    NSAppendPrintF_safe(&v79, "\n");
    objc_storeStrong(v57, v79);
    uint64_t v28 = self;
    goto LABEL_55;
  }

  if ((void)v68)
  {
LABEL_59:
    uint64_t v59 = (id *)(v103 + 5);
    __n128 v77 = (id)v103[5];
    NSAppendPrintF_safe(&v77, "\n");
    objc_storeStrong(v59, v77);
    uint64_t v28 = self;
LABEL_60:
    spatialDeviceMapUnmatched = v28->_spatialDeviceMapUnmatched;
    v76[0] = _NSConcreteStackBlock;
    v76[1] = 3221225472LL;
    v76[2] = sub_100052734;
    v76[3] = &unk_1008808E0;
    v76[4] = &v102;
    -[NSMutableDictionary enumerateKeysAndObjectsUsingBlock:]( spatialDeviceMapUnmatched,  "enumerateKeysAndObjectsUsingBlock:",  v76);
    int v69 = 1;
    goto LABEL_64;
  }

          id v24 = 2LL;
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Remote side parameters are invalid, bailing.",  v91,  v92,  v93,  v94,  v95,  v96,  v97,  v100);
            v98 = (os_log_s *)sub_100086554(0x2Fu);
            if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR)) {
LABEL_57:
            }
              sub_100657858();
            return 2LL;
          }

          return v24;
        }

        if ((a3 & 1) == 0)
        {
          if ((unsigned __int16)(*(_WORD *)(a2 + 14) + 5535) <= 0x1602u)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"Invalid parameter %s:%d=%d",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  (uint64_t)"checkParams");
              int v72 = (os_log_s *)sub_100086554(0x2Fu);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
                goto LABEL_54;
              }
            }

            goto LABEL_55;
          }

          if ((unsigned __int16)(*(_WORD *)(a2 + 16) + 5535) <= 0x1602u)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"Invalid parameter %s:%d=%d",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  (uint64_t)"checkParams");
              v90 = (os_log_s *)sub_100086554(0x2Fu);
              if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
                goto LABEL_54;
              }
            }

            goto LABEL_55;
          }
        }
      }

      ((void (*)(unsigned int *, uint64_t, uint64_t))off_100885DD0[v11])(a1, a2, a4);
      return 0LL;
    }

    if (sub_100185B88(a1))
    {
LABEL_44:
      if (v9 > v8)
      {
LABEL_45:
        *(_BYTE *)(a4 + 10) = v8;
        int v81 = sub_10017AB4C(a1);
        ++*(_BYTE *)(v81 + 76);
        goto LABEL_3;
      }

      goto LABEL_47;
    }

    sub_1001EE2A0();
    return 0LL;
  }

  uint64_t v28 = *(unsigned __int16 *)(v21 + 36);
  uint64_t v9 = qword_1008E2C28;
  while (*(unsigned __int16 *)(v9 + 24) != v28)
  {
    uint64_t v9 = *(void *)(v9 + 80);
    if (v9 == qword_1008E2C28 || v9 == 0) {
      goto LABEL_52;
    }
  }

  if (*(_BYTE *)(v9 + 16) && (sub_1001858C4(v28) & 1) == 0) {
    return 0LL;
  }
  unint64_t v39 = &qword_1008E2C40;
LABEL_72:
  int v7 = *v39;
  if (*v39)
  {
    if (v7 == qword_1008E2C38 || v7 == qword_1008E2C40)
    {
      *a4 = a3 - *(void *)(v9 + 48);
      *(void *)(v9 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = a3;
    }

    else
    {
LABEL_79:
      *a4 = a3 - *(void *)(v7 + 48);
      *(void *)(v7 + 4_Block_object_dispose((const void *)(v15 - 96), 8) = a3;
    }
  }

  return v7;
}

    ++v53;
  }

  while (v53 != 4);
  if (!v54)
  {
    if (v48 == (_DWORD)a1
      && v38 == 1
      && *(_BYTE *)a2 == 1
      && *(_WORD *)(a2 + 2) == 4
      && HIWORD(*(_DWORD *)(a2 + 8)) == 1024)
    {
      id v62 = (unsigned __int16)*v6;
      if ((unsigned __int16)*(_DWORD *)(a2 + 8) >= v62)
      {
        LODWORD(v52) = v62 <= 0x400 ? 1024 : (unsigned __int16)*v6;
        if (((_DWORD)v52 - 1024) < 0x25)
        {
          int v54 = &word_1008EDCC0;
          word_1008EDCC0 = (__int16)v52;
          byte_1008EDCC8 = 6;
          word_1008EDCCA = 2;
          qword_1008EDCD0 = (uint64_t)&byte_1008EDCD8;
          byte_1008EDCD8 = 4;
          v94 = &(&off_100886970)[2 * ((_DWORD)v52 - 1024)];
          v95 = *v94;
          v96 = a5;
          v97 = strlen(*v94);
          a5 = v96;
          word_1008EDCDA = v97;
          qword_1008EDCE0 = (uint64_t)v95;
          byte_1008EDCE8 = 1;
          word_1008EDCEA = 2;
          dword_1008EDCF0 = *((unsigned __int16 *)v94 + 4);
          goto LABEL_116;
        }
      }
    }

    goto LABEL_67;
  }

  if ((unsigned __int16)*v54 != (unsigned __int16)v52)
  {
    uint64_t v52 = a5;
    sub_1001EE2A0();
    a5 = v52;
    LOWORD(v52) = *v54;
  }

      id v29 = (*(uint64_t (**)(uint64_t))(*(void *)v6[5] + 16LL))(v6[5]);
      id v30 = v6[5];
      if (v29)
      {
        id v31 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 16LL))(v6[5]);
        uint64_t v32 = v6[5];
        if (v31 != 1)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v32 + 16LL))(v6[5]) != 3)
          {
            unint64_t v40 = 0;
            goto LABEL_105;
          }

          int v72 = v6[5];
          unint64_t v40 = [*(id *)(v72 + 232) count] != 0;
          [*(id *)(v72 + 240) removeAllObjects];
LABEL_104:
          BOOL v15 = a2;
LABEL_105:
          sub_10027D160(a1, v15);
          uint64_t v59 = sub_1002E8E64();
          (*(void (**)(uint64_t, unint64_t, id))(*(void *)v59 + 8LL))(v59, v15, v13);
          v111 = 0LL;
          *(_OWORD *)__p = 0u;
          v110 = 0u;
          sub_100494958(v15, (uint64_t)buf);
          sub_10040CC88((uint64_t)__p, (__int128 *)buf, *(_BYTE *)(v6[5] + 129));
          if (v108 < 0) {
            operator delete(*(void **)buf);
          }
          if (qword_1008D9298 != -1) {
            dispatch_once(&qword_1008D9298, &stru_10088BCC0);
          }
          sub_10040D074(qword_1008D9290, (uint64_t)__p);
          sub_10027D37C(a1);
          sub_1001FDBCC(v78, v6);
          operator delete(v6);
          if (v80) {
            (*(void (**)(uint64_t))(*(void *)v80 + 8LL))(v80);
          }
          uint64_t v60 = *v78;
          if (*v78 == v81)
          {
LABEL_120:
            int v64 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 320) objectForKeyedSubscript:v13]);
            uint64_t v65 = v64;
            if (v64)
            {
              [v64 removeObject:v14];
              [*(id *)(a1 + 320) setObject:v65 forKeyedSubscript:v13];
              uint32_t v66 = (os_log_s *)qword_1008F7628;
              if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138543618;
                *(void *)&uint8_t buf[4] = v13;
                v106 = 2112;
                v107 = v14;
                _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEFAULT,  "Application %{public}@ for user %@ is no longer interested in FindMy devices",  buf,  0x16u);
              }
            }
          }

          else
          {
            while (![*(id *)(v60[5] + 88) isEqualToString:v13]
                 || ([*(id *)(v60[5] + 104) isEqual:v14] & 1) == 0)
            {
              int v61 = (uint64_t *)v60[1];
              if (v61)
              {
                do
                {
                  id v62 = v61;
                  int v61 = (uint64_t *)*v61;
                }

                while (v61);
              }

              else
              {
                do
                {
                  id v62 = (uint64_t *)v60[2];
                  int v63 = *v62 == (void)v60;
                  uint64_t v60 = v62;
                }

                while (!v63);
              }

              uint64_t v60 = v62;
              if (v62 == v81) {
                goto LABEL_120;
              }
            }
          }

          if (*(_BYTE *)(a1 + 178))
          {
            uint64_t v67 = *v78;
            if (*v78 == v81)
            {
LABEL_134:
              int v71 = 0;
            }

            else
            {
              while (1)
              {
                char v68 = v67[5];
                if (*(_BYTE *)(v68 + 24))
                {
                  if (*(void *)(v68 + 96)) {
                    break;
                  }
                }

                int v69 = (uint64_t *)v67[1];
                if (v69)
                {
                  do
                  {
                    BOOL v70 = v69;
                    int v69 = (uint64_t *)*v69;
                  }

                  while (v69);
                }

                else
                {
                  do
                  {
                    BOOL v70 = (uint64_t *)v67[2];
                    int v63 = *v70 == (void)v67;
                    uint64_t v67 = v70;
                  }

                  while (!v63);
                }

                uint64_t v67 = v70;
                if (v70 == v81) {
                  goto LABEL_134;
                }
              }

              int v71 = 1;
            }

            *(_BYTE *)(a1 + 17_Block_object_dispose((const void *)(v15 - 96), 8) = v71;
          }

          if (!*(void *)(a1 + 240)) {
            word_1008D925A = 1;
          }
          if (qword_1008D61A8 != -1) {
            dispatch_once(&qword_1008D61A8, &stru_10088BCE0);
          }
          __int128 v73 = qword_1008D61A0;
          int v74 = sub_100494CF8(a2);
          sub_1004966BC(v73, v74);
          if (v40) {
            sub_100278BE4(a1);
          }
          if (SHIBYTE(v110) < 0) {
            operator delete(__p[1]);
          }
          goto LABEL_148;
        }

        if (*(_BYTE *)(v32 + 226))
        {
          if (qword_1008D6288 != -1) {
            dispatch_once(&qword_1008D6288, &stru_10088BBE0);
          }
          sub_100575180((uint64_t)off_1008D6280, v15);
        }

        sub_10027D0D4(a1, v15);
        __n128 v77 = v13;
        __n128 v82 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v32 + 80) allKeys]);
        [*(id *)(v32 + 80) removeAllObjects];
        __int128 v86 = 0u;
        int v87 = 0u;
        __int128 v84 = 0u;
        int v85 = 0u;
        uint64_t v33 = v82;
        __int16 v34 = [v33 countByEnumeratingWithState:&v84 objects:v112 count:16];
        if (v34)
        {
          char v35 = *(void *)v85;
          do
          {
            uint64_t v36 = 0LL;
            do
            {
              if (*(void *)v85 != v35) {
                objc_enumerationMutation(v33);
              }
              __int128 v37 = *(void **)(*((void *)&v84 + 1) + 8LL * (void)v36);
              if (qword_1008D5F10 != -1) {
                dispatch_once(&qword_1008D5F10, &stru_10088BB00);
              }
              int v38 = off_1008D5F08;
              unint64_t v39 = sub_10027CF60(a1, v37);
              sub_100593618((uint64_t)v38, v37, v39, 1);
              uint64_t v36 = (char *)v36 + 1;
            }

            while (v34 != v36);
            __int16 v34 = [v33 countByEnumeratingWithState:&v84 objects:v112 count:16];
          }

          while (v34);
        }

        uint64_t v13 = v77;
        unint64_t v40 = 0;
      }

      else
      {
        if (*(_BYTE *)(v30 + 272)) {
          sub_1003909B4(v6[5], v15);
        }
        memset(v100, 0, sizeof(v100));
        sub_100396E6C(v30, v15, 0, v14, 0LL, v100, 0LL, v13);
        if (qword_1008D5F60 != -1) {
          dispatch_once(&qword_1008D5F60, &stru_10088BAE0);
        }
        sub_100555D70(qword_1008D5F58, v15);
        [*(id *)(v30 + 224) removeAllObjects];
        id v41 = [*(id *)(v30 + 216) count];
        __int128 v42 = v41 != 0LL;
        uint64_t v83 = v30;
        if (v41)
        {
          v98 = 0u;
          v99 = 0u;
          v96 = 0u;
          v97 = 0u;
          unint64_t v43 = *(id *)(v30 + 216);
          unint64_t v44 = [v43 countByEnumeratingWithState:&v96 objects:v115 count:16];
          if (v44)
          {
            uint64_t v45 = *(void *)v97;
            do
            {
              for (uint64_t j = 0LL; j != v44; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v97 != v45) {
                  objc_enumerationMutation(v43);
                }
                int v47 = *(id *)(*((void *)&v96 + 1) + 8LL * (void)j);
                sub_10027CD0C(a1, v47);
              }

              unint64_t v44 = [v43 countByEnumeratingWithState:&v96 objects:v115 count:16];
            }

            while (v44);
          }

          id v30 = v83;
        }

        [*(id *)(v30 + 304) removeAllObjects];
        int v76 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v30 + 80) allKeys]);
        [*(id *)(v30 + 80) removeAllObjects];
        __int128 v75 = v42;
        v94 = 0u;
        v95 = 0u;
        v92 = 0u;
        v93 = 0u;
        uint64_t v33 = v76;
        uint64_t v48 = [v33 countByEnumeratingWithState:&v92 objects:v114 count:16];
        if (v48)
        {
          id v49 = *(void *)v93;
          do
          {
            uint64_t v50 = 0LL;
            do
            {
              if (*(void *)v93 != v49) {
                objc_enumerationMutation(v33);
              }
              uint64_t v51 = *(void **)(*((void *)&v92 + 1) + 8LL * (void)v50);
              if (qword_1008D5F10 != -1) {
                dispatch_once(&qword_1008D5F10, &stru_10088BB00);
              }
              uint64_t v52 = off_1008D5F08;
              uint64_t v53 = sub_10027CF60(a1, v51);
              sub_100593618((uint64_t)v52, v51, v53, 0);
              uint64_t v50 = (char *)v50 + 1;
            }

            while (v48 != v50);
            uint64_t v48 = [v33 countByEnumeratingWithState:&v92 objects:v114 count:16];
          }

          while (v48);
        }

        unint64_t v40 = v75;
        sub_10027D044(a1, a2);
        int v54 = *(void **)(v83 + 360);
        if (v54 && [v54 count])
        {
          v90 = 0u;
          v91 = 0u;
          int v88 = 0u;
          v89 = 0u;
          uint64_t v55 = *(id *)(v83 + 360);
          uint64_t v56 = [v55 countByEnumeratingWithState:&v88 objects:v113 count:16];
          if (v56)
          {
            uint64_t v57 = *(void *)v89;
            do
            {
              for (k = 0LL; k != v56; k = (char *)k + 1)
              {
                if (*(void *)v89 != v57) {
                  objc_enumerationMutation(v55);
                }
                sub_10039BB08(v83, *(void **)(*((void *)&v88 + 1) + 8LL * (void)k), 0, 0LL);
              }

              uint64_t v56 = [v55 countByEnumeratingWithState:&v88 objects:v113 count:16];
            }

            while (v56);
          }

          [*(id *)(v83 + 360) removeAllObjects];
        }
      }

      goto LABEL_104;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7628, OS_LOG_TYPE_ERROR)) {
    sub_100665978();
  }
  return 1LL;
}

              *(void *)(a1 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = v32;
              *(void *)(a1 + 96) = v23;
              *(void *)(a1 + 104) = &v21[8 * v20];
              if (v33) {
                operator delete(v33);
              }
              goto LABEL_57;
            }
          }

          *BOOL v15 = v11;
          id v23 = v15 + 1;
LABEL_57:
          *(void *)(a1 + 96) = v23;
          int v38 = *(uint64_t **)(v9 + 16);
          unint64_t v39 = (char *)v38 - (char *)(v10 + 1);
          if (v38 != v10 + 1) {
            memmove(v10, v10 + 1, (char *)v38 - (char *)(v10 + 1));
          }
          uint64_t v27 = (uint64_t *)((char *)v10 + v39);
          *(void *)(v9 + 16) = (char *)v10 + v39;
        }

        while (v10 != v27);
      }

      sub_1001FDBCC((uint64_t **)(a1 + 16), v5);
      operator delete(v5);
      unint64_t v40 = (void *)sub_10036B2F4(v9);
      operator delete(v40);
    }
  }

  v103 = 0;
  id v30 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENOverrideShortAPWakeDeltaInSeconds");
  id v31 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v30 + 88LL))(v30, buf, __p, &v103);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v31) {
      goto LABEL_63;
    }
  }

  else if (!v31)
  {
    goto LABEL_63;
  }

  uint64_t v32 = v103;
  *(_WORD *)(a1 + 222) = v103;
  uint64_t v33 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v32;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Overriding fAPWakeDeltaDurationNormalSeconds = %d ",  buf,  8u);
  }

  __int16 v34 = **(unsigned __int16 **)(a2 + 8);
  char v35 = v34 - 1;
  uint64_t v36 = *(unsigned __int16 *)(*v13)[1];
  while (1)
  {
    __int128 v37 = v34;
    __int16 v34 = v35;
    int v38 = *v5;
    if (*v5) {
      break;
    }
LABEL_84:
    char v35 = v34 - 1;
  }

  unint64_t v39 = v5;
  unint64_t v40 = *v5;
  do
  {
    id v41 = *(unsigned __int16 *)(v40 + 32);
    __int128 v42 = v41 >= (unsigned __int16)v34;
    else {
      unint64_t v43 = (uint64_t *)(v40 + 8);
    }
    if (v42) {
      unint64_t v39 = (void *)v40;
    }
    unint64_t v40 = *v43;
  }

  while (*v43);
  if (v39 != v5 && *((unsigned __int16 *)v39 + 16) <= (unsigned __int16)v34)
  {
    id v49 = *(void *)(v39[5] + 8LL);
    uint64_t v50 = *(_DWORD *)(v49 + 20);
    *(_OWORD *)&v68.__r_.__value_.__l.__data_ = *(_OWORD *)(v49 + 4);
    LODWORD(v68.__r_.__value_.__r.__words[2]) = v50;
    sub_100634334((__n128 *)&buf, (__n128 *)&v68);
    int v61 = 0;
    uint64_t v60 = xmmword_1006C305C;
    if (sub_1001BEC7C((unsigned __int8 *)&buf, (unsigned __int8 *)&v60))
    {
      uint64_t v57 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
      sub_1003826DC((void *)v39[5], (uint64_t)v57);
      LOWORD(buf.__r_.__value_.__l.__data_) = **(_WORD **)(a2 + 8);
      v68.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
      uint64_t v33 = 0;
      sub_1002550B8(v6, (unsigned __int16 *)&buf, (uint64_t)&unk_1006C2518, &v68)[5] = v57;
      goto LABEL_90;
    }

    LOWORD(v36) = *(_WORD *)(*v13)[1];
    goto LABEL_84;
  }

  if (v38)
  {
    unint64_t v44 = v37 - 2;
    uint64_t v45 = v5;
    do
    {
      int v46 = *(unsigned __int16 *)(v38 + 32);
      int v47 = v46 >= v44;
      if (v46 >= v44) {
        uint64_t v48 = (uint64_t *)v38;
      }
      else {
        uint64_t v48 = (uint64_t *)(v38 + 8);
      }
      if (v47) {
        uint64_t v45 = (void *)v38;
      }
      int v38 = *v48;
    }

    while (*v48);
  }

  sub_10057EAB4(a1, a2);
  return sub_10057E258(a1, a2);
}

LABEL_63:
  int v69 = 0;
LABEL_64:
  if (v66 && -[NSMutableDictionary count](v28->_deviceMap, "count"))
  {
    if (!v69)
    {
      int v61 = (id *)(v103 + 5);
      __int128 v75 = (id)v103[5];
      NSAppendPrintF_safe(&v75, "\n");
      objc_storeStrong(v61, v75);
      uint64_t v28 = self;
    }

    deviceMap = v28->_deviceMap;
    v74[0] = _NSConcreteStackBlock;
    v74[1] = 3221225472LL;
    v74[2] = sub_100052780;
    v74[3] = &unk_1008808E0;
    v74[4] = &v102;
    -[NSMutableDictionary enumerateKeysAndObjectsUsingBlock:](deviceMap, "enumerateKeysAndObjectsUsingBlock:", v74);
  }

  else if (!v69)
  {
    int v63 = (id *)(v103 + 5);
    __int128 v73 = (id)v103[5];
    NSAppendPrintF_safe(&v73, "\n");
    objc_storeStrong(v63, v73);
  }

LABEL_72:
  int v64 = (id)v103[5];
  _Block_object_dispose(&v102, 8);

  return v64;
}

        __n128 result = (char *)sub_1000B1814(4uLL);
        uint64_t v28 = result;
        id v29 = 33620128;
        if (result) {
          goto LABEL_55;
        }
      }

      return result;
    case 't':
      goto LABEL_10;
    case 'u':
      if ((_DWORD)a4 == 1)
      {
        if (!v9) {
          goto LABEL_54;
        }
        uint64_t v10 = *(unsigned __int8 *)a5;
        return (char *)v9(a1, a2, v10);
      }

      sub_1001EE134( (uint64_t)"Invalid length for GetTotalNumberOfItems: %d (expecting equal to 1)",  v67,  v68,  v69,  v70,  v71,  v72,  v73,  a4);
      int v74 = (os_log_s *)sub_100086554(4u);
      if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
        goto LABEL_45;
      }
      goto LABEL_44;
    default:
      if ((_DWORD)a3 != 128)
      {
LABEL_10:
        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"PDU 0x%x shouldn't be sent on the browsing channel",  v19,  v20,  v21,  v22,  v23,  v24,  v25,  a3);
          int v26 = (os_log_s *)sub_100086554(4u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
            sub_100657858();
          }
        }

        __n128 result = (char *)sub_1000B1814(4uLL);
        uint64_t v28 = result;
        id v29 = 65696;
        if (!result) {
          return result;
        }
        goto LABEL_55;
      }

      if (a4 > 3)
      {
        if (v38)
        {
          unint64_t v39 = a5 + 2;
          unint64_t v40 = bswap32(a5[1]) >> 16;
          return (char *)v38(a1, a2, bswap32(*a5) >> 16, v40, v39);
        }

        uint64_t v27 = *v23 + v21;
        sub_1001EE0E4( "Cap %d is {id=%d, tech=%s, usable=%d, tput=%d, latency=%d, power=%d, extra=%d, common=%d}",  v22++,  *v24,  v26,  *(unsigned __int8 *)(v27 + 2),  *(_DWORD *)(v27 + 4),  *(unsigned __int16 *)(v27 + 8),  *(unsigned __int16 *)(v27 + 10),  *(unsigned __int8 *)(v27 + 12),  *(unsigned __int8 *)(v27 + 13));
        v21 += 64LL;
      }

      while (v22 < *v10);
    }

    ++v0;
  }

  while (v0 < dword_1008F29B4);
  if (!dword_1008F29B4) {
    goto LABEL_66;
  }
}

      v155 = v48;
      sub_10008B740((uint64_t)a1);
      if (xmmword_1008F29C8) {
        xmmword_1008F29C8(a1, v47, *((unsigned __int8 *)a1 + 26), *((_DWORD *)a1 + 37) == 2);
      }
      int v78 = dword_1008F29B4;
      if (!dword_1008F29B4) {
        goto LABEL_77;
      }
      uint64_t v79 = &word_1008F29F8;
      while (*((unsigned __int16 **)v79 - 1) != a1)
      {
        v79 += 536;
        if (!--v78) {
          goto LABEL_77;
        }
      }

      __int128 v80 = (unsigned __int16)*v79;
      if ((_DWORD)v80 == 0xFFFF)
      {
LABEL_77:
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"Not tracking this device.", v83, v84, v85, v86, v87, v88, v89, v154);
          v90 = (os_log_s *)sub_100086554(0x56u);
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR)) {
            goto LABEL_79;
          }
        }
      }

      else if ((sub_10008D900((uint64_t)a1) & 1) != 0)
      {
        int v81 = dword_1008F29B4;
        if (!dword_1008F29B4) {
          goto LABEL_114;
        }
        __n128 v82 = &dword_1008F2A20;
        while (*((unsigned __int16 *)v82 - 20) != (_DWORD)v80)
        {
          v82 += 268;
          if (!--v81) {
            goto LABEL_114;
          }
        }

        if (*v82 != 2)
        {
LABEL_114:
          v134 = dword_1008F29B4;
          if (dword_1008F29B4)
          {
            v135 = (unsigned int *)&dword_1008F2A20;
            while (*((unsigned __int16 *)v135 - 20) != (_DWORD)v80)
            {
              v135 += 268;
              if (!--v134) {
                goto LABEL_119;
              }
            }

            v136 = *v135;
          }

          else
          {
LABEL_119:
            v136 = 0;
          }

          v137 = sub_1000FFB28(v136);
          sub_1001EE134( (uint64_t)"Caps response should only be send when in ENCRYPTED state. Current state is %s",  v138,  v139,  v140,  v141,  v142,  v143,  v144,  (uint64_t)v137);
          v145 = (os_log_s *)sub_100086554(0x56u);
          if (!os_log_type_enabled(v145, OS_LOG_TYPE_ERROR)) {
            goto LABEL_80;
          }
          goto LABEL_79;
        }

        sub_100102124(v80, 6u);
        v121 = 13LL * byte_1008F29B0;
        v122 = (char *)sub_1000B17F4(v121 + 7);
        if (v122)
        {
          v123 = v122;
          *v122 = 2;
          v122[1] = v121 + 5;
          *(_DWORD *)(v122 + 2) = 2;
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Sending CAPS_IND on lmhandle 0x%4x to version %d",  v124,  v125,  v126,  v127,  v128,  v129,  v130,  *a1);
            v131 = (os_log_s *)sub_100086554(0x56u);
            if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
            {
              v132 = sub_1001EDDCC();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = v132;
              _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
            }
          }

          v133 = sub_10008F3E4(0LL, (__int128 *)a1, v80, v123, v121 + 7, 0);
          sub_1000B1838(v123);
          if (!v133 || v133 == 412) {
            goto LABEL_100;
          }
          goto LABEL_80;
        }

        if (sub_1000A86F0())
        {
          sub_1001EE134( (uint64_t)"Failed to allocate %d bytes (%d transports)",  v146,  v147,  v148,  v149,  v150,  v151,  v152,  (v121 + 7));
          v153 = (os_log_s *)sub_100086554(0x56u);
          if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR)) {
LABEL_79:
          }
            sub_100657858();
        }
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Link is not encrypted, can't send caps", v113, v114, v115, v116, v117, v118, v119, v154);
        v120 = (os_log_s *)sub_100086554(0x56u);
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR)) {
          goto LABEL_79;
        }
      }

  uint32_t v66 = sub_10017AB4C((unsigned int *)v0);
  sub_10017B47C(*(unsigned __int16 **)(v66 + 112));
  if (sub_1000A86F0())
  {
    uint64_t v67 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL);
    char v68 = (v1 >> 8) & 0x3F;
    sub_10017AB4C((unsigned int *)v0);
    sub_10017AB4C((unsigned int *)v0);
    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL) > v68
      || v68 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 4LL))
    {
      sub_10017AB4C((unsigned int *)v0);
      sub_10017AB4C((unsigned int *)v0);
      sub_10017AB4C((unsigned int *)v0);
    }

    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 6LL) > v68
      || v68 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C((unsigned int *)v0) + 112) + 4LL))
    {
      sub_10017AB4C((unsigned int *)v0);
      sub_10017AB4C((unsigned int *)v0);
      sub_10017AB4C((unsigned int *)v0);
    }

    sub_10017AB4C((unsigned int *)v0);
    sub_10017AB4C((unsigned int *)v0);
    sub_10017AB4C((unsigned int *)v0);
    sub_1001EE134( (uint64_t)"Invalid S-Frame header while in RECV e:%d, r:%d, n:%d, u:%d, WITH_VALID_REQSEQ=%d, WITH_VALID_REQSEQ_VALU E=%d, WITH_VALID_REQSEQ_BOUNDS=%d",  v69,  v70,  v71,  v72,  v73,  v74,  v75,  v67);
    int v76 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR)) {
      sub_100657F74();
    }
  }

  return sub_1001759FC(*(unsigned __int16 *)(v0 + 4), 436LL);
}

            sub_100657858();
            return;
          }

          uint64_t v36 = (__int128 **)qword_1008E88E0;
          while (*v36 != a1)
          {
            v36 += 3;
            if (!--v35) {
              goto LABEL_30;
            }
          }

          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Ignoring request as connection 0x%x already has one in the stall queue",  v43,  v44,  v45,  v46,  v47,  v48,  v49,  (uint64_t)a1);
            uint64_t v50 = (os_log_s *)sub_100086554(0x44u);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
              goto LABEL_63;
            }
          }
        }
      }

      else if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Ignoring request [%@] as connection 0x%x is already pending transaction %d",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  (uint64_t)a2);
        uint64_t v32 = (os_log_s *)sub_100086554(0x44u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          goto LABEL_63;
        }
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Ignoring request as ATT database is not initialized!",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v76);
      id v24 = (os_log_s *)sub_100086554(0x44u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        goto LABEL_63;
      }
    }
  }

  v102 = 0;
  __int16 v34 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENOverrideNormalAPWakeDeltaInSeconds");
  char v35 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v34 + 88LL))(v34, buf, __p, &v102);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v35) {
      goto LABEL_71;
    }
  }

  else if (!v35)
  {
    goto LABEL_71;
  }

  uint64_t v36 = v102;
  *(_WORD *)(a1 + 224) = v102;
  __int128 v37 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v36;
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Overriding fAPWakeDeltaDurationShortSeconds = %d ",  buf,  8u);
  }

          if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
            sub_100684B08();
          }
LABEL_65:
          id v31 = 0LL;
          goto LABEL_66;
        }

        ++v16;
      }

      unint64_t v16 = (uint64_t **)*v16;
      if (!v16) {
        goto LABEL_56;
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
    sub_100684B94();
  }
  float v14 = (uint64_t **)a1[73];
  if (!v14)
  {
LABEL_11:
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_100684B68();
    }
    goto LABEL_63;
  }

  while (1)
  {
    BOOL v15 = *((unsigned __int16 *)v14 + 16);
    if (v50 >= v15) {
      break;
    }
LABEL_10:
    float v14 = (uint64_t **)*v14;
    if (!v14) {
      goto LABEL_11;
    }
  }

  if (v15 < v50)
  {
    ++v14;
    goto LABEL_10;
  }

  size_t v18 = sub_10036D800((uint64_t)(a1 + 72), &v50);
  uint64_t v19 = v18;
  int v20 = *((unsigned __int8 *)v18 + 72);
  if (*((_BYTE *)v18 + 72))
  {
    unint64_t v21 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_FAULT))
    {
      unint64_t v39 = v19[11];
      unint64_t v40 = *((_DWORD *)v19 + 19);
      id v41 = *((unsigned __int8 *)v19 + 74);
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v20;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v41;
      *(_WORD *)&_BYTE buf[14] = 1024;
      *(_DWORD *)&uint8_t buf[16] = v40;
      *(_WORD *)&buf[20] = 1024;
      *(_DWORD *)&buf[22] = v39;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "Set report queue already occupied - {isEntryValid %d, reportType %d, reportID %d, size %d}",  buf,  0x1Au);
    }

    goto LABEL_63;
  }

  *((_BYTE *)v18 + 74) = a3;
  *((_DWORD *)v18 + 19) = a4;
  id v31 = 1LL;
  *((_BYTE *)v18 + 72) = 1;
  v18[11] = a6;
  uint64_t v32 = malloc(a6);
  v19[10] = (uint64_t)v32;
  memcpy(v32, a5, a6);
  *((_BYTE *)v19 + 73) = 0;
  uint64_t v33 = (os_log_s *)qword_1008F7730;
  if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316674;
    *(void *)&uint8_t buf[4] = "set";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&_BYTE buf[14] = v50;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    *(_WORD *)&_BYTE buf[24] = 1024;
    *(_DWORD *)&buf[26] = a4;
    *(_WORD *)&buf[30] = 2048;
    *(void *)uint64_t v53 = a6;
    *(_WORD *)&v53[8] = 1040;
    *(_DWORD *)&v53[10] = a6;
    int v54 = 2098;
    uint64_t v55 = v32;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "Queued %s report {handle: 0x%x, type: %d, ID: %d, size: %zu, {%{public}.*P}",  buf,  0x38u);
  }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089D810);
          }
          sub_1005D6F0C((uint64_t)off_1008D5F28, v6, 0);
          int v38 = 0;
          unint64_t v39 = 3;
LABEL_77:
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089D810);
          }
          sub_1005D6C64((uint64_t)off_1008D5F28, v6, v38);
          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089D810);
          }
          sub_1005D6D74((uint64_t)off_1008D5F28, v6, v39);
          uint64_t v45 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_INFO))
          {
            sub_100494958(*(void *)(a1 + 128), (uint64_t)v149);
            int v46 = v152 >= 0 ? v149 : *(_BYTE **)v149;
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = v46;
            *(_WORD *)&_BYTE buf[12] = 1024;
            *(_DWORD *)&_BYTE buf[14] = v38;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v39;
            *(_WORD *)v145 = 2112;
            *(void *)&v145[2] = v6;
            _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_INFO,  "Session %s setting up connection scan level of %d (screenOff %d) for device %@",  buf,  0x22u);
            if (v152 < 0) {
              operator delete(*(void **)v149);
            }
          }

          if (*v106 < 1)
          {
            uint64_t v55 = 0LL;
LABEL_166:
            if (v105)
            {
              sub_10043F3F4(a1, 85LL, xdict, v105);
LABEL_173:

              goto LABEL_34;
            }

            v100 = sub_100404FE8();
            v107[0] = _NSConcreteStackBlock;
            v107[1] = 3221225472LL;
            v107[2] = sub_1004E75B4;
            v107[3] = &unk_100880D48;
            v110 = a1;
            v108 = v6;
            v109 = v22;
            sub_1004054B4(v100, v107);

            int v87 = v108;
LABEL_172:

            goto LABEL_173;
          }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089D810);
          }
          int v47 = sub_1005D7650((uint64_t)off_1008D5F28, v6);
          uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
          id v49 = v48 == 0LL;

          if (v49)
          {
            uint64_t v50 = sub_10025E150(v143, "kCBConnectOptionsTemporaryLTK");
            uint64_t v51 = v105;
            uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(v50);
            if (qword_1008D5F30 != -1) {
              dispatch_once(&qword_1008D5F30, &stru_10089D810);
            }
            uint64_t v53 = sub_1005CC198((uint64_t)off_1008D5F28, v6, 0);
            if ([v52 length])
            {
              int v54 = (os_log_s *)qword_1008F75F0;
              if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                *(void *)&uint8_t buf[4] = v6;
                _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEFAULT,  "preparing a temporary LTK for device %@",  buf,  0xCu);
              }

              if (v53)
              {
                [v22 setTemporaryLTK:v52];
              }

              else
              {
                if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                  sub_10068779C();
                }
                uint64_t v51 = 8;
              }
            }

            v105 = v51;
          }

          if (v134)
          {
            uint64_t v58 = (os_log_s *)qword_1008F75F0;
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
            {
              sub_100494958(*(void *)(a1 + 128), (uint64_t)buf);
              if (buf[23] >= 0) {
                uint64_t v59 = buf;
              }
              else {
                uint64_t v59 = *(_BYTE **)buf;
              }
              *(_DWORD *)v149 = 136315394;
              *(void *)&v149[4] = v59;
              v150 = 2112;
              v151 = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "Session %s is asking to hide %@ from BT Settings menu",  v149,  0x16u);
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              uint64_t v60 = v134;
            }

            else
            {
              uint64_t v60 = 1LL;
            }

            [v22 setHideFromBTSettings:v60 != 0];
          }

          int v61 = sub_10025E1C8(v143, "kCBConnectOptionClientBundleID");
          id v62 = (__CFString *)objc_claimAutoreleasedReturnValue(v61);
          int v63 = sub_10025E1C8(v143, "kCBConnectOptionClientProcessID");
          int v64 = (__CFString *)objc_claimAutoreleasedReturnValue(v63);
          uint64_t v65 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
          {
            uint32_t v66 = @"NoClientBundleID";
            uint64_t v67 = @"NoClientProcessID";
            if (v62) {
              uint32_t v66 = v62;
            }
            if (v64) {
              uint64_t v67 = v64;
            }
            *(_DWORD *)buf = 138413314;
            *(void *)&uint8_t buf[4] = v66;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&_BYTE buf[14] = v67;
            *(_WORD *)&buf[22] = 2048;
            *(void *)v145 = v129;
            *(_WORD *)&v145[8] = 2048;
            v146 = v128;
            v147 = 2048;
            v148 = v124;
            _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "clientBundleID %@ clientProcessID %@ connectionUseCase %lld maxAllowedConnectionDelay %lld isLatencyCritical %lld",  buf,  0x34u);
          }

          [v22 setClientBundleID:v62];
          [v22 setClientProcessID:v64];
          [v22 setConnectionUseCase:v129];
          [v22 setMaxAllowedConnectionDelay:v128];
          if (v124 == 1)
          {
            if (*(_BYTE *)(a1 + 84))
            {
              char v68 = sub_1002E6BF0();
              if ((*(unsigned int (**)(uint64_t))(*(void *)v68 + 384LL))(v68))
              {
                int v69 = (os_log_s *)qword_1008F75F0;
                if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
                {
                  BOOL v70 = @"NoClientBundleID";
                  if (v62) {
                    BOOL v70 = v62;
                  }
                  int v71 = @"NoClientProcessID";
                  if (v64) {
                    int v71 = v64;
                  }
                  *(_DWORD *)buf = 138412546;
                  *(void *)&uint8_t buf[4] = v70;
                  *(_WORD *)&_BYTE buf[12] = 2112;
                  *(void *)&_BYTE buf[14] = v71;
                  _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "clientBundleID %@ clientProcessID %@ fLatencyCriticalRequest received",  buf,  0x16u);
                }

                [v22 setIsLatencyCritical:1];
              }
            }
          }

          int v72 = sub_10025E9B4(v143, "kCBOptionUseCaseList");
          __int128 v73 = (void *)objc_claimAutoreleasedReturnValue(v72);
          int v74 = v73;
          if (v73)
          {
            if ([v73 count])
            {
              __int128 v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v74));
              int v76 = (void *)objc_claimAutoreleasedReturnValue([v75 allObjects]);

              __n128 v77 = objc_claimAutoreleasedReturnValue([v76 sortedArrayUsingSelector:"compare:"]);
              uint64_t v55 = (void *)v77;
            }

            else
            {
              uint64_t v55 = v74;
            }
          }

          else
          {
            uint64_t v55 = 0LL;
          }

          [v22 setUseCaseList:v55];
          if (v55 && [v55 count])
          {
            int v78 = sub_1004E646C(v55);
            uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue(v78);
            __int128 v80 = (os_log_s *)qword_1008F75F0;
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
            {
              int v81 = (id)objc_claimAutoreleasedReturnValue([v79 componentsJoinedByString:@","]);
              *(_DWORD *)buf = 138412290;
              *(void *)&uint8_t buf[4] = v81;
              _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "connUseCaseList: %@", buf, 0xCu);
            }

            if (![v22 connectionUseCase])
            {
              __n128 v82 = (void *)objc_claimAutoreleasedReturnValue([v55 firstObject]);
              uint64_t v83 = v82;
              if (v82)
              {
                objc_msgSend(v22, "setConnectionUseCase:", objc_msgSend(v82, "longLongValue"));
                __int128 v84 = (os_log_s *)qword_1008F75F0;
                if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
                {
                  int v85 = sub_1004E656C((int)[v83 longLongValue]);
                  *(_DWORD *)buf = 136315138;
                  *(void *)&uint8_t buf[4] = v85;
                  _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "default useCase derived from useCaseList: %s",  buf,  0xCu);
                }
              }
            }
          }

          if (*v106 < 1) {
            goto LABEL_166;
          }
          __int128 v86 = sub_10025E150(v143, "kCBConnectOptionConnectionOptionTemporaryIRKValue");
          int v87 = (void *)objc_claimAutoreleasedReturnValue(v86);
          if (![v87 length])
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEBUG)) {
              sub_1006876F8((uint64_t)v6);
            }
            goto LABEL_165;
          }

          if (qword_1008D5F30 != -1) {
            dispatch_once(&qword_1008D5F30, &stru_10089D810);
          }
          int v88 = sub_1005CC198((uint64_t)off_1008D5F28, v6, 0);
          v89 = sub_10025E150(v143, "kCBConnectOptionConnectionOptionTemporaryIdentityAddress");
          v90 = (void *)objc_claimAutoreleasedReturnValue(v89);
          v91 = [v90 copy];

          *(_DWORD *)&v149[3] = 0;
          *(_DWORD *)v149 = 0;
          if ([v91 length] == (id)6 || objc_msgSend(v91, "length") == (id)7)
          {
            v92 = (os_log_s *)qword_1008F75F0;
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412546;
              *(void *)&uint8_t buf[4] = v6;
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&_BYTE buf[14] = v91;
              _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEFAULT,  "preparing a temporary IRK for device %@ for address %@",  buf,  0x16u);
            }

            if ([v91 length] == (id)6)
            {
              v93 = 0LL;
              v149[0] = 1;
            }

            else
            {
              v93 = 1LL;
              [v91 getBytes:v149 length:1];
            }

            objc_msgSend(v91, "getBytes:range:", &v149[1], v93, 6);
            v94 = sub_1005BF848(v88);
            v95 = (void *)objc_claimAutoreleasedReturnValue(v94);
            [v22 setTemporaryIdentityAddress:v95];
          }

          else
          {
            if (!v88)
            {
              if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                sub_10068779C();
              }
              v105 = 8;
LABEL_164:

LABEL_165:
              goto LABEL_166;
            }

            v101 = sub_1005BF848(v88);
            v102 = (void *)objc_claimAutoreleasedReturnValue(v101);
            [v22 setTemporaryIdentityAddress:v102];

            v103 = (os_log_s *)qword_1008F75F0;
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412546;
              *(void *)&uint8_t buf[4] = v6;
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&_BYTE buf[14] = v91;
              _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_DEFAULT,  "preparing a temporary IRK from device UUID %@ for address %@",  buf,  0x16u);
            }

            v149[0] = 0;
            v104 = sub_1001BEE0C(v88);
            *(_DWORD *)&v149[1] = v104;
            *(_WORD *)&v149[5] = WORD2(v104);
          }

          v96 = (os_log_s *)qword_1008F75F0;
          if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            *(void *)&uint8_t buf[4] = v6;
            _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "setting up temporary IRK for device %@",  buf,  0xCu);
          }

          [v22 setTemporaryIRK:v87];
          v97 = (void *)objc_claimAutoreleasedReturnValue([v22 temporaryIRK]);
          v98 = [v97 length];

          if (v98 != (id)16)
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
              sub_100687770();
            }

            goto LABEL_172;
          }

          v99 = objc_claimAutoreleasedReturnValue([v22 temporaryIRK]);
          *(_OWORD *)buf = *(_OWORD *)[v99 bytes];

          if (qword_1008D5F20 != -1) {
            dispatch_once(&qword_1008D5F20, &stru_10089D7F0);
          }
          sub_10062D3AC(qword_1008D5F18, (int *)v149, buf, v6);
          goto LABEL_164;
        }
      }

      else
      {
        v106 = (int *)(a1 + 80);
      }

      [v22 setInitPHYs:1];
      [v22 setPHYOptions:0];
      [v22 setEnableScanCore:0];
      goto LABEL_37;
    }

    id v29 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
    {
      uint64_t v56 = *(void *)(a1 + 96);
      uint64_t v57 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 138412802;
      *(void *)&uint8_t buf[4] = v56;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&_BYTE buf[14] = v57;
      *(_WORD *)&buf[22] = 2112;
      *(void *)v145 = v6;
      _os_log_error_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "App %@ for user %@ is not allowed to access %@",  buf,  0x20u);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR))
  {
    sub_1006877FC();
  }

  float v14 = 17;
LABEL_33:
  sub_10043F3F4(a1, 85LL, xdict, v14);
LABEL_34:
}

  char v35 = (id *)sub_1002DCC34(*(void *)(a1 + 240), v73);
  uint64_t v36 = v35;
  if (!v35)
  {
    uint64_t v48 = objc_autoreleasePoolPush();
    if ((v71 & 0x100000000LL) == 0)
    {
      uuid_clear(uu);
      uint64_t v36 = 0LL;
      uint64_t v55 = 1;
      goto LABEL_108;
    }

    memset(out, 0, sizeof(out));
    uuid_clear(out);
    if (v74)
    {
      sub_100241F90(&__p, v74);
      uuid_copy(out, (const unsigned __int8 *)&__p);
      id v49 = sub_100241F94(out);
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(v49);
      uint64_t v51 = (unint64_t)[*(id *)(a1 + 160) objectForKey:v50];
      if (v51 | sub_1002DCB1C(*(void *)(a1 + 240), v50))
      {
        if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
        {
          sub_100366664(out, &__p);
          sub_10069ADD4();
        }

        uuid_clear(uu);
        uint64_t v36 = 0LL;
        uint64_t v55 = 1;
        goto LABEL_107;
      }
    }

    else
    {
      do
      {
        int v61 = objc_autoreleasePoolPush();
        *(_DWORD *)((char *)v77 + 3) = 0;
        v77[0] = 0;
        id v62 = sub_1001BCDB0(v73);
        v77[0] = v62;
        BYTE2(v77[1]) = BYTE6(v62);
        LOWORD(v77[1]) = WORD2(v62);
        if (uuid_is_null(out)) {
          int v63 = 7;
        }
        else {
          int v63 = 0;
        }
        sub_1000B1CE0(out, (uint64_t)v77, v63);
        int v64 = sub_100241F94(out);
        uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(v64);
        uint32_t v66 = (unint64_t)[*(id *)(a1 + 160) objectForKey:v65];
        uint64_t v67 = v66 | sub_1002DCB1C(*(void *)(a1 + 240), v65);
        char v68 = v67 != 0;
        if (v67)
        {
          int v69 = (os_log_s *)qword_1008F75A0;
          if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
          {
            sub_100366664(out, &__p);
            BOOL v70 = &__p;
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              BOOL v70 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)buf = 136446210;
            v93 = v70;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEBUG,  "UUID generation collision - UUID %{public}s already exists!",  buf,  0xCu);
          }
        }

        objc_autoreleasePoolPop(v61);
      }

      while (v68);
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v52 = sub_1005BFB9C(v73);
      uint64_t v53 = (id)objc_claimAutoreleasedReturnValue(v52);
      sub_100366664(out, &__p);
      sub_10069AD88();
    }

    uint64_t v36 = operator new(0x268uLL);
    int v54 = sub_100241F94(out);
    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(v54);
    sub_1002E545C((uint64_t)v36, v50, v73);
    uint64_t v55 = 0;
LABEL_107:

LABEL_108:
    objc_autoreleasePoolPop(v48);
    if (v55) {
      goto LABEL_15;
    }
LABEL_109:
    sub_1005D00CC(a1, (uint64_t)v36);
    sub_100241F90(uu, *v36);
    goto LABEL_15;
  }

  __int128 v37 = [*v35 copy];
  int v38 = (os_log_s *)qword_1008F75A0;
  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v39 = sub_1005BFB9C(v73);
    unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
    LODWORD(__p.__r_.__value_.__l.__data_) = 138543618;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2114;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v37;
    _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "Address %{public}@ is already associated with device %{public}@",  (uint8_t *)&__p,  0x16u);
  }

  if (!v74)
  {
    if ([*(id *)(a1 + 160) objectForKey:v37]
      && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
    {
      uint64_t v60 = sub_1005BFB9C(v73);
      objc_claimAutoreleasedReturnValue(v60);
      sub_10069AE20();
    }

    goto LABEL_109;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_ERROR))
  {
    id v41 = sub_1005BFB9C(v73);
    objc_claimAutoreleasedReturnValue(v41);
    sub_10069AE5C();
  }

  uuid_clear(uu);

LABEL_15:
  sub_100242FAC((uint64_t)v86);
}

void sub_100052670( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

uint64_t sub_1000526D0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000526E0(uint64_t a1)
{
}

void sub_1000526E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v3 + 40);
  NSAppendPrintF_safe(&obj, "        Matched: %@\n", a3);
  objc_storeStrong((id *)(v3 + 40), obj);
}

void sub_100052734(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v3 + 40);
  NSAppendPrintF_safe(&obj, "        Unmatched: %@\n", a3);
  objc_storeStrong((id *)(v3 + 40), obj);
}

void sub_100052780(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id obj = *(id *)(v3 + 40);
  NSAppendPrintF_safe(&obj, "        SpatialDeviceHistory: %@\n", a3);
  objc_storeStrong((id *)(v3 + 40), obj);
}

void sub_1000530D4(_Unwind_Exception *a1)
{
}

void sub_100053100(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    free(v1);
  }
}

void sub_100053440(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (dword_1008D6630 <= 30)
  {
    id v9 = v3;
    if (dword_1008D6630 != -1 || (int v8 = _LogCategory_Initialize(&dword_1008D6630, 30LL), v4 = v9, v8))
    {
      uint64_t v5 = *(unsigned int *)(a1 + 40);
      uint64_t v6 = CUPrintNSError(v4);
      int v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _remoteInvalidate]_block_invoke",  30LL,  "Remote invalidate sent: CID 0x%X, %@",  v5,  v7);

      uint64_t v4 = v9;
    }
  }

  if (!*(_BYTE *)(a1 + 44))
  {
    uint64_t v10 = v4;
    [*(id *)(a1 + 32) invalidate];
    uint64_t v4 = v10;
  }
}

LABEL_37:
LABEL_38:
LABEL_39:

    goto LABEL_40;
  }

  if (dword_1008D6630 <= 90 && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL))) {
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcReceivedMessage:remoteDevice:]",  90LL,  "### Remote cycle: %@",  self->_remoteDevice);
  }
  if (CUXPCDictionaryExpectsReply(v6))
  {
    size_t v18 = CBErrorF(4294960561LL, "Remote cycle");
    uint64_t v11 = (RPCompanionLinkClient *)objc_claimAutoreleasedReturnValue(v18);
    -[CBDaemonXPCConnection _xpcSendReplyError:request:](self, "_xpcSendReplyError:request:", v11, v6);
LABEL_40:
  }

  ((void (*)(void *))v5[2])(v5);

  _Block_object_dispose(&v59, 8);
}

          size_t v18 = CFNumberCreate(0LL, v13, p_valuePtr);
          break;
        case 4:
          BOOL v15 = (const char *)length[1];
          goto LABEL_31;
        case 5:
          if (LOBYTE(length[1])) {
            unint64_t v16 = kCFBooleanTrue;
          }
          else {
            unint64_t v16 = kCFBooleanFalse;
          }
          if (v16) {
            goto LABEL_39;
          }
          goto LABEL_40;
        default:
          goto LABEL_30;
      }
    }

  if (a4) {
    char *v19 = 0;
  }
  *a2 = v19 + 1;
  if (a3) {
    *a3 = (_WORD)v19 - (_WORD)v4;
  }
  return v4;
}

  id v31 = v61;
  uint64_t v32 = WORD2(v62);
  if (HIBYTE(v62))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
    uint64_t v33 = 0;
  }

  else
  {
    uint64_t v33 = WORD1(v62) - WORD2(v62);
  }

  __int16 v34 = 27 - a7;
  if (v33 < (int)(27 - a7))
  {
    uint64_t v59 = "ByteStream_NumReadBytesAvail(bs) >= ((27) - blobLen)";
    goto LABEL_110;
  }

  if (BYTE6(v62) != 2)
  {
    uint64_t v59 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_110:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 3321, v59);
  }

  bzero((void *)(v31 + v32), v34);
  char v35 = WORD2(v62) + v34;
  WORD2(v62) += v34;
  if (a9 && a7)
  {
    uint64_t v36 = 0LL;
    do
    {
      if (HIBYTE(v62))
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
LABEL_73:
        uint64_t v50 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_75:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 3324, v50);
      }

      __int128 v37 = WORD2(v62);
      if (BYTE6(v62) != 2)
      {
        uint64_t v50 = "(bs).__RWFlag == BYTESTREAM_WRITE";
        goto LABEL_75;
      }

      int v38 = *(_BYTE *)(a9 + v36);
      ++WORD2(v62);
      *(_BYTE *)(v61 + v37) = v38;
      ++v36;
    }

    while (v36 < a7);
    char v35 = WORD2(v62);
  }

  unint64_t v39 = v61;
  if (HIBYTE(v62))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
    unint64_t v40 = 0;
  }

  else
  {
    unint64_t v40 = WORD1(v62) - v35;
  }

  if (v40 < v34)
  {
    uint64_t v60 = "ByteStream_NumReadBytesAvail(bs) >= ((27) - blobLen)";
    goto LABEL_113;
  }

  if (BYTE6(v62) != 2)
  {
    uint64_t v60 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_113:
    sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 3326, v60);
  }

  bzero((void *)(v39 + v35), v34);
  unint64_t v44 = BYTE4(v62) + v34;
  WORD2(v62) += v34;
  if (a2)
  {
    uint64_t v45 = a2;
    do
    {
      if (HIBYTE(v62))
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c");
LABEL_65:
        uint64_t v48 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_67:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 3329, v48);
      }

      int v46 = WORD2(v62);
      if (BYTE6(v62) != 2)
      {
        uint64_t v48 = "(bs).__RWFlag == BYTESTREAM_WRITE";
        goto LABEL_67;
      }

      int v47 = *(_BYTE *)(a1 - 1 + v45--);
      ++WORD2(v62);
      *(_BYTE *)(v61 + v46) = v47;
    }

    while ((unint64_t)(v45 + 1) > 1);
    unint64_t v44 = BYTE4(v62);
  }

  return sub_10018BD78(233, v61, v44, a10, (uint64_t)sub_10013A594, v41, v42, v43);
}

                              uint64_t v33 = a10;
                              if (a10 >= 0x1Bu) {
                                sub_1001EE2A0();
                              }
                              if (a8)
                              {
                                if (!a10)
                                {
                                  if (a9) {
                                    return sub_10018BD78( 556,  v57,  BYTE4(v58),  a11,  (uint64_t)sub_10013C934,  v20,  v21,  v22);
                                  }
LABEL_62:
                                  __int128 v42 = v57;
                                  unint64_t v43 = WORD2(v58);
                                  if (HIBYTE(v58))
                                  {
                                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/St"
                                                           "ack/vsc/bcm/bcm_vsc.c");
                                    unint64_t v44 = 0;
                                  }

                                  else
                                  {
                                    unint64_t v44 = WORD1(v58) - WORD2(v58);
                                  }

                                  if (v44 < a10)
                                  {
                                    uint64_t v56 = "ByteStream_NumReadBytesAvail(bs) >= (blobLen)";
                                  }

                                  else
                                  {
                                    if (BYTE6(v58) == 2)
                                    {
                                      bzero((void *)(v42 + v43), a10);
                                      WORD2(v58) += a10;
                                      return sub_10018BD78( 556,  v57,  BYTE4(v58),  a11,  (uint64_t)sub_10013C934,  v20,  v21,  v22);
                                    }

                                    uint64_t v56 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                                  }

                                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6500,  v56);
                                }

                                __int16 v34 = a10;
                                do
                                {
                                  if (HIBYTE(v58))
                                  {
                                    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/St"
                                                           "ack/vsc/bcm/bcm_vsc.c");
LABEL_75:
                                    int v46 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_77:
                                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6496,  v46);
                                  }

                                  char v35 = WORD2(v58);
                                  if (BYTE6(v58) != 2)
                                  {
                                    int v46 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                                    goto LABEL_77;
                                  }

                                  uint64_t v36 = *(_BYTE *)(a8 - 1 + v34--);
                                  ++WORD2(v58);
                                  *(_BYTE *)(v57 + v35) = v36;
                                }

                                while ((unint64_t)(v34 + 1) > 1);
                                if (!a9) {
                                  goto LABEL_62;
                                }
LABEL_56:
                                if (a10)
                                {
                                  while (!HIBYTE(v58))
                                  {
                                    unint64_t v40 = WORD2(v58);
                                    if (BYTE6(v58) != 2)
                                    {
                                      int v47 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                                      goto LABEL_81;
                                    }

                                    id v41 = *(_BYTE *)(a9 - 1 + v33--);
                                    ++WORD2(v58);
                                    *(_BYTE *)(v57 + v40) = v41;
                                    if ((unint64_t)(v33 + 1) <= 1) {
                                      return sub_10018BD78( 556,  v57,  BYTE4(v58),  a11,  (uint64_t)sub_10013C934,  v20,  v21,  v22);
                                    }
                                  }

                                  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stac"
                                                         "k/vsc/bcm/bcm_vsc.c");
LABEL_79:
                                  int v47 = "ByteStream_NumReadBytesAvail(bs) >= 1";
LABEL_81:
                                  sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6504,  v47);
                                }

                                return sub_10018BD78(556, v57, BYTE4(v58), a11, (uint64_t)sub_10013C934, v20, v21, v22);
                              }

                              __int128 v37 = v57;
                              int v38 = WORD2(v58);
                              if (HIBYTE(v58))
                              {
                                sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/"
                                                       "vsc/bcm/bcm_vsc.c");
                                unint64_t v39 = 0;
                              }

                              else
                              {
                                unint64_t v39 = WORD1(v58) - WORD2(v58);
                              }

                              if (v39 < a10)
                              {
                                uint64_t v55 = "ByteStream_NumReadBytesAvail(bs) >= (blobLen)";
                              }

                              else
                              {
                                if (BYTE6(v58) == 2)
                                {
                                  bzero((void *)(v37 + v38), a10);
                                  WORD2(v58) += a10;
                                  if (!a9) {
                                    goto LABEL_62;
                                  }
                                  goto LABEL_56;
                                }

                                uint64_t v55 = "(bs).__RWFlag == BYTESTREAM_WRITE";
                              }

                              sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6492,  v55);
                            }

                            int v54 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_109:
                            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6475,  v54);
                          }

                          int v54 = "ByteStream_NumReadBytesAvail(bs) >= 2";
                          goto LABEL_109;
                        }

                        uint64_t v53 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_105:
                        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6474,  v53);
                      }

                      uint64_t v53 = "ByteStream_NumReadBytesAvail(bs) >= 2";
                      goto LABEL_105;
                    }

                    uint64_t v52 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_101:
                    sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6473,  v52);
                  }

                  uint64_t v52 = "ByteStream_NumReadBytesAvail(bs) >= (1)";
                  goto LABEL_101;
                }

                uint64_t v51 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_97:
                sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6472,  v51);
              }

              uint64_t v51 = "ByteStream_NumReadBytesAvail(bs) >= 1";
              goto LABEL_97;
            }

            uint64_t v50 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_93:
            sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c",  6471,  v50);
          }

          uint64_t v50 = "ByteStream_NumReadBytesAvail(bs) >= 2";
          goto LABEL_93;
        }

        id v49 = "(bs).__RWFlag == BYTESTREAM_WRITE";
LABEL_89:
        sub_1000E6B88("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/bcm/bcm_vsc.c", 6470, v49);
      }
    }

    id v49 = "ByteStream_NumReadBytesAvail(bs) >= 1";
    goto LABEL_89;
  }

  return result;
}

    LOBYTE(v182) = (16 * BYTE13(v184) - 80) | v32;
    if (*((_BYTE *)a1 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  401,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    if (*((_BYTE *)a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
LABEL_77:
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the address type of the LE extended advertising report event",  v77,  v78,  v79,  v80,  v81,  v82,  v83,  v181);
      __int128 v84 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    unint64_t v40 = *((unsigned __int16 *)a1 + 5);
    id v41 = *((unsigned __int16 *)a1 + 6);
    __int128 v42 = *a1;
    *((_WORD *)a1 + 6) = v41 + 1;
    BYTE1(v182) = *(_BYTE *)(v42 + v41);
    if ((int)(v40 - (v41 + 1)) <= 5) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  404,  "ByteStream_NumReadBytesAvail(*pBs) >= OI_BD_ADDR_BYTE_SIZE");
    }
    sub_1001F0050((uint64_t)&v182 + 2, v42 + v41 + 1, 6uLL);
    unint64_t v43 = *((_WORD *)a1 + 6);
    *((_WORD *)a1 + 6) = v43 + 6;
    if (*((_BYTE *)a1 + 15)) {
      break;
    }
    if (*((_BYTE *)a1 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  407,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    unint64_t v44 = *((unsigned __int16 *)a1 + 5);
    if (v44 <= (unsigned __int16)(v43 + 6))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the primary PHY  of the LE extended advertising report event",  v93,  v94,  v95,  v96,  v97,  v98,  v99,  v181);
      v100 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v100, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    uint64_t v45 = *a1;
    *((_WORD *)a1 + 6) = v43 + 7;
    BYTE5(ptr[1]) = *(_BYTE *)(v45 + (unsigned __int16)(v43 + 6));
    LOBYTE(v185) = BYTE5(ptr[1]) >> 7;
    BYTE1(v185) = (BYTE5(ptr[1]) & 0x40) != 0;
    BYTE2(v185) = (BYTE5(ptr[1]) & 0x20) != 0;
    if (v44 <= (unsigned __int16)(v43 + 7))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the secondary PHY of the LE extended advertising report event",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  v181);
      v108 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    *((_WORD *)a1 + 6) = v43 + 8;
    BYTE6(ptr[1]) = *(_BYTE *)(v45 + (unsigned __int16)(v43 + 7));
    if (v44 <= (unsigned __int16)(v43 + 8))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the advertising SID of the LE extended advertising report event",  v109,  v110,  v111,  v112,  v113,  v114,  v115,  v181);
      v116 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    *((_WORD *)a1 + 6) = v43 + 9;
    HIBYTE(ptr[1]) = *(_BYTE *)(v45 + (unsigned __int16)(v43 + 8));
    if (v44 <= (unsigned __int16)(v43 + 9))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the advertising SID of the LE extended advertising report event",  v117,  v118,  v119,  v120,  v121,  v122,  v123,  v181);
      v124 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v124, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    *((_WORD *)a1 + 6) = v43 + 10;
    LOBYTE(v184) = *(_BYTE *)(v45 + (unsigned __int16)(v43 + 9));
    if (v44 <= (unsigned __int16)(v43 + 10))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the advertising SID of the LE extended advertising report event",  v125,  v126,  v127,  v128,  v129,  v130,  v131,  v181);
      v132 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    *((_WORD *)a1 + 6) = v43 + 11;
    LOBYTE(ptr[1]) = *(_BYTE *)(v45 + (unsigned __int16)(v43 + 10));
    if ((int)(v44 - (unsigned __int16)(v43 + 11)) <= 1)
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the periodic advertising interval of the LE extended advertising report event",  v133,  v134,  v135,  v136,  v137,  v138,  v139,  v181);
      v140 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v140, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    WORD1(v184) = *(_WORD *)(v45 + (unsigned __int16)(v43 + 11));
    int v46 = v43 + 13;
    *((_WORD *)a1 + 6) = v43 + 13;
    if (v44 <= (unsigned __int16)(v43 + 13))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the direct address type of the LE extended advertising report event",  v141,  v142,  v143,  v144,  v145,  v146,  v147,  v181);
      v148 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v148, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    int v47 = v43 + 14;
    *((_WORD *)a1 + 6) = v47;
    BYTE4(v184) = *(_BYTE *)(v45 + v46);
    if ((int)(v44 - v47) <= 5) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  434,  "ByteStream_NumReadBytesAvail(*pBs) >= OI_BD_ADDR_BYTE_SIZE");
    }
    sub_1001F0050((uint64_t)&v184 + 5, v45 + v47, 6uLL);
    uint64_t v48 = *((_WORD *)a1 + 6);
    *((_WORD *)a1 + 6) = v48 + 6;
    if (*((_BYTE *)a1 + 15))
    {
      sub_1001EE134( (uint64_t)"Could not get the direct address of the LE extended advertising report event",  v149,  v150,  v151,  v152,  v153,  v154,  v155,  v181);
      v156 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    if (*((_BYTE *)a1 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  437,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    if (*((unsigned __int16 *)a1 + 5) <= (unsigned __int16)(v48 + 6))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_1001EE134( (uint64_t)"Could not get the dataLength of the LE extended advertising report event",  v157,  v158,  v159,  v160,  v161,  v162,  v163,  v181);
      v164 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v164, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    id v49 = *a1;
    *((_WORD *)a1 + 6) = v48 + 7;
    uint64_t v50 = (unsigned __int16)(v48 + 6);
    uint64_t v51 = *(unsigned __int8 *)(v49 + v50);
    WORD4(v182) = *(unsigned __int8 *)(v49 + v50);
    if (v51 >= 0xE6)
    {
      sub_1001EE134( (uint64_t)"Too many data bytes in the LE extended advertising report event.",  v165,  v166,  v167,  v168,  v169,  v170,  v171,  v181);
      v172 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v172, OS_LOG_TYPE_ERROR)) {
        return;
      }
      goto LABEL_116;
    }

    uint64_t v52 = sub_1000B17F4(v51);
    ptr[0] = v52;
    if (!v52) {
      goto LABEL_65;
    }
    uint64_t v53 = WORD4(v182);
    if (!WORD4(v182)) {
      goto LABEL_65;
    }
    if (*((_BYTE *)a1 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c",  449,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    int v54 = v52;
    uint64_t v55 = *a1;
    uint64_t v56 = *((unsigned __int16 *)a1 + 6);
    if (*((_BYTE *)a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      uint64_t v57 = 0;
    }

    else
    {
      uint64_t v57 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v56;
    }

    if (v57 < WORD4(v182))
    {
      *((_BYTE *)a1 + 15) = 1;
LABEL_114:
      sub_1001EE134( (uint64_t)"Could not get the dataLength of the LE extended advertising report event",  v173,  v174,  v175,  v176,  v177,  v178,  v179,  v181);
      v180 = (os_log_s *)sub_100086554(0x42u);
      if (!os_log_type_enabled(v180, OS_LOG_TYPE_ERROR)) {
        return;
      }
LABEL_116:
      sub_100657858();
      return;
    }

    uint64_t v58 = (char *)(v55 + v56);
    uint64_t v59 = &v54[v53];
    do
    {
      uint64_t v60 = *v58++;
      *v54++ = v60;
    }

    while (v54 < v59);
    *((_WORD *)a1 + 6) += WORD4(v182);
    if (*((_BYTE *)a1 + 15)) {
      goto LABEL_114;
    }
LABEL_65:
    if (BYTE1(v182) >= 2u) {
      BYTE1(v182) -= 2;
    }
    sub_1001C5618((unsigned __int16 *)&v182);
    sub_1000B1838(ptr[0]);
    if (++v16 == v15) {
      return;
    }
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Could not get the address of the LE advertising report event",  v85,  v86,  v87,  v88,  v89,  v90,  v91,  v181);
    v92 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR)) {
      goto LABEL_116;
    }
  }

      sub_1000B1838(v28);
      goto LABEL_38;
    }

        if ((sub_1001E631C(v46) & 1) == 0)
        {
          (*(void (**)(uint64_t))(qword_1008EDD28 + 48))(a1);
          return;
        }
      }
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Non-bondable mode, rejecting pin code request from %:, %!",  v21,  v22,  v23,  v12,  v13,  v14,  v15,  a1);
      id v24 = (os_log_s *)sub_100086554(0x37u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

      if (v22[39])
      {
        int v72 = (os_log_s *)qword_1008F75C8;
        uint64_t v11 = v84;
        if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
        {
          if (v23 < 0) {
            id v22 = *(unsigned __int8 **)v22;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = v22;
          _os_log_error_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_ERROR,  "Ignoring pipe event as endpoint %{public}s is pending deletion",  buf,  0xCu);
        }

        goto LABEL_117;
      }

      v90 = 0;
      v89 = 0;
      uint64_t v11 = v84;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008898A8);
      }
      sub_1005D70B4((uint64_t)off_1008D5F28, v84, &v90, &v89);
      if ((v89 & 0x100) != 0) {
        id v30 = 1;
      }
      else {
        id v30 = 3;
      }
      if ((v89 & 0x80) != 0) {
        id v31 = 2;
      }
      else {
        id v31 = v30;
      }
      int v85 = v31;
      uint64_t v32 = *((_DWORD *)v22 + 8);
      if ((v32 - 1) >= 2)
      {
        *(_DWORD *)uu = 0;
        uint64_t v36 = sub_10024F00C();
        if (sub_1002501A0(v36, a2, a3, *((unsigned int *)v19 + 15), (uint64_t)uu, a6, v22[37]))
        {
          __int128 v73 = (os_log_s *)qword_1008F75C8;
          if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
          {
            if ((a4[23] & 0x80u) == 0) {
              int v76 = a4;
            }
            else {
              int v76 = *(unsigned __int8 **)a4;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = v76;
            *(_WORD *)&_BYTE buf[12] = 2114;
            *(void *)&_BYTE buf[14] = v84;
            _os_log_error_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_ERROR,  "Failed to register pipe for endpoint %{public}s on device %{public}@",  buf,  0x16u);
          }

          goto LABEL_117;
        }

        __int128 v37 = (void *)*((void *)v22 + 5);
        int v38 = -[PipeMapping initWithIdentifier:handle:]( objc_alloc(&OBJC_CLASS___PipeMapping),  "initWithIdentifier:handle:",  v84,  a3);
        [v37 addObject:v38];

        unint64_t v39 = (os_log_s *)qword_1008F75C8;
        if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_DEFAULT))
        {
          if ((a4[23] & 0x80u) == 0) {
            unint64_t v40 = a4;
          }
          else {
            unint64_t v40 = *(unsigned __int8 **)a4;
          }
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = a3;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v40;
          *(_WORD *)&buf[18] = 2114;
          *(void *)&buf[20] = v84;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = a6;
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Successfully created pipe 0x%04X to endpoint %{public}s on device %{public}@ with priority %d",  buf,  0x22u);
        }

        BOOL v17 = a1;
        if (*v19) {
          (**(void (***)(void, unsigned __int8 *, void *, void, void, void, void, void, unint64_t))*v19)( *v19,  a4,  v84,  a5,  a6,  *(unsigned int *)uu,  v22[37],  v90,  __PAIR64__(v85, v89));
        }
      }

      else
      {
        if (v32 == 1) {
          uint64_t v33 = "skywalk";
        }
        else {
          uint64_t v33 = "networkrelay";
        }
        if (v32 == 2 && (_os_feature_enabled_impl("terminus", "BluetoothPacketParser") & 1) == 0)
        {
          __int128 v75 = (os_log_s *)qword_1008F75C8;
          if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_FAULT))
          {
            if ((a4[23] & 0x80u) == 0) {
              int v78 = a4;
            }
            else {
              int v78 = *(unsigned __int8 **)a4;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = v33;
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&_BYTE buf[14] = v78;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&_BYTE buf[24] = v84;
            _os_log_fault_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_FAULT,  "Failed to register %{public}s pipe for endpoint %{public}s on device %{public}@ due to missing feature",  buf,  0x20u);
          }

          goto LABEL_117;
        }

        memset(uu, 0, sizeof(uu));
        v98[0] = 0LL;
        v98[1] = 0LL;
        [v84 getUUIDBytes:v98];
        __n128 v82 = v33;
        if (*((_DWORD *)v22 + 8) == 2)
        {
          uuid_clear(uu);
          __int16 v34 = sub_10024F00C();
          char v35 = sub_1002505B4(v34, a2, a3, a6, &v97, v22[37], 1, (uint64_t)v98);
        }

        else
        {
          id v41 = sub_10024F00C();
          __int128 v42 = *((_DWORD *)v19 + 15);
          unint64_t v43 = v22[37];
          unint64_t v44 = a4[23];
          uint64_t v45 = (v44 & 0x80u) != 0LL;
          if ((v44 & 0x80u) != 0LL) {
            unint64_t v44 = *((void *)a4 + 1);
          }
          if (v45) {
            int v46 = *(unsigned __int8 **)a4;
          }
          else {
            int v46 = a4;
          }
          int v47 = (char *)&v46[v44];
          if (v44 >= 8)
          {
            uint64_t v48 = v46;
            do
            {
              id v49 = (char *)memchr(v48, 116, v44 - 7);
              if (!v49) {
                break;
              }
              if (*(void *)v49 == 0x73756E696D726574LL) {
                goto LABEL_73;
              }
              uint64_t v48 = (unsigned __int8 *)(v49 + 1);
              unint64_t v44 = v47 - (char *)v48;
            }

            while (v47 - (char *)v48 > 7);
          }

          id v49 = v47;
LABEL_73:
          uint64_t v50 = v49 == v47 || v49 - (char *)v46 == -1;
          uint64_t v51 = !v50;
          a3 = v81;
          uint64_t v11 = v84;
          char v35 = sub_100251530(v41, a2, v81, v42, (uint64_t)uu, a6, &v97, v43 != 0, v51);
          BOOL v17 = a1;
        }

        if (v35)
        {
          int v74 = (os_log_s *)qword_1008F75C8;
          if (os_log_type_enabled((os_log_t)qword_1008F75C8, OS_LOG_TYPE_ERROR))
          {
            if ((a4[23] & 0x80u) == 0) {
              __n128 v77 = a4;
            }
            else {
              __n128 v77 = *(unsigned __int8 **)a4;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = v82;
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&_BYTE buf[14] = v77;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&_BYTE buf[24] = v11;
            _os_log_error_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_ERROR,  "Failed to register %{public}s pipe for endpoint %{public}s on device %{public}@",  buf,  0x20u);
          }
      }

      id v24 = (void *)v5[1];
      if (v24)
      {
        do
        {
          id v25 = v24;
          id v24 = (void *)*v24;
        }

        while (v24);
      }

      else
      {
        do
        {
          id v25 = (void *)v5[2];
          int v26 = *v25 == (void)v5;
          uint64_t v5 = v25;
        }

        while (!v26);
      }

      uint64_t v5 = v25;
    }

    while (v25 != (void *)(a1 + 232));
  }

  uint64_t v27 = *(unint64_t **)buf;
  uint64_t v28 = v37;
  while (v27 != v28)
    sub_100277D34(a1, *v27++, 1);

  if (*(void *)buf)
  {
    __int128 v37 = *(unint64_t **)buf;
    operator delete(*(void **)buf);
  }

  CFDictionaryRemoveValue(v5, @"MagicAccRachet");
  if ((a2 & 0x200) == 0)
  {
LABEL_22:
    if ((a2 & 0x400) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

      CFDictionaryRemoveValue(Value, v23);
LABEL_38:
      if (a8)
      {
        if (CFDictionaryGetCount((CFDictionaryRef)*a7) < 1)
        {
          sub_1005BFC20(a1, &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v33 = &__p;
          }
          else {
            uint64_t v33 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
          }
          int v38 = sub_100296CF0((char *)v33, v14, a6);
        }

        else
        {
          id v31 = &__p;
          sub_1005BFC20(a1, &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            id v31 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
          }
          uint64_t v32 = objc_claimAutoreleasedReturnValue([v37 UUIDString]);
          int v38 = sub_1002961E4((const char *)v31, (const char *)[v32 UTF8String], *a7, v14, a6, 0, 1);
        }
      }

      if (v25) {
        goto LABEL_50;
      }
      goto LABEL_51;
    }

    uint64_t v28 = @"Local Encryption";
  }

  else
  {
    uint64_t v28 = @"Remote Encryption";
  }

  Value = (__CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)*a7, v28);
  id v30 = Value;
  if (!a4 || !a5)
  {
    if (!Value) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }

  if (Value)
  {
LABEL_32:
    CFDictionarySetValue(v30, v23, v25);
    goto LABEL_38;
  }

  id v30 = CFDictionaryCreateMutable( kCFAllocatorDefault,  4LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (v30)
  {
    CFDictionarySetValue((CFMutableDictionaryRef)*a7, v28, v30);
    CFRelease(v30);
    goto LABEL_32;
  }

  int v38 = 4;
  if (v25) {
LABEL_50:
  }
    CFRelease(v25);
LABEL_51:
  if (v23) {
    CFRelease(v23);
  }
  CFRelease(v14);
  __int16 v34 = v38;

  return v34;
}

      LODWORD(v1) = 52;
      goto LABEL_39;
    }

    goto LABEL_38;
  }

  if (v4 > 87)
  {
    switch(v4)
    {
      case 'g':
      case 'm':
        goto LABEL_37;
      case 'h':
      case 'n':
        goto LABEL_38;
      case 'i':
      case 'j':
      case 'k':
      case 'l':
        goto LABEL_47;
      default:
        if ((v4 - 161) < 4)
        {
          LODWORD(v1) = 42;
          goto LABEL_39;
        }

        if (v4 != 88) {
          goto LABEL_47;
        }
        goto LABEL_37;
    }
  }

  if (v4 <= 79)
  {
    if (v4 != 78) {
      goto LABEL_37;
    }
    goto LABEL_38;
  }

  switch(v4)
  {
    case 'P':
      goto LABEL_38;
    case 'Q':
      goto LABEL_37;
    case 'R':
LABEL_38:
      LODWORD(v1) = 44;
      goto LABEL_39;
  }

    BOOL v15 = 8LL;
    goto LABEL_41;
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_1008950E8);
  }
  sub_1004006DC((uint64_t)off_1008D5F48, (uint64_t)v13, a4);
  sub_10002418C(&__p, a3);
  uint64_t v27 = 0LL;
  *(_OWORD *)&v28.__r_.__value_.__l.__data_ = 0uLL;
  sub_1000B0400((uint64_t)&v27);
  v28.__r_.__value_.__r.__words[0] = (int)v27;
  v28.__r_.__value_.__l.__size_ = SWORD2(v27);
  sub_1003D0F60(v13, &__p, &v28);
  sub_100532E6C((char *)v33, a5);
  if (qword_1008D67B8 != -1) {
    dispatch_once(&qword_1008D67B8, &stru_100895108);
  }
  sub_100535F68((uint64_t)off_1008D67B0, (uint64_t)v13, (uint64_t)v33);
  float v14 = sub_1003B1A7C(v12, (uint64_t)v13);
  BOOL v15 = v14;
  if ((_DWORD)v14 == 601 || !(_DWORD)v14)
  {
    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_1008950E8);
    }
    unint64_t v16 = sub_1003FEFA8((uint64_t)off_1008D5F48, a1, (uint64_t)v13);
    *a6 = v16;
    if (v16)
    {
      BOOL v15 = 0LL;
      goto LABEL_41;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
    {
      sub_1003FE1B4((unsigned __int8 *)&v25, &__p);
      sub_100677C28();
    }

  if (v8)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75D8, OS_LOG_TYPE_ERROR)) {
      sub_10067CD14();
    }
    *(_DWORD *)(qword_1008F72C0 + 12_Block_object_dispose((const void *)(v15 - 96), 8) = 0;
    sub_100416100();
  }

  if (qword_1008D60D0 != -1) {
    dispatch_once(&qword_1008D60D0, &stru_1008983E0);
  }
  uint64_t v10 = sub_1004272C4((uint64_t)off_1008D60C8, (uint64_t)v3);
  uint64_t v11 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68158210;
    *(_DWORD *)&uint8_t buf[4] = 6;
    *(_WORD *)&uint8_t buf[8] = 2096;
    *(void *)&buf[10] = a2;
    size_t v18 = 1024;
    LODWORD(v19) = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Device %{bluetooth:BD_ADDR}.6P services are %x",  buf,  0x18u);
  }

  if ((v10 & 0x20080) != 0
    && sub_10010F494(a2, 1)
    && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067EF60();
  }

  if (sub_1003D2AF4((uint64_t)v3))
  {
    sub_1003D0454((uint64_t)v3, &v16);
    unint64_t v12 = v16 & 0x1F00;
    if ((v12 == 512 || v12 == 256)
      && sub_10010F6AC(a2, 1)
      && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
    {
      sub_10067EF00();
    }
  }

  if (sub_1003D0268((uint64_t)v3) == 26
    && sub_1003D17A4((uint64_t)v3)
    && sub_10010F7B4(a2, 2)
    && os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR))
  {
    sub_10067EEA0();
  }

  if (SHIBYTE(v26[0]) < 0) {
    operator delete(v25[1]);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(v23[1]);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[1]);
  }
  return nullsub_63((char *)&v20 + 1, v13);
}

            int v26 = (void *)objc_claimAutoreleasedReturnValue([v18 UUIDString]);
            [v33 setObject:v21 forKey:v26];

            goto LABEL_45;
          }
        }

        else if (buf[23])
        {
          goto LABEL_23;
        }

        uint64_t v28 = (os_log_s *)qword_1008F7588;
        if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "MUC - Not a cloud paired device %@",  buf,  0xCu);
        }

    sub_100241F90(buf, v5);
    *(void *)v140 = &v110;
    id v23 = sub_1005BCE78(a1 + 360, (unint64_t *)&v110, (uint64_t)&unk_1006C2518, (void **)v140);
    uuid_copy((unsigned __int8 *)v23 + 40, buf);
    id v24 = (void *)v13[1];
    if (v24)
    {
      do
      {
        id v25 = (void **)v24;
        id v24 = (void *)*v24;
      }

      while (v24);
    }

    else
    {
      do
      {
        id v25 = (void **)v13[2];
        int v26 = *v25 == v13;
        uint64_t v13 = v25;
      }

      while (!v26);
    }

    uint64_t v13 = v25;
    if (v25 == &v150) {
      goto LABEL_43;
    }
  }

  uint64_t v33 = *(uint64_t **)(a1 + 360);
  if (v33 != (uint64_t *)(a1 + 368))
  {
    do
    {
      sub_100241F90(buf, v5);
      __int16 v34 = uuid_compare((const unsigned __int8 *)v33 + 40, buf);
      if ((_DWORD)v34)
      {
        char v35 = (uint64_t *)v33[1];
        if (v35)
        {
          do
          {
            uint64_t v36 = v35;
            char v35 = (uint64_t *)*v35;
          }

          while (v35);
        }

        else
        {
          do
          {
            uint64_t v36 = (uint64_t *)v33[2];
            int v26 = *v36 == (void)v33;
            uint64_t v33 = v36;
          }

          while (!v26);
        }
      }

      else
      {
        __int128 v37 = sub_1005A10D0(v34, v33[4]);
        int v38 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v37;
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_INFO,  "removeAddressFromBTController returned %d",  buf,  8u);
        }

        uint64_t v36 = sub_1001FDBCC((uint64_t **)(a1 + 360), v33);
        operator delete(v33);
      }

      uint64_t v33 = v36;
    }

    while (v36 != (uint64_t *)(a1 + 368));
  }

  sub_10023BF24((uint64_t)&v149, v150);
  if (v20 > 103)
  {
    if (v20 != 104)
    {
      if (v20 != 160) {
        goto LABEL_96;
      }
      goto LABEL_7;
    }

    id v23 = 0;
    goto LABEL_41;
  }

  if (!*(_WORD *)(*(void *)(a1 + 8) + 124LL)) {
    goto LABEL_17;
  }
LABEL_61:
  unint64_t v40 = *(unsigned __int8 *)(a1 + 81);
  int v20 = 1LL;
  if (v40 <= 0x20)
  {
    if (((1LL << v40) & 0x100010002LL) != 0)
    {
      id v41 = (void *)(a1 + 32);
    }

    else
    {
      if (((1LL << v40) & 0x110) == 0) {
        goto LABEL_67;
      }
      id v41 = (void *)(a1 + 24);
    }

    ++*v41;
  }

    sub_100242FAC((uint64_t)v26);
  }

  return v3;
}

LABEL_41:
}

    __int128 v42 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer stackController](self->_daemon, "stackController"));
    unint64_t v43 = v74;
    uint64_t v53 = v74[5];
    unint64_t v44 = [v42 modifyDevice:v12 settings:v79[0] error:&v53];
    objc_storeStrong(v43 + 5, v53);

    if ((v44 & 1) == 0) {
      goto LABEL_48;
    }
    goto LABEL_45;
  }

  ((void (*)(void *))v38[2])(v38);

  _Block_object_dispose(&v59, 8);
}

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Received %d remote services from the remote central %p !",  v63,  v64,  v65,  v66,  v67,  v68,  v69,  v26);
      BOOL v70 = (os_log_s *)sub_100086554(0x51u);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v153 = sub_1001EDDCC();
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }

    *(_DWORD *)(*((void *)&xmmword_1008DD4E8 + v151) + 16LL) = v26;
    int v71 = sub_1000B1814(88LL * v26);
    *(void *)(*((void *)&xmmword_1008DD4E8 + v151) + 8LL) = v71;
    if (!v71 || (v147 = v26, (ptr = sub_1000B17F4(2LL * v26)) == 0LL))
    {
      sub_100091EC4((uint64_t)v5);
      return;
    }

    if ((_DWORD)v26)
    {
      id v23 = 0LL;
      v142 = 0;
      v148 = 0;
      id v24 = 1;
      v144 = v26;
      v145 = a3;
      v146 = (uint64_t)v5;
      v143 = a2;
      while (1)
      {
        int v72 = v24 + 5;
        __int128 v73 = a2[v24];
        int v74 = v24 + 1LL;
        if (a3 - v74 < v73)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Service size is larger than total data size !!",  v125,  v126,  v127,  v128,  v129,  v130,  v131,  v141);
            v132 = (os_log_s *)sub_100086554(0x51u);
            if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          id v24 = v74;
          goto LABEL_102;
        }

        __int128 v75 = &a2[v24];
        LODWORD(v76) = v75[4];
        else {
          __n128 v77 = v75[4];
        }
        if ((int)v77 + 4 > v73)
        {
          if (sub_1000A86F0())
          {
            sub_1001EE134( (uint64_t)"Size mismatch (%d > %d || %d)",  v133,  v134,  v135,  v136,  v137,  v138,  v139,  (v72 + v77));
            v140 = (os_log_s *)sub_100086554(0x51u);
            if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR)) {
              sub_100657858();
            }
          }

          id v24 = v72;
LABEL_102:
          id v25 = v142;
          goto LABEL_15;
        }

        int v78 = v72 + v77;
        if ((int)v77 + 5 <= v73)
        {
          uint64_t v79 = a2[v78];
          v150 = v78 + 1;
        }

        else
        {
          v150 = v72 + v77;
          uint64_t v79 = 0;
        }

        __int128 v80 = a2[v74] | (v75[2] << 8);
        int v81 = *(void *)(*((void *)&xmmword_1008DD4E8 + v151) + 8LL) + 88 * v23;
        *(_DWORD *)(v81 + 36) = v75[3];
        *(_DWORD *)(v81 + 40) = v80;
        __n128 v82 = &a2[v72];
        *(_DWORD *)(v81 + 32) = v77;
        *(void *)(v81 + 44) = 0x100000001LL;
        memmove((void *)v81, v82, v77);
        uint64_t v83 = (_BYTE *)(*(void *)(*((void *)&xmmword_1008DD4E8 + v151) + 8LL) + 88 * v23);
        v83[56] = v79 & 1;
        v83[57] = (v79 & 2) != 0;
        v83[55] = 0;
        if (word_1008DD568)
        {
          __int128 v84 = 0LL;
          else {
            int v76 = v76;
          }
          int v85 = &byte_1008DD585;
          while (1)
          {
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"Matching remote service %@ of len %d, type %d and ID %d with local service ID %d",  v86,  v87,  v88,  v89,  v90,  v91,  v92,  (uint64_t)v82);
              v93 = (os_log_s *)sub_100086554(0x51u);
              if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
              {
                v94 = sub_1001EDDCC();
                *(_DWORD *)buf = 136446210;
                v153 = v94;
                _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }

            v95 = memcmp("com.apple.BT.TS", v82, v76);
            if ((byte_1008DD4E0 || v95 != 0) && !*v85)
            {
              v97 = *(void *)(*((void *)&xmmword_1008DD4E8 + v151) + 8LL);
            }

            ++v84;
            v85 += 72;
            if (v84 >= (unsigned __int16)word_1008DD568)
            {
              a3 = v145;
              uint64_t v5 = (__int128 *)v146;
              LODWORD(v26) = v144;
              goto LABEL_74;
            }
          }

          *(_BYTE *)(v97 + 88 * v23 + 54) = *(v85 - 1);
          uint64_t v5 = (__int128 *)v146;
          if (*(v85 - 5) && !sub_10008D900(v146))
          {
            LODWORD(v26) = v144;
            a3 = v145;
            a2 = v143;
            if (sub_1000A86F0())
            {
              sub_1001EE134( (uint64_t)"Match found but requires encryption",  v107,  v108,  v109,  v110,  v111,  v112,  v113,  v141);
              v114 = (os_log_s *)sub_100086554(0x51u);
              if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
              {
                v115 = sub_1001EDDCC();
                *(_DWORD *)buf = 136446210;
                v153 = v115;
                _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }

            v142 = 1;
            *(_BYTE *)(*(void *)(*((void *)&xmmword_1008DD4E8 + v151) + 8LL) + 88 * v23 + 55) = 1;
          }

          else
          {
            LODWORD(v26) = v144;
            a3 = v145;
            a2 = v143;
            if (sub_1000A86F0())
            {
              sub_1001EE134((uint64_t)"Match found - returning service", v98, v99, v100, v101, v102, v103, v104, v141);
              v105 = (os_log_s *)sub_100086554(0x51u);
              if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
              {
                v106 = sub_1001EDDCC();
                *(_DWORD *)buf = 136446210;
                v153 = v106;
                _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }

            *((_WORD *)ptr + v148++) = v80;
          }
        }

        else
        {
          a3 = v145;
          uint64_t v5 = (__int128 *)v146;
          LODWORD(v26) = v144;
LABEL_74:
          a2 = v143;
        }

        ++v23;
        id v24 = v150;
        if (v150 >= a3 || v23 >= v147) {
          goto LABEL_102;
        }
      }

      v116 = v24;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Not enough data to get header", v117, v118, v119, v120, v121, v122, v123, v141);
        v124 = (os_log_s *)sub_100086554(0x51u);
        if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      id v25 = v142;
      id v24 = v116;
    }

    else
    {
      LODWORD(v23) = 0;
      v148 = 0;
      id v25 = 0;
      id v24 = 1;
    }

    goto LABEL_15;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Received remote services from a peer, but we're not supposed to have any services, so ignoring !",  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v141);
    int v54 = (os_log_s *)sub_100086554(0x51u);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v153 = sub_1001EDDCC();
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  int v61 = v5 - v109;
  if (*(unsigned __int8 *)(*((void *)&xmmword_1008DD4E8 + v108) + 48LL) < 8u)
  {
    id v62 = 2LL;
  }

  else
  {
    v29[2] = HIBYTE(v61);
    id v62 = 3LL;
  }

  int v63 = v107;
  int v64 = v111;
  v29[1] = v61;
  v29[v62] = v64;
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"Sending %d out of total %d registered services to %p, pduCounter %d",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  v64);
    int v72 = (os_log_s *)sub_100086554(0x51u);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v73 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      v113 = v73;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  if (v64)
  {
    int v74 = sub_10008DF98(a1, v29, v63, 1);
    if ((_DWORD)v74
      && sub_1000A86F0()
      && (sub_1001EE134((uint64_t)"Sending services PDU failed with %!", v75, v76, v77, v78, v79, v80, v81, v74),
          __n128 v82 = (os_log_s *)sub_100086554(0x51u),
          os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)))
    {
      sub_100657858();
      if ((_DWORD)v30) {
        goto LABEL_52;
      }
    }

    else if ((_DWORD)v30)
    {
LABEL_52:
      if (sub_1000A86F0())
      {
        sub_1001EE134( (uint64_t)"Sending left over services: singleByteLengthIndex is %d, lNbServices %d, adding services, status %!",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  v30);
        v91 = (os_log_s *)sub_100086554(0x51u);
        if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
        {
          v92 = sub_1001EDDCC();
          *(_DWORD *)buf = 136446210;
          v113 = v92;
          _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }

      if (v30 < (unsigned __int16)word_1008DD568)
      {
        v93 = (char *)&qword_1008DD570[9 * v30 + 1] + 4;
        *(void *)&v90 = 136446466LL;
        v111 = v90;
        do
        {
          if (!v93[9])
          {
            else {
              v94 = *(v93 - 4);
            }
            v95 = sub_10008FEE4( a1,  *((unsigned __int16 *)v93 + 3),  *(const void **)(v93 - 12),  v94,  *(_DWORD *)v93,  (unsigned __int16)v30);
            if ((_DWORD)v95)
            {
              v96 = v95;
              if (sub_1000A86F0())
              {
                sub_1001EE134( (uint64_t)"Sending services added PDU failed with %!",  v97,  v98,  v99,  v100,  v101,  v102,  v103,  v96);
                v104 = (os_log_s *)sub_100086554(0x51u);
                if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
                {
                  v105 = sub_1001EDDCC();
                  *(_DWORD *)buf = v111;
                  v113 = v105;
                  v114 = 1024;
                  v115 = 0xFFFF;
                  _os_log_error_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  buf,  0x12u);
                }
              }
            }
          }

          ++v30;
          v93 += 72;
        }

        while (v30 < (unsigned __int16)word_1008DD568);
      }
    }
  }

        uint64_t v51 = 0;
        LODWORD(a2) = v50;
        goto LABEL_42;
      }
    }

    id v49 = 0LL;
    *(_BYTE *)(a2 + 15) = 1;
    uint64_t v50 = 17;
    goto LABEL_41;
  }

  sub_1001EE2A0();
  if (!a4) {
    goto LABEL_23;
  }
LABEL_9:
  if (a4 == 3)
  {
    uint64_t v45 = sub_1000E4B00(a3, a1);
    if ((_DWORD)v45)
    {
      if (*(_BYTE *)(a2 + 14) != 1) {
        sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c",  4367,  "(*pBs).__RWFlag == BYTESTREAM_READ");
      }
      if (*(_BYTE *)(a2 + 15))
      {
        sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
      }

      else
      {
        int v64 = *(unsigned __int16 *)(a2 + 12);
        if (*(unsigned __int16 *)(a2 + 10) > v64)
        {
          uint64_t v65 = *(void *)a2;
          *(_WORD *)(a2 + 12) = v64 + 1;
          uint32_t v66 = *(_BYTE *)(v65 + v64);
          if (v66) {
            LOBYTE(a2) = v66;
          }
          else {
            LOBYTE(a2) = 24;
          }
          goto LABEL_53;
        }
      }

      *(_BYTE *)(a2 + 15) = 1;
      LOBYTE(a2) = 17;
    }

    else
    {
      LOBYTE(a2) = 1;
    }

        *((_BYTE *)a2 + 15) = 1;
        LOBYTE(v17) = 17;
        goto LABEL_42;
      }

      *((_BYTE *)a2 + 15) = 1;
    }

    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
    uint64_t v27 = 0;
    goto LABEL_41;
  }

  if (*((_BYTE *)a2 + 15))
  {
    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
    uint64_t v19 = 0;
    int v20 = 0;
    if (*(void *)(*(void *)(qword_1008DFDB0 + 24) + 112LL)) {
      LOBYTE(v17) = 24;
    }
    else {
      LOBYTE(v17) = 25;
    }
    goto LABEL_18;
  }

  id v24 = *((_WORD *)a2 + 5);
  id v25 = *((_WORD *)a2 + 6);
  uint64_t v19 = v24 - v25;
  int v26 = qword_1008DFDB0;
  if (!*(void *)(*(void *)(qword_1008DFDB0 + 24) + 112LL))
  {
    int v20 = 0;
    LOBYTE(v17) = 25;
    goto LABEL_18;
  }

  if ((v24 - v25) > 0x3Eu)
  {
    int v20 = 0;
    LOBYTE(v17) = -127;
    goto LABEL_18;
  }

  if (*((_WORD *)a2 + 5) == v25)
  {
    int v20 = 0;
    LOBYTE(v17) = 24;
    goto LABEL_18;
  }

  if ((_BYTE)v24 == (_BYTE)v25)
  {
    uint64_t v19 = 0;
    LOBYTE(v17) = 0;
    int v20 = 0;
LABEL_59:
    if (*(unsigned __int8 *)(v26 + 103) | v17)
    {
      sub_1000DCEB8(a1, a3, (__int16 *)v42, v19, v20, v17);
      if ((_BYTE)v17) {
        return v17;
      }
      int v26 = qword_1008DFDB0;
    }

    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)(v26 + 24) + 112LL))(a3, v42, v19);
    LOBYTE(v17) = 0;
    return v17;
  }

  char v35 = 0LL;
  int v20 = 0;
  LOBYTE(v17) = 0;
  while (1)
  {
    if (*((_BYTE *)a2 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c",  4496,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    if (*((_BYTE *)a2 + 15)) {
      break;
    }
    uint64_t v36 = *((unsigned __int16 *)a2 + 6);
    __int128 v37 = *a2;
    *((_WORD *)a2 + 6) = v36 + 1;
    int v38 = *(unsigned __int8 *)(v37 + v36) >> 2;
    unint64_t v39 = sub_1000E4C8C(v38, a1);
    *((_WORD *)v42 + v35) = sub_1000DB7D8(v39);
    if (!v39)
    {
      LOBYTE(v17) = 18;
LABEL_55:
      uint64_t v19 = ++v35;
      int v20 = v38;
      goto LABEL_56;
    }

    if (*(_BYTE *)(v39 + 134) != 4)
    {
      LOBYTE(v17) = 49;
      goto LABEL_55;
    }

    ++v35;
LABEL_56:
    if (v35 >= v19)
    {
      int v26 = qword_1008DFDB0;
      goto LABEL_59;
    }
  }

  sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/profiles/av/avdtp/avdtp.c");
LABEL_64:
  *((_BYTE *)a2 + 15) = 1;
  LOBYTE(v17) = 17;
  uint64_t v19 = v35;
LABEL_18:
  sub_1000DCEB8(a1, a3, (__int16 *)v42, v19, v20, v17);
  return v17;
}

  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v15 - 96), 8) = 0;
  return 1720LL;
}

    byte_1008E21B8 = 0;
    if ((_DWORD)a1 || (a2 & 1) == 0)
    {
      ((void (*)(uint64_t, void))off_1008E21C0)(a1, 0LL);
    }

    else
    {
      if (dword_1008E21E8) {
        int v26 = 1LL;
      }
      else {
        int v26 = 2LL;
      }
      ((void (*)(void, uint64_t))off_1008E21C0)(0LL, v26);
    }

    goto LABEL_48;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"readScanEnableCb - orphan callback", v13, v14, v15, v16, v17, v18, v19, v27);
    int v20 = (os_log_s *)sub_100086554(0x2Cu);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

    ++byte_1008E223B;
    if (!*((_WORD *)v13 + 9)) {
      sub_100115768();
    }
    if (*(_BYTE *)(a2 + 224))
    {
      sub_1001129EC(a2);
      if (*(_BYTE *)(a2 + 278))
      {
        float v14 = sub_100191D30();
      }

      else
      {
        uint64_t v36 = a2;
        float v14 = sub_100128D24(26LL);
      }

      a1 = v14;
      if (!(_DWORD)v14) {
        goto LABEL_77;
      }
    }

    else
    {
      a1 = 1360LL;
    }

    if (!a5) {
      goto LABEL_42;
    }
    goto LABEL_44;
  }

  unint64_t v12 = v11;
  if (sub_1000A86F0())
  {
    uint64_t v13 = (uint64_t *)sub_10017AB4C(a1);
    sub_1001EE134((uint64_t)"OI_Sar_SetMTU(%d, %d) failed %!", v14, v15, v16, v17, v18, v19, v20, *v13);
    unint64_t v21 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
LABEL_7:
    }
      sub_100657858();
  }

  return v12;
}

  uint64_t v32 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  uint64_t v33 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v32;
  __int16 v34 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  if (v33 > 0x3F)
  {
    if (v12 < v34)
    {
      uint64_t v36 = *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
      if (((*(_BYTE *)(sub_10017AB4C(a1) + 54) + (_BYTE)v36) & 0x3Fu) <= v12) {
        goto LABEL_61;
      }
    }
  }

  else
  {
    if (v34 > v12) {
      goto LABEL_61;
    }
    char v35 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  }

  __int128 v37 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  int v38 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v37;
  unint64_t v39 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
  if (v38 > 0x3F)
  {
    if (v12 <= v39)
    {
      unint64_t v40 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
    }
  }

  else if (v12 <= v39)
  {
    goto LABEL_61;
  }

  id v41 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v41
    || v41 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
  {
    __int128 v42 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    unint64_t v43 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    if (v42 <= v41)
    {
      if (v41 - v43 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL)) {
        goto LABEL_61;
      }
    }

    else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
              + (_BYTE)v43) & 0x3Fu) < v41)
    }
    {
      goto LABEL_61;
    }
  }

  if (v20 && *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL)
    || *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 16LL))
  {
LABEL_61:
    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL) == v12)
    {
      unint64_t v44 = (a2 >> 8) & 0x3F;
      if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) <= v44
        && v44 <= *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
      {
        goto LABEL_87;
      }

      uint64_t v45 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      int v46 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      if (v45 <= v44)
      {
        if (v44 - v46 <= *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL)) {
          goto LABEL_87;
        }
      }

      else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
                + (_BYTE)v46) & 0x3Fu) >= v44)
      }
      {
LABEL_87:
        if ((!v20 || !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL))
          && *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 16LL))
        {
          sub_100181EEC((uint64_t)a1, v44, v20);
          sub_100182D14(a1, a3);
          uint64_t v59 = (*(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL) + 1) & 0x3F;
          uint64_t v60 = sub_10017AB4C(a1);
          __n128 result = 0LL;
          *(_WORD *)(*(void *)(v60 + 112) + 8LL) = v59;
          return result;
        }
      }
    }

    else
    {
      unint64_t v44 = (a2 >> 8) & 0x3F;
    }

    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v44
      || v44 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
    {
      int v47 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      uint64_t v48 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
      if (v47 <= v44)
      {
        if (v44 - v48 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL))
        {
LABEL_85:
          uint64_t v57 = sub_10017AB4C(a1);
          sub_10017B47C(*(unsigned __int16 **)(v57 + 112));
          return 543LL;
        }
      }

      else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
                + (_BYTE)v48) & 0x3Fu) < v44)
      }
      {
        goto LABEL_85;
      }
    }

    id v49 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
    uint64_t v50 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v49;
    uint64_t v51 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
    if (v50 > 0x3F)
    {
      if (v12 < v51)
      {
        uint64_t v53 = *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
        if (((*(_BYTE *)(sub_10017AB4C(a1) + 54) + (_BYTE)v53) & 0x3Fu) <= v12) {
          goto LABEL_85;
        }
      }
    }

    else
    {
      if (v51 > v12) {
        goto LABEL_85;
      }
      uint64_t v52 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
    }

    if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL) == v12
      || v20 && *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL)
      || !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 16LL))
    {
      goto LABEL_85;
    }

    int v54 = sub_10017AB4C(a1);
    sub_10017B47C(*(unsigned __int16 **)(v54 + 112));
    uint64_t v55 = (uint64_t)a1;
    uint64_t v56 = v44;
    goto LABEL_96;
  }

  int v61 = sub_10017AB4C(a1);
  sub_10017B47C(*(unsigned __int16 **)(v61 + 112));
  if (v12 >= *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL))
  {
    int v63 = v12 - *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
  }

  else
  {
    id v62 = sub_10017AB4C(a1);
    else {
      int v63 = (((unsigned __int16)v12 | 0x40) - *(_WORD *)(*(void *)(v62 + 112) + 8LL)) & 0x3F;
    }
  }

  sub_100181EEC((uint64_t)a1, v41, v20);
  if (v63 > 2)
  {
    uint64_t v79 = sub_100182EE0((uint64_t)a1);
    if ((_DWORD)v79)
    {
      __int128 v80 = v79;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to send a REJ %!", v81, v82, v83, v84, v85, v86, v87, v80);
        int v88 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    v89 = sub_10017AB4C(a1);
    __n128 result = 0LL;
    __n128 v77 = *(void *)(v89 + 112);
    int v78 = 1;
  }

  else
  {
    *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 144LL) = 0;
    *(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 151LL) = 0;
    uint64_t v65 = *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
    *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 152LL) = v65;
    sub_100182D14(a1, a3);
    uint32_t v66 = sub_100182DBC(a1, v12);
    if ((_DWORD)v66)
    {
      uint64_t v67 = v66;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to send SREJ : %!", v68, v69, v70, v71, v72, v73, v74, v67);
        __int128 v75 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    int v76 = sub_10017AB4C(a1);
    __n128 result = 0LL;
    __n128 v77 = *(void *)(v76 + 112);
    int v78 = 2;
  }

  *(_BYTE *)(v77 + 3) = v78;
  return result;
}

        *(_BYTE *)(a1 + 15) = 1;
        goto LABEL_42;
      }

      *(_BYTE *)(a1 + 15) = 1;
    }

    sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_41;
  }

  if (v10 == 1)
  {
    if (*(_BYTE *)(a1 + 14) != 1) {
      sub_1000E6B88( "/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c",  1016,  "(*pBs).__RWFlag == BYTESTREAM_READ");
    }
    if (*(_BYTE *)(a1 + 15))
    {
      sub_1001ED1C4((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    }

    else
    {
      __int128 v37 = *(unsigned __int16 *)(a1 + 12);
      if (*(unsigned __int16 *)(a1 + 10) - (int)v37 >= 2)
      {
        v74[2] = *(_WORD *)(*(void *)a1 + v37);
        *(_WORD *)(a1 + 12) = v37 + 2;
LABEL_36:
        if (sub_1000A86F0())
        {
          sub_1001EE134((uint64_t)"  Rejected - MTU exceeded, max MTU = %d", v38, v39, v40, v41, v42, v43, v44, v74[2]);
          uint64_t v45 = (os_log_s *)sub_100086554(0x2Fu);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
            goto LABEL_44;
          }
        }

        goto LABEL_45;
      }
    }

    *(_BYTE *)(a1 + 15) = 1;
    goto LABEL_36;
  }

  if (v10)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"  Rejected - unknown reason code", v28, v29, v30, v31, v32, v33, v34, v72);
      char v35 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_44;
      }
    }
  }

  else if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"  Rejected - Command not understood", v19, v20, v21, v22, v23, v24, v25, v72);
    int v26 = (os_log_s *)sub_100086554(0x2Fu);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
LABEL_44:
    }
      sub_100657858();
  }

  ++*(void *)(a1 + 24);
  return v14;
}

  ++*(void *)(a1 + 24);
  return v14;
}

  ++*(void *)(a1 + 24);
  return v14;
}

  if ((_DWORD)v69)
  {
    v107[0] = *(_OWORD *)(a4 + 18);
    *(_OWORD *)((char *)v107 + 15) = *(_OWORD *)((char *)a4 + 87);
    v93 = *(void *)((char *)a4 + 103);
    v94 = *(int *)((char *)a4 + 111);
    v91 = *(_WORD *)((char *)a4 + 115);
    v92 = *((_BYTE *)a4 + 117);
    int v46 = *((_BYTE *)a4 + 118);
    v106 = *((_BYTE *)a4 + 127);
    v105 = *(void *)((char *)a4 + 119);
    int v47 = *((void *)a4 + 8);
    uint64_t v48 = fwrite("\n======Secondary Device======\n", 0x1EuLL, 1uLL, v26);
    __int128 v73 = v47;
    *(_OWORD *)int v74 = v107[0];
    *(_OWORD *)&v74[15] = *(_OWORD *)((char *)v107 + 15);
    __int128 v75 = v93;
    int v76 = v94;
    __n128 v77 = v91;
    int v78 = v92;
    uint64_t v79 = v46;
    int v81 = v106;
    __int128 v80 = v105;
    sub_1003593C0(v48, v26, (uint64_t)&v73);
  }

  fclose(v26);
  int v20 = 0LL;
LABEL_44:
  if ((v69 & 0x100000000LL) != 0) {
    return v20;
  }
  id v49 = (char *)a4 + v25;
  bzero(buf, 0x29AuLL);
  bzero(v98, 0x29AuLL);
  sub_1003595F0(v50, (char *)buf, (uint64_t)a4 + v25 + 4);
  uint64_t v51 = *((unsigned __int8 *)a4 + v25);
  buf[1] = *((_BYTE *)a4 + v25);
  if (v68) {
    v104 |= v68;
  }
  uint64_t v52 = *((unsigned __int16 *)v49 + 1);
  *(_WORD *)&buf[3] = *((_WORD *)v49 + 1);
  uint64_t v53 = (os_log_s *)qword_1008F7568;
  if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_DEFAULT))
  {
    int v54 = *(id *)(v9 + 8);
    uint64_t v55 = v49[1];
    *(_DWORD *)v95 = 138544130;
    *(void *)&v95[4] = v54;
    *(_WORD *)&v95[12] = 1024;
    *(_DWORD *)&v95[14] = v51;
    *(_WORD *)&v95[18] = 1024;
    *(_DWORD *)&v95[20] = v55;
    v96 = 1024;
    v97 = v52;
    _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEFAULT,  "recvW1AppDiagnosticsHandler: Received %{public}@ AWD: awdVersion=%d, data[1]=%d, awdLength=%d",  v95,  0x1Eu);
  }

  if (v52 == 386)
  {
    uint64_t v56 = v49[1];
    uint64_t v57 = v56 != 0;
  }

  else
  {
    if (v52 < 0x182 || (uint64_t v57 = v49[1]) == 0)
    {
      int v64 = (os_log_s *)qword_1008F7568;
      if (os_log_type_enabled((os_log_t)qword_1008F7568, OS_LOG_TYPE_ERROR))
      {
        uint64_t v65 = *(id *)(v9 + 8);
        uint32_t v66 = v49[1];
        *(_DWORD *)v95 = 138543874;
        *(void *)&v95[4] = v65;
        *(_WORD *)&v95[12] = 1024;
        *(_DWORD *)&v95[14] = v52;
        *(_WORD *)&v95[18] = 1024;
        *(_DWORD *)&v95[20] = v66;
        _os_log_error_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_ERROR,  "recvW1AppDiagnosticsHandler: %{public}@ sent invalid AWD header awdLength=%d data[1]=%d",  v95,  0x18u);
      }

      return 3LL;
    }

    uint64_t v56 = 1;
  }

  buf[0] = v57;
  uint8_t buf[2] = v56;
  v103 = *(_DWORD *)(v9 + 24);
  memset(v95, 0, sizeof(v95));
  sub_10040CB88((uint64_t)v95, 5, (uint64_t)v70);
  *(void *)&v95[16] = buf;
  uint64_t v58 = sub_1002E8D94();
  uint64_t v59 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v58 + 56LL))(v58, v95);
  uint64_t v60 = *(_WORD *)&buf[3];
  int v61 = v69 ^ 1;
  if ((v61 & 1) == 0)
  {
    sub_1003595F0(v59, (char *)v98, (uint64_t)(v49 + 390));
    if (v68) {
      v104 |= v68;
    }
    if (buf[0] == 1) {
      id v62 = 2;
    }
    else {
      id v62 = 1;
    }
    LOBYTE(v98[0]) = v62;
    BYTE1(v98[0]) = buf[1];
    BYTE2(v98[0]) = 2;
    *(_WORD *)((char *)v98 + 3) = v60;
    v101 = *(_DWORD *)(v9 + 24);
    v71[0] = 0LL;
    v71[1] = 0LL;
    int v72 = 0LL;
    sub_10040CB88((uint64_t)v71, 5, (uint64_t)v70);
    int v72 = v98;
    int v63 = sub_1002E8D94();
    (*(void (**)(uint64_t, void *))(*(void *)v63 + 56LL))(v63, v71);
  }

  return v20;
}

    int v20 = 1LL;
  }

  sub_10023E78C((uint64_t)&v22, v23[0]);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p);
  }
  return v20;
}

    int v20 = 1LL;
  }

  sub_10023E78C((uint64_t)&v22, v23[0]);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p);
  }
  return v20;
}

    int v20 = 1LL;
  }

  sub_10023E78C((uint64_t)&v22, v23[0]);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p);
  }
  return v20;
}

  ++*(void *)(a1 + 24);
  return v14;
}

  ++*(void *)(a1 + 24);
  return v14;
}

  if (*(int *)(a1 + 80) < 1)
  {
    v97 = 0LL;
    v96 = 0LL;
    uint64_t v59 = (os_log_s *)qword_1008F75F0;
    if (!*(_BYTE *)(a1 + 185))
    {
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v70 = (void *)(a1 + 56);
        if (*v42 < 0) {
          BOOL v70 = *v43;
        }
        *(_DWORD *)v113 = 136446210;
        *(void *)&v113[4] = v70;
        _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "Access level is less than kXPCAccessLevelSystem for session %{public}s. Restricted state operation not allowed",  v113,  0xCu);
      }

      *(_BYTE *)(a1 + 186) = 0;
      goto LABEL_47;
    }
  }

  else
  {
    uint64_t v59 = (os_log_s *)qword_1008F75F0;
  }

  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v113 = 134217984;
    *(void *)&v113[4] = v98;
    _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEFAULT,  "Setting fNeedsRestrictedState operation: %lld",  v113,  0xCu);
  }

  *(_BYTE *)(a1 + 186) = v98 != 0;
LABEL_47:
  uint64_t v60 = (uint64_t)[v75 containsObject:v6];
  int v61 = v60;
  if ((_DWORD)v60)
  {
    id v62 = (os_log_s *)qword_1008F75F0;
    uint64_t v60 = os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v60)
    {
      *(_DWORD *)v113 = 138412290;
      *(void *)&v113[4] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "Override restricted state operation for bundle: %@",  v113,  0xCu);
    }
  }

  if ((sub_1004DE290(v60, *(void **)(a1 + 96)) & 1) != 0 || *(int *)(a1 + 80) >= 1)
  {
    *(_BYTE *)(a1 + 8_Block_object_dispose((const void *)(v15 - 96), 8) = 1;
    int v63 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
    {
      int v64 = *(void *)(a1 + 96);
      *(_DWORD *)v113 = 138412290;
      *(void *)&v113[4] = v64;
      _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Warning: Overriding TCC for bundleIdentifier %@",  v113,  0xCu);
    }
  }

  else
  {
    *(_BYTE *)(a1 + 194) = sub_10025E2E0(v108, "kCBManagerPrivacySupported");
  }

  if (*(void *)(a1 + 128))
  {
    uint64_t v65 = (os_log_s *)qword_1008F75F0;
    if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
      sub_100686D44((char *)(a1 + 79), (void *)(a1 + 56), v65);
    }
  }

  else
  {
    uint32_t v66 = v109;
    if (v109 == 20161219)
    {
      memset(v113, 0, sizeof(v113));
      xpc_connection_get_audit_token(*(void *)(a1 + 16), v113);
      uint64_t v67 = sub_100404FE8();
      v76[0] = _NSConcreteStackBlock;
      v76[1] = 3221225472LL;
      v76[2] = sub_1004DE598;
      v76[3] = &unk_10089CFB8;
      int v88 = 0;
      int v81 = a1;
      __n128 v82 = v103;
      v89 = v61;
      uint64_t v83 = v97;
      __int128 v84 = v96;
      int v85 = *(_OWORD *)v113;
      __int128 v86 = *(_OWORD *)&v113[16];
      __n128 v77 = v6;
      int v87 = v73;
      int v78 = v72;
      uint64_t v79 = v106;
      __int128 v80 = v104;
      sub_1004054B4(v67, v76);
    }

    else
    {
      char v68 = (os_log_s *)qword_1008F75F0;
      if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
        sub_100686CC8(v66, v68, v69);
      }
    }
  }

  if (SHIBYTE(v92) < 0) {
    operator delete(*((void **)&v91 + 1));
  }
  std::streambuf::~streambuf(&v90[1]);
  std::ios::~ios(v94);

LABEL_65:
  if (!*(void *)(a1 + 128)) {
    sub_10043F468(a1, 2u);
  }

  _Block_object_dispose(v104, 8);
  _Block_object_dispose(v106, 8);
}

  ++*(void *)(a1 + 24);
  return v14;
}

  ++*(void *)(a1 + 24);
  return v14;
}

          uint64_t v19 = v10 + v15;
          uint64_t v10 = v10 + v15 - v14;
          if (v19 == (_WORD)v14) {
            goto LABEL_42;
          }
          break;
      }
    }
  }

  BOOL v17 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionHomeTimeDurationFromDisabledToStageOneValue");
  size_t v18 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v17 + 88LL))(v17, buf, __p, &v87);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v18) {
      goto LABEL_49;
    }
  }

  else if (!v18)
  {
    goto LABEL_49;
  }

  uint64_t v19 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v87;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "LeConnectionHomeTimeDurationFromDisabledToStageOneValue=%d (override)",  buf,  8u);
  }

      id v24 = (void **)&v21;
      sub_100024304(&v24);
      goto LABEL_42;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
      sub_10069B8DC();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
  {
    sub_10069B8B0();
  }

void sub_1000543DC(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1[4] == *(void *)(a1[5] + 152LL))
  {
    if (v3)
    {
      if (dword_1008D6630 > 90) {
        goto LABEL_2;
      }
      id v10 = v3;
      if (dword_1008D6630 == -1)
      {
        int v8 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v4 = v10;
        if (!v8) {
          goto LABEL_2;
        }
      }

      uint64_t v5 = a1[6];
      uint64_t v6 = CUPrintNSError(v4);
      int v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcReceivedMessage:remoteDevice:]_block_invoke",  90LL,  "### Remote client start failed: peer %@, %@",  v5,  v7);
    }

    else
    {
      if (dword_1008D6630 > 30) {
        goto LABEL_2;
      }
      id v10 = 0LL;
      if (dword_1008D6630 == -1)
      {
        int v9 = _LogCategory_Initialize(&dword_1008D6630, 30LL);
        uint64_t v4 = 0LL;
        if (!v9) {
          goto LABEL_2;
        }
      }

      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcReceivedMessage:remoteDevice:]_block_invoke",  30LL,  "Remote client started: peer %@",  a1[6]);
    }

    uint64_t v4 = v10;
  }

void sub_1000544F4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (dword_1008D6630 <= 20 && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 20LL)))
  {
    uint64_t v10 = CUPrintNSObjectOneLine(v7);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    uint64_t v12 = CUPrintNSError(v9);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcReceivedMessage:remoteDevice:]_block_invoke_2",  20LL,  "Remote request response: %@, %@",  v11,  v13);
  }

  id v22 = v7;
  if (!v22 || v9)
  {
    BOOL v17 = *(void **)(a1 + 32);
    if (v9)
    {
      [*(id *)(a1 + 32) _xpcSendReplyError:v9 request:*(void *)(a1 + 40)];
    }

    else
    {
      uint64_t v20 = CBErrorF(4294960596LL, "No response, no error");
      unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      [v17 _xpcSendReplyError:v21 request:*(void *)(a1 + 40)];
    }
  }

  else
  {
    float v14 = (void *)_CFXPCCreateXPCObjectFromCFObject(v22);
    if (v14)
    {
      uint64_t Reply = CUXPCDictionaryCreateReply(*(void *)(a1 + 40));
      unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(Reply);
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 3221225472LL;
      applier[2] = sub_1000546D4;
      applier[3] = &unk_100880930;
      applier[4] = v16;
      xpc_dictionary_apply(v14, applier);
      [*(id *)(a1 + 32) _xpcSendReply:v16];
    }

    else
    {
      size_t v18 = *(void **)(a1 + 32);
      uint64_t v19 = CBErrorF(4294960579LL, "CF to XPC failed");
      unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v19);
      [v18 _xpcSendReplyError:v16 request:*(void *)(a1 + 40)];
    }
  }
}

uint64_t sub_1000546D4(uint64_t a1, const char *a2, void *a3)
{
  return 1LL;
}

void sub_1000546F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (dword_1008D6630 <= 20)
  {
    id v10 = v3;
    if (dword_1008D6630 != -1 || (int v9 = _LogCategory_Initialize(&dword_1008D6630, 20LL), v4 = v10, v9))
    {
      uint64_t v5 = CUPrintNSObjectOneLine(*(void *)(a1 + 32));
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      uint64_t v7 = CUPrintNSError(v10);
      id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcReceivedMessage:remoteDevice:]_block_invoke_4",  20LL,  "Remote event sent: %@, %@",  v6,  v8);

      uint64_t v4 = v10;
    }
  }
}

LABEL_87:
}

  return (char)v11;
}

  if (qword_1008D60E0 != -1) {
    dispatch_once(&qword_1008D60E0, &stru_100888C10);
  }
  sub_100217F10((uint64_t)off_1008D60D8, (uint64_t)a2, 5LL);
  if (v39)
  {
    unint64_t v43 = (os_log_s *)qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_96;
    }
    *(_WORD *)int v54 = 0;
    unint64_t v44 = "Requested magic paired device prox keys again due to missing prox keys";
  }

  else
  {
    if ((v30 & v32) != 1) {
      goto LABEL_96;
    }
    unint64_t v43 = (os_log_s *)qword_1008F7560;
    if (!os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_96;
    }
    *(_WORD *)int v54 = 0;
    unint64_t v44 = "Requested magic paired device prox keys again";
  }

  _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v44, v54, 2u);
LABEL_96:
  if (v52)
  {
    uint64_t v45 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v54 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Disable HS fallback for guest not in contacts",  v54,  2u);
    }
  }

  if (v31)
  {
    int v46 = v52 ? 2LL : 1LL;
    sub_100215778((uint64_t)a1, (uint64_t)a2, 19LL, v46, 1u);
    if (sub_1003D2B2C((uint64_t)a2, 22))
    {
      if (qword_1008D9108 != -1) {
        dispatch_once(&qword_1008D9108, &stru_100888B70);
      }
      else {
        int v47 = 2LL;
      }
      sub_100215778((uint64_t)a1, (uint64_t)a2, 18LL, v47, 1u);
    }
  }

  if (v26)
  {
    uint64_t v48 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v54 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "Skipping AACP commands not for guest devices",  v54,  2u);
    }
  }

  else
  {
    sub_100242F54((uint64_t)v58);
    sub_10021D698((uint64_t)a1, (uint64_t)a2, v50, v31);
    sub_100242ECC((uint64_t)v58);
  }

  id v49 = sub_1003DF944((uint64_t)a2);
  if ((v49 & 1) == 0) {
    sub_10021E798(v49, (uint64_t)a2);
  }
  sub_100214A10((uint64_t)a1, (uint64_t)a2, 8LL);
  sub_10021C770((uint64_t)a1, (uint64_t)a2);
  if (qword_1008D67D8 != -1) {
    dispatch_once(&qword_1008D67D8, &stru_100888C90);
  }
  sub_1003530F4(qword_1008D67D0, (uint64_t)a2, v53[20]);
  sub_100242FAC((uint64_t)v58);
  if (SHIBYTE(v60) < 0) {
    operator delete(v59[0]);
  }
}

  *(_BYTE *)(a1 + 1446) = 0;
  *(_DWORD *)(a1 + 144_Block_object_dispose((const void *)(v15 - 96), 8) = 0;
  unint64_t v43 = 0;
  uint64_t v33 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRssiThresholdOrderType19");
  __int16 v34 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v33 + 88LL))(v33, buf, __p, &v43);
  if (v47 < 0) {
    operator delete(__p[0]);
  }
  if (v50 < 0)
  {
    operator delete(*(void **)buf);
    if (!v34) {
      goto LABEL_95;
    }
  }

  else if (!v34)
  {
    goto LABEL_95;
  }

  *(_BYTE *)(a1 + 1446) = 1;
  char v35 = v43;
  *(_DWORD *)(a1 + 144_Block_object_dispose((const void *)(v15 - 96), 8) = v43;
  uint64_t v36 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = 1;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v35;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "Force %d RSSI Threshold Order RSSI value = %d ",  buf,  0xEu);
  }

  v99 = 0;
  int v46 = sub_1002E6E00();
  sub_10002418C(buf, "ENScanOverrides");
  sub_10002418C(__p, "ENEnableAdaptiveAPWakeScheduling");
  int v47 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, unsigned __int8 *))(*(void *)v46 + 72LL))( v46,  buf,  __p,  &v99);
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v47) {
      goto LABEL_95;
    }
  }

  else if (!v47)
  {
    goto LABEL_95;
  }

  uint64_t v48 = v99;
  *(_BYTE *)(a1 + 249) = v99;
  id v49 = (os_log_s *)qword_1008F76C8;
  if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v48;
    _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Overriding fEnableAdaptiveAPWakeScheduling = %d ",  buf,  8u);
  }

  if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_ERROR))
  {
    sub_100531170((void *)a2, &v68);
    sub_10067FF98();
  }

void sub_1000552D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (dword_1008D6630 <= 20)
  {
    id v10 = v3;
    if (dword_1008D6630 != -1 || (int v9 = _LogCategory_Initialize(&dword_1008D6630, 20LL), v4 = v10, v9))
    {
      uint64_t v5 = CUPrintNSObjectOneLine(*(void *)(a1 + 32));
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      uint64_t v7 = CUPrintNSError(v10);
      id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendEvent:]_block_invoke",  20LL,  "Remote event sent: %@, %@",  v6,  v8);

      uint64_t v4 = v10;
    }
  }
}

id sub_100055D84(id result)
{
  uint64_t v1 = (void *)*((void *)result + 5);
  if (*((void *)result + 4) == v1[9]) {
    return objc_msgSend(v1, "_xpcPowerStateChanged:", objc_msgSend(*((id *)result + 5), "_powerStateForClient"));
  }
  return result;
}

void sub_100055DC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) == *(void *)(v1 + 72))
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 136) addressMonitor]);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 connectableAddressData]);

    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) advertisingAddressDataConnectable]);
    id v24 = v4;
    id v6 = v5;
    if (v24 == v6)
    {
    }

    else
    {
      if ((v24 == 0LL) == (v6 != 0LL))
      {

LABEL_9:
        [*(id *)(a1 + 32) setAdvertisingAddressDataConnectable:v24];
        int v8 = 1;
LABEL_10:
        int v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) addressMonitor]);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 nonConnectableAddressData]);

        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) advertisingAddressDataNonConnectable]);
        id v12 = v10;
        id v13 = v11;
        if (v12 == v13)
        {
        }

        else
        {
          float v14 = v13;
          if ((v12 == 0LL) == (v13 != 0LL))
          {

LABEL_17:
            [*(id *)(a1 + 32) setAdvertisingAddressDataNonConnectable:v12];
            int v16 = 1;
LABEL_18:
            BOOL v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) addressMonitor]);
            size_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 nonConnectableSecondaryAddressData]);

            uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) advertisingAddressDataNonConnectableSecondary]);
            id v20 = v18;
            id v21 = v19;
            if (v20 == v21)
            {
            }

            else
            {
              id v22 = v21;
              if ((v20 == 0LL) == (v21 != 0LL))
              {

LABEL_26:
                [*(id *)(a1 + 32) setAdvertisingAddressDataNonConnectableSecondary:v20];
LABEL_27:
                [*(id *)(a1 + 40) _xpcAdvertisingAddressChanged];
LABEL_28:

                return;
              }

              unsigned __int8 v23 = [v20 isEqual:v21];

              if ((v23 & 1) == 0) {
                goto LABEL_26;
              }
            }

            if ((v8 | v16) != 1) {
              goto LABEL_28;
            }
            goto LABEL_27;
          }

          unsigned __int8 v15 = [v12 isEqual:v13];

          if ((v15 & 1) == 0) {
            goto LABEL_17;
          }
        }

        int v16 = 0;
        goto LABEL_18;
      }

      unsigned __int8 v7 = [v24 isEqual:v6];

      if ((v7 & 1) == 0) {
        goto LABEL_9;
      }
    }

    int v8 = 0;
    goto LABEL_10;
  }

void sub_100056304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_100056340(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBAdvertiserUpdate:]_block_invoke",  90LL,  "### CBAdvertiser Update failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_1000568A4(_Unwind_Exception *a1)
{
}

id sub_1000568F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBConnectionActivate:]_block_invoke",  90LL,  "### CBConnection activate failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void *sub_1000569BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v2 == result[10]) {
    return objc_msgSend(result, "_xpcCBConnection:pairingCompletedWithDevice:error:");
  }
  return result;
}

void *sub_1000569DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v2 == result[10]) {
    return objc_msgSend(result, "_xpcCBConnection:pairingPromptWithPairingInfo:");
  }
  return result;
}

void *sub_1000569F8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[10]) {
    return [result _xpcSendEvent:a2];
  }
  return result;
}

void sub_100056A14(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v11 = v3;
  if (v3)
  {
    id v4 = v3;
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 != -1 || (int v8 = _LogCategory_Initialize(&dword_1008D6630, 90LL), v4 = v11, v8))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        uint64_t v6 = CUPrintNSError(v4);
        unsigned __int8 v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBConnectionActivate:]_block_invoke_5",  90LL,  "### Activate failed: %@, %@",  v5,  v7);

        id v4 = v11;
      }
    }

    [*(id *)(a1 + 40) _xpcSendReplyError:v4 request:*(void *)(a1 + 48)];
  }

  else
  {
    if (dword_1008D6630 <= 30
      && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBConnectionActivate:]_block_invoke_5",  30LL,  "Activated: %@",  *(void *)(a1 + 32));
    }

    uint64_t Reply = CUXPCDictionaryCreateReply(*(void *)(a1 + 48));
    id v10 = (void *)objc_claimAutoreleasedReturnValue(Reply);
    [*(id *)(a1 + 40) _xpcSendReply:v10];
  }
}

void sub_100056B50(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v11 = v3;
  if (v3)
  {
    id v4 = v3;
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 != -1 || (int v8 = _LogCategory_Initialize(&dword_1008D6630, 90LL), v4 = v11, v8))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        uint64_t v6 = CUPrintNSError(v4);
        unsigned __int8 v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBConnectionActivate:]_block_invoke_6",  90LL,  "### Activate failed: %@, %@",  v5,  v7);

        id v4 = v11;
      }
    }

    [*(id *)(a1 + 40) _xpcSendReplyError:v4 request:*(void *)(a1 + 48)];
  }

  else
  {
    if (dword_1008D6630 <= 30
      && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBConnectionActivate:]_block_invoke_6",  30LL,  "Activated: %@",  *(void *)(a1 + 32));
    }

    uint64_t Reply = CUXPCDictionaryCreateReply(*(void *)(a1 + 48));
    id v10 = (void *)objc_claimAutoreleasedReturnValue(Reply);
    [*(id *)(a1 + 40) _xpcSendReply:v10];
  }
}

void sub_100056F70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_100056FB4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBConnectionDisconnect:]_block_invoke",  90LL,  "### CBConnection disconnect failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_1000574C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

id sub_1000574FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBConnectionPairingContinue:]_block_invoke",  90LL,  "### CBConnection pairing continue failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

id sub_1000579B4(id result)
{
  uint64_t v1 = (void *)*((void *)result + 5);
  if (*((void *)result + 4) == v1[11]) {
    return objc_msgSend(v1, "_xpcPowerStateChanged:", objc_msgSend(*((id *)result + 5), "_powerStateForClient"));
  }
  return result;
}

void sub_1000579F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) == *(void *)(v1 + 88))
  {
    id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 136) stackController]);
    objc_msgSend((id)v1, "_xpcDiscoverableStateChanged:", objc_msgSend(v2, "discoverableState"));
  }

void sub_100057A5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) == *(void *)(v1 + 88))
  {
    id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 136) stackController]);
    objc_msgSend((id)v1, "_xpcInquiryStateChanged:", objc_msgSend(v2, "inquiryState"));
  }

void *sub_100057AC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v6 == result[11]) {
    return [result _xpcReceivedRelayMessageType:a4 messageData:a5 conduitDevice:a2 sourceDevice:a3];
  }
  return result;
}

void *sub_100057AE8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[11]) {
    return [result _xpcTipiChanged:a2];
  }
  return result;
}

void sub_100058748( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_1000587B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyControllerSettings:]_block_invoke",  90LL,  "### ModifyControllerSettings failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100058B3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

id sub_100058B78(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcGetDevices:]_block_invoke",  90LL,  "### GetDevices failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100058EE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_100058F24(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDeleteDevice:]_block_invoke",  90LL,  "### DeleteDevice failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

LABEL_30:
      char v35 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer stackController](self->_daemon, "stackController"));
      uint64_t v36 = v60;
      v55[0] = _NSConcreteStackBlock;
      v55[1] = 3221225472LL;
      v55[2] = sub_100059804;
      v55[3] = &unk_1008809D0;
      v55[4] = v12;
      uint64_t v56 = v67;
      uint64_t v57 = self;
      uint64_t v58 = v4;
      [v35 modifyDevice:v12 connectionPriorityDevices:v56 timeoutSeconds:v55 completionHandler:v36];

      goto LABEL_48;
    }

    uint64_t v32 = v65;
    if (v65)
    {
      if (dword_1008D6630 > 30) {
        goto LABEL_38;
      }
      if (dword_1008D6630 == -1)
      {
        uint64_t v32 = v65;
      }

      if (v20 > 3u) {
        uint64_t v33 = "?";
      }
      else {
        uint64_t v33 = off_100880B48[(char)v20];
      }
      __int128 v37 = CUPrintFlags32(v23, &unk_1006BB408);
      int v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyDevice:]",  30LL,  "ModifyDevice: %@, PeerSourceDevice %@, PeerSourceState %s RequestFlags %@",  v12,  v32,  v33,  v38);

LABEL_38:
      unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer stackController](self->_daemon, "stackController"));
      unint64_t v40 = v74;
      int v54 = v74[5];
      id v41 = [v39 modifyDevice:v12 peerSourceDevice:v65 peerSourceState:(char)v20 requestFlags:v23 error:&v54];
      objc_storeStrong(v40 + 5, v54);

      if ((v41 & 1) == 0) {
        goto LABEL_48;
      }
LABEL_45:
      uint64_t Reply = CUXPCDictionaryCreateReply(v4);
      id v49 = (void *)objc_claimAutoreleasedReturnValue(Reply);
      if (v49)
      {
        -[CBDaemonXPCConnection _xpcSendReply:](self, "_xpcSendReply:", v49);
      }

      else if (dword_1008D6630 <= 90 {
             && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
      }
      {
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyDevice:]",  90LL,  "### ModifyDevice create reply failed");
      }

      goto LABEL_48;
    }

    __int16 v34 = v79[0];
    if (!v79[0])
    {
      if (dword_1008D6630 <= 30
        && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
      {
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyDevice:]",  30LL,  "ModifyDevice: %@ (in-place)",  v12);
      }

      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(-[CBDaemonServer stackController](self->_daemon, "stackController"));
      int v46 = v74;
      uint64_t v52 = v74[5];
      int v47 = [v45 modifyDevice:v12 error:&v52];
      objc_storeStrong(v46 + 5, v52);

      if (!v47) {
        goto LABEL_48;
      }
      goto LABEL_45;
    }

    if (dword_1008D6630 <= 30)
    {
      if (dword_1008D6630 != -1)
      {
LABEL_28:
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyDevice:]",  30LL,  "ModifyDevice: %@, %@",  v12,  v34);
        goto LABEL_41;
      }

      if (_LogCategory_Initialize(&dword_1008D6630, 30LL))
      {
        __int16 v34 = v79[0];
        goto LABEL_28;
      }
    }

      if (v3 == v1)
      {
        uint64_t v2 = sub_10008C93C();
        uint64_t v3 = byte_1008DDC88;
      }

      goto LABEL_21;
    case 1:
      if ((unsigned __int16)word_1008DDC90 <= 9u || word_1008DDC90 == 10)
      {
        sub_1000FC0A8();
        sub_10008C9DC();
        ++word_1008DDC90;
        if (dword_1008DDC8C) {
          goto LABEL_19;
        }
      }

      else
      {
        sub_1000FC0A8();
        sub_10008C9DC();
        word_1008DDC90 = 0;
      }

    uint64_t v19 = *(void (**)(uint64_t))(qword_1008DDE00 + 32);
    if (v19) {
      v19(a1);
    }
  }

      if (!sub_1001086D8(v37, a1, v26, v25, 1LL))
      {
LABEL_36:
        sub_1000B080C((uint64_t)&qword_1008F29F0[134 * v35 + 19]);
        return;
      }

    dword_1008E2244 = 0;
    id v11 = (void *)qword_1008E2228;
    if (!qword_1008E2228) {
      id v11 = &unk_1006BCBE8;
    }
    if (*(void *)(a2 + 104)) {
      id v11 = *(void **)(a2 + 104);
    }
    if (byte_1008E223B)
    {
      id v12 = 0;
      while (1)
      {
        uint64_t v13 = (void *)*v11;
        if (!*v11) {
          break;
        }
        ++v12;
        id v11 = (void *)*v11;
      }

      uint64_t v13 = v11;
      a1 = a4;
      if ((_DWORD)a4) {
        goto LABEL_50;
      }
    }

    else
    {
      uint64_t v13 = v11;
    }

    if (!a1 || !a2 || !a3)
    {
      sub_1001EE2A0();
      return 101LL;
    }

    char v35 = sub_100174A3C(a5);
    if ((_DWORD)v35)
    {
      id v11 = v35;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Invalid Connect Params: %!", v36, v37, v38, v39, v40, v41, v42, v11);
        unint64_t v43 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }

      return v11;
    }

    *(void *)(sub_10017AB4C(v85) + 96) = a1;
    *(void *)(sub_10017AB4C(v85) + 8_Block_object_dispose(va, 8) = a2;
    uint64_t v59 = v85;
    *((void *)v85 + 4) = a3;
    *(_WORD *)(sub_10017AB4C(v59) + 4_Block_object_dispose(va, 8) = 0;
    *(_BYTE *)(sub_10017AB4C(v85) + 7_Block_object_dispose(va, 8) = 0;
    uint64_t v60 = *(_WORD *)a5;
    *(_WORD *)(sub_10017AB4C(v85) + 36) = v60;
    int v61 = sub_100186230(v85, 5, 0);
    if ((_DWORD)v61
      || (!*(_DWORD *)(a5 + 12) ? (id v62 = -1) : (id v62 = *(_DWORD *)(a5 + 12)),
          int v63 = v85,
          v85[19] = v62,
          int v61 = sub_100187CD4(*((unsigned __int16 *)v63 + 2), 15, 5u, 0LL, (uint64_t *)v63 + 12, v62),
          (_DWORD)v61))
    {
      id v11 = v61;
      sub_1001734D8((uint64_t)v85);
      return v11;
    }

    __int128 v80 = *(_WORD *)(a5 + 2);
    *(_WORD *)(sub_10017AB4C(v85) + 72) = v80;
    sub_10016ECFC(v85, *(unsigned __int16 *)(a5 + 8), *(_WORD *)(a5 + 6));
    int v81 = *(unsigned __int16 *)(sub_1001EDBA0(0x28u) + 8);
    else {
      __n128 v82 = (__int16 *)(sub_10017AB4C(v85) + 36);
    }
    uint64_t v83 = *v82;
    id v24 = 0;
    *(_WORD *)(sub_10017AB4C(v85) + 36) = v83;
    goto LABEL_40;
  }

  if (!v21)
  {
    id v24 = 8;
    goto LABEL_40;
  }

  if (v84 < 0x10u) {
    unsigned __int8 v23 = v22;
  }
  else {
    unsigned __int8 v23 = 0;
  }
  if ((v23 & 1) == 0)
  {
    if ((*(unsigned __int8 *)(v20 + 168) | 2) != 3)
    {
      id v24 = 5;
      goto LABEL_40;
    }

    goto LABEL_29;
  }

  id v24 = 7;
LABEL_40:
  unint64_t v44 = v85;
  if (!v85) {
    sub_1001EE2A0();
  }
  uint64_t v45 = *(__int128 **)sub_10017AB4C(v44);
  int v46 = *(_BYTE *)(sub_10017AB4C(v44) + 29);
  if (!v24 && *(_BYTE *)(sub_10017AB4C(v44) + 16) != 2) {
    sub_1001EE2A0();
  }
  int v47 = *((_WORD *)v44 + 2);
  uint64_t v48 = *(_WORD *)(sub_10017AB4C(v44) + 36);
  id v49 = *(_WORD *)(sub_10017AB4C(v44) + 72);
  uint64_t v50 = sub_10016ED64(v44);
  id v11 = sub_1001CA640(v45, v46, v47, v48, v49, v50, v24);
  *(_BYTE *)(sub_10017AB4C(v44) + 16) = 4;
  if ((_DWORD)v11
    && sub_1000A86F0()
    && (sub_1001EE134((uint64_t)"SignalMan_LeChannelConnectionRsp failed %!", v51, v52, v53, v54, v55, v56, v57, v11),
        uint64_t v58 = (os_log_s *)sub_100086554(0x2Fu),
        os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)))
  {
    sub_100657858();
    if (v24) {
      goto LABEL_49;
    }
  }

  else if (v24)
  {
LABEL_49:
    sub_100173C90((uint64_t)v44, (v24 + 580));
    return v11;
  }

  int v64 = (uint64_t *)sub_10017AB4C(v44);
  uint64_t v65 = sub_10018A690(*v64);
  if ((_DWORD)v11)
  {
    if (sub_1000A86F0())
    {
      uint32_t v66 = *(void *)sub_10017AB4C(v44);
      sub_10017AB4C(v44);
      sub_1001EE134((uint64_t)"OI_Sar_SetMTU(%d, %d) failed %!", v67, v68, v69, v70, v71, v72, v73, v66);
      int v74 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }
  }

  __int128 v75 = *(void (**)(uint64_t, uint64_t, void, uint64_t))(sub_10017AB4C(v44) + 96);
  int v76 = *((unsigned __int16 *)v44 + 2);
  __n128 v77 = *(unsigned __int16 *)(sub_10017AB4C(v44) + 36);
  int v78 = sub_10017AB4C(v44);
  v75(v76, v77, *(unsigned __int16 *)(v78 + 32), v65);
  return v11;
}

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"Invalid parameters", v19, v20, v21, v22, v23, v24, v25, v43);
    int v26 = (os_log_s *)sub_100086554(0x42u);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

  return 101LL;
}

    *(_BYTE *)(a1 + 77) |= 1u;
  }

  if ((*(_BYTE *)(a1 + 76) & 2) != 0 && (*(_BYTE *)(a1 + 77) & 2) == 0)
  {
    buf[0] = 8;
    buf[1] = *(_BYTE *)sub_100184B70();
    uint8_t buf[2] = *((_BYTE *)sub_100184B70() + 1);
    buf[3] = *((_BYTE *)sub_100184B70() + 2);
    uint8_t buf[4] = *((_BYTE *)sub_100184B70() + 3);
    buf[5] = *((_BYTE *)sub_100184B70() + 4);
    buf[6] = *((_BYTE *)sub_100184B70() + 5);
    buf[7] = *((_BYTE *)sub_100184B70() + 6);
    uint8_t buf[8] = *((_BYTE *)sub_100184B70() + 7);
    buf[9] = *((_BYTE *)sub_100184B70() + 8);
    buf[10] = *((_BYTE *)sub_100184B70() + 9);
    buf[11] = *((_BYTE *)sub_100184B70() + 10);
    _BYTE buf[12] = *((_BYTE *)sub_100184B70() + 11);
    buf[13] = *((_BYTE *)sub_100184B70() + 12);
    _BYTE buf[14] = *((_BYTE *)sub_100184B70() + 13);
    uint8_t buf[15] = *((_BYTE *)sub_100184B70() + 14);
    uint8_t buf[16] = *((_BYTE *)sub_100184B70() + 15);
    if (*(_BYTE *)(a1 + 9))
    {
      sub_100184F74(*(__int128 **)a1, buf, 0x11uLL, 1);
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This link is not encrypted, cannot send IRK.", v23, v24, v25, v26, v27, v28, v29, v66);
      id v30 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    if (!*(_DWORD *)(*(void *)a1 + 236LL) && ((*(_BYTE *)(a1 + 76) & 8) == 0 || (*(_BYTE *)(a1 + 74) & 8) == 0)) {
      sub_100090E10(*(void *)a1);
    }
    *(_DWORD *)((char *)v68 + 3) = 0;
    v68[0] = 0;
    sub_1001BDFB4((uint64_t)v68);
    sub_1001BDFE8((uint64_t)v68);
    buf[0] = 9;
    buf[1] = v68[0];
    v31.i32[0] = *(_DWORD *)((char *)v68 + 3);
    uint64_t v32 = (int16x8_t)vmovl_u8(v31);
    *(int16x4_t *)v32.i8 = vrev64_s16(*(int16x4_t *)v32.i8);
    *(_DWORD *)&uint8_t buf[2] = vmovn_s16(v32).u32[0];
    buf[6] = BYTE2(v68[0]);
    buf[7] = BYTE1(v68[0]);
    if (*(_BYTE *)(a1 + 9))
    {
      sub_100184F74(*(__int128 **)a1, buf, 8uLL, 1);
    }

    else if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"This link is not encrypted, cannot send address.", v33, v34, v35, v36, v37, v38, v39, v66);
      unint64_t v40 = (os_log_s *)sub_100086554(0x43u);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    *(_BYTE *)(a1 + 77) |= 2u;
  }

  if (*(_BYTE *)(*(void *)a1 + 70LL)) {
    id v41 = 67;
  }
  else {
    id v41 = 65;
  }
  sub_100185420(a1, v41);
}

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

        *a3 = 0;
        *a4 = 0;
        return 155LL;
      }
    }
  }

  return result;
}

        int v16 = "int";
      }
    }

    else
    {
      BOOL v17 = CFGetTypeID(v11);
      if (v17 != CFStringGetTypeID() || (size_t v18 = CFStringGetCStringPtr(v11, 0x8000100u)) == 0LL)
      {
        int v16 = "";
        uint64_t v15 = v7;
        goto LABEL_35;
      }

      int v16 = v18;
      if (!a5) {
        goto LABEL_21;
      }
      uint64_t v19 = *a5;
      if (*a5)
      {
        id v20 = 0LL;
        id v21 = a5 + 1;
        while (strcasecmp(v16, v19))
        {
          id v22 = *v21++;
          uint64_t v19 = v22;
          v20 += 0x100000000000000LL;
          if (!v22) {
            goto LABEL_17;
          }
        }

        uint64_t v15 = v20 >> 56;
      }

      else
      {
LABEL_17:
        uint64_t v15 = -1LL;
      }

      valuePtr = v15;
      if (v15 == v7)
      {
LABEL_21:
        *(void *)buf = 0LL;
        unsigned __int8 v23 = strtoq(v16, (char **)buf, 0);
        valuePtr = v23;
        if (**(_BYTE **)buf) {
          id v24 = 1;
        }
        else {
          id v24 = v23 <= v7;
        }
        if (v24 || v23 >= a4)
        {
          valuePtr = v7;
          uint64_t v15 = v7;
          goto LABEL_31;
        }

        uint64_t v15 = v23;
        if (a5) {
          goto LABEL_9;
        }
        goto LABEL_30;
      }
    }

      ++v61;
    }

    uint64_t v48 = 0;
    __n128 v77 = 0LL;
LABEL_34:
    BOOL v70 = 0LL;
LABEL_36:
    int v71 = 0LL;
LABEL_38:
    int v69 = 0LL;
LABEL_39:
    char v68 = 0LL;
LABEL_40:
    uint64_t v67 = 0LL;
LABEL_41:
    uint32_t v66 = 0LL;
LABEL_42:
    uint64_t v65 = 0LL;
LABEL_43:
    int v64 = 0LL;
LABEL_44:
    int v63 = 0LL;
LABEL_45:
    id v49 = 0LL;
    int v47 = 7;
    goto LABEL_26;
  }

  uint64_t v51 = (os_log_s *)qword_1008F7710;
  if (os_log_type_enabled((os_log_t)qword_1008F7710, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[BTVCLinkAgent _receivedAdvReport:withData:fromPeer:peerInfo:]";
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%s empty ADV set received", buf, 0xCu);
  }

  int v9 = 0LL;
LABEL_63:
}

      operator delete(__s1);
      if (v20)
      {
LABEL_31:
        id v21 = v2[5];
        if (*(_BYTE *)(v21 + 40) == 1)
        {
          id v22 = *(void *)(v21 + 8);
          unsigned __int8 v23 = *(void *)(v21 + 16);
          while (v22 != v23)
          {
            id v25 = *(void *)(*(void *)v22 + 120LL);
            id v24 = *(void *)(*(void *)v22 + 128LL);
            if (v25 != v24)
            {
              if (v5 || (int v6 = *(_WORD *)(*(void *)v22 + 2LL), v5 = 1, v25 + 26 != v24)) {
                ++v5;
              }
            }

            v22 += 8LL;
          }
        }
      }

    ++v21;
  }

    ++v21;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_ERROR)) {
    sub_100673C64();
  }
  *(_BYTE *)(a2 + 705) = 0;
  sub_10036C49C(a1, a2, 0);
}

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

  std::string::operator=(a1 + 10, &__str);
  if (v10 != a3) {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)&a3->__r_.__value_.__l.__data_;
  }
  a1[57].__r_.__value_.__s.__data_[1] = 1;
  sub_100242F54((uint64_t)v35);
  if (sub_1003CF350((unsigned __int8 *)a1))
  {
    int v16 = sub_1002E6D7C();
    BOOL v17 = (*(uint64_t (**)(uint64_t, std::string *, std::string *))(*(void *)v16 + 40LL))(v16, a1, &__str);
    size_t v18 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003FE1B4((unsigned __int8 *)&a1[5].__r_.__value_.__s.__data_[8], __p);
      if (v27 >= 0) {
        uint64_t v19 = __p;
      }
      else {
        uint64_t v19 = (void **)__p[0];
      }
      id v20 = &__str;
      if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        id v20 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 67109891;
      __int128 v37 = v17;
      int v38 = 2082;
      unint64_t v39 = v19;
      unint64_t v40 = 2160;
      id v41 = 1752392040LL;
      __int128 v42 = 2081;
      unint64_t v43 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "setName id result = %d, device address = %{public}s, value = %{private, mask.hash}s",  buf,  0x26u);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_1003D1398((uint64_t)a1);
  }

  id v21 = sub_1002E8FF0();
  sub_1003FE1B4((unsigned __int8 *)&a1[5].__r_.__value_.__s.__data_[8], v24);
  (*(void (**)(uint64_t, void **))(*(void *)v21 + 40LL))(v21, v24);
  if (v25 < 0) {
    operator delete(v24[0]);
  }
  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100895B68);
  }
  sub_1003FFDA4((os_unfair_lock_s *)off_1008D5F48, (uint64_t)a1, 1);
  cap = a1[21].__r_.__value_.__l.__cap_;
  if (cap) {
    (*(void (**)(std::string::size_type))(*(void *)cap + 16LL))(cap);
  }
LABEL_50:
  if (SHIBYTE(v31) < 0) {
    operator delete(v29);
  }
  if (SHIBYTE(v34) < 0) {
    operator delete(v32);
  }
  return sub_100242FAC((uint64_t)v35);
}

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0xFF0uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      sub_1003CED44(a2);
      unsigned __int8 v7 = 0LL;
      *a3 |= 0x10u;
      goto LABEL_63;
    }

    if (!os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO)) {
      goto LABEL_62;
    }
    sub_1003CF00C(a2, __p);
    if (v46 >= 0) {
      uint64_t v28 = __p;
    }
    else {
      uint64_t v28 = *(_BYTE **)__p;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v48 = v28;
    int v26 = "Both EIR and SDP are up-to-date for device %{public}s";
  }

  else
  {
    if (!os_log_type_enabled((os_log_t)qword_1008F7590, OS_LOG_TYPE_INFO)) {
      goto LABEL_62;
    }
    sub_1003CF00C(a2, __p);
    if (v46 >= 0) {
      id v25 = __p;
    }
    else {
      id v25 = *(_BYTE **)__p;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v48 = v25;
    int v26 = "We have SDP but not EIR for device %{public}s";
  }

  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, v26, buf, 0xCu);
  if (v46 < 0) {
LABEL_61:
  }
    operator delete(*(void **)__p);
LABEL_62:
  unsigned __int8 v7 = sub_10044F370(a1, a2);
LABEL_63:
  if (v42)
  {
    unint64_t v43 = v42;
    operator delete(v42);
  }

  return v7;
}

    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_10089A478);
    }
    id v24 = qword_1008D5F18;
    id v21 = v11;
    sub_10002418C(v38, (char *)[v21 UTF8String]);
    id v25 = sub_100625934(v24, (unsigned __int8 *)v38);
    int v26 = v25;
    if (v39 < 0)
    {
      operator delete(v38[0]);
      if ((v26 & 1) != 0)
      {
LABEL_53:

        goto LABEL_54;
      }
    }

    else if ((v25 & 1) != 0)
    {
      goto LABEL_53;
    }

    memset(uu, 0, sizeof(uu));
    uuid_clear(uu);
    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_10089A518);
    }
    sub_1005C8684((uint64_t)off_1008D5F28, v9, 0, 1u, 0LL, 0LL, src);
    uuid_copy(uu, src);
    if (uuid_is_null(uu))
    {
      uint64_t v27 = (os_log_s *)(id)qword_1008F7588;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = sub_1005BFB9C(v9);
        id v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
        *(_DWORD *)src = 138412290;
        id v41 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "No static random device found with address %@",  src,  0xCu);
      }
    }

    else
    {
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_10089A478);
      }
      id v30 = qword_1008D5F18;
      id v31 = sub_100241F94(uu);
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
      sub_100625C0C(v30, v27);
    }

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_10089A518);
    }
    sub_1005C8684((uint64_t)off_1008D5F28, v6, 0, 1u, 0LL, 0LL, src);
    uuid_copy(uu, src);
    if (uuid_is_null(uu))
    {
      uint64_t v32 = (os_log_s *)(id)qword_1008F7588;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = sub_1005BFB9C(v6);
        __int16 v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
        *(_DWORD *)src = 138412290;
        id v41 = v34;
        _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "No local device found with address %@",  src,  0xCu);
      }
    }

    else
    {
      if (qword_1008D5F20 != -1) {
        dispatch_once(&qword_1008D5F20, &stru_10089A478);
      }
      char v35 = qword_1008D5F18;
      uint64_t v36 = sub_100241F94(uu);
      uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
      sub_100625C0C(v35, v32);
    }

    goto LABEL_53;
  }

  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"PublicAddress"]);
  id v20 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"RandomAddress"]);
  id v21 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Invalid public address %@ and Invalid random address %@",  v19,  v20));

  id v22 = (os_log_s *)qword_1008F7588;
  if (os_log_type_enabled((os_log_t)qword_1008F7588, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    int v47 = v21;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Error unpairing Cloud Device: %@", buf, 0xCu);
  }

  id v21 = (os_log_s *)qword_1008F7578;
  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_100684DBC((uint64_t)v8, v21, v22);
  }
  return 0LL;
}

      uint64_t v19 = (os_log_s *)qword_1008F7570;
      if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEBUG))
      {
        *(void *)buf = &v29;
        id v25 = *(unsigned __int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 58);
        *(void *)buf = &v29;
        if (v25 >= *(unsigned __int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 60))
        {
          *(void *)buf = &v29;
          int v26 = (unsigned __int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 60);
        }

        else
        {
          *(void *)buf = &v29;
          int v26 = (unsigned __int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 58);
        }

        uint64_t v27 = *v26;
        *(void *)buf = &v29;
        uint64_t v28 = *(unsigned __int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 58);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v27;
        id v31 = 1024;
        uint64_t v32 = v28;
        uint64_t v33 = 1024;
        __int16 v34 = a3;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "A2DP Link Adaptive Bitrate: currentRate: %3d currentIndexedRate: %3d reTransmissionStats: %3d",  buf,  0x14u);
      }

      *(void *)buf = &v29;
      if (*(unsigned __int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 58) <= *(unsigned __int16 *)(*((void *)v10 + 2) + 2LL * v16))
      {
        *(void *)buf = &v29;
        if (*(unsigned __int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 58) < *(unsigned __int16 *)(*((void *)v10 + 2) + 2LL * v16))
        {
          *(void *)buf = &v29;
          id v20 = sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
          id v21 = *v10;
          if (*v10)
          {
            id v22 = 0LL;
            unsigned __int8 v23 = *((void *)v10 + 2);
            while (*(unsigned __int16 *)(v23 + 2 * v22) > *(unsigned __int8 *)(v20[5] + 58))
            {
              if (v21 == ++v22)
              {
                LODWORD(v22) = *v10;
                break;
              }
            }
          }

          goto LABEL_46;
        }
      }

      else
      {
        *(void *)buf = &v29;
        if (*(__int16 *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 62) < 0)
        {
          id v24 = (os_log_s *)qword_1008F7570;
          if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a3;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "A2DP Link Adaptive Bitrate: Ignoring first retransmission rate report (%d%%)",  buf,  8u);
          }
        }

        else
        {
          sub_1004ABC60(a1, v29, *(unsigned __int16 *)(*((void *)v10 + 2) + 2LL * v16));
        }
      }

      *(void *)buf = &v29;
      *(_WORD *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 62) = 0;
LABEL_46:
      *(void *)buf = &v29;
      *(_BYTE *)(sub_100029574(v7, &v29, (uint64_t)&unk_1006C2518, (uint64_t **)buf)[5] + 70) = 0;
      return;
    }

    if (os_log_type_enabled((os_log_t)qword_1008F7570, OS_LOG_TYPE_ERROR)) {
      sub_100685224();
    }
  }

      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        int v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    id v25 = 1LL;
  }
  else {
    id v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&int v54 = sub_100008BA0((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&uint64_t v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_10023FEC0(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_10023FFD4((uint64_t)&v54, v27);
  }

  id v29 = (char *)*a1;
  id v30 = v54;
  id v31 = v55;
  *(void *)&int v54 = *a1;
  *((void *)&v54 + 1) = v27;
  uint64_t v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  uint64_t v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&uint64_t v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

  objc_storeStrong((id *)(a1 + 64), a2);
  sub_1005C1B24(a1);
  __int128 v37 = 0LL;
  *(_BYTE *)(a1 + 23_Block_object_dispose(va, 8) = 1;
LABEL_40:

  return v37;
}

  sub_100242F54((uint64_t)v99);
  uint64_t v19 = a3[23];
  if ((char)a3[23] < 0)
  {
    unsigned __int8 v23 = *((void *)a3 + 1);
    if (v23 != 16)
    {
      if (v23 != 18) {
        goto LABEL_62;
      }
      id v24 = **(void **)a3 == 0x746C697542736148LL && *(void *)(*(void *)a3 + 8LL) == 0x6369767265536E69LL;
      if (!v24 || *(_WORD *)(*(void *)a3 + 16LL) != 29541) {
        goto LABEL_62;
      }
      goto LABEL_58;
    }

    id v20 = *(uint64_t **)a3;
  }

  else
  {
    id v20 = (uint64_t *)a3;
    if (v19 != 16)
    {
      if (v19 != 18)
      {
LABEL_60:
        if (v19 != 12)
        {
LABEL_69:
          if (v19 != 35)
          {
LABEL_86:
            if (v19 != 25)
            {
LABEL_102:
              if (v19 != 14)
              {
                unint64_t v44 = a3;
                if (v19 != 16) {
                  goto LABEL_129;
                }
                goto LABEL_117;
              }

              uint64_t v45 = 0;
              int v46 = (uint64_t *)a3;
              goto LABEL_109;
            }

            char v35 = (uint64_t *)a3;
            goto LABEL_91;
          }

          uint64_t v33 = a3;
          goto LABEL_84;
        }

        id v29 = a3;
        goto LABEL_64;
      }

      if (*(void *)a3 != 0x746C697542736148LL
        || *((void *)a3 + 1) != 0x6369767265536E69LL
        || *((_WORD *)a3 + 8) != 29541)
      {
        goto LABEL_153;
      }

      goto LABEL_58;
    }
  }

  uint64_t v27 = *v20;
  int v26 = v20[1];
  if (v27 == 0x747541746F4E6F44LL && v26 == 0x7463656E6E6F436FLL)
  {
LABEL_58:
    sub_1005CB544(a1, 1);
    uint64_t v19 = a3[23];
  }

  if ((v19 & 0x80) == 0) {
    goto LABEL_60;
  }
LABEL_62:
  if (*((void *)a3 + 1) != 12LL) {
    goto LABEL_82;
  }
  id v29 = *(unsigned __int8 **)a3;
LABEL_64:
  id v30 = *(void *)v29;
  id v31 = *((_DWORD *)v29 + 2);
  if (v30 == 0x57656C7070417349LL && v31 == 1751348321)
  {
    if (qword_1008D5F20 != -1) {
      dispatch_once(&qword_1008D5F20, &stru_1008A34D8);
    }
    sub_10062673C(qword_1008D5F18, v5);
    uint64_t v19 = a3[23];
    if ((v19 & 0x80) == 0) {
      goto LABEL_69;
    }
  }

  else if ((v19 & 0x80) == 0)
  {
    goto LABEL_69;
  }

      uuid_clear(a3);
      goto LABEL_31;
    }
  }

  uint64_t v13 = (void *)sub_1002DCB1C(*(void *)(a1 + 240), v5);
  uint64_t v14 = (os_log_s *)qword_1008F75A0;
  if (v13)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = sub_1005BFB9C(v7);
      int v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
      *(_DWORD *)buf = 138543618;
      uint64_t v28 = v16;
      id v29 = 2114;
      id v30 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Address %{public}@ is already associated with device %{public}@",  buf,  0x16u);
    }

    if ([*(id *)(a1 + 160) objectForKey:v5]
      && os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_FAULT))
    {
      BOOL v17 = sub_1005BFB9C(v7);
      objc_claimAutoreleasedReturnValue(v17);
      sub_10069AE20();
    }

    sub_100241F90(a3, *v13);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F75A0, OS_LOG_TYPE_DEBUG))
    {
      size_t v18 = sub_1005BFB9C(v7);
      objc_claimAutoreleasedReturnValue(v18);
      sub_10069B604();
    }

    uint64_t v19 = operator new(0x268uLL);
    sub_1002E545C((uint64_t)v19, v5, v7);
    sub_1005D00CC(a1, (uint64_t)v19);
    sub_100241F90(a3, *v19);
  }

        if ((v12 & 1) != 0)
        {
          if ((v12 & 2) != 0
            && (uint64_t v15 = sub_1002E6BF0(), (*(unsigned int (**)(uint64_t))(*(void *)v15 + 704LL))(v15) < 2))
          {
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
              sub_10069C8B8();
            }
          }

          else
          {
            *(_BYTE *)(a1 + 714) = 0;
            if (sub_1005F313C(a1, 1LL)
              && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
            {
              sub_10069C858();
            }
          }
        }

        else
        {
          sub_1005E3ED4(a1, 1LL);
        }

        goto LABEL_39;
      }
    }

    if ((v13 & 1) == 0) {
      goto LABEL_39;
    }
    goto LABEL_30;
  }

  id v10 = (os_log_s *)qword_1008F75B8;
  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "ADVBUFF cannot update ADV Buffer config when in Legacy mode",  (uint8_t *)v16,  2u);
  }

  return 12LL;
}

LABEL_52:
  ((void (*)(void *))v5[2])(v5);
  _Block_object_dispose(&v73, 8);
}

      id v29 = 0LL;
      id v30 = v20 <= 1 ? 1LL : v20;
      while (1)
      {
        id v31 = v27[v29];
        if (v31 == 58 || v31 == 61) {
          break;
        }
        if (v30 == ++v29) {
          goto LABEL_61;
        }
      }

      LOWORD(v30) = v29;
LABEL_61:
      uint64_t v32 = (_DWORD)v20 == (unsigned __int16)v30;
      LOWORD(v20) = v30;
      if (v32)
      {
        uint64_t v33 = 134LL;
      }

      else
      {
LABEL_64:
        __int16 v34 = sub_1000B17F4((unsigned __int16)v20 + 1);
        buf[1] = v34;
        if (v34)
        {
          char v35 = v34;
          LOWORD(buf[2]) = v20;
          memmove(v34, v27, (unsigned __int16)v20);
          v35[(unsigned __int16)v20] = 0;
          buf[3] = &v27[(unsigned __int16)(v20 + 1)];
          (*a1)(buf);
          sub_1000B1838(buf[1]);
          goto LABEL_70;
        }

        uint64_t v33 = 106LL;
      }

      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Parse response failed - %!, continuing", v36, v37, v38, v39, v40, v41, v42, v33);
        unint64_t v43 = (os_log_s *)sub_100086554(0);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          unint64_t v44 = sub_1001EDDCC();
          LODWORD(buf[0]) = 136446466;
          *(void **)((char *)buf + 4) = v44;
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = 0xFFFF;
          _os_log_error_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s (status=%{bluetooth:OI_STATUS}u)",  (uint8_t *)buf,  0x12u);
        }
      }
    }

  uint64_t v36 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  __int128 v37 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v36;
  int v38 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  if (v37 > 0x3F)
  {
    if (v10 < v38)
    {
      unint64_t v40 = *(_WORD *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
    }
  }

  else
  {
    unint64_t v39 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  }

  id v41 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 10LL);
  __int128 v42 = *(unsigned __int8 *)(sub_10017AB4C(a1) + 54) + v41;
  unint64_t v43 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
  if (v42 > 0x3F)
  {
    if (v10 <= v43)
    {
      id v49 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 8LL);
    }
  }

  else if (v10 <= v43)
  {
    goto LABEL_73;
  }

  uint64_t v50 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL) > v50
    || v50 > *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 4LL))
  {
    uint64_t v51 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    uint64_t v52 = *(unsigned __int16 *)(*(void *)(sub_10017AB4C(a1) + 112) + 6LL);
    if (v51 <= v50)
    {
      if (v50 - v52 > *(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL)) {
        goto LABEL_73;
      }
    }

    else if (((*(_DWORD *)(*(void *)(*(void *)(sub_10017AB4C(a1) + 112) + 176LL) + 32LL) {
              + (_BYTE)v52) & 0x3Fu) < v50)
    }
    {
      goto LABEL_73;
    }
  }

  if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 2LL))
    && !*(_BYTE *)(*(void *)(sub_10017AB4C(a1) + 112) + 151LL))
  {
    sub_100182D14(a1, a3);
    sub_100181EEC((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
    int v69 = sub_100182DBC(a1, (a2 >> 1) & 0x3F);
    if ((_DWORD)v69)
    {
      BOOL v70 = v69;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"Failed to send SREJ : %!", v71, v72, v73, v74, v75, v76, v77, v70);
        int v78 = (os_log_s *)sub_100086554(0x2Fu);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR)) {
          sub_100657858();
        }
      }
    }

    return 0LL;
  }

    sub_100657F74();
LABEL_37:
    sub_1001CBE38((__int128 *)v4, 8, (char *)v7);
    return v8;
  }

  if (*(_BYTE *)(v5 + 16) != 1 && *(_OWORD *)(v5 + 17) == 0LL)
  {
    int v6 = *a2;
    *(_OWORD *)(v5 + 17) = *a2;
  }

  BOOL v17 = sub_1001CCC34(v5, 0, (void *)(v5 + 88), *(uint8x8_t *)&v6);
  if ((_DWORD)v17)
  {
    int v8 = v17;
    sub_1001EE134( (uint64_t)"Could not generate confirmation value with status %!",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v8);
    id v25 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_37;
    }
    goto LABEL_52;
  }

  if (*(_BYTE *)(v4 + 70) && *(_DWORD *)(v7 + 84) != 1)
  {
    int v8 = 0LL;
    *(_DWORD *)(v7 + 84) = 2;
    return v8;
  }

  int v8 = sub_1001CCDD0(v4, (void *)(v7 + 88));
  if ((_DWORD)v8)
  {
    sub_1001EE134( (uint64_t)"Could not send pairing confirmation to handle 0x%x with status %!",  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v4);
    uint64_t v33 = (os_log_s *)sub_100086554(0x43u);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_37;
    }
    goto LABEL_52;
  }

  return v8;
}

  unsigned __int8 v7 = sub_1002E6BF0();
  memset(&buf, 0, sizeof(buf));
  *(_DWORD *)(a1 + 224) = 1;
  sub_10002418C(&v29, "Diversity");
  sub_10002418C(v27, "DiversityAntennaConfig");
  *(_BYTE *)(a1 + 222) = (*(uint64_t (**)(uint64_t, std::string *, void **, std::string *))(*(void *)a1 + 56LL))( a1,  &v29,  v27,  &buf);
  if (v28 < 0) {
    operator delete(v27[0]);
  }
  if (*(_BYTE *)(a1 + 222))
  {
    if (!std::string::compare(&buf, "DIVERSITY_ANT1"))
    {
      *(_DWORD *)(a1 + 224) = 1;
      int v8 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      LOWORD(v29.__r_.__value_.__l.__data_) = 0;
      int v9 = "Diversity antenna configuration override: Diversity Antenna 1";
    }

    else if (!std::string::compare(&buf, "DIVERSITY_ANT2"))
    {
      *(_DWORD *)(a1 + 224) = 2;
      int v8 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      LOWORD(v29.__r_.__value_.__l.__data_) = 0;
      int v9 = "Diversity antenna configuration override: Diversity Antenna 2";
    }

    else
    {
      *(_BYTE *)(a1 + 222) = 0;
      int v8 = (os_log_s *)qword_1008F7578;
      if (!os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      LOWORD(v29.__r_.__value_.__l.__data_) = 0;
      int v9 = "Warning: Diversity antenna configuration override: Invalid.  Using default diversity antenna.";
    }

    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v29, 2u);
  }

  v179[0] = @"NumberOfA2DPSessionPerDay";
  uint64_t v50 = (unsigned __int16 *)v138;
  v111 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 134)));
  v180[0] = v111;
  v179[1] = @"NumberOfAppleLEPencilPairedDeviceCount";
  v109 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 568)));
  v180[1] = v109;
  v179[2] = @"NumberOfAppleLEPencilSessionPerDay";
  v107 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  (_DWORD)v44 + (_DWORD)v43 + obj + v116));
  v180[2] = v107;
  v179[3] = @"NumberOfClassicLocalPairedDeviceCount";
  v106 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  v50[280] - v50[282]));
  v180[3] = v106;
  v179[4] = @"NumberOfHFPSessionPerDay";
  v105 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 136)));
  v180[4] = v105;
  v179[5] = @"NumberOfLECloudPairedDeviceCount";
  v104 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 566)));
  v180[5] = v104;
  v179[6] = @"NumberOfLELocalPairedDeviceCount";
  v103 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  v50[281] - v50[283]));
  v180[6] = v103;
  v179[7] = @"NumberOfLEPairedDeviceCount";
  v102 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 562)));
  v180[7] = v102;
  v179[8] = @"NumberOfMagicPairedDeviceCount";
  v101 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 564)));
  v180[8] = v101;
  v179[9] = @"NumberOfPairedDeviceCount";
  v100 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 560)));
  v180[9] = v100;
  v179[10] = @"NumberCTKDPairedDeviceCount";
  v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 570)));
  v180[10] = v99;
  v179[11] = @"MaxClassicDeviceCount";
  v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v118));
  v180[11] = v98;
  v179[12] = @"MaxAppleClassicDeviceCount";
  v97 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v4));
  v180[12] = v97;
  v179[13] = @"MaxLEDeviceCount";
  v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v134));
  v180[13] = v96;
  v179[14] = @"MaxLEThirdPartyDeviceCount";
  v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v121));
  v180[14] = v95;
  v179[15] = @"MaxCarKeyDeviceCount";
  v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v126));
  v180[15] = v127;
  v179[16] = @"MaxAppleLEDeviceCount";
  v131 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v130));
  v180[16] = v131;
  v179[17] = @"PowerState";
  v114 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v113 == 1));
  v180[17] = v114;
  v179[18] = @"TotalNumberOfDeviceCount";
  v135 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v134 + v118));
  v180[18] = v135;
  v179[19] = @"TotalAppleLESessionDurationInSec";
  v119 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v13));
  v180[19] = v119;
  v179[20] = @"TotalCarKeyDeviceDurationInSec";
  uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v14));
  v180[20] = v51;
  v179[21] = @"TotalLEDeviceDurationInSec";
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v16));
  v180[21] = v52;
  v179[22] = @"TotalLEThirdPartyAppSessionDurationInSec";
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v15));
  v180[22] = v53;
  v179[23] = @"ClassicReadDeviceNameFromFlashSuccessDailyCount";
  int v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v138 + 600)));
  v180[23] = v54;
  v179[24] = @"ClassicReadDeviceNameFromFlashFailureDailyCount";
  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v138 + 596)));
  v180[24] = v55;
  v179[25] = @"NumberOfApplePencilV1ConnectionsCount";
  uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v43));
  v180[25] = v56;
  v179[26] = @"NumberOfApplePencilV2ConnectionsCount";
  uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v44));
  v180[26] = v57;
  v179[27] = @"NumberOfApplePencilV3ConnectionsCount";
  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", obj));
  v180[27] = v58;
  v179[28] = @"NumberOfApplePencilV4ConnectionsCount";
  uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v116));
  v180[28] = v59;
  v122 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v180,  v179,  29LL));

  uint64_t v60 = v138;
  sub_1002EFD68(v138, 0x47u, v122);
  v120 = (unsigned int *)(v138 + 104);
  if (*(_WORD *)(v138 + 116))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100321F34;
    block[3] = &unk_10087EB20;
    block[4] = v138;
    if (qword_1008EFE18 != -1) {
      dispatch_once(&qword_1008EFE18, block);
    }
    v161[0] = @"AutoDateTimeEnabled";
    v162 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(v138 + 578)));
    v161[1] = @"AverageReferenceTimeDelta";
    v136 = (void *)v162;
    v163 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *v120));
    v161[2] = @"AverageReferenceTimeUncertainty";
    v132 = (void *)v163;
    v164 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(v138 + 108)));
    v161[3] = @"AverageReferenceTimeReliability";
    v128 = (void *)v164;
    v165 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(v138 + 112)));
    v161[4] = @"numberOfAuthAndIntegrityTagsProcessed";
    obja = (id)v165;
    v117 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 116)));
    v166 = v117;
    v161[5] = @"numberOfAuthAndIntegrityTagsResolved";
    v115 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 118)));
    v167 = v115;
    v161[6] = @"NumberOfAuthTagsResolvedAndIntegrityNotResolved";
    v112 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 120)));
    v168 = v112;
    v161[7] = @"NumberOfResolvedAuthTagsDecryptionFailed";
    v110 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 122)));
    v169 = v110;
    v161[8] = @"NumberOfResolvedAuthIntegrityTagsCurrentWindow";
    v108 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 124)));
    v170 = v108;
    v161[9] = @"NumberOfResolvedAuthIntegrityTagsPreviousWindow";
    int v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 126)));
    v171 = v61;
    v161[10] = @"NumberOfResolvedAuthIntegrityTagsNextWindow";
    id v62 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v138 + 128)));
    v172 = v62;
    v161[11] = @"percentageOfAuthAndIntegrityTagsResolved";
    int v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  (double)(*(unsigned __int16 *)(v138 + 118) / *(unsigned __int16 *)(v138 + 116))
                    * 100.0));
    v173 = v63;
    v161[12] = @"percentageOfAuthTagsResolvedAndIntegrityNotResolved";
    int v64 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  (double)(*(unsigned __int16 *)(v138 + 120) / *(unsigned __int16 *)(v138 + 116))
                    * 100.0));
    v174 = v64;
    v161[13] = @"percentageOfResolvedAuthTagsDecryptionFailed";
    uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  (double)(*(unsigned __int16 *)(v138 + 122) / *(unsigned __int16 *)(v138 + 116))
                    * 100.0));
    v175 = v65;
    v161[14] = @"percentageOfResolvedAuthIntegrityTagsCurrentWindow";
    uint32_t v66 = *(unsigned __int16 *)(v138 + 118);
    if (*(_WORD *)(v138 + 118)) {
      uint32_t v66 = *(unsigned __int16 *)(v138 + 124) / v66;
    }
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)(int)v66 * 100.0));
    v176 = v67;
    v161[15] = @"percentageOfResolvedAuthIntegrityTagsPreviousWindow";
    char v68 = *(unsigned __int16 *)(v138 + 118);
    if (*(_WORD *)(v138 + 118)) {
      char v68 = *(unsigned __int16 *)(v138 + 126) / v68;
    }
    int v69 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)(int)v68 * 100.0));
    v177 = v69;
    v161[16] = @"percentageOfResolvedAuthIntegrityTagsNextWindow";
    BOOL v70 = *(unsigned __int16 *)(v138 + 118);
    if (*(_WORD *)(v138 + 118)) {
      BOOL v70 = *(unsigned __int16 *)(v138 + 128) / v70;
    }
    int v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", (double)(int)v70 * 100.0));
    v178 = v71;
    int v72 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v162,  v161,  17LL));

    sub_1002EFD68(v138, 0x3Fu, v72);
    uint64_t v60 = v138;
  }

  v137 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v141 = 0u;
  v142 = 0u;
  v139 = 0u;
  v140 = 0u;
  __int128 v73 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v60 + 336) allKeys]);
  objb = v73;
  int v74 = [v73 countByEnumeratingWithState:&v139 objects:v160 count:16];
  if (v74)
  {
    __int128 v75 = 0;
    LODWORD(v76) = 0;
    v129 = *(void *)v140;
    do
    {
      __n128 v77 = 0LL;
      v133 = v74;
      do
      {
        if (*(void *)v140 != v129) {
          objc_enumerationMutation(objb);
        }
        int v78 = *(void *)(*((void *)&v139 + 1) + 8LL * (void)v77);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v137,  "setObject:forKeyedSubscript:",  v78,  @"ServiceType");
        uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v138 + 336) objectForKeyedSubscript:v78]);
        __int128 v80 = (void *)objc_claimAutoreleasedReturnValue([v79 objectAtIndexedSubscript:0]);
        int v81 = [v80 unsignedIntValue];
        __n128 v82 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v138 + 336) objectForKeyedSubscript:v78]);
        uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue([v82 objectAtIndexedSubscript:1]);
        __int128 v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  100 * v81 / [v83 unsignedIntValue]));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v137,  "setObject:forKeyedSubscript:",  v84,  @"ConnectionSuccessPercentagePerDay");

        int v85 = objc_claimAutoreleasedReturnValue([*(id *)(v138 + 336) objectForKeyedSubscript:v78]);
        __int128 v86 = (void *)objc_claimAutoreleasedReturnValue([(id)v85 objectAtIndexedSubscript:1]);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v137,  "setObject:forKeyedSubscript:",  v86,  @"TotalConnectionPerDay");

        int v87 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v138 + 336) objectForKeyedSubscript:v78]);
        int v88 = (void *)objc_claimAutoreleasedReturnValue([v87 objectAtIndexedSubscript:0]);
        LODWORD(v85) = [v88 unsignedIntValue];

        v89 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v138 + 336) objectForKeyedSubscript:v78]);
        v90 = (void *)objc_claimAutoreleasedReturnValue([v89 objectAtIndexedSubscript:1]);
        LODWORD(v8_Block_object_dispose(va, 8) = [v90 unsignedIntValue];

        sub_1002EFD68(v138, 0x73u, v137);
        v75 += v85;
        int v76 = ((_DWORD)v88 + v76);
        __n128 v77 = (char *)v77 + 1;
      }

      while (v133 != v77);
      int v74 = [objb countByEnumeratingWithState:&v139 objects:v160 count:16];
    }

    while (v74);

    v91 = v138;
    if ((_DWORD)v76)
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v137,  "setObject:forKeyedSubscript:",  @"Overall",  @"ServiceType");
      v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  100 * v75 / v76));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v137,  "setObject:forKeyedSubscript:",  v92,  @"ConnectionSuccessPercentagePerDay");

      v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v76));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v137,  "setObject:forKeyedSubscript:",  v93,  @"TotalConnectionPerDay");

      v91 = v138;
      sub_1002EFD68(v138, 0x73u, v137);
    }
  }

  else
  {

    v91 = v138;
  }

  *(void *)v120 = 0LL;
  *(void *)(v138 + 112) = 0LL;
  *(_DWORD *)(v138 + 12_Block_object_dispose(va, 8) = 0;
  *(void *)(v138 + 120) = 0LL;
  *(_DWORD *)(v91 + 132) = 0;
  *(_WORD *)(v91 + 136) = 0;
  [*(id *)(v91 + 304) removeAllObjects];
  [*(id *)(v91 + 312) removeAllObjects];
  [*(id *)(v91 + 328) removeAllObjects];
  [*(id *)(v91 + 336) removeAllObjects];
  [*(id *)(v91 + 344) removeAllObjects];
  [*(id *)(v91 + 368) removeAllObjects];
  [*(id *)(v91 + 376) removeAllObjects];
  *(void *)(v91 + 596) = 0LL;

  return sub_100242FAC((uint64_t)buf);
}

  *(_OWORD *)(a1 + 56_Block_object_dispose(va, 8) = xmmword_1006C4180;
  *(_OWORD *)(a1 + 584) = xmmword_1006C4190;
  *(_DWORD *)(a1 + 600) = 9000;
  *(_OWORD *)(a1 + 256) = xmmword_1006C41A0;
  *(_OWORD *)(a1 + 272) = xmmword_1006C41B0;
  uint64_t v19 = sub_1002E6E00();
  sub_10002418C(buf, "CoexConnectionScanParameters");
  sub_10002418C(__p, "CoexConnectionScanTimeout");
  id v20 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(void *)v19 + 88LL))(v19, buf, __p, &v172);
  if (v171 < 0) {
    operator delete(__p[0]);
  }
  if (v175 < 0)
  {
    operator delete(*(void **)buf);
    if (!v20) {
      goto LABEL_64;
    }
  }

  else if (!v20)
  {
    goto LABEL_64;
  }

  id v21 = v172;
  id v22 = (os_log_s *)qword_1008F7620;
  if (v172)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Warning: Override fFastConnectionScanDurationMsCoexCarPlay=%dms",  buf,  8u);
      id v21 = v172;
    }

    *(_DWORD *)(a1 + 596) = v21;
    *(_DWORD *)(a1 + 600) = v21;
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
  {
    sub_100696E24();
  }

  id v21 = sub_1002E6E00();
  sub_10002418C(buf, "LE");
  sub_10002418C(__p, "ForceRSSIDetectionDebug");
  id v22 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(void *)v21 + 88LL))( v21,  buf,  __p,  (char *)&v59 + 4);
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v66 < 0)
  {
    operator delete(*(void **)buf);
    if (!v22) {
      goto LABEL_64;
    }
  }

  else if (!v22)
  {
    goto LABEL_64;
  }

  unsigned __int8 v23 = HIDWORD(v59);
  id v24 = (os_log_s *)qword_1008F7620;
  if (HIDWORD(v59) >= 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_10069901C();
    }
    return 3LL;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Using override value for  ForceRSSIDetectionDebug (%d)",  buf,  8u);
  }

    goto LABEL_53;
  }

  id v20 = sub_1005E7BF8(a1, 22LL);
  if (!(_DWORD)v20 || !os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
    goto LABEL_52;
  }
  sub_10069D9D8();
LABEL_60:
  if (((v13 ^ v3) & 4) != 0)
  {
    if ((v13 & 4) != 0)
    {
      id v20 = sub_1005E7BF8(a1, 7LL);
      if ((_DWORD)v20 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069D858();
      }
    }

    else
    {
      id v20 = sub_1005E78AC(a1, 7);
      if ((_DWORD)v20 && os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR)) {
        sub_10069D7F8();
      }
    }
  }

  return v20;
}
}

void sub_1000596E8(_Unwind_Exception *a1)
{
}

id sub_10005973C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyDevice:]_block_invoke",  90LL,  "### ModifyDevice failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100059804(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v12 = v3;
  if (dword_1008D6630 <= 30)
  {
    if (dword_1008D6630 != -1 || (v9 = _LogCategory_Initialize(&dword_1008D6630, 30LL), id v3 = v12, v9))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v5 = CUPrintNSObjectOneLine(*(void *)(a1 + 40));
      int v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      uint64_t v7 = CUPrintNSError(v12);
      int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyDevice:]_block_invoke_2",  30LL,  "ModifyDevice CnxPri completed: %@, %@, %@",  v4,  v6,  v8);

      id v3 = v12;
    }
  }

  if (v3)
  {
    [*(id *)(a1 + 48) _xpcSendReplyError:v3 request:*(void *)(a1 + 56)];
  }

  else
  {
    uint64_t Reply = CUXPCDictionaryCreateReply(*(void *)(a1 + 56));
    id v11 = (void *)objc_claimAutoreleasedReturnValue(Reply);
    if (v11)
    {
      [*(id *)(a1 + 48) _xpcSendReply:v11];
    }

    else if (dword_1008D6630 <= 90 {
           && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
    }
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcModifyDevice:]_block_invoke_2",  90LL,  "### ModifyDevice create reply failed");
    }
  }
}

void sub_100059BF8(_Unwind_Exception *a1)
{
}

id sub_100059C30(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcPerformDeviceRequest:]_block_invoke",  90LL,  "### PerformDeviceRequest failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100059CF8(uint64_t a1, void *a2, void *a3)
{
  id v17 = a2;
  id v5 = a3;
  if (dword_1008D6630 <= 30 && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = CUPrintNSError(v5);
    int v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcPerformDeviceRequest:]_block_invoke_2",  30LL,  "PerformDeviceRequest completed: %@, %@, %@",  v6,  v7,  v9);
  }

  id v10 = v5;
  if (v10)
  {
    [*(id *)(a1 + 48) _xpcSendReplyError:v10 request:*(void *)(a1 + 56)];
  }

  else if (v17)
  {
    uint64_t Reply = CUXPCDictionaryCreateReply(*(void *)(a1 + 56));
    uint64_t v12 = objc_claimAutoreleasedReturnValue(Reply);
    uint64_t v13 = (void *)v12;
    if (v12)
    {
      CUXPCEncodeObject(v12, "dvRs", v17, 0LL);
      [*(id *)(a1 + 48) _xpcSendReply:v13];
    }

    else if (dword_1008D6630 <= 90 {
           && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
    }
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcPerformDeviceRequest:]_block_invoke_2",  90LL,  "### PerformDeviceRequest create reply failed");
    }
  }

  else
  {
    uint64_t v14 = *(void **)(a1 + 48);
    uint64_t v15 = CBErrorF(4294960534LL, "No error, but no response");
    int v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    [v14 _xpcSendReplyError:v16 request:*(void *)(a1 + 56)];
  }
}

void sub_10005B3AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

id sub_10005B450(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticControl:]_block_invoke",  90LL,  "### DiagnosticControl failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

uint64_t sub_10005B7B4(uint64_t result)
{
  if (dword_1008D6630 <= 30)
  {
    uint64_t v1 = result;
    if (dword_1008D6630 != -1) {
      return LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticAdvertiser]_block_invoke",  30LL,  "Diags: advertiser invalidated: %@",  *(void *)(v1 + 32));
    }
    id result = _LogCategory_Initialize(&dword_1008D6630, 30LL);
    if ((_DWORD)result) {
      return LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticAdvertiser]_block_invoke",  30LL,  "Diags: advertiser invalidated: %@",  *(void *)(v1 + 32));
    }
  }

  return result;
}

void sub_10005B830(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) testAdvertiser]);

  id v5 = v9;
  if (v3 == v4)
  {
    if (v9)
    {
      if (dword_1008D6630 <= 30
        && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
      {
        uint64_t v6 = CUPrintNSError(v9);
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticAdvertiser]_block_invoke_2",  30LL,  "### Diags: advertiser failed: %@",  v7);
      }

      [*(id *)(a1 + 32) invalidate];
      [*(id *)(*(void *)(a1 + 40) + 136) setTestAdvertiser:0];
      goto LABEL_11;
    }

    if (dword_1008D6630 <= 30)
    {
      if (dword_1008D6630 != -1 || (v8 = _LogCategory_Initialize(&dword_1008D6630, 30LL), id v5 = 0LL, v8))
      {
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticAdvertiser]_block_invoke_2",  30LL,  "Diags: advertiser activated: %@",  *(void *)(a1 + 32));
LABEL_11:
        id v5 = v9;
      }
    }
  }
}

void sub_10005BAE4(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) testAssertion]);

  id v5 = v9;
  if (v3 == v4)
  {
    if (v9)
    {
      if (dword_1008D6630 <= 30
        && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
      {
        uint64_t v6 = CUPrintNSError(v9);
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticAssertion]_block_invoke",  30LL,  "### Diags: assertion failed: %@",  v7);
      }

      [*(id *)(a1 + 32) invalidate];
      [*(id *)(*(void *)(a1 + 40) + 136) setTestAssertion:0];
      goto LABEL_11;
    }

    if (dword_1008D6630 <= 30)
    {
      if (dword_1008D6630 != -1 || (v8 = _LogCategory_Initialize(&dword_1008D6630, 30LL), id v5 = 0LL, v8))
      {
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticAssertion]_block_invoke",  30LL,  "Diags: assertion activated: %@",  *(void *)(a1 + 32));
LABEL_11:
        id v5 = v9;
      }
    }
  }
}

void sub_10005BE30(uint64_t a1, void *a2)
{
  id v5 = a2;
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) testDiscovery]);

  if (v3 == v4
    && dword_1008D6630 <= 30
    && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
  {
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticDiscovery]_block_invoke",  30LL,  "Diags: discovery found: %@",  v5);
  }
}

void sub_10005BED8(uint64_t a1, void *a2)
{
  id v5 = a2;
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) testDiscovery]);

  if (v3 == v4
    && dword_1008D6630 <= 30
    && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
  {
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticDiscovery]_block_invoke_2",  30LL,  "Diags: discovery lost: %@",  v5);
  }
}

uint64_t sub_10005BF80(uint64_t result)
{
  if (dword_1008D6630 <= 30)
  {
    uint64_t v1 = result;
    if (dword_1008D6630 != -1) {
      return LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticDiscovery]_block_invoke_3",  30LL,  "Diags: discovery invalidated: %@",  *(void *)(v1 + 32));
    }
    id result = _LogCategory_Initialize(&dword_1008D6630, 30LL);
    if ((_DWORD)result) {
      return LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticDiscovery]_block_invoke_3",  30LL,  "Diags: discovery invalidated: %@",  *(void *)(v1 + 32));
    }
  }

  return result;
}

void sub_10005BFFC(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) testDiscovery]);

  id v5 = v9;
  if (v3 == v4)
  {
    if (v9)
    {
      if (dword_1008D6630 <= 30
        && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
      {
        uint64_t v6 = CUPrintNSError(v9);
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticDiscovery]_block_invoke_4",  30LL,  "### Diags: discovery failed: %@",  v7);
      }

      [*(id *)(a1 + 32) invalidate];
      [*(id *)(*(void *)(a1 + 40) + 136) setTestDiscovery:0];
      goto LABEL_11;
    }

    if (dword_1008D6630 <= 30)
    {
      if (dword_1008D6630 != -1 || (v8 = _LogCategory_Initialize(&dword_1008D6630, 30LL), id v5 = 0LL, v8))
      {
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticDiscovery]_block_invoke_4",  30LL,  "Diags: discovery activated: %@",  *(void *)(a1 + 32));
LABEL_11:
        id v5 = v9;
      }
    }
  }
}

void sub_10005C3AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

id sub_10005C3EC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcDiagnosticLog:]_block_invoke",  90LL,  "### DiagnosticLog failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005CBA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v15 = v3;
  if (v3)
  {
    id v4 = v3;
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 != -1 || (int v10 = _LogCategory_Initialize(&dword_1008D6630, 90LL), v4 = v15, v10))
      {
        uint64_t v5 = *(int *)(a1 + 48);
        else {
          int v6 = off_100880B80[v5];
        }
        uint64_t v11 = CUPrintNSError(v4);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSetLowPowerMode:]_block_invoke",  90LL,  "### SetLowPowerMode failed: %s, %@",  v6,  v12);

        id v4 = v15;
      }
    }

    [*(id *)(a1 + 32) _xpcSendReplyError:v4 request:*(void *)(a1 + 40)];
  }

  else
  {
    xpc_object_t reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 40));
    if (dword_1008D6630 <= 30
      && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL)))
    {
      uint64_t v8 = *(int *)(a1 + 48);
      else {
        id v9 = off_100880B80[v8];
      }
      uint64_t v13 = CUPrintNSError(0LL);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSetLowPowerMode:]_block_invoke",  30LL,  "### SetLowPowerMode result: %s, %@",  v9,  v14);
    }

    if (reply)
    {
      [*(id *)(a1 + 32) _xpcSendReply:reply];
    }

    else if (dword_1008D6630 <= 90 {
           && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
    }
    {
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSetLowPowerMode:]_block_invoke",  90LL,  "### setLowPowerMode create reply failed");
    }
  }
}

void sub_10005D168( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

id sub_10005D1A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSetPowerState:]_block_invoke",  90LL,  "### SetPowerState failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005D848( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47)
{
}

id sub_10005D8BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcReadPrefs:]_block_invoke",  90LL,  "### ReadPrefs failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005DD70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

id sub_10005DDC0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcWritePref:]_block_invoke",  90LL,  "### WritePrefs failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005E328(_Unwind_Exception *a1)
{
}

id sub_10005E36C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendRelayMessage:]_block_invoke",  90LL,  "### SendRelayMessage failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

LABEL_11:
    goto LABEL_12;
  }

    goto LABEL_12;
  }

  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    id v9 = "~IOBTDebug";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "IOBTDebug::%s: --done\n",  buf,  0xCu);
  }

  std::mutex::~mutex((std::mutex *)this);
}

  int v10 = *v9;
  uint64_t v11 = sub_10012CB7C(*v8);
  if (!v11)
  {
    uint64_t v12 = malloc(v7 + (unint64_t)a3);
    if (!v12)
    {
      sub_1001EE0E4("failed to allocate memory for tx_buff");
      off_1008D9F20("PCIe memory allocation failure", 1LL);
      return 106LL;
    }

    uint64_t v11 = (uint64_t)v12;
    int v6 = j__free;
  }

  *(_WORD *)uint64_t v11 = a2;
  *(_BYTE *)(v11 + 2) = a3;
  if (a1 == 243 || a1 == 2) {
    *(_BYTE *)(v11 + 3) = BYTE1(a3);
  }
  if (a3) {
    sub_10011EF64((char *)(v11 + v7));
  }
  else {
    sub_1000BA1F0();
  }
  uint64_t v14 = 0;
  if ((AppleConvergedTransportWrite(v10, v11, v7 + a3, &v14, 0xFFFFFFFFLL, v6) & 1) != 0) {
    return 625LL;
  }
  if (!byte_1008D9F19)
  {
    sub_1001EE0E4("PCIe write failed: type %u\n", a1);
    off_1008D9F20("PCIe write failed", 1LL);
  }

  return 1205LL;
}

  switch(v6)
  {
    case 0:
      id v9 = qword_1008DDD30;
      *(_BYTE *)(qword_1008DDD30 + 11) = 1;
      *(_WORD *)(v9 + _Block_object_dispose((const void *)(v2 - 136), 8) = a3 + 3;
      sub_10011EF64((char *)(*(void *)(v9 + 16) + 3LL));
      int v10 = qword_1008DDD30;
      **(_WORD **)(qword_1008DDD30 + 16) = a2;
      *(_BYTE *)(*(void *)(v10 + 16) + 2LL) = a3;
      uint64_t v11 = byte_1008DDD4A;
      *(_BYTE *)(v10 + 10) = byte_1008DDD4A;
      *(void *)int v10 = 0LL;
      byte_1008DDD4A = (v11 + 1) & 7;
      uint64_t v12 = &qword_1008DDD18;
      uint64_t v13 = (uint64_t *)qword_1008DDD18;
      if (qword_1008DDD18)
      {
        do
        {
          uint64_t v12 = v13;
          uint64_t v13 = (uint64_t *)*v13;
        }

        while (v13);
      }

      *uint64_t v12 = v10;
      goto LABEL_32;
    case 1:
      id v15 = qword_1008DDD28;
      if (!qword_1008DDD28)
      {
        sub_1001EE2A0();
        id v15 = qword_1008DDD28;
      }

      qword_1008DDD28 = *(void *)v15;
      *(_BYTE *)(v15 + 11) = 2;
      *(_WORD *)(v15 + _Block_object_dispose((const void *)(v2 - 136), 8) = a3 + 4;
      sub_10011EF64((char *)(*(void *)(v15 + 16) + 4LL));
      **(_WORD **)(v15 + 16) = a2;
      *(_WORD *)(*(void *)(v15 + 16) + 2LL) = a3;
      int v16 = byte_1008DDD4A;
      *(_BYTE *)(v15 + 10) = byte_1008DDD4A;
      *(void *)id v15 = 0LL;
      byte_1008DDD4A = (v16 + 1) & 7;
      id v17 = &qword_1008DDD18;
      size_t v18 = (uint64_t *)qword_1008DDD18;
      if (qword_1008DDD18)
      {
        do
        {
          id v17 = v18;
          size_t v18 = (uint64_t *)*v18;
        }

        while (v18);
      }

      *id v17 = v15;
      if (!qword_1008DDD28) {
        goto LABEL_32;
      }
      uint64_t v19 = 2;
      goto LABEL_31;
    case 2:
      if (v7 == 4)
      {
        uint64_t v14 = 3;
        goto LABEL_24;
      }

      id v20 = qword_1008DDD38;
      *(_BYTE *)(qword_1008DDD38 + 11) = 3;
      *(_WORD *)(v20 + _Block_object_dispose((const void *)(v2 - 136), 8) = a3 + 3;
      sub_10011EF64((char *)(*(void *)(v20 + 16) + 3LL));
      id v21 = qword_1008DDD38;
      **(_WORD **)(qword_1008DDD38 + 16) = a2;
      *(_BYTE *)(*(void *)(v21 + 16) + 2LL) = a3;
      if (*(_BYTE *)(v21 + 11)) {
        id v22 = 0;
      }
      else {
        id v22 = byte_1008DDD59;
      }
      *(_BYTE *)(v21 + 10) = v22;
      if (qword_1008DDD18 != v21)
      {
        *(void *)id v21 = qword_1008DDD18;
        qword_1008DDD18 = v21;
      }

      uint64_t v19 = 3;
LABEL_31:
      sub_10009B8EC(v19);
LABEL_32:
      if (!dword_1008F1F8C) {
        sub_10009B934();
      }
      break;
    default:
      sub_1001EE2A0();
      goto LABEL_32;
  }

  switch(v8)
  {
    case 0:
      uint64_t v11 = qword_1008DDD30;
      *(_BYTE *)(qword_1008DDD30 + 11) = 1;
      *(_WORD *)(v11 + _Block_object_dispose((const void *)(v2 - 136), 8) = a3 + 3;
      memmove((void *)(*(void *)(v11 + 16) + 3LL), a4, a3);
      uint64_t v12 = qword_1008DDD30;
      **(_WORD **)(qword_1008DDD30 + 16) = a2;
      *(_BYTE *)(*(void *)(v12 + 16) + 2LL) = a3;
      uint64_t v13 = byte_1008DDD4A;
      *(_BYTE *)(v12 + 10) = byte_1008DDD4A;
      *(void *)uint64_t v12 = 0LL;
      byte_1008DDD4A = (v13 + 1) & 7;
      uint64_t v14 = &qword_1008DDD18;
      id v15 = (uint64_t *)qword_1008DDD18;
      if (qword_1008DDD18)
      {
        do
        {
          uint64_t v14 = v15;
          id v15 = (uint64_t *)*v15;
        }

        while (v15);
      }

      *uint64_t v14 = v12;
      goto LABEL_32;
    case 1:
      id v17 = qword_1008DDD28;
      if (!qword_1008DDD28)
      {
        sub_1001EE2A0();
        id v17 = qword_1008DDD28;
      }

      qword_1008DDD28 = *(void *)v17;
      *(_BYTE *)(v17 + 11) = 2;
      *(_WORD *)(v17 + _Block_object_dispose((const void *)(v2 - 136), 8) = a3 + 4;
      memmove((void *)(*(void *)(v17 + 16) + 4LL), a4, a3);
      **(_WORD **)(v17 + 16) = a2;
      *(_WORD *)(*(void *)(v17 + 16) + 2LL) = a3;
      size_t v18 = byte_1008DDD4A;
      *(_BYTE *)(v17 + 10) = byte_1008DDD4A;
      *(void *)id v17 = 0LL;
      byte_1008DDD4A = (v18 + 1) & 7;
      uint64_t v19 = &qword_1008DDD18;
      id v20 = (uint64_t *)qword_1008DDD18;
      if (qword_1008DDD18)
      {
        do
        {
          uint64_t v19 = v20;
          id v20 = (uint64_t *)*v20;
        }

        while (v20);
      }

      void *v19 = v17;
      if (!qword_1008DDD28) {
        goto LABEL_32;
      }
      id v21 = 2;
      goto LABEL_31;
    case 2:
      if (v9 == 4)
      {
        int v16 = 3;
        goto LABEL_24;
      }

      id v22 = qword_1008DDD38;
      *(_BYTE *)(qword_1008DDD38 + 11) = 3;
      *(_WORD *)(v22 + _Block_object_dispose((const void *)(v2 - 136), 8) = a3 + 3;
      memmove((void *)(*(void *)(v22 + 16) + 3LL), a4, a3);
      unsigned __int8 v23 = qword_1008DDD38;
      **(_WORD **)(qword_1008DDD38 + 16) = a2;
      *(_BYTE *)(*(void *)(v23 + 16) + 2LL) = a3;
      if (*(_BYTE *)(v23 + 11)) {
        id v24 = 0;
      }
      else {
        id v24 = byte_1008DDD59;
      }
      *(_BYTE *)(v23 + 10) = v24;
      if (qword_1008DDD18 != v23)
      {
        *(void *)unsigned __int8 v23 = qword_1008DDD18;
        qword_1008DDD18 = v23;
      }

      id v21 = 3;
LABEL_31:
      sub_10009B8EC(v21);
LABEL_32:
      if (!dword_1008F1F8C) {
        sub_10009B934();
      }
      break;
    default:
      sub_1001EE2A0();
      goto LABEL_32;
  }

  id result = 0LL;
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 136), 8) = v4;
  return result;
}

    id v17 = 8;
LABEL_51:
    *a3 = v17;
    sub_1000E7E40(a1, a2, (unsigned __int8 *)a3);
    return;
  }

  uint64_t v8 = *(void (**)(uint64_t, uint64_t, char *))(*(void *)(qword_1008F29A0 + 16) + 24LL);
  if (v8) {
    v8(a1, a2, a3);
  }
}

  sub_1001EE134((uint64_t)"SubOpcode Incorrect %!", v18, v19, v20, v21, v22, v23, v24, a1);
  id v25 = (os_log_s *)sub_100086554(0x54u);
  if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
    goto LABEL_13;
  }
  sub_100657F74();
  if (a2) {
LABEL_14:
  }
    a2(a1, v14, v13);
}

    id v20 = (__int128 *)a1;
    id v21 = a7;
    id v22 = a3;
    uint64_t v19 = 2;
    return sub_1001CA640(v20, v21, v22, 0, 0, 0, v19);
  }

  if ((a3 & 0xFFC0) != 0x40)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"%! - Rejecting connect attempt due to source CID out of range",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  589LL);
      uint64_t v51 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    id v20 = (__int128 *)a1;
    id v21 = a7;
    id v22 = a3;
    uint64_t v19 = 9;
    return sub_1001CA640(v20, v21, v22, 0, 0, 0, v19);
  }

  uint64_t v83 = 0LL;
  sub_100172290(a3, a1, &v83);
  if (v83)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"%! - Rejecting connect attempt due to source CID already connected",  v36,  v37,  v38,  v39,  v40,  v41,  v42,  10LL);
      unint64_t v43 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    id v20 = (__int128 *)a1;
    id v21 = a7;
    id v22 = a3;
    uint64_t v19 = 10;
    return sub_1001CA640(v20, v21, v22, 0, 0, 0, v19);
  }

  if (sub_100172ECC(2u, (uint64_t *)&v84, 1))
  {
    sub_1001EE134( (uint64_t)"%! - rejecting connect attempt due to ailure to allocate channel",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  584LL);
    uint64_t v59 = (os_log_s *)sub_100086554(0x2Fu);
    if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  uint64_t v60 = v84;
  *((_WORD *)v84 + 3) = v27;
  int v61 = sub_10017AB4C(v60);
  id v62 = *(_WORD *)(a1 + 52);
  *(_DWORD *)(v61 + 10) = *(_DWORD *)(a1 + 48);
  *(_WORD *)(v61 + 14) = v62;
  int v63 = sub_10017AB4C(v84);
  int v64 = *(_DWORD *)(a1 + 51);
  *(_DWORD *)(v63 + 104) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(v63 + 107) = v64;
  *(_BYTE *)(sub_10017AB4C(v84) + 24) = 1;
  *(void *)sub_10017AB4C(v84) = a1;
  *(_WORD *)(sub_10017AB4C(v84) + _Block_object_dispose((const void *)(v2 - 136), 8) = a3;
  *(_BYTE *)(sub_10017AB4C(v84) + 29) = a7;
  if (14 * a5 < a4) {
    LOWORD(a4) = 14 * a5;
  }
  *(_WORD *)(sub_10017AB4C(v84) + 32) = a4;
  *(_WORD *)(sub_10017AB4C(v84) + 60) = a5;
  if (sub_10016EC44(v84, a6))
  {
    sub_1001734D8((uint64_t)v84);
    sub_1001EE134( (uint64_t)"%! - rejecting connect attempt due to failure to init remote parameters, returned %!(%d), ejecting connection",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  584LL);
    int v72 = (os_log_s *)sub_100086554(0x2Fu);
    if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
LABEL_31:
    sub_100657858();
LABEL_32:
    id v20 = (__int128 *)a1;
    id v21 = a7;
    id v22 = a3;
    uint64_t v19 = 4;
    return sub_1001CA640(v20, v21, v22, 0, 0, 0, v19);
  }

  *(_BYTE *)(sub_10017AB4C(v84) + 16) = 2;
  int v74 = sub_10017AB4C(v84);
  id result = sub_10017AD3C(v74 + 104, *((unsigned __int16 *)v84 + 2), *((unsigned __int16 *)v84 + 3), a7, a8);
  if ((_DWORD)result)
  {
    sub_1001734D8((uint64_t)v84);
    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"%! - rejecting connect attempt due to failure to find a handler for this channel",  v75,  v76,  v77,  v78,  v79,  v80,  v81,  582LL);
      __n128 v82 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
        sub_100657858();
      }
    }

    goto LABEL_11;
  }

  return result;
}

    if (sub_1000A86F0())
    {
      sub_1001EE134( (uint64_t)"Fragmented packet with cid 0x%4x available, but no queue with corresponding CID exists",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *(unsigned __int16 *)(*(void *)a2 + 36LL));
      size_t v18 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    goto LABEL_55;
  }

  uint64_t v19 = sub_1001EC43C(qword_1008E2C40);
  id v20 = v19;
  __int128 v42 = v19;
  if (!a2)
  {
    sub_1001EE2A0();
    if (v20) {
      goto LABEL_18;
    }
LABEL_40:
    if (*(_BYTE *)(v7 + 16))
    {
      if (!sub_1001EC434(*(void *)(v7 + 8)))
      {
        unint64_t v40 = (_BYTE *)sub_1001EC30C(*(void *)v7);
        *(void *)a2 = v40;
        if (!*v40) {
          sub_100189A0C((uint64_t)v40);
        }
LABEL_63:
        if (qword_1008E2C38 != v7 && qword_1008E2C40 != v7) {
          goto LABEL_79;
        }
        return v7;
      }

      uint64_t v27 = *(void *)(v7 + 8);
    }

    else
    {
      uint64_t v27 = *(void *)v7;
    }

    *(void *)a2 = sub_1001EC30C(v27);
    goto LABEL_63;
  }

  if (!v19) {
    goto LABEL_40;
  }
  while (1)
  {
LABEL_18:
    id v21 = sub_1001EC460(v20);
    id v22 = *(void *)(v21 + 8);
    if (*(void *)a2 && v22 != *(void *)(*(void *)a2 + 8LL)) {
      goto LABEL_39;
    }
    if (!sub_10012D514(v22)
      && !sub_10012D5BC(*(void *)(v21 + 8))
      && !sub_10012D5EC(*(void *)(v21 + 8))
      && !sub_10012D61C(*(void *)(v21 + 8)))
    {
      break;
    }

    unsigned __int8 v23 = *(unsigned __int8 *)(*(void *)(v21 + 8) + 2LL);
    if (*(_BYTE *)(*(void *)(v21 + 8) + 2LL)) {
      id v24 = 1;
    }
    else {
      id v24 = byte_1008F6E91 == 0;
    }
    if (!v24
      || (v23 == 4 ? (id v25 = byte_1008F6E92 == 0) : (id v25 = 1),
          !v25 || (v23 == 8 ? (int v26 = byte_1008F6E90 == 0) : (int v26 = 1), !v26)))
    {
      *(void *)a2 = v21;
      sub_1001EC468(qword_1008E2C40, v42);
      id v21 = *(void *)a2;
      goto LABEL_44;
    }

  int v16 = &qword_1008E38B8[421 * v10];
  id v17 = *((unsigned __int8 *)v16 + 3352);
  if (*((_BYTE *)v16 + 3352))
  {
    if ((_DWORD)a1)
    {
LABEL_13:
      sub_1001A057C(a1, v17, v4, v5, v6, v7, v8, v9);
      return;
    }

    LODWORD(v4) = BYTE1(qword_1008E38B8[421 * v10 + 419]);
  }

  else
  {
    if ((_DWORD)a1) {
      goto LABEL_13;
    }
    size_t v18 = &qword_1008E38B8[421 * v10];
    uint64_t v4 = *((unsigned __int8 *)v18 + 3353);
    if (!*((_BYTE *)v18 + 3353)) {
      goto LABEL_13;
    }
  }

  uint64_t v19 = sub_10019DE34(byte_1008E7A82[v10], v17, v4);
  if ((_DWORD)v19) {
    sub_1001A0FE8(v19, v20, v21, v22, v23, v24, v25, v26);
  }
}

    id result = 0LL;
LABEL_13:
    id v3 = (_BYTE *)(a1 + 14);
LABEL_14:
    *id v3 = 0;
    return result;
  }

  return 106LL;
}

      int v6 = 0LL;
      goto LABEL_12;
    }

    uint64_t v5 = *v3;
    if (*v3)
    {
      int v6 = *v5;
      if (*v5) {
        break;
      }
    }

    ++v3;
  }

  if (qword_1008D6458 != -1) {
    dispatch_once(&qword_1008D6458, &stru_100888B90);
  }
  if ((sub_10036DB74((void *)qword_1008D6450, v6) & 1) == 0)
  {
    uint64_t v7 = (os_log_s *)qword_1008F7560;
    if (os_log_type_enabled((os_log_t)qword_1008F7560, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v10 = 0;
      uint64_t v8 = "getA2DPStreamingDevice: no A2DP stream";
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, v10, 2u);
    }

    goto LABEL_11;
  }

  uint64_t v12 = sub_10025D564(*(void *)(a1 + 16));
  uint64_t v13 = objc_claimAutoreleasedReturnValue(v12);
  uint64_t v14 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = v13;

  if (([&off_1008C3150 containsObject:*(void *)(a1 + 96)] & 1) == 0)
  {
    id v15 = operator new(0x40uLL);
    sub_10002418C(__p, (char *)[*(id *)(a1 + 96) UTF8String]);
    sub_10032E930((int)v15, (int)__p, a4);
    *(void *)(a1 + 32) = v15;
    if (v22 < 0) {
      operator delete(__p[0]);
    }
  }

  *(_BYTE *)(a1 + 84) = sub_10025D500(a1);
  *(_BYTE *)(a1 + 89) = sub_10025D500(a1);
  *(_BYTE *)(a1 + 85) = sub_10025D500(a1);
  return a1;
}

  bzero(__p, 0x1000uLL);
  uint64_t v14 = -1;
  uint64_t v13 = 0;
  uint64_t v12 = 0;
  if (sub_1002D5DCC(a1, (uint64_t)a2, (uint64_t)"HIDDescriptor", (uint64_t)__p, v7))
  {
    uint64_t v8 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
      sub_100669DB0((uint64_t *)&v15, v8, v9);
    }
  }

  sub_1002D5DCC(a1, (uint64_t)a2, (uint64_t)"HIDVendorID", (uint64_t)&v14, (id)2);
  sub_1002D5DCC(a1, (uint64_t)a2, (uint64_t)"HIDVendorIDSource", (uint64_t)&v13, (id)2);
  sub_1002D5DCC(a1, (uint64_t)a2, (uint64_t)"HIDProductID", (uint64_t)&v12 + 2, (id)2);
  sub_1002D5DCC(a1, (uint64_t)a2, (uint64_t)"HIDVersion", (uint64_t)&v12, (id)2);
  sub_10056AB04(&buf, __p, v15);
  sub_1003D536C(a2, (uint64_t)&buf, v14, v13, SHIWORD(v12), v12);
  *(void *)&buf = &off_10087FAA8;
  if (*((void *)&buf + 1)) {
    sub_1002CD254(*((unsigned int **)&buf + 1));
  }
  return 0LL;
}

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v14 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", (int)uint64);
    if (!(_DWORD)uint64)
    {
      xpc_dictionary_set_data(v14, "kCBMsgArgData", v12, v7);
      xpc_dictionary_set_data(v14, "kCBMsgArgExtensionToken", v15, 0x200uLL);
    }

    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v14);
    xpc_release(v14);
  }

    int v10 = 17LL;
    goto LABEL_17;
  }

  [*(id *)(a1 + 256) addObject:v5];
LABEL_6:
  id v22 = 0LL;
  id v20 = 0u;
  id v21 = 0u;
  size_t v18 = 0u;
  uint64_t v19 = 0u;
  if (qword_1008D5F10 != -1) {
    dispatch_once(&qword_1008D5F10, &stru_100894610);
  }
  sub_10058C504((uint64_t)off_1008D5F08, v5, (uint64_t)&v18);
  if ((void)v18)
  {
    uint64_t v7 = [*((id *)&v18 + 1) mutableCopy];
    uint64_t v8 = v7;
    id v9 = *(void *)(a1 + 88);
    if (a3) {
      [v7 addObject:v9];
    }
    else {
      [v7 removeObject:v9];
    }
    objc_storeStrong((id *)&v18 + 1, v8);
    if (qword_1008D5F10 != -1) {
      dispatch_once(&qword_1008D5F10, &stru_100894610);
    }
    uint64_t v11 = off_1008D5F08;
    v13[0] = (id)v18;
    v13[1] = *((id *)&v18 + 1);
    uint64_t v14 = v19;
    id v15 = v20;
    int v16 = v21;
    id v17 = v22;
    sub_10058C62C((uint64_t)v11, v5, (uint64_t)v13);
  }

  int v10 = 0LL;
LABEL_17:

  return v10;
}

      int v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_12;
      }
    }

    if (v8 >= v5)
    {
      id v9 = 1LL;
      goto LABEL_13;
    }

  return v5;
}

  return v5;
}

    *(_DWORD *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = mach_absolute_time();
    id v3 = *(_DWORD *)(a1 + 112);
    goto LABEL_12;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_ERROR)) {
    sub_10067C1EC();
  }
  id v3 = 1;
  *(_DWORD *)(a1 + 112) = 1;
LABEL_12:
  sub_10040E234((os_unfair_lock_s *)a1, v3);
}

  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  return v7;
}

      if (sub_10043DCE4(a1)) {
        return sub_100242FAC((uint64_t)v8);
      }
      goto LABEL_12;
    }

  uint64_t v4 = *result;
  if (!*result)
  {
LABEL_15:
    if (os_log_type_enabled((os_log_t)qword_1008F7728, OS_LOG_TYPE_ERROR)) {
      sub_100685FCC();
    }
    return 0LL;
  }

  while (v4 != a2)
  {
    uint64_t v4 = result[12];
    if (!result[12]) {
      goto LABEL_15;
    }
    result += 12;
  }

  return result;
}

  _Block_object_dispose(&v34, 8);
}

  return v7;
}
}

  int v10 = (v9 >> 4) & 0xF0 | (v9 >> 8) & 0xF00;
LABEL_12:
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (reply)
  {
    uint64_t v13 = reply;
    xpc_dictionary_set_uint64(reply, "kCBMsgArgResult", v8);
    xpc_dictionary_set_uint64(v13, "kCBMsgArgCallManagementMessage", v10);
    xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), v13);
    xpc_release(v13);
  }

  sub_100242CD8(&v5);
  return v3;
}

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  xpc_dictionary_set_uint64(reply, "kCBMsgArgStatus", v11);
  xpc_connection_send_message(*(xpc_connection_t *)(*(void *)(a1 + 72) + 16LL), reply);
  xpc_release(reply);
}

  if (!uuid_is_null(uu))
  {
    *(void *)&int v26 = uu;
    sub_1005BC438( (uint64_t **)(a1 + 432),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v26)[6] = a2;
    id v30 = 0LL;
    uint64_t v28 = 0u;
    id v29 = 0u;
    int v26 = 0u;
    uint64_t v27 = 0u;
    int v16 = sub_100241F94(uu);
    id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    sub_10058C504(a1, v17, (uint64_t)&v26);

    if (!(void)v26)
    {
LABEL_24:
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3321888768LL;
      v31[2] = sub_10058C7AC;
      v31[3] = &unk_1008A2368;
      uuid_copy(v34, uu);
      v34[16] = a3;
      v34[17] = a5;
      uint64_t v32 = a4;
      uint64_t v33 = a6;
      sub_10058C72C((os_unfair_lock_s *)a1, v31);

      return;
    }

    if ((a4 & 0x40) != 0)
    {
      size_t v18 = 5LL;
    }

    else
    {
      if ((a4 & 0x80) != 0)
      {
        *((void *)&v28 + 1) = 0LL;
LABEL_23:
        uint64_t v19 = sub_100241F94(uu);
        id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
        v21[0] = (id)v26;
        v21[1] = *((id *)&v26 + 1);
        id v22 = v27;
        unsigned __int8 v23 = v28;
        id v24 = v29;
        id v25 = v30;
        sub_10058C62C(a1, v20, (uint64_t)v21);

        goto LABEL_24;
      }

      if ((a4 & 0x100) != 0) {
        size_t v18 = 1LL;
      }
      else {
        size_t v18 = 6LL;
      }
    }

    *((void *)&v28 + 1) = v18;
    goto LABEL_23;
  }

  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
    sub_100697284();
  }
}

  if (uuid_is_null(uu))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100699CD8();
    }
    return sub_100242FAC((uint64_t)v83);
  }

  uint64_t v12 = sub_1002E6BF0();
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v12 + 952LL))(v12))
  {
    int v76 = 0;
    __n128 v77 = 0;
    goto LABEL_46;
  }

  uint64_t v13 = *(void **)(a1 + 536);
  if (!v13) {
    goto LABEL_26;
  }
  uint64_t v14 = a1 + 536;
  do
  {
    id v15 = v13[4];
    int v16 = v15 >= v84;
    if (v15 >= v84) {
      id v17 = v13;
    }
    else {
      id v17 = v13 + 1;
    }
    if (v16) {
      uint64_t v14 = (uint64_t)v13;
    }
    uint64_t v13 = (void *)*v17;
  }

  while (*v17);
  if (v14 != a1 + 536 && v84 >= *(void *)(v14 + 32))
  {
    int v61 = *(unsigned __int16 *)(v14 + 46);
    id v62 = *(unsigned __int16 *)(v14 + 48);
    int v63 = *(_WORD *)(v14 + 50);
    int v64 = *(_DWORD *)(v14 + 52);
    *(void *)buf = &v84;
    uint64_t v65 = sub_1005BC978((uint64_t **)(a1 + 528), &v84, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
    if (v62) {
      uint32_t v66 = 0;
    }
    else {
      uint32_t v66 = v61 == 1;
    }
    if (v66) {
      uint64_t v67 = 0;
    }
    else {
      uint64_t v67 = v64;
    }
    *((_WORD *)v65 + 20) = a3;
    *((_WORD *)v65 + 21) = a4;
    *((_WORD *)v65 + 22) = a5;
    int v76 = v61;
    __n128 v77 = v62;
    *((_WORD *)v65 + 23) = v61;
    *((_WORD *)v65 + 24) = v62;
    *((_WORD *)v65 + 25) = v63;
    *((_DWORD *)v65 + 13) = v67;
    char v68 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = v84;
      _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEFAULT,  "Updated previously stored connection parameters for handle %p.",  buf,  0xCu);
    }
  }

  else
  {
LABEL_26:
    size_t v18 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "No previously stored connection parameters. Saving new parameters now. Subrate factor & Continuation number initialized to 0.",  buf,  2u);
    }

    *(void *)buf = &v84;
    uint64_t v19 = sub_1005BC978((uint64_t **)(a1 + 528), &v84, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
    int v76 = 0;
    __n128 v77 = 0;
    *((_WORD *)v19 + 20) = a3;
    *((_WORD *)v19 + 21) = a4;
    *((_WORD *)v19 + 22) = a5;
    *(uint64_t *)((char *)v19 + 46) = 0LL;
    *((_WORD *)v19 + 27) = 0;
  }

  id v20 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    __int128 v75 = v84;
    *(void *)__p = &v84;
    *(void *)__p = &v84;
    *(void *)__p = &v84;
    *(void *)__p = &v84;
    *(void *)__p = &v84;
    *(void *)__p = &v84;
    id v25 = *((_DWORD *)sub_1005BC978((uint64_t **)(a1 + 528), &v84, (uint64_t)&unk_1006C2518, (uint64_t **)__p) + 13);
    *(_DWORD *)buf = 134219520;
    *(void *)&uint8_t buf[4] = v75;
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&_BYTE buf[14] = v74;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v21;
    *(_WORD *)&_BYTE buf[24] = 1024;
    *(_DWORD *)&buf[26] = v22;
    *(_WORD *)&buf[30] = 1024;
    *(_DWORD *)&buf[32] = v23;
    *(_WORD *)&buf[36] = 1024;
    v104 = v24;
    v105 = 1024;
    v106 = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "handleConnectionParametersUpdatedCallback: Connection parameters for handle %p. Connection Interval:%d Peripheral latency:%d Supervision Timeout=%d Subrate Factor: %d Continuation Number: %d. Subrating Status: %d",  buf,  0x30u);
  }

  int v26 = *(void **)(a1 + 512);
  if (v26)
  {
    uint64_t v27 = v84;
    uint64_t v28 = a1 + 512;
    do
    {
      id v29 = v26[4];
      id v30 = v29 >= v84;
      if (v29 >= v84) {
        id v31 = v26;
      }
      else {
        id v31 = v26 + 1;
      }
      if (v30) {
        uint64_t v28 = (uint64_t)v26;
      }
      int v26 = (void *)*v31;
    }

    while (*v31);
    if (v28 != a1 + 512 && v84 >= *(void *)(v28 + 32))
    {
      int v69 = *(void *)(v28 + 40);
      BOOL v70 = *(unsigned __int16 *)(v28 + 48);
      int v71 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67110144;
        *(_DWORD *)&uint8_t buf[4] = WORD1(v69);
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = WORD2(v69);
        *(_WORD *)&_BYTE buf[14] = 1024;
        *(_DWORD *)&uint8_t buf[16] = (unsigned __int16)v69;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = HIWORD(v69);
        *(_WORD *)&buf[26] = 1024;
        *(_DWORD *)&buf[28] = v70;
        _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "Locally initiated connection parameter update is now complete. Proceeding with sending connection subrating pa rameters: subrateMin:%d subrateMax:%d maxLatency:%d continuationNumber=%d supervisionTimeout=%d",  buf,  0x20u);
        uint64_t v27 = v84;
      }

      int v72 = sub_1005993F4(a1, v27, v69, v70);
      __int128 v73 = qword_1008F7620;
      if (!os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v72;
      uint64_t v33 = "Sent LE Connection Subrating Request with status: %d";
      __int16 v34 = (os_log_s *)v73;
      char v35 = OS_LOG_TYPE_DEFAULT;
      uint64_t v36 = 8;
      goto LABEL_44;
    }
  }

  uint64_t v32 = qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    uint64_t v33 = "No connection subrating requests pending for this handle";
    __int16 v34 = (os_log_s *)v32;
    char v35 = OS_LOG_TYPE_INFO;
    uint64_t v36 = 2;
LABEL_44:
    _os_log_impl((void *)&_mh_execute_header, v34, v35, v33, buf, v36);
  }

  if (uuid_is_null(uu))
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100699CD8();
    }
  }

  else
  {
    id v17 = *(void **)(a1 + 536);
    if (!v17) {
      goto LABEL_25;
    }
    size_t v18 = v56;
    uint64_t v19 = (void *)(a1 + 536);
    do
    {
      id v20 = v17[4];
      id v21 = v20 >= v56;
      if (v20 >= v56) {
        id v22 = v17;
      }
      else {
        id v22 = v17 + 1;
      }
      if (v21) {
        uint64_t v19 = v17;
      }
      id v17 = (void *)*v22;
    }

    while (*v22);
    if (v19 != (void *)(a1 + 536) && v56 >= v19[4])
    {
      id v24 = *((_WORD *)v19 + 20);
      int v6 = *((_WORD *)v19 + 25);
      id v25 = *((_DWORD *)v19 + 13);
      log = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_DEFAULT,  "Updated previously stored connection parameters for handle %p.",  buf,  0xCu);
      }
    }

    else
    {
LABEL_25:
      unsigned __int8 v23 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "No previously stored connection parameters. Saving new parameters now. Connection Interval initialized to 0.",  buf,  2u);
      }

      id v24 = 0;
      id v25 = 0;
    }

    *(void *)buf = &v56;
    int v26 = sub_1005BC978((uint64_t **)(a1 + 528), &v56, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
    *((_WORD *)v26 + 20) = v24;
    *((_WORD *)v26 + 21) = a4;
    *((_WORD *)v26 + 22) = a6;
    *((_WORD *)v26 + 23) = a3;
    *((_WORD *)v26 + 24) = a5;
    *((_WORD *)v26 + 25) = v6;
    *((_DWORD *)v26 + 13) = v25;
    if (a3 == 1
      && (*(void *)buf = &v56,
          *((int *)sub_1005BC978((uint64_t **)(a1 + 528), &v56, (uint64_t)&unk_1006C2518, (uint64_t **)buf) + 13) <= 1))
    {
      uint64_t v27 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v57 = &v56;
        uint64_t v53 = *((_DWORD *)sub_1005BC978((uint64_t **)(a1 + 528), &v56, (uint64_t)&unk_1006C2518, (uint64_t **)&v57) + 13);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v53;
        *(_WORD *)&uint8_t buf[8] = 2048;
        *(void *)&buf[10] = v56;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "Connection subrating status was %d to handle %p. Setting status to OFF.",  buf,  0x12u);
      }

      *(void *)buf = &v56;
      uint64_t v28 = sub_1005BC978((uint64_t **)(a1 + 528), &v56, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
      id v29 = 0;
    }

    else
    {
      id v30 = (os_log_s *)qword_1008F7620;
      if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v57 = &v56;
        uint64_t v52 = *((_DWORD *)sub_1005BC978((uint64_t **)(a1 + 528), &v56, (uint64_t)&unk_1006C2518, (uint64_t **)&v57) + 13);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v52;
        *(_WORD *)&uint8_t buf[8] = 2048;
        *(void *)&buf[10] = v56;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "Connection subrating status was %d to handle %p. Setting status to ON.",  buf,  0x12u);
      }

      *(void *)buf = &v56;
      uint64_t v28 = sub_1005BC978((uint64_t **)(a1 + 528), &v56, (uint64_t)&unk_1006C2518, (uint64_t **)buf);
      id v29 = 2;
    }

    *((_DWORD *)v28 + 13) = v29;
    id v31 = *(void **)(a1 + 512);
    if (v31)
    {
      uint64_t v32 = v56;
      uint64_t v33 = (void *)(a1 + 512);
      do
      {
        __int16 v34 = v31[4];
        char v35 = v34 >= v56;
        if (v34 >= v56) {
          uint64_t v36 = v31;
        }
        else {
          uint64_t v36 = v31 + 1;
        }
        if (v35) {
          uint64_t v33 = v31;
        }
        id v31 = (void *)*v36;
      }

      while (*v36);
      if (v33 != (void *)(a1 + 512) && v56 >= v33[4])
      {
        __int128 v37 = (os_log_s *)qword_1008F7620;
        if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
        {
          int v38 = *((unsigned __int16 *)v33 + 24);
          unint64_t v39 = *((unsigned __int16 *)v33 + 23);
          unint64_t v40 = *((unsigned __int16 *)v33 + 22);
          id v41 = *((unsigned __int16 *)v33 + 21);
          __int128 v42 = *((unsigned __int16 *)v33 + 20);
          *(_DWORD *)buf = 134219264;
          *(void *)&uint8_t buf[4] = v32;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&_BYTE buf[14] = v41;
          int v61 = 1024;
          id v62 = v40;
          int v63 = 1024;
          int v64 = v42;
          uint64_t v65 = 1024;
          uint32_t v66 = v39;
          uint64_t v67 = 1024;
          char v68 = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Locally initiated connection subrating update to handle %p is now complete. Connection subrating parameters requested: subrateMin:%d subrateMax:%d maxLatency:%d continuationNumber=%d supervisionTimeout=%d",  buf,  0x2Au);
        }

        sub_10020166C(a1 + 504, &v56);
      }
    }

    unint64_t v43 = (os_log_s *)qword_1008F7620;
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v44 = v56;
      uint64_t v57 = &v56;
      uint64_t v57 = &v56;
      uint64_t v57 = &v56;
      uint64_t v57 = &v56;
      uint64_t v57 = &v56;
      uint64_t v57 = &v56;
      uint64_t v50 = *((_DWORD *)sub_1005BC978((uint64_t **)(a1 + 528), &v56, (uint64_t)&unk_1006C2518, (uint64_t **)&v57) + 13);
      *(_DWORD *)buf = 134219520;
      *(void *)&uint8_t buf[4] = v44;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&_BYTE buf[14] = v45;
      int v61 = 1024;
      id v62 = v46;
      int v63 = 1024;
      int v64 = v47;
      uint64_t v65 = 1024;
      uint32_t v66 = v48;
      uint64_t v67 = 1024;
      char v68 = v49;
      int v69 = 1024;
      BOOL v70 = v50;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "handleConnectionSubratingCompleted: Updated previously stored connection parameters for handle %p. Connection In terval:%d Peripheral latency:%d Supervision Timeout=%d Subrate Factor: %d Continuation Number: %d. Subrating Status set to %d",  buf,  0x30u);
    }

    v58[0] = _NSConcreteStackBlock;
    v58[1] = 3321888768LL;
    v58[2] = sub_1005AF81C;
    v58[3] = &unk_1008A2740;
    v58[4] = a1;
    uuid_copy(v59, uu);
    v58[5] = v56;
    sub_10058C72C((os_unfair_lock_s *)a1, v58);
  }

  return sub_100242FAC((uint64_t)v55);
}

  is_null = uuid_is_null(uu);
  id v17 = (os_log_s *)qword_1008F7620;
  if (is_null)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR)) {
      sub_100699CD8();
    }
  }

  else if (a3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      sub_100366664(uu, out);
      sub_100699D68();
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
    {
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(uu, out);
      sub_10002418C(__p, out);
      size_t v18 = v86 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446466;
      int v88 = v18;
      v89 = 1024;
      v90 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Le link %{public}s is ready with status %{bluetooth:OI_STATUS}u",  buf,  0x12u);
      if (v86 < 0) {
        operator delete(__p[0]);
      }
    }

    buf[0] = 0;
    sub_100242CA4(buf);
    uint64_t v19 = sub_1001B9B58(v76);
    int v72 = sub_1001B9B9C(v76);
    int v71 = sub_1001B9BE0(v76);
    sub_100242CD0(buf);
    id v20 = sub_100241F94(uu);
    id v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    sub_100592364(a1, v21);

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    id v22 = off_1008D5F28;
    unsigned __int8 v23 = sub_100241F94(uu);
    id v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
    sub_1005D21F0((uint64_t)v22, v24, a5);

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    id v25 = off_1008D5F28;
    int v26 = sub_100241F94(uu);
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
    sub_1005D24B4((uint64_t)v25, v27, a6);

    if (qword_1008D5F30 != -1) {
      dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
    }
    uint64_t v28 = off_1008D5F28;
    id v29 = sub_100241F94(uu);
    id v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    sub_1005D25C8((uint64_t)v28, v30, (int)((double)v19 * 1.25));

    id v31 = sub_1002E6BF0();
    if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 736LL))(v31))
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      uint64_t v32 = off_1008D5F28;
      uint64_t v33 = sub_100241F94(uu);
      __int16 v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
      LODWORD(v32) = sub_1005CF88C((uint64_t)v32, v34);

      if ((_DWORD)v32)
      {
        char v35 = sub_100241F94(uu);
        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
        sub_100241F90(out, v36);
        sub_1005B0278(a1, (unsigned __int8 *)out);
      }
    }

    if (v19)
    {
      __int128 v37 = v76;
      *(void *)out = uu;
      sub_1005BC438( (uint64_t **)(a1 + 408),  uu,  (uint64_t)&unk_1006C2518,  (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)out)[6] = v37;
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      int v38 = off_1008D5F28;
      unint64_t v39 = sub_100241F94(uu);
      unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
      sub_1005D3A4C((uint64_t)v38, v40, *(_DWORD *)(v76 + 144));

      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      id v41 = off_1008D5F28;
      __int128 v42 = sub_100241F94(uu);
      unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(v42);
      sub_1005D3C5C((uint64_t)v41, v43);

      unint64_t v44 = sub_1002E6BF0();
      if ((*(unsigned int (**)(uint64_t))(*(void *)v44 + 952LL))(v44))
      {
        uint64_t v45 = *(void **)(a1 + 536);
        if (!v45) {
          goto LABEL_51;
        }
        int v46 = v76;
        int v47 = a1 + 536;
        do
        {
          uint64_t v48 = v45[4];
          id v49 = v48 >= v76;
          if (v48 >= v76) {
            uint64_t v50 = v45;
          }
          else {
            uint64_t v50 = v45 + 1;
          }
          if (v49) {
            int v47 = (uint64_t)v45;
          }
          uint64_t v45 = (void *)*v50;
        }

        while (*v50);
        if (v47 != a1 + 536 && v76 >= *(void *)(v47 + 32))
        {
          uint64_t v53 = *(_WORD *)(v47 + 46);
          int v54 = *(_WORD *)(v47 + 48);
          char v68 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)out = 134217984;
            *(void *)&out[4] = v46;
            _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEFAULT,  "Updated previously stored connection parameters for handle %p.",  (uint8_t *)out,  0xCu);
          }
        }

        else
        {
LABEL_51:
          uint64_t v51 = (os_log_s *)qword_1008F7620;
          if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)out = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "No previously stored connection parameters. Saving new parameters now. Subrate factor & Continuation numbe r initialized to 0.",  (uint8_t *)out,  2u);
          }

          *(void *)out = &v76;
          uint64_t v52 = sub_1005BC978((uint64_t **)(a1 + 528), &v76, (uint64_t)&unk_1006C2518, (uint64_t **)out);
          uint64_t v53 = 0;
          int v54 = 0;
          *((_WORD *)v52 + 20) = v19;
          *((_WORD *)v52 + 21) = v72;
          *((_WORD *)v52 + 22) = v71;
          *(uint64_t *)((char *)v52 + 46) = 0LL;
          *((_WORD *)v52 + 27) = 0;
        }

        uint64_t v55 = *(void **)(a1 + 512);
        if (v55)
        {
          uint64_t v56 = v76;
          uint64_t v57 = a1 + 512;
          do
          {
            uint64_t v58 = v55[4];
            uint64_t v59 = v58 >= v76;
            if (v58 >= v76) {
              uint64_t v60 = v55;
            }
            else {
              uint64_t v60 = v55 + 1;
            }
            if (v59) {
              uint64_t v57 = (uint64_t)v55;
            }
            uint64_t v55 = (void *)*v60;
          }

          while (*v60);
          if (v57 != a1 + 512 && v76 >= *(void *)(v57 + 32))
          {
            int v61 = *(void *)(v57 + 40);
            int v69 = (os_log_s *)qword_1008F7620;
            BOOL v70 = *(unsigned __int16 *)(v57 + 48);
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)out = 67110144;
              *(_DWORD *)&out[4] = WORD1(v61);
              *(_WORD *)&out[8] = 1024;
              *(_DWORD *)&out[10] = WORD2(v61);
              *(_WORD *)&out[14] = 1024;
              *(_DWORD *)&out[16] = (unsigned __int16)v61;
              *(_WORD *)&out[20] = 1024;
              *(_DWORD *)&out[22] = HIWORD(v61);
              *(_WORD *)&out[26] = 1024;
              *(_DWORD *)&out[28] = v70;
              _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "LE Link is now ready. Proceeding with sending connection subrating parameters: subrateMin:%d subrateMax: %d maxLatency:%d continuationNumber=%d supervisionTimeout=%d",  (uint8_t *)out,  0x20u);
              uint64_t v56 = v76;
            }

            id v62 = sub_1005993F4(a1, v56, v61, v70);
            int v63 = (os_log_s *)qword_1008F7620;
            if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)out = 67109120;
              *(_DWORD *)&out[4] = v62;
              _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEFAULT,  "Sent LE Connection Subrating Request with status: %d",  (uint8_t *)out,  8u);
            }
          }
        }
      }

      else
      {
        uint64_t v53 = 0;
        int v54 = 0;
      }

      v77[0] = _NSConcreteStackBlock;
      v77[1] = 3321888768LL;
      v77[2] = sub_1005B02CC;
      v77[3] = &unk_1008A2770;
      uuid_copy(v84, uu);
      int v78 = 0;
      uint64_t v79 = v19;
      __int128 v80 = v72;
      int v81 = v71;
      __n128 v82 = v53;
      uint64_t v83 = v54;
      sub_10058C72C((os_unfair_lock_s *)a1, v77);
    }

    else if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_ERROR))
    {
      sub_100699D3C();
    }

    if (a4)
    {
      if (qword_1008D5F30 != -1) {
        dispatch_once(&qword_1008D5F30, &stru_1008A2B30);
      }
      int v64 = off_1008D5F28;
      uint64_t v65 = sub_100241F94(uu);
      uint32_t v66 = (void *)objc_claimAutoreleasedReturnValue(v65);
      sub_10002418C(v73, "requiresCTOFix");
      sub_1005CCF08((uint64_t)v64, v66, (unsigned __int8 *)v73);
      if (v74 < 0) {
        operator delete(v73[0]);
      }
    }

    sub_100242CD8(buf);
  }

  return sub_100242FAC((uint64_t)v75);
}

  if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_FAULT)) {
    sub_100699DB0();
  }
  if (!uuid_is_null(uu))
  {
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3321888768LL;
    v22[2] = sub_1005B0564;
    v22[3] = &unk_1008A27A0;
    v22[4] = a8;
    uuid_copy(v24, uu);
    void v22[5] = a3;
    v22[6] = a4;
    v22[7] = a5;
    v22[8] = a6;
    unsigned __int8 v23 = a7;
    sub_10058C72C((os_unfair_lock_s *)a1, v22);
  }

  return sub_100242FAC((uint64_t)v21);
}

      objc_autoreleasePoolPop(v5);
      id v9 = (void *)v4[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          id v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          int v10 = (void *)v4[2];
          uint64_t v11 = *v10 == (void)v4;
          uint64_t v4 = v10;
        }

        while (!v11);
      }

      uint64_t v4 = v10;
    }

    while (v10 != (void *)(a1 + 2048));
  }

  sub_1002CD254(v3);
}
}

  if (a3)
  {
    v12[0] = &v11;
    sub_1003A17F0((uint64_t **)(a1 + 104), (unint64_t *)&v11, (uint64_t)&unk_1006C2518, v12)[5] = a3;
  }

  else
  {
    sub_100241F90(v12, v5);
    sub_10064DA6C((uint64_t **)(a1 + 128), (unsigned __int8 *)v12);
  }

  sub_100242FAC((uint64_t)v10);
}

void sub_10005E780(_Unwind_Exception *a1)
{
}

id sub_10005E7C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendSmartRoutingInformation:]_block_invoke",  90LL,  "### SendSmartRoutingInformation failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005EC8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

id sub_10005ECD0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendAudioAccessoryEventMessage:]_block_invoke",  90LL,  "## SendAudioAccessoryEventMessage failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005F05C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_10005F09C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendAudioAccessoryConfigMessage:]_block_invoke",  90LL,  "## SendAudioAccessoryConfigMessage failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005F4B0(_Unwind_Exception *a1)
{
}

id sub_10005F4F0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcSendConversationDetectMessage:]_block_invoke",  90LL,  "### SendConversationDetectMessage failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10005F86C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10005F890(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = objc_alloc(&OBJC_CLASS___CBDeviceIdentity);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id obj = *(id *)(v7 + 40);
  id v8 = [v6 initWithXPCObject:v5 error:&obj];

  objc_storeStrong((id *)(v7 + 40), obj);
  if (v8)
  {
    [*(id *)(a1 + 32) addObject:v8];
  }

  else if (dword_1008D6630 <= 90 {
         && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
  }
  {
    uint64_t v10 = CUPrintNSError(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcUpdateIdentities:]_block_invoke",  90LL,  "### CBDeviceIdentity init failed: index %zu, %@",  a2,  v11);
  }

  return 1LL;
}

void sub_10005FE80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_10005FE98(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = (void *)v1[12];
  if (*(void **)(a1 + 40) == v2)
  {
    id v3 = v2;
    objc_msgSend(v1, "_xpcPowerStateChanged:", objc_msgSend(v1, "_powerStateForClient"));
  }

void *sub_10005FEF8(uint64_t a1, uint64_t a2)
{
  id result = *(void **)(a1 + 32);
  if (*(void *)(a1 + 40) == result[12]) {
    return [result _xpcDeviceFound:a2];
  }
  return result;
}

void *sub_10005FF1C(uint64_t a1, uint64_t a2)
{
  id result = *(void **)(a1 + 32);
  if (*(void *)(a1 + 40) == result[12]) {
    return [result _xpcDeviceLost:a2];
  }
  return result;
}

void *sub_10005FF40(uint64_t a1, uint64_t a2)
{
  id result = *(void **)(a1 + 32);
  if (*(void *)(a1 + 40) == result[12]) {
    return [result _xpcDevicesBuffered:a2];
  }
  return result;
}

void *sub_10005FF64(uint64_t a1)
{
  id result = *(void **)(a1 + 32);
  if (*(void *)(a1 + 40) == result[12]) {
    return [result _xpcSystemOverrideChanged];
  }
  return result;
}

void sub_10005FF84(void *a1, void *a2, void *a3)
{
  id v14 = a2;
  id v5 = a3;
  if ([v5 discoveryTypesContainCBDiscovery:a1[4]])
  {
    id v6 = *(void **)(a1[5] + 128LL);
    if (!v6)
    {
      uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v8 = a1[5];
      id v9 = *(void **)(v8 + 128);
      *(void *)(v8 + 12_Block_object_dispose(va, 8) = v7;

      id v6 = *(void **)(a1[5] + 128LL);
    }

    [v6 setObject:v5 forKeyedSubscript:v14];
    if (!*(void *)(*(void *)(a1[6] + 8LL) + 40LL))
    {
      xpc_object_t v10 = xpc_array_create(0LL, 0LL);
      uint64_t v11 = *(void *)(a1[6] + 8LL);
      uint64_t v12 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v10;
    }

    xpc_object_t v13 = xpc_dictionary_create(0LL, 0LL, 0LL);
    [v5 encodeWithXPCObject:v13];
    xpc_array_append_value(*(xpc_object_t *)(*(void *)(a1[6] + 8LL) + 40LL), v13);
  }
}

void sub_100060380( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100060398(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = (void *)v1[13];
  if (*(void **)(a1 + 40) == v2)
  {
    id v3 = v2;
    objc_msgSend(v1, "_xpcPowerStateChanged:", objc_msgSend(v1, "_powerStateForClient"));
  }

void *sub_1000603F8(uint64_t a1, uint64_t a2)
{
  id result = *(void **)(a1 + 32);
  if (*(void *)(a1 + 40) == result[13]) {
    return [result _xpcDeviceFound:a2];
  }
  return result;
}

void *sub_10006041C(uint64_t a1, uint64_t a2)
{
  id result = *(void **)(a1 + 32);
  if (*(void *)(a1 + 40) == result[13]) {
    return [result _xpcDeviceLost:a2];
  }
  return result;
}

void sub_100060440(void *a1, void *a2, void *a3)
{
  id v14 = a2;
  id v5 = a3;
  if ([v5 discoveryTypesContainCBDiscovery:a1[4]])
  {
    id v6 = *(void **)(a1[5] + 128LL);
    if (!v6)
    {
      uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v8 = a1[5];
      id v9 = *(void **)(v8 + 128);
      *(void *)(v8 + 12_Block_object_dispose(va, 8) = v7;

      id v6 = *(void **)(a1[5] + 128LL);
    }

    [v6 setObject:v5 forKeyedSubscript:v14];
    if (!*(void *)(*(void *)(a1[6] + 8LL) + 40LL))
    {
      xpc_object_t v10 = xpc_array_create(0LL, 0LL);
      uint64_t v11 = *(void *)(a1[6] + 8LL);
      uint64_t v12 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v10;
    }

    xpc_object_t v13 = xpc_dictionary_create(0LL, 0LL, 0LL);
    [v5 encodeWithXPCObject:v13];
    xpc_array_append_value(*(xpc_object_t *)(*(void *)(a1[6] + 8LL) + 40LL), v13);
  }
}

void sub_100060874( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

id sub_1000608B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBDiscoveryFinish:]_block_invoke",  90LL,  "### Discovery Finish failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_10006097C(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  if (dword_1008D6630 <= 30 && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 30LL))) {
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBDiscoveryFinish:]_block_invoke_2",  30,  "Discovery Finish completed: CID 0x%X",  [*(id *)(a1 + 32) clientID]);
  }
  uint64_t Reply = CUXPCDictionaryCreateReply(*(void *)(a1 + 40));
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(Reply);
  if (v7)
  {
    if (v5) {
      CUXPCEncodeNSError(v5, v7, "errO", "errC", "errD", "errM", "errO");
    }
    CUXPCEncodeObject(v7, "dsSm", v8, 0LL);
    [*(id *)(a1 + 48) _xpcSendReply:v7];
  }

  else if (dword_1008D6630 <= 90 {
         && (dword_1008D6630 != -1 || _LogCategory_Initialize(&dword_1008D6630, 90LL)))
  }
  {
    LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBDiscoveryFinish:]_block_invoke_2",  90LL,  "### Discovery Finish create reply failed");
  }
}

void sub_100060D5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_100060D98(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBDiscoveryUpdate:]_block_invoke",  90LL,  "### Discovery Update failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100060FCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

id sub_100061000(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBDiscoveryClearDuplicateFilterCache:]_block_invoke",  90LL,  "### Discovery Clear Duplicates Filter Cache failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100061354( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

id sub_100061390(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBDiscoveryGetDevices:]_block_invoke",  90LL,  "### CBDiscoveryGetDevices failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100061458(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if ((*(void *)(a1 + 40) & (unint64_t)[v5 discoveryFlags]) != 0)
  {
    xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
    [v5 encodeWithXPCObject:v4];
    xpc_array_append_value(*(xpc_object_t *)(a1 + 32), v4);
  }
}

LABEL_49:
  ((void (*)(void *))v7[2])(v7);
  _Block_object_dispose(&v75, 8);
}

  if (*(_BYTE *)(a3 + 54) == 13) {
    uint64_t v52 = dword_1008D6EC8;
  }
  else {
    uint64_t v52 = -1;
  }
  *(_DWORD *)(*(void *)(a3 + 64) + 76LL) = v52;
  if (sub_1000A86F0())
  {
    sub_1001EE134( (uint64_t)"CL registering service ID %d with priority %d and cid 0x%4x. MaxLatency=%d",  v53,  v54,  v55,  v56,  v57,  v58,  v59,  *(unsigned int *)(a3 + 40));
    uint64_t v60 = (os_log_s *)sub_100086554(0x51u);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      int v61 = sub_1001EDDCC();
      *(_DWORD *)buf = 136446210;
      uint64_t v65 = v61;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }

  uint64_t v12 = sub_100187CD4( *(unsigned __int16 *)(*(void *)(a3 + 64) + 4LL),  v24,  *(unsigned __int8 *)(a3 + 54),  (uint64_t)sub_10008D9F8,  (uint64_t *)(*(void *)(a3 + 64) + 96LL),  *(_DWORD *)(*(void *)(a3 + 64) + 76LL));
  if ((_DWORD)v12) {
    goto LABEL_56;
  }
  sub_10018A690(a1);
  return v12;
}

    int v69 = sub_10017AB4C((unsigned int *)a1);
    sub_10017B47C(*(unsigned __int16 **)(v69 + 112));
    BOOL v70 = sub_10017AB4C((unsigned int *)a1);
    sub_10017B47C(*(unsigned __int16 **)(v70 + 112));
    return;
  }

  xpc_object_t v10 = sub_10017AB4C((unsigned int *)a1);
  uint64_t v11 = 4LL;
  if (!*(_BYTE *)(v10 + 78)) {
    uint64_t v11 = 2LL;
  }
  if (v11 > a3)
  {
    if (sub_1000A86F0())
    {
      sub_1001EE134((uint64_t)"Received bad I-Frame packet with length %d", v12, v13, v14, v15, v16, v17, v18, a3);
      uint64_t v19 = (os_log_s *)sub_100086554(0x2Fu);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        sub_100657F74();
      }
    }

    uint64_t v28 = (char *)__p;
    if (!__p) {
      goto LABEL_51;
    }
LABEL_50:
    char v35 = v28;
    operator delete(v28);
    goto LABEL_51;
  }

  return 0LL;
}

      ++v37;
    }

    while (v37 != v36);
LABEL_57:
    if (v38 != v36 && v38 == v35)
    {
      __int128 v42 = 1;
    }

    else
    {
LABEL_60:
      sub_100494958(a2, (uint64_t)buf);
      unint64_t v43 = HIBYTE(v143);
      if (v143 >= 0) {
        unint64_t v44 = buf;
      }
      else {
        unint64_t v44 = *(_BYTE **)buf;
      }
      if (v143 < 0) {
        unint64_t v43 = *(void *)&buf[8];
      }
      uint64_t v45 = 15LL;
      if (v43 < 0xF) {
        uint64_t v45 = v43;
      }
      int v46 = &v44[v45];
      if (v45)
      {
        int v47 = v44;
        uint64_t v48 = &v44[v45];
        do
        {
          if (*v47 == 99)
          {
            id v49 = &_mh_execute_header.magic + 1;
            while (v49 != 15)
            {
              if (&v47[v49] == v46) {
                goto LABEL_79;
              }
              uint64_t v50 = v47[v49];
              uint64_t v51 = aComAppleLeapp[v49++];
              if (v50 != v51) {
                goto LABEL_70;
              }
            }

            uint64_t v48 = v47;
          }

    sub_100242F54((uint64_t)v33);
    if (sub_1003CF350((unsigned __int8 *)a1))
    {
      uint64_t v28 = sub_1002E6D7C();
      (*(void (**)(uint64_t, uint64_t, std::string *))(*(void *)v28 + 216LL))(v28, a1, &__str);
      id v29 = *(void *)(a1 + 520);
      if (v29) {
        (*(void (**)(uint64_t))(*(void *)v29 + 16LL))(v29);
      }
    }

    if (a3)
    {
      if (qword_1008D5F50 != -1) {
        dispatch_once(&qword_1008D5F50, &stru_100895B68);
      }
      sub_1003FFDA4((os_unfair_lock_s *)off_1008D5F48, a1, 4098);
    }

    if (qword_1008D5F50 != -1) {
      dispatch_once(&qword_1008D5F50, &stru_100895B68);
    }
    sub_1003FFDA4((os_unfair_lock_s *)off_1008D5F48, a1, 2);
    if (qword_1008D5F40 != -1) {
      dispatch_once(&qword_1008D5F40, &stru_100895C28);
    }
    sub_1003B243C((uint64_t)off_1008D5F38, a1);
    goto LABEL_61;
  }

  if ((v14 & 0x80) != 0)
  {
  }

  else if (*(_BYTE *)(a1 + 303))
  {
    int v16 = p_str;
    uint64_t v17 = (unsigned __int8 *)(a1 + 280);
    while (*v17 == v16->__r_.__value_.__s.__data_[0])
    {
      ++v17;
      int v16 = (std::string *)((char *)v16 + 1);
      if (!--v14) {
        goto LABEL_64;
      }
    }

    goto LABEL_40;
  }

      if (++v5 == v30) {
        goto LABEL_50;
      }
    }
  }

  if (qword_1008D5F50 != -1) {
    dispatch_once(&qword_1008D5F50, &stru_100896218);
  }
  id v25 = sub_1003FFEB0(off_1008D5F48, (uint64_t)&v32, 0);
  if (v25)
  {
    uint64_t v26 = (os_log_s *)(id)qword_1008F7600;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      sub_1003CF00C((uint64_t)v25, &__p);
      uint64_t v27 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = v27;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Non-paired device nickname being set to empty for %{public}s",  buf,  0xCu);
    }

    sub_10002418C(&__p, "");
    sub_1003D17B0((uint64_t)v25, &__p, 0);
  }

  id v20 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionHomeDisconnectionStageOneToDisabledValue");
  id v21 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v20 + 88LL))(v20, buf, __p, &v86);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v21) {
      goto LABEL_57;
    }
  }

  else if (!v21)
  {
    goto LABEL_57;
  }

  id v22 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v86;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "LeConnectionHomeDisconnectionStageOneToDisabledValue=%d (override)",  buf,  8u);
  }

void sub_100061DD0(_Unwind_Exception *a1)
{
}

id sub_100061E34(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBSpatialInteractionSessionActivate:]_block_invoke",  90LL,  "### Spatial Activate failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100061EFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) == *(void *)(v1 + 112))
  {
    unsigned __int8 v3 = [*(id *)(v1 + 136) supportsNCSecondaryAdvertisingInstance];
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 136) addressMonitor]);
    id v5 = v4;
    if ((v3 & 1) != 0) {
      uint64_t v6 = objc_claimAutoreleasedReturnValue([v4 nonConnectableSecondaryAddressData]);
    }
    else {
      uint64_t v6 = objc_claimAutoreleasedReturnValue([v4 nonConnectableAddressData]);
    }
    id v13 = (id)v6;

    uint64_t v7 = v13;
    if (!v13) {
      goto LABEL_14;
    }
    id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) advertisingAddressData]);
    id v9 = v13;
    id v10 = v8;
    if (v9 == v10)
    {
    }

    else
    {
      uint64_t v11 = v10;
      if (v10)
      {
        unsigned __int8 v12 = [v9 isEqual:v10];

        uint64_t v7 = v13;
        if ((v12 & 1) != 0) {
          goto LABEL_14;
        }
      }

      else
      {
      }

      [*(id *)(a1 + 32) setAdvertisingAddressData:v9];
      [*(id *)(a1 + 40) _xpcAdvertisingAddressChanged];
    }

    uint64_t v7 = v13;
LABEL_14:
  }

void *sub_10006201C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[14]) {
    return [result _xpcSpatialInteractionAOPDataReceived:a2];
  }
  return result;
}

id sub_100062038(id result)
{
  uint64_t v1 = (void *)*((void *)result + 5);
  if (*((void *)result + 4) == v1[14]) {
    return objc_msgSend(v1, "_xpcPowerStateChanged:", objc_msgSend(*((id *)result + 5), "_powerStateForClient"));
  }
  return result;
}

void *sub_10006207C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[14]) {
    return [result _xpcDeviceFound:a2];
  }
  return result;
}

void *sub_100062098(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[14]) {
    return [result _xpcDeviceLost:a2];
  }
  return result;
}

void *sub_1000620B4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[12]) {
    return [result _spatialInteractionDeviceFound:a2 checkOnly:0];
  }
  return result;
}

void *sub_1000620D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v3 == result[12]) {
    return [result _spatialInteractionDeviceLost:a2 removeUnmatched:1 reason:"BLE lost"];
  }
  return result;
}

void sub_1000620FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  if (v2 == *(void *)(v1 + 96))
  {
    if (*(_BYTE *)(v1 + 10))
    {
      [(id)v1 _xpcSystemOverrideChanged];
    }

    else
    {
      uint64_t v3 = *(dispatch_queue_s **)(v1 + 144);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10006217C;
      block[3] = &unk_10087EEC8;
      block[4] = v1;
      dispatch_async(v3, block);
    }
  }

id sub_10006217C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _xpcSystemOverrideChanged];
}

void sub_100062184(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
}

void sub_1000624EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_100062530(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBSpatialInteractionSessionUpdate:]_block_invoke",  90LL,  "### Spatial Update failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100062AC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

id sub_100062B1C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBSpatialInteractionSessionAddPeerToken:]_block_invoke",  90LL,  "### Spatial AddPeerToken failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

void sub_100062BE4(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
}

void sub_10006308C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

id sub_1000630F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id result = *(id *)(*(void *)(v2 + 8) + 40LL);
  if (result)
  {
    if (dword_1008D6630 <= 90)
    {
      if (dword_1008D6630 == -1)
      {
        int v6 = _LogCategory_Initialize(&dword_1008D6630, 90LL);
        uint64_t v2 = *(void *)(a1 + 48);
        if (!v6) {
          return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
        }
        id result = *(id *)(*(void *)(v2 + 8) + 40LL);
      }

      uint64_t v4 = CUPrintNSError(result);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      LogPrintF_safe( &dword_1008D6630,  "-[CBDaemonXPCConnection _xpcCBSpatialInteractionSessionRemovePeerToken:]_block_invoke",  90LL,  "### Spatial RemovePeerToken failed: %@",  v5);

      uint64_t v2 = *(void *)(a1 + 48);
    }

    return [*(id *)(a1 + 32) _xpcSendReplyError:*(void *)(*(void *)(v2 + 8) + 40) request:*(void *)(a1 + 40)];
  }

  return result;
}

LABEL_140:
  if (IsAppleInternalBuild(v127, v128))
  {
    if (v132) {
      v129 = 2;
    }
    else {
      v129 = 1;
    }
    if ((v82 & 1) != 0) {
      v130 = 4LL;
    }
    else {
      v130 = v129;
    }
    v131 = objc_autoreleasePoolPush();
    -[CBDaemonXPCConnection _updateDeviceMapSpatialInteractionDeviceTimestampArrayDictionary:device:]( self,  "_updateDeviceMapSpatialInteractionDeviceTimestampArrayDictionary:device:",  v130,  v154);
    objc_autoreleasePoolPop(v131);
  }

  int v63 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v78 + 4);
  CFDictionarySetValue(v4, @"idVendor", v63);
  CFRelease(v63);
  int v64 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v78);
  CFDictionarySetValue(v4, @"idProduct", v64);
  CFRelease(v64);
  *(void *)&xmmword_1008DE038 = IONotificationPortCreate(v1);
  *((void *)&xmmword_1008DE038 + 1) = IONotificationPortGetRunLoopSource((IONotificationPortRef)xmmword_1008DE038);
  sub_1001EE0E4("[bm3_usb][IOThreadFunc] -- setting gIOThreadInfo.runloop to CFRunLoopGetCurrent()\n");
  qword_1008DE050 = (uint64_t)CFRunLoopGetCurrent();
  CFRunLoopAddSource( (CFRunLoopRef)qword_1008DE050,  *((CFRunLoopSourceRef *)&xmmword_1008DE038 + 1),  kCFRunLoopDefaultMode);
  IOServiceAddMatchingNotification( (IONotificationPortRef)xmmword_1008DE038,  "IOServiceFirstMatch",  v4,  (IOServiceMatchingCallback)sub_1000AB3A0,  0LL,  (io_iterator_t *)&dword_1008DE048);
  pthread_mutex_lock(&stru_1008DE458);
  LODWORD(qword_1008DE05_Block_object_dispose((const void *)(v16 - 160), 8) = 1;
  pthread_cond_signal(&stru_1008DE428);
  pthread_mutex_unlock(&stru_1008DE458);
  sub_1001EE0E4("[bm3_usb][IOThreadFunc] calling CFRunLoopRun()\n");
  CFRunLoopRun();
  return 0LL;
}

  v94 = 0;
  __int128 v73 = sub_1002E6E00();
  sub_10002418C(buf, "LeObserver");
  sub_10002418C(__p, "OverrideContactTracingScanDurationA2DPWifi2GSeconds");
  int v74 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v73 + 88LL))(v73, buf, __p, &v94);
  if (v94) {
    __int128 v75 = v74;
  }
  else {
    __int128 v75 = 0;
  }
  if (v110 < 0) {
    operator delete(__p[0]);
  }
  if (v113 < 0)
  {
    operator delete(*(void **)buf);
    if (!v75) {
      goto LABEL_152;
    }
  }

  else if (!v75)
  {
    goto LABEL_152;
  }

  *(_WORD *)(a1 + 270) = v94;
  int v76 = sub_1002E6E00();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v76 + 176LL))(v76))
  {
    __n128 v77 = (os_log_s *)qword_1008F76C8;
    if (os_log_type_enabled((os_log_t)qword_1008F76C8, OS_LOG_TYPE_DEFAULT))
    {
      int v78 = *(unsigned __int16 *)(a1 + 270);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v78;
      _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_DEFAULT,  "Overriding fContactTracingScanDurationWhileA2DPWifi2G with %d seconds",  buf,  8u);
    }
  }

LABEL_148:
LABEL_149:
LABEL_150:
}

      int v71 = (os_log_s *)qword_1008F75B0;
      if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
      {
        int v72 = &v101;
        if ((v101.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          int v72 = (std::stringbuf::string_type *)v101.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = v72;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s", buf, 0xCu);
      }

      __int128 v73 = (int *)v66[5];
      int v74 = (int *)v66[6];
      while (v73 != v74)
      {
        __int128 v75 = (os_log_s *)qword_1008F75B0;
        if (os_log_type_enabled((os_log_t)qword_1008F75B0, OS_LOG_TYPE_DEFAULT))
        {
          int v76 = *v73;
          __n128 v77 = *((unsigned __int16 *)v73 + 2);
          sub_10056B0A4((uint64_t)(v73 + 2), &v100);
          int v78 = &v100;
          if ((v100.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            int v78 = (std::stringbuf::string_type *)v100.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v76;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v77;
          *(_WORD *)&_BYTE buf[14] = 2082;
          *(void *)&uint8_t buf[16] = v78;
          _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "statedump:       0x%0x @ %d [ %{public}s ]",  buf,  0x18u);
          int v74 = (int *)v66[6];
        }

        v73 += 8;
      }

      uint64_t v79 = (void *)v66[1];
      if (v79)
      {
        do
        {
          __int128 v80 = v79;
          uint64_t v79 = (void *)*v79;
        }

        while (v79);
      }

      else
      {
        do
        {
          __int128 v80 = (void *)v66[2];
          id v20 = *v80 == (void)v66;
          uint32_t v66 = v80;
        }

        while (!v20);
      }

      uint32_t v66 = v80;
    }

    while (v80 != (void *)(a1 + 520));
  }

  return sub_100242FAC((uint64_t)v96);
}

id sub_100064028()
{
  if (qword_1008D9EC8 != -1) {
    dispatch_once(&qword_1008D9EC8, &stru_100880B28);
  }
  return (id)qword_1008D9EC0;
}

void sub_100064890(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
  [v2 timeIntervalSince1970];
  double v4 = v3;

  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [*(id *)(*(void *)(a1 + 32) + 112) clientID]));
  int v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) getSpatialInteractionDeviceTimestampArrayForClientID:v5]);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 lastObject]);
  id v8 = v7;
  if (v7
    && [v7 reason] == *(unsigned __int8 *)(a1 + 48)
    && ([v8 timestamp], v9 * -1000.0 + v4 * 1000.0 < 1500.0))
  {
    objc_msgSend(v8, "setDuplicateCount:", (objc_msgSend(v8, "duplicateCount") + 1));
  }

  else
  {
    id v10 = objc_alloc_init(&OBJC_CLASS___CBSpatialInteractionDeviceTimestampInfo);
    [v10 setTimestamp:v4];
    [v10 setReason:*(unsigned __int8 *)(a1 + 48)];
    [v10 setDuplicateCount:0];
    [v6 addObject:v10];
  }

  [*(id *)(a1 + 40) setSpatialInteractionDeviceTimestampArrayForClientID:v6 clientID:v5];
  uint64_t v11 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) spatialInteractionDeviceTimestampArrayClientIDs]);
  if (v11)
  {
    unsigned __int8 v12 = (void *)v11;
    uint64_t v13 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) spatialInteractionDeviceTimestampArrayDictionary]);
    if (v13)
    {
      id v14 = (void *)v13;
      id v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) spatialInteractionDeviceTimestampArrayClientIDs]);
      id v16 = [v15 count];
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) spatialInteractionDeviceTimestampArrayDictionary]);
      id v18 = [v17 count];

      if (v16 == v18) {
        goto LABEL_16;
      }
    }

    else
    {
    }
  }

  id v19 = sub_100064028();
  id v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
    sub_1006577FC(v20);
  }

  [*(id *)(a1 + 40) setSpatialInteractionDeviceTimestampArrayDictionary:0];
  [*(id *)(a1 + 40) setSpatialInteractionDeviceTimestampArrayClientIDs:0];
LABEL_16:
}

void *sub_1000655D0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id result = *(void **)(a1 + 40);
  if (v2 == result[7]) {
    return [result _whbTimerFired];
  }
  return result;
}

void sub_100065B18(id a1)
{
  os_log_t v1 = os_log_create("com.apple.bluetooth", "CBDaemonXPCConnection");
  uint64_t v2 = (void *)qword_1008D9EC0;
  qword_1008D9EC0 = (uint64_t)v1;
}

void sub_100065B48( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void sub_100066024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10006677C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

void sub_100066C3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22)
{
  v23[2](v23);
  _Block_object_dispose(&a22, 8);

  _Unwind_Resume(a1);
}

uint64_t sub_100066CDC(uint64_t result)
{
  if (*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL))
  {
    uint64_t v1 = result;
    if (dword_1008D66A0 <= 90
      && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 90LL)))
    {
      LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack addDiscoverableController:error:]_block_invoke",  90LL,  "### addDiscoverableController failed");
    }

    if (qword_1008D61A8 != -1) {
      dispatch_once(&qword_1008D61A8, &stru_1008810A8);
    }
    return sub_1004966BC(qword_1008D61A0, *(void *)(*(void *)(*(void *)(v1 + 32) + 8LL) + 24LL));
  }

  return result;
}

void sub_100066ED4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
}

void sub_100067380(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 48);
  id v11 = 0LL;
  [v2 setLowPowerModeWithReason:v3 error:&v11];
  id v4 = v11;
  id v5 = *(void **)(a1 + 40);
  int v6 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 112LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100067428;
  block[3] = &unk_100880C58;
  id v9 = v4;
  id v10 = v5;
  id v7 = v4;
  dispatch_async(v6, block);
}

uint64_t sub_100067428(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

LABEL_25:
    id v18 = 0;
    goto LABEL_19;
  }

  if (qword_1008D6798 != -1) {
    dispatch_once(&qword_1008D6798, &stru_100881168);
  }
  sub_1001F7734(qword_1008D6790);
  if (qword_1008D6798 != -1) {
    dispatch_once(&qword_1008D6798, &stru_100881168);
  }
  id v10 = sub_1001F813C(qword_1008D6790, v5);
  if (qword_1008D6798 != -1) {
    dispatch_once(&qword_1008D6798, &stru_100881168);
  }
  sub_1001F780C(qword_1008D6790);
  if (v10) {
    id v11 = (v10 + 310000);
  }
  else {
    id v11 = 0LL;
  }
  unsigned __int8 v12 = sub_1000B05D8() - v6;
  if (dword_1008D66A0 <= 30 && (dword_1008D66A0 != -1 || _LogCategory_Initialize(&dword_1008D66A0, 30LL))) {
    LogPrintF_safe( &dword_1008D66A0,  "-[CBStackControllerBTStack setLowPowerModeWithReason:error:]",  30LL,  "LPM entry took %llums",  v12);
  }
  dispatch_source_cancel(v7);
  if (v12 >> 3 <= 0x464)
  {
    v24[0] = @"errorCode";
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v11));
    v25[0] = v13;
    v24[1] = @"errorCount";
    id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (_DWORD)v11 != 0));
    v25[1] = v14;
    v24[2] = @"timeToEnter";
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v12));
    v25[2] = v15;
    id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v25,  v24,  3LL));

    uint64_t v17 = sub_1002E8D94();
    (*(void (**)(uint64_t, void *))(*(void *)v17 + 216LL))(v17, v16);
  }

  if ((_DWORD)v11)
  {
    if (a4)
    {
      id v22 = CBErrorF(v11, "enterLPM failed");
      id v21 = (void *)objc_claimAutoreleasedReturnValue(v22);
      goto LABEL_24;
    }

    goto LABEL_25;
  }

  id v18 = 1;
LABEL_19:

  return v18;
}
    }
  }

  ((void (*)(void *))v45[2])(v45);

  _Block_object_dispose(&v59, 8);
}

    if (HIDWORD(v28) && HIDWORD(v28) == *(unsigned __int16 *)(a1 + 24))
    {
      sub_10007BEB8((uint64_t)&v29, v28, (unsigned __int8 *)a1);
      if (!(_DWORD)v16) {
        return;
      }
      sub_10007C6E0( v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v27,  SWORD2(v27),  SBYTE6(v27),  SHIBYTE(v27),  v28,  HIDWORD(v28),  v29);
      if (!v24) {
        return;
      }
      id v25 = *(_BYTE **)(a1 + 48);
      if (v25) {
        *id v25 = 0;
      }
    }

    sub_10007B1BC((_WORD *)a1);
    if ((v26 & 1) == 0) {
      return;
    }
  }

  id v11 = **(void **)(a1 + 40);
  if (!v11) {
    goto LABEL_25;
  }
  while (1)
  {
    sub_10007B16C(v31, (void *)v11);
    if (v12)
    {
      *(_BYTE *)(v11 + 24) = 0;
    }

    id v11 = *(void *)(v11 + 16);
    if (!v11) {
      goto LABEL_25;
    }
  }

      sub_1001EE0E4("PCIe default packet type: 0x%x\n", a1);
      off_1008D9F20("PCIe bad packet type", 1LL);
      return 101LL;
    }

    int v6 = sub_10007DCB4;
    id v7 = 3;
    id v8 = &qword_1008D9F08;
    id v9 = &qword_1008D9F38;
  }

  if ((int)v10 > 112)
  {
    if ((int)v10 > 144)
    {
      if ((_DWORD)v10 == 145)
      {
        sub_100096D08((uint64_t)a1, (uint64_t)&a2[v11], (unsigned __int16)v9, a4);
        return;
      }
    }

    else
    {
      switch((_DWORD)v10)
      {
        case 0x71:
          sub_100096810((uint64_t)a1, (uint64_t)&a2[v11], (unsigned __int16)v9);
          return;
        case 0x72:
          sub_100096A0C((uint64_t)a1, (double *)&a2[v11], (unsigned __int16)v9);
          return;
        case 0x90:
          sub_100096E50(a1, &a2[v11], (unsigned __int16)v9);
          return;
      }
    }

    byte_1008DDCD8 = *((_BYTE *)&word_1008DDCE0 + v14);
    qword_1008DDCB8 = qword_1008DDCE8[v14];
    qword_1008DDCC0 = qword_1008DDCB8;
    word_1008DDCD0 = v3;
    *((_WORD *)&dword_1008DDCDC + v14) = 0;
    goto LABEL_26;
  }

  id v16 = 0LL;
  uint64_t v17 = 1;
  do
  {
    id v18 = *((unsigned __int16 *)&dword_1008DDCDC + v16);
    if ((v17 & 1) == 0) {
      break;
    }
    uint64_t v17 = 0;
    id v16 = 1LL;
  }

  while (!v18);
  if (v18 && sub_100098FB4(0))
  {
    id v14 = 0LL;
    LOBYTE(v3) = 1;
    while (1)
    {
      id v19 = v3;
      uint64_t v3 = *((unsigned __int16 *)&dword_1008DDCDC + v14);
      if (*((_WORD *)&dword_1008DDCDC + v14)) {
        goto LABEL_25;
      }
      id v14 = 1LL;
      if ((v19 & 1) == 0)
      {
LABEL_23:
        uint64_t v3 = (unsigned __int16)word_1008DDCD0;
        if (word_1008DDCD0) {
          goto LABEL_26;
        }
        return;
      }
    }
  }

  if (*(void *)qword_1008E1E90)
  {
    sub_1000B1838(*(void **)qword_1008E1E90);
    *(void *)qword_1008E1E90 = 0LL;
  }

  sub_10017A8B8(17);
  sub_10017A8B8(19);
  if (qword_1008E1E90)
  {
    sub_1000B1838((void *)qword_1008E1E90);
    qword_1008E1E90 = 0LL;
  }

  return v3;
}

  if (a3 == 2 && (_DWORD)a4 && v10 && v8 && ((a4 - 702) > 8 || ((1 << (a4 + 66)) & 0x1C1) == 0))
  {
    sub_10011A1AC(0LL, v7, 0, a4);
    return;
  }

  if ((_DWORD)a4 && v10)
  {
    if (dword_1008E2244)
    {
      sub_1001EEB14(dword_1008E2244);
      dword_1008E2244 = 0;
    }

    uint64_t v13 = sub_10010CAA4(v7, 0x13u);
    if ((_DWORD)v13)
    {
      id v14 = v13;
      if (sub_1000A86F0())
      {
        sub_1001EE134((uint64_t)"OI_LP_DisconnectReq failed: %! (%d)", v15, v16, v17, v18, v19, v20, v21, v14);
        id v22 = (os_log_s *)sub_100086554(0x3Eu);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          sub_100657858();
          if (!v10) {
            goto LABEL_52;
          }
          goto LABEL_49;
        }
      }
    }

    sub_10011DC18((__int128 *)a1, 8, (char *)v6);
    return;
  }

  if (sub_1000A86F0())
  {
    sub_1001EE134((uint64_t)"We were not expecting address info...", v7, v8, v9, v10, v11, v12, v13, v99);
    id v14 = (os_log_s *)sub_100086554(0x43u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      sub_100657858();
    }
  }

          *id v10 = v12;
LABEL_5:
          ++v8;
          ++v10;
          if (v8 >= a3[4]) {
            goto LABEL_27;
          }
          break;
        case 's':
          *(_DWORD *)id v10 = a1;
          goto LABEL_5;
        default:
          goto LABEL_5;
      }
    }
  }

  byte_1008E8964 = 0;
  if (!v2) {
    sub_1001B8EFC(v1);
  }
}

        id v20 = (os_log_s *)qword_1008F7730;
        if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
          sub_10065DB64(v5, v20, v21, v22, v23, v24, v25, v26);
        }
        return;
      }

      uint64_t v17 = (v5 - 144);
      if (v17 <= 0x36)
      {
        if (v17 == 48)
        {
          id v18 = -14;
          goto LABEL_28;
        }
      }

      if ((_DWORD)v5 != 224) {
        goto LABEL_25;
      }
LABEL_15:
      id v18 = -16;
LABEL_28:
      buf[0] = v18;
      if (sub_1001FEC98(v7, buf))
      {
        uint64_t v36 = v18;
        *(void *)buf = &v36;
        uint64_t v27 = (__IOHIDUserDevice *)sub_1001FED4C((uint64_t)v7, &v36, (uint64_t)&unk_1006C2518, (_BYTE **)buf)[3];
        if (v27)
        {
          uint64_t v28 = mach_absolute_time();
          IOHIDUserDeviceHandleReportWithTimeStamp(v27, v28, a2, a3);
          return;
        }
      }

      goto LABEL_31;
    }

    id v10 = (os_log_s *)qword_1008F7730;
    if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR)) {
      sub_10065DAFC(v5, v10, v11, v12, v13, v14, v15, v16);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008F7730, OS_LOG_TYPE_ERROR))
  {
    sub_10065DAD0();
  }

                *(void *)buf = v11;
                *(_WORD *)&uint8_t buf[8] = v9;
                *(void *)&uint64_t v83 = 0LL;
                WORD4(v83) = 0;
                int v74 = 0;
                uint64_t v17 = sub_100242CA4(&v74);
                if ((_WORD)v9)
                {
                  id v18 = 0LL;
                  id v19 = 0LL;
                  while (1)
                  {
                    id v20 = &v11[24 * v18];
                    if (*(_WORD *)v20 == 1)
                    {
                      int v72 = *(_OWORD *)v20;
                      __int128 v73 = *((void *)v20 + 2);
                      id v21 = sub_100212350((uint64_t)v17, (uint64_t)&v72);
                      id v22 = (void *)objc_claimAutoreleasedReturnValue(v21);

                      if (![v22 count])
                      {
                        if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                          sub_10065F274();
                        }
                        uint64_t v28 = 0LL;
                        id v19 = v22;
                        goto LABEL_87;
                      }

                      BOOL v70 = 0u;
                      int v71 = 0u;
                      char v68 = 0u;
                      int v69 = 0u;
                      id v19 = v22;
                      unsigned __int8 v23 = [v19 countByEnumeratingWithState:&v68 objects:v81 count:16];
                      if (v23)
                      {
                        id v24 = *(void *)v69;
                        while (2)
                        {
                          for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
                          {
                            if (*(void *)v69 != v24) {
                              objc_enumerationMutation(v19);
                            }
                            uint64_t v26 = *(void **)(*((void *)&v68 + 1) + 8LL * (void)i);
                            if ((unint64_t)[v26 length] > 4)
                            {
                              id v31 = (os_log_s *)qword_1008F75F0;
                              if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                                sub_10065F31C(&v66, v67, v31);
                              }
                            }

                            else
                            {
                              *(_WORD *)int v78 = 0;
                              uint64_t v27 = v26;
                              uint64_t v28 = sub_1001DF1BC(*(_DWORD *)[v27 bytes], v78);
                              id v29 = (os_log_s *)qword_1008F75F0;
                              id v30 = os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR);
                              if ((_DWORD)v28)
                              {
                                if (v30) {
                                  sub_10065F2A0();
                                }

                                goto LABEL_87;
                              }

                              if (v30)
                              {
                                LODWORD(v80) = 138412290;
                                *(void *)((char *)&v80 + 4) = v27;
                                _os_log_error_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "New service being added for %@",  (uint8_t *)&v80,  0xCu);
                              }
                            }
                          }

                          unsigned __int8 v23 = [v19 countByEnumeratingWithState:&v68 objects:v81 count:16];
                          if (v23) {
                            continue;
                          }
                          break;
                        }
                      }
                    }
                  }
                }

                id v19 = 0LL;
LABEL_63:
                unint64_t v40 = sub_1001E139C((uint64_t)buf, (int *)&v75);
                sub_100242CD0(&v74);
                id v41 = (os_log_s *)qword_1008F75F0;
                if (v40)
                {
                  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                    sub_10065F214();
                  }
                }

                else
                {
                  if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(v80) = 67109120;
                    DWORD1(v80) = v75;
                    _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "addServiceDataToLocalSDP: SRH 0x%X",  (uint8_t *)&v80,  8u);
                  }

                  __int128 v80 = 0uLL;
                  sub_100242F28((uint64_t)&v80, a1 + 216);
                  int v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
                  if ((_WORD)v9)
                  {
                    __int128 v42 = (unsigned __int16)v9;
                    unint64_t v43 = (uint64_t)(v11 + 8);
                    do
                    {
                      unint64_t v44 = *(unsigned __int16 *)(v43 - 8);
                      if (v44 == 13 || v44 == 4)
                      {
                        int v46 = sub_1002124B4(a1, v43);
                        if ((_DWORD)v46)
                        {
                          int v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  v46));
                          uint64_t v48 = [v61 containsObject:v47];

                          if ((v48 & 1) == 0)
                          {
                            id v49 = (os_log_s *)qword_1008F75F0;
                            if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_DEFAULT))
                            {
                              *(_DWORD *)int v78 = 67109120;
                              uint64_t v79 = v46;
                              _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "addServiceDataToLocalSDP: publishing PSM %d",  v78,  8u);
                            }

                            uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  v46));
                            [v61 addObject:v50];

                            if (v19)
                            {
                              uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v19 firstObject]);
                              uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  v46));
                              uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithObject:forKey:",  v58,  v51));
                              uint64_t v53 = *(void **)(a1 + 280);
                              int v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v75));
                              [v53 setObject:v52 forKeyedSubscript:v54];
                            }

                            else
                            {
                              uint64_t v55 = (os_log_s *)qword_1008F75F0;
                              if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                                sub_10065F1E0(&v64, v65, v55);
                              }
                            }

                            uint64_t v56 = sub_100404FE8();
                            v62[0] = _NSConcreteStackBlock;
                            v62[1] = 3221225472LL;
                            v62[2] = sub_100212590;
                            v62[3] = &unk_1008878D8;
                            v62[4] = a1;
                            int v63 = v46;
                            sub_1004054B4(v56, v62);
                          }
                        }
                      }

                      v43 += 24LL;
                      --v42;
                    }

                    while (v42);
                  }

                  sub_100242FAC((uint64_t)&v80);
                }

                uint64_t v28 = v75;
LABEL_87:

                sub_100242CD8(&v74);
              }

              else
              {
                if (os_log_type_enabled((os_log_t)qword_1008F75F0, OS_LOG_TYPE_ERROR)) {
                  sub_10065F1B4();
                }
                uint64_t v28 = 0LL;
              }

              id v4 = v59;
              goto LABEL_89;
            }

            id v7 = "ByteStream_NumReadBytesAvail(byteStreamData) >= 2";
            id v8 = 1530;
          }

  if (v4)
  {
    uint64_t v17 = v4;
    operator delete(v4);
  }

      id v8 = (void *)v4[1];
      if (v8)
      {
        do
        {
          id v9 = v8;
          id v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          id v9 = (void *)v4[2];
          id v10 = *v9 == (void)v4;
          id v4 = v9;
        }

        while (!v10);
      }

      id v4 = v9;
    }

    while (v9 != v3);
  }

  return 0LL;
}

  unsigned __int8 v12 = (os_log_s *)qword_1008F75E0;
  if (os_log_type_enabled((os_log_t)qword_1008F75E0, OS_LOG_TYPE_ERROR))
  {
    sub_100532EFC(a3, __dst);
    sub_10066C4CC((uint64_t)__dst, buf, v12);
  }

  uint64_t v13 = 159LL;
LABEL_28:
  if (v23) {
    sub_1002CD254(v23);
  }
  return v13;
}

          std::string::assign(&buf, v18);
          goto LABEL_26;
        }
      }

      else if (v11 == 8)
      {
        unsigned __int8 v12 = *(unsigned int *)(a1 + 344);
        if ((_DWORD)v12)
        {
          uint64_t v13 = 0LL;
          id v14 = 0LL;
          id v15 = *(void *)(a1 + 360);
          do
          {
            if (*(_DWORD *)(v15 + v13 + 4) == a4)
            {
              id v16 = (os_log_s *)qword_1008F7558;
              id v8 = os_log_type_enabled((os_log_t)qword_1008F7558, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v8)
              {
                LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
                HIDWORD(buf.__r_.__value_.__r.__words[0]) = a4;
                _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Remote endpoint supports delay reporting (SEID %d)",  (uint8_t *)&buf,  8u);
                id v15 = *(void *)(a1 + 360);
                unsigned __int8 v12 = *(unsigned int *)(a1 + 344);
              }

              *(_BYTE *)(v15 + v13 + 24) = 1;
            }

            ++v14;
            v13 += 32LL;
          }

          while (v14 < v12);
        }
      }

  _Block_object_dispose(v16, 8);
}

  _Block_object_dispose(v16, 8);
}

  _Block_object_dispose(&v27, 8);
}

  _Block_object_dispose(v16, 8);
}

  _Block_object_dispose(&v41, 8);
}

  _Block_object_dispose(&v33, 8);
}

  _Block_object_dispose(v33, 8);

  _Block_object_dispose(&v36, 8);
}

  _Block_object_dispose(&v31, 8);
}

  _Block_object_dispose(&v17, 8);
}

  id v30 = &off_10087FAA8;
  if (v31) {
    sub_1002CD254(v31);
  }
  _Block_object_dispose(&v32, 8);
}

        xpc_object_t reply = xpc_dictionary_create_reply(xdict);
        uint64_t v53 = reply;
        if (reply)
        {
          xpc_dictionary_set_int64(reply, "kCBLePowerControlCmd", v32);
          xpc_dictionary_set_int64(v53, "kCBMsgArgResult", v31);
          if (v32 == 246)
          {
            xpc_dictionary_set_int64(v53, "kCBMsgArgConnHandle", (unsigned __int16)value);
            xpc_dictionary_set_int64(v53, "kCBMsgArgReason", BYTE3(value));
            xpc_dictionary_set_int64(v53, "kCBMsgArgPHY", BYTE4(value));
            xpc_dictionary_set_int64(v53, "kCBMsgArgTransmitPowerLevel", SBYTE5(value));
            xpc_dictionary_set_int64(v53, "kCBMsgArgTransmitPowerFlag", BYTE6(value));
            int v54 = SHIBYTE(value);
            uint64_t v55 = "kCBMsgArgDelta";
          }

          else
          {
            if (v32 != 245)
            {
LABEL_34:
              xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), v53);
              xpc_release(v53);
              goto LABEL_35;
            }

            xpc_dictionary_set_int64(v53, "kCBMsgArgConnHandle", word_1008F7550);
            xpc_dictionary_set_int64(v53, "kCBMsgArgCurrentTxPowerLevel", byte_1008F7553);
            int v54 = byte_1008F7554;
            uint64_t v55 = "kCBMsgArgMaxTxPowerLevel";
          }

          xpc_dictionary_set_int64(v53, v55, v54);
          goto LABEL_34;
        }

          id v16 = v13;
          goto LABEL_32;
        }

        if (v13 != 2) {
          goto LABEL_25;
        }
      }

      else
      {
        if (v15 == 1)
        {
          id v16 = v13 - 7;
          if (v13 >= 7)
          {
            id v20 = sub_10040F7FC(a2);
            sub_10040F7FC(a2);
            id v21 = sub_10040F7FC(a2);
            sub_10040F7B0(a2);
            buf[0] = 0;
            sub_100242CA4(buf);
            if (sub_100171EC4(a4, (uint64_t *)&v34) || !sub_10017AB4C(v34))
            {
              id v22 = (os_log_s *)qword_1008F75D0;
              if (os_log_type_enabled((os_log_t)qword_1008F75D0, OS_LOG_TYPE_ERROR)) {
                sub_10068F46C(&v32, v33, v22);
              }
            }

            else
            {
              *(_WORD *)(sub_10017AB4C(v34) + _Block_object_dispose((const void *)(v16 - 160), 8) = v20;
              *(_WORD *)(sub_10017AB4C(v34) + 32) = v21;
              id v25 = sub_10017AB4C(v34);
              sub_1000D7738(a4, *(_WORD *)(v25 + 36), v21);
              uint64_t v26 = sub_10017AB4C(v34);
              id v11 = sub_1000E7018((int *)(v26 + 10));
            }

            goto LABEL_31;
          }

          goto LABEL_25;
        }

        if (v15 != 3) {
          goto LABEL_23;
        }
        if (v13 != 2) {
          goto LABEL_25;
        }
      }

      sub_10040F7FC(a2);
LABEL_36:
      id v9 = (__int16)v14 - v13;
      id v10 = v9 << 16;
    }
  }

  return 0LL;
}

  id v11 = sub_1002E6E00();
  sub_10002418C(buf, "CONNECTION");
  sub_10002418C(__p, "LeConnectionDCKTimeDurationFromStageOneToDisabledValue");
  unsigned __int8 v12 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(void *)v11 + 88LL))(v11, buf, __p, &v89);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  if (v94 < 0)
  {
    operator delete(*(void **)buf);
    if (!v12) {
      goto LABEL_33;
    }
  }

  else if (!v12)
  {
    goto LABEL_33;
  }

  uint64_t v13 = (os_log_s *)qword_1008F7620;
  if (os_log_type_enabled((os_log_t)qword_1008F7620, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v89;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "LeConnectionDCKTimeDurationFromStageOneToDisabledValue=%d (override)",  buf,  8u);
  }

        v8 += 96LL;
        if (v8 == *(void *)&__dst[8]) {
          uint64_t v17 = 1;
        }
        else {
          uint64_t v17 = (char)v11;
        }
      }

      while ((v17 & 1) == 0);
    }

    id v18 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
    {
      unsigned __int8 v23 = sub_1006103C4((void *)(*(void *)(v163 + 8) + 208LL));
      sub_100494958(v6[4], (uint64_t)__p);
      id v24 = __p;
      if (v217 < 0) {
        id v24 = *(_BYTE **)__p;
      }
      *(_DWORD *)buf = 134218242;
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&_BYTE buf[14] = v24;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "bypassFilterDuplicateTable 0x%0256llx  %{public}s",  buf,  0x16u);
      if (v217 < 0) {
        operator delete(*(void **)__p);
      }
    }

    *(void *)__p = __dst;
    sub_100050E64((void ***)__p);
    id v19 = (void *)v6[1];
    if (v19)
    {
      do
      {
        id v20 = v19;
        id v19 = (void *)*v19;
      }

      while (v19);
    }

    else
    {
      do
      {
        id v20 = (void *)v6[2];
        id v21 = *v20 == (void)v6;
        int v6 = v20;
      }

      while (!v21);
    }

    if (v20 == v166) {
      id v22 = 1;
    }
    else {
      id v22 = (char)v11;
    }
    int v6 = v20;
  }

  while ((v22 & 1) == 0);
  if ((v11 & 1) == 0)
  {
LABEL_233:
    if (!v149 || v148[85])
    {
      id v25 = v196;
      if (v196 != (uint64_t *)&v197)
      {
        do
        {
          uint64_t v26 = sub_1002E6E9C();
          (*(void (**)(uint64_t, uint64_t))(*(void *)v26 + 760LL))(v26, v25[4]);
          uint64_t v27 = (uint64_t *)v25[1];
          if (v27)
          {
            do
            {
              uint64_t v28 = v27;
              uint64_t v27 = (uint64_t *)*v27;
            }

            while (v27);
          }

          else
          {
            do
            {
              uint64_t v28 = (uint64_t *)v25[2];
              id v21 = *v28 == (void)v25;
              id v25 = v28;
            }

            while (!v21);
          }

          id v25 = v28;
        }

        while (v28 != (uint64_t *)&v197);
      }
    }

    v164 = 0;
  }

  else
  {
    v164 = 1;
  }

  id v29 = *(void **)(a1 + 2040);
  if (v29 != v166)
  {
    do
    {
      id v30 = v29[5];
      if (!sub_100617C84(v30)) {
        goto LABEL_160;
      }
      id v31 = *(unsigned __int8 *)(v30 + 81);
      if (v31 > 0x20) {
        goto LABEL_160;
      }
      if (((1LL << v31) & 0x114) != 0)
      {
        if (!sub_100610CCC(v30)) {
          goto LABEL_160;
        }
        if (!*(_BYTE *)(v30 + 224)) {
          goto LABEL_160;
        }
        uint64_t v32 = (uint64_t *)sub_100610E3C(v30);
        uint64_t v33 = *v32;
        __int16 v34 = v32[1];
        if (*v32 == v34) {
          goto LABEL_160;
        }
        char v35 = 0;
        while (1)
        {
          uint64_t v36 = *(void *)(v30 + 8);
          if (*(_BYTE *)(v36 + 143) && !*(void *)(a1 + 2344))
          {
            int v46 = (os_log_s *)qword_1008F76D8;
            if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_DEFAULT))
            {
              sub_1006344B4(v33, __dst);
              int v47 = __dst;
              if ((__dst[23] & 0x80u) != 0) {
                int v47 = *(uint8_t **)__dst;
              }
              *(_DWORD *)__p = 136446210;
              *(void *)&__p[4] = v47;
              _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "skipping adding %{public}s to filters",  __p,  0xCu);
            }
          }

          else
          {
            if (*(unsigned __int8 *)(v36 + 203) < ++v35)
            {
              int v64 = (os_log_s *)qword_1008F75B8;
              if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
              {
                sub_100494958(v29[4], (uint64_t)__p);
                uint64_t v65 = v217;
                uint32_t v66 = *(_BYTE **)__p;
                uint64_t v67 = (void *)sub_100610E3C(v30);
                char v68 = __p;
                if (v65 < 0) {
                  char v68 = v66;
                }
                int v69 = (uint64_t)(v67[1] - *v67) >> 2;
                *(_DWORD *)__dst = 136446722;
                *(void *)&__dst[4] = v68;
                *(_WORD *)&__dst[12] = 1024;
                *(_DWORD *)&__dst[14] = v35;
                *(_WORD *)&__dst[18] = 2048;
                *(void *)&__dst[20] = 0xCCCCCCCCCCCCCCCDLL * v69;
                _os_log_error_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_ERROR,  "%{public}s asked to scan for more than %d (%ld) UUID's.",  __dst,  0x1Cu);
                if (v217 < 0) {
                  operator delete(*(void **)__p);
                }
              }

              goto LABEL_160;
            }

            __int128 v37 = *(_OWORD *)v33;
            v210 = *(_DWORD *)(v33 + 16);
            v209 = v37;
            int v38 = sub_100610E48(v30, (unsigned __int8 *)&v209);
            unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
            unint64_t v40 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
            {
              sub_1006344B4(v33, __dst);
              id v41 = __dst;
              if ((__dst[23] & 0x80u) != 0) {
                id v41 = *(uint8_t **)__dst;
              }
              *(_DWORD *)__p = 136315394;
              *(void *)&__p[4] = v41;
              *(_WORD *)&__p[12] = 2112;
              *(void *)&__p[14] = v39;
              _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_INFO,  "addFilters aUUID:%s enhancedRules:%@",  __p,  0x16u);
            }

            if ([v39 count])
            {
              v180 = 0u;
              v181 = 0u;
              v178 = 0u;
              v179 = 0u;
              __int128 v42 = v39;
              unint64_t v43 = [v42 countByEnumeratingWithState:&v178 objects:v208 count:16];
              if (v43)
              {
                unint64_t v44 = *(void *)v179;
                do
                {
                  for (uint64_t i = 0LL; i != v43; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v179 != v44) {
                      objc_enumerationMutation(v42);
                    }
                    sub_1005FD1A4(a1, *(void **)(*((void *)&v178 + 1) + 8LL * (void)i));
                  }

                  unint64_t v43 = [v42 countByEnumeratingWithState:&v178 objects:v208 count:16];
                }

                while (v43);
              }
            }

            else
            {
              sub_10038CF98(&v199, (unsigned __int8 *)v33, v33);
            }
          }

          v33 += 20LL;
          if (v33 == v34) {
            goto LABEL_160;
          }
        }
      }

      if (((1LL << v31) & 0x100010000LL) == 0) {
        goto LABEL_160;
      }
      *(_BYTE *)(a1 + 1849) |= sub_100610D74(v30);
      *(_BYTE *)(a1 + 1850) |= sub_100610D98(v30);
      if (!sub_100610DB8(v30))
      {
        if (*(_BYTE *)(v30 + 224))
        {
          uint64_t v48 = (uint64_t *)sub_100610E3C(v30);
          id v49 = *v48;
          uint64_t v50 = v48[1];
          if (*v48 != v50)
          {
            uint64_t v51 = 0;
            do
            {
              uint64_t v52 = *(void *)(v30 + 8);
              if (*(_BYTE *)(v52 + 143) && !*(void *)(a1 + 2344))
              {
                id v62 = (os_log_s *)qword_1008F76D8;
                if (os_log_type_enabled((os_log_t)qword_1008F76D8, OS_LOG_TYPE_INFO))
                {
                  sub_1006344B4(v49, __dst);
                  int v63 = __dst;
                  if ((__dst[23] & 0x80u) != 0) {
                    int v63 = *(uint8_t **)__dst;
                  }
                  *(_DWORD *)__p = 136446210;
                  *(void *)&__p[4] = v63;
                  _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_INFO,  "skipping adding %{public}s to filters",  __p,  0xCu);
                }
              }

              else
              {
                if (*(unsigned __int8 *)(v52 + 203) < ++v51)
                {
                  BOOL v70 = (os_log_s *)qword_1008F75B8;
                  if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
                  {
                    sub_100494958(v29[4], (uint64_t)__p);
                    int v71 = v217;
                    int v72 = *(_BYTE **)__p;
                    __int128 v73 = (void *)sub_100610E3C(v30);
                    int v74 = __p;
                    if (v71 < 0) {
                      int v74 = v72;
                    }
                    __int128 v75 = (uint64_t)(v73[1] - *v73) >> 2;
                    *(_DWORD *)__dst = 136446722;
                    *(void *)&__dst[4] = v74;
                    *(_WORD *)&__dst[12] = 1024;
                    *(_DWORD *)&__dst[14] = v51;
                    *(_WORD *)&__dst[18] = 2048;
                    *(void *)&__dst[20] = 0xCCCCCCCCCCCCCCCDLL * v75;
                    _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_INFO,  "%{public}s asked to scan for more than %d (%ld) UUID's.",  __dst,  0x1Cu);
                    if (v217 < 0) {
                      operator delete(*(void **)__p);
                    }
                  }

                  break;
                }

                uint64_t v53 = *(_OWORD *)v49;
                v214 = *(_DWORD *)(v49 + 16);
                v213 = v53;
                int v54 = sub_100610E48(v30, (unsigned __int8 *)&v213);
                uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
                uint64_t v56 = (os_log_s *)qword_1008F75B8;
                if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_INFO))
                {
                  sub_1006344B4(v49, __dst);
                  uint64_t v57 = __dst;
                  if ((__dst[23] & 0x80u) != 0) {
                    uint64_t v57 = *(uint8_t **)__dst;
                  }
                  *(_DWORD *)__p = 136315394;
                  *(void *)&__p[4] = v57;
                  *(_WORD *)&__p[12] = 2112;
                  *(void *)&__p[14] = v55;
                  _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_INFO,  "addFilters aUUID:%s enhancedRules:%@",  __p,  0x16u);
                }

                if ([v55 count])
                {
                  v188 = 0u;
                  v189 = 0u;
                  v186 = 0u;
                  v187 = 0u;
                  uint64_t v58 = v55;
                  uint64_t v59 = [v58 countByEnumeratingWithState:&v186 objects:v212 count:16];
                  if (v59)
                  {
                    uint64_t v60 = *(void *)v187;
                    do
                    {
                      for (uint64_t j = 0LL; j != v59; uint64_t j = (char *)j + 1)
                      {
                        if (*(void *)v187 != v60) {
                          objc_enumerationMutation(v58);
                        }
                        sub_1005FD1A4(a1, *(void **)(*((void *)&v186 + 1) + 8LL * (void)j));
                      }

                      uint64_t v59 = [v58 countByEnumeratingWithState:&v186 objects:v212 count:16];
                    }

                    while (v59);
                  }
                }

                else
                {
                  sub_10038CF98(&v199, (unsigned __int8 *)v49, v49);
                }
              }

              v49 += 20LL;
            }

            while (v49 != v50);
          }
        }
      }

      if (*(_BYTE *)(a1 + 1843))
      {
        if (!v149 || v148[85]) {
          sub_10061540C(v30);
        }
        int v76 = sub_1006163F8(v30);
        __n128 v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
        int v78 = v77;
        if (v77 && [v77 count]) {
          [*(id *)(a1 + 4368) addObjectsFromArray:v78];
        }
      }

      uint64_t v79 = sub_100616628(v30, v164, (_DWORD *)(a1 + 4376));
      __int128 v80 = (void *)objc_claimAutoreleasedReturnValue(v79);
      v184 = 0u;
      v185 = 0u;
      v182 = 0u;
      v183 = 0u;
      int v81 = v80;
      __n128 v82 = [v81 countByEnumeratingWithState:&v182 objects:v211 count:16];
      if (v82)
      {
        uint64_t v83 = *(void *)v183;
        do
        {
          __int128 v84 = 0LL;
          do
          {
            if (*(void *)v183 != v83) {
              objc_enumerationMutation(v81);
            }
            int v85 = *(void **)(*((void *)&v182 + 1) + 8LL * (void)v84);
            __int128 v86 = (os_log_s *)qword_1008F75B8;
            if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG))
            {
              if (*(char *)(v30 + 255) < 0)
              {
                sub_100024238(__dst, *(void **)(v30 + 232), *(void *)(v30 + 240));
              }

              else
              {
                *(_OWORD *)__dst = *(_OWORD *)(v30 + 232);
                *(void *)&__dst[16] = *(void *)(v30 + 248);
              }

              int v87 = __dst;
              if ((__dst[23] & 0x80u) != 0) {
                int v87 = *(uint8_t **)__dst;
              }
              *(_DWORD *)__p = 136315394;
              *(void *)&__p[4] = v87;
              *(_WORD *)&__p[12] = 2112;
              *(void *)&__p[14] = v85;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEBUG,  "addUniqueRulesToDictionary: %s rule %@",  __p,  0x16u);
            }

            sub_1005FD6A8(a1, v85);
            __int128 v84 = (char *)v84 + 1;
          }

          while (v82 != v84);
          int v88 = [v81 countByEnumeratingWithState:&v182 objects:v211 count:16];
          __n128 v82 = v88;
        }

        while (v88);
      }

LABEL_160:
      v89 = (void *)v29[1];
      if (v89)
      {
        do
        {
          v90 = v89;
          v89 = (void *)*v89;
        }

        while (v89);
      }

      else
      {
        do
        {
          v90 = (void *)v29[2];
          id v21 = *v90 == (void)v29;
          id v29 = v90;
        }

        while (!v21);
      }

      id v29 = v90;
    }

    while (v90 != v166);
  }

  if (![*(id *)(a1 + 4352) count])
  {
    memset(__dst, 0, 22);
    v91 = sub_1002E6BF0();
    else {
      v92 = 1LL;
    }
    v93 = (os_log_s *)qword_1008F75B8;
    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__p = 0xFF04000200LL;
      *(_WORD *)&__p[8] = 1024;
      *(_DWORD *)&__p[10] = -87;
      _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_DEFAULT,  "Adding bogus rule for type %d and RSSI %d",  __p,  0xEu);
    }

    v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    v95 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", __dst, 22LL));
    [v94 setObject:v95 forKeyedSubscript:@"data"];

    v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", __dst, 22LL));
    [v94 setObject:v96 forKeyedSubscript:@"mask"];

    v97 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](&OBJC_CLASS___NSNumber, "numberWithChar:", 169LL));
    [v94 setObject:v97 forKeyedSubscript:@"rssi"];

    v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 255LL));
    [v94 setObject:v98 forKeyedSubscript:@"puckType"];

    v99 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 2LL));
    [v94 setObject:v99 forKeyedSubscript:@"matchAllDevices"];

    v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", 0LL));
    [v94 setObject:v100 forKeyedSubscript:@"address"];

    v101 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 0LL));
    [v94 setObject:v101 forKeyedSubscript:@"bypassFilterDuplicate"];

    v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v92));
    [v94 setObject:v102 forKeyedSubscript:@"targetCore"];

    v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 1LL));
    [v94 setObject:v103 forKeyedSubscript:@"rssithresholdOrder"];

    v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
    [v94 setObject:v104 forKeyedSubscript:@"report127dBm"];

    v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
    [v94 setObject:v105 forKeyedSubscript:@"report27dBm"];

    sub_1005FD6A8(a1, v94);
    *(_BYTE *)(a1 + 1850) = 1;
  }

  if (!v149 || v148[85])
  {
    v176 = 0u;
    v177 = 0u;
    v174 = 0u;
    v175 = 0u;
    id obj = *(id *)(a1 + 4352);
    v106 = [obj countByEnumeratingWithState:&v174 objects:v207 count:16];
    if (v106)
    {
      v151 = *(void *)v175;
LABEL_177:
      v168 = 0LL;
      v152 = v106;
      while (1)
      {
        if (*(void *)v175 != v151) {
          objc_enumerationMutation(obj);
        }
        v107 = *(void **)(*((void *)&v174 + 1) + 8 * v168);
        *(void *)&__dst[8] = 0LL;
        *(void *)__dst = 0LL;
        v108 = objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"data"]);
        v109 = [v108 bytes];
        v110 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"data"]);
        sub_10056AB04(__dst, v109, (size_t)[v110 length]);

        *(void *)&__p[8] = 0LL;
        *(void *)__p = 0LL;
        v111 = objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"mask"]);
        v112 = [v111 bytes];
        v113 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"mask"]);
        sub_10056AB04(__p, v112, (size_t)[v113 length]);

        v114 = sub_1002E6E9C();
        v167 = sub_10056AAF0((uint64_t)__dst);
        v165 = sub_10056AAD8((uint64_t)__dst);
        v162 = sub_10056AAF0((uint64_t)__p);
        v161 = sub_10056AAD8((uint64_t)__p);
        v158 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"rssi"]);
        v160 = [v158 intValue];
        v157 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"puckType"]);
        v159 = [v157 unsignedIntValue];
        v156 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"matchAllDevices"]);
        v115 = [v156 unsignedIntValue];
        v155 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"address"]);
        v116 = [v155 unsignedLongLongValue];
        v154 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"bypassFilterDuplicate"]);
        v117 = [v154 unsignedIntValue];
        v153 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"targetCore"]);
        v118 = [v153 unsignedIntValue];
        v119 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"rssithresholdOrder"]);
        v120 = [v119 unsignedIntValue];
        v121 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"report127dBm"]);
        v122 = [v121 unsignedIntValue];
        v123 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"report27dBm"]);
        BYTE4(v147) = [v123 unsignedIntValue];
        BYTE3(v147) = v122;
        BYTE2(v147) = v120;
        BYTE1(v147) = v118;
        LOBYTE(v147) = v117;
        v124 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, void, void, void, id, uint64_t))(*(void *)v114 + 672LL))( v114,  v167,  v165,  v162,  v161,  v160,  v159,  v115,  v116,  v147);

        if (v124)
        {
          v125 = (os_log_s *)qword_1008F75B8;
          if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v124;
            _os_log_error_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_ERROR,  "Failed to add rule with result %d",  buf,  8u);
          }
        }

        *(void *)__p = &off_10087FAA8;
        if (*(void *)&__p[8]) {
          sub_1002CD254(*(unsigned int **)&__p[8]);
        }
        *(void *)__dst = &off_10087FAA8;
        if (*(void *)&__dst[8]) {
          sub_1002CD254(*(unsigned int **)&__dst[8]);
        }
        if (v124) {
          break;
        }
        if (v152 == (id)++v168)
        {
          v106 = [obj countByEnumeratingWithState:&v174 objects:v207 count:16];
          if (v106) {
            goto LABEL_177;
          }
          break;
        }
      }
    }

    if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_DEBUG)) {
      sub_10069DAD0();
    }
    v126 = sub_1002E6E9C();
    (*(void (**)(uint64_t, void))(*(void *)v126 + 744LL))(v126, *(unsigned int *)(a1 + 4376));
    if (*(_BYTE *)(a1 + 1849) && (!v149 || v148[85]))
    {
      v127 = sub_1002E6E9C();
      (*(void (**)(uint64_t, uint64_t))(*(void *)v127 + 624LL))(v127, 1LL);
    }
  }

  if (!v201 && ![*(id *)(a1 + 4360) count])
  {
    sub_1006343C4((uint64_t)__dst, &xmmword_1006C472F, 16LL);
    sub_10038CF98(&v199, __dst, (uint64_t)__dst);
  }

  if (!v149 || v148[85])
  {
    v128 = sub_1002E6E9C();
    (*(void (**)(uint64_t, uint64_t))(*(void *)v128 + 392LL))(v128, 1LL);
    v129 = v199;
    if (v199 != (uint64_t *)&v200)
    {
      while (1)
      {
        v130 = sub_1002E6E9C();
        v205 = *(_OWORD *)((char *)v129 + 28);
        v206 = *((_DWORD *)v129 + 11);
        if ((*(unsigned int (**)(uint64_t, __int128 *, void, uint64_t, uint64_t, uint64_t))(*(void *)v130 + 408LL))( v130,  &v205,  0LL,  169LL,  1LL,  1LL))
        {
          break;
        }

        v131 = (uint64_t *)v129[1];
        if (v131)
        {
          do
          {
            v132 = v131;
            v131 = (uint64_t *)*v131;
          }

          while (v131);
        }

        else
        {
          do
          {
            v132 = (uint64_t *)v129[2];
            id v21 = *v132 == (void)v129;
            v129 = v132;
          }

          while (!v21);
        }

        v129 = v132;
      }

      if (os_log_type_enabled((os_log_t)qword_1008F75B8, OS_LOG_TYPE_ERROR))
      {
        sub_1006344B4((uint64_t)v129 + 28, __dst);
        sub_10069DA84();
      }
    }

    return;
  }

  if (([*(id *)(a1 + 88) isEqualToString:@"XZ"] & 1) == 0)
  {
    unsigned __int8 v12 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Does not support location based power tables -- setting country code to default",  buf,  2u);
    }

    sub_1006362A8(a1, @"XZ");
  }
  }

  else
  {
    uint64_t v17 = 0;
  }

  if ((v54 | v17) == 1)
  {
    id v21 = (os_log_s *)qword_1008F7578;
    if (os_log_type_enabled((os_log_t)qword_1008F7578, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412802;
      int v69 = v57;
      BOOL v70 = 1024;
      *(_DWORD *)int v71 = v54;
      *(_WORD *)&v71[4] = 1024;
      *(_DWORD *)&v71[6] = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Overriding bundle %@ state to foregroundRunning isExtension:%d isAssertionReasonWatchConnectivity:%d",  buf,  0x18u);
    }

    HIDWORD(v52) = 16;
  }

  if (v55 != 1)
  {
    if ([v56 pid])
    {
      uint64_t v32 = (os_log_s *)qword_1008F7680;
      if (!os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_92;
      }
      uint64_t v33 = [v57 UTF8String];
      __int16 v34 = [v56 pid];
      if (SHIDWORD(v52) <= 7)
      {
        if (HIDWORD(v52) == 2)
        {
          char v35 = "terminated";
          goto LABEL_81;
        }

        if (HIDWORD(v52) == 4)
        {
          char v35 = "suspended";
          goto LABEL_81;
        }
      }

      else
      {
        switch(HIDWORD(v52))
        {
          case 8:
            char v35 = "background-running";
            goto LABEL_81;
          case 0x10:
            char v35 = "foreground-running";
            goto LABEL_81;
          case 0x20:
            char v35 = "daemon";
LABEL_81:
            unint64_t v44 = objc_msgSend(v56, "isAlive", v52);
            uint64_t v45 = "false";
            *(_DWORD *)buf = 136446978;
            int v69 = v33;
            BOOL v70 = 1024;
            if (v44) {
              uint64_t v45 = "true";
            }
            *(_DWORD *)int v71 = v34;
            *(_WORD *)&v71[4] = 2082;
            *(void *)&v71[6] = v35;
            int v72 = 2080;
            __int128 v73 = v45;
            _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "Application %{public}s is still at pid %d, with state %{public}s, isAlive: %s",  buf,  0x26u);
LABEL_92:
            uint64_t v48 = (os_log_s *)qword_1008F7680;
            if (!os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_106;
            }
            id v49 = [v57 UTF8String];
            if (SHIDWORD(v52) <= 7)
            {
              if (HIDWORD(v52) == 2)
              {
                uint64_t v50 = "terminated";
                goto LABEL_105;
              }

              if (HIDWORD(v52) == 4)
              {
                uint64_t v50 = "suspended";
                goto LABEL_105;
              }
            }

            else
            {
              switch(HIDWORD(v52))
              {
                case 8:
                  uint64_t v50 = "background-running";
                  goto LABEL_105;
                case 0x10:
                  uint64_t v50 = "foreground-running";
                  goto LABEL_105;
                case 0x20:
                  uint64_t v50 = "daemon";
LABEL_105:
                  *(_DWORD *)buf = 136446466;
                  int v69 = v49;
                  BOOL v70 = 2082;
                  *(void *)int v71 = v50;
                  _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "State of application %{public}s is now %{public}s",  buf,  0x16u);
LABEL_106:
                  objc_msgSend(v56, "setState:", HIDWORD(v52), v52);
                  uint64_t v51 = *(void *)(a1 + 40);
                  if (*(void *)(v51 + 8))
                  {
                    v58[0] = _NSConcreteStackBlock;
                    v58[1] = 3221225472LL;
                    v58[2] = sub_10063B11C;
                    v58[3] = &unk_100880E40;
                    v58[4] = v51;
                    uint64_t v59 = v57;
                    uint64_t v60 = v53;
                    dispatch_async(&_dispatch_main_q, v58);
                  }

                  goto LABEL_108;
              }
            }

            uint64_t v50 = "unknown";
            goto LABEL_105;
        }
      }

      char v35 = "unknown";
      goto LABEL_81;
    }

    [v56 setPid:v52];
    unint64_t v39 = (os_log_s *)qword_1008F7680;
    if (!os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT))
    {
LABEL_91:
      objc_msgSend(*(id *)(a1 + 40), "takeAssertionForProcess:duration:isUrgent:", v57, 10, 0, v52);
      goto LABEL_92;
    }

    unint64_t v40 = [v57 UTF8String];
    id v41 = [v56 pid];
    if (SHIDWORD(v52) <= 7)
    {
      if (HIDWORD(v52) == 2)
      {
        __int128 v42 = "terminated";
        goto LABEL_88;
      }

      if (HIDWORD(v52) == 4)
      {
        __int128 v42 = "suspended";
        goto LABEL_88;
      }
    }

    else
    {
      switch(HIDWORD(v52))
      {
        case 8:
          __int128 v42 = "background-running";
          goto LABEL_88;
        case 0x10:
          __int128 v42 = "foreground-running";
          goto LABEL_88;
        case 0x20:
          __int128 v42 = "daemon";
LABEL_88:
          int v46 = objc_msgSend(v56, "isAlive", v52);
          int v47 = "false";
          *(_DWORD *)buf = 136446978;
          int v69 = v40;
          BOOL v70 = 1024;
          if (v46) {
            int v47 = "true";
          }
          *(_DWORD *)int v71 = v41;
          *(_WORD *)&v71[4] = 2082;
          *(void *)&v71[6] = v42;
          int v72 = 2080;
          __int128 v73 = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Application %{public}s is now at pid %d, with state %{public}s, isAlive: %s",  buf,  0x26u);
          goto LABEL_91;
      }
    }

    __int128 v42 = "unknown";
    goto LABEL_88;
  }

  id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:BKSApplicationStateExitReasonKey]);
  unsigned __int8 v23 = [v22 unsignedIntValue];

  id v24 = (os_log_s *)qword_1008F7680;
  if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT))
  {
    id v25 = [v57 UTF8String];
    uint64_t v26 = "terminated";
    if (v23 == 1) {
      uint64_t v26 = "killed by the user";
    }
    *(_DWORD *)buf = 136446466;
    int v69 = v25;
    BOOL v70 = 2082;
    *(void *)int v71 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Application %{public}s has been %{public}s",  buf,  0x16u);
  }

  objc_msgSend(v56, "setPid:", 0, v52);
  uint64_t v27 = *(void *)(a1 + 40);
  if (*(void *)(v27 + 8))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10063B098;
    block[3] = &unk_100880E40;
    void block[4] = v27;
    id v62 = v57;
    int v63 = v23 == 1;
    dispatch_async(&_dispatch_main_q, block);
  }

  if (v23 == 1)
  {
    uint64_t v28 = qword_1008F7680;
    if (os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      int v69 = v57;
      id v29 = "bundleID %{public}@ in launch queue but won't resurrect. Reason: killed by user.";
      id v30 = (os_log_s *)v28;
      id v31 = 12;
LABEL_76:
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
    }
  }

  else
  {
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 40) + 112) objectForKey:v57]);
    __int128 v37 = (os_log_s *)qword_1008F7680;
    int v38 = os_log_type_enabled((os_log_t)qword_1008F7680, OS_LOG_TYPE_DEFAULT);
    if (v36)
    {
      if (v38)
      {
        *(_DWORD *)buf = 138543362;
        int v69 = v57;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Found bundleID in launch queue, attempting to resurrect - %{public}@",  buf,  0xCu);
      }

      [*(id *)(a1 + 40) openBundle:v57 options:v36 attempt:0];
      [*(id *)(*(void *)(a1 + 40) + 112) removeObjectForKey:v57];
    }

    else if (v38)
    {
      *(_DWORD *)buf = 138543362;
      int v69 = v57;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "BundleID not in launch queue - not resurrecting: %{public}@",  buf,  0xCu);
    }
  }